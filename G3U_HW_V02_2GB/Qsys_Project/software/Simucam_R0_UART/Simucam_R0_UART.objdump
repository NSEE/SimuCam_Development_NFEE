
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x0005224c memsz 0x0006c4ac flags rwx
    LOAD off    0x00054000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  00054000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004a470  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00005dac  8114a6cc  8114a6cc  0004b6cc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  81150478  81150478  00051478  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0001a260  8115226c  8115226c  0005326c  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  8116c4cc  8116c4cc  00054000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  00054000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00054000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001d58  00000000  00000000  00054028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   00070608  00000000  00000000  00055d80  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0001680d  00000000  00000000  000c6388  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00022989  00000000  00000000  000dcb95  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000099b0  00000000  00000000  000ff520  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000ca87  00000000  00000000  00108ed0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026ecc  00000000  00000000  00115957  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  0013c824  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00002390  00000000  00000000  0013c868  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  0014b01d  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  0014b023  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  0014b02f  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  0014b030  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  0014b031  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  0014b035  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  0014b039  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  0014b03d  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  0014b048  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  0014b052  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  0014b05c  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003f  00000000  00000000  0014b06d  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     00226f57  00000000  00000000  0014b0ac  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
8114a6cc l    d  .rodata	00000000 .rodata
81150478 l    d  .rwdata	00000000 .rwdata
8115226c l    d  .bss	00000000 .bss
8116c4cc l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm_channel.c
811047c8 l     F .text	00000050 uliCommReadReg
81104774 l     F .text	00000054 vCommWriteReg
00000000 l    df *ABS*	00000000 data_packet.c
81105008 l     F .text	00000050 uliDpktReadReg
81104fb4 l     F .text	00000054 vDpktWriteReg
00000000 l    df *ABS*	00000000 fee_buffers.c
81152290 l     O .bss	00000004 viCh1HoldContext
81152294 l     O .bss	00000004 viCh2HoldContext
81152298 l     O .bss	00000004 viCh3HoldContext
8115229c l     O .bss	00000004 viCh4HoldContext
811522a0 l     O .bss	00000004 viCh5HoldContext
811522a4 l     O .bss	00000004 viCh6HoldContext
811522a8 l     O .bss	00000004 viCh7HoldContext
811522ac l     O .bss	00000004 viCh8HoldContext
81106c90 l     F .text	00000054 vFeebWriteReg
81106ce4 l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
811522b0 l     O .bss	00000004 viCh1HoldContext
811522b4 l     O .bss	00000004 viCh2HoldContext
811522b8 l     O .bss	00000004 viCh3HoldContext
811522bc l     O .bss	00000004 viCh4HoldContext
811522c0 l     O .bss	00000004 viCh5HoldContext
811522c4 l     O .bss	00000004 viCh6HoldContext
811522c8 l     O .bss	00000004 viCh7HoldContext
811522cc l     O .bss	00000004 viCh8HoldContext
81109e80 l     F .text	00000054 vRmapWriteReg
81109f24 l     F .text	00000268 uliConvRmapCfgAddr
00000000 l    df *ABS*	00000000 spw_controller.c
8110a858 l     F .text	00000050 uliSpwcReadReg
8110a804 l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
81152194 l     O .rwdata	00000001 ucIoValue
8110aa58 l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
8110b348 l     F .text	0000013c msgdma_write_extended_descriptor
8110b484 l     F .text	00000164 msgdma_construct_extended_descriptor
8110b5e8 l     F .text	00000318 msgdma_descriptor_async_transfer
8110b900 l     F .text	000003fc msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8110c47c l     F .text	00000054 vRstcWriteReg
8110c4d0 l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
811522d4 l     O .bss	00000004 viHoldContext
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
811522dc l     O .bss	00000004 pxNFee.5668
811522e0 l     O .bss	00000004 incrementador.5673
811522e4 l     O .bss	00000004 tCodFeeTask.5671
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
811522e8 l     O .bss	00000004 xRAckLocal.5601
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
811522ec l     O .bss	00000004 bDmaBack.5642
811522f0 l     O .bss	00000001 ucWhoGetDMA.5643
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
811522f2 l     O .bss	00000004 xSAckLocal.5586
00000000 l    df *ABS*	00000000 parser_comm_task.c
8115246c l     O .bss	0000004c PreParsedLocal.5639
811524b8 l     O .bss	00000054 xTcPusL.5638
00000000 l    df *ABS*	00000000 receiver_uart_task.c
8115250c l     O .bss	0000004c xPreParsedReader.5631
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
81152558 l     O .bss	00000054 xPusLocal.5874
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
8114ddc3 l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 sync_handler.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 ctype_.c
8114f8b9 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
81150478 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
81121e18 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vfprintf.c
8114fa86 l     O .rodata	00000010 zeroes.4389
8114fa96 l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
8114faa6 l     O .rodata	00000010 zeroes.4404
81126a90 l     F .text	000000c4 __sbprintf
8114fab6 l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
8114face l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
81128778 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
8112a2c8 l     F .text	00000008 __fp_unlock
8112a2dc l     F .text	000001a4 __sinit.part.1
8112a480 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
81150cc4 l     O .rwdata	00000020 lc_ctype_charset
81150ca4 l     O .rwdata	00000020 lc_message_charset
81150ce4 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
8114fb0c l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
8112d2f0 l     F .text	0000006c sulp
8114fc54 l     O .rodata	00000014 fpi.2737
8114fc68 l     O .rodata	00000028 tinytens
8114fc40 l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
8114fca0 l     O .rodata	00000010 blanks.4332
8114fc90 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
81130960 l     F .text	00000104 __sprint_r.part.0
8114fcc0 l     O .rodata	00000010 blanks.4348
8114fcb0 l     O .rodata	00000010 zeroes.4349
81131efc l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
811323b0 l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
8113558c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
811356d0 l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
81135704 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
81135988 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
81135a80 l       .text	00000000 tx_next_char
81135aa8 l       .text	00000000 end_tx
81135a88 l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
81136584 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
81136800 l     F .text	00000044 alt_get_errno
81136844 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
81136a6c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
811521dc l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
8113700c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
811521e8 l     O .rwdata	00000004 lockid
811523b4 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
811521ec l     O .rwdata	00000004 lockid
811523bc l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
81138a98 l     F .text	00000050 OS_InitMisc
81138ae8 l     F .text	00000074 OS_InitRdyList
81138c6c l     F .text	000000ec OS_InitTCBList
811389b0 l     F .text	000000e8 OS_InitEventList
81138b5c l     F .text	00000088 OS_InitTaskIdle
81138be4 l     F .text	00000088 OS_InitTaskStat
81138efc l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
8113ad14 l     F .text	000000fc OS_FlagTaskRdy
8113aac4 l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
8113c600 l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
81141030 l     F .text	00000044 OSTmr_Lock
81140ad0 l     F .text	00000074 OSTmr_Alloc
81141074 l     F .text	0000003c OSTmr_Unlock
81140f34 l     F .text	000000fc OSTmr_Unlink
81140b44 l     F .text	000000a4 OSTmr_Free
81140de4 l     F .text	00000150 OSTmr_Link
81140d5c l     F .text	00000088 OSTmr_InitTask
811410b0 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
811411c0 l     F .text	0000003c alt_dev_reg
81150f60 l     O .rwdata	0000106c jtag_uart_0
81151fcc l     O .rwdata	000000d0 rs232_uart
8115209c l     O .rwdata	00000064 dma_DDR_M1
81152100 l     O .rwdata	00000064 dma_DDR_M2
81152164 l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
81145a50 l     F .text	000002bc altera_avalon_jtag_uart_irq
81145d0c l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
81146510 l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
811468a8 l     F .text	000000a4 altera_avalon_uart_irq
8114694c l     F .text	00000140 altera_avalon_uart_rxirq
81146a8c l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
81146c94 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
81146f48 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
811471cc l     F .text	00000044 alt_get_errno
81147210 l     F .text	0000009c alt_msgdma_write_standard_descriptor
811472ac l     F .text	00000134 alt_msgdma_write_extended_descriptor
811473e0 l     F .text	0000018c alt_msgdma_irq
8114756c l     F .text	00000094 alt_msgdma_construct_standard_descriptor
81147600 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
8114775c l     F .text	00000340 alt_msgdma_descriptor_async_transfer
81147a9c l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
811481a4 l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
81148250 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
8114941c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
81149a60 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
81152464 l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
81152468 g     O .bss	00000004 alt_instruction_exception_handler
81107150 g     F .text	00000044 vRmapCh7IrqFlagClrWriteCmd
81152cec g     O .bss	00001000 vFeeTask0_stk
8111b0e4 g     F .text	0000004c vFailDeleteInitialization
81119b88 g     F .text	00000d44 vLoadDebugConfs
81152438 g     O .bss	00000004 aux_status_register
81153cec g     O .bss	00001000 vInAckHandlerTask_stk
811491d8 g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
81107498 g     F .text	00000050 uliRmapCh1WriteCmdAddress
8110cb1c g     F .text	0000004c vSyncInitIrq
81116428 g     F .text	00000284 vCheckRetransmission128
8112c974 g     F .text	0000007c _mprec_log10
8110cd24 g     F .text	00000040 bSyncSetMbt
8111c6a8 g     F .text	00000054 vFailRequestDMAFromIRQ
8110ac3c g     F .text	00000108 I2C_Read
8115223a g     O .rwdata	00000002 OSTaskNameSize
811522fc g     O .bss	00000004 xWaitSyncQFee
81154cec g     O .bss	00000260 xBuffer64
8112ca68 g     F .text	0000008c __any_on
8112b43c g     F .text	0000005c _isatty_r
8114fb18 g     O .rodata	00000028 __mprec_tinytens
81107440 g     F .text	00000058 bRmapCh8IrqFlagWriteCmd
811366a4 g     F .text	0000015c alt_main
8110654c g     F .text	00000078 bFeebGetRightBufferEmpty
81121d3c g     F .text	000000c8 _puts_r
81105794 g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
811523c4 g     O .bss	00000004 OSTmrFreeList
8116c3cc g     O .bss	00000100 alt_irq
8112b5ac g     F .text	00000068 _lseek_r
8111d938 g     F .text	00000030 vChangeDefaultAutoResetSync
8113b574 g     F .text	000000d4 OS_MemInit
8111c654 g     F .text	00000054 vFailRequestDMA
811065c4 g     F .text	00000068 bFeebGetCh1LeftBufferEmpty
81118e80 g     F .text	000009d8 vLoadDefaultETHConf
81111860 g     F .text	0000014c bCheckInAck64
81154f4c g     O .bss	00000150 xPus
81140010 g     F .text	00000068 OSTimeSet
811150d4 g     F .text	0000008c vPusType250run
8112a680 g     F .text	000000ac __sflags
8111c028 g     F .text	00000068 vCoudlNotCreateNFee2Task
8111c414 g     F .text	0000004c vCouldNotGetMutexMebPus
81135230 g     F .text	00000088 .hidden __eqdf2
811157a0 g     F .text	00000088 vSendCmdQToDataCTRL
81102a8c g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
8111d824 g     F .text	00000034 vLoadDefaultSyncSource
8111ab7c g     F .text	0000004c vFailCreateMutexDMA
811416c0 g     F .text	000001ac Check_for_Master_Boot_Record
81165de0 g     O .bss	00000010 OSTmrWheelTbl
81107538 g     F .text	00000050 uliRmapCh3WriteCmdAddress
81147f64 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
8115509c g     O .bss	00000020 xFeeQueueTBL3
811376fc g     F .text	00000594 OSEventPendMulti
81152300 g     O .bss	00000004 xNfeeSchedule
8116c4cc g       *ABS*	00000000 __alt_heap_start
8114a098 g     F .text	0000002c OSTaskCreateHook
81145538 g     F .text	000001c4 alt_up_sd_card_fclose
81152304 g     O .bss	00000004 xSemCountBuffer64
8110452c g     F .text	0000016c bCommSetGlobalIrqEn
8110793c g     F .text	00000088 bRmapGetIrqControl
81121b80 g     F .text	00000044 printf
811522d1 g     O .bss	00000001 SspdConfigControl
8110d140 g     F .text	00000054 bSyncCtrReset
81152212 g     O .rwdata	00000002 OSMboxEn
8110ff38 g     F .text	00000260 vQCmdFeeRMAPWaitingSync
8111e4ac g     F .text	000000a4 aatoh
81137cf4 g     F .text	00000054 OSIntEnter
8113301c g     F .text	000000a4 _wcrtomb_r
811056a0 g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
8111b04c g     F .text	0000004c vFailReceiverCreate
81152308 g     O .bss	00000004 xQMaskDataCtrl
811051b0 g     F .text	00000084 vFeebCh2HandleIrq
811222a4 g     F .text	00000064 __sseek
8112a630 g     F .text	00000010 __sinit
8110bdbc g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
811283f8 g     F .text	00000148 __swbuf_r
81116c00 g     F .text	00000470 bResourcesInitRTOS
8110a3a4 g     F .text	000000f4 bSpwcGetLinkError
81152222 g     O .rwdata	00000002 OSQEn
8110f828 g     F .text	000004a8 vQCmdFeeRMAPinStandBy
81106e78 g     F .text	00000040 vRmapCh4HandleIrq
8112b4c8 g     F .text	00000084 _setlocale_r
811550bc g     O .bss	00000020 SyncTBL2
81152198 g     O .rwdata	00000004 LedsPainelControl
811525d4 g     O .bss	00000100 cDebugBuffer
8112a488 g     F .text	00000070 __sfmoreglue
81130948 g     F .text	00000018 ungetc
811059a4 g     F .text	000000d4 bFeebCh1SetBufferSize
811373b8 g     F .text	000000d4 __malloc_unlock
81102d88 g     F .text	00000214 DMA_MULTIPLE_TRANSFER
8114a118 g     F .text	00000028 OSTaskStatHook
811155fc g     F .text	00000088 vSendCmdQToNFeeCTRL
8111d894 g     F .text	00000030 vChangeDefaultSyncSource
811523c8 g     O .bss	00000001 OSLockNesting
811523cc g     O .bss	00000004 OSTmrSemSignal
8111cad4 g     F .text	000001e0 vNFeeStructureInit
8115230c g     O .bss	00000004 xSemCommInit
81102910 g     F .text	00000080 uliXorshift32
8112d35c g     F .text	00001600 _strtod_r
81152310 g     O .bss	00000004 xSemCountSenderACK
8111e664 g     F .text	00000448 .hidden __divsf3
8115245c g     O .bss	00000004 current_sector_modified
81152260 g     O .rwdata	00000002 OSDataSize
811523d0 g     O .bss	00000001 OSRunning
8110a680 g     F .text	00000184 bSpwcInitCh
8113636c g     F .text	00000064 alt_log_jtag_uart_isr_proc
811550dc g     O .bss	00001000 senderTask_stk
81108430 g     F .text	00000094 bRmapGetMemConfigStat
81152314 g     O .bss	00000004 fp
811560dc g     O .bss	00000048 xNfeeScheduleTBL
81111718 g     F .text	00000148 bCheckInAck128
8112b93c g     F .text	0000015c memmove
8114a194 g     F .text	0000002c OSInitHookBegin
8110d5dc g     F .text	00000074 bSyncCtrCh8OutEnable
81110304 g     F .text	00000088 bEnableDbBuffer
81152258 g     O .rwdata	00000002 OSTmrSize
8112a618 g     F .text	00000018 _cleanup
8111dd60 g     F .text	00000040 siCloseFile
81106b0c g     F .text	00000184 bFeebInitCh
8112ba98 g     F .text	000000b0 _Balloc
8111d8c4 g     F .text	00000038 vLoadDefaultAutoResetSync
81107a4c g     F .text	000000d8 bRmapSetCodecConfig
81144114 g     F .text	000000cc alt_up_sd_card_is_Present
81147ea4 g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
81152274 g     O .bss	00000004 pxDmaM1Dev
81102b24 g     F .text	000000a8 DMA_DISPATCHER_STOP
811413e8 g     F .text	00000054 Save_Modified_Sector
811058f4 g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
811523d4 g     O .bss	00000004 OSIdleCtr
81152390 g     O .bss	00000001 alt_log_write_on_flag
8110a8a8 g     F .text	0000003c bEnableIsoDrivers
8111f0d4 g     F .text	000000dc .hidden __gtdf2
81149e28 g     F .text	0000002c altera_nios2_gen2_irq_init
81149f10 g       .text	00000000 OSStartTsk
8110ce98 g     F .text	00000070 bSyncSetNCycles
8113926c g     F .text	000002dc OS_TCBInit
81152393 g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
8111d4ac g     F .text	00000078 vInitSimucamBasicHW
81156124 g     O .bss	00001000 vTimeoutCheckerTask_stk
8110d4f4 g     F .text	00000074 bSyncCtrCh6OutEnable
8110afb8 g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
81152454 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
811523d8 g     O .bss	00000002 OSTmrUsed
81152318 g     O .bss	00000004 xSemCountBuffer128
81103264 g     F .text	000000f8 TEMP_Read
81107894 g     F .text	000000a8 bRmapSetIrqControl
81105cf4 g     F .text	000000d4 bFeebCh5SetBufferSize
81157124 g     O .bss	00001000 vDataControlTask_stk
811052b8 g     F .text	00000084 vFeebCh4HandleIrq
8115225e g     O .rwdata	00000002 OSTmrWheelTblSize
8111d154 g     F .text	0000002c cFeeSpwChannelDisable
811521fe g     O .rwdata	00000002 OSEventSize
811523da g     O .bss	00000001 OSPrioHighRdy
81120d1c g     F .text	00000064 _fstat_r
8114a0c4 g     F .text	0000002c OSTaskDelHook
8115236c g     O .bss	00000004 errno
8110d8d0 g     F .text	0000003c uliSyncGetCtr
81128388 g     F .text	0000001c __svfscanf
81122218 g     F .text	00000008 __seofread
81149ef0 g       .text	00000000 OSStartHighRdy
8111ca34 g     F .text	00000028 vEvtChangeFeeControllerMode
81110538 g     F .text	00000968 vPrintConsoleNFee
81112690 g     F .text	000000c8 bSendCmdQToNFeeInst
81106f38 g     F .text	00000040 vRmapCh7HandleIrq
8113ea40 g     F .text	000001ec OSTaskCreateExt
81165db4 g     O .bss	00000011 alt_log_write_buf
81104a44 g     F .text	0000012c bDpktGetPacketConfig
811076c8 g     F .text	00000050 uliRmapCh8WriteCmdAddress
8111b408 g     F .text	00000068 vFailGetCountSemaphorePreParsedBuffer
8112f48c g     F .text	00001244 ___svfiprintf_internal_r
8111422c g     F .text	00000364 bPreParserV2
8113a5f4 g     F .text	00000068 OSFlagPendGetFlagsRdy
8115223e g     O .rwdata	00000002 OSTaskStatStkSize
811066fc g     F .text	00000068 bFeebGetCh2RightBufferEmpty
81139740 g     F .text	00000310 OSFlagAccept
8113cd1c g     F .text	000000c0 OSQFlush
81152ad4 g     O .bss	00000118 xRmap
8113c798 g     F .text	00000148 OSQAccept
811523a4 g     O .bss	00000004 alt_argv
8115a190 g       *ABS*	00000000 _gp
8111ad14 g     F .text	0000004c vFailSendPreAckReceiverSemaphore
81136ed0 g     F .text	0000013c usleep
811446ec g     F .text	00000384 alt_up_sd_card_fopen
8111dbcc g     F .text	00000030 bSDcardIsPresent
81114590 g     F .text	00000178 vSenderComTask
81144254 g     F .text	000000d8 alt_up_sd_card_find_first
8113e88c g     F .text	000001b4 OSTaskCreate
8111b5a8 g     F .text	00000068 vFailSendNack
81152448 g     O .bss	00000004 command_argument_register
8113e394 g     F .text	000004f8 OSTaskChangePrio
81114c98 g     F .text	000000ac vPusMebInTaskConfigMode
8111bd20 g     F .text	00000088 vCouldNotSendTMPusCommand
811523c0 g     O .bss	00000004 alt_heapsem
8111cff4 g     F .text	000000b0 vResetMemCCDFEE
8110b250 g     F .text	00000080 bSetBoardLeds
81139548 g     F .text	000001f8 OSDebugInit
8113ec2c g     F .text	0000034c OSTaskDel
8113b648 g     F .text	000001ac OSMutexAccept
81158124 g     O .bss	000002b8 xSimMeb
8111d390 g     F .text	00000040 vSetTimeCode
81148a4c g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
8115231c g     O .bss	00000004 xSemCountPreParsed
81150d44 g     O .rwdata	00000180 alt_fd_list
81105844 g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
81150ee0 g     O .rwdata	0000001d alt_log_msg_alt_main
81165df0 g     O .bss	00000840 OSFlagTbl
811071d8 g     F .text	00000058 bRmapCh1IrqFlagWriteCmd
8111ae7c g     F .text	00000068 vFailGetCountSemaphoreReceiverTask
811075d8 g     F .text	00000050 uliRmapCh5WriteCmdAddress
8111d77c g     F .text	0000003c vLoadDefaultRTValue
81138778 g     F .text	000000c0 OS_EventTaskRemove
811583dc g     O .bss	00001000 vFeeTask5_stk
81152392 g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
81143968 g     F .text	00000134 find_first_empty_record_in_root_directory
8114950c g     F .text	00000098 alt_find_dev
81121868 g     F .text	00000150 memcpy
81132ce8 g     F .text	00000264 __hexnan
81104e40 g     F .text	00000174 bDpktInitCh
811593dc g     O .bss	00000160 xBuffer32
81152228 g     O .rwdata	00000002 OSRdyTblSize
81166630 g     O .bss	000001a0 OSTmrTbl
8112a2d0 g     F .text	0000000c _cleanup_r
81120254 g     F .text	000000e4 .hidden __floatsidf
81118aa8 g     F .text	000001a8 vSendPusTM64
8110cc94 g     F .text	0000004c ucSyncStatusErrorCode
8111570c g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
8111d250 g     F .text	00000034 cFeeRMAPLogDisable
81112b18 g     F .text	00000df0 vParserCommTask
81149b2c g     F .text	00000084 alt_io_redirect
8111d1e4 g     F .text	00000034 cFeeRMAPEchoingDisable
811352b8 g     F .text	000000f4 .hidden __ltdf2
8111c360 g     F .text	0000004c vFailSendPUStoMebTask
811073e8 g     F .text	00000058 bRmapCh7IrqFlagWriteCmd
811061c0 g     F .text	000000d4 bFeebSetIrqControl
8111bb18 g     F .text	00000068 vCouldNotRetransmitB128TimeoutTask
81152320 g     O .bss	00000004 xMutexReceivedACK
81103be0 g     F .text	000000b0 bSdmaInitM2Dma
8115228c g     O .bss	00000004 EDpktMode
81148ed4 g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
8114921c g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
8110d1e8 g     F .text	00000054 bSyncCtrErrInj
8114917c g     F .text	0000005c alt_msgdma_register_callback
81119858 g     F .text	00000330 vShowEthConfig
8111d524 g     F .text	00000030 bLogWriteSDCard
8111b198 g     F .text	00000068 vFailSetCountSemaphorexBuffer64
81121e04 g     F .text	00000014 puts
8111dde0 g     F .text	00000284 bInitSync
8114a23c g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8110c9c8 g     F .text	00000128 vSyncHandleIrq
8113748c g     F .text	00000128 OSEventNameGet
81105508 g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
8115220c g     O .rwdata	00000002 OSFlagMax
8112b6c8 g     F .text	000000e0 mbrtowc
81143560 g     F .text	000001b4 find_first_empty_cluster
81115828 g     F .text	00000088 vSendCmdQToDataCTRL_PRIO
8110d480 g     F .text	00000074 bSyncCtrCh5OutEnable
811522d8 g     O .bss	00000001 vucN
8112d0c8 g     F .text	00000074 __fpclassifyd
8110cbf4 g     F .text	00000054 bSyncStatusExtnIrq
811283a4 g     F .text	00000054 _vfscanf_r
8113bcc8 g     F .text	000005a4 OSMutexPend
8112c8c8 g     F .text	000000ac __ratio
81144050 g     F .text	000000c4 alt_up_sd_card_open_dev
8111bda8 g     F .text	00000068 vWarnCouldNotgetMutexRetrans128
81137d48 g     F .text	00000100 OSIntExit
8110cd64 g     F .text	00000040 bSyncSetBt
81131ee0 g     F .text	0000001c __vfiprintf_internal
8111c460 g     F .text	00000068 vCouldNotCreateQueueMaskNfeeCtrl
81152246 g     O .rwdata	00000002 OSTCBSize
811054c4 g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
811523db g     O .bss	00000001 OSPrioCur
81145f80 g     F .text	000002c4 altera_avalon_jtag_uart_read
81148714 g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
81121b48 g     F .text	00000038 _printf_r
81133dd4 g     F .text	00000064 .hidden __udivsi3
811359cc g     F .text	000000ac isatty
811522d0 g     O .bss	00000001 LedsBoardControl
81152324 g     O .bss	00000004 xSemCountReceivedACK
8115222c g     O .rwdata	00000002 OSStkWidth
8112b498 g     F .text	00000030 iswspace
8114fb68 g     O .rodata	000000c8 __mprec_tens
81152220 g     O .rwdata	00000002 OSPtrSize
8111c6fc g     F .text	00000054 vFailSendRMAPFromIRQ
8111c1c8 g     F .text	00000068 vCoudlNotCreateNFeeControllerTask
8112b54c g     F .text	0000000c __locale_charset
8110d398 g     F .text	00000074 bSyncCtrCh3OutEnable
81133fc4 g     F .text	000000c8 .hidden __lesf2
81152200 g     O .rwdata	00000002 OSEventTblSize
8111e5e8 g     F .text	0000007c .hidden __fixunsdfsi
81149e54 g       .text	00000000 OSCtxSw
8110ad44 g     F .text	00000160 I2C_MultipleRead
81136510 g     F .text	00000074 alt_log_system_clock
81152378 g     O .bss	00000004 __malloc_top_pad
811523dc g     O .bss	00000004 OSTCBList
81140a90 g     F .text	00000040 OSTmrSignal
81152388 g     O .bss	00000004 alt_fd_list_lock
8112efb8 g     F .text	0000001c strtoul
811521b0 g     O .rwdata	00000004 __mb_cur_max
8112b57c g     F .text	0000000c _localeconv_r
8112efd4 g     F .text	000002e0 _strtoull_r
8110c40c g     F .text	00000070 vRstcHoldDeviceReset
8112bebc g     F .text	00000044 __i2b
8112ade0 g     F .text	000004c4 __sfvwrite_r
81142840 g     F .text	000000c0 get_dir_divider_location
81107084 g     F .text	00000044 vRmapCh4IrqFlagClrWriteCmd
811667d0 g     O .bss	00000c30 OSMemTbl
811523e0 g     O .bss	00000001 OSTickStepState
81136120 g     F .text	00000060 alt_log_printf_proc
81104d7c g     F .text	000000c4 bDpktGetPixelDelay
8115953c g     O .bss	00001800 vReceiverUartTask_stk
81122010 g     F .text	0000005c _sbrk_r
81152328 g     O .bss	00000004 xSemTimeoutChecker
81142500 g     F .text	000000cc filename_to_upper_case
81152394 g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
81152224 g     O .rwdata	00000002 OSQMax
81144a70 g     F .text	00000090 alt_up_sd_card_set_attributes
8113b9c4 g     F .text	00000304 OSMutexDel
81167400 g     O .bss	00001000 OSTaskStatStk
8111dbfc g     F .text	00000030 bSDcardFAT16Check
8113b190 g     F .text	000000f8 OSMemNameGet
8111ab1c g     F .text	00000060 vFailCreateMutexSResources
8114186c g     F .text	00000284 Read_File_Record_At_Offset
8115ad3c g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
81152204 g     O .rwdata	00000002 OSFlagEn
8112caf4 g     F .text	00000068 _read_r
8115224a g     O .rwdata	00000002 OSTimeTickHookEn
8113ae10 g     F .text	000000ac OS_FlagUnlink
8113d1e4 g     F .text	00000170 OSQPost
81102478 g     F .text	00000498 bDdr2MemoryRandomReadTest
811521cc g     O .rwdata	00000004 alt_max_fd
8111b8c4 g     F .text	0000004c vFailTimeoutCheckerTaskCreate
81138db4 g     F .text	00000070 OS_MemCopy
81138e24 g     F .text	000000d8 OS_Sched
811430e4 g     F .text	0000047c find_file_in_directory
8113208c g     F .text	000000f8 _fclose_r
8113b098 g     F .text	000000f8 OSMemGet
8113f270 g     F .text	000001bc OSTaskNameSet
8112a298 g     F .text	00000030 fflush
81152374 g     O .bss	00000004 __malloc_max_sbrked_mem
811523e4 g     O .bss	00000004 OSCtxSwCtr
81105dc8 g     F .text	000000d4 bFeebCh6SetBufferSize
8114a140 g     F .text	00000054 OSTimeTickHook
8115ad7c g     O .bss	00001000 vOutAckHandlerTask_stk
81135800 g     F .text	00000188 alt_irq_register
8115220e g     O .rwdata	00000002 OSFlagNameSize
81120338 g     F .text	00000118 .hidden __extendsfdf2
81138838 g     F .text	00000108 OS_EventTaskRemoveMulti
8111bee8 g     F .text	00000070 vFailCreateNFEESyncQueue
811441e0 g     F .text	00000074 alt_up_sd_card_is_FAT16
8110aad4 g     F .text	00000088 I2C_TestAdress
8113408c g     F .text	000008b4 .hidden __adddf3
81165dc8 g     O .bss	00000018 alt_log_jtag_uart_alarm_1
81133e90 g     F .text	00000078 .hidden __nesf2
81107040 g     F .text	00000044 vRmapCh3IrqFlagClrWriteCmd
811050e4 g     F .text	0000008c usiLineTrDelayCalcPeriodNs
81138620 g     F .text	00000158 OS_EventTaskWaitMulti
8115bd7c g     O .bss	00000020 SyncTBL4
8112c660 g     F .text	00000114 __b2d
8114844c g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
81152226 g     O .rwdata	00000002 OSQSize
8113379c g     F .text	00000540 .hidden __umoddi3
811365c8 g     F .text	000000dc lseek
8113dcd4 g     F .text	00000214 OSSemPend
8111c3ac g     F .text	00000068 vCouldNotGetCmdQueueMeb
81107bb0 g     F .text	00000160 bRmapGetCodecStatus
8110a498 g     F .text	000000d0 bSpwcGetLinkStatus
811068ec g     F .text	00000088 bFeebGetWindowing
811521a0 g     O .rwdata	00000004 _global_impure_ptr
8110c97c g     F .text	0000004c bSSDisplayUpdate
81142ba4 g     F .text	00000540 get_home_directory_cluster_for_file
8112cb5c g     F .text	0000056c _realloc_r
81152210 g     O .rwdata	00000002 OSLowestPrio
8116c4cc g       *ABS*	00000000 __bss_end
81149968 g     F .text	000000f8 alt_iic_isr_register
8114a210 g     F .text	0000002c OSTCBInitHook
81152256 g     O .rwdata	00000002 OSTmrCfgTicksPerSec
81136dc0 g     F .text	00000110 alt_tick
81107718 g     F .text	0000017c vRmapInitIrq
8111ae14 g     F .text	00000068 vFailGetMutexSenderTask
8110c32c g     F .text	0000006c vRstcSimucamReset
811103f0 g     F .text	000000a4 bSendRequestNFeeCtrl
8114fcd0 g     O .rodata	00000100 __hexdig
81148fc8 g     F .text	000001b4 alt_msgdma_init
8113321c g     F .text	00000580 .hidden __udivdi3
81113f14 g     F .text	0000017c setPreAckSenderFreePos
81132304 g     F .text	00000024 _fputwc_r
811521f8 g     O .rwdata	00000002 OSEventEn
8114fb40 g     O .rodata	00000028 __mprec_bigtens
8112bc98 g     F .text	0000010c __s2b
81152252 g     O .rwdata	00000002 OSTmrCfgNameSize
8115bd9c g     O .bss	00000020 xFeeQueueTBL4
8110ce24 g     F .text	00000074 bSyncSetPolarity
811166ac g     F .text	0000028c vCheckRetransmission64
811353ac g     F .text	000000b0 .hidden __floatunsidf
81152398 g     O .bss	00000004 alt_system_clock_in_sec
81136318 g     F .text	00000054 alt_log_jtag_uart_startup_info
8111b3a0 g     F .text	00000068 vFailFoundBufferRetransmission
8112c398 g     F .text	00000060 __mcmp
81152460 g     O .bss	00000004 current_sector_index
81146740 g     F .text	00000168 altera_avalon_uart_init
811492a4 g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
81104118 g     F .text	00000414 bSdmaDmaM2Transfer
8111d3d0 g     F .text	00000034 vResetTimeCode
8111d128 g     F .text	0000002c cFeeSpwChannelEnable
8112a650 g     F .text	00000018 __fp_lock_all
8111c890 g     F .text	0000004c vFailSendMsgDataCTRL
81149914 g     F .text	00000054 alt_ic_irq_enabled
8110ab5c g     F .text	000000e0 I2C_Write
81107288 g     F .text	00000058 bRmapCh3IrqFlagWriteCmd
811523e8 g     O .bss	00000002 OSTmrFree
8113ac2c g     F .text	000000e8 OS_FlagInit
81136d1c g     F .text	000000a4 alt_alarm_stop
81122678 g     F .text	0000001c strtol
81152391 g     O .bss	00000001 alt_log_sys_clk_on_flag
8114023c g     F .text	00000140 OSTmrDel
811415d8 g     F .text	000000e8 mark_cluster
81152234 g     O .rwdata	00000002 OSTaskIdleStkSize
8115238c g     O .bss	00000004 alt_irq_active
8113d8f4 g     F .text	000000b8 OSSemAccept
811208b4 g     F .text	0000044c _fseeko_r
81117538 g     F .text	00000260 vFillMemmoryPattern
811223f4 g     F .text	00000044 strnlen
8113b3a4 g     F .text	000000e0 OSMemPut
8113aebc g     F .text	000001dc OSMemCreate
811523ec g     O .bss	00000004 OSIdleCtrMax
81118c50 g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
81135b68 g     F .text	000005b8 alt_log_private_printf
81150d1c g     O .rwdata	00000028 alt_dev_null
8114805c g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
8110cde4 g     F .text	00000040 bSyncSetOst
81152248 g     O .rwdata	00000002 OSTicksPerSec
81150ec4 g     O .rwdata	00000019 alt_log_msg_bss
81143a9c g     F .text	00000194 convert_filename_to_name_extension
811084c4 g     F .text	0000104c bRmapSetRmapMemHKArea
81106764 g     F .text	000000e0 bFeebSetBufferSize
81114708 g     F .text	00000434 vSimMebTask
8110aea4 g     F .text	00000094 i2c_start
81149e54 g       .text	00000000 OSIntCtxSw
8111c750 g     F .text	00000054 vFailSendMsgSync
8110d40c g     F .text	00000074 bSyncCtrCh4OutEnable
81148e40 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
811356a8 g     F .text	00000028 alt_dcache_flush_all
8112bda4 g     F .text	00000068 __hi0bits
81115160 g     F .text	00000114 vPusType251run
81107628 g     F .text	00000050 uliRmapCh6WriteCmdAddress
8111d7b8 g     F .text	0000003c vChangeRTValue
81152434 g     O .bss	00000004 is_sd_card_formated_as_FAT16
811162a4 g     F .text	00000184 vCheck
8111ca84 g     F .text	00000050 vNFeeNotInUse
811201d4 g     F .text	00000080 .hidden __fixdfsi
81112758 g     F .text	000000c8 bSendCmdQToNFeeInst_Prio
81105f70 g     F .text	000000d4 bFeebCh8SetBufferSize
811069fc g     F .text	00000088 bFeebStopCh
8110d9fc g     F .text	00000084 uliPerCalcPeriodMs
8111207c g     F .text	00000424 vNFeeControlTask
8115bdbc g     O .bss	00001000 vInitialTask_stk
8115232c g     O .bss	00000002 usiIdCMD
8115cdbc g     O .bss	00000020 SyncTBL3
8110d0ec g     F .text	00000054 bSyncCtrStart
81143714 g     F .text	00000254 find_first_empty_record_in_a_subdirectory
8112e95c g     F .text	00000018 strtod
81106a84 g     F .text	00000088 bFeebClrCh
811523f0 g     O .bss	00000004 OSTCBFreeList
81107390 g     F .text	00000058 bRmapCh6IrqFlagWriteCmd
8113dee8 g     F .text	00000174 OSSemPendAbort
8111afb4 g     F .text	0000004c vFailGetMacRTC
81107588 g     F .text	00000050 uliRmapCh4WriteCmdAddress
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
8111b82c g     F .text	0000004c vFailCreateTimerRetransmisison
8111b338 g     F .text	00000068 vFailGetCountSemaphorexBuffer32
81117b18 g     F .text	000002f0 bSendUART128v2
8111d5ec g     F .text	000000ec vSimucamStructureInit
811521c4 g     O .rwdata	00000008 alt_dev_list
811207e4 g     F .text	0000004c _fputc_r
81137050 g     F .text	0000010c write
81121bc4 g     F .text	000000a8 _putc_r
81152458 g     O .bss	00000004 device_pointer
8115224c g     O .rwdata	00000002 OSVersionNbr
81133f08 g     F .text	000000bc .hidden __gtsf2
8111c974 g     F .text	0000004c vFailFlushMEBQueue
81113908 g     F .text	00000118 getPreParsedPacket
811102a4 g     F .text	00000060 bEnableSPWChannel
81135748 g     F .text	000000b8 fstat
8111d438 g     F .text	00000040 vChangeIdNFEEMaster
811207b8 g     F .text	0000002c fprintf
8111d218 g     F .text	00000038 cFeeRMAPLogEnable
81102c74 g     F .text	00000114 DMA_SINGLE_TRANSFER
8110589c g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
8111b978 g     F .text	00000068 vFailPostBlockingSemTimeoutTask
8111e18c g     F .text	00000058 _reg_write
8111d478 g     F .text	00000034 vChangeDefaultIdNFEEMaster
811352b8 g     F .text	000000f4 .hidden __ledf2
81106eb8 g     F .text	00000040 vRmapCh5HandleIrq
81110198 g     F .text	00000054 bDisableRmapIRQ
8115cddc g     O .bss	00001000 vStackMonitor_stk
8111bcb8 g     F .text	00000068 vCouldNotSendLog
811404bc g     F .text	000001b8 OSTmrRemainGet
811521f4 g     O .rwdata	00000004 OSEndiannessTest
8110c520 g     F .text	00000058 v_spi_start
8112c100 g     F .text	00000148 __pow5mult
811074e8 g     F .text	00000050 uliRmapCh2WriteCmdAddress
81130a7c g     F .text	00001464 ___vfiprintf_internal_r
81152384 g     O .bss	00000004 __nlocale_changed
81133e38 g     F .text	00000058 .hidden __umodsi3
8110d23c g     F .text	00000074 bSyncCtrSyncOutEnable
8111dc2c g     F .text	000000f8 bInitializeSDCard
8111b748 g     F .text	0000004c vFailParserCommTaskCreate
8111bc50 g     F .text	00000068 vCouldNotSendReset
811220b0 g     F .text	00000038 _scanf_r
8111b7e0 g     F .text	0000004c vFailOutAckHandlerTaskCreate
81152206 g     O .rwdata	00000002 OSFlagGrpSize
81114d44 g     F .text	0000008c vPusType250conf
8115dddc g     O .bss	00000058 xInUseRetrans
8110cba4 g     F .text	00000050 bSyncIrqFlagSync
811484ac g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
81140674 g     F .text	000000ec OSTmrStateGet
8116c4cc g       *ABS*	00000000 end
811053c0 g     F .text	00000084 vFeebCh6HandleIrq
81117798 g     F .text	00000260 vPrintMemmoryPattern
8111b4d8 g     F .text	00000068 vNoContentInPreParsedBuffer
81120d00 g     F .text	0000001c fseeko
81113a20 g     F .text	00000168 bSendMessagePUStoMebTask
8111be78 g     F .text	00000070 vFailCreateNFEEQueue
81120668 g     F .text	0000000c _atoi_r
81146f8c g     F .text	00000240 altera_avalon_uart_write
81135aac g     F .text	00000054 alt_log_txchar
81120898 g     F .text	0000001c fseek
81117a88 g     F .text	00000090 vCCDChangeValues
81145880 g     F .text	000001d0 altera_avalon_jtag_uart_init
811390b4 g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
8111ac14 g     F .text	0000004c vFailTestCriticasParts
811fa000 g       *ABS*	00000000 __alt_stack_pointer
8110200c g     F .text	0000046c bDdr2MemoryRandomWriteTest
81146594 g     F .text	00000084 alt_avalon_timer_sc_init
81106844 g     F .text	000000a8 bFeebSetWindowing
81146680 g     F .text	00000068 altera_avalon_uart_write_fd
811205f8 g     F .text	00000064 .hidden __clzsi2
811466e8 g     F .text	00000058 altera_avalon_uart_close_fd
8115de34 g     O .bss	00000020 xMebQTBL
81146244 g     F .text	000002cc altera_avalon_jtag_uart_write
81140be8 g     F .text	00000174 OSTmr_Init
8115de54 g     O .bss	00000348 xBuffer128
8112a640 g     F .text	00000004 __sfp_lock_acquire
8110335c g     F .text	00000048 sense_log_temp
8112b858 g     F .text	000000e4 memchr
81138d58 g     F .text	0000005c OS_MemClr
81124874 g     F .text	00002200 ___vfprintf_internal_r
81149f34 g     F .text	00000164 OSTaskStkInit
811220e8 g     F .text	00000060 _sprintf_r
8110815c g     F .text	000002d4 bRmapGetMemConfigArea
8115232e g     O .bss	00000001 SemCount32
8112aac8 g     F .text	00000318 _free_r
81149bb0 g     F .text	00000234 alt_printf
81118a58 g     F .text	00000050 vTimeoutCheck
8111e23c g     F .text	000001fc _print_codec_status
8112b558 g     F .text	00000010 __locale_mb_cur_max
81138368 g     F .text	000001a0 OS_EventTaskRdy
811079c4 g     F .text	00000088 bRmapGetIrqFlags
81102bcc g     F .text	000000a8 DMA_DISPATCHER_RESET
8114a488 g     F .text	00000188 __call_exitprocs
81112568 g     F .text	00000128 vPerformActionNFCRunning
811523f4 g     O .bss	00000001 OSCPUUsage
8111c0f8 g     F .text	00000068 vCoudlNotCreateNFee4Task
81152380 g     O .bss	00000004 __mlocale_changed
811124a0 g     F .text	000000c8 vPerformActionNFCConfig
8110d194 g     F .text	00000054 bSyncCtrOneShot
811521a8 g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
8110d90c g     F .text	0000003c uliSyncReadStatus
811523ac g     O .bss	00000004 _alt_tick_rate
8113cddc g     F .text	00000294 OSQPend
8112ea7c g     F .text	000002e8 _strtoll_r
8115e19c g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
81165d64 g     O .bss	00000034 xDefaults
8113fb60 g     F .text	0000010c OSTimeDly
81115028 g     F .text	000000ac vPusMebInTaskRunningMode
8110cb68 g     F .text	0000003c vSyncIrqFlagClrSync
8112c248 g     F .text	00000150 __lshift
81112820 g     F .text	000002f8 vOutAckHandlerTask
81147f04 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
811523b0 g     O .bss	00000004 _alt_nticks
81136ab0 g     F .text	00000104 read
8114123c g     F .text	000000f0 alt_sys_init
8111eeb0 g     F .text	0000012c .hidden __floatsisf
81106ffc g     F .text	00000044 vRmapCh2IrqFlagClrWriteCmd
8112f2b4 g     F .text	000001d8 __ssprint_r
81121ae0 g     F .text	00000068 _open_r
8111e104 g     F .text	00000088 bTestSimucamCriticalHW
811063c8 g     F .text	0000010c bFeebGetBuffersStatus
8111a8cc g     F .text	000000a4 ucCrc8
81100818 g     F .text	00000cb0 bDdr2EepromDump
811523f5 g     O .bss	00000001 OSTaskCtr
81135a78 g       .text	00000000 tx_log_str
81114b3c g     F .text	0000015c vPusMebTask
81118a08 g     F .text	00000050 siPosStr
81115684 g     F .text	00000088 vSendCmdQToNFeeCTRL_PRIO
81132f4c g     F .text	000000d0 strncmp
8110d948 g     F .text	0000005c bSyncWriteReg
81107338 g     F .text	00000058 bRmapCh5IrqFlagWriteCmd
8113fc6c g     F .text	00000164 OSTimeDlyHMSM
8112bf00 g     F .text	00000200 __multiply
81145e18 g     F .text	00000070 altera_avalon_jtag_uart_close
8110c6f0 g     F .text	00000058 v_spi_end
8111dda0 g     F .text	00000040 cGetNextChar
8114a39c g     F .text	000000ec strncpy
811525ac g     O .bss	00000028 __malloc_current_mallinfo
811521fa g     O .rwdata	00000002 OSEventMax
81133e90 g     F .text	00000078 .hidden __eqsf2
8112c774 g     F .text	00000154 __d2b
8113e05c g     F .text	00000118 OSSemPost
81105590 g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
8111d7f4 g     F .text	00000030 vChangeDefaultRTValue
81105484 g     F .text	00000040 vFeebCh8HandleIrq
81152430 g     O .bss	00000004 initialized
811188b8 g     F .text	00000100 vSendLog
81137edc g     F .text	000000e4 OSSchedUnlock
8110c748 g     F .text	00000164 RTCC_SPI_R_MAC
811521d8 g     O .rwdata	00000004 alt_log_boot_on_flag
811456fc g     F .text	00000068 altera_avalon_jtag_uart_read_fd
8112ed64 g     F .text	00000254 _strtoul_r
8115e1dc g     O .bss	00000020 xFeeQueueTBL5
811496b4 g     F .text	000000e4 alt_get_fd
811523f8 g     O .bss	00000004 OSMemFreeList
81138038 g     F .text	000000b8 OSStatInit
8111e0d0 g     F .text	00000034 bClearCounterSync
81102990 g     F .text	00000064 DMA_OPEN_DEVICE
8116be64 g     O .bss	00000014 search_data
8110a18c g     F .text	00000134 bSpwcSetLink
8113545c g     F .text	00000130 alt_busy_sleep
8113a9f8 g     F .text	000000cc OSFlagQuery
8110d2b0 g     F .text	00000074 bSyncCtrCh1OutEnable
81152230 g     O .rwdata	00000002 OSTaskCreateExtEn
8111e438 g     F .text	00000074 _split_codec_status
8112871c g     F .text	0000005c _close_r
8111b540 g     F .text	00000068 vCouldNotSendEthConfUART
81111af8 g     F .text	00000584 vInitialTask
81136220 g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
811483ec g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
8114a320 g     F .text	0000007c memcmp
81138340 g     F .text	00000028 OS_Dummy
811457cc g     F .text	00000058 altera_avalon_jtag_uart_close_fd
8116c4cc g       *ABS*	00000000 __alt_stack_base
81105e9c g     F .text	000000d4 bFeebCh7SetBufferSize
81145824 g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
811055d4 g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
81120d80 g     F .text	000000d4 _fwrite_r
811159b8 g     F .text	000000a4 vReleaseSyncMessages
8114850c g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
811056e4 g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
811285c0 g     F .text	0000015c __swsetup_r
81168400 g     O .bss	00000300 OSQTbl
8111c530 g     F .text	00000068 vCouldNotGetQueueMaskNfeeCtrl
81165d98 g     O .bss	0000001c xConfEth
81134940 g     F .text	000008f0 .hidden __divdf3
8111d858 g     F .text	0000003c vChangeSyncSource
8112a4f8 g     F .text	00000120 __sfp
8116be78 g     O .bss	00000054 boot_sector_data
8111c4c8 g     F .text	00000068 vCouldNotCreateQueueMaskDataCtrl
8110a5f8 g     F .text	00000088 bSpwcClearTimecode
81102ad8 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
8112c9f0 g     F .text	00000078 __copybits
8115089c g     O .rwdata	00000408 __malloc_av_
8112a64c g     F .text	00000004 __sinit_lock_release
8115226c g     O .bss	00000004 uliInitialState
8110af38 g     F .text	00000080 i2c_stop
8111e550 g     F .text	00000064 Verif_Error
8111e5b4 g     F .text	00000034 toInt
8111ad60 g     F .text	0000004c vFailSendPreAckSenderSemaphore
811523fc g     O .bss	00000004 OSTCBHighRdy
8111f1b0 g     F .text	00000720 .hidden __muldf3
811221bc g     F .text	0000005c __sread
8112a960 g     F .text	0000003c fread
81152400 g     O .bss	00000004 OSQFreeList
811495a4 g     F .text	00000110 alt_find_file
81149460 g     F .text	000000ac alt_dev_llist_insert
81137290 g     F .text	00000128 __malloc_lock
81120788 g     F .text	00000030 _fprintf_r
81136c20 g     F .text	000000fc sbrk
8111d0a4 g     F .text	0000002c vFeeSpwRMAPLoadDefault
8111b2d0 g     F .text	00000068 vFailGetCountSemaphorexBuffer64
81122694 g     F .text	000021e0 ___svfprintf_internal_r
81118df8 g     F .text	00000088 vTMPusTestConnection
81152330 g     O .bss	00000004 xMebQ
811375b4 g     F .text	00000148 OSEventNameSet
8112a234 g     F .text	00000064 _fflush_r
81131fc0 g     F .text	000000cc _calloc_r
81152404 g     O .bss	00000001 OSRdyGrp
8111c844 g     F .text	0000004c vFailSendMsgFeeCTRL
8110cce0 g     F .text	00000044 ucSyncStatusCycleNumber
81107b24 g     F .text	0000008c bRmapGetCodecConfig
81140760 g     F .text	00000148 OSTmrStart
8110533c g     F .text	00000084 vFeebCh5HandleIrq
81120770 g     F .text	00000018 fopen
811029f4 g     F .text	0000004c DMA_CONFIG
8115226c g       *ABS*	00000000 __bss_start
81105c20 g     F .text	000000d4 bFeebCh4SetBufferSize
811219b8 g     F .text	00000128 memset
81113dd8 g     F .text	0000013c setPreParsedFreePos
8110f3fc g     F .text	000001fc vQCmdFEEinStandBy
81148f68 g     F .text	00000060 alt_msgdma_open
8111d9b0 g     F .text	0000021c pattern_createPattern
81117384 g     F .text	000001b4 main
8111aee4 g     F .text	00000068 vFailGetMutexReceiverTask
8115e1fc g     O .bss	00001000 vNFeeControlTask_stk
81107194 g     F .text	00000044 vRmapCh8IrqFlagClrWriteCmd
8111d710 g     F .text	0000003c vChangeEPValue
811072e0 g     F .text	00000058 bRmapCh4IrqFlagWriteCmd
811523a8 g     O .bss	00000004 alt_envp
8111c8dc g     F .text	0000004c vFailFlushQueue
81152370 g     O .bss	00000004 __malloc_max_total_mem
8114880c g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
8111a970 g     F .text	0000005c ucCrc8wInit
8111b878 g     F .text	0000004c vCouldNotCheckBufferTimeOutFunction
81145764 g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102f9c g     F .text	000002c8 POWER_Read
8110b0f0 g     F .text	00000160 i2c_read
8115f1fc g     O .bss	00000020 SyncTBL5
81128540 g     F .text	00000018 __swbuf
8114ffd0 g     O .rodata	00000100 OSUnMapTbl
81133fc4 g     F .text	000000c8 .hidden __ltsf2
81144b00 g     F .text	00000090 alt_up_sd_card_get_attributes
8112a72c g     F .text	00000234 _fread_r
8111adac g     F .text	00000068 vFailGetCountSemaphoreSenderTask
8110a8e4 g     F .text	0000003c bDisableIsoDrivers
8115222a g     O .rwdata	00000002 OSSemEn
8114132c g     F .text	000000bc Write_Sector_Data
81144f10 g     F .text	00000628 alt_up_sd_card_write
81152334 g     O .bss	00000004 xFeeQ
8110662c g     F .text	00000068 bFeebGetCh1RightBufferEmpty
8113a65c g     F .text	0000039c OSFlagPost
81122308 g     F .text	00000008 __sclose
8111bb80 g     F .text	00000068 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
81132184 g     F .text	00000014 fclose
81138508 g     F .text	00000118 OS_EventTaskWait
8111ba48 g     F .text	00000068 vCouldNotRetransmitB32TimeoutTask
81122438 g     F .text	00000240 _strtol_r
81120450 g     F .text	000001a8 .hidden __truncdfsf2
8115f21c g     O .bss	00000020 xFeeQueueTBL2
81139198 g     F .text	000000d4 OS_TaskStatStkChk
8113ef78 g     F .text	00000158 OSTaskDelReq
81104b70 g     F .text	000000c4 bDpktGetPacketHeader
81106d34 g     F .text	000000c4 vRmapCh1HandleIrq
81128980 g     F .text	00001690 _dtoa_r
81148b28 g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
81121054 g     F .text	00000814 _malloc_r
8115f23c g     O .bss	00000020 SyncTBL0
81133188 g     F .text	00000030 __ascii_wctomb
8113b7f4 g     F .text	000001d0 OSMutexCreate
8111b9e0 g     F .text	00000068 vFailCouldNotRetransmitTimeoutTask
811119ac g     F .text	0000014c bCheckInAck32
811521d0 g     O .rwdata	00000004 alt_errno
81148654 g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
81137fc0 g     F .text	00000078 OSStart
8110a2c0 g     F .text	000000e4 bSpwcGetLink
8110be44 g     F .text	000004e8 POWER_SPI_RW
811306d0 g     F .text	000000dc __submore
81136180 g     F .text	000000a0 altera_avalon_jtag_uart_report_log
81137228 g     F .text	00000068 __env_unlock
8111bfc0 g     F .text	00000068 vCoudlNotCreateNFee1Task
8112b2a4 g     F .text	000000cc _fwalk
8113f42c g     F .text	000001dc OSTaskResume
8113b484 g     F .text	000000f0 OSMemQuery
8115223c g     O .rwdata	00000002 OSTaskStatEn
8116c4cc g       *ABS*	00000000 __alt_stack_limit
8115227c g     O .bss	00000004 ECommSpwCh
8111d8fc g     F .text	0000003c vChangeAutoResetSync
8112b7f4 g     F .text	00000064 _mbtowc_r
811113c8 g     F .text	00000350 vInAckHandlerTaskV2
81152216 g     O .rwdata	00000002 OSMemMax
8113d354 g     F .text	00000178 OSQPostFront
81121c6c g     F .text	000000d0 putc
81133cdc g     F .text	00000084 .hidden __divsi3
81152405 g     O .bss	00000006 OSRdyTbl
811521f0 g     O .rwdata	00000002 OSDebugEn
81150f34 g     O .rwdata	0000002a alt_log_msg_cache
8112a99c g     F .text	0000012c _malloc_trim_r
81109cdc g     F .text	000001a4 bRmapInitCh
81152364 g     O .bss	00000008 xSdHandle
8111eaac g     F .text	00000404 .hidden __mulsf3
81152208 g     O .rwdata	00000002 OSFlagNodeSize
81152270 g     O .bss	00000004 pnt_memory
8111d968 g     F .text	00000048 vSyncReset
81110ea0 g     F .text	00000528 vLoadCtemp
8110cda4 g     F .text	00000040 bSyncSetPer
81100308 g     F .text	00000510 bDdr2EepromTest
8115243c g     O .bss	00000004 status_register
81152250 g     O .rwdata	00000002 OSTmrCfgMax
8110d738 g     F .text	00000074 bSyncIrqFlagClrError
8111b610 g     F .text	00000068 vFailSetPreAckSenderBuffer
8112d214 g     F .text	000000dc strcmp
81152444 g     O .bss	00000004 command_register
8113c8e0 g     F .text	000001b4 OSQCreate
8113f0d0 g     F .text	000001a0 OSTaskNameGet
8115f25c g     O .bss	00001000 vFeeTask4_stk
8116025c g     O .bss	00000018 xReceivedACK
8113d4cc g     F .text	00000214 OSQPostOpt
811380f0 g     F .text	00000228 OSTimeTick
81152238 g     O .rwdata	00000002 OSTaskMax
8113d9ac g     F .text	000000e0 OSSemCreate
8115225c g     O .rwdata	00000002 OSTmrWheelSize
8111be10 g     F .text	00000068 vFailCreateScheduleQueue
8111e1e4 g     F .text	00000058 _reg_read
8113c48c g     F .text	00000174 OSMutexQuery
81110494 g     F .text	000000a4 bSendGiveBackNFeeCtrl
81135230 g     F .text	00000088 .hidden __nedf2
81152232 g     O .rwdata	00000002 OSTaskDelEn
8111d6d8 g     F .text	00000038 vLoadDefaultEPValue
81160274 g     O .bss	00001000 vFeeTask1_stk
8110d568 g     F .text	00000074 bSyncCtrCh7OutEnable
8113e174 g     F .text	00000118 OSSemQuery
8113ca94 g     F .text	00000288 OSQDel
8113d070 g     F .text	00000174 OSQPendAbort
81152338 g     O .bss	00000004 xMutexPreParsed
811411fc g     F .text	00000040 alt_irq_init
81136bb4 g     F .text	0000006c alt_release_fd
8114151c g     F .text	000000bc get_cluster_flag
8110d7ac g     F .text	00000074 bSyncIrqFlagClrBlank
81149260 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
8110caf0 g     F .text	0000002c vSyncClearCounter
81150f00 g     O .rwdata	00000031 alt_log_msg_stackpointer
81122148 g     F .text	00000074 sprintf
8114f6b8 g     O .rodata	00000100 .hidden __clz_tab
81141af0 g     F .text	00000294 Write_File_Record_At_Offset
81101584 g     F .text	0000057c bDdr2MemoryWriteTest
8111af4c g     F .text	00000068 vFailGetMutexTxUARTSenderTask
8115237c g     O .bss	00000004 _PathLocale
8110d878 g     F .text	00000058 bSyncIrqFlagBlank
8110bcfc g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
811408a8 g     F .text	000001e8 OSTmrStop
81109ed4 g     F .text	00000050 uliRmapReadReg
811189b8 g     F .text	00000050 usiGetIdCMD
8110d9a4 g     F .text	00000058 uliSyncReadReg
8112e974 g     F .text	00000108 strtof
81105234 g     F .text	00000084 vFeebCh3HandleIrq
81133f08 g     F .text	000000bc .hidden __gesf2
81122310 g     F .text	0000004c strcspn
81128558 g     F .text	00000068 _write_r
8110c398 g     F .text	00000074 vRstcReleaseDeviceReset
8111b794 g     F .text	0000004c vFailInAckHandlerTaskCreate
81137e48 g     F .text	00000094 OSSchedLock
8111c090 g     F .text	00000068 vCoudlNotCreateNFee3Task
8112b588 g     F .text	00000018 setlocale
811485b4 g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
81168700 g     O .bss	00000800 OSTmrTaskStk
8112206c g     F .text	00000044 scanf
8111c300 g     F .text	00000060 vFailCreateMutexSPUSQueueMeb
81139a50 g     F .text	00000110 OSFlagCreate
81141d84 g     F .text	00000688 Check_for_DOS_FAT
811158b0 g     F .text	00000064 vMebInit
81143c30 g     F .text	000002d0 create_file
8112d20c g     F .text	00000008 nanf
811521a4 g     O .rwdata	00000004 _impure_ptr
81152440 g     O .bss	00000004 CSD_register_w0
811523a0 g     O .bss	00000004 alt_argc
8111b268 g     F .text	00000068 vFailGetCountSemaphorexBuffer128
8112a010 g     F .text	00000224 __sflush_r
8112b614 g     F .text	000000b4 _mbrtowc_r
8110a568 g     F .text	00000090 bSpwcGetTimecode
8112b574 g     F .text	00000008 __locale_cjk_lang
811033a4 g     F .text	0000078c sense_log
81152280 g     O .bss	00000004 ESdmaBufferSide
81152202 g     O .rwdata	00000002 OSEventMultiEn
81120894 g     F .text	00000004 _fseek_r
81161274 g     O .bss	00001800 vParserCommTask_stk
8111aaac g     F .text	00000070 printErrorTask
8111d74c g     F .text	00000030 vChangeDefaultEPValue
81116938 g     F .text	000002c8 vCheckRetransmission32
81140078 g     F .text	000001c4 OSTmrCreate
81115a5c g     F .text	000007dc vStackMonitor
81121e34 g     F .text	000001dc __srefill_r
8110a920 g     F .text	0000003c bEnableLvdsBoard
8115233c g     O .bss	00000004 xMutexBuffer32
81106df8 g     F .text	00000040 vRmapCh2HandleIrq
81139b60 g     F .text	00000250 OSFlagDel
8115240c g     O .bss	00000004 OSEventFreeList
8110a998 g     F .text	000000c0 bSetPreEmphasys
8110f238 g     F .text	000001c4 vQCmdFEEinConfig
81100020 g       .exceptions	00000000 alt_irq_entry
8112b7a8 g     F .text	0000004c __ascii_mbtowc
8110d074 g     F .text	00000078 bSyncCtrExtnIrq
81106694 g     F .text	00000068 bFeebGetCh2LeftBufferEmpty
8112c5fc g     F .text	00000064 __ulp
8111d284 g     F .text	0000010c vNFeeControlInit
81115914 g     F .text	000000a4 vSwapMemmory
8113a034 g     F .text	000005c0 OSFlagPend
8115224e g     O .rwdata	00000002 OSTmrEn
8112a668 g     F .text	00000018 __fp_unlock_all
81162a74 g     O .bss	00000010 xDma
81120830 g     F .text	00000064 fputc
811101ec g     F .text	00000058 bEnableRmapIRQ
81118100 g     F .text	000002f8 bSendUART32v2
81114090 g     F .text	0000019c setPreAckReceiverFreePos
8110d034 g     F .text	00000040 bSyncErrInj
811521bc g     O .rwdata	00000008 alt_fs_list
81162a84 g     O .bss	00001000 vSimMebTask_stk
8111c298 g     F .text	00000068 vCoudlNotCreateMebTask
811425cc g     F .text	00000274 check_file_name_for_FAT16_compliance
81163a84 g     O .bss	00001000 vFeeTask3_stk
8114037c g     F .text	00000140 OSTmrNameGet
811526d4 g     O .bss	00000400 xSZData
8110f5f8 g     F .text	00000230 vQCmdFEEinFullPattern
81138f78 g     F .text	0000007c OS_StrCopy
8115244c g     O .bss	00000004 buffer_memory
8111b470 g     F .text	00000068 vFailGetxMutexPreParsedParserRxTask
8111d554 g     F .text	00000098 vLogWriteNUC
81152218 g     O .rwdata	00000002 OSMemNameSize
81103b30 g     F .text	000000b0 bSdmaInitM1Dma
8110d6c4 g     F .text	00000074 bSyncIrqEnableBlank
8114a1c0 g     F .text	00000028 OSInitHookEnd
8111ccb4 g     F .text	00000340 vUpdateMemMapFEE
8111b6e0 g     F .text	00000068 vFailSetPreAckReceiverBuffer
8110594c g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
81152244 g     O .rwdata	00000002 OSTCBPrioTblMax
8112b5a0 g     F .text	0000000c localeconv
8111c230 g     F .text	00000068 vCoudlNotCreateDataControllerTask
81152340 g     O .bss	00000004 xTimerRetransmission
81113b88 g     F .text	00000250 vReceiverUartTask
8115239c g     O .bss	00000004 alt_log_sys_clk_count
81152240 g     O .rwdata	00000002 OSTaskStatStkChkEn
811363d0 g     F .text	00000140 alt_log_write
81164a84 g     O .bss	00001000 vFeeTask2_stk
81152344 g     O .bss	00000004 xMutexBuffer128
81105170 g     F .text	00000040 vFeebCh1HandleIrq
8111e064 g     F .text	0000003c bStartSync
81105444 g     F .text	00000040 vFeebCh7HandleIrq
8111e0a0 g     F .text	00000030 bStopSync
81152284 g     O .bss	00000004 ECommBufferSide
81149798 g     F .text	00000058 alt_ic_isr_register
81152214 g     O .rwdata	00000002 OSMemEn
81106e38 g     F .text	00000040 vRmapCh3HandleIrq
81152190 g     O .rwdata	00000004 alt_stack_limit_value
81115274 g     F .text	00000388 vPusType252run
8111c7f8 g     F .text	0000004c vFailSendMsgMasterSyncMeb
81120e54 g     F .text	0000003c fwrite
81152450 g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
8115221e g     O .rwdata	00000002 OSMutexEn
8111c598 g     F .text	00000068 vCouldNotGetQueueMaskDataCtrl
8115226c g       *ABS*	00000000 _edata
81146618 g     F .text	00000068 altera_avalon_uart_read_fd
8111d404 g     F .text	00000034 vLoadDefaultIdNFEEMaster
81105058 g     F .text	0000008c usiAdcPxDelayCalcPeriodNs
8116c4cc g       *ABS*	00000000 _end
8116becc g     O .bss	00000500 active_files
81152410 g     O .bss	00000001 OSIntNesting
8111b000 g     F .text	0000004c vFailInitialization
811014c8 g     F .text	000000bc bDdr2SwitchMemory
8111d180 g     F .text	0000002c cFeeRMAPDump
81105b4c g     F .text	000000d4 bFeebCh3SetBufferSize
81152348 g     O .bss	00000004 xSemCountBuffer32
81132198 g     F .text	0000016c __fputwc
8115234c g     O .bss	00000004 xQMaskFeeCtrl
8111d0d0 g     F .text	0000002c vFeeSpwRMAPChangeConfig
81128318 g     F .text	00000070 vfscanf
81143f00 g     F .text	00000150 copy_file_record_name_to_string
81145e88 g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
8113fdd0 g     F .text	000001dc OSTimeDlyResume
8114240c g     F .text	000000f4 Look_for_FAT16
81110244 g     F .text	00000060 bDisableSPWChannel
81139ee0 g     F .text	00000154 OSFlagNameSet
8111038c g     F .text	00000064 bDisAndClrDbBuffer
81152350 g     O .bss	00000004 xMutexBuffer64
81107d10 g     F .text	00000160 bRmapGetCodecError
8113f608 g     F .text	000001c8 OSTaskStkChk
81149880 g     F .text	00000094 alt_ic_irq_disable
81103c90 g     F .text	00000488 bSdmaDmaM1Transfer
8115221a g     O .rwdata	00000002 OSMemSize
81114e24 g     F .text	00000204 vPusType252conf
8111b130 g     F .text	00000068 vFailSetCountSemaphorexBuffer32
81122220 g     F .text	00000084 __swrite
811521ac g     O .rwdata	00000004 __malloc_trim_threshold
8112b568 g     F .text	0000000c __locale_msgcharset
81165a84 g     O .bss	00000020 xFeeQueueTBL1
81152414 g     O .bss	00000004 OSTCBCur
8111bab0 g     F .text	00000068 vCouldNotRetransmitB64TimeoutTask
8110be00 g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
8114a2e0 g     F .text	00000040 exit
8113c26c g     F .text	00000220 OSMutexPost
8110d820 g     F .text	00000058 bSyncIrqFlagError
8114432c g     F .text	000003c0 alt_up_sd_card_find_next
8115221c g     O .rwdata	00000002 OSMemTblSize
8112b370 g     F .text	000000cc _fwalk_reent
811489ac g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
8111efdc g     F .text	000000f8 .hidden __floatunsisf
8112c3f8 g     F .text	00000204 __mdiff
8111bf58 g     F .text	00000068 vCoudlNotCreateNFee0Task
81106044 g     F .text	0000017c vFeebInitIrq
81104818 g     F .text	0000022c bDpktSetPacketConfig
8111b098 g     F .text	0000004c vFailSenderCreate
81133d60 g     F .text	00000074 .hidden __modsi3
8111c160 g     F .text	00000068 vCoudlNotCreateNFee5Task
8110cf80 g     F .text	0000003c uliSyncGetPer
81106ef8 g     F .text	00000040 vRmapCh6HandleIrq
81152354 g     O .bss	00000004 xMutexSenderACK
8111b910 g     F .text	00000068 vFailGetBlockingSemTimeoutTask
8115219c g     O .rwdata	00000004 __ctype_ptr__
8111b678 g     F .text	00000068 vFailSetPreParsedBuffer
8114143c g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
8112a644 g     F .text	00000004 __sfp_lock_release
81106294 g     F .text	000000ac bFeebGetIrqControl
8111bbe8 g     F .text	00000068 vCouldNotSendTurnOff
81137c90 g     F .text	00000064 OSInit
8110b2d0 g     F .text	00000078 bSetPainelLeds
811480f4 g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
81152418 g     O .bss	00000004 OSTmrTime
81101b00 g     F .text	0000050c bDdr2MemoryReadTest
81107e70 g     F .text	000002ec bRmapSetMemConfigArea
8113f9bc g     F .text	0000012c OSTaskQuery
8110d650 g     F .text	00000074 bSyncIrqEnableError
81152358 g     O .bss	00000004 xMutexPus
8113d844 g     F .text	000000b0 OS_QInit
8112d13c g     F .text	000000d0 __sccl
8112065c g     F .text	0000000c atoi
8110db20 g     F .text	00001530 vFeeTask
81138ff4 g     F .text	0000005c OS_StrLen
8111c9c0 g     F .text	0000004c vFailFlushNFEEQueue
8110573c g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
8111a9cc g     F .text	000000e0 vDataControllerInit
8113b288 g     F .text	0000011c OSMemNameSet
8114f7b8 g     O .rodata	00000101 _ctype_
8110cf44 g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
8111b200 g     F .text	00000068 vFailSetCountSemaphorexBuffer128
81152236 g     O .rwdata	00000002 OSTaskProfileEn
8111ca0c g     F .text	00000028 vEvtChangeMebMode
81147fc4 g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
8115235c g     O .bss	00000004 xTxUARTMutex
8115241c g     O .bss	00000004 OSTime
811521b4 g     O .rwdata	00000004 __mbtowc
81146c38 g     F .text	0000005c altera_avalon_uart_close
8110f050 g     F .text	000001e8 vQCmdFEEinWaitingSync
81152420 g     O .bss	00000004 OSTmrSem
81114dd0 g     F .text	00000054 vPusType251conf
81168f00 g     O .bss	00001000 OSTaskIdleStk
81120674 g     F .text	000000fc _fopen_r
811522f8 g     O .bss	00000004 pdata
8114a610 g     F .text	000000bc _exit
811064d4 g     F .text	00000078 bFeebGetLeftBufferEmpty
811492e8 g     F .text	00000134 alt_alarm_start
81139db0 g     F .text	00000130 OSFlagNameGet
8113ffac g     F .text	00000064 OSTimeGet
81152288 g     O .bss	00000004 ESdmaChBufferId
81144b90 g     F .text	00000380 alt_up_sd_card_read
811070c8 g     F .text	00000044 vRmapCh5IrqFlagClrWriteCmd
81120e90 g     F .text	000001c4 __smakebuf_r
81152360 g     O .bss	00000001 SemCount64
81117e08 g     F .text	000002f8 bSendUART64v2
8111c928 g     F .text	0000004c vFailFlushQueueData
811057ec g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
81152264 g     O .rwdata	00000008 alt_msgdma_list
8112235c g     F .text	00000098 strlen
8110c63c g     F .text	000000b4 uc_spi_get_byte
8110710c g     F .text	00000044 vRmapCh6IrqFlagClrWriteCmd
8111c600 g     F .text	00000054 vFailSendMsgAccessDMA
8114a0f0 g     F .text	00000028 OSTaskSwHook
81136910 g     F .text	0000015c open
81109510 g     F .text	000007cc bRmapGetRmapMemHKArea
81169f00 g     O .bss	00000d00 OSEventTbl
8111d0fc g     F .text	0000002c vFeeSpwRMAPChangeDefault
8111f0d4 g     F .text	000000dc .hidden __gedf2
8111c7a4 g     F .text	00000054 vFailSendMsgSyncRMAPTRIGGER
81165aa4 g     O .bss	00000020 xSenderACK
81149de4 g     F .text	00000044 alt_putchar
8116ac00 g     O .bss	000011b8 OSTCBTbl
811324b0 g     F .text	00000838 __gethex
8113e28c g     F .text	00000108 OSSemSet
81116238 g     F .text	0000006c vTimeoutCheckerTaskv2
8111d1ac g     F .text	00000038 cFeeRMAPEchoingEnable
811521b8 g     O .rwdata	00000004 __wctomb
81117070 g     F .text	00000314 vVariablesInitialization
81130a64 g     F .text	00000018 __sprint_r
8110fcd0 g     F .text	00000268 vQCmdFeeRMAPinFullPattern
81106340 g     F .text	00000088 bFeebGetIrqFlags
81152278 g     O .bss	00000004 pxDmaM2Dev
8111abc8 g     F .text	0000004c vFailCreateSemaphoreResources
811521d4 g     O .rwdata	00000004 alt_priority_mask
8110a95c g     F .text	0000003c bDisableLvdsBoard
8113da8c g     F .text	00000248 OSSemDel
81105a78 g     F .text	000000d4 bFeebCh2SetBufferSize
81152424 g     O .bss	00000004 OSFlagFreeList
8110c578 g     F .text	000000c4 v_spi_send_byte
8110c8ac g     F .text	000000d0 bSSDisplayConfig
811497f0 g     F .text	00000090 alt_ic_irq_enable
811521fc g     O .rwdata	00000002 OSEventNameSize
81126a74 g     F .text	0000001c __vfprintf_internal
81152428 g     O .bss	00000001 OSStatRdy
8110d324 g     F .text	00000074 bSyncCtrCh2OutEnable
8116bdb8 g     O .bss	000000ac OSTCBPrioTbl
81146cd8 g     F .text	00000270 altera_avalon_uart_read
811331b8 g     F .text	00000064 _wctomb_r
8113715c g     F .text	000000cc __env_lock
81152242 g     O .rwdata	00000002 OSTaskSwHookEn
81152bec g     O .bss	00000100 cTemp
8110554c g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
8111f8d0 g     F .text	00000904 .hidden __subdf3
81165ac4 g     O .bss	00000260 xPreParsed
8110cfbc g     F .text	0000003c uliSyncGetOst
81152361 g     O .bss	00000001 SemCount128
81106f78 g     F .text	00000040 vRmapCh8HandleIrq
81105618 g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
811183f8 g     F .text	00000290 vSendEthConf
81104698 g     F .text	000000dc bCommInitCh
8112be0c g     F .text	000000b0 __lo0bits
81126b54 g     F .text	000017c4 __svfscanf_r
811521e0 g     O .rwdata	00000008 alt_alarm_list
811307ac g     F .text	0000019c _ungetc_r
8115220a g     O .rwdata	00000002 OSFlagWidth
81106fb8 g     F .text	00000044 vRmapCh1IrqFlagClrWriteCmd
81102a40 g     F .text	0000004c DMA_BUSY
811330c0 g     F .text	000000c8 wcrtomb
81104c34 g     F .text	00000148 bDpktSetPixelDelay
811179f8 g     F .text	00000090 vCCDLoadDefaultValues
811355d0 g     F .text	000000d8 close
8110cff8 g     F .text	0000003c uliSyncGetGeneral
8111ca5c g     F .text	00000028 vEvtChangeDataControllerMode
811523b8 g     O .bss	00000004 alt_envsem
81135b00 g     F .text	00000068 alt_log_repchar
8115242c g     O .bss	00000004 OSIdleCtrRun
81138318 g     F .text	00000028 OSVersion
81152254 g     O .rwdata	00000002 OSTmrCfgWheelSize
8113fae8 g     F .text	00000078 OS_TaskStkClr
8111dd24 g     F .text	0000003c siOpenFile
8110da80 g     F .text	000000a0 vDataControlTask
8115222e g     O .rwdata	00000002 OSTaskCreateEn
81107230 g     F .text	00000058 bRmapCh2IrqFlagWriteCmd
81107678 g     F .text	00000050 uliRmapCh7WriteCmdAddress
81106974 g     F .text	00000088 bFeebStartCh
81118688 g     F .text	00000118 vSendTurnOff
8111acc8 g     F .text	0000004c vFailSendPreParsedSemaphore
81142900 g     F .text	000002a4 match_file_record_to_name_ext
81138940 g     F .text	00000070 OS_EventWaitListInit
81132328 g     F .text	00000088 fputwc
81165d24 g     O .bss	00000020 xFeeQueueTBL0
8111ac60 g     F .text	00000068 vFailSendxSemCommInit
8114a1e8 g     F .text	00000028 OSTaskIdleHook
811187a0 g     F .text	00000118 vSendReset
8112a648 g     F .text	00000004 __sinit_lock_acquire
8112bb70 g     F .text	00000128 __multadd
81165d44 g     O .bss	00000020 SyncTBL1
8110565c g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110cc48 g     F .text	0000004c ucSyncStatusState
8113f7d0 g     F .text	000001ec OSTaskSuspend
8112bb48 g     F .text	00000028 _Bfree
8110cf08 g     F .text	0000003c uliSyncGetMbt
81139050 g     F .text	00000064 OS_TaskIdle
8115225a g     O .rwdata	00000002 OSTmrTblSize
8113d6e0 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	1137cf40 	call	81137cf4 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045f4 	movhi	r2,33047
81100150:	10b0f304 	addi	r2,r2,-15412
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045f4 	movhi	r2,33047
81100168:	10b0f304 	addi	r2,r2,-15412
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	1137d480 	call	81137d48 <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0b617 	ldw	r2,-32040(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0b617 	ldw	r2,-32040(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204574 	movhi	r4,33045
81100260:	21087604 	addi	r4,r4,8664
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204574 	movhi	r4,33045
81100270:	2103cd04 	addi	r4,r4,3892
81100274:	1135a780 	call	81135a78 <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204574 	movhi	r4,33045
8110027c:	21087604 	addi	r4,r4,8664
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204574 	movhi	r4,33045
8110028c:	2103c004 	addi	r4,r4,3840
81100290:	1135a780 	call	81135a78 <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04574 	movhi	gp,33045
    ori gp, gp, %lo(_gp)
811002a0:	d6a86414 	ori	gp,gp,41360
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204574 	movhi	r4,33045
811002a8:	21087604 	addi	r4,r4,8664
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204574 	movhi	r4,33045
811002b8:	2103b104 	addi	r4,r4,3780
811002bc:	1135a780 	call	81135a78 <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04574 	movhi	r2,33045
    ori r2, r2, %lo(__bss_start)
811002c4:	10889b14 	ori	r2,r2,8812

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18f13314 	ori	r3,r3,50380

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204574 	movhi	r4,33045
811002e8:	21087604 	addi	r4,r4,8664
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204574 	movhi	r4,33045
811002f8:	2103b804 	addi	r4,r4,3808
811002fc:	1135a780 	call	81135a78 <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	11366a40 	call	811366a4 <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
81100328:	00e04574 	movhi	r3,33045
8110032c:	18c97504 	addi	r3,r3,9684
81100330:	00a04574 	movhi	r2,33045
81100334:	10a9b304 	addi	r2,r2,-22836
81100338:	1009883a 	mov	r4,r2
8110033c:	00800884 	movi	r2,34
81100340:	100d883a 	mov	r6,r2
81100344:	200b883a 	mov	r5,r4
81100348:	1809883a 	mov	r4,r3
8110034c:	11218680 	call	81121868 <memcpy>
	debug(fp, cDebugBuffer);
81100350:	d0a06117 	ldw	r2,-32380(gp)
81100354:	01604574 	movhi	r5,33045
81100358:	29497504 	addi	r5,r5,9684
8110035c:	1009883a 	mov	r4,r2
81100360:	11207b80 	call	811207b8 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100364:	00bfe804 	movi	r2,-96
81100368:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110036c:	00800044 	movi	r2,1
81100370:	e0bff915 	stw	r2,-28(fp)
	switch (ucMemoryId) {
81100374:	e0bfff03 	ldbu	r2,-4(fp)
81100378:	10000326 	beq	r2,zero,81100388 <bDdr2EepromTest+0x80>
8110037c:	10800060 	cmpeqi	r2,r2,1
81100380:	1000081e 	bne	r2,zero,811003a4 <bDdr2EepromTest+0x9c>
81100384:	00000e06 	br	811003c0 <bDdr2EepromTest+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100388:	00a00034 	movhi	r2,32768
8110038c:	10827c04 	addi	r2,r2,2544
81100390:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100394:	00a00034 	movhi	r2,32768
81100398:	10828004 	addi	r2,r2,2560
8110039c:	e0bffb15 	stw	r2,-20(fp)
		break;
811003a0:	00001906 	br	81100408 <bDdr2EepromTest+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811003a4:	00a00034 	movhi	r2,32768
811003a8:	10825804 	addi	r2,r2,2400
811003ac:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811003b0:	00a00034 	movhi	r2,32768
811003b4:	10825c04 	addi	r2,r2,2416
811003b8:	e0bffb15 	stw	r2,-20(fp)
		break;
811003bc:	00001206 	br	81100408 <bDdr2EepromTest+0x100>
	default:
		bSuccess = FALSE;
811003c0:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811003c4:	00e04574 	movhi	r3,33045
811003c8:	18c97504 	addi	r3,r3,9684
811003cc:	00a04574 	movhi	r2,33045
811003d0:	10a9bc04 	addi	r2,r2,-22800
811003d4:	1009883a 	mov	r4,r2
811003d8:	00800bc4 	movi	r2,47
811003dc:	100d883a 	mov	r6,r2
811003e0:	200b883a 	mov	r5,r4
811003e4:	1809883a 	mov	r4,r3
811003e8:	11218680 	call	81121868 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811003ec:	d0a06117 	ldw	r2,-32380(gp)
811003f0:	01604574 	movhi	r5,33045
811003f4:	29497504 	addi	r5,r5,9684
811003f8:	1009883a 	mov	r4,r2
811003fc:	11207b80 	call	811207b8 <fprintf>
		;
#endif
		return bSuccess;
81100400:	e0bff917 	ldw	r2,-28(fp)
81100404:	0000ff06 	br	81100804 <bDdr2EepromTest+0x4fc>
	}

	alt_u8 ucControlAddr, ucValue;
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
81100408:	00e04574 	movhi	r3,33045
8110040c:	18c97504 	addi	r3,r3,9684
81100410:	00a04574 	movhi	r2,33045
81100414:	10a9c804 	addi	r2,r2,-22752
81100418:	1009883a 	mov	r4,r2
8110041c:	008005c4 	movi	r2,23
81100420:	100d883a 	mov	r6,r2
81100424:	200b883a 	mov	r5,r4
81100428:	1809883a 	mov	r4,r3
8110042c:	11218680 	call	81121868 <memcpy>
	debug(fp, cDebugBuffer);
81100430:	d0a06117 	ldw	r2,-32380(gp)
81100434:	01604574 	movhi	r5,33045
81100438:	29497504 	addi	r5,r5,9684
8110043c:	1009883a 	mov	r4,r2
81100440:	11207b80 	call	811207b8 <fprintf>
#endif
	usleep(20 * 1000);
81100444:	01138804 	movi	r4,20000
81100448:	1136ed00 	call	81136ed0 <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
8110044c:	e03ffc15 	stw	zero,-16(fp)
81100450:	00003306 	br	81100520 <bDdr2EepromTest+0x218>
		ucControlAddr = iI;
81100454:	e0bffc17 	ldw	r2,-16(fp)
81100458:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110045c:	e0bffd03 	ldbu	r2,-12(fp)
81100460:	10c03fcc 	andi	r3,r2,255
81100464:	18c0201c 	xori	r3,r3,128
81100468:	18ffe004 	addi	r3,r3,-128
8110046c:	e13ffd43 	ldbu	r4,-11(fp)
81100470:	e0bffe04 	addi	r2,fp,-8
81100474:	d8800015 	stw	r2,0(sp)
81100478:	200f883a 	mov	r7,r4
8110047c:	180d883a 	mov	r6,r3
81100480:	e17ffb17 	ldw	r5,-20(fp)
81100484:	e13ffa17 	ldw	r4,-24(fp)
81100488:	110ac3c0 	call	8110ac3c <I2C_Read>
8110048c:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
81100490:	e0bff917 	ldw	r2,-28(fp)
81100494:	10001026 	beq	r2,zero,811004d8 <bDdr2EepromTest+0x1d0>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
81100498:	e0bffd43 	ldbu	r2,-11(fp)
8110049c:	e0fffe03 	ldbu	r3,-8(fp)
811004a0:	18c03fcc 	andi	r3,r3,255
811004a4:	180f883a 	mov	r7,r3
811004a8:	100d883a 	mov	r6,r2
811004ac:	01604574 	movhi	r5,33045
811004b0:	2969ce04 	addi	r5,r5,-22728
811004b4:	01204574 	movhi	r4,33045
811004b8:	21097504 	addi	r4,r4,9684
811004bc:	11221480 	call	81122148 <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
811004c0:	d0a06117 	ldw	r2,-32380(gp)
811004c4:	01604574 	movhi	r5,33045
811004c8:	29497504 	addi	r5,r5,9684
811004cc:	1009883a 	mov	r4,r2
811004d0:	11207b80 	call	811207b8 <fprintf>
811004d4:	00000f06 	br	81100514 <bDdr2EepromTest+0x20c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
811004d8:	00e04574 	movhi	r3,33045
811004dc:	18c97504 	addi	r3,r3,9684
811004e0:	00a04574 	movhi	r2,33045
811004e4:	10a9d304 	addi	r2,r2,-22708
811004e8:	1009883a 	mov	r4,r2
811004ec:	008005c4 	movi	r2,23
811004f0:	100d883a 	mov	r6,r2
811004f4:	200b883a 	mov	r5,r4
811004f8:	1809883a 	mov	r4,r3
811004fc:	11218680 	call	81121868 <memcpy>
			debug(fp, cDebugBuffer);
81100500:	d0a06117 	ldw	r2,-32380(gp)
81100504:	01604574 	movhi	r5,33045
81100508:	29497504 	addi	r5,r5,9684
8110050c:	1009883a 	mov	r4,r2
81100510:	11207b80 	call	811207b8 <fprintf>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100514:	e0bffc17 	ldw	r2,-16(fp)
81100518:	10800044 	addi	r2,r2,1
8110051c:	e0bffc15 	stw	r2,-16(fp)
81100520:	e0bffc17 	ldw	r2,-16(fp)
81100524:	10804008 	cmpgei	r2,r2,256
81100528:	1000021e 	bne	r2,zero,81100534 <bDdr2EepromTest+0x22c>
8110052c:	e0bff917 	ldw	r2,-28(fp)
81100530:	103fc81e 	bne	r2,zero,81100454 <__reset+0xfb0e0454>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
81100534:	e0bff917 	ldw	r2,-28(fp)
81100538:	10001026 	beq	r2,zero,8110057c <bDdr2EepromTest+0x274>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
8110053c:	00e04574 	movhi	r3,33045
81100540:	18c97504 	addi	r3,r3,9684
81100544:	00a04574 	movhi	r2,33045
81100548:	10a9d904 	addi	r2,r2,-22684
8110054c:	1009883a 	mov	r4,r2
81100550:	00800884 	movi	r2,34
81100554:	100d883a 	mov	r6,r2
81100558:	200b883a 	mov	r5,r4
8110055c:	1809883a 	mov	r4,r3
81100560:	11218680 	call	81121868 <memcpy>
		debug(fp, cDebugBuffer);
81100564:	d0a06117 	ldw	r2,-32380(gp)
81100568:	01604574 	movhi	r5,33045
8110056c:	29497504 	addi	r5,r5,9684
81100570:	1009883a 	mov	r4,r2
81100574:	11207b80 	call	811207b8 <fprintf>
81100578:	00000f06 	br	811005b8 <bDdr2EepromTest+0x2b0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
8110057c:	00e04574 	movhi	r3,33045
81100580:	18c97504 	addi	r3,r3,9684
81100584:	00a04574 	movhi	r2,33045
81100588:	10a9e204 	addi	r2,r2,-22648
8110058c:	1009883a 	mov	r4,r2
81100590:	008007c4 	movi	r2,31
81100594:	100d883a 	mov	r6,r2
81100598:	200b883a 	mov	r5,r4
8110059c:	1809883a 	mov	r4,r3
811005a0:	11218680 	call	81121868 <memcpy>
		debug(fp, cDebugBuffer);
811005a4:	d0a06117 	ldw	r2,-32380(gp)
811005a8:	01604574 	movhi	r5,33045
811005ac:	29497504 	addi	r5,r5,9684
811005b0:	1009883a 	mov	r4,r2
811005b4:	11207b80 	call	811207b8 <fprintf>
#endif
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
811005b8:	00e04574 	movhi	r3,33045
811005bc:	18c97504 	addi	r3,r3,9684
811005c0:	00a04574 	movhi	r2,33045
811005c4:	10a9ea04 	addi	r2,r2,-22616
811005c8:	1009883a 	mov	r4,r2
811005cc:	00800604 	movi	r2,24
811005d0:	100d883a 	mov	r6,r2
811005d4:	200b883a 	mov	r5,r4
811005d8:	1809883a 	mov	r4,r3
811005dc:	11218680 	call	81121868 <memcpy>
	debug(fp, cDebugBuffer);
811005e0:	d0a06117 	ldw	r2,-32380(gp)
811005e4:	01604574 	movhi	r5,33045
811005e8:	29497504 	addi	r5,r5,9684
811005ec:	1009883a 	mov	r4,r2
811005f0:	11207b80 	call	811207b8 <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
811005f4:	00800484 	movi	r2,18
811005f8:	e0bffd85 	stb	r2,-10(fp)
811005fc:	00bfe004 	movi	r2,-128
81100600:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100604:	01138804 	movi	r4,20000
81100608:	1136ed00 	call	81136ed0 <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110060c:	e0bffd03 	ldbu	r2,-12(fp)
81100610:	10c03fcc 	andi	r3,r2,255
81100614:	18c0201c 	xori	r3,r3,128
81100618:	18ffe004 	addi	r3,r3,-128
8110061c:	e13ffdc3 	ldbu	r4,-9(fp)
81100620:	e0bffd83 	ldbu	r2,-10(fp)
81100624:	d8800015 	stw	r2,0(sp)
81100628:	200f883a 	mov	r7,r4
8110062c:	180d883a 	mov	r6,r3
81100630:	e17ffb17 	ldw	r5,-20(fp)
81100634:	e13ffa17 	ldw	r4,-24(fp)
81100638:	110ab5c0 	call	8110ab5c <I2C_Write>
8110063c:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
81100640:	e0bff917 	ldw	r2,-28(fp)
81100644:	1000101e 	bne	r2,zero,81100688 <bDdr2EepromTest+0x380>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
81100648:	00e04574 	movhi	r3,33045
8110064c:	18c97504 	addi	r3,r3,9684
81100650:	00a04574 	movhi	r2,33045
81100654:	10a9f004 	addi	r2,r2,-22592
81100658:	1009883a 	mov	r4,r2
8110065c:	00800604 	movi	r2,24
81100660:	100d883a 	mov	r6,r2
81100664:	200b883a 	mov	r5,r4
81100668:	1809883a 	mov	r4,r3
8110066c:	11218680 	call	81121868 <memcpy>
		debug(fp, cDebugBuffer);
81100670:	d0a06117 	ldw	r2,-32380(gp)
81100674:	01604574 	movhi	r5,33045
81100678:	29497504 	addi	r5,r5,9684
8110067c:	1009883a 	mov	r4,r2
81100680:	11207b80 	call	811207b8 <fprintf>
81100684:	00003306 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100688:	e0bffd03 	ldbu	r2,-12(fp)
8110068c:	10c03fcc 	andi	r3,r2,255
81100690:	18c0201c 	xori	r3,r3,128
81100694:	18ffe004 	addi	r3,r3,-128
81100698:	e13ffdc3 	ldbu	r4,-9(fp)
8110069c:	e0bffe44 	addi	r2,fp,-7
811006a0:	d8800015 	stw	r2,0(sp)
811006a4:	200f883a 	mov	r7,r4
811006a8:	180d883a 	mov	r6,r3
811006ac:	e17ffb17 	ldw	r5,-20(fp)
811006b0:	e13ffa17 	ldw	r4,-24(fp)
811006b4:	110ac3c0 	call	8110ac3c <I2C_Read>
811006b8:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
811006bc:	e0bff917 	ldw	r2,-28(fp)
811006c0:	1000101e 	bne	r2,zero,81100704 <bDdr2EepromTest+0x3fc>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
811006c4:	00e04574 	movhi	r3,33045
811006c8:	18c97504 	addi	r3,r3,9684
811006cc:	00a04574 	movhi	r2,33045
811006d0:	10a9f604 	addi	r2,r2,-22568
811006d4:	1009883a 	mov	r4,r2
811006d8:	00800884 	movi	r2,34
811006dc:	100d883a 	mov	r6,r2
811006e0:	200b883a 	mov	r5,r4
811006e4:	1809883a 	mov	r4,r3
811006e8:	11218680 	call	81121868 <memcpy>
			debug(fp, cDebugBuffer);
811006ec:	d0a06117 	ldw	r2,-32380(gp)
811006f0:	01604574 	movhi	r5,33045
811006f4:	29497504 	addi	r5,r5,9684
811006f8:	1009883a 	mov	r4,r2
811006fc:	11207b80 	call	811207b8 <fprintf>
81100700:	00001406 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100704:	e0bffe43 	ldbu	r2,-7(fp)
81100708:	10c03fcc 	andi	r3,r2,255
8110070c:	e0bffd83 	ldbu	r2,-10(fp)
81100710:	18801026 	beq	r3,r2,81100754 <bDdr2EepromTest+0x44c>
				bSuccess = FALSE;
81100714:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100718:	e0bffe43 	ldbu	r2,-7(fp)
8110071c:	10803fcc 	andi	r2,r2,255
81100720:	e0fffd83 	ldbu	r3,-10(fp)
81100724:	180f883a 	mov	r7,r3
81100728:	100d883a 	mov	r6,r2
8110072c:	01604574 	movhi	r5,33045
81100730:	2969ff04 	addi	r5,r5,-22532
81100734:	01204574 	movhi	r4,33045
81100738:	21097504 	addi	r4,r4,9684
8110073c:	11221480 	call	81122148 <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
81100740:	d0a06117 	ldw	r2,-32380(gp)
81100744:	01604574 	movhi	r5,33045
81100748:	29497504 	addi	r5,r5,9684
8110074c:	1009883a 	mov	r4,r2
81100750:	11207b80 	call	811207b8 <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
81100754:	e0bff917 	ldw	r2,-28(fp)
81100758:	10001026 	beq	r2,zero,8110079c <bDdr2EepromTest+0x494>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
8110075c:	00e04574 	movhi	r3,33045
81100760:	18c97504 	addi	r3,r3,9684
81100764:	00a04574 	movhi	r2,33045
81100768:	10aa0e04 	addi	r2,r2,-22472
8110076c:	1009883a 	mov	r4,r2
81100770:	008008c4 	movi	r2,35
81100774:	100d883a 	mov	r6,r2
81100778:	200b883a 	mov	r5,r4
8110077c:	1809883a 	mov	r4,r3
81100780:	11218680 	call	81121868 <memcpy>
		debug(fp, cDebugBuffer);
81100784:	d0a06117 	ldw	r2,-32380(gp)
81100788:	01604574 	movhi	r5,33045
8110078c:	29497504 	addi	r5,r5,9684
81100790:	1009883a 	mov	r4,r2
81100794:	11207b80 	call	811207b8 <fprintf>
81100798:	00000f06 	br	811007d8 <bDdr2EepromTest+0x4d0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
8110079c:	00e04574 	movhi	r3,33045
811007a0:	18c97504 	addi	r3,r3,9684
811007a4:	00a04574 	movhi	r2,33045
811007a8:	10aa1704 	addi	r2,r2,-22436
811007ac:	1009883a 	mov	r4,r2
811007b0:	00800804 	movi	r2,32
811007b4:	100d883a 	mov	r6,r2
811007b8:	200b883a 	mov	r5,r4
811007bc:	1809883a 	mov	r4,r3
811007c0:	11218680 	call	81121868 <memcpy>
		debug(fp, cDebugBuffer);
811007c4:	d0a06117 	ldw	r2,-32380(gp)
811007c8:	01604574 	movhi	r5,33045
811007cc:	29497504 	addi	r5,r5,9684
811007d0:	1009883a 	mov	r4,r2
811007d4:	11207b80 	call	811207b8 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811007d8:	00a04574 	movhi	r2,33045
811007dc:	10897504 	addi	r2,r2,9684
811007e0:	00c00284 	movi	r3,10
811007e4:	10c00005 	stb	r3,0(r2)
811007e8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811007ec:	d0a06117 	ldw	r2,-32380(gp)
811007f0:	01604574 	movhi	r5,33045
811007f4:	29497504 	addi	r5,r5,9684
811007f8:	1009883a 	mov	r4,r2
811007fc:	11207b80 	call	811207b8 <fprintf>
#endif

	return bSuccess;
81100800:	e0bff917 	ldw	r2,-28(fp)
}
81100804:	e037883a 	mov	sp,fp
81100808:	dfc00117 	ldw	ra,4(sp)
8110080c:	df000017 	ldw	fp,0(sp)
81100810:	dec00204 	addi	sp,sp,8
81100814:	f800283a 	ret

81100818 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
81100818:	deffb704 	addi	sp,sp,-292
8110081c:	de00012e 	bgeu	sp,et,81100824 <bDdr2EepromDump+0xc>
81100820:	003b68fa 	trap	3
81100824:	dfc04815 	stw	ra,288(sp)
81100828:	df004715 	stw	fp,284(sp)
8110082c:	df004704 	addi	fp,sp,284
81100830:	2005883a 	mov	r2,r4
81100834:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
81100838:	00e04574 	movhi	r3,33045
8110083c:	18c97504 	addi	r3,r3,9684
81100840:	00a04574 	movhi	r2,33045
81100844:	10aa1f04 	addi	r2,r2,-22404
81100848:	1009883a 	mov	r4,r2
8110084c:	00800884 	movi	r2,34
81100850:	100d883a 	mov	r6,r2
81100854:	200b883a 	mov	r5,r4
81100858:	1809883a 	mov	r4,r3
8110085c:	11218680 	call	81121868 <memcpy>
	debug(fp, cDebugBuffer);
81100860:	d0a06117 	ldw	r2,-32380(gp)
81100864:	01604574 	movhi	r5,33045
81100868:	29497504 	addi	r5,r5,9684
8110086c:	1009883a 	mov	r4,r2
81100870:	11207b80 	call	811207b8 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100874:	00bfe804 	movi	r2,-96
81100878:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110087c:	00800044 	movi	r2,1
81100880:	e0bfbe15 	stw	r2,-264(fp)
	switch (ucMemoryId) {
81100884:	e0bfff03 	ldbu	r2,-4(fp)
81100888:	10000326 	beq	r2,zero,81100898 <bDdr2EepromDump+0x80>
8110088c:	10800060 	cmpeqi	r2,r2,1
81100890:	1000081e 	bne	r2,zero,811008b4 <bDdr2EepromDump+0x9c>
81100894:	00000e06 	br	811008d0 <bDdr2EepromDump+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100898:	00a00034 	movhi	r2,32768
8110089c:	10827c04 	addi	r2,r2,2544
811008a0:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
811008a4:	00a00034 	movhi	r2,32768
811008a8:	10828004 	addi	r2,r2,2560
811008ac:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008b0:	00001906 	br	81100918 <bDdr2EepromDump+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811008b4:	00a00034 	movhi	r2,32768
811008b8:	10825804 	addi	r2,r2,2400
811008bc:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811008c0:	00a00034 	movhi	r2,32768
811008c4:	10825c04 	addi	r2,r2,2416
811008c8:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008cc:	00001206 	br	81100918 <bDdr2EepromDump+0x100>
	default:
		bSuccess = FALSE;
811008d0:	e03fbe15 	stw	zero,-264(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811008d4:	00e04574 	movhi	r3,33045
811008d8:	18c97504 	addi	r3,r3,9684
811008dc:	00a04574 	movhi	r2,33045
811008e0:	10aa2804 	addi	r2,r2,-22368
811008e4:	1009883a 	mov	r4,r2
811008e8:	00800bc4 	movi	r2,47
811008ec:	100d883a 	mov	r6,r2
811008f0:	200b883a 	mov	r5,r4
811008f4:	1809883a 	mov	r4,r3
811008f8:	11218680 	call	81121868 <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
811008fc:	d0a06117 	ldw	r2,-32380(gp)
81100900:	01604574 	movhi	r5,33045
81100904:	29497504 	addi	r5,r5,9684
81100908:	1009883a 	mov	r4,r2
8110090c:	11207b80 	call	811207b8 <fprintf>
		;
#endif
		return bSuccess;
81100910:	e0bfbe17 	ldw	r2,-264(fp)
81100914:	0002e706 	br	811014b4 <bDdr2EepromDump+0xc9c>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100918:	e0bfbd03 	ldbu	r2,-268(fp)
8110091c:	10c03fcc 	andi	r3,r2,255
81100920:	18c0201c 	xori	r3,r3,128
81100924:	18ffe004 	addi	r3,r3,-128
81100928:	e13fbf04 	addi	r4,fp,-260
8110092c:	00804004 	movi	r2,256
81100930:	d8800015 	stw	r2,0(sp)
81100934:	200f883a 	mov	r7,r4
81100938:	180d883a 	mov	r6,r3
8110093c:	e17fbb17 	ldw	r5,-276(fp)
81100940:	e13fba17 	ldw	r4,-280(fp)
81100944:	110ad440 	call	8110ad44 <I2C_MultipleRead>
81100948:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
8110094c:	e0bfbe17 	ldw	r2,-264(fp)
81100950:	1002be26 	beq	r2,zero,8110144c <bDdr2EepromDump+0xc34>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81100954:	e03fbc15 	stw	zero,-272(fp)
81100958:	0002b606 	br	81101434 <bDdr2EepromDump+0xc1c>
			if (iI == 0) {
8110095c:	e0bfbc17 	ldw	r2,-272(fp)
81100960:	1000121e 	bne	r2,zero,811009ac <bDdr2EepromDump+0x194>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
81100964:	e0ffbf04 	addi	r3,fp,-260
81100968:	e0bfbc17 	ldw	r2,-272(fp)
8110096c:	1885883a 	add	r2,r3,r2
81100970:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100974:	10803fcc 	andi	r2,r2,255
81100978:	100f883a 	mov	r7,r2
8110097c:	e1bfbc17 	ldw	r6,-272(fp)
81100980:	01604574 	movhi	r5,33045
81100984:	296a3404 	addi	r5,r5,-22320
81100988:	01204574 	movhi	r4,33045
8110098c:	21097504 	addi	r4,r4,9684
81100990:	11221480 	call	81122148 <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
81100994:	d0a06117 	ldw	r2,-32380(gp)
81100998:	01604574 	movhi	r5,33045
8110099c:	29497504 	addi	r5,r5,9684
811009a0:	1009883a 	mov	r4,r2
811009a4:	11207b80 	call	811207b8 <fprintf>
811009a8:	00029f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 1) {
811009ac:	e0bfbc17 	ldw	r2,-272(fp)
811009b0:	10800058 	cmpnei	r2,r2,1
811009b4:	1000101e 	bne	r2,zero,811009f8 <bDdr2EepromDump+0x1e0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811009b8:	00e04574 	movhi	r3,33045
811009bc:	18c97504 	addi	r3,r3,9684
811009c0:	00a04574 	movhi	r2,33045
811009c4:	10aa4004 	addi	r2,r2,-22272
811009c8:	1009883a 	mov	r4,r2
811009cc:	00800c04 	movi	r2,48
811009d0:	100d883a 	mov	r6,r2
811009d4:	200b883a 	mov	r5,r4
811009d8:	1809883a 	mov	r4,r3
811009dc:	11218680 	call	81121868 <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
811009e0:	d0a06117 	ldw	r2,-32380(gp)
811009e4:	01604574 	movhi	r5,33045
811009e8:	29497504 	addi	r5,r5,9684
811009ec:	1009883a 	mov	r4,r2
811009f0:	11207b80 	call	811207b8 <fprintf>
811009f4:	00028c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 2) {
811009f8:	e0bfbc17 	ldw	r2,-272(fp)
811009fc:	10800098 	cmpnei	r2,r2,2
81100a00:	1000101e 	bne	r2,zero,81100a44 <bDdr2EepromDump+0x22c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
81100a04:	00e04574 	movhi	r3,33045
81100a08:	18c97504 	addi	r3,r3,9684
81100a0c:	00a04574 	movhi	r2,33045
81100a10:	10aa4c04 	addi	r2,r2,-22224
81100a14:	1009883a 	mov	r4,r2
81100a18:	008007c4 	movi	r2,31
81100a1c:	100d883a 	mov	r6,r2
81100a20:	200b883a 	mov	r5,r4
81100a24:	1809883a 	mov	r4,r3
81100a28:	11218680 	call	81121868 <memcpy>
				debug(fp, cDebugBuffer);
81100a2c:	d0a06117 	ldw	r2,-32380(gp)
81100a30:	01604574 	movhi	r5,33045
81100a34:	29497504 	addi	r5,r5,9684
81100a38:	1009883a 	mov	r4,r2
81100a3c:	11207b80 	call	811207b8 <fprintf>
81100a40:	00027906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 3) {
81100a44:	e0bfbc17 	ldw	r2,-272(fp)
81100a48:	108000d8 	cmpnei	r2,r2,3
81100a4c:	1000101e 	bne	r2,zero,81100a90 <bDdr2EepromDump+0x278>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a50:	00e04574 	movhi	r3,33045
81100a54:	18c97504 	addi	r3,r3,9684
81100a58:	00a04574 	movhi	r2,33045
81100a5c:	10aa5404 	addi	r2,r2,-22192
81100a60:	1009883a 	mov	r4,r2
81100a64:	008009c4 	movi	r2,39
81100a68:	100d883a 	mov	r6,r2
81100a6c:	200b883a 	mov	r5,r4
81100a70:	1809883a 	mov	r4,r3
81100a74:	11218680 	call	81121868 <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a78:	d0a06117 	ldw	r2,-32380(gp)
81100a7c:	01604574 	movhi	r5,33045
81100a80:	29497504 	addi	r5,r5,9684
81100a84:	1009883a 	mov	r4,r2
81100a88:	11207b80 	call	811207b8 <fprintf>
81100a8c:	00026606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 4) {
81100a90:	e0bfbc17 	ldw	r2,-272(fp)
81100a94:	10800118 	cmpnei	r2,r2,4
81100a98:	1000101e 	bne	r2,zero,81100adc <bDdr2EepromDump+0x2c4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a9c:	00e04574 	movhi	r3,33045
81100aa0:	18c97504 	addi	r3,r3,9684
81100aa4:	00a04574 	movhi	r2,33045
81100aa8:	10aa5e04 	addi	r2,r2,-22152
81100aac:	1009883a 	mov	r4,r2
81100ab0:	00800a84 	movi	r2,42
81100ab4:	100d883a 	mov	r6,r2
81100ab8:	200b883a 	mov	r5,r4
81100abc:	1809883a 	mov	r4,r3
81100ac0:	11218680 	call	81121868 <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100ac4:	d0a06117 	ldw	r2,-32380(gp)
81100ac8:	01604574 	movhi	r5,33045
81100acc:	29497504 	addi	r5,r5,9684
81100ad0:	1009883a 	mov	r4,r2
81100ad4:	11207b80 	call	811207b8 <fprintf>
81100ad8:	00025306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 5) {
81100adc:	e0bfbc17 	ldw	r2,-272(fp)
81100ae0:	10800158 	cmpnei	r2,r2,5
81100ae4:	1000101e 	bne	r2,zero,81100b28 <bDdr2EepromDump+0x310>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ae8:	00e04574 	movhi	r3,33045
81100aec:	18c97504 	addi	r3,r3,9684
81100af0:	00a04574 	movhi	r2,33045
81100af4:	10aa6904 	addi	r2,r2,-22108
81100af8:	1009883a 	mov	r4,r2
81100afc:	00800c04 	movi	r2,48
81100b00:	100d883a 	mov	r6,r2
81100b04:	200b883a 	mov	r5,r4
81100b08:	1809883a 	mov	r4,r3
81100b0c:	11218680 	call	81121868 <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100b10:	d0a06117 	ldw	r2,-32380(gp)
81100b14:	01604574 	movhi	r5,33045
81100b18:	29497504 	addi	r5,r5,9684
81100b1c:	1009883a 	mov	r4,r2
81100b20:	11207b80 	call	811207b8 <fprintf>
81100b24:	00024006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 6) {
81100b28:	e0bfbc17 	ldw	r2,-272(fp)
81100b2c:	10800198 	cmpnei	r2,r2,6
81100b30:	1000101e 	bne	r2,zero,81100b74 <bDdr2EepromDump+0x35c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100b34:	00e04574 	movhi	r3,33045
81100b38:	18c97504 	addi	r3,r3,9684
81100b3c:	00a04574 	movhi	r2,33045
81100b40:	10aa7504 	addi	r2,r2,-22060
81100b44:	1009883a 	mov	r4,r2
81100b48:	00800544 	movi	r2,21
81100b4c:	100d883a 	mov	r6,r2
81100b50:	200b883a 	mov	r5,r4
81100b54:	1809883a 	mov	r4,r3
81100b58:	11218680 	call	81121868 <memcpy>
				debug(fp, cDebugBuffer);
81100b5c:	d0a06117 	ldw	r2,-32380(gp)
81100b60:	01604574 	movhi	r5,33045
81100b64:	29497504 	addi	r5,r5,9684
81100b68:	1009883a 	mov	r4,r2
81100b6c:	11207b80 	call	811207b8 <fprintf>
81100b70:	00022d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 7) {
81100b74:	e0bfbc17 	ldw	r2,-272(fp)
81100b78:	108001d8 	cmpnei	r2,r2,7
81100b7c:	1000101e 	bne	r2,zero,81100bc0 <bDdr2EepromDump+0x3a8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b80:	00e04574 	movhi	r3,33045
81100b84:	18c97504 	addi	r3,r3,9684
81100b88:	00a04574 	movhi	r2,33045
81100b8c:	10aa7b04 	addi	r2,r2,-22036
81100b90:	1009883a 	mov	r4,r2
81100b94:	00800804 	movi	r2,32
81100b98:	100d883a 	mov	r6,r2
81100b9c:	200b883a 	mov	r5,r4
81100ba0:	1809883a 	mov	r4,r3
81100ba4:	11218680 	call	81121868 <memcpy>
				debug(fp, cDebugBuffer);
81100ba8:	d0a06117 	ldw	r2,-32380(gp)
81100bac:	01604574 	movhi	r5,33045
81100bb0:	29497504 	addi	r5,r5,9684
81100bb4:	1009883a 	mov	r4,r2
81100bb8:	11207b80 	call	811207b8 <fprintf>
81100bbc:	00021a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 16) {
81100bc0:	e0bfbc17 	ldw	r2,-272(fp)
81100bc4:	10800418 	cmpnei	r2,r2,16
81100bc8:	1000101e 	bne	r2,zero,81100c0c <bDdr2EepromDump+0x3f4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100bcc:	00e04574 	movhi	r3,33045
81100bd0:	18c97504 	addi	r3,r3,9684
81100bd4:	00a04574 	movhi	r2,33045
81100bd8:	10aa8304 	addi	r2,r2,-22004
81100bdc:	1009883a 	mov	r4,r2
81100be0:	00800d04 	movi	r2,52
81100be4:	100d883a 	mov	r6,r2
81100be8:	200b883a 	mov	r5,r4
81100bec:	1809883a 	mov	r4,r3
81100bf0:	11218680 	call	81121868 <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100bf4:	d0a06117 	ldw	r2,-32380(gp)
81100bf8:	01604574 	movhi	r5,33045
81100bfc:	29497504 	addi	r5,r5,9684
81100c00:	1009883a 	mov	r4,r2
81100c04:	11207b80 	call	811207b8 <fprintf>
81100c08:	00020706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 13) {
81100c0c:	e0bfbc17 	ldw	r2,-272(fp)
81100c10:	10800358 	cmpnei	r2,r2,13
81100c14:	1000101e 	bne	r2,zero,81100c58 <bDdr2EepromDump+0x440>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100c18:	00e04574 	movhi	r3,33045
81100c1c:	18c97504 	addi	r3,r3,9684
81100c20:	00a04574 	movhi	r2,33045
81100c24:	10aa9004 	addi	r2,r2,-21952
81100c28:	1009883a 	mov	r4,r2
81100c2c:	008005c4 	movi	r2,23
81100c30:	100d883a 	mov	r6,r2
81100c34:	200b883a 	mov	r5,r4
81100c38:	1809883a 	mov	r4,r3
81100c3c:	11218680 	call	81121868 <memcpy>
				debug(fp, cDebugBuffer);
81100c40:	d0a06117 	ldw	r2,-32380(gp)
81100c44:	01604574 	movhi	r5,33045
81100c48:	29497504 	addi	r5,r5,9684
81100c4c:	1009883a 	mov	r4,r2
81100c50:	11207b80 	call	811207b8 <fprintf>
81100c54:	0001f406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 14) {
81100c58:	e0bfbc17 	ldw	r2,-272(fp)
81100c5c:	10800398 	cmpnei	r2,r2,14
81100c60:	1000101e 	bne	r2,zero,81100ca4 <bDdr2EepromDump+0x48c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100c64:	00e04574 	movhi	r3,33045
81100c68:	18c97504 	addi	r3,r3,9684
81100c6c:	00a04574 	movhi	r2,33045
81100c70:	10aa9604 	addi	r2,r2,-21928
81100c74:	1009883a 	mov	r4,r2
81100c78:	008004c4 	movi	r2,19
81100c7c:	100d883a 	mov	r6,r2
81100c80:	200b883a 	mov	r5,r4
81100c84:	1809883a 	mov	r4,r3
81100c88:	11218680 	call	81121868 <memcpy>
				debug(fp, cDebugBuffer);
81100c8c:	d0a06117 	ldw	r2,-32380(gp)
81100c90:	01604574 	movhi	r5,33045
81100c94:	29497504 	addi	r5,r5,9684
81100c98:	1009883a 	mov	r4,r2
81100c9c:	11207b80 	call	811207b8 <fprintf>
81100ca0:	0001e106 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 17) {
81100ca4:	e0bfbc17 	ldw	r2,-272(fp)
81100ca8:	10800458 	cmpnei	r2,r2,17
81100cac:	1000101e 	bne	r2,zero,81100cf0 <bDdr2EepromDump+0x4d8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100cb0:	00e04574 	movhi	r3,33045
81100cb4:	18c97504 	addi	r3,r3,9684
81100cb8:	00a04574 	movhi	r2,33045
81100cbc:	10aa9b04 	addi	r2,r2,-21908
81100cc0:	1009883a 	mov	r4,r2
81100cc4:	00800684 	movi	r2,26
81100cc8:	100d883a 	mov	r6,r2
81100ccc:	200b883a 	mov	r5,r4
81100cd0:	1809883a 	mov	r4,r3
81100cd4:	11218680 	call	81121868 <memcpy>
				debug(fp, cDebugBuffer);
81100cd8:	d0a06117 	ldw	r2,-32380(gp)
81100cdc:	01604574 	movhi	r5,33045
81100ce0:	29497504 	addi	r5,r5,9684
81100ce4:	1009883a 	mov	r4,r2
81100ce8:	11207b80 	call	811207b8 <fprintf>
81100cec:	0001ce06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 18) {
81100cf0:	e0bfbc17 	ldw	r2,-272(fp)
81100cf4:	10800498 	cmpnei	r2,r2,18
81100cf8:	1000101e 	bne	r2,zero,81100d3c <bDdr2EepromDump+0x524>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100cfc:	00e04574 	movhi	r3,33045
81100d00:	18c97504 	addi	r3,r3,9684
81100d04:	00a04574 	movhi	r2,33045
81100d08:	10aaa204 	addi	r2,r2,-21880
81100d0c:	1009883a 	mov	r4,r2
81100d10:	00800d44 	movi	r2,53
81100d14:	100d883a 	mov	r6,r2
81100d18:	200b883a 	mov	r5,r4
81100d1c:	1809883a 	mov	r4,r3
81100d20:	11218680 	call	81121868 <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100d24:	d0a06117 	ldw	r2,-32380(gp)
81100d28:	01604574 	movhi	r5,33045
81100d2c:	29497504 	addi	r5,r5,9684
81100d30:	1009883a 	mov	r4,r2
81100d34:	11207b80 	call	811207b8 <fprintf>
81100d38:	0001bb06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 20) {
81100d3c:	e0bfbc17 	ldw	r2,-272(fp)
81100d40:	10800518 	cmpnei	r2,r2,20
81100d44:	1000101e 	bne	r2,zero,81100d88 <bDdr2EepromDump+0x570>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100d48:	00e04574 	movhi	r3,33045
81100d4c:	18c97504 	addi	r3,r3,9684
81100d50:	00a04574 	movhi	r2,33045
81100d54:	10aab004 	addi	r2,r2,-21824
81100d58:	1009883a 	mov	r4,r2
81100d5c:	00801204 	movi	r2,72
81100d60:	100d883a 	mov	r6,r2
81100d64:	200b883a 	mov	r5,r4
81100d68:	1809883a 	mov	r4,r3
81100d6c:	11218680 	call	81121868 <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d70:	d0a06117 	ldw	r2,-32380(gp)
81100d74:	01604574 	movhi	r5,33045
81100d78:	29497504 	addi	r5,r5,9684
81100d7c:	1009883a 	mov	r4,r2
81100d80:	11207b80 	call	811207b8 <fprintf>
81100d84:	0001a806 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 22) {
81100d88:	e0bfbc17 	ldw	r2,-272(fp)
81100d8c:	10800598 	cmpnei	r2,r2,22
81100d90:	1000101e 	bne	r2,zero,81100dd4 <bDdr2EepromDump+0x5bc>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100d94:	00e04574 	movhi	r3,33045
81100d98:	18c97504 	addi	r3,r3,9684
81100d9c:	00a04574 	movhi	r2,33045
81100da0:	10aac204 	addi	r2,r2,-21752
81100da4:	1009883a 	mov	r4,r2
81100da8:	00800784 	movi	r2,30
81100dac:	100d883a 	mov	r6,r2
81100db0:	200b883a 	mov	r5,r4
81100db4:	1809883a 	mov	r4,r3
81100db8:	11218680 	call	81121868 <memcpy>
				debug(fp, cDebugBuffer);
81100dbc:	d0a06117 	ldw	r2,-32380(gp)
81100dc0:	01604574 	movhi	r5,33045
81100dc4:	29497504 	addi	r5,r5,9684
81100dc8:	1009883a 	mov	r4,r2
81100dcc:	11207b80 	call	811207b8 <fprintf>
81100dd0:	00019506 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 27) {
81100dd4:	e0bfbc17 	ldw	r2,-272(fp)
81100dd8:	108006d8 	cmpnei	r2,r2,27
81100ddc:	1000101e 	bne	r2,zero,81100e20 <bDdr2EepromDump+0x608>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100de0:	00e04574 	movhi	r3,33045
81100de4:	18c97504 	addi	r3,r3,9684
81100de8:	00a04574 	movhi	r2,33045
81100dec:	10aaca04 	addi	r2,r2,-21720
81100df0:	1009883a 	mov	r4,r2
81100df4:	00800a04 	movi	r2,40
81100df8:	100d883a 	mov	r6,r2
81100dfc:	200b883a 	mov	r5,r4
81100e00:	1809883a 	mov	r4,r3
81100e04:	11218680 	call	81121868 <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e08:	d0a06117 	ldw	r2,-32380(gp)
81100e0c:	01604574 	movhi	r5,33045
81100e10:	29497504 	addi	r5,r5,9684
81100e14:	1009883a 	mov	r4,r2
81100e18:	11207b80 	call	811207b8 <fprintf>
81100e1c:	00018206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 28) {
81100e20:	e0bfbc17 	ldw	r2,-272(fp)
81100e24:	10800718 	cmpnei	r2,r2,28
81100e28:	1000101e 	bne	r2,zero,81100e6c <bDdr2EepromDump+0x654>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e2c:	00e04574 	movhi	r3,33045
81100e30:	18c97504 	addi	r3,r3,9684
81100e34:	00a04574 	movhi	r2,33045
81100e38:	10aad404 	addi	r2,r2,-21680
81100e3c:	1009883a 	mov	r4,r2
81100e40:	00800cc4 	movi	r2,51
81100e44:	100d883a 	mov	r6,r2
81100e48:	200b883a 	mov	r5,r4
81100e4c:	1809883a 	mov	r4,r3
81100e50:	11218680 	call	81121868 <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e54:	d0a06117 	ldw	r2,-32380(gp)
81100e58:	01604574 	movhi	r5,33045
81100e5c:	29497504 	addi	r5,r5,9684
81100e60:	1009883a 	mov	r4,r2
81100e64:	11207b80 	call	811207b8 <fprintf>
81100e68:	00016f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 29) {
81100e6c:	e0bfbc17 	ldw	r2,-272(fp)
81100e70:	10800758 	cmpnei	r2,r2,29
81100e74:	1000101e 	bne	r2,zero,81100eb8 <bDdr2EepromDump+0x6a0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e78:	00e04574 	movhi	r3,33045
81100e7c:	18c97504 	addi	r3,r3,9684
81100e80:	00a04574 	movhi	r2,33045
81100e84:	10aae104 	addi	r2,r2,-21628
81100e88:	1009883a 	mov	r4,r2
81100e8c:	008009c4 	movi	r2,39
81100e90:	100d883a 	mov	r6,r2
81100e94:	200b883a 	mov	r5,r4
81100e98:	1809883a 	mov	r4,r3
81100e9c:	11218680 	call	81121868 <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100ea0:	d0a06117 	ldw	r2,-32380(gp)
81100ea4:	01604574 	movhi	r5,33045
81100ea8:	29497504 	addi	r5,r5,9684
81100eac:	1009883a 	mov	r4,r2
81100eb0:	11207b80 	call	811207b8 <fprintf>
81100eb4:	00015c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 30) {
81100eb8:	e0bfbc17 	ldw	r2,-272(fp)
81100ebc:	10800798 	cmpnei	r2,r2,30
81100ec0:	1000101e 	bne	r2,zero,81100f04 <bDdr2EepromDump+0x6ec>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ec4:	00e04574 	movhi	r3,33045
81100ec8:	18c97504 	addi	r3,r3,9684
81100ecc:	00a04574 	movhi	r2,33045
81100ed0:	10aaeb04 	addi	r2,r2,-21588
81100ed4:	1009883a 	mov	r4,r2
81100ed8:	00800b04 	movi	r2,44
81100edc:	100d883a 	mov	r6,r2
81100ee0:	200b883a 	mov	r5,r4
81100ee4:	1809883a 	mov	r4,r3
81100ee8:	11218680 	call	81121868 <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100eec:	d0a06117 	ldw	r2,-32380(gp)
81100ef0:	01604574 	movhi	r5,33045
81100ef4:	29497504 	addi	r5,r5,9684
81100ef8:	1009883a 	mov	r4,r2
81100efc:	11207b80 	call	811207b8 <fprintf>
81100f00:	00014906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 31) {
81100f04:	e0bfbc17 	ldw	r2,-272(fp)
81100f08:	108007d8 	cmpnei	r2,r2,31
81100f0c:	1000101e 	bne	r2,zero,81100f50 <bDdr2EepromDump+0x738>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f10:	00e04574 	movhi	r3,33045
81100f14:	18c97504 	addi	r3,r3,9684
81100f18:	00a04574 	movhi	r2,33045
81100f1c:	10aaf604 	addi	r2,r2,-21544
81100f20:	1009883a 	mov	r4,r2
81100f24:	008010c4 	movi	r2,67
81100f28:	100d883a 	mov	r6,r2
81100f2c:	200b883a 	mov	r5,r4
81100f30:	1809883a 	mov	r4,r3
81100f34:	11218680 	call	81121868 <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100f38:	d0a06117 	ldw	r2,-32380(gp)
81100f3c:	01604574 	movhi	r5,33045
81100f40:	29497504 	addi	r5,r5,9684
81100f44:	1009883a 	mov	r4,r2
81100f48:	11207b80 	call	811207b8 <fprintf>
81100f4c:	00013606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 36) {
81100f50:	e0bfbc17 	ldw	r2,-272(fp)
81100f54:	10800918 	cmpnei	r2,r2,36
81100f58:	1000101e 	bne	r2,zero,81100f9c <bDdr2EepromDump+0x784>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f5c:	00e04574 	movhi	r3,33045
81100f60:	18c97504 	addi	r3,r3,9684
81100f64:	00a04574 	movhi	r2,33045
81100f68:	10ab0704 	addi	r2,r2,-21476
81100f6c:	1009883a 	mov	r4,r2
81100f70:	00800a84 	movi	r2,42
81100f74:	100d883a 	mov	r6,r2
81100f78:	200b883a 	mov	r5,r4
81100f7c:	1809883a 	mov	r4,r3
81100f80:	11218680 	call	81121868 <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f84:	d0a06117 	ldw	r2,-32380(gp)
81100f88:	01604574 	movhi	r5,33045
81100f8c:	29497504 	addi	r5,r5,9684
81100f90:	1009883a 	mov	r4,r2
81100f94:	11207b80 	call	811207b8 <fprintf>
81100f98:	00012306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 37) {
81100f9c:	e0bfbc17 	ldw	r2,-272(fp)
81100fa0:	10800958 	cmpnei	r2,r2,37
81100fa4:	1000101e 	bne	r2,zero,81100fe8 <bDdr2EepromDump+0x7d0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100fa8:	00e04574 	movhi	r3,33045
81100fac:	18c97504 	addi	r3,r3,9684
81100fb0:	00a04574 	movhi	r2,33045
81100fb4:	10ab1204 	addi	r2,r2,-21432
81100fb8:	1009883a 	mov	r4,r2
81100fbc:	00800cc4 	movi	r2,51
81100fc0:	100d883a 	mov	r6,r2
81100fc4:	200b883a 	mov	r5,r4
81100fc8:	1809883a 	mov	r4,r3
81100fcc:	11218680 	call	81121868 <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fd0:	d0a06117 	ldw	r2,-32380(gp)
81100fd4:	01604574 	movhi	r5,33045
81100fd8:	29497504 	addi	r5,r5,9684
81100fdc:	1009883a 	mov	r4,r2
81100fe0:	11207b80 	call	811207b8 <fprintf>
81100fe4:	00011006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 38) {
81100fe8:	e0bfbc17 	ldw	r2,-272(fp)
81100fec:	10800998 	cmpnei	r2,r2,38
81100ff0:	1000101e 	bne	r2,zero,81101034 <bDdr2EepromDump+0x81c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ff4:	00e04574 	movhi	r3,33045
81100ff8:	18c97504 	addi	r3,r3,9684
81100ffc:	00a04574 	movhi	r2,33045
81101000:	10ab1f04 	addi	r2,r2,-21380
81101004:	1009883a 	mov	r4,r2
81101008:	00800dc4 	movi	r2,55
8110100c:	100d883a 	mov	r6,r2
81101010:	200b883a 	mov	r5,r4
81101014:	1809883a 	mov	r4,r3
81101018:	11218680 	call	81121868 <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
8110101c:	d0a06117 	ldw	r2,-32380(gp)
81101020:	01604574 	movhi	r5,33045
81101024:	29497504 	addi	r5,r5,9684
81101028:	1009883a 	mov	r4,r2
8110102c:	11207b80 	call	811207b8 <fprintf>
81101030:	0000fd06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 41) {
81101034:	e0bfbc17 	ldw	r2,-272(fp)
81101038:	10800a58 	cmpnei	r2,r2,41
8110103c:	1000101e 	bne	r2,zero,81101080 <bDdr2EepromDump+0x868>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101040:	00e04574 	movhi	r3,33045
81101044:	18c97504 	addi	r3,r3,9684
81101048:	00a04574 	movhi	r2,33045
8110104c:	10ab2d04 	addi	r2,r2,-21324
81101050:	1009883a 	mov	r4,r2
81101054:	00800c84 	movi	r2,50
81101058:	100d883a 	mov	r6,r2
8110105c:	200b883a 	mov	r5,r4
81101060:	1809883a 	mov	r4,r3
81101064:	11218680 	call	81121868 <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101068:	d0a06117 	ldw	r2,-32380(gp)
8110106c:	01604574 	movhi	r5,33045
81101070:	29497504 	addi	r5,r5,9684
81101074:	1009883a 	mov	r4,r2
81101078:	11207b80 	call	811207b8 <fprintf>
8110107c:	0000ea06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 42) {
81101080:	e0bfbc17 	ldw	r2,-272(fp)
81101084:	10800a98 	cmpnei	r2,r2,42
81101088:	1000101e 	bne	r2,zero,811010cc <bDdr2EepromDump+0x8b4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110108c:	00e04574 	movhi	r3,33045
81101090:	18c97504 	addi	r3,r3,9684
81101094:	00a04574 	movhi	r2,33045
81101098:	10ab3a04 	addi	r2,r2,-21272
8110109c:	1009883a 	mov	r4,r2
811010a0:	00800cc4 	movi	r2,51
811010a4:	100d883a 	mov	r6,r2
811010a8:	200b883a 	mov	r5,r4
811010ac:	1809883a 	mov	r4,r3
811010b0:	11218680 	call	81121868 <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
811010b4:	d0a06117 	ldw	r2,-32380(gp)
811010b8:	01604574 	movhi	r5,33045
811010bc:	29497504 	addi	r5,r5,9684
811010c0:	1009883a 	mov	r4,r2
811010c4:	11207b80 	call	811207b8 <fprintf>
811010c8:	0000d706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 62) {
811010cc:	e0bfbc17 	ldw	r2,-272(fp)
811010d0:	10800f98 	cmpnei	r2,r2,62
811010d4:	1000101e 	bne	r2,zero,81101118 <bDdr2EepromDump+0x900>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
811010d8:	00e04574 	movhi	r3,33045
811010dc:	18c97504 	addi	r3,r3,9684
811010e0:	00a04574 	movhi	r2,33045
811010e4:	10ab4704 	addi	r2,r2,-21220
811010e8:	1009883a 	mov	r4,r2
811010ec:	00800404 	movi	r2,16
811010f0:	100d883a 	mov	r6,r2
811010f4:	200b883a 	mov	r5,r4
811010f8:	1809883a 	mov	r4,r3
811010fc:	11218680 	call	81121868 <memcpy>
				debug(fp, cDebugBuffer);
81101100:	d0a06117 	ldw	r2,-32380(gp)
81101104:	01604574 	movhi	r5,33045
81101108:	29497504 	addi	r5,r5,9684
8110110c:	1009883a 	mov	r4,r2
81101110:	11207b80 	call	811207b8 <fprintf>
81101114:	0000c406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 63) {
81101118:	e0bfbc17 	ldw	r2,-272(fp)
8110111c:	10800fd8 	cmpnei	r2,r2,63
81101120:	10001f1e 	bne	r2,zero,811011a0 <bDdr2EepromDump+0x988>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
81101124:	00a04574 	movhi	r2,33045
81101128:	10897504 	addi	r2,r2,9684
8110112c:	00c00a04 	movi	r3,40
81101130:	10c00005 	stb	r3,0(r2)
81101134:	00c010c4 	movi	r3,67
81101138:	10c00045 	stb	r3,1(r2)
8110113c:	00c01a04 	movi	r3,104
81101140:	10c00085 	stb	r3,2(r2)
81101144:	00c01944 	movi	r3,101
81101148:	10c000c5 	stb	r3,3(r2)
8110114c:	00c018c4 	movi	r3,99
81101150:	10c00105 	stb	r3,4(r2)
81101154:	00c01ac4 	movi	r3,107
81101158:	10c00145 	stb	r3,5(r2)
8110115c:	00c01cc4 	movi	r3,115
81101160:	10c00185 	stb	r3,6(r2)
81101164:	00c01d44 	movi	r3,117
81101168:	10c001c5 	stb	r3,7(r2)
8110116c:	00c01b44 	movi	r3,109
81101170:	10c00205 	stb	r3,8(r2)
81101174:	00c00a44 	movi	r3,41
81101178:	10c00245 	stb	r3,9(r2)
8110117c:	00c00284 	movi	r3,10
81101180:	10c00285 	stb	r3,10(r2)
81101184:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
81101188:	d0a06117 	ldw	r2,-32380(gp)
8110118c:	01604574 	movhi	r5,33045
81101190:	29497504 	addi	r5,r5,9684
81101194:	1009883a 	mov	r4,r2
81101198:	11207b80 	call	811207b8 <fprintf>
8110119c:	0000a206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 64) {
811011a0:	e0bfbc17 	ldw	r2,-272(fp)
811011a4:	10801018 	cmpnei	r2,r2,64
811011a8:	1000101e 	bne	r2,zero,811011ec <bDdr2EepromDump+0x9d4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
811011ac:	00e04574 	movhi	r3,33045
811011b0:	18c97504 	addi	r3,r3,9684
811011b4:	00a04574 	movhi	r2,33045
811011b8:	10ab4b04 	addi	r2,r2,-21204
811011bc:	1009883a 	mov	r4,r2
811011c0:	00800804 	movi	r2,32
811011c4:	100d883a 	mov	r6,r2
811011c8:	200b883a 	mov	r5,r4
811011cc:	1809883a 	mov	r4,r3
811011d0:	11218680 	call	81121868 <memcpy>
				debug(fp, cDebugBuffer);
811011d4:	d0a06117 	ldw	r2,-32380(gp)
811011d8:	01604574 	movhi	r5,33045
811011dc:	29497504 	addi	r5,r5,9684
811011e0:	1009883a 	mov	r4,r2
811011e4:	11207b80 	call	811207b8 <fprintf>
811011e8:	00008f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 72) {
811011ec:	e0bfbc17 	ldw	r2,-272(fp)
811011f0:	10801218 	cmpnei	r2,r2,72
811011f4:	1000101e 	bne	r2,zero,81101238 <bDdr2EepromDump+0xa20>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811011f8:	00e04574 	movhi	r3,33045
811011fc:	18c97504 	addi	r3,r3,9684
81101200:	00a04574 	movhi	r2,33045
81101204:	10ab5304 	addi	r2,r2,-21172
81101208:	1009883a 	mov	r4,r2
8110120c:	00800dc4 	movi	r2,55
81101210:	100d883a 	mov	r6,r2
81101214:	200b883a 	mov	r5,r4
81101218:	1809883a 	mov	r4,r3
8110121c:	11218680 	call	81121868 <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
81101220:	d0a06117 	ldw	r2,-32380(gp)
81101224:	01604574 	movhi	r5,33045
81101228:	29497504 	addi	r5,r5,9684
8110122c:	1009883a 	mov	r4,r2
81101230:	11207b80 	call	811207b8 <fprintf>
81101234:	00007c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 73) {
81101238:	e0bfbc17 	ldw	r2,-272(fp)
8110123c:	10801258 	cmpnei	r2,r2,73
81101240:	1000101e 	bne	r2,zero,81101284 <bDdr2EepromDump+0xa6c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
81101244:	00e04574 	movhi	r3,33045
81101248:	18c97504 	addi	r3,r3,9684
8110124c:	00a04574 	movhi	r2,33045
81101250:	10ab6104 	addi	r2,r2,-21116
81101254:	1009883a 	mov	r4,r2
81101258:	00800784 	movi	r2,30
8110125c:	100d883a 	mov	r6,r2
81101260:	200b883a 	mov	r5,r4
81101264:	1809883a 	mov	r4,r3
81101268:	11218680 	call	81121868 <memcpy>
				debug(fp, cDebugBuffer);
8110126c:	d0a06117 	ldw	r2,-32380(gp)
81101270:	01604574 	movhi	r5,33045
81101274:	29497504 	addi	r5,r5,9684
81101278:	1009883a 	mov	r4,r2
8110127c:	11207b80 	call	811207b8 <fprintf>
81101280:	00006906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 91) {
81101284:	e0bfbc17 	ldw	r2,-272(fp)
81101288:	108016d8 	cmpnei	r2,r2,91
8110128c:	1000101e 	bne	r2,zero,811012d0 <bDdr2EepromDump+0xab8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
81101290:	00e04574 	movhi	r3,33045
81101294:	18c97504 	addi	r3,r3,9684
81101298:	00a04574 	movhi	r2,33045
8110129c:	10ab6904 	addi	r2,r2,-21084
811012a0:	1009883a 	mov	r4,r2
811012a4:	00800804 	movi	r2,32
811012a8:	100d883a 	mov	r6,r2
811012ac:	200b883a 	mov	r5,r4
811012b0:	1809883a 	mov	r4,r3
811012b4:	11218680 	call	81121868 <memcpy>
				debug(fp, cDebugBuffer);
811012b8:	d0a06117 	ldw	r2,-32380(gp)
811012bc:	01604574 	movhi	r5,33045
811012c0:	29497504 	addi	r5,r5,9684
811012c4:	1009883a 	mov	r4,r2
811012c8:	11207b80 	call	811207b8 <fprintf>
811012cc:	00005606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 93) {
811012d0:	e0bfbc17 	ldw	r2,-272(fp)
811012d4:	10801758 	cmpnei	r2,r2,93
811012d8:	1000101e 	bne	r2,zero,8110131c <bDdr2EepromDump+0xb04>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811012dc:	00e04574 	movhi	r3,33045
811012e0:	18c97504 	addi	r3,r3,9684
811012e4:	00a04574 	movhi	r2,33045
811012e8:	10ab7104 	addi	r2,r2,-21052
811012ec:	1009883a 	mov	r4,r2
811012f0:	008009c4 	movi	r2,39
811012f4:	100d883a 	mov	r6,r2
811012f8:	200b883a 	mov	r5,r4
811012fc:	1809883a 	mov	r4,r3
81101300:	11218680 	call	81121868 <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
81101304:	d0a06117 	ldw	r2,-32380(gp)
81101308:	01604574 	movhi	r5,33045
8110130c:	29497504 	addi	r5,r5,9684
81101310:	1009883a 	mov	r4,r2
81101314:	11207b80 	call	811207b8 <fprintf>
81101318:	00004306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 94) {
8110131c:	e0bfbc17 	ldw	r2,-272(fp)
81101320:	10801798 	cmpnei	r2,r2,94
81101324:	1000101e 	bne	r2,zero,81101368 <bDdr2EepromDump+0xb50>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
81101328:	00e04574 	movhi	r3,33045
8110132c:	18c97504 	addi	r3,r3,9684
81101330:	00a04574 	movhi	r2,33045
81101334:	10ab7b04 	addi	r2,r2,-21012
81101338:	1009883a 	mov	r4,r2
8110133c:	008006c4 	movi	r2,27
81101340:	100d883a 	mov	r6,r2
81101344:	200b883a 	mov	r5,r4
81101348:	1809883a 	mov	r4,r3
8110134c:	11218680 	call	81121868 <memcpy>
				debug(fp, cDebugBuffer);
81101350:	d0a06117 	ldw	r2,-32380(gp)
81101354:	01604574 	movhi	r5,33045
81101358:	29497504 	addi	r5,r5,9684
8110135c:	1009883a 	mov	r4,r2
81101360:	11207b80 	call	811207b8 <fprintf>
81101364:	00003006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 95) {
81101368:	e0bfbc17 	ldw	r2,-272(fp)
8110136c:	108017d8 	cmpnei	r2,r2,95
81101370:	1000101e 	bne	r2,zero,811013b4 <bDdr2EepromDump+0xb9c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101374:	00e04574 	movhi	r3,33045
81101378:	18c97504 	addi	r3,r3,9684
8110137c:	00a04574 	movhi	r2,33045
81101380:	10ab8204 	addi	r2,r2,-20984
81101384:	1009883a 	mov	r4,r2
81101388:	00800a04 	movi	r2,40
8110138c:	100d883a 	mov	r6,r2
81101390:	200b883a 	mov	r5,r4
81101394:	1809883a 	mov	r4,r3
81101398:	11218680 	call	81121868 <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
8110139c:	d0a06117 	ldw	r2,-32380(gp)
811013a0:	01604574 	movhi	r5,33045
811013a4:	29497504 	addi	r5,r5,9684
811013a8:	1009883a 	mov	r4,r2
811013ac:	11207b80 	call	811207b8 <fprintf>
811013b0:	00001d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 99) {
811013b4:	e0bfbc17 	ldw	r2,-272(fp)
811013b8:	108018d8 	cmpnei	r2,r2,99
811013bc:	1000101e 	bne	r2,zero,81101400 <bDdr2EepromDump+0xbe8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
811013c0:	00e04574 	movhi	r3,33045
811013c4:	18c97504 	addi	r3,r3,9684
811013c8:	00a04574 	movhi	r2,33045
811013cc:	10ab8c04 	addi	r2,r2,-20944
811013d0:	1009883a 	mov	r4,r2
811013d4:	00800984 	movi	r2,38
811013d8:	100d883a 	mov	r6,r2
811013dc:	200b883a 	mov	r5,r4
811013e0:	1809883a 	mov	r4,r3
811013e4:	11218680 	call	81121868 <memcpy>
				debug(fp, cDebugBuffer);
811013e8:	d0a06117 	ldw	r2,-32380(gp)
811013ec:	01604574 	movhi	r5,33045
811013f0:	29497504 	addi	r5,r5,9684
811013f4:	1009883a 	mov	r4,r2
811013f8:	11207b80 	call	811207b8 <fprintf>
811013fc:	00000a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101400:	00a04574 	movhi	r2,33045
81101404:	10897504 	addi	r2,r2,9684
81101408:	00c00284 	movi	r3,10
8110140c:	10c00005 	stb	r3,0(r2)
81101410:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
81101414:	d0a06117 	ldw	r2,-32380(gp)
81101418:	01604574 	movhi	r5,33045
8110141c:	29497504 	addi	r5,r5,9684
81101420:	1009883a 	mov	r4,r2
81101424:	11207b80 	call	811207b8 <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81101428:	e0bfbc17 	ldw	r2,-272(fp)
8110142c:	10800044 	addi	r2,r2,1
81101430:	e0bfbc15 	stw	r2,-272(fp)
81101434:	e0bfbc17 	ldw	r2,-272(fp)
81101438:	10804008 	cmpgei	r2,r2,256
8110143c:	1000121e 	bne	r2,zero,81101488 <bDdr2EepromDump+0xc70>
81101440:	e0bfbe17 	ldw	r2,-264(fp)
81101444:	103d451e 	bne	r2,zero,8110095c <__reset+0xfb0e095c>
81101448:	00000f06 	br	81101488 <bDdr2EepromDump+0xc70>
#endif
			}
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
8110144c:	00e04574 	movhi	r3,33045
81101450:	18c97504 	addi	r3,r3,9684
81101454:	00a04574 	movhi	r2,33045
81101458:	10ab9604 	addi	r2,r2,-20904
8110145c:	1009883a 	mov	r4,r2
81101460:	008005c4 	movi	r2,23
81101464:	100d883a 	mov	r6,r2
81101468:	200b883a 	mov	r5,r4
8110146c:	1809883a 	mov	r4,r3
81101470:	11218680 	call	81121868 <memcpy>
		debug(fp, cDebugBuffer);
81101474:	d0a06117 	ldw	r2,-32380(gp)
81101478:	01604574 	movhi	r5,33045
8110147c:	29497504 	addi	r5,r5,9684
81101480:	1009883a 	mov	r4,r2
81101484:	11207b80 	call	811207b8 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101488:	00a04574 	movhi	r2,33045
8110148c:	10897504 	addi	r2,r2,9684
81101490:	00c00284 	movi	r3,10
81101494:	10c00005 	stb	r3,0(r2)
81101498:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110149c:	d0a06117 	ldw	r2,-32380(gp)
811014a0:	01604574 	movhi	r5,33045
811014a4:	29497504 	addi	r5,r5,9684
811014a8:	1009883a 	mov	r4,r2
811014ac:	11207b80 	call	811207b8 <fprintf>
#endif

	return bSuccess;
811014b0:	e0bfbe17 	ldw	r2,-264(fp)
}
811014b4:	e037883a 	mov	sp,fp
811014b8:	dfc00117 	ldw	ra,4(sp)
811014bc:	df000017 	ldw	fp,0(sp)
811014c0:	dec00204 	addi	sp,sp,8
811014c4:	f800283a 	ret

811014c8 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811014c8:	defffb04 	addi	sp,sp,-20
811014cc:	de00012e 	bgeu	sp,et,811014d4 <bDdr2SwitchMemory+0xc>
811014d0:	003b68fa 	trap	3
811014d4:	dfc00415 	stw	ra,16(sp)
811014d8:	df000315 	stw	fp,12(sp)
811014dc:	df000304 	addi	fp,sp,12
811014e0:	2005883a 	mov	r2,r4
811014e4:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess;
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
811014e8:	00a04834 	movhi	r2,33056
811014ec:	108c2204 	addi	r2,r2,12424
811014f0:	e0bffe15 	stw	r2,-8(fp)

	bSuccess = TRUE;
811014f4:	00800044 	movi	r2,1
811014f8:	e0bffd15 	stw	r2,-12(fp)
	switch (ucMemoryId) {
811014fc:	e0bfff03 	ldbu	r2,-4(fp)
81101500:	10000326 	beq	r2,zero,81101510 <bDdr2SwitchMemory+0x48>
81101504:	10800060 	cmpeqi	r2,r2,1
81101508:	1000041e 	bne	r2,zero,8110151c <bDdr2SwitchMemory+0x54>
8110150c:	00000706 	br	8110152c <bDdr2SwitchMemory+0x64>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
81101510:	e0bffe17 	ldw	r2,-8(fp)
81101514:	10000015 	stw	zero,0(r2)
		break;
81101518:	00001406 	br	8110156c <bDdr2SwitchMemory+0xa4>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
8110151c:	e0bffe17 	ldw	r2,-8(fp)
81101520:	00e00034 	movhi	r3,32768
81101524:	10c00015 	stw	r3,0(r2)
		break;
81101528:	00001006 	br	8110156c <bDdr2SwitchMemory+0xa4>
	default:
		bSuccess = FALSE;
8110152c:	e03ffd15 	stw	zero,-12(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101530:	00e04574 	movhi	r3,33045
81101534:	18c97504 	addi	r3,r3,9684
81101538:	00a04574 	movhi	r2,33045
8110153c:	10ab9c04 	addi	r2,r2,-20880
81101540:	1009883a 	mov	r4,r2
81101544:	00800f04 	movi	r2,60
81101548:	100d883a 	mov	r6,r2
8110154c:	200b883a 	mov	r5,r4
81101550:	1809883a 	mov	r4,r3
81101554:	11218680 	call	81121868 <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
81101558:	d0a06117 	ldw	r2,-32380(gp)
8110155c:	01604574 	movhi	r5,33045
81101560:	29497504 	addi	r5,r5,9684
81101564:	1009883a 	mov	r4,r2
81101568:	11207b80 	call	811207b8 <fprintf>
		;
#endif
	}

	return bSuccess;
8110156c:	e0bffd17 	ldw	r2,-12(fp)
}
81101570:	e037883a 	mov	sp,fp
81101574:	dfc00117 	ldw	ra,4(sp)
81101578:	df000017 	ldw	fp,0(sp)
8110157c:	dec00204 	addi	sp,sp,8
81101580:	f800283a 	ret

81101584 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
81101584:	deffe204 	addi	sp,sp,-120
81101588:	de00012e 	bgeu	sp,et,81101590 <bDdr2MemoryWriteTest+0xc>
8110158c:	003b68fa 	trap	3
81101590:	dfc01d15 	stw	ra,116(sp)
81101594:	df001c15 	stw	fp,112(sp)
81101598:	dc401b15 	stw	r17,108(sp)
8110159c:	dc001a15 	stw	r16,104(sp)
811015a0:	df001c04 	addi	fp,sp,112
811015a4:	2005883a 	mov	r2,r4
811015a8:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
811015ac:	00e04574 	movhi	r3,33045
811015b0:	18c97504 	addi	r3,r3,9684
811015b4:	00a04574 	movhi	r2,33045
811015b8:	10abab04 	addi	r2,r2,-20820
811015bc:	1009883a 	mov	r4,r2
811015c0:	00800a04 	movi	r2,40
811015c4:	100d883a 	mov	r6,r2
811015c8:	200b883a 	mov	r5,r4
811015cc:	1809883a 	mov	r4,r3
811015d0:	11218680 	call	81121868 <memcpy>
	debug(fp, cDebugBuffer);
811015d4:	d0a06117 	ldw	r2,-32380(gp)
811015d8:	01604574 	movhi	r5,33045
811015dc:	29497504 	addi	r5,r5,9684
811015e0:	1009883a 	mov	r4,r2
811015e4:	11207b80 	call	811207b8 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811015e8:	00800044 	movi	r2,1
811015ec:	e0bfed15 	stw	r2,-76(fp)
	switch (ucMemoryId) {
811015f0:	e0bffd03 	ldbu	r2,-12(fp)
811015f4:	10000326 	beq	r2,zero,81101604 <bDdr2MemoryWriteTest+0x80>
811015f8:	10800060 	cmpeqi	r2,r2,1
811015fc:	1000081e 	bne	r2,zero,81101620 <bDdr2MemoryWriteTest+0x9c>
81101600:	00000e06 	br	8110163c <bDdr2MemoryWriteTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101604:	e0bffd03 	ldbu	r2,-12(fp)
81101608:	1009883a 	mov	r4,r2
8110160c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101610:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101614:	00a00034 	movhi	r2,32768
81101618:	e0bfe615 	stw	r2,-104(fp)
		break;
8110161c:	00001906 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101620:	e0bffd03 	ldbu	r2,-12(fp)
81101624:	1009883a 	mov	r4,r2
81101628:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110162c:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101630:	00a00034 	movhi	r2,32768
81101634:	e0bfe615 	stw	r2,-104(fp)
		break;
81101638:	00001206 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	default:
		bSuccess = FALSE;
8110163c:	e03fed15 	stw	zero,-76(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101640:	00e04574 	movhi	r3,33045
81101644:	18c97504 	addi	r3,r3,9684
81101648:	00a04574 	movhi	r2,33045
8110164c:	10a9bc04 	addi	r2,r2,-22800
81101650:	1009883a 	mov	r4,r2
81101654:	00800bc4 	movi	r2,47
81101658:	100d883a 	mov	r6,r2
8110165c:	200b883a 	mov	r5,r4
81101660:	1809883a 	mov	r4,r3
81101664:	11218680 	call	81121868 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101668:	d0a06117 	ldw	r2,-32380(gp)
8110166c:	01604574 	movhi	r5,33045
81101670:	29497504 	addi	r5,r5,9684
81101674:	1009883a 	mov	r4,r2
81101678:	11207b80 	call	811207b8 <fprintf>
		;
#endif
		return bSuccess;
8110167c:	e0bfed17 	ldw	r2,-76(fp)
81101680:	00011806 	br	81101ae4 <bDdr2MemoryWriteTest+0x560>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81101684:	e0bfe617 	ldw	r2,-104(fp)
81101688:	1004d53a 	srli	r2,r2,20
8110168c:	100d883a 	mov	r6,r2
81101690:	01604574 	movhi	r5,33045
81101694:	296bb504 	addi	r5,r5,-20780
81101698:	01204574 	movhi	r4,33045
8110169c:	21097504 	addi	r4,r4,9684
811016a0:	11221480 	call	81122148 <sprintf>
	debug(fp, cDebugBuffer);
811016a4:	d0a06117 	ldw	r2,-32380(gp)
811016a8:	01604574 	movhi	r5,33045
811016ac:	29497504 	addi	r5,r5,9684
811016b0:	1009883a 	mov	r4,r2
811016b4:	11207b80 	call	811207b8 <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811016b8:	00800104 	movi	r2,4
811016bc:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811016c0:	e03fec15 	stw	zero,-80(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811016c4:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811016c8:	e03fe715 	stw	zero,-100(fp)
811016cc:	00001506 	br	81101724 <bDdr2MemoryWriteTest+0x1a0>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
811016d0:	e0ffe617 	ldw	r3,-104(fp)
811016d4:	00b33374 	movhi	r2,52429
811016d8:	10b33344 	addi	r2,r2,-13107
811016dc:	1888383a 	mulxuu	r4,r3,r2
811016e0:	1885383a 	mul	r2,r3,r2
811016e4:	1021883a 	mov	r16,r2
811016e8:	2023883a 	mov	r17,r4
811016ec:	8804d0fa 	srli	r2,r17,3
811016f0:	e0ffe717 	ldw	r3,-100(fp)
811016f4:	18c00044 	addi	r3,r3,1
811016f8:	10c7383a 	mul	r3,r2,r3
811016fc:	e0bfe717 	ldw	r2,-100(fp)
81101700:	1085883a 	add	r2,r2,r2
81101704:	1085883a 	add	r2,r2,r2
81101708:	e13fe504 	addi	r4,fp,-108
8110170c:	2085883a 	add	r2,r4,r2
81101710:	10800e04 	addi	r2,r2,56
81101714:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101718:	e0bfe717 	ldw	r2,-100(fp)
8110171c:	10800044 	addi	r2,r2,1
81101720:	e0bfe715 	stw	r2,-100(fp)
81101724:	e0bfe717 	ldw	r2,-100(fp)
81101728:	10800290 	cmplti	r2,r2,10
8110172c:	103fe81e 	bne	r2,zero,811016d0 <__reset+0xfb0e16d0>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101730:	d0a08817 	ldw	r2,-32224(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81101734:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101738:	00804004 	movi	r2,256
8110173c:	e0bfea15 	stw	r2,-88(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81101740:	e03fe715 	stw	zero,-100(fp)
81101744:	00001e06 	br	811017c0 <bDdr2MemoryWriteTest+0x23c>
		if (iI == 0) {
81101748:	e0bfe717 	ldw	r2,-100(fp)
8110174c:	1000091e 	bne	r2,zero,81101774 <bDdr2MemoryWriteTest+0x1f0>
			xSZData[iI] = uliInitValue;
81101750:	00a04574 	movhi	r2,33045
81101754:	1089b504 	addi	r2,r2,9940
81101758:	e0ffe717 	ldw	r3,-100(fp)
8110175c:	18c7883a 	add	r3,r3,r3
81101760:	18c7883a 	add	r3,r3,r3
81101764:	10c5883a 	add	r2,r2,r3
81101768:	e0fff017 	ldw	r3,-64(fp)
8110176c:	10c00015 	stw	r3,0(r2)
81101770:	00001006 	br	811017b4 <bDdr2MemoryWriteTest+0x230>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
81101774:	e0bfe717 	ldw	r2,-100(fp)
81101778:	10ffffc4 	addi	r3,r2,-1
8110177c:	00a04574 	movhi	r2,33045
81101780:	1089b504 	addi	r2,r2,9940
81101784:	18c7883a 	add	r3,r3,r3
81101788:	18c7883a 	add	r3,r3,r3
8110178c:	10c5883a 	add	r2,r2,r3
81101790:	10800017 	ldw	r2,0(r2)
81101794:	11000364 	muli	r4,r2,13
81101798:	00a04574 	movhi	r2,33045
8110179c:	1089b504 	addi	r2,r2,9940
811017a0:	e0ffe717 	ldw	r3,-100(fp)
811017a4:	18c7883a 	add	r3,r3,r3
811017a8:	18c7883a 	add	r3,r3,r3
811017ac:	10c5883a 	add	r2,r2,r3
811017b0:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811017b4:	e0bfe717 	ldw	r2,-100(fp)
811017b8:	10800044 	addi	r2,r2,1
811017bc:	e0bfe715 	stw	r2,-100(fp)
811017c0:	e0ffe717 	ldw	r3,-100(fp)
811017c4:	e0bfea17 	ldw	r2,-88(fp)
811017c8:	18bfdf16 	blt	r3,r2,81101748 <__reset+0xfb0e1748>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811017cc:	e0bfea17 	ldw	r2,-88(fp)
811017d0:	10ffffc4 	addi	r3,r2,-1
811017d4:	00a04574 	movhi	r2,33045
811017d8:	1089b504 	addi	r2,r2,9940
811017dc:	18c7883a 	add	r3,r3,r3
811017e0:	18c7883a 	add	r3,r3,r3
811017e4:	10c7883a 	add	r3,r2,r3
811017e8:	00aaaaf4 	movhi	r2,43691
811017ec:	10aaaa84 	addi	r2,r2,-21846
811017f0:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
811017f4:	e0bfea17 	ldw	r2,-88(fp)
811017f8:	10ffff84 	addi	r3,r2,-2
811017fc:	00a04574 	movhi	r2,33045
81101800:	1089b504 	addi	r2,r2,9940
81101804:	18c7883a 	add	r3,r3,r3
81101808:	18c7883a 	add	r3,r3,r3
8110180c:	10c7883a 	add	r3,r2,r3
81101810:	00955574 	movhi	r2,21845
81101814:	10955544 	addi	r2,r2,21845
81101818:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
8110181c:	e0bfea17 	ldw	r2,-88(fp)
81101820:	10ffff44 	addi	r3,r2,-3
81101824:	00a04574 	movhi	r2,33045
81101828:	1089b504 	addi	r2,r2,9940
8110182c:	18c7883a 	add	r3,r3,r3
81101830:	18c7883a 	add	r3,r3,r3
81101834:	10c5883a 	add	r2,r2,r3
81101838:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
8110183c:	e0bfea17 	ldw	r2,-88(fp)
81101840:	10ffff04 	addi	r3,r2,-4
81101844:	00a04574 	movhi	r2,33045
81101848:	1089b504 	addi	r2,r2,9940
8110184c:	18c7883a 	add	r3,r3,r3
81101850:	18c7883a 	add	r3,r3,r3
81101854:	10c5883a 	add	r2,r2,r3
81101858:	00ffffc4 	movi	r3,-1
8110185c:	10c00015 	stw	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101860:	00e04574 	movhi	r3,33045
81101864:	18c97504 	addi	r3,r3,9684
81101868:	00a04574 	movhi	r2,33045
8110186c:	10abbb04 	addi	r2,r2,-20756
81101870:	1009883a 	mov	r4,r2
81101874:	00800444 	movi	r2,17
81101878:	100d883a 	mov	r6,r2
8110187c:	200b883a 	mov	r5,r4
81101880:	1809883a 	mov	r4,r3
81101884:	11218680 	call	81121868 <memcpy>
	debug(fp, cDebugBuffer);
81101888:	d0a06117 	ldw	r2,-32380(gp)
8110188c:	01604574 	movhi	r5,33045
81101890:	29497504 	addi	r5,r5,9684
81101894:	1009883a 	mov	r4,r2
81101898:	11207b80 	call	811207b8 <fprintf>
8110189c:	d0a08817 	ldw	r2,-32224(gp)
#endif
	iTimeStart = alt_nticks();
811018a0:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
811018a4:	e0bfe517 	ldw	r2,-108(fp)
811018a8:	e0bfe915 	stw	r2,-92(fp)
	iNAccessLen = sizeof(xSZData);
811018ac:	00810004 	movi	r2,1024
811018b0:	e0bfe815 	stw	r2,-96(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
811018b4:	e0ffe817 	ldw	r3,-96(fp)
811018b8:	e0bfee17 	ldw	r2,-72(fp)
811018bc:	1885283a 	div	r2,r3,r2
811018c0:	e0bfea15 	stw	r2,-88(fp)
	iNPos = 0;
811018c4:	e03feb15 	stw	zero,-84(fp)
	while (iNPos < uliByteLen) {
811018c8:	00003a06 	br	811019b4 <bDdr2MemoryWriteTest+0x430>
		iNRemainedLen = uliByteLen - iNPos;
811018cc:	e0bfeb17 	ldw	r2,-84(fp)
811018d0:	e0ffe617 	ldw	r3,-104(fp)
811018d4:	1885c83a 	sub	r2,r3,r2
811018d8:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
811018dc:	e0bfe817 	ldw	r2,-96(fp)
811018e0:	e0fff217 	ldw	r3,-56(fp)
811018e4:	1880060e 	bge	r3,r2,81101900 <bDdr2MemoryWriteTest+0x37c>
			iNAccessLen = iNRemainedLen;
811018e8:	e0bff217 	ldw	r2,-56(fp)
811018ec:	e0bfe815 	stw	r2,-96(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
811018f0:	e0ffe817 	ldw	r3,-96(fp)
811018f4:	e0bfee17 	ldw	r2,-72(fp)
811018f8:	1885283a 	div	r2,r3,r2
811018fc:	e0bfea15 	stw	r2,-88(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
81101900:	e0bfe817 	ldw	r2,-96(fp)
81101904:	100d883a 	mov	r6,r2
81101908:	01604574 	movhi	r5,33045
8110190c:	2949b504 	addi	r5,r5,9940
81101910:	e13fe917 	ldw	r4,-92(fp)
81101914:	11218680 	call	81121868 <memcpy>
		pxDes += iNItemNum;
81101918:	e0bfea17 	ldw	r2,-88(fp)
8110191c:	1085883a 	add	r2,r2,r2
81101920:	1085883a 	add	r2,r2,r2
81101924:	1007883a 	mov	r3,r2
81101928:	e0bfe917 	ldw	r2,-92(fp)
8110192c:	10c5883a 	add	r2,r2,r3
81101930:	e0bfe915 	stw	r2,-92(fp)
		iNPos += iNAccessLen;
81101934:	e0ffeb17 	ldw	r3,-84(fp)
81101938:	e0bfe817 	ldw	r2,-96(fp)
8110193c:	1885883a 	add	r2,r3,r2
81101940:	e0bfeb15 	stw	r2,-84(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101944:	e0bfec17 	ldw	r2,-80(fp)
81101948:	10800288 	cmpgei	r2,r2,10
8110194c:	1000191e 	bne	r2,zero,811019b4 <bDdr2MemoryWriteTest+0x430>
81101950:	e0bfec17 	ldw	r2,-80(fp)
81101954:	1085883a 	add	r2,r2,r2
81101958:	1085883a 	add	r2,r2,r2
8110195c:	e0ffe504 	addi	r3,fp,-108
81101960:	1885883a 	add	r2,r3,r2
81101964:	10800e04 	addi	r2,r2,56
81101968:	10800017 	ldw	r2,0(r2)
8110196c:	e0ffeb17 	ldw	r3,-84(fp)
81101970:	18801036 	bltu	r3,r2,811019b4 <bDdr2MemoryWriteTest+0x430>
			iNProgressIndex++;
81101974:	e0bfec17 	ldw	r2,-80(fp)
81101978:	10800044 	addi	r2,r2,1
8110197c:	e0bfec15 	stw	r2,-80(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101980:	e0bfec17 	ldw	r2,-80(fp)
81101984:	108002a4 	muli	r2,r2,10
81101988:	100d883a 	mov	r6,r2
8110198c:	01604574 	movhi	r5,33045
81101990:	296bc004 	addi	r5,r5,-20736
81101994:	01204574 	movhi	r4,33045
81101998:	21097504 	addi	r4,r4,9684
8110199c:	11221480 	call	81122148 <sprintf>
			debug(fp, cDebugBuffer);
811019a0:	d0a06117 	ldw	r2,-32380(gp)
811019a4:	01604574 	movhi	r5,33045
811019a8:	29497504 	addi	r5,r5,9684
811019ac:	1009883a 	mov	r4,r2
811019b0:	11207b80 	call	811207b8 <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
811019b4:	e0ffeb17 	ldw	r3,-84(fp)
811019b8:	e0bfe617 	ldw	r2,-104(fp)
811019bc:	18bfc336 	bltu	r3,r2,811018cc <__reset+0xfb0e18cc>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
811019c0:	11356a80 	call	811356a8 <alt_dcache_flush_all>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811019c4:	00a04574 	movhi	r2,33045
811019c8:	10897504 	addi	r2,r2,9684
811019cc:	00c00284 	movi	r3,10
811019d0:	10c00005 	stb	r3,0(r2)
811019d4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811019d8:	d0a06117 	ldw	r2,-32380(gp)
811019dc:	01604574 	movhi	r5,33045
811019e0:	29497504 	addi	r5,r5,9684
811019e4:	1009883a 	mov	r4,r2
811019e8:	11207b80 	call	811207b8 <fprintf>
811019ec:	d0e08817 	ldw	r3,-32224(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
811019f0:	e0bff117 	ldw	r2,-60(fp)
811019f4:	1885c83a 	sub	r2,r3,r2
811019f8:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
811019fc:	e0bfed17 	ldw	r2,-76(fp)
81101a00:	10001e26 	beq	r2,zero,81101a7c <bDdr2MemoryWriteTest+0x4f8>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101a04:	e13fef17 	ldw	r4,-68(fp)
81101a08:	111eeb00 	call	8111eeb0 <__floatsisf>
81101a0c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101a10:	d0a08717 	ldw	r2,-32228(gp)
81101a14:	1009883a 	mov	r4,r2
81101a18:	111efdc0 	call	8111efdc <__floatunsisf>
81101a1c:	1007883a 	mov	r3,r2
81101a20:	180b883a 	mov	r5,r3
81101a24:	8009883a 	mov	r4,r16
81101a28:	111e6640 	call	8111e664 <__divsf3>
81101a2c:	1007883a 	mov	r3,r2
81101a30:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101a34:	1009883a 	mov	r4,r2
81101a38:	11203380 	call	81120338 <__extendsfdf2>
81101a3c:	1009883a 	mov	r4,r2
81101a40:	180b883a 	mov	r5,r3
81101a44:	d9400015 	stw	r5,0(sp)
81101a48:	200f883a 	mov	r7,r4
81101a4c:	e1bfe617 	ldw	r6,-104(fp)
81101a50:	01604574 	movhi	r5,33045
81101a54:	296bc204 	addi	r5,r5,-20728
81101a58:	01204574 	movhi	r4,33045
81101a5c:	21097504 	addi	r4,r4,9684
81101a60:	11221480 	call	81122148 <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a64:	d0a06117 	ldw	r2,-32380(gp)
81101a68:	01604574 	movhi	r5,33045
81101a6c:	29497504 	addi	r5,r5,9684
81101a70:	1009883a 	mov	r4,r2
81101a74:	11207b80 	call	811207b8 <fprintf>
81101a78:	00000f06 	br	81101ab8 <bDdr2MemoryWriteTest+0x534>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101a7c:	00e04574 	movhi	r3,33045
81101a80:	18c97504 	addi	r3,r3,9684
81101a84:	00a04574 	movhi	r2,33045
81101a88:	10abce04 	addi	r2,r2,-20680
81101a8c:	1009883a 	mov	r4,r2
81101a90:	00800584 	movi	r2,22
81101a94:	100d883a 	mov	r6,r2
81101a98:	200b883a 	mov	r5,r4
81101a9c:	1809883a 	mov	r4,r3
81101aa0:	11218680 	call	81121868 <memcpy>
		debug(fp, cDebugBuffer);
81101aa4:	d0a06117 	ldw	r2,-32380(gp)
81101aa8:	01604574 	movhi	r5,33045
81101aac:	29497504 	addi	r5,r5,9684
81101ab0:	1009883a 	mov	r4,r2
81101ab4:	11207b80 	call	811207b8 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ab8:	00a04574 	movhi	r2,33045
81101abc:	10897504 	addi	r2,r2,9684
81101ac0:	00c00284 	movi	r3,10
81101ac4:	10c00005 	stb	r3,0(r2)
81101ac8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101acc:	d0a06117 	ldw	r2,-32380(gp)
81101ad0:	01604574 	movhi	r5,33045
81101ad4:	29497504 	addi	r5,r5,9684
81101ad8:	1009883a 	mov	r4,r2
81101adc:	11207b80 	call	811207b8 <fprintf>
#endif

	return bSuccess;
81101ae0:	e0bfed17 	ldw	r2,-76(fp)
}
81101ae4:	e6fffe04 	addi	sp,fp,-8
81101ae8:	dfc00317 	ldw	ra,12(sp)
81101aec:	df000217 	ldw	fp,8(sp)
81101af0:	dc400117 	ldw	r17,4(sp)
81101af4:	dc000017 	ldw	r16,0(sp)
81101af8:	dec00404 	addi	sp,sp,16
81101afc:	f800283a 	ret

81101b00 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101b00:	deffe204 	addi	sp,sp,-120
81101b04:	de00012e 	bgeu	sp,et,81101b0c <bDdr2MemoryReadTest+0xc>
81101b08:	003b68fa 	trap	3
81101b0c:	dfc01d15 	stw	ra,116(sp)
81101b10:	df001c15 	stw	fp,112(sp)
81101b14:	dc401b15 	stw	r17,108(sp)
81101b18:	dc001a15 	stw	r16,104(sp)
81101b1c:	df001c04 	addi	fp,sp,112
81101b20:	2005883a 	mov	r2,r4
81101b24:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101b28:	00e04574 	movhi	r3,33045
81101b2c:	18c97504 	addi	r3,r3,9684
81101b30:	00a04574 	movhi	r2,33045
81101b34:	10abd404 	addi	r2,r2,-20656
81101b38:	1009883a 	mov	r4,r2
81101b3c:	008009c4 	movi	r2,39
81101b40:	100d883a 	mov	r6,r2
81101b44:	200b883a 	mov	r5,r4
81101b48:	1809883a 	mov	r4,r3
81101b4c:	11218680 	call	81121868 <memcpy>
	debug(fp, cDebugBuffer);
81101b50:	d0a06117 	ldw	r2,-32380(gp)
81101b54:	01604574 	movhi	r5,33045
81101b58:	29497504 	addi	r5,r5,9684
81101b5c:	1009883a 	mov	r4,r2
81101b60:	11207b80 	call	811207b8 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81101b64:	00800044 	movi	r2,1
81101b68:	e0bfe515 	stw	r2,-108(fp)
	switch (ucMemoryId) {
81101b6c:	e0bffd03 	ldbu	r2,-12(fp)
81101b70:	10000326 	beq	r2,zero,81101b80 <bDdr2MemoryReadTest+0x80>
81101b74:	10800060 	cmpeqi	r2,r2,1
81101b78:	1000081e 	bne	r2,zero,81101b9c <bDdr2MemoryReadTest+0x9c>
81101b7c:	00000e06 	br	81101bb8 <bDdr2MemoryReadTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b80:	e0bffd03 	ldbu	r2,-12(fp)
81101b84:	1009883a 	mov	r4,r2
81101b88:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101b8c:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101b90:	00a00034 	movhi	r2,32768
81101b94:	e0bfe715 	stw	r2,-100(fp)
		break;
81101b98:	00001906 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b9c:	e0bffd03 	ldbu	r2,-12(fp)
81101ba0:	1009883a 	mov	r4,r2
81101ba4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101ba8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101bac:	00a00034 	movhi	r2,32768
81101bb0:	e0bfe715 	stw	r2,-100(fp)
		break;
81101bb4:	00001206 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	default:
		bSuccess = FALSE;
81101bb8:	e03fe515 	stw	zero,-108(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101bbc:	00e04574 	movhi	r3,33045
81101bc0:	18c97504 	addi	r3,r3,9684
81101bc4:	00a04574 	movhi	r2,33045
81101bc8:	10a9bc04 	addi	r2,r2,-22800
81101bcc:	1009883a 	mov	r4,r2
81101bd0:	00800bc4 	movi	r2,47
81101bd4:	100d883a 	mov	r6,r2
81101bd8:	200b883a 	mov	r5,r4
81101bdc:	1809883a 	mov	r4,r3
81101be0:	11218680 	call	81121868 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101be4:	d0a06117 	ldw	r2,-32380(gp)
81101be8:	01604574 	movhi	r5,33045
81101bec:	29497504 	addi	r5,r5,9684
81101bf0:	1009883a 	mov	r4,r2
81101bf4:	11207b80 	call	811207b8 <fprintf>
		;
#endif
		return bSuccess;
81101bf8:	e0bfe517 	ldw	r2,-108(fp)
81101bfc:	0000fc06 	br	81101ff0 <bDdr2MemoryReadTest+0x4f0>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101c00:	e0bfe717 	ldw	r2,-100(fp)
81101c04:	1004d53a 	srli	r2,r2,20
81101c08:	100d883a 	mov	r6,r2
81101c0c:	01604574 	movhi	r5,33045
81101c10:	296bde04 	addi	r5,r5,-20616
81101c14:	01204574 	movhi	r4,33045
81101c18:	21097504 	addi	r4,r4,9684
81101c1c:	11221480 	call	81122148 <sprintf>
	debug(fp, cDebugBuffer);
81101c20:	d0a06117 	ldw	r2,-32380(gp)
81101c24:	01604574 	movhi	r5,33045
81101c28:	29497504 	addi	r5,r5,9684
81101c2c:	1009883a 	mov	r4,r2
81101c30:	11207b80 	call	811207b8 <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101c34:	00804004 	movi	r2,256
81101c38:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101c3c:	00800104 	movi	r2,4
81101c40:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101c44:	e0ffec17 	ldw	r3,-80(fp)
81101c48:	e0bfef17 	ldw	r2,-68(fp)
81101c4c:	1885383a 	mul	r2,r3,r2
81101c50:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101c54:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101c58:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c5c:	e03fe815 	stw	zero,-96(fp)
81101c60:	00001506 	br	81101cb8 <bDdr2MemoryReadTest+0x1b8>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101c64:	e0ffe717 	ldw	r3,-100(fp)
81101c68:	00b33374 	movhi	r2,52429
81101c6c:	10b33344 	addi	r2,r2,-13107
81101c70:	1888383a 	mulxuu	r4,r3,r2
81101c74:	1885383a 	mul	r2,r3,r2
81101c78:	1021883a 	mov	r16,r2
81101c7c:	2023883a 	mov	r17,r4
81101c80:	8804d0fa 	srli	r2,r17,3
81101c84:	e0ffe817 	ldw	r3,-96(fp)
81101c88:	18c00044 	addi	r3,r3,1
81101c8c:	10c7383a 	mul	r3,r2,r3
81101c90:	e0bfe817 	ldw	r2,-96(fp)
81101c94:	1085883a 	add	r2,r2,r2
81101c98:	1085883a 	add	r2,r2,r2
81101c9c:	e13fe504 	addi	r4,fp,-108
81101ca0:	2085883a 	add	r2,r4,r2
81101ca4:	10800e04 	addi	r2,r2,56
81101ca8:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101cac:	e0bfe817 	ldw	r2,-96(fp)
81101cb0:	10800044 	addi	r2,r2,1
81101cb4:	e0bfe815 	stw	r2,-96(fp)
81101cb8:	e0bfe817 	ldw	r2,-96(fp)
81101cbc:	10800290 	cmplti	r2,r2,10
81101cc0:	103fe81e 	bne	r2,zero,81101c64 <__reset+0xfb0e1c64>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101cc4:	e03fee15 	stw	zero,-72(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101cc8:	00e04574 	movhi	r3,33045
81101ccc:	18c97504 	addi	r3,r3,9684
81101cd0:	00a04574 	movhi	r2,33045
81101cd4:	10abe404 	addi	r2,r2,-20592
81101cd8:	1009883a 	mov	r4,r2
81101cdc:	008006c4 	movi	r2,27
81101ce0:	100d883a 	mov	r6,r2
81101ce4:	200b883a 	mov	r5,r4
81101ce8:	1809883a 	mov	r4,r3
81101cec:	11218680 	call	81121868 <memcpy>
	debug(fp, cDebugBuffer);
81101cf0:	d0a06117 	ldw	r2,-32380(gp)
81101cf4:	01604574 	movhi	r5,33045
81101cf8:	29497504 	addi	r5,r5,9684
81101cfc:	1009883a 	mov	r4,r2
81101d00:	11207b80 	call	811207b8 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101d04:	d0a08817 	ldw	r2,-32224(gp)
#endif
	iTimeStart = alt_nticks();
81101d08:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101d0c:	e0bfe617 	ldw	r2,-104(fp)
81101d10:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101d14:	00810004 	movi	r2,1024
81101d18:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101d1c:	e0ffe917 	ldw	r3,-92(fp)
81101d20:	e0bfef17 	ldw	r2,-68(fp)
81101d24:	1885283a 	div	r2,r3,r2
81101d28:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101d2c:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101d30:	00006206 	br	81101ebc <bDdr2MemoryReadTest+0x3bc>
		iNRemainedLen = uliByteLen - iNPos;
81101d34:	e0bfed17 	ldw	r2,-76(fp)
81101d38:	e0ffe717 	ldw	r3,-100(fp)
81101d3c:	1885c83a 	sub	r2,r3,r2
81101d40:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101d44:	e0bfe917 	ldw	r2,-92(fp)
81101d48:	e0fff217 	ldw	r3,-56(fp)
81101d4c:	1880060e 	bge	r3,r2,81101d68 <bDdr2MemoryReadTest+0x268>
			iNAccessLen = iNRemainedLen;
81101d50:	e0bff217 	ldw	r2,-56(fp)
81101d54:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101d58:	e0ffe917 	ldw	r3,-92(fp)
81101d5c:	e0bfef17 	ldw	r2,-68(fp)
81101d60:	1885283a 	div	r2,r3,r2
81101d64:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101d68:	00a04574 	movhi	r2,33045
81101d6c:	1089b504 	addi	r2,r2,9940
81101d70:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101d74:	e03fe815 	stw	zero,-96(fp)
81101d78:	00002b06 	br	81101e28 <bDdr2MemoryReadTest+0x328>
			if (*pxSrc++ != *pxDes++) {
81101d7c:	e0bfeb17 	ldw	r2,-84(fp)
81101d80:	10c00104 	addi	r3,r2,4
81101d84:	e0ffeb15 	stw	r3,-84(fp)
81101d88:	10c00017 	ldw	r3,0(r2)
81101d8c:	e0bfea17 	ldw	r2,-88(fp)
81101d90:	11000104 	addi	r4,r2,4
81101d94:	e13fea15 	stw	r4,-88(fp)
81101d98:	10800017 	ldw	r2,0(r2)
81101d9c:	18801f26 	beq	r3,r2,81101e1c <bDdr2MemoryReadTest+0x31c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101da0:	e0bfeb17 	ldw	r2,-84(fp)
81101da4:	10bfff04 	addi	r2,r2,-4
81101da8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dac:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101db0:	00a04574 	movhi	r2,33045
81101db4:	1089b504 	addi	r2,r2,9940
81101db8:	e0ffe817 	ldw	r3,-96(fp)
81101dbc:	18c7883a 	add	r3,r3,r3
81101dc0:	18c7883a 	add	r3,r3,r3
81101dc4:	10c5883a 	add	r2,r2,r3
81101dc8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dcc:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101dd0:	e0ffed17 	ldw	r3,-76(fp)
81101dd4:	e0bfef17 	ldw	r2,-68(fp)
81101dd8:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101ddc:	e0bfe817 	ldw	r2,-96(fp)
81101de0:	1885883a 	add	r2,r3,r2
81101de4:	d8800015 	stw	r2,0(sp)
81101de8:	280f883a 	mov	r7,r5
81101dec:	200d883a 	mov	r6,r4
81101df0:	01604574 	movhi	r5,33045
81101df4:	296beb04 	addi	r5,r5,-20564
81101df8:	01204574 	movhi	r4,33045
81101dfc:	21097504 	addi	r4,r4,9684
81101e00:	11221480 	call	81122148 <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101e04:	d0a06117 	ldw	r2,-32380(gp)
81101e08:	01604574 	movhi	r5,33045
81101e0c:	29497504 	addi	r5,r5,9684
81101e10:	1009883a 	mov	r4,r2
81101e14:	11207b80 	call	811207b8 <fprintf>
#endif
				bSuccess = FALSE;
81101e18:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101e1c:	e0bfe817 	ldw	r2,-96(fp)
81101e20:	10800044 	addi	r2,r2,1
81101e24:	e0bfe815 	stw	r2,-96(fp)
81101e28:	e0ffe817 	ldw	r3,-96(fp)
81101e2c:	e0bfec17 	ldw	r2,-80(fp)
81101e30:	1880020e 	bge	r3,r2,81101e3c <bDdr2MemoryReadTest+0x33c>
81101e34:	e0bfe517 	ldw	r2,-108(fp)
81101e38:	103fd01e 	bne	r2,zero,81101d7c <__reset+0xfb0e1d7c>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101e3c:	e0ffed17 	ldw	r3,-76(fp)
81101e40:	e0bfe917 	ldw	r2,-92(fp)
81101e44:	1885883a 	add	r2,r3,r2
81101e48:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101e4c:	e0bfee17 	ldw	r2,-72(fp)
81101e50:	10800288 	cmpgei	r2,r2,10
81101e54:	1000191e 	bne	r2,zero,81101ebc <bDdr2MemoryReadTest+0x3bc>
81101e58:	e0bfee17 	ldw	r2,-72(fp)
81101e5c:	1085883a 	add	r2,r2,r2
81101e60:	1085883a 	add	r2,r2,r2
81101e64:	e0ffe504 	addi	r3,fp,-108
81101e68:	1885883a 	add	r2,r3,r2
81101e6c:	10800e04 	addi	r2,r2,56
81101e70:	10800017 	ldw	r2,0(r2)
81101e74:	e0ffed17 	ldw	r3,-76(fp)
81101e78:	18801036 	bltu	r3,r2,81101ebc <bDdr2MemoryReadTest+0x3bc>
			iNProgressIndex++;
81101e7c:	e0bfee17 	ldw	r2,-72(fp)
81101e80:	10800044 	addi	r2,r2,1
81101e84:	e0bfee15 	stw	r2,-72(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101e88:	e0bfee17 	ldw	r2,-72(fp)
81101e8c:	108002a4 	muli	r2,r2,10
81101e90:	100d883a 	mov	r6,r2
81101e94:	01604574 	movhi	r5,33045
81101e98:	296bc004 	addi	r5,r5,-20736
81101e9c:	01204574 	movhi	r4,33045
81101ea0:	21097504 	addi	r4,r4,9684
81101ea4:	11221480 	call	81122148 <sprintf>
			debug(fp, cDebugBuffer);
81101ea8:	d0a06117 	ldw	r2,-32380(gp)
81101eac:	01604574 	movhi	r5,33045
81101eb0:	29497504 	addi	r5,r5,9684
81101eb4:	1009883a 	mov	r4,r2
81101eb8:	11207b80 	call	811207b8 <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101ebc:	e0bfe517 	ldw	r2,-108(fp)
81101ec0:	10000326 	beq	r2,zero,81101ed0 <bDdr2MemoryReadTest+0x3d0>
81101ec4:	e0ffed17 	ldw	r3,-76(fp)
81101ec8:	e0bfe717 	ldw	r2,-100(fp)
81101ecc:	18bf9936 	bltu	r3,r2,81101d34 <__reset+0xfb0e1d34>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ed0:	00a04574 	movhi	r2,33045
81101ed4:	10897504 	addi	r2,r2,9684
81101ed8:	00c00284 	movi	r3,10
81101edc:	10c00005 	stb	r3,0(r2)
81101ee0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101ee4:	d0a06117 	ldw	r2,-32380(gp)
81101ee8:	01604574 	movhi	r5,33045
81101eec:	29497504 	addi	r5,r5,9684
81101ef0:	1009883a 	mov	r4,r2
81101ef4:	11207b80 	call	811207b8 <fprintf>
81101ef8:	d0e08817 	ldw	r3,-32224(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101efc:	e0bff117 	ldw	r2,-60(fp)
81101f00:	1885c83a 	sub	r2,r3,r2
81101f04:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101f08:	e0bfe517 	ldw	r2,-108(fp)
81101f0c:	10001e26 	beq	r2,zero,81101f88 <bDdr2MemoryReadTest+0x488>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101f10:	e13ff017 	ldw	r4,-64(fp)
81101f14:	111eeb00 	call	8111eeb0 <__floatsisf>
81101f18:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101f1c:	d0a08717 	ldw	r2,-32228(gp)
81101f20:	1009883a 	mov	r4,r2
81101f24:	111efdc0 	call	8111efdc <__floatunsisf>
81101f28:	1007883a 	mov	r3,r2
81101f2c:	180b883a 	mov	r5,r3
81101f30:	8009883a 	mov	r4,r16
81101f34:	111e6640 	call	8111e664 <__divsf3>
81101f38:	1007883a 	mov	r3,r2
81101f3c:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101f40:	1009883a 	mov	r4,r2
81101f44:	11203380 	call	81120338 <__extendsfdf2>
81101f48:	1009883a 	mov	r4,r2
81101f4c:	180b883a 	mov	r5,r3
81101f50:	d9400015 	stw	r5,0(sp)
81101f54:	200f883a 	mov	r7,r4
81101f58:	e1bfe717 	ldw	r6,-100(fp)
81101f5c:	01604574 	movhi	r5,33045
81101f60:	296bf904 	addi	r5,r5,-20508
81101f64:	01204574 	movhi	r4,33045
81101f68:	21097504 	addi	r4,r4,9684
81101f6c:	11221480 	call	81122148 <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101f70:	d0a06117 	ldw	r2,-32380(gp)
81101f74:	01604574 	movhi	r5,33045
81101f78:	29497504 	addi	r5,r5,9684
81101f7c:	1009883a 	mov	r4,r2
81101f80:	11207b80 	call	811207b8 <fprintf>
81101f84:	00000f06 	br	81101fc4 <bDdr2MemoryReadTest+0x4c4>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101f88:	00e04574 	movhi	r3,33045
81101f8c:	18c97504 	addi	r3,r3,9684
81101f90:	00a04574 	movhi	r2,33045
81101f94:	10ac0504 	addi	r2,r2,-20460
81101f98:	1009883a 	mov	r4,r2
81101f9c:	00800544 	movi	r2,21
81101fa0:	100d883a 	mov	r6,r2
81101fa4:	200b883a 	mov	r5,r4
81101fa8:	1809883a 	mov	r4,r3
81101fac:	11218680 	call	81121868 <memcpy>
		debug(fp, cDebugBuffer);
81101fb0:	d0a06117 	ldw	r2,-32380(gp)
81101fb4:	01604574 	movhi	r5,33045
81101fb8:	29497504 	addi	r5,r5,9684
81101fbc:	1009883a 	mov	r4,r2
81101fc0:	11207b80 	call	811207b8 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101fc4:	00a04574 	movhi	r2,33045
81101fc8:	10897504 	addi	r2,r2,9684
81101fcc:	00c00284 	movi	r3,10
81101fd0:	10c00005 	stb	r3,0(r2)
81101fd4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101fd8:	d0a06117 	ldw	r2,-32380(gp)
81101fdc:	01604574 	movhi	r5,33045
81101fe0:	29497504 	addi	r5,r5,9684
81101fe4:	1009883a 	mov	r4,r2
81101fe8:	11207b80 	call	811207b8 <fprintf>
#endif

	return bSuccess;
81101fec:	e0bfe517 	ldw	r2,-108(fp)
}
81101ff0:	e6fffe04 	addi	sp,fp,-8
81101ff4:	dfc00317 	ldw	ra,12(sp)
81101ff8:	df000217 	ldw	fp,8(sp)
81101ffc:	dc400117 	ldw	r17,4(sp)
81102000:	dc000017 	ldw	r16,0(sp)
81102004:	dec00404 	addi	sp,sp,16
81102008:	f800283a 	ret

8110200c <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
8110200c:	deffec04 	addi	sp,sp,-80
81102010:	de00012e 	bgeu	sp,et,81102018 <bDdr2MemoryRandomWriteTest+0xc>
81102014:	003b68fa 	trap	3
81102018:	dfc01315 	stw	ra,76(sp)
8110201c:	df001215 	stw	fp,72(sp)
81102020:	dcc01115 	stw	r19,68(sp)
81102024:	dc801015 	stw	r18,64(sp)
81102028:	dc400f15 	stw	r17,60(sp)
8110202c:	dc000e15 	stw	r16,56(sp)
81102030:	df001204 	addi	fp,sp,72
81102034:	2005883a 	mov	r2,r4
81102038:	e17ffa15 	stw	r5,-24(fp)
8110203c:	e1bffb15 	stw	r6,-20(fp)
81102040:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81102044:	00e04574 	movhi	r3,33045
81102048:	18c97504 	addi	r3,r3,9684
8110204c:	00a04574 	movhi	r2,33045
81102050:	10ac0b04 	addi	r2,r2,-20436
81102054:	1009883a 	mov	r4,r2
81102058:	00800bc4 	movi	r2,47
8110205c:	100d883a 	mov	r6,r2
81102060:	200b883a 	mov	r5,r4
81102064:	1809883a 	mov	r4,r3
81102068:	11218680 	call	81121868 <memcpy>
	debug(fp, cDebugBuffer);
8110206c:	d0a06117 	ldw	r2,-32380(gp)
81102070:	01604574 	movhi	r5,33045
81102074:	29497504 	addi	r5,r5,9684
81102078:	1009883a 	mov	r4,r2
8110207c:	11207b80 	call	811207b8 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102080:	00800044 	movi	r2,1
81102084:	e0bff415 	stw	r2,-48(fp)
	switch (ucMemoryId) {
81102088:	e0bff903 	ldbu	r2,-28(fp)
8110208c:	10000326 	beq	r2,zero,8110209c <bDdr2MemoryRandomWriteTest+0x90>
81102090:	10800060 	cmpeqi	r2,r2,1
81102094:	1000081e 	bne	r2,zero,811020b8 <bDdr2MemoryRandomWriteTest+0xac>
81102098:	00000e06 	br	811020d4 <bDdr2MemoryRandomWriteTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
8110209c:	e0bff903 	ldbu	r2,-28(fp)
811020a0:	1009883a 	mov	r4,r2
811020a4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020a8:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811020ac:	00a00034 	movhi	r2,32768
811020b0:	e0bff015 	stw	r2,-64(fp)
		break;
811020b4:	00001906 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020b8:	e0bff903 	ldbu	r2,-28(fp)
811020bc:	1009883a 	mov	r4,r2
811020c0:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020c4:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811020c8:	00a00034 	movhi	r2,32768
811020cc:	e0bff015 	stw	r2,-64(fp)
		break;
811020d0:	00001206 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	default:
		bSuccess = FALSE;
811020d4:	e03ff415 	stw	zero,-48(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811020d8:	00e04574 	movhi	r3,33045
811020dc:	18c97504 	addi	r3,r3,9684
811020e0:	00a04574 	movhi	r2,33045
811020e4:	10a9bc04 	addi	r2,r2,-22800
811020e8:	1009883a 	mov	r4,r2
811020ec:	00800bc4 	movi	r2,47
811020f0:	100d883a 	mov	r6,r2
811020f4:	200b883a 	mov	r5,r4
811020f8:	1809883a 	mov	r4,r3
811020fc:	11218680 	call	81121868 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102100:	d0a06117 	ldw	r2,-32380(gp)
81102104:	01604574 	movhi	r5,33045
81102108:	29497504 	addi	r5,r5,9684
8110210c:	1009883a 	mov	r4,r2
81102110:	11207b80 	call	811207b8 <fprintf>
		;
#endif
		return bSuccess;
81102114:	e0bff417 	ldw	r2,-48(fp)
81102118:	0000ce06 	br	81102454 <bDdr2MemoryRandomWriteTest+0x448>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
8110211c:	e0bff017 	ldw	r2,-64(fp)
81102120:	1004d53a 	srli	r2,r2,20
81102124:	100d883a 	mov	r6,r2
81102128:	01604574 	movhi	r5,33045
8110212c:	296bb504 	addi	r5,r5,-20780
81102130:	01204574 	movhi	r4,33045
81102134:	21097504 	addi	r4,r4,9684
81102138:	11221480 	call	81122148 <sprintf>
	debug(fp, cDebugBuffer);
8110213c:	d0a06117 	ldw	r2,-32380(gp)
81102140:	01604574 	movhi	r5,33045
81102144:	29497504 	addi	r5,r5,9684
81102148:	1009883a 	mov	r4,r2
8110214c:	11207b80 	call	811207b8 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102150:	d0a08817 	ldw	r2,-32224(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
81102154:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
81102158:	d0a03717 	ldw	r2,-32548(gp)
8110215c:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102160:	e0ffef17 	ldw	r3,-68(fp)
81102164:	e0bff017 	ldw	r2,-64(fp)
81102168:	1885883a 	add	r2,r3,r2
8110216c:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102170:	e0fff017 	ldw	r3,-64(fp)
81102174:	00b33374 	movhi	r2,52429
81102178:	10b33344 	addi	r2,r2,-13107
8110217c:	1888383a 	mulxuu	r4,r3,r2
81102180:	1885383a 	mul	r2,r3,r2
81102184:	1025883a 	mov	r18,r2
81102188:	2027883a 	mov	r19,r4
8110218c:	9806d13a 	srli	r3,r19,4
81102190:	e0bfef17 	ldw	r2,-68(fp)
81102194:	1885883a 	add	r2,r3,r2
81102198:	e0bff215 	stw	r2,-56(fp)
	ucPercentage = 5;
8110219c:	00800144 	movi	r2,5
811021a0:	e0bff305 	stb	r2,-52(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
811021a4:	00e04574 	movhi	r3,33045
811021a8:	18c97504 	addi	r3,r3,9684
811021ac:	00a04574 	movhi	r2,33045
811021b0:	10ac1704 	addi	r2,r2,-20388
811021b4:	1009883a 	mov	r4,r2
811021b8:	00800584 	movi	r2,22
811021bc:	100d883a 	mov	r6,r2
811021c0:	200b883a 	mov	r5,r4
811021c4:	1809883a 	mov	r4,r3
811021c8:	11218680 	call	81121868 <memcpy>
	debug(fp, cDebugBuffer);
811021cc:	d0a06117 	ldw	r2,-32380(gp)
811021d0:	01604574 	movhi	r5,33045
811021d4:	29497504 	addi	r5,r5,9684
811021d8:	1009883a 	mov	r4,r2
811021dc:	11207b80 	call	811207b8 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
811021e0:	e0bffa17 	ldw	r2,-24(fp)
811021e4:	10800058 	cmpnei	r2,r2,1
811021e8:	10000a1e 	bne	r2,zero,81102214 <bDdr2MemoryRandomWriteTest+0x208>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
811021ec:	01604574 	movhi	r5,33045
811021f0:	296c1d04 	addi	r5,r5,-20364
811021f4:	01204574 	movhi	r4,33045
811021f8:	21097504 	addi	r4,r4,9684
811021fc:	11221480 	call	81122148 <sprintf>
		debug(fp, cDebugBuffer);
81102200:	d0a06117 	ldw	r2,-32380(gp)
81102204:	01604574 	movhi	r5,33045
81102208:	29497504 	addi	r5,r5,9684
8110220c:	1009883a 	mov	r4,r2
81102210:	11207b80 	call	811207b8 <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
81102214:	e03ff615 	stw	zero,-40(fp)
81102218:	d0a08817 	ldw	r2,-32224(gp)

	TimeStart = alt_nticks();
8110221c:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102220:	e0bfef17 	ldw	r2,-68(fp)
81102224:	e0bff115 	stw	r2,-60(fp)
81102228:	00002c06 	br	811022dc <bDdr2MemoryRandomWriteTest+0x2d0>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
8110222c:	e0bff804 	addi	r2,fp,-32
81102230:	1009883a 	mov	r4,r2
81102234:	11029100 	call	81102910 <uliXorshift32>
81102238:	1007883a 	mov	r3,r2
8110223c:	e0bff117 	ldw	r2,-60(fp)
81102240:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
81102244:	e0bffa17 	ldw	r2,-24(fp)
81102248:	10800060 	cmpeqi	r2,r2,1
8110224c:	1009883a 	mov	r4,r2
81102250:	e0bff117 	ldw	r2,-60(fp)
81102254:	e0fff217 	ldw	r3,-56(fp)
81102258:	1885803a 	cmpltu	r2,r3,r2
8110225c:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
81102260:	10803fcc 	andi	r2,r2,255
81102264:	10001a26 	beq	r2,zero,811022d0 <bDdr2MemoryRandomWriteTest+0x2c4>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102268:	e0bff303 	ldbu	r2,-52(fp)
8110226c:	100d883a 	mov	r6,r2
81102270:	01604574 	movhi	r5,33045
81102274:	296c1f04 	addi	r5,r5,-20356
81102278:	01204574 	movhi	r4,33045
8110227c:	21097504 	addi	r4,r4,9684
81102280:	11221480 	call	81122148 <sprintf>
			debug(fp, cDebugBuffer);
81102284:	d0a06117 	ldw	r2,-32380(gp)
81102288:	01604574 	movhi	r5,33045
8110228c:	29497504 	addi	r5,r5,9684
81102290:	1009883a 	mov	r4,r2
81102294:	11207b80 	call	811207b8 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102298:	e0fff017 	ldw	r3,-64(fp)
8110229c:	00b33374 	movhi	r2,52429
811022a0:	10b33344 	addi	r2,r2,-13107
811022a4:	1888383a 	mulxuu	r4,r3,r2
811022a8:	1885383a 	mul	r2,r3,r2
811022ac:	1021883a 	mov	r16,r2
811022b0:	2023883a 	mov	r17,r4
811022b4:	8804d13a 	srli	r2,r17,4
811022b8:	e0fff217 	ldw	r3,-56(fp)
811022bc:	1885883a 	add	r2,r3,r2
811022c0:	e0bff215 	stw	r2,-56(fp)
			ucPercentage += 5;
811022c4:	e0bff303 	ldbu	r2,-52(fp)
811022c8:	10800144 	addi	r2,r2,5
811022cc:	e0bff305 	stb	r2,-52(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
811022d0:	e0bff117 	ldw	r2,-60(fp)
811022d4:	10800104 	addi	r2,r2,4
811022d8:	e0bff115 	stw	r2,-60(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
811022dc:	e0fff117 	ldw	r3,-60(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
811022e0:	e0bff517 	ldw	r2,-44(fp)
811022e4:	18bfd136 	bltu	r3,r2,8110222c <__reset+0xfb0e222c>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
811022e8:	11356a80 	call	811356a8 <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
811022ec:	e0bffa17 	ldw	r2,-24(fp)
811022f0:	10800058 	cmpnei	r2,r2,1
811022f4:	10000a1e 	bne	r2,zero,81102320 <bDdr2MemoryRandomWriteTest+0x314>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811022f8:	01604574 	movhi	r5,33045
811022fc:	296c2204 	addi	r5,r5,-20344
81102300:	01204574 	movhi	r4,33045
81102304:	21097504 	addi	r4,r4,9684
81102308:	11221480 	call	81122148 <sprintf>
		debug(fp, cDebugBuffer);
8110230c:	d0a06117 	ldw	r2,-32380(gp)
81102310:	01604574 	movhi	r5,33045
81102314:	29497504 	addi	r5,r5,9684
81102318:	1009883a 	mov	r4,r2
8110231c:	11207b80 	call	811207b8 <fprintf>
#endif
	}

	if (bSuccess) {
81102320:	e0bff417 	ldw	r2,-48(fp)
81102324:	10003126 	beq	r2,zero,811023ec <bDdr2MemoryRandomWriteTest+0x3e0>
		if (bTime == TRUE) {
81102328:	e0bffb17 	ldw	r2,-20(fp)
8110232c:	10800058 	cmpnei	r2,r2,1
81102330:	1000221e 	bne	r2,zero,811023bc <bDdr2MemoryRandomWriteTest+0x3b0>
81102334:	d0e08817 	ldw	r3,-32224(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102338:	e0bff717 	ldw	r2,-36(fp)
8110233c:	1885c83a 	sub	r2,r3,r2
81102340:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
81102344:	e13ff617 	ldw	r4,-40(fp)
81102348:	111eeb00 	call	8111eeb0 <__floatsisf>
8110234c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102350:	d0a08717 	ldw	r2,-32228(gp)
81102354:	1009883a 	mov	r4,r2
81102358:	111efdc0 	call	8111efdc <__floatunsisf>
8110235c:	1007883a 	mov	r3,r2
81102360:	180b883a 	mov	r5,r3
81102364:	8009883a 	mov	r4,r16
81102368:	111e6640 	call	8111e664 <__divsf3>
8110236c:	1007883a 	mov	r3,r2
81102370:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
81102374:	1009883a 	mov	r4,r2
81102378:	11203380 	call	81120338 <__extendsfdf2>
8110237c:	1009883a 	mov	r4,r2
81102380:	180b883a 	mov	r5,r3
81102384:	d9400015 	stw	r5,0(sp)
81102388:	200f883a 	mov	r7,r4
8110238c:	e1bff017 	ldw	r6,-64(fp)
81102390:	01604574 	movhi	r5,33045
81102394:	296c2504 	addi	r5,r5,-20332
81102398:	01204574 	movhi	r4,33045
8110239c:	21097504 	addi	r4,r4,9684
811023a0:	11221480 	call	81122148 <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811023a4:	d0a06117 	ldw	r2,-32380(gp)
811023a8:	01604574 	movhi	r5,33045
811023ac:	29497504 	addi	r5,r5,9684
811023b0:	1009883a 	mov	r4,r2
811023b4:	11207b80 	call	811207b8 <fprintf>
811023b8:	00001b06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
811023bc:	e1bff017 	ldw	r6,-64(fp)
811023c0:	01604574 	movhi	r5,33045
811023c4:	296c3104 	addi	r5,r5,-20284
811023c8:	01204574 	movhi	r4,33045
811023cc:	21097504 	addi	r4,r4,9684
811023d0:	11221480 	call	81122148 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
811023d4:	d0a06117 	ldw	r2,-32380(gp)
811023d8:	01604574 	movhi	r5,33045
811023dc:	29497504 	addi	r5,r5,9684
811023e0:	1009883a 	mov	r4,r2
811023e4:	11207b80 	call	811207b8 <fprintf>
811023e8:	00000f06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
811023ec:	00e04574 	movhi	r3,33045
811023f0:	18c97504 	addi	r3,r3,9684
811023f4:	00a04574 	movhi	r2,33045
811023f8:	10abce04 	addi	r2,r2,-20680
811023fc:	1009883a 	mov	r4,r2
81102400:	00800584 	movi	r2,22
81102404:	100d883a 	mov	r6,r2
81102408:	200b883a 	mov	r5,r4
8110240c:	1809883a 	mov	r4,r3
81102410:	11218680 	call	81121868 <memcpy>
		debug(fp, cDebugBuffer);
81102414:	d0a06117 	ldw	r2,-32380(gp)
81102418:	01604574 	movhi	r5,33045
8110241c:	29497504 	addi	r5,r5,9684
81102420:	1009883a 	mov	r4,r2
81102424:	11207b80 	call	811207b8 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102428:	00a04574 	movhi	r2,33045
8110242c:	10897504 	addi	r2,r2,9684
81102430:	00c00284 	movi	r3,10
81102434:	10c00005 	stb	r3,0(r2)
81102438:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110243c:	d0a06117 	ldw	r2,-32380(gp)
81102440:	01604574 	movhi	r5,33045
81102444:	29497504 	addi	r5,r5,9684
81102448:	1009883a 	mov	r4,r2
8110244c:	11207b80 	call	811207b8 <fprintf>
#endif

	return bSuccess;
81102450:	e0bff417 	ldw	r2,-48(fp)
}
81102454:	e6fffc04 	addi	sp,fp,-16
81102458:	dfc00517 	ldw	ra,20(sp)
8110245c:	df000417 	ldw	fp,16(sp)
81102460:	dcc00317 	ldw	r19,12(sp)
81102464:	dc800217 	ldw	r18,8(sp)
81102468:	dc400117 	ldw	r17,4(sp)
8110246c:	dc000017 	ldw	r16,0(sp)
81102470:	dec00604 	addi	sp,sp,24
81102474:	f800283a 	ret

81102478 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102478:	deffec04 	addi	sp,sp,-80
8110247c:	de00012e 	bgeu	sp,et,81102484 <bDdr2MemoryRandomReadTest+0xc>
81102480:	003b68fa 	trap	3
81102484:	dfc01315 	stw	ra,76(sp)
81102488:	df001215 	stw	fp,72(sp)
8110248c:	dcc01115 	stw	r19,68(sp)
81102490:	dc801015 	stw	r18,64(sp)
81102494:	dc400f15 	stw	r17,60(sp)
81102498:	dc000e15 	stw	r16,56(sp)
8110249c:	df001204 	addi	fp,sp,72
811024a0:	2005883a 	mov	r2,r4
811024a4:	e17ffa15 	stw	r5,-24(fp)
811024a8:	e1bffb15 	stw	r6,-20(fp)
811024ac:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
811024b0:	00e04574 	movhi	r3,33045
811024b4:	18c97504 	addi	r3,r3,9684
811024b8:	00a04574 	movhi	r2,33045
811024bc:	10ac3b04 	addi	r2,r2,-20244
811024c0:	1009883a 	mov	r4,r2
811024c4:	00800b84 	movi	r2,46
811024c8:	100d883a 	mov	r6,r2
811024cc:	200b883a 	mov	r5,r4
811024d0:	1809883a 	mov	r4,r3
811024d4:	11218680 	call	81121868 <memcpy>
	debug(fp, cDebugBuffer);
811024d8:	d0a06117 	ldw	r2,-32380(gp)
811024dc:	01604574 	movhi	r5,33045
811024e0:	29497504 	addi	r5,r5,9684
811024e4:	1009883a 	mov	r4,r2
811024e8:	11207b80 	call	811207b8 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811024ec:	00800044 	movi	r2,1
811024f0:	e0bfef15 	stw	r2,-68(fp)
	switch (ucMemoryId) {
811024f4:	e0bff903 	ldbu	r2,-28(fp)
811024f8:	10000326 	beq	r2,zero,81102508 <bDdr2MemoryRandomReadTest+0x90>
811024fc:	10800060 	cmpeqi	r2,r2,1
81102500:	1000081e 	bne	r2,zero,81102524 <bDdr2MemoryRandomReadTest+0xac>
81102504:	00000e06 	br	81102540 <bDdr2MemoryRandomReadTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102508:	e0bff903 	ldbu	r2,-28(fp)
8110250c:	1009883a 	mov	r4,r2
81102510:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102514:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81102518:	00a00034 	movhi	r2,32768
8110251c:	e0bff115 	stw	r2,-60(fp)
		break;
81102520:	00001906 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102524:	e0bff903 	ldbu	r2,-28(fp)
81102528:	1009883a 	mov	r4,r2
8110252c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102530:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102534:	00a00034 	movhi	r2,32768
81102538:	e0bff115 	stw	r2,-60(fp)
		break;
8110253c:	00001206 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	default:
		bSuccess = FALSE;
81102540:	e03fef15 	stw	zero,-68(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81102544:	00e04574 	movhi	r3,33045
81102548:	18c97504 	addi	r3,r3,9684
8110254c:	00a04574 	movhi	r2,33045
81102550:	10a9bc04 	addi	r2,r2,-22800
81102554:	1009883a 	mov	r4,r2
81102558:	00800bc4 	movi	r2,47
8110255c:	100d883a 	mov	r6,r2
81102560:	200b883a 	mov	r5,r4
81102564:	1809883a 	mov	r4,r3
81102568:	11218680 	call	81121868 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
8110256c:	d0a06117 	ldw	r2,-32380(gp)
81102570:	01604574 	movhi	r5,33045
81102574:	29497504 	addi	r5,r5,9684
81102578:	1009883a 	mov	r4,r2
8110257c:	11207b80 	call	811207b8 <fprintf>
		;
#endif
		return bSuccess;
81102580:	e0bfef17 	ldw	r2,-68(fp)
81102584:	0000d906 	br	811028ec <bDdr2MemoryRandomReadTest+0x474>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102588:	e0bff117 	ldw	r2,-60(fp)
8110258c:	1004d53a 	srli	r2,r2,20
81102590:	100d883a 	mov	r6,r2
81102594:	01604574 	movhi	r5,33045
81102598:	296bb504 	addi	r5,r5,-20780
8110259c:	01204574 	movhi	r4,33045
811025a0:	21097504 	addi	r4,r4,9684
811025a4:	11221480 	call	81122148 <sprintf>
	debug(fp, cDebugBuffer);
811025a8:	d0a06117 	ldw	r2,-32380(gp)
811025ac:	01604574 	movhi	r5,33045
811025b0:	29497504 	addi	r5,r5,9684
811025b4:	1009883a 	mov	r4,r2
811025b8:	11207b80 	call	811207b8 <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
811025bc:	d0a03717 	ldw	r2,-32548(gp)
811025c0:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
811025c4:	e0fff017 	ldw	r3,-64(fp)
811025c8:	e0bff117 	ldw	r2,-60(fp)
811025cc:	1885883a 	add	r2,r3,r2
811025d0:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
811025d4:	e0fff117 	ldw	r3,-60(fp)
811025d8:	00b33374 	movhi	r2,52429
811025dc:	10b33344 	addi	r2,r2,-13107
811025e0:	1888383a 	mulxuu	r4,r3,r2
811025e4:	1885383a 	mul	r2,r3,r2
811025e8:	1025883a 	mov	r18,r2
811025ec:	2027883a 	mov	r19,r4
811025f0:	9806d13a 	srli	r3,r19,4
811025f4:	e0bff017 	ldw	r2,-64(fp)
811025f8:	1885883a 	add	r2,r3,r2
811025fc:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
81102600:	00800144 	movi	r2,5
81102604:	e0bff405 	stb	r2,-48(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
81102608:	00e04574 	movhi	r3,33045
8110260c:	18c97504 	addi	r3,r3,9684
81102610:	00a04574 	movhi	r2,33045
81102614:	10ac4704 	addi	r2,r2,-20196
81102618:	1009883a 	mov	r4,r2
8110261c:	00800604 	movi	r2,24
81102620:	100d883a 	mov	r6,r2
81102624:	200b883a 	mov	r5,r4
81102628:	1809883a 	mov	r4,r3
8110262c:	11218680 	call	81121868 <memcpy>
	debug(fp, cDebugBuffer);
81102630:	d0a06117 	ldw	r2,-32380(gp)
81102634:	01604574 	movhi	r5,33045
81102638:	29497504 	addi	r5,r5,9684
8110263c:	1009883a 	mov	r4,r2
81102640:	11207b80 	call	811207b8 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102644:	e0bffa17 	ldw	r2,-24(fp)
81102648:	10800058 	cmpnei	r2,r2,1
8110264c:	10000a1e 	bne	r2,zero,81102678 <bDdr2MemoryRandomReadTest+0x200>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102650:	01604574 	movhi	r5,33045
81102654:	296c1d04 	addi	r5,r5,-20364
81102658:	01204574 	movhi	r4,33045
8110265c:	21097504 	addi	r4,r4,9684
81102660:	11221480 	call	81122148 <sprintf>
		debug(fp, cDebugBuffer);
81102664:	d0a06117 	ldw	r2,-32380(gp)
81102668:	01604574 	movhi	r5,33045
8110266c:	29497504 	addi	r5,r5,9684
81102670:	1009883a 	mov	r4,r2
81102674:	11207b80 	call	811207b8 <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
81102678:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8110267c:	d0a08817 	ldw	r2,-32224(gp)

	TimeStart = alt_nticks();
81102680:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
81102684:	e0bff017 	ldw	r2,-64(fp)
81102688:	e0bff215 	stw	r2,-56(fp)
8110268c:	00003a06 	br	81102778 <bDdr2MemoryRandomReadTest+0x300>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
81102690:	e0bff804 	addi	r2,fp,-32
81102694:	1009883a 	mov	r4,r2
81102698:	11029100 	call	81102910 <uliXorshift32>
8110269c:	1007883a 	mov	r3,r2
811026a0:	e0bff217 	ldw	r2,-56(fp)
811026a4:	10800017 	ldw	r2,0(r2)
811026a8:	18801026 	beq	r3,r2,811026ec <bDdr2MemoryRandomReadTest+0x274>
			bSuccess = FALSE;
811026ac:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
811026b0:	e0bffa17 	ldw	r2,-24(fp)
811026b4:	10800058 	cmpnei	r2,r2,1
811026b8:	10000c1e 	bne	r2,zero,811026ec <bDdr2MemoryRandomReadTest+0x274>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
811026bc:	e0bff217 	ldw	r2,-56(fp)
811026c0:	100d883a 	mov	r6,r2
811026c4:	01604574 	movhi	r5,33045
811026c8:	296c4d04 	addi	r5,r5,-20172
811026cc:	01204574 	movhi	r4,33045
811026d0:	21097504 	addi	r4,r4,9684
811026d4:	11221480 	call	81122148 <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
811026d8:	d0a06117 	ldw	r2,-32380(gp)
811026dc:	01604574 	movhi	r5,33045
811026e0:	29497504 	addi	r5,r5,9684
811026e4:	1009883a 	mov	r4,r2
811026e8:	11207b80 	call	811207b8 <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
811026ec:	e0bffa17 	ldw	r2,-24(fp)
811026f0:	10800058 	cmpnei	r2,r2,1
811026f4:	10001d1e 	bne	r2,zero,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
811026f8:	e0bff217 	ldw	r2,-56(fp)
811026fc:	e0fff317 	ldw	r3,-52(fp)
81102700:	18801a2e 	bgeu	r3,r2,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102704:	e0bff403 	ldbu	r2,-48(fp)
81102708:	100d883a 	mov	r6,r2
8110270c:	01604574 	movhi	r5,33045
81102710:	296c1f04 	addi	r5,r5,-20356
81102714:	01204574 	movhi	r4,33045
81102718:	21097504 	addi	r4,r4,9684
8110271c:	11221480 	call	81122148 <sprintf>
			debug(fp, cDebugBuffer);
81102720:	d0a06117 	ldw	r2,-32380(gp)
81102724:	01604574 	movhi	r5,33045
81102728:	29497504 	addi	r5,r5,9684
8110272c:	1009883a 	mov	r4,r2
81102730:	11207b80 	call	811207b8 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102734:	e0fff117 	ldw	r3,-60(fp)
81102738:	00b33374 	movhi	r2,52429
8110273c:	10b33344 	addi	r2,r2,-13107
81102740:	1888383a 	mulxuu	r4,r3,r2
81102744:	1885383a 	mul	r2,r3,r2
81102748:	1021883a 	mov	r16,r2
8110274c:	2023883a 	mov	r17,r4
81102750:	8804d13a 	srli	r2,r17,4
81102754:	e0fff317 	ldw	r3,-52(fp)
81102758:	1885883a 	add	r2,r3,r2
8110275c:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
81102760:	e0bff403 	ldbu	r2,-48(fp)
81102764:	10800144 	addi	r2,r2,5
81102768:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
8110276c:	e0bff217 	ldw	r2,-56(fp)
81102770:	10800104 	addi	r2,r2,4
81102774:	e0bff215 	stw	r2,-56(fp)
81102778:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
8110277c:	e0bff517 	ldw	r2,-44(fp)
81102780:	18bfc336 	bltu	r3,r2,81102690 <__reset+0xfb0e2690>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
81102784:	e0bffa17 	ldw	r2,-24(fp)
81102788:	10800058 	cmpnei	r2,r2,1
8110278c:	10000a1e 	bne	r2,zero,811027b8 <bDdr2MemoryRandomReadTest+0x340>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
81102790:	01604574 	movhi	r5,33045
81102794:	296c2204 	addi	r5,r5,-20344
81102798:	01204574 	movhi	r4,33045
8110279c:	21097504 	addi	r4,r4,9684
811027a0:	11221480 	call	81122148 <sprintf>
		debug(fp, cDebugBuffer);
811027a4:	d0a06117 	ldw	r2,-32380(gp)
811027a8:	01604574 	movhi	r5,33045
811027ac:	29497504 	addi	r5,r5,9684
811027b0:	1009883a 	mov	r4,r2
811027b4:	11207b80 	call	811207b8 <fprintf>
#endif
	}

	if (bSuccess) {
811027b8:	e0bfef17 	ldw	r2,-68(fp)
811027bc:	10003126 	beq	r2,zero,81102884 <bDdr2MemoryRandomReadTest+0x40c>
		if (bTime == TRUE) {
811027c0:	e0bffb17 	ldw	r2,-20(fp)
811027c4:	10800058 	cmpnei	r2,r2,1
811027c8:	1000221e 	bne	r2,zero,81102854 <bDdr2MemoryRandomReadTest+0x3dc>
811027cc:	d0e08817 	ldw	r3,-32224(gp)
			TimeElapsed = alt_nticks() - TimeStart;
811027d0:	e0bff717 	ldw	r2,-36(fp)
811027d4:	1885c83a 	sub	r2,r3,r2
811027d8:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
811027dc:	e13ff617 	ldw	r4,-40(fp)
811027e0:	111eeb00 	call	8111eeb0 <__floatsisf>
811027e4:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811027e8:	d0a08717 	ldw	r2,-32228(gp)
811027ec:	1009883a 	mov	r4,r2
811027f0:	111efdc0 	call	8111efdc <__floatunsisf>
811027f4:	1007883a 	mov	r3,r2
811027f8:	180b883a 	mov	r5,r3
811027fc:	8009883a 	mov	r4,r16
81102800:	111e6640 	call	8111e664 <__divsf3>
81102804:	1007883a 	mov	r3,r2
81102808:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
8110280c:	1009883a 	mov	r4,r2
81102810:	11203380 	call	81120338 <__extendsfdf2>
81102814:	1009883a 	mov	r4,r2
81102818:	180b883a 	mov	r5,r3
8110281c:	d9400015 	stw	r5,0(sp)
81102820:	200f883a 	mov	r7,r4
81102824:	e1bff117 	ldw	r6,-60(fp)
81102828:	01604574 	movhi	r5,33045
8110282c:	296c5504 	addi	r5,r5,-20140
81102830:	01204574 	movhi	r4,33045
81102834:	21097504 	addi	r4,r4,9684
81102838:	11221480 	call	81122148 <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
8110283c:	d0a06117 	ldw	r2,-32380(gp)
81102840:	01604574 	movhi	r5,33045
81102844:	29497504 	addi	r5,r5,9684
81102848:	1009883a 	mov	r4,r2
8110284c:	11207b80 	call	811207b8 <fprintf>
81102850:	00001b06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
81102854:	e1bff117 	ldw	r6,-60(fp)
81102858:	01604574 	movhi	r5,33045
8110285c:	296c6104 	addi	r5,r5,-20092
81102860:	01204574 	movhi	r4,33045
81102864:	21097504 	addi	r4,r4,9684
81102868:	11221480 	call	81122148 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
8110286c:	d0a06117 	ldw	r2,-32380(gp)
81102870:	01604574 	movhi	r5,33045
81102874:	29497504 	addi	r5,r5,9684
81102878:	1009883a 	mov	r4,r2
8110287c:	11207b80 	call	811207b8 <fprintf>
81102880:	00000f06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81102884:	00e04574 	movhi	r3,33045
81102888:	18c97504 	addi	r3,r3,9684
8110288c:	00a04574 	movhi	r2,33045
81102890:	10ac0504 	addi	r2,r2,-20460
81102894:	1009883a 	mov	r4,r2
81102898:	00800544 	movi	r2,21
8110289c:	100d883a 	mov	r6,r2
811028a0:	200b883a 	mov	r5,r4
811028a4:	1809883a 	mov	r4,r3
811028a8:	11218680 	call	81121868 <memcpy>
		debug(fp, cDebugBuffer);
811028ac:	d0a06117 	ldw	r2,-32380(gp)
811028b0:	01604574 	movhi	r5,33045
811028b4:	29497504 	addi	r5,r5,9684
811028b8:	1009883a 	mov	r4,r2
811028bc:	11207b80 	call	811207b8 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811028c0:	00a04574 	movhi	r2,33045
811028c4:	10897504 	addi	r2,r2,9684
811028c8:	00c00284 	movi	r3,10
811028cc:	10c00005 	stb	r3,0(r2)
811028d0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811028d4:	d0a06117 	ldw	r2,-32380(gp)
811028d8:	01604574 	movhi	r5,33045
811028dc:	29497504 	addi	r5,r5,9684
811028e0:	1009883a 	mov	r4,r2
811028e4:	11207b80 	call	811207b8 <fprintf>
#endif

	return bSuccess;
811028e8:	e0bfef17 	ldw	r2,-68(fp)
}
811028ec:	e6fffc04 	addi	sp,fp,-16
811028f0:	dfc00517 	ldw	ra,20(sp)
811028f4:	df000417 	ldw	fp,16(sp)
811028f8:	dcc00317 	ldw	r19,12(sp)
811028fc:	dc800217 	ldw	r18,8(sp)
81102900:	dc400117 	ldw	r17,4(sp)
81102904:	dc000017 	ldw	r16,0(sp)
81102908:	dec00604 	addi	sp,sp,24
8110290c:	f800283a 	ret

81102910 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
81102910:	defffd04 	addi	sp,sp,-12
81102914:	de00012e 	bgeu	sp,et,8110291c <uliXorshift32+0xc>
81102918:	003b68fa 	trap	3
8110291c:	df000215 	stw	fp,8(sp)
81102920:	df000204 	addi	fp,sp,8
81102924:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
81102928:	e0bfff17 	ldw	r2,-4(fp)
8110292c:	10800017 	ldw	r2,0(r2)
81102930:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81102934:	e0bffe17 	ldw	r2,-8(fp)
81102938:	1004937a 	slli	r2,r2,13
8110293c:	e0fffe17 	ldw	r3,-8(fp)
81102940:	1884f03a 	xor	r2,r3,r2
81102944:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
81102948:	e0bffe17 	ldw	r2,-8(fp)
8110294c:	1004d47a 	srli	r2,r2,17
81102950:	e0fffe17 	ldw	r3,-8(fp)
81102954:	1884f03a 	xor	r2,r3,r2
81102958:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
8110295c:	e0bffe17 	ldw	r2,-8(fp)
81102960:	1004917a 	slli	r2,r2,5
81102964:	e0fffe17 	ldw	r3,-8(fp)
81102968:	1884f03a 	xor	r2,r3,r2
8110296c:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
81102970:	e0bfff17 	ldw	r2,-4(fp)
81102974:	e0fffe17 	ldw	r3,-8(fp)
81102978:	10c00015 	stw	r3,0(r2)

	return uliX;
8110297c:	e0bffe17 	ldw	r2,-8(fp)
}
81102980:	e037883a 	mov	sp,fp
81102984:	df000017 	ldw	fp,0(sp)
81102988:	dec00104 	addi	sp,sp,4
8110298c:	f800283a 	ret

81102990 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
81102990:	defffb04 	addi	sp,sp,-20
81102994:	de00012e 	bgeu	sp,et,8110299c <DMA_OPEN_DEVICE+0xc>
81102998:	003b68fa 	trap	3
8110299c:	dfc00415 	stw	ra,16(sp)
811029a0:	df000315 	stw	fp,12(sp)
811029a4:	df000304 	addi	fp,sp,12
811029a8:	e13ffe15 	stw	r4,-8(fp)
811029ac:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
811029b0:	00800044 	movi	r2,1
811029b4:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
811029b8:	e13fff17 	ldw	r4,-4(fp)
811029bc:	1148f680 	call	81148f68 <alt_msgdma_open>
811029c0:	1007883a 	mov	r3,r2
811029c4:	e0bffe17 	ldw	r2,-8(fp)
811029c8:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
811029cc:	e0bffe17 	ldw	r2,-8(fp)
811029d0:	10800017 	ldw	r2,0(r2)
811029d4:	1000011e 	bne	r2,zero,811029dc <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
811029d8:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
811029dc:	e0bffd17 	ldw	r2,-12(fp)
}
811029e0:	e037883a 	mov	sp,fp
811029e4:	dfc00117 	ldw	ra,4(sp)
811029e8:	df000017 	ldw	fp,0(sp)
811029ec:	dec00204 	addi	sp,sp,8
811029f0:	f800283a 	ret

811029f4 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
811029f4:	defffc04 	addi	sp,sp,-16
811029f8:	de00012e 	bgeu	sp,et,81102a00 <DMA_CONFIG+0xc>
811029fc:	003b68fa 	trap	3
81102a00:	df000315 	stw	fp,12(sp)
81102a04:	df000304 	addi	fp,sp,12
81102a08:	e13ffe15 	stw	r4,-8(fp)
81102a0c:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a10:	00800044 	movi	r2,1
81102a14:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
81102a18:	e0bffe17 	ldw	r2,-8(fp)
81102a1c:	10800317 	ldw	r2,12(r2)
81102a20:	10800104 	addi	r2,r2,4
81102a24:	e0ffff17 	ldw	r3,-4(fp)
81102a28:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
81102a2c:	e0bffd17 	ldw	r2,-12(fp)
}
81102a30:	e037883a 	mov	sp,fp
81102a34:	df000017 	ldw	fp,0(sp)
81102a38:	dec00104 	addi	sp,sp,4
81102a3c:	f800283a 	ret

81102a40 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
81102a40:	defffd04 	addi	sp,sp,-12
81102a44:	de00012e 	bgeu	sp,et,81102a4c <DMA_BUSY+0xc>
81102a48:	003b68fa 	trap	3
81102a4c:	df000215 	stw	fp,8(sp)
81102a50:	df000204 	addi	fp,sp,8
81102a54:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102a58:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102a5c:	e0bfff17 	ldw	r2,-4(fp)
81102a60:	10800317 	ldw	r2,12(r2)
81102a64:	10800037 	ldwio	r2,0(r2)
81102a68:	1080004c 	andi	r2,r2,1
81102a6c:	10000226 	beq	r2,zero,81102a78 <DMA_BUSY+0x38>
    bBusy = TRUE;
81102a70:	00800044 	movi	r2,1
81102a74:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102a78:	e0bffe17 	ldw	r2,-8(fp)
}
81102a7c:	e037883a 	mov	sp,fp
81102a80:	df000017 	ldw	fp,0(sp)
81102a84:	dec00104 	addi	sp,sp,4
81102a88:	f800283a 	ret

81102a8c <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102a8c:	defffd04 	addi	sp,sp,-12
81102a90:	de00012e 	bgeu	sp,et,81102a98 <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102a94:	003b68fa 	trap	3
81102a98:	df000215 	stw	fp,8(sp)
81102a9c:	df000204 	addi	fp,sp,8
81102aa0:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102aa4:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102aa8:	e0bfff17 	ldw	r2,-4(fp)
81102aac:	10800317 	ldw	r2,12(r2)
81102ab0:	10800037 	ldwio	r2,0(r2)
81102ab4:	1080010c 	andi	r2,r2,4
81102ab8:	10000226 	beq	r2,zero,81102ac4 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102abc:	00800044 	movi	r2,1
81102ac0:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102ac4:	e0bffe17 	ldw	r2,-8(fp)
}
81102ac8:	e037883a 	mov	sp,fp
81102acc:	df000017 	ldw	fp,0(sp)
81102ad0:	dec00104 	addi	sp,sp,4
81102ad4:	f800283a 	ret

81102ad8 <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102ad8:	defffd04 	addi	sp,sp,-12
81102adc:	de00012e 	bgeu	sp,et,81102ae4 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102ae0:	003b68fa 	trap	3
81102ae4:	df000215 	stw	fp,8(sp)
81102ae8:	df000204 	addi	fp,sp,8
81102aec:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102af0:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102af4:	e0bfff17 	ldw	r2,-4(fp)
81102af8:	10800317 	ldw	r2,12(r2)
81102afc:	10800037 	ldwio	r2,0(r2)
81102b00:	1080008c 	andi	r2,r2,2
81102b04:	10000226 	beq	r2,zero,81102b10 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102b08:	00800044 	movi	r2,1
81102b0c:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102b10:	e0bffe17 	ldw	r2,-8(fp)
}
81102b14:	e037883a 	mov	sp,fp
81102b18:	df000017 	ldw	fp,0(sp)
81102b1c:	dec00104 	addi	sp,sp,4
81102b20:	f800283a 	ret

81102b24 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b24:	defffa04 	addi	sp,sp,-24
81102b28:	de00012e 	bgeu	sp,et,81102b30 <DMA_DISPATCHER_STOP+0xc>
81102b2c:	003b68fa 	trap	3
81102b30:	dfc00515 	stw	ra,20(sp)
81102b34:	df000415 	stw	fp,16(sp)
81102b38:	df000404 	addi	fp,sp,16
81102b3c:	e13ffd15 	stw	r4,-12(fp)
81102b40:	e17ffe15 	stw	r5,-8(fp)
81102b44:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b48:	00800044 	movi	r2,1
81102b4c:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102b50:	e0bffd17 	ldw	r2,-12(fp)
81102b54:	10800317 	ldw	r2,12(r2)
81102b58:	10800104 	addi	r2,r2,4
81102b5c:	00c00044 	movi	r3,1
81102b60:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102b64:	e0bffe17 	ldw	r2,-8(fp)
81102b68:	10800058 	cmpnei	r2,r2,1
81102b6c:	10000f1e 	bne	r2,zero,81102bac <DMA_DISPATCHER_STOP+0x88>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b70:	00000806 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102b74:	e0bfff17 	ldw	r2,-4(fp)
81102b78:	1000031e 	bne	r2,zero,81102b88 <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102b7c:	01000044 	movi	r4,1
81102b80:	1136ed00 	call	81136ed0 <usleep>
81102b84:	00000306 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      } else {
        usleep(WaitPeriodUs);
81102b88:	e0bfff17 	ldw	r2,-4(fp)
81102b8c:	1009883a 	mov	r4,r2
81102b90:	1136ed00 	call	81136ed0 <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b94:	e0bffd17 	ldw	r2,-12(fp)
81102b98:	10800317 	ldw	r2,12(r2)
81102b9c:	10800037 	ldwio	r2,0(r2)
81102ba0:	1080080c 	andi	r2,r2,32
81102ba4:	103ff31e 	bne	r2,zero,81102b74 <__reset+0xfb0e2b74>
81102ba8:	00000206 	br	81102bb4 <DMA_DISPATCHER_STOP+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102bac:	e0bffc17 	ldw	r2,-16(fp)
81102bb0:	00000106 	br	81102bb8 <DMA_DISPATCHER_STOP+0x94>
  }
  
  return bSuccess;
81102bb4:	e0bffc17 	ldw	r2,-16(fp)
}
81102bb8:	e037883a 	mov	sp,fp
81102bbc:	dfc00117 	ldw	ra,4(sp)
81102bc0:	df000017 	ldw	fp,0(sp)
81102bc4:	dec00204 	addi	sp,sp,8
81102bc8:	f800283a 	ret

81102bcc <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102bcc:	defffa04 	addi	sp,sp,-24
81102bd0:	de00012e 	bgeu	sp,et,81102bd8 <DMA_DISPATCHER_RESET+0xc>
81102bd4:	003b68fa 	trap	3
81102bd8:	dfc00515 	stw	ra,20(sp)
81102bdc:	df000415 	stw	fp,16(sp)
81102be0:	df000404 	addi	fp,sp,16
81102be4:	e13ffd15 	stw	r4,-12(fp)
81102be8:	e17ffe15 	stw	r5,-8(fp)
81102bec:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102bf0:	00800044 	movi	r2,1
81102bf4:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102bf8:	e0bffd17 	ldw	r2,-12(fp)
81102bfc:	10800317 	ldw	r2,12(r2)
81102c00:	10800104 	addi	r2,r2,4
81102c04:	00c00084 	movi	r3,2
81102c08:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102c0c:	e0bffe17 	ldw	r2,-8(fp)
81102c10:	10800058 	cmpnei	r2,r2,1
81102c14:	10000f1e 	bne	r2,zero,81102c54 <DMA_DISPATCHER_RESET+0x88>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c18:	00000806 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102c1c:	e0bfff17 	ldw	r2,-4(fp)
81102c20:	1000031e 	bne	r2,zero,81102c30 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102c24:	01000044 	movi	r4,1
81102c28:	1136ed00 	call	81136ed0 <usleep>
81102c2c:	00000306 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      } else {
        usleep(WaitPeriodUs);
81102c30:	e0bfff17 	ldw	r2,-4(fp)
81102c34:	1009883a 	mov	r4,r2
81102c38:	1136ed00 	call	81136ed0 <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c3c:	e0bffd17 	ldw	r2,-12(fp)
81102c40:	10800317 	ldw	r2,12(r2)
81102c44:	10800037 	ldwio	r2,0(r2)
81102c48:	1080100c 	andi	r2,r2,64
81102c4c:	103ff31e 	bne	r2,zero,81102c1c <__reset+0xfb0e2c1c>
81102c50:	00000206 	br	81102c5c <DMA_DISPATCHER_RESET+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102c54:	e0bffc17 	ldw	r2,-16(fp)
81102c58:	00000106 	br	81102c60 <DMA_DISPATCHER_RESET+0x94>
  }
  
  return bSuccess;
81102c5c:	e0bffc17 	ldw	r2,-16(fp)
}
81102c60:	e037883a 	mov	sp,fp
81102c64:	dfc00117 	ldw	ra,4(sp)
81102c68:	df000017 	ldw	fp,0(sp)
81102c6c:	dec00204 	addi	sp,sp,8
81102c70:	f800283a 	ret

81102c74 <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102c74:	defff604 	addi	sp,sp,-40
81102c78:	de00012e 	bgeu	sp,et,81102c80 <DMA_SINGLE_TRANSFER+0xc>
81102c7c:	003b68fa 	trap	3
81102c80:	dfc00915 	stw	ra,36(sp)
81102c84:	df000815 	stw	fp,32(sp)
81102c88:	dc000715 	stw	r16,28(sp)
81102c8c:	df000804 	addi	fp,sp,32
81102c90:	e13ffb15 	stw	r4,-20(fp)
81102c94:	e17ffc15 	stw	r5,-16(fp)
81102c98:	e1bffd15 	stw	r6,-12(fp)
81102c9c:	e1fffe15 	stw	r7,-8(fp)
81102ca0:	defff804 	addi	sp,sp,-32
81102ca4:	d8800204 	addi	r2,sp,8
81102ca8:	108003c4 	addi	r2,r2,15
81102cac:	1004d13a 	srli	r2,r2,4
81102cb0:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102cb4:	00800044 	movi	r2,1
81102cb8:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102cbc:	e0fffc17 	ldw	r3,-16(fp)
81102cc0:	e13ffd17 	ldw	r4,-12(fp)
81102cc4:	e0800217 	ldw	r2,8(fp)
81102cc8:	d8800115 	stw	r2,4(sp)
81102ccc:	e0bffe17 	ldw	r2,-8(fp)
81102cd0:	d8800015 	stw	r2,0(sp)
81102cd4:	200f883a 	mov	r7,r4
81102cd8:	180d883a 	mov	r6,r3
81102cdc:	800b883a 	mov	r5,r16
81102ce0:	e13ffb17 	ldw	r4,-20(fp)
81102ce4:	1147f640 	call	81147f64 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102ce8:	10000326 	beq	r2,zero,81102cf8 <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102cec:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102cf0:	e0bffa17 	ldw	r2,-24(fp)
81102cf4:	00001e06 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102cf8:	800b883a 	mov	r5,r16
81102cfc:	e13ffb17 	ldw	r4,-20(fp)
81102d00:	11491d80 	call	811491d8 <alt_msgdma_standard_descriptor_async_transfer>
81102d04:	10000326 	beq	r2,zero,81102d14 <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102d08:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102d0c:	e0bffa17 	ldw	r2,-24(fp)
81102d10:	00001706 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102d14:	e0bffa17 	ldw	r2,-24(fp)
81102d18:	10800060 	cmpeqi	r2,r2,1
81102d1c:	1007883a 	mov	r3,r2
81102d20:	e0800317 	ldw	r2,12(fp)
81102d24:	10800060 	cmpeqi	r2,r2,1
81102d28:	1884703a 	and	r2,r3,r2
81102d2c:	10803fcc 	andi	r2,r2,255
81102d30:	10000e26 	beq	r2,zero,81102d6c <DMA_SINGLE_TRANSFER+0xf8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d34:	00000806 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102d38:	e0800417 	ldw	r2,16(fp)
81102d3c:	1000031e 	bne	r2,zero,81102d4c <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102d40:	0100fa04 	movi	r4,1000
81102d44:	1136ed00 	call	81136ed0 <usleep>
81102d48:	00000306 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      } else {
        usleep(WaitPeriodUs);
81102d4c:	e0800417 	ldw	r2,16(fp)
81102d50:	1009883a 	mov	r4,r2
81102d54:	1136ed00 	call	81136ed0 <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d58:	e0bffb17 	ldw	r2,-20(fp)
81102d5c:	10800317 	ldw	r2,12(r2)
81102d60:	10800037 	ldwio	r2,0(r2)
81102d64:	1080004c 	andi	r2,r2,1
81102d68:	103ff31e 	bne	r2,zero,81102d38 <__reset+0xfb0e2d38>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102d6c:	e0bffa17 	ldw	r2,-24(fp)
}
81102d70:	e6ffff04 	addi	sp,fp,-4
81102d74:	dfc00217 	ldw	ra,8(sp)
81102d78:	df000117 	ldw	fp,4(sp)
81102d7c:	dc000017 	ldw	r16,0(sp)
81102d80:	dec00304 	addi	sp,sp,12
81102d84:	f800283a 	ret

81102d88 <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102d88:	defff504 	addi	sp,sp,-44
81102d8c:	de00012e 	bgeu	sp,et,81102d94 <DMA_MULTIPLE_TRANSFER+0xc>
81102d90:	003b68fa 	trap	3
81102d94:	dfc00a15 	stw	ra,40(sp)
81102d98:	df000915 	stw	fp,36(sp)
81102d9c:	dc000815 	stw	r16,32(sp)
81102da0:	df000904 	addi	fp,sp,36
81102da4:	e13ffb15 	stw	r4,-20(fp)
81102da8:	e17ffc15 	stw	r5,-16(fp)
81102dac:	e1bffd15 	stw	r6,-12(fp)
81102db0:	3805883a 	mov	r2,r7
81102db4:	e0bffe05 	stb	r2,-8(fp)
81102db8:	defff804 	addi	sp,sp,-32
81102dbc:	d8800204 	addi	r2,sp,8
81102dc0:	108003c4 	addi	r2,r2,15
81102dc4:	1004d13a 	srli	r2,r2,4
81102dc8:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102dcc:	00800044 	movi	r2,1
81102dd0:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102dd4:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102dd8:	00002506 	br	81102e70 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102ddc:	e0bffa03 	ldbu	r2,-24(fp)
81102de0:	1085883a 	add	r2,r2,r2
81102de4:	1085883a 	add	r2,r2,r2
81102de8:	1007883a 	mov	r3,r2
81102dec:	e0bffc17 	ldw	r2,-16(fp)
81102df0:	10c5883a 	add	r2,r2,r3
81102df4:	10800017 	ldw	r2,0(r2)
81102df8:	1009883a 	mov	r4,r2
81102dfc:	e0bffa03 	ldbu	r2,-24(fp)
81102e00:	1085883a 	add	r2,r2,r2
81102e04:	1085883a 	add	r2,r2,r2
81102e08:	1007883a 	mov	r3,r2
81102e0c:	e0bffd17 	ldw	r2,-12(fp)
81102e10:	10c5883a 	add	r2,r2,r3
81102e14:	10800017 	ldw	r2,0(r2)
81102e18:	1007883a 	mov	r3,r2
81102e1c:	e0800317 	ldw	r2,12(fp)
81102e20:	10804034 	orhi	r2,r2,256
81102e24:	d8800115 	stw	r2,4(sp)
81102e28:	e0800217 	ldw	r2,8(fp)
81102e2c:	d8800015 	stw	r2,0(sp)
81102e30:	180f883a 	mov	r7,r3
81102e34:	200d883a 	mov	r6,r4
81102e38:	800b883a 	mov	r5,r16
81102e3c:	e13ffb17 	ldw	r4,-20(fp)
81102e40:	1147f640 	call	81147f64 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102e44:	10000226 	beq	r2,zero,81102e50 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102e48:	e03ff915 	stw	zero,-28(fp)
81102e4c:	00000506 	br	81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102e50:	800b883a 	mov	r5,r16
81102e54:	e13ffb17 	ldw	r4,-20(fp)
81102e58:	11491d80 	call	811491d8 <alt_msgdma_standard_descriptor_async_transfer>
81102e5c:	10000126 	beq	r2,zero,81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102e60:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102e64:	e0bffa03 	ldbu	r2,-24(fp)
81102e68:	10800044 	addi	r2,r2,1
81102e6c:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e70:	e0bff917 	ldw	r2,-28(fp)
81102e74:	10800060 	cmpeqi	r2,r2,1
81102e78:	1009883a 	mov	r4,r2
81102e7c:	e0fffa03 	ldbu	r3,-24(fp)
81102e80:	e0bffe03 	ldbu	r2,-8(fp)
81102e84:	10bfffc4 	addi	r2,r2,-1
81102e88:	1884803a 	cmplt	r2,r3,r2
81102e8c:	2084703a 	and	r2,r4,r2
81102e90:	10803fcc 	andi	r2,r2,255
81102e94:	103fd11e 	bne	r2,zero,81102ddc <__reset+0xfb0e2ddc>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102e98:	e0bff917 	ldw	r2,-28(fp)
81102e9c:	10800058 	cmpnei	r2,r2,1
81102ea0:	1000211e 	bne	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102ea4:	e0bffa03 	ldbu	r2,-24(fp)
81102ea8:	1085883a 	add	r2,r2,r2
81102eac:	1085883a 	add	r2,r2,r2
81102eb0:	1007883a 	mov	r3,r2
81102eb4:	e0bffc17 	ldw	r2,-16(fp)
81102eb8:	10c5883a 	add	r2,r2,r3
81102ebc:	10800017 	ldw	r2,0(r2)
81102ec0:	1009883a 	mov	r4,r2
81102ec4:	e0bffa03 	ldbu	r2,-24(fp)
81102ec8:	1085883a 	add	r2,r2,r2
81102ecc:	1085883a 	add	r2,r2,r2
81102ed0:	1007883a 	mov	r3,r2
81102ed4:	e0bffd17 	ldw	r2,-12(fp)
81102ed8:	10c5883a 	add	r2,r2,r3
81102edc:	10800017 	ldw	r2,0(r2)
81102ee0:	1007883a 	mov	r3,r2
81102ee4:	e0800317 	ldw	r2,12(fp)
81102ee8:	d8800115 	stw	r2,4(sp)
81102eec:	e0800217 	ldw	r2,8(fp)
81102ef0:	d8800015 	stw	r2,0(sp)
81102ef4:	180f883a 	mov	r7,r3
81102ef8:	200d883a 	mov	r6,r4
81102efc:	800b883a 	mov	r5,r16
81102f00:	e13ffb17 	ldw	r4,-20(fp)
81102f04:	1147f640 	call	81147f64 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102f08:	10000226 	beq	r2,zero,81102f14 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102f0c:	e03ff915 	stw	zero,-28(fp)
81102f10:	00000506 	br	81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102f14:	800b883a 	mov	r5,r16
81102f18:	e13ffb17 	ldw	r4,-20(fp)
81102f1c:	11491d80 	call	811491d8 <alt_msgdma_standard_descriptor_async_transfer>
81102f20:	10000126 	beq	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102f24:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102f28:	e0bff917 	ldw	r2,-28(fp)
81102f2c:	10800060 	cmpeqi	r2,r2,1
81102f30:	1007883a 	mov	r3,r2
81102f34:	e0800417 	ldw	r2,16(fp)
81102f38:	10800060 	cmpeqi	r2,r2,1
81102f3c:	1884703a 	and	r2,r3,r2
81102f40:	10803fcc 	andi	r2,r2,255
81102f44:	10000e26 	beq	r2,zero,81102f80 <DMA_MULTIPLE_TRANSFER+0x1f8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f48:	00000806 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102f4c:	e0800517 	ldw	r2,20(fp)
81102f50:	1000031e 	bne	r2,zero,81102f60 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102f54:	0100fa04 	movi	r4,1000
81102f58:	1136ed00 	call	81136ed0 <usleep>
81102f5c:	00000306 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      } else {
    	usleep(WaitPeriodUs);
81102f60:	e0800517 	ldw	r2,20(fp)
81102f64:	1009883a 	mov	r4,r2
81102f68:	1136ed00 	call	81136ed0 <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f6c:	e0bffb17 	ldw	r2,-20(fp)
81102f70:	10800317 	ldw	r2,12(r2)
81102f74:	10800037 	ldwio	r2,0(r2)
81102f78:	1080004c 	andi	r2,r2,1
81102f7c:	103ff31e 	bne	r2,zero,81102f4c <__reset+0xfb0e2f4c>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102f80:	e0bff917 	ldw	r2,-28(fp)
}
81102f84:	e6ffff04 	addi	sp,fp,-4
81102f88:	dfc00217 	ldw	ra,8(sp)
81102f8c:	df000117 	ldw	fp,4(sp)
81102f90:	dc000017 	ldw	r16,0(sp)
81102f94:	dec00304 	addi	sp,sp,12
81102f98:	f800283a 	ret

81102f9c <POWER_Read>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102f9c:	deffef04 	addi	sp,sp,-68
81102fa0:	de00012e 	bgeu	sp,et,81102fa8 <POWER_Read+0xc>
81102fa4:	003b68fa 	trap	3
81102fa8:	dfc01015 	stw	ra,64(sp)
81102fac:	df000f15 	stw	fp,60(sp)
81102fb0:	df000f04 	addi	fp,sp,60
81102fb4:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
81102fb8:	00800044 	movi	r2,1
81102fbc:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81102fc0:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81102fc4:	00800204 	movi	r2,8
81102fc8:	e0bffc15 	stw	r2,-16(fp)
81102fcc:	00800104 	movi	r2,4
81102fd0:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81102fd4:	00800044 	movi	r2,1
81102fd8:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81102fdc:	00800044 	movi	r2,1
81102fe0:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81102fe4:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81102fe8:	e03ff515 	stw	zero,-44(fp)
81102fec:	00009206 	br	81103238 <POWER_Read+0x29c>
		NextChannel = 0;
81102ff0:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81102ff4:	e0bff517 	ldw	r2,-44(fp)
81102ff8:	10c03fcc 	andi	r3,r2,255
81102ffc:	e13ffa03 	ldbu	r4,-24(fp)
81103000:	e0bfff17 	ldw	r2,-4(fp)
81103004:	d8800115 	stw	r2,4(sp)
81103008:	e0bff917 	ldw	r2,-28(fp)
8110300c:	d8800015 	stw	r2,0(sp)
81103010:	e1fff817 	ldw	r7,-32(fp)
81103014:	e1bff717 	ldw	r6,-36(fp)
81103018:	200b883a 	mov	r5,r4
8110301c:	1809883a 	mov	r4,r3
81103020:	110be440 	call	8110be44 <POWER_SPI_RW>
81103024:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103028:	e03ff415 	stw	zero,-48(fp)
8110302c:	00007406 	br	81103200 <POWER_Read+0x264>
			NextChannel = i + 1;
81103030:	e0bff417 	ldw	r2,-48(fp)
81103034:	10800044 	addi	r2,r2,1
81103038:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
8110303c:	e0bff517 	ldw	r2,-44(fp)
81103040:	10c03fcc 	andi	r3,r2,255
81103044:	e13ffa03 	ldbu	r4,-24(fp)
81103048:	e0bffe04 	addi	r2,fp,-8
8110304c:	d8800115 	stw	r2,4(sp)
81103050:	e0bff917 	ldw	r2,-28(fp)
81103054:	d8800015 	stw	r2,0(sp)
81103058:	e1fff817 	ldw	r7,-32(fp)
8110305c:	e1bff717 	ldw	r6,-36(fp)
81103060:	200b883a 	mov	r5,r4
81103064:	1809883a 	mov	r4,r3
81103068:	110be440 	call	8110be44 <POWER_SPI_RW>
8110306c:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
81103070:	e0bff317 	ldw	r2,-52(fp)
81103074:	10005026 	beq	r2,zero,811031b8 <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
81103078:	e0bffe17 	ldw	r2,-8(fp)
8110307c:	1004d7ba 	srli	r2,r2,30
81103080:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
81103084:	e0bffe17 	ldw	r2,-8(fp)
81103088:	1004d07a 	srli	r2,r2,1
8110308c:	108001cc 	andi	r2,r2,7
81103090:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
81103094:	e0bffe17 	ldw	r2,-8(fp)
81103098:	1004d13a 	srli	r2,r2,4
8110309c:	1080004c 	andi	r2,r2,1
811030a0:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
811030a4:	e0bffe17 	ldw	r2,-8(fp)
811030a8:	1004d17a 	srli	r2,r2,5
811030ac:	1080004c 	andi	r2,r2,1
811030b0:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
811030b4:	e0bffe17 	ldw	r2,-8(fp)
811030b8:	1080004c 	andi	r2,r2,1
811030bc:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
811030c0:	e0bffa43 	ldbu	r2,-23(fp)
811030c4:	10000d26 	beq	r2,zero,811030fc <POWER_Read+0x160>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
811030c8:	e1bff417 	ldw	r6,-48(fp)
811030cc:	01604574 	movhi	r5,33045
811030d0:	296c6b04 	addi	r5,r5,-20052
811030d4:	01204574 	movhi	r4,33045
811030d8:	21097504 	addi	r4,r4,9684
811030dc:	11221480 	call	81122148 <sprintf>
					debug(fp, cDebugBuffer);
811030e0:	d0a06117 	ldw	r2,-32380(gp)
811030e4:	01604574 	movhi	r5,33045
811030e8:	29497504 	addi	r5,r5,9684
811030ec:	1009883a 	mov	r4,r2
811030f0:	11207b80 	call	811207b8 <fprintf>
#endif
					bSuccess = FALSE;
811030f4:	e03ff315 	stw	zero,-52(fp)
811030f8:	00002206 	br	81103184 <POWER_Read+0x1e8>
				} else if (Channel != i) {
811030fc:	e0fffa83 	ldbu	r3,-22(fp)
81103100:	e0bff417 	ldw	r2,-48(fp)
81103104:	18801026 	beq	r3,r2,81103148 <POWER_Read+0x1ac>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer,
81103108:	e0bffa83 	ldbu	r2,-22(fp)
8110310c:	d8800015 	stw	r2,0(sp)
81103110:	e1fff417 	ldw	r7,-48(fp)
81103114:	e1bff417 	ldw	r6,-48(fp)
81103118:	01604574 	movhi	r5,33045
8110311c:	296c7104 	addi	r5,r5,-20028
81103120:	01204574 	movhi	r4,33045
81103124:	21097504 	addi	r4,r4,9684
81103128:	11221480 	call	81122148 <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
8110312c:	d0a06117 	ldw	r2,-32380(gp)
81103130:	01604574 	movhi	r5,33045
81103134:	29497504 	addi	r5,r5,9684
81103138:	1009883a 	mov	r4,r2
8110313c:	11207b80 	call	811207b8 <fprintf>
#endif
					bSuccess = FALSE;
81103140:	e03ff315 	stw	zero,-52(fp)
81103144:	00000f06 	br	81103184 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
81103148:	e0fffac3 	ldbu	r3,-21(fp)
8110314c:	e0bff817 	ldw	r2,-32(fp)
81103150:	18800c26 	beq	r3,r2,81103184 <POWER_Read+0x1e8>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
81103154:	e1bff417 	ldw	r6,-48(fp)
81103158:	01604574 	movhi	r5,33045
8110315c:	296c7d04 	addi	r5,r5,-19980
81103160:	01204574 	movhi	r4,33045
81103164:	21097504 	addi	r4,r4,9684
81103168:	11221480 	call	81122148 <sprintf>
					debug(fp, cDebugBuffer);
8110316c:	d0a06117 	ldw	r2,-32380(gp)
81103170:	01604574 	movhi	r5,33045
81103174:	29497504 	addi	r5,r5,9684
81103178:	1009883a 	mov	r4,r2
8110317c:	11207b80 	call	811207b8 <fprintf>
#endif
					bSuccess = FALSE;
81103180:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
81103184:	e0bff317 	ldw	r2,-52(fp)
81103188:	10001a26 	beq	r2,zero,811031f4 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
8110318c:	e0bff617 	ldw	r2,-40(fp)
81103190:	10c00044 	addi	r3,r2,1
81103194:	e0fff615 	stw	r3,-40(fp)
81103198:	1085883a 	add	r2,r2,r2
8110319c:	1085883a 	add	r2,r2,r2
811031a0:	1007883a 	mov	r3,r2
811031a4:	e0bfff17 	ldw	r2,-4(fp)
811031a8:	10c5883a 	add	r2,r2,r3
811031ac:	e0fffe17 	ldw	r3,-8(fp)
811031b0:	10c00015 	stw	r3,0(r2)
811031b4:	00000f06 	br	811031f4 <POWER_Read+0x258>
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
811031b8:	00e04574 	movhi	r3,33045
811031bc:	18c97504 	addi	r3,r3,9684
811031c0:	00a04574 	movhi	r2,33045
811031c4:	10ac8304 	addi	r2,r2,-19956
811031c8:	1009883a 	mov	r4,r2
811031cc:	00800444 	movi	r2,17
811031d0:	100d883a 	mov	r6,r2
811031d4:	200b883a 	mov	r5,r4
811031d8:	1809883a 	mov	r4,r3
811031dc:	11218680 	call	81121868 <memcpy>
				debug(fp, cDebugBuffer);
811031e0:	d0a06117 	ldw	r2,-32380(gp)
811031e4:	01604574 	movhi	r5,33045
811031e8:	29497504 	addi	r5,r5,9684
811031ec:	1009883a 	mov	r4,r2
811031f0:	11207b80 	call	811207b8 <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
811031f4:	e0bff417 	ldw	r2,-48(fp)
811031f8:	10800044 	addi	r2,r2,1
811031fc:	e0bff415 	stw	r2,-48(fp)
81103200:	e0bff517 	ldw	r2,-44(fp)
81103204:	1085883a 	add	r2,r2,r2
81103208:	1085883a 	add	r2,r2,r2
8110320c:	e0fff304 	addi	r3,fp,-52
81103210:	1885883a 	add	r2,r3,r2
81103214:	10800904 	addi	r2,r2,36
81103218:	10800017 	ldw	r2,0(r2)
8110321c:	e0fff417 	ldw	r3,-48(fp)
81103220:	1880020e 	bge	r3,r2,8110322c <POWER_Read+0x290>
81103224:	e0bff317 	ldw	r2,-52(fp)
81103228:	103f811e 	bne	r2,zero,81103030 <__reset+0xfb0e3030>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
8110322c:	e0bff517 	ldw	r2,-44(fp)
81103230:	10800044 	addi	r2,r2,1
81103234:	e0bff515 	stw	r2,-44(fp)
81103238:	e0bff517 	ldw	r2,-44(fp)
8110323c:	10800088 	cmpgei	r2,r2,2
81103240:	1000021e 	bne	r2,zero,8110324c <POWER_Read+0x2b0>
81103244:	e0bff317 	ldw	r2,-52(fp)
81103248:	103f691e 	bne	r2,zero,81102ff0 <__reset+0xfb0e2ff0>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
8110324c:	e0bff317 	ldw	r2,-52(fp)
}
81103250:	e037883a 	mov	sp,fp
81103254:	dfc00117 	ldw	ra,4(sp)
81103258:	df000017 	ldw	fp,0(sp)
8110325c:	dec00204 	addi	sp,sp,8
81103260:	f800283a 	ret

81103264 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
81103264:	defff904 	addi	sp,sp,-28
81103268:	de00012e 	bgeu	sp,et,81103270 <TEMP_Read+0xc>
8110326c:	003b68fa 	trap	3
81103270:	dfc00615 	stw	ra,24(sp)
81103274:	df000515 	stw	fp,20(sp)
81103278:	df000504 	addi	fp,sp,20
8110327c:	e13ffe15 	stw	r4,-8(fp)
81103280:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
81103284:	00800c04 	movi	r2,48
81103288:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
8110328c:	e0bffd83 	ldbu	r2,-10(fp)
81103290:	10c03fcc 	andi	r3,r2,255
81103294:	18c0201c 	xori	r3,r3,128
81103298:	18ffe004 	addi	r3,r3,-128
8110329c:	e0bffdc4 	addi	r2,fp,-9
811032a0:	d8800015 	stw	r2,0(sp)
811032a4:	000f883a 	mov	r7,zero
811032a8:	180d883a 	mov	r6,r3
811032ac:	01600034 	movhi	r5,32768
811032b0:	29426004 	addi	r5,r5,2432
811032b4:	01200034 	movhi	r4,32768
811032b8:	21026404 	addi	r4,r4,2448
811032bc:	110ac3c0 	call	8110ac3c <I2C_Read>
811032c0:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
811032c4:	e0bffc17 	ldw	r2,-16(fp)
811032c8:	10000226 	beq	r2,zero,811032d4 <TEMP_Read+0x70>
		BoardTemp = Data;
811032cc:	e0bffdc3 	ldbu	r2,-9(fp)
811032d0:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
811032d4:	e0bffc17 	ldw	r2,-16(fp)
811032d8:	10001226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
811032dc:	e0bffd83 	ldbu	r2,-10(fp)
811032e0:	10c03fcc 	andi	r3,r2,255
811032e4:	18c0201c 	xori	r3,r3,128
811032e8:	18ffe004 	addi	r3,r3,-128
811032ec:	e0bffdc4 	addi	r2,fp,-9
811032f0:	d8800015 	stw	r2,0(sp)
811032f4:	01c00044 	movi	r7,1
811032f8:	180d883a 	mov	r6,r3
811032fc:	01600034 	movhi	r5,32768
81103300:	29426004 	addi	r5,r5,2432
81103304:	01200034 	movhi	r4,32768
81103308:	21026404 	addi	r4,r4,2448
8110330c:	110ac3c0 	call	8110ac3c <I2C_Read>
81103310:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
81103314:	e0bffc17 	ldw	r2,-16(fp)
81103318:	10000226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
			FpgaTemp = Data;
8110331c:	e0bffdc3 	ldbu	r2,-9(fp)
81103320:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
81103324:	e0bffc17 	ldw	r2,-16(fp)
81103328:	10000626 	beq	r2,zero,81103344 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
8110332c:	e0bffe17 	ldw	r2,-8(fp)
81103330:	e0fffd03 	ldbu	r3,-12(fp)
81103334:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
81103338:	e0bfff17 	ldw	r2,-4(fp)
8110333c:	e0fffd43 	ldbu	r3,-11(fp)
81103340:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81103344:	e0bffc17 	ldw	r2,-16(fp)
}
81103348:	e037883a 	mov	sp,fp
8110334c:	dfc00117 	ldw	ra,4(sp)
81103350:	df000017 	ldw	fp,0(sp)
81103354:	dec00204 	addi	sp,sp,8
81103358:	f800283a 	ret

8110335c <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
8110335c:	defffb04 	addi	sp,sp,-20
81103360:	de00012e 	bgeu	sp,et,81103368 <sense_log_temp+0xc>
81103364:	003b68fa 	trap	3
81103368:	dfc00415 	stw	ra,16(sp)
8110336c:	df000315 	stw	fp,12(sp)
81103370:	df000304 	addi	fp,sp,12
81103374:	e13ffe15 	stw	r4,-8(fp)
81103378:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
8110337c:	e17fff17 	ldw	r5,-4(fp)
81103380:	e13ffe17 	ldw	r4,-8(fp)
81103384:	11032640 	call	81103264 <TEMP_Read>
81103388:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
8110338c:	e0bffd17 	ldw	r2,-12(fp)
}
81103390:	e037883a 	mov	sp,fp
81103394:	dfc00117 	ldw	ra,4(sp)
81103398:	df000017 	ldw	fp,0(sp)
8110339c:	dec00204 	addi	sp,sp,8
811033a0:	f800283a 	ret

811033a4 <sense_log>:

void sense_log(void) {
811033a4:	deff0404 	addi	sp,sp,-1008
811033a8:	de00012e 	bgeu	sp,et,811033b0 <sense_log+0xc>
811033ac:	003b68fa 	trap	3
811033b0:	dfc0fb15 	stw	ra,1004(sp)
811033b4:	df00fa15 	stw	fp,1000(sp)
811033b8:	dd40f915 	stw	r21,996(sp)
811033bc:	dd00f815 	stw	r20,992(sp)
811033c0:	dcc0f715 	stw	r19,988(sp)
811033c4:	dc80f615 	stw	r18,984(sp)
811033c8:	dc40f515 	stw	r17,980(sp)
811033cc:	dc00f415 	stw	r16,976(sp)
811033d0:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
811033d4:	00902834 	movhi	r2,16544
811033d8:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
811033dc:	008ed174 	movhi	r2,15173
811033e0:	10a6e984 	addi	r2,r2,-25690
811033e4:	e0bf2215 	stw	r2,-888(fp)
811033e8:	008ea0f4 	movhi	r2,14979
811033ec:	10849bc4 	addi	r2,r2,4719
811033f0:	e0bf2315 	stw	r2,-884(fp)
811033f4:	008ed174 	movhi	r2,15173
811033f8:	10a6e984 	addi	r2,r2,-25690
811033fc:	e0bf2415 	stw	r2,-880(fp)
81103400:	008ed174 	movhi	r2,15173
81103404:	10a6e984 	addi	r2,r2,-25690
81103408:	e0bf2515 	stw	r2,-876(fp)
8110340c:	008ed174 	movhi	r2,15173
81103410:	10a6e984 	addi	r2,r2,-25690
81103414:	e0bf2615 	stw	r2,-872(fp)
81103418:	008ed174 	movhi	r2,15173
8110341c:	10a6e984 	addi	r2,r2,-25690
81103420:	e0bf2715 	stw	r2,-868(fp)
81103424:	008ed174 	movhi	r2,15173
81103428:	10a6e984 	addi	r2,r2,-25690
8110342c:	e0bf2815 	stw	r2,-864(fp)
81103430:	008ed174 	movhi	r2,15173
81103434:	10a6e984 	addi	r2,r2,-25690
81103438:	e0bf2915 	stw	r2,-860(fp)
8110343c:	008ed174 	movhi	r2,15173
81103440:	10a6e984 	addi	r2,r2,-25690
81103444:	e0bf2a15 	stw	r2,-856(fp)
81103448:	008ed174 	movhi	r2,15173
8110344c:	10a6e984 	addi	r2,r2,-25690
81103450:	e0bf2b15 	stw	r2,-852(fp)
81103454:	008ed174 	movhi	r2,15173
81103458:	10a6e984 	addi	r2,r2,-25690
8110345c:	e0bf2c15 	stw	r2,-848(fp)
81103460:	008ed174 	movhi	r2,15173
81103464:	10a6e984 	addi	r2,r2,-25690
81103468:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
8110346c:	008fd9b4 	movhi	r2,16230
81103470:	10999984 	addi	r2,r2,26214
81103474:	e0bf2e15 	stw	r2,-840(fp)
81103478:	008fd9b4 	movhi	r2,16230
8110347c:	10999984 	addi	r2,r2,26214
81103480:	e0bf2f15 	stw	r2,-836(fp)
81103484:	00901034 	movhi	r2,16448
81103488:	e0bf3015 	stw	r2,-832(fp)
8110348c:	008fd9b4 	movhi	r2,16230
81103490:	10999984 	addi	r2,r2,26214
81103494:	e0bf3115 	stw	r2,-828(fp)
81103498:	008ff9b4 	movhi	r2,16358
8110349c:	10999984 	addi	r2,r2,26214
811034a0:	e0bf3215 	stw	r2,-824(fp)
811034a4:	00900834 	movhi	r2,16416
811034a8:	e0bf3315 	stw	r2,-820(fp)
811034ac:	008ff9b4 	movhi	r2,16358
811034b0:	10999984 	addi	r2,r2,26214
811034b4:	e0bf3415 	stw	r2,-816(fp)
811034b8:	00900834 	movhi	r2,16416
811034bc:	e0bf3515 	stw	r2,-812(fp)
811034c0:	008fe374 	movhi	r2,16269
811034c4:	10b33344 	addi	r2,r2,-13107
811034c8:	e0bf3615 	stw	r2,-808(fp)
811034cc:	008fecf4 	movhi	r2,16307
811034d0:	108cccc4 	addi	r2,r2,13107
811034d4:	e0bf3715 	stw	r2,-804(fp)
811034d8:	009014f4 	movhi	r2,16467
811034dc:	108cccc4 	addi	r2,r2,13107
811034e0:	e0bf3815 	stw	r2,-800(fp)
811034e4:	00900834 	movhi	r2,16416
811034e8:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
811034ec:	00a04574 	movhi	r2,33045
811034f0:	10acba04 	addi	r2,r2,-19736
811034f4:	e0ff3a04 	addi	r3,fp,-792
811034f8:	1009883a 	mov	r4,r2
811034fc:	0080c004 	movi	r2,768
81103500:	100d883a 	mov	r6,r2
81103504:	200b883a 	mov	r5,r4
81103508:	1809883a 	mov	r4,r3
8110350c:	11218680 	call	81121868 <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
81103510:	e0bf1604 	addi	r2,fp,-936
81103514:	1009883a 	mov	r4,r2
81103518:	1102f9c0 	call	81102f9c <POWER_Read>
8110351c:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
81103520:	e0bf0f17 	ldw	r2,-964(fp)
81103524:	10016026 	beq	r2,zero,81103aa8 <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103528:	e03f0c15 	stw	zero,-976(fp)
8110352c:	00014c06 	br	81103a60 <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
81103530:	e0bf0c17 	ldw	r2,-976(fp)
81103534:	1085883a 	add	r2,r2,r2
81103538:	1085883a 	add	r2,r2,r2
8110353c:	e0ff0c04 	addi	r3,fp,-976
81103540:	1885883a 	add	r2,r3,r2
81103544:	10800a04 	addi	r2,r2,40
81103548:	10800017 	ldw	r2,0(r2)
8110354c:	1004d77a 	srli	r2,r2,29
81103550:	1080004c 	andi	r2,r2,1
81103554:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
81103558:	e0bf0c17 	ldw	r2,-976(fp)
8110355c:	1085883a 	add	r2,r2,r2
81103560:	1085883a 	add	r2,r2,r2
81103564:	e0ff0c04 	addi	r3,fp,-976
81103568:	1885883a 	add	r2,r3,r2
8110356c:	10800a04 	addi	r2,r2,40
81103570:	10800017 	ldw	r2,0(r2)
81103574:	1004d73a 	srli	r2,r2,28
81103578:	1080004c 	andi	r2,r2,1
8110357c:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
81103580:	e0bf0c17 	ldw	r2,-976(fp)
81103584:	1085883a 	add	r2,r2,r2
81103588:	1085883a 	add	r2,r2,r2
8110358c:	e0ff0c04 	addi	r3,fp,-976
81103590:	1885883a 	add	r2,r3,r2
81103594:	10800a04 	addi	r2,r2,40
81103598:	10800017 	ldw	r2,0(r2)
8110359c:	1006d1ba 	srli	r3,r2,6
811035a0:	00801034 	movhi	r2,64
811035a4:	10bfffc4 	addi	r2,r2,-1
811035a8:	1884703a 	and	r2,r3,r2
811035ac:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
811035b0:	e0bf1117 	ldw	r2,-956(fp)
811035b4:	1000091e 	bne	r2,zero,811035dc <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
811035b8:	e13f1217 	ldw	r4,-952(fp)
811035bc:	111efdc0 	call	8111efdc <__floatunsisf>
811035c0:	1007883a 	mov	r3,r2
811035c4:	0152a034 	movhi	r5,19072
811035c8:	1809883a 	mov	r4,r3
811035cc:	111e6640 	call	8111e664 <__divsf3>
811035d0:	1007883a 	mov	r3,r2
811035d4:	e0ff0d15 	stw	r3,-972(fp)
811035d8:	00000106 	br	811035e0 <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
811035dc:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
811035e0:	e0bf1017 	ldw	r2,-960(fp)
811035e4:	10002626 	beq	r2,zero,81103680 <sense_log+0x2dc>
811035e8:	e0bf1117 	ldw	r2,-956(fp)
811035ec:	10002426 	beq	r2,zero,81103680 <sense_log+0x2dc>
				fVol = fRef * 0.5;
811035f0:	014fc034 	movhi	r5,16128
811035f4:	e13f0e17 	ldw	r4,-968(fp)
811035f8:	111eaac0 	call	8111eaac <__mulsf3>
811035fc:	1007883a 	mov	r3,r2
81103600:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103604:	e0ff3a04 	addi	r3,fp,-792
81103608:	e0bf0c17 	ldw	r2,-976(fp)
8110360c:	100491ba 	slli	r2,r2,6
81103610:	18a1883a 	add	r16,r3,r2
81103614:	e0bf0c17 	ldw	r2,-976(fp)
81103618:	1085883a 	add	r2,r2,r2
8110361c:	1085883a 	add	r2,r2,r2
81103620:	e0ff0c04 	addi	r3,fp,-976
81103624:	1885883a 	add	r2,r3,r2
81103628:	10800a04 	addi	r2,r2,40
8110362c:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
81103630:	1023883a 	mov	r17,r2
81103634:	e13f1317 	ldw	r4,-948(fp)
81103638:	11203380 	call	81120338 <__extendsfdf2>
8110363c:	1009883a 	mov	r4,r2
81103640:	180b883a 	mov	r5,r3
81103644:	d9000015 	stw	r4,0(sp)
81103648:	d9400115 	stw	r5,4(sp)
8110364c:	880f883a 	mov	r7,r17
81103650:	800d883a 	mov	r6,r16
81103654:	01604574 	movhi	r5,33045
81103658:	296c8804 	addi	r5,r5,-19936
8110365c:	01204574 	movhi	r4,33045
81103660:	21097504 	addi	r4,r4,9684
81103664:	11221480 	call	81122148 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103668:	d0a06117 	ldw	r2,-32380(gp)
8110366c:	01604574 	movhi	r5,33045
81103670:	29497504 	addi	r5,r5,9684
81103674:	1009883a 	mov	r4,r2
81103678:	11207b80 	call	811207b8 <fprintf>
8110367c:	0000f506 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
81103680:	e0bf1017 	ldw	r2,-960(fp)
81103684:	10006426 	beq	r2,zero,81103818 <sense_log+0x474>
81103688:	e0bf1117 	ldw	r2,-956(fp)
8110368c:	1000621e 	bne	r2,zero,81103818 <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
81103690:	e13f0e17 	ldw	r4,-968(fp)
81103694:	11203380 	call	81120338 <__extendsfdf2>
81103698:	1011883a 	mov	r8,r2
8110369c:	1813883a 	mov	r9,r3
811036a0:	000d883a 	mov	r6,zero
811036a4:	01cff834 	movhi	r7,16352
811036a8:	4009883a 	mov	r4,r8
811036ac:	480b883a 	mov	r5,r9
811036b0:	111f1b00 	call	8111f1b0 <__muldf3>
811036b4:	1009883a 	mov	r4,r2
811036b8:	180b883a 	mov	r5,r3
811036bc:	2021883a 	mov	r16,r4
811036c0:	2823883a 	mov	r17,r5
811036c4:	e13f0d17 	ldw	r4,-972(fp)
811036c8:	11203380 	call	81120338 <__extendsfdf2>
811036cc:	1009883a 	mov	r4,r2
811036d0:	180b883a 	mov	r5,r3
811036d4:	200d883a 	mov	r6,r4
811036d8:	280f883a 	mov	r7,r5
811036dc:	8009883a 	mov	r4,r16
811036e0:	880b883a 	mov	r5,r17
811036e4:	111f1b00 	call	8111f1b0 <__muldf3>
811036e8:	1009883a 	mov	r4,r2
811036ec:	180b883a 	mov	r5,r3
811036f0:	2005883a 	mov	r2,r4
811036f4:	2807883a 	mov	r3,r5
811036f8:	1009883a 	mov	r4,r2
811036fc:	180b883a 	mov	r5,r3
81103700:	11204500 	call	81120450 <__truncdfsf2>
81103704:	1007883a 	mov	r3,r2
81103708:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
8110370c:	e0bf0c17 	ldw	r2,-976(fp)
81103710:	1085883a 	add	r2,r2,r2
81103714:	1085883a 	add	r2,r2,r2
81103718:	e0ff0c04 	addi	r3,fp,-976
8110371c:	1885883a 	add	r2,r3,r2
81103720:	10801604 	addi	r2,r2,88
81103724:	10c00017 	ldw	r3,0(r2)
81103728:	180b883a 	mov	r5,r3
8110372c:	e13f0d17 	ldw	r4,-972(fp)
81103730:	111e6640 	call	8111e664 <__divsf3>
81103734:	1007883a 	mov	r3,r2
81103738:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
8110373c:	e0bf0c17 	ldw	r2,-976(fp)
81103740:	1085883a 	add	r2,r2,r2
81103744:	1085883a 	add	r2,r2,r2
81103748:	e0ff0c04 	addi	r3,fp,-976
8110374c:	1885883a 	add	r2,r3,r2
81103750:	10802204 	addi	r2,r2,136
81103754:	10c00017 	ldw	r3,0(r2)
81103758:	e17f1417 	ldw	r5,-944(fp)
8110375c:	1809883a 	mov	r4,r3
81103760:	111eaac0 	call	8111eaac <__mulsf3>
81103764:	1007883a 	mov	r3,r2
81103768:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
8110376c:	e0ff3a04 	addi	r3,fp,-792
81103770:	e0bf0c17 	ldw	r2,-976(fp)
81103774:	100491ba 	slli	r2,r2,6
81103778:	18a9883a 	add	r20,r3,r2
8110377c:	e0bf0c17 	ldw	r2,-976(fp)
81103780:	1085883a 	add	r2,r2,r2
81103784:	1085883a 	add	r2,r2,r2
81103788:	e0ff0c04 	addi	r3,fp,-976
8110378c:	1885883a 	add	r2,r3,r2
81103790:	10800a04 	addi	r2,r2,40
81103794:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103798:	102b883a 	mov	r21,r2
8110379c:	e13f0d17 	ldw	r4,-972(fp)
811037a0:	11203380 	call	81120338 <__extendsfdf2>
811037a4:	1021883a 	mov	r16,r2
811037a8:	1823883a 	mov	r17,r3
811037ac:	e13f1417 	ldw	r4,-944(fp)
811037b0:	11203380 	call	81120338 <__extendsfdf2>
811037b4:	1025883a 	mov	r18,r2
811037b8:	1827883a 	mov	r19,r3
811037bc:	e13f1517 	ldw	r4,-940(fp)
811037c0:	11203380 	call	81120338 <__extendsfdf2>
811037c4:	1009883a 	mov	r4,r2
811037c8:	180b883a 	mov	r5,r3
811037cc:	d9000415 	stw	r4,16(sp)
811037d0:	d9400515 	stw	r5,20(sp)
811037d4:	dc800215 	stw	r18,8(sp)
811037d8:	dcc00315 	stw	r19,12(sp)
811037dc:	dc000015 	stw	r16,0(sp)
811037e0:	dc400115 	stw	r17,4(sp)
811037e4:	a80f883a 	mov	r7,r21
811037e8:	a00d883a 	mov	r6,r20
811037ec:	01604574 	movhi	r5,33045
811037f0:	296c9104 	addi	r5,r5,-19900
811037f4:	01204574 	movhi	r4,33045
811037f8:	21097504 	addi	r4,r4,9684
811037fc:	11221480 	call	81122148 <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103800:	d0a06117 	ldw	r2,-32380(gp)
81103804:	01604574 	movhi	r5,33045
81103808:	29497504 	addi	r5,r5,9684
8110380c:	1009883a 	mov	r4,r2
81103810:	11207b80 	call	811207b8 <fprintf>
81103814:	00008f06 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
81103818:	e0bf1017 	ldw	r2,-960(fp)
8110381c:	1000641e 	bne	r2,zero,811039b0 <sense_log+0x60c>
81103820:	e0bf1117 	ldw	r2,-956(fp)
81103824:	10006226 	beq	r2,zero,811039b0 <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
81103828:	e13f0e17 	ldw	r4,-968(fp)
8110382c:	11203380 	call	81120338 <__extendsfdf2>
81103830:	1011883a 	mov	r8,r2
81103834:	1813883a 	mov	r9,r3
81103838:	000d883a 	mov	r6,zero
8110383c:	01cff834 	movhi	r7,16352
81103840:	4009883a 	mov	r4,r8
81103844:	480b883a 	mov	r5,r9
81103848:	111f1b00 	call	8111f1b0 <__muldf3>
8110384c:	1009883a 	mov	r4,r2
81103850:	180b883a 	mov	r5,r3
81103854:	2021883a 	mov	r16,r4
81103858:	2823883a 	mov	r17,r5
8110385c:	e13f0d17 	ldw	r4,-972(fp)
81103860:	11203380 	call	81120338 <__extendsfdf2>
81103864:	1009883a 	mov	r4,r2
81103868:	180b883a 	mov	r5,r3
8110386c:	200d883a 	mov	r6,r4
81103870:	280f883a 	mov	r7,r5
81103874:	8009883a 	mov	r4,r16
81103878:	880b883a 	mov	r5,r17
8110387c:	111f1b00 	call	8111f1b0 <__muldf3>
81103880:	1009883a 	mov	r4,r2
81103884:	180b883a 	mov	r5,r3
81103888:	2005883a 	mov	r2,r4
8110388c:	2807883a 	mov	r3,r5
81103890:	1009883a 	mov	r4,r2
81103894:	180b883a 	mov	r5,r3
81103898:	11204500 	call	81120450 <__truncdfsf2>
8110389c:	1007883a 	mov	r3,r2
811038a0:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811038a4:	e0bf0c17 	ldw	r2,-976(fp)
811038a8:	1085883a 	add	r2,r2,r2
811038ac:	1085883a 	add	r2,r2,r2
811038b0:	e0ff0c04 	addi	r3,fp,-976
811038b4:	1885883a 	add	r2,r3,r2
811038b8:	10801604 	addi	r2,r2,88
811038bc:	10c00017 	ldw	r3,0(r2)
811038c0:	180b883a 	mov	r5,r3
811038c4:	e13f0d17 	ldw	r4,-972(fp)
811038c8:	111e6640 	call	8111e664 <__divsf3>
811038cc:	1007883a 	mov	r3,r2
811038d0:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
811038d4:	e0bf0c17 	ldw	r2,-976(fp)
811038d8:	1085883a 	add	r2,r2,r2
811038dc:	1085883a 	add	r2,r2,r2
811038e0:	e0ff0c04 	addi	r3,fp,-976
811038e4:	1885883a 	add	r2,r3,r2
811038e8:	10802204 	addi	r2,r2,136
811038ec:	10c00017 	ldw	r3,0(r2)
811038f0:	e17f1417 	ldw	r5,-944(fp)
811038f4:	1809883a 	mov	r4,r3
811038f8:	111eaac0 	call	8111eaac <__mulsf3>
811038fc:	1007883a 	mov	r3,r2
81103900:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
81103904:	e0ff3a04 	addi	r3,fp,-792
81103908:	e0bf0c17 	ldw	r2,-976(fp)
8110390c:	100491ba 	slli	r2,r2,6
81103910:	18a9883a 	add	r20,r3,r2
81103914:	e0bf0c17 	ldw	r2,-976(fp)
81103918:	1085883a 	add	r2,r2,r2
8110391c:	1085883a 	add	r2,r2,r2
81103920:	e0ff0c04 	addi	r3,fp,-976
81103924:	1885883a 	add	r2,r3,r2
81103928:	10800a04 	addi	r2,r2,40
8110392c:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103930:	102b883a 	mov	r21,r2
81103934:	e13f0d17 	ldw	r4,-972(fp)
81103938:	11203380 	call	81120338 <__extendsfdf2>
8110393c:	1021883a 	mov	r16,r2
81103940:	1823883a 	mov	r17,r3
81103944:	e13f1417 	ldw	r4,-944(fp)
81103948:	11203380 	call	81120338 <__extendsfdf2>
8110394c:	1025883a 	mov	r18,r2
81103950:	1827883a 	mov	r19,r3
81103954:	e13f1517 	ldw	r4,-940(fp)
81103958:	11203380 	call	81120338 <__extendsfdf2>
8110395c:	1009883a 	mov	r4,r2
81103960:	180b883a 	mov	r5,r3
81103964:	d9000415 	stw	r4,16(sp)
81103968:	d9400515 	stw	r5,20(sp)
8110396c:	dc800215 	stw	r18,8(sp)
81103970:	dcc00315 	stw	r19,12(sp)
81103974:	dc000015 	stw	r16,0(sp)
81103978:	dc400115 	stw	r17,4(sp)
8110397c:	a80f883a 	mov	r7,r21
81103980:	a00d883a 	mov	r6,r20
81103984:	01604574 	movhi	r5,33045
81103988:	296ca104 	addi	r5,r5,-19836
8110398c:	01204574 	movhi	r4,33045
81103990:	21097504 	addi	r4,r4,9684
81103994:	11221480 	call	81122148 <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103998:	d0a06117 	ldw	r2,-32380(gp)
8110399c:	01604574 	movhi	r5,33045
811039a0:	29497504 	addi	r5,r5,9684
811039a4:	1009883a 	mov	r4,r2
811039a8:	11207b80 	call	811207b8 <fprintf>
811039ac:	00002906 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
811039b0:	e0bf1017 	ldw	r2,-960(fp)
811039b4:	1000271e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
811039b8:	e0bf1117 	ldw	r2,-956(fp)
811039bc:	1000251e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
811039c0:	e0bf0e17 	ldw	r2,-968(fp)
811039c4:	10a0003c 	xorhi	r2,r2,32768
811039c8:	014fc034 	movhi	r5,16128
811039cc:	1009883a 	mov	r4,r2
811039d0:	111eaac0 	call	8111eaac <__mulsf3>
811039d4:	1007883a 	mov	r3,r2
811039d8:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811039dc:	e0ff3a04 	addi	r3,fp,-792
811039e0:	e0bf0c17 	ldw	r2,-976(fp)
811039e4:	100491ba 	slli	r2,r2,6
811039e8:	18a1883a 	add	r16,r3,r2
811039ec:	e0bf0c17 	ldw	r2,-976(fp)
811039f0:	1085883a 	add	r2,r2,r2
811039f4:	1085883a 	add	r2,r2,r2
811039f8:	e0ff0c04 	addi	r3,fp,-976
811039fc:	1885883a 	add	r2,r3,r2
81103a00:	10800a04 	addi	r2,r2,40
81103a04:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
81103a08:	1023883a 	mov	r17,r2
81103a0c:	e13f1317 	ldw	r4,-948(fp)
81103a10:	11203380 	call	81120338 <__extendsfdf2>
81103a14:	1009883a 	mov	r4,r2
81103a18:	180b883a 	mov	r5,r3
81103a1c:	d9000015 	stw	r4,0(sp)
81103a20:	d9400115 	stw	r5,4(sp)
81103a24:	880f883a 	mov	r7,r17
81103a28:	800d883a 	mov	r6,r16
81103a2c:	01604574 	movhi	r5,33045
81103a30:	296cb104 	addi	r5,r5,-19772
81103a34:	01204574 	movhi	r4,33045
81103a38:	21097504 	addi	r4,r4,9684
81103a3c:	11221480 	call	81122148 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103a40:	d0a06117 	ldw	r2,-32380(gp)
81103a44:	01604574 	movhi	r5,33045
81103a48:	29497504 	addi	r5,r5,9684
81103a4c:	1009883a 	mov	r4,r2
81103a50:	11207b80 	call	811207b8 <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103a54:	e0bf0c17 	ldw	r2,-976(fp)
81103a58:	10800044 	addi	r2,r2,1
81103a5c:	e0bf0c15 	stw	r2,-976(fp)
81103a60:	e0bf0c17 	ldw	r2,-976(fp)
81103a64:	10800308 	cmpgei	r2,r2,12
81103a68:	1000021e 	bne	r2,zero,81103a74 <sense_log+0x6d0>
81103a6c:	e0bf0f17 	ldw	r2,-964(fp)
81103a70:	103eaf1e 	bne	r2,zero,81103530 <__reset+0xfb0e3530>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103a74:	00a04574 	movhi	r2,33045
81103a78:	10897504 	addi	r2,r2,9684
81103a7c:	00c00344 	movi	r3,13
81103a80:	10c00005 	stb	r3,0(r2)
81103a84:	00c00284 	movi	r3,10
81103a88:	10c00045 	stb	r3,1(r2)
81103a8c:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103a90:	d0a06117 	ldw	r2,-32380(gp)
81103a94:	01604574 	movhi	r5,33045
81103a98:	29497504 	addi	r5,r5,9684
81103a9c:	1009883a 	mov	r4,r2
81103aa0:	11207b80 	call	811207b8 <fprintf>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103aa4:	00001606 	br	81103b00 <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103aa8:	00a04574 	movhi	r2,33045
81103aac:	10897504 	addi	r2,r2,9684
81103ab0:	00c01144 	movi	r3,69
81103ab4:	10c00005 	stb	r3,0(r2)
81103ab8:	00c01c84 	movi	r3,114
81103abc:	10c00045 	stb	r3,1(r2)
81103ac0:	00c01c84 	movi	r3,114
81103ac4:	10c00085 	stb	r3,2(r2)
81103ac8:	00c01bc4 	movi	r3,111
81103acc:	10c000c5 	stb	r3,3(r2)
81103ad0:	00c01c84 	movi	r3,114
81103ad4:	10c00105 	stb	r3,4(r2)
81103ad8:	00c00344 	movi	r3,13
81103adc:	10c00145 	stb	r3,5(r2)
81103ae0:	00c00284 	movi	r3,10
81103ae4:	10c00185 	stb	r3,6(r2)
81103ae8:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103aec:	d0a06117 	ldw	r2,-32380(gp)
81103af0:	01604574 	movhi	r5,33045
81103af4:	29497504 	addi	r5,r5,9684
81103af8:	1009883a 	mov	r4,r2
81103afc:	11207b80 	call	811207b8 <fprintf>
#endif
	}
}
81103b00:	0001883a 	nop
81103b04:	e6fffa04 	addi	sp,fp,-24
81103b08:	dfc00717 	ldw	ra,28(sp)
81103b0c:	df000617 	ldw	fp,24(sp)
81103b10:	dd400517 	ldw	r21,20(sp)
81103b14:	dd000417 	ldw	r20,16(sp)
81103b18:	dcc00317 	ldw	r19,12(sp)
81103b1c:	dc800217 	ldw	r18,8(sp)
81103b20:	dc400117 	ldw	r17,4(sp)
81103b24:	dc000017 	ldw	r16,0(sp)
81103b28:	dec00804 	addi	sp,sp,32
81103b2c:	f800283a 	ret

81103b30 <bSdmaInitM1Dma>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103b30:	defffc04 	addi	sp,sp,-16
81103b34:	de00012e 	bgeu	sp,et,81103b3c <bSdmaInitM1Dma+0xc>
81103b38:	003b68fa 	trap	3
81103b3c:	dfc00315 	stw	ra,12(sp)
81103b40:	df000215 	stw	fp,8(sp)
81103b44:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103b48:	00800044 	movi	r2,1
81103b4c:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103b50:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103b54:	01204574 	movhi	r4,33045
81103b58:	212d7a04 	addi	r4,r4,-18968
81103b5c:	1148f680 	call	81148f68 <alt_msgdma_open>
81103b60:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev == NULL) {
81103b64:	d0a03917 	ldw	r2,-32540(gp)
81103b68:	1000021e 	bne	r2,zero,81103b74 <bSdmaInitM1Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103b6c:	e03ffe15 	stw	zero,-8(fp)
81103b70:	00001506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
81103b74:	d0a03917 	ldw	r2,-32540(gp)
81103b78:	10800317 	ldw	r2,12(r2)
81103b7c:	10800104 	addi	r2,r2,4
81103b80:	00c00084 	movi	r3,2
81103b84:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103b88:	00000a06 	br	81103bb4 <bSdmaInitM1Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103b8c:	01000044 	movi	r4,1
81103b90:	1136ed00 	call	81136ed0 <usleep>
			usiCounter++;
81103b94:	e0bfff0b 	ldhu	r2,-4(fp)
81103b98:	10800044 	addi	r2,r2,1
81103b9c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103ba0:	e0bfff0b 	ldhu	r2,-4(fp)
81103ba4:	1084e230 	cmpltui	r2,r2,5000
81103ba8:	1000021e 	bne	r2,zero,81103bb4 <bSdmaInitM1Dma+0x84>
				bStatus = FALSE;
81103bac:	e03ffe15 	stw	zero,-8(fp)
				break;
81103bb0:	00000506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bb4:	d0a03917 	ldw	r2,-32540(gp)
81103bb8:	10800317 	ldw	r2,12(r2)
81103bbc:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103bc0:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bc4:	103ff11e 	bne	r2,zero,81103b8c <__reset+0xfb0e3b8c>
				break;
			}
		}
	}

	return bStatus;
81103bc8:	e0bffe17 	ldw	r2,-8(fp)
}
81103bcc:	e037883a 	mov	sp,fp
81103bd0:	dfc00117 	ldw	ra,4(sp)
81103bd4:	df000017 	ldw	fp,0(sp)
81103bd8:	dec00204 	addi	sp,sp,8
81103bdc:	f800283a 	ret

81103be0 <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103be0:	defffc04 	addi	sp,sp,-16
81103be4:	de00012e 	bgeu	sp,et,81103bec <bSdmaInitM2Dma+0xc>
81103be8:	003b68fa 	trap	3
81103bec:	dfc00315 	stw	ra,12(sp)
81103bf0:	df000215 	stw	fp,8(sp)
81103bf4:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103bf8:	00800044 	movi	r2,1
81103bfc:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103c00:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103c04:	01204574 	movhi	r4,33045
81103c08:	212d7f04 	addi	r4,r4,-18948
81103c0c:	1148f680 	call	81148f68 <alt_msgdma_open>
81103c10:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103c14:	d0a03a17 	ldw	r2,-32536(gp)
81103c18:	1000021e 	bne	r2,zero,81103c24 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103c1c:	e03ffe15 	stw	zero,-8(fp)
81103c20:	00001506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
81103c24:	d0a03a17 	ldw	r2,-32536(gp)
81103c28:	10800317 	ldw	r2,12(r2)
81103c2c:	10800104 	addi	r2,r2,4
81103c30:	00c00084 	movi	r3,2
81103c34:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c38:	00000a06 	br	81103c64 <bSdmaInitM2Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103c3c:	01000044 	movi	r4,1
81103c40:	1136ed00 	call	81136ed0 <usleep>
			usiCounter++;
81103c44:	e0bfff0b 	ldhu	r2,-4(fp)
81103c48:	10800044 	addi	r2,r2,1
81103c4c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103c50:	e0bfff0b 	ldhu	r2,-4(fp)
81103c54:	1084e230 	cmpltui	r2,r2,5000
81103c58:	1000021e 	bne	r2,zero,81103c64 <bSdmaInitM2Dma+0x84>
				bStatus = FALSE;
81103c5c:	e03ffe15 	stw	zero,-8(fp)
				break;
81103c60:	00000506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c64:	d0a03a17 	ldw	r2,-32536(gp)
81103c68:	10800317 	ldw	r2,12(r2)
81103c6c:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c70:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c74:	103ff11e 	bne	r2,zero,81103c3c <__reset+0xfb0e3c3c>
				break;
			}
		}
	}

	return bStatus;
81103c78:	e0bffe17 	ldw	r2,-8(fp)
}
81103c7c:	e037883a 	mov	sp,fp
81103c80:	dfc00117 	ldw	ra,4(sp)
81103c84:	df000017 	ldw	fp,0(sp)
81103c88:	dec00204 	addi	sp,sp,8
81103c8c:	f800283a 	ret

81103c90 <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
81103c90:	deffe804 	addi	sp,sp,-96
81103c94:	de00012e 	bgeu	sp,et,81103c9c <bSdmaDmaM1Transfer+0xc>
81103c98:	003b68fa 	trap	3
81103c9c:	dfc01715 	stw	ra,92(sp)
81103ca0:	df001615 	stw	fp,88(sp)
81103ca4:	dc001515 	stw	r16,84(sp)
81103ca8:	df001604 	addi	fp,sp,88
81103cac:	e13ffb15 	stw	r4,-20(fp)
81103cb0:	2809883a 	mov	r4,r5
81103cb4:	3007883a 	mov	r3,r6
81103cb8:	3805883a 	mov	r2,r7
81103cbc:	e13ffc0d 	sth	r4,-16(fp)
81103cc0:	e0fffd05 	stb	r3,-12(fp)
81103cc4:	e0bffe05 	stb	r2,-8(fp)
81103cc8:	defff004 	addi	sp,sp,-64
81103ccc:	d8800904 	addi	r2,sp,36
81103cd0:	108007c4 	addi	r2,r2,31
81103cd4:	1004d17a 	srli	r2,r2,5
81103cd8:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81103cdc:	00800044 	movi	r2,1
81103ce0:	e0bff315 	stw	r2,-52(fp)
	alt_u16 usiCnt = 0;
81103ce4:	e03ff40d 	sth	zero,-48(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103ce8:	e03ff515 	stw	zero,-44(fp)
	alt_u32 uliDestAddrHigh = 0;
81103cec:	e03ff615 	stw	zero,-40(fp)

	alt_u32 uliSrcAddrLow = 0;
81103cf0:	e03ff715 	stw	zero,-36(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103cf4:	e03ff815 	stw	zero,-32(fp)

	alt_u32 uliControlBits = 0x00000000;
81103cf8:	e03ffa15 	stw	zero,-24(fp)

	bool bBufferEmptyFlag = FALSE;
81103cfc:	e03ff915 	stw	zero,-28(fp)

	switch (ucChBufferId) {
81103d00:	e0bffe03 	ldbu	r2,-8(fp)
81103d04:	10c00228 	cmpgeui	r3,r2,8
81103d08:	1800b81e 	bne	r3,zero,81103fec <bSdmaDmaM1Transfer+0x35c>
81103d0c:	100690ba 	slli	r3,r2,2
81103d10:	00a04434 	movhi	r2,33040
81103d14:	108f4904 	addi	r2,r2,15652
81103d18:	1885883a 	add	r2,r3,r2
81103d1c:	10800017 	ldw	r2,0(r2)
81103d20:	1000683a 	jmp	r2
81103d24:	81103d44 	addi	r4,r16,16629
81103d28:	81103d98 	cmpnei	r4,r16,16630
81103d2c:	81103df4 	orhi	r4,r16,16631
81103d30:	81103e48 	cmpgei	r4,r16,16633
81103d34:	81103e9c 	xori	r4,r16,16634
81103d38:	81103ef0 	cmpltui	r4,r16,16635
81103d3c:	81103f44 	addi	r4,r16,16637
81103d40:	81103f98 	cmpnei	r4,r16,16638
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103d44:	e0bffd03 	ldbu	r2,-12(fp)
81103d48:	10000826 	beq	r2,zero,81103d6c <bSdmaDmaM1Transfer+0xdc>
81103d4c:	10800060 	cmpeqi	r2,r2,1
81103d50:	10000d26 	beq	r2,zero,81103d88 <bSdmaDmaM1Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103d54:	e03ff515 	stw	zero,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103d58:	00800044 	movi	r2,1
81103d5c:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
81103d60:	110662c0 	call	8110662c <bFeebGetCh1RightBufferEmpty>
81103d64:	e0bff915 	stw	r2,-28(fp)
			break;
81103d68:	00000a06 	br	81103d94 <bSdmaDmaM1Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103d6c:	00800074 	movhi	r2,1
81103d70:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103d74:	00800044 	movi	r2,1
81103d78:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
81103d7c:	11065c40 	call	811065c4 <bFeebGetCh1LeftBufferEmpty>
81103d80:	e0bff915 	stw	r2,-28(fp)
			break;
81103d84:	00000306 	br	81103d94 <bSdmaDmaM1Transfer+0x104>
		default:
			bStatus = FALSE;
81103d88:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103d8c:	e03ff915 	stw	zero,-28(fp)
			break;
81103d90:	0001883a 	nop
		}
		break;
81103d94:	00009706 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103d98:	e0bffd03 	ldbu	r2,-12(fp)
81103d9c:	10000926 	beq	r2,zero,81103dc4 <bSdmaDmaM1Transfer+0x134>
81103da0:	10800060 	cmpeqi	r2,r2,1
81103da4:	10000f26 	beq	r2,zero,81103de4 <bSdmaDmaM1Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103da8:	00880004 	movi	r2,8192
81103dac:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103db0:	00800044 	movi	r2,1
81103db4:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
81103db8:	11066fc0 	call	811066fc <bFeebGetCh2RightBufferEmpty>
81103dbc:	e0bff915 	stw	r2,-28(fp)
			break;
81103dc0:	00000b06 	br	81103df0 <bSdmaDmaM1Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103dc4:	00800074 	movhi	r2,1
81103dc8:	10880004 	addi	r2,r2,8192
81103dcc:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103dd0:	00800044 	movi	r2,1
81103dd4:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
81103dd8:	11066940 	call	81106694 <bFeebGetCh2LeftBufferEmpty>
81103ddc:	e0bff915 	stw	r2,-28(fp)
			break;
81103de0:	00000306 	br	81103df0 <bSdmaDmaM1Transfer+0x160>
		default:
			bStatus = FALSE;
81103de4:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103de8:	e03ff915 	stw	zero,-28(fp)
			break;
81103dec:	0001883a 	nop
		}
		break;
81103df0:	00008006 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103df4:	e0bffd03 	ldbu	r2,-12(fp)
81103df8:	10000826 	beq	r2,zero,81103e1c <bSdmaDmaM1Transfer+0x18c>
81103dfc:	10800060 	cmpeqi	r2,r2,1
81103e00:	10000d26 	beq	r2,zero,81103e38 <bSdmaDmaM1Transfer+0x1a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103e04:	00900004 	movi	r2,16384
81103e08:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103e0c:	00800044 	movi	r2,1
81103e10:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103e14:	e03ff915 	stw	zero,-28(fp)
			break;
81103e18:	00000a06 	br	81103e44 <bSdmaDmaM1Transfer+0x1b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103e1c:	00800074 	movhi	r2,1
81103e20:	10900004 	addi	r2,r2,16384
81103e24:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103e28:	00800044 	movi	r2,1
81103e2c:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103e30:	e03ff915 	stw	zero,-28(fp)
			break;
81103e34:	00000306 	br	81103e44 <bSdmaDmaM1Transfer+0x1b4>
		default:
			bStatus = FALSE;
81103e38:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103e3c:	e03ff915 	stw	zero,-28(fp)
			break;
81103e40:	0001883a 	nop
		}
		break;
81103e44:	00006b06 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103e48:	e0bffd03 	ldbu	r2,-12(fp)
81103e4c:	10000826 	beq	r2,zero,81103e70 <bSdmaDmaM1Transfer+0x1e0>
81103e50:	10800060 	cmpeqi	r2,r2,1
81103e54:	10000d26 	beq	r2,zero,81103e8c <bSdmaDmaM1Transfer+0x1fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103e58:	00980004 	movi	r2,24576
81103e5c:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103e60:	00800044 	movi	r2,1
81103e64:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103e68:	e03ff915 	stw	zero,-28(fp)
			break;
81103e6c:	00000a06 	br	81103e98 <bSdmaDmaM1Transfer+0x208>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103e70:	00800074 	movhi	r2,1
81103e74:	10980004 	addi	r2,r2,24576
81103e78:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103e7c:	00800044 	movi	r2,1
81103e80:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103e84:	e03ff915 	stw	zero,-28(fp)
			break;
81103e88:	00000306 	br	81103e98 <bSdmaDmaM1Transfer+0x208>
		default:
			bStatus = FALSE;
81103e8c:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103e90:	e03ff915 	stw	zero,-28(fp)
			break;
81103e94:	0001883a 	nop
		}
		break;
81103e98:	00005606 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103e9c:	e0bffd03 	ldbu	r2,-12(fp)
81103ea0:	10000826 	beq	r2,zero,81103ec4 <bSdmaDmaM1Transfer+0x234>
81103ea4:	10800060 	cmpeqi	r2,r2,1
81103ea8:	10000d26 	beq	r2,zero,81103ee0 <bSdmaDmaM1Transfer+0x250>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103eac:	00a00014 	movui	r2,32768
81103eb0:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103eb4:	00800044 	movi	r2,1
81103eb8:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103ebc:	e03ff915 	stw	zero,-28(fp)
			break;
81103ec0:	00000a06 	br	81103eec <bSdmaDmaM1Transfer+0x25c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103ec4:	008000b4 	movhi	r2,2
81103ec8:	10a00004 	addi	r2,r2,-32768
81103ecc:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103ed0:	00800044 	movi	r2,1
81103ed4:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103ed8:	e03ff915 	stw	zero,-28(fp)
			break;
81103edc:	00000306 	br	81103eec <bSdmaDmaM1Transfer+0x25c>
		default:
			bStatus = FALSE;
81103ee0:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103ee4:	e03ff915 	stw	zero,-28(fp)
			break;
81103ee8:	0001883a 	nop
		}
		break;
81103eec:	00004106 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103ef0:	e0bffd03 	ldbu	r2,-12(fp)
81103ef4:	10000826 	beq	r2,zero,81103f18 <bSdmaDmaM1Transfer+0x288>
81103ef8:	10800060 	cmpeqi	r2,r2,1
81103efc:	10000d26 	beq	r2,zero,81103f34 <bSdmaDmaM1Transfer+0x2a4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103f00:	00a80014 	movui	r2,40960
81103f04:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103f08:	00800044 	movi	r2,1
81103f0c:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103f10:	e03ff915 	stw	zero,-28(fp)
			break;
81103f14:	00000a06 	br	81103f40 <bSdmaDmaM1Transfer+0x2b0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103f18:	008000b4 	movhi	r2,2
81103f1c:	10a80004 	addi	r2,r2,-24576
81103f20:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103f24:	00800044 	movi	r2,1
81103f28:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103f2c:	e03ff915 	stw	zero,-28(fp)
			break;
81103f30:	00000306 	br	81103f40 <bSdmaDmaM1Transfer+0x2b0>
		default:
			bStatus = FALSE;
81103f34:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103f38:	e03ff915 	stw	zero,-28(fp)
			break;
81103f3c:	0001883a 	nop
		}
		break;
81103f40:	00002c06 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103f44:	e0bffd03 	ldbu	r2,-12(fp)
81103f48:	10000826 	beq	r2,zero,81103f6c <bSdmaDmaM1Transfer+0x2dc>
81103f4c:	10800060 	cmpeqi	r2,r2,1
81103f50:	10000d26 	beq	r2,zero,81103f88 <bSdmaDmaM1Transfer+0x2f8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103f54:	00b00014 	movui	r2,49152
81103f58:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103f5c:	00800044 	movi	r2,1
81103f60:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103f64:	e03ff915 	stw	zero,-28(fp)
			break;
81103f68:	00000a06 	br	81103f94 <bSdmaDmaM1Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103f6c:	008000b4 	movhi	r2,2
81103f70:	10b00004 	addi	r2,r2,-16384
81103f74:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103f78:	00800044 	movi	r2,1
81103f7c:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103f80:	e03ff915 	stw	zero,-28(fp)
			break;
81103f84:	00000306 	br	81103f94 <bSdmaDmaM1Transfer+0x304>
		default:
			bStatus = FALSE;
81103f88:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103f8c:	e03ff915 	stw	zero,-28(fp)
			break;
81103f90:	0001883a 	nop
		}
		break;
81103f94:	00001706 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81103f98:	e0bffd03 	ldbu	r2,-12(fp)
81103f9c:	10000826 	beq	r2,zero,81103fc0 <bSdmaDmaM1Transfer+0x330>
81103fa0:	10800060 	cmpeqi	r2,r2,1
81103fa4:	10000d26 	beq	r2,zero,81103fdc <bSdmaDmaM1Transfer+0x34c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81103fa8:	00b80014 	movui	r2,57344
81103fac:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81103fb0:	00800044 	movi	r2,1
81103fb4:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103fb8:	e03ff915 	stw	zero,-28(fp)
			break;
81103fbc:	00000a06 	br	81103fe8 <bSdmaDmaM1Transfer+0x358>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81103fc0:	008000b4 	movhi	r2,2
81103fc4:	10b80004 	addi	r2,r2,-8192
81103fc8:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81103fcc:	00800044 	movi	r2,1
81103fd0:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103fd4:	e03ff915 	stw	zero,-28(fp)
			break;
81103fd8:	00000306 	br	81103fe8 <bSdmaDmaM1Transfer+0x358>
		default:
			bStatus = FALSE;
81103fdc:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103fe0:	e03ff915 	stw	zero,-28(fp)
			break;
81103fe4:	0001883a 	nop
		}
		break;
81103fe8:	00000206 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	default:
		bStatus = FALSE;
81103fec:	e03ff315 	stw	zero,-52(fp)
		break;
81103ff0:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW
81103ff4:	e0bffb17 	ldw	r2,-20(fp)
81103ff8:	e0bff715 	stw	r2,-36(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81103ffc:	e03ff815 	stw	zero,-32(fp)

	if ((bStatus) && (bBufferEmptyFlag)) {
81104000:	e0bff317 	ldw	r2,-52(fp)
81104004:	10003d26 	beq	r2,zero,811040fc <bSdmaDmaM1Transfer+0x46c>
81104008:	e0bff917 	ldw	r2,-28(fp)
8110400c:	10003b26 	beq	r2,zero,811040fc <bSdmaDmaM1Transfer+0x46c>
		if (pxDmaM1Dev == NULL) {
81104010:	d0a03917 	ldw	r2,-32540(gp)
81104014:	1000021e 	bne	r2,zero,81104020 <bSdmaDmaM1Transfer+0x390>
			bStatus = FALSE;
81104018:	e03ff315 	stw	zero,-52(fp)
8110401c:	00003706 	br	811040fc <bSdmaDmaM1Transfer+0x46c>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81104020:	e03ff40d 	sth	zero,-48(fp)
81104024:	00003206 	br	811040f0 <bSdmaDmaM1Transfer+0x460>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
81104028:	01000044 	movi	r4,1
8110402c:	113545c0 	call	8113545c <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81104030:	d0a03917 	ldw	r2,-32540(gp)
81104034:	10800317 	ldw	r2,12(r2)
81104038:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
8110403c:	1080010c 	andi	r2,r2,4
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
81104040:	103ff91e 	bne	r2,zero,81104028 <__reset+0xfb0e4028>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
81104044:	d2203917 	ldw	r8,-32540(gp)
81104048:	e17ff717 	ldw	r5,-36(fp)
8110404c:	e1bff517 	ldw	r6,-44(fp)
81104050:	e0bff817 	ldw	r2,-32(fp)
81104054:	e0fff617 	ldw	r3,-40(fp)
81104058:	01000044 	movi	r4,1
8110405c:	d9000815 	stw	r4,32(sp)
81104060:	01000044 	movi	r4,1
81104064:	d9000715 	stw	r4,28(sp)
81104068:	01000044 	movi	r4,1
8110406c:	d9000615 	stw	r4,24(sp)
81104070:	01000044 	movi	r4,1
81104074:	d9000515 	stw	r4,20(sp)
81104078:	01000044 	movi	r4,1
8110407c:	d9000415 	stw	r4,16(sp)
81104080:	d8c00315 	stw	r3,12(sp)
81104084:	d8800215 	stw	r2,8(sp)
81104088:	e0bffa17 	ldw	r2,-24(fp)
8110408c:	d8800115 	stw	r2,4(sp)
81104090:	00802204 	movi	r2,136
81104094:	d8800015 	stw	r2,0(sp)
81104098:	300f883a 	mov	r7,r6
8110409c:	280d883a 	mov	r6,r5
811040a0:	800b883a 	mov	r5,r16
811040a4:	4009883a 	mov	r4,r8
811040a8:	110bcfc0 	call	8110bcfc <iMsgdmaConstructExtendedMmToMmDescriptor>
811040ac:	10000226 	beq	r2,zero,811040b8 <bSdmaDmaM1Transfer+0x428>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
811040b0:	e03ff315 	stw	zero,-52(fp)
					break;
811040b4:	00001106 	br	811040fc <bSdmaDmaM1Transfer+0x46c>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM1Dev,
811040b8:	d0a03917 	ldw	r2,-32540(gp)
811040bc:	800b883a 	mov	r5,r16
811040c0:	1009883a 	mov	r4,r2
811040c4:	110be000 	call	8110be00 <iMsgdmaExtendedDescriptorSyncTransfer>
811040c8:	10000226 	beq	r2,zero,811040d4 <bSdmaDmaM1Transfer+0x444>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
811040cc:	e03ff315 	stw	zero,-52(fp)
						break;
811040d0:	00000a06 	br	811040fc <bSdmaDmaM1Transfer+0x46c>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
811040d4:	e0bff717 	ldw	r2,-36(fp)
811040d8:	10802204 	addi	r2,r2,136
811040dc:	e0bff715 	stw	r2,-36(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
811040e0:	e03ff815 	stw	zero,-32(fp)

	if ((bStatus) && (bBufferEmptyFlag)) {
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
811040e4:	e0bff40b 	ldhu	r2,-48(fp)
811040e8:	10800044 	addi	r2,r2,1
811040ec:	e0bff40d 	sth	r2,-48(fp)
811040f0:	e0fff40b 	ldhu	r3,-48(fp)
811040f4:	e0bffc0b 	ldhu	r2,-16(fp)
811040f8:	18bfcd36 	bltu	r3,r2,81104030 <__reset+0xfb0e4030>
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
811040fc:	e0bff317 	ldw	r2,-52(fp)
}
81104100:	e6ffff04 	addi	sp,fp,-4
81104104:	dfc00217 	ldw	ra,8(sp)
81104108:	df000117 	ldw	fp,4(sp)
8110410c:	dc000017 	ldw	r16,0(sp)
81104110:	dec00304 	addi	sp,sp,12
81104114:	f800283a 	ret

81104118 <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
81104118:	deffe904 	addi	sp,sp,-92
8110411c:	de00012e 	bgeu	sp,et,81104124 <bSdmaDmaM2Transfer+0xc>
81104120:	003b68fa 	trap	3
81104124:	dfc01615 	stw	ra,88(sp)
81104128:	df001515 	stw	fp,84(sp)
8110412c:	dc001415 	stw	r16,80(sp)
81104130:	df001504 	addi	fp,sp,84
81104134:	e13ffb15 	stw	r4,-20(fp)
81104138:	2809883a 	mov	r4,r5
8110413c:	3007883a 	mov	r3,r6
81104140:	3805883a 	mov	r2,r7
81104144:	e13ffc0d 	sth	r4,-16(fp)
81104148:	e0fffd05 	stb	r3,-12(fp)
8110414c:	e0bffe05 	stb	r2,-8(fp)
81104150:	defff004 	addi	sp,sp,-64
81104154:	d8800904 	addi	r2,sp,36
81104158:	108007c4 	addi	r2,r2,31
8110415c:	1004d17a 	srli	r2,r2,5
81104160:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81104164:	00800044 	movi	r2,1
81104168:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
8110416c:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81104170:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
81104174:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
81104178:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
8110417c:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81104180:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81104184:	e0bffe03 	ldbu	r2,-8(fp)
81104188:	10c00228 	cmpgeui	r3,r2,8
8110418c:	18009c1e 	bne	r3,zero,81104400 <bSdmaDmaM2Transfer+0x2e8>
81104190:	100690ba 	slli	r3,r2,2
81104194:	00a04434 	movhi	r2,33040
81104198:	10906a04 	addi	r2,r2,16808
8110419c:	1885883a 	add	r2,r3,r2
811041a0:	10800017 	ldw	r2,0(r2)
811041a4:	1000683a 	jmp	r2
811041a8:	811041c8 	cmpgei	r4,r16,16647
811041ac:	81104208 	cmpgei	r4,r16,16648
811041b0:	81104250 	cmplti	r4,r16,16649
811041b4:	81104298 	cmpnei	r4,r16,16650
811041b8:	811042e0 	cmpeqi	r4,r16,16651
811041bc:	81104328 	cmpgeui	r4,r16,16652
811041c0:	81104370 	cmpltui	r4,r16,16653
811041c4:	811043b8 	rdprs	r4,r16,16654
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
811041c8:	e0bffd03 	ldbu	r2,-12(fp)
811041cc:	10000626 	beq	r2,zero,811041e8 <bSdmaDmaM2Transfer+0xd0>
811041d0:	10800060 	cmpeqi	r2,r2,1
811041d4:	10000926 	beq	r2,zero,811041fc <bSdmaDmaM2Transfer+0xe4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
811041d8:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
811041dc:	00800044 	movi	r2,1
811041e0:	e0bff715 	stw	r2,-36(fp)
			break;
811041e4:	00000706 	br	81104204 <bSdmaDmaM2Transfer+0xec>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
811041e8:	00800074 	movhi	r2,1
811041ec:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
811041f0:	00800044 	movi	r2,1
811041f4:	e0bff715 	stw	r2,-36(fp)
			break;
811041f8:	00000206 	br	81104204 <bSdmaDmaM2Transfer+0xec>
		default:
			bStatus = FALSE;
811041fc:	e03ff415 	stw	zero,-48(fp)
			break;
81104200:	0001883a 	nop
		}
		break;
81104204:	00008006 	br	81104408 <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81104208:	e0bffd03 	ldbu	r2,-12(fp)
8110420c:	10000726 	beq	r2,zero,8110422c <bSdmaDmaM2Transfer+0x114>
81104210:	10800060 	cmpeqi	r2,r2,1
81104214:	10000b26 	beq	r2,zero,81104244 <bSdmaDmaM2Transfer+0x12c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81104218:	00880004 	movi	r2,8192
8110421c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81104220:	00800044 	movi	r2,1
81104224:	e0bff715 	stw	r2,-36(fp)
			break;
81104228:	00000806 	br	8110424c <bSdmaDmaM2Transfer+0x134>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
8110422c:	00800074 	movhi	r2,1
81104230:	10880004 	addi	r2,r2,8192
81104234:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81104238:	00800044 	movi	r2,1
8110423c:	e0bff715 	stw	r2,-36(fp)
			break;
81104240:	00000206 	br	8110424c <bSdmaDmaM2Transfer+0x134>
		default:
			bStatus = FALSE;
81104244:	e03ff415 	stw	zero,-48(fp)
			break;
81104248:	0001883a 	nop
		}
		break;
8110424c:	00006e06 	br	81104408 <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81104250:	e0bffd03 	ldbu	r2,-12(fp)
81104254:	10000726 	beq	r2,zero,81104274 <bSdmaDmaM2Transfer+0x15c>
81104258:	10800060 	cmpeqi	r2,r2,1
8110425c:	10000b26 	beq	r2,zero,8110428c <bSdmaDmaM2Transfer+0x174>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81104260:	00900004 	movi	r2,16384
81104264:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81104268:	00800044 	movi	r2,1
8110426c:	e0bff715 	stw	r2,-36(fp)
			break;
81104270:	00000806 	br	81104294 <bSdmaDmaM2Transfer+0x17c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81104274:	00800074 	movhi	r2,1
81104278:	10900004 	addi	r2,r2,16384
8110427c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81104280:	00800044 	movi	r2,1
81104284:	e0bff715 	stw	r2,-36(fp)
			break;
81104288:	00000206 	br	81104294 <bSdmaDmaM2Transfer+0x17c>
		default:
			bStatus = FALSE;
8110428c:	e03ff415 	stw	zero,-48(fp)
			break;
81104290:	0001883a 	nop
		}
		break;
81104294:	00005c06 	br	81104408 <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81104298:	e0bffd03 	ldbu	r2,-12(fp)
8110429c:	10000726 	beq	r2,zero,811042bc <bSdmaDmaM2Transfer+0x1a4>
811042a0:	10800060 	cmpeqi	r2,r2,1
811042a4:	10000b26 	beq	r2,zero,811042d4 <bSdmaDmaM2Transfer+0x1bc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
811042a8:	00980004 	movi	r2,24576
811042ac:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
811042b0:	00800044 	movi	r2,1
811042b4:	e0bff715 	stw	r2,-36(fp)
			break;
811042b8:	00000806 	br	811042dc <bSdmaDmaM2Transfer+0x1c4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
811042bc:	00800074 	movhi	r2,1
811042c0:	10980004 	addi	r2,r2,24576
811042c4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
811042c8:	00800044 	movi	r2,1
811042cc:	e0bff715 	stw	r2,-36(fp)
			break;
811042d0:	00000206 	br	811042dc <bSdmaDmaM2Transfer+0x1c4>
		default:
			bStatus = FALSE;
811042d4:	e03ff415 	stw	zero,-48(fp)
			break;
811042d8:	0001883a 	nop
		}
		break;
811042dc:	00004a06 	br	81104408 <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
811042e0:	e0bffd03 	ldbu	r2,-12(fp)
811042e4:	10000726 	beq	r2,zero,81104304 <bSdmaDmaM2Transfer+0x1ec>
811042e8:	10800060 	cmpeqi	r2,r2,1
811042ec:	10000b26 	beq	r2,zero,8110431c <bSdmaDmaM2Transfer+0x204>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
811042f0:	00a00014 	movui	r2,32768
811042f4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
811042f8:	00800044 	movi	r2,1
811042fc:	e0bff715 	stw	r2,-36(fp)
			break;
81104300:	00000806 	br	81104324 <bSdmaDmaM2Transfer+0x20c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81104304:	008000b4 	movhi	r2,2
81104308:	10a00004 	addi	r2,r2,-32768
8110430c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81104310:	00800044 	movi	r2,1
81104314:	e0bff715 	stw	r2,-36(fp)
			break;
81104318:	00000206 	br	81104324 <bSdmaDmaM2Transfer+0x20c>
		default:
			bStatus = FALSE;
8110431c:	e03ff415 	stw	zero,-48(fp)
			break;
81104320:	0001883a 	nop
		}
		break;
81104324:	00003806 	br	81104408 <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81104328:	e0bffd03 	ldbu	r2,-12(fp)
8110432c:	10000726 	beq	r2,zero,8110434c <bSdmaDmaM2Transfer+0x234>
81104330:	10800060 	cmpeqi	r2,r2,1
81104334:	10000b26 	beq	r2,zero,81104364 <bSdmaDmaM2Transfer+0x24c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81104338:	00a80014 	movui	r2,40960
8110433c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81104340:	00800044 	movi	r2,1
81104344:	e0bff715 	stw	r2,-36(fp)
			break;
81104348:	00000806 	br	8110436c <bSdmaDmaM2Transfer+0x254>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
8110434c:	008000b4 	movhi	r2,2
81104350:	10a80004 	addi	r2,r2,-24576
81104354:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81104358:	00800044 	movi	r2,1
8110435c:	e0bff715 	stw	r2,-36(fp)
			break;
81104360:	00000206 	br	8110436c <bSdmaDmaM2Transfer+0x254>
		default:
			bStatus = FALSE;
81104364:	e03ff415 	stw	zero,-48(fp)
			break;
81104368:	0001883a 	nop
		}
		break;
8110436c:	00002606 	br	81104408 <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81104370:	e0bffd03 	ldbu	r2,-12(fp)
81104374:	10000726 	beq	r2,zero,81104394 <bSdmaDmaM2Transfer+0x27c>
81104378:	10800060 	cmpeqi	r2,r2,1
8110437c:	10000b26 	beq	r2,zero,811043ac <bSdmaDmaM2Transfer+0x294>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81104380:	00b00014 	movui	r2,49152
81104384:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81104388:	00800044 	movi	r2,1
8110438c:	e0bff715 	stw	r2,-36(fp)
			break;
81104390:	00000806 	br	811043b4 <bSdmaDmaM2Transfer+0x29c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81104394:	008000b4 	movhi	r2,2
81104398:	10b00004 	addi	r2,r2,-16384
8110439c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
811043a0:	00800044 	movi	r2,1
811043a4:	e0bff715 	stw	r2,-36(fp)
			break;
811043a8:	00000206 	br	811043b4 <bSdmaDmaM2Transfer+0x29c>
		default:
			bStatus = FALSE;
811043ac:	e03ff415 	stw	zero,-48(fp)
			break;
811043b0:	0001883a 	nop
		}
		break;
811043b4:	00001406 	br	81104408 <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
811043b8:	e0bffd03 	ldbu	r2,-12(fp)
811043bc:	10000726 	beq	r2,zero,811043dc <bSdmaDmaM2Transfer+0x2c4>
811043c0:	10800060 	cmpeqi	r2,r2,1
811043c4:	10000b26 	beq	r2,zero,811043f4 <bSdmaDmaM2Transfer+0x2dc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
811043c8:	00b80014 	movui	r2,57344
811043cc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
811043d0:	00800044 	movi	r2,1
811043d4:	e0bff715 	stw	r2,-36(fp)
			break;
811043d8:	00000806 	br	811043fc <bSdmaDmaM2Transfer+0x2e4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
811043dc:	008000b4 	movhi	r2,2
811043e0:	10b80004 	addi	r2,r2,-8192
811043e4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
811043e8:	00800044 	movi	r2,1
811043ec:	e0bff715 	stw	r2,-36(fp)
			break;
811043f0:	00000206 	br	811043fc <bSdmaDmaM2Transfer+0x2e4>
		default:
			bStatus = FALSE;
811043f4:	e03ff415 	stw	zero,-48(fp)
			break;
811043f8:	0001883a 	nop
		}
		break;
811043fc:	00000206 	br	81104408 <bSdmaDmaM2Transfer+0x2f0>
	default:
		bStatus = FALSE;
81104400:	e03ff415 	stw	zero,-48(fp)
		break;
81104404:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
81104408:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bStatus = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
8110440c:	00a00034 	movhi	r2,32768
81104410:	1885883a 	add	r2,r3,r2
81104414:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
81104418:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
8110441c:	e0bff417 	ldw	r2,-48(fp)
81104420:	10003b26 	beq	r2,zero,81104510 <bSdmaDmaM2Transfer+0x3f8>
		if (pxDmaM2Dev == NULL) {
81104424:	d0a03a17 	ldw	r2,-32536(gp)
81104428:	1000021e 	bne	r2,zero,81104434 <bSdmaDmaM2Transfer+0x31c>
			bStatus = FALSE;
8110442c:	e03ff415 	stw	zero,-48(fp)
81104430:	00003706 	br	81104510 <bSdmaDmaM2Transfer+0x3f8>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81104434:	e03ff50d 	sth	zero,-44(fp)
81104438:	00003206 	br	81104504 <bSdmaDmaM2Transfer+0x3ec>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
8110443c:	01000044 	movi	r4,1
81104440:	113545c0 	call	8113545c <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81104444:	d0a03a17 	ldw	r2,-32536(gp)
81104448:	10800317 	ldw	r2,12(r2)
8110444c:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81104450:	1080010c 	andi	r2,r2,4
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
81104454:	103ff91e 	bne	r2,zero,8110443c <__reset+0xfb0e443c>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
81104458:	d2203a17 	ldw	r8,-32536(gp)
8110445c:	e17ff817 	ldw	r5,-32(fp)
81104460:	e1bff617 	ldw	r6,-40(fp)
81104464:	e0bff917 	ldw	r2,-28(fp)
81104468:	e0fff717 	ldw	r3,-36(fp)
8110446c:	01000044 	movi	r4,1
81104470:	d9000815 	stw	r4,32(sp)
81104474:	01000044 	movi	r4,1
81104478:	d9000715 	stw	r4,28(sp)
8110447c:	01000044 	movi	r4,1
81104480:	d9000615 	stw	r4,24(sp)
81104484:	01000044 	movi	r4,1
81104488:	d9000515 	stw	r4,20(sp)
8110448c:	01000044 	movi	r4,1
81104490:	d9000415 	stw	r4,16(sp)
81104494:	d8c00315 	stw	r3,12(sp)
81104498:	d8800215 	stw	r2,8(sp)
8110449c:	e0bffa17 	ldw	r2,-24(fp)
811044a0:	d8800115 	stw	r2,4(sp)
811044a4:	00802204 	movi	r2,136
811044a8:	d8800015 	stw	r2,0(sp)
811044ac:	300f883a 	mov	r7,r6
811044b0:	280d883a 	mov	r6,r5
811044b4:	800b883a 	mov	r5,r16
811044b8:	4009883a 	mov	r4,r8
811044bc:	110bcfc0 	call	8110bcfc <iMsgdmaConstructExtendedMmToMmDescriptor>
811044c0:	10000226 	beq	r2,zero,811044cc <bSdmaDmaM2Transfer+0x3b4>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
811044c4:	e03ff415 	stw	zero,-48(fp)
					break;
811044c8:	00001106 	br	81104510 <bSdmaDmaM2Transfer+0x3f8>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
811044cc:	d0a03a17 	ldw	r2,-32536(gp)
811044d0:	800b883a 	mov	r5,r16
811044d4:	1009883a 	mov	r4,r2
811044d8:	110be000 	call	8110be00 <iMsgdmaExtendedDescriptorSyncTransfer>
811044dc:	10000226 	beq	r2,zero,811044e8 <bSdmaDmaM2Transfer+0x3d0>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
811044e0:	e03ff415 	stw	zero,-48(fp)
						break;
811044e4:	00000a06 	br	81104510 <bSdmaDmaM2Transfer+0x3f8>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
811044e8:	e0bff817 	ldw	r2,-32(fp)
811044ec:	10802204 	addi	r2,r2,136
811044f0:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
811044f4:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
811044f8:	e0bff50b 	ldhu	r2,-44(fp)
811044fc:	10800044 	addi	r2,r2,1
81104500:	e0bff50d 	sth	r2,-44(fp)
81104504:	e0fff50b 	ldhu	r3,-44(fp)
81104508:	e0bffc0b 	ldhu	r2,-16(fp)
8110450c:	18bfcd36 	bltu	r3,r2,81104444 <__reset+0xfb0e4444>
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
81104510:	e0bff417 	ldw	r2,-48(fp)
}
81104514:	e6ffff04 	addi	sp,fp,-4
81104518:	dfc00217 	ldw	ra,8(sp)
8110451c:	df000117 	ldw	fp,4(sp)
81104520:	dc000017 	ldw	r16,0(sp)
81104524:	dec00304 	addi	sp,sp,12
81104528:	f800283a 	ret

8110452c <bCommSetGlobalIrqEn>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bCommSetGlobalIrqEn(bool bGlobalIrqEnable, alt_u8 ucCommCh) {
8110452c:	defff904 	addi	sp,sp,-28
81104530:	de00012e 	bgeu	sp,et,81104538 <bCommSetGlobalIrqEn+0xc>
81104534:	003b68fa 	trap	3
81104538:	dfc00615 	stw	ra,24(sp)
8110453c:	df000515 	stw	fp,20(sp)
81104540:	df000504 	addi	fp,sp,20
81104544:	e13ffe15 	stw	r4,-8(fp)
81104548:	2805883a 	mov	r2,r5
8110454c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81104550:	00800044 	movi	r2,1
81104554:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
81104558:	e03ffc15 	stw	zero,-16(fp)
	alt_u32 *puliCommAddr = 0;
8110455c:	e03ffd15 	stw	zero,-12(fp)

	switch (ucCommCh) {
81104560:	e0bfff03 	ldbu	r2,-4(fp)
81104564:	10c00228 	cmpgeui	r3,r2,8
81104568:	18002e1e 	bne	r3,zero,81104624 <bCommSetGlobalIrqEn+0xf8>
8110456c:	100690ba 	slli	r3,r2,2
81104570:	00a04434 	movhi	r2,33040
81104574:	10916104 	addi	r2,r2,17796
81104578:	1885883a 	add	r2,r3,r2
8110457c:	10800017 	ldw	r2,0(r2)
81104580:	1000683a 	jmp	r2
81104584:	811045a4 	muli	r4,r16,16662
81104588:	811045b4 	orhi	r4,r16,16662
8110458c:	811045c4 	addi	r4,r16,16663
81104590:	811045d4 	ori	r4,r16,16663
81104594:	811045e4 	muli	r4,r16,16663
81104598:	811045f4 	orhi	r4,r16,16663
8110459c:	81104604 	addi	r4,r16,16664
811045a0:	81104614 	ori	r4,r16,16664
	case eCommSpwCh1:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
811045a4:	00a04834 	movhi	r2,33056
811045a8:	108b0004 	addi	r2,r2,11264
811045ac:	e0bffd15 	stw	r2,-12(fp)
		break;
811045b0:	00001e06 	br	8110462c <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh2:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
811045b4:	00a04834 	movhi	r2,33056
811045b8:	108a0004 	addi	r2,r2,10240
811045bc:	e0bffd15 	stw	r2,-12(fp)
		break;
811045c0:	00001a06 	br	8110462c <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh3:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811045c4:	00a04834 	movhi	r2,33056
811045c8:	108b0004 	addi	r2,r2,11264
811045cc:	e0bffd15 	stw	r2,-12(fp)
		break;
811045d0:	00001606 	br	8110462c <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh4:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
811045d4:	00a04834 	movhi	r2,33056
811045d8:	108a0004 	addi	r2,r2,10240
811045dc:	e0bffd15 	stw	r2,-12(fp)
		break;
811045e0:	00001206 	br	8110462c <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh5:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
811045e4:	00a04834 	movhi	r2,33056
811045e8:	108b0004 	addi	r2,r2,11264
811045ec:	e0bffd15 	stw	r2,-12(fp)
		break;
811045f0:	00000e06 	br	8110462c <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh6:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
811045f4:	00a04834 	movhi	r2,33056
811045f8:	108a0004 	addi	r2,r2,10240
811045fc:	e0bffd15 	stw	r2,-12(fp)
		break;
81104600:	00000a06 	br	8110462c <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh7:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104604:	00a04834 	movhi	r2,33056
81104608:	108b0004 	addi	r2,r2,11264
8110460c:	e0bffd15 	stw	r2,-12(fp)
		break;
81104610:	00000606 	br	8110462c <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh8:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104614:	00a04834 	movhi	r2,33056
81104618:	108a0004 	addi	r2,r2,10240
8110461c:	e0bffd15 	stw	r2,-12(fp)
		break;
81104620:	00000206 	br	8110462c <bCommSetGlobalIrqEn+0x100>
	default:
		bStatus = FALSE;
81104624:	e03ffb15 	stw	zero,-20(fp)
		break;
81104628:	0001883a 	nop
	}

	if (bStatus) {
8110462c:	e0bffb17 	ldw	r2,-20(fp)
81104630:	10001326 	beq	r2,zero,81104680 <bCommSetGlobalIrqEn+0x154>
		uliReg = uliCommReadReg(puliCommAddr,
81104634:	01400444 	movi	r5,17
81104638:	e13ffd17 	ldw	r4,-12(fp)
8110463c:	11047c80 	call	811047c8 <uliCommReadReg>
81104640:	e0bffc15 	stw	r2,-16(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (bGlobalIrqEnable) {
81104644:	e0bffe17 	ldw	r2,-8(fp)
81104648:	10000426 	beq	r2,zero,8110465c <bCommSetGlobalIrqEn+0x130>
			uliReg |= COMM_IRQ_GLOBAL_EN_MSK;
8110464c:	e0bffc17 	ldw	r2,-16(fp)
81104650:	10800074 	orhi	r2,r2,1
81104654:	e0bffc15 	stw	r2,-16(fp)
81104658:	00000506 	br	81104670 <bCommSetGlobalIrqEn+0x144>
		} else {
			uliReg &= (~COMM_IRQ_GLOBAL_EN_MSK);
8110465c:	e0fffc17 	ldw	r3,-16(fp)
81104660:	00bffff4 	movhi	r2,65535
81104664:	10bfffc4 	addi	r2,r2,-1
81104668:	1884703a 	and	r2,r3,r2
8110466c:	e0bffc15 	stw	r2,-16(fp)
		}

		vCommWriteReg(puliCommAddr, COMM_IRQ_CONTROL_REG_OFST, uliReg);
81104670:	e1bffc17 	ldw	r6,-16(fp)
81104674:	01400444 	movi	r5,17
81104678:	e13ffd17 	ldw	r4,-12(fp)
8110467c:	11047740 	call	81104774 <vCommWriteReg>
	}

	return bStatus;
81104680:	e0bffb17 	ldw	r2,-20(fp)
}
81104684:	e037883a 	mov	sp,fp
81104688:	dfc00117 	ldw	ra,4(sp)
8110468c:	df000017 	ldw	fp,0(sp)
81104690:	dec00204 	addi	sp,sp,8
81104694:	f800283a 	ret

81104698 <bCommInitCh>:

bool bCommInitCh(TCommChannel *pxCommCh, alt_u8 ucCommCh) {
81104698:	defffb04 	addi	sp,sp,-20
8110469c:	de00012e 	bgeu	sp,et,811046a4 <bCommInitCh+0xc>
811046a0:	003b68fa 	trap	3
811046a4:	dfc00415 	stw	ra,16(sp)
811046a8:	df000315 	stw	fp,12(sp)
811046ac:	df000304 	addi	fp,sp,12
811046b0:	e13ffe15 	stw	r4,-8(fp)
811046b4:	2805883a 	mov	r2,r5
811046b8:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811046bc:	00800044 	movi	r2,1
811046c0:	e0bffd15 	stw	r2,-12(fp)

	if (!bSpwcInitCh(&(pxCommCh->xSpacewire), ucCommCh)) {
811046c4:	e0bffe17 	ldw	r2,-8(fp)
811046c8:	10805704 	addi	r2,r2,348
811046cc:	e0ffff03 	ldbu	r3,-4(fp)
811046d0:	180b883a 	mov	r5,r3
811046d4:	1009883a 	mov	r4,r2
811046d8:	110a6800 	call	8110a680 <bSpwcInitCh>
811046dc:	1000011e 	bne	r2,zero,811046e4 <bCommInitCh+0x4c>
		bStatus = FALSE;
811046e0:	e03ffd15 	stw	zero,-12(fp)
	}
	vFeebInitIrq(ucCommCh);
811046e4:	e0bfff03 	ldbu	r2,-4(fp)
811046e8:	1009883a 	mov	r4,r2
811046ec:	11060440 	call	81106044 <vFeebInitIrq>

	if (!bFeebInitCh(&(pxCommCh->xFeeBuffer), ucCommCh)) {
811046f0:	e0bffe17 	ldw	r2,-8(fp)
811046f4:	10800904 	addi	r2,r2,36
811046f8:	e0ffff03 	ldbu	r3,-4(fp)
811046fc:	180b883a 	mov	r5,r3
81104700:	1009883a 	mov	r4,r2
81104704:	1106b0c0 	call	81106b0c <bFeebInitCh>
81104708:	1000011e 	bne	r2,zero,81104710 <bCommInitCh+0x78>
		bStatus = FALSE;
8110470c:	e03ffd15 	stw	zero,-12(fp)
	}
	if (!bRmapInitCh(&(pxCommCh->xRmap), ucCommCh)) {
81104710:	e0bffe17 	ldw	r2,-8(fp)
81104714:	10801104 	addi	r2,r2,68
81104718:	e0ffff03 	ldbu	r3,-4(fp)
8110471c:	180b883a 	mov	r5,r3
81104720:	1009883a 	mov	r4,r2
81104724:	1109cdc0 	call	81109cdc <bRmapInitCh>
81104728:	1000011e 	bne	r2,zero,81104730 <bCommInitCh+0x98>
		bStatus = FALSE;
8110472c:	e03ffd15 	stw	zero,-12(fp)
	}
	vRmapInitIrq(ucCommCh);
81104730:	e0bfff03 	ldbu	r2,-4(fp)
81104734:	1009883a 	mov	r4,r2
81104738:	11077180 	call	81107718 <vRmapInitIrq>

	if (!bDpktInitCh(&(pxCommCh->xDataPacket), ucCommCh)) {
8110473c:	e0bffe17 	ldw	r2,-8(fp)
81104740:	10800104 	addi	r2,r2,4
81104744:	e0ffff03 	ldbu	r3,-4(fp)
81104748:	180b883a 	mov	r5,r3
8110474c:	1009883a 	mov	r4,r2
81104750:	1104e400 	call	81104e40 <bDpktInitCh>
81104754:	1000011e 	bne	r2,zero,8110475c <bCommInitCh+0xc4>
		bStatus = FALSE;
81104758:	e03ffd15 	stw	zero,-12(fp)
	}
	return bStatus;
8110475c:	e0bffd17 	ldw	r2,-12(fp)
}
81104760:	e037883a 	mov	sp,fp
81104764:	dfc00117 	ldw	ra,4(sp)
81104768:	df000017 	ldw	fp,0(sp)
8110476c:	dec00204 	addi	sp,sp,8
81104770:	f800283a 	ret

81104774 <vCommWriteReg>:
//! [public functions]

//! [private functions]
static void vCommWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104774:	defffc04 	addi	sp,sp,-16
81104778:	de00012e 	bgeu	sp,et,81104780 <vCommWriteReg+0xc>
8110477c:	003b68fa 	trap	3
81104780:	df000315 	stw	fp,12(sp)
81104784:	df000304 	addi	fp,sp,12
81104788:	e13ffd15 	stw	r4,-12(fp)
8110478c:	e17ffe15 	stw	r5,-8(fp)
81104790:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104794:	e0bffe17 	ldw	r2,-8(fp)
81104798:	1085883a 	add	r2,r2,r2
8110479c:	1085883a 	add	r2,r2,r2
811047a0:	1007883a 	mov	r3,r2
811047a4:	e0bffd17 	ldw	r2,-12(fp)
811047a8:	10c5883a 	add	r2,r2,r3
811047ac:	e0ffff17 	ldw	r3,-4(fp)
811047b0:	10c00015 	stw	r3,0(r2)
}
811047b4:	0001883a 	nop
811047b8:	e037883a 	mov	sp,fp
811047bc:	df000017 	ldw	fp,0(sp)
811047c0:	dec00104 	addi	sp,sp,4
811047c4:	f800283a 	ret

811047c8 <uliCommReadReg>:

static alt_u32 uliCommReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
811047c8:	defffc04 	addi	sp,sp,-16
811047cc:	de00012e 	bgeu	sp,et,811047d4 <uliCommReadReg+0xc>
811047d0:	003b68fa 	trap	3
811047d4:	df000315 	stw	fp,12(sp)
811047d8:	df000304 	addi	fp,sp,12
811047dc:	e13ffe15 	stw	r4,-8(fp)
811047e0:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
811047e4:	e0bfff17 	ldw	r2,-4(fp)
811047e8:	1085883a 	add	r2,r2,r2
811047ec:	1085883a 	add	r2,r2,r2
811047f0:	1007883a 	mov	r3,r2
811047f4:	e0bffe17 	ldw	r2,-8(fp)
811047f8:	10c5883a 	add	r2,r2,r3
811047fc:	10800017 	ldw	r2,0(r2)
81104800:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81104804:	e0bffd17 	ldw	r2,-12(fp)
}
81104808:	e037883a 	mov	sp,fp
8110480c:	df000017 	ldw	fp,0(sp)
81104810:	dec00104 	addi	sp,sp,4
81104814:	f800283a 	ret

81104818 <bDpktSetPacketConfig>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bDpktSetPacketConfig(TDpktChannel *pxDpktCh) {
81104818:	defffb04 	addi	sp,sp,-20
8110481c:	de00012e 	bgeu	sp,et,81104824 <bDpktSetPacketConfig+0xc>
81104820:	003b68fa 	trap	3
81104824:	dfc00415 	stw	ra,16(sp)
81104828:	df000315 	stw	fp,12(sp)
8110482c:	df000304 	addi	fp,sp,12
81104830:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104834:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104838:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
8110483c:	e0bfff17 	ldw	r2,-4(fp)
81104840:	10007a26 	beq	r2,zero,81104a2c <bDpktSetPacketConfig+0x214>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104844:	e0bfff17 	ldw	r2,-4(fp)
81104848:	10800017 	ldw	r2,0(r2)
8110484c:	01400204 	movi	r5,8
81104850:	1009883a 	mov	r4,r2
81104854:	11050080 	call	81105008 <uliDpktReadReg>
81104858:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
8110485c:	e0bffe17 	ldw	r2,-8(fp)
81104860:	10bfffec 	andhi	r2,r2,65535
81104864:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
81104868:	e0bfff17 	ldw	r2,-4(fp)
8110486c:	1080010b 	ldhu	r2,4(r2)
81104870:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
81104874:	e0fffe17 	ldw	r3,-8(fp)
81104878:	1884b03a 	or	r2,r3,r2
8110487c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
81104880:	e0bffe17 	ldw	r2,-8(fp)
81104884:	10bfffcc 	andi	r2,r2,65535
81104888:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));
8110488c:	e0bfff17 	ldw	r2,-4(fp)
81104890:	1080018b 	ldhu	r2,6(r2)
81104894:	10bfffcc 	andi	r2,r2,65535
81104898:	1004943a 	slli	r2,r2,16
8110489c:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
811048a0:	e0bffe17 	ldw	r2,-8(fp)
811048a4:	10c4b03a 	or	r2,r2,r3
811048a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_1_REG_OFST,
811048ac:	e0bfff17 	ldw	r2,-4(fp)
811048b0:	10800017 	ldw	r2,0(r2)
811048b4:	e1bffe17 	ldw	r6,-8(fp)
811048b8:	01400204 	movi	r5,8
811048bc:	1009883a 	mov	r4,r2
811048c0:	1104fb40 	call	81104fb4 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811048c4:	e0bfff17 	ldw	r2,-4(fp)
811048c8:	10800017 	ldw	r2,0(r2)
811048cc:	01400244 	movi	r5,9
811048d0:	1009883a 	mov	r4,r2
811048d4:	11050080 	call	81105008 <uliDpktReadReg>
811048d8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
811048dc:	e0bffe17 	ldw	r2,-8(fp)
811048e0:	10bfffec 	andhi	r2,r2,65535
811048e4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
811048e8:	e0bfff17 	ldw	r2,-4(fp)
811048ec:	1080020b 	ldhu	r2,8(r2)
811048f0:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
811048f4:	e0fffe17 	ldw	r3,-8(fp)
811048f8:	1884b03a 	or	r2,r3,r2
811048fc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
81104900:	e0bffe17 	ldw	r2,-8(fp)
81104904:	10bfffcc 	andi	r2,r2,65535
81104908:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
8110490c:	e0bfff17 	ldw	r2,-4(fp)
81104910:	1080028b 	ldhu	r2,10(r2)
										<< 16));
81104914:	10bfffcc 	andi	r2,r2,65535
81104918:	1004943a 	slli	r2,r2,16
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
8110491c:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
81104920:	e0bffe17 	ldw	r2,-8(fp)
81104924:	10c4b03a 	or	r2,r2,r3
81104928:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
										<< 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_2_REG_OFST,
8110492c:	e0bfff17 	ldw	r2,-4(fp)
81104930:	10800017 	ldw	r2,0(r2)
81104934:	e1bffe17 	ldw	r6,-8(fp)
81104938:	01400244 	movi	r5,9
8110493c:	1009883a 	mov	r4,r2
81104940:	1104fb40 	call	81104fb4 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104944:	e0bfff17 	ldw	r2,-4(fp)
81104948:	10800017 	ldw	r2,0(r2)
8110494c:	01400284 	movi	r5,10
81104950:	1009883a 	mov	r4,r2
81104954:	11050080 	call	81105008 <uliDpktReadReg>
81104958:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
8110495c:	e0bffe17 	ldw	r2,-8(fp)
81104960:	10bfffec 	andhi	r2,r2,65535
81104964:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
81104968:	e0bfff17 	ldw	r2,-4(fp)
8110496c:	1080030b 	ldhu	r2,12(r2)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
81104970:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
81104974:	e0fffe17 	ldw	r3,-8(fp)
81104978:	1884b03a 	or	r2,r3,r2
8110497c:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
										<< 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_3_REG_OFST,
81104980:	e0bfff17 	ldw	r2,-4(fp)
81104984:	10800017 	ldw	r2,0(r2)
81104988:	e1bffe17 	ldw	r6,-8(fp)
8110498c:	01400284 	movi	r5,10
81104990:	1009883a 	mov	r4,r2
81104994:	1104fb40 	call	81104fb4 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104998:	e0bfff17 	ldw	r2,-4(fp)
8110499c:	10800017 	ldw	r2,0(r2)
811049a0:	014002c4 	movi	r5,11
811049a4:	1009883a 	mov	r4,r2
811049a8:	11050080 	call	81105008 <uliDpktReadReg>
811049ac:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
811049b0:	e0fffe17 	ldw	r3,-8(fp)
811049b4:	00bfc004 	movi	r2,-256
811049b8:	1884703a 	and	r2,r3,r2
811049bc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
811049c0:	e0bfff17 	ldw	r2,-4(fp)
811049c4:	10800383 	ldbu	r2,14(r2)
811049c8:	10803fcc 	andi	r2,r2,255
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
811049cc:	e0fffe17 	ldw	r3,-8(fp)
811049d0:	1884b03a 	or	r2,r3,r2
811049d4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
811049d8:	e0fffe17 	ldw	r3,-8(fp)
811049dc:	00bffff4 	movhi	r2,65535
811049e0:	10803fc4 	addi	r2,r2,255
811049e4:	1884703a 	and	r2,r3,r2
811049e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
811049ec:	e0bfff17 	ldw	r2,-4(fp)
811049f0:	108003c3 	ldbu	r2,15(r2)
811049f4:	10803fcc 	andi	r2,r2,255
811049f8:	1004923a 	slli	r2,r2,8
811049fc:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
81104a00:	e0fffe17 	ldw	r3,-8(fp)
81104a04:	1884b03a 	or	r2,r3,r2
81104a08:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_4_REG_OFST,
81104a0c:	e0bfff17 	ldw	r2,-4(fp)
81104a10:	10800017 	ldw	r2,0(r2)
81104a14:	e1bffe17 	ldw	r6,-8(fp)
81104a18:	014002c4 	movi	r5,11
81104a1c:	1009883a 	mov	r4,r2
81104a20:	1104fb40 	call	81104fb4 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104a24:	00800044 	movi	r2,1
81104a28:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104a2c:	e0bffd17 	ldw	r2,-12(fp)
}
81104a30:	e037883a 	mov	sp,fp
81104a34:	dfc00117 	ldw	ra,4(sp)
81104a38:	df000017 	ldw	fp,0(sp)
81104a3c:	dec00204 	addi	sp,sp,8
81104a40:	f800283a 	ret

81104a44 <bDpktGetPacketConfig>:

bool bDpktGetPacketConfig(TDpktChannel *pxDpktCh) {
81104a44:	defffb04 	addi	sp,sp,-20
81104a48:	de00012e 	bgeu	sp,et,81104a50 <bDpktGetPacketConfig+0xc>
81104a4c:	003b68fa 	trap	3
81104a50:	dfc00415 	stw	ra,16(sp)
81104a54:	df000315 	stw	fp,12(sp)
81104a58:	df000304 	addi	fp,sp,12
81104a5c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104a60:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104a64:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104a68:	e0bfff17 	ldw	r2,-4(fp)
81104a6c:	10003a26 	beq	r2,zero,81104b58 <bDpktGetPacketConfig+0x114>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a70:	e0bfff17 	ldw	r2,-4(fp)
81104a74:	10800017 	ldw	r2,0(r2)
81104a78:	01400204 	movi	r5,8
81104a7c:	1009883a 	mov	r4,r2
81104a80:	11050080 	call	81105008 <uliDpktReadReg>
81104a84:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
81104a88:	e0bffe17 	ldw	r2,-8(fp)
81104a8c:	1007883a 	mov	r3,r2
81104a90:	e0bfff17 	ldw	r2,-4(fp)
81104a94:	10c0010d 	sth	r3,4(r2)
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);
81104a98:	e0bffe17 	ldw	r2,-8(fp)
81104a9c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
81104aa0:	1007883a 	mov	r3,r2
81104aa4:	e0bfff17 	ldw	r2,-4(fp)
81104aa8:	10c0018d 	sth	r3,6(r2)
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104aac:	e0bfff17 	ldw	r2,-4(fp)
81104ab0:	10800017 	ldw	r2,0(r2)
81104ab4:	01400244 	movi	r5,9
81104ab8:	1009883a 	mov	r4,r2
81104abc:	11050080 	call	81105008 <uliDpktReadReg>
81104ac0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
81104ac4:	e0bffe17 	ldw	r2,-8(fp)
81104ac8:	1007883a 	mov	r3,r2
81104acc:	e0bfff17 	ldw	r2,-4(fp)
81104ad0:	10c0020d 	sth	r3,8(r2)
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);
81104ad4:	e0bffe17 	ldw	r2,-8(fp)
81104ad8:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
81104adc:	1007883a 	mov	r3,r2
81104ae0:	e0bfff17 	ldw	r2,-4(fp)
81104ae4:	10c0028d 	sth	r3,10(r2)
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104ae8:	e0bfff17 	ldw	r2,-4(fp)
81104aec:	10800017 	ldw	r2,0(r2)
81104af0:	01400284 	movi	r5,10
81104af4:	1009883a 	mov	r4,r2
81104af8:	11050080 	call	81105008 <uliDpktReadReg>
81104afc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiPacketLength = (alt_u16)(
81104b00:	e0bffe17 	ldw	r2,-8(fp)
81104b04:	1007883a 	mov	r3,r2
81104b08:	e0bfff17 	ldw	r2,-4(fp)
81104b0c:	10c0030d 	sth	r3,12(r2)
				(uliReg & COMM_DATA_PKT_LENGTH_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b10:	e0bfff17 	ldw	r2,-4(fp)
81104b14:	10800017 	ldw	r2,0(r2)
81104b18:	014002c4 	movi	r5,11
81104b1c:	1009883a 	mov	r4,r2
81104b20:	11050080 	call	81105008 <uliDpktReadReg>
81104b24:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
81104b28:	e0bffe17 	ldw	r2,-8(fp)
81104b2c:	1007883a 	mov	r3,r2
81104b30:	e0bfff17 	ldw	r2,-4(fp)
81104b34:	10c00385 	stb	r3,14(r2)
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
81104b38:	e0bffe17 	ldw	r2,-8(fp)
81104b3c:	10bfc00c 	andi	r2,r2,65280
81104b40:	1004d23a 	srli	r2,r2,8
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
81104b44:	1007883a 	mov	r3,r2
81104b48:	e0bfff17 	ldw	r2,-4(fp)
81104b4c:	10c003c5 	stb	r3,15(r2)
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);

		bStatus = TRUE;
81104b50:	00800044 	movi	r2,1
81104b54:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104b58:	e0bffd17 	ldw	r2,-12(fp)
}
81104b5c:	e037883a 	mov	sp,fp
81104b60:	dfc00117 	ldw	ra,4(sp)
81104b64:	df000017 	ldw	fp,0(sp)
81104b68:	dec00204 	addi	sp,sp,8
81104b6c:	f800283a 	ret

81104b70 <bDpktGetPacketHeader>:

bool bDpktGetPacketHeader(TDpktChannel *pxDpktCh) {
81104b70:	defffb04 	addi	sp,sp,-20
81104b74:	de00012e 	bgeu	sp,et,81104b7c <bDpktGetPacketHeader+0xc>
81104b78:	003b68fa 	trap	3
81104b7c:	dfc00415 	stw	ra,16(sp)
81104b80:	df000315 	stw	fp,12(sp)
81104b84:	df000304 	addi	fp,sp,12
81104b88:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104b8c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104b90:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104b94:	e0bfff17 	ldw	r2,-4(fp)
81104b98:	10002026 	beq	r2,zero,81104c1c <bDpktGetPacketHeader+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b9c:	e0bfff17 	ldw	r2,-4(fp)
81104ba0:	10800017 	ldw	r2,0(r2)
81104ba4:	01400304 	movi	r5,12
81104ba8:	1009883a 	mov	r4,r2
81104bac:	11050080 	call	81105008 <uliDpktReadReg>
81104bb0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
81104bb4:	e0bffe17 	ldw	r2,-8(fp)
81104bb8:	1007883a 	mov	r3,r2
81104bbc:	e0bfff17 	ldw	r2,-4(fp)
81104bc0:	10c0040d 	sth	r3,16(r2)
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);
81104bc4:	e0bffe17 	ldw	r2,-8(fp)
81104bc8:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
81104bcc:	1007883a 	mov	r3,r2
81104bd0:	e0bfff17 	ldw	r2,-4(fp)
81104bd4:	10c0048d 	sth	r3,18(r2)
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104bd8:	e0bfff17 	ldw	r2,-4(fp)
81104bdc:	10800017 	ldw	r2,0(r2)
81104be0:	01400344 	movi	r5,13
81104be4:	1009883a 	mov	r4,r2
81104be8:	11050080 	call	81105008 <uliDpktReadReg>
81104bec:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
81104bf0:	e0bffe17 	ldw	r2,-8(fp)
81104bf4:	1007883a 	mov	r3,r2
81104bf8:	e0bfff17 	ldw	r2,-4(fp)
81104bfc:	10c0050d 	sth	r3,20(r2)
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);
81104c00:	e0bffe17 	ldw	r2,-8(fp)
81104c04:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
81104c08:	1007883a 	mov	r3,r2
81104c0c:	e0bfff17 	ldw	r2,-4(fp)
81104c10:	10c0058d 	sth	r3,22(r2)
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);

		bStatus = TRUE;
81104c14:	00800044 	movi	r2,1
81104c18:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104c1c:	e0bffd17 	ldw	r2,-12(fp)
}
81104c20:	e037883a 	mov	sp,fp
81104c24:	dfc00117 	ldw	ra,4(sp)
81104c28:	df000017 	ldw	fp,0(sp)
81104c2c:	dec00204 	addi	sp,sp,8
81104c30:	f800283a 	ret

81104c34 <bDpktSetPixelDelay>:

bool bDpktSetPixelDelay(TDpktChannel *pxDpktCh) {
81104c34:	defffb04 	addi	sp,sp,-20
81104c38:	de00012e 	bgeu	sp,et,81104c40 <bDpktSetPixelDelay+0xc>
81104c3c:	003b68fa 	trap	3
81104c40:	dfc00415 	stw	ra,16(sp)
81104c44:	df000315 	stw	fp,12(sp)
81104c48:	df000304 	addi	fp,sp,12
81104c4c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104c50:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104c54:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104c58:	e0bfff17 	ldw	r2,-4(fp)
81104c5c:	10004126 	beq	r2,zero,81104d64 <bDpktSetPixelDelay+0x130>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c60:	e0bfff17 	ldw	r2,-4(fp)
81104c64:	10800017 	ldw	r2,0(r2)
81104c68:	01400384 	movi	r5,14
81104c6c:	1009883a 	mov	r4,r2
81104c70:	11050080 	call	81105008 <uliDpktReadReg>
81104c74:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
81104c78:	e0bffe17 	ldw	r2,-8(fp)
81104c7c:	10bfffec 	andhi	r2,r2,65535
81104c80:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));
81104c84:	e0bfff17 	ldw	r2,-4(fp)
81104c88:	1080060b 	ldhu	r2,24(r2)
81104c8c:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
81104c90:	e0fffe17 	ldw	r3,-8(fp)
81104c94:	1884b03a 	or	r2,r3,r2
81104c98:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_1_REG_OFST,
81104c9c:	e0bfff17 	ldw	r2,-4(fp)
81104ca0:	10800017 	ldw	r2,0(r2)
81104ca4:	e1bffe17 	ldw	r6,-8(fp)
81104ca8:	01400384 	movi	r5,14
81104cac:	1009883a 	mov	r4,r2
81104cb0:	1104fb40 	call	81104fb4 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104cb4:	e0bfff17 	ldw	r2,-4(fp)
81104cb8:	10800017 	ldw	r2,0(r2)
81104cbc:	014003c4 	movi	r5,15
81104cc0:	1009883a 	mov	r4,r2
81104cc4:	11050080 	call	81105008 <uliDpktReadReg>
81104cc8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
81104ccc:	e0bffe17 	ldw	r2,-8(fp)
81104cd0:	10bfffec 	andhi	r2,r2,65535
81104cd4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));
81104cd8:	e0bfff17 	ldw	r2,-4(fp)
81104cdc:	1080068b 	ldhu	r2,26(r2)
81104ce0:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
81104ce4:	e0fffe17 	ldw	r3,-8(fp)
81104ce8:	1884b03a 	or	r2,r3,r2
81104cec:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_2_REG_OFST,
81104cf0:	e0bfff17 	ldw	r2,-4(fp)
81104cf4:	10800017 	ldw	r2,0(r2)
81104cf8:	e1bffe17 	ldw	r6,-8(fp)
81104cfc:	014003c4 	movi	r5,15
81104d00:	1009883a 	mov	r4,r2
81104d04:	1104fb40 	call	81104fb4 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d08:	e0bfff17 	ldw	r2,-4(fp)
81104d0c:	10800017 	ldw	r2,0(r2)
81104d10:	01400404 	movi	r5,16
81104d14:	1009883a 	mov	r4,r2
81104d18:	11050080 	call	81105008 <uliDpktReadReg>
81104d1c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
81104d20:	e0bffe17 	ldw	r2,-8(fp)
81104d24:	10bfffec 	andhi	r2,r2,65535
81104d28:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));
81104d2c:	e0bfff17 	ldw	r2,-4(fp)
81104d30:	1080070b 	ldhu	r2,28(r2)
81104d34:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
81104d38:	e0fffe17 	ldw	r3,-8(fp)
81104d3c:	1884b03a 	or	r2,r3,r2
81104d40:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_3_REG_OFST,
81104d44:	e0bfff17 	ldw	r2,-4(fp)
81104d48:	10800017 	ldw	r2,0(r2)
81104d4c:	e1bffe17 	ldw	r6,-8(fp)
81104d50:	01400404 	movi	r5,16
81104d54:	1009883a 	mov	r4,r2
81104d58:	1104fb40 	call	81104fb4 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104d5c:	00800044 	movi	r2,1
81104d60:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104d64:	e0bffd17 	ldw	r2,-12(fp)
}
81104d68:	e037883a 	mov	sp,fp
81104d6c:	dfc00117 	ldw	ra,4(sp)
81104d70:	df000017 	ldw	fp,0(sp)
81104d74:	dec00204 	addi	sp,sp,8
81104d78:	f800283a 	ret

81104d7c <bDpktGetPixelDelay>:

bool bDpktGetPixelDelay(TDpktChannel *pxDpktCh) {
81104d7c:	defffb04 	addi	sp,sp,-20
81104d80:	de00012e 	bgeu	sp,et,81104d88 <bDpktGetPixelDelay+0xc>
81104d84:	003b68fa 	trap	3
81104d88:	dfc00415 	stw	ra,16(sp)
81104d8c:	df000315 	stw	fp,12(sp)
81104d90:	df000304 	addi	fp,sp,12
81104d94:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104d98:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104d9c:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104da0:	e0bfff17 	ldw	r2,-4(fp)
81104da4:	10002026 	beq	r2,zero,81104e28 <bDpktGetPixelDelay+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104da8:	e0bfff17 	ldw	r2,-4(fp)
81104dac:	10800017 	ldw	r2,0(r2)
81104db0:	01400384 	movi	r5,14
81104db4:	1009883a 	mov	r4,r2
81104db8:	11050080 	call	81105008 <uliDpktReadReg>
81104dbc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiLineDelay = (alt_u16)(
81104dc0:	e0bffe17 	ldw	r2,-8(fp)
81104dc4:	1007883a 	mov	r3,r2
81104dc8:	e0bfff17 	ldw	r2,-4(fp)
81104dcc:	10c0060d 	sth	r3,24(r2)
				(uliReg & COMM_DATA_PKT_LINE_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104dd0:	e0bfff17 	ldw	r2,-4(fp)
81104dd4:	10800017 	ldw	r2,0(r2)
81104dd8:	014003c4 	movi	r5,15
81104ddc:	1009883a 	mov	r4,r2
81104de0:	11050080 	call	81105008 <uliDpktReadReg>
81104de4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiColumnDelay = (alt_u16)(
81104de8:	e0bffe17 	ldw	r2,-8(fp)
81104dec:	1007883a 	mov	r3,r2
81104df0:	e0bfff17 	ldw	r2,-4(fp)
81104df4:	10c0068d 	sth	r3,26(r2)
				(uliReg & COMM_DATA_PKT_COLUMN_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104df8:	e0bfff17 	ldw	r2,-4(fp)
81104dfc:	10800017 	ldw	r2,0(r2)
81104e00:	01400404 	movi	r5,16
81104e04:	1009883a 	mov	r4,r2
81104e08:	11050080 	call	81105008 <uliDpktReadReg>
81104e0c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiAdcDelay = (alt_u16)(
81104e10:	e0bffe17 	ldw	r2,-8(fp)
81104e14:	1007883a 	mov	r3,r2
81104e18:	e0bfff17 	ldw	r2,-4(fp)
81104e1c:	10c0070d 	sth	r3,28(r2)
				(uliReg & COMM_DATA_PKT_ADC_DLY_MSK) >> 0);

		bStatus = TRUE;
81104e20:	00800044 	movi	r2,1
81104e24:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104e28:	e0bffd17 	ldw	r2,-12(fp)
}
81104e2c:	e037883a 	mov	sp,fp
81104e30:	dfc00117 	ldw	ra,4(sp)
81104e34:	df000017 	ldw	fp,0(sp)
81104e38:	dec00204 	addi	sp,sp,8
81104e3c:	f800283a 	ret

81104e40 <bDpktInitCh>:

bool bDpktInitCh(TDpktChannel *pxDpktCh, alt_u8 ucCommCh) {
81104e40:	defffb04 	addi	sp,sp,-20
81104e44:	de00012e 	bgeu	sp,et,81104e4c <bDpktInitCh+0xc>
81104e48:	003b68fa 	trap	3
81104e4c:	dfc00415 	stw	ra,16(sp)
81104e50:	df000315 	stw	fp,12(sp)
81104e54:	df000304 	addi	fp,sp,12
81104e58:	e13ffe15 	stw	r4,-8(fp)
81104e5c:	2805883a 	mov	r2,r5
81104e60:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81104e64:	e03ffd15 	stw	zero,-12(fp)

	if (pxDpktCh != NULL) {
81104e68:	e0bffe17 	ldw	r2,-8(fp)
81104e6c:	10004b26 	beq	r2,zero,81104f9c <bDpktInitCh+0x15c>
		bStatus = TRUE;
81104e70:	00800044 	movi	r2,1
81104e74:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81104e78:	e0bfff03 	ldbu	r2,-4(fp)
81104e7c:	10c00228 	cmpgeui	r3,r2,8
81104e80:	1800361e 	bne	r3,zero,81104f5c <bDpktInitCh+0x11c>
81104e84:	100690ba 	slli	r3,r2,2
81104e88:	00a04434 	movhi	r2,33040
81104e8c:	1093a704 	addi	r2,r2,20124
81104e90:	1885883a 	add	r2,r3,r2
81104e94:	10800017 	ldw	r2,0(r2)
81104e98:	1000683a 	jmp	r2
81104e9c:	81104ebc 	xorhi	r4,r16,16698
81104ea0:	81104ed0 	cmplti	r4,r16,16699
81104ea4:	81104ee4 	muli	r4,r16,16699
81104ea8:	81104ef8 	rdprs	r4,r16,16699
81104eac:	81104f0c 	andi	r4,r16,16700
81104eb0:	81104f20 	cmpeqi	r4,r16,16700
81104eb4:	81104f34 	orhi	r4,r16,16700
81104eb8:	81104f48 	cmpgei	r4,r16,16701
		case eCommSpwCh1:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81104ebc:	e0fffe17 	ldw	r3,-8(fp)
81104ec0:	00a04834 	movhi	r2,33056
81104ec4:	108b0004 	addi	r2,r2,11264
81104ec8:	18800015 	stw	r2,0(r3)
			break;
81104ecc:	00002506 	br	81104f64 <bDpktInitCh+0x124>
		case eCommSpwCh2:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104ed0:	e0fffe17 	ldw	r3,-8(fp)
81104ed4:	00a04834 	movhi	r2,33056
81104ed8:	108a0004 	addi	r2,r2,10240
81104edc:	18800015 	stw	r2,0(r3)
			break;
81104ee0:	00002006 	br	81104f64 <bDpktInitCh+0x124>
		case eCommSpwCh3:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81104ee4:	e0fffe17 	ldw	r3,-8(fp)
81104ee8:	00a04834 	movhi	r2,33056
81104eec:	108b0004 	addi	r2,r2,11264
81104ef0:	18800015 	stw	r2,0(r3)
			break;
81104ef4:	00001b06 	br	81104f64 <bDpktInitCh+0x124>
		case eCommSpwCh4:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104ef8:	e0fffe17 	ldw	r3,-8(fp)
81104efc:	00a04834 	movhi	r2,33056
81104f00:	108a0004 	addi	r2,r2,10240
81104f04:	18800015 	stw	r2,0(r3)
			break;
81104f08:	00001606 	br	81104f64 <bDpktInitCh+0x124>
		case eCommSpwCh5:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104f0c:	e0fffe17 	ldw	r3,-8(fp)
81104f10:	00a04834 	movhi	r2,33056
81104f14:	108b0004 	addi	r2,r2,11264
81104f18:	18800015 	stw	r2,0(r3)
			break;
81104f1c:	00001106 	br	81104f64 <bDpktInitCh+0x124>
		case eCommSpwCh6:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104f20:	e0fffe17 	ldw	r3,-8(fp)
81104f24:	00a04834 	movhi	r2,33056
81104f28:	108a0004 	addi	r2,r2,10240
81104f2c:	18800015 	stw	r2,0(r3)
			break;
81104f30:	00000c06 	br	81104f64 <bDpktInitCh+0x124>
		case eCommSpwCh7:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104f34:	e0fffe17 	ldw	r3,-8(fp)
81104f38:	00a04834 	movhi	r2,33056
81104f3c:	108b0004 	addi	r2,r2,11264
81104f40:	18800015 	stw	r2,0(r3)
			break;
81104f44:	00000706 	br	81104f64 <bDpktInitCh+0x124>
		case eCommSpwCh8:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104f48:	e0fffe17 	ldw	r3,-8(fp)
81104f4c:	00a04834 	movhi	r2,33056
81104f50:	108a0004 	addi	r2,r2,10240
81104f54:	18800015 	stw	r2,0(r3)
			break;
81104f58:	00000206 	br	81104f64 <bDpktInitCh+0x124>
		default:
			bStatus = FALSE;
81104f5c:	e03ffd15 	stw	zero,-12(fp)
			break;
81104f60:	0001883a 	nop
		}

		if (bStatus) {
81104f64:	e0bffd17 	ldw	r2,-12(fp)
81104f68:	10000c26 	beq	r2,zero,81104f9c <bDpktInitCh+0x15c>
			if (!bDpktGetPacketConfig(pxDpktCh)) {
81104f6c:	e13ffe17 	ldw	r4,-8(fp)
81104f70:	1104a440 	call	81104a44 <bDpktGetPacketConfig>
81104f74:	1000011e 	bne	r2,zero,81104f7c <bDpktInitCh+0x13c>
				bStatus = FALSE;
81104f78:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPacketHeader(pxDpktCh)) {
81104f7c:	e13ffe17 	ldw	r4,-8(fp)
81104f80:	1104b700 	call	81104b70 <bDpktGetPacketHeader>
81104f84:	1000011e 	bne	r2,zero,81104f8c <bDpktInitCh+0x14c>
				bStatus = FALSE;
81104f88:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPixelDelay(pxDpktCh)) {
81104f8c:	e13ffe17 	ldw	r4,-8(fp)
81104f90:	1104d7c0 	call	81104d7c <bDpktGetPixelDelay>
81104f94:	1000011e 	bne	r2,zero,81104f9c <bDpktInitCh+0x15c>
				bStatus = FALSE;
81104f98:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81104f9c:	e0bffd17 	ldw	r2,-12(fp)
}
81104fa0:	e037883a 	mov	sp,fp
81104fa4:	dfc00117 	ldw	ra,4(sp)
81104fa8:	df000017 	ldw	fp,0(sp)
81104fac:	dec00204 	addi	sp,sp,8
81104fb0:	f800283a 	ret

81104fb4 <vDpktWriteReg>:
//! [public functions]

//! [private functions]
static void vDpktWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104fb4:	defffc04 	addi	sp,sp,-16
81104fb8:	de00012e 	bgeu	sp,et,81104fc0 <vDpktWriteReg+0xc>
81104fbc:	003b68fa 	trap	3
81104fc0:	df000315 	stw	fp,12(sp)
81104fc4:	df000304 	addi	fp,sp,12
81104fc8:	e13ffd15 	stw	r4,-12(fp)
81104fcc:	e17ffe15 	stw	r5,-8(fp)
81104fd0:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104fd4:	e0bffe17 	ldw	r2,-8(fp)
81104fd8:	1085883a 	add	r2,r2,r2
81104fdc:	1085883a 	add	r2,r2,r2
81104fe0:	1007883a 	mov	r3,r2
81104fe4:	e0bffd17 	ldw	r2,-12(fp)
81104fe8:	10c5883a 	add	r2,r2,r3
81104fec:	e0ffff17 	ldw	r3,-4(fp)
81104ff0:	10c00015 	stw	r3,0(r2)
}
81104ff4:	0001883a 	nop
81104ff8:	e037883a 	mov	sp,fp
81104ffc:	df000017 	ldw	fp,0(sp)
81105000:	dec00104 	addi	sp,sp,4
81105004:	f800283a 	ret

81105008 <uliDpktReadReg>:

static alt_u32 uliDpktReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81105008:	defffc04 	addi	sp,sp,-16
8110500c:	de00012e 	bgeu	sp,et,81105014 <uliDpktReadReg+0xc>
81105010:	003b68fa 	trap	3
81105014:	df000315 	stw	fp,12(sp)
81105018:	df000304 	addi	fp,sp,12
8110501c:	e13ffe15 	stw	r4,-8(fp)
81105020:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81105024:	e0bfff17 	ldw	r2,-4(fp)
81105028:	1085883a 	add	r2,r2,r2
8110502c:	1085883a 	add	r2,r2,r2
81105030:	1007883a 	mov	r3,r2
81105034:	e0bffe17 	ldw	r2,-8(fp)
81105038:	10c5883a 	add	r2,r2,r3
8110503c:	10800017 	ldw	r2,0(r2)
81105040:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81105044:	e0bffd17 	ldw	r2,-12(fp)
}
81105048:	e037883a 	mov	sp,fp
8110504c:	df000017 	ldw	fp,0(sp)
81105050:	dec00104 	addi	sp,sp,4
81105054:	f800283a 	ret

81105058 <usiAdcPxDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * ADC Pixel Delay period in uliPeriodNs ns.
 */
alt_u16 usiAdcPxDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
81105058:	defffc04 	addi	sp,sp,-16
8110505c:	de00012e 	bgeu	sp,et,81105064 <usiAdcPxDelayCalcPeriodNs+0xc>
81105060:	003b68fa 	trap	3
81105064:	dfc00315 	stw	ra,12(sp)
81105068:	df000215 	stw	fp,8(sp)
8110506c:	df000204 	addi	fp,sp,8
81105070:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 10 = Delay[ns] * 1e-1
	 * AdcPxDelay = Delay[ns] * 1e-1
	 */

	alt_u16 usiAdcPxDelay;
	usiAdcPxDelay = (alt_u16) ((float) uliPeriodNs * 1e-1);
81105074:	e13fff17 	ldw	r4,-4(fp)
81105078:	111efdc0 	call	8111efdc <__floatunsisf>
8110507c:	1007883a 	mov	r3,r2
81105080:	1809883a 	mov	r4,r3
81105084:	11203380 	call	81120338 <__extendsfdf2>
81105088:	1011883a 	mov	r8,r2
8110508c:	1813883a 	mov	r9,r3
81105090:	01a666b4 	movhi	r6,39322
81105094:	31a66684 	addi	r6,r6,-26214
81105098:	01cfeeb4 	movhi	r7,16314
8110509c:	39e66644 	addi	r7,r7,-26215
811050a0:	4009883a 	mov	r4,r8
811050a4:	480b883a 	mov	r5,r9
811050a8:	111f1b00 	call	8111f1b0 <__muldf3>
811050ac:	1009883a 	mov	r4,r2
811050b0:	180b883a 	mov	r5,r3
811050b4:	2005883a 	mov	r2,r4
811050b8:	2807883a 	mov	r3,r5
811050bc:	1009883a 	mov	r4,r2
811050c0:	180b883a 	mov	r5,r3
811050c4:	111e5e80 	call	8111e5e8 <__fixunsdfsi>
811050c8:	e0bffe0d 	sth	r2,-8(fp)

	return usiAdcPxDelay;
811050cc:	e0bffe0b 	ldhu	r2,-8(fp)
}
811050d0:	e037883a 	mov	sp,fp
811050d4:	dfc00117 	ldw	ra,4(sp)
811050d8:	df000017 	ldw	fp,0(sp)
811050dc:	dec00204 	addi	sp,sp,8
811050e0:	f800283a 	ret

811050e4 <usiLineTrDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * Line Transfer Delay period in uliPeriodNs ns.
 */
alt_u16 usiLineTrDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
811050e4:	defffc04 	addi	sp,sp,-16
811050e8:	de00012e 	bgeu	sp,et,811050f0 <usiLineTrDelayCalcPeriodNs+0xc>
811050ec:	003b68fa 	trap	3
811050f0:	dfc00315 	stw	ra,12(sp)
811050f4:	df000215 	stw	fp,8(sp)
811050f8:	df000204 	addi	fp,sp,8
811050fc:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 100 = Delay[ns] * 1e-2
	 * LineTrDelay = Delay[ns] * 1e-2
	 */

	alt_u16 LineTrDelay;
	LineTrDelay = (alt_u16) ((float) uliPeriodNs * 1e-2);
81105100:	e13fff17 	ldw	r4,-4(fp)
81105104:	111efdc0 	call	8111efdc <__floatunsisf>
81105108:	1007883a 	mov	r3,r2
8110510c:	1809883a 	mov	r4,r3
81105110:	11203380 	call	81120338 <__extendsfdf2>
81105114:	1011883a 	mov	r8,r2
81105118:	1813883a 	mov	r9,r3
8110511c:	0191ebb4 	movhi	r6,18350
81105120:	31851ec4 	addi	r6,r6,5243
81105124:	01cfe134 	movhi	r7,16260
81105128:	39deb844 	addi	r7,r7,31457
8110512c:	4009883a 	mov	r4,r8
81105130:	480b883a 	mov	r5,r9
81105134:	111f1b00 	call	8111f1b0 <__muldf3>
81105138:	1009883a 	mov	r4,r2
8110513c:	180b883a 	mov	r5,r3
81105140:	2005883a 	mov	r2,r4
81105144:	2807883a 	mov	r3,r5
81105148:	1009883a 	mov	r4,r2
8110514c:	180b883a 	mov	r5,r3
81105150:	111e5e80 	call	8111e5e8 <__fixunsdfsi>
81105154:	e0bffe0d 	sth	r2,-8(fp)

	return LineTrDelay;
81105158:	e0bffe0b 	ldhu	r2,-8(fp)
}
8110515c:	e037883a 	mov	sp,fp
81105160:	dfc00117 	ldw	ra,4(sp)
81105164:	df000017 	ldw	fp,0(sp)
81105168:	dec00204 	addi	sp,sp,8
8110516c:	f800283a 	ret

81105170 <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81105170:	defffb04 	addi	sp,sp,-20
81105174:	de00012e 	bgeu	sp,et,8110517c <vFeebCh1HandleIrq+0xc>
81105178:	003b68fa 	trap	3
8110517c:	dfc00415 	stw	ra,16(sp)
81105180:	df000315 	stw	fp,12(sp)
81105184:	df000304 	addi	fp,sp,12
81105188:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110518c:	e0bfff17 	ldw	r2,-4(fp)
81105190:	e0bffd15 	stw	r2,-12(fp)
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	INT8U error_codel;
	tQMask uiCmdtoSend;

	vFeebCh1IrqFlagClrBufferEmpty();
81105194:	11054c40 	call	811054c4 <vFeebCh1IrqFlagClrBufferEmpty>
	/* Make one requests for the Double buffer */
	/* Address of the NFEE is hard coded */



}
81105198:	0001883a 	nop
8110519c:	e037883a 	mov	sp,fp
811051a0:	dfc00117 	ldw	ra,4(sp)
811051a4:	df000017 	ldw	fp,0(sp)
811051a8:	dec00204 	addi	sp,sp,8
811051ac:	f800283a 	ret

811051b0 <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
811051b0:	defffa04 	addi	sp,sp,-24
811051b4:	de00012e 	bgeu	sp,et,811051bc <vFeebCh2HandleIrq+0xc>
811051b8:	003b68fa 	trap	3
811051bc:	dfc00515 	stw	ra,20(sp)
811051c0:	df000415 	stw	fp,16(sp)
811051c4:	df000404 	addi	fp,sp,16
811051c8:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811051cc:	e0bfff17 	ldw	r2,-4(fp)
811051d0:	e0bffc15 	stw	r2,-16(fp)

	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811051d4:	00800404 	movi	r2,16
811051d8:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811051dc:	00bfe004 	movi	r2,-128
811051e0:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811051e4:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 1;
811051e8:	00800044 	movi	r2,1
811051ec:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811051f0:	d0a05c17 	ldw	r2,-32400(gp)
811051f4:	e0fffe17 	ldw	r3,-8(fp)
811051f8:	180b883a 	mov	r5,r3
811051fc:	1009883a 	mov	r4,r2
81105200:	113d1e40 	call	8113d1e4 <OSQPost>
81105204:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105208:	e0bffd03 	ldbu	r2,-12(fp)
8110520c:	10000226 	beq	r2,zero,81105218 <vFeebCh2HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 1 );
81105210:	01000044 	movi	r4,1
81105214:	111c6a80 	call	8111c6a8 <vFailRequestDMAFromIRQ>
	}

	vFeebCh2IrqFlagClrBufferEmpty();
81105218:	11055080 	call	81105508 <vFeebCh2IrqFlagClrBufferEmpty>
}
8110521c:	0001883a 	nop
81105220:	e037883a 	mov	sp,fp
81105224:	dfc00117 	ldw	ra,4(sp)
81105228:	df000017 	ldw	fp,0(sp)
8110522c:	dec00204 	addi	sp,sp,8
81105230:	f800283a 	ret

81105234 <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
81105234:	defffa04 	addi	sp,sp,-24
81105238:	de00012e 	bgeu	sp,et,81105240 <vFeebCh3HandleIrq+0xc>
8110523c:	003b68fa 	trap	3
81105240:	dfc00515 	stw	ra,20(sp)
81105244:	df000415 	stw	fp,16(sp)
81105248:	df000404 	addi	fp,sp,16
8110524c:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105250:	e0bfff17 	ldw	r2,-4(fp)
81105254:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105258:	00800404 	movi	r2,16
8110525c:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105260:	00bfe004 	movi	r2,-128
81105264:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105268:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 2;
8110526c:	00800084 	movi	r2,2
81105270:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105274:	d0a05c17 	ldw	r2,-32400(gp)
81105278:	e0fffe17 	ldw	r3,-8(fp)
8110527c:	180b883a 	mov	r5,r3
81105280:	1009883a 	mov	r4,r2
81105284:	113d1e40 	call	8113d1e4 <OSQPost>
81105288:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110528c:	e0bffd03 	ldbu	r2,-12(fp)
81105290:	10000226 	beq	r2,zero,8110529c <vFeebCh3HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 2 );
81105294:	01000084 	movi	r4,2
81105298:	111c6a80 	call	8111c6a8 <vFailRequestDMAFromIRQ>
	}

	vFeebCh3IrqFlagClrBufferEmpty();
8110529c:	110554c0 	call	8110554c <vFeebCh3IrqFlagClrBufferEmpty>
}
811052a0:	0001883a 	nop
811052a4:	e037883a 	mov	sp,fp
811052a8:	dfc00117 	ldw	ra,4(sp)
811052ac:	df000017 	ldw	fp,0(sp)
811052b0:	dec00204 	addi	sp,sp,8
811052b4:	f800283a 	ret

811052b8 <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
811052b8:	defffa04 	addi	sp,sp,-24
811052bc:	de00012e 	bgeu	sp,et,811052c4 <vFeebCh4HandleIrq+0xc>
811052c0:	003b68fa 	trap	3
811052c4:	dfc00515 	stw	ra,20(sp)
811052c8:	df000415 	stw	fp,16(sp)
811052cc:	df000404 	addi	fp,sp,16
811052d0:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811052d4:	e0bfff17 	ldw	r2,-4(fp)
811052d8:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811052dc:	00800404 	movi	r2,16
811052e0:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811052e4:	00bfe004 	movi	r2,-128
811052e8:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811052ec:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 3;
811052f0:	008000c4 	movi	r2,3
811052f4:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811052f8:	d0a05c17 	ldw	r2,-32400(gp)
811052fc:	e0fffe17 	ldw	r3,-8(fp)
81105300:	180b883a 	mov	r5,r3
81105304:	1009883a 	mov	r4,r2
81105308:	113d1e40 	call	8113d1e4 <OSQPost>
8110530c:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105310:	e0bffd03 	ldbu	r2,-12(fp)
81105314:	10000226 	beq	r2,zero,81105320 <vFeebCh4HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 3 );
81105318:	010000c4 	movi	r4,3
8110531c:	111c6a80 	call	8111c6a8 <vFailRequestDMAFromIRQ>
	}

	vFeebCh4IrqFlagClrBufferEmpty();
81105320:	11055900 	call	81105590 <vFeebCh4IrqFlagClrBufferEmpty>
}
81105324:	0001883a 	nop
81105328:	e037883a 	mov	sp,fp
8110532c:	dfc00117 	ldw	ra,4(sp)
81105330:	df000017 	ldw	fp,0(sp)
81105334:	dec00204 	addi	sp,sp,8
81105338:	f800283a 	ret

8110533c <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
8110533c:	defffa04 	addi	sp,sp,-24
81105340:	de00012e 	bgeu	sp,et,81105348 <vFeebCh5HandleIrq+0xc>
81105344:	003b68fa 	trap	3
81105348:	dfc00515 	stw	ra,20(sp)
8110534c:	df000415 	stw	fp,16(sp)
81105350:	df000404 	addi	fp,sp,16
81105354:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105358:	e0bfff17 	ldw	r2,-4(fp)
8110535c:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105360:	00800404 	movi	r2,16
81105364:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105368:	00bfe004 	movi	r2,-128
8110536c:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105370:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 4;
81105374:	00800104 	movi	r2,4
81105378:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
8110537c:	d0a05c17 	ldw	r2,-32400(gp)
81105380:	e0fffe17 	ldw	r3,-8(fp)
81105384:	180b883a 	mov	r5,r3
81105388:	1009883a 	mov	r4,r2
8110538c:	113d1e40 	call	8113d1e4 <OSQPost>
81105390:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105394:	e0bffd03 	ldbu	r2,-12(fp)
81105398:	10000226 	beq	r2,zero,811053a4 <vFeebCh5HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 4 );
8110539c:	01000104 	movi	r4,4
811053a0:	111c6a80 	call	8111c6a8 <vFailRequestDMAFromIRQ>
	}

	vFeebCh5IrqFlagClrBufferEmpty();
811053a4:	11055d40 	call	811055d4 <vFeebCh5IrqFlagClrBufferEmpty>
}
811053a8:	0001883a 	nop
811053ac:	e037883a 	mov	sp,fp
811053b0:	dfc00117 	ldw	ra,4(sp)
811053b4:	df000017 	ldw	fp,0(sp)
811053b8:	dec00204 	addi	sp,sp,8
811053bc:	f800283a 	ret

811053c0 <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
811053c0:	defffa04 	addi	sp,sp,-24
811053c4:	de00012e 	bgeu	sp,et,811053cc <vFeebCh6HandleIrq+0xc>
811053c8:	003b68fa 	trap	3
811053cc:	dfc00515 	stw	ra,20(sp)
811053d0:	df000415 	stw	fp,16(sp)
811053d4:	df000404 	addi	fp,sp,16
811053d8:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811053dc:	e0bfff17 	ldw	r2,-4(fp)
811053e0:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811053e4:	00800404 	movi	r2,16
811053e8:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811053ec:	00bfe004 	movi	r2,-128
811053f0:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811053f4:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 5;
811053f8:	00800144 	movi	r2,5
811053fc:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105400:	d0a05c17 	ldw	r2,-32400(gp)
81105404:	e0fffe17 	ldw	r3,-8(fp)
81105408:	180b883a 	mov	r5,r3
8110540c:	1009883a 	mov	r4,r2
81105410:	113d1e40 	call	8113d1e4 <OSQPost>
81105414:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105418:	e0bffd03 	ldbu	r2,-12(fp)
8110541c:	10000226 	beq	r2,zero,81105428 <vFeebCh6HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 5 );
81105420:	01000144 	movi	r4,5
81105424:	111c6a80 	call	8111c6a8 <vFailRequestDMAFromIRQ>
	}


	vFeebCh6IrqFlagClrBufferEmpty();
81105428:	11056180 	call	81105618 <vFeebCh6IrqFlagClrBufferEmpty>
}
8110542c:	0001883a 	nop
81105430:	e037883a 	mov	sp,fp
81105434:	dfc00117 	ldw	ra,4(sp)
81105438:	df000017 	ldw	fp,0(sp)
8110543c:	dec00204 	addi	sp,sp,8
81105440:	f800283a 	ret

81105444 <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
81105444:	defffc04 	addi	sp,sp,-16
81105448:	de00012e 	bgeu	sp,et,81105450 <vFeebCh7HandleIrq+0xc>
8110544c:	003b68fa 	trap	3
81105450:	dfc00315 	stw	ra,12(sp)
81105454:	df000215 	stw	fp,8(sp)
81105458:	df000204 	addi	fp,sp,8
8110545c:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105460:	e0bfff17 	ldw	r2,-4(fp)
81105464:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh7IrqFlagClrBufferEmpty();
81105468:	110565c0 	call	8110565c <vFeebCh7IrqFlagClrBufferEmpty>
}
8110546c:	0001883a 	nop
81105470:	e037883a 	mov	sp,fp
81105474:	dfc00117 	ldw	ra,4(sp)
81105478:	df000017 	ldw	fp,0(sp)
8110547c:	dec00204 	addi	sp,sp,8
81105480:	f800283a 	ret

81105484 <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
81105484:	defffc04 	addi	sp,sp,-16
81105488:	de00012e 	bgeu	sp,et,81105490 <vFeebCh8HandleIrq+0xc>
8110548c:	003b68fa 	trap	3
81105490:	dfc00315 	stw	ra,12(sp)
81105494:	df000215 	stw	fp,8(sp)
81105498:	df000204 	addi	fp,sp,8
8110549c:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811054a0:	e0bfff17 	ldw	r2,-4(fp)
811054a4:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh8IrqFlagClrBufferEmpty();
811054a8:	11056a00 	call	811056a0 <vFeebCh8IrqFlagClrBufferEmpty>
}
811054ac:	0001883a 	nop
811054b0:	e037883a 	mov	sp,fp
811054b4:	dfc00117 	ldw	ra,4(sp)
811054b8:	df000017 	ldw	fp,0(sp)
811054bc:	dec00204 	addi	sp,sp,8
811054c0:	f800283a 	ret

811054c4 <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
811054c4:	defffe04 	addi	sp,sp,-8
811054c8:	de00012e 	bgeu	sp,et,811054d0 <vFeebCh1IrqFlagClrBufferEmpty+0xc>
811054cc:	003b68fa 	trap	3
811054d0:	dfc00115 	stw	ra,4(sp)
811054d4:	df000015 	stw	fp,0(sp)
811054d8:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811054dc:	01804004 	movi	r6,256
811054e0:	014004c4 	movi	r5,19
811054e4:	01204834 	movhi	r4,33056
811054e8:	210b0004 	addi	r4,r4,11264
811054ec:	1106c900 	call	81106c90 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811054f0:	0001883a 	nop
811054f4:	e037883a 	mov	sp,fp
811054f8:	dfc00117 	ldw	ra,4(sp)
811054fc:	df000017 	ldw	fp,0(sp)
81105500:	dec00204 	addi	sp,sp,8
81105504:	f800283a 	ret

81105508 <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
81105508:	defffe04 	addi	sp,sp,-8
8110550c:	de00012e 	bgeu	sp,et,81105514 <vFeebCh2IrqFlagClrBufferEmpty+0xc>
81105510:	003b68fa 	trap	3
81105514:	dfc00115 	stw	ra,4(sp)
81105518:	df000015 	stw	fp,0(sp)
8110551c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105520:	01804004 	movi	r6,256
81105524:	014004c4 	movi	r5,19
81105528:	01204834 	movhi	r4,33056
8110552c:	210a0004 	addi	r4,r4,10240
81105530:	1106c900 	call	81106c90 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105534:	0001883a 	nop
81105538:	e037883a 	mov	sp,fp
8110553c:	dfc00117 	ldw	ra,4(sp)
81105540:	df000017 	ldw	fp,0(sp)
81105544:	dec00204 	addi	sp,sp,8
81105548:	f800283a 	ret

8110554c <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
8110554c:	defffe04 	addi	sp,sp,-8
81105550:	de00012e 	bgeu	sp,et,81105558 <vFeebCh3IrqFlagClrBufferEmpty+0xc>
81105554:	003b68fa 	trap	3
81105558:	dfc00115 	stw	ra,4(sp)
8110555c:	df000015 	stw	fp,0(sp)
81105560:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105564:	01804004 	movi	r6,256
81105568:	014004c4 	movi	r5,19
8110556c:	01204834 	movhi	r4,33056
81105570:	210b0004 	addi	r4,r4,11264
81105574:	1106c900 	call	81106c90 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105578:	0001883a 	nop
8110557c:	e037883a 	mov	sp,fp
81105580:	dfc00117 	ldw	ra,4(sp)
81105584:	df000017 	ldw	fp,0(sp)
81105588:	dec00204 	addi	sp,sp,8
8110558c:	f800283a 	ret

81105590 <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
81105590:	defffe04 	addi	sp,sp,-8
81105594:	de00012e 	bgeu	sp,et,8110559c <vFeebCh4IrqFlagClrBufferEmpty+0xc>
81105598:	003b68fa 	trap	3
8110559c:	dfc00115 	stw	ra,4(sp)
811055a0:	df000015 	stw	fp,0(sp)
811055a4:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811055a8:	01804004 	movi	r6,256
811055ac:	014004c4 	movi	r5,19
811055b0:	01204834 	movhi	r4,33056
811055b4:	210a0004 	addi	r4,r4,10240
811055b8:	1106c900 	call	81106c90 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811055bc:	0001883a 	nop
811055c0:	e037883a 	mov	sp,fp
811055c4:	dfc00117 	ldw	ra,4(sp)
811055c8:	df000017 	ldw	fp,0(sp)
811055cc:	dec00204 	addi	sp,sp,8
811055d0:	f800283a 	ret

811055d4 <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
811055d4:	defffe04 	addi	sp,sp,-8
811055d8:	de00012e 	bgeu	sp,et,811055e0 <vFeebCh5IrqFlagClrBufferEmpty+0xc>
811055dc:	003b68fa 	trap	3
811055e0:	dfc00115 	stw	ra,4(sp)
811055e4:	df000015 	stw	fp,0(sp)
811055e8:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811055ec:	01804004 	movi	r6,256
811055f0:	014004c4 	movi	r5,19
811055f4:	01204834 	movhi	r4,33056
811055f8:	210b0004 	addi	r4,r4,11264
811055fc:	1106c900 	call	81106c90 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105600:	0001883a 	nop
81105604:	e037883a 	mov	sp,fp
81105608:	dfc00117 	ldw	ra,4(sp)
8110560c:	df000017 	ldw	fp,0(sp)
81105610:	dec00204 	addi	sp,sp,8
81105614:	f800283a 	ret

81105618 <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
81105618:	defffe04 	addi	sp,sp,-8
8110561c:	de00012e 	bgeu	sp,et,81105624 <vFeebCh6IrqFlagClrBufferEmpty+0xc>
81105620:	003b68fa 	trap	3
81105624:	dfc00115 	stw	ra,4(sp)
81105628:	df000015 	stw	fp,0(sp)
8110562c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105630:	01804004 	movi	r6,256
81105634:	014004c4 	movi	r5,19
81105638:	01204834 	movhi	r4,33056
8110563c:	210a0004 	addi	r4,r4,10240
81105640:	1106c900 	call	81106c90 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105644:	0001883a 	nop
81105648:	e037883a 	mov	sp,fp
8110564c:	dfc00117 	ldw	ra,4(sp)
81105650:	df000017 	ldw	fp,0(sp)
81105654:	dec00204 	addi	sp,sp,8
81105658:	f800283a 	ret

8110565c <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
8110565c:	defffe04 	addi	sp,sp,-8
81105660:	de00012e 	bgeu	sp,et,81105668 <vFeebCh7IrqFlagClrBufferEmpty+0xc>
81105664:	003b68fa 	trap	3
81105668:	dfc00115 	stw	ra,4(sp)
8110566c:	df000015 	stw	fp,0(sp)
81105670:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105674:	01804004 	movi	r6,256
81105678:	014004c4 	movi	r5,19
8110567c:	01204834 	movhi	r4,33056
81105680:	210b0004 	addi	r4,r4,11264
81105684:	1106c900 	call	81106c90 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105688:	0001883a 	nop
8110568c:	e037883a 	mov	sp,fp
81105690:	dfc00117 	ldw	ra,4(sp)
81105694:	df000017 	ldw	fp,0(sp)
81105698:	dec00204 	addi	sp,sp,8
8110569c:	f800283a 	ret

811056a0 <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
811056a0:	defffe04 	addi	sp,sp,-8
811056a4:	de00012e 	bgeu	sp,et,811056ac <vFeebCh8IrqFlagClrBufferEmpty+0xc>
811056a8:	003b68fa 	trap	3
811056ac:	dfc00115 	stw	ra,4(sp)
811056b0:	df000015 	stw	fp,0(sp)
811056b4:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811056b8:	01804004 	movi	r6,256
811056bc:	014004c4 	movi	r5,19
811056c0:	01204834 	movhi	r4,33056
811056c4:	210a0004 	addi	r4,r4,10240
811056c8:	1106c900 	call	81106c90 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811056cc:	0001883a 	nop
811056d0:	e037883a 	mov	sp,fp
811056d4:	dfc00117 	ldw	ra,4(sp)
811056d8:	df000017 	ldw	fp,0(sp)
811056dc:	dec00204 	addi	sp,sp,8
811056e0:	f800283a 	ret

811056e4 <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
811056e4:	defffd04 	addi	sp,sp,-12
811056e8:	de00012e 	bgeu	sp,et,811056f0 <bFeebCh1IrqFlagBufferEmpty+0xc>
811056ec:	003b68fa 	trap	3
811056f0:	dfc00215 	stw	ra,8(sp)
811056f4:	df000115 	stw	fp,4(sp)
811056f8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811056fc:	01400484 	movi	r5,18
81105700:	01204834 	movhi	r4,33056
81105704:	210b0004 	addi	r4,r4,11264
81105708:	1106ce40 	call	81106ce4 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
8110570c:	1080400c 	andi	r2,r2,256
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105710:	10000326 	beq	r2,zero,81105720 <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105714:	00800044 	movi	r2,1
81105718:	e0bfff15 	stw	r2,-4(fp)
8110571c:	00000106 	br	81105724 <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105720:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105724:	e0bfff17 	ldw	r2,-4(fp)
}
81105728:	e037883a 	mov	sp,fp
8110572c:	dfc00117 	ldw	ra,4(sp)
81105730:	df000017 	ldw	fp,0(sp)
81105734:	dec00204 	addi	sp,sp,8
81105738:	f800283a 	ret

8110573c <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
8110573c:	defffd04 	addi	sp,sp,-12
81105740:	de00012e 	bgeu	sp,et,81105748 <bFeebCh2IrqFlagBufferEmpty+0xc>
81105744:	003b68fa 	trap	3
81105748:	dfc00215 	stw	ra,8(sp)
8110574c:	df000115 	stw	fp,4(sp)
81105750:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105754:	01400484 	movi	r5,18
81105758:	01204834 	movhi	r4,33056
8110575c:	210a0004 	addi	r4,r4,10240
81105760:	1106ce40 	call	81106ce4 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105764:	1080400c 	andi	r2,r2,256
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105768:	10000326 	beq	r2,zero,81105778 <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
8110576c:	00800044 	movi	r2,1
81105770:	e0bfff15 	stw	r2,-4(fp)
81105774:	00000106 	br	8110577c <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105778:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110577c:	e0bfff17 	ldw	r2,-4(fp)
}
81105780:	e037883a 	mov	sp,fp
81105784:	dfc00117 	ldw	ra,4(sp)
81105788:	df000017 	ldw	fp,0(sp)
8110578c:	dec00204 	addi	sp,sp,8
81105790:	f800283a 	ret

81105794 <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
81105794:	defffd04 	addi	sp,sp,-12
81105798:	de00012e 	bgeu	sp,et,811057a0 <bFeebCh3IrqFlagBufferEmpty+0xc>
8110579c:	003b68fa 	trap	3
811057a0:	dfc00215 	stw	ra,8(sp)
811057a4:	df000115 	stw	fp,4(sp)
811057a8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811057ac:	01400484 	movi	r5,18
811057b0:	01204834 	movhi	r4,33056
811057b4:	210b0004 	addi	r4,r4,11264
811057b8:	1106ce40 	call	81106ce4 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811057bc:	1080400c 	andi	r2,r2,256
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811057c0:	10000326 	beq	r2,zero,811057d0 <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811057c4:	00800044 	movi	r2,1
811057c8:	e0bfff15 	stw	r2,-4(fp)
811057cc:	00000106 	br	811057d4 <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811057d0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811057d4:	e0bfff17 	ldw	r2,-4(fp)
}
811057d8:	e037883a 	mov	sp,fp
811057dc:	dfc00117 	ldw	ra,4(sp)
811057e0:	df000017 	ldw	fp,0(sp)
811057e4:	dec00204 	addi	sp,sp,8
811057e8:	f800283a 	ret

811057ec <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
811057ec:	defffd04 	addi	sp,sp,-12
811057f0:	de00012e 	bgeu	sp,et,811057f8 <bFeebCh4IrqFlagBufferEmpty+0xc>
811057f4:	003b68fa 	trap	3
811057f8:	dfc00215 	stw	ra,8(sp)
811057fc:	df000115 	stw	fp,4(sp)
81105800:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105804:	01400484 	movi	r5,18
81105808:	01204834 	movhi	r4,33056
8110580c:	210a0004 	addi	r4,r4,10240
81105810:	1106ce40 	call	81106ce4 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105814:	1080400c 	andi	r2,r2,256
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105818:	10000326 	beq	r2,zero,81105828 <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
8110581c:	00800044 	movi	r2,1
81105820:	e0bfff15 	stw	r2,-4(fp)
81105824:	00000106 	br	8110582c <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105828:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110582c:	e0bfff17 	ldw	r2,-4(fp)
}
81105830:	e037883a 	mov	sp,fp
81105834:	dfc00117 	ldw	ra,4(sp)
81105838:	df000017 	ldw	fp,0(sp)
8110583c:	dec00204 	addi	sp,sp,8
81105840:	f800283a 	ret

81105844 <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
81105844:	defffd04 	addi	sp,sp,-12
81105848:	de00012e 	bgeu	sp,et,81105850 <bFeebCh5IrqFlagBufferEmpty+0xc>
8110584c:	003b68fa 	trap	3
81105850:	dfc00215 	stw	ra,8(sp)
81105854:	df000115 	stw	fp,4(sp)
81105858:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
8110585c:	01400484 	movi	r5,18
81105860:	01204834 	movhi	r4,33056
81105864:	210b0004 	addi	r4,r4,11264
81105868:	1106ce40 	call	81106ce4 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
8110586c:	1080400c 	andi	r2,r2,256
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105870:	10000326 	beq	r2,zero,81105880 <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105874:	00800044 	movi	r2,1
81105878:	e0bfff15 	stw	r2,-4(fp)
8110587c:	00000106 	br	81105884 <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105880:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105884:	e0bfff17 	ldw	r2,-4(fp)
}
81105888:	e037883a 	mov	sp,fp
8110588c:	dfc00117 	ldw	ra,4(sp)
81105890:	df000017 	ldw	fp,0(sp)
81105894:	dec00204 	addi	sp,sp,8
81105898:	f800283a 	ret

8110589c <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
8110589c:	defffd04 	addi	sp,sp,-12
811058a0:	de00012e 	bgeu	sp,et,811058a8 <bFeebCh6IrqFlagBufferEmpty+0xc>
811058a4:	003b68fa 	trap	3
811058a8:	dfc00215 	stw	ra,8(sp)
811058ac:	df000115 	stw	fp,4(sp)
811058b0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811058b4:	01400484 	movi	r5,18
811058b8:	01204834 	movhi	r4,33056
811058bc:	210a0004 	addi	r4,r4,10240
811058c0:	1106ce40 	call	81106ce4 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811058c4:	1080400c 	andi	r2,r2,256
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811058c8:	10000326 	beq	r2,zero,811058d8 <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811058cc:	00800044 	movi	r2,1
811058d0:	e0bfff15 	stw	r2,-4(fp)
811058d4:	00000106 	br	811058dc <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811058d8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811058dc:	e0bfff17 	ldw	r2,-4(fp)
}
811058e0:	e037883a 	mov	sp,fp
811058e4:	dfc00117 	ldw	ra,4(sp)
811058e8:	df000017 	ldw	fp,0(sp)
811058ec:	dec00204 	addi	sp,sp,8
811058f0:	f800283a 	ret

811058f4 <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
811058f4:	defffd04 	addi	sp,sp,-12
811058f8:	de00012e 	bgeu	sp,et,81105900 <bFeebCh7IrqFlagBufferEmpty+0xc>
811058fc:	003b68fa 	trap	3
81105900:	dfc00215 	stw	ra,8(sp)
81105904:	df000115 	stw	fp,4(sp)
81105908:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
8110590c:	01400484 	movi	r5,18
81105910:	01204834 	movhi	r4,33056
81105914:	210b0004 	addi	r4,r4,11264
81105918:	1106ce40 	call	81106ce4 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
8110591c:	1080400c 	andi	r2,r2,256
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105920:	10000326 	beq	r2,zero,81105930 <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105924:	00800044 	movi	r2,1
81105928:	e0bfff15 	stw	r2,-4(fp)
8110592c:	00000106 	br	81105934 <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105930:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105934:	e0bfff17 	ldw	r2,-4(fp)
}
81105938:	e037883a 	mov	sp,fp
8110593c:	dfc00117 	ldw	ra,4(sp)
81105940:	df000017 	ldw	fp,0(sp)
81105944:	dec00204 	addi	sp,sp,8
81105948:	f800283a 	ret

8110594c <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
8110594c:	defffd04 	addi	sp,sp,-12
81105950:	de00012e 	bgeu	sp,et,81105958 <bFeebCh8IrqFlagBufferEmpty+0xc>
81105954:	003b68fa 	trap	3
81105958:	dfc00215 	stw	ra,8(sp)
8110595c:	df000115 	stw	fp,4(sp)
81105960:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105964:	01400484 	movi	r5,18
81105968:	01204834 	movhi	r4,33056
8110596c:	210a0004 	addi	r4,r4,10240
81105970:	1106ce40 	call	81106ce4 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105974:	1080400c 	andi	r2,r2,256
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105978:	10000326 	beq	r2,zero,81105988 <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
8110597c:	00800044 	movi	r2,1
81105980:	e0bfff15 	stw	r2,-4(fp)
81105984:	00000106 	br	8110598c <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105988:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110598c:	e0bfff17 	ldw	r2,-4(fp)
}
81105990:	e037883a 	mov	sp,fp
81105994:	dfc00117 	ldw	ra,4(sp)
81105998:	df000017 	ldw	fp,0(sp)
8110599c:	dec00204 	addi	sp,sp,8
811059a0:	f800283a 	ret

811059a4 <bFeebCh1SetBufferSize>:

bool bFeebCh1SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
811059a4:	defffa04 	addi	sp,sp,-24
811059a8:	de00012e 	bgeu	sp,et,811059b0 <bFeebCh1SetBufferSize+0xc>
811059ac:	003b68fa 	trap	3
811059b0:	dfc00515 	stw	ra,20(sp)
811059b4:	df000415 	stw	fp,16(sp)
811059b8:	df000404 	addi	fp,sp,16
811059bc:	2007883a 	mov	r3,r4
811059c0:	2805883a 	mov	r2,r5
811059c4:	e0fffe05 	stb	r3,-8(fp)
811059c8:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811059cc:	00800044 	movi	r2,1
811059d0:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
811059d4:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
811059d8:	e0bffe03 	ldbu	r2,-8(fp)
811059dc:	10001f26 	beq	r2,zero,81105a5c <bFeebCh1SetBufferSize+0xb8>
811059e0:	e0bffe03 	ldbu	r2,-8(fp)
811059e4:	10800468 	cmpgeui	r2,r2,17
811059e8:	10001c1e 	bne	r2,zero,81105a5c <bFeebCh1SetBufferSize+0xb8>
		switch (ucBufferSide) {
811059ec:	e0bfff03 	ldbu	r2,-4(fp)
811059f0:	10000326 	beq	r2,zero,81105a00 <bFeebCh1SetBufferSize+0x5c>
811059f4:	10800060 	cmpeqi	r2,r2,1
811059f8:	10000b1e 	bne	r2,zero,81105a28 <bFeebCh1SetBufferSize+0x84>
811059fc:	00001406 	br	81105a50 <bFeebCh1SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105a00:	e0bffe03 	ldbu	r2,-8(fp)
81105a04:	10bfffc4 	addi	r2,r2,-1
81105a08:	108003cc 	andi	r2,r2,15
81105a0c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105a10:	e1bffd17 	ldw	r6,-12(fp)
81105a14:	01400544 	movi	r5,21
81105a18:	01204834 	movhi	r4,33056
81105a1c:	210b0004 	addi	r4,r4,11264
81105a20:	1106c900 	call	81106c90 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105a24:	00000c06 	br	81105a58 <bFeebCh1SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105a28:	e0bffe03 	ldbu	r2,-8(fp)
81105a2c:	10bfffc4 	addi	r2,r2,-1
81105a30:	108003cc 	andi	r2,r2,15
81105a34:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105a38:	e1bffd17 	ldw	r6,-12(fp)
81105a3c:	01400504 	movi	r5,20
81105a40:	01204834 	movhi	r4,33056
81105a44:	210b0004 	addi	r4,r4,11264
81105a48:	1106c900 	call	81106c90 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105a4c:	00000206 	br	81105a58 <bFeebCh1SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105a50:	e03ffc15 	stw	zero,-16(fp)
			break;
81105a54:	0001883a 	nop
		}
	} else {
81105a58:	00000106 	br	81105a60 <bFeebCh1SetBufferSize+0xbc>
		bStatus = FALSE;
81105a5c:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105a60:	e0bffc17 	ldw	r2,-16(fp)
}
81105a64:	e037883a 	mov	sp,fp
81105a68:	dfc00117 	ldw	ra,4(sp)
81105a6c:	df000017 	ldw	fp,0(sp)
81105a70:	dec00204 	addi	sp,sp,8
81105a74:	f800283a 	ret

81105a78 <bFeebCh2SetBufferSize>:

bool bFeebCh2SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105a78:	defffa04 	addi	sp,sp,-24
81105a7c:	de00012e 	bgeu	sp,et,81105a84 <bFeebCh2SetBufferSize+0xc>
81105a80:	003b68fa 	trap	3
81105a84:	dfc00515 	stw	ra,20(sp)
81105a88:	df000415 	stw	fp,16(sp)
81105a8c:	df000404 	addi	fp,sp,16
81105a90:	2007883a 	mov	r3,r4
81105a94:	2805883a 	mov	r2,r5
81105a98:	e0fffe05 	stb	r3,-8(fp)
81105a9c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105aa0:	00800044 	movi	r2,1
81105aa4:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105aa8:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105aac:	e0bffe03 	ldbu	r2,-8(fp)
81105ab0:	10001f26 	beq	r2,zero,81105b30 <bFeebCh2SetBufferSize+0xb8>
81105ab4:	e0bffe03 	ldbu	r2,-8(fp)
81105ab8:	10800468 	cmpgeui	r2,r2,17
81105abc:	10001c1e 	bne	r2,zero,81105b30 <bFeebCh2SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105ac0:	e0bfff03 	ldbu	r2,-4(fp)
81105ac4:	10000326 	beq	r2,zero,81105ad4 <bFeebCh2SetBufferSize+0x5c>
81105ac8:	10800060 	cmpeqi	r2,r2,1
81105acc:	10000b1e 	bne	r2,zero,81105afc <bFeebCh2SetBufferSize+0x84>
81105ad0:	00001406 	br	81105b24 <bFeebCh2SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ad4:	e0bffe03 	ldbu	r2,-8(fp)
81105ad8:	10bfffc4 	addi	r2,r2,-1
81105adc:	108003cc 	andi	r2,r2,15
81105ae0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105ae4:	e1bffd17 	ldw	r6,-12(fp)
81105ae8:	01400544 	movi	r5,21
81105aec:	01204834 	movhi	r4,33056
81105af0:	210a0004 	addi	r4,r4,10240
81105af4:	1106c900 	call	81106c90 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105af8:	00000c06 	br	81105b2c <bFeebCh2SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105afc:	e0bffe03 	ldbu	r2,-8(fp)
81105b00:	10bfffc4 	addi	r2,r2,-1
81105b04:	108003cc 	andi	r2,r2,15
81105b08:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105b0c:	e1bffd17 	ldw	r6,-12(fp)
81105b10:	01400504 	movi	r5,20
81105b14:	01204834 	movhi	r4,33056
81105b18:	210a0004 	addi	r4,r4,10240
81105b1c:	1106c900 	call	81106c90 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105b20:	00000206 	br	81105b2c <bFeebCh2SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105b24:	e03ffc15 	stw	zero,-16(fp)
			break;
81105b28:	0001883a 	nop
		}
	} else {
81105b2c:	00000106 	br	81105b34 <bFeebCh2SetBufferSize+0xbc>
		bStatus = FALSE;
81105b30:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105b34:	e0bffc17 	ldw	r2,-16(fp)
}
81105b38:	e037883a 	mov	sp,fp
81105b3c:	dfc00117 	ldw	ra,4(sp)
81105b40:	df000017 	ldw	fp,0(sp)
81105b44:	dec00204 	addi	sp,sp,8
81105b48:	f800283a 	ret

81105b4c <bFeebCh3SetBufferSize>:

bool bFeebCh3SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105b4c:	defffa04 	addi	sp,sp,-24
81105b50:	de00012e 	bgeu	sp,et,81105b58 <bFeebCh3SetBufferSize+0xc>
81105b54:	003b68fa 	trap	3
81105b58:	dfc00515 	stw	ra,20(sp)
81105b5c:	df000415 	stw	fp,16(sp)
81105b60:	df000404 	addi	fp,sp,16
81105b64:	2007883a 	mov	r3,r4
81105b68:	2805883a 	mov	r2,r5
81105b6c:	e0fffe05 	stb	r3,-8(fp)
81105b70:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105b74:	00800044 	movi	r2,1
81105b78:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105b7c:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105b80:	e0bffe03 	ldbu	r2,-8(fp)
81105b84:	10001f26 	beq	r2,zero,81105c04 <bFeebCh3SetBufferSize+0xb8>
81105b88:	e0bffe03 	ldbu	r2,-8(fp)
81105b8c:	10800468 	cmpgeui	r2,r2,17
81105b90:	10001c1e 	bne	r2,zero,81105c04 <bFeebCh3SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105b94:	e0bfff03 	ldbu	r2,-4(fp)
81105b98:	10000326 	beq	r2,zero,81105ba8 <bFeebCh3SetBufferSize+0x5c>
81105b9c:	10800060 	cmpeqi	r2,r2,1
81105ba0:	10000b1e 	bne	r2,zero,81105bd0 <bFeebCh3SetBufferSize+0x84>
81105ba4:	00001406 	br	81105bf8 <bFeebCh3SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ba8:	e0bffe03 	ldbu	r2,-8(fp)
81105bac:	10bfffc4 	addi	r2,r2,-1
81105bb0:	108003cc 	andi	r2,r2,15
81105bb4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105bb8:	e1bffd17 	ldw	r6,-12(fp)
81105bbc:	01400544 	movi	r5,21
81105bc0:	01204834 	movhi	r4,33056
81105bc4:	210b0004 	addi	r4,r4,11264
81105bc8:	1106c900 	call	81106c90 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105bcc:	00000c06 	br	81105c00 <bFeebCh3SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105bd0:	e0bffe03 	ldbu	r2,-8(fp)
81105bd4:	10bfffc4 	addi	r2,r2,-1
81105bd8:	108003cc 	andi	r2,r2,15
81105bdc:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105be0:	e1bffd17 	ldw	r6,-12(fp)
81105be4:	01400504 	movi	r5,20
81105be8:	01204834 	movhi	r4,33056
81105bec:	210b0004 	addi	r4,r4,11264
81105bf0:	1106c900 	call	81106c90 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105bf4:	00000206 	br	81105c00 <bFeebCh3SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105bf8:	e03ffc15 	stw	zero,-16(fp)
			break;
81105bfc:	0001883a 	nop
		}
	} else {
81105c00:	00000106 	br	81105c08 <bFeebCh3SetBufferSize+0xbc>
		bStatus = FALSE;
81105c04:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105c08:	e0bffc17 	ldw	r2,-16(fp)
}
81105c0c:	e037883a 	mov	sp,fp
81105c10:	dfc00117 	ldw	ra,4(sp)
81105c14:	df000017 	ldw	fp,0(sp)
81105c18:	dec00204 	addi	sp,sp,8
81105c1c:	f800283a 	ret

81105c20 <bFeebCh4SetBufferSize>:

bool bFeebCh4SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105c20:	defffa04 	addi	sp,sp,-24
81105c24:	de00012e 	bgeu	sp,et,81105c2c <bFeebCh4SetBufferSize+0xc>
81105c28:	003b68fa 	trap	3
81105c2c:	dfc00515 	stw	ra,20(sp)
81105c30:	df000415 	stw	fp,16(sp)
81105c34:	df000404 	addi	fp,sp,16
81105c38:	2007883a 	mov	r3,r4
81105c3c:	2805883a 	mov	r2,r5
81105c40:	e0fffe05 	stb	r3,-8(fp)
81105c44:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105c48:	00800044 	movi	r2,1
81105c4c:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105c50:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105c54:	e0bffe03 	ldbu	r2,-8(fp)
81105c58:	10001f26 	beq	r2,zero,81105cd8 <bFeebCh4SetBufferSize+0xb8>
81105c5c:	e0bffe03 	ldbu	r2,-8(fp)
81105c60:	10800468 	cmpgeui	r2,r2,17
81105c64:	10001c1e 	bne	r2,zero,81105cd8 <bFeebCh4SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105c68:	e0bfff03 	ldbu	r2,-4(fp)
81105c6c:	10000326 	beq	r2,zero,81105c7c <bFeebCh4SetBufferSize+0x5c>
81105c70:	10800060 	cmpeqi	r2,r2,1
81105c74:	10000b1e 	bne	r2,zero,81105ca4 <bFeebCh4SetBufferSize+0x84>
81105c78:	00001406 	br	81105ccc <bFeebCh4SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105c7c:	e0bffe03 	ldbu	r2,-8(fp)
81105c80:	10bfffc4 	addi	r2,r2,-1
81105c84:	108003cc 	andi	r2,r2,15
81105c88:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105c8c:	e1bffd17 	ldw	r6,-12(fp)
81105c90:	01400544 	movi	r5,21
81105c94:	01204834 	movhi	r4,33056
81105c98:	210a0004 	addi	r4,r4,10240
81105c9c:	1106c900 	call	81106c90 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105ca0:	00000c06 	br	81105cd4 <bFeebCh4SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ca4:	e0bffe03 	ldbu	r2,-8(fp)
81105ca8:	10bfffc4 	addi	r2,r2,-1
81105cac:	108003cc 	andi	r2,r2,15
81105cb0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105cb4:	e1bffd17 	ldw	r6,-12(fp)
81105cb8:	01400504 	movi	r5,20
81105cbc:	01204834 	movhi	r4,33056
81105cc0:	210a0004 	addi	r4,r4,10240
81105cc4:	1106c900 	call	81106c90 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105cc8:	00000206 	br	81105cd4 <bFeebCh4SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105ccc:	e03ffc15 	stw	zero,-16(fp)
			break;
81105cd0:	0001883a 	nop
		}
	} else {
81105cd4:	00000106 	br	81105cdc <bFeebCh4SetBufferSize+0xbc>
		bStatus = FALSE;
81105cd8:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105cdc:	e0bffc17 	ldw	r2,-16(fp)
}
81105ce0:	e037883a 	mov	sp,fp
81105ce4:	dfc00117 	ldw	ra,4(sp)
81105ce8:	df000017 	ldw	fp,0(sp)
81105cec:	dec00204 	addi	sp,sp,8
81105cf0:	f800283a 	ret

81105cf4 <bFeebCh5SetBufferSize>:

bool bFeebCh5SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105cf4:	defffa04 	addi	sp,sp,-24
81105cf8:	de00012e 	bgeu	sp,et,81105d00 <bFeebCh5SetBufferSize+0xc>
81105cfc:	003b68fa 	trap	3
81105d00:	dfc00515 	stw	ra,20(sp)
81105d04:	df000415 	stw	fp,16(sp)
81105d08:	df000404 	addi	fp,sp,16
81105d0c:	2007883a 	mov	r3,r4
81105d10:	2805883a 	mov	r2,r5
81105d14:	e0fffe05 	stb	r3,-8(fp)
81105d18:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105d1c:	00800044 	movi	r2,1
81105d20:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105d24:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105d28:	e0bffe03 	ldbu	r2,-8(fp)
81105d2c:	10001f26 	beq	r2,zero,81105dac <bFeebCh5SetBufferSize+0xb8>
81105d30:	e0bffe03 	ldbu	r2,-8(fp)
81105d34:	10800468 	cmpgeui	r2,r2,17
81105d38:	10001c1e 	bne	r2,zero,81105dac <bFeebCh5SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105d3c:	e0bfff03 	ldbu	r2,-4(fp)
81105d40:	10000326 	beq	r2,zero,81105d50 <bFeebCh5SetBufferSize+0x5c>
81105d44:	10800060 	cmpeqi	r2,r2,1
81105d48:	10000b1e 	bne	r2,zero,81105d78 <bFeebCh5SetBufferSize+0x84>
81105d4c:	00001406 	br	81105da0 <bFeebCh5SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105d50:	e0bffe03 	ldbu	r2,-8(fp)
81105d54:	10bfffc4 	addi	r2,r2,-1
81105d58:	108003cc 	andi	r2,r2,15
81105d5c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105d60:	e1bffd17 	ldw	r6,-12(fp)
81105d64:	01400544 	movi	r5,21
81105d68:	01204834 	movhi	r4,33056
81105d6c:	210b0004 	addi	r4,r4,11264
81105d70:	1106c900 	call	81106c90 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105d74:	00000c06 	br	81105da8 <bFeebCh5SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105d78:	e0bffe03 	ldbu	r2,-8(fp)
81105d7c:	10bfffc4 	addi	r2,r2,-1
81105d80:	108003cc 	andi	r2,r2,15
81105d84:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105d88:	e1bffd17 	ldw	r6,-12(fp)
81105d8c:	01400504 	movi	r5,20
81105d90:	01204834 	movhi	r4,33056
81105d94:	210b0004 	addi	r4,r4,11264
81105d98:	1106c900 	call	81106c90 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105d9c:	00000206 	br	81105da8 <bFeebCh5SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105da0:	e03ffc15 	stw	zero,-16(fp)
			break;
81105da4:	0001883a 	nop
		}
	} else {
81105da8:	00000106 	br	81105db0 <bFeebCh5SetBufferSize+0xbc>
		bStatus = FALSE;
81105dac:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105db0:	e0bffc17 	ldw	r2,-16(fp)
}
81105db4:	e037883a 	mov	sp,fp
81105db8:	dfc00117 	ldw	ra,4(sp)
81105dbc:	df000017 	ldw	fp,0(sp)
81105dc0:	dec00204 	addi	sp,sp,8
81105dc4:	f800283a 	ret

81105dc8 <bFeebCh6SetBufferSize>:

bool bFeebCh6SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105dc8:	defffa04 	addi	sp,sp,-24
81105dcc:	de00012e 	bgeu	sp,et,81105dd4 <bFeebCh6SetBufferSize+0xc>
81105dd0:	003b68fa 	trap	3
81105dd4:	dfc00515 	stw	ra,20(sp)
81105dd8:	df000415 	stw	fp,16(sp)
81105ddc:	df000404 	addi	fp,sp,16
81105de0:	2007883a 	mov	r3,r4
81105de4:	2805883a 	mov	r2,r5
81105de8:	e0fffe05 	stb	r3,-8(fp)
81105dec:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105df0:	00800044 	movi	r2,1
81105df4:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105df8:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105dfc:	e0bffe03 	ldbu	r2,-8(fp)
81105e00:	10001f26 	beq	r2,zero,81105e80 <bFeebCh6SetBufferSize+0xb8>
81105e04:	e0bffe03 	ldbu	r2,-8(fp)
81105e08:	10800468 	cmpgeui	r2,r2,17
81105e0c:	10001c1e 	bne	r2,zero,81105e80 <bFeebCh6SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105e10:	e0bfff03 	ldbu	r2,-4(fp)
81105e14:	10000326 	beq	r2,zero,81105e24 <bFeebCh6SetBufferSize+0x5c>
81105e18:	10800060 	cmpeqi	r2,r2,1
81105e1c:	10000b1e 	bne	r2,zero,81105e4c <bFeebCh6SetBufferSize+0x84>
81105e20:	00001406 	br	81105e74 <bFeebCh6SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105e24:	e0bffe03 	ldbu	r2,-8(fp)
81105e28:	10bfffc4 	addi	r2,r2,-1
81105e2c:	108003cc 	andi	r2,r2,15
81105e30:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105e34:	e1bffd17 	ldw	r6,-12(fp)
81105e38:	01400544 	movi	r5,21
81105e3c:	01204834 	movhi	r4,33056
81105e40:	210a0004 	addi	r4,r4,10240
81105e44:	1106c900 	call	81106c90 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105e48:	00000c06 	br	81105e7c <bFeebCh6SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105e4c:	e0bffe03 	ldbu	r2,-8(fp)
81105e50:	10bfffc4 	addi	r2,r2,-1
81105e54:	108003cc 	andi	r2,r2,15
81105e58:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105e5c:	e1bffd17 	ldw	r6,-12(fp)
81105e60:	01400504 	movi	r5,20
81105e64:	01204834 	movhi	r4,33056
81105e68:	210a0004 	addi	r4,r4,10240
81105e6c:	1106c900 	call	81106c90 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105e70:	00000206 	br	81105e7c <bFeebCh6SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105e74:	e03ffc15 	stw	zero,-16(fp)
			break;
81105e78:	0001883a 	nop
		}
	} else {
81105e7c:	00000106 	br	81105e84 <bFeebCh6SetBufferSize+0xbc>
		bStatus = FALSE;
81105e80:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105e84:	e0bffc17 	ldw	r2,-16(fp)
}
81105e88:	e037883a 	mov	sp,fp
81105e8c:	dfc00117 	ldw	ra,4(sp)
81105e90:	df000017 	ldw	fp,0(sp)
81105e94:	dec00204 	addi	sp,sp,8
81105e98:	f800283a 	ret

81105e9c <bFeebCh7SetBufferSize>:

bool bFeebCh7SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105e9c:	defffa04 	addi	sp,sp,-24
81105ea0:	de00012e 	bgeu	sp,et,81105ea8 <bFeebCh7SetBufferSize+0xc>
81105ea4:	003b68fa 	trap	3
81105ea8:	dfc00515 	stw	ra,20(sp)
81105eac:	df000415 	stw	fp,16(sp)
81105eb0:	df000404 	addi	fp,sp,16
81105eb4:	2007883a 	mov	r3,r4
81105eb8:	2805883a 	mov	r2,r5
81105ebc:	e0fffe05 	stb	r3,-8(fp)
81105ec0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105ec4:	00800044 	movi	r2,1
81105ec8:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105ecc:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105ed0:	e0bffe03 	ldbu	r2,-8(fp)
81105ed4:	10001f26 	beq	r2,zero,81105f54 <bFeebCh7SetBufferSize+0xb8>
81105ed8:	e0bffe03 	ldbu	r2,-8(fp)
81105edc:	10800468 	cmpgeui	r2,r2,17
81105ee0:	10001c1e 	bne	r2,zero,81105f54 <bFeebCh7SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105ee4:	e0bfff03 	ldbu	r2,-4(fp)
81105ee8:	10000326 	beq	r2,zero,81105ef8 <bFeebCh7SetBufferSize+0x5c>
81105eec:	10800060 	cmpeqi	r2,r2,1
81105ef0:	10000b1e 	bne	r2,zero,81105f20 <bFeebCh7SetBufferSize+0x84>
81105ef4:	00001406 	br	81105f48 <bFeebCh7SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ef8:	e0bffe03 	ldbu	r2,-8(fp)
81105efc:	10bfffc4 	addi	r2,r2,-1
81105f00:	108003cc 	andi	r2,r2,15
81105f04:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105f08:	e1bffd17 	ldw	r6,-12(fp)
81105f0c:	01400544 	movi	r5,21
81105f10:	01204834 	movhi	r4,33056
81105f14:	210b0004 	addi	r4,r4,11264
81105f18:	1106c900 	call	81106c90 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105f1c:	00000c06 	br	81105f50 <bFeebCh7SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105f20:	e0bffe03 	ldbu	r2,-8(fp)
81105f24:	10bfffc4 	addi	r2,r2,-1
81105f28:	108003cc 	andi	r2,r2,15
81105f2c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105f30:	e1bffd17 	ldw	r6,-12(fp)
81105f34:	01400504 	movi	r5,20
81105f38:	01204834 	movhi	r4,33056
81105f3c:	210b0004 	addi	r4,r4,11264
81105f40:	1106c900 	call	81106c90 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105f44:	00000206 	br	81105f50 <bFeebCh7SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105f48:	e03ffc15 	stw	zero,-16(fp)
			break;
81105f4c:	0001883a 	nop
		}
	} else {
81105f50:	00000106 	br	81105f58 <bFeebCh7SetBufferSize+0xbc>
		bStatus = FALSE;
81105f54:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105f58:	e0bffc17 	ldw	r2,-16(fp)
}
81105f5c:	e037883a 	mov	sp,fp
81105f60:	dfc00117 	ldw	ra,4(sp)
81105f64:	df000017 	ldw	fp,0(sp)
81105f68:	dec00204 	addi	sp,sp,8
81105f6c:	f800283a 	ret

81105f70 <bFeebCh8SetBufferSize>:

bool bFeebCh8SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105f70:	defffa04 	addi	sp,sp,-24
81105f74:	de00012e 	bgeu	sp,et,81105f7c <bFeebCh8SetBufferSize+0xc>
81105f78:	003b68fa 	trap	3
81105f7c:	dfc00515 	stw	ra,20(sp)
81105f80:	df000415 	stw	fp,16(sp)
81105f84:	df000404 	addi	fp,sp,16
81105f88:	2007883a 	mov	r3,r4
81105f8c:	2805883a 	mov	r2,r5
81105f90:	e0fffe05 	stb	r3,-8(fp)
81105f94:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105f98:	00800044 	movi	r2,1
81105f9c:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105fa0:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105fa4:	e0bffe03 	ldbu	r2,-8(fp)
81105fa8:	10001f26 	beq	r2,zero,81106028 <bFeebCh8SetBufferSize+0xb8>
81105fac:	e0bffe03 	ldbu	r2,-8(fp)
81105fb0:	10800468 	cmpgeui	r2,r2,17
81105fb4:	10001c1e 	bne	r2,zero,81106028 <bFeebCh8SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105fb8:	e0bfff03 	ldbu	r2,-4(fp)
81105fbc:	10000326 	beq	r2,zero,81105fcc <bFeebCh8SetBufferSize+0x5c>
81105fc0:	10800060 	cmpeqi	r2,r2,1
81105fc4:	10000b1e 	bne	r2,zero,81105ff4 <bFeebCh8SetBufferSize+0x84>
81105fc8:	00001406 	br	8110601c <bFeebCh8SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105fcc:	e0bffe03 	ldbu	r2,-8(fp)
81105fd0:	10bfffc4 	addi	r2,r2,-1
81105fd4:	108003cc 	andi	r2,r2,15
81105fd8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105fdc:	e1bffd17 	ldw	r6,-12(fp)
81105fe0:	01400544 	movi	r5,21
81105fe4:	01204834 	movhi	r4,33056
81105fe8:	210a0004 	addi	r4,r4,10240
81105fec:	1106c900 	call	81106c90 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105ff0:	00000c06 	br	81106024 <bFeebCh8SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ff4:	e0bffe03 	ldbu	r2,-8(fp)
81105ff8:	10bfffc4 	addi	r2,r2,-1
81105ffc:	108003cc 	andi	r2,r2,15
81106000:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81106004:	e1bffd17 	ldw	r6,-12(fp)
81106008:	01400504 	movi	r5,20
8110600c:	01204834 	movhi	r4,33056
81106010:	210a0004 	addi	r4,r4,10240
81106014:	1106c900 	call	81106c90 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81106018:	00000206 	br	81106024 <bFeebCh8SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
8110601c:	e03ffc15 	stw	zero,-16(fp)
			break;
81106020:	0001883a 	nop
		}
	} else {
81106024:	00000106 	br	8110602c <bFeebCh8SetBufferSize+0xbc>
		bStatus = FALSE;
81106028:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
8110602c:	e0bffc17 	ldw	r2,-16(fp)
}
81106030:	e037883a 	mov	sp,fp
81106034:	dfc00117 	ldw	ra,4(sp)
81106038:	df000017 	ldw	fp,0(sp)
8110603c:	dec00204 	addi	sp,sp,8
81106040:	f800283a 	ret

81106044 <vFeebInitIrq>:

void vFeebInitIrq(alt_u8 ucCommCh) {
81106044:	defffc04 	addi	sp,sp,-16
81106048:	de00012e 	bgeu	sp,et,81106050 <vFeebInitIrq+0xc>
8110604c:	003b68fa 	trap	3
81106050:	dfc00315 	stw	ra,12(sp)
81106054:	df000215 	stw	fp,8(sp)
81106058:	df000204 	addi	fp,sp,8
8110605c:	2005883a 	mov	r2,r4
81106060:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81106064:	e0bfff03 	ldbu	r2,-4(fp)
81106068:	10c00228 	cmpgeui	r3,r2,8
8110606c:	18004e1e 	bne	r3,zero,811061a8 <vFeebInitIrq+0x164>
81106070:	100690ba 	slli	r3,r2,2
81106074:	00a04434 	movhi	r2,33040
81106078:	10982204 	addi	r2,r2,24712
8110607c:	1885883a 	add	r2,r3,r2
81106080:	10800017 	ldw	r2,0(r2)
81106084:	1000683a 	jmp	r2
81106088:	811060a8 	cmpgeui	r4,r16,16770
8110608c:	811060c8 	cmpgei	r4,r16,16771
81106090:	811060e8 	cmpgeui	r4,r16,16771
81106094:	81106108 	cmpgei	r4,r16,16772
81106098:	81106128 	cmpgeui	r4,r16,16772
8110609c:	81106148 	cmpgei	r4,r16,16773
811060a0:	81106168 	cmpgeui	r4,r16,16773
811060a4:	81106188 	cmpgei	r4,r16,16774
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
811060a8:	d0a04004 	addi	r2,gp,-32512
811060ac:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_BUFFERS_IRQ, pvHoldContext,
811060b0:	01a04434 	movhi	r6,33040
811060b4:	31945c04 	addi	r6,r6,20848
811060b8:	e17ffe17 	ldw	r5,-8(fp)
811060bc:	01000584 	movi	r4,22
811060c0:	11358000 	call	81135800 <alt_irq_register>
				vFeebCh1HandleIrq);
		break;
811060c4:	00003806 	br	811061a8 <vFeebInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
811060c8:	d0a04104 	addi	r2,gp,-32508
811060cc:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_BUFFERS_IRQ, pvHoldContext,
811060d0:	01a04434 	movhi	r6,33040
811060d4:	31946c04 	addi	r6,r6,20912
811060d8:	e17ffe17 	ldw	r5,-8(fp)
811060dc:	01000504 	movi	r4,20
811060e0:	11358000 	call	81135800 <alt_irq_register>
				vFeebCh2HandleIrq);
		break;
811060e4:	00003006 	br	811061a8 <vFeebInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
811060e8:	d0a04204 	addi	r2,gp,-32504
811060ec:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_BUFFERS_IRQ, pvHoldContext,
811060f0:	01a04434 	movhi	r6,33040
811060f4:	31948d04 	addi	r6,r6,21044
811060f8:	e17ffe17 	ldw	r5,-8(fp)
811060fc:	01000484 	movi	r4,18
81106100:	11358000 	call	81135800 <alt_irq_register>
				vFeebCh3HandleIrq);
		break;
81106104:	00002806 	br	811061a8 <vFeebInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81106108:	d0a04304 	addi	r2,gp,-32500
8110610c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_BUFFERS_IRQ, pvHoldContext,
81106110:	01a04434 	movhi	r6,33040
81106114:	3194ae04 	addi	r6,r6,21176
81106118:	e17ffe17 	ldw	r5,-8(fp)
8110611c:	01000404 	movi	r4,16
81106120:	11358000 	call	81135800 <alt_irq_register>
				vFeebCh4HandleIrq);
		break;
81106124:	00002006 	br	811061a8 <vFeebInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81106128:	d0a04404 	addi	r2,gp,-32496
8110612c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_BUFFERS_IRQ, pvHoldContext,
81106130:	01a04434 	movhi	r6,33040
81106134:	3194cf04 	addi	r6,r6,21308
81106138:	e17ffe17 	ldw	r5,-8(fp)
8110613c:	01000204 	movi	r4,8
81106140:	11358000 	call	81135800 <alt_irq_register>
				vFeebCh5HandleIrq);
		break;
81106144:	00001806 	br	811061a8 <vFeebInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81106148:	d0a04504 	addi	r2,gp,-32492
8110614c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_BUFFERS_IRQ, pvHoldContext,
81106150:	01a04434 	movhi	r6,33040
81106154:	3194f004 	addi	r6,r6,21440
81106158:	e17ffe17 	ldw	r5,-8(fp)
8110615c:	01000184 	movi	r4,6
81106160:	11358000 	call	81135800 <alt_irq_register>
				vFeebCh6HandleIrq);
		break;
81106164:	00001006 	br	811061a8 <vFeebInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81106168:	d0a04604 	addi	r2,gp,-32488
8110616c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_BUFFERS_IRQ, pvHoldContext,
81106170:	01a04434 	movhi	r6,33040
81106174:	31951104 	addi	r6,r6,21572
81106178:	e17ffe17 	ldw	r5,-8(fp)
8110617c:	01000144 	movi	r4,5
81106180:	11358000 	call	81135800 <alt_irq_register>
				vFeebCh7HandleIrq);
		break;
81106184:	00000806 	br	811061a8 <vFeebInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81106188:	d0a04704 	addi	r2,gp,-32484
8110618c:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_BUFFERS_IRQ, pvHoldContext,
81106190:	01a04434 	movhi	r6,33040
81106194:	31952104 	addi	r6,r6,21636
81106198:	e17ffe17 	ldw	r5,-8(fp)
8110619c:	01000084 	movi	r4,2
811061a0:	11358000 	call	81135800 <alt_irq_register>
				vFeebCh8HandleIrq);
		break;
811061a4:	0001883a 	nop
	}
}
811061a8:	0001883a 	nop
811061ac:	e037883a 	mov	sp,fp
811061b0:	dfc00117 	ldw	ra,4(sp)
811061b4:	df000017 	ldw	fp,0(sp)
811061b8:	dec00204 	addi	sp,sp,8
811061bc:	f800283a 	ret

811061c0 <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
811061c0:	defffb04 	addi	sp,sp,-20
811061c4:	de00012e 	bgeu	sp,et,811061cc <bFeebSetIrqControl+0xc>
811061c8:	003b68fa 	trap	3
811061cc:	dfc00415 	stw	ra,16(sp)
811061d0:	df000315 	stw	fp,12(sp)
811061d4:	df000304 	addi	fp,sp,12
811061d8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811061dc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811061e0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811061e4:	e0bfff17 	ldw	r2,-4(fp)
811061e8:	10002426 	beq	r2,zero,8110627c <bFeebSetIrqControl+0xbc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811061ec:	e0bfff17 	ldw	r2,-4(fp)
811061f0:	10800017 	ldw	r2,0(r2)
811061f4:	01400444 	movi	r5,17
811061f8:	1009883a 	mov	r4,r2
811061fc:	1106ce40 	call	81106ce4 <uliFeebReadReg>
81106200:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
81106204:	e0bfff17 	ldw	r2,-4(fp)
81106208:	10800217 	ldw	r2,8(r2)
8110620c:	10000426 	beq	r2,zero,81106220 <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_LEFT_BUFF_EPY_EN_MSK;
81106210:	e0bffe17 	ldw	r2,-8(fp)
81106214:	10808014 	ori	r2,r2,512
81106218:	e0bffe15 	stw	r2,-8(fp)
8110621c:	00000406 	br	81106230 <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_LEFT_BUFF_EPY_EN_MSK);
81106220:	e0fffe17 	ldw	r3,-8(fp)
81106224:	00bf7fc4 	movi	r2,-513
81106228:	1884703a 	and	r2,r3,r2
8110622c:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
81106230:	e0bfff17 	ldw	r2,-4(fp)
81106234:	10800317 	ldw	r2,12(r2)
81106238:	10000426 	beq	r2,zero,8110624c <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_RIGH_BUFF_EPY_EN_MSK;
8110623c:	e0bffe17 	ldw	r2,-8(fp)
81106240:	10804014 	ori	r2,r2,256
81106244:	e0bffe15 	stw	r2,-8(fp)
81106248:	00000406 	br	8110625c <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_RIGH_BUFF_EPY_EN_MSK);
8110624c:	e0fffe17 	ldw	r3,-8(fp)
81106250:	00bfbfc4 	movi	r2,-257
81106254:	1884703a 	and	r2,r3,r2
81106258:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CONTROL_REG_OFST,
8110625c:	e0bfff17 	ldw	r2,-4(fp)
81106260:	10800017 	ldw	r2,0(r2)
81106264:	e1bffe17 	ldw	r6,-8(fp)
81106268:	01400444 	movi	r5,17
8110626c:	1009883a 	mov	r4,r2
81106270:	1106c900 	call	81106c90 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81106274:	00800044 	movi	r2,1
81106278:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110627c:	e0bffd17 	ldw	r2,-12(fp)
}
81106280:	e037883a 	mov	sp,fp
81106284:	dfc00117 	ldw	ra,4(sp)
81106288:	df000017 	ldw	fp,0(sp)
8110628c:	dec00204 	addi	sp,sp,8
81106290:	f800283a 	ret

81106294 <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
81106294:	defffb04 	addi	sp,sp,-20
81106298:	de00012e 	bgeu	sp,et,811062a0 <bFeebGetIrqControl+0xc>
8110629c:	003b68fa 	trap	3
811062a0:	dfc00415 	stw	ra,16(sp)
811062a4:	df000315 	stw	fp,12(sp)
811062a8:	df000304 	addi	fp,sp,12
811062ac:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811062b0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811062b4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811062b8:	e0bfff17 	ldw	r2,-4(fp)
811062bc:	10001a26 	beq	r2,zero,81106328 <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811062c0:	e0bfff17 	ldw	r2,-4(fp)
811062c4:	10800017 	ldw	r2,0(r2)
811062c8:	01400444 	movi	r5,17
811062cc:	1009883a 	mov	r4,r2
811062d0:	1106ce40 	call	81106ce4 <uliFeebReadReg>
811062d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_LEFT_BUFF_EPY_EN_MSK) {
811062d8:	e0bffe17 	ldw	r2,-8(fp)
811062dc:	1080800c 	andi	r2,r2,512
811062e0:	10000426 	beq	r2,zero,811062f4 <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
811062e4:	e0bfff17 	ldw	r2,-4(fp)
811062e8:	00c00044 	movi	r3,1
811062ec:	10c00215 	stw	r3,8(r2)
811062f0:	00000206 	br	811062fc <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
811062f4:	e0bfff17 	ldw	r2,-4(fp)
811062f8:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_RIGH_BUFF_EPY_EN_MSK) {
811062fc:	e0bffe17 	ldw	r2,-8(fp)
81106300:	1080400c 	andi	r2,r2,256
81106304:	10000426 	beq	r2,zero,81106318 <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
81106308:	e0bfff17 	ldw	r2,-4(fp)
8110630c:	00c00044 	movi	r3,1
81106310:	10c00315 	stw	r3,12(r2)
81106314:	00000206 	br	81106320 <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
81106318:	e0bfff17 	ldw	r2,-4(fp)
8110631c:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
81106320:	00800044 	movi	r2,1
81106324:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106328:	e0bffd17 	ldw	r2,-12(fp)
}
8110632c:	e037883a 	mov	sp,fp
81106330:	dfc00117 	ldw	ra,4(sp)
81106334:	df000017 	ldw	fp,0(sp)
81106338:	dec00204 	addi	sp,sp,8
8110633c:	f800283a 	ret

81106340 <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
81106340:	defffb04 	addi	sp,sp,-20
81106344:	de00012e 	bgeu	sp,et,8110634c <bFeebGetIrqFlags+0xc>
81106348:	003b68fa 	trap	3
8110634c:	dfc00415 	stw	ra,16(sp)
81106350:	df000315 	stw	fp,12(sp)
81106354:	df000304 	addi	fp,sp,12
81106358:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110635c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106360:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106364:	e0bfff17 	ldw	r2,-4(fp)
81106368:	10001126 	beq	r2,zero,811063b0 <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
8110636c:	e0bfff17 	ldw	r2,-4(fp)
81106370:	10800017 	ldw	r2,0(r2)
81106374:	01400484 	movi	r5,18
81106378:	1009883a 	mov	r4,r2
8110637c:	1106ce40 	call	81106ce4 <uliFeebReadReg>
81106380:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81106384:	e0bffe17 	ldw	r2,-8(fp)
81106388:	1080400c 	andi	r2,r2,256
8110638c:	10000426 	beq	r2,zero,811063a0 <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
81106390:	e0bfff17 	ldw	r2,-4(fp)
81106394:	00c00044 	movi	r3,1
81106398:	10c00415 	stw	r3,16(r2)
8110639c:	00000206 	br	811063a8 <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
811063a0:	e0bfff17 	ldw	r2,-4(fp)
811063a4:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
811063a8:	00800044 	movi	r2,1
811063ac:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811063b0:	e0bffd17 	ldw	r2,-12(fp)
}
811063b4:	e037883a 	mov	sp,fp
811063b8:	dfc00117 	ldw	ra,4(sp)
811063bc:	df000017 	ldw	fp,0(sp)
811063c0:	dec00204 	addi	sp,sp,8
811063c4:	f800283a 	ret

811063c8 <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
811063c8:	defffb04 	addi	sp,sp,-20
811063cc:	de00012e 	bgeu	sp,et,811063d4 <bFeebGetBuffersStatus+0xc>
811063d0:	003b68fa 	trap	3
811063d4:	dfc00415 	stw	ra,16(sp)
811063d8:	df000315 	stw	fp,12(sp)
811063dc:	df000304 	addi	fp,sp,12
811063e0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811063e4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811063e8:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811063ec:	e0bfff17 	ldw	r2,-4(fp)
811063f0:	10003226 	beq	r2,zero,811064bc <bFeebGetBuffersStatus+0xf4>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811063f4:	e0bfff17 	ldw	r2,-4(fp)
811063f8:	10800017 	ldw	r2,0(r2)
811063fc:	014000c4 	movi	r5,3
81106400:	1009883a 	mov	r4,r2
81106404:	1106ce40 	call	81106ce4 <uliFeebReadReg>
81106408:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
8110640c:	e0bffe17 	ldw	r2,-8(fp)
81106410:	1080008c 	andi	r2,r2,2
81106414:	10000426 	beq	r2,zero,81106428 <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
81106418:	e0bfff17 	ldw	r2,-4(fp)
8110641c:	00c00044 	movi	r3,1
81106420:	10c00515 	stw	r3,20(r2)
81106424:	00000206 	br	81106430 <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
81106428:	e0bfff17 	ldw	r2,-4(fp)
8110642c:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106430:	e0bffe17 	ldw	r2,-8(fp)
81106434:	1080004c 	andi	r2,r2,1
81106438:	10000426 	beq	r2,zero,8110644c <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
8110643c:	e0bfff17 	ldw	r2,-4(fp)
81106440:	00c00044 	movi	r3,1
81106444:	10c00615 	stw	r3,24(r2)
81106448:	00000206 	br	81106454 <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
8110644c:	e0bfff17 	ldw	r2,-4(fp)
81106450:	10000615 	stw	zero,24(r2)
		}

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106454:	e0bfff17 	ldw	r2,-4(fp)
81106458:	10800017 	ldw	r2,0(r2)
8110645c:	01400504 	movi	r5,20
81106460:	1009883a 	mov	r4,r2
81106464:	1106ce40 	call	81106ce4 <uliFeebReadReg>
81106468:	e0bffe15 	stw	r2,-8(fp)
		COMM_RIGT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
8110646c:	e0bffe17 	ldw	r2,-8(fp)
81106470:	108003cc 	andi	r2,r2,15
81106474:	10800044 	addi	r2,r2,1
81106478:	1007883a 	mov	r3,r2
8110647c:	e0bfff17 	ldw	r2,-4(fp)
81106480:	10c00745 	stb	r3,29(r2)
				& COMM_RIGT_FEEBUFF_SIZE_MSK) + 1;

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106484:	e0bfff17 	ldw	r2,-4(fp)
81106488:	10800017 	ldw	r2,0(r2)
8110648c:	01400544 	movi	r5,21
81106490:	1009883a 	mov	r4,r2
81106494:	1106ce40 	call	81106ce4 <uliFeebReadReg>
81106498:	e0bffe15 	stw	r2,-8(fp)
		COMM_LEFT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
8110649c:	e0bffe17 	ldw	r2,-8(fp)
811064a0:	108003cc 	andi	r2,r2,15
811064a4:	10800044 	addi	r2,r2,1
811064a8:	1007883a 	mov	r3,r2
811064ac:	e0bfff17 	ldw	r2,-4(fp)
811064b0:	10c00745 	stb	r3,29(r2)
				& COMM_LEFT_FEEBUFF_SIZE_MSK) + 1;

		bStatus = TRUE;
811064b4:	00800044 	movi	r2,1
811064b8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811064bc:	e0bffd17 	ldw	r2,-12(fp)
}
811064c0:	e037883a 	mov	sp,fp
811064c4:	dfc00117 	ldw	ra,4(sp)
811064c8:	df000017 	ldw	fp,0(sp)
811064cc:	dec00204 	addi	sp,sp,8
811064d0:	f800283a 	ret

811064d4 <bFeebGetLeftBufferEmpty>:

bool bFeebGetLeftBufferEmpty(TFeebChannel *pxFeebCh){
811064d4:	defffb04 	addi	sp,sp,-20
811064d8:	de00012e 	bgeu	sp,et,811064e0 <bFeebGetLeftBufferEmpty+0xc>
811064dc:	003b68fa 	trap	3
811064e0:	dfc00415 	stw	ra,16(sp)
811064e4:	df000315 	stw	fp,12(sp)
811064e8:	df000304 	addi	fp,sp,12
811064ec:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
811064f0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811064f4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811064f8:	e0bfff17 	ldw	r2,-4(fp)
811064fc:	10000d26 	beq	r2,zero,81106534 <bFeebGetLeftBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106500:	e0bfff17 	ldw	r2,-4(fp)
81106504:	10800017 	ldw	r2,0(r2)
81106508:	014000c4 	movi	r5,3
8110650c:	1009883a 	mov	r4,r2
81106510:	1106ce40 	call	81106ce4 <uliFeebReadReg>
81106514:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
81106518:	e0bffe17 	ldw	r2,-8(fp)
8110651c:	1080008c 	andi	r2,r2,2
81106520:	10000326 	beq	r2,zero,81106530 <bFeebGetLeftBufferEmpty+0x5c>
			bFlag = TRUE;
81106524:	00800044 	movi	r2,1
81106528:	e0bffd15 	stw	r2,-12(fp)
8110652c:	00000106 	br	81106534 <bFeebGetLeftBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
81106530:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
81106534:	e0bffd17 	ldw	r2,-12(fp)
}
81106538:	e037883a 	mov	sp,fp
8110653c:	dfc00117 	ldw	ra,4(sp)
81106540:	df000017 	ldw	fp,0(sp)
81106544:	dec00204 	addi	sp,sp,8
81106548:	f800283a 	ret

8110654c <bFeebGetRightBufferEmpty>:

bool bFeebGetRightBufferEmpty(TFeebChannel *pxFeebCh){
8110654c:	defffb04 	addi	sp,sp,-20
81106550:	de00012e 	bgeu	sp,et,81106558 <bFeebGetRightBufferEmpty+0xc>
81106554:	003b68fa 	trap	3
81106558:	dfc00415 	stw	ra,16(sp)
8110655c:	df000315 	stw	fp,12(sp)
81106560:	df000304 	addi	fp,sp,12
81106564:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
81106568:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110656c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106570:	e0bfff17 	ldw	r2,-4(fp)
81106574:	10000d26 	beq	r2,zero,811065ac <bFeebGetRightBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106578:	e0bfff17 	ldw	r2,-4(fp)
8110657c:	10800017 	ldw	r2,0(r2)
81106580:	014000c4 	movi	r5,3
81106584:	1009883a 	mov	r4,r2
81106588:	1106ce40 	call	81106ce4 <uliFeebReadReg>
8110658c:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106590:	e0bffe17 	ldw	r2,-8(fp)
81106594:	1080004c 	andi	r2,r2,1
81106598:	10000326 	beq	r2,zero,811065a8 <bFeebGetRightBufferEmpty+0x5c>
			bFlag = TRUE;
8110659c:	00800044 	movi	r2,1
811065a0:	e0bffd15 	stw	r2,-12(fp)
811065a4:	00000106 	br	811065ac <bFeebGetRightBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
811065a8:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
811065ac:	e0bffd17 	ldw	r2,-12(fp)
}
811065b0:	e037883a 	mov	sp,fp
811065b4:	dfc00117 	ldw	ra,4(sp)
811065b8:	df000017 	ldw	fp,0(sp)
811065bc:	dec00204 	addi	sp,sp,8
811065c0:	f800283a 	ret

811065c4 <bFeebGetCh1LeftBufferEmpty>:

bool bFeebGetCh1LeftBufferEmpty(void){
811065c4:	defffc04 	addi	sp,sp,-16
811065c8:	de00012e 	bgeu	sp,et,811065d0 <bFeebGetCh1LeftBufferEmpty+0xc>
811065cc:	003b68fa 	trap	3
811065d0:	dfc00315 	stw	ra,12(sp)
811065d4:	df000215 	stw	fp,8(sp)
811065d8:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
811065dc:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
811065e0:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
811065e4:	014000c4 	movi	r5,3
811065e8:	01204834 	movhi	r4,33056
811065ec:	210b0004 	addi	r4,r4,11264
811065f0:	1106ce40 	call	81106ce4 <uliFeebReadReg>
811065f4:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811065f8:	e0bfff17 	ldw	r2,-4(fp)
811065fc:	1080008c 	andi	r2,r2,2
81106600:	10000326 	beq	r2,zero,81106610 <bFeebGetCh1LeftBufferEmpty+0x4c>
			bFlag = TRUE;
81106604:	00800044 	movi	r2,1
81106608:	e0bffe15 	stw	r2,-8(fp)
8110660c:	00000106 	br	81106614 <bFeebGetCh1LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81106610:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106614:	e0bffe17 	ldw	r2,-8(fp)
}
81106618:	e037883a 	mov	sp,fp
8110661c:	dfc00117 	ldw	ra,4(sp)
81106620:	df000017 	ldw	fp,0(sp)
81106624:	dec00204 	addi	sp,sp,8
81106628:	f800283a 	ret

8110662c <bFeebGetCh1RightBufferEmpty>:

bool bFeebGetCh1RightBufferEmpty(void){
8110662c:	defffc04 	addi	sp,sp,-16
81106630:	de00012e 	bgeu	sp,et,81106638 <bFeebGetCh1RightBufferEmpty+0xc>
81106634:	003b68fa 	trap	3
81106638:	dfc00315 	stw	ra,12(sp)
8110663c:	df000215 	stw	fp,8(sp)
81106640:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106644:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
81106648:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
8110664c:	014000c4 	movi	r5,3
81106650:	01204834 	movhi	r4,33056
81106654:	210b0004 	addi	r4,r4,11264
81106658:	1106ce40 	call	81106ce4 <uliFeebReadReg>
8110665c:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106660:	e0bfff17 	ldw	r2,-4(fp)
81106664:	1080004c 	andi	r2,r2,1
81106668:	10000326 	beq	r2,zero,81106678 <bFeebGetCh1RightBufferEmpty+0x4c>
			bFlag = TRUE;
8110666c:	00800044 	movi	r2,1
81106670:	e0bffe15 	stw	r2,-8(fp)
81106674:	00000106 	br	8110667c <bFeebGetCh1RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81106678:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
8110667c:	e0bffe17 	ldw	r2,-8(fp)
}
81106680:	e037883a 	mov	sp,fp
81106684:	dfc00117 	ldw	ra,4(sp)
81106688:	df000017 	ldw	fp,0(sp)
8110668c:	dec00204 	addi	sp,sp,8
81106690:	f800283a 	ret

81106694 <bFeebGetCh2LeftBufferEmpty>:

bool bFeebGetCh2LeftBufferEmpty(void){
81106694:	defffc04 	addi	sp,sp,-16
81106698:	de00012e 	bgeu	sp,et,811066a0 <bFeebGetCh2LeftBufferEmpty+0xc>
8110669c:	003b68fa 	trap	3
811066a0:	dfc00315 	stw	ra,12(sp)
811066a4:	df000215 	stw	fp,8(sp)
811066a8:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
811066ac:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
811066b0:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
811066b4:	014000c4 	movi	r5,3
811066b8:	01204834 	movhi	r4,33056
811066bc:	210a0004 	addi	r4,r4,10240
811066c0:	1106ce40 	call	81106ce4 <uliFeebReadReg>
811066c4:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811066c8:	e0bfff17 	ldw	r2,-4(fp)
811066cc:	1080008c 	andi	r2,r2,2
811066d0:	10000326 	beq	r2,zero,811066e0 <bFeebGetCh2LeftBufferEmpty+0x4c>
			bFlag = TRUE;
811066d4:	00800044 	movi	r2,1
811066d8:	e0bffe15 	stw	r2,-8(fp)
811066dc:	00000106 	br	811066e4 <bFeebGetCh2LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
811066e0:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
811066e4:	e0bffe17 	ldw	r2,-8(fp)
}
811066e8:	e037883a 	mov	sp,fp
811066ec:	dfc00117 	ldw	ra,4(sp)
811066f0:	df000017 	ldw	fp,0(sp)
811066f4:	dec00204 	addi	sp,sp,8
811066f8:	f800283a 	ret

811066fc <bFeebGetCh2RightBufferEmpty>:

bool bFeebGetCh2RightBufferEmpty(void){
811066fc:	defffc04 	addi	sp,sp,-16
81106700:	de00012e 	bgeu	sp,et,81106708 <bFeebGetCh2RightBufferEmpty+0xc>
81106704:	003b68fa 	trap	3
81106708:	dfc00315 	stw	ra,12(sp)
8110670c:	df000215 	stw	fp,8(sp)
81106710:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106714:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
81106718:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
8110671c:	014000c4 	movi	r5,3
81106720:	01204834 	movhi	r4,33056
81106724:	210a0004 	addi	r4,r4,10240
81106728:	1106ce40 	call	81106ce4 <uliFeebReadReg>
8110672c:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106730:	e0bfff17 	ldw	r2,-4(fp)
81106734:	1080004c 	andi	r2,r2,1
81106738:	10000326 	beq	r2,zero,81106748 <bFeebGetCh2RightBufferEmpty+0x4c>
			bFlag = TRUE;
8110673c:	00800044 	movi	r2,1
81106740:	e0bffe15 	stw	r2,-8(fp)
81106744:	00000106 	br	8110674c <bFeebGetCh2RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81106748:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
8110674c:	e0bffe17 	ldw	r2,-8(fp)
}
81106750:	e037883a 	mov	sp,fp
81106754:	dfc00117 	ldw	ra,4(sp)
81106758:	df000017 	ldw	fp,0(sp)
8110675c:	dec00204 	addi	sp,sp,8
81106760:	f800283a 	ret

81106764 <bFeebSetBufferSize>:

bool bFeebSetBufferSize(TFeebChannel *pxFeebCh, alt_u8 ucBufferSizeInBlocks,
		alt_u8 ucBufferSide) {
81106764:	defff904 	addi	sp,sp,-28
81106768:	de00012e 	bgeu	sp,et,81106770 <bFeebSetBufferSize+0xc>
8110676c:	003b68fa 	trap	3
81106770:	dfc00615 	stw	ra,24(sp)
81106774:	df000515 	stw	fp,20(sp)
81106778:	df000504 	addi	fp,sp,20
8110677c:	e13ffd15 	stw	r4,-12(fp)
81106780:	2807883a 	mov	r3,r5
81106784:	3005883a 	mov	r2,r6
81106788:	e0fffe05 	stb	r3,-8(fp)
8110678c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81106790:	00800044 	movi	r2,1
81106794:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
81106798:	e03ffc15 	stw	zero,-16(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
8110679c:	e0bffe03 	ldbu	r2,-8(fp)
811067a0:	10002126 	beq	r2,zero,81106828 <bFeebSetBufferSize+0xc4>
811067a4:	e0bffe03 	ldbu	r2,-8(fp)
811067a8:	10800468 	cmpgeui	r2,r2,17
811067ac:	10001e1e 	bne	r2,zero,81106828 <bFeebSetBufferSize+0xc4>
		switch (ucBufferSide) {
811067b0:	e0bfff03 	ldbu	r2,-4(fp)
811067b4:	10000326 	beq	r2,zero,811067c4 <bFeebSetBufferSize+0x60>
811067b8:	10800060 	cmpeqi	r2,r2,1
811067bc:	10000c1e 	bne	r2,zero,811067f0 <bFeebSetBufferSize+0x8c>
811067c0:	00001606 	br	8110681c <bFeebSetBufferSize+0xb8>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811067c4:	e0bffe03 	ldbu	r2,-8(fp)
811067c8:	10bfffc4 	addi	r2,r2,-1
811067cc:	108003cc 	andi	r2,r2,15
811067d0:	e0bffc15 	stw	r2,-16(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
811067d4:	e0bffd17 	ldw	r2,-12(fp)
811067d8:	10800017 	ldw	r2,0(r2)
811067dc:	e1bffc17 	ldw	r6,-16(fp)
811067e0:	01400544 	movi	r5,21
811067e4:	1009883a 	mov	r4,r2
811067e8:	1106c900 	call	81106c90 <vFeebWriteReg>
					COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811067ec:	00000d06 	br	81106824 <bFeebSetBufferSize+0xc0>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811067f0:	e0bffe03 	ldbu	r2,-8(fp)
811067f4:	10bfffc4 	addi	r2,r2,-1
811067f8:	108003cc 	andi	r2,r2,15
811067fc:	e0bffc15 	stw	r2,-16(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
81106800:	e0bffd17 	ldw	r2,-12(fp)
81106804:	10800017 	ldw	r2,0(r2)
81106808:	e1bffc17 	ldw	r6,-16(fp)
8110680c:	01400504 	movi	r5,20
81106810:	1009883a 	mov	r4,r2
81106814:	1106c900 	call	81106c90 <vFeebWriteReg>
					COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81106818:	00000206 	br	81106824 <bFeebSetBufferSize+0xc0>
		default:
			bStatus = FALSE;
8110681c:	e03ffb15 	stw	zero,-20(fp)
			break;
81106820:	0001883a 	nop
		}
	} else {
81106824:	00000106 	br	8110682c <bFeebSetBufferSize+0xc8>
		bStatus = FALSE;
81106828:	e03ffb15 	stw	zero,-20(fp)
	}

	return bStatus;
8110682c:	e0bffb17 	ldw	r2,-20(fp)
}
81106830:	e037883a 	mov	sp,fp
81106834:	dfc00117 	ldw	ra,4(sp)
81106838:	df000017 	ldw	fp,0(sp)
8110683c:	dec00204 	addi	sp,sp,8
81106840:	f800283a 	ret

81106844 <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
81106844:	defffb04 	addi	sp,sp,-20
81106848:	de00012e 	bgeu	sp,et,81106850 <bFeebSetWindowing+0xc>
8110684c:	003b68fa 	trap	3
81106850:	dfc00415 	stw	ra,16(sp)
81106854:	df000315 	stw	fp,12(sp)
81106858:	df000304 	addi	fp,sp,12
8110685c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106860:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106864:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106868:	e0bfff17 	ldw	r2,-4(fp)
8110686c:	10001926 	beq	r2,zero,811068d4 <bFeebSetWindowing+0x90>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106870:	e0bfff17 	ldw	r2,-4(fp)
81106874:	10800017 	ldw	r2,0(r2)
81106878:	01400084 	movi	r5,2
8110687c:	1009883a 	mov	r4,r2
81106880:	1106ce40 	call	81106ce4 <uliFeebReadReg>
81106884:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (pxFeebCh->xWindowingConfig.bMasking) {
81106888:	e0bfff17 	ldw	r2,-4(fp)
8110688c:	10800117 	ldw	r2,4(r2)
81106890:	10000426 	beq	r2,zero,811068a4 <bFeebSetWindowing+0x60>
			uliReg |= COMM_FEE_MASKING_EN_MSK;
81106894:	e0bffe17 	ldw	r2,-8(fp)
81106898:	10800214 	ori	r2,r2,8
8110689c:	e0bffe15 	stw	r2,-8(fp)
811068a0:	00000406 	br	811068b4 <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_FEE_MASKING_EN_MSK);
811068a4:	e0fffe17 	ldw	r3,-8(fp)
811068a8:	00bffdc4 	movi	r2,-9
811068ac:	1884703a 	and	r2,r3,r2
811068b0:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
811068b4:	e0bfff17 	ldw	r2,-4(fp)
811068b8:	10800017 	ldw	r2,0(r2)
811068bc:	e1bffe17 	ldw	r6,-8(fp)
811068c0:	01400084 	movi	r5,2
811068c4:	1009883a 	mov	r4,r2
811068c8:	1106c900 	call	81106c90 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
811068cc:	00800044 	movi	r2,1
811068d0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811068d4:	e0bffd17 	ldw	r2,-12(fp)
}
811068d8:	e037883a 	mov	sp,fp
811068dc:	dfc00117 	ldw	ra,4(sp)
811068e0:	df000017 	ldw	fp,0(sp)
811068e4:	dec00204 	addi	sp,sp,8
811068e8:	f800283a 	ret

811068ec <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
811068ec:	defffb04 	addi	sp,sp,-20
811068f0:	de00012e 	bgeu	sp,et,811068f8 <bFeebGetWindowing+0xc>
811068f4:	003b68fa 	trap	3
811068f8:	dfc00415 	stw	ra,16(sp)
811068fc:	df000315 	stw	fp,12(sp)
81106900:	df000304 	addi	fp,sp,12
81106904:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106908:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110690c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106910:	e0bfff17 	ldw	r2,-4(fp)
81106914:	10001126 	beq	r2,zero,8110695c <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106918:	e0bfff17 	ldw	r2,-4(fp)
8110691c:	10800017 	ldw	r2,0(r2)
81106920:	01400084 	movi	r5,2
81106924:	1009883a 	mov	r4,r2
81106928:	1106ce40 	call	81106ce4 <uliFeebReadReg>
8110692c:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (uliReg & COMM_FEE_MASKING_EN_MSK) {
81106930:	e0bffe17 	ldw	r2,-8(fp)
81106934:	1080020c 	andi	r2,r2,8
81106938:	10000426 	beq	r2,zero,8110694c <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
8110693c:	e0bfff17 	ldw	r2,-4(fp)
81106940:	00c00044 	movi	r3,1
81106944:	10c00115 	stw	r3,4(r2)
81106948:	00000206 	br	81106954 <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
8110694c:	e0bfff17 	ldw	r2,-4(fp)
81106950:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
81106954:	00800044 	movi	r2,1
81106958:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110695c:	e0bffd17 	ldw	r2,-12(fp)
}
81106960:	e037883a 	mov	sp,fp
81106964:	dfc00117 	ldw	ra,4(sp)
81106968:	df000017 	ldw	fp,0(sp)
8110696c:	dec00204 	addi	sp,sp,8
81106970:	f800283a 	ret

81106974 <bFeebStartCh>:

bool bFeebStartCh(TFeebChannel *pxFeebCh) {
81106974:	defffb04 	addi	sp,sp,-20
81106978:	de00012e 	bgeu	sp,et,81106980 <bFeebStartCh+0xc>
8110697c:	003b68fa 	trap	3
81106980:	dfc00415 	stw	ra,16(sp)
81106984:	df000315 	stw	fp,12(sp)
81106988:	df000304 	addi	fp,sp,12
8110698c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106990:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106994:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106998:	e0bfff17 	ldw	r2,-4(fp)
8110699c:	10001126 	beq	r2,zero,811069e4 <bFeebStartCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811069a0:	e0bfff17 	ldw	r2,-4(fp)
811069a4:	10800017 	ldw	r2,0(r2)
811069a8:	01400084 	movi	r5,2
811069ac:	1009883a 	mov	r4,r2
811069b0:	1106ce40 	call	81106ce4 <uliFeebReadReg>
811069b4:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_START_MSK;
811069b8:	e0bffe17 	ldw	r2,-8(fp)
811069bc:	10800114 	ori	r2,r2,4
811069c0:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
811069c4:	e0bfff17 	ldw	r2,-4(fp)
811069c8:	10800017 	ldw	r2,0(r2)
811069cc:	e1bffe17 	ldw	r6,-8(fp)
811069d0:	01400084 	movi	r5,2
811069d4:	1009883a 	mov	r4,r2
811069d8:	1106c900 	call	81106c90 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
811069dc:	00800044 	movi	r2,1
811069e0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811069e4:	e0bffd17 	ldw	r2,-12(fp)
}
811069e8:	e037883a 	mov	sp,fp
811069ec:	dfc00117 	ldw	ra,4(sp)
811069f0:	df000017 	ldw	fp,0(sp)
811069f4:	dec00204 	addi	sp,sp,8
811069f8:	f800283a 	ret

811069fc <bFeebStopCh>:

bool bFeebStopCh(TFeebChannel *pxFeebCh) {
811069fc:	defffb04 	addi	sp,sp,-20
81106a00:	de00012e 	bgeu	sp,et,81106a08 <bFeebStopCh+0xc>
81106a04:	003b68fa 	trap	3
81106a08:	dfc00415 	stw	ra,16(sp)
81106a0c:	df000315 	stw	fp,12(sp)
81106a10:	df000304 	addi	fp,sp,12
81106a14:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106a18:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106a1c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106a20:	e0bfff17 	ldw	r2,-4(fp)
81106a24:	10001126 	beq	r2,zero,81106a6c <bFeebStopCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106a28:	e0bfff17 	ldw	r2,-4(fp)
81106a2c:	10800017 	ldw	r2,0(r2)
81106a30:	01400084 	movi	r5,2
81106a34:	1009883a 	mov	r4,r2
81106a38:	1106ce40 	call	81106ce4 <uliFeebReadReg>
81106a3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_STOP_MSK;
81106a40:	e0bffe17 	ldw	r2,-8(fp)
81106a44:	10800094 	ori	r2,r2,2
81106a48:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106a4c:	e0bfff17 	ldw	r2,-4(fp)
81106a50:	10800017 	ldw	r2,0(r2)
81106a54:	e1bffe17 	ldw	r6,-8(fp)
81106a58:	01400084 	movi	r5,2
81106a5c:	1009883a 	mov	r4,r2
81106a60:	1106c900 	call	81106c90 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106a64:	00800044 	movi	r2,1
81106a68:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106a6c:	e0bffd17 	ldw	r2,-12(fp)
}
81106a70:	e037883a 	mov	sp,fp
81106a74:	dfc00117 	ldw	ra,4(sp)
81106a78:	df000017 	ldw	fp,0(sp)
81106a7c:	dec00204 	addi	sp,sp,8
81106a80:	f800283a 	ret

81106a84 <bFeebClrCh>:

bool bFeebClrCh(TFeebChannel *pxFeebCh) {
81106a84:	defffb04 	addi	sp,sp,-20
81106a88:	de00012e 	bgeu	sp,et,81106a90 <bFeebClrCh+0xc>
81106a8c:	003b68fa 	trap	3
81106a90:	dfc00415 	stw	ra,16(sp)
81106a94:	df000315 	stw	fp,12(sp)
81106a98:	df000304 	addi	fp,sp,12
81106a9c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106aa0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106aa4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106aa8:	e0bfff17 	ldw	r2,-4(fp)
81106aac:	10001126 	beq	r2,zero,81106af4 <bFeebClrCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106ab0:	e0bfff17 	ldw	r2,-4(fp)
81106ab4:	10800017 	ldw	r2,0(r2)
81106ab8:	01400084 	movi	r5,2
81106abc:	1009883a 	mov	r4,r2
81106ac0:	1106ce40 	call	81106ce4 <uliFeebReadReg>
81106ac4:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_CLR_MSK;
81106ac8:	e0bffe17 	ldw	r2,-8(fp)
81106acc:	10800054 	ori	r2,r2,1
81106ad0:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106ad4:	e0bfff17 	ldw	r2,-4(fp)
81106ad8:	10800017 	ldw	r2,0(r2)
81106adc:	e1bffe17 	ldw	r6,-8(fp)
81106ae0:	01400084 	movi	r5,2
81106ae4:	1009883a 	mov	r4,r2
81106ae8:	1106c900 	call	81106c90 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81106aec:	00800044 	movi	r2,1
81106af0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106af4:	e0bffd17 	ldw	r2,-12(fp)
}
81106af8:	e037883a 	mov	sp,fp
81106afc:	dfc00117 	ldw	ra,4(sp)
81106b00:	df000017 	ldw	fp,0(sp)
81106b04:	dec00204 	addi	sp,sp,8
81106b08:	f800283a 	ret

81106b0c <bFeebInitCh>:

bool bFeebInitCh(TFeebChannel *pxFeebCh, alt_u8 ucCommCh) {
81106b0c:	defffb04 	addi	sp,sp,-20
81106b10:	de00012e 	bgeu	sp,et,81106b18 <bFeebInitCh+0xc>
81106b14:	003b68fa 	trap	3
81106b18:	dfc00415 	stw	ra,16(sp)
81106b1c:	df000315 	stw	fp,12(sp)
81106b20:	df000304 	addi	fp,sp,12
81106b24:	e13ffe15 	stw	r4,-8(fp)
81106b28:	2805883a 	mov	r2,r5
81106b2c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81106b30:	e03ffd15 	stw	zero,-12(fp)

	if (pxFeebCh != NULL) {
81106b34:	e0bffe17 	ldw	r2,-8(fp)
81106b38:	10004f26 	beq	r2,zero,81106c78 <bFeebInitCh+0x16c>
		bStatus = TRUE;
81106b3c:	00800044 	movi	r2,1
81106b40:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81106b44:	e0bfff03 	ldbu	r2,-4(fp)
81106b48:	10c00228 	cmpgeui	r3,r2,8
81106b4c:	1800361e 	bne	r3,zero,81106c28 <bFeebInitCh+0x11c>
81106b50:	100690ba 	slli	r3,r2,2
81106b54:	00a04434 	movhi	r2,33040
81106b58:	109ada04 	addi	r2,r2,27496
81106b5c:	1885883a 	add	r2,r3,r2
81106b60:	10800017 	ldw	r2,0(r2)
81106b64:	1000683a 	jmp	r2
81106b68:	81106b88 	cmpgei	r4,r16,16814
81106b6c:	81106b9c 	xori	r4,r16,16814
81106b70:	81106bb0 	cmpltui	r4,r16,16814
81106b74:	81106bc4 	addi	r4,r16,16815
81106b78:	81106bd8 	cmpnei	r4,r16,16815
81106b7c:	81106bec 	andhi	r4,r16,16815
81106b80:	81106c00 	call	881106c0 <__reset+0x20f06c0>
81106b84:	81106c14 	ori	r4,r16,16816
		case eCommSpwCh1:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81106b88:	e0fffe17 	ldw	r3,-8(fp)
81106b8c:	00a04834 	movhi	r2,33056
81106b90:	108b0004 	addi	r2,r2,11264
81106b94:	18800015 	stw	r2,0(r3)
			break;
81106b98:	00002506 	br	81106c30 <bFeebInitCh+0x124>
		case eCommSpwCh2:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81106b9c:	e0fffe17 	ldw	r3,-8(fp)
81106ba0:	00a04834 	movhi	r2,33056
81106ba4:	108a0004 	addi	r2,r2,10240
81106ba8:	18800015 	stw	r2,0(r3)
			break;
81106bac:	00002006 	br	81106c30 <bFeebInitCh+0x124>
		case eCommSpwCh3:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81106bb0:	e0fffe17 	ldw	r3,-8(fp)
81106bb4:	00a04834 	movhi	r2,33056
81106bb8:	108b0004 	addi	r2,r2,11264
81106bbc:	18800015 	stw	r2,0(r3)
			break;
81106bc0:	00001b06 	br	81106c30 <bFeebInitCh+0x124>
		case eCommSpwCh4:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81106bc4:	e0fffe17 	ldw	r3,-8(fp)
81106bc8:	00a04834 	movhi	r2,33056
81106bcc:	108a0004 	addi	r2,r2,10240
81106bd0:	18800015 	stw	r2,0(r3)
			break;
81106bd4:	00001606 	br	81106c30 <bFeebInitCh+0x124>
		case eCommSpwCh5:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81106bd8:	e0fffe17 	ldw	r3,-8(fp)
81106bdc:	00a04834 	movhi	r2,33056
81106be0:	108b0004 	addi	r2,r2,11264
81106be4:	18800015 	stw	r2,0(r3)
			break;
81106be8:	00001106 	br	81106c30 <bFeebInitCh+0x124>
		case eCommSpwCh6:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81106bec:	e0fffe17 	ldw	r3,-8(fp)
81106bf0:	00a04834 	movhi	r2,33056
81106bf4:	108a0004 	addi	r2,r2,10240
81106bf8:	18800015 	stw	r2,0(r3)
			break;
81106bfc:	00000c06 	br	81106c30 <bFeebInitCh+0x124>
		case eCommSpwCh7:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81106c00:	e0fffe17 	ldw	r3,-8(fp)
81106c04:	00a04834 	movhi	r2,33056
81106c08:	108b0004 	addi	r2,r2,11264
81106c0c:	18800015 	stw	r2,0(r3)
			break;
81106c10:	00000706 	br	81106c30 <bFeebInitCh+0x124>
		case eCommSpwCh8:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81106c14:	e0fffe17 	ldw	r3,-8(fp)
81106c18:	00a04834 	movhi	r2,33056
81106c1c:	108a0004 	addi	r2,r2,10240
81106c20:	18800015 	stw	r2,0(r3)
			break;
81106c24:	00000206 	br	81106c30 <bFeebInitCh+0x124>
		default:
			bStatus = FALSE;
81106c28:	e03ffd15 	stw	zero,-12(fp)
			break;
81106c2c:	0001883a 	nop
		}

		if (bStatus) {
81106c30:	e0bffd17 	ldw	r2,-12(fp)
81106c34:	10001026 	beq	r2,zero,81106c78 <bFeebInitCh+0x16c>
			if (!bFeebGetIrqControl(pxFeebCh)) {
81106c38:	e13ffe17 	ldw	r4,-8(fp)
81106c3c:	11062940 	call	81106294 <bFeebGetIrqControl>
81106c40:	1000011e 	bne	r2,zero,81106c48 <bFeebInitCh+0x13c>
				bStatus = FALSE;
81106c44:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetIrqFlags(pxFeebCh)) {
81106c48:	e13ffe17 	ldw	r4,-8(fp)
81106c4c:	11063400 	call	81106340 <bFeebGetIrqFlags>
81106c50:	1000011e 	bne	r2,zero,81106c58 <bFeebInitCh+0x14c>
				bStatus = FALSE;
81106c54:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetBuffersStatus(pxFeebCh)) {
81106c58:	e13ffe17 	ldw	r4,-8(fp)
81106c5c:	11063c80 	call	811063c8 <bFeebGetBuffersStatus>
81106c60:	1000011e 	bne	r2,zero,81106c68 <bFeebInitCh+0x15c>
				bStatus = FALSE;
81106c64:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetWindowing(pxFeebCh)) {
81106c68:	e13ffe17 	ldw	r4,-8(fp)
81106c6c:	11068ec0 	call	811068ec <bFeebGetWindowing>
81106c70:	1000011e 	bne	r2,zero,81106c78 <bFeebInitCh+0x16c>
				bStatus = FALSE;
81106c74:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81106c78:	e0bffd17 	ldw	r2,-12(fp)
}
81106c7c:	e037883a 	mov	sp,fp
81106c80:	dfc00117 	ldw	ra,4(sp)
81106c84:	df000017 	ldw	fp,0(sp)
81106c88:	dec00204 	addi	sp,sp,8
81106c8c:	f800283a 	ret

81106c90 <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81106c90:	defffc04 	addi	sp,sp,-16
81106c94:	de00012e 	bgeu	sp,et,81106c9c <vFeebWriteReg+0xc>
81106c98:	003b68fa 	trap	3
81106c9c:	df000315 	stw	fp,12(sp)
81106ca0:	df000304 	addi	fp,sp,12
81106ca4:	e13ffd15 	stw	r4,-12(fp)
81106ca8:	e17ffe15 	stw	r5,-8(fp)
81106cac:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81106cb0:	e0bffe17 	ldw	r2,-8(fp)
81106cb4:	1085883a 	add	r2,r2,r2
81106cb8:	1085883a 	add	r2,r2,r2
81106cbc:	1007883a 	mov	r3,r2
81106cc0:	e0bffd17 	ldw	r2,-12(fp)
81106cc4:	10c5883a 	add	r2,r2,r3
81106cc8:	e0ffff17 	ldw	r3,-4(fp)
81106ccc:	10c00015 	stw	r3,0(r2)
}
81106cd0:	0001883a 	nop
81106cd4:	e037883a 	mov	sp,fp
81106cd8:	df000017 	ldw	fp,0(sp)
81106cdc:	dec00104 	addi	sp,sp,4
81106ce0:	f800283a 	ret

81106ce4 <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81106ce4:	defffc04 	addi	sp,sp,-16
81106ce8:	de00012e 	bgeu	sp,et,81106cf0 <uliFeebReadReg+0xc>
81106cec:	003b68fa 	trap	3
81106cf0:	df000315 	stw	fp,12(sp)
81106cf4:	df000304 	addi	fp,sp,12
81106cf8:	e13ffe15 	stw	r4,-8(fp)
81106cfc:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81106d00:	e0bfff17 	ldw	r2,-4(fp)
81106d04:	1085883a 	add	r2,r2,r2
81106d08:	1085883a 	add	r2,r2,r2
81106d0c:	1007883a 	mov	r3,r2
81106d10:	e0bffe17 	ldw	r2,-8(fp)
81106d14:	10c5883a 	add	r2,r2,r3
81106d18:	10800017 	ldw	r2,0(r2)
81106d1c:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81106d20:	e0bffd17 	ldw	r2,-12(fp)
}
81106d24:	e037883a 	mov	sp,fp
81106d28:	df000017 	ldw	fp,0(sp)
81106d2c:	dec00104 	addi	sp,sp,4
81106d30:	f800283a 	ret

81106d34 <vRmapCh1HandleIrq>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
/* todo:Trigger not working right */
void vRmapCh1HandleIrq(void* pvContext) {
81106d34:	defffa04 	addi	sp,sp,-24
81106d38:	de00012e 	bgeu	sp,et,81106d40 <vRmapCh1HandleIrq+0xc>
81106d3c:	003b68fa 	trap	3
81106d40:	dfc00515 	stw	ra,20(sp)
81106d44:	df000415 	stw	fp,16(sp)
81106d48:	df000404 	addi	fp,sp,16
81106d4c:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106d50:	e0bfff17 	ldw	r2,-4(fp)
81106d54:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;

	/* Warnning simplification: For now all address is lower than 1 bytes  */

#ifdef DEBUG_ON
	fprintf(fp,"IRQ RMAP.\n");
81106d58:	d0a06117 	ldw	r2,-32380(gp)
81106d5c:	100f883a 	mov	r7,r2
81106d60:	01800284 	movi	r6,10
81106d64:	01400044 	movi	r5,1
81106d68:	01204574 	movhi	r4,33045
81106d6c:	212d8404 	addi	r4,r4,-18928
81106d70:	1120e540 	call	81120e54 <fwrite>
#endif

	ucADDRReg = (unsigned char)uliRmapCh1WriteCmdAddress();
81106d74:	11074980 	call	81107498 <uliRmapCh1WriteCmdAddress>
81106d78:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
81106d7c:	00800444 	movi	r2,17
81106d80:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
81106d84:	00bffc04 	movi	r2,-16
81106d88:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
81106d8c:	e0bffd03 	ldbu	r2,-12(fp)
81106d90:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
81106d94:	e03ffe05 	stb	zero,-8(fp)

#ifdef DEBUG_ON
	fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
81106d98:	d0a06117 	ldw	r2,-32380(gp)
81106d9c:	e0fffd03 	ldbu	r3,-12(fp)
81106da0:	180d883a 	mov	r6,r3
81106da4:	01604574 	movhi	r5,33045
81106da8:	296d8704 	addi	r5,r5,-18916
81106dac:	1009883a 	mov	r4,r2
81106db0:	11207b80 	call	811207b8 <fprintf>
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord);
81106db4:	d0a06917 	ldw	r2,-32348(gp)
81106db8:	e0fffe17 	ldw	r3,-8(fp)
81106dbc:	180b883a 	mov	r5,r3
81106dc0:	1009883a 	mov	r4,r2
81106dc4:	113d3540 	call	8113d354 <OSQPostFront>
81106dc8:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
81106dcc:	e0bffd43 	ldbu	r2,-11(fp)
81106dd0:	10000226 	beq	r2,zero,81106ddc <vRmapCh1HandleIrq+0xa8>
		vFailSendRMAPFromIRQ( 0 );
81106dd4:	0009883a 	mov	r4,zero
81106dd8:	111c6fc0 	call	8111c6fc <vFailSendRMAPFromIRQ>
	}

	vRmapCh1IrqFlagClrWriteCmd();
81106ddc:	1106fb80 	call	81106fb8 <vRmapCh1IrqFlagClrWriteCmd>
}
81106de0:	0001883a 	nop
81106de4:	e037883a 	mov	sp,fp
81106de8:	dfc00117 	ldw	ra,4(sp)
81106dec:	df000017 	ldw	fp,0(sp)
81106df0:	dec00204 	addi	sp,sp,8
81106df4:	f800283a 	ret

81106df8 <vRmapCh2HandleIrq>:

void vRmapCh2HandleIrq(void* pvContext) {
81106df8:	defffc04 	addi	sp,sp,-16
81106dfc:	de00012e 	bgeu	sp,et,81106e04 <vRmapCh2HandleIrq+0xc>
81106e00:	003b68fa 	trap	3
81106e04:	dfc00315 	stw	ra,12(sp)
81106e08:	df000215 	stw	fp,8(sp)
81106e0c:	df000204 	addi	fp,sp,8
81106e10:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106e14:	e0bfff17 	ldw	r2,-4(fp)
81106e18:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh2IrqFlagClrWriteCmd();
81106e1c:	1106ffc0 	call	81106ffc <vRmapCh2IrqFlagClrWriteCmd>
}
81106e20:	0001883a 	nop
81106e24:	e037883a 	mov	sp,fp
81106e28:	dfc00117 	ldw	ra,4(sp)
81106e2c:	df000017 	ldw	fp,0(sp)
81106e30:	dec00204 	addi	sp,sp,8
81106e34:	f800283a 	ret

81106e38 <vRmapCh3HandleIrq>:

void vRmapCh3HandleIrq(void* pvContext) {
81106e38:	defffc04 	addi	sp,sp,-16
81106e3c:	de00012e 	bgeu	sp,et,81106e44 <vRmapCh3HandleIrq+0xc>
81106e40:	003b68fa 	trap	3
81106e44:	dfc00315 	stw	ra,12(sp)
81106e48:	df000215 	stw	fp,8(sp)
81106e4c:	df000204 	addi	fp,sp,8
81106e50:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106e54:	e0bfff17 	ldw	r2,-4(fp)
81106e58:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh3IrqFlagClrWriteCmd();
81106e5c:	11070400 	call	81107040 <vRmapCh3IrqFlagClrWriteCmd>
}
81106e60:	0001883a 	nop
81106e64:	e037883a 	mov	sp,fp
81106e68:	dfc00117 	ldw	ra,4(sp)
81106e6c:	df000017 	ldw	fp,0(sp)
81106e70:	dec00204 	addi	sp,sp,8
81106e74:	f800283a 	ret

81106e78 <vRmapCh4HandleIrq>:

void vRmapCh4HandleIrq(void* pvContext) {
81106e78:	defffc04 	addi	sp,sp,-16
81106e7c:	de00012e 	bgeu	sp,et,81106e84 <vRmapCh4HandleIrq+0xc>
81106e80:	003b68fa 	trap	3
81106e84:	dfc00315 	stw	ra,12(sp)
81106e88:	df000215 	stw	fp,8(sp)
81106e8c:	df000204 	addi	fp,sp,8
81106e90:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106e94:	e0bfff17 	ldw	r2,-4(fp)
81106e98:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh4IrqFlagClrWriteCmd();
81106e9c:	11070840 	call	81107084 <vRmapCh4IrqFlagClrWriteCmd>
}
81106ea0:	0001883a 	nop
81106ea4:	e037883a 	mov	sp,fp
81106ea8:	dfc00117 	ldw	ra,4(sp)
81106eac:	df000017 	ldw	fp,0(sp)
81106eb0:	dec00204 	addi	sp,sp,8
81106eb4:	f800283a 	ret

81106eb8 <vRmapCh5HandleIrq>:

void vRmapCh5HandleIrq(void* pvContext) {
81106eb8:	defffc04 	addi	sp,sp,-16
81106ebc:	de00012e 	bgeu	sp,et,81106ec4 <vRmapCh5HandleIrq+0xc>
81106ec0:	003b68fa 	trap	3
81106ec4:	dfc00315 	stw	ra,12(sp)
81106ec8:	df000215 	stw	fp,8(sp)
81106ecc:	df000204 	addi	fp,sp,8
81106ed0:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106ed4:	e0bfff17 	ldw	r2,-4(fp)
81106ed8:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh5IrqFlagClrWriteCmd();
81106edc:	11070c80 	call	811070c8 <vRmapCh5IrqFlagClrWriteCmd>
}
81106ee0:	0001883a 	nop
81106ee4:	e037883a 	mov	sp,fp
81106ee8:	dfc00117 	ldw	ra,4(sp)
81106eec:	df000017 	ldw	fp,0(sp)
81106ef0:	dec00204 	addi	sp,sp,8
81106ef4:	f800283a 	ret

81106ef8 <vRmapCh6HandleIrq>:

void vRmapCh6HandleIrq(void* pvContext) {
81106ef8:	defffc04 	addi	sp,sp,-16
81106efc:	de00012e 	bgeu	sp,et,81106f04 <vRmapCh6HandleIrq+0xc>
81106f00:	003b68fa 	trap	3
81106f04:	dfc00315 	stw	ra,12(sp)
81106f08:	df000215 	stw	fp,8(sp)
81106f0c:	df000204 	addi	fp,sp,8
81106f10:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106f14:	e0bfff17 	ldw	r2,-4(fp)
81106f18:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vRmapCh6IrqFlagClrWriteCmd();
81106f1c:	110710c0 	call	8110710c <vRmapCh6IrqFlagClrWriteCmd>
}
81106f20:	0001883a 	nop
81106f24:	e037883a 	mov	sp,fp
81106f28:	dfc00117 	ldw	ra,4(sp)
81106f2c:	df000017 	ldw	fp,0(sp)
81106f30:	dec00204 	addi	sp,sp,8
81106f34:	f800283a 	ret

81106f38 <vRmapCh7HandleIrq>:

void vRmapCh7HandleIrq(void* pvContext) {
81106f38:	defffc04 	addi	sp,sp,-16
81106f3c:	de00012e 	bgeu	sp,et,81106f44 <vRmapCh7HandleIrq+0xc>
81106f40:	003b68fa 	trap	3
81106f44:	dfc00315 	stw	ra,12(sp)
81106f48:	df000215 	stw	fp,8(sp)
81106f4c:	df000204 	addi	fp,sp,8
81106f50:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106f54:	e0bfff17 	ldw	r2,-4(fp)
81106f58:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh7IrqFlagClrWriteCmd();
81106f5c:	11071500 	call	81107150 <vRmapCh7IrqFlagClrWriteCmd>
}
81106f60:	0001883a 	nop
81106f64:	e037883a 	mov	sp,fp
81106f68:	dfc00117 	ldw	ra,4(sp)
81106f6c:	df000017 	ldw	fp,0(sp)
81106f70:	dec00204 	addi	sp,sp,8
81106f74:	f800283a 	ret

81106f78 <vRmapCh8HandleIrq>:

void vRmapCh8HandleIrq(void* pvContext) {
81106f78:	defffc04 	addi	sp,sp,-16
81106f7c:	de00012e 	bgeu	sp,et,81106f84 <vRmapCh8HandleIrq+0xc>
81106f80:	003b68fa 	trap	3
81106f84:	dfc00315 	stw	ra,12(sp)
81106f88:	df000215 	stw	fp,8(sp)
81106f8c:	df000204 	addi	fp,sp,8
81106f90:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106f94:	e0bfff17 	ldw	r2,-4(fp)
81106f98:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh8IrqFlagClrWriteCmd();
81106f9c:	11071940 	call	81107194 <vRmapCh8IrqFlagClrWriteCmd>
}
81106fa0:	0001883a 	nop
81106fa4:	e037883a 	mov	sp,fp
81106fa8:	dfc00117 	ldw	ra,4(sp)
81106fac:	df000017 	ldw	fp,0(sp)
81106fb0:	dec00204 	addi	sp,sp,8
81106fb4:	f800283a 	ret

81106fb8 <vRmapCh1IrqFlagClrWriteCmd>:

void vRmapCh1IrqFlagClrWriteCmd(void) {
81106fb8:	defffe04 	addi	sp,sp,-8
81106fbc:	de00012e 	bgeu	sp,et,81106fc4 <vRmapCh1IrqFlagClrWriteCmd+0xc>
81106fc0:	003b68fa 	trap	3
81106fc4:	dfc00115 	stw	ra,4(sp)
81106fc8:	df000015 	stw	fp,0(sp)
81106fcc:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106fd0:	01800044 	movi	r6,1
81106fd4:	014004c4 	movi	r5,19
81106fd8:	01204834 	movhi	r4,33056
81106fdc:	210b0004 	addi	r4,r4,11264
81106fe0:	1109e800 	call	81109e80 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106fe4:	0001883a 	nop
81106fe8:	e037883a 	mov	sp,fp
81106fec:	dfc00117 	ldw	ra,4(sp)
81106ff0:	df000017 	ldw	fp,0(sp)
81106ff4:	dec00204 	addi	sp,sp,8
81106ff8:	f800283a 	ret

81106ffc <vRmapCh2IrqFlagClrWriteCmd>:

void vRmapCh2IrqFlagClrWriteCmd(void) {
81106ffc:	defffe04 	addi	sp,sp,-8
81107000:	de00012e 	bgeu	sp,et,81107008 <vRmapCh2IrqFlagClrWriteCmd+0xc>
81107004:	003b68fa 	trap	3
81107008:	dfc00115 	stw	ra,4(sp)
8110700c:	df000015 	stw	fp,0(sp)
81107010:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107014:	01800044 	movi	r6,1
81107018:	014004c4 	movi	r5,19
8110701c:	01204834 	movhi	r4,33056
81107020:	210a0004 	addi	r4,r4,10240
81107024:	1109e800 	call	81109e80 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107028:	0001883a 	nop
8110702c:	e037883a 	mov	sp,fp
81107030:	dfc00117 	ldw	ra,4(sp)
81107034:	df000017 	ldw	fp,0(sp)
81107038:	dec00204 	addi	sp,sp,8
8110703c:	f800283a 	ret

81107040 <vRmapCh3IrqFlagClrWriteCmd>:

void vRmapCh3IrqFlagClrWriteCmd(void) {
81107040:	defffe04 	addi	sp,sp,-8
81107044:	de00012e 	bgeu	sp,et,8110704c <vRmapCh3IrqFlagClrWriteCmd+0xc>
81107048:	003b68fa 	trap	3
8110704c:	dfc00115 	stw	ra,4(sp)
81107050:	df000015 	stw	fp,0(sp)
81107054:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81107058:	01800044 	movi	r6,1
8110705c:	014004c4 	movi	r5,19
81107060:	01204834 	movhi	r4,33056
81107064:	210b0004 	addi	r4,r4,11264
81107068:	1109e800 	call	81109e80 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8110706c:	0001883a 	nop
81107070:	e037883a 	mov	sp,fp
81107074:	dfc00117 	ldw	ra,4(sp)
81107078:	df000017 	ldw	fp,0(sp)
8110707c:	dec00204 	addi	sp,sp,8
81107080:	f800283a 	ret

81107084 <vRmapCh4IrqFlagClrWriteCmd>:

void vRmapCh4IrqFlagClrWriteCmd(void) {
81107084:	defffe04 	addi	sp,sp,-8
81107088:	de00012e 	bgeu	sp,et,81107090 <vRmapCh4IrqFlagClrWriteCmd+0xc>
8110708c:	003b68fa 	trap	3
81107090:	dfc00115 	stw	ra,4(sp)
81107094:	df000015 	stw	fp,0(sp)
81107098:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8110709c:	01800044 	movi	r6,1
811070a0:	014004c4 	movi	r5,19
811070a4:	01204834 	movhi	r4,33056
811070a8:	210a0004 	addi	r4,r4,10240
811070ac:	1109e800 	call	81109e80 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811070b0:	0001883a 	nop
811070b4:	e037883a 	mov	sp,fp
811070b8:	dfc00117 	ldw	ra,4(sp)
811070bc:	df000017 	ldw	fp,0(sp)
811070c0:	dec00204 	addi	sp,sp,8
811070c4:	f800283a 	ret

811070c8 <vRmapCh5IrqFlagClrWriteCmd>:

void vRmapCh5IrqFlagClrWriteCmd(void) {
811070c8:	defffe04 	addi	sp,sp,-8
811070cc:	de00012e 	bgeu	sp,et,811070d4 <vRmapCh5IrqFlagClrWriteCmd+0xc>
811070d0:	003b68fa 	trap	3
811070d4:	dfc00115 	stw	ra,4(sp)
811070d8:	df000015 	stw	fp,0(sp)
811070dc:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811070e0:	01800044 	movi	r6,1
811070e4:	014004c4 	movi	r5,19
811070e8:	01204834 	movhi	r4,33056
811070ec:	210b0004 	addi	r4,r4,11264
811070f0:	1109e800 	call	81109e80 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811070f4:	0001883a 	nop
811070f8:	e037883a 	mov	sp,fp
811070fc:	dfc00117 	ldw	ra,4(sp)
81107100:	df000017 	ldw	fp,0(sp)
81107104:	dec00204 	addi	sp,sp,8
81107108:	f800283a 	ret

8110710c <vRmapCh6IrqFlagClrWriteCmd>:

void vRmapCh6IrqFlagClrWriteCmd(void) {
8110710c:	defffe04 	addi	sp,sp,-8
81107110:	de00012e 	bgeu	sp,et,81107118 <vRmapCh6IrqFlagClrWriteCmd+0xc>
81107114:	003b68fa 	trap	3
81107118:	dfc00115 	stw	ra,4(sp)
8110711c:	df000015 	stw	fp,0(sp)
81107120:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81107124:	01800044 	movi	r6,1
81107128:	014004c4 	movi	r5,19
8110712c:	01204834 	movhi	r4,33056
81107130:	210a0004 	addi	r4,r4,10240
81107134:	1109e800 	call	81109e80 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107138:	0001883a 	nop
8110713c:	e037883a 	mov	sp,fp
81107140:	dfc00117 	ldw	ra,4(sp)
81107144:	df000017 	ldw	fp,0(sp)
81107148:	dec00204 	addi	sp,sp,8
8110714c:	f800283a 	ret

81107150 <vRmapCh7IrqFlagClrWriteCmd>:

void vRmapCh7IrqFlagClrWriteCmd(void) {
81107150:	defffe04 	addi	sp,sp,-8
81107154:	de00012e 	bgeu	sp,et,8110715c <vRmapCh7IrqFlagClrWriteCmd+0xc>
81107158:	003b68fa 	trap	3
8110715c:	dfc00115 	stw	ra,4(sp)
81107160:	df000015 	stw	fp,0(sp)
81107164:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81107168:	01800044 	movi	r6,1
8110716c:	014004c4 	movi	r5,19
81107170:	01204834 	movhi	r4,33056
81107174:	210b0004 	addi	r4,r4,11264
81107178:	1109e800 	call	81109e80 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8110717c:	0001883a 	nop
81107180:	e037883a 	mov	sp,fp
81107184:	dfc00117 	ldw	ra,4(sp)
81107188:	df000017 	ldw	fp,0(sp)
8110718c:	dec00204 	addi	sp,sp,8
81107190:	f800283a 	ret

81107194 <vRmapCh8IrqFlagClrWriteCmd>:

void vRmapCh8IrqFlagClrWriteCmd(void) {
81107194:	defffe04 	addi	sp,sp,-8
81107198:	de00012e 	bgeu	sp,et,811071a0 <vRmapCh8IrqFlagClrWriteCmd+0xc>
8110719c:	003b68fa 	trap	3
811071a0:	dfc00115 	stw	ra,4(sp)
811071a4:	df000015 	stw	fp,0(sp)
811071a8:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811071ac:	01800044 	movi	r6,1
811071b0:	014004c4 	movi	r5,19
811071b4:	01204834 	movhi	r4,33056
811071b8:	210a0004 	addi	r4,r4,10240
811071bc:	1109e800 	call	81109e80 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811071c0:	0001883a 	nop
811071c4:	e037883a 	mov	sp,fp
811071c8:	dfc00117 	ldw	ra,4(sp)
811071cc:	df000017 	ldw	fp,0(sp)
811071d0:	dec00204 	addi	sp,sp,8
811071d4:	f800283a 	ret

811071d8 <bRmapCh1IrqFlagWriteCmd>:

bool bRmapCh1IrqFlagWriteCmd(void) {
811071d8:	defffd04 	addi	sp,sp,-12
811071dc:	de00012e 	bgeu	sp,et,811071e4 <bRmapCh1IrqFlagWriteCmd+0xc>
811071e0:	003b68fa 	trap	3
811071e4:	dfc00215 	stw	ra,8(sp)
811071e8:	df000115 	stw	fp,4(sp)
811071ec:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811071f0:	01400484 	movi	r5,18
811071f4:	01204834 	movhi	r4,33056
811071f8:	210b0004 	addi	r4,r4,11264
811071fc:	1109ed40 	call	81109ed4 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107200:	1080004c 	andi	r2,r2,1
}

bool bRmapCh1IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81107204:	10000326 	beq	r2,zero,81107214 <bRmapCh1IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107208:	00800044 	movi	r2,1
8110720c:	e0bfff15 	stw	r2,-4(fp)
81107210:	00000106 	br	81107218 <bRmapCh1IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107214:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107218:	e0bfff17 	ldw	r2,-4(fp)
}
8110721c:	e037883a 	mov	sp,fp
81107220:	dfc00117 	ldw	ra,4(sp)
81107224:	df000017 	ldw	fp,0(sp)
81107228:	dec00204 	addi	sp,sp,8
8110722c:	f800283a 	ret

81107230 <bRmapCh2IrqFlagWriteCmd>:

bool bRmapCh2IrqFlagWriteCmd(void) {
81107230:	defffd04 	addi	sp,sp,-12
81107234:	de00012e 	bgeu	sp,et,8110723c <bRmapCh2IrqFlagWriteCmd+0xc>
81107238:	003b68fa 	trap	3
8110723c:	dfc00215 	stw	ra,8(sp)
81107240:	df000115 	stw	fp,4(sp)
81107244:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107248:	01400484 	movi	r5,18
8110724c:	01204834 	movhi	r4,33056
81107250:	210a0004 	addi	r4,r4,10240
81107254:	1109ed40 	call	81109ed4 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107258:	1080004c 	andi	r2,r2,1
}

bool bRmapCh2IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
8110725c:	10000326 	beq	r2,zero,8110726c <bRmapCh2IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107260:	00800044 	movi	r2,1
81107264:	e0bfff15 	stw	r2,-4(fp)
81107268:	00000106 	br	81107270 <bRmapCh2IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110726c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107270:	e0bfff17 	ldw	r2,-4(fp)
}
81107274:	e037883a 	mov	sp,fp
81107278:	dfc00117 	ldw	ra,4(sp)
8110727c:	df000017 	ldw	fp,0(sp)
81107280:	dec00204 	addi	sp,sp,8
81107284:	f800283a 	ret

81107288 <bRmapCh3IrqFlagWriteCmd>:

bool bRmapCh3IrqFlagWriteCmd(void) {
81107288:	defffd04 	addi	sp,sp,-12
8110728c:	de00012e 	bgeu	sp,et,81107294 <bRmapCh3IrqFlagWriteCmd+0xc>
81107290:	003b68fa 	trap	3
81107294:	dfc00215 	stw	ra,8(sp)
81107298:	df000115 	stw	fp,4(sp)
8110729c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811072a0:	01400484 	movi	r5,18
811072a4:	01204834 	movhi	r4,33056
811072a8:	210b0004 	addi	r4,r4,11264
811072ac:	1109ed40 	call	81109ed4 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811072b0:	1080004c 	andi	r2,r2,1
}

bool bRmapCh3IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811072b4:	10000326 	beq	r2,zero,811072c4 <bRmapCh3IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811072b8:	00800044 	movi	r2,1
811072bc:	e0bfff15 	stw	r2,-4(fp)
811072c0:	00000106 	br	811072c8 <bRmapCh3IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811072c4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811072c8:	e0bfff17 	ldw	r2,-4(fp)
}
811072cc:	e037883a 	mov	sp,fp
811072d0:	dfc00117 	ldw	ra,4(sp)
811072d4:	df000017 	ldw	fp,0(sp)
811072d8:	dec00204 	addi	sp,sp,8
811072dc:	f800283a 	ret

811072e0 <bRmapCh4IrqFlagWriteCmd>:

bool bRmapCh4IrqFlagWriteCmd(void) {
811072e0:	defffd04 	addi	sp,sp,-12
811072e4:	de00012e 	bgeu	sp,et,811072ec <bRmapCh4IrqFlagWriteCmd+0xc>
811072e8:	003b68fa 	trap	3
811072ec:	dfc00215 	stw	ra,8(sp)
811072f0:	df000115 	stw	fp,4(sp)
811072f4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811072f8:	01400484 	movi	r5,18
811072fc:	01204834 	movhi	r4,33056
81107300:	210a0004 	addi	r4,r4,10240
81107304:	1109ed40 	call	81109ed4 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107308:	1080004c 	andi	r2,r2,1
}

bool bRmapCh4IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8110730c:	10000326 	beq	r2,zero,8110731c <bRmapCh4IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107310:	00800044 	movi	r2,1
81107314:	e0bfff15 	stw	r2,-4(fp)
81107318:	00000106 	br	81107320 <bRmapCh4IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110731c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107320:	e0bfff17 	ldw	r2,-4(fp)
}
81107324:	e037883a 	mov	sp,fp
81107328:	dfc00117 	ldw	ra,4(sp)
8110732c:	df000017 	ldw	fp,0(sp)
81107330:	dec00204 	addi	sp,sp,8
81107334:	f800283a 	ret

81107338 <bRmapCh5IrqFlagWriteCmd>:

bool bRmapCh5IrqFlagWriteCmd(void) {
81107338:	defffd04 	addi	sp,sp,-12
8110733c:	de00012e 	bgeu	sp,et,81107344 <bRmapCh5IrqFlagWriteCmd+0xc>
81107340:	003b68fa 	trap	3
81107344:	dfc00215 	stw	ra,8(sp)
81107348:	df000115 	stw	fp,4(sp)
8110734c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81107350:	01400484 	movi	r5,18
81107354:	01204834 	movhi	r4,33056
81107358:	210b0004 	addi	r4,r4,11264
8110735c:	1109ed40 	call	81109ed4 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107360:	1080004c 	andi	r2,r2,1
}

bool bRmapCh5IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81107364:	10000326 	beq	r2,zero,81107374 <bRmapCh5IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107368:	00800044 	movi	r2,1
8110736c:	e0bfff15 	stw	r2,-4(fp)
81107370:	00000106 	br	81107378 <bRmapCh5IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107374:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107378:	e0bfff17 	ldw	r2,-4(fp)
}
8110737c:	e037883a 	mov	sp,fp
81107380:	dfc00117 	ldw	ra,4(sp)
81107384:	df000017 	ldw	fp,0(sp)
81107388:	dec00204 	addi	sp,sp,8
8110738c:	f800283a 	ret

81107390 <bRmapCh6IrqFlagWriteCmd>:

bool bRmapCh6IrqFlagWriteCmd(void) {
81107390:	defffd04 	addi	sp,sp,-12
81107394:	de00012e 	bgeu	sp,et,8110739c <bRmapCh6IrqFlagWriteCmd+0xc>
81107398:	003b68fa 	trap	3
8110739c:	dfc00215 	stw	ra,8(sp)
811073a0:	df000115 	stw	fp,4(sp)
811073a4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811073a8:	01400484 	movi	r5,18
811073ac:	01204834 	movhi	r4,33056
811073b0:	210a0004 	addi	r4,r4,10240
811073b4:	1109ed40 	call	81109ed4 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811073b8:	1080004c 	andi	r2,r2,1
}

bool bRmapCh6IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811073bc:	10000326 	beq	r2,zero,811073cc <bRmapCh6IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811073c0:	00800044 	movi	r2,1
811073c4:	e0bfff15 	stw	r2,-4(fp)
811073c8:	00000106 	br	811073d0 <bRmapCh6IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811073cc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811073d0:	e0bfff17 	ldw	r2,-4(fp)
}
811073d4:	e037883a 	mov	sp,fp
811073d8:	dfc00117 	ldw	ra,4(sp)
811073dc:	df000017 	ldw	fp,0(sp)
811073e0:	dec00204 	addi	sp,sp,8
811073e4:	f800283a 	ret

811073e8 <bRmapCh7IrqFlagWriteCmd>:

bool bRmapCh7IrqFlagWriteCmd(void) {
811073e8:	defffd04 	addi	sp,sp,-12
811073ec:	de00012e 	bgeu	sp,et,811073f4 <bRmapCh7IrqFlagWriteCmd+0xc>
811073f0:	003b68fa 	trap	3
811073f4:	dfc00215 	stw	ra,8(sp)
811073f8:	df000115 	stw	fp,4(sp)
811073fc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81107400:	01400484 	movi	r5,18
81107404:	01204834 	movhi	r4,33056
81107408:	210b0004 	addi	r4,r4,11264
8110740c:	1109ed40 	call	81109ed4 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107410:	1080004c 	andi	r2,r2,1
}

bool bRmapCh7IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81107414:	10000326 	beq	r2,zero,81107424 <bRmapCh7IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107418:	00800044 	movi	r2,1
8110741c:	e0bfff15 	stw	r2,-4(fp)
81107420:	00000106 	br	81107428 <bRmapCh7IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107424:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107428:	e0bfff17 	ldw	r2,-4(fp)
}
8110742c:	e037883a 	mov	sp,fp
81107430:	dfc00117 	ldw	ra,4(sp)
81107434:	df000017 	ldw	fp,0(sp)
81107438:	dec00204 	addi	sp,sp,8
8110743c:	f800283a 	ret

81107440 <bRmapCh8IrqFlagWriteCmd>:

bool bRmapCh8IrqFlagWriteCmd(void) {
81107440:	defffd04 	addi	sp,sp,-12
81107444:	de00012e 	bgeu	sp,et,8110744c <bRmapCh8IrqFlagWriteCmd+0xc>
81107448:	003b68fa 	trap	3
8110744c:	dfc00215 	stw	ra,8(sp)
81107450:	df000115 	stw	fp,4(sp)
81107454:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81107458:	01400484 	movi	r5,18
8110745c:	01204834 	movhi	r4,33056
81107460:	210a0004 	addi	r4,r4,10240
81107464:	1109ed40 	call	81109ed4 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107468:	1080004c 	andi	r2,r2,1
}

bool bRmapCh8IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
8110746c:	10000326 	beq	r2,zero,8110747c <bRmapCh8IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107470:	00800044 	movi	r2,1
81107474:	e0bfff15 	stw	r2,-4(fp)
81107478:	00000106 	br	81107480 <bRmapCh8IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110747c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107480:	e0bfff17 	ldw	r2,-4(fp)
}
81107484:	e037883a 	mov	sp,fp
81107488:	dfc00117 	ldw	ra,4(sp)
8110748c:	df000017 	ldw	fp,0(sp)
81107490:	dec00204 	addi	sp,sp,8
81107494:	f800283a 	ret

81107498 <uliRmapCh1WriteCmdAddress>:

alt_u32 uliRmapCh1WriteCmdAddress(void) {
81107498:	defffd04 	addi	sp,sp,-12
8110749c:	de00012e 	bgeu	sp,et,811074a4 <uliRmapCh1WriteCmdAddress+0xc>
811074a0:	003b68fa 	trap	3
811074a4:	dfc00215 	stw	ra,8(sp)
811074a8:	df000115 	stw	fp,4(sp)
811074ac:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811074b0:	01400184 	movi	r5,6
811074b4:	01204834 	movhi	r4,33056
811074b8:	210b0004 	addi	r4,r4,11264
811074bc:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811074c0:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_1_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);


	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811074c4:	e13fff17 	ldw	r4,-4(fp)
811074c8:	1109f240 	call	81109f24 <uliConvRmapCfgAddr>
811074cc:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811074d0:	e0bfff17 	ldw	r2,-4(fp)
}
811074d4:	e037883a 	mov	sp,fp
811074d8:	dfc00117 	ldw	ra,4(sp)
811074dc:	df000017 	ldw	fp,0(sp)
811074e0:	dec00204 	addi	sp,sp,8
811074e4:	f800283a 	ret

811074e8 <uliRmapCh2WriteCmdAddress>:

alt_u32 uliRmapCh2WriteCmdAddress(void) {
811074e8:	defffd04 	addi	sp,sp,-12
811074ec:	de00012e 	bgeu	sp,et,811074f4 <uliRmapCh2WriteCmdAddress+0xc>
811074f0:	003b68fa 	trap	3
811074f4:	dfc00215 	stw	ra,8(sp)
811074f8:	df000115 	stw	fp,4(sp)
811074fc:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107500:	01400184 	movi	r5,6
81107504:	01204834 	movhi	r4,33056
81107508:	210a0004 	addi	r4,r4,10240
8110750c:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81107510:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_2_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107514:	e13fff17 	ldw	r4,-4(fp)
81107518:	1109f240 	call	81109f24 <uliConvRmapCfgAddr>
8110751c:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107520:	e0bfff17 	ldw	r2,-4(fp)
}
81107524:	e037883a 	mov	sp,fp
81107528:	dfc00117 	ldw	ra,4(sp)
8110752c:	df000017 	ldw	fp,0(sp)
81107530:	dec00204 	addi	sp,sp,8
81107534:	f800283a 	ret

81107538 <uliRmapCh3WriteCmdAddress>:

alt_u32 uliRmapCh3WriteCmdAddress(void) {
81107538:	defffd04 	addi	sp,sp,-12
8110753c:	de00012e 	bgeu	sp,et,81107544 <uliRmapCh3WriteCmdAddress+0xc>
81107540:	003b68fa 	trap	3
81107544:	dfc00215 	stw	ra,8(sp)
81107548:	df000115 	stw	fp,4(sp)
8110754c:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107550:	01400184 	movi	r5,6
81107554:	01204834 	movhi	r4,33056
81107558:	210b0004 	addi	r4,r4,11264
8110755c:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81107560:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_3_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107564:	e13fff17 	ldw	r4,-4(fp)
81107568:	1109f240 	call	81109f24 <uliConvRmapCfgAddr>
8110756c:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107570:	e0bfff17 	ldw	r2,-4(fp)
}
81107574:	e037883a 	mov	sp,fp
81107578:	dfc00117 	ldw	ra,4(sp)
8110757c:	df000017 	ldw	fp,0(sp)
81107580:	dec00204 	addi	sp,sp,8
81107584:	f800283a 	ret

81107588 <uliRmapCh4WriteCmdAddress>:

alt_u32 uliRmapCh4WriteCmdAddress(void) {
81107588:	defffd04 	addi	sp,sp,-12
8110758c:	de00012e 	bgeu	sp,et,81107594 <uliRmapCh4WriteCmdAddress+0xc>
81107590:	003b68fa 	trap	3
81107594:	dfc00215 	stw	ra,8(sp)
81107598:	df000115 	stw	fp,4(sp)
8110759c:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811075a0:	01400184 	movi	r5,6
811075a4:	01204834 	movhi	r4,33056
811075a8:	210a0004 	addi	r4,r4,10240
811075ac:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811075b0:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_4_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811075b4:	e13fff17 	ldw	r4,-4(fp)
811075b8:	1109f240 	call	81109f24 <uliConvRmapCfgAddr>
811075bc:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811075c0:	e0bfff17 	ldw	r2,-4(fp)
}
811075c4:	e037883a 	mov	sp,fp
811075c8:	dfc00117 	ldw	ra,4(sp)
811075cc:	df000017 	ldw	fp,0(sp)
811075d0:	dec00204 	addi	sp,sp,8
811075d4:	f800283a 	ret

811075d8 <uliRmapCh5WriteCmdAddress>:

alt_u32 uliRmapCh5WriteCmdAddress(void) {
811075d8:	defffd04 	addi	sp,sp,-12
811075dc:	de00012e 	bgeu	sp,et,811075e4 <uliRmapCh5WriteCmdAddress+0xc>
811075e0:	003b68fa 	trap	3
811075e4:	dfc00215 	stw	ra,8(sp)
811075e8:	df000115 	stw	fp,4(sp)
811075ec:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811075f0:	01400184 	movi	r5,6
811075f4:	01204834 	movhi	r4,33056
811075f8:	210b0004 	addi	r4,r4,11264
811075fc:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81107600:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_5_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107604:	e13fff17 	ldw	r4,-4(fp)
81107608:	1109f240 	call	81109f24 <uliConvRmapCfgAddr>
8110760c:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107610:	e0bfff17 	ldw	r2,-4(fp)
}
81107614:	e037883a 	mov	sp,fp
81107618:	dfc00117 	ldw	ra,4(sp)
8110761c:	df000017 	ldw	fp,0(sp)
81107620:	dec00204 	addi	sp,sp,8
81107624:	f800283a 	ret

81107628 <uliRmapCh6WriteCmdAddress>:

alt_u32 uliRmapCh6WriteCmdAddress(void) {
81107628:	defffd04 	addi	sp,sp,-12
8110762c:	de00012e 	bgeu	sp,et,81107634 <uliRmapCh6WriteCmdAddress+0xc>
81107630:	003b68fa 	trap	3
81107634:	dfc00215 	stw	ra,8(sp)
81107638:	df000115 	stw	fp,4(sp)
8110763c:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107640:	01400184 	movi	r5,6
81107644:	01204834 	movhi	r4,33056
81107648:	210a0004 	addi	r4,r4,10240
8110764c:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81107650:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_6_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81107654:	e13fff17 	ldw	r4,-4(fp)
81107658:	1109f240 	call	81109f24 <uliConvRmapCfgAddr>
8110765c:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107660:	e0bfff17 	ldw	r2,-4(fp)
}
81107664:	e037883a 	mov	sp,fp
81107668:	dfc00117 	ldw	ra,4(sp)
8110766c:	df000017 	ldw	fp,0(sp)
81107670:	dec00204 	addi	sp,sp,8
81107674:	f800283a 	ret

81107678 <uliRmapCh7WriteCmdAddress>:

alt_u32 uliRmapCh7WriteCmdAddress(void) {
81107678:	defffd04 	addi	sp,sp,-12
8110767c:	de00012e 	bgeu	sp,et,81107684 <uliRmapCh7WriteCmdAddress+0xc>
81107680:	003b68fa 	trap	3
81107684:	dfc00215 	stw	ra,8(sp)
81107688:	df000115 	stw	fp,4(sp)
8110768c:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107690:	01400184 	movi	r5,6
81107694:	01204834 	movhi	r4,33056
81107698:	210b0004 	addi	r4,r4,11264
8110769c:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811076a0:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_7_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811076a4:	e13fff17 	ldw	r4,-4(fp)
811076a8:	1109f240 	call	81109f24 <uliConvRmapCfgAddr>
811076ac:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811076b0:	e0bfff17 	ldw	r2,-4(fp)
}
811076b4:	e037883a 	mov	sp,fp
811076b8:	dfc00117 	ldw	ra,4(sp)
811076bc:	df000017 	ldw	fp,0(sp)
811076c0:	dec00204 	addi	sp,sp,8
811076c4:	f800283a 	ret

811076c8 <uliRmapCh8WriteCmdAddress>:

alt_u32 uliRmapCh8WriteCmdAddress(void) {
811076c8:	defffd04 	addi	sp,sp,-12
811076cc:	de00012e 	bgeu	sp,et,811076d4 <uliRmapCh8WriteCmdAddress+0xc>
811076d0:	003b68fa 	trap	3
811076d4:	dfc00215 	stw	ra,8(sp)
811076d8:	df000115 	stw	fp,4(sp)
811076dc:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811076e0:	01400184 	movi	r5,6
811076e4:	01204834 	movhi	r4,33056
811076e8:	210a0004 	addi	r4,r4,10240
811076ec:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811076f0:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_8_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811076f4:	e13fff17 	ldw	r4,-4(fp)
811076f8:	1109f240 	call	81109f24 <uliConvRmapCfgAddr>
811076fc:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107700:	e0bfff17 	ldw	r2,-4(fp)
}
81107704:	e037883a 	mov	sp,fp
81107708:	dfc00117 	ldw	ra,4(sp)
8110770c:	df000017 	ldw	fp,0(sp)
81107710:	dec00204 	addi	sp,sp,8
81107714:	f800283a 	ret

81107718 <vRmapInitIrq>:

void vRmapInitIrq(alt_u8 ucCommCh) {
81107718:	defffc04 	addi	sp,sp,-16
8110771c:	de00012e 	bgeu	sp,et,81107724 <vRmapInitIrq+0xc>
81107720:	003b68fa 	trap	3
81107724:	dfc00315 	stw	ra,12(sp)
81107728:	df000215 	stw	fp,8(sp)
8110772c:	df000204 	addi	fp,sp,8
81107730:	2005883a 	mov	r2,r4
81107734:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81107738:	e0bfff03 	ldbu	r2,-4(fp)
8110773c:	10c00228 	cmpgeui	r3,r2,8
81107740:	18004e1e 	bne	r3,zero,8110787c <vRmapInitIrq+0x164>
81107744:	100690ba 	slli	r3,r2,2
81107748:	00a04434 	movhi	r2,33040
8110774c:	109dd704 	addi	r2,r2,30556
81107750:	1885883a 	add	r2,r3,r2
81107754:	10800017 	ldw	r2,0(r2)
81107758:	1000683a 	jmp	r2
8110775c:	8110777c 	xorhi	r4,r16,16861
81107760:	8110779c 	xori	r4,r16,16862
81107764:	811077bc 	xorhi	r4,r16,16862
81107768:	811077dc 	xori	r4,r16,16863
8110776c:	811077fc 	xorhi	r4,r16,16863
81107770:	8110781c 	xori	r4,r16,16864
81107774:	8110783c 	xorhi	r4,r16,16864
81107778:	8110785c 	xori	r4,r16,16865
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
8110777c:	d0a04804 	addi	r2,gp,-32480
81107780:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_RMAP_IRQ, pvHoldContext, vRmapCh1HandleIrq);
81107784:	01a04434 	movhi	r6,33040
81107788:	319b4d04 	addi	r6,r6,27956
8110778c:	e17ffe17 	ldw	r5,-8(fp)
81107790:	010005c4 	movi	r4,23
81107794:	11358000 	call	81135800 <alt_irq_register>
		break;
81107798:	00003806 	br	8110787c <vRmapInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
8110779c:	d0a04904 	addi	r2,gp,-32476
811077a0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_RMAP_IRQ, pvHoldContext, vRmapCh2HandleIrq);
811077a4:	01a04434 	movhi	r6,33040
811077a8:	319b7e04 	addi	r6,r6,28152
811077ac:	e17ffe17 	ldw	r5,-8(fp)
811077b0:	01000544 	movi	r4,21
811077b4:	11358000 	call	81135800 <alt_irq_register>
		break;
811077b8:	00003006 	br	8110787c <vRmapInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
811077bc:	d0a04a04 	addi	r2,gp,-32472
811077c0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_RMAP_IRQ, pvHoldContext, vRmapCh3HandleIrq);
811077c4:	01a04434 	movhi	r6,33040
811077c8:	319b8e04 	addi	r6,r6,28216
811077cc:	e17ffe17 	ldw	r5,-8(fp)
811077d0:	010004c4 	movi	r4,19
811077d4:	11358000 	call	81135800 <alt_irq_register>
		break;
811077d8:	00002806 	br	8110787c <vRmapInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
811077dc:	d0a04b04 	addi	r2,gp,-32468
811077e0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_RMAP_IRQ, pvHoldContext, vRmapCh4HandleIrq);
811077e4:	01a04434 	movhi	r6,33040
811077e8:	319b9e04 	addi	r6,r6,28280
811077ec:	e17ffe17 	ldw	r5,-8(fp)
811077f0:	01000444 	movi	r4,17
811077f4:	11358000 	call	81135800 <alt_irq_register>
		break;
811077f8:	00002006 	br	8110787c <vRmapInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
811077fc:	d0a04c04 	addi	r2,gp,-32464
81107800:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_RMAP_IRQ, pvHoldContext, vRmapCh5HandleIrq);
81107804:	01a04434 	movhi	r6,33040
81107808:	319bae04 	addi	r6,r6,28344
8110780c:	e17ffe17 	ldw	r5,-8(fp)
81107810:	01000244 	movi	r4,9
81107814:	11358000 	call	81135800 <alt_irq_register>
		break;
81107818:	00001806 	br	8110787c <vRmapInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
8110781c:	d0a04d04 	addi	r2,gp,-32460
81107820:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_RMAP_IRQ, pvHoldContext, vRmapCh6HandleIrq);
81107824:	01a04434 	movhi	r6,33040
81107828:	319bbe04 	addi	r6,r6,28408
8110782c:	e17ffe17 	ldw	r5,-8(fp)
81107830:	010001c4 	movi	r4,7
81107834:	11358000 	call	81135800 <alt_irq_register>
		break;
81107838:	00001006 	br	8110787c <vRmapInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
8110783c:	d0a04e04 	addi	r2,gp,-32456
81107840:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_RMAP_IRQ, pvHoldContext, vRmapCh7HandleIrq);
81107844:	01a04434 	movhi	r6,33040
81107848:	319bce04 	addi	r6,r6,28472
8110784c:	e17ffe17 	ldw	r5,-8(fp)
81107850:	01000104 	movi	r4,4
81107854:	11358000 	call	81135800 <alt_irq_register>
		break;
81107858:	00000806 	br	8110787c <vRmapInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
8110785c:	d0a04f04 	addi	r2,gp,-32452
81107860:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_RMAP_IRQ, pvHoldContext, vRmapCh8HandleIrq);
81107864:	01a04434 	movhi	r6,33040
81107868:	319bde04 	addi	r6,r6,28536
8110786c:	e17ffe17 	ldw	r5,-8(fp)
81107870:	010000c4 	movi	r4,3
81107874:	11358000 	call	81135800 <alt_irq_register>
		break;
81107878:	0001883a 	nop
	}
}
8110787c:	0001883a 	nop
81107880:	e037883a 	mov	sp,fp
81107884:	dfc00117 	ldw	ra,4(sp)
81107888:	df000017 	ldw	fp,0(sp)
8110788c:	dec00204 	addi	sp,sp,8
81107890:	f800283a 	ret

81107894 <bRmapSetIrqControl>:

bool bRmapSetIrqControl(TRmapChannel *pxRmapCh) {
81107894:	defffb04 	addi	sp,sp,-20
81107898:	de00012e 	bgeu	sp,et,811078a0 <bRmapSetIrqControl+0xc>
8110789c:	003b68fa 	trap	3
811078a0:	dfc00415 	stw	ra,16(sp)
811078a4:	df000315 	stw	fp,12(sp)
811078a8:	df000304 	addi	fp,sp,12
811078ac:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811078b0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811078b4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811078b8:	e0bfff17 	ldw	r2,-4(fp)
811078bc:	10001926 	beq	r2,zero,81107924 <bRmapSetIrqControl+0x90>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811078c0:	e0bfff17 	ldw	r2,-4(fp)
811078c4:	10800017 	ldw	r2,0(r2)
811078c8:	01400444 	movi	r5,17
811078cc:	1009883a 	mov	r4,r2
811078d0:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811078d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxRmapCh->xRmapIrqControl.bWriteCmdEn) {
811078d8:	e0bfff17 	ldw	r2,-4(fp)
811078dc:	10801017 	ldw	r2,64(r2)
811078e0:	10000426 	beq	r2,zero,811078f4 <bRmapSetIrqControl+0x60>
			uliReg |= COMM_IRQ_RMAP_WRCMD_EN_MSK;
811078e4:	e0bffe17 	ldw	r2,-8(fp)
811078e8:	10800054 	ori	r2,r2,1
811078ec:	e0bffe15 	stw	r2,-8(fp)
811078f0:	00000406 	br	81107904 <bRmapSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_RMAP_WRCMD_EN_MSK);
811078f4:	e0fffe17 	ldw	r3,-8(fp)
811078f8:	00bfff84 	movi	r2,-2
811078fc:	1884703a 	and	r2,r3,r2
81107900:	e0bffe15 	stw	r2,-8(fp)
		}

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_IRQ_CONTROL_REG_OFST,
81107904:	e0bfff17 	ldw	r2,-4(fp)
81107908:	10800017 	ldw	r2,0(r2)
8110790c:	e1bffe17 	ldw	r6,-8(fp)
81107910:	01400444 	movi	r5,17
81107914:	1009883a 	mov	r4,r2
81107918:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);
		bStatus = TRUE;
8110791c:	00800044 	movi	r2,1
81107920:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107924:	e0bffd17 	ldw	r2,-12(fp)
}
81107928:	e037883a 	mov	sp,fp
8110792c:	dfc00117 	ldw	ra,4(sp)
81107930:	df000017 	ldw	fp,0(sp)
81107934:	dec00204 	addi	sp,sp,8
81107938:	f800283a 	ret

8110793c <bRmapGetIrqControl>:

bool bRmapGetIrqControl(TRmapChannel *pxRmapCh) {
8110793c:	defffb04 	addi	sp,sp,-20
81107940:	de00012e 	bgeu	sp,et,81107948 <bRmapGetIrqControl+0xc>
81107944:	003b68fa 	trap	3
81107948:	dfc00415 	stw	ra,16(sp)
8110794c:	df000315 	stw	fp,12(sp)
81107950:	df000304 	addi	fp,sp,12
81107954:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107958:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110795c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107960:	e0bfff17 	ldw	r2,-4(fp)
81107964:	10001126 	beq	r2,zero,811079ac <bRmapGetIrqControl+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107968:	e0bfff17 	ldw	r2,-4(fp)
8110796c:	10800017 	ldw	r2,0(r2)
81107970:	01400444 	movi	r5,17
81107974:	1009883a 	mov	r4,r2
81107978:	1109ed40 	call	81109ed4 <uliRmapReadReg>
8110797c:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_EN_MSK) {
81107980:	e0bffe17 	ldw	r2,-8(fp)
81107984:	1080004c 	andi	r2,r2,1
81107988:	10000426 	beq	r2,zero,8110799c <bRmapGetIrqControl+0x60>
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
8110798c:	e0bfff17 	ldw	r2,-4(fp)
81107990:	00c00044 	movi	r3,1
81107994:	10c01015 	stw	r3,64(r2)
81107998:	00000206 	br	811079a4 <bRmapGetIrqControl+0x68>
		} else {
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
8110799c:	e0bfff17 	ldw	r2,-4(fp)
811079a0:	10001015 	stw	zero,64(r2)
		}

		bStatus = TRUE;
811079a4:	00800044 	movi	r2,1
811079a8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811079ac:	e0bffd17 	ldw	r2,-12(fp)
}
811079b0:	e037883a 	mov	sp,fp
811079b4:	dfc00117 	ldw	ra,4(sp)
811079b8:	df000017 	ldw	fp,0(sp)
811079bc:	dec00204 	addi	sp,sp,8
811079c0:	f800283a 	ret

811079c4 <bRmapGetIrqFlags>:

bool bRmapGetIrqFlags(TRmapChannel *pxRmapCh) {
811079c4:	defffb04 	addi	sp,sp,-20
811079c8:	de00012e 	bgeu	sp,et,811079d0 <bRmapGetIrqFlags+0xc>
811079cc:	003b68fa 	trap	3
811079d0:	dfc00415 	stw	ra,16(sp)
811079d4:	df000315 	stw	fp,12(sp)
811079d8:	df000304 	addi	fp,sp,12
811079dc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811079e0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811079e4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811079e8:	e0bfff17 	ldw	r2,-4(fp)
811079ec:	10001126 	beq	r2,zero,81107a34 <bRmapGetIrqFlags+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811079f0:	e0bfff17 	ldw	r2,-4(fp)
811079f4:	10800017 	ldw	r2,0(r2)
811079f8:	01400484 	movi	r5,18
811079fc:	1009883a 	mov	r4,r2
81107a00:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81107a04:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107a08:	e0bffe17 	ldw	r2,-8(fp)
81107a0c:	1080004c 	andi	r2,r2,1
81107a10:	10000426 	beq	r2,zero,81107a24 <bRmapGetIrqFlags+0x60>
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = TRUE;
81107a14:	e0bfff17 	ldw	r2,-4(fp)
81107a18:	00c00044 	movi	r3,1
81107a1c:	10c01115 	stw	r3,68(r2)
81107a20:	00000206 	br	81107a2c <bRmapGetIrqFlags+0x68>
		} else {
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = FALSE;
81107a24:	e0bfff17 	ldw	r2,-4(fp)
81107a28:	10001115 	stw	zero,68(r2)
		}

		bStatus = TRUE;
81107a2c:	00800044 	movi	r2,1
81107a30:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107a34:	e0bffd17 	ldw	r2,-12(fp)
}
81107a38:	e037883a 	mov	sp,fp
81107a3c:	dfc00117 	ldw	ra,4(sp)
81107a40:	df000017 	ldw	fp,0(sp)
81107a44:	dec00204 	addi	sp,sp,8
81107a48:	f800283a 	ret

81107a4c <bRmapSetCodecConfig>:

bool bRmapSetCodecConfig(TRmapChannel *pxRmapCh) {
81107a4c:	defffb04 	addi	sp,sp,-20
81107a50:	de00012e 	bgeu	sp,et,81107a58 <bRmapSetCodecConfig+0xc>
81107a54:	003b68fa 	trap	3
81107a58:	dfc00415 	stw	ra,16(sp)
81107a5c:	df000315 	stw	fp,12(sp)
81107a60:	df000304 	addi	fp,sp,12
81107a64:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107a68:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107a6c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107a70:	e0bfff17 	ldw	r2,-4(fp)
81107a74:	10002526 	beq	r2,zero,81107b0c <bRmapSetCodecConfig+0xc0>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107a78:	e0bfff17 	ldw	r2,-4(fp)
81107a7c:	10800017 	ldw	r2,0(r2)
81107a80:	01400104 	movi	r5,4
81107a84:	1009883a 	mov	r4,r2
81107a88:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81107a8c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
81107a90:	e0fffe17 	ldw	r3,-8(fp)
81107a94:	00bfc004 	movi	r2,-256
81107a98:	1884703a 	and	r2,r3,r2
81107a9c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
81107aa0:	e0bfff17 	ldw	r2,-4(fp)
81107aa4:	10800143 	ldbu	r2,5(r2)
81107aa8:	10803fcc 	andi	r2,r2,255

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
81107aac:	e0fffe17 	ldw	r3,-8(fp)
81107ab0:	1884b03a 	or	r2,r3,r2
81107ab4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
81107ab8:	e0fffe17 	ldw	r3,-8(fp)
81107abc:	00bffff4 	movhi	r2,65535
81107ac0:	10803fc4 	addi	r2,r2,255
81107ac4:	1884703a 	and	r2,r3,r2
81107ac8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));
81107acc:	e0bfff17 	ldw	r2,-4(fp)
81107ad0:	10800103 	ldbu	r2,4(r2)
81107ad4:	10803fcc 	andi	r2,r2,255
81107ad8:	1004923a 	slli	r2,r2,8
81107adc:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
81107ae0:	e0fffe17 	ldw	r3,-8(fp)
81107ae4:	1884b03a 	or	r2,r3,r2
81107ae8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CODEC_CFG_REG_OFST,
81107aec:	e0bfff17 	ldw	r2,-4(fp)
81107af0:	10800017 	ldw	r2,0(r2)
81107af4:	e1bffe17 	ldw	r6,-8(fp)
81107af8:	01400104 	movi	r5,4
81107afc:	1009883a 	mov	r4,r2
81107b00:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81107b04:	00800044 	movi	r2,1
81107b08:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107b0c:	e0bffd17 	ldw	r2,-12(fp)
}
81107b10:	e037883a 	mov	sp,fp
81107b14:	dfc00117 	ldw	ra,4(sp)
81107b18:	df000017 	ldw	fp,0(sp)
81107b1c:	dec00204 	addi	sp,sp,8
81107b20:	f800283a 	ret

81107b24 <bRmapGetCodecConfig>:

bool bRmapGetCodecConfig(TRmapChannel *pxRmapCh) {
81107b24:	defffb04 	addi	sp,sp,-20
81107b28:	de00012e 	bgeu	sp,et,81107b30 <bRmapGetCodecConfig+0xc>
81107b2c:	003b68fa 	trap	3
81107b30:	dfc00415 	stw	ra,16(sp)
81107b34:	df000315 	stw	fp,12(sp)
81107b38:	df000304 	addi	fp,sp,12
81107b3c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107b40:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107b44:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107b48:	e0bfff17 	ldw	r2,-4(fp)
81107b4c:	10001226 	beq	r2,zero,81107b98 <bRmapGetCodecConfig+0x74>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b50:	e0bfff17 	ldw	r2,-4(fp)
81107b54:	10800017 	ldw	r2,0(r2)
81107b58:	01400104 	movi	r5,4
81107b5c:	1009883a 	mov	r4,r2
81107b60:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81107b64:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
81107b68:	e0bffe17 	ldw	r2,-8(fp)
81107b6c:	1007883a 	mov	r3,r2
81107b70:	e0bfff17 	ldw	r2,-4(fp)
81107b74:	10c00145 	stb	r3,5(r2)
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);
81107b78:	e0bffe17 	ldw	r2,-8(fp)
81107b7c:	10bfc00c 	andi	r2,r2,65280
81107b80:	1004d23a 	srli	r2,r2,8
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
81107b84:	1007883a 	mov	r3,r2
81107b88:	e0bfff17 	ldw	r2,-4(fp)
81107b8c:	10c00105 	stb	r3,4(r2)
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);

		bStatus = TRUE;
81107b90:	00800044 	movi	r2,1
81107b94:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107b98:	e0bffd17 	ldw	r2,-12(fp)
}
81107b9c:	e037883a 	mov	sp,fp
81107ba0:	dfc00117 	ldw	ra,4(sp)
81107ba4:	df000017 	ldw	fp,0(sp)
81107ba8:	dec00204 	addi	sp,sp,8
81107bac:	f800283a 	ret

81107bb0 <bRmapGetCodecStatus>:

bool bRmapGetCodecStatus(TRmapChannel *pxRmapCh) {
81107bb0:	defffb04 	addi	sp,sp,-20
81107bb4:	de00012e 	bgeu	sp,et,81107bbc <bRmapGetCodecStatus+0xc>
81107bb8:	003b68fa 	trap	3
81107bbc:	dfc00415 	stw	ra,16(sp)
81107bc0:	df000315 	stw	fp,12(sp)
81107bc4:	df000304 	addi	fp,sp,12
81107bc8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107bcc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107bd0:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107bd4:	e0bfff17 	ldw	r2,-4(fp)
81107bd8:	10004726 	beq	r2,zero,81107cf8 <bRmapGetCodecStatus+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107bdc:	e0bfff17 	ldw	r2,-4(fp)
81107be0:	10800017 	ldw	r2,0(r2)
81107be4:	01400144 	movi	r5,5
81107be8:	1009883a 	mov	r4,r2
81107bec:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81107bf0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_STAT_CMD_RECEIVED_MSK) {
81107bf4:	e0bffe17 	ldw	r2,-8(fp)
81107bf8:	1080004c 	andi	r2,r2,1
81107bfc:	10000426 	beq	r2,zero,81107c10 <bRmapGetCodecStatus+0x60>
			pxRmapCh->xRmapCodecStatus.bCommandReceived = TRUE;
81107c00:	e0bfff17 	ldw	r2,-4(fp)
81107c04:	00c00044 	movi	r3,1
81107c08:	10c00215 	stw	r3,8(r2)
81107c0c:	00000206 	br	81107c18 <bRmapGetCodecStatus+0x68>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81107c10:	e0bfff17 	ldw	r2,-4(fp)
81107c14:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_REQ_MSK) {
81107c18:	e0bffe17 	ldw	r2,-8(fp)
81107c1c:	1080008c 	andi	r2,r2,2
81107c20:	10000426 	beq	r2,zero,81107c34 <bRmapGetCodecStatus+0x84>
			pxRmapCh->xRmapCodecStatus.bWriteRequested = TRUE;
81107c24:	e0bfff17 	ldw	r2,-4(fp)
81107c28:	00c00044 	movi	r3,1
81107c2c:	10c00315 	stw	r3,12(r2)
81107c30:	00000206 	br	81107c3c <bRmapGetCodecStatus+0x8c>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteRequested = FALSE;
81107c34:	e0bfff17 	ldw	r2,-4(fp)
81107c38:	10000315 	stw	zero,12(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_AUTH_MSK) {
81107c3c:	e0bffe17 	ldw	r2,-8(fp)
81107c40:	1080010c 	andi	r2,r2,4
81107c44:	10000426 	beq	r2,zero,81107c58 <bRmapGetCodecStatus+0xa8>
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = TRUE;
81107c48:	e0bfff17 	ldw	r2,-4(fp)
81107c4c:	00c00044 	movi	r3,1
81107c50:	10c00415 	stw	r3,16(r2)
81107c54:	00000206 	br	81107c60 <bRmapGetCodecStatus+0xb0>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = FALSE;
81107c58:	e0bfff17 	ldw	r2,-4(fp)
81107c5c:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_REQ_MSK) {
81107c60:	e0bffe17 	ldw	r2,-8(fp)
81107c64:	1080020c 	andi	r2,r2,8
81107c68:	10000426 	beq	r2,zero,81107c7c <bRmapGetCodecStatus+0xcc>
			pxRmapCh->xRmapCodecStatus.bReadRequested = TRUE;
81107c6c:	e0bfff17 	ldw	r2,-4(fp)
81107c70:	00c00044 	movi	r3,1
81107c74:	10c00515 	stw	r3,20(r2)
81107c78:	00000206 	br	81107c84 <bRmapGetCodecStatus+0xd4>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadRequested = FALSE;
81107c7c:	e0bfff17 	ldw	r2,-4(fp)
81107c80:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_AUTH_MSK) {
81107c84:	e0bffe17 	ldw	r2,-8(fp)
81107c88:	1080040c 	andi	r2,r2,16
81107c8c:	10000426 	beq	r2,zero,81107ca0 <bRmapGetCodecStatus+0xf0>
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = TRUE;
81107c90:	e0bfff17 	ldw	r2,-4(fp)
81107c94:	00c00044 	movi	r3,1
81107c98:	10c00615 	stw	r3,24(r2)
81107c9c:	00000206 	br	81107ca8 <bRmapGetCodecStatus+0xf8>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = FALSE;
81107ca0:	e0bfff17 	ldw	r2,-4(fp)
81107ca4:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_RMAP_STAT_REPLY_SEND_MSK) {
81107ca8:	e0bffe17 	ldw	r2,-8(fp)
81107cac:	1080080c 	andi	r2,r2,32
81107cb0:	10000426 	beq	r2,zero,81107cc4 <bRmapGetCodecStatus+0x114>
			pxRmapCh->xRmapCodecStatus.bReplySended = TRUE;
81107cb4:	e0bfff17 	ldw	r2,-4(fp)
81107cb8:	00c00044 	movi	r3,1
81107cbc:	10c00715 	stw	r3,28(r2)
81107cc0:	00000206 	br	81107ccc <bRmapGetCodecStatus+0x11c>
		} else {
			pxRmapCh->xRmapCodecStatus.bReplySended = FALSE;
81107cc4:	e0bfff17 	ldw	r2,-4(fp)
81107cc8:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_RMAP_STAT_DISCARD_PKG_MSK) {
81107ccc:	e0bffe17 	ldw	r2,-8(fp)
81107cd0:	1080100c 	andi	r2,r2,64
81107cd4:	10000426 	beq	r2,zero,81107ce8 <bRmapGetCodecStatus+0x138>
			pxRmapCh->xRmapCodecStatus.bDiscardedPackage = TRUE;
81107cd8:	e0bfff17 	ldw	r2,-4(fp)
81107cdc:	00c00044 	movi	r3,1
81107ce0:	10c00815 	stw	r3,32(r2)
81107ce4:	00000206 	br	81107cf0 <bRmapGetCodecStatus+0x140>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81107ce8:	e0bfff17 	ldw	r2,-4(fp)
81107cec:	10000215 	stw	zero,8(r2)
		}

		bStatus = TRUE;
81107cf0:	00800044 	movi	r2,1
81107cf4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107cf8:	e0bffd17 	ldw	r2,-12(fp)
}
81107cfc:	e037883a 	mov	sp,fp
81107d00:	dfc00117 	ldw	ra,4(sp)
81107d04:	df000017 	ldw	fp,0(sp)
81107d08:	dec00204 	addi	sp,sp,8
81107d0c:	f800283a 	ret

81107d10 <bRmapGetCodecError>:

bool bRmapGetCodecError(TRmapChannel *pxRmapCh) {
81107d10:	defffb04 	addi	sp,sp,-20
81107d14:	de00012e 	bgeu	sp,et,81107d1c <bRmapGetCodecError+0xc>
81107d18:	003b68fa 	trap	3
81107d1c:	dfc00415 	stw	ra,16(sp)
81107d20:	df000315 	stw	fp,12(sp)
81107d24:	df000304 	addi	fp,sp,12
81107d28:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107d2c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107d30:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107d34:	e0bfff17 	ldw	r2,-4(fp)
81107d38:	10004726 	beq	r2,zero,81107e58 <bRmapGetCodecError+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d3c:	e0bfff17 	ldw	r2,-4(fp)
81107d40:	10800017 	ldw	r2,0(r2)
81107d44:	01400144 	movi	r5,5
81107d48:	1009883a 	mov	r4,r2
81107d4c:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81107d50:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_ERR_EARLY_EOP_MSK) {
81107d54:	e0bffe17 	ldw	r2,-8(fp)
81107d58:	1080006c 	andhi	r2,r2,1
81107d5c:	10000426 	beq	r2,zero,81107d70 <bRmapGetCodecError+0x60>
			pxRmapCh->xRmapCodecError.bEarlyEop = TRUE;
81107d60:	e0bfff17 	ldw	r2,-4(fp)
81107d64:	00c00044 	movi	r3,1
81107d68:	10c00915 	stw	r3,36(r2)
81107d6c:	00000206 	br	81107d78 <bRmapGetCodecError+0x68>
		} else {
			pxRmapCh->xRmapCodecError.bEarlyEop = FALSE;
81107d70:	e0bfff17 	ldw	r2,-4(fp)
81107d74:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_RMAP_ERR_EEP_MSK) {
81107d78:	e0bffe17 	ldw	r2,-8(fp)
81107d7c:	108000ac 	andhi	r2,r2,2
81107d80:	10000426 	beq	r2,zero,81107d94 <bRmapGetCodecError+0x84>
			pxRmapCh->xRmapCodecError.bEep = TRUE;
81107d84:	e0bfff17 	ldw	r2,-4(fp)
81107d88:	00c00044 	movi	r3,1
81107d8c:	10c00a15 	stw	r3,40(r2)
81107d90:	00000206 	br	81107d9c <bRmapGetCodecError+0x8c>
		} else {
			pxRmapCh->xRmapCodecError.bEep = FALSE;
81107d94:	e0bfff17 	ldw	r2,-4(fp)
81107d98:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_RMAP_ERR_HEADER_CRC_MSK) {
81107d9c:	e0bffe17 	ldw	r2,-8(fp)
81107da0:	1080012c 	andhi	r2,r2,4
81107da4:	10000426 	beq	r2,zero,81107db8 <bRmapGetCodecError+0xa8>
			pxRmapCh->xRmapCodecError.bHeaderCRC = TRUE;
81107da8:	e0bfff17 	ldw	r2,-4(fp)
81107dac:	00c00044 	movi	r3,1
81107db0:	10c00b15 	stw	r3,44(r2)
81107db4:	00000206 	br	81107dc0 <bRmapGetCodecError+0xb0>
		} else {
			pxRmapCh->xRmapCodecError.bHeaderCRC = FALSE;
81107db8:	e0bfff17 	ldw	r2,-4(fp)
81107dbc:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_RMAP_ERR_UNUSED_PKT_MSK) {
81107dc0:	e0bffe17 	ldw	r2,-8(fp)
81107dc4:	1080022c 	andhi	r2,r2,8
81107dc8:	10000426 	beq	r2,zero,81107ddc <bRmapGetCodecError+0xcc>
			pxRmapCh->xRmapCodecError.bUnusedPacketType = TRUE;
81107dcc:	e0bfff17 	ldw	r2,-4(fp)
81107dd0:	00c00044 	movi	r3,1
81107dd4:	10c00c15 	stw	r3,48(r2)
81107dd8:	00000206 	br	81107de4 <bRmapGetCodecError+0xd4>
		} else {
			pxRmapCh->xRmapCodecError.bUnusedPacketType = FALSE;
81107ddc:	e0bfff17 	ldw	r2,-4(fp)
81107de0:	10000c15 	stw	zero,48(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_CMD_MSK) {
81107de4:	e0bffe17 	ldw	r2,-8(fp)
81107de8:	1080042c 	andhi	r2,r2,16
81107dec:	10000426 	beq	r2,zero,81107e00 <bRmapGetCodecError+0xf0>
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = TRUE;
81107df0:	e0bfff17 	ldw	r2,-4(fp)
81107df4:	00c00044 	movi	r3,1
81107df8:	10c00d15 	stw	r3,52(r2)
81107dfc:	00000206 	br	81107e08 <bRmapGetCodecError+0xf8>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = FALSE;
81107e00:	e0bfff17 	ldw	r2,-4(fp)
81107e04:	10000d15 	stw	zero,52(r2)
		}
		if (uliReg & COMM_RMAP_ERR_TOO_MUCH_DATA_MSK) {
81107e08:	e0bffe17 	ldw	r2,-8(fp)
81107e0c:	1080082c 	andhi	r2,r2,32
81107e10:	10000426 	beq	r2,zero,81107e24 <bRmapGetCodecError+0x114>
			pxRmapCh->xRmapCodecError.bTooMuchData = TRUE;
81107e14:	e0bfff17 	ldw	r2,-4(fp)
81107e18:	00c00044 	movi	r3,1
81107e1c:	10c00e15 	stw	r3,56(r2)
81107e20:	00000206 	br	81107e2c <bRmapGetCodecError+0x11c>
		} else {
			pxRmapCh->xRmapCodecError.bTooMuchData = FALSE;
81107e24:	e0bfff17 	ldw	r2,-4(fp)
81107e28:	10000e15 	stw	zero,56(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_DCRC_MSK) {
81107e2c:	e0bffe17 	ldw	r2,-8(fp)
81107e30:	1080102c 	andhi	r2,r2,64
81107e34:	10000426 	beq	r2,zero,81107e48 <bRmapGetCodecError+0x138>
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = TRUE;
81107e38:	e0bfff17 	ldw	r2,-4(fp)
81107e3c:	00c00044 	movi	r3,1
81107e40:	10c00f15 	stw	r3,60(r2)
81107e44:	00000206 	br	81107e50 <bRmapGetCodecError+0x140>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = FALSE;
81107e48:	e0bfff17 	ldw	r2,-4(fp)
81107e4c:	10000f15 	stw	zero,60(r2)
		}

		bStatus = TRUE;
81107e50:	00800044 	movi	r2,1
81107e54:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107e58:	e0bffd17 	ldw	r2,-12(fp)
}
81107e5c:	e037883a 	mov	sp,fp
81107e60:	dfc00117 	ldw	ra,4(sp)
81107e64:	df000017 	ldw	fp,0(sp)
81107e68:	dec00204 	addi	sp,sp,8
81107e6c:	f800283a 	ret

81107e70 <bRmapSetMemConfigArea>:

bool bRmapSetMemConfigArea(TRmapChannel *pxRmapCh) {
81107e70:	defffb04 	addi	sp,sp,-20
81107e74:	de00012e 	bgeu	sp,et,81107e7c <bRmapSetMemConfigArea+0xc>
81107e78:	003b68fa 	trap	3
81107e7c:	dfc00415 	stw	ra,16(sp)
81107e80:	df000315 	stw	fp,12(sp)
81107e84:	df000304 	addi	fp,sp,12
81107e88:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107e8c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107e90:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107e94:	e0bfff17 	ldw	r2,-4(fp)
81107e98:	1000aa26 	beq	r2,zero,81108144 <bRmapSetMemConfigArea+0x2d4>

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config;
81107e9c:	e0bfff17 	ldw	r2,-4(fp)
81107ea0:	10801217 	ldw	r2,72(r2)
81107ea4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_REGCLK_DIR_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 3));
//			uliReg &= (~COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 4));
//			uliReg &= (~COMM_RMAP_REGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 20));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107ea8:	e0bfff17 	ldw	r2,-4(fp)
81107eac:	10800017 	ldw	r2,0(r2)
81107eb0:	e1bffe17 	ldw	r6,-8(fp)
81107eb4:	01401004 	movi	r5,64
81107eb8:	1009883a 	mov	r4,r2
81107ebc:	1109e800 	call	81109e80 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config;
81107ec0:	e0bfff17 	ldw	r2,-4(fp)
81107ec4:	10801317 	ldw	r2,76(r2)
81107ec8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK);
//			uliReg |= (COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107ecc:	e0bfff17 	ldw	r2,-4(fp)
81107ed0:	10800017 	ldw	r2,0(r2)
81107ed4:	e1bffe17 	ldw	r6,-8(fp)
81107ed8:	01401044 	movi	r5,65
81107edc:	1009883a 	mov	r4,r2
81107ee0:	1109e800 	call	81109e80 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config;
81107ee4:	e0bfff17 	ldw	r2,-4(fp)
81107ee8:	10801417 	ldw	r2,80(r2)
81107eec:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_DIGITISE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_PACKET_SIZE_CTRL_MSK);
//			uliReg |= (COMM_RMAP_PACKET_SIZE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107ef0:	e0bfff17 	ldw	r2,-4(fp)
81107ef4:	10800017 	ldw	r2,0(r2)
81107ef8:	e1bffe17 	ldw	r6,-8(fp)
81107efc:	01401084 	movi	r5,66
81107f00:	1009883a 	mov	r4,r2
81107f04:	1109e800 	call	81109e80 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config;
81107f08:	e0bfff17 	ldw	r2,-4(fp)
81107f0c:	10801517 	ldw	r2,84(r2)
81107f10:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f14:	e0bfff17 	ldw	r2,-4(fp)
81107f18:	10800017 	ldw	r2,0(r2)
81107f1c:	e1bffe17 	ldw	r6,-8(fp)
81107f20:	014010c4 	movi	r5,67
81107f24:	1009883a 	mov	r4,r2
81107f28:	1109e800 	call	81109e80 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107f2c:	e0bfff17 	ldw	r2,-4(fp)
81107f30:	10802217 	ldw	r2,136(r2)
81107f34:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f38:	e0bfff17 	ldw	r2,-4(fp)
81107f3c:	10800017 	ldw	r2,0(r2)
81107f40:	e1bffe17 	ldw	r6,-8(fp)
81107f44:	01401104 	movi	r5,68
81107f48:	1009883a 	mov	r4,r2
81107f4c:	1109e800 	call	81109e80 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config;
81107f50:	e0bfff17 	ldw	r2,-4(fp)
81107f54:	10801717 	ldw	r2,92(r2)
81107f58:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f5c:	e0bfff17 	ldw	r2,-4(fp)
81107f60:	10800017 	ldw	r2,0(r2)
81107f64:	e1bffe17 	ldw	r6,-8(fp)
81107f68:	01401144 	movi	r5,69
81107f6c:	1009883a 	mov	r4,r2
81107f70:	1109e800 	call	81109e80 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config;
81107f74:	e0bfff17 	ldw	r2,-4(fp)
81107f78:	10801817 	ldw	r2,96(r2)
81107f7c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f80:	e0bfff17 	ldw	r2,-4(fp)
81107f84:	10800017 	ldw	r2,0(r2)
81107f88:	e1bffe17 	ldw	r6,-8(fp)
81107f8c:	01401184 	movi	r5,70
81107f90:	1009883a 	mov	r4,r2
81107f94:	1109e800 	call	81109e80 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config;
81107f98:	e0bfff17 	ldw	r2,-4(fp)
81107f9c:	10801917 	ldw	r2,100(r2)
81107fa0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107fa4:	e0bfff17 	ldw	r2,-4(fp)
81107fa8:	10800017 	ldw	r2,0(r2)
81107fac:	e1bffe17 	ldw	r6,-8(fp)
81107fb0:	014011c4 	movi	r5,71
81107fb4:	1009883a 	mov	r4,r2
81107fb8:	1109e800 	call	81109e80 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config;
81107fbc:	e0bfff17 	ldw	r2,-4(fp)
81107fc0:	10801a17 	ldw	r2,104(r2)
81107fc4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107fc8:	e0bfff17 	ldw	r2,-4(fp)
81107fcc:	10800017 	ldw	r2,0(r2)
81107fd0:	e1bffe17 	ldw	r6,-8(fp)
81107fd4:	01401204 	movi	r5,72
81107fd8:	1009883a 	mov	r4,r2
81107fdc:	1109e800 	call	81109e80 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config;
81107fe0:	e0bfff17 	ldw	r2,-4(fp)
81107fe4:	10801b17 	ldw	r2,108(r2)
81107fe8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107fec:	e0bfff17 	ldw	r2,-4(fp)
81107ff0:	10800017 	ldw	r2,0(r2)
81107ff4:	e1bffe17 	ldw	r6,-8(fp)
81107ff8:	01401244 	movi	r5,73
81107ffc:	1009883a 	mov	r4,r2
81108000:	1109e800 	call	81109e80 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST, uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108004:	e0bfff17 	ldw	r2,-4(fp)
81108008:	10800017 	ldw	r2,0(r2)
8110800c:	01401284 	movi	r5,74
81108010:	1009883a 	mov	r4,r2
81108014:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108018:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config;
8110801c:	e0bfff17 	ldw	r2,-4(fp)
81108020:	10801c17 	ldw	r2,112(r2)
81108024:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81108028:	e0bfff17 	ldw	r2,-4(fp)
8110802c:	10800017 	ldw	r2,0(r2)
81108030:	e1bffe17 	ldw	r6,-8(fp)
81108034:	01401284 	movi	r5,74
81108038:	1009883a 	mov	r4,r2
8110803c:	1109e800 	call	81109e80 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config;
81108040:	e0bfff17 	ldw	r2,-4(fp)
81108044:	10801d17 	ldw	r2,116(r2)
81108048:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110804c:	e0bfff17 	ldw	r2,-4(fp)
81108050:	10800017 	ldw	r2,0(r2)
81108054:	e1bffe17 	ldw	r6,-8(fp)
81108058:	014012c4 	movi	r5,75
8110805c:	1009883a 	mov	r4,r2
81108060:	1109e800 	call	81109e80 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig;
81108064:	e0bfff17 	ldw	r2,-4(fp)
81108068:	10801e17 	ldw	r2,120(r2)
8110806c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_MODE_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_MODE_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST,
81108070:	e0bfff17 	ldw	r2,-4(fp)
81108074:	10800017 	ldw	r2,0(r2)
81108078:	e1bffe17 	ldw	r6,-8(fp)
8110807c:	01401304 	movi	r5,76
81108080:	1009883a 	mov	r4,r2
81108084:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSyncConfig;
81108088:	e0bfff17 	ldw	r2,-4(fp)
8110808c:	10801f17 	ldw	r2,124(r2)
81108090:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SYNC_CFG_MSK);
//			uliReg |= (COMM_RMAP_SYNC_CFG_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
//			uliReg &= (~COMM_RMAP_SELF_TRIGGER_CTRL_MSK);
//			uliReg |= (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST,
81108094:	e0bfff17 	ldw	r2,-4(fp)
81108098:	10800017 	ldw	r2,0(r2)
8110809c:	e1bffe17 	ldw	r6,-8(fp)
811080a0:	01401344 	movi	r5,77
811080a4:	1009883a 	mov	r4,r2
811080a8:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliDacControl;
811080ac:	e0bfff17 	ldw	r2,-4(fp)
811080b0:	10802017 	ldw	r2,128(r2)
811080b4:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST,
811080b8:	e0bfff17 	ldw	r2,-4(fp)
811080bc:	10800017 	ldw	r2,0(r2)
811080c0:	e1bffe17 	ldw	r6,-8(fp)
811080c4:	01401384 	movi	r5,78
811080c8:	1009883a 	mov	r4,r2
811080cc:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
811080d0:	e0bfff17 	ldw	r2,-4(fp)
811080d4:	10802217 	ldw	r2,136(r2)
811080d8:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811080dc:	e0bfff17 	ldw	r2,-4(fp)
811080e0:	10800017 	ldw	r2,0(r2)
811080e4:	e1bffe17 	ldw	r6,-8(fp)
811080e8:	014013c4 	movi	r5,79
811080ec:	1009883a 	mov	r4,r2
811080f0:	1109e800 	call	81109e80 <vRmapWriteReg>
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
811080f4:	e0bfff17 	ldw	r2,-4(fp)
811080f8:	10802217 	ldw	r2,136(r2)
811080fc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_FRAME_NUMBER_MSK);
//			uliReg |= (COMM_RMAP_FRAME_NUMBER_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliFrameNumber. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST,
81108100:	e0bfff17 	ldw	r2,-4(fp)
81108104:	10800017 	ldw	r2,0(r2)
81108108:	e1bffe17 	ldw	r6,-8(fp)
8110810c:	01401404 	movi	r5,80
81108110:	1009883a 	mov	r4,r2
81108114:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCurrentMode;
81108118:	e0bfff17 	ldw	r2,-4(fp)
8110811c:	10802317 	ldw	r2,140(r2)
81108120:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_CURRENT_MODE_MSK);
//			uliReg |= (COMM_RMAP_CURRENT_MODE_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCurrentMode. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST,
81108124:	e0bfff17 	ldw	r2,-4(fp)
81108128:	10800017 	ldw	r2,0(r2)
8110812c:	e1bffe17 	ldw	r6,-8(fp)
81108130:	01401444 	movi	r5,81
81108134:	1009883a 	mov	r4,r2
81108138:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
8110813c:	00800044 	movi	r2,1
81108140:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108144:	e0bffd17 	ldw	r2,-12(fp)
}
81108148:	e037883a 	mov	sp,fp
8110814c:	dfc00117 	ldw	ra,4(sp)
81108150:	df000017 	ldw	fp,0(sp)
81108154:	dec00204 	addi	sp,sp,8
81108158:	f800283a 	ret

8110815c <bRmapGetMemConfigArea>:

bool bRmapGetMemConfigArea(TRmapChannel *pxRmapCh) {
8110815c:	defffb04 	addi	sp,sp,-20
81108160:	de00012e 	bgeu	sp,et,81108168 <bRmapGetMemConfigArea+0xc>
81108164:	003b68fa 	trap	3
81108168:	dfc00415 	stw	ra,16(sp)
8110816c:	df000315 	stw	fp,12(sp)
81108170:	df000304 	addi	fp,sp,12
81108174:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108178:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110817c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108180:	e0bfff17 	ldw	r2,-4(fp)
81108184:	1000a426 	beq	r2,zero,81108418 <bRmapGetMemConfigArea+0x2bc>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108188:	e0bfff17 	ldw	r2,-4(fp)
8110818c:	10800017 	ldw	r2,0(r2)
81108190:	01401004 	movi	r5,64
81108194:	1009883a 	mov	r4,r2
81108198:	1109ed40 	call	81109ed4 <uliRmapReadReg>
8110819c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config = uliReg;
811081a0:	e0bfff17 	ldw	r2,-4(fp)
811081a4:	e0fffe17 	ldw	r3,-8(fp)
811081a8:	10c01215 	stw	r3,72(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081ac:	e0bfff17 	ldw	r2,-4(fp)
811081b0:	10800017 	ldw	r2,0(r2)
811081b4:	01401044 	movi	r5,65
811081b8:	1009883a 	mov	r4,r2
811081bc:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811081c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config = uliReg;
811081c4:	e0bfff17 	ldw	r2,-4(fp)
811081c8:	e0fffe17 	ldw	r3,-8(fp)
811081cc:	10c01315 	stw	r3,76(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081d0:	e0bfff17 	ldw	r2,-4(fp)
811081d4:	10800017 	ldw	r2,0(r2)
811081d8:	01401084 	movi	r5,66
811081dc:	1009883a 	mov	r4,r2
811081e0:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811081e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config = uliReg;
811081e8:	e0bfff17 	ldw	r2,-4(fp)
811081ec:	e0fffe17 	ldw	r3,-8(fp)
811081f0:	10c01415 	stw	r3,80(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081f4:	e0bfff17 	ldw	r2,-4(fp)
811081f8:	10800017 	ldw	r2,0(r2)
811081fc:	014010c4 	movi	r5,67
81108200:	1009883a 	mov	r4,r2
81108204:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108208:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config = uliReg;
8110820c:	e0bfff17 	ldw	r2,-4(fp)
81108210:	e0fffe17 	ldw	r3,-8(fp)
81108214:	10c01515 	stw	r3,84(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108218:	e0bfff17 	ldw	r2,-4(fp)
8110821c:	10800017 	ldw	r2,0(r2)
81108220:	01401104 	movi	r5,68
81108224:	1009883a 	mov	r4,r2
81108228:	1109ed40 	call	81109ed4 <uliRmapReadReg>
8110822c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81108230:	e0bfff17 	ldw	r2,-4(fp)
81108234:	e0fffe17 	ldw	r3,-8(fp)
81108238:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110823c:	e0bfff17 	ldw	r2,-4(fp)
81108240:	10800017 	ldw	r2,0(r2)
81108244:	01401144 	movi	r5,69
81108248:	1009883a 	mov	r4,r2
8110824c:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108250:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config = uliReg;
81108254:	e0bfff17 	ldw	r2,-4(fp)
81108258:	e0fffe17 	ldw	r3,-8(fp)
8110825c:	10c01715 	stw	r3,92(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108260:	e0bfff17 	ldw	r2,-4(fp)
81108264:	10800017 	ldw	r2,0(r2)
81108268:	01401184 	movi	r5,70
8110826c:	1009883a 	mov	r4,r2
81108270:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108274:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config = uliReg;
81108278:	e0bfff17 	ldw	r2,-4(fp)
8110827c:	e0fffe17 	ldw	r3,-8(fp)
81108280:	10c01815 	stw	r3,96(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108284:	e0bfff17 	ldw	r2,-4(fp)
81108288:	10800017 	ldw	r2,0(r2)
8110828c:	014011c4 	movi	r5,71
81108290:	1009883a 	mov	r4,r2
81108294:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108298:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config = uliReg;
8110829c:	e0bfff17 	ldw	r2,-4(fp)
811082a0:	e0fffe17 	ldw	r3,-8(fp)
811082a4:	10c01915 	stw	r3,100(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082a8:	e0bfff17 	ldw	r2,-4(fp)
811082ac:	10800017 	ldw	r2,0(r2)
811082b0:	01401204 	movi	r5,72
811082b4:	1009883a 	mov	r4,r2
811082b8:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811082bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config = uliReg;
811082c0:	e0bfff17 	ldw	r2,-4(fp)
811082c4:	e0fffe17 	ldw	r3,-8(fp)
811082c8:	10c01a15 	stw	r3,104(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082cc:	e0bfff17 	ldw	r2,-4(fp)
811082d0:	10800017 	ldw	r2,0(r2)
811082d4:	01401244 	movi	r5,73
811082d8:	1009883a 	mov	r4,r2
811082dc:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811082e0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config = uliReg;
811082e4:	e0bfff17 	ldw	r2,-4(fp)
811082e8:	e0fffe17 	ldw	r3,-8(fp)
811082ec:	10c01b15 	stw	r3,108(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082f0:	e0bfff17 	ldw	r2,-4(fp)
811082f4:	10800017 	ldw	r2,0(r2)
811082f8:	01401284 	movi	r5,74
811082fc:	1009883a 	mov	r4,r2
81108300:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108304:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config = uliReg;
81108308:	e0bfff17 	ldw	r2,-4(fp)
8110830c:	e0fffe17 	ldw	r3,-8(fp)
81108310:	10c01c15 	stw	r3,112(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108314:	e0bfff17 	ldw	r2,-4(fp)
81108318:	10800017 	ldw	r2,0(r2)
8110831c:	014012c4 	movi	r5,75
81108320:	1009883a 	mov	r4,r2
81108324:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108328:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config = uliReg;
8110832c:	e0bfff17 	ldw	r2,-4(fp)
81108330:	e0fffe17 	ldw	r3,-8(fp)
81108334:	10c01d15 	stw	r3,116(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108338:	e0bfff17 	ldw	r2,-4(fp)
8110833c:	10800017 	ldw	r2,0(r2)
81108340:	01401304 	movi	r5,76
81108344:	1009883a 	mov	r4,r2
81108348:	1109ed40 	call	81109ed4 <uliRmapReadReg>
8110834c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_OP_MODE_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig = uliReg;
81108350:	e0bfff17 	ldw	r2,-4(fp)
81108354:	e0fffe17 	ldw	r3,-8(fp)
81108358:	10c01e15 	stw	r3,120(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110835c:	e0bfff17 	ldw	r2,-4(fp)
81108360:	10800017 	ldw	r2,0(r2)
81108364:	01401344 	movi	r5,77
81108368:	1009883a 	mov	r4,r2
8110836c:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108370:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SYNC_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSyncConfig = uliReg;
81108374:	e0bfff17 	ldw	r2,-4(fp)
81108378:	e0fffe17 	ldw	r3,-8(fp)
8110837c:	10c01f15 	stw	r3,124(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108380:	e0bfff17 	ldw	r2,-4(fp)
81108384:	10800017 	ldw	r2,0(r2)
81108388:	01401384 	movi	r5,78
8110838c:	1009883a 	mov	r4,r2
81108390:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108394:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_DAC_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliDacControl = uliReg;
81108398:	e0bfff17 	ldw	r2,-4(fp)
8110839c:	e0fffe17 	ldw	r3,-8(fp)
811083a0:	10c02015 	stw	r3,128(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083a4:	e0bfff17 	ldw	r2,-4(fp)
811083a8:	10800017 	ldw	r2,0(r2)
811083ac:	014013c4 	movi	r5,79
811083b0:	1009883a 	mov	r4,r2
811083b4:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811083b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811083bc:	e0bfff17 	ldw	r2,-4(fp)
811083c0:	e0fffe17 	ldw	r3,-8(fp)
811083c4:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083c8:	e0bfff17 	ldw	r2,-4(fp)
811083cc:	10800017 	ldw	r2,0(r2)
811083d0:	01401404 	movi	r5,80
811083d4:	1009883a 	mov	r4,r2
811083d8:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811083dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_FRAME_NUMBER_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811083e0:	e0bfff17 	ldw	r2,-4(fp)
811083e4:	e0fffe17 	ldw	r3,-8(fp)
811083e8:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083ec:	e0bfff17 	ldw	r2,-4(fp)
811083f0:	10800017 	ldw	r2,0(r2)
811083f4:	01401444 	movi	r5,81
811083f8:	1009883a 	mov	r4,r2
811083fc:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108400:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CURRENT_MODE_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCurrentMode = uliReg;
81108404:	e0bfff17 	ldw	r2,-4(fp)
81108408:	e0fffe17 	ldw	r3,-8(fp)
8110840c:	10c02315 	stw	r3,140(r2)

		bStatus = TRUE;
81108410:	00800044 	movi	r2,1
81108414:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108418:	e0bffd17 	ldw	r2,-12(fp)
}
8110841c:	e037883a 	mov	sp,fp
81108420:	dfc00117 	ldw	ra,4(sp)
81108424:	df000017 	ldw	fp,0(sp)
81108428:	dec00204 	addi	sp,sp,8
8110842c:	f800283a 	ret

81108430 <bRmapGetMemConfigStat>:

bool bRmapGetMemConfigStat(TRmapChannel *pxRmapCh) {
81108430:	defffb04 	addi	sp,sp,-20
81108434:	de00012e 	bgeu	sp,et,8110843c <bRmapGetMemConfigStat+0xc>
81108438:	003b68fa 	trap	3
8110843c:	dfc00415 	stw	ra,16(sp)
81108440:	df000315 	stw	fp,12(sp)
81108444:	df000304 	addi	fp,sp,12
81108448:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110844c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108450:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108454:	e0bfff17 	ldw	r2,-4(fp)
81108458:	10001426 	beq	r2,zero,811084ac <bRmapGetMemConfigStat+0x7c>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110845c:	e0bfff17 	ldw	r2,-4(fp)
81108460:	10800017 	ldw	r2,0(r2)
81108464:	014001c4 	movi	r5,7
81108468:	1009883a 	mov	r4,r2
8110846c:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108470:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_RD_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastReadAddress = (alt_u32) ((uliReg
81108474:	e0bfff17 	ldw	r2,-4(fp)
81108478:	e0fffe17 	ldw	r3,-8(fp)
8110847c:	10c02515 	stw	r3,148(r2)
				& COMM_RMAP_LST_RD_ADDR_MSK) >> 0);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108480:	e0bfff17 	ldw	r2,-4(fp)
81108484:	10800017 	ldw	r2,0(r2)
81108488:	01400184 	movi	r5,6
8110848c:	1009883a 	mov	r4,r2
81108490:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108494:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_WR_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastWriteAddress = (alt_u32) ((uliReg
81108498:	e0bfff17 	ldw	r2,-4(fp)
8110849c:	e0fffe17 	ldw	r3,-8(fp)
811084a0:	10c02415 	stw	r3,144(r2)
				& COMM_RMAP_LST_WR_ADDR_MSK) >> 0);

		bStatus = TRUE;
811084a4:	00800044 	movi	r2,1
811084a8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811084ac:	e0bffd17 	ldw	r2,-12(fp)
}
811084b0:	e037883a 	mov	sp,fp
811084b4:	dfc00117 	ldw	ra,4(sp)
811084b8:	df000017 	ldw	fp,0(sp)
811084bc:	dec00204 	addi	sp,sp,8
811084c0:	f800283a 	ret

811084c4 <bRmapSetRmapMemHKArea>:

bool bRmapSetRmapMemHKArea(TRmapChannel *pxRmapCh) {
811084c4:	defffb04 	addi	sp,sp,-20
811084c8:	de00012e 	bgeu	sp,et,811084d0 <bRmapSetRmapMemHKArea+0xc>
811084cc:	003b68fa 	trap	3
811084d0:	dfc00415 	stw	ra,16(sp)
811084d4:	df000315 	stw	fp,12(sp)
811084d8:	df000304 	addi	fp,sp,12
811084dc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811084e0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811084e4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811084e8:	e0bfff17 	ldw	r2,-4(fp)
811084ec:	10040226 	beq	r2,zero,811094f8 <bRmapSetRmapMemHKArea+0x1034>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811084f0:	e0bfff17 	ldw	r2,-4(fp)
811084f4:	10800017 	ldw	r2,0(r2)
811084f8:	01402804 	movi	r5,160
811084fc:	1009883a 	mov	r4,r2
81108500:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108504:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
81108508:	e0bffe17 	ldw	r2,-8(fp)
8110850c:	10bfffec 	andhi	r2,r2,65535
81108510:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
81108514:	e0bfff17 	ldw	r2,-4(fp)
81108518:	1080260b 	ldhu	r2,152(r2)
8110851c:	10bfffcc 	andi	r2,r2,65535
	if (pxRmapCh != NULL) {

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
81108520:	e0fffe17 	ldw	r3,-8(fp)
81108524:	1884b03a 	or	r2,r3,r2
81108528:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
8110852c:	e0bffe17 	ldw	r2,-8(fp)
81108530:	10bfffcc 	andi	r2,r2,65535
81108534:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
81108538:	e0bfff17 	ldw	r2,-4(fp)
8110853c:	1080268b 	ldhu	r2,154(r2)
81108540:	10bfffcc 	andi	r2,r2,65535
81108544:	1004943a 	slli	r2,r2,16
81108548:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
8110854c:	e0bffe17 	ldw	r2,-8(fp)
81108550:	10c4b03a 	or	r2,r2,r3
81108554:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_0_REG_OFST,
81108558:	e0bfff17 	ldw	r2,-4(fp)
8110855c:	10800017 	ldw	r2,0(r2)
81108560:	e1bffe17 	ldw	r6,-8(fp)
81108564:	01402804 	movi	r5,160
81108568:	1009883a 	mov	r4,r2
8110856c:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108570:	e0bfff17 	ldw	r2,-4(fp)
81108574:	10800017 	ldw	r2,0(r2)
81108578:	01402844 	movi	r5,161
8110857c:	1009883a 	mov	r4,r2
81108580:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108584:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
81108588:	e0bffe17 	ldw	r2,-8(fp)
8110858c:	10bfffec 	andhi	r2,r2,65535
81108590:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
81108594:	e0bfff17 	ldw	r2,-4(fp)
81108598:	1080270b 	ldhu	r2,156(r2)
8110859c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
811085a0:	e0fffe17 	ldw	r3,-8(fp)
811085a4:	1884b03a 	or	r2,r3,r2
811085a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
811085ac:	e0bffe17 	ldw	r2,-8(fp)
811085b0:	10bfffcc 	andi	r2,r2,65535
811085b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
811085b8:	e0bfff17 	ldw	r2,-4(fp)
811085bc:	1080278b 	ldhu	r2,158(r2)
811085c0:	10bfffcc 	andi	r2,r2,65535
811085c4:	1004943a 	slli	r2,r2,16
811085c8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
811085cc:	e0bffe17 	ldw	r2,-8(fp)
811085d0:	10c4b03a 	or	r2,r2,r3
811085d4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_1_REG_OFST,
811085d8:	e0bfff17 	ldw	r2,-4(fp)
811085dc:	10800017 	ldw	r2,0(r2)
811085e0:	e1bffe17 	ldw	r6,-8(fp)
811085e4:	01402844 	movi	r5,161
811085e8:	1009883a 	mov	r4,r2
811085ec:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085f0:	e0bfff17 	ldw	r2,-4(fp)
811085f4:	10800017 	ldw	r2,0(r2)
811085f8:	01402884 	movi	r5,162
811085fc:	1009883a 	mov	r4,r2
81108600:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108604:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
81108608:	e0bffe17 	ldw	r2,-8(fp)
8110860c:	10bfffec 	andhi	r2,r2,65535
81108610:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
81108614:	e0bfff17 	ldw	r2,-4(fp)
81108618:	1080280b 	ldhu	r2,160(r2)
8110861c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
81108620:	e0fffe17 	ldw	r3,-8(fp)
81108624:	1884b03a 	or	r2,r3,r2
81108628:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
8110862c:	e0bffe17 	ldw	r2,-8(fp)
81108630:	10bfffcc 	andi	r2,r2,65535
81108634:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
81108638:	e0bfff17 	ldw	r2,-4(fp)
8110863c:	1080288b 	ldhu	r2,162(r2)
81108640:	10bfffcc 	andi	r2,r2,65535
81108644:	1004943a 	slli	r2,r2,16
81108648:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
8110864c:	e0bffe17 	ldw	r2,-8(fp)
81108650:	10c4b03a 	or	r2,r2,r3
81108654:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_2_REG_OFST,
81108658:	e0bfff17 	ldw	r2,-4(fp)
8110865c:	10800017 	ldw	r2,0(r2)
81108660:	e1bffe17 	ldw	r6,-8(fp)
81108664:	01402884 	movi	r5,162
81108668:	1009883a 	mov	r4,r2
8110866c:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108670:	e0bfff17 	ldw	r2,-4(fp)
81108674:	10800017 	ldw	r2,0(r2)
81108678:	014028c4 	movi	r5,163
8110867c:	1009883a 	mov	r4,r2
81108680:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108684:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
81108688:	e0bffe17 	ldw	r2,-8(fp)
8110868c:	10bfffec 	andhi	r2,r2,65535
81108690:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
81108694:	e0bfff17 	ldw	r2,-4(fp)
81108698:	1080290b 	ldhu	r2,164(r2)
8110869c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
811086a0:	e0fffe17 	ldw	r3,-8(fp)
811086a4:	1884b03a 	or	r2,r3,r2
811086a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
811086ac:	e0bffe17 	ldw	r2,-8(fp)
811086b0:	10bfffcc 	andi	r2,r2,65535
811086b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
811086b8:	e0bfff17 	ldw	r2,-4(fp)
811086bc:	1080298b 	ldhu	r2,166(r2)
811086c0:	10bfffcc 	andi	r2,r2,65535
811086c4:	1004943a 	slli	r2,r2,16
811086c8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
811086cc:	e0bffe17 	ldw	r2,-8(fp)
811086d0:	10c4b03a 	or	r2,r2,r3
811086d4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_3_REG_OFST,
811086d8:	e0bfff17 	ldw	r2,-4(fp)
811086dc:	10800017 	ldw	r2,0(r2)
811086e0:	e1bffe17 	ldw	r6,-8(fp)
811086e4:	014028c4 	movi	r5,163
811086e8:	1009883a 	mov	r4,r2
811086ec:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086f0:	e0bfff17 	ldw	r2,-4(fp)
811086f4:	10800017 	ldw	r2,0(r2)
811086f8:	01402904 	movi	r5,164
811086fc:	1009883a 	mov	r4,r2
81108700:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108704:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
81108708:	e0bffe17 	ldw	r2,-8(fp)
8110870c:	10bfffec 	andhi	r2,r2,65535
81108710:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
81108714:	e0bfff17 	ldw	r2,-4(fp)
81108718:	10802a0b 	ldhu	r2,168(r2)
8110871c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
81108720:	e0fffe17 	ldw	r3,-8(fp)
81108724:	1884b03a 	or	r2,r3,r2
81108728:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
8110872c:	e0bffe17 	ldw	r2,-8(fp)
81108730:	10bfffcc 	andi	r2,r2,65535
81108734:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
81108738:	e0bfff17 	ldw	r2,-4(fp)
8110873c:	10802a8b 	ldhu	r2,170(r2)
81108740:	10bfffcc 	andi	r2,r2,65535
81108744:	1004943a 	slli	r2,r2,16
81108748:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
8110874c:	e0bffe17 	ldw	r2,-8(fp)
81108750:	10c4b03a 	or	r2,r2,r3
81108754:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_4_REG_OFST,
81108758:	e0bfff17 	ldw	r2,-4(fp)
8110875c:	10800017 	ldw	r2,0(r2)
81108760:	e1bffe17 	ldw	r6,-8(fp)
81108764:	01402904 	movi	r5,164
81108768:	1009883a 	mov	r4,r2
8110876c:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108770:	e0bfff17 	ldw	r2,-4(fp)
81108774:	10800017 	ldw	r2,0(r2)
81108778:	01402944 	movi	r5,165
8110877c:	1009883a 	mov	r4,r2
81108780:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108784:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
81108788:	e0bffe17 	ldw	r2,-8(fp)
8110878c:	10bfffec 	andhi	r2,r2,65535
81108790:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
81108794:	e0bfff17 	ldw	r2,-4(fp)
81108798:	10802b0b 	ldhu	r2,172(r2)
8110879c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
811087a0:	e0fffe17 	ldw	r3,-8(fp)
811087a4:	1884b03a 	or	r2,r3,r2
811087a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
811087ac:	e0bffe17 	ldw	r2,-8(fp)
811087b0:	10bfffcc 	andi	r2,r2,65535
811087b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
811087b8:	e0bfff17 	ldw	r2,-4(fp)
811087bc:	10802b8b 	ldhu	r2,174(r2)
811087c0:	10bfffcc 	andi	r2,r2,65535
811087c4:	1004943a 	slli	r2,r2,16
811087c8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
811087cc:	e0bffe17 	ldw	r2,-8(fp)
811087d0:	10c4b03a 	or	r2,r2,r3
811087d4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_5_REG_OFST,
811087d8:	e0bfff17 	ldw	r2,-4(fp)
811087dc:	10800017 	ldw	r2,0(r2)
811087e0:	e1bffe17 	ldw	r6,-8(fp)
811087e4:	01402944 	movi	r5,165
811087e8:	1009883a 	mov	r4,r2
811087ec:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811087f0:	e0bfff17 	ldw	r2,-4(fp)
811087f4:	10800017 	ldw	r2,0(r2)
811087f8:	01402984 	movi	r5,166
811087fc:	1009883a 	mov	r4,r2
81108800:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108804:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
81108808:	e0bffe17 	ldw	r2,-8(fp)
8110880c:	10bfffec 	andhi	r2,r2,65535
81108810:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
81108814:	e0bfff17 	ldw	r2,-4(fp)
81108818:	10802c0b 	ldhu	r2,176(r2)
8110881c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
81108820:	e0fffe17 	ldw	r3,-8(fp)
81108824:	1884b03a 	or	r2,r3,r2
81108828:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
8110882c:	e0bffe17 	ldw	r2,-8(fp)
81108830:	10bfffcc 	andi	r2,r2,65535
81108834:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
81108838:	e0bfff17 	ldw	r2,-4(fp)
8110883c:	10802c8b 	ldhu	r2,178(r2)
81108840:	10bfffcc 	andi	r2,r2,65535
81108844:	1004943a 	slli	r2,r2,16
81108848:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
8110884c:	e0bffe17 	ldw	r2,-8(fp)
81108850:	10c4b03a 	or	r2,r2,r3
81108854:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_6_REG_OFST,
81108858:	e0bfff17 	ldw	r2,-4(fp)
8110885c:	10800017 	ldw	r2,0(r2)
81108860:	e1bffe17 	ldw	r6,-8(fp)
81108864:	01402984 	movi	r5,166
81108868:	1009883a 	mov	r4,r2
8110886c:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108870:	e0bfff17 	ldw	r2,-4(fp)
81108874:	10800017 	ldw	r2,0(r2)
81108878:	014029c4 	movi	r5,167
8110887c:	1009883a 	mov	r4,r2
81108880:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108884:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
81108888:	e0bffe17 	ldw	r2,-8(fp)
8110888c:	10bfffec 	andhi	r2,r2,65535
81108890:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
81108894:	e0bfff17 	ldw	r2,-4(fp)
81108898:	10802d0b 	ldhu	r2,180(r2)
8110889c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
811088a0:	e0fffe17 	ldw	r3,-8(fp)
811088a4:	1884b03a 	or	r2,r3,r2
811088a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
811088ac:	e0bffe17 	ldw	r2,-8(fp)
811088b0:	10bfffcc 	andi	r2,r2,65535
811088b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
811088b8:	e0bfff17 	ldw	r2,-4(fp)
811088bc:	10802d8b 	ldhu	r2,182(r2)
811088c0:	10bfffcc 	andi	r2,r2,65535
811088c4:	1004943a 	slli	r2,r2,16
811088c8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
811088cc:	e0bffe17 	ldw	r2,-8(fp)
811088d0:	10c4b03a 	or	r2,r2,r3
811088d4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_7_REG_OFST,
811088d8:	e0bfff17 	ldw	r2,-4(fp)
811088dc:	10800017 	ldw	r2,0(r2)
811088e0:	e1bffe17 	ldw	r6,-8(fp)
811088e4:	014029c4 	movi	r5,167
811088e8:	1009883a 	mov	r4,r2
811088ec:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811088f0:	e0bfff17 	ldw	r2,-4(fp)
811088f4:	10800017 	ldw	r2,0(r2)
811088f8:	01402a04 	movi	r5,168
811088fc:	1009883a 	mov	r4,r2
81108900:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108904:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
81108908:	e0bffe17 	ldw	r2,-8(fp)
8110890c:	10bfffec 	andhi	r2,r2,65535
81108910:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
81108914:	e0bfff17 	ldw	r2,-4(fp)
81108918:	10802e0b 	ldhu	r2,184(r2)
8110891c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
81108920:	e0fffe17 	ldw	r3,-8(fp)
81108924:	1884b03a 	or	r2,r3,r2
81108928:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
8110892c:	e0bffe17 	ldw	r2,-8(fp)
81108930:	10bfffcc 	andi	r2,r2,65535
81108934:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
81108938:	e0bfff17 	ldw	r2,-4(fp)
8110893c:	10802e8b 	ldhu	r2,186(r2)
81108940:	10bfffcc 	andi	r2,r2,65535
81108944:	1004943a 	slli	r2,r2,16
81108948:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
8110894c:	e0bffe17 	ldw	r2,-8(fp)
81108950:	10c4b03a 	or	r2,r2,r3
81108954:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_8_REG_OFST,
81108958:	e0bfff17 	ldw	r2,-4(fp)
8110895c:	10800017 	ldw	r2,0(r2)
81108960:	e1bffe17 	ldw	r6,-8(fp)
81108964:	01402a04 	movi	r5,168
81108968:	1009883a 	mov	r4,r2
8110896c:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108970:	e0bfff17 	ldw	r2,-4(fp)
81108974:	10800017 	ldw	r2,0(r2)
81108978:	01402a44 	movi	r5,169
8110897c:	1009883a 	mov	r4,r2
81108980:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108984:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
81108988:	e0bffe17 	ldw	r2,-8(fp)
8110898c:	10bfffec 	andhi	r2,r2,65535
81108990:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
81108994:	e0bfff17 	ldw	r2,-4(fp)
81108998:	10802f0b 	ldhu	r2,188(r2)
8110899c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
811089a0:	e0fffe17 	ldw	r3,-8(fp)
811089a4:	1884b03a 	or	r2,r3,r2
811089a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
811089ac:	e0bffe17 	ldw	r2,-8(fp)
811089b0:	10bfffcc 	andi	r2,r2,65535
811089b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
811089b8:	e0bfff17 	ldw	r2,-4(fp)
811089bc:	10802f8b 	ldhu	r2,190(r2)
811089c0:	10bfffcc 	andi	r2,r2,65535
811089c4:	1004943a 	slli	r2,r2,16
811089c8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
811089cc:	e0bffe17 	ldw	r2,-8(fp)
811089d0:	10c4b03a 	or	r2,r2,r3
811089d4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_9_REG_OFST,
811089d8:	e0bfff17 	ldw	r2,-4(fp)
811089dc:	10800017 	ldw	r2,0(r2)
811089e0:	e1bffe17 	ldw	r6,-8(fp)
811089e4:	01402a44 	movi	r5,169
811089e8:	1009883a 	mov	r4,r2
811089ec:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811089f0:	e0bfff17 	ldw	r2,-4(fp)
811089f4:	10800017 	ldw	r2,0(r2)
811089f8:	01402a84 	movi	r5,170
811089fc:	1009883a 	mov	r4,r2
81108a00:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108a04:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
81108a08:	e0bffe17 	ldw	r2,-8(fp)
81108a0c:	10bfffec 	andhi	r2,r2,65535
81108a10:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
81108a14:	e0bfff17 	ldw	r2,-4(fp)
81108a18:	1080300b 	ldhu	r2,192(r2)
81108a1c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
81108a20:	e0fffe17 	ldw	r3,-8(fp)
81108a24:	1884b03a 	or	r2,r3,r2
81108a28:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
81108a2c:	e0bffe17 	ldw	r2,-8(fp)
81108a30:	10bfffcc 	andi	r2,r2,65535
81108a34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
81108a38:	e0bfff17 	ldw	r2,-4(fp)
81108a3c:	1080308b 	ldhu	r2,194(r2)
81108a40:	10bfffcc 	andi	r2,r2,65535
81108a44:	1004943a 	slli	r2,r2,16
81108a48:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
81108a4c:	e0bffe17 	ldw	r2,-8(fp)
81108a50:	10c4b03a 	or	r2,r2,r3
81108a54:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_10_REG_OFST,
81108a58:	e0bfff17 	ldw	r2,-4(fp)
81108a5c:	10800017 	ldw	r2,0(r2)
81108a60:	e1bffe17 	ldw	r6,-8(fp)
81108a64:	01402a84 	movi	r5,170
81108a68:	1009883a 	mov	r4,r2
81108a6c:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a70:	e0bfff17 	ldw	r2,-4(fp)
81108a74:	10800017 	ldw	r2,0(r2)
81108a78:	01402ac4 	movi	r5,171
81108a7c:	1009883a 	mov	r4,r2
81108a80:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108a84:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
81108a88:	e0bffe17 	ldw	r2,-8(fp)
81108a8c:	10bfffec 	andhi	r2,r2,65535
81108a90:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
81108a94:	e0bfff17 	ldw	r2,-4(fp)
81108a98:	1080310b 	ldhu	r2,196(r2)
81108a9c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
81108aa0:	e0fffe17 	ldw	r3,-8(fp)
81108aa4:	1884b03a 	or	r2,r3,r2
81108aa8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
81108aac:	e0bffe17 	ldw	r2,-8(fp)
81108ab0:	10bfffcc 	andi	r2,r2,65535
81108ab4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
81108ab8:	e0bfff17 	ldw	r2,-4(fp)
81108abc:	1080318b 	ldhu	r2,198(r2)
81108ac0:	10bfffcc 	andi	r2,r2,65535
81108ac4:	1004943a 	slli	r2,r2,16
81108ac8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
81108acc:	e0bffe17 	ldw	r2,-8(fp)
81108ad0:	10c4b03a 	or	r2,r2,r3
81108ad4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_11_REG_OFST,
81108ad8:	e0bfff17 	ldw	r2,-4(fp)
81108adc:	10800017 	ldw	r2,0(r2)
81108ae0:	e1bffe17 	ldw	r6,-8(fp)
81108ae4:	01402ac4 	movi	r5,171
81108ae8:	1009883a 	mov	r4,r2
81108aec:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108af0:	e0bfff17 	ldw	r2,-4(fp)
81108af4:	10800017 	ldw	r2,0(r2)
81108af8:	01402b04 	movi	r5,172
81108afc:	1009883a 	mov	r4,r2
81108b00:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108b04:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
81108b08:	e0bffe17 	ldw	r2,-8(fp)
81108b0c:	10bfffec 	andhi	r2,r2,65535
81108b10:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
81108b14:	e0bfff17 	ldw	r2,-4(fp)
81108b18:	1080320b 	ldhu	r2,200(r2)
81108b1c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
81108b20:	e0fffe17 	ldw	r3,-8(fp)
81108b24:	1884b03a 	or	r2,r3,r2
81108b28:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
81108b2c:	e0bffe17 	ldw	r2,-8(fp)
81108b30:	10bfffcc 	andi	r2,r2,65535
81108b34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
81108b38:	e0bfff17 	ldw	r2,-4(fp)
81108b3c:	1080328b 	ldhu	r2,202(r2)
81108b40:	10bfffcc 	andi	r2,r2,65535
81108b44:	1004943a 	slli	r2,r2,16
81108b48:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
81108b4c:	e0bffe17 	ldw	r2,-8(fp)
81108b50:	10c4b03a 	or	r2,r2,r3
81108b54:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_12_REG_OFST,
81108b58:	e0bfff17 	ldw	r2,-4(fp)
81108b5c:	10800017 	ldw	r2,0(r2)
81108b60:	e1bffe17 	ldw	r6,-8(fp)
81108b64:	01402b04 	movi	r5,172
81108b68:	1009883a 	mov	r4,r2
81108b6c:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b70:	e0bfff17 	ldw	r2,-4(fp)
81108b74:	10800017 	ldw	r2,0(r2)
81108b78:	01402b44 	movi	r5,173
81108b7c:	1009883a 	mov	r4,r2
81108b80:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108b84:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
81108b88:	e0bffe17 	ldw	r2,-8(fp)
81108b8c:	10bfffec 	andhi	r2,r2,65535
81108b90:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
81108b94:	e0bfff17 	ldw	r2,-4(fp)
81108b98:	1080330b 	ldhu	r2,204(r2)
81108b9c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
81108ba0:	e0fffe17 	ldw	r3,-8(fp)
81108ba4:	1884b03a 	or	r2,r3,r2
81108ba8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
81108bac:	e0bffe17 	ldw	r2,-8(fp)
81108bb0:	10bfffcc 	andi	r2,r2,65535
81108bb4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
81108bb8:	e0bfff17 	ldw	r2,-4(fp)
81108bbc:	1080338b 	ldhu	r2,206(r2)
81108bc0:	10bfffcc 	andi	r2,r2,65535
81108bc4:	1004943a 	slli	r2,r2,16
81108bc8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
81108bcc:	e0bffe17 	ldw	r2,-8(fp)
81108bd0:	10c4b03a 	or	r2,r2,r3
81108bd4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_13_REG_OFST,
81108bd8:	e0bfff17 	ldw	r2,-4(fp)
81108bdc:	10800017 	ldw	r2,0(r2)
81108be0:	e1bffe17 	ldw	r6,-8(fp)
81108be4:	01402b44 	movi	r5,173
81108be8:	1009883a 	mov	r4,r2
81108bec:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108bf0:	e0bfff17 	ldw	r2,-4(fp)
81108bf4:	10800017 	ldw	r2,0(r2)
81108bf8:	01402b84 	movi	r5,174
81108bfc:	1009883a 	mov	r4,r2
81108c00:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108c04:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
81108c08:	e0bffe17 	ldw	r2,-8(fp)
81108c0c:	10bfffec 	andhi	r2,r2,65535
81108c10:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
81108c14:	e0bfff17 	ldw	r2,-4(fp)
81108c18:	1080340b 	ldhu	r2,208(r2)
81108c1c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
81108c20:	e0fffe17 	ldw	r3,-8(fp)
81108c24:	1884b03a 	or	r2,r3,r2
81108c28:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
81108c2c:	e0bffe17 	ldw	r2,-8(fp)
81108c30:	10bfffcc 	andi	r2,r2,65535
81108c34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
81108c38:	e0bfff17 	ldw	r2,-4(fp)
81108c3c:	1080348b 	ldhu	r2,210(r2)
81108c40:	10bfffcc 	andi	r2,r2,65535
81108c44:	1004943a 	slli	r2,r2,16
81108c48:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
81108c4c:	e0bffe17 	ldw	r2,-8(fp)
81108c50:	10c4b03a 	or	r2,r2,r3
81108c54:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_14_REG_OFST,
81108c58:	e0bfff17 	ldw	r2,-4(fp)
81108c5c:	10800017 	ldw	r2,0(r2)
81108c60:	e1bffe17 	ldw	r6,-8(fp)
81108c64:	01402b84 	movi	r5,174
81108c68:	1009883a 	mov	r4,r2
81108c6c:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c70:	e0bfff17 	ldw	r2,-4(fp)
81108c74:	10800017 	ldw	r2,0(r2)
81108c78:	01402bc4 	movi	r5,175
81108c7c:	1009883a 	mov	r4,r2
81108c80:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108c84:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
81108c88:	e0bffe17 	ldw	r2,-8(fp)
81108c8c:	10bfffec 	andhi	r2,r2,65535
81108c90:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
81108c94:	e0bfff17 	ldw	r2,-4(fp)
81108c98:	1080350b 	ldhu	r2,212(r2)
81108c9c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
81108ca0:	e0fffe17 	ldw	r3,-8(fp)
81108ca4:	1884b03a 	or	r2,r3,r2
81108ca8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
81108cac:	e0bffe17 	ldw	r2,-8(fp)
81108cb0:	10bfffcc 	andi	r2,r2,65535
81108cb4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
81108cb8:	e0bfff17 	ldw	r2,-4(fp)
81108cbc:	1080358b 	ldhu	r2,214(r2)
81108cc0:	10bfffcc 	andi	r2,r2,65535
81108cc4:	1004943a 	slli	r2,r2,16
81108cc8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
81108ccc:	e0bffe17 	ldw	r2,-8(fp)
81108cd0:	10c4b03a 	or	r2,r2,r3
81108cd4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_15_REG_OFST,
81108cd8:	e0bfff17 	ldw	r2,-4(fp)
81108cdc:	10800017 	ldw	r2,0(r2)
81108ce0:	e1bffe17 	ldw	r6,-8(fp)
81108ce4:	01402bc4 	movi	r5,175
81108ce8:	1009883a 	mov	r4,r2
81108cec:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108cf0:	e0bfff17 	ldw	r2,-4(fp)
81108cf4:	10800017 	ldw	r2,0(r2)
81108cf8:	01402c04 	movi	r5,176
81108cfc:	1009883a 	mov	r4,r2
81108d00:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108d04:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
81108d08:	e0bffe17 	ldw	r2,-8(fp)
81108d0c:	10bfffec 	andhi	r2,r2,65535
81108d10:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
81108d14:	e0bfff17 	ldw	r2,-4(fp)
81108d18:	1080360b 	ldhu	r2,216(r2)
81108d1c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
81108d20:	e0fffe17 	ldw	r3,-8(fp)
81108d24:	1884b03a 	or	r2,r3,r2
81108d28:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
81108d2c:	e0bffe17 	ldw	r2,-8(fp)
81108d30:	10bfffcc 	andi	r2,r2,65535
81108d34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
81108d38:	e0bfff17 	ldw	r2,-4(fp)
81108d3c:	1080368b 	ldhu	r2,218(r2)
81108d40:	10bfffcc 	andi	r2,r2,65535
81108d44:	1004943a 	slli	r2,r2,16
81108d48:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
81108d4c:	e0bffe17 	ldw	r2,-8(fp)
81108d50:	10c4b03a 	or	r2,r2,r3
81108d54:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_16_REG_OFST,
81108d58:	e0bfff17 	ldw	r2,-4(fp)
81108d5c:	10800017 	ldw	r2,0(r2)
81108d60:	e1bffe17 	ldw	r6,-8(fp)
81108d64:	01402c04 	movi	r5,176
81108d68:	1009883a 	mov	r4,r2
81108d6c:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108d70:	e0bfff17 	ldw	r2,-4(fp)
81108d74:	10800017 	ldw	r2,0(r2)
81108d78:	01402c44 	movi	r5,177
81108d7c:	1009883a 	mov	r4,r2
81108d80:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108d84:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
81108d88:	e0bffe17 	ldw	r2,-8(fp)
81108d8c:	10bfffec 	andhi	r2,r2,65535
81108d90:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
81108d94:	e0bfff17 	ldw	r2,-4(fp)
81108d98:	1080370b 	ldhu	r2,220(r2)
81108d9c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
81108da0:	e0fffe17 	ldw	r3,-8(fp)
81108da4:	1884b03a 	or	r2,r3,r2
81108da8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
81108dac:	e0bffe17 	ldw	r2,-8(fp)
81108db0:	10bfffcc 	andi	r2,r2,65535
81108db4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
81108db8:	e0bfff17 	ldw	r2,-4(fp)
81108dbc:	1080378b 	ldhu	r2,222(r2)
81108dc0:	10bfffcc 	andi	r2,r2,65535
81108dc4:	1004943a 	slli	r2,r2,16
81108dc8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
81108dcc:	e0bffe17 	ldw	r2,-8(fp)
81108dd0:	10c4b03a 	or	r2,r2,r3
81108dd4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_17_REG_OFST,
81108dd8:	e0bfff17 	ldw	r2,-4(fp)
81108ddc:	10800017 	ldw	r2,0(r2)
81108de0:	e1bffe17 	ldw	r6,-8(fp)
81108de4:	01402c44 	movi	r5,177
81108de8:	1009883a 	mov	r4,r2
81108dec:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108df0:	e0bfff17 	ldw	r2,-4(fp)
81108df4:	10800017 	ldw	r2,0(r2)
81108df8:	01402c84 	movi	r5,178
81108dfc:	1009883a 	mov	r4,r2
81108e00:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108e04:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
81108e08:	e0bffe17 	ldw	r2,-8(fp)
81108e0c:	10bfffec 	andhi	r2,r2,65535
81108e10:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
81108e14:	e0bfff17 	ldw	r2,-4(fp)
81108e18:	1080380b 	ldhu	r2,224(r2)
81108e1c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
81108e20:	e0fffe17 	ldw	r3,-8(fp)
81108e24:	1884b03a 	or	r2,r3,r2
81108e28:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
81108e2c:	e0bffe17 	ldw	r2,-8(fp)
81108e30:	10bfffcc 	andi	r2,r2,65535
81108e34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
81108e38:	e0bfff17 	ldw	r2,-4(fp)
81108e3c:	1080388b 	ldhu	r2,226(r2)
81108e40:	10bfffcc 	andi	r2,r2,65535
81108e44:	1004943a 	slli	r2,r2,16
81108e48:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
81108e4c:	e0bffe17 	ldw	r2,-8(fp)
81108e50:	10c4b03a 	or	r2,r2,r3
81108e54:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_18_REG_OFST,
81108e58:	e0bfff17 	ldw	r2,-4(fp)
81108e5c:	10800017 	ldw	r2,0(r2)
81108e60:	e1bffe17 	ldw	r6,-8(fp)
81108e64:	01402c84 	movi	r5,178
81108e68:	1009883a 	mov	r4,r2
81108e6c:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108e70:	e0bfff17 	ldw	r2,-4(fp)
81108e74:	10800017 	ldw	r2,0(r2)
81108e78:	01402cc4 	movi	r5,179
81108e7c:	1009883a 	mov	r4,r2
81108e80:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108e84:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
81108e88:	e0bffe17 	ldw	r2,-8(fp)
81108e8c:	10bfffec 	andhi	r2,r2,65535
81108e90:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
81108e94:	e0bfff17 	ldw	r2,-4(fp)
81108e98:	1080390b 	ldhu	r2,228(r2)
81108e9c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
81108ea0:	e0fffe17 	ldw	r3,-8(fp)
81108ea4:	1884b03a 	or	r2,r3,r2
81108ea8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
81108eac:	e0bffe17 	ldw	r2,-8(fp)
81108eb0:	10bfffcc 	andi	r2,r2,65535
81108eb4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
81108eb8:	e0bfff17 	ldw	r2,-4(fp)
81108ebc:	1080398b 	ldhu	r2,230(r2)
81108ec0:	10bfffcc 	andi	r2,r2,65535
81108ec4:	1004943a 	slli	r2,r2,16
81108ec8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
81108ecc:	e0bffe17 	ldw	r2,-8(fp)
81108ed0:	10c4b03a 	or	r2,r2,r3
81108ed4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_19_REG_OFST,
81108ed8:	e0bfff17 	ldw	r2,-4(fp)
81108edc:	10800017 	ldw	r2,0(r2)
81108ee0:	e1bffe17 	ldw	r6,-8(fp)
81108ee4:	01402cc4 	movi	r5,179
81108ee8:	1009883a 	mov	r4,r2
81108eec:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ef0:	e0bfff17 	ldw	r2,-4(fp)
81108ef4:	10800017 	ldw	r2,0(r2)
81108ef8:	01402d04 	movi	r5,180
81108efc:	1009883a 	mov	r4,r2
81108f00:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108f04:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
81108f08:	e0bffe17 	ldw	r2,-8(fp)
81108f0c:	10bfffec 	andhi	r2,r2,65535
81108f10:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
81108f14:	e0bfff17 	ldw	r2,-4(fp)
81108f18:	10803a0b 	ldhu	r2,232(r2)
81108f1c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
81108f20:	e0fffe17 	ldw	r3,-8(fp)
81108f24:	1884b03a 	or	r2,r3,r2
81108f28:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
81108f2c:	e0bffe17 	ldw	r2,-8(fp)
81108f30:	10bfffcc 	andi	r2,r2,65535
81108f34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
81108f38:	e0bfff17 	ldw	r2,-4(fp)
81108f3c:	10803a8b 	ldhu	r2,234(r2)
81108f40:	10bfffcc 	andi	r2,r2,65535
81108f44:	1004943a 	slli	r2,r2,16
81108f48:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
81108f4c:	e0bffe17 	ldw	r2,-8(fp)
81108f50:	10c4b03a 	or	r2,r2,r3
81108f54:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_20_REG_OFST,
81108f58:	e0bfff17 	ldw	r2,-4(fp)
81108f5c:	10800017 	ldw	r2,0(r2)
81108f60:	e1bffe17 	ldw	r6,-8(fp)
81108f64:	01402d04 	movi	r5,180
81108f68:	1009883a 	mov	r4,r2
81108f6c:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108f70:	e0bfff17 	ldw	r2,-4(fp)
81108f74:	10800017 	ldw	r2,0(r2)
81108f78:	01402d44 	movi	r5,181
81108f7c:	1009883a 	mov	r4,r2
81108f80:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81108f84:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
81108f88:	e0bffe17 	ldw	r2,-8(fp)
81108f8c:	10bfffec 	andhi	r2,r2,65535
81108f90:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
81108f94:	e0bfff17 	ldw	r2,-4(fp)
81108f98:	10803b0b 	ldhu	r2,236(r2)
81108f9c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
81108fa0:	e0fffe17 	ldw	r3,-8(fp)
81108fa4:	1884b03a 	or	r2,r3,r2
81108fa8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
81108fac:	e0bffe17 	ldw	r2,-8(fp)
81108fb0:	10bfffcc 	andi	r2,r2,65535
81108fb4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
81108fb8:	e0bfff17 	ldw	r2,-4(fp)
81108fbc:	10803b8b 	ldhu	r2,238(r2)
81108fc0:	10bfffcc 	andi	r2,r2,65535
81108fc4:	1004943a 	slli	r2,r2,16
81108fc8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
81108fcc:	e0bffe17 	ldw	r2,-8(fp)
81108fd0:	10c4b03a 	or	r2,r2,r3
81108fd4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_21_REG_OFST,
81108fd8:	e0bfff17 	ldw	r2,-4(fp)
81108fdc:	10800017 	ldw	r2,0(r2)
81108fe0:	e1bffe17 	ldw	r6,-8(fp)
81108fe4:	01402d44 	movi	r5,181
81108fe8:	1009883a 	mov	r4,r2
81108fec:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ff0:	e0bfff17 	ldw	r2,-4(fp)
81108ff4:	10800017 	ldw	r2,0(r2)
81108ff8:	01402d84 	movi	r5,182
81108ffc:	1009883a 	mov	r4,r2
81109000:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109004:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
81109008:	e0bffe17 	ldw	r2,-8(fp)
8110900c:	10bfffec 	andhi	r2,r2,65535
81109010:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
81109014:	e0bfff17 	ldw	r2,-4(fp)
81109018:	10803c0b 	ldhu	r2,240(r2)
8110901c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
81109020:	e0fffe17 	ldw	r3,-8(fp)
81109024:	1884b03a 	or	r2,r3,r2
81109028:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
8110902c:	e0bffe17 	ldw	r2,-8(fp)
81109030:	10bfffcc 	andi	r2,r2,65535
81109034:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
81109038:	e0bfff17 	ldw	r2,-4(fp)
8110903c:	10803c8b 	ldhu	r2,242(r2)
81109040:	10bfffcc 	andi	r2,r2,65535
81109044:	1004943a 	slli	r2,r2,16
81109048:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
8110904c:	e0bffe17 	ldw	r2,-8(fp)
81109050:	10c4b03a 	or	r2,r2,r3
81109054:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_22_REG_OFST,
81109058:	e0bfff17 	ldw	r2,-4(fp)
8110905c:	10800017 	ldw	r2,0(r2)
81109060:	e1bffe17 	ldw	r6,-8(fp)
81109064:	01402d84 	movi	r5,182
81109068:	1009883a 	mov	r4,r2
8110906c:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109070:	e0bfff17 	ldw	r2,-4(fp)
81109074:	10800017 	ldw	r2,0(r2)
81109078:	01402dc4 	movi	r5,183
8110907c:	1009883a 	mov	r4,r2
81109080:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109084:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
81109088:	e0bffe17 	ldw	r2,-8(fp)
8110908c:	10bfffec 	andhi	r2,r2,65535
81109090:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
81109094:	e0bfff17 	ldw	r2,-4(fp)
81109098:	10803d0b 	ldhu	r2,244(r2)
8110909c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
811090a0:	e0fffe17 	ldw	r3,-8(fp)
811090a4:	1884b03a 	or	r2,r3,r2
811090a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
811090ac:	e0bffe17 	ldw	r2,-8(fp)
811090b0:	10bfffcc 	andi	r2,r2,65535
811090b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
811090b8:	e0bfff17 	ldw	r2,-4(fp)
811090bc:	10803d8b 	ldhu	r2,246(r2)
811090c0:	10bfffcc 	andi	r2,r2,65535
811090c4:	1004943a 	slli	r2,r2,16
811090c8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
811090cc:	e0bffe17 	ldw	r2,-8(fp)
811090d0:	10c4b03a 	or	r2,r2,r3
811090d4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_23_REG_OFST,
811090d8:	e0bfff17 	ldw	r2,-4(fp)
811090dc:	10800017 	ldw	r2,0(r2)
811090e0:	e1bffe17 	ldw	r6,-8(fp)
811090e4:	01402dc4 	movi	r5,183
811090e8:	1009883a 	mov	r4,r2
811090ec:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811090f0:	e0bfff17 	ldw	r2,-4(fp)
811090f4:	10800017 	ldw	r2,0(r2)
811090f8:	01402e04 	movi	r5,184
811090fc:	1009883a 	mov	r4,r2
81109100:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109104:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
81109108:	e0bffe17 	ldw	r2,-8(fp)
8110910c:	10bfffec 	andhi	r2,r2,65535
81109110:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
81109114:	e0bfff17 	ldw	r2,-4(fp)
81109118:	10803e0b 	ldhu	r2,248(r2)
8110911c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
81109120:	e0fffe17 	ldw	r3,-8(fp)
81109124:	1884b03a 	or	r2,r3,r2
81109128:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
8110912c:	e0bffe17 	ldw	r2,-8(fp)
81109130:	10bfffcc 	andi	r2,r2,65535
81109134:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
81109138:	e0bfff17 	ldw	r2,-4(fp)
8110913c:	10803e8b 	ldhu	r2,250(r2)
81109140:	10bfffcc 	andi	r2,r2,65535
81109144:	1004943a 	slli	r2,r2,16
81109148:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
8110914c:	e0bffe17 	ldw	r2,-8(fp)
81109150:	10c4b03a 	or	r2,r2,r3
81109154:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_24_REG_OFST,
81109158:	e0bfff17 	ldw	r2,-4(fp)
8110915c:	10800017 	ldw	r2,0(r2)
81109160:	e1bffe17 	ldw	r6,-8(fp)
81109164:	01402e04 	movi	r5,184
81109168:	1009883a 	mov	r4,r2
8110916c:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109170:	e0bfff17 	ldw	r2,-4(fp)
81109174:	10800017 	ldw	r2,0(r2)
81109178:	01402e44 	movi	r5,185
8110917c:	1009883a 	mov	r4,r2
81109180:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109184:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
81109188:	e0bffe17 	ldw	r2,-8(fp)
8110918c:	10bfffec 	andhi	r2,r2,65535
81109190:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
81109194:	e0bfff17 	ldw	r2,-4(fp)
81109198:	10803f0b 	ldhu	r2,252(r2)
8110919c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
811091a0:	e0fffe17 	ldw	r3,-8(fp)
811091a4:	1884b03a 	or	r2,r3,r2
811091a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
811091ac:	e0bffe17 	ldw	r2,-8(fp)
811091b0:	10bfffcc 	andi	r2,r2,65535
811091b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
811091b8:	e0bfff17 	ldw	r2,-4(fp)
811091bc:	10803f8b 	ldhu	r2,254(r2)
811091c0:	10bfffcc 	andi	r2,r2,65535
811091c4:	1004943a 	slli	r2,r2,16
811091c8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
811091cc:	e0bffe17 	ldw	r2,-8(fp)
811091d0:	10c4b03a 	or	r2,r2,r3
811091d4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_25_REG_OFST,
811091d8:	e0bfff17 	ldw	r2,-4(fp)
811091dc:	10800017 	ldw	r2,0(r2)
811091e0:	e1bffe17 	ldw	r6,-8(fp)
811091e4:	01402e44 	movi	r5,185
811091e8:	1009883a 	mov	r4,r2
811091ec:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811091f0:	e0bfff17 	ldw	r2,-4(fp)
811091f4:	10800017 	ldw	r2,0(r2)
811091f8:	01402e84 	movi	r5,186
811091fc:	1009883a 	mov	r4,r2
81109200:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109204:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
81109208:	e0bffe17 	ldw	r2,-8(fp)
8110920c:	10bfffec 	andhi	r2,r2,65535
81109210:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
81109214:	e0bfff17 	ldw	r2,-4(fp)
81109218:	1080400b 	ldhu	r2,256(r2)
8110921c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
81109220:	e0fffe17 	ldw	r3,-8(fp)
81109224:	1884b03a 	or	r2,r3,r2
81109228:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
8110922c:	e0bffe17 	ldw	r2,-8(fp)
81109230:	10bfffcc 	andi	r2,r2,65535
81109234:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
81109238:	e0bfff17 	ldw	r2,-4(fp)
8110923c:	1080408b 	ldhu	r2,258(r2)
81109240:	10bfffcc 	andi	r2,r2,65535
81109244:	1004943a 	slli	r2,r2,16
81109248:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
8110924c:	e0bffe17 	ldw	r2,-8(fp)
81109250:	10c4b03a 	or	r2,r2,r3
81109254:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_26_REG_OFST,
81109258:	e0bfff17 	ldw	r2,-4(fp)
8110925c:	10800017 	ldw	r2,0(r2)
81109260:	e1bffe17 	ldw	r6,-8(fp)
81109264:	01402e84 	movi	r5,186
81109268:	1009883a 	mov	r4,r2
8110926c:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109270:	e0bfff17 	ldw	r2,-4(fp)
81109274:	10800017 	ldw	r2,0(r2)
81109278:	01402ec4 	movi	r5,187
8110927c:	1009883a 	mov	r4,r2
81109280:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109284:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
81109288:	e0bffe17 	ldw	r2,-8(fp)
8110928c:	10bfffec 	andhi	r2,r2,65535
81109290:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
81109294:	e0bfff17 	ldw	r2,-4(fp)
81109298:	1080410b 	ldhu	r2,260(r2)
8110929c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
811092a0:	e0fffe17 	ldw	r3,-8(fp)
811092a4:	1884b03a 	or	r2,r3,r2
811092a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
811092ac:	e0bffe17 	ldw	r2,-8(fp)
811092b0:	10bfffcc 	andi	r2,r2,65535
811092b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
811092b8:	e0bfff17 	ldw	r2,-4(fp)
811092bc:	1080418b 	ldhu	r2,262(r2)
811092c0:	10bfffcc 	andi	r2,r2,65535
811092c4:	1004943a 	slli	r2,r2,16
811092c8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
811092cc:	e0bffe17 	ldw	r2,-8(fp)
811092d0:	10c4b03a 	or	r2,r2,r3
811092d4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_27_REG_OFST,
811092d8:	e0bfff17 	ldw	r2,-4(fp)
811092dc:	10800017 	ldw	r2,0(r2)
811092e0:	e1bffe17 	ldw	r6,-8(fp)
811092e4:	01402ec4 	movi	r5,187
811092e8:	1009883a 	mov	r4,r2
811092ec:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811092f0:	e0bfff17 	ldw	r2,-4(fp)
811092f4:	10800017 	ldw	r2,0(r2)
811092f8:	01402f04 	movi	r5,188
811092fc:	1009883a 	mov	r4,r2
81109300:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109304:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
81109308:	e0bffe17 	ldw	r2,-8(fp)
8110930c:	10bfffec 	andhi	r2,r2,65535
81109310:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
81109314:	e0bfff17 	ldw	r2,-4(fp)
81109318:	1080420b 	ldhu	r2,264(r2)
8110931c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
81109320:	e0fffe17 	ldw	r3,-8(fp)
81109324:	1884b03a 	or	r2,r3,r2
81109328:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
8110932c:	e0bffe17 	ldw	r2,-8(fp)
81109330:	10bfffcc 	andi	r2,r2,65535
81109334:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
81109338:	e0bfff17 	ldw	r2,-4(fp)
8110933c:	1080428b 	ldhu	r2,266(r2)
81109340:	10bfffcc 	andi	r2,r2,65535
81109344:	1004943a 	slli	r2,r2,16
81109348:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
8110934c:	e0bffe17 	ldw	r2,-8(fp)
81109350:	10c4b03a 	or	r2,r2,r3
81109354:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_28_REG_OFST,
81109358:	e0bfff17 	ldw	r2,-4(fp)
8110935c:	10800017 	ldw	r2,0(r2)
81109360:	e1bffe17 	ldw	r6,-8(fp)
81109364:	01402f04 	movi	r5,188
81109368:	1009883a 	mov	r4,r2
8110936c:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109370:	e0bfff17 	ldw	r2,-4(fp)
81109374:	10800017 	ldw	r2,0(r2)
81109378:	01402f44 	movi	r5,189
8110937c:	1009883a 	mov	r4,r2
81109380:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109384:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
81109388:	e0bffe17 	ldw	r2,-8(fp)
8110938c:	10bfffec 	andhi	r2,r2,65535
81109390:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
81109394:	e0bfff17 	ldw	r2,-4(fp)
81109398:	1080430b 	ldhu	r2,268(r2)
8110939c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
811093a0:	e0fffe17 	ldw	r3,-8(fp)
811093a4:	1884b03a 	or	r2,r3,r2
811093a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
811093ac:	e0bffe17 	ldw	r2,-8(fp)
811093b0:	10bfffcc 	andi	r2,r2,65535
811093b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
811093b8:	e0bfff17 	ldw	r2,-4(fp)
811093bc:	1080438b 	ldhu	r2,270(r2)
811093c0:	10bfffcc 	andi	r2,r2,65535
811093c4:	1004943a 	slli	r2,r2,16
811093c8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
811093cc:	e0bffe17 	ldw	r2,-8(fp)
811093d0:	10c4b03a 	or	r2,r2,r3
811093d4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_29_REG_OFST,
811093d8:	e0bfff17 	ldw	r2,-4(fp)
811093dc:	10800017 	ldw	r2,0(r2)
811093e0:	e1bffe17 	ldw	r6,-8(fp)
811093e4:	01402f44 	movi	r5,189
811093e8:	1009883a 	mov	r4,r2
811093ec:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811093f0:	e0bfff17 	ldw	r2,-4(fp)
811093f4:	10800017 	ldw	r2,0(r2)
811093f8:	01402f84 	movi	r5,190
811093fc:	1009883a 	mov	r4,r2
81109400:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109404:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
81109408:	e0bffe17 	ldw	r2,-8(fp)
8110940c:	10bfffec 	andhi	r2,r2,65535
81109410:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
81109414:	e0bfff17 	ldw	r2,-4(fp)
81109418:	1080440b 	ldhu	r2,272(r2)
8110941c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
81109420:	e0fffe17 	ldw	r3,-8(fp)
81109424:	1884b03a 	or	r2,r3,r2
81109428:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
8110942c:	e0bffe17 	ldw	r2,-8(fp)
81109430:	10bfffcc 	andi	r2,r2,65535
81109434:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
81109438:	e0bfff17 	ldw	r2,-4(fp)
8110943c:	1080448b 	ldhu	r2,274(r2)
81109440:	10bfffcc 	andi	r2,r2,65535
81109444:	1004943a 	slli	r2,r2,16
81109448:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
8110944c:	e0bffe17 	ldw	r2,-8(fp)
81109450:	10c4b03a 	or	r2,r2,r3
81109454:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_30_REG_OFST,
81109458:	e0bfff17 	ldw	r2,-4(fp)
8110945c:	10800017 	ldw	r2,0(r2)
81109460:	e1bffe17 	ldw	r6,-8(fp)
81109464:	01402f84 	movi	r5,190
81109468:	1009883a 	mov	r4,r2
8110946c:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109470:	e0bfff17 	ldw	r2,-4(fp)
81109474:	10800017 	ldw	r2,0(r2)
81109478:	01402fc4 	movi	r5,191
8110947c:	1009883a 	mov	r4,r2
81109480:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109484:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
81109488:	e0bffe17 	ldw	r2,-8(fp)
8110948c:	10bfffec 	andhi	r2,r2,65535
81109490:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
81109494:	e0bfff17 	ldw	r2,-4(fp)
81109498:	1080450b 	ldhu	r2,276(r2)
8110949c:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
811094a0:	e0fffe17 	ldw	r3,-8(fp)
811094a4:	1884b03a 	or	r2,r3,r2
811094a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
811094ac:	e0bffe17 	ldw	r2,-8(fp)
811094b0:	10bfffcc 	andi	r2,r2,65535
811094b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
811094b8:	e0bfff17 	ldw	r2,-4(fp)
811094bc:	1080458b 	ldhu	r2,278(r2)
811094c0:	10bfffcc 	andi	r2,r2,65535
811094c4:	1004943a 	slli	r2,r2,16
811094c8:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
811094cc:	e0bffe17 	ldw	r2,-8(fp)
811094d0:	10c4b03a 	or	r2,r2,r3
811094d4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_31_REG_OFST,
811094d8:	e0bfff17 	ldw	r2,-4(fp)
811094dc:	10800017 	ldw	r2,0(r2)
811094e0:	e1bffe17 	ldw	r6,-8(fp)
811094e4:	01402fc4 	movi	r5,191
811094e8:	1009883a 	mov	r4,r2
811094ec:	1109e800 	call	81109e80 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
811094f0:	00800044 	movi	r2,1
811094f4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811094f8:	e0bffd17 	ldw	r2,-12(fp)
}
811094fc:	e037883a 	mov	sp,fp
81109500:	dfc00117 	ldw	ra,4(sp)
81109504:	df000017 	ldw	fp,0(sp)
81109508:	dec00204 	addi	sp,sp,8
8110950c:	f800283a 	ret

81109510 <bRmapGetRmapMemHKArea>:

bool bRmapGetRmapMemHKArea(TRmapChannel *pxRmapCh) {
81109510:	defffb04 	addi	sp,sp,-20
81109514:	de00012e 	bgeu	sp,et,8110951c <bRmapGetRmapMemHKArea+0xc>
81109518:	003b68fa 	trap	3
8110951c:	dfc00415 	stw	ra,16(sp)
81109520:	df000315 	stw	fp,12(sp)
81109524:	df000304 	addi	fp,sp,12
81109528:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110952c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109530:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81109534:	e0bfff17 	ldw	r2,-4(fp)
81109538:	1001e226 	beq	r2,zero,81109cc4 <bRmapGetRmapMemHKArea+0x7b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110953c:	e0bfff17 	ldw	r2,-4(fp)
81109540:	10800017 	ldw	r2,0(r2)
81109544:	01402804 	movi	r5,160
81109548:	1009883a 	mov	r4,r2
8110954c:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109550:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
81109554:	e0bffe17 	ldw	r2,-8(fp)
81109558:	1007883a 	mov	r3,r2
8110955c:	e0bfff17 	ldw	r2,-4(fp)
81109560:	10c0260d 	sth	r3,152(r2)
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);
81109564:	e0bffe17 	ldw	r2,-8(fp)
81109568:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
8110956c:	1007883a 	mov	r3,r2
81109570:	e0bfff17 	ldw	r2,-4(fp)
81109574:	10c0268d 	sth	r3,154(r2)
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109578:	e0bfff17 	ldw	r2,-4(fp)
8110957c:	10800017 	ldw	r2,0(r2)
81109580:	01402844 	movi	r5,161
81109584:	1009883a 	mov	r4,r2
81109588:	1109ed40 	call	81109ed4 <uliRmapReadReg>
8110958c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
81109590:	e0bffe17 	ldw	r2,-8(fp)
81109594:	1007883a 	mov	r3,r2
81109598:	e0bfff17 	ldw	r2,-4(fp)
8110959c:	10c0270d 	sth	r3,156(r2)
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);
811095a0:	e0bffe17 	ldw	r2,-8(fp)
811095a4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
811095a8:	1007883a 	mov	r3,r2
811095ac:	e0bfff17 	ldw	r2,-4(fp)
811095b0:	10c0278d 	sth	r3,158(r2)
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811095b4:	e0bfff17 	ldw	r2,-4(fp)
811095b8:	10800017 	ldw	r2,0(r2)
811095bc:	01402884 	movi	r5,162
811095c0:	1009883a 	mov	r4,r2
811095c4:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811095c8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
811095cc:	e0bffe17 	ldw	r2,-8(fp)
811095d0:	1007883a 	mov	r3,r2
811095d4:	e0bfff17 	ldw	r2,-4(fp)
811095d8:	10c0280d 	sth	r3,160(r2)
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);
811095dc:	e0bffe17 	ldw	r2,-8(fp)
811095e0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
811095e4:	1007883a 	mov	r3,r2
811095e8:	e0bfff17 	ldw	r2,-4(fp)
811095ec:	10c0288d 	sth	r3,162(r2)
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811095f0:	e0bfff17 	ldw	r2,-4(fp)
811095f4:	10800017 	ldw	r2,0(r2)
811095f8:	014028c4 	movi	r5,163
811095fc:	1009883a 	mov	r4,r2
81109600:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109604:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
81109608:	e0bffe17 	ldw	r2,-8(fp)
8110960c:	1007883a 	mov	r3,r2
81109610:	e0bfff17 	ldw	r2,-4(fp)
81109614:	10c0290d 	sth	r3,164(r2)
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);
81109618:	e0bffe17 	ldw	r2,-8(fp)
8110961c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
81109620:	1007883a 	mov	r3,r2
81109624:	e0bfff17 	ldw	r2,-4(fp)
81109628:	10c0298d 	sth	r3,166(r2)
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110962c:	e0bfff17 	ldw	r2,-4(fp)
81109630:	10800017 	ldw	r2,0(r2)
81109634:	01402904 	movi	r5,164
81109638:	1009883a 	mov	r4,r2
8110963c:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109640:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
81109644:	e0bffe17 	ldw	r2,-8(fp)
81109648:	1007883a 	mov	r3,r2
8110964c:	e0bfff17 	ldw	r2,-4(fp)
81109650:	10c02a0d 	sth	r3,168(r2)
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);
81109654:	e0bffe17 	ldw	r2,-8(fp)
81109658:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
8110965c:	1007883a 	mov	r3,r2
81109660:	e0bfff17 	ldw	r2,-4(fp)
81109664:	10c02a8d 	sth	r3,170(r2)
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109668:	e0bfff17 	ldw	r2,-4(fp)
8110966c:	10800017 	ldw	r2,0(r2)
81109670:	01402944 	movi	r5,165
81109674:	1009883a 	mov	r4,r2
81109678:	1109ed40 	call	81109ed4 <uliRmapReadReg>
8110967c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
81109680:	e0bffe17 	ldw	r2,-8(fp)
81109684:	1007883a 	mov	r3,r2
81109688:	e0bfff17 	ldw	r2,-4(fp)
8110968c:	10c02b0d 	sth	r3,172(r2)
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);
81109690:	e0bffe17 	ldw	r2,-8(fp)
81109694:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
81109698:	1007883a 	mov	r3,r2
8110969c:	e0bfff17 	ldw	r2,-4(fp)
811096a0:	10c02b8d 	sth	r3,174(r2)
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811096a4:	e0bfff17 	ldw	r2,-4(fp)
811096a8:	10800017 	ldw	r2,0(r2)
811096ac:	01402984 	movi	r5,166
811096b0:	1009883a 	mov	r4,r2
811096b4:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811096b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
811096bc:	e0bffe17 	ldw	r2,-8(fp)
811096c0:	1007883a 	mov	r3,r2
811096c4:	e0bfff17 	ldw	r2,-4(fp)
811096c8:	10c02c0d 	sth	r3,176(r2)
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);
811096cc:	e0bffe17 	ldw	r2,-8(fp)
811096d0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
811096d4:	1007883a 	mov	r3,r2
811096d8:	e0bfff17 	ldw	r2,-4(fp)
811096dc:	10c02c8d 	sth	r3,178(r2)
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811096e0:	e0bfff17 	ldw	r2,-4(fp)
811096e4:	10800017 	ldw	r2,0(r2)
811096e8:	014029c4 	movi	r5,167
811096ec:	1009883a 	mov	r4,r2
811096f0:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811096f4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
811096f8:	e0bffe17 	ldw	r2,-8(fp)
811096fc:	1007883a 	mov	r3,r2
81109700:	e0bfff17 	ldw	r2,-4(fp)
81109704:	10c02d0d 	sth	r3,180(r2)
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);
81109708:	e0bffe17 	ldw	r2,-8(fp)
8110970c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
81109710:	1007883a 	mov	r3,r2
81109714:	e0bfff17 	ldw	r2,-4(fp)
81109718:	10c02d8d 	sth	r3,182(r2)
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110971c:	e0bfff17 	ldw	r2,-4(fp)
81109720:	10800017 	ldw	r2,0(r2)
81109724:	01402a04 	movi	r5,168
81109728:	1009883a 	mov	r4,r2
8110972c:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109730:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
81109734:	e0bffe17 	ldw	r2,-8(fp)
81109738:	1007883a 	mov	r3,r2
8110973c:	e0bfff17 	ldw	r2,-4(fp)
81109740:	10c02e0d 	sth	r3,184(r2)
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);
81109744:	e0bffe17 	ldw	r2,-8(fp)
81109748:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
8110974c:	1007883a 	mov	r3,r2
81109750:	e0bfff17 	ldw	r2,-4(fp)
81109754:	10c02e8d 	sth	r3,186(r2)
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109758:	e0bfff17 	ldw	r2,-4(fp)
8110975c:	10800017 	ldw	r2,0(r2)
81109760:	01402a44 	movi	r5,169
81109764:	1009883a 	mov	r4,r2
81109768:	1109ed40 	call	81109ed4 <uliRmapReadReg>
8110976c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
81109770:	e0bffe17 	ldw	r2,-8(fp)
81109774:	1007883a 	mov	r3,r2
81109778:	e0bfff17 	ldw	r2,-4(fp)
8110977c:	10c02f0d 	sth	r3,188(r2)
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);
81109780:	e0bffe17 	ldw	r2,-8(fp)
81109784:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
81109788:	1007883a 	mov	r3,r2
8110978c:	e0bfff17 	ldw	r2,-4(fp)
81109790:	10c02f8d 	sth	r3,190(r2)
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109794:	e0bfff17 	ldw	r2,-4(fp)
81109798:	10800017 	ldw	r2,0(r2)
8110979c:	01402a84 	movi	r5,170
811097a0:	1009883a 	mov	r4,r2
811097a4:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811097a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
811097ac:	e0bffe17 	ldw	r2,-8(fp)
811097b0:	1007883a 	mov	r3,r2
811097b4:	e0bfff17 	ldw	r2,-4(fp)
811097b8:	10c0300d 	sth	r3,192(r2)
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);
811097bc:	e0bffe17 	ldw	r2,-8(fp)
811097c0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
811097c4:	1007883a 	mov	r3,r2
811097c8:	e0bfff17 	ldw	r2,-4(fp)
811097cc:	10c0308d 	sth	r3,194(r2)
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811097d0:	e0bfff17 	ldw	r2,-4(fp)
811097d4:	10800017 	ldw	r2,0(r2)
811097d8:	01402ac4 	movi	r5,171
811097dc:	1009883a 	mov	r4,r2
811097e0:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811097e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
811097e8:	e0bffe17 	ldw	r2,-8(fp)
811097ec:	1007883a 	mov	r3,r2
811097f0:	e0bfff17 	ldw	r2,-4(fp)
811097f4:	10c0310d 	sth	r3,196(r2)
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VREF_MSK) >> 16);
811097f8:	e0bffe17 	ldw	r2,-8(fp)
811097fc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
81109800:	1007883a 	mov	r3,r2
81109804:	e0bfff17 	ldw	r2,-4(fp)
81109808:	10c0318d 	sth	r3,198(r2)
				& COMM_RMAP_HK_5VREF_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110980c:	e0bfff17 	ldw	r2,-4(fp)
81109810:	10800017 	ldw	r2,0(r2)
81109814:	01402b04 	movi	r5,172
81109818:	1009883a 	mov	r4,r2
8110981c:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109820:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
81109824:	e0bffe17 	ldw	r2,-8(fp)
81109828:	1007883a 	mov	r3,r2
8110982c:	e0bfff17 	ldw	r2,-4(fp)
81109830:	10c0320d 	sth	r3,200(r2)
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);
81109834:	e0bffe17 	ldw	r2,-8(fp)
81109838:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
8110983c:	1007883a 	mov	r3,r2
81109840:	e0bfff17 	ldw	r2,-4(fp)
81109844:	10c0328d 	sth	r3,202(r2)
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109848:	e0bfff17 	ldw	r2,-4(fp)
8110984c:	10800017 	ldw	r2,0(r2)
81109850:	01402b44 	movi	r5,173
81109854:	1009883a 	mov	r4,r2
81109858:	1109ed40 	call	81109ed4 <uliRmapReadReg>
8110985c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
81109860:	e0bffe17 	ldw	r2,-8(fp)
81109864:	1007883a 	mov	r3,r2
81109868:	e0bfff17 	ldw	r2,-4(fp)
8110986c:	10c0330d 	sth	r3,204(r2)
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);
81109870:	e0bffe17 	ldw	r2,-8(fp)
81109874:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
81109878:	1007883a 	mov	r3,r2
8110987c:	e0bfff17 	ldw	r2,-4(fp)
81109880:	10c0338d 	sth	r3,206(r2)
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109884:	e0bfff17 	ldw	r2,-4(fp)
81109888:	10800017 	ldw	r2,0(r2)
8110988c:	01402b84 	movi	r5,174
81109890:	1009883a 	mov	r4,r2
81109894:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109898:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
8110989c:	e0bffe17 	ldw	r2,-8(fp)
811098a0:	1007883a 	mov	r3,r2
811098a4:	e0bfff17 	ldw	r2,-4(fp)
811098a8:	10c0340d 	sth	r3,208(r2)
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);
811098ac:	e0bffe17 	ldw	r2,-8(fp)
811098b0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
811098b4:	1007883a 	mov	r3,r2
811098b8:	e0bfff17 	ldw	r2,-4(fp)
811098bc:	10c0348d 	sth	r3,210(r2)
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811098c0:	e0bfff17 	ldw	r2,-4(fp)
811098c4:	10800017 	ldw	r2,0(r2)
811098c8:	01402bc4 	movi	r5,175
811098cc:	1009883a 	mov	r4,r2
811098d0:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811098d4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
811098d8:	e0bffe17 	ldw	r2,-8(fp)
811098dc:	1007883a 	mov	r3,r2
811098e0:	e0bfff17 	ldw	r2,-4(fp)
811098e4:	10c0350d 	sth	r3,212(r2)
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);
811098e8:	e0bffe17 	ldw	r2,-8(fp)
811098ec:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
811098f0:	1007883a 	mov	r3,r2
811098f4:	e0bfff17 	ldw	r2,-4(fp)
811098f8:	10c0358d 	sth	r3,214(r2)
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811098fc:	e0bfff17 	ldw	r2,-4(fp)
81109900:	10800017 	ldw	r2,0(r2)
81109904:	01402c04 	movi	r5,176
81109908:	1009883a 	mov	r4,r2
8110990c:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109910:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
81109914:	e0bffe17 	ldw	r2,-8(fp)
81109918:	1007883a 	mov	r3,r2
8110991c:	e0bfff17 	ldw	r2,-4(fp)
81109920:	10c0360d 	sth	r3,216(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);
81109924:	e0bffe17 	ldw	r2,-8(fp)
81109928:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
8110992c:	1007883a 	mov	r3,r2
81109930:	e0bfff17 	ldw	r2,-4(fp)
81109934:	10c0368d 	sth	r3,218(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109938:	e0bfff17 	ldw	r2,-4(fp)
8110993c:	10800017 	ldw	r2,0(r2)
81109940:	01402c44 	movi	r5,177
81109944:	1009883a 	mov	r4,r2
81109948:	1109ed40 	call	81109ed4 <uliRmapReadReg>
8110994c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
81109950:	e0bffe17 	ldw	r2,-8(fp)
81109954:	1007883a 	mov	r3,r2
81109958:	e0bfff17 	ldw	r2,-4(fp)
8110995c:	10c0370d 	sth	r3,220(r2)
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);
81109960:	e0bffe17 	ldw	r2,-8(fp)
81109964:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
81109968:	1007883a 	mov	r3,r2
8110996c:	e0bfff17 	ldw	r2,-4(fp)
81109970:	10c0378d 	sth	r3,222(r2)
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109974:	e0bfff17 	ldw	r2,-4(fp)
81109978:	10800017 	ldw	r2,0(r2)
8110997c:	01402c84 	movi	r5,178
81109980:	1009883a 	mov	r4,r2
81109984:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109988:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
8110998c:	e0bffe17 	ldw	r2,-8(fp)
81109990:	1007883a 	mov	r3,r2
81109994:	e0bfff17 	ldw	r2,-4(fp)
81109998:	10c0380d 	sth	r3,224(r2)
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);
8110999c:	e0bffe17 	ldw	r2,-8(fp)
811099a0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
811099a4:	1007883a 	mov	r3,r2
811099a8:	e0bfff17 	ldw	r2,-4(fp)
811099ac:	10c0388d 	sth	r3,226(r2)
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811099b0:	e0bfff17 	ldw	r2,-4(fp)
811099b4:	10800017 	ldw	r2,0(r2)
811099b8:	01402cc4 	movi	r5,179
811099bc:	1009883a 	mov	r4,r2
811099c0:	1109ed40 	call	81109ed4 <uliRmapReadReg>
811099c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
811099c8:	e0bffe17 	ldw	r2,-8(fp)
811099cc:	1007883a 	mov	r3,r2
811099d0:	e0bfff17 	ldw	r2,-4(fp)
811099d4:	10c0390d 	sth	r3,228(r2)
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);
811099d8:	e0bffe17 	ldw	r2,-8(fp)
811099dc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
811099e0:	1007883a 	mov	r3,r2
811099e4:	e0bfff17 	ldw	r2,-4(fp)
811099e8:	10c0398d 	sth	r3,230(r2)
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811099ec:	e0bfff17 	ldw	r2,-4(fp)
811099f0:	10800017 	ldw	r2,0(r2)
811099f4:	01402d04 	movi	r5,180
811099f8:	1009883a 	mov	r4,r2
811099fc:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109a00:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
81109a04:	e0bffe17 	ldw	r2,-8(fp)
81109a08:	1007883a 	mov	r3,r2
81109a0c:	e0bfff17 	ldw	r2,-4(fp)
81109a10:	10c03a0d 	sth	r3,232(r2)
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);
81109a14:	e0bffe17 	ldw	r2,-8(fp)
81109a18:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
81109a1c:	1007883a 	mov	r3,r2
81109a20:	e0bfff17 	ldw	r2,-4(fp)
81109a24:	10c03a8d 	sth	r3,234(r2)
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a28:	e0bfff17 	ldw	r2,-4(fp)
81109a2c:	10800017 	ldw	r2,0(r2)
81109a30:	01402d44 	movi	r5,181
81109a34:	1009883a 	mov	r4,r2
81109a38:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109a3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
81109a40:	e0bffe17 	ldw	r2,-8(fp)
81109a44:	1007883a 	mov	r3,r2
81109a48:	e0bfff17 	ldw	r2,-4(fp)
81109a4c:	10c03b0d 	sth	r3,236(r2)
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);
81109a50:	e0bffe17 	ldw	r2,-8(fp)
81109a54:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
81109a58:	1007883a 	mov	r3,r2
81109a5c:	e0bfff17 	ldw	r2,-4(fp)
81109a60:	10c03b8d 	sth	r3,238(r2)
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109a64:	e0bfff17 	ldw	r2,-4(fp)
81109a68:	10800017 	ldw	r2,0(r2)
81109a6c:	01402d84 	movi	r5,182
81109a70:	1009883a 	mov	r4,r2
81109a74:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109a78:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
81109a7c:	e0bffe17 	ldw	r2,-8(fp)
81109a80:	1007883a 	mov	r3,r2
81109a84:	e0bfff17 	ldw	r2,-4(fp)
81109a88:	10c03c0d 	sth	r3,240(r2)
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);
81109a8c:	e0bffe17 	ldw	r2,-8(fp)
81109a90:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
81109a94:	1007883a 	mov	r3,r2
81109a98:	e0bfff17 	ldw	r2,-4(fp)
81109a9c:	10c03c8d 	sth	r3,242(r2)
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109aa0:	e0bfff17 	ldw	r2,-4(fp)
81109aa4:	10800017 	ldw	r2,0(r2)
81109aa8:	01402dc4 	movi	r5,183
81109aac:	1009883a 	mov	r4,r2
81109ab0:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109ab4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
81109ab8:	e0bffe17 	ldw	r2,-8(fp)
81109abc:	1007883a 	mov	r3,r2
81109ac0:	e0bfff17 	ldw	r2,-4(fp)
81109ac4:	10c03d0d 	sth	r3,244(r2)
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);
81109ac8:	e0bffe17 	ldw	r2,-8(fp)
81109acc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
81109ad0:	1007883a 	mov	r3,r2
81109ad4:	e0bfff17 	ldw	r2,-4(fp)
81109ad8:	10c03d8d 	sth	r3,246(r2)
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109adc:	e0bfff17 	ldw	r2,-4(fp)
81109ae0:	10800017 	ldw	r2,0(r2)
81109ae4:	01402e04 	movi	r5,184
81109ae8:	1009883a 	mov	r4,r2
81109aec:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109af0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
81109af4:	e0bffe17 	ldw	r2,-8(fp)
81109af8:	1007883a 	mov	r3,r2
81109afc:	e0bfff17 	ldw	r2,-4(fp)
81109b00:	10c03e0d 	sth	r3,248(r2)
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);
81109b04:	e0bffe17 	ldw	r2,-8(fp)
81109b08:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
81109b0c:	1007883a 	mov	r3,r2
81109b10:	e0bfff17 	ldw	r2,-4(fp)
81109b14:	10c03e8d 	sth	r3,250(r2)
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b18:	e0bfff17 	ldw	r2,-4(fp)
81109b1c:	10800017 	ldw	r2,0(r2)
81109b20:	01402e44 	movi	r5,185
81109b24:	1009883a 	mov	r4,r2
81109b28:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109b2c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
81109b30:	e0bffe17 	ldw	r2,-8(fp)
81109b34:	1007883a 	mov	r3,r2
81109b38:	e0bfff17 	ldw	r2,-4(fp)
81109b3c:	10c03f0d 	sth	r3,252(r2)
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);
81109b40:	e0bffe17 	ldw	r2,-8(fp)
81109b44:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
81109b48:	1007883a 	mov	r3,r2
81109b4c:	e0bfff17 	ldw	r2,-4(fp)
81109b50:	10c03f8d 	sth	r3,254(r2)
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b54:	e0bfff17 	ldw	r2,-4(fp)
81109b58:	10800017 	ldw	r2,0(r2)
81109b5c:	01402e84 	movi	r5,186
81109b60:	1009883a 	mov	r4,r2
81109b64:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109b68:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
81109b6c:	e0bffe17 	ldw	r2,-8(fp)
81109b70:	1007883a 	mov	r3,r2
81109b74:	e0bfff17 	ldw	r2,-4(fp)
81109b78:	10c0400d 	sth	r3,256(r2)
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);
81109b7c:	e0bffe17 	ldw	r2,-8(fp)
81109b80:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
81109b84:	1007883a 	mov	r3,r2
81109b88:	e0bfff17 	ldw	r2,-4(fp)
81109b8c:	10c0408d 	sth	r3,258(r2)
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109b90:	e0bfff17 	ldw	r2,-4(fp)
81109b94:	10800017 	ldw	r2,0(r2)
81109b98:	01402ec4 	movi	r5,187
81109b9c:	1009883a 	mov	r4,r2
81109ba0:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109ba4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
81109ba8:	e0bffe17 	ldw	r2,-8(fp)
81109bac:	1007883a 	mov	r3,r2
81109bb0:	e0bfff17 	ldw	r2,-4(fp)
81109bb4:	10c0410d 	sth	r3,260(r2)
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);
81109bb8:	e0bffe17 	ldw	r2,-8(fp)
81109bbc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
81109bc0:	1007883a 	mov	r3,r2
81109bc4:	e0bfff17 	ldw	r2,-4(fp)
81109bc8:	10c0418d 	sth	r3,262(r2)
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109bcc:	e0bfff17 	ldw	r2,-4(fp)
81109bd0:	10800017 	ldw	r2,0(r2)
81109bd4:	01402f04 	movi	r5,188
81109bd8:	1009883a 	mov	r4,r2
81109bdc:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109be0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
81109be4:	e0bffe17 	ldw	r2,-8(fp)
81109be8:	1007883a 	mov	r3,r2
81109bec:	e0bfff17 	ldw	r2,-4(fp)
81109bf0:	10c0420d 	sth	r3,264(r2)
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);
81109bf4:	e0bffe17 	ldw	r2,-8(fp)
81109bf8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
81109bfc:	1007883a 	mov	r3,r2
81109c00:	e0bfff17 	ldw	r2,-4(fp)
81109c04:	10c0428d 	sth	r3,266(r2)
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109c08:	e0bfff17 	ldw	r2,-4(fp)
81109c0c:	10800017 	ldw	r2,0(r2)
81109c10:	01402f44 	movi	r5,189
81109c14:	1009883a 	mov	r4,r2
81109c18:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109c1c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
81109c20:	e0bffe17 	ldw	r2,-8(fp)
81109c24:	1007883a 	mov	r3,r2
81109c28:	e0bfff17 	ldw	r2,-4(fp)
81109c2c:	10c0430d 	sth	r3,268(r2)
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);
81109c30:	e0bffe17 	ldw	r2,-8(fp)
81109c34:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
81109c38:	1007883a 	mov	r3,r2
81109c3c:	e0bfff17 	ldw	r2,-4(fp)
81109c40:	10c0438d 	sth	r3,270(r2)
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109c44:	e0bfff17 	ldw	r2,-4(fp)
81109c48:	10800017 	ldw	r2,0(r2)
81109c4c:	01402f84 	movi	r5,190
81109c50:	1009883a 	mov	r4,r2
81109c54:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109c58:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
81109c5c:	e0bffe17 	ldw	r2,-8(fp)
81109c60:	1007883a 	mov	r3,r2
81109c64:	e0bfff17 	ldw	r2,-4(fp)
81109c68:	10c0440d 	sth	r3,272(r2)
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);
81109c6c:	e0bffe17 	ldw	r2,-8(fp)
81109c70:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
81109c74:	1007883a 	mov	r3,r2
81109c78:	e0bfff17 	ldw	r2,-4(fp)
81109c7c:	10c0448d 	sth	r3,274(r2)
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109c80:	e0bfff17 	ldw	r2,-4(fp)
81109c84:	10800017 	ldw	r2,0(r2)
81109c88:	01402fc4 	movi	r5,191
81109c8c:	1009883a 	mov	r4,r2
81109c90:	1109ed40 	call	81109ed4 <uliRmapReadReg>
81109c94:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
81109c98:	e0bffe17 	ldw	r2,-8(fp)
81109c9c:	1007883a 	mov	r3,r2
81109ca0:	e0bfff17 	ldw	r2,-4(fp)
81109ca4:	10c0450d 	sth	r3,276(r2)
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);
81109ca8:	e0bffe17 	ldw	r2,-8(fp)
81109cac:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
81109cb0:	1007883a 	mov	r3,r2
81109cb4:	e0bfff17 	ldw	r2,-4(fp)
81109cb8:	10c0458d 	sth	r3,278(r2)
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);

		bStatus = TRUE;
81109cbc:	00800044 	movi	r2,1
81109cc0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109cc4:	e0bffd17 	ldw	r2,-12(fp)
}
81109cc8:	e037883a 	mov	sp,fp
81109ccc:	dfc00117 	ldw	ra,4(sp)
81109cd0:	df000017 	ldw	fp,0(sp)
81109cd4:	dec00204 	addi	sp,sp,8
81109cd8:	f800283a 	ret

81109cdc <bRmapInitCh>:

bool bRmapInitCh(TRmapChannel *pxRmapCh, alt_u8 ucCommCh) {
81109cdc:	defffb04 	addi	sp,sp,-20
81109ce0:	de00012e 	bgeu	sp,et,81109ce8 <bRmapInitCh+0xc>
81109ce4:	003b68fa 	trap	3
81109ce8:	dfc00415 	stw	ra,16(sp)
81109cec:	df000315 	stw	fp,12(sp)
81109cf0:	df000304 	addi	fp,sp,12
81109cf4:	e13ffe15 	stw	r4,-8(fp)
81109cf8:	2805883a 	mov	r2,r5
81109cfc:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81109d00:	e03ffd15 	stw	zero,-12(fp)

	if (pxRmapCh != NULL) {
81109d04:	e0bffe17 	ldw	r2,-8(fp)
81109d08:	10005726 	beq	r2,zero,81109e68 <bRmapInitCh+0x18c>
		bStatus = TRUE;
81109d0c:	00800044 	movi	r2,1
81109d10:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81109d14:	e0bfff03 	ldbu	r2,-4(fp)
81109d18:	10c00228 	cmpgeui	r3,r2,8
81109d1c:	1800361e 	bne	r3,zero,81109df8 <bRmapInitCh+0x11c>
81109d20:	100690ba 	slli	r3,r2,2
81109d24:	00a04474 	movhi	r2,33041
81109d28:	10a74e04 	addi	r2,r2,-25288
81109d2c:	1885883a 	add	r2,r3,r2
81109d30:	10800017 	ldw	r2,0(r2)
81109d34:	1000683a 	jmp	r2
81109d38:	81109d58 	cmpnei	r4,r16,17013
81109d3c:	81109d6c 	andhi	r4,r16,17013
81109d40:	81109d80 	call	881109d8 <__reset+0x20f09d8>
81109d44:	81109d94 	ori	r4,r16,17014
81109d48:	81109da8 	cmpgeui	r4,r16,17014
81109d4c:	81109dbc 	xorhi	r4,r16,17014
81109d50:	81109dd0 	cmplti	r4,r16,17015
81109d54:	81109de4 	muli	r4,r16,17015
		case eCommSpwCh1:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81109d58:	e0fffe17 	ldw	r3,-8(fp)
81109d5c:	00a04834 	movhi	r2,33056
81109d60:	108b0004 	addi	r2,r2,11264
81109d64:	18800015 	stw	r2,0(r3)
			break;
81109d68:	00002506 	br	81109e00 <bRmapInitCh+0x124>
		case eCommSpwCh2:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81109d6c:	e0fffe17 	ldw	r3,-8(fp)
81109d70:	00a04834 	movhi	r2,33056
81109d74:	108a0004 	addi	r2,r2,10240
81109d78:	18800015 	stw	r2,0(r3)
			break;
81109d7c:	00002006 	br	81109e00 <bRmapInitCh+0x124>
		case eCommSpwCh3:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81109d80:	e0fffe17 	ldw	r3,-8(fp)
81109d84:	00a04834 	movhi	r2,33056
81109d88:	108b0004 	addi	r2,r2,11264
81109d8c:	18800015 	stw	r2,0(r3)
			break;
81109d90:	00001b06 	br	81109e00 <bRmapInitCh+0x124>
		case eCommSpwCh4:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81109d94:	e0fffe17 	ldw	r3,-8(fp)
81109d98:	00a04834 	movhi	r2,33056
81109d9c:	108a0004 	addi	r2,r2,10240
81109da0:	18800015 	stw	r2,0(r3)
			break;
81109da4:	00001606 	br	81109e00 <bRmapInitCh+0x124>
		case eCommSpwCh5:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81109da8:	e0fffe17 	ldw	r3,-8(fp)
81109dac:	00a04834 	movhi	r2,33056
81109db0:	108b0004 	addi	r2,r2,11264
81109db4:	18800015 	stw	r2,0(r3)
			break;
81109db8:	00001106 	br	81109e00 <bRmapInitCh+0x124>
		case eCommSpwCh6:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81109dbc:	e0fffe17 	ldw	r3,-8(fp)
81109dc0:	00a04834 	movhi	r2,33056
81109dc4:	108a0004 	addi	r2,r2,10240
81109dc8:	18800015 	stw	r2,0(r3)
			break;
81109dcc:	00000c06 	br	81109e00 <bRmapInitCh+0x124>
		case eCommSpwCh7:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81109dd0:	e0fffe17 	ldw	r3,-8(fp)
81109dd4:	00a04834 	movhi	r2,33056
81109dd8:	108b0004 	addi	r2,r2,11264
81109ddc:	18800015 	stw	r2,0(r3)
			break;
81109de0:	00000706 	br	81109e00 <bRmapInitCh+0x124>
		case eCommSpwCh8:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81109de4:	e0fffe17 	ldw	r3,-8(fp)
81109de8:	00a04834 	movhi	r2,33056
81109dec:	108a0004 	addi	r2,r2,10240
81109df0:	18800015 	stw	r2,0(r3)
			break;
81109df4:	00000206 	br	81109e00 <bRmapInitCh+0x124>
		default:
			bStatus = FALSE;
81109df8:	e03ffd15 	stw	zero,-12(fp)
			break;
81109dfc:	0001883a 	nop
		}

		if (bStatus) {
81109e00:	e0bffd17 	ldw	r2,-12(fp)
81109e04:	10001826 	beq	r2,zero,81109e68 <bRmapInitCh+0x18c>
			if (!bRmapGetIrqControl(pxRmapCh)) {
81109e08:	e13ffe17 	ldw	r4,-8(fp)
81109e0c:	110793c0 	call	8110793c <bRmapGetIrqControl>
81109e10:	1000011e 	bne	r2,zero,81109e18 <bRmapInitCh+0x13c>
				bStatus = FALSE;
81109e14:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecConfig(pxRmapCh)) {
81109e18:	e13ffe17 	ldw	r4,-8(fp)
81109e1c:	1107b240 	call	81107b24 <bRmapGetCodecConfig>
81109e20:	1000011e 	bne	r2,zero,81109e28 <bRmapInitCh+0x14c>
				bStatus = FALSE;
81109e24:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecStatus(pxRmapCh)) {
81109e28:	e13ffe17 	ldw	r4,-8(fp)
81109e2c:	1107bb00 	call	81107bb0 <bRmapGetCodecStatus>
81109e30:	1000011e 	bne	r2,zero,81109e38 <bRmapInitCh+0x15c>
				bStatus = FALSE;
81109e34:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigArea(pxRmapCh)) {
81109e38:	e13ffe17 	ldw	r4,-8(fp)
81109e3c:	110815c0 	call	8110815c <bRmapGetMemConfigArea>
81109e40:	1000011e 	bne	r2,zero,81109e48 <bRmapInitCh+0x16c>
				bStatus = FALSE;
81109e44:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigStat(pxRmapCh)) {
81109e48:	e13ffe17 	ldw	r4,-8(fp)
81109e4c:	11084300 	call	81108430 <bRmapGetMemConfigStat>
81109e50:	1000011e 	bne	r2,zero,81109e58 <bRmapInitCh+0x17c>
				bStatus = FALSE;
81109e54:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetRmapMemHKArea(pxRmapCh)) {
81109e58:	e13ffe17 	ldw	r4,-8(fp)
81109e5c:	11095100 	call	81109510 <bRmapGetRmapMemHKArea>
81109e60:	1000011e 	bne	r2,zero,81109e68 <bRmapInitCh+0x18c>
				bStatus = FALSE;
81109e64:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81109e68:	e0bffd17 	ldw	r2,-12(fp)
}
81109e6c:	e037883a 	mov	sp,fp
81109e70:	dfc00117 	ldw	ra,4(sp)
81109e74:	df000017 	ldw	fp,0(sp)
81109e78:	dec00204 	addi	sp,sp,8
81109e7c:	f800283a 	ret

81109e80 <vRmapWriteReg>:
//! [public functions]

//! [private functions]
static void vRmapWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81109e80:	defffc04 	addi	sp,sp,-16
81109e84:	de00012e 	bgeu	sp,et,81109e8c <vRmapWriteReg+0xc>
81109e88:	003b68fa 	trap	3
81109e8c:	df000315 	stw	fp,12(sp)
81109e90:	df000304 	addi	fp,sp,12
81109e94:	e13ffd15 	stw	r4,-12(fp)
81109e98:	e17ffe15 	stw	r5,-8(fp)
81109e9c:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81109ea0:	e0bffe17 	ldw	r2,-8(fp)
81109ea4:	1085883a 	add	r2,r2,r2
81109ea8:	1085883a 	add	r2,r2,r2
81109eac:	1007883a 	mov	r3,r2
81109eb0:	e0bffd17 	ldw	r2,-12(fp)
81109eb4:	10c5883a 	add	r2,r2,r3
81109eb8:	e0ffff17 	ldw	r3,-4(fp)
81109ebc:	10c00015 	stw	r3,0(r2)
}
81109ec0:	0001883a 	nop
81109ec4:	e037883a 	mov	sp,fp
81109ec8:	df000017 	ldw	fp,0(sp)
81109ecc:	dec00104 	addi	sp,sp,4
81109ed0:	f800283a 	ret

81109ed4 <uliRmapReadReg>:

alt_u32 uliRmapReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81109ed4:	defffc04 	addi	sp,sp,-16
81109ed8:	de00012e 	bgeu	sp,et,81109ee0 <uliRmapReadReg+0xc>
81109edc:	003b68fa 	trap	3
81109ee0:	df000315 	stw	fp,12(sp)
81109ee4:	df000304 	addi	fp,sp,12
81109ee8:	e13ffe15 	stw	r4,-8(fp)
81109eec:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81109ef0:	e0bfff17 	ldw	r2,-4(fp)
81109ef4:	1085883a 	add	r2,r2,r2
81109ef8:	1085883a 	add	r2,r2,r2
81109efc:	1007883a 	mov	r3,r2
81109f00:	e0bffe17 	ldw	r2,-8(fp)
81109f04:	10c5883a 	add	r2,r2,r3
81109f08:	10800017 	ldw	r2,0(r2)
81109f0c:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81109f10:	e0bffd17 	ldw	r2,-12(fp)
}
81109f14:	e037883a 	mov	sp,fp
81109f18:	df000017 	ldw	fp,0(sp)
81109f1c:	dec00104 	addi	sp,sp,4
81109f20:	f800283a 	ret

81109f24 <uliConvRmapCfgAddr>:

static alt_u32 uliConvRmapCfgAddr(alt_u32 puliRmapAddr) {
81109f24:	defffd04 	addi	sp,sp,-12
81109f28:	de00012e 	bgeu	sp,et,81109f30 <uliConvRmapCfgAddr+0xc>
81109f2c:	003b68fa 	trap	3
81109f30:	df000215 	stw	fp,8(sp)
81109f34:	df000204 	addi	fp,sp,8
81109f38:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliValue;

	switch (puliRmapAddr) {
81109f3c:	e0bfff17 	ldw	r2,-4(fp)
81109f40:	10801368 	cmpgeui	r2,r2,77
81109f44:	10008a1e 	bne	r2,zero,8110a170 <uliConvRmapCfgAddr+0x24c>
81109f48:	e0bfff17 	ldw	r2,-4(fp)
81109f4c:	100690ba 	slli	r3,r2,2
81109f50:	00a04474 	movhi	r2,33041
81109f54:	10a7d904 	addi	r2,r2,-24732
81109f58:	1885883a 	add	r2,r3,r2
81109f5c:	10800017 	ldw	r2,0(r2)
81109f60:	1000683a 	jmp	r2
81109f64:	8110a098 	cmpnei	r4,r16,17026
81109f68:	8110a170 	cmpltui	r4,r16,17029
81109f6c:	8110a170 	cmpltui	r4,r16,17029
81109f70:	8110a170 	cmpltui	r4,r16,17029
81109f74:	8110a0a4 	muli	r4,r16,17026
81109f78:	8110a170 	cmpltui	r4,r16,17029
81109f7c:	8110a170 	cmpltui	r4,r16,17029
81109f80:	8110a170 	cmpltui	r4,r16,17029
81109f84:	8110a0b0 	cmpltui	r4,r16,17026
81109f88:	8110a170 	cmpltui	r4,r16,17029
81109f8c:	8110a170 	cmpltui	r4,r16,17029
81109f90:	8110a170 	cmpltui	r4,r16,17029
81109f94:	8110a0bc 	xorhi	r4,r16,17026
81109f98:	8110a170 	cmpltui	r4,r16,17029
81109f9c:	8110a170 	cmpltui	r4,r16,17029
81109fa0:	8110a170 	cmpltui	r4,r16,17029
81109fa4:	8110a0c8 	cmpgei	r4,r16,17027
81109fa8:	8110a170 	cmpltui	r4,r16,17029
81109fac:	8110a170 	cmpltui	r4,r16,17029
81109fb0:	8110a170 	cmpltui	r4,r16,17029
81109fb4:	8110a0d4 	ori	r4,r16,17027
81109fb8:	8110a170 	cmpltui	r4,r16,17029
81109fbc:	8110a170 	cmpltui	r4,r16,17029
81109fc0:	8110a170 	cmpltui	r4,r16,17029
81109fc4:	8110a0e0 	cmpeqi	r4,r16,17027
81109fc8:	8110a170 	cmpltui	r4,r16,17029
81109fcc:	8110a170 	cmpltui	r4,r16,17029
81109fd0:	8110a170 	cmpltui	r4,r16,17029
81109fd4:	8110a0ec 	andhi	r4,r16,17027
81109fd8:	8110a170 	cmpltui	r4,r16,17029
81109fdc:	8110a170 	cmpltui	r4,r16,17029
81109fe0:	8110a170 	cmpltui	r4,r16,17029
81109fe4:	8110a0f8 	rdprs	r4,r16,17027
81109fe8:	8110a170 	cmpltui	r4,r16,17029
81109fec:	8110a170 	cmpltui	r4,r16,17029
81109ff0:	8110a170 	cmpltui	r4,r16,17029
81109ff4:	8110a104 	addi	r4,r16,17028
81109ff8:	8110a170 	cmpltui	r4,r16,17029
81109ffc:	8110a170 	cmpltui	r4,r16,17029
8110a000:	8110a170 	cmpltui	r4,r16,17029
8110a004:	8110a110 	cmplti	r4,r16,17028
8110a008:	8110a170 	cmpltui	r4,r16,17029
8110a00c:	8110a170 	cmpltui	r4,r16,17029
8110a010:	8110a170 	cmpltui	r4,r16,17029
8110a014:	8110a11c 	xori	r4,r16,17028
8110a018:	8110a170 	cmpltui	r4,r16,17029
8110a01c:	8110a170 	cmpltui	r4,r16,17029
8110a020:	8110a170 	cmpltui	r4,r16,17029
8110a024:	8110a170 	cmpltui	r4,r16,17029
8110a028:	8110a170 	cmpltui	r4,r16,17029
8110a02c:	8110a170 	cmpltui	r4,r16,17029
8110a030:	8110a170 	cmpltui	r4,r16,17029
8110a034:	8110a170 	cmpltui	r4,r16,17029
8110a038:	8110a170 	cmpltui	r4,r16,17029
8110a03c:	8110a170 	cmpltui	r4,r16,17029
8110a040:	8110a170 	cmpltui	r4,r16,17029
8110a044:	8110a128 	cmpgeui	r4,r16,17028
8110a048:	8110a170 	cmpltui	r4,r16,17029
8110a04c:	8110a170 	cmpltui	r4,r16,17029
8110a050:	8110a170 	cmpltui	r4,r16,17029
8110a054:	8110a134 	orhi	r4,r16,17028
8110a058:	8110a170 	cmpltui	r4,r16,17029
8110a05c:	8110a170 	cmpltui	r4,r16,17029
8110a060:	8110a170 	cmpltui	r4,r16,17029
8110a064:	8110a140 	call	88110a14 <__reset+0x20f0a14>
8110a068:	8110a170 	cmpltui	r4,r16,17029
8110a06c:	8110a170 	cmpltui	r4,r16,17029
8110a070:	8110a170 	cmpltui	r4,r16,17029
8110a074:	8110a14c 	andi	r4,r16,17029
8110a078:	8110a170 	cmpltui	r4,r16,17029
8110a07c:	8110a170 	cmpltui	r4,r16,17029
8110a080:	8110a170 	cmpltui	r4,r16,17029
8110a084:	8110a158 	cmpnei	r4,r16,17029
8110a088:	8110a170 	cmpltui	r4,r16,17029
8110a08c:	8110a170 	cmpltui	r4,r16,17029
8110a090:	8110a170 	cmpltui	r4,r16,17029
8110a094:	8110a164 	muli	r4,r16,17029
	case 0x00000000:
		uliValue = 0x00000040;
8110a098:	00801004 	movi	r2,64
8110a09c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0a0:	00003506 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	case 0x00000004:
		uliValue = 0x00000041;
8110a0a4:	00801044 	movi	r2,65
8110a0a8:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0ac:	00003206 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	case 0x00000008:
		uliValue = 0x00000042;
8110a0b0:	00801084 	movi	r2,66
8110a0b4:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0b8:	00002f06 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	case 0x0000000C:
		uliValue = 0x00000043;
8110a0bc:	008010c4 	movi	r2,67
8110a0c0:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0c4:	00002c06 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	case 0x00000010:
		uliValue = 0x00000044;
8110a0c8:	00801104 	movi	r2,68
8110a0cc:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0d0:	00002906 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	case 0x00000014:
		uliValue = 0x00000045;
8110a0d4:	00801144 	movi	r2,69
8110a0d8:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0dc:	00002606 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	case 0x00000018:
		uliValue = 0x00000046;
8110a0e0:	00801184 	movi	r2,70
8110a0e4:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0e8:	00002306 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	case 0x0000001C:
		uliValue = 0x00000047;
8110a0ec:	008011c4 	movi	r2,71
8110a0f0:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a0f4:	00002006 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	case 0x00000020:
		uliValue = 0x00000048;
8110a0f8:	00801204 	movi	r2,72
8110a0fc:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a100:	00001d06 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	case 0x00000024:
		uliValue = 0x00000049;
8110a104:	00801244 	movi	r2,73
8110a108:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a10c:	00001a06 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	case 0x00000028:
		uliValue = 0x0000004A;
8110a110:	00801284 	movi	r2,74
8110a114:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a118:	00001706 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	case 0x0000002C:
		uliValue = 0x0000004B;
8110a11c:	008012c4 	movi	r2,75
8110a120:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a124:	00001406 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	case 0x00000038:
		uliValue = 0x0000004C;
8110a128:	00801304 	movi	r2,76
8110a12c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a130:	00001106 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	case 0x0000003C:
		uliValue = 0x0000004D;
8110a134:	00801344 	movi	r2,77
8110a138:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a13c:	00000e06 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	case 0x00000040:
		uliValue = 0x0000004E;
8110a140:	00801384 	movi	r2,78
8110a144:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a148:	00000b06 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	case 0x00000044:
		uliValue = 0x0000004F;
8110a14c:	008013c4 	movi	r2,79
8110a150:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a154:	00000806 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	case 0x00000048:
		uliValue = 0x00000050;
8110a158:	00801404 	movi	r2,80
8110a15c:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a160:	00000506 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	case 0x0000004C:
		uliValue = 0x00000051;
8110a164:	00801444 	movi	r2,81
8110a168:	e0bffe15 	stw	r2,-8(fp)
		break;
8110a16c:	00000206 	br	8110a178 <uliConvRmapCfgAddr+0x254>
	default:
		uliValue = 0x00000000;
8110a170:	e03ffe15 	stw	zero,-8(fp)
		break;
8110a174:	0001883a 	nop
	}

	return uliValue;
8110a178:	e0bffe17 	ldw	r2,-8(fp)
}
8110a17c:	e037883a 	mov	sp,fp
8110a180:	df000017 	ldw	fp,0(sp)
8110a184:	dec00104 	addi	sp,sp,4
8110a188:	f800283a 	ret

8110a18c <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
8110a18c:	defffb04 	addi	sp,sp,-20
8110a190:	de00012e 	bgeu	sp,et,8110a198 <bSpwcSetLink+0xc>
8110a194:	003b68fa 	trap	3
8110a198:	dfc00415 	stw	ra,16(sp)
8110a19c:	df000315 	stw	fp,12(sp)
8110a1a0:	df000304 	addi	fp,sp,12
8110a1a4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a1a8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a1ac:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a1b0:	e0bfff17 	ldw	r2,-4(fp)
8110a1b4:	10003c26 	beq	r2,zero,8110a2a8 <bSpwcSetLink+0x11c>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a1b8:	e0bfff17 	ldw	r2,-4(fp)
8110a1bc:	10800017 	ldw	r2,0(r2)
8110a1c0:	000b883a 	mov	r5,zero
8110a1c4:	1009883a 	mov	r4,r2
8110a1c8:	110a8580 	call	8110a858 <uliSpwcReadReg>
8110a1cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
8110a1d0:	e0bfff17 	ldw	r2,-4(fp)
8110a1d4:	10800117 	ldw	r2,4(r2)
8110a1d8:	10000426 	beq	r2,zero,8110a1ec <bSpwcSetLink+0x60>
			uliReg |= COMM_SPW_LNKCFG_AUTOSTART_MSK;
8110a1dc:	e0bffe17 	ldw	r2,-8(fp)
8110a1e0:	10800114 	ori	r2,r2,4
8110a1e4:	e0bffe15 	stw	r2,-8(fp)
8110a1e8:	00000406 	br	8110a1fc <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_AUTOSTART_MSK);
8110a1ec:	e0fffe17 	ldw	r3,-8(fp)
8110a1f0:	00bffec4 	movi	r2,-5
8110a1f4:	1884703a 	and	r2,r3,r2
8110a1f8:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bLinkStart) {
8110a1fc:	e0bfff17 	ldw	r2,-4(fp)
8110a200:	10800217 	ldw	r2,8(r2)
8110a204:	10000426 	beq	r2,zero,8110a218 <bSpwcSetLink+0x8c>
			uliReg |= COMM_SPW_LNKCFG_LINKSTART_MSK;
8110a208:	e0bffe17 	ldw	r2,-8(fp)
8110a20c:	10800094 	ori	r2,r2,2
8110a210:	e0bffe15 	stw	r2,-8(fp)
8110a214:	00000406 	br	8110a228 <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_LINKSTART_MSK);
8110a218:	e0fffe17 	ldw	r3,-8(fp)
8110a21c:	00bfff44 	movi	r2,-3
8110a220:	1884703a 	and	r2,r3,r2
8110a224:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
8110a228:	e0bfff17 	ldw	r2,-4(fp)
8110a22c:	10800317 	ldw	r2,12(r2)
8110a230:	10000426 	beq	r2,zero,8110a244 <bSpwcSetLink+0xb8>
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
8110a234:	e0bffe17 	ldw	r2,-8(fp)
8110a238:	10800054 	ori	r2,r2,1
8110a23c:	e0bffe15 	stw	r2,-8(fp)
8110a240:	00000406 	br	8110a254 <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
8110a244:	e0fffe17 	ldw	r3,-8(fp)
8110a248:	00bfff84 	movi	r2,-2
8110a24c:	1884703a 	and	r2,r3,r2
8110a250:	e0bffe15 	stw	r2,-8(fp)
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
8110a254:	e0fffe17 	ldw	r3,-8(fp)
8110a258:	00804034 	movhi	r2,256
8110a25c:	10bfffc4 	addi	r2,r2,-1
8110a260:	1884703a 	and	r2,r3,r2
8110a264:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));
8110a268:	e0bfff17 	ldw	r2,-4(fp)
8110a26c:	10800403 	ldbu	r2,16(r2)
8110a270:	10803fcc 	andi	r2,r2,255
8110a274:	1004963a 	slli	r2,r2,24
8110a278:	1007883a 	mov	r3,r2
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
8110a27c:	e0bffe17 	ldw	r2,-8(fp)
8110a280:	10c4b03a 	or	r2,r2,r3
8110a284:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_LINK_CFG_STAT_REG_OFST,
8110a288:	e0bfff17 	ldw	r2,-4(fp)
8110a28c:	10800017 	ldw	r2,0(r2)
8110a290:	e1bffe17 	ldw	r6,-8(fp)
8110a294:	000b883a 	mov	r5,zero
8110a298:	1009883a 	mov	r4,r2
8110a29c:	110a8040 	call	8110a804 <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
8110a2a0:	00800044 	movi	r2,1
8110a2a4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a2a8:	e0bffd17 	ldw	r2,-12(fp)
}
8110a2ac:	e037883a 	mov	sp,fp
8110a2b0:	dfc00117 	ldw	ra,4(sp)
8110a2b4:	df000017 	ldw	fp,0(sp)
8110a2b8:	dec00204 	addi	sp,sp,8
8110a2bc:	f800283a 	ret

8110a2c0 <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
8110a2c0:	defffb04 	addi	sp,sp,-20
8110a2c4:	de00012e 	bgeu	sp,et,8110a2cc <bSpwcGetLink+0xc>
8110a2c8:	003b68fa 	trap	3
8110a2cc:	dfc00415 	stw	ra,16(sp)
8110a2d0:	df000315 	stw	fp,12(sp)
8110a2d4:	df000304 	addi	fp,sp,12
8110a2d8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a2dc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a2e0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a2e4:	e0bfff17 	ldw	r2,-4(fp)
8110a2e8:	10002826 	beq	r2,zero,8110a38c <bSpwcGetLink+0xcc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a2ec:	e0bfff17 	ldw	r2,-4(fp)
8110a2f0:	10800017 	ldw	r2,0(r2)
8110a2f4:	000b883a 	mov	r5,zero
8110a2f8:	1009883a 	mov	r4,r2
8110a2fc:	110a8580 	call	8110a858 <uliSpwcReadReg>
8110a300:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKCFG_AUTOSTART_MSK) {
8110a304:	e0bffe17 	ldw	r2,-8(fp)
8110a308:	1080010c 	andi	r2,r2,4
8110a30c:	10000426 	beq	r2,zero,8110a320 <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
8110a310:	e0bfff17 	ldw	r2,-4(fp)
8110a314:	00c00044 	movi	r3,1
8110a318:	10c00115 	stw	r3,4(r2)
8110a31c:	00000206 	br	8110a328 <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
8110a320:	e0bfff17 	ldw	r2,-4(fp)
8110a324:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_LINKSTART_MSK) {
8110a328:	e0bffe17 	ldw	r2,-8(fp)
8110a32c:	1080008c 	andi	r2,r2,2
8110a330:	10000426 	beq	r2,zero,8110a344 <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bLinkStart = TRUE;
8110a334:	e0bfff17 	ldw	r2,-4(fp)
8110a338:	00c00044 	movi	r3,1
8110a33c:	10c00215 	stw	r3,8(r2)
8110a340:	00000206 	br	8110a34c <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bLinkStart = FALSE;
8110a344:	e0bfff17 	ldw	r2,-4(fp)
8110a348:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
8110a34c:	e0bffe17 	ldw	r2,-8(fp)
8110a350:	1080004c 	andi	r2,r2,1
8110a354:	10000426 	beq	r2,zero,8110a368 <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
8110a358:	e0bfff17 	ldw	r2,-4(fp)
8110a35c:	00c00044 	movi	r3,1
8110a360:	10c00315 	stw	r3,12(r2)
8110a364:	00000206 	br	8110a370 <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
8110a368:	e0bfff17 	ldw	r2,-4(fp)
8110a36c:	10000315 	stw	zero,12(r2)
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);
8110a370:	e0bffe17 	ldw	r2,-8(fp)
8110a374:	1004d63a 	srli	r2,r2,24
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
8110a378:	1007883a 	mov	r3,r2
8110a37c:	e0bfff17 	ldw	r2,-4(fp)
8110a380:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);

		bStatus = TRUE;
8110a384:	00800044 	movi	r2,1
8110a388:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a38c:	e0bffd17 	ldw	r2,-12(fp)
}
8110a390:	e037883a 	mov	sp,fp
8110a394:	dfc00117 	ldw	ra,4(sp)
8110a398:	df000017 	ldw	fp,0(sp)
8110a39c:	dec00204 	addi	sp,sp,8
8110a3a0:	f800283a 	ret

8110a3a4 <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
8110a3a4:	defffb04 	addi	sp,sp,-20
8110a3a8:	de00012e 	bgeu	sp,et,8110a3b0 <bSpwcGetLinkError+0xc>
8110a3ac:	003b68fa 	trap	3
8110a3b0:	dfc00415 	stw	ra,16(sp)
8110a3b4:	df000315 	stw	fp,12(sp)
8110a3b8:	df000304 	addi	fp,sp,12
8110a3bc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a3c0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a3c4:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a3c8:	e0bfff17 	ldw	r2,-4(fp)
8110a3cc:	10002c26 	beq	r2,zero,8110a480 <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a3d0:	e0bfff17 	ldw	r2,-4(fp)
8110a3d4:	10800017 	ldw	r2,0(r2)
8110a3d8:	000b883a 	mov	r5,zero
8110a3dc:	1009883a 	mov	r4,r2
8110a3e0:	110a8580 	call	8110a858 <uliSpwcReadReg>
8110a3e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKERR_DISCONNECT_MSK) {
8110a3e8:	e0bffe17 	ldw	r2,-8(fp)
8110a3ec:	1080006c 	andhi	r2,r2,1
8110a3f0:	10000426 	beq	r2,zero,8110a404 <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
8110a3f4:	e0bfff17 	ldw	r2,-4(fp)
8110a3f8:	00c00044 	movi	r3,1
8110a3fc:	10c00515 	stw	r3,20(r2)
8110a400:	00000206 	br	8110a40c <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
8110a404:	e0bfff17 	ldw	r2,-4(fp)
8110a408:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_PARITY_MSK) {
8110a40c:	e0bffe17 	ldw	r2,-8(fp)
8110a410:	108000ac 	andhi	r2,r2,2
8110a414:	10000426 	beq	r2,zero,8110a428 <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
8110a418:	e0bfff17 	ldw	r2,-4(fp)
8110a41c:	00c00044 	movi	r3,1
8110a420:	10c00615 	stw	r3,24(r2)
8110a424:	00000206 	br	8110a430 <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
8110a428:	e0bfff17 	ldw	r2,-4(fp)
8110a42c:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_ESCAPE_MSK) {
8110a430:	e0bffe17 	ldw	r2,-8(fp)
8110a434:	1080012c 	andhi	r2,r2,4
8110a438:	10000426 	beq	r2,zero,8110a44c <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
8110a43c:	e0bfff17 	ldw	r2,-4(fp)
8110a440:	00c00044 	movi	r3,1
8110a444:	10c00715 	stw	r3,28(r2)
8110a448:	00000206 	br	8110a454 <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
8110a44c:	e0bfff17 	ldw	r2,-4(fp)
8110a450:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_CREDIT_MSK) {
8110a454:	e0bffe17 	ldw	r2,-8(fp)
8110a458:	1080022c 	andhi	r2,r2,8
8110a45c:	10000426 	beq	r2,zero,8110a470 <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
8110a460:	e0bfff17 	ldw	r2,-4(fp)
8110a464:	00c00044 	movi	r3,1
8110a468:	10c00815 	stw	r3,32(r2)
8110a46c:	00000206 	br	8110a478 <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
8110a470:	e0bfff17 	ldw	r2,-4(fp)
8110a474:	10000815 	stw	zero,32(r2)
		}

		bStatus = TRUE;
8110a478:	00800044 	movi	r2,1
8110a47c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a480:	e0bffd17 	ldw	r2,-12(fp)
}
8110a484:	e037883a 	mov	sp,fp
8110a488:	dfc00117 	ldw	ra,4(sp)
8110a48c:	df000017 	ldw	fp,0(sp)
8110a490:	dec00204 	addi	sp,sp,8
8110a494:	f800283a 	ret

8110a498 <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
8110a498:	defffb04 	addi	sp,sp,-20
8110a49c:	de00012e 	bgeu	sp,et,8110a4a4 <bSpwcGetLinkStatus+0xc>
8110a4a0:	003b68fa 	trap	3
8110a4a4:	dfc00415 	stw	ra,16(sp)
8110a4a8:	df000315 	stw	fp,12(sp)
8110a4ac:	df000304 	addi	fp,sp,12
8110a4b0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a4b4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a4b8:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a4bc:	e0bfff17 	ldw	r2,-4(fp)
8110a4c0:	10002326 	beq	r2,zero,8110a550 <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a4c4:	e0bfff17 	ldw	r2,-4(fp)
8110a4c8:	10800017 	ldw	r2,0(r2)
8110a4cc:	000b883a 	mov	r5,zero
8110a4d0:	1009883a 	mov	r4,r2
8110a4d4:	110a8580 	call	8110a858 <uliSpwcReadReg>
8110a4d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKSTAT_STARTED_MSK) {
8110a4dc:	e0bffe17 	ldw	r2,-8(fp)
8110a4e0:	1081000c 	andi	r2,r2,1024
8110a4e4:	10000426 	beq	r2,zero,8110a4f8 <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
8110a4e8:	e0bfff17 	ldw	r2,-4(fp)
8110a4ec:	00c00044 	movi	r3,1
8110a4f0:	10c00915 	stw	r3,36(r2)
8110a4f4:	00000206 	br	8110a500 <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
8110a4f8:	e0bfff17 	ldw	r2,-4(fp)
8110a4fc:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_CONNECTING_MSK) {
8110a500:	e0bffe17 	ldw	r2,-8(fp)
8110a504:	1080800c 	andi	r2,r2,512
8110a508:	10000426 	beq	r2,zero,8110a51c <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
8110a50c:	e0bfff17 	ldw	r2,-4(fp)
8110a510:	00c00044 	movi	r3,1
8110a514:	10c00a15 	stw	r3,40(r2)
8110a518:	00000206 	br	8110a524 <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
8110a51c:	e0bfff17 	ldw	r2,-4(fp)
8110a520:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_RUNNING_MSK) {
8110a524:	e0bffe17 	ldw	r2,-8(fp)
8110a528:	1080400c 	andi	r2,r2,256
8110a52c:	10000426 	beq	r2,zero,8110a540 <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
8110a530:	e0bfff17 	ldw	r2,-4(fp)
8110a534:	00c00044 	movi	r3,1
8110a538:	10c00b15 	stw	r3,44(r2)
8110a53c:	00000206 	br	8110a548 <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
8110a540:	e0bfff17 	ldw	r2,-4(fp)
8110a544:	10000b15 	stw	zero,44(r2)
		}

		bStatus = TRUE;
8110a548:	00800044 	movi	r2,1
8110a54c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a550:	e0bffd17 	ldw	r2,-12(fp)
}
8110a554:	e037883a 	mov	sp,fp
8110a558:	dfc00117 	ldw	ra,4(sp)
8110a55c:	df000017 	ldw	fp,0(sp)
8110a560:	dec00204 	addi	sp,sp,8
8110a564:	f800283a 	ret

8110a568 <bSpwcGetTimecode>:

bool bSpwcGetTimecode(TSpwcChannel *pxSpwcCh) {
8110a568:	defffb04 	addi	sp,sp,-20
8110a56c:	de00012e 	bgeu	sp,et,8110a574 <bSpwcGetTimecode+0xc>
8110a570:	003b68fa 	trap	3
8110a574:	dfc00415 	stw	ra,16(sp)
8110a578:	df000315 	stw	fp,12(sp)
8110a57c:	df000304 	addi	fp,sp,12
8110a580:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a584:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a588:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a58c:	e0bfff17 	ldw	r2,-4(fp)
8110a590:	10001326 	beq	r2,zero,8110a5e0 <bSpwcGetTimecode+0x78>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a594:	e0bfff17 	ldw	r2,-4(fp)
8110a598:	10800017 	ldw	r2,0(r2)
8110a59c:	01400044 	movi	r5,1
8110a5a0:	1009883a 	mov	r4,r2
8110a5a4:	110a8580 	call	8110a858 <uliSpwcReadReg>
8110a5a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
8110a5ac:	e0bffe17 	ldw	r2,-8(fp)
8110a5b0:	1080300c 	andi	r2,r2,192
8110a5b4:	1004d1ba 	srli	r2,r2,6

	if (pxSpwcCh != NULL) {
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
8110a5b8:	1007883a 	mov	r3,r2
8110a5bc:	e0bfff17 	ldw	r2,-4(fp)
8110a5c0:	10c00c05 	stb	r3,48(r2)
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
		pxSpwcCh->xTimecode.ucCounter= (alt_u8)(
8110a5c4:	e0bffe17 	ldw	r2,-8(fp)
8110a5c8:	10800fcc 	andi	r2,r2,63
8110a5cc:	1007883a 	mov	r3,r2
8110a5d0:	e0bfff17 	ldw	r2,-4(fp)
8110a5d4:	10c00c45 	stb	r3,49(r2)
				(uliReg & COMM_TIMECODE_TIME_MSK) >> 0);

		bStatus = TRUE;
8110a5d8:	00800044 	movi	r2,1
8110a5dc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a5e0:	e0bffd17 	ldw	r2,-12(fp)
}
8110a5e4:	e037883a 	mov	sp,fp
8110a5e8:	dfc00117 	ldw	ra,4(sp)
8110a5ec:	df000017 	ldw	fp,0(sp)
8110a5f0:	dec00204 	addi	sp,sp,8
8110a5f4:	f800283a 	ret

8110a5f8 <bSpwcClearTimecode>:

bool bSpwcClearTimecode(TSpwcChannel *pxSpwcCh) {
8110a5f8:	defffb04 	addi	sp,sp,-20
8110a5fc:	de00012e 	bgeu	sp,et,8110a604 <bSpwcClearTimecode+0xc>
8110a600:	003b68fa 	trap	3
8110a604:	dfc00415 	stw	ra,16(sp)
8110a608:	df000315 	stw	fp,12(sp)
8110a60c:	df000304 	addi	fp,sp,12
8110a610:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a614:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a618:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a61c:	e0bfff17 	ldw	r2,-4(fp)
8110a620:	10001126 	beq	r2,zero,8110a668 <bSpwcClearTimecode+0x70>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a624:	e0bfff17 	ldw	r2,-4(fp)
8110a628:	10800017 	ldw	r2,0(r2)
8110a62c:	01400044 	movi	r5,1
8110a630:	1009883a 	mov	r4,r2
8110a634:	110a8580 	call	8110a858 <uliSpwcReadReg>
8110a638:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		uliReg |= COMM_TIMECODE_CLR_MSK;
8110a63c:	e0bffe17 	ldw	r2,-8(fp)
8110a640:	10804014 	ori	r2,r2,256
8110a644:	e0bffe15 	stw	r2,-8(fp)

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_TIMECODE_REG_OFST, uliReg);
8110a648:	e0bfff17 	ldw	r2,-4(fp)
8110a64c:	10800017 	ldw	r2,0(r2)
8110a650:	e1bffe17 	ldw	r6,-8(fp)
8110a654:	01400044 	movi	r5,1
8110a658:	1009883a 	mov	r4,r2
8110a65c:	110a8040 	call	8110a804 <vSpwcWriteReg>
		bStatus = TRUE;
8110a660:	00800044 	movi	r2,1
8110a664:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a668:	e0bffd17 	ldw	r2,-12(fp)
}
8110a66c:	e037883a 	mov	sp,fp
8110a670:	dfc00117 	ldw	ra,4(sp)
8110a674:	df000017 	ldw	fp,0(sp)
8110a678:	dec00204 	addi	sp,sp,8
8110a67c:	f800283a 	ret

8110a680 <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
8110a680:	defffb04 	addi	sp,sp,-20
8110a684:	de00012e 	bgeu	sp,et,8110a68c <bSpwcInitCh+0xc>
8110a688:	003b68fa 	trap	3
8110a68c:	dfc00415 	stw	ra,16(sp)
8110a690:	df000315 	stw	fp,12(sp)
8110a694:	df000304 	addi	fp,sp,12
8110a698:	e13ffe15 	stw	r4,-8(fp)
8110a69c:	2805883a 	mov	r2,r5
8110a6a0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110a6a4:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
8110a6a8:	e0bffe17 	ldw	r2,-8(fp)
8110a6ac:	10004f26 	beq	r2,zero,8110a7ec <bSpwcInitCh+0x16c>
		bStatus = TRUE;
8110a6b0:	00800044 	movi	r2,1
8110a6b4:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
8110a6b8:	e0bfff03 	ldbu	r2,-4(fp)
8110a6bc:	10c00228 	cmpgeui	r3,r2,8
8110a6c0:	1800361e 	bne	r3,zero,8110a79c <bSpwcInitCh+0x11c>
8110a6c4:	100690ba 	slli	r3,r2,2
8110a6c8:	00a04474 	movhi	r2,33041
8110a6cc:	10a9b704 	addi	r2,r2,-22820
8110a6d0:	1885883a 	add	r2,r3,r2
8110a6d4:	10800017 	ldw	r2,0(r2)
8110a6d8:	1000683a 	jmp	r2
8110a6dc:	8110a6fc 	xorhi	r4,r16,17051
8110a6e0:	8110a710 	cmplti	r4,r16,17052
8110a6e4:	8110a724 	muli	r4,r16,17052
8110a6e8:	8110a738 	rdprs	r4,r16,17052
8110a6ec:	8110a74c 	andi	r4,r16,17053
8110a6f0:	8110a760 	cmpeqi	r4,r16,17053
8110a6f4:	8110a774 	orhi	r4,r16,17053
8110a6f8:	8110a788 	cmpgei	r4,r16,17054
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8110a6fc:	e0fffe17 	ldw	r3,-8(fp)
8110a700:	00a04834 	movhi	r2,33056
8110a704:	108b0004 	addi	r2,r2,11264
8110a708:	18800015 	stw	r2,0(r3)
			break;
8110a70c:	00002506 	br	8110a7a4 <bSpwcInitCh+0x124>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
8110a710:	e0fffe17 	ldw	r3,-8(fp)
8110a714:	00a04834 	movhi	r2,33056
8110a718:	108a0004 	addi	r2,r2,10240
8110a71c:	18800015 	stw	r2,0(r3)
			break;
8110a720:	00002006 	br	8110a7a4 <bSpwcInitCh+0x124>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
8110a724:	e0fffe17 	ldw	r3,-8(fp)
8110a728:	00a04834 	movhi	r2,33056
8110a72c:	108b0004 	addi	r2,r2,11264
8110a730:	18800015 	stw	r2,0(r3)
			break;
8110a734:	00001b06 	br	8110a7a4 <bSpwcInitCh+0x124>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8110a738:	e0fffe17 	ldw	r3,-8(fp)
8110a73c:	00a04834 	movhi	r2,33056
8110a740:	108a0004 	addi	r2,r2,10240
8110a744:	18800015 	stw	r2,0(r3)
			break;
8110a748:	00001606 	br	8110a7a4 <bSpwcInitCh+0x124>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
8110a74c:	e0fffe17 	ldw	r3,-8(fp)
8110a750:	00a04834 	movhi	r2,33056
8110a754:	108b0004 	addi	r2,r2,11264
8110a758:	18800015 	stw	r2,0(r3)
			break;
8110a75c:	00001106 	br	8110a7a4 <bSpwcInitCh+0x124>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
8110a760:	e0fffe17 	ldw	r3,-8(fp)
8110a764:	00a04834 	movhi	r2,33056
8110a768:	108a0004 	addi	r2,r2,10240
8110a76c:	18800015 	stw	r2,0(r3)
			break;
8110a770:	00000c06 	br	8110a7a4 <bSpwcInitCh+0x124>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
8110a774:	e0fffe17 	ldw	r3,-8(fp)
8110a778:	00a04834 	movhi	r2,33056
8110a77c:	108b0004 	addi	r2,r2,11264
8110a780:	18800015 	stw	r2,0(r3)
			break;
8110a784:	00000706 	br	8110a7a4 <bSpwcInitCh+0x124>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110a788:	e0fffe17 	ldw	r3,-8(fp)
8110a78c:	00a04834 	movhi	r2,33056
8110a790:	108a0004 	addi	r2,r2,10240
8110a794:	18800015 	stw	r2,0(r3)
			break;
8110a798:	00000206 	br	8110a7a4 <bSpwcInitCh+0x124>
		default:
			bStatus = FALSE;
8110a79c:	e03ffd15 	stw	zero,-12(fp)
			break;
8110a7a0:	0001883a 	nop
		}

		if (bStatus) {
8110a7a4:	e0bffd17 	ldw	r2,-12(fp)
8110a7a8:	10001026 	beq	r2,zero,8110a7ec <bSpwcInitCh+0x16c>
			if (!bSpwcGetLink(pxSpwcCh)) {
8110a7ac:	e13ffe17 	ldw	r4,-8(fp)
8110a7b0:	110a2c00 	call	8110a2c0 <bSpwcGetLink>
8110a7b4:	1000011e 	bne	r2,zero,8110a7bc <bSpwcInitCh+0x13c>
				bStatus = FALSE;
8110a7b8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
8110a7bc:	e13ffe17 	ldw	r4,-8(fp)
8110a7c0:	110a3a40 	call	8110a3a4 <bSpwcGetLinkError>
8110a7c4:	1000011e 	bne	r2,zero,8110a7cc <bSpwcInitCh+0x14c>
				bStatus = FALSE;
8110a7c8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
8110a7cc:	e13ffe17 	ldw	r4,-8(fp)
8110a7d0:	110a4980 	call	8110a498 <bSpwcGetLinkStatus>
8110a7d4:	1000011e 	bne	r2,zero,8110a7dc <bSpwcInitCh+0x15c>
				bStatus = FALSE;
8110a7d8:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetTimecode(pxSpwcCh)) {
8110a7dc:	e13ffe17 	ldw	r4,-8(fp)
8110a7e0:	110a5680 	call	8110a568 <bSpwcGetTimecode>
8110a7e4:	1000011e 	bne	r2,zero,8110a7ec <bSpwcInitCh+0x16c>
				bStatus = FALSE;
8110a7e8:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
8110a7ec:	e0bffd17 	ldw	r2,-12(fp)
}
8110a7f0:	e037883a 	mov	sp,fp
8110a7f4:	dfc00117 	ldw	ra,4(sp)
8110a7f8:	df000017 	ldw	fp,0(sp)
8110a7fc:	dec00204 	addi	sp,sp,8
8110a800:	f800283a 	ret

8110a804 <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110a804:	defffc04 	addi	sp,sp,-16
8110a808:	de00012e 	bgeu	sp,et,8110a810 <vSpwcWriteReg+0xc>
8110a80c:	003b68fa 	trap	3
8110a810:	df000315 	stw	fp,12(sp)
8110a814:	df000304 	addi	fp,sp,12
8110a818:	e13ffd15 	stw	r4,-12(fp)
8110a81c:	e17ffe15 	stw	r5,-8(fp)
8110a820:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110a824:	e0bffe17 	ldw	r2,-8(fp)
8110a828:	1085883a 	add	r2,r2,r2
8110a82c:	1085883a 	add	r2,r2,r2
8110a830:	1007883a 	mov	r3,r2
8110a834:	e0bffd17 	ldw	r2,-12(fp)
8110a838:	10c5883a 	add	r2,r2,r3
8110a83c:	e0ffff17 	ldw	r3,-4(fp)
8110a840:	10c00015 	stw	r3,0(r2)
}
8110a844:	0001883a 	nop
8110a848:	e037883a 	mov	sp,fp
8110a84c:	df000017 	ldw	fp,0(sp)
8110a850:	dec00104 	addi	sp,sp,4
8110a854:	f800283a 	ret

8110a858 <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110a858:	defffc04 	addi	sp,sp,-16
8110a85c:	de00012e 	bgeu	sp,et,8110a864 <uliSpwcReadReg+0xc>
8110a860:	003b68fa 	trap	3
8110a864:	df000315 	stw	fp,12(sp)
8110a868:	df000304 	addi	fp,sp,12
8110a86c:	e13ffe15 	stw	r4,-8(fp)
8110a870:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110a874:	e0bfff17 	ldw	r2,-4(fp)
8110a878:	1085883a 	add	r2,r2,r2
8110a87c:	1085883a 	add	r2,r2,r2
8110a880:	1007883a 	mov	r3,r2
8110a884:	e0bffe17 	ldw	r2,-8(fp)
8110a888:	10c5883a 	add	r2,r2,r3
8110a88c:	10800017 	ldw	r2,0(r2)
8110a890:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110a894:	e0bffd17 	ldw	r2,-12(fp)
}
8110a898:	e037883a 	mov	sp,fp
8110a89c:	df000017 	ldw	fp,0(sp)
8110a8a0:	dec00104 	addi	sp,sp,4
8110a8a4:	f800283a 	ret

8110a8a8 <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
8110a8a8:	defffe04 	addi	sp,sp,-8
8110a8ac:	de00012e 	bgeu	sp,et,8110a8b4 <bEnableIsoDrivers+0xc>
8110a8b0:	003b68fa 	trap	3
8110a8b4:	dfc00115 	stw	ra,4(sp)
8110a8b8:	df000015 	stw	fp,0(sp)
8110a8bc:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
8110a8c0:	01400204 	movi	r5,8
8110a8c4:	01000044 	movi	r4,1
8110a8c8:	110aa580 	call	8110aa58 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a8cc:	00800044 	movi	r2,1
}
8110a8d0:	e037883a 	mov	sp,fp
8110a8d4:	dfc00117 	ldw	ra,4(sp)
8110a8d8:	df000017 	ldw	fp,0(sp)
8110a8dc:	dec00204 	addi	sp,sp,8
8110a8e0:	f800283a 	ret

8110a8e4 <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
8110a8e4:	defffe04 	addi	sp,sp,-8
8110a8e8:	de00012e 	bgeu	sp,et,8110a8f0 <bDisableIsoDrivers+0xc>
8110a8ec:	003b68fa 	trap	3
8110a8f0:	dfc00115 	stw	ra,4(sp)
8110a8f4:	df000015 	stw	fp,0(sp)
8110a8f8:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
8110a8fc:	01400204 	movi	r5,8
8110a900:	0009883a 	mov	r4,zero
8110a904:	110aa580 	call	8110aa58 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a908:	00800044 	movi	r2,1
}
8110a90c:	e037883a 	mov	sp,fp
8110a910:	dfc00117 	ldw	ra,4(sp)
8110a914:	df000017 	ldw	fp,0(sp)
8110a918:	dec00204 	addi	sp,sp,8
8110a91c:	f800283a 	ret

8110a920 <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
8110a920:	defffe04 	addi	sp,sp,-8
8110a924:	de00012e 	bgeu	sp,et,8110a92c <bEnableLvdsBoard+0xc>
8110a928:	003b68fa 	trap	3
8110a92c:	dfc00115 	stw	ra,4(sp)
8110a930:	df000015 	stw	fp,0(sp)
8110a934:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
8110a938:	01400104 	movi	r5,4
8110a93c:	01000044 	movi	r4,1
8110a940:	110aa580 	call	8110aa58 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a944:	00800044 	movi	r2,1
}
8110a948:	e037883a 	mov	sp,fp
8110a94c:	dfc00117 	ldw	ra,4(sp)
8110a950:	df000017 	ldw	fp,0(sp)
8110a954:	dec00204 	addi	sp,sp,8
8110a958:	f800283a 	ret

8110a95c <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
8110a95c:	defffe04 	addi	sp,sp,-8
8110a960:	de00012e 	bgeu	sp,et,8110a968 <bDisableLvdsBoard+0xc>
8110a964:	003b68fa 	trap	3
8110a968:	dfc00115 	stw	ra,4(sp)
8110a96c:	df000015 	stw	fp,0(sp)
8110a970:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
8110a974:	01400104 	movi	r5,4
8110a978:	0009883a 	mov	r4,zero
8110a97c:	110aa580 	call	8110aa58 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a980:	00800044 	movi	r2,1
}
8110a984:	e037883a 	mov	sp,fp
8110a988:	dfc00117 	ldw	ra,4(sp)
8110a98c:	df000017 	ldw	fp,0(sp)
8110a990:	dec00204 	addi	sp,sp,8
8110a994:	f800283a 	ret

8110a998 <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
8110a998:	defffd04 	addi	sp,sp,-12
8110a99c:	de00012e 	bgeu	sp,et,8110a9a4 <bSetPreEmphasys+0xc>
8110a9a0:	003b68fa 	trap	3
8110a9a4:	dfc00215 	stw	ra,8(sp)
8110a9a8:	df000115 	stw	fp,4(sp)
8110a9ac:	df000104 	addi	fp,sp,4
8110a9b0:	2005883a 	mov	r2,r4
8110a9b4:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
8110a9b8:	e0bfff03 	ldbu	r2,-4(fp)
8110a9bc:	10c00060 	cmpeqi	r3,r2,1
8110a9c0:	18000d1e 	bne	r3,zero,8110a9f8 <bSetPreEmphasys+0x60>
8110a9c4:	10c00088 	cmpgei	r3,r2,2
8110a9c8:	1800021e 	bne	r3,zero,8110a9d4 <bSetPreEmphasys+0x3c>
8110a9cc:	10000626 	beq	r2,zero,8110a9e8 <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110a9d0:	00001b06 	br	8110aa40 <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
8110a9d4:	10c000a0 	cmpeqi	r3,r2,2
8110a9d8:	18000e1e 	bne	r3,zero,8110aa14 <bSetPreEmphasys+0x7c>
8110a9dc:	108000e0 	cmpeqi	r2,r2,3
8110a9e0:	1000131e 	bne	r2,zero,8110aa30 <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110a9e4:	00001606 	br	8110aa40 <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110a9e8:	014000c4 	movi	r5,3
8110a9ec:	0009883a 	mov	r4,zero
8110a9f0:	110aa580 	call	8110aa58 <bCtrlIoLvdsDrive>
      break;
8110a9f4:	00001206 	br	8110aa40 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
8110a9f8:	01400084 	movi	r5,2
8110a9fc:	0009883a 	mov	r4,zero
8110aa00:	110aa580 	call	8110aa58 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
8110aa04:	01400044 	movi	r5,1
8110aa08:	01000044 	movi	r4,1
8110aa0c:	110aa580 	call	8110aa58 <bCtrlIoLvdsDrive>
      break;
8110aa10:	00000b06 	br	8110aa40 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
8110aa14:	01400044 	movi	r5,1
8110aa18:	0009883a 	mov	r4,zero
8110aa1c:	110aa580 	call	8110aa58 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
8110aa20:	01400084 	movi	r5,2
8110aa24:	01000044 	movi	r4,1
8110aa28:	110aa580 	call	8110aa58 <bCtrlIoLvdsDrive>
      break;
8110aa2c:	00000406 	br	8110aa40 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110aa30:	014000c4 	movi	r5,3
8110aa34:	01000044 	movi	r4,1
8110aa38:	110aa580 	call	8110aa58 <bCtrlIoLvdsDrive>
      break;
8110aa3c:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
8110aa40:	00800044 	movi	r2,1
}
8110aa44:	e037883a 	mov	sp,fp
8110aa48:	dfc00117 	ldw	ra,4(sp)
8110aa4c:	df000017 	ldw	fp,0(sp)
8110aa50:	dec00204 	addi	sp,sp,8
8110aa54:	f800283a 	ret

8110aa58 <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
8110aa58:	defffd04 	addi	sp,sp,-12
8110aa5c:	de00012e 	bgeu	sp,et,8110aa64 <bCtrlIoLvdsDrive+0xc>
8110aa60:	003b68fa 	trap	3
8110aa64:	df000215 	stw	fp,8(sp)
8110aa68:	df000204 	addi	fp,sp,8
8110aa6c:	e13ffe15 	stw	r4,-8(fp)
8110aa70:	2805883a 	mov	r2,r5
8110aa74:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
8110aa78:	e0bffe17 	ldw	r2,-8(fp)
8110aa7c:	1000071e 	bne	r2,zero,8110aa9c <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
8110aa80:	e0bfff03 	ldbu	r2,-4(fp)
8110aa84:	0084303a 	nor	r2,zero,r2
8110aa88:	1007883a 	mov	r3,r2
8110aa8c:	d0a00103 	ldbu	r2,-32764(gp)
8110aa90:	1884703a 	and	r2,r3,r2
8110aa94:	d0a00105 	stb	r2,-32764(gp)
8110aa98:	00000406 	br	8110aaac <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
8110aa9c:	d0e00103 	ldbu	r3,-32764(gp)
8110aaa0:	e0bfff03 	ldbu	r2,-4(fp)
8110aaa4:	1884b03a 	or	r2,r3,r2
8110aaa8:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
8110aaac:	d0a00103 	ldbu	r2,-32764(gp)
8110aab0:	10c03fcc 	andi	r3,r2,255
8110aab4:	00a00034 	movhi	r2,32768
8110aab8:	10822804 	addi	r2,r2,2208
8110aabc:	10c00035 	stwio	r3,0(r2)
  return TRUE;
8110aac0:	00800044 	movi	r2,1
}
8110aac4:	e037883a 	mov	sp,fp
8110aac8:	df000017 	ldw	fp,0(sp)
8110aacc:	dec00104 	addi	sp,sp,4
8110aad0:	f800283a 	ret

8110aad4 <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
8110aad4:	defffa04 	addi	sp,sp,-24
8110aad8:	de00012e 	bgeu	sp,et,8110aae0 <I2C_TestAdress+0xc>
8110aadc:	003b68fa 	trap	3
8110aae0:	dfc00515 	stw	ra,20(sp)
8110aae4:	df000415 	stw	fp,16(sp)
8110aae8:	df000404 	addi	fp,sp,16
8110aaec:	e13ffd15 	stw	r4,-12(fp)
8110aaf0:	e17ffe15 	stw	r5,-8(fp)
8110aaf4:	3005883a 	mov	r2,r6
8110aaf8:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110aafc:	00800044 	movi	r2,1
8110ab00:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110ab04:	e17ffe17 	ldw	r5,-8(fp)
8110ab08:	e13ffd17 	ldw	r4,-12(fp)
8110ab0c:	110aea40 	call	8110aea4 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110ab10:	e0bfff03 	ldbu	r2,-4(fp)
8110ab14:	10803fcc 	andi	r2,r2,255
8110ab18:	100d883a 	mov	r6,r2
8110ab1c:	e17ffe17 	ldw	r5,-8(fp)
8110ab20:	e13ffd17 	ldw	r4,-12(fp)
8110ab24:	110afb80 	call	8110afb8 <i2c_write>
8110ab28:	1000011e 	bne	r2,zero,8110ab30 <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
8110ab2c:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110ab30:	e17ffe17 	ldw	r5,-8(fp)
8110ab34:	e13ffd17 	ldw	r4,-12(fp)
8110ab38:	110af380 	call	8110af38 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110ab3c:	0106d604 	movi	r4,7000
8110ab40:	1136ed00 	call	81136ed0 <usleep>
    
    return bSuccess;
8110ab44:	e0bffc17 	ldw	r2,-16(fp)

}
8110ab48:	e037883a 	mov	sp,fp
8110ab4c:	dfc00117 	ldw	ra,4(sp)
8110ab50:	df000017 	ldw	fp,0(sp)
8110ab54:	dec00204 	addi	sp,sp,8
8110ab58:	f800283a 	ret

8110ab5c <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
8110ab5c:	defff804 	addi	sp,sp,-32
8110ab60:	de00012e 	bgeu	sp,et,8110ab68 <I2C_Write+0xc>
8110ab64:	003b68fa 	trap	3
8110ab68:	dfc00715 	stw	ra,28(sp)
8110ab6c:	df000615 	stw	fp,24(sp)
8110ab70:	df000604 	addi	fp,sp,24
8110ab74:	e13ffb15 	stw	r4,-20(fp)
8110ab78:	e17ffc15 	stw	r5,-16(fp)
8110ab7c:	3009883a 	mov	r4,r6
8110ab80:	3807883a 	mov	r3,r7
8110ab84:	e0800217 	ldw	r2,8(fp)
8110ab88:	e13ffd05 	stb	r4,-12(fp)
8110ab8c:	e0fffe05 	stb	r3,-8(fp)
8110ab90:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110ab94:	00800044 	movi	r2,1
8110ab98:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110ab9c:	e17ffc17 	ldw	r5,-16(fp)
8110aba0:	e13ffb17 	ldw	r4,-20(fp)
8110aba4:	110aea40 	call	8110aea4 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110aba8:	e0bffd03 	ldbu	r2,-12(fp)
8110abac:	10803fcc 	andi	r2,r2,255
8110abb0:	100d883a 	mov	r6,r2
8110abb4:	e17ffc17 	ldw	r5,-16(fp)
8110abb8:	e13ffb17 	ldw	r4,-20(fp)
8110abbc:	110afb80 	call	8110afb8 <i2c_write>
8110abc0:	1000011e 	bne	r2,zero,8110abc8 <I2C_Write+0x6c>
        bSuccess = FALSE;
8110abc4:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110abc8:	e0bffa17 	ldw	r2,-24(fp)
8110abcc:	10000726 	beq	r2,zero,8110abec <I2C_Write+0x90>
8110abd0:	e0bffe03 	ldbu	r2,-8(fp)
8110abd4:	100d883a 	mov	r6,r2
8110abd8:	e17ffc17 	ldw	r5,-16(fp)
8110abdc:	e13ffb17 	ldw	r4,-20(fp)
8110abe0:	110afb80 	call	8110afb8 <i2c_write>
8110abe4:	1000011e 	bne	r2,zero,8110abec <I2C_Write+0x90>
        bSuccess = FALSE;
8110abe8:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
8110abec:	e0bffa17 	ldw	r2,-24(fp)
8110abf0:	10000726 	beq	r2,zero,8110ac10 <I2C_Write+0xb4>
8110abf4:	e0bfff03 	ldbu	r2,-4(fp)
8110abf8:	100d883a 	mov	r6,r2
8110abfc:	e17ffc17 	ldw	r5,-16(fp)
8110ac00:	e13ffb17 	ldw	r4,-20(fp)
8110ac04:	110afb80 	call	8110afb8 <i2c_write>
8110ac08:	1000011e 	bne	r2,zero,8110ac10 <I2C_Write+0xb4>
        bSuccess = FALSE;
8110ac0c:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110ac10:	e17ffc17 	ldw	r5,-16(fp)
8110ac14:	e13ffb17 	ldw	r4,-20(fp)
8110ac18:	110af380 	call	8110af38 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110ac1c:	0106d604 	movi	r4,7000
8110ac20:	1136ed00 	call	81136ed0 <usleep>
    
    return bSuccess;
8110ac24:	e0bffa17 	ldw	r2,-24(fp)

}
8110ac28:	e037883a 	mov	sp,fp
8110ac2c:	dfc00117 	ldw	ra,4(sp)
8110ac30:	df000017 	ldw	fp,0(sp)
8110ac34:	dec00204 	addi	sp,sp,8
8110ac38:	f800283a 	ret

8110ac3c <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
8110ac3c:	defff904 	addi	sp,sp,-28
8110ac40:	de00012e 	bgeu	sp,et,8110ac48 <I2C_Read+0xc>
8110ac44:	003b68fa 	trap	3
8110ac48:	dfc00615 	stw	ra,24(sp)
8110ac4c:	df000515 	stw	fp,20(sp)
8110ac50:	df000504 	addi	fp,sp,20
8110ac54:	e13ffc15 	stw	r4,-16(fp)
8110ac58:	e17ffd15 	stw	r5,-12(fp)
8110ac5c:	3007883a 	mov	r3,r6
8110ac60:	3805883a 	mov	r2,r7
8110ac64:	e0fffe05 	stb	r3,-8(fp)
8110ac68:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110ac6c:	00800044 	movi	r2,1
8110ac70:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110ac74:	e17ffd17 	ldw	r5,-12(fp)
8110ac78:	e13ffc17 	ldw	r4,-16(fp)
8110ac7c:	110aea40 	call	8110aea4 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110ac80:	e0bffe03 	ldbu	r2,-8(fp)
8110ac84:	10803fcc 	andi	r2,r2,255
8110ac88:	100d883a 	mov	r6,r2
8110ac8c:	e17ffd17 	ldw	r5,-12(fp)
8110ac90:	e13ffc17 	ldw	r4,-16(fp)
8110ac94:	110afb80 	call	8110afb8 <i2c_write>
8110ac98:	1000011e 	bne	r2,zero,8110aca0 <I2C_Read+0x64>
        bSuccess = FALSE;
8110ac9c:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110aca0:	e0bffb17 	ldw	r2,-20(fp)
8110aca4:	10000726 	beq	r2,zero,8110acc4 <I2C_Read+0x88>
8110aca8:	e0bfff03 	ldbu	r2,-4(fp)
8110acac:	100d883a 	mov	r6,r2
8110acb0:	e17ffd17 	ldw	r5,-12(fp)
8110acb4:	e13ffc17 	ldw	r4,-16(fp)
8110acb8:	110afb80 	call	8110afb8 <i2c_write>
8110acbc:	1000011e 	bne	r2,zero,8110acc4 <I2C_Read+0x88>
        bSuccess = FALSE;
8110acc0:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
8110acc4:	e17ffd17 	ldw	r5,-12(fp)
8110acc8:	e13ffc17 	ldw	r4,-16(fp)
8110accc:	110aea40 	call	8110aea4 <i2c_start>
    DeviceAddr |= 1; // Read
8110acd0:	e0bffe03 	ldbu	r2,-8(fp)
8110acd4:	10800054 	ori	r2,r2,1
8110acd8:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110acdc:	e0bffb17 	ldw	r2,-20(fp)
8110ace0:	10000826 	beq	r2,zero,8110ad04 <I2C_Read+0xc8>
8110ace4:	e0bffe03 	ldbu	r2,-8(fp)
8110ace8:	10803fcc 	andi	r2,r2,255
8110acec:	100d883a 	mov	r6,r2
8110acf0:	e17ffd17 	ldw	r5,-12(fp)
8110acf4:	e13ffc17 	ldw	r4,-16(fp)
8110acf8:	110afb80 	call	8110afb8 <i2c_write>
8110acfc:	1000011e 	bne	r2,zero,8110ad04 <I2C_Read+0xc8>
        bSuccess = FALSE;
8110ad00:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110ad04:	e0bffb17 	ldw	r2,-20(fp)
8110ad08:	10000526 	beq	r2,zero,8110ad20 <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
8110ad0c:	000f883a 	mov	r7,zero
8110ad10:	e1800217 	ldw	r6,8(fp)
8110ad14:	e17ffd17 	ldw	r5,-12(fp)
8110ad18:	e13ffc17 	ldw	r4,-16(fp)
8110ad1c:	110b0f00 	call	8110b0f0 <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
8110ad20:	e17ffd17 	ldw	r5,-12(fp)
8110ad24:	e13ffc17 	ldw	r4,-16(fp)
8110ad28:	110af380 	call	8110af38 <i2c_stop>
    
    return bSuccess;
8110ad2c:	e0bffb17 	ldw	r2,-20(fp)
}
8110ad30:	e037883a 	mov	sp,fp
8110ad34:	dfc00117 	ldw	ra,4(sp)
8110ad38:	df000017 	ldw	fp,0(sp)
8110ad3c:	dec00204 	addi	sp,sp,8
8110ad40:	f800283a 	ret

8110ad44 <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
8110ad44:	defff604 	addi	sp,sp,-40
8110ad48:	de00012e 	bgeu	sp,et,8110ad50 <I2C_MultipleRead+0xc>
8110ad4c:	003b68fa 	trap	3
8110ad50:	dfc00915 	stw	ra,36(sp)
8110ad54:	df000815 	stw	fp,32(sp)
8110ad58:	df000804 	addi	fp,sp,32
8110ad5c:	e13ffb15 	stw	r4,-20(fp)
8110ad60:	e17ffc15 	stw	r5,-16(fp)
8110ad64:	3007883a 	mov	r3,r6
8110ad68:	e1fffe15 	stw	r7,-8(fp)
8110ad6c:	e0800217 	ldw	r2,8(fp)
8110ad70:	e0fffd05 	stb	r3,-12(fp)
8110ad74:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
8110ad78:	00800044 	movi	r2,1
8110ad7c:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
8110ad80:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110ad84:	e17ffc17 	ldw	r5,-16(fp)
8110ad88:	e13ffb17 	ldw	r4,-20(fp)
8110ad8c:	110aea40 	call	8110aea4 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110ad90:	e0bffd03 	ldbu	r2,-12(fp)
8110ad94:	10803fcc 	andi	r2,r2,255
8110ad98:	100d883a 	mov	r6,r2
8110ad9c:	e17ffc17 	ldw	r5,-16(fp)
8110ada0:	e13ffb17 	ldw	r4,-20(fp)
8110ada4:	110afb80 	call	8110afb8 <i2c_write>
8110ada8:	1000011e 	bne	r2,zero,8110adb0 <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
8110adac:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110adb0:	e0bff917 	ldw	r2,-28(fp)
8110adb4:	10000726 	beq	r2,zero,8110add4 <I2C_MultipleRead+0x90>
8110adb8:	e0bffa03 	ldbu	r2,-24(fp)
8110adbc:	100d883a 	mov	r6,r2
8110adc0:	e17ffc17 	ldw	r5,-16(fp)
8110adc4:	e13ffb17 	ldw	r4,-20(fp)
8110adc8:	110afb80 	call	8110afb8 <i2c_write>
8110adcc:	1000011e 	bne	r2,zero,8110add4 <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
8110add0:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
8110add4:	e0bff917 	ldw	r2,-28(fp)
8110add8:	10000326 	beq	r2,zero,8110ade8 <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
8110addc:	e17ffc17 	ldw	r5,-16(fp)
8110ade0:	e13ffb17 	ldw	r4,-20(fp)
8110ade4:	110aea40 	call	8110aea4 <i2c_start>
    DeviceAddr |= 1; // Read
8110ade8:	e0bffd03 	ldbu	r2,-12(fp)
8110adec:	10800054 	ori	r2,r2,1
8110adf0:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110adf4:	e0bff917 	ldw	r2,-28(fp)
8110adf8:	10000826 	beq	r2,zero,8110ae1c <I2C_MultipleRead+0xd8>
8110adfc:	e0bffd03 	ldbu	r2,-12(fp)
8110ae00:	10803fcc 	andi	r2,r2,255
8110ae04:	100d883a 	mov	r6,r2
8110ae08:	e17ffc17 	ldw	r5,-16(fp)
8110ae0c:	e13ffb17 	ldw	r4,-20(fp)
8110ae10:	110afb80 	call	8110afb8 <i2c_write>
8110ae14:	1000011e 	bne	r2,zero,8110ae1c <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
8110ae18:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110ae1c:	e0bff917 	ldw	r2,-28(fp)
8110ae20:	10001726 	beq	r2,zero,8110ae80 <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
8110ae24:	e03ff815 	stw	zero,-32(fp)
8110ae28:	00001006 	br	8110ae6c <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
8110ae2c:	e0bff817 	ldw	r2,-32(fp)
8110ae30:	e0fffe17 	ldw	r3,-8(fp)
8110ae34:	1889883a 	add	r4,r3,r2
8110ae38:	e0bfff0b 	ldhu	r2,-4(fp)
8110ae3c:	10ffffc4 	addi	r3,r2,-1
8110ae40:	e0bff817 	ldw	r2,-32(fp)
8110ae44:	1884c03a 	cmpne	r2,r3,r2
8110ae48:	10803fcc 	andi	r2,r2,255
8110ae4c:	100f883a 	mov	r7,r2
8110ae50:	200d883a 	mov	r6,r4
8110ae54:	e17ffc17 	ldw	r5,-16(fp)
8110ae58:	e13ffb17 	ldw	r4,-20(fp)
8110ae5c:	110b0f00 	call	8110b0f0 <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
8110ae60:	e0bff817 	ldw	r2,-32(fp)
8110ae64:	10800044 	addi	r2,r2,1
8110ae68:	e0bff815 	stw	r2,-32(fp)
8110ae6c:	e0bfff0b 	ldhu	r2,-4(fp)
8110ae70:	e0fff817 	ldw	r3,-32(fp)
8110ae74:	1880020e 	bge	r3,r2,8110ae80 <I2C_MultipleRead+0x13c>
8110ae78:	e0bff917 	ldw	r2,-28(fp)
8110ae7c:	103feb1e 	bne	r2,zero,8110ae2c <__reset+0xfb0eae2c>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
8110ae80:	e17ffc17 	ldw	r5,-16(fp)
8110ae84:	e13ffb17 	ldw	r4,-20(fp)
8110ae88:	110af380 	call	8110af38 <i2c_stop>
    
    return bSuccess;    
8110ae8c:	e0bff917 	ldw	r2,-28(fp)
    
}
8110ae90:	e037883a 	mov	sp,fp
8110ae94:	dfc00117 	ldw	ra,4(sp)
8110ae98:	df000017 	ldw	fp,0(sp)
8110ae9c:	dec00204 	addi	sp,sp,8
8110aea0:	f800283a 	ret

8110aea4 <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
8110aea4:	defffc04 	addi	sp,sp,-16
8110aea8:	de00012e 	bgeu	sp,et,8110aeb0 <i2c_start+0xc>
8110aeac:	003b68fa 	trap	3
8110aeb0:	dfc00315 	stw	ra,12(sp)
8110aeb4:	df000215 	stw	fp,8(sp)
8110aeb8:	df000204 	addi	fp,sp,8
8110aebc:	e13ffe15 	stw	r4,-8(fp)
8110aec0:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
8110aec4:	e0bfff17 	ldw	r2,-4(fp)
8110aec8:	10800104 	addi	r2,r2,4
8110aecc:	1007883a 	mov	r3,r2
8110aed0:	00800044 	movi	r2,1
8110aed4:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
8110aed8:	e0bfff17 	ldw	r2,-4(fp)
8110aedc:	00c00044 	movi	r3,1
8110aee0:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
8110aee4:	e0bffe17 	ldw	r2,-8(fp)
8110aee8:	00c00044 	movi	r3,1
8110aeec:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110aef0:	01000044 	movi	r4,1
8110aef4:	1136ed00 	call	81136ed0 <usleep>
     
    SDA_LOW(data_base); // data low
8110aef8:	e0bfff17 	ldw	r2,-4(fp)
8110aefc:	0007883a 	mov	r3,zero
8110af00:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
8110af04:	01000044 	movi	r4,1
8110af08:	1136ed00 	call	81136ed0 <usleep>
    SCL_LOW(clk_base); // clock low
8110af0c:	e0bffe17 	ldw	r2,-8(fp)
8110af10:	0007883a 	mov	r3,zero
8110af14:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110af18:	01000044 	movi	r4,1
8110af1c:	1136ed00 	call	81136ed0 <usleep>
}
8110af20:	0001883a 	nop
8110af24:	e037883a 	mov	sp,fp
8110af28:	dfc00117 	ldw	ra,4(sp)
8110af2c:	df000017 	ldw	fp,0(sp)
8110af30:	dec00204 	addi	sp,sp,8
8110af34:	f800283a 	ret

8110af38 <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
8110af38:	defffc04 	addi	sp,sp,-16
8110af3c:	de00012e 	bgeu	sp,et,8110af44 <i2c_stop+0xc>
8110af40:	003b68fa 	trap	3
8110af44:	dfc00315 	stw	ra,12(sp)
8110af48:	df000215 	stw	fp,8(sp)
8110af4c:	df000204 	addi	fp,sp,8
8110af50:	e13ffe15 	stw	r4,-8(fp)
8110af54:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
8110af58:	e0bfff17 	ldw	r2,-4(fp)
8110af5c:	10800104 	addi	r2,r2,4
8110af60:	1007883a 	mov	r3,r2
8110af64:	00800044 	movi	r2,1
8110af68:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
8110af6c:	e0bfff17 	ldw	r2,-4(fp)
8110af70:	0007883a 	mov	r3,zero
8110af74:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
8110af78:	e0bffe17 	ldw	r2,-8(fp)
8110af7c:	00c00044 	movi	r3,1
8110af80:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
8110af84:	01000044 	movi	r4,1
8110af88:	1136ed00 	call	81136ed0 <usleep>
    SDA_HIGH(data_base); // data high
8110af8c:	e0bfff17 	ldw	r2,-4(fp)
8110af90:	00c00044 	movi	r3,1
8110af94:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
8110af98:	01000044 	movi	r4,1
8110af9c:	1136ed00 	call	81136ed0 <usleep>
    

    
}
8110afa0:	0001883a 	nop
8110afa4:	e037883a 	mov	sp,fp
8110afa8:	dfc00117 	ldw	ra,4(sp)
8110afac:	df000017 	ldw	fp,0(sp)
8110afb0:	dec00204 	addi	sp,sp,8
8110afb4:	f800283a 	ret

8110afb8 <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
8110afb8:	defff804 	addi	sp,sp,-32
8110afbc:	de00012e 	bgeu	sp,et,8110afc4 <i2c_write+0xc>
8110afc0:	003b68fa 	trap	3
8110afc4:	dfc00715 	stw	ra,28(sp)
8110afc8:	df000615 	stw	fp,24(sp)
8110afcc:	df000604 	addi	fp,sp,24
8110afd0:	e13ffd15 	stw	r4,-12(fp)
8110afd4:	e17ffe15 	stw	r5,-8(fp)
8110afd8:	3005883a 	mov	r2,r6
8110afdc:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
8110afe0:	00bfe004 	movi	r2,-128
8110afe4:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
8110afe8:	e0bffe17 	ldw	r2,-8(fp)
8110afec:	10800104 	addi	r2,r2,4
8110aff0:	1007883a 	mov	r3,r2
8110aff4:	00800044 	movi	r2,1
8110aff8:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
8110affc:	e03ffb15 	stw	zero,-20(fp)
8110b000:	00001f06 	br	8110b080 <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
8110b004:	e0bffd17 	ldw	r2,-12(fp)
8110b008:	0007883a 	mov	r3,zero
8110b00c:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
8110b010:	e0ffff03 	ldbu	r3,-4(fp)
8110b014:	e0bffa03 	ldbu	r2,-24(fp)
8110b018:	1884703a 	and	r2,r3,r2
8110b01c:	10803fcc 	andi	r2,r2,255
8110b020:	10000426 	beq	r2,zero,8110b034 <i2c_write+0x7c>
            SDA_HIGH(data_base);
8110b024:	e0bffe17 	ldw	r2,-8(fp)
8110b028:	00c00044 	movi	r3,1
8110b02c:	10c00035 	stwio	r3,0(r2)
8110b030:	00000306 	br	8110b040 <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
8110b034:	e0bffe17 	ldw	r2,-8(fp)
8110b038:	0007883a 	mov	r3,zero
8110b03c:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
8110b040:	e0bffa03 	ldbu	r2,-24(fp)
8110b044:	1004d07a 	srli	r2,r2,1
8110b048:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
8110b04c:	e0bffd17 	ldw	r2,-12(fp)
8110b050:	00c00044 	movi	r3,1
8110b054:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b058:	01000044 	movi	r4,1
8110b05c:	1136ed00 	call	81136ed0 <usleep>
        SCL_LOW(clk_base);
8110b060:	e0bffd17 	ldw	r2,-12(fp)
8110b064:	0007883a 	mov	r3,zero
8110b068:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b06c:	01000044 	movi	r4,1
8110b070:	1136ed00 	call	81136ed0 <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
8110b074:	e0bffb17 	ldw	r2,-20(fp)
8110b078:	10800044 	addi	r2,r2,1
8110b07c:	e0bffb15 	stw	r2,-20(fp)
8110b080:	e0bffb17 	ldw	r2,-20(fp)
8110b084:	10800210 	cmplti	r2,r2,8
8110b088:	103fde1e 	bne	r2,zero,8110b004 <__reset+0xfb0eb004>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
8110b08c:	e0bffe17 	ldw	r2,-8(fp)
8110b090:	10800104 	addi	r2,r2,4
8110b094:	0007883a 	mov	r3,zero
8110b098:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
8110b09c:	e0bffd17 	ldw	r2,-12(fp)
8110b0a0:	00c00044 	movi	r3,1
8110b0a4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
8110b0a8:	01000044 	movi	r4,1
8110b0ac:	1136ed00 	call	81136ed0 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
8110b0b0:	e0bffe17 	ldw	r2,-8(fp)
8110b0b4:	10800037 	ldwio	r2,0(r2)
8110b0b8:	1005003a 	cmpeq	r2,r2,zero
8110b0bc:	10803fcc 	andi	r2,r2,255
8110b0c0:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
8110b0c4:	e0bffd17 	ldw	r2,-12(fp)
8110b0c8:	0007883a 	mov	r3,zero
8110b0cc:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b0d0:	01000044 	movi	r4,1
8110b0d4:	1136ed00 	call	81136ed0 <usleep>
    return bAck;
8110b0d8:	e0bffc17 	ldw	r2,-16(fp)
}    
8110b0dc:	e037883a 	mov	sp,fp
8110b0e0:	dfc00117 	ldw	ra,4(sp)
8110b0e4:	df000017 	ldw	fp,0(sp)
8110b0e8:	dec00204 	addi	sp,sp,8
8110b0ec:	f800283a 	ret

8110b0f0 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
8110b0f0:	defff804 	addi	sp,sp,-32
8110b0f4:	de00012e 	bgeu	sp,et,8110b0fc <i2c_read+0xc>
8110b0f8:	003b68fa 	trap	3
8110b0fc:	dfc00715 	stw	ra,28(sp)
8110b100:	df000615 	stw	fp,24(sp)
8110b104:	df000604 	addi	fp,sp,24
8110b108:	e13ffc15 	stw	r4,-16(fp)
8110b10c:	e17ffd15 	stw	r5,-12(fp)
8110b110:	e1bffe15 	stw	r6,-8(fp)
8110b114:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
8110b118:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
8110b11c:	e0bffd17 	ldw	r2,-12(fp)
8110b120:	10800104 	addi	r2,r2,4
8110b124:	0007883a 	mov	r3,zero
8110b128:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
8110b12c:	e0bffc17 	ldw	r2,-16(fp)
8110b130:	0007883a 	mov	r3,zero
8110b134:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b138:	01000044 	movi	r4,1
8110b13c:	1136ed00 	call	81136ed0 <usleep>

    for(i=0;i<8;i++){
8110b140:	e03ffb15 	stw	zero,-20(fp)
8110b144:	00001606 	br	8110b1a0 <i2c_read+0xb0>
        Data <<= 1;
8110b148:	e0bffa03 	ldbu	r2,-24(fp)
8110b14c:	1085883a 	add	r2,r2,r2
8110b150:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
8110b154:	e0bffc17 	ldw	r2,-16(fp)
8110b158:	00c00044 	movi	r3,1
8110b15c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b160:	01000044 	movi	r4,1
8110b164:	1136ed00 	call	81136ed0 <usleep>
        if (SDA_READ(data_base))  // read data   
8110b168:	e0bffd17 	ldw	r2,-12(fp)
8110b16c:	10800037 	ldwio	r2,0(r2)
8110b170:	10000326 	beq	r2,zero,8110b180 <i2c_read+0x90>
            Data |= 0x01;
8110b174:	e0bffa03 	ldbu	r2,-24(fp)
8110b178:	10800054 	ori	r2,r2,1
8110b17c:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
8110b180:	e0bffc17 	ldw	r2,-16(fp)
8110b184:	0007883a 	mov	r3,zero
8110b188:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110b18c:	01000044 	movi	r4,1
8110b190:	1136ed00 	call	81136ed0 <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
8110b194:	e0bffb17 	ldw	r2,-20(fp)
8110b198:	10800044 	addi	r2,r2,1
8110b19c:	e0bffb15 	stw	r2,-20(fp)
8110b1a0:	e0bffb17 	ldw	r2,-20(fp)
8110b1a4:	10800210 	cmplti	r2,r2,8
8110b1a8:	103fe71e 	bne	r2,zero,8110b148 <__reset+0xfb0eb148>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
8110b1ac:	e0bffc17 	ldw	r2,-16(fp)
8110b1b0:	0007883a 	mov	r3,zero
8110b1b4:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
8110b1b8:	e0bffd17 	ldw	r2,-12(fp)
8110b1bc:	10800104 	addi	r2,r2,4
8110b1c0:	1007883a 	mov	r3,r2
8110b1c4:	00800044 	movi	r2,1
8110b1c8:	18800035 	stwio	r2,0(r3)
    if (bAck)
8110b1cc:	e0bfff17 	ldw	r2,-4(fp)
8110b1d0:	10000426 	beq	r2,zero,8110b1e4 <i2c_read+0xf4>
        SDA_LOW(data_base);
8110b1d4:	e0bffd17 	ldw	r2,-12(fp)
8110b1d8:	0007883a 	mov	r3,zero
8110b1dc:	10c00035 	stwio	r3,0(r2)
8110b1e0:	00000306 	br	8110b1f0 <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
8110b1e4:	e0bffd17 	ldw	r2,-12(fp)
8110b1e8:	00c00044 	movi	r3,1
8110b1ec:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
8110b1f0:	e0bffc17 	ldw	r2,-16(fp)
8110b1f4:	00c00044 	movi	r3,1
8110b1f8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
8110b1fc:	01000044 	movi	r4,1
8110b200:	1136ed00 	call	81136ed0 <usleep>
    SCL_LOW(clk_base); // clock low
8110b204:	e0bffc17 	ldw	r2,-16(fp)
8110b208:	0007883a 	mov	r3,zero
8110b20c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110b210:	01000044 	movi	r4,1
8110b214:	1136ed00 	call	81136ed0 <usleep>
    SDA_LOW(data_base);  // data low
8110b218:	e0bffd17 	ldw	r2,-12(fp)
8110b21c:	0007883a 	mov	r3,zero
8110b220:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
8110b224:	01000044 	movi	r4,1
8110b228:	1136ed00 	call	81136ed0 <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
8110b22c:	e0bffe17 	ldw	r2,-8(fp)
8110b230:	e0fffa03 	ldbu	r3,-24(fp)
8110b234:	10c00005 	stb	r3,0(r2)
}
8110b238:	0001883a 	nop
8110b23c:	e037883a 	mov	sp,fp
8110b240:	dfc00117 	ldw	ra,4(sp)
8110b244:	df000017 	ldw	fp,0(sp)
8110b248:	dec00204 	addi	sp,sp,8
8110b24c:	f800283a 	ret

8110b250 <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
8110b250:	defffd04 	addi	sp,sp,-12
8110b254:	de00012e 	bgeu	sp,et,8110b25c <bSetBoardLeds+0xc>
8110b258:	003b68fa 	trap	3
8110b25c:	df000215 	stw	fp,8(sp)
8110b260:	df000204 	addi	fp,sp,8
8110b264:	e13ffe15 	stw	r4,-8(fp)
8110b268:	2805883a 	mov	r2,r5
8110b26c:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
8110b270:	e0bffe17 	ldw	r2,-8(fp)
8110b274:	10800058 	cmpnei	r2,r2,1
8110b278:	1000071e 	bne	r2,zero,8110b298 <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
8110b27c:	e0bfff03 	ldbu	r2,-4(fp)
8110b280:	0084303a 	nor	r2,zero,r2
8110b284:	1007883a 	mov	r3,r2
8110b288:	d0a05003 	ldbu	r2,-32448(gp)
8110b28c:	1884703a 	and	r2,r3,r2
8110b290:	d0a05005 	stb	r2,-32448(gp)
8110b294:	00000406 	br	8110b2a8 <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
8110b298:	d0e05003 	ldbu	r3,-32448(gp)
8110b29c:	e0bfff03 	ldbu	r2,-4(fp)
8110b2a0:	1884b03a 	or	r2,r3,r2
8110b2a4:	d0a05005 	stb	r2,-32448(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
8110b2a8:	d0a05003 	ldbu	r2,-32448(gp)
8110b2ac:	10c03fcc 	andi	r3,r2,255
8110b2b0:	00a00034 	movhi	r2,32768
8110b2b4:	10827404 	addi	r2,r2,2512
8110b2b8:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110b2bc:	00800044 	movi	r2,1
}
8110b2c0:	e037883a 	mov	sp,fp
8110b2c4:	df000017 	ldw	fp,0(sp)
8110b2c8:	dec00104 	addi	sp,sp,4
8110b2cc:	f800283a 	ret

8110b2d0 <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
8110b2d0:	defffd04 	addi	sp,sp,-12
8110b2d4:	de00012e 	bgeu	sp,et,8110b2dc <bSetPainelLeds+0xc>
8110b2d8:	003b68fa 	trap	3
8110b2dc:	df000215 	stw	fp,8(sp)
8110b2e0:	df000204 	addi	fp,sp,8
8110b2e4:	e13ffe15 	stw	r4,-8(fp)
8110b2e8:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
8110b2ec:	e0bffe17 	ldw	r2,-8(fp)
8110b2f0:	10800058 	cmpnei	r2,r2,1
8110b2f4:	1000051e 	bne	r2,zero,8110b30c <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
8110b2f8:	d0e00217 	ldw	r3,-32760(gp)
8110b2fc:	e0bfff17 	ldw	r2,-4(fp)
8110b300:	1884b03a 	or	r2,r3,r2
8110b304:	d0a00215 	stw	r2,-32760(gp)
8110b308:	00000506 	br	8110b320 <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
8110b30c:	e0bfff17 	ldw	r2,-4(fp)
8110b310:	0086303a 	nor	r3,zero,r2
8110b314:	d0a00217 	ldw	r2,-32760(gp)
8110b318:	1884703a 	and	r2,r3,r2
8110b31c:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
8110b320:	d0a00217 	ldw	r2,-32760(gp)
8110b324:	1007883a 	mov	r3,r2
8110b328:	00a00034 	movhi	r2,32768
8110b32c:	10824004 	addi	r2,r2,2304
8110b330:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110b334:	00800044 	movi	r2,1
}
8110b338:	e037883a 	mov	sp,fp
8110b33c:	df000017 	ldw	fp,0(sp)
8110b340:	dec00104 	addi	sp,sp,4
8110b344:	f800283a 	ret

8110b348 <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
8110b348:	defffc04 	addi	sp,sp,-16
8110b34c:	de00012e 	bgeu	sp,et,8110b354 <msgdma_write_extended_descriptor+0xc>
8110b350:	003b68fa 	trap	3
8110b354:	df000315 	stw	fp,12(sp)
8110b358:	df000304 	addi	fp,sp,12
8110b35c:	e13ffd15 	stw	r4,-12(fp)
8110b360:	e17ffe15 	stw	r5,-8(fp)
8110b364:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
8110b368:	e0bffd17 	ldw	r2,-12(fp)
8110b36c:	10800037 	ldwio	r2,0(r2)
8110b370:	1080010c 	andi	r2,r2,4
8110b374:	10000226 	beq	r2,zero,8110b380 <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
8110b378:	00bff904 	movi	r2,-28
8110b37c:	00003d06 	br	8110b474 <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
8110b380:	e0bfff17 	ldw	r2,-4(fp)
8110b384:	10800017 	ldw	r2,0(r2)
8110b388:	1007883a 	mov	r3,r2
8110b38c:	e0bffe17 	ldw	r2,-8(fp)
8110b390:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
8110b394:	e0bffe17 	ldw	r2,-8(fp)
8110b398:	10800104 	addi	r2,r2,4
8110b39c:	e0ffff17 	ldw	r3,-4(fp)
8110b3a0:	18c00117 	ldw	r3,4(r3)
8110b3a4:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
8110b3a8:	e0bffe17 	ldw	r2,-8(fp)
8110b3ac:	10800204 	addi	r2,r2,8
8110b3b0:	e0ffff17 	ldw	r3,-4(fp)
8110b3b4:	18c00217 	ldw	r3,8(r3)
8110b3b8:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
8110b3bc:	e0bffe17 	ldw	r2,-8(fp)
8110b3c0:	10800304 	addi	r2,r2,12
8110b3c4:	e0ffff17 	ldw	r3,-4(fp)
8110b3c8:	18c0030b 	ldhu	r3,12(r3)
8110b3cc:	18ffffcc 	andi	r3,r3,65535
8110b3d0:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
8110b3d4:	e0bffe17 	ldw	r2,-8(fp)
8110b3d8:	10800384 	addi	r2,r2,14
8110b3dc:	e0ffff17 	ldw	r3,-4(fp)
8110b3e0:	18c00383 	ldbu	r3,14(r3)
8110b3e4:	18c03fcc 	andi	r3,r3,255
8110b3e8:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
8110b3ec:	e0bffe17 	ldw	r2,-8(fp)
8110b3f0:	108003c4 	addi	r2,r2,15
8110b3f4:	e0ffff17 	ldw	r3,-4(fp)
8110b3f8:	18c003c3 	ldbu	r3,15(r3)
8110b3fc:	18c03fcc 	andi	r3,r3,255
8110b400:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
8110b404:	e0bffe17 	ldw	r2,-8(fp)
8110b408:	10800404 	addi	r2,r2,16
8110b40c:	e0ffff17 	ldw	r3,-4(fp)
8110b410:	18c0040b 	ldhu	r3,16(r3)
8110b414:	18ffffcc 	andi	r3,r3,65535
8110b418:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
8110b41c:	e0bffe17 	ldw	r2,-8(fp)
8110b420:	10800484 	addi	r2,r2,18
8110b424:	e0ffff17 	ldw	r3,-4(fp)
8110b428:	18c0048b 	ldhu	r3,18(r3)
8110b42c:	18ffffcc 	andi	r3,r3,65535
8110b430:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
8110b434:	e0bffe17 	ldw	r2,-8(fp)
8110b438:	10800504 	addi	r2,r2,20
8110b43c:	e0ffff17 	ldw	r3,-4(fp)
8110b440:	18c00517 	ldw	r3,20(r3)
8110b444:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
8110b448:	e0bffe17 	ldw	r2,-8(fp)
8110b44c:	10800604 	addi	r2,r2,24
8110b450:	e0ffff17 	ldw	r3,-4(fp)
8110b454:	18c00617 	ldw	r3,24(r3)
8110b458:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
8110b45c:	e0bffe17 	ldw	r2,-8(fp)
8110b460:	10800704 	addi	r2,r2,28
8110b464:	e0ffff17 	ldw	r3,-4(fp)
8110b468:	18c00717 	ldw	r3,28(r3)
8110b46c:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
8110b470:	0005883a 	mov	r2,zero
}
8110b474:	e037883a 	mov	sp,fp
8110b478:	df000017 	ldw	fp,0(sp)
8110b47c:	dec00104 	addi	sp,sp,4
8110b480:	f800283a 	ret

8110b484 <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
8110b484:	defff604 	addi	sp,sp,-40
8110b488:	de00012e 	bgeu	sp,et,8110b490 <msgdma_construct_extended_descriptor+0xc>
8110b48c:	003b68fa 	trap	3
8110b490:	df000915 	stw	fp,36(sp)
8110b494:	df000904 	addi	fp,sp,36
8110b498:	e13ff715 	stw	r4,-36(fp)
8110b49c:	e17ff815 	stw	r5,-32(fp)
8110b4a0:	e1bff915 	stw	r6,-28(fp)
8110b4a4:	e1fffa15 	stw	r7,-24(fp)
8110b4a8:	e1800517 	ldw	r6,20(fp)
8110b4ac:	e1400617 	ldw	r5,24(fp)
8110b4b0:	e1000717 	ldw	r4,28(fp)
8110b4b4:	e0c00817 	ldw	r3,32(fp)
8110b4b8:	e0800917 	ldw	r2,36(fp)
8110b4bc:	e1bffb0d 	sth	r6,-20(fp)
8110b4c0:	e17ffc05 	stb	r5,-16(fp)
8110b4c4:	e13ffd05 	stb	r4,-12(fp)
8110b4c8:	e0fffe0d 	sth	r3,-8(fp)
8110b4cc:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
8110b4d0:	e0bff717 	ldw	r2,-36(fp)
8110b4d4:	10c01217 	ldw	r3,72(r2)
8110b4d8:	e0800117 	ldw	r2,4(fp)
8110b4dc:	18801936 	bltu	r3,r2,8110b544 <msgdma_construct_extended_descriptor+0xc0>
8110b4e0:	e13ff717 	ldw	r4,-36(fp)
8110b4e4:	20801317 	ldw	r2,76(r4)
8110b4e8:	20c01417 	ldw	r3,80(r4)
8110b4ec:	e13ffe0b 	ldhu	r4,-8(fp)
8110b4f0:	213fffcc 	andi	r4,r4,65535
8110b4f4:	2015883a 	mov	r10,r4
8110b4f8:	0017883a 	mov	r11,zero
8110b4fc:	1ac01136 	bltu	r3,r11,8110b544 <msgdma_construct_extended_descriptor+0xc0>
8110b500:	58c0011e 	bne	r11,r3,8110b508 <msgdma_construct_extended_descriptor+0x84>
8110b504:	12800f36 	bltu	r2,r10,8110b544 <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
8110b508:	e13ff717 	ldw	r4,-36(fp)
8110b50c:	20801317 	ldw	r2,76(r4)
8110b510:	20c01417 	ldw	r3,80(r4)
8110b514:	e13fff0b 	ldhu	r4,-4(fp)
8110b518:	213fffcc 	andi	r4,r4,65535
8110b51c:	2011883a 	mov	r8,r4
8110b520:	0013883a 	mov	r9,zero
8110b524:	1a400736 	bltu	r3,r9,8110b544 <msgdma_construct_extended_descriptor+0xc0>
8110b528:	48c0011e 	bne	r9,r3,8110b530 <msgdma_construct_extended_descriptor+0xac>
8110b52c:	12000536 	bltu	r2,r8,8110b544 <msgdma_construct_extended_descriptor+0xc0>
8110b530:	e0bff717 	ldw	r2,-36(fp)
8110b534:	10801703 	ldbu	r2,92(r2)
8110b538:	10803fcc 	andi	r2,r2,255
8110b53c:	10800060 	cmpeqi	r2,r2,1
8110b540:	1000021e 	bne	r2,zero,8110b54c <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
8110b544:	00bffa84 	movi	r2,-22
8110b548:	00002306 	br	8110b5d8 <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
8110b54c:	e0bff817 	ldw	r2,-32(fp)
8110b550:	e0fff917 	ldw	r3,-28(fp)
8110b554:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
8110b558:	e0bff817 	ldw	r2,-32(fp)
8110b55c:	e0fffa17 	ldw	r3,-24(fp)
8110b560:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
8110b564:	e0bff817 	ldw	r2,-32(fp)
8110b568:	e0c00117 	ldw	r3,4(fp)
8110b56c:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
8110b570:	e0bff817 	ldw	r2,-32(fp)
8110b574:	e0fffb0b 	ldhu	r3,-20(fp)
8110b578:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
8110b57c:	e0bff817 	ldw	r2,-32(fp)
8110b580:	e0fffc03 	ldbu	r3,-16(fp)
8110b584:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8110b588:	e0bff817 	ldw	r2,-32(fp)
8110b58c:	e0fffd03 	ldbu	r3,-12(fp)
8110b590:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
8110b594:	e0bff817 	ldw	r2,-32(fp)
8110b598:	e0fffe0b 	ldhu	r3,-8(fp)
8110b59c:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
8110b5a0:	e0bff817 	ldw	r2,-32(fp)
8110b5a4:	e0ffff0b 	ldhu	r3,-4(fp)
8110b5a8:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
8110b5ac:	e0bff817 	ldw	r2,-32(fp)
8110b5b0:	e0c00317 	ldw	r3,12(fp)
8110b5b4:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
8110b5b8:	e0bff817 	ldw	r2,-32(fp)
8110b5bc:	e0c00417 	ldw	r3,16(fp)
8110b5c0:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8110b5c4:	e0800217 	ldw	r2,8(fp)
8110b5c8:	10e00034 	orhi	r3,r2,32768
8110b5cc:	e0bff817 	ldw	r2,-32(fp)
8110b5d0:	10c00715 	stw	r3,28(r2)

	return 0;
8110b5d4:	0005883a 	mov	r2,zero

}
8110b5d8:	e037883a 	mov	sp,fp
8110b5dc:	df000017 	ldw	fp,0(sp)
8110b5e0:	dec00104 	addi	sp,sp,4
8110b5e4:	f800283a 	ret

8110b5e8 <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110b5e8:	deffee04 	addi	sp,sp,-72
8110b5ec:	de00012e 	bgeu	sp,et,8110b5f4 <msgdma_descriptor_async_transfer+0xc>
8110b5f0:	003b68fa 	trap	3
8110b5f4:	dfc01115 	stw	ra,68(sp)
8110b5f8:	df001015 	stw	fp,64(sp)
8110b5fc:	df001004 	addi	fp,sp,64
8110b600:	e13ffd15 	stw	r4,-12(fp)
8110b604:	e17ffe15 	stw	r5,-8(fp)
8110b608:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110b60c:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
8110b610:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
8110b614:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b618:	e0bffd17 	ldw	r2,-12(fp)
8110b61c:	10800317 	ldw	r2,12(r2)
8110b620:	10800204 	addi	r2,r2,8
8110b624:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110b628:	10bfffcc 	andi	r2,r2,65535
8110b62c:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b630:	e0bffd17 	ldw	r2,-12(fp)
8110b634:	10800317 	ldw	r2,12(r2)
8110b638:	10800204 	addi	r2,r2,8
8110b63c:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110b640:	1004d43a 	srli	r2,r2,16
8110b644:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b648:	e0bffd17 	ldw	r2,-12(fp)
8110b64c:	10800917 	ldw	r2,36(r2)
8110b650:	e0fff417 	ldw	r3,-48(fp)
8110b654:	1880042e 	bgeu	r3,r2,8110b668 <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110b658:	e0bffd17 	ldw	r2,-12(fp)
8110b65c:	10800917 	ldw	r2,36(r2)
8110b660:	e0fff317 	ldw	r3,-52(fp)
8110b664:	18800236 	bltu	r3,r2,8110b670 <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
8110b668:	00bff904 	movi	r2,-28
8110b66c:	00009f06 	br	8110b8ec <msgdma_descriptor_async_transfer+0x304>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110b670:	e0bffd17 	ldw	r2,-12(fp)
8110b674:	10801817 	ldw	r2,96(r2)
8110b678:	e0bff615 	stw	r2,-40(fp)
8110b67c:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8110b680:	e0bffc0b 	ldhu	r2,-16(fp)
8110b684:	e0fffc84 	addi	r3,fp,-14
8110b688:	180d883a 	mov	r6,r3
8110b68c:	100b883a 	mov	r5,r2
8110b690:	e13ff617 	ldw	r4,-40(fp)
8110b694:	113dcd40 	call	8113dcd4 <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8110b698:	00800804 	movi	r2,32
8110b69c:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b6a0:	0005303a 	rdctl	r2,status
8110b6a4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b6a8:	e0fff717 	ldw	r3,-36(fp)
8110b6ac:	00bfff84 	movi	r2,-2
8110b6b0:	1884703a 	and	r2,r3,r2
8110b6b4:	1001703a 	wrctl	status,r2
  
  return context;
8110b6b8:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110b6bc:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b6c0:	e0bffd17 	ldw	r2,-12(fp)
8110b6c4:	10800317 	ldw	r2,12(r2)
8110b6c8:	10800104 	addi	r2,r2,4
8110b6cc:	e0fff117 	ldw	r3,-60(fp)
8110b6d0:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110b6d4:	e0bffd17 	ldw	r2,-12(fp)
8110b6d8:	10800317 	ldw	r2,12(r2)
8110b6dc:	e0fffd17 	ldw	r3,-12(fp)
8110b6e0:	18c00317 	ldw	r3,12(r3)
8110b6e4:	18c00037 	ldwio	r3,0(r3)
8110b6e8:	10c00035 	stwio	r3,0(r2)
8110b6ec:	e0bff217 	ldw	r2,-56(fp)
8110b6f0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b6f4:	e0bffb17 	ldw	r2,-20(fp)
8110b6f8:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
8110b6fc:	e0bffe17 	ldw	r2,-8(fp)
8110b700:	10001026 	beq	r2,zero,8110b744 <msgdma_descriptor_async_transfer+0x15c>
8110b704:	e0bfff17 	ldw	r2,-4(fp)
8110b708:	10000e1e 	bne	r2,zero,8110b744 <msgdma_descriptor_async_transfer+0x15c>
		counter = 0; /* reset counter */
8110b70c:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110b710:	d0a06117 	ldw	r2,-32380(gp)
8110b714:	100f883a 	mov	r7,r2
8110b718:	01800784 	movi	r6,30
8110b71c:	01400044 	movi	r5,1
8110b720:	01204574 	movhi	r4,33045
8110b724:	212d8b04 	addi	r4,r4,-18900
8110b728:	1120e540 	call	81120e54 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110b72c:	e0bffd17 	ldw	r2,-12(fp)
8110b730:	10801817 	ldw	r2,96(r2)
8110b734:	1009883a 	mov	r4,r2
8110b738:	113e05c0 	call	8113e05c <OSSemPost>

		return -ETIME;
8110b73c:	00bff084 	movi	r2,-62
8110b740:	00006a06 	br	8110b8ec <msgdma_descriptor_async_transfer+0x304>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b744:	e0bffe17 	ldw	r2,-8(fp)
8110b748:	1000231e 	bne	r2,zero,8110b7d8 <msgdma_descriptor_async_transfer+0x1f0>
8110b74c:	e0bfff17 	ldw	r2,-4(fp)
8110b750:	10002126 	beq	r2,zero,8110b7d8 <msgdma_descriptor_async_transfer+0x1f0>
		counter = 0; /* reset counter */
8110b754:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b758:	00001506 	br	8110b7b0 <msgdma_descriptor_async_transfer+0x1c8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110b75c:	01000044 	movi	r4,1
8110b760:	113545c0 	call	8113545c <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b764:	e0bff00b 	ldhu	r2,-64(fp)
8110b768:	1084e230 	cmpltui	r2,r2,5000
8110b76c:	10000d1e 	bne	r2,zero,8110b7a4 <msgdma_descriptor_async_transfer+0x1bc>
			{
#ifdef DEBUG_ON
				debug(fp,
8110b770:	d0a06117 	ldw	r2,-32380(gp)
8110b774:	100f883a 	mov	r7,r2
8110b778:	01801544 	movi	r6,85
8110b77c:	01400044 	movi	r5,1
8110b780:	01204574 	movhi	r4,33045
8110b784:	212d9304 	addi	r4,r4,-18868
8110b788:	1120e540 	call	81120e54 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110b78c:	e0bffd17 	ldw	r2,-12(fp)
8110b790:	10801817 	ldw	r2,96(r2)
8110b794:	1009883a 	mov	r4,r2
8110b798:	113e05c0 	call	8113e05c <OSSemPost>

				return -ETIME;
8110b79c:	00bff084 	movi	r2,-62
8110b7a0:	00005206 	br	8110b8ec <msgdma_descriptor_async_transfer+0x304>
			}
			counter++;
8110b7a4:	e0bff00b 	ldhu	r2,-64(fp)
8110b7a8:	10800044 	addi	r2,r2,1
8110b7ac:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110b7b0:	e0bffd17 	ldw	r2,-12(fp)
8110b7b4:	10c00317 	ldw	r3,12(r2)
8110b7b8:	e0bffd17 	ldw	r2,-12(fp)
8110b7bc:	10800417 	ldw	r2,16(r2)
8110b7c0:	e1bfff17 	ldw	r6,-4(fp)
8110b7c4:	100b883a 	mov	r5,r2
8110b7c8:	1809883a 	mov	r4,r3
8110b7cc:	110b3480 	call	8110b348 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b7d0:	103fe21e 	bne	r2,zero,8110b75c <__reset+0xfb0eb75c>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b7d4:	00000606 	br	8110b7f0 <msgdma_descriptor_async_transfer+0x208>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110b7d8:	e0bffd17 	ldw	r2,-12(fp)
8110b7dc:	10801817 	ldw	r2,96(r2)
8110b7e0:	1009883a 	mov	r4,r2
8110b7e4:	113e05c0 	call	8113e05c <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110b7e8:	00bfffc4 	movi	r2,-1
8110b7ec:	00003f06 	br	8110b8ec <msgdma_descriptor_async_transfer+0x304>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
8110b7f0:	e0bffd17 	ldw	r2,-12(fp)
8110b7f4:	10800b17 	ldw	r2,44(r2)
8110b7f8:	10001c26 	beq	r2,zero,8110b86c <msgdma_descriptor_async_transfer+0x284>

		control |= (dev->control |
8110b7fc:	e0bffd17 	ldw	r2,-12(fp)
8110b800:	10c00d17 	ldw	r3,52(r2)
8110b804:	e0bff117 	ldw	r2,-60(fp)
8110b808:	1884b03a 	or	r2,r3,r2
8110b80c:	10800514 	ori	r2,r2,20
8110b810:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8110b814:	e0fff117 	ldw	r3,-60(fp)
8110b818:	00bff7c4 	movi	r2,-33
8110b81c:	1884703a 	and	r2,r3,r2
8110b820:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b824:	0005303a 	rdctl	r2,status
8110b828:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b82c:	e0fff917 	ldw	r3,-28(fp)
8110b830:	00bfff84 	movi	r2,-2
8110b834:	1884703a 	and	r2,r3,r2
8110b838:	1001703a 	wrctl	status,r2
  
  return context;
8110b83c:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110b840:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b844:	e0bffd17 	ldw	r2,-12(fp)
8110b848:	10800317 	ldw	r2,12(r2)
8110b84c:	10800104 	addi	r2,r2,4
8110b850:	e0fff117 	ldw	r3,-60(fp)
8110b854:	10c00035 	stwio	r3,0(r2)
8110b858:	e0bff217 	ldw	r2,-56(fp)
8110b85c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b860:	e0bff517 	ldw	r2,-44(fp)
8110b864:	1001703a 	wrctl	status,r2
8110b868:	00001b06 	br	8110b8d8 <msgdma_descriptor_async_transfer+0x2f0>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
8110b86c:	e0bffd17 	ldw	r2,-12(fp)
8110b870:	10c00d17 	ldw	r3,52(r2)
8110b874:	e0bff117 	ldw	r2,-60(fp)
8110b878:	1884b03a 	or	r2,r3,r2
8110b87c:	10800114 	ori	r2,r2,4
8110b880:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
8110b884:	e0fff117 	ldw	r3,-60(fp)
8110b888:	00bff3c4 	movi	r2,-49
8110b88c:	1884703a 	and	r2,r3,r2
8110b890:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b894:	0005303a 	rdctl	r2,status
8110b898:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b89c:	e0fffa17 	ldw	r3,-24(fp)
8110b8a0:	00bfff84 	movi	r2,-2
8110b8a4:	1884703a 	and	r2,r3,r2
8110b8a8:	1001703a 	wrctl	status,r2
  
  return context;
8110b8ac:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110b8b0:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b8b4:	e0bffd17 	ldw	r2,-12(fp)
8110b8b8:	10800317 	ldw	r2,12(r2)
8110b8bc:	10800104 	addi	r2,r2,4
8110b8c0:	e0fff117 	ldw	r3,-60(fp)
8110b8c4:	10c00035 	stwio	r3,0(r2)
8110b8c8:	e0bff217 	ldw	r2,-56(fp)
8110b8cc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b8d0:	e0bff817 	ldw	r2,-32(fp)
8110b8d4:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110b8d8:	e0bffd17 	ldw	r2,-12(fp)
8110b8dc:	10801817 	ldw	r2,96(r2)
8110b8e0:	1009883a 	mov	r4,r2
8110b8e4:	113e05c0 	call	8113e05c <OSSemPost>

	return 0;
8110b8e8:	0005883a 	mov	r2,zero
}
8110b8ec:	e037883a 	mov	sp,fp
8110b8f0:	dfc00117 	ldw	ra,4(sp)
8110b8f4:	df000017 	ldw	fp,0(sp)
8110b8f8:	dec00204 	addi	sp,sp,8
8110b8fc:	f800283a 	ret

8110b900 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110b900:	deffee04 	addi	sp,sp,-72
8110b904:	de00012e 	bgeu	sp,et,8110b90c <msgdma_descriptor_sync_transfer+0xc>
8110b908:	003b68fa 	trap	3
8110b90c:	dfc01115 	stw	ra,68(sp)
8110b910:	df001015 	stw	fp,64(sp)
8110b914:	df001004 	addi	fp,sp,64
8110b918:	e13ffd15 	stw	r4,-12(fp)
8110b91c:	e17ffe15 	stw	r5,-8(fp)
8110b920:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110b924:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
8110b928:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
8110b92c:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
8110b930:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b934:	e0bffd17 	ldw	r2,-12(fp)
8110b938:	10800317 	ldw	r2,12(r2)
8110b93c:	10800204 	addi	r2,r2,8
8110b940:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110b944:	10bfffcc 	andi	r2,r2,65535
8110b948:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b94c:	e0bffd17 	ldw	r2,-12(fp)
8110b950:	10800317 	ldw	r2,12(r2)
8110b954:	10800204 	addi	r2,r2,8
8110b958:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110b95c:	1004d43a 	srli	r2,r2,16
8110b960:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
8110b964:	00807804 	movi	r2,480
8110b968:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b96c:	00001d06 	br	8110b9e4 <msgdma_descriptor_sync_transfer+0xe4>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
8110b970:	01000044 	movi	r4,1
8110b974:	113545c0 	call	8113545c <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b978:	e0bff10b 	ldhu	r2,-60(fp)
8110b97c:	1084e230 	cmpltui	r2,r2,5000
8110b980:	1000091e 	bne	r2,zero,8110b9a8 <msgdma_descriptor_sync_transfer+0xa8>
		{
#ifdef DEBUG_ON
			debug(fp,
8110b984:	d0a06117 	ldw	r2,-32380(gp)
8110b988:	100f883a 	mov	r7,r2
8110b98c:	01801304 	movi	r6,76
8110b990:	01400044 	movi	r5,1
8110b994:	01204574 	movhi	r4,33045
8110b998:	212da904 	addi	r4,r4,-18780
8110b99c:	1120e540 	call	81120e54 <fwrite>
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
8110b9a0:	00bff084 	movi	r2,-62
8110b9a4:	0000d006 	br	8110bce8 <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110b9a8:	e0bff10b 	ldhu	r2,-60(fp)
8110b9ac:	10800044 	addi	r2,r2,1
8110b9b0:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b9b4:	e0bffd17 	ldw	r2,-12(fp)
8110b9b8:	10800317 	ldw	r2,12(r2)
8110b9bc:	10800204 	addi	r2,r2,8
8110b9c0:	10800037 	ldwio	r2,0(r2)
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
8110b9c4:	10bfffcc 	andi	r2,r2,65535
8110b9c8:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b9cc:	e0bffd17 	ldw	r2,-12(fp)
8110b9d0:	10800317 	ldw	r2,12(r2)
8110b9d4:	10800204 	addi	r2,r2,8
8110b9d8:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
8110b9dc:	1004d43a 	srli	r2,r2,16
8110b9e0:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b9e4:	e0bffd17 	ldw	r2,-12(fp)
8110b9e8:	10800917 	ldw	r2,36(r2)
8110b9ec:	e0fff317 	ldw	r3,-52(fp)
8110b9f0:	18bfdf2e 	bgeu	r3,r2,8110b970 <__reset+0xfb0eb970>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110b9f4:	e0bffd17 	ldw	r2,-12(fp)
8110b9f8:	10800917 	ldw	r2,36(r2)
8110b9fc:	e0fff217 	ldw	r3,-56(fp)
8110ba00:	18bfdb2e 	bgeu	r3,r2,8110b970 <__reset+0xfb0eb970>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110ba04:	e0bffd17 	ldw	r2,-12(fp)
8110ba08:	10801817 	ldw	r2,96(r2)
8110ba0c:	e0bff815 	stw	r2,-32(fp)
8110ba10:	e03ffc0d 	sth	zero,-16(fp)
8110ba14:	e0bffc0b 	ldhu	r2,-16(fp)
8110ba18:	e0fffc84 	addi	r3,fp,-14
8110ba1c:	180d883a 	mov	r6,r3
8110ba20:	100b883a 	mov	r5,r2
8110ba24:	e13ff817 	ldw	r4,-32(fp)
8110ba28:	113dcd40 	call	8113dcd4 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110ba2c:	0005303a 	rdctl	r2,status
8110ba30:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110ba34:	e0fffb17 	ldw	r3,-20(fp)
8110ba38:	00bfff84 	movi	r2,-2
8110ba3c:	1884703a 	and	r2,r3,r2
8110ba40:	1001703a 	wrctl	status,r2
  
  return context;
8110ba44:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110ba48:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110ba4c:	e0bffd17 	ldw	r2,-12(fp)
8110ba50:	10800317 	ldw	r2,12(r2)
8110ba54:	10800104 	addi	r2,r2,4
8110ba58:	00c00804 	movi	r3,32
8110ba5c:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110ba60:	e0bffd17 	ldw	r2,-12(fp)
8110ba64:	10800317 	ldw	r2,12(r2)
8110ba68:	e0fffd17 	ldw	r3,-12(fp)
8110ba6c:	18c00317 	ldw	r3,12(r3)
8110ba70:	18c00037 	ldwio	r3,0(r3)
8110ba74:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
8110ba78:	e0bffe17 	ldw	r2,-8(fp)
8110ba7c:	10001026 	beq	r2,zero,8110bac0 <msgdma_descriptor_sync_transfer+0x1c0>
8110ba80:	e0bfff17 	ldw	r2,-4(fp)
8110ba84:	10000e1e 	bne	r2,zero,8110bac0 <msgdma_descriptor_sync_transfer+0x1c0>
		counter = 0; /* reset counter */
8110ba88:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110ba8c:	d0a06117 	ldw	r2,-32380(gp)
8110ba90:	100f883a 	mov	r7,r2
8110ba94:	01800784 	movi	r6,30
8110ba98:	01400044 	movi	r5,1
8110ba9c:	01204574 	movhi	r4,33045
8110baa0:	212d8b04 	addi	r4,r4,-18900
8110baa4:	1120e540 	call	81120e54 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110baa8:	e0bffd17 	ldw	r2,-12(fp)
8110baac:	10801817 	ldw	r2,96(r2)
8110bab0:	1009883a 	mov	r4,r2
8110bab4:	113e05c0 	call	8113e05c <OSSemPost>

		return -ETIME;
8110bab8:	00bff084 	movi	r2,-62
8110babc:	00008a06 	br	8110bce8 <msgdma_descriptor_sync_transfer+0x3e8>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110bac0:	e0bffe17 	ldw	r2,-8(fp)
8110bac4:	1000231e 	bne	r2,zero,8110bb54 <msgdma_descriptor_sync_transfer+0x254>
8110bac8:	e0bfff17 	ldw	r2,-4(fp)
8110bacc:	10002126 	beq	r2,zero,8110bb54 <msgdma_descriptor_sync_transfer+0x254>
		counter = 0; /* reset counter */
8110bad0:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110bad4:	00001506 	br	8110bb2c <msgdma_descriptor_sync_transfer+0x22c>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110bad8:	01000044 	movi	r4,1
8110badc:	113545c0 	call	8113545c <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110bae0:	e0bff10b 	ldhu	r2,-60(fp)
8110bae4:	1084e230 	cmpltui	r2,r2,5000
8110bae8:	10000d1e 	bne	r2,zero,8110bb20 <msgdma_descriptor_sync_transfer+0x220>
			{
#ifdef DEBUG_ON
				debug(fp,
8110baec:	d0a06117 	ldw	r2,-32380(gp)
8110baf0:	100f883a 	mov	r7,r2
8110baf4:	01801004 	movi	r6,64
8110baf8:	01400044 	movi	r5,1
8110bafc:	01204574 	movhi	r4,33045
8110bb00:	212dbd04 	addi	r4,r4,-18700
8110bb04:	1120e540 	call	81120e54 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110bb08:	e0bffd17 	ldw	r2,-12(fp)
8110bb0c:	10801817 	ldw	r2,96(r2)
8110bb10:	1009883a 	mov	r4,r2
8110bb14:	113e05c0 	call	8113e05c <OSSemPost>

				return -ETIME;
8110bb18:	00bff084 	movi	r2,-62
8110bb1c:	00007206 	br	8110bce8 <msgdma_descriptor_sync_transfer+0x3e8>
			}
			counter++;
8110bb20:	e0bff10b 	ldhu	r2,-60(fp)
8110bb24:	10800044 	addi	r2,r2,1
8110bb28:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110bb2c:	e0bffd17 	ldw	r2,-12(fp)
8110bb30:	10c00317 	ldw	r3,12(r2)
8110bb34:	e0bffd17 	ldw	r2,-12(fp)
8110bb38:	10800417 	ldw	r2,16(r2)
8110bb3c:	e1bfff17 	ldw	r6,-4(fp)
8110bb40:	100b883a 	mov	r5,r2
8110bb44:	1809883a 	mov	r4,r3
8110bb48:	110b3480 	call	8110b348 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110bb4c:	103fe21e 	bne	r2,zero,8110bad8 <__reset+0xfb0ebad8>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110bb50:	00000606 	br	8110bb6c <msgdma_descriptor_sync_transfer+0x26c>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110bb54:	e0bffd17 	ldw	r2,-12(fp)
8110bb58:	10801817 	ldw	r2,96(r2)
8110bb5c:	1009883a 	mov	r4,r2
8110bb60:	113e05c0 	call	8113e05c <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110bb64:	00bfffc4 	movi	r2,-1
8110bb68:	00005f06 	br	8110bce8 <msgdma_descriptor_sync_transfer+0x3e8>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110bb6c:	e0bffd17 	ldw	r2,-12(fp)
8110bb70:	10800317 	ldw	r2,12(r2)
8110bb74:	10800104 	addi	r2,r2,4
8110bb78:	e0fffd17 	ldw	r3,-12(fp)
8110bb7c:	19000d17 	ldw	r4,52(r3)
8110bb80:	00fff2c4 	movi	r3,-53
8110bb84:	20c6703a 	and	r3,r4,r3
8110bb88:	18c00114 	ori	r3,r3,4
8110bb8c:	10c00035 	stwio	r3,0(r2)
8110bb90:	e0bff517 	ldw	r2,-44(fp)
8110bb94:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110bb98:	e0bff717 	ldw	r2,-36(fp)
8110bb9c:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
8110bba0:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110bba4:	e0bffd17 	ldw	r2,-12(fp)
8110bba8:	10800317 	ldw	r2,12(r2)
8110bbac:	10800037 	ldwio	r2,0(r2)
8110bbb0:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110bbb4:	00001906 	br	8110bc1c <msgdma_descriptor_sync_transfer+0x31c>
		alt_busy_sleep(1); /* delay 1us */
8110bbb8:	01000044 	movi	r4,1
8110bbbc:	113545c0 	call	8113545c <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110bbc0:	e0bff10b 	ldhu	r2,-60(fp)
8110bbc4:	1084e230 	cmpltui	r2,r2,5000
8110bbc8:	10000d1e 	bne	r2,zero,8110bc00 <msgdma_descriptor_sync_transfer+0x300>
		{
#ifdef DEBUG_ON
			debug(fp,
8110bbcc:	d0a06117 	ldw	r2,-32380(gp)
8110bbd0:	100f883a 	mov	r7,r2
8110bbd4:	01801184 	movi	r6,70
8110bbd8:	01400044 	movi	r5,1
8110bbdc:	01204574 	movhi	r4,33045
8110bbe0:	212dce04 	addi	r4,r4,-18632
8110bbe4:	1120e540 	call	81120e54 <fwrite>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
8110bbe8:	e0bffd17 	ldw	r2,-12(fp)
8110bbec:	10801817 	ldw	r2,96(r2)
8110bbf0:	1009883a 	mov	r4,r2
8110bbf4:	113e05c0 	call	8113e05c <OSSemPost>

			return -ETIME;
8110bbf8:	00bff084 	movi	r2,-62
8110bbfc:	00003a06 	br	8110bce8 <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110bc00:	e0bff10b 	ldhu	r2,-60(fp)
8110bc04:	10800044 	addi	r2,r2,1
8110bc08:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110bc0c:	e0bffd17 	ldw	r2,-12(fp)
8110bc10:	10800317 	ldw	r2,12(r2)
8110bc14:	10800037 	ldwio	r2,0(r2)
8110bc18:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110bc1c:	e0fff017 	ldw	r3,-64(fp)
8110bc20:	e0bff617 	ldw	r2,-40(fp)
8110bc24:	1884703a 	and	r2,r3,r2
8110bc28:	1000031e 	bne	r2,zero,8110bc38 <msgdma_descriptor_sync_transfer+0x338>
8110bc2c:	e0bff017 	ldw	r2,-64(fp)
8110bc30:	1080004c 	andi	r2,r2,1
8110bc34:	103fe01e 	bne	r2,zero,8110bbb8 <__reset+0xfb0ebbb8>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
8110bc38:	e0fff017 	ldw	r3,-64(fp)
8110bc3c:	e0bff617 	ldw	r2,-40(fp)
8110bc40:	1884703a 	and	r2,r3,r2
8110bc44:	10000626 	beq	r2,zero,8110bc60 <msgdma_descriptor_sync_transfer+0x360>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110bc48:	e0bffd17 	ldw	r2,-12(fp)
8110bc4c:	10801817 	ldw	r2,96(r2)
8110bc50:	1009883a 	mov	r4,r2
8110bc54:	113e05c0 	call	8113e05c <OSSemPost>

		return error;
8110bc58:	e0bff617 	ldw	r2,-40(fp)
8110bc5c:	00002206 	br	8110bce8 <msgdma_descriptor_sync_transfer+0x3e8>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
8110bc60:	e0bffd17 	ldw	r2,-12(fp)
8110bc64:	10800317 	ldw	r2,12(r2)
8110bc68:	10800104 	addi	r2,r2,4
8110bc6c:	10800037 	ldwio	r2,0(r2)
8110bc70:	10800814 	ori	r2,r2,32
8110bc74:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110bc78:	0005303a 	rdctl	r2,status
8110bc7c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110bc80:	e0fffa17 	ldw	r3,-24(fp)
8110bc84:	00bfff84 	movi	r2,-2
8110bc88:	1884703a 	and	r2,r3,r2
8110bc8c:	1001703a 	wrctl	status,r2
  
  return context;
8110bc90:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110bc94:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110bc98:	e0bffd17 	ldw	r2,-12(fp)
8110bc9c:	10800317 	ldw	r2,12(r2)
8110bca0:	10800104 	addi	r2,r2,4
8110bca4:	e0fff417 	ldw	r3,-48(fp)
8110bca8:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110bcac:	e0bffd17 	ldw	r2,-12(fp)
8110bcb0:	10800317 	ldw	r2,12(r2)
8110bcb4:	e0fffd17 	ldw	r3,-12(fp)
8110bcb8:	18c00317 	ldw	r3,12(r3)
8110bcbc:	18c00037 	ldwio	r3,0(r3)
8110bcc0:	10c00035 	stwio	r3,0(r2)
8110bcc4:	e0bff517 	ldw	r2,-44(fp)
8110bcc8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110bccc:	e0bff917 	ldw	r2,-28(fp)
8110bcd0:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110bcd4:	e0bffd17 	ldw	r2,-12(fp)
8110bcd8:	10801817 	ldw	r2,96(r2)
8110bcdc:	1009883a 	mov	r4,r2
8110bce0:	113e05c0 	call	8113e05c <OSSemPost>

	return 0;
8110bce4:	0005883a 	mov	r2,zero

}
8110bce8:	e037883a 	mov	sp,fp
8110bcec:	dfc00117 	ldw	ra,4(sp)
8110bcf0:	df000017 	ldw	fp,0(sp)
8110bcf4:	dec00204 	addi	sp,sp,8
8110bcf8:	f800283a 	ret

8110bcfc <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
8110bcfc:	deffec04 	addi	sp,sp,-80
8110bd00:	de00012e 	bgeu	sp,et,8110bd08 <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
8110bd04:	003b68fa 	trap	3
8110bd08:	dfc01315 	stw	ra,76(sp)
8110bd0c:	df001215 	stw	fp,72(sp)
8110bd10:	df001204 	addi	fp,sp,72
8110bd14:	e13ff715 	stw	r4,-36(fp)
8110bd18:	e17ff815 	stw	r5,-32(fp)
8110bd1c:	e1bff915 	stw	r6,-28(fp)
8110bd20:	e1fffa15 	stw	r7,-24(fp)
8110bd24:	e1800617 	ldw	r6,24(fp)
8110bd28:	e1400717 	ldw	r5,28(fp)
8110bd2c:	e1000817 	ldw	r4,32(fp)
8110bd30:	e0c00917 	ldw	r3,36(fp)
8110bd34:	e0800a17 	ldw	r2,40(fp)
8110bd38:	e1bffb0d 	sth	r6,-20(fp)
8110bd3c:	e17ffc05 	stb	r5,-16(fp)
8110bd40:	e13ffd05 	stb	r4,-12(fp)
8110bd44:	e0fffe0d 	sth	r3,-8(fp)
8110bd48:	e0bfff0d 	sth	r2,-4(fp)
	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
8110bd4c:	e0bffb0b 	ldhu	r2,-20(fp)
8110bd50:	e0fffc03 	ldbu	r3,-16(fp)
8110bd54:	e13ffd03 	ldbu	r4,-12(fp)
8110bd58:	e17ffe0b 	ldhu	r5,-8(fp)
8110bd5c:	e1bfff0b 	ldhu	r6,-4(fp)
8110bd60:	d9800815 	stw	r6,32(sp)
8110bd64:	d9400715 	stw	r5,28(sp)
8110bd68:	d9000615 	stw	r4,24(sp)
8110bd6c:	d8c00515 	stw	r3,20(sp)
8110bd70:	d8800415 	stw	r2,16(sp)
8110bd74:	e0800517 	ldw	r2,20(fp)
8110bd78:	d8800315 	stw	r2,12(sp)
8110bd7c:	e0800417 	ldw	r2,16(fp)
8110bd80:	d8800215 	stw	r2,8(sp)
8110bd84:	e0800317 	ldw	r2,12(fp)
8110bd88:	d8800115 	stw	r2,4(sp)
8110bd8c:	e0800217 	ldw	r2,8(fp)
8110bd90:	d8800015 	stw	r2,0(sp)
8110bd94:	e1fffa17 	ldw	r7,-24(fp)
8110bd98:	e1bff917 	ldw	r6,-28(fp)
8110bd9c:	e17ff817 	ldw	r5,-32(fp)
8110bda0:	e13ff717 	ldw	r4,-36(fp)
8110bda4:	110b4840 	call	8110b484 <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
8110bda8:	e037883a 	mov	sp,fp
8110bdac:	dfc00117 	ldw	ra,4(sp)
8110bdb0:	df000017 	ldw	fp,0(sp)
8110bdb4:	dec00204 	addi	sp,sp,8
8110bdb8:	f800283a 	ret

8110bdbc <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110bdbc:	defffc04 	addi	sp,sp,-16
8110bdc0:	de00012e 	bgeu	sp,et,8110bdc8 <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
8110bdc4:	003b68fa 	trap	3
8110bdc8:	dfc00315 	stw	ra,12(sp)
8110bdcc:	df000215 	stw	fp,8(sp)
8110bdd0:	df000204 	addi	fp,sp,8
8110bdd4:	e13ffe15 	stw	r4,-8(fp)
8110bdd8:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
8110bddc:	e1bfff17 	ldw	r6,-4(fp)
8110bde0:	000b883a 	mov	r5,zero
8110bde4:	e13ffe17 	ldw	r4,-8(fp)
8110bde8:	110b5e80 	call	8110b5e8 <msgdma_descriptor_async_transfer>
}
8110bdec:	e037883a 	mov	sp,fp
8110bdf0:	dfc00117 	ldw	ra,4(sp)
8110bdf4:	df000017 	ldw	fp,0(sp)
8110bdf8:	dec00204 	addi	sp,sp,8
8110bdfc:	f800283a 	ret

8110be00 <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110be00:	defffc04 	addi	sp,sp,-16
8110be04:	de00012e 	bgeu	sp,et,8110be0c <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
8110be08:	003b68fa 	trap	3
8110be0c:	dfc00315 	stw	ra,12(sp)
8110be10:	df000215 	stw	fp,8(sp)
8110be14:	df000204 	addi	fp,sp,8
8110be18:	e13ffe15 	stw	r4,-8(fp)
8110be1c:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
8110be20:	e1bfff17 	ldw	r6,-4(fp)
8110be24:	000b883a 	mov	r5,zero
8110be28:	e13ffe17 	ldw	r4,-8(fp)
8110be2c:	110b9000 	call	8110b900 <msgdma_descriptor_sync_transfer>
}
8110be30:	e037883a 	mov	sp,fp
8110be34:	dfc00117 	ldw	ra,4(sp)
8110be38:	df000017 	ldw	fp,0(sp)
8110be3c:	dec00204 	addi	sp,sp,8
8110be40:	f800283a 	ret

8110be44 <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
8110be44:	defff204 	addi	sp,sp,-56
8110be48:	de00012e 	bgeu	sp,et,8110be50 <POWER_SPI_RW+0xc>
8110be4c:	003b68fa 	trap	3
8110be50:	dfc00d15 	stw	ra,52(sp)
8110be54:	df000c15 	stw	fp,48(sp)
8110be58:	df000c04 	addi	fp,sp,48
8110be5c:	2007883a 	mov	r3,r4
8110be60:	2805883a 	mov	r2,r5
8110be64:	e1bffe15 	stw	r6,-8(fp)
8110be68:	e1ffff15 	stw	r7,-4(fp)
8110be6c:	e0fffc05 	stb	r3,-16(fp)
8110be70:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
8110be74:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
8110be78:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
8110be7c:	008003f4 	movhi	r2,15
8110be80:	10909004 	addi	r2,r2,16960
8110be84:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
8110be88:	00bfe004 	movi	r2,-128
8110be8c:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
8110be90:	e0bffe17 	ldw	r2,-8(fp)
8110be94:	10000226 	beq	r2,zero,8110bea0 <POWER_SPI_RW+0x5c>
8110be98:	00800804 	movi	r2,32
8110be9c:	00000106 	br	8110bea4 <POWER_SPI_RW+0x60>
8110bea0:	0005883a 	mov	r2,zero
8110bea4:	e0fff403 	ldbu	r3,-48(fp)
8110bea8:	10c4b03a 	or	r2,r2,r3
8110beac:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
8110beb0:	e0800217 	ldw	r2,8(fp)
8110beb4:	10000226 	beq	r2,zero,8110bec0 <POWER_SPI_RW+0x7c>
8110beb8:	00800404 	movi	r2,16
8110bebc:	00000106 	br	8110bec4 <POWER_SPI_RW+0x80>
8110bec0:	0005883a 	mov	r2,zero
8110bec4:	e0fff403 	ldbu	r3,-48(fp)
8110bec8:	10c4b03a 	or	r2,r2,r3
8110becc:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
8110bed0:	e0bfff17 	ldw	r2,-4(fp)
8110bed4:	10000226 	beq	r2,zero,8110bee0 <POWER_SPI_RW+0x9c>
8110bed8:	00800204 	movi	r2,8
8110bedc:	00000106 	br	8110bee4 <POWER_SPI_RW+0xa0>
8110bee0:	0005883a 	mov	r2,zero
8110bee4:	e0fff403 	ldbu	r3,-48(fp)
8110bee8:	10c4b03a 	or	r2,r2,r3
8110beec:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
8110bef0:	e0bffd03 	ldbu	r2,-12(fp)
8110bef4:	108001cc 	andi	r2,r2,7
8110bef8:	1007883a 	mov	r3,r2
8110befc:	e0bff403 	ldbu	r2,-48(fp)
8110bf00:	1884b03a 	or	r2,r3,r2
8110bf04:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
8110bf08:	0007883a 	mov	r3,zero
8110bf0c:	00a00034 	movhi	r2,32768
8110bf10:	10824404 	addi	r2,r2,2320
8110bf14:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
8110bf18:	0007883a 	mov	r3,zero
8110bf1c:	00a00034 	movhi	r2,32768
8110bf20:	10824c04 	addi	r2,r2,2352
8110bf24:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
8110bf28:	e0bffc03 	ldbu	r2,-16(fp)
8110bf2c:	1000021e 	bne	r2,zero,8110bf38 <POWER_SPI_RW+0xf4>
8110bf30:	00c00084 	movi	r3,2
8110bf34:	00000106 	br	8110bf3c <POWER_SPI_RW+0xf8>
8110bf38:	00c00044 	movi	r3,1
8110bf3c:	00a00034 	movhi	r2,32768
8110bf40:	10824804 	addi	r2,r2,2336
8110bf44:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110bf48:	010003c4 	movi	r4,15
8110bf4c:	1136ed00 	call	81136ed0 <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110bf50:	00000306 	br	8110bf60 <POWER_SPI_RW+0x11c>
		nWait++;
8110bf54:	e0bff817 	ldw	r2,-32(fp)
8110bf58:	10800044 	addi	r2,r2,1
8110bf5c:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110bf60:	00a00034 	movhi	r2,32768
8110bf64:	10825404 	addi	r2,r2,2384
8110bf68:	10800037 	ldwio	r2,0(r2)
8110bf6c:	1080004c 	andi	r2,r2,1
8110bf70:	10000326 	beq	r2,zero,8110bf80 <POWER_SPI_RW+0x13c>
8110bf74:	e0fff817 	ldw	r3,-32(fp)
8110bf78:	e0bffa17 	ldw	r2,-24(fp)
8110bf7c:	18bff516 	blt	r3,r2,8110bf54 <__reset+0xfb0ebf54>
		nWait++;
	}

	if (SPI_SDO) {
8110bf80:	00a00034 	movhi	r2,32768
8110bf84:	10825404 	addi	r2,r2,2384
8110bf88:	10800037 	ldwio	r2,0(r2)
8110bf8c:	1080004c 	andi	r2,r2,1
8110bf90:	10000626 	beq	r2,zero,8110bfac <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110bf94:	00c000c4 	movi	r3,3
8110bf98:	00a00034 	movhi	r2,32768
8110bf9c:	10824804 	addi	r2,r2,2336
8110bfa0:	10c00035 	stwio	r3,0(r2)
#ifdef DEBUG_ON
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
8110bfa4:	0005883a 	mov	r2,zero
8110bfa8:	0000db06 	br	8110c318 <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110bfac:	e03ff715 	stw	zero,-36(fp)
8110bfb0:	00002406 	br	8110c044 <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
8110bfb4:	e0bff403 	ldbu	r2,-48(fp)
8110bfb8:	10803fcc 	andi	r2,r2,255
8110bfbc:	1004d1fa 	srli	r2,r2,7
8110bfc0:	10c03fcc 	andi	r3,r2,255
8110bfc4:	00a00034 	movhi	r2,32768
8110bfc8:	10825004 	addi	r2,r2,2368
8110bfcc:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110bfd0:	e0bff403 	ldbu	r2,-48(fp)
8110bfd4:	1085883a 	add	r2,r2,r2
8110bfd8:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110bfdc:	e0bff517 	ldw	r2,-44(fp)
8110bfe0:	1085883a 	add	r2,r2,r2
8110bfe4:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110bfe8:	00a00034 	movhi	r2,32768
8110bfec:	10825404 	addi	r2,r2,2384
8110bff0:	10800037 	ldwio	r2,0(r2)
8110bff4:	1080004c 	andi	r2,r2,1
8110bff8:	1007883a 	mov	r3,r2
8110bffc:	e0bff517 	ldw	r2,-44(fp)
8110c000:	10c4b03a 	or	r2,r2,r3
8110c004:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c008:	00c00044 	movi	r3,1
8110c00c:	00a00034 	movhi	r2,32768
8110c010:	10824c04 	addi	r2,r2,2352
8110c014:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c018:	010003c4 	movi	r4,15
8110c01c:	1136ed00 	call	81136ed0 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c020:	0007883a 	mov	r3,zero
8110c024:	00a00034 	movhi	r2,32768
8110c028:	10824c04 	addi	r2,r2,2352
8110c02c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c030:	010003c4 	movi	r4,15
8110c034:	1136ed00 	call	81136ed0 <usleep>
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110c038:	e0bff717 	ldw	r2,-36(fp)
8110c03c:	10800044 	addi	r2,r2,1
8110c040:	e0bff715 	stw	r2,-36(fp)
8110c044:	e0bff717 	ldw	r2,-36(fp)
8110c048:	10800090 	cmplti	r2,r2,2
8110c04c:	103fd91e 	bne	r2,zero,8110bfb4 <__reset+0xfb0ebfb4>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110c050:	e03ff715 	stw	zero,-36(fp)
8110c054:	00002406 	br	8110c0e8 <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
8110c058:	e0bff403 	ldbu	r2,-48(fp)
8110c05c:	10803fcc 	andi	r2,r2,255
8110c060:	1004d1fa 	srli	r2,r2,7
8110c064:	10c03fcc 	andi	r3,r2,255
8110c068:	00a00034 	movhi	r2,32768
8110c06c:	10825004 	addi	r2,r2,2368
8110c070:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110c074:	e0bff403 	ldbu	r2,-48(fp)
8110c078:	1085883a 	add	r2,r2,r2
8110c07c:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
8110c080:	e0bff517 	ldw	r2,-44(fp)
8110c084:	1085883a 	add	r2,r2,r2
8110c088:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
8110c08c:	00a00034 	movhi	r2,32768
8110c090:	10825404 	addi	r2,r2,2384
8110c094:	10800037 	ldwio	r2,0(r2)
8110c098:	1080004c 	andi	r2,r2,1
8110c09c:	1007883a 	mov	r3,r2
8110c0a0:	e0bff517 	ldw	r2,-44(fp)
8110c0a4:	10c4b03a 	or	r2,r2,r3
8110c0a8:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c0ac:	00c00044 	movi	r3,1
8110c0b0:	00a00034 	movhi	r2,32768
8110c0b4:	10824c04 	addi	r2,r2,2352
8110c0b8:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c0bc:	010003c4 	movi	r4,15
8110c0c0:	1136ed00 	call	81136ed0 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c0c4:	0007883a 	mov	r3,zero
8110c0c8:	00a00034 	movhi	r2,32768
8110c0cc:	10824c04 	addi	r2,r2,2352
8110c0d0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c0d4:	010003c4 	movi	r4,15
8110c0d8:	1136ed00 	call	81136ed0 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110c0dc:	e0bff717 	ldw	r2,-36(fp)
8110c0e0:	10800044 	addi	r2,r2,1
8110c0e4:	e0bff715 	stw	r2,-36(fp)
8110c0e8:	e0bff717 	ldw	r2,-36(fp)
8110c0ec:	10800210 	cmplti	r2,r2,8
8110c0f0:	103fd91e 	bne	r2,zero,8110c058 <__reset+0xfb0ec058>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110c0f4:	e03ff715 	stw	zero,-36(fp)
8110c0f8:	00001a06 	br	8110c164 <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
8110c0fc:	e0bff517 	ldw	r2,-44(fp)
8110c100:	1085883a 	add	r2,r2,r2
8110c104:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
8110c108:	00a00034 	movhi	r2,32768
8110c10c:	10825404 	addi	r2,r2,2384
8110c110:	10800037 	ldwio	r2,0(r2)
8110c114:	1080004c 	andi	r2,r2,1
8110c118:	1007883a 	mov	r3,r2
8110c11c:	e0bff517 	ldw	r2,-44(fp)
8110c120:	10c4b03a 	or	r2,r2,r3
8110c124:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c128:	00c00044 	movi	r3,1
8110c12c:	00a00034 	movhi	r2,32768
8110c130:	10824c04 	addi	r2,r2,2352
8110c134:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c138:	010003c4 	movi	r4,15
8110c13c:	1136ed00 	call	81136ed0 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c140:	0007883a 	mov	r3,zero
8110c144:	00a00034 	movhi	r2,32768
8110c148:	10824c04 	addi	r2,r2,2352
8110c14c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c150:	010003c4 	movi	r4,15
8110c154:	1136ed00 	call	81136ed0 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110c158:	e0bff717 	ldw	r2,-36(fp)
8110c15c:	10800044 	addi	r2,r2,1
8110c160:	e0bff715 	stw	r2,-36(fp)
8110c164:	e0bff717 	ldw	r2,-36(fp)
8110c168:	10800210 	cmplti	r2,r2,8
8110c16c:	103fe31e 	bne	r2,zero,8110c0fc <__reset+0xfb0ec0fc>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110c170:	e03ff715 	stw	zero,-36(fp)
8110c174:	00001a06 	br	8110c1e0 <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8110c178:	e0bff517 	ldw	r2,-44(fp)
8110c17c:	1085883a 	add	r2,r2,r2
8110c180:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
8110c184:	00a00034 	movhi	r2,32768
8110c188:	10825404 	addi	r2,r2,2384
8110c18c:	10800037 	ldwio	r2,0(r2)
8110c190:	1080004c 	andi	r2,r2,1
8110c194:	1007883a 	mov	r3,r2
8110c198:	e0bff517 	ldw	r2,-44(fp)
8110c19c:	10c4b03a 	or	r2,r2,r3
8110c1a0:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c1a4:	00c00044 	movi	r3,1
8110c1a8:	00a00034 	movhi	r2,32768
8110c1ac:	10824c04 	addi	r2,r2,2352
8110c1b0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c1b4:	010003c4 	movi	r4,15
8110c1b8:	1136ed00 	call	81136ed0 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c1bc:	0007883a 	mov	r3,zero
8110c1c0:	00a00034 	movhi	r2,32768
8110c1c4:	10824c04 	addi	r2,r2,2352
8110c1c8:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c1cc:	010003c4 	movi	r4,15
8110c1d0:	1136ed00 	call	81136ed0 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110c1d4:	e0bff717 	ldw	r2,-36(fp)
8110c1d8:	10800044 	addi	r2,r2,1
8110c1dc:	e0bff715 	stw	r2,-36(fp)
8110c1e0:	e0bff717 	ldw	r2,-36(fp)
8110c1e4:	10800210 	cmplti	r2,r2,8
8110c1e8:	103fe31e 	bne	r2,zero,8110c178 <__reset+0xfb0ec178>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110c1ec:	e03ff715 	stw	zero,-36(fp)
8110c1f0:	00001a06 	br	8110c25c <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110c1f4:	e0bff517 	ldw	r2,-44(fp)
8110c1f8:	1085883a 	add	r2,r2,r2
8110c1fc:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110c200:	00a00034 	movhi	r2,32768
8110c204:	10825404 	addi	r2,r2,2384
8110c208:	10800037 	ldwio	r2,0(r2)
8110c20c:	1080004c 	andi	r2,r2,1
8110c210:	1007883a 	mov	r3,r2
8110c214:	e0bff517 	ldw	r2,-44(fp)
8110c218:	10c4b03a 	or	r2,r2,r3
8110c21c:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110c220:	00c00044 	movi	r3,1
8110c224:	00a00034 	movhi	r2,32768
8110c228:	10824c04 	addi	r2,r2,2352
8110c22c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c230:	010003c4 	movi	r4,15
8110c234:	1136ed00 	call	81136ed0 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110c238:	0007883a 	mov	r3,zero
8110c23c:	00a00034 	movhi	r2,32768
8110c240:	10824c04 	addi	r2,r2,2352
8110c244:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110c248:	010003c4 	movi	r4,15
8110c24c:	1136ed00 	call	81136ed0 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110c250:	e0bff717 	ldw	r2,-36(fp)
8110c254:	10800044 	addi	r2,r2,1
8110c258:	e0bff715 	stw	r2,-36(fp)
8110c25c:	e0bff717 	ldw	r2,-36(fp)
8110c260:	10800190 	cmplti	r2,r2,6
8110c264:	103fe31e 	bne	r2,zero,8110c1f4 <__reset+0xfb0ec1f4>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8110c268:	00c00044 	movi	r3,1
8110c26c:	00a00034 	movhi	r2,32768
8110c270:	10824c04 	addi	r2,r2,2352
8110c274:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110c278:	010003c4 	movi	r4,15
8110c27c:	1136ed00 	call	81136ed0 <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110c280:	00c000c4 	movi	r3,3
8110c284:	00a00034 	movhi	r2,32768
8110c288:	10824804 	addi	r2,r2,2336
8110c28c:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
8110c290:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
8110c294:	00800044 	movi	r2,1
8110c298:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8110c29c:	e03ff715 	stw	zero,-36(fp)
8110c2a0:	00000d06 	br	8110c2d8 <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
8110c2a4:	e0fff517 	ldw	r3,-44(fp)
8110c2a8:	e0bff617 	ldw	r2,-40(fp)
8110c2ac:	1884703a 	and	r2,r3,r2
8110c2b0:	1000031e 	bne	r2,zero,8110c2c0 <POWER_SPI_RW+0x47c>
			nZeroCnt++;
8110c2b4:	e0bff917 	ldw	r2,-28(fp)
8110c2b8:	10800044 	addi	r2,r2,1
8110c2bc:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
8110c2c0:	e0bff617 	ldw	r2,-40(fp)
8110c2c4:	1085883a 	add	r2,r2,r2
8110c2c8:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8110c2cc:	e0bff717 	ldw	r2,-36(fp)
8110c2d0:	10800044 	addi	r2,r2,1
8110c2d4:	e0bff715 	stw	r2,-36(fp)
8110c2d8:	e0bff717 	ldw	r2,-36(fp)
8110c2dc:	10800810 	cmplti	r2,r2,32
8110c2e0:	103ff01e 	bne	r2,zero,8110c2a4 <__reset+0xfb0ec2a4>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
8110c2e4:	e0bff917 	ldw	r2,-28(fp)
8110c2e8:	1080004c 	andi	r2,r2,1
8110c2ec:	1005003a 	cmpeq	r2,r2,zero
8110c2f0:	10803fcc 	andi	r2,r2,255
8110c2f4:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8110c2f8:	e0bffb17 	ldw	r2,-20(fp)
8110c2fc:	1000021e 	bne	r2,zero,8110c308 <POWER_SPI_RW+0x4c4>
#ifdef DEBUG_ON
//		debug(fp, "Parity Check Error \r\n");
#endif
		return FALSE;
8110c300:	0005883a 	mov	r2,zero
8110c304:	00000406 	br	8110c318 <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8110c308:	e0800317 	ldw	r2,12(fp)
8110c30c:	e0fff517 	ldw	r3,-44(fp)
8110c310:	10c00015 	stw	r3,0(r2)

	return bSuccess;
8110c314:	e0bffb17 	ldw	r2,-20(fp)
}
8110c318:	e037883a 	mov	sp,fp
8110c31c:	dfc00117 	ldw	ra,4(sp)
8110c320:	df000017 	ldw	fp,0(sp)
8110c324:	dec00204 	addi	sp,sp,8
8110c328:	f800283a 	ret

8110c32c <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
8110c32c:	defffc04 	addi	sp,sp,-16
8110c330:	de00012e 	bgeu	sp,et,8110c338 <vRstcSimucamReset+0xc>
8110c334:	003b68fa 	trap	3
8110c338:	dfc00315 	stw	ra,12(sp)
8110c33c:	df000215 	stw	fp,8(sp)
8110c340:	df000204 	addi	fp,sp,8
8110c344:	2005883a 	mov	r2,r4
8110c348:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8110c34c:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
8110c350:	e0bfff0b 	ldhu	r2,-4(fp)
8110c354:	e0fffe17 	ldw	r3,-8(fp)
8110c358:	1884b03a 	or	r2,r3,r2
8110c35c:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
8110c360:	e0bffe17 	ldw	r2,-8(fp)
8110c364:	10800074 	orhi	r2,r2,1
8110c368:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c36c:	e1bffe17 	ldw	r6,-8(fp)
8110c370:	000b883a 	mov	r5,zero
8110c374:	01200034 	movhi	r4,32768
8110c378:	21020004 	addi	r4,r4,2048
8110c37c:	110c47c0 	call	8110c47c <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
8110c380:	0001883a 	nop
8110c384:	e037883a 	mov	sp,fp
8110c388:	dfc00117 	ldw	ra,4(sp)
8110c38c:	df000017 	ldw	fp,0(sp)
8110c390:	dec00204 	addi	sp,sp,8
8110c394:	f800283a 	ret

8110c398 <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110c398:	defffc04 	addi	sp,sp,-16
8110c39c:	de00012e 	bgeu	sp,et,8110c3a4 <vRstcReleaseDeviceReset+0xc>
8110c3a0:	003b68fa 	trap	3
8110c3a4:	dfc00315 	stw	ra,12(sp)
8110c3a8:	df000215 	stw	fp,8(sp)
8110c3ac:	df000204 	addi	fp,sp,8
8110c3b0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110c3b4:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c3b8:	01400044 	movi	r5,1
8110c3bc:	01200034 	movhi	r4,32768
8110c3c0:	21020004 	addi	r4,r4,2048
8110c3c4:	110c4d00 	call	8110c4d0 <uliRstReadReg>
8110c3c8:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8110c3cc:	e0bfff17 	ldw	r2,-4(fp)
8110c3d0:	0084303a 	nor	r2,zero,r2
8110c3d4:	e0fffe17 	ldw	r3,-8(fp)
8110c3d8:	1884703a 	and	r2,r3,r2
8110c3dc:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c3e0:	e1bffe17 	ldw	r6,-8(fp)
8110c3e4:	01400044 	movi	r5,1
8110c3e8:	01200034 	movhi	r4,32768
8110c3ec:	21020004 	addi	r4,r4,2048
8110c3f0:	110c47c0 	call	8110c47c <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110c3f4:	0001883a 	nop
8110c3f8:	e037883a 	mov	sp,fp
8110c3fc:	dfc00117 	ldw	ra,4(sp)
8110c400:	df000017 	ldw	fp,0(sp)
8110c404:	dec00204 	addi	sp,sp,8
8110c408:	f800283a 	ret

8110c40c <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
8110c40c:	defffc04 	addi	sp,sp,-16
8110c410:	de00012e 	bgeu	sp,et,8110c418 <vRstcHoldDeviceReset+0xc>
8110c414:	003b68fa 	trap	3
8110c418:	dfc00315 	stw	ra,12(sp)
8110c41c:	df000215 	stw	fp,8(sp)
8110c420:	df000204 	addi	fp,sp,8
8110c424:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110c428:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c42c:	01400044 	movi	r5,1
8110c430:	01200034 	movhi	r4,32768
8110c434:	21020004 	addi	r4,r4,2048
8110c438:	110c4d00 	call	8110c4d0 <uliRstReadReg>
8110c43c:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
8110c440:	e0fffe17 	ldw	r3,-8(fp)
8110c444:	e0bfff17 	ldw	r2,-4(fp)
8110c448:	1884b03a 	or	r2,r3,r2
8110c44c:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110c450:	e1bffe17 	ldw	r6,-8(fp)
8110c454:	01400044 	movi	r5,1
8110c458:	01200034 	movhi	r4,32768
8110c45c:	21020004 	addi	r4,r4,2048
8110c460:	110c47c0 	call	8110c47c <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110c464:	0001883a 	nop
8110c468:	e037883a 	mov	sp,fp
8110c46c:	dfc00117 	ldw	ra,4(sp)
8110c470:	df000017 	ldw	fp,0(sp)
8110c474:	dec00204 	addi	sp,sp,8
8110c478:	f800283a 	ret

8110c47c <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110c47c:	defffc04 	addi	sp,sp,-16
8110c480:	de00012e 	bgeu	sp,et,8110c488 <vRstcWriteReg+0xc>
8110c484:	003b68fa 	trap	3
8110c488:	df000315 	stw	fp,12(sp)
8110c48c:	df000304 	addi	fp,sp,12
8110c490:	e13ffd15 	stw	r4,-12(fp)
8110c494:	e17ffe15 	stw	r5,-8(fp)
8110c498:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110c49c:	e0bffe17 	ldw	r2,-8(fp)
8110c4a0:	1085883a 	add	r2,r2,r2
8110c4a4:	1085883a 	add	r2,r2,r2
8110c4a8:	1007883a 	mov	r3,r2
8110c4ac:	e0bffd17 	ldw	r2,-12(fp)
8110c4b0:	10c5883a 	add	r2,r2,r3
8110c4b4:	e0ffff17 	ldw	r3,-4(fp)
8110c4b8:	10c00015 	stw	r3,0(r2)
}
8110c4bc:	0001883a 	nop
8110c4c0:	e037883a 	mov	sp,fp
8110c4c4:	df000017 	ldw	fp,0(sp)
8110c4c8:	dec00104 	addi	sp,sp,4
8110c4cc:	f800283a 	ret

8110c4d0 <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110c4d0:	defffc04 	addi	sp,sp,-16
8110c4d4:	de00012e 	bgeu	sp,et,8110c4dc <uliRstReadReg+0xc>
8110c4d8:	003b68fa 	trap	3
8110c4dc:	df000315 	stw	fp,12(sp)
8110c4e0:	df000304 	addi	fp,sp,12
8110c4e4:	e13ffe15 	stw	r4,-8(fp)
8110c4e8:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110c4ec:	e0bfff17 	ldw	r2,-4(fp)
8110c4f0:	1085883a 	add	r2,r2,r2
8110c4f4:	1085883a 	add	r2,r2,r2
8110c4f8:	1007883a 	mov	r3,r2
8110c4fc:	e0bffe17 	ldw	r2,-8(fp)
8110c500:	10c5883a 	add	r2,r2,r3
8110c504:	10800017 	ldw	r2,0(r2)
8110c508:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110c50c:	e0bffd17 	ldw	r2,-12(fp)
}
8110c510:	e037883a 	mov	sp,fp
8110c514:	df000017 	ldw	fp,0(sp)
8110c518:	dec00104 	addi	sp,sp,4
8110c51c:	f800283a 	ret

8110c520 <v_spi_start>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
8110c520:	defffe04 	addi	sp,sp,-8
8110c524:	de00012e 	bgeu	sp,et,8110c52c <v_spi_start+0xc>
8110c528:	003b68fa 	trap	3
8110c52c:	dfc00115 	stw	ra,4(sp)
8110c530:	df000015 	stw	fp,0(sp)
8110c534:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8110c538:	0007883a 	mov	r3,zero
8110c53c:	00a00034 	movhi	r2,32768
8110c540:	10823004 	addi	r2,r2,2240
8110c544:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8110c548:	0007883a 	mov	r3,zero
8110c54c:	00a00034 	movhi	r2,32768
8110c550:	10822c04 	addi	r2,r2,2224
8110c554:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110c558:	01002584 	movi	r4,150
8110c55c:	1136ed00 	call	81136ed0 <usleep>
}
8110c560:	0001883a 	nop
8110c564:	e037883a 	mov	sp,fp
8110c568:	dfc00117 	ldw	ra,4(sp)
8110c56c:	df000017 	ldw	fp,0(sp)
8110c570:	dec00204 	addi	sp,sp,8
8110c574:	f800283a 	ret

8110c578 <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8110c578:	defffc04 	addi	sp,sp,-16
8110c57c:	de00012e 	bgeu	sp,et,8110c584 <v_spi_send_byte+0xc>
8110c580:	003b68fa 	trap	3
8110c584:	dfc00315 	stw	ra,12(sp)
8110c588:	df000215 	stw	fp,8(sp)
8110c58c:	df000204 	addi	fp,sp,8
8110c590:	2005883a 	mov	r2,r4
8110c594:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110c598:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8110c59c:	00bfe004 	movi	r2,-128
8110c5a0:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
8110c5a4:	e03ffe05 	stb	zero,-8(fp)
8110c5a8:	00001b06 	br	8110c618 <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8110c5ac:	e0ffff03 	ldbu	r3,-4(fp)
8110c5b0:	e0bffe43 	ldbu	r2,-7(fp)
8110c5b4:	1884703a 	and	r2,r3,r2
8110c5b8:	10803fcc 	andi	r2,r2,255
8110c5bc:	1004c03a 	cmpne	r2,r2,zero
8110c5c0:	10c03fcc 	andi	r3,r2,255
8110c5c4:	00a00034 	movhi	r2,32768
8110c5c8:	10823404 	addi	r2,r2,2256
8110c5cc:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
8110c5d0:	e0bffe43 	ldbu	r2,-7(fp)
8110c5d4:	1004d07a 	srli	r2,r2,1
8110c5d8:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
8110c5dc:	00c00044 	movi	r3,1
8110c5e0:	00a00034 	movhi	r2,32768
8110c5e4:	10823004 	addi	r2,r2,2240
8110c5e8:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c5ec:	01002584 	movi	r4,150
8110c5f0:	1136ed00 	call	81136ed0 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110c5f4:	0007883a 	mov	r3,zero
8110c5f8:	00a00034 	movhi	r2,32768
8110c5fc:	10823004 	addi	r2,r2,2240
8110c600:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c604:	01002584 	movi	r4,150
8110c608:	1136ed00 	call	81136ed0 <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
8110c60c:	e0bffe03 	ldbu	r2,-8(fp)
8110c610:	10800044 	addi	r2,r2,1
8110c614:	e0bffe05 	stb	r2,-8(fp)
8110c618:	e0bffe03 	ldbu	r2,-8(fp)
8110c61c:	10800230 	cmpltui	r2,r2,8
8110c620:	103fe21e 	bne	r2,zero,8110c5ac <__reset+0xfb0ec5ac>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
8110c624:	0001883a 	nop
8110c628:	e037883a 	mov	sp,fp
8110c62c:	dfc00117 	ldw	ra,4(sp)
8110c630:	df000017 	ldw	fp,0(sp)
8110c634:	dec00204 	addi	sp,sp,8
8110c638:	f800283a 	ret

8110c63c <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8110c63c:	defffd04 	addi	sp,sp,-12
8110c640:	de00012e 	bgeu	sp,et,8110c648 <uc_spi_get_byte+0xc>
8110c644:	003b68fa 	trap	3
8110c648:	dfc00215 	stw	ra,8(sp)
8110c64c:	df000115 	stw	fp,4(sp)
8110c650:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
8110c654:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8110c658:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8110c65c:	e03fff05 	stb	zero,-4(fp)
8110c660:	00001a06 	br	8110c6cc <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
8110c664:	e0bfff43 	ldbu	r2,-3(fp)
8110c668:	1085883a 	add	r2,r2,r2
8110c66c:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
8110c670:	00a00034 	movhi	r2,32768
8110c674:	10823804 	addi	r2,r2,2272
8110c678:	10800037 	ldwio	r2,0(r2)
8110c67c:	1080004c 	andi	r2,r2,1
8110c680:	1007883a 	mov	r3,r2
8110c684:	e0bfff43 	ldbu	r2,-3(fp)
8110c688:	1884b03a 	or	r2,r3,r2
8110c68c:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
8110c690:	00c00044 	movi	r3,1
8110c694:	00a00034 	movhi	r2,32768
8110c698:	10823004 	addi	r2,r2,2240
8110c69c:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c6a0:	01002584 	movi	r4,150
8110c6a4:	1136ed00 	call	81136ed0 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110c6a8:	0007883a 	mov	r3,zero
8110c6ac:	00a00034 	movhi	r2,32768
8110c6b0:	10823004 	addi	r2,r2,2240
8110c6b4:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c6b8:	01002584 	movi	r4,150
8110c6bc:	1136ed00 	call	81136ed0 <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
8110c6c0:	e0bfff03 	ldbu	r2,-4(fp)
8110c6c4:	10800044 	addi	r2,r2,1
8110c6c8:	e0bfff05 	stb	r2,-4(fp)
8110c6cc:	e0bfff03 	ldbu	r2,-4(fp)
8110c6d0:	10800230 	cmpltui	r2,r2,8
8110c6d4:	103fe31e 	bne	r2,zero,8110c664 <__reset+0xfb0ec664>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8110c6d8:	e0bfff43 	ldbu	r2,-3(fp)
}
8110c6dc:	e037883a 	mov	sp,fp
8110c6e0:	dfc00117 	ldw	ra,4(sp)
8110c6e4:	df000017 	ldw	fp,0(sp)
8110c6e8:	dec00204 	addi	sp,sp,8
8110c6ec:	f800283a 	ret

8110c6f0 <v_spi_end>:

void v_spi_end(void){
8110c6f0:	defffe04 	addi	sp,sp,-8
8110c6f4:	de00012e 	bgeu	sp,et,8110c6fc <v_spi_end+0xc>
8110c6f8:	003b68fa 	trap	3
8110c6fc:	dfc00115 	stw	ra,4(sp)
8110c700:	df000015 	stw	fp,0(sp)
8110c704:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8110c708:	0007883a 	mov	r3,zero
8110c70c:	00a00034 	movhi	r2,32768
8110c710:	10823004 	addi	r2,r2,2240
8110c714:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110c718:	01002584 	movi	r4,150
8110c71c:	1136ed00 	call	81136ed0 <usleep>
    SPI_CS_N(1);
8110c720:	00c00044 	movi	r3,1
8110c724:	00a00034 	movhi	r2,32768
8110c728:	10822c04 	addi	r2,r2,2224
8110c72c:	10c00035 	stwio	r3,0(r2)
}
8110c730:	0001883a 	nop
8110c734:	e037883a 	mov	sp,fp
8110c738:	dfc00117 	ldw	ra,4(sp)
8110c73c:	df000017 	ldw	fp,0(sp)
8110c740:	dec00204 	addi	sp,sp,8
8110c744:	f800283a 	ret

8110c748 <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8110c748:	defff604 	addi	sp,sp,-40
8110c74c:	de00012e 	bgeu	sp,et,8110c754 <RTCC_SPI_R_MAC+0xc>
8110c750:	003b68fa 	trap	3
8110c754:	dfc00915 	stw	ra,36(sp)
8110c758:	df000815 	stw	fp,32(sp)
8110c75c:	df000804 	addi	fp,sp,32
8110c760:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110c764:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8110c768:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8110c76c:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
8110c770:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
8110c774:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8110c778:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8110c77c:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
8110c780:	00800084 	movi	r2,2
8110c784:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110c788:	00800cc4 	movi	r2,51
8110c78c:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
8110c790:	110c5200 	call	8110c520 <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
8110c794:	e0bffec3 	ldbu	r2,-5(fp)
8110c798:	1009883a 	mov	r4,r2
8110c79c:	110c5780 	call	8110c578 <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
8110c7a0:	e0bffe83 	ldbu	r2,-6(fp)
8110c7a4:	1009883a 	mov	r4,r2
8110c7a8:	110c5780 	call	8110c578 <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8110c7ac:	110c63c0 	call	8110c63c <uc_spi_get_byte>
8110c7b0:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
8110c7b4:	110c63c0 	call	8110c63c <uc_spi_get_byte>
8110c7b8:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8110c7bc:	110c63c0 	call	8110c63c <uc_spi_get_byte>
8110c7c0:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
8110c7c4:	110c63c0 	call	8110c63c <uc_spi_get_byte>
8110c7c8:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8110c7cc:	110c63c0 	call	8110c63c <uc_spi_get_byte>
8110c7d0:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
8110c7d4:	110c63c0 	call	8110c63c <uc_spi_get_byte>
8110c7d8:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
8110c7dc:	110c6f00 	call	8110c6f0 <v_spi_end>

    bSuccess = TRUE;
8110c7e0:	00800044 	movi	r2,1
8110c7e4:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8110c7e8:	e0bfff17 	ldw	r2,-4(fp)
8110c7ec:	e0fffd03 	ldbu	r3,-12(fp)
8110c7f0:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
8110c7f4:	e0bfff17 	ldw	r2,-4(fp)
8110c7f8:	10800044 	addi	r2,r2,1
8110c7fc:	e0fffd43 	ldbu	r3,-11(fp)
8110c800:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
8110c804:	e0bfff17 	ldw	r2,-4(fp)
8110c808:	10800084 	addi	r2,r2,2
8110c80c:	e0fffd83 	ldbu	r3,-10(fp)
8110c810:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
8110c814:	e0bfff17 	ldw	r2,-4(fp)
8110c818:	108000c4 	addi	r2,r2,3
8110c81c:	e0fffdc3 	ldbu	r3,-9(fp)
8110c820:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
8110c824:	e0bfff17 	ldw	r2,-4(fp)
8110c828:	10800104 	addi	r2,r2,4
8110c82c:	e0fffe03 	ldbu	r3,-8(fp)
8110c830:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
8110c834:	e0bfff17 	ldw	r2,-4(fp)
8110c838:	10800144 	addi	r2,r2,5
8110c83c:	e0fffe43 	ldbu	r3,-7(fp)
8110c840:	10c00005 	stb	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
8110c844:	e1bffd03 	ldbu	r6,-12(fp)
8110c848:	e1fffd43 	ldbu	r7,-11(fp)
8110c84c:	e0bffd83 	ldbu	r2,-10(fp)
8110c850:	e0fffdc3 	ldbu	r3,-9(fp)
8110c854:	e13ffe03 	ldbu	r4,-8(fp)
8110c858:	e17ffe43 	ldbu	r5,-7(fp)
8110c85c:	d9400315 	stw	r5,12(sp)
8110c860:	d9000215 	stw	r4,8(sp)
8110c864:	d8c00115 	stw	r3,4(sp)
8110c868:	d8800015 	stw	r2,0(sp)
8110c86c:	01604574 	movhi	r5,33045
8110c870:	296de004 	addi	r5,r5,-18560
8110c874:	01204574 	movhi	r4,33045
8110c878:	21097504 	addi	r4,r4,9684
8110c87c:	11221480 	call	81122148 <sprintf>
	debug(fp, cDebugBuffer);
8110c880:	d0a06117 	ldw	r2,-32380(gp)
8110c884:	01604574 	movhi	r5,33045
8110c888:	29497504 	addi	r5,r5,9684
8110c88c:	1009883a 	mov	r4,r2
8110c890:	11207b80 	call	811207b8 <fprintf>
#endif

    return bSuccess;
8110c894:	e0bffc17 	ldw	r2,-16(fp)
}
8110c898:	e037883a 	mov	sp,fp
8110c89c:	dfc00117 	ldw	ra,4(sp)
8110c8a0:	df000017 	ldw	fp,0(sp)
8110c8a4:	dec00204 	addi	sp,sp,8
8110c8a8:	f800283a 	ret

8110c8ac <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8110c8ac:	defffd04 	addi	sp,sp,-12
8110c8b0:	de00012e 	bgeu	sp,et,8110c8b8 <bSSDisplayConfig+0xc>
8110c8b4:	003b68fa 	trap	3
8110c8b8:	df000215 	stw	fp,8(sp)
8110c8bc:	df000204 	addi	fp,sp,8
8110c8c0:	2005883a 	mov	r2,r4
8110c8c4:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8110c8c8:	e0bfff03 	ldbu	r2,-4(fp)
8110c8cc:	10c00168 	cmpgeui	r3,r2,5
8110c8d0:	18001c1e 	bne	r3,zero,8110c944 <bSSDisplayConfig+0x98>
8110c8d4:	100690ba 	slli	r3,r2,2
8110c8d8:	00a04474 	movhi	r2,33041
8110c8dc:	10b23b04 	addi	r2,r2,-14100
8110c8e0:	1885883a 	add	r2,r3,r2
8110c8e4:	10800017 	ldw	r2,0(r2)
8110c8e8:	1000683a 	jmp	r2
8110c8ec:	8110c900 	call	88110c90 <__reset+0x20f0c90>
8110c8f0:	8110c90c 	andi	r4,r16,17188
8110c8f4:	8110c918 	cmpnei	r4,r16,17188
8110c8f8:	8110c92c 	andhi	r4,r16,17188
8110c8fc:	8110c93c 	xorhi	r4,r16,17188
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
8110c900:	00800cc4 	movi	r2,51
8110c904:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c908:	00001006 	br	8110c94c <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
8110c90c:	00801544 	movi	r2,85
8110c910:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c914:	00000d06 	br	8110c94c <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110c918:	d0e05043 	ldbu	r3,-32447(gp)
8110c91c:	00bff744 	movi	r2,-35
8110c920:	1884703a 	and	r2,r3,r2
8110c924:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c928:	00000806 	br	8110c94c <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
8110c92c:	d0a05043 	ldbu	r2,-32447(gp)
8110c930:	10800894 	ori	r2,r2,34
8110c934:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c938:	00000406 	br	8110c94c <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8110c93c:	d0205045 	stb	zero,-32447(gp)
	    break;
8110c940:	00000206 	br	8110c94c <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
8110c944:	0005883a 	mov	r2,zero
8110c948:	00000806 	br	8110c96c <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110c94c:	00a00034 	movhi	r2,32768
8110c950:	10828404 	addi	r2,r2,2576
8110c954:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8110c958:	d0a05043 	ldbu	r2,-32447(gp)
8110c95c:	10c03fcc 	andi	r3,r2,255
8110c960:	e0bffe17 	ldw	r2,-8(fp)
8110c964:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110c968:	00800044 	movi	r2,1
}
8110c96c:	e037883a 	mov	sp,fp
8110c970:	df000017 	ldw	fp,0(sp)
8110c974:	dec00104 	addi	sp,sp,4
8110c978:	f800283a 	ret

8110c97c <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8110c97c:	defffd04 	addi	sp,sp,-12
8110c980:	de00012e 	bgeu	sp,et,8110c988 <bSSDisplayUpdate+0xc>
8110c984:	003b68fa 	trap	3
8110c988:	df000215 	stw	fp,8(sp)
8110c98c:	df000204 	addi	fp,sp,8
8110c990:	2005883a 	mov	r2,r4
8110c994:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110c998:	00a00034 	movhi	r2,32768
8110c99c:	10828404 	addi	r2,r2,2576
8110c9a0:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
8110c9a4:	e0bffe17 	ldw	r2,-8(fp)
8110c9a8:	10800104 	addi	r2,r2,4
8110c9ac:	e0ffff03 	ldbu	r3,-4(fp)
8110c9b0:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110c9b4:	00800044 	movi	r2,1
}
8110c9b8:	e037883a 	mov	sp,fp
8110c9bc:	df000017 	ldw	fp,0(sp)
8110c9c0:	dec00104 	addi	sp,sp,4
8110c9c4:	f800283a 	ret

8110c9c8 <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8110c9c8:	defff904 	addi	sp,sp,-28
8110c9cc:	de00012e 	bgeu	sp,et,8110c9d4 <vSyncHandleIrq+0xc>
8110c9d0:	003b68fa 	trap	3
8110c9d4:	dfc00615 	stw	ra,24(sp)
8110c9d8:	df000515 	stw	fp,20(sp)
8110c9dc:	df000504 	addi	fp,sp,20
8110c9e0:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	volatile int* pviHoldContext = (volatile int*) pvContext;
8110c9e4:	e0bfff17 	ldw	r2,-4(fp)
8110c9e8:	e0bffc15 	stw	r2,-16(fp)


	uiCmdtoSend.ulWord = 0;
8110c9ec:	e03ffe15 	stw	zero,-8(fp)
	/* MasterSync? */
	ucSyncL = (vucN % 4);
8110c9f0:	d0a05203 	ldbu	r2,-32440(gp)
8110c9f4:	108000cc 	andi	r2,r2,3
8110c9f8:	e0bffd05 	stb	r2,-12(fp)
	if ( ucSyncL == 0 )
8110c9fc:	e0bffd03 	ldbu	r2,-12(fp)
8110ca00:	1000031e 	bne	r2,zero,8110ca10 <vSyncHandleIrq+0x48>
		uiCmdtoSend.ucByte[2] = M_MASTER_SYNC;
8110ca04:	00bff804 	movi	r2,-32
8110ca08:	e0bffe85 	stb	r2,-6(fp)
8110ca0c:	00000206 	br	8110ca18 <vSyncHandleIrq+0x50>
	else
		uiCmdtoSend.ucByte[2] = M_SYNC;
8110ca10:	00bff844 	movi	r2,-31
8110ca14:	e0bffe85 	stb	r2,-6(fp)

	uiCmdtoSend.ucByte[3] = M_MEB_ADDR;
8110ca18:	00800044 	movi	r2,1
8110ca1c:	e0bffec5 	stb	r2,-5(fp)

	/* Send Priority message to the Meb Task to indicate the Master Sync */
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
8110ca20:	d0a06817 	ldw	r2,-32352(gp)
8110ca24:	e0fffe17 	ldw	r3,-8(fp)
8110ca28:	180b883a 	mov	r5,r3
8110ca2c:	1009883a 	mov	r4,r2
8110ca30:	113d3540 	call	8113d354 <OSQPostFront>
8110ca34:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110ca38:	e0bffd43 	ldbu	r2,-11(fp)
8110ca3c:	10000126 	beq	r2,zero,8110ca44 <vSyncHandleIrq+0x7c>
		vFailSendMsgMasterSyncMeb( );
8110ca40:	111c7f80 	call	8111c7f8 <vFailSendMsgMasterSyncMeb>
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110ca44:	e03ffb05 	stb	zero,-20(fp)
8110ca48:	00001606 	br	8110caa4 <vSyncHandleIrq+0xdc>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8110ca4c:	e0bffb03 	ldbu	r2,-20(fp)
8110ca50:	10800444 	addi	r2,r2,17
8110ca54:	e0bffec5 	stb	r2,-5(fp)
		error_codel = OSQPostFront(xFeeQ[ ucIL ], (void *)uiCmdtoSend.ulWord);
8110ca58:	e0bffb03 	ldbu	r2,-20(fp)
8110ca5c:	1085883a 	add	r2,r2,r2
8110ca60:	1087883a 	add	r3,r2,r2
8110ca64:	d0a06904 	addi	r2,gp,-32348
8110ca68:	1885883a 	add	r2,r3,r2
8110ca6c:	10800017 	ldw	r2,0(r2)
8110ca70:	e0fffe17 	ldw	r3,-8(fp)
8110ca74:	180b883a 	mov	r5,r3
8110ca78:	1009883a 	mov	r4,r2
8110ca7c:	113d3540 	call	8113d354 <OSQPostFront>
8110ca80:	e0bffd45 	stb	r2,-11(fp)
		if ( error_codel != OS_ERR_NONE ) {
8110ca84:	e0bffd43 	ldbu	r2,-11(fp)
8110ca88:	10000326 	beq	r2,zero,8110ca98 <vSyncHandleIrq+0xd0>
			vFailSendMsgSync( ucIL );
8110ca8c:	e0bffb03 	ldbu	r2,-20(fp)
8110ca90:	1009883a 	mov	r4,r2
8110ca94:	111c7500 	call	8111c750 <vFailSendMsgSync>
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
	if ( error_codel != OS_ERR_NONE ) {
		vFailSendMsgMasterSyncMeb( );
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110ca98:	e0bffb03 	ldbu	r2,-20(fp)
8110ca9c:	10800044 	addi	r2,r2,1
8110caa0:	e0bffb05 	stb	r2,-20(fp)
8110caa4:	e0bffb03 	ldbu	r2,-20(fp)
8110caa8:	103fe826 	beq	r2,zero,8110ca4c <__reset+0xfb0eca4c>
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}

	vucN += 1;
8110caac:	d0a05203 	ldbu	r2,-32440(gp)
8110cab0:	10800044 	addi	r2,r2,1
8110cab4:	d0a05205 	stb	r2,-32440(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"Sync %hu \n", ucSyncL);
8110cab8:	d0a06117 	ldw	r2,-32380(gp)
8110cabc:	e0fffd03 	ldbu	r3,-12(fp)
8110cac0:	180d883a 	mov	r6,r3
8110cac4:	01604574 	movhi	r5,33045
8110cac8:	296def04 	addi	r5,r5,-18500
8110cacc:	1009883a 	mov	r4,r2
8110cad0:	11207b80 	call	811207b8 <fprintf>
	#endif

	vSyncIrqFlagClrSync();
8110cad4:	110cb680 	call	8110cb68 <vSyncIrqFlagClrSync>
}
8110cad8:	0001883a 	nop
8110cadc:	e037883a 	mov	sp,fp
8110cae0:	dfc00117 	ldw	ra,4(sp)
8110cae4:	df000017 	ldw	fp,0(sp)
8110cae8:	dec00204 	addi	sp,sp,8
8110caec:	f800283a 	ret

8110caf0 <vSyncClearCounter>:

void vSyncClearCounter(void) {
8110caf0:	deffff04 	addi	sp,sp,-4
8110caf4:	de00012e 	bgeu	sp,et,8110cafc <vSyncClearCounter+0xc>
8110caf8:	003b68fa 	trap	3
8110cafc:	df000015 	stw	fp,0(sp)
8110cb00:	d839883a 	mov	fp,sp
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	vucN = 0;
8110cb04:	d0205205 	stb	zero,-32440(gp)
}
8110cb08:	0001883a 	nop
8110cb0c:	e037883a 	mov	sp,fp
8110cb10:	df000017 	ldw	fp,0(sp)
8110cb14:	dec00104 	addi	sp,sp,4
8110cb18:	f800283a 	ret

8110cb1c <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8110cb1c:	defffd04 	addi	sp,sp,-12
8110cb20:	de00012e 	bgeu	sp,et,8110cb28 <vSyncInitIrq+0xc>
8110cb24:	003b68fa 	trap	3
8110cb28:	dfc00215 	stw	ra,8(sp)
8110cb2c:	df000115 	stw	fp,4(sp)
8110cb30:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
8110cb34:	d0a05104 	addi	r2,gp,-32444
8110cb38:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8110cb3c:	01a04474 	movhi	r6,33041
8110cb40:	31b27204 	addi	r6,r6,-13880
8110cb44:	e17fff17 	ldw	r5,-4(fp)
8110cb48:	01000284 	movi	r4,10
8110cb4c:	11358000 	call	81135800 <alt_irq_register>
}
8110cb50:	0001883a 	nop
8110cb54:	e037883a 	mov	sp,fp
8110cb58:	dfc00117 	ldw	ra,4(sp)
8110cb5c:	df000017 	ldw	fp,0(sp)
8110cb60:	dec00204 	addi	sp,sp,8
8110cb64:	f800283a 	ret

8110cb68 <vSyncIrqFlagClrSync>:

void vSyncIrqFlagClrSync(void) {
8110cb68:	defffe04 	addi	sp,sp,-8
8110cb6c:	de00012e 	bgeu	sp,et,8110cb74 <vSyncIrqFlagClrSync+0xc>
8110cb70:	003b68fa 	trap	3
8110cb74:	dfc00115 	stw	ra,4(sp)
8110cb78:	df000015 	stw	fp,0(sp)
8110cb7c:	d839883a 	mov	fp,sp
	bSyncWriteReg(SYNC_IRQ_FG_CLR_REG_OFFSET, (alt_u32) SYNC_IRQ_FG_CLR_MSK);
8110cb80:	01400044 	movi	r5,1
8110cb84:	010002c4 	movi	r4,11
8110cb88:	110d9480 	call	8110d948 <bSyncWriteReg>
}
8110cb8c:	0001883a 	nop
8110cb90:	e037883a 	mov	sp,fp
8110cb94:	dfc00117 	ldw	ra,4(sp)
8110cb98:	df000017 	ldw	fp,0(sp)
8110cb9c:	dec00204 	addi	sp,sp,8
8110cba0:	f800283a 	ret

8110cba4 <bSyncIrqFlagSync>:

bool bSyncIrqFlagSync(void) {
8110cba4:	defffd04 	addi	sp,sp,-12
8110cba8:	de00012e 	bgeu	sp,et,8110cbb0 <bSyncIrqFlagSync+0xc>
8110cbac:	003b68fa 	trap	3
8110cbb0:	dfc00215 	stw	ra,8(sp)
8110cbb4:	df000115 	stw	fp,4(sp)
8110cbb8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliSyncReadReg(SYNC_IRQ_FG_REG_OFFSET) & SYNC_IRQ_FG_MSK) {
8110cbbc:	01000304 	movi	r4,12
8110cbc0:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110cbc4:	1080004c 	andi	r2,r2,1
8110cbc8:	10000326 	beq	r2,zero,8110cbd8 <bSyncIrqFlagSync+0x34>
		bFlag = TRUE;
8110cbcc:	00800044 	movi	r2,1
8110cbd0:	e0bfff15 	stw	r2,-4(fp)
8110cbd4:	00000106 	br	8110cbdc <bSyncIrqFlagSync+0x38>
	} else {
		bFlag = FALSE;
8110cbd8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110cbdc:	e0bfff17 	ldw	r2,-4(fp)
}
8110cbe0:	e037883a 	mov	sp,fp
8110cbe4:	dfc00117 	ldw	ra,4(sp)
8110cbe8:	df000017 	ldw	fp,0(sp)
8110cbec:	dec00204 	addi	sp,sp,8
8110cbf0:	f800283a 	ret

8110cbf4 <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
8110cbf4:	defffc04 	addi	sp,sp,-16
8110cbf8:	de00012e 	bgeu	sp,et,8110cc00 <bSyncStatusExtnIrq+0xc>
8110cbfc:	003b68fa 	trap	3
8110cc00:	dfc00315 	stw	ra,12(sp)
8110cc04:	df000215 	stw	fp,8(sp)
8110cc08:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cc0c:	0009883a 	mov	r4,zero
8110cc10:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110cc14:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8110cc18:	e0bfff17 	ldw	r2,-4(fp)
8110cc1c:	1000030e 	bge	r2,zero,8110cc2c <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
8110cc20:	00800044 	movi	r2,1
8110cc24:	e0bffe15 	stw	r2,-8(fp)
8110cc28:	00000106 	br	8110cc30 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8110cc2c:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110cc30:	e0bffe17 	ldw	r2,-8(fp)
}
8110cc34:	e037883a 	mov	sp,fp
8110cc38:	dfc00117 	ldw	ra,4(sp)
8110cc3c:	df000017 	ldw	fp,0(sp)
8110cc40:	dec00204 	addi	sp,sp,8
8110cc44:	f800283a 	ret

8110cc48 <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110cc48:	defffc04 	addi	sp,sp,-16
8110cc4c:	de00012e 	bgeu	sp,et,8110cc54 <ucSyncStatusState+0xc>
8110cc50:	003b68fa 	trap	3
8110cc54:	dfc00315 	stw	ra,12(sp)
8110cc58:	df000215 	stw	fp,8(sp)
8110cc5c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110cc60:	0009883a 	mov	r4,zero
8110cc64:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110cc68:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8110cc6c:	e0bffe17 	ldw	r2,-8(fp)
8110cc70:	10803fec 	andhi	r2,r2,255
8110cc74:	1004d43a 	srli	r2,r2,16
8110cc78:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110cc7c:	e0bfff03 	ldbu	r2,-4(fp)
}
8110cc80:	e037883a 	mov	sp,fp
8110cc84:	dfc00117 	ldw	ra,4(sp)
8110cc88:	df000017 	ldw	fp,0(sp)
8110cc8c:	dec00204 	addi	sp,sp,8
8110cc90:	f800283a 	ret

8110cc94 <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
8110cc94:	defffc04 	addi	sp,sp,-16
8110cc98:	de00012e 	bgeu	sp,et,8110cca0 <ucSyncStatusErrorCode+0xc>
8110cc9c:	003b68fa 	trap	3
8110cca0:	dfc00315 	stw	ra,12(sp)
8110cca4:	df000215 	stw	fp,8(sp)
8110cca8:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110ccac:	0009883a 	mov	r4,zero
8110ccb0:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110ccb4:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8110ccb8:	e0bffe17 	ldw	r2,-8(fp)
8110ccbc:	10bfc00c 	andi	r2,r2,65280
8110ccc0:	1004d23a 	srli	r2,r2,8
8110ccc4:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110ccc8:	e0bfff03 	ldbu	r2,-4(fp)
}
8110cccc:	e037883a 	mov	sp,fp
8110ccd0:	dfc00117 	ldw	ra,4(sp)
8110ccd4:	df000017 	ldw	fp,0(sp)
8110ccd8:	dec00204 	addi	sp,sp,8
8110ccdc:	f800283a 	ret

8110cce0 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
8110cce0:	defffc04 	addi	sp,sp,-16
8110cce4:	de00012e 	bgeu	sp,et,8110ccec <ucSyncStatusCycleNumber+0xc>
8110cce8:	003b68fa 	trap	3
8110ccec:	dfc00315 	stw	ra,12(sp)
8110ccf0:	df000215 	stw	fp,8(sp)
8110ccf4:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110ccf8:	0009883a 	mov	r4,zero
8110ccfc:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110cd00:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
8110cd04:	e0bffe17 	ldw	r2,-8(fp)
8110cd08:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110cd0c:	e0bfff03 	ldbu	r2,-4(fp)
}
8110cd10:	e037883a 	mov	sp,fp
8110cd14:	dfc00117 	ldw	ra,4(sp)
8110cd18:	df000017 	ldw	fp,0(sp)
8110cd1c:	dec00204 	addi	sp,sp,8
8110cd20:	f800283a 	ret

8110cd24 <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
8110cd24:	defffd04 	addi	sp,sp,-12
8110cd28:	de00012e 	bgeu	sp,et,8110cd30 <bSyncSetMbt+0xc>
8110cd2c:	003b68fa 	trap	3
8110cd30:	dfc00215 	stw	ra,8(sp)
8110cd34:	df000115 	stw	fp,4(sp)
8110cd38:	df000104 	addi	fp,sp,4
8110cd3c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
8110cd40:	e17fff17 	ldw	r5,-4(fp)
8110cd44:	01000104 	movi	r4,4
8110cd48:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110cd4c:	00800044 	movi	r2,1
}
8110cd50:	e037883a 	mov	sp,fp
8110cd54:	dfc00117 	ldw	ra,4(sp)
8110cd58:	df000017 	ldw	fp,0(sp)
8110cd5c:	dec00204 	addi	sp,sp,8
8110cd60:	f800283a 	ret

8110cd64 <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
8110cd64:	defffd04 	addi	sp,sp,-12
8110cd68:	de00012e 	bgeu	sp,et,8110cd70 <bSyncSetBt+0xc>
8110cd6c:	003b68fa 	trap	3
8110cd70:	dfc00215 	stw	ra,8(sp)
8110cd74:	df000115 	stw	fp,4(sp)
8110cd78:	df000104 	addi	fp,sp,4
8110cd7c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
8110cd80:	e17fff17 	ldw	r5,-4(fp)
8110cd84:	01000144 	movi	r4,5
8110cd88:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110cd8c:	00800044 	movi	r2,1
}
8110cd90:	e037883a 	mov	sp,fp
8110cd94:	dfc00117 	ldw	ra,4(sp)
8110cd98:	df000017 	ldw	fp,0(sp)
8110cd9c:	dec00204 	addi	sp,sp,8
8110cda0:	f800283a 	ret

8110cda4 <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
8110cda4:	defffd04 	addi	sp,sp,-12
8110cda8:	de00012e 	bgeu	sp,et,8110cdb0 <bSyncSetPer+0xc>
8110cdac:	003b68fa 	trap	3
8110cdb0:	dfc00215 	stw	ra,8(sp)
8110cdb4:	df000115 	stw	fp,4(sp)
8110cdb8:	df000104 	addi	fp,sp,4
8110cdbc:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
8110cdc0:	e17fff17 	ldw	r5,-4(fp)
8110cdc4:	01000184 	movi	r4,6
8110cdc8:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110cdcc:	00800044 	movi	r2,1
}
8110cdd0:	e037883a 	mov	sp,fp
8110cdd4:	dfc00117 	ldw	ra,4(sp)
8110cdd8:	df000017 	ldw	fp,0(sp)
8110cddc:	dec00204 	addi	sp,sp,8
8110cde0:	f800283a 	ret

8110cde4 <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
8110cde4:	defffd04 	addi	sp,sp,-12
8110cde8:	de00012e 	bgeu	sp,et,8110cdf0 <bSyncSetOst+0xc>
8110cdec:	003b68fa 	trap	3
8110cdf0:	dfc00215 	stw	ra,8(sp)
8110cdf4:	df000115 	stw	fp,4(sp)
8110cdf8:	df000104 	addi	fp,sp,4
8110cdfc:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
8110ce00:	e17fff17 	ldw	r5,-4(fp)
8110ce04:	010001c4 	movi	r4,7
8110ce08:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110ce0c:	00800044 	movi	r2,1
}
8110ce10:	e037883a 	mov	sp,fp
8110ce14:	dfc00117 	ldw	ra,4(sp)
8110ce18:	df000017 	ldw	fp,0(sp)
8110ce1c:	dec00204 	addi	sp,sp,8
8110ce20:	f800283a 	ret

8110ce24 <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
8110ce24:	defffc04 	addi	sp,sp,-16
8110ce28:	de00012e 	bgeu	sp,et,8110ce30 <bSyncSetPolarity+0xc>
8110ce2c:	003b68fa 	trap	3
8110ce30:	dfc00315 	stw	ra,12(sp)
8110ce34:	df000215 	stw	fp,8(sp)
8110ce38:	df000204 	addi	fp,sp,8
8110ce3c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110ce40:	01000204 	movi	r4,8
8110ce44:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110ce48:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110ce4c:	e0bfff17 	ldw	r2,-4(fp)
8110ce50:	1000051e 	bne	r2,zero,8110ce68 <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
8110ce54:	e0fffe17 	ldw	r3,-8(fp)
8110ce58:	00bfbfc4 	movi	r2,-257
8110ce5c:	1884703a 	and	r2,r3,r2
8110ce60:	e0bffe15 	stw	r2,-8(fp)
8110ce64:	00000306 	br	8110ce74 <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
8110ce68:	e0bffe17 	ldw	r2,-8(fp)
8110ce6c:	10804014 	ori	r2,r2,256
8110ce70:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110ce74:	e17ffe17 	ldw	r5,-8(fp)
8110ce78:	01000204 	movi	r4,8
8110ce7c:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110ce80:	00800044 	movi	r2,1
}
8110ce84:	e037883a 	mov	sp,fp
8110ce88:	dfc00117 	ldw	ra,4(sp)
8110ce8c:	df000017 	ldw	fp,0(sp)
8110ce90:	dec00204 	addi	sp,sp,8
8110ce94:	f800283a 	ret

8110ce98 <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
8110ce98:	defffc04 	addi	sp,sp,-16
8110ce9c:	de00012e 	bgeu	sp,et,8110cea4 <bSyncSetNCycles+0xc>
8110cea0:	003b68fa 	trap	3
8110cea4:	dfc00315 	stw	ra,12(sp)
8110cea8:	df000215 	stw	fp,8(sp)
8110ceac:	df000204 	addi	fp,sp,8
8110ceb0:	2005883a 	mov	r2,r4
8110ceb4:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110ceb8:	01000204 	movi	r4,8
8110cebc:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110cec0:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
8110cec4:	e0fffe17 	ldw	r3,-8(fp)
8110cec8:	00bfc004 	movi	r2,-256
8110cecc:	1884703a 	and	r2,r3,r2
8110ced0:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
8110ced4:	e0bfff03 	ldbu	r2,-4(fp)
8110ced8:	e0fffe17 	ldw	r3,-8(fp)
8110cedc:	1884b03a 	or	r2,r3,r2
8110cee0:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110cee4:	e17ffe17 	ldw	r5,-8(fp)
8110cee8:	01000204 	movi	r4,8
8110ceec:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110cef0:	00800044 	movi	r2,1
}
8110cef4:	e037883a 	mov	sp,fp
8110cef8:	dfc00117 	ldw	ra,4(sp)
8110cefc:	df000017 	ldw	fp,0(sp)
8110cf00:	dec00204 	addi	sp,sp,8
8110cf04:	f800283a 	ret

8110cf08 <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
8110cf08:	defffd04 	addi	sp,sp,-12
8110cf0c:	de00012e 	bgeu	sp,et,8110cf14 <uliSyncGetMbt+0xc>
8110cf10:	003b68fa 	trap	3
8110cf14:	dfc00215 	stw	ra,8(sp)
8110cf18:	df000115 	stw	fp,4(sp)
8110cf1c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
8110cf20:	01000104 	movi	r4,4
8110cf24:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110cf28:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cf2c:	e0bfff17 	ldw	r2,-4(fp)
}
8110cf30:	e037883a 	mov	sp,fp
8110cf34:	dfc00117 	ldw	ra,4(sp)
8110cf38:	df000017 	ldw	fp,0(sp)
8110cf3c:	dec00204 	addi	sp,sp,8
8110cf40:	f800283a 	ret

8110cf44 <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
8110cf44:	defffd04 	addi	sp,sp,-12
8110cf48:	de00012e 	bgeu	sp,et,8110cf50 <uliSyncGetBt+0xc>
8110cf4c:	003b68fa 	trap	3
8110cf50:	dfc00215 	stw	ra,8(sp)
8110cf54:	df000115 	stw	fp,4(sp)
8110cf58:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
8110cf5c:	01000144 	movi	r4,5
8110cf60:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110cf64:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cf68:	e0bfff17 	ldw	r2,-4(fp)
}
8110cf6c:	e037883a 	mov	sp,fp
8110cf70:	dfc00117 	ldw	ra,4(sp)
8110cf74:	df000017 	ldw	fp,0(sp)
8110cf78:	dec00204 	addi	sp,sp,8
8110cf7c:	f800283a 	ret

8110cf80 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
8110cf80:	defffd04 	addi	sp,sp,-12
8110cf84:	de00012e 	bgeu	sp,et,8110cf8c <uliSyncGetPer+0xc>
8110cf88:	003b68fa 	trap	3
8110cf8c:	dfc00215 	stw	ra,8(sp)
8110cf90:	df000115 	stw	fp,4(sp)
8110cf94:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
8110cf98:	01000184 	movi	r4,6
8110cf9c:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110cfa0:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cfa4:	e0bfff17 	ldw	r2,-4(fp)
}
8110cfa8:	e037883a 	mov	sp,fp
8110cfac:	dfc00117 	ldw	ra,4(sp)
8110cfb0:	df000017 	ldw	fp,0(sp)
8110cfb4:	dec00204 	addi	sp,sp,8
8110cfb8:	f800283a 	ret

8110cfbc <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
8110cfbc:	defffd04 	addi	sp,sp,-12
8110cfc0:	de00012e 	bgeu	sp,et,8110cfc8 <uliSyncGetOst+0xc>
8110cfc4:	003b68fa 	trap	3
8110cfc8:	dfc00215 	stw	ra,8(sp)
8110cfcc:	df000115 	stw	fp,4(sp)
8110cfd0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
8110cfd4:	010001c4 	movi	r4,7
8110cfd8:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110cfdc:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cfe0:	e0bfff17 	ldw	r2,-4(fp)
}
8110cfe4:	e037883a 	mov	sp,fp
8110cfe8:	dfc00117 	ldw	ra,4(sp)
8110cfec:	df000017 	ldw	fp,0(sp)
8110cff0:	dec00204 	addi	sp,sp,8
8110cff4:	f800283a 	ret

8110cff8 <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
8110cff8:	defffd04 	addi	sp,sp,-12
8110cffc:	de00012e 	bgeu	sp,et,8110d004 <uliSyncGetGeneral+0xc>
8110d000:	003b68fa 	trap	3
8110d004:	dfc00215 	stw	ra,8(sp)
8110d008:	df000115 	stw	fp,4(sp)
8110d00c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110d010:	01000204 	movi	r4,8
8110d014:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d018:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d01c:	e0bfff17 	ldw	r2,-4(fp)
}
8110d020:	e037883a 	mov	sp,fp
8110d024:	dfc00117 	ldw	ra,4(sp)
8110d028:	df000017 	ldw	fp,0(sp)
8110d02c:	dec00204 	addi	sp,sp,8
8110d030:	f800283a 	ret

8110d034 <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
8110d034:	defffd04 	addi	sp,sp,-12
8110d038:	de00012e 	bgeu	sp,et,8110d040 <bSyncErrInj+0xc>
8110d03c:	003b68fa 	trap	3
8110d040:	dfc00215 	stw	ra,8(sp)
8110d044:	df000115 	stw	fp,4(sp)
8110d048:	df000104 	addi	fp,sp,4
8110d04c:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
8110d050:	e17fff17 	ldw	r5,-4(fp)
8110d054:	01000244 	movi	r4,9
8110d058:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d05c:	00800044 	movi	r2,1
}
8110d060:	e037883a 	mov	sp,fp
8110d064:	dfc00117 	ldw	ra,4(sp)
8110d068:	df000017 	ldw	fp,0(sp)
8110d06c:	dec00204 	addi	sp,sp,8
8110d070:	f800283a 	ret

8110d074 <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
8110d074:	defffc04 	addi	sp,sp,-16
8110d078:	de00012e 	bgeu	sp,et,8110d080 <bSyncCtrExtnIrq+0xc>
8110d07c:	003b68fa 	trap	3
8110d080:	dfc00315 	stw	ra,12(sp)
8110d084:	df000215 	stw	fp,8(sp)
8110d088:	df000204 	addi	fp,sp,8
8110d08c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d090:	01000284 	movi	r4,10
8110d094:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d098:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d09c:	e0bfff17 	ldw	r2,-4(fp)
8110d0a0:	1000061e 	bne	r2,zero,8110d0bc <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
8110d0a4:	e0fffe17 	ldw	r3,-8(fp)
8110d0a8:	00a00034 	movhi	r2,32768
8110d0ac:	10bfffc4 	addi	r2,r2,-1
8110d0b0:	1884703a 	and	r2,r3,r2
8110d0b4:	e0bffe15 	stw	r2,-8(fp)
8110d0b8:	00000306 	br	8110d0c8 <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
8110d0bc:	e0bffe17 	ldw	r2,-8(fp)
8110d0c0:	10a00034 	orhi	r2,r2,32768
8110d0c4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d0c8:	e17ffe17 	ldw	r5,-8(fp)
8110d0cc:	01000284 	movi	r4,10
8110d0d0:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d0d4:	00800044 	movi	r2,1
}
8110d0d8:	e037883a 	mov	sp,fp
8110d0dc:	dfc00117 	ldw	ra,4(sp)
8110d0e0:	df000017 	ldw	fp,0(sp)
8110d0e4:	dec00204 	addi	sp,sp,8
8110d0e8:	f800283a 	ret

8110d0ec <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
8110d0ec:	defffd04 	addi	sp,sp,-12
8110d0f0:	de00012e 	bgeu	sp,et,8110d0f8 <bSyncCtrStart+0xc>
8110d0f4:	003b68fa 	trap	3
8110d0f8:	dfc00215 	stw	ra,8(sp)
8110d0fc:	df000115 	stw	fp,4(sp)
8110d100:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d104:	01000284 	movi	r4,10
8110d108:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d10c:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
8110d110:	e0bfff17 	ldw	r2,-4(fp)
8110d114:	10800234 	orhi	r2,r2,8
8110d118:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d11c:	e17fff17 	ldw	r5,-4(fp)
8110d120:	01000284 	movi	r4,10
8110d124:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d128:	00800044 	movi	r2,1
}
8110d12c:	e037883a 	mov	sp,fp
8110d130:	dfc00117 	ldw	ra,4(sp)
8110d134:	df000017 	ldw	fp,0(sp)
8110d138:	dec00204 	addi	sp,sp,8
8110d13c:	f800283a 	ret

8110d140 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
8110d140:	defffd04 	addi	sp,sp,-12
8110d144:	de00012e 	bgeu	sp,et,8110d14c <bSyncCtrReset+0xc>
8110d148:	003b68fa 	trap	3
8110d14c:	dfc00215 	stw	ra,8(sp)
8110d150:	df000115 	stw	fp,4(sp)
8110d154:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d158:	01000284 	movi	r4,10
8110d15c:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d160:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
8110d164:	e0bfff17 	ldw	r2,-4(fp)
8110d168:	10800134 	orhi	r2,r2,4
8110d16c:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d170:	e17fff17 	ldw	r5,-4(fp)
8110d174:	01000284 	movi	r4,10
8110d178:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d17c:	00800044 	movi	r2,1
}
8110d180:	e037883a 	mov	sp,fp
8110d184:	dfc00117 	ldw	ra,4(sp)
8110d188:	df000017 	ldw	fp,0(sp)
8110d18c:	dec00204 	addi	sp,sp,8
8110d190:	f800283a 	ret

8110d194 <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
8110d194:	defffd04 	addi	sp,sp,-12
8110d198:	de00012e 	bgeu	sp,et,8110d1a0 <bSyncCtrOneShot+0xc>
8110d19c:	003b68fa 	trap	3
8110d1a0:	dfc00215 	stw	ra,8(sp)
8110d1a4:	df000115 	stw	fp,4(sp)
8110d1a8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d1ac:	01000284 	movi	r4,10
8110d1b0:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d1b4:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
8110d1b8:	e0bfff17 	ldw	r2,-4(fp)
8110d1bc:	108000b4 	orhi	r2,r2,2
8110d1c0:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d1c4:	e17fff17 	ldw	r5,-4(fp)
8110d1c8:	01000284 	movi	r4,10
8110d1cc:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d1d0:	00800044 	movi	r2,1
}
8110d1d4:	e037883a 	mov	sp,fp
8110d1d8:	dfc00117 	ldw	ra,4(sp)
8110d1dc:	df000017 	ldw	fp,0(sp)
8110d1e0:	dec00204 	addi	sp,sp,8
8110d1e4:	f800283a 	ret

8110d1e8 <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
8110d1e8:	defffd04 	addi	sp,sp,-12
8110d1ec:	de00012e 	bgeu	sp,et,8110d1f4 <bSyncCtrErrInj+0xc>
8110d1f0:	003b68fa 	trap	3
8110d1f4:	dfc00215 	stw	ra,8(sp)
8110d1f8:	df000115 	stw	fp,4(sp)
8110d1fc:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d200:	01000284 	movi	r4,10
8110d204:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d208:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
8110d20c:	e0bfff17 	ldw	r2,-4(fp)
8110d210:	10800074 	orhi	r2,r2,1
8110d214:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d218:	e17fff17 	ldw	r5,-4(fp)
8110d21c:	01000284 	movi	r4,10
8110d220:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d224:	00800044 	movi	r2,1
}
8110d228:	e037883a 	mov	sp,fp
8110d22c:	dfc00117 	ldw	ra,4(sp)
8110d230:	df000017 	ldw	fp,0(sp)
8110d234:	dec00204 	addi	sp,sp,8
8110d238:	f800283a 	ret

8110d23c <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
8110d23c:	defffc04 	addi	sp,sp,-16
8110d240:	de00012e 	bgeu	sp,et,8110d248 <bSyncCtrSyncOutEnable+0xc>
8110d244:	003b68fa 	trap	3
8110d248:	dfc00315 	stw	ra,12(sp)
8110d24c:	df000215 	stw	fp,8(sp)
8110d250:	df000204 	addi	fp,sp,8
8110d254:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d258:	01000284 	movi	r4,10
8110d25c:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d260:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d264:	e0bfff17 	ldw	r2,-4(fp)
8110d268:	1000051e 	bne	r2,zero,8110d280 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
8110d26c:	e0fffe17 	ldw	r3,-8(fp)
8110d270:	00bfbfc4 	movi	r2,-257
8110d274:	1884703a 	and	r2,r3,r2
8110d278:	e0bffe15 	stw	r2,-8(fp)
8110d27c:	00000306 	br	8110d28c <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
8110d280:	e0bffe17 	ldw	r2,-8(fp)
8110d284:	10804014 	ori	r2,r2,256
8110d288:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d28c:	e17ffe17 	ldw	r5,-8(fp)
8110d290:	01000284 	movi	r4,10
8110d294:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d298:	00800044 	movi	r2,1
}
8110d29c:	e037883a 	mov	sp,fp
8110d2a0:	dfc00117 	ldw	ra,4(sp)
8110d2a4:	df000017 	ldw	fp,0(sp)
8110d2a8:	dec00204 	addi	sp,sp,8
8110d2ac:	f800283a 	ret

8110d2b0 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
8110d2b0:	defffc04 	addi	sp,sp,-16
8110d2b4:	de00012e 	bgeu	sp,et,8110d2bc <bSyncCtrCh1OutEnable+0xc>
8110d2b8:	003b68fa 	trap	3
8110d2bc:	dfc00315 	stw	ra,12(sp)
8110d2c0:	df000215 	stw	fp,8(sp)
8110d2c4:	df000204 	addi	fp,sp,8
8110d2c8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d2cc:	01000284 	movi	r4,10
8110d2d0:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d2d4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d2d8:	e0bfff17 	ldw	r2,-4(fp)
8110d2dc:	1000051e 	bne	r2,zero,8110d2f4 <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
8110d2e0:	e0fffe17 	ldw	r3,-8(fp)
8110d2e4:	00bfff84 	movi	r2,-2
8110d2e8:	1884703a 	and	r2,r3,r2
8110d2ec:	e0bffe15 	stw	r2,-8(fp)
8110d2f0:	00000306 	br	8110d300 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
8110d2f4:	e0bffe17 	ldw	r2,-8(fp)
8110d2f8:	10800054 	ori	r2,r2,1
8110d2fc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d300:	e17ffe17 	ldw	r5,-8(fp)
8110d304:	01000284 	movi	r4,10
8110d308:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d30c:	00800044 	movi	r2,1
}
8110d310:	e037883a 	mov	sp,fp
8110d314:	dfc00117 	ldw	ra,4(sp)
8110d318:	df000017 	ldw	fp,0(sp)
8110d31c:	dec00204 	addi	sp,sp,8
8110d320:	f800283a 	ret

8110d324 <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
8110d324:	defffc04 	addi	sp,sp,-16
8110d328:	de00012e 	bgeu	sp,et,8110d330 <bSyncCtrCh2OutEnable+0xc>
8110d32c:	003b68fa 	trap	3
8110d330:	dfc00315 	stw	ra,12(sp)
8110d334:	df000215 	stw	fp,8(sp)
8110d338:	df000204 	addi	fp,sp,8
8110d33c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d340:	01000284 	movi	r4,10
8110d344:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d348:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d34c:	e0bfff17 	ldw	r2,-4(fp)
8110d350:	1000051e 	bne	r2,zero,8110d368 <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
8110d354:	e0fffe17 	ldw	r3,-8(fp)
8110d358:	00bfff44 	movi	r2,-3
8110d35c:	1884703a 	and	r2,r3,r2
8110d360:	e0bffe15 	stw	r2,-8(fp)
8110d364:	00000306 	br	8110d374 <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8110d368:	e0bffe17 	ldw	r2,-8(fp)
8110d36c:	10800094 	ori	r2,r2,2
8110d370:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d374:	e17ffe17 	ldw	r5,-8(fp)
8110d378:	01000284 	movi	r4,10
8110d37c:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d380:	00800044 	movi	r2,1
}
8110d384:	e037883a 	mov	sp,fp
8110d388:	dfc00117 	ldw	ra,4(sp)
8110d38c:	df000017 	ldw	fp,0(sp)
8110d390:	dec00204 	addi	sp,sp,8
8110d394:	f800283a 	ret

8110d398 <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8110d398:	defffc04 	addi	sp,sp,-16
8110d39c:	de00012e 	bgeu	sp,et,8110d3a4 <bSyncCtrCh3OutEnable+0xc>
8110d3a0:	003b68fa 	trap	3
8110d3a4:	dfc00315 	stw	ra,12(sp)
8110d3a8:	df000215 	stw	fp,8(sp)
8110d3ac:	df000204 	addi	fp,sp,8
8110d3b0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d3b4:	01000284 	movi	r4,10
8110d3b8:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d3bc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d3c0:	e0bfff17 	ldw	r2,-4(fp)
8110d3c4:	1000051e 	bne	r2,zero,8110d3dc <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8110d3c8:	e0fffe17 	ldw	r3,-8(fp)
8110d3cc:	00bffec4 	movi	r2,-5
8110d3d0:	1884703a 	and	r2,r3,r2
8110d3d4:	e0bffe15 	stw	r2,-8(fp)
8110d3d8:	00000306 	br	8110d3e8 <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8110d3dc:	e0bffe17 	ldw	r2,-8(fp)
8110d3e0:	10800114 	ori	r2,r2,4
8110d3e4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d3e8:	e17ffe17 	ldw	r5,-8(fp)
8110d3ec:	01000284 	movi	r4,10
8110d3f0:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d3f4:	00800044 	movi	r2,1
}
8110d3f8:	e037883a 	mov	sp,fp
8110d3fc:	dfc00117 	ldw	ra,4(sp)
8110d400:	df000017 	ldw	fp,0(sp)
8110d404:	dec00204 	addi	sp,sp,8
8110d408:	f800283a 	ret

8110d40c <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8110d40c:	defffc04 	addi	sp,sp,-16
8110d410:	de00012e 	bgeu	sp,et,8110d418 <bSyncCtrCh4OutEnable+0xc>
8110d414:	003b68fa 	trap	3
8110d418:	dfc00315 	stw	ra,12(sp)
8110d41c:	df000215 	stw	fp,8(sp)
8110d420:	df000204 	addi	fp,sp,8
8110d424:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d428:	01000284 	movi	r4,10
8110d42c:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d430:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d434:	e0bfff17 	ldw	r2,-4(fp)
8110d438:	1000051e 	bne	r2,zero,8110d450 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8110d43c:	e0fffe17 	ldw	r3,-8(fp)
8110d440:	00bffdc4 	movi	r2,-9
8110d444:	1884703a 	and	r2,r3,r2
8110d448:	e0bffe15 	stw	r2,-8(fp)
8110d44c:	00000306 	br	8110d45c <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
8110d450:	e0bffe17 	ldw	r2,-8(fp)
8110d454:	10800214 	ori	r2,r2,8
8110d458:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d45c:	e17ffe17 	ldw	r5,-8(fp)
8110d460:	01000284 	movi	r4,10
8110d464:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d468:	00800044 	movi	r2,1
}
8110d46c:	e037883a 	mov	sp,fp
8110d470:	dfc00117 	ldw	ra,4(sp)
8110d474:	df000017 	ldw	fp,0(sp)
8110d478:	dec00204 	addi	sp,sp,8
8110d47c:	f800283a 	ret

8110d480 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
8110d480:	defffc04 	addi	sp,sp,-16
8110d484:	de00012e 	bgeu	sp,et,8110d48c <bSyncCtrCh5OutEnable+0xc>
8110d488:	003b68fa 	trap	3
8110d48c:	dfc00315 	stw	ra,12(sp)
8110d490:	df000215 	stw	fp,8(sp)
8110d494:	df000204 	addi	fp,sp,8
8110d498:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d49c:	01000284 	movi	r4,10
8110d4a0:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d4a4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d4a8:	e0bfff17 	ldw	r2,-4(fp)
8110d4ac:	1000051e 	bne	r2,zero,8110d4c4 <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
8110d4b0:	e0fffe17 	ldw	r3,-8(fp)
8110d4b4:	00bffbc4 	movi	r2,-17
8110d4b8:	1884703a 	and	r2,r3,r2
8110d4bc:	e0bffe15 	stw	r2,-8(fp)
8110d4c0:	00000306 	br	8110d4d0 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
8110d4c4:	e0bffe17 	ldw	r2,-8(fp)
8110d4c8:	10800414 	ori	r2,r2,16
8110d4cc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d4d0:	e17ffe17 	ldw	r5,-8(fp)
8110d4d4:	01000284 	movi	r4,10
8110d4d8:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d4dc:	00800044 	movi	r2,1
}
8110d4e0:	e037883a 	mov	sp,fp
8110d4e4:	dfc00117 	ldw	ra,4(sp)
8110d4e8:	df000017 	ldw	fp,0(sp)
8110d4ec:	dec00204 	addi	sp,sp,8
8110d4f0:	f800283a 	ret

8110d4f4 <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
8110d4f4:	defffc04 	addi	sp,sp,-16
8110d4f8:	de00012e 	bgeu	sp,et,8110d500 <bSyncCtrCh6OutEnable+0xc>
8110d4fc:	003b68fa 	trap	3
8110d500:	dfc00315 	stw	ra,12(sp)
8110d504:	df000215 	stw	fp,8(sp)
8110d508:	df000204 	addi	fp,sp,8
8110d50c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d510:	01000284 	movi	r4,10
8110d514:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d518:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d51c:	e0bfff17 	ldw	r2,-4(fp)
8110d520:	1000051e 	bne	r2,zero,8110d538 <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
8110d524:	e0fffe17 	ldw	r3,-8(fp)
8110d528:	00bff7c4 	movi	r2,-33
8110d52c:	1884703a 	and	r2,r3,r2
8110d530:	e0bffe15 	stw	r2,-8(fp)
8110d534:	00000306 	br	8110d544 <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110d538:	e0bffe17 	ldw	r2,-8(fp)
8110d53c:	10800814 	ori	r2,r2,32
8110d540:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d544:	e17ffe17 	ldw	r5,-8(fp)
8110d548:	01000284 	movi	r4,10
8110d54c:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d550:	00800044 	movi	r2,1
}
8110d554:	e037883a 	mov	sp,fp
8110d558:	dfc00117 	ldw	ra,4(sp)
8110d55c:	df000017 	ldw	fp,0(sp)
8110d560:	dec00204 	addi	sp,sp,8
8110d564:	f800283a 	ret

8110d568 <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8110d568:	defffc04 	addi	sp,sp,-16
8110d56c:	de00012e 	bgeu	sp,et,8110d574 <bSyncCtrCh7OutEnable+0xc>
8110d570:	003b68fa 	trap	3
8110d574:	dfc00315 	stw	ra,12(sp)
8110d578:	df000215 	stw	fp,8(sp)
8110d57c:	df000204 	addi	fp,sp,8
8110d580:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d584:	01000284 	movi	r4,10
8110d588:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d58c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d590:	e0bfff17 	ldw	r2,-4(fp)
8110d594:	1000051e 	bne	r2,zero,8110d5ac <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8110d598:	e0fffe17 	ldw	r3,-8(fp)
8110d59c:	00bfefc4 	movi	r2,-65
8110d5a0:	1884703a 	and	r2,r3,r2
8110d5a4:	e0bffe15 	stw	r2,-8(fp)
8110d5a8:	00000306 	br	8110d5b8 <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
8110d5ac:	e0bffe17 	ldw	r2,-8(fp)
8110d5b0:	10801014 	ori	r2,r2,64
8110d5b4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d5b8:	e17ffe17 	ldw	r5,-8(fp)
8110d5bc:	01000284 	movi	r4,10
8110d5c0:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d5c4:	00800044 	movi	r2,1
}
8110d5c8:	e037883a 	mov	sp,fp
8110d5cc:	dfc00117 	ldw	ra,4(sp)
8110d5d0:	df000017 	ldw	fp,0(sp)
8110d5d4:	dec00204 	addi	sp,sp,8
8110d5d8:	f800283a 	ret

8110d5dc <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8110d5dc:	defffc04 	addi	sp,sp,-16
8110d5e0:	de00012e 	bgeu	sp,et,8110d5e8 <bSyncCtrCh8OutEnable+0xc>
8110d5e4:	003b68fa 	trap	3
8110d5e8:	dfc00315 	stw	ra,12(sp)
8110d5ec:	df000215 	stw	fp,8(sp)
8110d5f0:	df000204 	addi	fp,sp,8
8110d5f4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d5f8:	01000284 	movi	r4,10
8110d5fc:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d600:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d604:	e0bfff17 	ldw	r2,-4(fp)
8110d608:	1000051e 	bne	r2,zero,8110d620 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8110d60c:	e0fffe17 	ldw	r3,-8(fp)
8110d610:	00bfdfc4 	movi	r2,-129
8110d614:	1884703a 	and	r2,r3,r2
8110d618:	e0bffe15 	stw	r2,-8(fp)
8110d61c:	00000306 	br	8110d62c <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
8110d620:	e0bffe17 	ldw	r2,-8(fp)
8110d624:	10802014 	ori	r2,r2,128
8110d628:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d62c:	e17ffe17 	ldw	r5,-8(fp)
8110d630:	01000284 	movi	r4,10
8110d634:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d638:	00800044 	movi	r2,1
}
8110d63c:	e037883a 	mov	sp,fp
8110d640:	dfc00117 	ldw	ra,4(sp)
8110d644:	df000017 	ldw	fp,0(sp)
8110d648:	dec00204 	addi	sp,sp,8
8110d64c:	f800283a 	ret

8110d650 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
8110d650:	defffc04 	addi	sp,sp,-16
8110d654:	de00012e 	bgeu	sp,et,8110d65c <bSyncIrqEnableError+0xc>
8110d658:	003b68fa 	trap	3
8110d65c:	dfc00315 	stw	ra,12(sp)
8110d660:	df000215 	stw	fp,8(sp)
8110d664:	df000204 	addi	fp,sp,8
8110d668:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110d66c:	01000044 	movi	r4,1
8110d670:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d674:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d678:	e0bfff17 	ldw	r2,-4(fp)
8110d67c:	1000051e 	bne	r2,zero,8110d694 <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
8110d680:	e0fffe17 	ldw	r3,-8(fp)
8110d684:	00bfff44 	movi	r2,-3
8110d688:	1884703a 	and	r2,r3,r2
8110d68c:	e0bffe15 	stw	r2,-8(fp)
8110d690:	00000306 	br	8110d6a0 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
8110d694:	e0bffe17 	ldw	r2,-8(fp)
8110d698:	10800094 	ori	r2,r2,2
8110d69c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110d6a0:	e17ffe17 	ldw	r5,-8(fp)
8110d6a4:	01000044 	movi	r4,1
8110d6a8:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d6ac:	00800044 	movi	r2,1
}
8110d6b0:	e037883a 	mov	sp,fp
8110d6b4:	dfc00117 	ldw	ra,4(sp)
8110d6b8:	df000017 	ldw	fp,0(sp)
8110d6bc:	dec00204 	addi	sp,sp,8
8110d6c0:	f800283a 	ret

8110d6c4 <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
8110d6c4:	defffc04 	addi	sp,sp,-16
8110d6c8:	de00012e 	bgeu	sp,et,8110d6d0 <bSyncIrqEnableBlank+0xc>
8110d6cc:	003b68fa 	trap	3
8110d6d0:	dfc00315 	stw	ra,12(sp)
8110d6d4:	df000215 	stw	fp,8(sp)
8110d6d8:	df000204 	addi	fp,sp,8
8110d6dc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110d6e0:	01000044 	movi	r4,1
8110d6e4:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d6e8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d6ec:	e0bfff17 	ldw	r2,-4(fp)
8110d6f0:	1000051e 	bne	r2,zero,8110d708 <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
8110d6f4:	e0fffe17 	ldw	r3,-8(fp)
8110d6f8:	00bfff84 	movi	r2,-2
8110d6fc:	1884703a 	and	r2,r3,r2
8110d700:	e0bffe15 	stw	r2,-8(fp)
8110d704:	00000306 	br	8110d714 <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8110d708:	e0bffe17 	ldw	r2,-8(fp)
8110d70c:	10800054 	ori	r2,r2,1
8110d710:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110d714:	e17ffe17 	ldw	r5,-8(fp)
8110d718:	01000044 	movi	r4,1
8110d71c:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d720:	00800044 	movi	r2,1
}
8110d724:	e037883a 	mov	sp,fp
8110d728:	dfc00117 	ldw	ra,4(sp)
8110d72c:	df000017 	ldw	fp,0(sp)
8110d730:	dec00204 	addi	sp,sp,8
8110d734:	f800283a 	ret

8110d738 <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110d738:	defffc04 	addi	sp,sp,-16
8110d73c:	de00012e 	bgeu	sp,et,8110d744 <bSyncIrqFlagClrError+0xc>
8110d740:	003b68fa 	trap	3
8110d744:	dfc00315 	stw	ra,12(sp)
8110d748:	df000215 	stw	fp,8(sp)
8110d74c:	df000204 	addi	fp,sp,8
8110d750:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110d754:	01000084 	movi	r4,2
8110d758:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d75c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d760:	e0bfff17 	ldw	r2,-4(fp)
8110d764:	1000051e 	bne	r2,zero,8110d77c <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110d768:	e0fffe17 	ldw	r3,-8(fp)
8110d76c:	00bfff44 	movi	r2,-3
8110d770:	1884703a 	and	r2,r3,r2
8110d774:	e0bffe15 	stw	r2,-8(fp)
8110d778:	00000306 	br	8110d788 <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110d77c:	e0bffe17 	ldw	r2,-8(fp)
8110d780:	10800094 	ori	r2,r2,2
8110d784:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110d788:	e17ffe17 	ldw	r5,-8(fp)
8110d78c:	01000084 	movi	r4,2
8110d790:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d794:	00800044 	movi	r2,1
}
8110d798:	e037883a 	mov	sp,fp
8110d79c:	dfc00117 	ldw	ra,4(sp)
8110d7a0:	df000017 	ldw	fp,0(sp)
8110d7a4:	dec00204 	addi	sp,sp,8
8110d7a8:	f800283a 	ret

8110d7ac <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
8110d7ac:	defffc04 	addi	sp,sp,-16
8110d7b0:	de00012e 	bgeu	sp,et,8110d7b8 <bSyncIrqFlagClrBlank+0xc>
8110d7b4:	003b68fa 	trap	3
8110d7b8:	dfc00315 	stw	ra,12(sp)
8110d7bc:	df000215 	stw	fp,8(sp)
8110d7c0:	df000204 	addi	fp,sp,8
8110d7c4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110d7c8:	01000084 	movi	r4,2
8110d7cc:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d7d0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d7d4:	e0bfff17 	ldw	r2,-4(fp)
8110d7d8:	1000051e 	bne	r2,zero,8110d7f0 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110d7dc:	e0fffe17 	ldw	r3,-8(fp)
8110d7e0:	00bfff84 	movi	r2,-2
8110d7e4:	1884703a 	and	r2,r3,r2
8110d7e8:	e0bffe15 	stw	r2,-8(fp)
8110d7ec:	00000306 	br	8110d7fc <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110d7f0:	e0bffe17 	ldw	r2,-8(fp)
8110d7f4:	10800054 	ori	r2,r2,1
8110d7f8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110d7fc:	e17ffe17 	ldw	r5,-8(fp)
8110d800:	01000084 	movi	r4,2
8110d804:	110d9480 	call	8110d948 <bSyncWriteReg>
	return TRUE;
8110d808:	00800044 	movi	r2,1
}
8110d80c:	e037883a 	mov	sp,fp
8110d810:	dfc00117 	ldw	ra,4(sp)
8110d814:	df000017 	ldw	fp,0(sp)
8110d818:	dec00204 	addi	sp,sp,8
8110d81c:	f800283a 	ret

8110d820 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
8110d820:	defffc04 	addi	sp,sp,-16
8110d824:	de00012e 	bgeu	sp,et,8110d82c <bSyncIrqFlagError+0xc>
8110d828:	003b68fa 	trap	3
8110d82c:	dfc00315 	stw	ra,12(sp)
8110d830:	df000215 	stw	fp,8(sp)
8110d834:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110d838:	010000c4 	movi	r4,3
8110d83c:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d840:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
8110d844:	e0bfff17 	ldw	r2,-4(fp)
8110d848:	1080008c 	andi	r2,r2,2
8110d84c:	10000326 	beq	r2,zero,8110d85c <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
8110d850:	00800044 	movi	r2,1
8110d854:	e0bffe15 	stw	r2,-8(fp)
8110d858:	00000106 	br	8110d860 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8110d85c:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d860:	e0bffe17 	ldw	r2,-8(fp)
}
8110d864:	e037883a 	mov	sp,fp
8110d868:	dfc00117 	ldw	ra,4(sp)
8110d86c:	df000017 	ldw	fp,0(sp)
8110d870:	dec00204 	addi	sp,sp,8
8110d874:	f800283a 	ret

8110d878 <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8110d878:	defffc04 	addi	sp,sp,-16
8110d87c:	de00012e 	bgeu	sp,et,8110d884 <bSyncIrqFlagBlank+0xc>
8110d880:	003b68fa 	trap	3
8110d884:	dfc00315 	stw	ra,12(sp)
8110d888:	df000215 	stw	fp,8(sp)
8110d88c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110d890:	010000c4 	movi	r4,3
8110d894:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d898:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
8110d89c:	e0bfff17 	ldw	r2,-4(fp)
8110d8a0:	1080004c 	andi	r2,r2,1
8110d8a4:	10000326 	beq	r2,zero,8110d8b4 <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8110d8a8:	00800044 	movi	r2,1
8110d8ac:	e0bffe15 	stw	r2,-8(fp)
8110d8b0:	00000106 	br	8110d8b8 <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
8110d8b4:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d8b8:	e0bffe17 	ldw	r2,-8(fp)
}
8110d8bc:	e037883a 	mov	sp,fp
8110d8c0:	dfc00117 	ldw	ra,4(sp)
8110d8c4:	df000017 	ldw	fp,0(sp)
8110d8c8:	dec00204 	addi	sp,sp,8
8110d8cc:	f800283a 	ret

8110d8d0 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
8110d8d0:	defffd04 	addi	sp,sp,-12
8110d8d4:	de00012e 	bgeu	sp,et,8110d8dc <uliSyncGetCtr+0xc>
8110d8d8:	003b68fa 	trap	3
8110d8dc:	dfc00215 	stw	ra,8(sp)
8110d8e0:	df000115 	stw	fp,4(sp)
8110d8e4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d8e8:	01000284 	movi	r4,10
8110d8ec:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d8f0:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d8f4:	e0bfff17 	ldw	r2,-4(fp)
}
8110d8f8:	e037883a 	mov	sp,fp
8110d8fc:	dfc00117 	ldw	ra,4(sp)
8110d900:	df000017 	ldw	fp,0(sp)
8110d904:	dec00204 	addi	sp,sp,8
8110d908:	f800283a 	ret

8110d90c <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8110d90c:	defffd04 	addi	sp,sp,-12
8110d910:	de00012e 	bgeu	sp,et,8110d918 <uliSyncReadStatus+0xc>
8110d914:	003b68fa 	trap	3
8110d918:	dfc00215 	stw	ra,8(sp)
8110d91c:	df000115 	stw	fp,4(sp)
8110d920:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110d924:	0009883a 	mov	r4,zero
8110d928:	110d9a40 	call	8110d9a4 <uliSyncReadReg>
8110d92c:	e0bfff15 	stw	r2,-4(fp)
	return aux;
8110d930:	e0bfff17 	ldw	r2,-4(fp)
}
8110d934:	e037883a 	mov	sp,fp
8110d938:	dfc00117 	ldw	ra,4(sp)
8110d93c:	df000017 	ldw	fp,0(sp)
8110d940:	dec00204 	addi	sp,sp,8
8110d944:	f800283a 	ret

8110d948 <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110d948:	defffc04 	addi	sp,sp,-16
8110d94c:	de00012e 	bgeu	sp,et,8110d954 <bSyncWriteReg+0xc>
8110d950:	003b68fa 	trap	3
8110d954:	df000315 	stw	fp,12(sp)
8110d958:	df000304 	addi	fp,sp,12
8110d95c:	e13ffe15 	stw	r4,-8(fp)
8110d960:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110d964:	00a00034 	movhi	r2,32768
8110d968:	10810004 	addi	r2,r2,1024
8110d96c:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
8110d970:	e0bffe17 	ldw	r2,-8(fp)
8110d974:	1085883a 	add	r2,r2,r2
8110d978:	1085883a 	add	r2,r2,r2
8110d97c:	1007883a 	mov	r3,r2
8110d980:	e0bffd17 	ldw	r2,-12(fp)
8110d984:	10c5883a 	add	r2,r2,r3
8110d988:	e0ffff17 	ldw	r3,-4(fp)
8110d98c:	10c00015 	stw	r3,0(r2)
	return TRUE;
8110d990:	00800044 	movi	r2,1
}
8110d994:	e037883a 	mov	sp,fp
8110d998:	df000017 	ldw	fp,0(sp)
8110d99c:	dec00104 	addi	sp,sp,4
8110d9a0:	f800283a 	ret

8110d9a4 <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
8110d9a4:	defffc04 	addi	sp,sp,-16
8110d9a8:	de00012e 	bgeu	sp,et,8110d9b0 <uliSyncReadReg+0xc>
8110d9ac:	003b68fa 	trap	3
8110d9b0:	df000315 	stw	fp,12(sp)
8110d9b4:	df000304 	addi	fp,sp,12
8110d9b8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110d9bc:	00a00034 	movhi	r2,32768
8110d9c0:	10810004 	addi	r2,r2,1024
8110d9c4:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8110d9c8:	e0bfff17 	ldw	r2,-4(fp)
8110d9cc:	1085883a 	add	r2,r2,r2
8110d9d0:	1085883a 	add	r2,r2,r2
8110d9d4:	1007883a 	mov	r3,r2
8110d9d8:	e0bffd17 	ldw	r2,-12(fp)
8110d9dc:	10c5883a 	add	r2,r2,r3
8110d9e0:	10800017 	ldw	r2,0(r2)
8110d9e4:	e0bffe15 	stw	r2,-8(fp)
	return value;
8110d9e8:	e0bffe17 	ldw	r2,-8(fp)
}
8110d9ec:	e037883a 	mov	sp,fp
8110d9f0:	df000017 	ldw	fp,0(sp)
8110d9f4:	dec00104 	addi	sp,sp,4
8110d9f8:	f800283a 	ret

8110d9fc <uliPerCalcPeriodMs>:

/*
 * Return the necessary PER value for a
 * Sync Signal period in usiPeriodMs ms.
 */
alt_u32 uliPerCalcPeriodMs(alt_u16 usiPeriodMs) {
8110d9fc:	defffc04 	addi	sp,sp,-16
8110da00:	de00012e 	bgeu	sp,et,8110da08 <uliPerCalcPeriodMs+0xc>
8110da04:	003b68fa 	trap	3
8110da08:	dfc00315 	stw	ra,12(sp)
8110da0c:	df000215 	stw	fp,8(sp)
8110da10:	df000204 	addi	fp,sp,8
8110da14:	2005883a 	mov	r2,r4
8110da18:	e0bfff0d 	sth	r2,-4(fp)
	 * Period[ms] / 20e-6 = Period[ms] * 5e+4
	 * PER = Period[ms] * 5e+4
	 */

	alt_u32 uliPer;
	uliPer = usiPeriodMs * 5e+4;
8110da1c:	e0bfff0b 	ldhu	r2,-4(fp)
8110da20:	1009883a 	mov	r4,r2
8110da24:	11202540 	call	81120254 <__floatsidf>
8110da28:	1011883a 	mov	r8,r2
8110da2c:	1813883a 	mov	r9,r3
8110da30:	000d883a 	mov	r6,zero
8110da34:	01d03a34 	movhi	r7,16616
8110da38:	39da8004 	addi	r7,r7,27136
8110da3c:	4009883a 	mov	r4,r8
8110da40:	480b883a 	mov	r5,r9
8110da44:	111f1b00 	call	8111f1b0 <__muldf3>
8110da48:	1009883a 	mov	r4,r2
8110da4c:	180b883a 	mov	r5,r3
8110da50:	2005883a 	mov	r2,r4
8110da54:	2807883a 	mov	r3,r5
8110da58:	1009883a 	mov	r4,r2
8110da5c:	180b883a 	mov	r5,r3
8110da60:	111e5e80 	call	8111e5e8 <__fixunsdfsi>
8110da64:	e0bffe15 	stw	r2,-8(fp)

	return uliPer;
8110da68:	e0bffe17 	ldw	r2,-8(fp)
}
8110da6c:	e037883a 	mov	sp,fp
8110da70:	dfc00117 	ldw	ra,4(sp)
8110da74:	df000017 	ldw	fp,0(sp)
8110da78:	dec00204 	addi	sp,sp,8
8110da7c:	f800283a 	ret

8110da80 <vDataControlTask>:


#include "data_control_task.h"

/* 0% Ready! */
void vDataControlTask(void *task_data) {
8110da80:	defff804 	addi	sp,sp,-32
8110da84:	de00012e 	bgeu	sp,et,8110da8c <vDataControlTask+0xc>
8110da88:	003b68fa 	trap	3
8110da8c:	dfc00715 	stw	ra,28(sp)
8110da90:	df000615 	stw	fp,24(sp)
8110da94:	df000604 	addi	fp,sp,24
8110da98:	e13ffd15 	stw	r4,-12(fp)
	tQMask uiCmdDTC;
	INT8U error_code;
	TNData_Control *pxDataC;


	pxDataC = (TNData_Control *) task_data;
8110da9c:	e0bffd17 	ldw	r2,-12(fp)
8110daa0:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"Data Controller Task. (Task on)\n");
8110daa4:	d0a06117 	ldw	r2,-32380(gp)
8110daa8:	100f883a 	mov	r7,r2
8110daac:	01800804 	movi	r6,32
8110dab0:	01400044 	movi	r5,1
8110dab4:	01204574 	movhi	r4,33045
8110dab8:	212df204 	addi	r4,r4,-18488
8110dabc:	1120e540 	call	81120e54 <fwrite>
    #endif

    pxDataC->bUpdateComplete = TRUE;
8110dac0:	e0bffa17 	ldw	r2,-24(fp)
8110dac4:	00c00044 	movi	r3,1
8110dac8:	10c00515 	stw	r3,20(r2)

    error_code = OSQFlush(xQMaskDataCtrl);
8110dacc:	d0a05e17 	ldw	r2,-32392(gp)
8110dad0:	1009883a 	mov	r4,r2
8110dad4:	113cd1c0 	call	8113cd1c <OSQFlush>
8110dad8:	e0bffc05 	stb	r2,-16(fp)
	if ( error_code != OS_NO_ERR ) {
8110dadc:	e0bffc03 	ldbu	r2,-16(fp)
8110dae0:	10803fcc 	andi	r2,r2,255
8110dae4:	10000126 	beq	r2,zero,8110daec <vDataControlTask+0x6c>
		vFailFlushQueueData();
8110dae8:	111c9280 	call	8111c928 <vFailFlushQueueData>
	}

	for (;;) {

		uiCmdDTC.ulWord = (unsigned int)OSQPend(xQMaskCMDNDataCtrlTBL, 0, &error_code); /* Blocking operation */
8110daec:	e0bffc04 	addi	r2,fp,-16
8110daf0:	100d883a 	mov	r6,r2
8110daf4:	000b883a 	mov	r5,zero
8110daf8:	012045b4 	movhi	r4,33046
8110dafc:	212b4f04 	addi	r4,r4,-21188
8110db00:	113cddc0 	call	8113cddc <OSQPend>
8110db04:	e0bffb15 	stw	r2,-20(fp)
			} else {

				/* todo: For now, do nothing */
			}
		}
		OSTimeDlyHMSM(0, 0, 5, 0); /*todo:Tirar depois do debug*/
8110db08:	000f883a 	mov	r7,zero
8110db0c:	01800144 	movi	r6,5
8110db10:	000b883a 	mov	r5,zero
8110db14:	0009883a 	mov	r4,zero
8110db18:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>
	}
8110db1c:	003ff306 	br	8110daec <__reset+0xfb0edaec>

8110db20 <vFeeTask>:
const char *cTemp[64];




void vFeeTask(void *task_data) {
8110db20:	defff004 	addi	sp,sp,-64
8110db24:	de00012e 	bgeu	sp,et,8110db2c <vFeeTask+0xc>
8110db28:	003b68fa 	trap	3
8110db2c:	dfc00f15 	stw	ra,60(sp)
8110db30:	df000e15 	stw	fp,56(sp)
8110db34:	df000e04 	addi	fp,sp,56
8110db38:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = FALSE;
8110db3c:	e03ffb15 	stw	zero,-20(fp)
	alt_u16 *pusiHK;
	alt_u32 *pusiHK32;
	unsigned char ucIL;


	pxNFee = ( TNFee * ) task_data;
8110db40:	e0bfff17 	ldw	r2,-4(fp)
8110db44:	d0a05315 	stw	r2,-32436(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
8110db48:	d0e06117 	ldw	r3,-32380(gp)
8110db4c:	d0a05317 	ldw	r2,-32436(gp)
8110db50:	10800003 	ldbu	r2,0(r2)
8110db54:	10803fcc 	andi	r2,r2,255
8110db58:	100d883a 	mov	r6,r2
8110db5c:	01604574 	movhi	r5,33045
8110db60:	296dfb04 	addi	r5,r5,-18452
8110db64:	1809883a 	mov	r4,r3
8110db68:	11207b80 	call	811207b8 <fprintf>
	#endif

	#ifdef DEBUG_ON
		vPrintConsoleNFee( pxNFee );
8110db6c:	d0a05317 	ldw	r2,-32436(gp)
8110db70:	1009883a 	mov	r4,r2
8110db74:	11105380 	call	81110538 <vPrintConsoleNFee>
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
8110db78:	d0a05317 	ldw	r2,-32436(gp)
8110db7c:	10802c17 	ldw	r2,176(r2)
8110db80:	10c00368 	cmpgeui	r3,r2,13
8110db84:	1805231e 	bne	r3,zero,8110f014 <vFeeTask+0x14f4>
8110db88:	100690ba 	slli	r3,r2,2
8110db8c:	00a04474 	movhi	r2,33041
8110db90:	10b6e804 	addi	r2,r2,-9312
8110db94:	1885883a 	add	r2,r3,r2
8110db98:	10800017 	ldw	r2,0(r2)
8110db9c:	1000683a 	jmp	r2
8110dba0:	8110dbd4 	ori	r4,r16,17263
8110dba4:	8110e320 	cmpeqi	r4,r16,17292
8110dba8:	8110e3a4 	muli	r4,r16,17294
8110dbac:	8110e4f8 	rdprs	r4,r16,17299
8110dbb0:	8110eba0 	cmpeqi	r4,r16,17326
8110dbb4:	8110e164 	muli	r4,r16,17285
8110dbb8:	8110e3b4 	orhi	r4,r16,17294
8110dbbc:	8110eae4 	muli	r4,r16,17323
8110dbc0:	8110f014 	ori	r4,r16,17344
8110dbc4:	8110f014 	ori	r4,r16,17344
8110dbc8:	8110e57c 	xorhi	r4,r16,17301
8110dbcc:	8110ef10 	cmplti	r4,r16,17340
8110dbd0:	8110ef6c 	andhi	r4,r16,17341
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110dbd4:	d0a05317 	ldw	r2,-32436(gp)
8110dbd8:	10800003 	ldbu	r2,0(r2)
8110dbdc:	10803fcc 	andi	r2,r2,255
8110dbe0:	1085883a 	add	r2,r2,r2
8110dbe4:	1087883a 	add	r3,r2,r2
8110dbe8:	d0a06904 	addi	r2,gp,-32348
8110dbec:	1885883a 	add	r2,r3,r2
8110dbf0:	10800017 	ldw	r2,0(r2)
8110dbf4:	1009883a 	mov	r4,r2
8110dbf8:	113cd1c0 	call	8113cd1c <OSQFlush>
8110dbfc:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110dc00:	e0bffd03 	ldbu	r2,-12(fp)
8110dc04:	10803fcc 	andi	r2,r2,255
8110dc08:	10000126 	beq	r2,zero,8110dc10 <vFeeTask+0xf0>
					vFailFlushNFEEQueue();
8110dc0c:	111c9c00 	call	8111c9c0 <vFailFlushNFEEQueue>
				}

				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110dc10:	d0a05317 	ldw	r2,-32436(gp)
8110dc14:	10800003 	ldbu	r2,0(r2)
8110dc18:	10803fcc 	andi	r2,r2,255
8110dc1c:	1085883a 	add	r2,r2,r2
8110dc20:	1087883a 	add	r3,r2,r2
8110dc24:	d0a05b04 	addi	r2,gp,-32404
8110dc28:	1885883a 	add	r2,r3,r2
8110dc2c:	10800017 	ldw	r2,0(r2)
8110dc30:	1009883a 	mov	r4,r2
8110dc34:	113cd1c0 	call	8113cd1c <OSQFlush>
8110dc38:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110dc3c:	e0bffd03 	ldbu	r2,-12(fp)
8110dc40:	10803fcc 	andi	r2,r2,255
8110dc44:	10000126 	beq	r2,zero,8110dc4c <vFeeTask+0x12c>
					vFailFlushNFEEQueue();
8110dc48:	111c9c00 	call	8111c9c0 <vFailFlushNFEEQueue>
				}				

				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110dc4c:	d0a05317 	ldw	r2,-32436(gp)
8110dc50:	10803304 	addi	r2,r2,204
8110dc54:	1009883a 	mov	r4,r2
8110dc58:	1104a440 	call	81104a44 <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFee->xCcdInfo.usiHalfWidth;
8110dc5c:	d0a05317 	ldw	r2,-32436(gp)
8110dc60:	d0e05317 	ldw	r3,-32436(gp)
8110dc64:	18c0308b 	ldhu	r3,194(r3)
8110dc68:	10c0340d 	sth	r3,208(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFee->xCcdInfo.usiHeight;
8110dc6c:	d0a05317 	ldw	r2,-32436(gp)
8110dc70:	d0e05317 	ldw	r3,-32436(gp)
8110dc74:	18c0310b 	ldhu	r3,196(r3)
8110dc78:	10c0348d 	sth	r3,210(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFee->xCcdInfo.usiHeight - pxNFee->xCcdInfo.usiOLN;
8110dc7c:	d0a05317 	ldw	r2,-32436(gp)
8110dc80:	d0e05317 	ldw	r3,-32436(gp)
8110dc84:	1900310b 	ldhu	r4,196(r3)
8110dc88:	d0e05317 	ldw	r3,-32436(gp)
8110dc8c:	18c0300b 	ldhu	r3,192(r3)
8110dc90:	20c7c83a 	sub	r3,r4,r3
8110dc94:	10c0350d 	sth	r3,212(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFee->xCcdInfo.usiOLN;
8110dc98:	d0a05317 	ldw	r2,-32436(gp)
8110dc9c:	d0e05317 	ldw	r3,-32436(gp)
8110dca0:	18c0300b 	ldhu	r3,192(r3)
8110dca4:	10c0358d 	sth	r3,214(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = 32768;
8110dca8:	d0a05317 	ldw	r2,-32436(gp)
8110dcac:	00e00004 	movi	r3,-32768
8110dcb0:	10c0360d 	sth	r3,216(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = 0; /* 32 KB */
8110dcb4:	d0a05317 	ldw	r2,-32436(gp)
8110dcb8:	100036c5 	stb	zero,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110dcbc:	d0a05317 	ldw	r2,-32436(gp)
8110dcc0:	00c00044 	movi	r3,1
8110dcc4:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110dcc8:	d0a05317 	ldw	r2,-32436(gp)
8110dccc:	10803304 	addi	r2,r2,204
8110dcd0:	1009883a 	mov	r4,r2
8110dcd4:	11048180 	call	81104818 <bDpktSetPacketConfig>
				bRmapSetRmapMemHKArea(&pxNFee->xChannel.xRmap);

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;
*/
				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110dcd8:	d0a05317 	ldw	r2,-32436(gp)
8110dcdc:	10804304 	addi	r2,r2,268
8110dce0:	1009883a 	mov	r4,r2
8110dce4:	11095100 	call	81109510 <bRmapGetRmapMemHKArea>
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE = 0xFF00;
8110dce8:	d0a05317 	ldw	r2,-32436(gp)
8110dcec:	00ffc004 	movi	r3,-256
8110dcf0:	10c0690d 	sth	r3,420(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodF = 0xFF01;
8110dcf4:	d0a05317 	ldw	r2,-32436(gp)
8110dcf8:	00ffc044 	movi	r3,-255
8110dcfc:	10c0698d 	sth	r3,422(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VrdMon = 0xFF02;
8110dd00:	d0a05317 	ldw	r2,-32436(gp)
8110dd04:	00ffc084 	movi	r3,-254
8110dd08:	10c06a0d 	sth	r3,424(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodE = 0xFF03;
8110dd0c:	d0a05317 	ldw	r2,-32436(gp)
8110dd10:	00ffc0c4 	movi	r3,-253
8110dd14:	10c06a8d 	sth	r3,426(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodF = 0xFF04;
8110dd18:	d0a05317 	ldw	r2,-32436(gp)
8110dd1c:	00ffc104 	movi	r3,-252
8110dd20:	10c06b0d 	sth	r3,428(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VrdMon = 0xFF05;
8110dd24:	d0a05317 	ldw	r2,-32436(gp)
8110dd28:	00ffc144 	movi	r3,-251
8110dd2c:	10c06b8d 	sth	r3,430(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodE = 0xFF06;
8110dd30:	d0a05317 	ldw	r2,-32436(gp)
8110dd34:	00ffc184 	movi	r3,-250
8110dd38:	10c06c0d 	sth	r3,432(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodF = 0xFF07;
8110dd3c:	d0a05317 	ldw	r2,-32436(gp)
8110dd40:	00ffc1c4 	movi	r3,-249
8110dd44:	10c06c8d 	sth	r3,434(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VrdMon = 0xFF08;
8110dd48:	d0a05317 	ldw	r2,-32436(gp)
8110dd4c:	00ffc204 	movi	r3,-248
8110dd50:	10c06d0d 	sth	r3,436(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodE  = 0xFF09;
8110dd54:	d0a05317 	ldw	r2,-32436(gp)
8110dd58:	00ffc244 	movi	r3,-247
8110dd5c:	10c06d8d 	sth	r3,438(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodF = 0xFF0A;
8110dd60:	d0a05317 	ldw	r2,-32436(gp)
8110dd64:	00ffc284 	movi	r3,-246
8110dd68:	10c06e0d 	sth	r3,440(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VrdMon = 0xFF0B;
8110dd6c:	d0a05317 	ldw	r2,-32436(gp)
8110dd70:	00ffc2c4 	movi	r3,-245
8110dd74:	10c06e8d 	sth	r3,442(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccd = 0xFF0C;
8110dd78:	d0a05317 	ldw	r2,-32436(gp)
8110dd7c:	00ffc304 	movi	r3,-244
8110dd80:	10c06f0d 	sth	r3,444(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclk = 0xFF0D;
8110dd84:	d0a05317 	ldw	r2,-32436(gp)
8110dd88:	00ffc344 	movi	r3,-243
8110dd8c:	10c06f8d 	sth	r3,446(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclk = 0xFF0E;
8110dd90:	d0a05317 	ldw	r2,-32436(gp)
8110dd94:	00ffc384 	movi	r3,-242
8110dd98:	10c0700d 	sth	r3,448(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclkLow = 0xFF0F;
8110dd9c:	d0a05317 	ldw	r2,-32436(gp)
8110dda0:	00ffc3c4 	movi	r3,-241
8110dda4:	10c0708d 	sth	r3,450(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbPos = 0xFF10;
8110dda8:	d0a05317 	ldw	r2,-32436(gp)
8110ddac:	00ffc404 	movi	r3,-240
8110ddb0:	10c0710d 	sth	r3,452(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbNeg = 0xFF11;
8110ddb4:	d0a05317 	ldw	r2,-32436(gp)
8110ddb8:	00ffc444 	movi	r3,-239
8110ddbc:	10c0718d 	sth	r3,454(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vbPos = 0xFF12;
8110ddc0:	d0a05317 	ldw	r2,-32436(gp)
8110ddc4:	00ffc484 	movi	r3,-238
8110ddc8:	10c0720d 	sth	r3,456(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vaPos = 0xFF13;
8110ddcc:	d0a05317 	ldw	r2,-32436(gp)
8110ddd0:	00ffc4c4 	movi	r3,-237
8110ddd4:	10c0728d 	sth	r3,458(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vdPos = 0xFF14;
8110ddd8:	d0a05317 	ldw	r2,-32436(gp)
8110dddc:	00ffc504 	movi	r3,-236
8110dde0:	10c0730d 	sth	r3,460(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vdPos = 0xFF15;
8110dde4:	d0a05317 	ldw	r2,-32436(gp)
8110dde8:	00ffc544 	movi	r3,-235
8110ddec:	10c0738d 	sth	r3,462(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk15vdPos = 0xFF16;
8110ddf0:	d0a05317 	ldw	r2,-32436(gp)
8110ddf4:	00ffc584 	movi	r3,-234
8110ddf8:	10c0740d 	sth	r3,464(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vref = 0xFF17;
8110ddfc:	d0a05317 	ldw	r2,-32436(gp)
8110de00:	00ffc5c4 	movi	r3,-233
8110de04:	10c0748d 	sth	r3,466(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccdPosRaw = 0xFF18;
8110de08:	d0a05317 	ldw	r2,-32436(gp)
8110de0c:	00ffc604 	movi	r3,-232
8110de10:	10c0750d 	sth	r3,468(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVclkPosRaw = 0xFF19;
8110de14:	d0a05317 	ldw	r2,-32436(gp)
8110de18:	00ffc644 	movi	r3,-231
8110de1c:	10c0758d 	sth	r3,470(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan1PosRaw = 0xFF1A;
8110de20:	d0a05317 	ldw	r2,-32436(gp)
8110de24:	00ffc684 	movi	r3,-230
8110de28:	10c0760d 	sth	r3,472(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan3NegRaw = 0xFF1B;
8110de2c:	d0a05317 	ldw	r2,-32436(gp)
8110de30:	00ffc6c4 	movi	r3,-229
8110de34:	10c0768d 	sth	r3,474(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan2PosRaw = 0xFF1C;
8110de38:	d0a05317 	ldw	r2,-32436(gp)
8110de3c:	00ffc704 	movi	r3,-228
8110de40:	10c0770d 	sth	r3,476(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigFpgaRaw = 0xFF1D;
8110de44:	d0a05317 	ldw	r2,-32436(gp)
8110de48:	00ffc744 	movi	r3,-227
8110de4c:	10c0778d 	sth	r3,478(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigSpwRaw = 0xFF1E;
8110de50:	d0a05317 	ldw	r2,-32436(gp)
8110de54:	00ffc784 	movi	r3,-226
8110de58:	10c0780d 	sth	r3,480(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclkLow = 0xFF1F;
8110de5c:	d0a05317 	ldw	r2,-32436(gp)
8110de60:	00ffc7c4 	movi	r3,-225
8110de64:	10c0788d 	sth	r3,482(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAE = 0xFF20;
8110de68:	d0a05317 	ldw	r2,-32436(gp)
8110de6c:	00ffc804 	movi	r3,-224
8110de70:	10c0790d 	sth	r3,484(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAF = 0xFF21;
8110de74:	d0a05317 	ldw	r2,-32436(gp)
8110de78:	00ffc844 	movi	r3,-223
8110de7c:	10c0798d 	sth	r3,486(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1Temp = 0xFF22;
8110de80:	d0a05317 	ldw	r2,-32436(gp)
8110de84:	00ffc884 	movi	r3,-222
8110de88:	10c07a0d 	sth	r3,488(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2Temp = 0xFF23;
8110de8c:	d0a05317 	ldw	r2,-32436(gp)
8110de90:	00ffc8c4 	movi	r3,-221
8110de94:	10c07a8d 	sth	r3,490(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3Temp = 0xFF24;
8110de98:	d0a05317 	ldw	r2,-32436(gp)
8110de9c:	00ffc904 	movi	r3,-220
8110dea0:	10c07b0d 	sth	r3,492(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4Temp = 0xFF25;
8110dea4:	d0a05317 	ldw	r2,-32436(gp)
8110dea8:	00ffc944 	movi	r3,-219
8110deac:	10c07b8d 	sth	r3,494(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkWp605Spare = 0xFF26;
8110deb0:	d0a05317 	ldw	r2,-32436(gp)
8110deb4:	00ffc984 	movi	r3,-218
8110deb8:	10c07c0d 	sth	r3,496(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA0 = 0xFF27;
8110debc:	d0a05317 	ldw	r2,-32436(gp)
8110dec0:	00ffc9c4 	movi	r3,-217
8110dec4:	10c07c8d 	sth	r3,498(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA1 = 0xFF28;
8110dec8:	d0a05317 	ldw	r2,-32436(gp)
8110decc:	00ffca04 	movi	r3,-216
8110ded0:	10c07d0d 	sth	r3,500(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA2 = 0xFF29;
8110ded4:	d0a05317 	ldw	r2,-32436(gp)
8110ded8:	00ffca44 	movi	r3,-215
8110dedc:	10c07d8d 	sth	r3,502(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA3 = 0xFF2A;
8110dee0:	d0a05317 	ldw	r2,-32436(gp)
8110dee4:	00ffca84 	movi	r3,-214
8110dee8:	10c07e0d 	sth	r3,504(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA4 = 0xFF2B;
8110deec:	d0a05317 	ldw	r2,-32436(gp)
8110def0:	00ffcac4 	movi	r3,-213
8110def4:	10c07e8d 	sth	r3,506(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA5 = 0xFF2C;
8110def8:	d0a05317 	ldw	r2,-32436(gp)
8110defc:	00ffcb04 	movi	r3,-212
8110df00:	10c07f0d 	sth	r3,508(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA6 = 0xFF2D;
8110df04:	d0a05317 	ldw	r2,-32436(gp)
8110df08:	00ffcb44 	movi	r3,-211
8110df0c:	10c07f8d 	sth	r3,510(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA7 = 0xFF2E;
8110df10:	d0a05317 	ldw	r2,-32436(gp)
8110df14:	00ffcb84 	movi	r3,-210
8110df18:	10c0800d 	sth	r3,512(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA8 = 0xFF2F;
8110df1c:	d0a05317 	ldw	r2,-32436(gp)
8110df20:	00ffcbc4 	movi	r3,-209
8110df24:	10c0808d 	sth	r3,514(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA9 = 0xFF30;
8110df28:	d0a05317 	ldw	r2,-32436(gp)
8110df2c:	00ffcc04 	movi	r3,-208
8110df30:	10c0810d 	sth	r3,516(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA10 = 0xFF31;
8110df34:	d0a05317 	ldw	r2,-32436(gp)
8110df38:	00ffcc44 	movi	r3,-207
8110df3c:	10c0818d 	sth	r3,518(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA11 = 0xFF32;
8110df40:	d0a05317 	ldw	r2,-32436(gp)
8110df44:	00ffcc84 	movi	r3,-206
8110df48:	10c0820d 	sth	r3,520(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA12 = 0xFF33;
8110df4c:	d0a05317 	ldw	r2,-32436(gp)
8110df50:	00ffccc4 	movi	r3,-205
8110df54:	10c0828d 	sth	r3,522(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA13 = 0xFF34;
8110df58:	d0a05317 	ldw	r2,-32436(gp)
8110df5c:	00ffcd04 	movi	r3,-204
8110df60:	10c0830d 	sth	r3,524(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA14 = 0xFF35;
8110df64:	d0a05317 	ldw	r2,-32436(gp)
8110df68:	00ffcd44 	movi	r3,-203
8110df6c:	10c0838d 	sth	r3,526(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA15 = 0xFF36;
8110df70:	d0a05317 	ldw	r2,-32436(gp)
8110df74:	00ffcd84 	movi	r3,-202
8110df78:	10c0840d 	sth	r3,528(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt0 = 0xFF37;
8110df7c:	d0a05317 	ldw	r2,-32436(gp)
8110df80:	00ffcdc4 	movi	r3,-201
8110df84:	10c0848d 	sth	r3,530(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt1 = 0xFF38;
8110df88:	d0a05317 	ldw	r2,-32436(gp)
8110df8c:	00ffce04 	movi	r3,-200
8110df90:	10c0850d 	sth	r3,532(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt2 = 0xFF39;
8110df94:	d0a05317 	ldw	r2,-32436(gp)
8110df98:	00ffce44 	movi	r3,-199
8110df9c:	10c0858d 	sth	r3,534(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt3 = 0xFF3A;
8110dfa0:	d0a05317 	ldw	r2,-32436(gp)
8110dfa4:	00ffce84 	movi	r3,-198
8110dfa8:	10c0860d 	sth	r3,536(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt4 = 0xFF3B;
8110dfac:	d0a05317 	ldw	r2,-32436(gp)
8110dfb0:	00ffcec4 	movi	r3,-197
8110dfb4:	10c0868d 	sth	r3,538(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt5 = 0xFF3C;
8110dfb8:	d0a05317 	ldw	r2,-32436(gp)
8110dfbc:	00ffcf04 	movi	r3,-196
8110dfc0:	10c0870d 	sth	r3,540(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt6 = 0xFF3D;
8110dfc4:	d0a05317 	ldw	r2,-32436(gp)
8110dfc8:	00ffcf44 	movi	r3,-195
8110dfcc:	10c0878d 	sth	r3,542(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt7 = 0xFF3E;
8110dfd0:	d0a05317 	ldw	r2,-32436(gp)
8110dfd4:	00ffcf84 	movi	r3,-194
8110dfd8:	10c0880d 	sth	r3,544(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiZeroHiresAmp = 0xFF3F;
8110dfdc:	d0a05317 	ldw	r2,-32436(gp)
8110dfe0:	00ffcfc4 	movi	r3,-193
8110dfe4:	10c0888d 	sth	r3,546(r2)
				bRmapSetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110dfe8:	d0a05317 	ldw	r2,-32436(gp)
8110dfec:	10804304 	addi	r2,r2,268
8110dff0:	1009883a 	mov	r4,r2
8110dff4:	11084c40 	call	811084c4 <bRmapSetRmapMemHKArea>


				vLoadCtemp();
8110dff8:	1110ea00 	call	81110ea0 <vLoadCtemp>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110dffc:	d0a05317 	ldw	r2,-32436(gp)
8110e000:	10804304 	addi	r2,r2,268
8110e004:	1009883a 	mov	r4,r2
8110e008:	11095100 	call	81109510 <bRmapGetRmapMemHKArea>
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;
8110e00c:	d0a05317 	ldw	r2,-32436(gp)
8110e010:	10806904 	addi	r2,r2,420
8110e014:	e0bff915 	stw	r2,-28(fp)

#ifdef DEBUG_ON
				fprintf(fp,"\n\n================= H  K ==================\n");
8110e018:	d0a06117 	ldw	r2,-32380(gp)
8110e01c:	100f883a 	mov	r7,r2
8110e020:	01800b04 	movi	r6,44
8110e024:	01400044 	movi	r5,1
8110e028:	01204574 	movhi	r4,33045
8110e02c:	212e0204 	addi	r4,r4,-18424
8110e030:	1120e540 	call	81120e54 <fwrite>

				for (ucIL = 0; ucIL < 64; ++ucIL) {
8110e034:	e03ffa05 	stb	zero,-24(fp)
8110e038:	00001606 	br	8110e094 <vFeeTask+0x574>
					fprintf(fp,"   - %s = %04x \n", cTemp[ucIL] , *pusiHK);
8110e03c:	d1206117 	ldw	r4,-32380(gp)
8110e040:	e0fffa03 	ldbu	r3,-24(fp)
8110e044:	00a04574 	movhi	r2,33045
8110e048:	108afb04 	addi	r2,r2,11244
8110e04c:	18c7883a 	add	r3,r3,r3
8110e050:	18c7883a 	add	r3,r3,r3
8110e054:	10c5883a 	add	r2,r2,r3
8110e058:	10c00017 	ldw	r3,0(r2)
8110e05c:	e0bff917 	ldw	r2,-28(fp)
8110e060:	1080000b 	ldhu	r2,0(r2)
8110e064:	10bfffcc 	andi	r2,r2,65535
8110e068:	100f883a 	mov	r7,r2
8110e06c:	180d883a 	mov	r6,r3
8110e070:	01604574 	movhi	r5,33045
8110e074:	296e0e04 	addi	r5,r5,-18376
8110e078:	11207b80 	call	811207b8 <fprintf>
					pusiHK++;
8110e07c:	e0bff917 	ldw	r2,-28(fp)
8110e080:	10800084 	addi	r2,r2,2
8110e084:	e0bff915 	stw	r2,-28(fp)
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;

#ifdef DEBUG_ON
				fprintf(fp,"\n\n================= H  K ==================\n");

				for (ucIL = 0; ucIL < 64; ++ucIL) {
8110e088:	e0bffa03 	ldbu	r2,-24(fp)
8110e08c:	10800044 	addi	r2,r2,1
8110e090:	e0bffa05 	stb	r2,-24(fp)
8110e094:	e0bffa03 	ldbu	r2,-24(fp)
8110e098:	10801030 	cmpltui	r2,r2,64
8110e09c:	103fe71e 	bne	r2,zero,8110e03c <__reset+0xfb0ee03c>
					fprintf(fp,"   - %s = %04x \n", cTemp[ucIL] , *pusiHK);
					pusiHK++;
				}
				fprintf(fp,"\n================= H  K ==================\n\n");
8110e0a0:	d0a06117 	ldw	r2,-32380(gp)
8110e0a4:	100f883a 	mov	r7,r2
8110e0a8:	01800b04 	movi	r6,44
8110e0ac:	01400044 	movi	r5,1
8110e0b0:	01204574 	movhi	r4,33045
8110e0b4:	212e1304 	addi	r4,r4,-18356
8110e0b8:	1120e540 	call	81120e54 <fwrite>
#endif

				/* Change the configuration */
				bRmapGetCodecConfig( &pxNFee->xChannel.xRmap );
8110e0bc:	d0a05317 	ldw	r2,-32436(gp)
8110e0c0:	10804304 	addi	r2,r2,268
8110e0c4:	1009883a 	mov	r4,r2
8110e0c8:	1107b240 	call	81107b24 <bRmapGetCodecConfig>
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char) xDefaults.ucRmapKey ;
8110e0cc:	d0e05317 	ldw	r3,-32436(gp)
8110e0d0:	00a045b4 	movhi	r2,33046
8110e0d4:	10975904 	addi	r2,r2,23908
8110e0d8:	10800c0b 	ldhu	r2,48(r2)
8110e0dc:	18804405 	stb	r2,272(r3)
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char) xDefaults.ucLogicalAddr;
8110e0e0:	d0e05317 	ldw	r3,-32436(gp)
8110e0e4:	00a045b4 	movhi	r2,33046
8110e0e8:	10975904 	addi	r2,r2,23908
8110e0ec:	10800c8b 	ldhu	r2,50(r2)
8110e0f0:	18804445 	stb	r2,273(r3)
				bRmapSetCodecConfig( &pxNFee->xChannel.xRmap );
8110e0f4:	d0a05317 	ldw	r2,-32436(gp)
8110e0f8:	10804304 	addi	r2,r2,268
8110e0fc:	1009883a 	mov	r4,r2
8110e100:	1107a4c0 	call	81107a4c <bRmapSetCodecConfig>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task. RMAP KEY = %hu\n", xDefaults.ucRmapKey );
8110e104:	d0e06117 	ldw	r3,-32380(gp)
8110e108:	00a045b4 	movhi	r2,33046
8110e10c:	10975904 	addi	r2,r2,23908
8110e110:	10800c0b 	ldhu	r2,48(r2)
8110e114:	10bfffcc 	andi	r2,r2,65535
8110e118:	100d883a 	mov	r6,r2
8110e11c:	01604574 	movhi	r5,33045
8110e120:	296e1f04 	addi	r5,r5,-18308
8110e124:	1809883a 	mov	r4,r3
8110e128:	11207b80 	call	811207b8 <fprintf>
					fprintf(fp,"NFEE %hhu Task. Log. Addr. = %hu \n", xDefaults.ucLogicalAddr);
8110e12c:	d0e06117 	ldw	r3,-32380(gp)
8110e130:	00a045b4 	movhi	r2,33046
8110e134:	10975904 	addi	r2,r2,23908
8110e138:	10800c8b 	ldhu	r2,50(r2)
8110e13c:	10bfffcc 	andi	r2,r2,65535
8110e140:	100d883a 	mov	r6,r2
8110e144:	01604574 	movhi	r5,33045
8110e148:	296e2704 	addi	r5,r5,-18276
8110e14c:	1809883a 	mov	r4,r3
8110e150:	11207b80 	call	811207b8 <fprintf>
				#endif

				pxNFee->xControl.eMode = sToFeeConfig;
8110e154:	d0a05317 	ldw	r2,-32436(gp)
8110e158:	00c00144 	movi	r3,5
8110e15c:	10c02c15 	stw	r3,176(r2)

				break;
8110e160:	0003ba06 	br	8110f04c <vFeeTask+0x152c>
			case sToFeeConfig: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e164:	d0a05317 	ldw	r2,-32436(gp)
8110e168:	10804304 	addi	r2,r2,268
8110e16c:	1009883a 	mov	r4,r2
8110e170:	110815c0 	call	8110815c <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /*Off*/
8110e174:	d0a05317 	ldw	r2,-32436(gp)
8110e178:	00c00184 	movi	r3,6
8110e17c:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e180:	d0a05317 	ldw	r2,-32436(gp)
8110e184:	10804304 	addi	r2,r2,268
8110e188:	1009883a 	mov	r4,r2
8110e18c:	1107e700 	call	81107e70 <bRmapSetMemConfigArea>

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110e190:	d0a05317 	ldw	r2,-32436(gp)
8110e194:	10808904 	addi	r2,r2,548
8110e198:	1009883a 	mov	r4,r2
8110e19c:	11102440 	call	81110244 <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
8110e1a0:	d0a05317 	ldw	r2,-32436(gp)
8110e1a4:	10002615 	stw	zero,152(r2)

				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
8110e1a8:	d0a05317 	ldw	r2,-32436(gp)
8110e1ac:	10c04304 	addi	r3,r2,268
8110e1b0:	d0a05317 	ldw	r2,-32436(gp)
8110e1b4:	10800003 	ldbu	r2,0(r2)
8110e1b8:	10803fcc 	andi	r2,r2,255
8110e1bc:	100b883a 	mov	r5,r2
8110e1c0:	1809883a 	mov	r4,r3
8110e1c4:	11101980 	call	81110198 <bDisableRmapIRQ>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e1c8:	d0a05317 	ldw	r2,-32436(gp)
8110e1cc:	10803b04 	addi	r2,r2,236
8110e1d0:	1009883a 	mov	r4,r2
8110e1d4:	111038c0 	call	8111038c <bDisAndClrDbBuffer>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
8110e1d8:	d0e06117 	ldw	r3,-32380(gp)
8110e1dc:	d0a05317 	ldw	r2,-32436(gp)
8110e1e0:	10800003 	ldbu	r2,0(r2)
8110e1e4:	10803fcc 	andi	r2,r2,255
8110e1e8:	100d883a 	mov	r6,r2
8110e1ec:	01604574 	movhi	r5,33045
8110e1f0:	296e3004 	addi	r5,r5,-18240
8110e1f4:	1809883a 	mov	r4,r3
8110e1f8:	11207b80 	call	811207b8 <fprintf>
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
8110e1fc:	d0a05317 	ldw	r2,-32436(gp)
8110e200:	10802217 	ldw	r2,136(r2)
8110e204:	10800058 	cmpnei	r2,r2,1
8110e208:	10000a1e 	bne	r2,zero,8110e234 <vFeeTask+0x714>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110e20c:	e0fff403 	ldbu	r3,-48(fp)
8110e210:	00a045b4 	movhi	r2,33046
8110e214:	108a9d04 	addi	r2,r2,10868
8110e218:	180690fa 	slli	r3,r3,3
8110e21c:	10c5883a 	add	r2,r2,r3
8110e220:	10800017 	ldw	r2,0(r2)
8110e224:	1009883a 	mov	r4,r2
8110e228:	113c26c0 	call	8113c26c <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
8110e22c:	d0a05317 	ldw	r2,-32436(gp)
8110e230:	10002215 	stw	zero,136(r2)
				}

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110e234:	d0a05317 	ldw	r2,-32436(gp)
8110e238:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e23c:	d0a05317 	ldw	r2,-32436(gp)
8110e240:	10800003 	ldbu	r2,0(r2)
8110e244:	10803fcc 	andi	r2,r2,255
8110e248:	1085883a 	add	r2,r2,r2
8110e24c:	1087883a 	add	r3,r2,r2
8110e250:	d0a05b04 	addi	r2,gp,-32404
8110e254:	1885883a 	add	r2,r3,r2
8110e258:	10800017 	ldw	r2,0(r2)
8110e25c:	1009883a 	mov	r4,r2
8110e260:	113cd1c0 	call	8113cd1c <OSQFlush>
8110e264:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e268:	e0bffd03 	ldbu	r2,-12(fp)
8110e26c:	10803fcc 	andi	r2,r2,255
8110e270:	10000126 	beq	r2,zero,8110e278 <vFeeTask+0x758>
					vFailFlushNFEEQueue();
8110e274:	111c9c00 	call	8111c9c0 <vFailFlushNFEEQueue>
				}

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110e278:	d0a05317 	ldw	r2,-32436(gp)
8110e27c:	10800003 	ldbu	r2,0(r2)
8110e280:	10803fcc 	andi	r2,r2,255
8110e284:	100d883a 	mov	r6,r2
8110e288:	000b883a 	mov	r5,zero
8110e28c:	01002044 	movi	r4,129
8110e290:	11104940 	call	81110494 <bSendGiveBackNFeeCtrl>

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
8110e294:	d0a05317 	ldw	r2,-32436(gp)
8110e298:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
8110e29c:	d0a05317 	ldw	r2,-32436(gp)
8110e2a0:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110e2a4:	d0a05317 	ldw	r2,-32436(gp)
8110e2a8:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110e2ac:	d0a05317 	ldw	r2,-32436(gp)
8110e2b0:	00c00044 	movi	r3,1
8110e2b4:	10c02115 	stw	r3,132(r2)

				vResetMemCCDFEE(pxNFee);
8110e2b8:	d0a05317 	ldw	r2,-32436(gp)
8110e2bc:	1009883a 	mov	r4,r2
8110e2c0:	111cff40 	call	8111cff4 <vResetMemCCDFEE>

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110e2c4:	d0a05317 	ldw	r2,-32436(gp)
8110e2c8:	10800003 	ldbu	r2,0(r2)
8110e2cc:	10803fcc 	andi	r2,r2,255
8110e2d0:	1085883a 	add	r2,r2,r2
8110e2d4:	1087883a 	add	r3,r2,r2
8110e2d8:	d0a06904 	addi	r2,gp,-32348
8110e2dc:	1885883a 	add	r2,r3,r2
8110e2e0:	10800017 	ldw	r2,0(r2)
8110e2e4:	1009883a 	mov	r4,r2
8110e2e8:	113cd1c0 	call	8113cd1c <OSQFlush>
8110e2ec:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e2f0:	e0bffd03 	ldbu	r2,-12(fp)
8110e2f4:	10803fcc 	andi	r2,r2,255
8110e2f8:	10000126 	beq	r2,zero,8110e300 <vFeeTask+0x7e0>
					vFailFlushNFEEQueue();
8110e2fc:	111c9c00 	call	8111c9c0 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bWatingSync = TRUE;
8110e300:	d0a05317 	ldw	r2,-32436(gp)
8110e304:	00c00044 	movi	r3,1
8110e308:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeConfig;
8110e30c:	d0a05317 	ldw	r2,-32436(gp)
8110e310:	00c00044 	movi	r3,1
8110e314:	10c02c15 	stw	r3,176(r2)
				bFinal = FALSE;
8110e318:	e03ff815 	stw	zero,-32(fp)
				break;
8110e31c:	00034b06 	br	8110f04c <vFeeTask+0x152c>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e320:	d0a05317 	ldw	r2,-32436(gp)
8110e324:	10800003 	ldbu	r2,0(r2)
8110e328:	10803fcc 	andi	r2,r2,255
8110e32c:	1085883a 	add	r2,r2,r2
8110e330:	1087883a 	add	r3,r2,r2
8110e334:	d0a06904 	addi	r2,gp,-32348
8110e338:	1885883a 	add	r2,r3,r2
8110e33c:	10800017 	ldw	r2,0(r2)
8110e340:	e0fffd04 	addi	r3,fp,-12
8110e344:	180d883a 	mov	r6,r3
8110e348:	000b883a 	mov	r5,zero
8110e34c:	1009883a 	mov	r4,r2
8110e350:	113cddc0 	call	8113cddc <OSQPend>
8110e354:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110e358:	e0bffd03 	ldbu	r2,-12(fp)
8110e35c:	10803fcc 	andi	r2,r2,255
8110e360:	1000061e 	bne	r2,zero,8110e37c <vFeeTask+0x85c>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8110e364:	d0a05317 	ldw	r2,-32436(gp)
8110e368:	e0fffe17 	ldw	r3,-8(fp)
8110e36c:	180b883a 	mov	r5,r3
8110e370:	1009883a 	mov	r4,r2
8110e374:	110f2380 	call	8110f238 <vQCmdFEEinConfig>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e378:	00033406 	br	8110f04c <vFeeTask+0x152c>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110e37c:	d0e06117 	ldw	r3,-32380(gp)
8110e380:	d0a05317 	ldw	r2,-32436(gp)
8110e384:	10800003 	ldbu	r2,0(r2)
8110e388:	10803fcc 	andi	r2,r2,255
8110e38c:	100d883a 	mov	r6,r2
8110e390:	01604574 	movhi	r5,33045
8110e394:	296e3704 	addi	r5,r5,-18212
8110e398:	1809883a 	mov	r4,r3
8110e39c:	11207b80 	call	811207b8 <fprintf>
					#endif
				}

				break;
8110e3a0:	00032a06 	br	8110f04c <vFeeTask+0x152c>
			case sFeeOn: /* Not implemented yet */

				pxNFee->xControl.eMode = sToFeeStandBy;
8110e3a4:	d0a05317 	ldw	r2,-32436(gp)
8110e3a8:	00c00184 	movi	r3,6
8110e3ac:	10c02c15 	stw	r3,176(r2)
				break;
8110e3b0:	00032606 	br	8110f04c <vFeeTask+0x152c>
			case sToFeeStandBy: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e3b4:	d0a05317 	ldw	r2,-32436(gp)
8110e3b8:	10804304 	addi	r2,r2,268
8110e3bc:	1009883a 	mov	r4,r2
8110e3c0:	110815c0 	call	8110815c <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00; /*sToFeeStandBy*/
8110e3c4:	d0a05317 	ldw	r2,-32436(gp)
8110e3c8:	10006615 	stw	zero,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e3cc:	d0a05317 	ldw	r2,-32436(gp)
8110e3d0:	10804304 	addi	r2,r2,268
8110e3d4:	1009883a 	mov	r4,r2
8110e3d8:	1107e700 	call	81107e70 <bRmapSetMemConfigArea>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e3dc:	d0a05317 	ldw	r2,-32436(gp)
8110e3e0:	10803b04 	addi	r2,r2,236
8110e3e4:	1009883a 	mov	r4,r2
8110e3e8:	111038c0 	call	8111038c <bDisAndClrDbBuffer>

				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
8110e3ec:	d0a05317 	ldw	r2,-32436(gp)
8110e3f0:	10c04304 	addi	r3,r2,268
8110e3f4:	d0a05317 	ldw	r2,-32436(gp)
8110e3f8:	10800003 	ldbu	r2,0(r2)
8110e3fc:	10803fcc 	andi	r2,r2,255
8110e400:	100b883a 	mov	r5,r2
8110e404:	1809883a 	mov	r4,r3
8110e408:	11101ec0 	call	811101ec <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110e40c:	d0a05317 	ldw	r2,-32436(gp)
8110e410:	10808904 	addi	r2,r2,548
8110e414:	1009883a 	mov	r4,r2
8110e418:	11102a40 	call	811102a4 <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
8110e41c:	d0a05317 	ldw	r2,-32436(gp)
8110e420:	00c00044 	movi	r3,1
8110e424:	10c02615 	stw	r3,152(r2)

				pxNFee->xControl.bSimulating = TRUE;
8110e428:	d0a05317 	ldw	r2,-32436(gp)
8110e42c:	00c00044 	movi	r3,1
8110e430:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110e434:	d0a05317 	ldw	r2,-32436(gp)
8110e438:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110e43c:	d0a05317 	ldw	r2,-32436(gp)
8110e440:	00c00044 	movi	r3,1
8110e444:	10c02115 	stw	r3,132(r2)

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110e448:	d0a05317 	ldw	r2,-32436(gp)
8110e44c:	10800003 	ldbu	r2,0(r2)
8110e450:	10803fcc 	andi	r2,r2,255
8110e454:	100d883a 	mov	r6,r2
8110e458:	000b883a 	mov	r5,zero
8110e45c:	01002044 	movi	r4,129
8110e460:	11104940 	call	81110494 <bSendGiveBackNFeeCtrl>

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110e464:	d0a05317 	ldw	r2,-32436(gp)
8110e468:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e46c:	d0a05317 	ldw	r2,-32436(gp)
8110e470:	10800003 	ldbu	r2,0(r2)
8110e474:	10803fcc 	andi	r2,r2,255
8110e478:	1085883a 	add	r2,r2,r2
8110e47c:	1087883a 	add	r3,r2,r2
8110e480:	d0a05b04 	addi	r2,gp,-32404
8110e484:	1885883a 	add	r2,r3,r2
8110e488:	10800017 	ldw	r2,0(r2)
8110e48c:	1009883a 	mov	r4,r2
8110e490:	113cd1c0 	call	8113cd1c <OSQFlush>
8110e494:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e498:	e0bffd03 	ldbu	r2,-12(fp)
8110e49c:	10803fcc 	andi	r2,r2,255
8110e4a0:	10000126 	beq	r2,zero,8110e4a8 <vFeeTask+0x988>
					vFailFlushNFEEQueue();
8110e4a4:	111c9c00 	call	8111c9c0 <vFailFlushNFEEQueue>
				}

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Standby Mode\n", pxNFee->ucId);
8110e4a8:	d0e06117 	ldw	r3,-32380(gp)
8110e4ac:	d0a05317 	ldw	r2,-32436(gp)
8110e4b0:	10800003 	ldbu	r2,0(r2)
8110e4b4:	10803fcc 	andi	r2,r2,255
8110e4b8:	100d883a 	mov	r6,r2
8110e4bc:	01604574 	movhi	r5,33045
8110e4c0:	296e4304 	addi	r5,r5,-18164
8110e4c4:	1809883a 	mov	r4,r3
8110e4c8:	11207b80 	call	811207b8 <fprintf>
				#endif

				/* Reset the memory addr variables thats is used in the transmission*/
				vResetMemCCDFEE(pxNFee);
8110e4cc:	d0a05317 	ldw	r2,-32436(gp)
8110e4d0:	1009883a 	mov	r4,r2
8110e4d4:	111cff40 	call	8111cff4 <vResetMemCCDFEE>

				incrementador = 0;
8110e4d8:	d0205415 	stw	zero,-32432(gp)

				pxNFee->xControl.bWatingSync = TRUE;
8110e4dc:	d0a05317 	ldw	r2,-32436(gp)
8110e4e0:	00c00044 	movi	r3,1
8110e4e4:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeStandBy;
8110e4e8:	d0a05317 	ldw	r2,-32436(gp)
8110e4ec:	00c000c4 	movi	r3,3
8110e4f0:	10c02c15 	stw	r3,176(r2)
				break;
8110e4f4:	0002d506 	br	8110f04c <vFeeTask+0x152c>


			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e4f8:	d0a05317 	ldw	r2,-32436(gp)
8110e4fc:	10800003 	ldbu	r2,0(r2)
8110e500:	10803fcc 	andi	r2,r2,255
8110e504:	1085883a 	add	r2,r2,r2
8110e508:	1087883a 	add	r3,r2,r2
8110e50c:	d0a06904 	addi	r2,gp,-32348
8110e510:	1885883a 	add	r2,r3,r2
8110e514:	10800017 	ldw	r2,0(r2)
8110e518:	e0fffd04 	addi	r3,fp,-12
8110e51c:	180d883a 	mov	r6,r3
8110e520:	000b883a 	mov	r5,zero
8110e524:	1009883a 	mov	r4,r2
8110e528:	113cddc0 	call	8113cddc <OSQPend>
8110e52c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110e530:	e0bffd03 	ldbu	r2,-12(fp)
8110e534:	10803fcc 	andi	r2,r2,255
8110e538:	1000061e 	bne	r2,zero,8110e554 <vFeeTask+0xa34>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
8110e53c:	d0a05317 	ldw	r2,-32436(gp)
8110e540:	e0fffe17 	ldw	r3,-8(fp)
8110e544:	180b883a 	mov	r5,r3
8110e548:	1009883a 	mov	r4,r2
8110e54c:	110f3fc0 	call	8110f3fc <vQCmdFEEinStandBy>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e550:	0002be06 	br	8110f04c <vFeeTask+0x152c>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110e554:	d0e06117 	ldw	r3,-32380(gp)
8110e558:	d0a05317 	ldw	r2,-32436(gp)
8110e55c:	10800003 	ldbu	r2,0(r2)
8110e560:	10803fcc 	andi	r2,r2,255
8110e564:	100d883a 	mov	r6,r2
8110e568:	01604574 	movhi	r5,33045
8110e56c:	296e3704 	addi	r5,r5,-18212
8110e570:	1809883a 	mov	r4,r3
8110e574:	11207b80 	call	811207b8 <fprintf>
					#endif
				}

				break;
8110e578:	0002b406 	br	8110f04c <vFeeTask+0x152c>


			case sNextPatternIteration:


				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110e57c:	d0a05317 	ldw	r2,-32436(gp)
8110e580:	10800003 	ldbu	r2,0(r2)
8110e584:	10803fcc 	andi	r2,r2,255
8110e588:	1085883a 	add	r2,r2,r2
8110e58c:	1087883a 	add	r3,r2,r2
8110e590:	d0a05b04 	addi	r2,gp,-32404
8110e594:	1885883a 	add	r2,r3,r2
8110e598:	10800017 	ldw	r2,0(r2)
8110e59c:	1009883a 	mov	r4,r2
8110e5a0:	113cd1c0 	call	8113cd1c <OSQFlush>
8110e5a4:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110e5a8:	e0bffd03 	ldbu	r2,-12(fp)
8110e5ac:	10803fcc 	andi	r2,r2,255
8110e5b0:	10000126 	beq	r2,zero,8110e5b8 <vFeeTask+0xa98>
					vFailFlushNFEEQueue();
8110e5b4:	111c9c00 	call	8111c9c0 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bUsingDMA = TRUE;
8110e5b8:	d0a05317 	ldw	r2,-32436(gp)
8110e5bc:	00c00044 	movi	r3,1
8110e5c0:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110e5c4:	d0a05317 	ldw	r2,-32436(gp)
8110e5c8:	00c00044 	movi	r3,1
8110e5cc:	10c02715 	stw	r3,156(r2)

				vResetMemCCDFEE(pxNFee);
8110e5d0:	d0a05317 	ldw	r2,-32436(gp)
8110e5d4:	1009883a 	mov	r4,r2
8110e5d8:	111cff40 	call	8111cff4 <vResetMemCCDFEE>

				bFeebCh1SetBufferSize(SDMA_MAX_BLOCKS,0);
8110e5dc:	000b883a 	mov	r5,zero
8110e5e0:	01000404 	movi	r4,16
8110e5e4:	11059a40 	call	811059a4 <bFeebCh1SetBufferSize>
				bFeebCh1SetBufferSize(SDMA_MAX_BLOCKS,1);
8110e5e8:	01400044 	movi	r5,1
8110e5ec:	01000404 	movi	r4,16
8110e5f0:	11059a40 	call	811059a4 <bFeebCh1SetBufferSize>

				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110e5f4:	d0a05317 	ldw	r2,-32436(gp)
8110e5f8:	10803b04 	addi	r2,r2,236
8110e5fc:	1009883a 	mov	r4,r2
8110e600:	11103040 	call	81110304 <bEnableDbBuffer>


				bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire);
8110e604:	d0a05317 	ldw	r2,-32436(gp)
8110e608:	10808904 	addi	r2,r2,548
8110e60c:	1009883a 	mov	r4,r2
8110e610:	110a5680 	call	8110a568 <bSpwcGetTimecode>
				tCodFeeTask = pxNFee->xChannel.xSpacewire.xTimecode.ucCounter;
8110e614:	d0a05317 	ldw	r2,-32436(gp)
8110e618:	10809543 	ldbu	r2,597(r2)
8110e61c:	10803fcc 	andi	r2,r2,255
8110e620:	d0a05515 	stw	r2,-32428(gp)
				tCodeNext = ( tCodFeeTask + 1) % 4;
8110e624:	d0a05517 	ldw	r2,-32428(gp)
8110e628:	10800044 	addi	r2,r2,1
8110e62c:	108000cc 	andi	r2,r2,3
8110e630:	e0bffc15 	stw	r2,-16(fp)
				if ( tCodeNext == 0 ) {
8110e634:	e0bffc17 	ldw	r2,-16(fp)
8110e638:	10000f1e 	bne	r2,zero,8110e678 <vFeeTask+0xb58>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
8110e63c:	d0a05317 	ldw	r2,-32436(gp)
8110e640:	10802917 	ldw	r2,164(r2)
8110e644:	10800003 	ldbu	r2,0(r2)
8110e648:	10803fcc 	andi	r2,r2,255
8110e64c:	10c00044 	addi	r3,r2,1
8110e650:	00a00034 	movhi	r2,32768
8110e654:	10800044 	addi	r2,r2,1
8110e658:	1884703a 	and	r2,r3,r2
8110e65c:	1000040e 	bge	r2,zero,8110e670 <vFeeTask+0xb50>
8110e660:	10bfffc4 	addi	r2,r2,-1
8110e664:	00ffff84 	movi	r3,-2
8110e668:	10c4b03a 	or	r2,r2,r3
8110e66c:	10800044 	addi	r2,r2,1
8110e670:	e0bff405 	stb	r2,-48(fp)
8110e674:	00000406 	br	8110e688 <vFeeTask+0xb68>
				} else {
					ucMemUsing = (unsigned char) *pxNFee->xControl.pActualMem ; /* Select the of the data control (te future)*/
8110e678:	d0a05317 	ldw	r2,-32436(gp)
8110e67c:	10802917 	ldw	r2,164(r2)
8110e680:	10800003 	ldbu	r2,0(r2)
8110e684:	e0bff405 	stb	r2,-48(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
8110e688:	d0e05317 	ldw	r3,-32436(gp)
8110e68c:	e0bffc17 	ldw	r2,-16(fp)
8110e690:	1885883a 	add	r2,r3,r2
8110e694:	10802a44 	addi	r2,r2,169
8110e698:	10800003 	ldbu	r2,0(r2)
8110e69c:	e0bff605 	stb	r2,-40(fp)

				if ( pxNFee->xControl.eSide == sLeft )
8110e6a0:	d0a05317 	ldw	r2,-32436(gp)
8110e6a4:	10802e17 	ldw	r2,184(r2)
8110e6a8:	1000071e 	bne	r2,zero,8110e6c8 <vFeeTask+0xba8>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
8110e6ac:	d0e05317 	ldw	r3,-32436(gp)
8110e6b0:	e0bff603 	ldbu	r2,-40(fp)
8110e6b4:	10800624 	muli	r2,r2,24
8110e6b8:	10800904 	addi	r2,r2,36
8110e6bc:	1885883a 	add	r2,r3,r2
8110e6c0:	e0bff515 	stw	r2,-44(fp)
8110e6c4:	00000606 	br	8110e6e0 <vFeeTask+0xbc0>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
8110e6c8:	d0e05317 	ldw	r3,-32436(gp)
8110e6cc:	e0bff603 	ldbu	r2,-40(fp)
8110e6d0:	10800624 	muli	r2,r2,24
8110e6d4:	10800c04 	addi	r2,r2,48
8110e6d8:	1885883a 	add	r2,r3,r2
8110e6dc:	e0bff515 	stw	r2,-44(fp)


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e6e0:	d0a05317 	ldw	r2,-32436(gp)
8110e6e4:	10803304 	addi	r2,r2,204
8110e6e8:	1009883a 	mov	r4,r2
8110e6ec:	1104a440 	call	81104a44 <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8110e6f0:	d0a05317 	ldw	r2,-32436(gp)
8110e6f4:	e0fff603 	ldbu	r3,-40(fp)
8110e6f8:	10c036c5 	stb	r3,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110e6fc:	d0a05317 	ldw	r2,-32436(gp)
8110e700:	00c00044 	movi	r3,1
8110e704:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110e708:	d0a05317 	ldw	r2,-32436(gp)
8110e70c:	10803304 	addi	r2,r2,204
8110e710:	1009883a 	mov	r4,r2
8110e714:	11048180 	call	81104818 <bDpktSetPacketConfig>


				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
8110e718:	d0a05317 	ldw	r2,-32436(gp)
8110e71c:	10800003 	ldbu	r2,0(r2)
8110e720:	10803fcc 	andi	r2,r2,255
8110e724:	100d883a 	mov	r6,r2
8110e728:	000b883a 	mov	r5,zero
8110e72c:	01002004 	movi	r4,128
8110e730:	11103f00 	call	811103f0 <bSendRequestNFeeCtrl>
				bDmaReturn = FALSE;
8110e734:	e03ff715 	stw	zero,-36(fp)
				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e738:	d0a05317 	ldw	r2,-32436(gp)
8110e73c:	10800003 	ldbu	r2,0(r2)
8110e740:	10803fcc 	andi	r2,r2,255
8110e744:	1085883a 	add	r2,r2,r2
8110e748:	1087883a 	add	r3,r2,r2
8110e74c:	d0a06904 	addi	r2,gp,-32348
8110e750:	1885883a 	add	r2,r3,r2
8110e754:	10800017 	ldw	r2,0(r2)
8110e758:	e0fffd04 	addi	r3,fp,-12
8110e75c:	180d883a 	mov	r6,r3
8110e760:	000b883a 	mov	r5,zero
8110e764:	1009883a 	mov	r4,r2
8110e768:	113cddc0 	call	8113cddc <OSQPend>
8110e76c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110e770:	e0bffd03 	ldbu	r2,-12(fp)
8110e774:	10803fcc 	andi	r2,r2,255
8110e778:	1000cd1e 	bne	r2,zero,8110eab0 <vFeeTask+0xf90>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110e77c:	e0bffe83 	ldbu	r2,-6(fp)
8110e780:	10803fcc 	andi	r2,r2,255
8110e784:	108023d8 	cmpnei	r2,r2,143
8110e788:	1000c31e 	bne	r2,zero,8110ea98 <vFeeTask+0xf78>

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110e78c:	e0fff403 	ldbu	r3,-48(fp)
8110e790:	00a045b4 	movhi	r2,33046
8110e794:	108a9d04 	addi	r2,r2,10868
8110e798:	180690fa 	slli	r3,r3,3
8110e79c:	10c5883a 	add	r2,r2,r3
8110e7a0:	10800017 	ldw	r2,0(r2)
8110e7a4:	e0fffd04 	addi	r3,fp,-12
8110e7a8:	180d883a 	mov	r6,r3
8110e7ac:	000b883a 	mov	r5,zero
8110e7b0:	1009883a 	mov	r4,r2
8110e7b4:	113bcc80 	call	8113bcc8 <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
8110e7b8:	e0bffd03 	ldbu	r2,-12(fp)
8110e7bc:	10803fcc 	andi	r2,r2,255
8110e7c0:	1000c41e 	bne	r2,zero,8110ead4 <vFeeTask+0xfb4>
	                    	pxNFee->xControl.bDMALocked = TRUE;
8110e7c4:	d0a05317 	ldw	r2,-32436(gp)
8110e7c8:	00c00044 	movi	r3,1
8110e7cc:	10c02215 	stw	r3,136(r2)

							if (  ucMemUsing == 0  ) {
8110e7d0:	e0bff403 	ldbu	r2,-48(fp)
8110e7d4:	1000471e 	bne	r2,zero,8110e8f4 <vFeeTask+0xdd4>
								/* Initializing the addr */
								xCcdMapLocal->ulBlockI = 0;
8110e7d8:	e0bff517 	ldw	r2,-44(fp)
8110e7dc:	10000115 	stw	zero,4(r2)
								xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
8110e7e0:	e0bff517 	ldw	r2,-44(fp)
8110e7e4:	10c00017 	ldw	r3,0(r2)
8110e7e8:	e0bff517 	ldw	r2,-44(fp)
8110e7ec:	10c00215 	stw	r3,8(r2)
								bDmaReturn = bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110e7f0:	e0bff517 	ldw	r2,-44(fp)
8110e7f4:	10800217 	ldw	r2,8(r2)
8110e7f8:	1009883a 	mov	r4,r2
8110e7fc:	d0a05317 	ldw	r2,-32436(gp)
8110e800:	10802e17 	ldw	r2,184(r2)
8110e804:	10c03fcc 	andi	r3,r2,255
8110e808:	d0a05317 	ldw	r2,-32436(gp)
8110e80c:	10800003 	ldbu	r2,0(r2)
8110e810:	10803fcc 	andi	r2,r2,255
8110e814:	100f883a 	mov	r7,r2
8110e818:	180d883a 	mov	r6,r3
8110e81c:	01400404 	movi	r5,16
8110e820:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
8110e824:	e0bff715 	stw	r2,-36(fp)
								if ( bDmaReturn == TRUE ) {
8110e828:	e0bff717 	ldw	r2,-36(fp)
8110e82c:	10800058 	cmpnei	r2,r2,1
8110e830:	1000251e 	bne	r2,zero,8110e8c8 <vFeeTask+0xda8>
									//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
									xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110e834:	e0bff517 	ldw	r2,-44(fp)
8110e838:	10800217 	ldw	r2,8(r2)
8110e83c:	10c22004 	addi	r3,r2,2176
8110e840:	e0bff517 	ldw	r2,-44(fp)
8110e844:	10c00215 	stw	r3,8(r2)
									xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110e848:	e0bff517 	ldw	r2,-44(fp)
8110e84c:	10800117 	ldw	r2,4(r2)
8110e850:	10c00404 	addi	r3,r2,16
8110e854:	e0bff517 	ldw	r2,-44(fp)
8110e858:	10c00115 	stw	r3,4(r2)
									bDmaReturn = bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110e85c:	e0bff517 	ldw	r2,-44(fp)
8110e860:	10800217 	ldw	r2,8(r2)
8110e864:	1009883a 	mov	r4,r2
8110e868:	d0a05317 	ldw	r2,-32436(gp)
8110e86c:	10802e17 	ldw	r2,184(r2)
8110e870:	10c03fcc 	andi	r3,r2,255
8110e874:	d0a05317 	ldw	r2,-32436(gp)
8110e878:	10800003 	ldbu	r2,0(r2)
8110e87c:	10803fcc 	andi	r2,r2,255
8110e880:	100f883a 	mov	r7,r2
8110e884:	180d883a 	mov	r6,r3
8110e888:	01400404 	movi	r5,16
8110e88c:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
8110e890:	e0bff715 	stw	r2,-36(fp)
									if ( bDmaReturn == TRUE ) {
8110e894:	e0bff717 	ldw	r2,-36(fp)
8110e898:	10800058 	cmpnei	r2,r2,1
8110e89c:	10000a1e 	bne	r2,zero,8110e8c8 <vFeeTask+0xda8>
										//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
										xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110e8a0:	e0bff517 	ldw	r2,-44(fp)
8110e8a4:	10800217 	ldw	r2,8(r2)
8110e8a8:	10c22004 	addi	r3,r2,2176
8110e8ac:	e0bff517 	ldw	r2,-44(fp)
8110e8b0:	10c00215 	stw	r3,8(r2)
										xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110e8b4:	e0bff517 	ldw	r2,-44(fp)
8110e8b8:	10800117 	ldw	r2,4(r2)
8110e8bc:	10c00404 	addi	r3,r2,16
8110e8c0:	e0bff517 	ldw	r2,-44(fp)
8110e8c4:	10c00115 	stw	r3,4(r2)

									}
								}
								OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110e8c8:	e0fff403 	ldbu	r3,-48(fp)
8110e8cc:	00a045b4 	movhi	r2,33046
8110e8d0:	108a9d04 	addi	r2,r2,10868
8110e8d4:	180690fa 	slli	r3,r3,3
8110e8d8:	10c5883a 	add	r2,r2,r3
8110e8dc:	10800017 	ldw	r2,0(r2)
8110e8e0:	1009883a 	mov	r4,r2
8110e8e4:	113c26c0 	call	8113c26c <OSMutexPost>
								pxNFee->xControl.bDMALocked = FALSE;
8110e8e8:	d0a05317 	ldw	r2,-32436(gp)
8110e8ec:	10002215 	stw	zero,136(r2)
8110e8f0:	00004606 	br	8110ea0c <vFeeTask+0xeec>
							} else {
								xCcdMapLocal->ulBlockI = 0;
8110e8f4:	e0bff517 	ldw	r2,-44(fp)
8110e8f8:	10000115 	stw	zero,4(r2)
								xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
8110e8fc:	e0bff517 	ldw	r2,-44(fp)
8110e900:	10c00017 	ldw	r3,0(r2)
8110e904:	e0bff517 	ldw	r2,-44(fp)
8110e908:	10c00215 	stw	r3,8(r2)
								bDmaReturn = bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110e90c:	e0bff517 	ldw	r2,-44(fp)
8110e910:	10800217 	ldw	r2,8(r2)
8110e914:	1009883a 	mov	r4,r2
8110e918:	d0a05317 	ldw	r2,-32436(gp)
8110e91c:	10802e17 	ldw	r2,184(r2)
8110e920:	10c03fcc 	andi	r3,r2,255
8110e924:	d0a05317 	ldw	r2,-32436(gp)
8110e928:	10800003 	ldbu	r2,0(r2)
8110e92c:	10803fcc 	andi	r2,r2,255
8110e930:	100f883a 	mov	r7,r2
8110e934:	180d883a 	mov	r6,r3
8110e938:	01400404 	movi	r5,16
8110e93c:	11041180 	call	81104118 <bSdmaDmaM2Transfer>
8110e940:	e0bff715 	stw	r2,-36(fp)
								if ( bDmaReturn == TRUE ) {
8110e944:	e0bff717 	ldw	r2,-36(fp)
8110e948:	10800058 	cmpnei	r2,r2,1
8110e94c:	1000251e 	bne	r2,zero,8110e9e4 <vFeeTask+0xec4>
									//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
									xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110e950:	e0bff517 	ldw	r2,-44(fp)
8110e954:	10800217 	ldw	r2,8(r2)
8110e958:	10c22004 	addi	r3,r2,2176
8110e95c:	e0bff517 	ldw	r2,-44(fp)
8110e960:	10c00215 	stw	r3,8(r2)
									xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110e964:	e0bff517 	ldw	r2,-44(fp)
8110e968:	10800117 	ldw	r2,4(r2)
8110e96c:	10c00404 	addi	r3,r2,16
8110e970:	e0bff517 	ldw	r2,-44(fp)
8110e974:	10c00115 	stw	r3,4(r2)
									bDmaReturn = bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110e978:	e0bff517 	ldw	r2,-44(fp)
8110e97c:	10800217 	ldw	r2,8(r2)
8110e980:	1009883a 	mov	r4,r2
8110e984:	d0a05317 	ldw	r2,-32436(gp)
8110e988:	10802e17 	ldw	r2,184(r2)
8110e98c:	10c03fcc 	andi	r3,r2,255
8110e990:	d0a05317 	ldw	r2,-32436(gp)
8110e994:	10800003 	ldbu	r2,0(r2)
8110e998:	10803fcc 	andi	r2,r2,255
8110e99c:	100f883a 	mov	r7,r2
8110e9a0:	180d883a 	mov	r6,r3
8110e9a4:	01400404 	movi	r5,16
8110e9a8:	11041180 	call	81104118 <bSdmaDmaM2Transfer>
8110e9ac:	e0bff715 	stw	r2,-36(fp)
									if ( bDmaReturn == TRUE ) {
8110e9b0:	e0bff717 	ldw	r2,-36(fp)
8110e9b4:	10800058 	cmpnei	r2,r2,1
8110e9b8:	10000a1e 	bne	r2,zero,8110e9e4 <vFeeTask+0xec4>
										//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
										xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110e9bc:	e0bff517 	ldw	r2,-44(fp)
8110e9c0:	10800217 	ldw	r2,8(r2)
8110e9c4:	10c22004 	addi	r3,r2,2176
8110e9c8:	e0bff517 	ldw	r2,-44(fp)
8110e9cc:	10c00215 	stw	r3,8(r2)
										xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110e9d0:	e0bff517 	ldw	r2,-44(fp)
8110e9d4:	10800117 	ldw	r2,4(r2)
8110e9d8:	10c00404 	addi	r3,r2,16
8110e9dc:	e0bff517 	ldw	r2,-44(fp)
8110e9e0:	10c00115 	stw	r3,4(r2)

									}
								}
								OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110e9e4:	e0fff403 	ldbu	r3,-48(fp)
8110e9e8:	00a045b4 	movhi	r2,33046
8110e9ec:	108a9d04 	addi	r2,r2,10868
8110e9f0:	180690fa 	slli	r3,r3,3
8110e9f4:	10c5883a 	add	r2,r2,r3
8110e9f8:	10800017 	ldw	r2,0(r2)
8110e9fc:	1009883a 	mov	r4,r2
8110ea00:	113c26c0 	call	8113c26c <OSMutexPost>
								pxNFee->xControl.bDMALocked = FALSE;
8110ea04:	d0a05317 	ldw	r2,-32436(gp)
8110ea08:	10002215 	stw	zero,136(r2)
							}
	                        /* Send message telling to controller that is not using the DMA any more */
							bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);							
8110ea0c:	d0a05317 	ldw	r2,-32436(gp)
8110ea10:	10800003 	ldbu	r2,0(r2)
8110ea14:	10803fcc 	andi	r2,r2,255
8110ea18:	100d883a 	mov	r6,r2
8110ea1c:	000b883a 	mov	r5,zero
8110ea20:	01002044 	movi	r4,129
8110ea24:	11104940 	call	81110494 <bSendGiveBackNFeeCtrl>

							if ( bDmaReturn == TRUE ) {
8110ea28:	e0bff717 	ldw	r2,-36(fp)
8110ea2c:	10800058 	cmpnei	r2,r2,1
8110ea30:	1000111e 	bne	r2,zero,8110ea78 <vFeeTask+0xf58>
								if (pxNFee->xControl.bWatingSync==TRUE) {
8110ea34:	d0a05317 	ldw	r2,-32436(gp)
8110ea38:	10802817 	ldw	r2,160(r2)
8110ea3c:	10800058 	cmpnei	r2,r2,1
8110ea40:	1000071e 	bne	r2,zero,8110ea60 <vFeeTask+0xf40>
									pxNFee->xControl.eNextMode = sToTestFullPattern;
8110ea44:	d0a05317 	ldw	r2,-32436(gp)
8110ea48:	00c001c4 	movi	r3,7
8110ea4c:	10c02d15 	stw	r3,180(r2)
									pxNFee->xControl.eMode = sFeeWaitingSync;
8110ea50:	d0a05317 	ldw	r2,-32436(gp)
8110ea54:	00c00304 	movi	r3,12
8110ea58:	10c02c15 	stw	r3,176(r2)
8110ea5c:	00000606 	br	8110ea78 <vFeeTask+0xf58>
								} else {
									pxNFee->xControl.eNextMode = sToTestFullPattern;
8110ea60:	d0a05317 	ldw	r2,-32436(gp)
8110ea64:	00c001c4 	movi	r3,7
8110ea68:	10c02d15 	stw	r3,180(r2)
									pxNFee->xControl.eMode = sToTestFullPattern;
8110ea6c:	d0a05317 	ldw	r2,-32436(gp)
8110ea70:	00c001c4 	movi	r3,7
8110ea74:	10c02c15 	stw	r3,176(r2)
								}
							}


							#ifdef DEBUG_ON
								fprintf(fp,"\nFEE TASK:  Double buffer prepared\n ");
8110ea78:	d0a06117 	ldw	r2,-32380(gp)
8110ea7c:	100f883a 	mov	r7,r2
8110ea80:	01800904 	movi	r6,36
8110ea84:	01400044 	movi	r5,1
8110ea88:	01204574 	movhi	r4,33045
8110ea8c:	212e4b04 	addi	r4,r4,-18132
8110ea90:	1120e540 	call	81120e54 <fwrite>
8110ea94:	00000f06 	br	8110ead4 <vFeeTask+0xfb4>
							#endif							
	                    }
					} else {

						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110ea98:	d0a05317 	ldw	r2,-32436(gp)
8110ea9c:	e0fffe17 	ldw	r3,-8(fp)
8110eaa0:	180b883a 	mov	r5,r3
8110eaa4:	1009883a 	mov	r4,r2
8110eaa8:	110f5f80 	call	8110f5f8 <vQCmdFEEinFullPattern>
8110eaac:	00000906 	br	8110ead4 <vFeeTask+0xfb4>
					}
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110eab0:	d0e06117 	ldw	r3,-32380(gp)
8110eab4:	d0a05317 	ldw	r2,-32436(gp)
8110eab8:	10800003 	ldbu	r2,0(r2)
8110eabc:	10803fcc 	andi	r2,r2,255
8110eac0:	100d883a 	mov	r6,r2
8110eac4:	01604574 	movhi	r5,33045
8110eac8:	296e3704 	addi	r5,r5,-18212
8110eacc:	1809883a 	mov	r4,r3
8110ead0:	11207b80 	call	811207b8 <fprintf>
					#endif
				}

				incrementador++;
8110ead4:	d0a05417 	ldw	r2,-32432(gp)
8110ead8:	10800044 	addi	r2,r2,1
8110eadc:	d0a05415 	stw	r2,-32432(gp)
				break;
8110eae0:	00015a06 	br	8110f04c <vFeeTask+0x152c>


			case sToTestFullPattern: /* Transition */
				bFinal = FALSE;
8110eae4:	e03ff815 	stw	zero,-32(fp)

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110eae8:	d0a05317 	ldw	r2,-32436(gp)
8110eaec:	10804304 	addi	r2,r2,268
8110eaf0:	1009883a 	mov	r4,r2
8110eaf4:	110815c0 	call	8110815c <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02; /*Pattern Full Image*/
8110eaf8:	d0a05317 	ldw	r2,-32436(gp)
8110eafc:	00c00084 	movi	r3,2
8110eb00:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110eb04:	d0a05317 	ldw	r2,-32436(gp)
8110eb08:	10804304 	addi	r2,r2,268
8110eb0c:	1009883a 	mov	r4,r2
8110eb10:	1107e700 	call	81107e70 <bRmapSetMemConfigArea>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
8110eb14:	d0e06117 	ldw	r3,-32380(gp)
8110eb18:	d0a05317 	ldw	r2,-32436(gp)
8110eb1c:	10800003 	ldbu	r2,0(r2)
8110eb20:	10803fcc 	andi	r2,r2,255
8110eb24:	100d883a 	mov	r6,r2
8110eb28:	01604574 	movhi	r5,33045
8110eb2c:	296e5504 	addi	r5,r5,-18092
8110eb30:	1809883a 	mov	r4,r3
8110eb34:	11207b80 	call	811207b8 <fprintf>
				#endif

				pxNFee->xControl.bUsingDMA = TRUE;
8110eb38:	d0a05317 	ldw	r2,-32436(gp)
8110eb3c:	00c00044 	movi	r3,1
8110eb40:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.eMode = sFeeTestFullPattern;
8110eb44:	d0a05317 	ldw	r2,-32436(gp)
8110eb48:	00c00104 	movi	r3,4
8110eb4c:	10c02c15 	stw	r3,176(r2)
				pxNFee->xControl.eNextMode = sFeeTestFullPattern;
8110eb50:	d0a05317 	ldw	r2,-32436(gp)
8110eb54:	00c00104 	movi	r3,4
8110eb58:	10c02d15 	stw	r3,180(r2)
				pxNFee->xControl.bWatingSync = TRUE;
8110eb5c:	d0a05317 	ldw	r2,-32436(gp)
8110eb60:	00c00044 	movi	r3,1
8110eb64:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110eb68:	d0a05317 	ldw	r2,-32436(gp)
8110eb6c:	00c00044 	movi	r3,1
8110eb70:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110eb74:	d0a05317 	ldw	r2,-32436(gp)
8110eb78:	00c00044 	movi	r3,1
8110eb7c:	10c02115 	stw	r3,132(r2)
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110eb80:	d0a05317 	ldw	r2,-32436(gp)
8110eb84:	10800003 	ldbu	r2,0(r2)
8110eb88:	10803fcc 	andi	r2,r2,255
8110eb8c:	100d883a 	mov	r6,r2
8110eb90:	000b883a 	mov	r5,zero
8110eb94:	01002004 	movi	r4,128
8110eb98:	11103f00 	call	811103f0 <bSendRequestNFeeCtrl>

				break;
8110eb9c:	00012b06 	br	8110f04c <vFeeTask+0x152c>


			case sFeeTestFullPattern: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110eba0:	d0a05317 	ldw	r2,-32436(gp)
8110eba4:	10800003 	ldbu	r2,0(r2)
8110eba8:	10803fcc 	andi	r2,r2,255
8110ebac:	1085883a 	add	r2,r2,r2
8110ebb0:	1087883a 	add	r3,r2,r2
8110ebb4:	d0a06904 	addi	r2,gp,-32348
8110ebb8:	1885883a 	add	r2,r3,r2
8110ebbc:	10800017 	ldw	r2,0(r2)
8110ebc0:	e0fffd04 	addi	r3,fp,-12
8110ebc4:	180d883a 	mov	r6,r3
8110ebc8:	000b883a 	mov	r5,zero
8110ebcc:	1009883a 	mov	r4,r2
8110ebd0:	113cddc0 	call	8113cddc <OSQPend>
8110ebd4:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110ebd8:	e0bffd03 	ldbu	r2,-12(fp)
8110ebdc:	10803fcc 	andi	r2,r2,255
8110ebe0:	1000c11e 	bne	r2,zero,8110eee8 <vFeeTask+0x13c8>

					/* First Check if is access to the DMA (priority) */
						if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110ebe4:	e0bffe83 	ldbu	r2,-6(fp)
8110ebe8:	10803fcc 	andi	r2,r2,255
8110ebec:	108023d8 	cmpnei	r2,r2,143
8110ebf0:	1000b01e 	bne	r2,zero,8110eeb4 <vFeeTask+0x1394>

							/* Try to get the Mutex */
		                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110ebf4:	e0fff403 	ldbu	r3,-48(fp)
8110ebf8:	00a045b4 	movhi	r2,33046
8110ebfc:	108a9d04 	addi	r2,r2,10868
8110ec00:	180690fa 	slli	r3,r3,3
8110ec04:	10c5883a 	add	r2,r2,r3
8110ec08:	10800017 	ldw	r2,0(r2)
8110ec0c:	e0fffd04 	addi	r3,fp,-12
8110ec10:	180d883a 	mov	r6,r3
8110ec14:	000b883a 	mov	r5,zero
8110ec18:	1009883a 	mov	r4,r2
8110ec1c:	113bcc80 	call	8113bcc8 <OSMutexPend>
		                    if ( error_code == OS_ERR_NONE ) {
8110ec20:	e0bffd03 	ldbu	r2,-12(fp)
8110ec24:	10803fcc 	andi	r2,r2,255
8110ec28:	1001071e 	bne	r2,zero,8110f048 <vFeeTask+0x1528>
		                    	pxNFee->xControl.bDMALocked = TRUE;
8110ec2c:	d0a05317 	ldw	r2,-32436(gp)
8110ec30:	00c00044 	movi	r3,1
8110ec34:	10c02215 	stw	r3,136(r2)

		                    	/* Is this the last block? */
		                    	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8110ec38:	e0bff517 	ldw	r2,-44(fp)
8110ec3c:	10800117 	ldw	r2,4(r2)
8110ec40:	10c00404 	addi	r3,r2,16
8110ec44:	d0a05317 	ldw	r2,-32436(gp)
8110ec48:	10800417 	ldw	r2,16(r2)
8110ec4c:	18803b36 	bltu	r3,r2,8110ed3c <vFeeTask+0x121c>

									#ifdef DEBUG_ON
										//fprintf(fp,"\n    i: %u ",incrementador);
										fprintf(fp,"\nEnd of transmission NFEE-%hhu -> CCD %hhu  -> Time Code Ref. used -> %hu   (n=%lu)\n", pxNFee->ucId, ucReadout, tCodFeeTask, incrementador);
8110ec50:	d1206117 	ldw	r4,-32380(gp)
8110ec54:	d0a05317 	ldw	r2,-32436(gp)
8110ec58:	10800003 	ldbu	r2,0(r2)
8110ec5c:	11403fcc 	andi	r5,r2,255
8110ec60:	e1bff603 	ldbu	r6,-40(fp)
8110ec64:	d0a05517 	ldw	r2,-32428(gp)
8110ec68:	d0e05417 	ldw	r3,-32432(gp)
8110ec6c:	d8c00115 	stw	r3,4(sp)
8110ec70:	d8800015 	stw	r2,0(sp)
8110ec74:	300f883a 	mov	r7,r6
8110ec78:	280d883a 	mov	r6,r5
8110ec7c:	01604574 	movhi	r5,33045
8110ec80:	296e5f04 	addi	r5,r5,-18052
8110ec84:	11207b80 	call	811207b8 <fprintf>
										fprintf(fp,"\nMemory used: %u ", ucMemUsing);
8110ec88:	d0a06117 	ldw	r2,-32380(gp)
8110ec8c:	e0fff403 	ldbu	r3,-48(fp)
8110ec90:	180d883a 	mov	r6,r3
8110ec94:	01604574 	movhi	r5,33045
8110ec98:	296e7504 	addi	r5,r5,-17964
8110ec9c:	1009883a 	mov	r4,r2
8110eca0:	11207b80 	call	811207b8 <fprintf>
										fprintf(fp,"\nTotal blocks transmited: %u ",xCcdMapLocal->ulBlockI);
8110eca4:	d0e06117 	ldw	r3,-32380(gp)
8110eca8:	e0bff517 	ldw	r2,-44(fp)
8110ecac:	10800117 	ldw	r2,4(r2)
8110ecb0:	100d883a 	mov	r6,r2
8110ecb4:	01604574 	movhi	r5,33045
8110ecb8:	296e7a04 	addi	r5,r5,-17944
8110ecbc:	1809883a 	mov	r4,r3
8110ecc0:	11207b80 	call	811207b8 <fprintf>
									#endif

		                    		/*Define the size of the data in the double buffer (need this to create the interrupt riht)*/
		                    		bFeebCh1SetBufferSize( (pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI), 0 );
8110ecc4:	d0a05317 	ldw	r2,-32436(gp)
8110ecc8:	10800417 	ldw	r2,16(r2)
8110eccc:	1007883a 	mov	r3,r2
8110ecd0:	e0bff517 	ldw	r2,-44(fp)
8110ecd4:	10800117 	ldw	r2,4(r2)
8110ecd8:	1885c83a 	sub	r2,r3,r2
8110ecdc:	10803fcc 	andi	r2,r2,255
8110ece0:	000b883a 	mov	r5,zero
8110ece4:	1009883a 	mov	r4,r2
8110ece8:	11059a40 	call	811059a4 <bFeebCh1SetBufferSize>
		                    		bFeebCh1SetBufferSize( (pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI), 1 );
8110ecec:	d0a05317 	ldw	r2,-32436(gp)
8110ecf0:	10800417 	ldw	r2,16(r2)
8110ecf4:	1007883a 	mov	r3,r2
8110ecf8:	e0bff517 	ldw	r2,-44(fp)
8110ecfc:	10800117 	ldw	r2,4(r2)
8110ed00:	1885c83a 	sub	r2,r3,r2
8110ed04:	10803fcc 	andi	r2,r2,255
8110ed08:	01400044 	movi	r5,1
8110ed0c:	1009883a 	mov	r4,r2
8110ed10:	11059a40 	call	811059a4 <bFeebCh1SetBufferSize>

		                    		usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8110ed14:	d0a05317 	ldw	r2,-32436(gp)
8110ed18:	10800417 	ldw	r2,16(r2)
8110ed1c:	1007883a 	mov	r3,r2
8110ed20:	e0bff517 	ldw	r2,-44(fp)
8110ed24:	10800117 	ldw	r2,4(r2)
8110ed28:	1885c83a 	sub	r2,r3,r2
8110ed2c:	e0bff68d 	sth	r2,-38(fp)
		                    		bFinal = TRUE;
8110ed30:	00800044 	movi	r2,1
8110ed34:	e0bff815 	stw	r2,-32(fp)
8110ed38:	00000306 	br	8110ed48 <vFeeTask+0x1228>

		                    	} else {

		                    		bFinal = FALSE;
8110ed3c:	e03ff815 	stw	zero,-32(fp)
		                    		usiLengthBlocks = SDMA_MAX_BLOCKS;
8110ed40:	00800404 	movi	r2,16
8110ed44:	e0bff68d 	sth	r2,-38(fp)
		                    	}

		                    	if ( ucMemUsing == 0  ) {
8110ed48:	e0bff403 	ldbu	r2,-48(fp)
8110ed4c:	1000111e 	bne	r2,zero,8110ed94 <vFeeTask+0x1274>
		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
		                    		bDmaReturn = bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI, usiLengthBlocks, pxNFee->xControl.eSide, pxNFee->ucId);
8110ed50:	e0bff517 	ldw	r2,-44(fp)
8110ed54:	10800217 	ldw	r2,8(r2)
8110ed58:	1011883a 	mov	r8,r2
8110ed5c:	e0fff68b 	ldhu	r3,-38(fp)
8110ed60:	d0a05317 	ldw	r2,-32436(gp)
8110ed64:	10802e17 	ldw	r2,184(r2)
8110ed68:	11003fcc 	andi	r4,r2,255
8110ed6c:	d0a05317 	ldw	r2,-32436(gp)
8110ed70:	10800003 	ldbu	r2,0(r2)
8110ed74:	10803fcc 	andi	r2,r2,255
8110ed78:	100f883a 	mov	r7,r2
8110ed7c:	200d883a 	mov	r6,r4
8110ed80:	180b883a 	mov	r5,r3
8110ed84:	4009883a 	mov	r4,r8
8110ed88:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
8110ed8c:	e0bff715 	stw	r2,-36(fp)
8110ed90:	00001006 	br	8110edd4 <vFeeTask+0x12b4>
		                    	} else {

		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
		                    		bDmaReturn = bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI, usiLengthBlocks, pxNFee->xControl.eSide, pxNFee->ucId);
8110ed94:	e0bff517 	ldw	r2,-44(fp)
8110ed98:	10800217 	ldw	r2,8(r2)
8110ed9c:	1011883a 	mov	r8,r2
8110eda0:	e0fff68b 	ldhu	r3,-38(fp)
8110eda4:	d0a05317 	ldw	r2,-32436(gp)
8110eda8:	10802e17 	ldw	r2,184(r2)
8110edac:	11003fcc 	andi	r4,r2,255
8110edb0:	d0a05317 	ldw	r2,-32436(gp)
8110edb4:	10800003 	ldbu	r2,0(r2)
8110edb8:	10803fcc 	andi	r2,r2,255
8110edbc:	100f883a 	mov	r7,r2
8110edc0:	200d883a 	mov	r6,r4
8110edc4:	180b883a 	mov	r5,r3
8110edc8:	4009883a 	mov	r4,r8
8110edcc:	11041180 	call	81104118 <bSdmaDmaM2Transfer>
8110edd0:	e0bff715 	stw	r2,-36(fp)
		                    	}


		                    	if ( bDmaReturn = TRUE ) {
8110edd4:	00800044 	movi	r2,1
8110edd8:	e0bff715 	stw	r2,-36(fp)
									/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */
									xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110eddc:	e0bff517 	ldw	r2,-44(fp)
8110ede0:	10800217 	ldw	r2,8(r2)
8110ede4:	10c22004 	addi	r3,r2,2176
8110ede8:	e0bff517 	ldw	r2,-44(fp)
8110edec:	10c00215 	stw	r3,8(r2)
									xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110edf0:	e0bff517 	ldw	r2,-44(fp)
8110edf4:	10800117 	ldw	r2,4(r2)
8110edf8:	10c00404 	addi	r3,r2,16
8110edfc:	e0bff517 	ldw	r2,-44(fp)
8110ee00:	10c00115 	stw	r3,4(r2)
										fprintf(fp,"\n--\n ");
									#endif
									bFinal = FALSE;
		                    	}

		                    	OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110ee04:	e0fff403 	ldbu	r3,-48(fp)
8110ee08:	00a045b4 	movhi	r2,33046
8110ee0c:	108a9d04 	addi	r2,r2,10868
8110ee10:	180690fa 	slli	r3,r3,3
8110ee14:	10c5883a 	add	r2,r2,r3
8110ee18:	10800017 	ldw	r2,0(r2)
8110ee1c:	1009883a 	mov	r4,r2
8110ee20:	113c26c0 	call	8113c26c <OSMutexPost>
		                    	pxNFee->xControl.bDMALocked = FALSE;
8110ee24:	d0a05317 	ldw	r2,-32436(gp)
8110ee28:	10002215 	stw	zero,136(r2)
		                        /* Send message telling to controller that is not using the DMA any more */
								bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110ee2c:	d0a05317 	ldw	r2,-32436(gp)
8110ee30:	10800003 	ldbu	r2,0(r2)
8110ee34:	10803fcc 	andi	r2,r2,255
8110ee38:	100d883a 	mov	r6,r2
8110ee3c:	000b883a 	mov	r5,zero
8110ee40:	01002044 	movi	r4,129
8110ee44:	11104940 	call	81110494 <bSendGiveBackNFeeCtrl>

								/* Just to see the progress */
								if ( ((xCcdMapLocal->ulBlockI) % 4096 == 0) ) {
8110ee48:	e0bff517 	ldw	r2,-44(fp)
8110ee4c:	10800117 	ldw	r2,4(r2)
8110ee50:	1083ffcc 	andi	r2,r2,4095
8110ee54:	1000081e 	bne	r2,zero,8110ee78 <vFeeTask+0x1358>

									#ifdef DEBUG_ON
										fprintf(fp,"\nblock: %u ", xCcdMapLocal->ulBlockI);
8110ee58:	d0e06117 	ldw	r3,-32380(gp)
8110ee5c:	e0bff517 	ldw	r2,-44(fp)
8110ee60:	10800117 	ldw	r2,4(r2)
8110ee64:	100d883a 	mov	r6,r2
8110ee68:	01604574 	movhi	r5,33045
8110ee6c:	296e8204 	addi	r5,r5,-17912
8110ee70:	1809883a 	mov	r4,r3
8110ee74:	11207b80 	call	811207b8 <fprintf>
									#endif
								}


								if ( bFinal == TRUE ) {
8110ee78:	e0bff817 	ldw	r2,-32(fp)
8110ee7c:	10800058 	cmpnei	r2,r2,1
8110ee80:	1000041e 	bne	r2,zero,8110ee94 <vFeeTask+0x1374>
									pxNFee->xControl.eMode = sEndTransmission;
8110ee84:	d0a05317 	ldw	r2,-32436(gp)
8110ee88:	00c002c4 	movi	r3,11
8110ee8c:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110ee90:	00006d06 	br	8110f048 <vFeeTask+0x1528>


								if ( bFinal == TRUE ) {
									pxNFee->xControl.eMode = sEndTransmission;
								} else {
									bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110ee94:	d0a05317 	ldw	r2,-32436(gp)
8110ee98:	10800003 	ldbu	r2,0(r2)
8110ee9c:	10803fcc 	andi	r2,r2,255
8110eea0:	100d883a 	mov	r6,r2
8110eea4:	000b883a 	mov	r5,zero
8110eea8:	01002004 	movi	r4,128
8110eeac:	11103f00 	call	811103f0 <bSendRequestNFeeCtrl>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110eeb0:	00006506 	br	8110f048 <vFeeTask+0x1528>
									bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
								}

		                    }
						} else {
							vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110eeb4:	d0a05317 	ldw	r2,-32436(gp)
8110eeb8:	e0fffe17 	ldw	r3,-8(fp)
8110eebc:	180b883a 	mov	r5,r3
8110eec0:	1009883a 	mov	r4,r2
8110eec4:	110f5f80 	call	8110f5f8 <vQCmdFEEinFullPattern>

							if ( pxNFee->xControl.bWatingSync == FALSE ) {
8110eec8:	d0a05317 	ldw	r2,-32436(gp)
8110eecc:	10802817 	ldw	r2,160(r2)
8110eed0:	10005d1e 	bne	r2,zero,8110f048 <vFeeTask+0x1528>
								pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8110eed4:	d0a05317 	ldw	r2,-32436(gp)
8110eed8:	d0e05317 	ldw	r3,-32436(gp)
8110eedc:	18c02d17 	ldw	r3,180(r3)
8110eee0:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110eee4:	00005806 	br	8110f048 <vFeeTask+0x1528>
							}
						}

				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110eee8:	d0e06117 	ldw	r3,-32380(gp)
8110eeec:	d0a05317 	ldw	r2,-32436(gp)
8110eef0:	10800003 	ldbu	r2,0(r2)
8110eef4:	10803fcc 	andi	r2,r2,255
8110eef8:	100d883a 	mov	r6,r2
8110eefc:	01604574 	movhi	r5,33045
8110ef00:	296e3704 	addi	r5,r5,-18212
8110ef04:	1809883a 	mov	r4,r3
8110ef08:	11207b80 	call	811207b8 <fprintf>
					#endif
				}

				break;
8110ef0c:	00004e06 	br	8110f048 <vFeeTask+0x1528>

			case sEndTransmission:

				pxNFee->xControl.bWatingSync = TRUE;
8110ef10:	d0a05317 	ldw	r2,-32436(gp)
8110ef14:	00c00044 	movi	r3,1
8110ef18:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110ef1c:	d0a05317 	ldw	r2,-32436(gp)
8110ef20:	10002315 	stw	zero,140(r2)

				if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
8110ef24:	d0a05317 	ldw	r2,-32436(gp)
8110ef28:	10802d17 	ldw	r2,180(r2)
8110ef2c:	10800198 	cmpnei	r2,r2,6
8110ef30:	1000071e 	bne	r2,zero,8110ef50 <vFeeTask+0x1430>
					pxNFee->xControl.eMode =  sFeeWaitingSync;
8110ef34:	d0a05317 	ldw	r2,-32436(gp)
8110ef38:	00c00304 	movi	r3,12
8110ef3c:	10c02c15 	stw	r3,176(r2)
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
8110ef40:	d0a05317 	ldw	r2,-32436(gp)
8110ef44:	00c00184 	movi	r3,6
8110ef48:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sNextPatternIteration;
					pxNFee->xControl.eNextMode =  sFeeWaitingSync;
				}

				break;
8110ef4c:	00003f06 	br	8110f04c <vFeeTask+0x152c>

				if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				} else {
					pxNFee->xControl.eMode =  sNextPatternIteration;
8110ef50:	d0a05317 	ldw	r2,-32436(gp)
8110ef54:	00c00284 	movi	r3,10
8110ef58:	10c02c15 	stw	r3,176(r2)
					pxNFee->xControl.eNextMode =  sFeeWaitingSync;
8110ef5c:	d0a05317 	ldw	r2,-32436(gp)
8110ef60:	00c00304 	movi	r3,12
8110ef64:	10c02d15 	stw	r3,180(r2)
				}

				break;
8110ef68:	00003806 	br	8110f04c <vFeeTask+0x152c>

			case sFeeWaitingSync:

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: (sFeeWaitingSync)\n", pxNFee->ucId);
8110ef6c:	d0e06117 	ldw	r3,-32380(gp)
8110ef70:	d0a05317 	ldw	r2,-32436(gp)
8110ef74:	10800003 	ldbu	r2,0(r2)
8110ef78:	10803fcc 	andi	r2,r2,255
8110ef7c:	100d883a 	mov	r6,r2
8110ef80:	01604574 	movhi	r5,33045
8110ef84:	296e8504 	addi	r5,r5,-17900
8110ef88:	1809883a 	mov	r4,r3
8110ef8c:	11207b80 	call	811207b8 <fprintf>
				#endif

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110ef90:	d0a05317 	ldw	r2,-32436(gp)
8110ef94:	10800003 	ldbu	r2,0(r2)
8110ef98:	10803fcc 	andi	r2,r2,255
8110ef9c:	1085883a 	add	r2,r2,r2
8110efa0:	1087883a 	add	r3,r2,r2
8110efa4:	d0a06904 	addi	r2,gp,-32348
8110efa8:	1885883a 	add	r2,r3,r2
8110efac:	10800017 	ldw	r2,0(r2)
8110efb0:	e0fffd04 	addi	r3,fp,-12
8110efb4:	180d883a 	mov	r6,r3
8110efb8:	000b883a 	mov	r5,zero
8110efbc:	1009883a 	mov	r4,r2
8110efc0:	113cddc0 	call	8113cddc <OSQPend>
8110efc4:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code != OS_ERR_NONE ) {
8110efc8:	e0bffd03 	ldbu	r2,-12(fp)
8110efcc:	10803fcc 	andi	r2,r2,255
8110efd0:	10000a26 	beq	r2,zero,8110effc <vFeeTask+0x14dc>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
8110efd4:	d0e06117 	ldw	r3,-32380(gp)
8110efd8:	d0a05317 	ldw	r2,-32436(gp)
8110efdc:	10800003 	ldbu	r2,0(r2)
8110efe0:	10803fcc 	andi	r2,r2,255
8110efe4:	100d883a 	mov	r6,r2
8110efe8:	01604574 	movhi	r5,33045
8110efec:	296e8e04 	addi	r5,r5,-17864
8110eff0:	1809883a 	mov	r4,r3
8110eff4:	11207b80 	call	811207b8 <fprintf>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
8110eff8:	00001406 	br	8110f04c <vFeeTask+0x152c>
				if ( error_code != OS_ERR_NONE ) {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
8110effc:	d0a05317 	ldw	r2,-32436(gp)
8110f000:	e0fffe17 	ldw	r3,-8(fp)
8110f004:	180b883a 	mov	r5,r3
8110f008:	1009883a 	mov	r4,r2
8110f00c:	110f0500 	call	8110f050 <vQCmdFEEinWaitingSync>
				}

				break;
8110f010:	00000e06 	br	8110f04c <vFeeTask+0x152c>


			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8110f014:	d0a05317 	ldw	r2,-32436(gp)
8110f018:	00c00144 	movi	r3,5
8110f01c:	10c02c15 	stw	r3,176(r2)
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
8110f020:	d0e06117 	ldw	r3,-32380(gp)
8110f024:	d0a05317 	ldw	r2,-32436(gp)
8110f028:	10800003 	ldbu	r2,0(r2)
8110f02c:	10803fcc 	andi	r2,r2,255
8110f030:	100d883a 	mov	r6,r2
8110f034:	01604574 	movhi	r5,33045
8110f038:	296e9f04 	addi	r5,r5,-17796
8110f03c:	1809883a 	mov	r4,r3
8110f040:	11207b80 	call	811207b8 <fprintf>
				#endif
				break;
8110f044:	00000106 	br	8110f04c <vFeeTask+0x152c>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110f048:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				#endif
				break;
		}

	}
8110f04c:	003aca06 	br	8110db78 <__reset+0xfb0edb78>

8110f050 <vQCmdFEEinWaitingSync>:

}

void vQCmdFEEinWaitingSync( TNFee *pxNFeeP, unsigned int cmd ) {
8110f050:	defffb04 	addi	sp,sp,-20
8110f054:	de00012e 	bgeu	sp,et,8110f05c <vQCmdFEEinWaitingSync+0xc>
8110f058:	003b68fa 	trap	3
8110f05c:	dfc00415 	stw	ra,16(sp)
8110f060:	df000315 	stw	fp,12(sp)
8110f064:	df000304 	addi	fp,sp,12
8110f068:	e13ffe15 	stw	r4,-8(fp)
8110f06c:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f070:	e0bfff17 	ldw	r2,-4(fp)
8110f074:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f078:	e0bffdc3 	ldbu	r2,-9(fp)
8110f07c:	10c03fcc 	andi	r3,r2,255
8110f080:	e0bffe17 	ldw	r2,-8(fp)
8110f084:	10800003 	ldbu	r2,0(r2)
8110f088:	10803fcc 	andi	r2,r2,255
8110f08c:	10800444 	addi	r2,r2,17
8110f090:	1880631e 	bne	r3,r2,8110f220 <vQCmdFEEinWaitingSync+0x1d0>

		switch (uiCmdFEEL.ucByte[2]) {
8110f094:	e0bffd83 	ldbu	r2,-10(fp)
8110f098:	10803fcc 	andi	r2,r2,255
8110f09c:	10c02860 	cmpeqi	r3,r2,161
8110f0a0:	18001a1e 	bne	r3,zero,8110f10c <vQCmdFEEinWaitingSync+0xbc>
8110f0a4:	10c02888 	cmpgei	r3,r2,162
8110f0a8:	18000c1e 	bne	r3,zero,8110f0dc <vQCmdFEEinWaitingSync+0x8c>
8110f0ac:	10c00120 	cmpeqi	r3,r2,4
8110f0b0:	18001f1e 	bne	r3,zero,8110f130 <vQCmdFEEinWaitingSync+0xe0>
8110f0b4:	10c00148 	cmpgei	r3,r2,5
8110f0b8:	1800031e 	bne	r3,zero,8110f0c8 <vQCmdFEEinWaitingSync+0x78>
8110f0bc:	10800060 	cmpeqi	r2,r2,1
8110f0c0:	1000121e 	bne	r2,zero,8110f10c <vQCmdFEEinWaitingSync+0xbc>
8110f0c4:	00004c06 	br	8110f1f8 <vQCmdFEEinWaitingSync+0x1a8>
8110f0c8:	10c00220 	cmpeqi	r3,r2,8
8110f0cc:	1800221e 	bne	r3,zero,8110f158 <vQCmdFEEinWaitingSync+0x108>
8110f0d0:	108023e0 	cmpeqi	r2,r2,143
8110f0d4:	10003e1e 	bne	r2,zero,8110f1d0 <vQCmdFEEinWaitingSync+0x180>
8110f0d8:	00004706 	br	8110f1f8 <vQCmdFEEinWaitingSync+0x1a8>
8110f0dc:	10c03888 	cmpgei	r3,r2,226
8110f0e0:	1800071e 	bne	r3,zero,8110f100 <vQCmdFEEinWaitingSync+0xb0>
8110f0e4:	10c03808 	cmpgei	r3,r2,224
8110f0e8:	1800321e 	bne	r3,zero,8110f1b4 <vQCmdFEEinWaitingSync+0x164>
8110f0ec:	10c02920 	cmpeqi	r3,r2,164
8110f0f0:	18000f1e 	bne	r3,zero,8110f130 <vQCmdFEEinWaitingSync+0xe0>
8110f0f4:	10802a20 	cmpeqi	r2,r2,168
8110f0f8:	1000171e 	bne	r2,zero,8110f158 <vQCmdFEEinWaitingSync+0x108>
8110f0fc:	00003e06 	br	8110f1f8 <vQCmdFEEinWaitingSync+0x1a8>
8110f100:	10803c20 	cmpeqi	r2,r2,240
8110f104:	10001e1e 	bne	r2,zero,8110f180 <vQCmdFEEinWaitingSync+0x130>
8110f108:	00003b06 	br	8110f1f8 <vQCmdFEEinWaitingSync+0x1a8>
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f10c:	e0bffe17 	ldw	r2,-8(fp)
8110f110:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110f114:	e0bffe17 	ldw	r2,-8(fp)
8110f118:	00c00144 	movi	r3,5
8110f11c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110f120:	e0bffe17 	ldw	r2,-8(fp)
8110f124:	00c00144 	movi	r3,5
8110f128:	10c02d15 	stw	r3,180(r2)
				break;
8110f12c:	00003c06 	br	8110f220 <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f130:	e0bffe17 	ldw	r2,-8(fp)
8110f134:	00c00044 	movi	r3,1
8110f138:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
8110f13c:	e0bffe17 	ldw	r2,-8(fp)
8110f140:	00c00304 	movi	r3,12
8110f144:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f148:	e0bffe17 	ldw	r2,-8(fp)
8110f14c:	00c00184 	movi	r3,6
8110f150:	10c02d15 	stw	r3,180(r2)
				break;
8110f154:	00003206 	br	8110f220 <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f158:	e0bffe17 	ldw	r2,-8(fp)
8110f15c:	00c00044 	movi	r3,1
8110f160:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110f164:	e0bffe17 	ldw	r2,-8(fp)
8110f168:	00c00284 	movi	r3,10
8110f16c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110f170:	e0bffe17 	ldw	r2,-8(fp)
8110f174:	00c00304 	movi	r3,12
8110f178:	10c02d15 	stw	r3,180(r2)
				break;
8110f17c:	00002806 	br	8110f220 <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110f180:	d0e06117 	ldw	r3,-32380(gp)
8110f184:	e0bffe17 	ldw	r2,-8(fp)
8110f188:	10800003 	ldbu	r2,0(r2)
8110f18c:	10803fcc 	andi	r2,r2,255
8110f190:	100d883a 	mov	r6,r2
8110f194:	01604574 	movhi	r5,33045
8110f198:	296eaa04 	addi	r5,r5,-17752
8110f19c:	1809883a 	mov	r4,r3
8110f1a0:	11207b80 	call	811207b8 <fprintf>
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPWaitingSync( pxNFeeP, cmd );
8110f1a4:	e17fff17 	ldw	r5,-4(fp)
8110f1a8:	e13ffe17 	ldw	r4,-8(fp)
8110f1ac:	110ff380 	call	8110ff38 <vQCmdFeeRMAPWaitingSync>
				break;
8110f1b0:	00001b06 	br	8110f220 <vQCmdFEEinWaitingSync+0x1d0>
			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f1b4:	e0bffe17 	ldw	r2,-8(fp)
8110f1b8:	10c02d17 	ldw	r3,180(r2)
8110f1bc:	e0bffe17 	ldw	r2,-8(fp)
8110f1c0:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f1c4:	e0bffe17 	ldw	r2,-8(fp)
8110f1c8:	10002815 	stw	zero,160(r2)

				break;
8110f1cc:	00001406 	br	8110f220 <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f1d0:	e0bffe17 	ldw	r2,-8(fp)
8110f1d4:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f1d8:	e0bffe17 	ldw	r2,-8(fp)
8110f1dc:	10800003 	ldbu	r2,0(r2)
8110f1e0:	10803fcc 	andi	r2,r2,255
8110f1e4:	100d883a 	mov	r6,r2
8110f1e8:	000b883a 	mov	r5,zero
8110f1ec:	01002044 	movi	r4,129
8110f1f0:	11104940 	call	81110494 <bSendGiveBackNFeeCtrl>
				break;
8110f1f4:	00000a06 	br	8110f220 <vQCmdFEEinWaitingSync+0x1d0>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110f1f8:	d0e06117 	ldw	r3,-32380(gp)
8110f1fc:	e0bffe17 	ldw	r2,-8(fp)
8110f200:	10800003 	ldbu	r2,0(r2)
8110f204:	10803fcc 	andi	r2,r2,255
8110f208:	100d883a 	mov	r6,r2
8110f20c:	01604574 	movhi	r5,33045
8110f210:	296eb404 	addi	r5,r5,-17712
8110f214:	1809883a 	mov	r4,r3
8110f218:	11207b80 	call	811207b8 <fprintf>
				#endif
				break;
8110f21c:	0001883a 	nop
		}
	}
}
8110f220:	0001883a 	nop
8110f224:	e037883a 	mov	sp,fp
8110f228:	dfc00117 	ldw	ra,4(sp)
8110f22c:	df000017 	ldw	fp,0(sp)
8110f230:	dec00204 	addi	sp,sp,8
8110f234:	f800283a 	ret

8110f238 <vQCmdFEEinConfig>:


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
8110f238:	defffb04 	addi	sp,sp,-20
8110f23c:	de00012e 	bgeu	sp,et,8110f244 <vQCmdFEEinConfig+0xc>
8110f240:	003b68fa 	trap	3
8110f244:	dfc00415 	stw	ra,16(sp)
8110f248:	df000315 	stw	fp,12(sp)
8110f24c:	df000304 	addi	fp,sp,12
8110f250:	e13ffe15 	stw	r4,-8(fp)
8110f254:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f258:	e0bfff17 	ldw	r2,-4(fp)
8110f25c:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f260:	e0bffdc3 	ldbu	r2,-9(fp)
8110f264:	10c03fcc 	andi	r3,r2,255
8110f268:	e0bffe17 	ldw	r2,-8(fp)
8110f26c:	10800003 	ldbu	r2,0(r2)
8110f270:	10803fcc 	andi	r2,r2,255
8110f274:	10800444 	addi	r2,r2,17
8110f278:	18805a1e 	bne	r3,r2,8110f3e4 <vQCmdFEEinConfig+0x1ac>

		switch (uiCmdFEEL.ucByte[2]) {
8110f27c:	e0bffd83 	ldbu	r2,-10(fp)
8110f280:	10803fcc 	andi	r2,r2,255
8110f284:	10c02860 	cmpeqi	r3,r2,161
8110f288:	18001a1e 	bne	r3,zero,8110f2f4 <vQCmdFEEinConfig+0xbc>
8110f28c:	10c02888 	cmpgei	r3,r2,162
8110f290:	18000c1e 	bne	r3,zero,8110f2c4 <vQCmdFEEinConfig+0x8c>
8110f294:	10c00120 	cmpeqi	r3,r2,4
8110f298:	1800201e 	bne	r3,zero,8110f31c <vQCmdFEEinConfig+0xe4>
8110f29c:	10c00148 	cmpgei	r3,r2,5
8110f2a0:	1800031e 	bne	r3,zero,8110f2b0 <vQCmdFEEinConfig+0x78>
8110f2a4:	10800060 	cmpeqi	r2,r2,1
8110f2a8:	1000121e 	bne	r2,zero,8110f2f4 <vQCmdFEEinConfig+0xbc>
8110f2ac:	00004206 	br	8110f3b8 <vQCmdFEEinConfig+0x180>
8110f2b0:	10c00220 	cmpeqi	r3,r2,8
8110f2b4:	1800221e 	bne	r3,zero,8110f340 <vQCmdFEEinConfig+0x108>
8110f2b8:	108023e0 	cmpeqi	r2,r2,143
8110f2bc:	1000341e 	bne	r2,zero,8110f390 <vQCmdFEEinConfig+0x158>
8110f2c0:	00003d06 	br	8110f3b8 <vQCmdFEEinConfig+0x180>
8110f2c4:	10c03888 	cmpgei	r3,r2,226
8110f2c8:	1800071e 	bne	r3,zero,8110f2e8 <vQCmdFEEinConfig+0xb0>
8110f2cc:	10c03808 	cmpgei	r3,r2,224
8110f2d0:	1800431e 	bne	r3,zero,8110f3e0 <vQCmdFEEinConfig+0x1a8>
8110f2d4:	10c02920 	cmpeqi	r3,r2,164
8110f2d8:	1800101e 	bne	r3,zero,8110f31c <vQCmdFEEinConfig+0xe4>
8110f2dc:	10802a20 	cmpeqi	r2,r2,168
8110f2e0:	1000171e 	bne	r2,zero,8110f340 <vQCmdFEEinConfig+0x108>
8110f2e4:	00003406 	br	8110f3b8 <vQCmdFEEinConfig+0x180>
8110f2e8:	10803c20 	cmpeqi	r2,r2,240
8110f2ec:	10001e1e 	bne	r2,zero,8110f368 <vQCmdFEEinConfig+0x130>
8110f2f0:	00003106 	br	8110f3b8 <vQCmdFEEinConfig+0x180>
			case M_FEE_CONFIG_FORCED:
			case M_FEE_CONFIG:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
8110f2f4:	d0e06117 	ldw	r3,-32380(gp)
8110f2f8:	e0bffe17 	ldw	r2,-8(fp)
8110f2fc:	10800003 	ldbu	r2,0(r2)
8110f300:	10803fcc 	andi	r2,r2,255
8110f304:	100d883a 	mov	r6,r2
8110f308:	01604574 	movhi	r5,33045
8110f30c:	296ec504 	addi	r5,r5,-17644
8110f310:	1809883a 	mov	r4,r3
8110f314:	11207b80 	call	811207b8 <fprintf>
				#endif
				break;
8110f318:	00003206 	br	8110f3e4 <vQCmdFEEinConfig+0x1ac>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				break;*/
			case M_FEE_STANDBY: /* Config -> StandBy is always forced mode (don't need sync) */
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f31c:	e0bffe17 	ldw	r2,-8(fp)
8110f320:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110f324:	e0bffe17 	ldw	r2,-8(fp)
8110f328:	00c00184 	movi	r3,6
8110f32c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f330:	e0bffe17 	ldw	r2,-8(fp)
8110f334:	00c00184 	movi	r3,6
8110f338:	10c02d15 	stw	r3,180(r2)
				break;				
8110f33c:	00002906 	br	8110f3e4 <vQCmdFEEinConfig+0x1ac>
			case M_FEE_FULL_PATTERN_FORCED:
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
8110f340:	d0e06117 	ldw	r3,-32380(gp)
8110f344:	e0bffe17 	ldw	r2,-8(fp)
8110f348:	10800003 	ldbu	r2,0(r2)
8110f34c:	10803fcc 	andi	r2,r2,255
8110f350:	100d883a 	mov	r6,r2
8110f354:	01604574 	movhi	r5,33045
8110f358:	296ed004 	addi	r5,r5,-17600
8110f35c:	1809883a 	mov	r4,r3
8110f360:	11207b80 	call	811207b8 <fprintf>
				#endif
				break;
8110f364:	00001f06 	br	8110f3e4 <vQCmdFEEinConfig+0x1ac>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Shouldn't receive RMAP Messages in this mode (Config Mode)\n", pxNFeeP->ucId);
8110f368:	d0e06117 	ldw	r3,-32380(gp)
8110f36c:	e0bffe17 	ldw	r2,-8(fp)
8110f370:	10800003 	ldbu	r2,0(r2)
8110f374:	10803fcc 	andi	r2,r2,255
8110f378:	100d883a 	mov	r6,r2
8110f37c:	01604574 	movhi	r5,33045
8110f380:	296ee104 	addi	r5,r5,-17532
8110f384:	1809883a 	mov	r4,r3
8110f388:	11207b80 	call	811207b8 <fprintf>
				#endif
				break;
8110f38c:	00001506 	br	8110f3e4 <vQCmdFEEinConfig+0x1ac>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f390:	e0bffe17 	ldw	r2,-8(fp)
8110f394:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f398:	e0bffe17 	ldw	r2,-8(fp)
8110f39c:	10800003 	ldbu	r2,0(r2)
8110f3a0:	10803fcc 	andi	r2,r2,255
8110f3a4:	100d883a 	mov	r6,r2
8110f3a8:	000b883a 	mov	r5,zero
8110f3ac:	01002044 	movi	r4,129
8110f3b0:	11104940 	call	81110494 <bSendGiveBackNFeeCtrl>
				break;
8110f3b4:	00000b06 	br	8110f3e4 <vQCmdFEEinConfig+0x1ac>
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110f3b8:	d0e06117 	ldw	r3,-32380(gp)
8110f3bc:	e0bffe17 	ldw	r2,-8(fp)
8110f3c0:	10800003 	ldbu	r2,0(r2)
8110f3c4:	10803fcc 	andi	r2,r2,255
8110f3c8:	100d883a 	mov	r6,r2
8110f3cc:	01604574 	movhi	r5,33045
8110f3d0:	296ef404 	addi	r5,r5,-17456
8110f3d4:	1809883a 	mov	r4,r3
8110f3d8:	11207b80 	call	811207b8 <fprintf>
				#endif
				break;
8110f3dc:	00000106 	br	8110f3e4 <vQCmdFEEinConfig+0x1ac>
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
				break;
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
8110f3e0:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110f3e4:	0001883a 	nop
8110f3e8:	e037883a 	mov	sp,fp
8110f3ec:	dfc00117 	ldw	ra,4(sp)
8110f3f0:	df000017 	ldw	fp,0(sp)
8110f3f4:	dec00204 	addi	sp,sp,8
8110f3f8:	f800283a 	ret

8110f3fc <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
8110f3fc:	defffb04 	addi	sp,sp,-20
8110f400:	de00012e 	bgeu	sp,et,8110f408 <vQCmdFEEinStandBy+0xc>
8110f404:	003b68fa 	trap	3
8110f408:	dfc00415 	stw	ra,16(sp)
8110f40c:	df000315 	stw	fp,12(sp)
8110f410:	df000304 	addi	fp,sp,12
8110f414:	e13ffe15 	stw	r4,-8(fp)
8110f418:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f41c:	e0bfff17 	ldw	r2,-4(fp)
8110f420:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f424:	e0bffdc3 	ldbu	r2,-9(fp)
8110f428:	10c03fcc 	andi	r3,r2,255
8110f42c:	e0bffe17 	ldw	r2,-8(fp)
8110f430:	10800003 	ldbu	r2,0(r2)
8110f434:	10803fcc 	andi	r2,r2,255
8110f438:	10800444 	addi	r2,r2,17
8110f43c:	1880681e 	bne	r3,r2,8110f5e0 <vQCmdFEEinStandBy+0x1e4>

		switch (uiCmdFEEL.ucByte[2]) {
8110f440:	e0bffd83 	ldbu	r2,-10(fp)
8110f444:	10803fcc 	andi	r2,r2,255
8110f448:	10c02860 	cmpeqi	r3,r2,161
8110f44c:	18001a1e 	bne	r3,zero,8110f4b8 <vQCmdFEEinStandBy+0xbc>
8110f450:	10c02888 	cmpgei	r3,r2,162
8110f454:	18000c1e 	bne	r3,zero,8110f488 <vQCmdFEEinStandBy+0x8c>
8110f458:	10c00120 	cmpeqi	r3,r2,4
8110f45c:	18001f1e 	bne	r3,zero,8110f4dc <vQCmdFEEinStandBy+0xe0>
8110f460:	10c00148 	cmpgei	r3,r2,5
8110f464:	1800031e 	bne	r3,zero,8110f474 <vQCmdFEEinStandBy+0x78>
8110f468:	10800060 	cmpeqi	r2,r2,1
8110f46c:	1000121e 	bne	r2,zero,8110f4b8 <vQCmdFEEinStandBy+0xbc>
8110f470:	00005006 	br	8110f5b4 <vQCmdFEEinStandBy+0x1b8>
8110f474:	10c00220 	cmpeqi	r3,r2,8
8110f478:	1800221e 	bne	r3,zero,8110f504 <vQCmdFEEinStandBy+0x108>
8110f47c:	108023e0 	cmpeqi	r2,r2,143
8110f480:	1000421e 	bne	r2,zero,8110f58c <vQCmdFEEinStandBy+0x190>
8110f484:	00004b06 	br	8110f5b4 <vQCmdFEEinStandBy+0x1b8>
8110f488:	10c03888 	cmpgei	r3,r2,226
8110f48c:	1800071e 	bne	r3,zero,8110f4ac <vQCmdFEEinStandBy+0xb0>
8110f490:	10c03808 	cmpgei	r3,r2,224
8110f494:	1800321e 	bne	r3,zero,8110f560 <vQCmdFEEinStandBy+0x164>
8110f498:	10c02920 	cmpeqi	r3,r2,164
8110f49c:	18000f1e 	bne	r3,zero,8110f4dc <vQCmdFEEinStandBy+0xe0>
8110f4a0:	10802a20 	cmpeqi	r2,r2,168
8110f4a4:	1000171e 	bne	r2,zero,8110f504 <vQCmdFEEinStandBy+0x108>
8110f4a8:	00004206 	br	8110f5b4 <vQCmdFEEinStandBy+0x1b8>
8110f4ac:	10803c20 	cmpeqi	r2,r2,240
8110f4b0:	10001e1e 	bne	r2,zero,8110f52c <vQCmdFEEinStandBy+0x130>
8110f4b4:	00003f06 	br	8110f5b4 <vQCmdFEEinStandBy+0x1b8>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f4b8:	e0bffe17 	ldw	r2,-8(fp)
8110f4bc:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110f4c0:	e0bffe17 	ldw	r2,-8(fp)
8110f4c4:	00c00144 	movi	r3,5
8110f4c8:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110f4cc:	e0bffe17 	ldw	r2,-8(fp)
8110f4d0:	00c00144 	movi	r3,5
8110f4d4:	10c02d15 	stw	r3,180(r2)
				break;				
8110f4d8:	00004106 	br	8110f5e0 <vQCmdFEEinStandBy+0x1e4>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by mode\n", pxNFeeP->ucId);
8110f4dc:	d0e06117 	ldw	r3,-32380(gp)
8110f4e0:	e0bffe17 	ldw	r2,-8(fp)
8110f4e4:	10800003 	ldbu	r2,0(r2)
8110f4e8:	10803fcc 	andi	r2,r2,255
8110f4ec:	100d883a 	mov	r6,r2
8110f4f0:	01604574 	movhi	r5,33045
8110f4f4:	296f0504 	addi	r5,r5,-17388
8110f4f8:	1809883a 	mov	r4,r3
8110f4fc:	11207b80 	call	811207b8 <fprintf>
				#endif
				break;
8110f500:	00003706 	br	8110f5e0 <vQCmdFEEinStandBy+0x1e4>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110f504:	e0bffe17 	ldw	r2,-8(fp)
8110f508:	00c00044 	movi	r3,1
8110f50c:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110f510:	e0bffe17 	ldw	r2,-8(fp)
8110f514:	00c00284 	movi	r3,10
8110f518:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110f51c:	e0bffe17 	ldw	r2,-8(fp)
8110f520:	00c00304 	movi	r3,12
8110f524:	10c02d15 	stw	r3,180(r2)
				break;
8110f528:	00002d06 	br	8110f5e0 <vQCmdFEEinStandBy+0x1e4>

			case M_FEE_RMAP:
				vQCmdFeeRMAPinStandBy( pxNFeeP, cmd );
8110f52c:	e17fff17 	ldw	r5,-4(fp)
8110f530:	e13ffe17 	ldw	r4,-8(fp)
8110f534:	110f8280 	call	8110f828 <vQCmdFeeRMAPinStandBy>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110f538:	d0e06117 	ldw	r3,-32380(gp)
8110f53c:	e0bffe17 	ldw	r2,-8(fp)
8110f540:	10800003 	ldbu	r2,0(r2)
8110f544:	10803fcc 	andi	r2,r2,255
8110f548:	100d883a 	mov	r6,r2
8110f54c:	01604574 	movhi	r5,33045
8110f550:	296eaa04 	addi	r5,r5,-17752
8110f554:	1809883a 	mov	r4,r3
8110f558:	11207b80 	call	811207b8 <fprintf>
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */

				break;
8110f55c:	00002006 	br	8110f5e0 <vQCmdFEEinStandBy+0x1e4>


			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8110f560:	e0bffe17 	ldw	r2,-8(fp)
8110f564:	10802c17 	ldw	r2,176(r2)
8110f568:	10800318 	cmpnei	r2,r2,12
8110f56c:	10001b1e 	bne	r2,zero,8110f5dc <vQCmdFEEinStandBy+0x1e0>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f570:	e0bffe17 	ldw	r2,-8(fp)
8110f574:	10c02d17 	ldw	r3,180(r2)
8110f578:	e0bffe17 	ldw	r2,-8(fp)
8110f57c:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f580:	e0bffe17 	ldw	r2,-8(fp)
8110f584:	10002815 	stw	zero,160(r2)
				}
				break;
8110f588:	00001406 	br	8110f5dc <vQCmdFEEinStandBy+0x1e0>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110f58c:	e0bffe17 	ldw	r2,-8(fp)
8110f590:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110f594:	e0bffe17 	ldw	r2,-8(fp)
8110f598:	10800003 	ldbu	r2,0(r2)
8110f59c:	10803fcc 	andi	r2,r2,255
8110f5a0:	100d883a 	mov	r6,r2
8110f5a4:	000b883a 	mov	r5,zero
8110f5a8:	01002044 	movi	r4,129
8110f5ac:	11104940 	call	81110494 <bSendGiveBackNFeeCtrl>
				break;
8110f5b0:	00000b06 	br	8110f5e0 <vQCmdFEEinStandBy+0x1e4>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110f5b4:	d0e06117 	ldw	r3,-32380(gp)
8110f5b8:	e0bffe17 	ldw	r2,-8(fp)
8110f5bc:	10800003 	ldbu	r2,0(r2)
8110f5c0:	10803fcc 	andi	r2,r2,255
8110f5c4:	100d883a 	mov	r6,r2
8110f5c8:	01604574 	movhi	r5,33045
8110f5cc:	296eb404 	addi	r5,r5,-17712
8110f5d0:	1809883a 	mov	r4,r3
8110f5d4:	11207b80 	call	811207b8 <fprintf>
				#endif
				break;
8110f5d8:	00000106 	br	8110f5e0 <vQCmdFEEinStandBy+0x1e4>
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}
				break;
8110f5dc:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110f5e0:	0001883a 	nop
8110f5e4:	e037883a 	mov	sp,fp
8110f5e8:	dfc00117 	ldw	ra,4(sp)
8110f5ec:	df000017 	ldw	fp,0(sp)
8110f5f0:	dec00204 	addi	sp,sp,8
8110f5f4:	f800283a 	ret

8110f5f8 <vQCmdFEEinFullPattern>:



void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
8110f5f8:	defffb04 	addi	sp,sp,-20
8110f5fc:	de00012e 	bgeu	sp,et,8110f604 <vQCmdFEEinFullPattern+0xc>
8110f600:	003b68fa 	trap	3
8110f604:	dfc00415 	stw	ra,16(sp)
8110f608:	df000315 	stw	fp,12(sp)
8110f60c:	df000304 	addi	fp,sp,12
8110f610:	e13ffe15 	stw	r4,-8(fp)
8110f614:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110f618:	e0bfff17 	ldw	r2,-4(fp)
8110f61c:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110f620:	e0bffdc3 	ldbu	r2,-9(fp)
8110f624:	10c03fcc 	andi	r3,r2,255
8110f628:	e0bffe17 	ldw	r2,-8(fp)
8110f62c:	10800003 	ldbu	r2,0(r2)
8110f630:	10803fcc 	andi	r2,r2,255
8110f634:	10800444 	addi	r2,r2,17
8110f638:	1880751e 	bne	r3,r2,8110f810 <vQCmdFEEinFullPattern+0x218>

		switch (uiCmdFEEL.ucByte[2]) {
8110f63c:	e0bffd83 	ldbu	r2,-10(fp)
8110f640:	10803fcc 	andi	r2,r2,255
8110f644:	10c02860 	cmpeqi	r3,r2,161
8110f648:	1800181e 	bne	r3,zero,8110f6ac <vQCmdFEEinFullPattern+0xb4>
8110f64c:	10c02888 	cmpgei	r3,r2,162
8110f650:	18000c1e 	bne	r3,zero,8110f684 <vQCmdFEEinFullPattern+0x8c>
8110f654:	10c000a0 	cmpeqi	r3,r2,2
8110f658:	18006a1e 	bne	r3,zero,8110f804 <vQCmdFEEinFullPattern+0x20c>
8110f65c:	10c000c8 	cmpgei	r3,r2,3
8110f660:	1800031e 	bne	r3,zero,8110f670 <vQCmdFEEinFullPattern+0x78>
8110f664:	10800060 	cmpeqi	r2,r2,1
8110f668:	1000101e 	bne	r2,zero,8110f6ac <vQCmdFEEinFullPattern+0xb4>
8110f66c:	00005b06 	br	8110f7dc <vQCmdFEEinFullPattern+0x1e4>
8110f670:	10c00120 	cmpeqi	r3,r2,4
8110f674:	1800161e 	bne	r3,zero,8110f6d0 <vQCmdFEEinFullPattern+0xd8>
8110f678:	10800220 	cmpeqi	r2,r2,8
8110f67c:	1000351e 	bne	r2,zero,8110f754 <vQCmdFEEinFullPattern+0x15c>
8110f680:	00005606 	br	8110f7dc <vQCmdFEEinFullPattern+0x1e4>
8110f684:	10c03888 	cmpgei	r3,r2,226
8110f688:	1800051e 	bne	r3,zero,8110f6a0 <vQCmdFEEinFullPattern+0xa8>
8110f68c:	10c03808 	cmpgei	r3,r2,224
8110f690:	1800471e 	bne	r3,zero,8110f7b0 <vQCmdFEEinFullPattern+0x1b8>
8110f694:	10802920 	cmpeqi	r2,r2,164
8110f698:	1000251e 	bne	r2,zero,8110f730 <vQCmdFEEinFullPattern+0x138>
8110f69c:	00004f06 	br	8110f7dc <vQCmdFEEinFullPattern+0x1e4>
8110f6a0:	10803c20 	cmpeqi	r2,r2,240
8110f6a4:	1000351e 	bne	r2,zero,8110f77c <vQCmdFEEinFullPattern+0x184>
8110f6a8:	00004c06 	br	8110f7dc <vQCmdFEEinFullPattern+0x1e4>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f6ac:	e0bffe17 	ldw	r2,-8(fp)
8110f6b0:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110f6b4:	e0bffe17 	ldw	r2,-8(fp)
8110f6b8:	00c00144 	movi	r3,5
8110f6bc:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110f6c0:	e0bffe17 	ldw	r2,-8(fp)
8110f6c4:	00c00144 	movi	r3,5
8110f6c8:	10c02d15 	stw	r3,180(r2)
				break;				
8110f6cc:	00005006 	br	8110f810 <vQCmdFEEinFullPattern+0x218>
				break;
			case M_FEE_STANDBY:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;*/ /* To finish the actual transfer only when sync comes */
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
8110f6d0:	e0bffe17 	ldw	r2,-8(fp)
8110f6d4:	10802c17 	ldw	r2,176(r2)
8110f6d8:	10800298 	cmpnei	r2,r2,10
8110f6dc:	10000a1e 	bne	r2,zero,8110f708 <vQCmdFEEinFullPattern+0x110>
					pxNFeeP->xControl.bWatingSync = TRUE;
8110f6e0:	e0bffe17 	ldw	r2,-8(fp)
8110f6e4:	00c00044 	movi	r3,1
8110f6e8:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110f6ec:	e0bffe17 	ldw	r2,-8(fp)
8110f6f0:	00c00304 	movi	r3,12
8110f6f4:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f6f8:	e0bffe17 	ldw	r2,-8(fp)
8110f6fc:	00c00184 	movi	r3,6
8110f700:	10c02d15 	stw	r3,180(r2)
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				}

				break;
8110f704:	00004206 	br	8110f810 <vQCmdFEEinFullPattern+0x218>
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				} else {
					pxNFeeP->xControl.bWatingSync = TRUE;
8110f708:	e0bffe17 	ldw	r2,-8(fp)
8110f70c:	00c00044 	movi	r3,1
8110f710:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8110f714:	e0bffe17 	ldw	r2,-8(fp)
8110f718:	00c00104 	movi	r3,4
8110f71c:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f720:	e0bffe17 	ldw	r2,-8(fp)
8110f724:	00c00184 	movi	r3,6
8110f728:	10c02d15 	stw	r3,180(r2)
				}

				break;
8110f72c:	00003806 	br	8110f810 <vQCmdFEEinFullPattern+0x218>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110f730:	e0bffe17 	ldw	r2,-8(fp)
8110f734:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110f738:	e0bffe17 	ldw	r2,-8(fp)
8110f73c:	00c00184 	movi	r3,6
8110f740:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110f744:	e0bffe17 	ldw	r2,-8(fp)
8110f748:	00c00184 	movi	r3,6
8110f74c:	10c02d15 	stw	r3,180(r2)
				break;				
8110f750:	00002f06 	br	8110f810 <vQCmdFEEinFullPattern+0x218>
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
8110f754:	d0e06117 	ldw	r3,-32380(gp)
8110f758:	e0bffe17 	ldw	r2,-8(fp)
8110f75c:	10800003 	ldbu	r2,0(r2)
8110f760:	10803fcc 	andi	r2,r2,255
8110f764:	100d883a 	mov	r6,r2
8110f768:	01604574 	movhi	r5,33045
8110f76c:	296f1004 	addi	r5,r5,-17344
8110f770:	1809883a 	mov	r4,r3
8110f774:	11207b80 	call	811207b8 <fprintf>
				#endif
				break;
8110f778:	00002506 	br	8110f810 <vQCmdFEEinFullPattern+0x218>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110f77c:	d0e06117 	ldw	r3,-32380(gp)
8110f780:	e0bffe17 	ldw	r2,-8(fp)
8110f784:	10800003 	ldbu	r2,0(r2)
8110f788:	10803fcc 	andi	r2,r2,255
8110f78c:	100d883a 	mov	r6,r2
8110f790:	01604574 	movhi	r5,33045
8110f794:	296eaa04 	addi	r5,r5,-17752
8110f798:	1809883a 	mov	r4,r3
8110f79c:	11207b80 	call	811207b8 <fprintf>
				#endif

				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPinFullPattern( pxNFeeP, cmd );
8110f7a0:	e17fff17 	ldw	r5,-4(fp)
8110f7a4:	e13ffe17 	ldw	r4,-8(fp)
8110f7a8:	110fcd00 	call	8110fcd0 <vQCmdFeeRMAPinFullPattern>

				break;
8110f7ac:	00001806 	br	8110f810 <vQCmdFEEinFullPattern+0x218>

			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8110f7b0:	e0bffe17 	ldw	r2,-8(fp)
8110f7b4:	10802c17 	ldw	r2,176(r2)
8110f7b8:	10800318 	cmpnei	r2,r2,12
8110f7bc:	1000131e 	bne	r2,zero,8110f80c <vQCmdFEEinFullPattern+0x214>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f7c0:	e0bffe17 	ldw	r2,-8(fp)
8110f7c4:	10c02d17 	ldw	r3,180(r2)
8110f7c8:	e0bffe17 	ldw	r2,-8(fp)
8110f7cc:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f7d0:	e0bffe17 	ldw	r2,-8(fp)
8110f7d4:	10002815 	stw	zero,160(r2)
				}

				break;
8110f7d8:	00000c06 	br	8110f80c <vQCmdFEEinFullPattern+0x214>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110f7dc:	d0e06117 	ldw	r3,-32380(gp)
8110f7e0:	e0bffe17 	ldw	r2,-8(fp)
8110f7e4:	10800003 	ldbu	r2,0(r2)
8110f7e8:	10803fcc 	andi	r2,r2,255
8110f7ec:	100d883a 	mov	r6,r2
8110f7f0:	01604574 	movhi	r5,33045
8110f7f4:	296ef404 	addi	r5,r5,-17456
8110f7f8:	1809883a 	mov	r4,r3
8110f7fc:	11207b80 	call	811207b8 <fprintf>
				#endif
				break;
8110f800:	00000306 	br	8110f810 <vQCmdFEEinFullPattern+0x218>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110f804:	0001883a 	nop
8110f808:	00000106 	br	8110f810 <vQCmdFEEinFullPattern+0x218>
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}

				break;
8110f80c:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110f810:	0001883a 	nop
8110f814:	e037883a 	mov	sp,fp
8110f818:	dfc00117 	ldw	ra,4(sp)
8110f81c:	df000017 	ldw	fp,0(sp)
8110f820:	dec00204 	addi	sp,sp,8
8110f824:	f800283a 	ret

8110f828 <vQCmdFeeRMAPinStandBy>:



void vQCmdFeeRMAPinStandBy( TNFee *pxNFeeP, unsigned int cmd ){
8110f828:	defff704 	addi	sp,sp,-36
8110f82c:	de00012e 	bgeu	sp,et,8110f834 <vQCmdFeeRMAPinStandBy+0xc>
8110f830:	003b68fa 	trap	3
8110f834:	dfc00815 	stw	ra,32(sp)
8110f838:	df000715 	stw	fp,28(sp)
8110f83c:	df000704 	addi	fp,sp,28
8110f840:	e13ffe15 	stw	r4,-8(fp)
8110f844:	e17fff15 	stw	r5,-4(fp)
	INT32U ucValueMasked;
	INT32U ucValueMasked2;


#ifdef DEBUG_ON
	fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (StandBy)\n", pxNFeeP->ucId);
8110f848:	d0e06117 	ldw	r3,-32380(gp)
8110f84c:	e0bffe17 	ldw	r2,-8(fp)
8110f850:	10800003 	ldbu	r2,0(r2)
8110f854:	10803fcc 	andi	r2,r2,255
8110f858:	100d883a 	mov	r6,r2
8110f85c:	01604574 	movhi	r5,33045
8110f860:	296f1e04 	addi	r5,r5,-17288
8110f864:	1809883a 	mov	r4,r3
8110f868:	11207b80 	call	811207b8 <fprintf>
#endif


	uiCmdFEEL.ulWord = cmd;
8110f86c:	e0bfff17 	ldw	r2,-4(fp)
8110f870:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110f874:	e0bffd43 	ldbu	r2,-11(fp)
8110f878:	e0bff905 	stb	r2,-28(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110f87c:	e0bffe17 	ldw	r2,-8(fp)
8110f880:	10804317 	ldw	r2,268(r2)
8110f884:	e0fff903 	ldbu	r3,-28(fp)
8110f888:	180b883a 	mov	r5,r3
8110f88c:	1009883a 	mov	r4,r2
8110f890:	1109ed40 	call	81109ed4 <uliRmapReadReg>
8110f894:	e0bffa15 	stw	r2,-24(fp)

	switch (ucADDRReg) {
8110f898:	e0bff903 	ldbu	r2,-28(fp)
8110f89c:	10bff004 	addi	r2,r2,-64
8110f8a0:	10c003a8 	cmpgeui	r3,r2,14
8110f8a4:	1800f91e 	bne	r3,zero,8110fc8c <vQCmdFeeRMAPinStandBy+0x464>
8110f8a8:	100690ba 	slli	r3,r2,2
8110f8ac:	00a04474 	movhi	r2,33041
8110f8b0:	10be3004 	addi	r2,r2,-1856
8110f8b4:	1885883a 	add	r2,r3,r2
8110f8b8:	10800017 	ldw	r2,0(r2)
8110f8bc:	1000683a 	jmp	r2
8110f8c0:	8110f8f8 	rdprs	r4,r16,17379
8110f8c4:	8110fcac 	andhi	r4,r16,17394
8110f8c8:	8110f9c4 	addi	r4,r16,17383
8110f8cc:	8110fb2c 	andhi	r4,r16,17388
8110f8d0:	8110fb2c 	andhi	r4,r16,17388
8110f8d4:	8110fb2c 	andhi	r4,r16,17388
8110f8d8:	8110fb2c 	andhi	r4,r16,17388
8110f8dc:	8110fb2c 	andhi	r4,r16,17388
8110f8e0:	8110fb2c 	andhi	r4,r16,17388
8110f8e4:	8110fb2c 	andhi	r4,r16,17388
8110f8e8:	8110fb2c 	andhi	r4,r16,17388
8110f8ec:	8110fb2c 	andhi	r4,r16,17388
8110f8f0:	8110fb48 	cmpgei	r4,r16,17389
8110f8f4:	8110fc1c 	xori	r4,r16,17392
		case 0x40://0x00000000: ccd_seq_1_config
			ucValueMasked = (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 4; /* Number of rows */
8110f8f8:	e0fffa17 	ldw	r3,-24(fp)
8110f8fc:	00800434 	movhi	r2,16
8110f900:	10bffc04 	addi	r2,r2,-16
8110f904:	1884703a 	and	r2,r3,r2
8110f908:	1004d13a 	srli	r2,r2,4
8110f90c:	e0bffb15 	stw	r2,-20(fp)
			ucValueMasked2 = (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 20; /* Number of columns */
8110f910:	e0bffa17 	ldw	r2,-24(fp)
8110f914:	1004d53a 	srli	r2,r2,20
8110f918:	e0bffc15 	stw	r2,-16(fp)

			pxNFeeP->xCcdInfo.usiHeight = ucValueMasked;
8110f91c:	e0bffb17 	ldw	r2,-20(fp)
8110f920:	1007883a 	mov	r3,r2
8110f924:	e0bffe17 	ldw	r2,-8(fp)
8110f928:	10c0310d 	sth	r3,196(r2)
			pxNFeeP->xCcdInfo.usiHalfWidth = ucValueMasked2;
8110f92c:	e0bffc17 	ldw	r2,-16(fp)
8110f930:	1007883a 	mov	r3,r2
8110f934:	e0bffe17 	ldw	r2,-8(fp)
8110f938:	10c0308d 	sth	r3,194(r2)
			vUpdateMemMapFEE(pxNFeeP);
8110f93c:	e13ffe17 	ldw	r4,-8(fp)
8110f940:	111ccb40 	call	8111ccb4 <vUpdateMemMapFEE>

			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110f944:	e0bffe17 	ldw	r2,-8(fp)
8110f948:	10803304 	addi	r2,r2,204
8110f94c:	1009883a 	mov	r4,r2
8110f950:	1104a440 	call	81104a44 <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFeeP->xCcdInfo.usiHalfWidth;
8110f954:	e0bffe17 	ldw	r2,-8(fp)
8110f958:	10c0308b 	ldhu	r3,194(r2)
8110f95c:	e0bffe17 	ldw	r2,-8(fp)
8110f960:	10c0340d 	sth	r3,208(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFeeP->xCcdInfo.usiHeight;
8110f964:	e0bffe17 	ldw	r2,-8(fp)
8110f968:	10c0310b 	ldhu	r3,196(r2)
8110f96c:	e0bffe17 	ldw	r2,-8(fp)
8110f970:	10c0348d 	sth	r3,210(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFeeP->xCcdInfo.usiHeight - pxNFeeP->xCcdInfo.usiOLN;
8110f974:	e0bffe17 	ldw	r2,-8(fp)
8110f978:	10c0310b 	ldhu	r3,196(r2)
8110f97c:	e0bffe17 	ldw	r2,-8(fp)
8110f980:	1080300b 	ldhu	r2,192(r2)
8110f984:	1885c83a 	sub	r2,r3,r2
8110f988:	1007883a 	mov	r3,r2
8110f98c:	e0bffe17 	ldw	r2,-8(fp)
8110f990:	10c0350d 	sth	r3,212(r2)
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110f994:	e0bffe17 	ldw	r2,-8(fp)
8110f998:	10803304 	addi	r2,r2,204
8110f99c:	1009883a 	mov	r4,r2
8110f9a0:	11048180 	call	81104818 <bDpktSetPacketConfig>

			#ifdef DEBUG_ON
				fprintf(fp,"- Rows: %u\n - Columns: %u\n", ucValueMasked, ucValueMasked2);
8110f9a4:	d0a06117 	ldw	r2,-32380(gp)
8110f9a8:	e1fffc17 	ldw	r7,-16(fp)
8110f9ac:	e1bffb17 	ldw	r6,-20(fp)
8110f9b0:	01604574 	movhi	r5,33045
8110f9b4:	296f2a04 	addi	r5,r5,-17240
8110f9b8:	1009883a 	mov	r4,r2
8110f9bc:	11207b80 	call	811207b8 <fprintf>
			#endif

			break;
8110f9c0:	0000bd06 	br	8110fcb8 <vQCmdFeeRMAPinStandBy+0x490>
		case 0x041://0x00000004:ccd_seq_2_config
			break;
		case 0x042://0x00000008:spw_packet_1_config

			ucValueMasked = (ucValueReg & COMM_RMAP_PACKET_SIZE_CTRL_MSK) >> 4;
8110f9c4:	e0fffa17 	ldw	r3,-24(fp)
8110f9c8:	00800434 	movhi	r2,16
8110f9cc:	10bffc04 	addi	r2,r2,-16
8110f9d0:	1884703a 	and	r2,r3,r2
8110f9d4:	1004d13a 	srli	r2,r2,4
8110f9d8:	e0bffb15 	stw	r2,-20(fp)
			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110f9dc:	e0bffe17 	ldw	r2,-8(fp)
8110f9e0:	10803304 	addi	r2,r2,204
8110f9e4:	1009883a 	mov	r4,r2
8110f9e8:	1104a440 	call	81104a44 <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = ucValueMasked;
8110f9ec:	e0bffb17 	ldw	r2,-20(fp)
8110f9f0:	1007883a 	mov	r3,r2
8110f9f4:	e0bffe17 	ldw	r2,-8(fp)
8110f9f8:	10c0360d 	sth	r3,216(r2)
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110f9fc:	e0bffe17 	ldw	r2,-8(fp)
8110fa00:	10803304 	addi	r2,r2,204
8110fa04:	1009883a 	mov	r4,r2
8110fa08:	11048180 	call	81104818 <bDpktSetPacketConfig>

			#ifdef DEBUG_ON
				fprintf(fp,"- Pckt Length: %u\n", ucValueMasked);
8110fa0c:	d0a06117 	ldw	r2,-32380(gp)
8110fa10:	e1bffb17 	ldw	r6,-20(fp)
8110fa14:	01604574 	movhi	r5,33045
8110fa18:	296f3104 	addi	r5,r5,-17212
8110fa1c:	1009883a 	mov	r4,r2
8110fa20:	11207b80 	call	811207b8 <fprintf>
			#endif

			ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8110fa24:	e0bffa17 	ldw	r2,-24(fp)
8110fa28:	1080030c 	andi	r2,r2,12
8110fa2c:	1004d0ba 	srli	r2,r2,2
8110fa30:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked2) {
8110fa34:	e0bffc17 	ldw	r2,-16(fp)
8110fa38:	10c000a0 	cmpeqi	r3,r2,2
8110fa3c:	18000e1e 	bne	r3,zero,8110fa78 <vQCmdFeeRMAPinStandBy+0x250>
8110fa40:	10c000e0 	cmpeqi	r3,r2,3
8110fa44:	1800171e 	bne	r3,zero,8110faa4 <vQCmdFeeRMAPinStandBy+0x27c>
8110fa48:	10800060 	cmpeqi	r2,r2,1
8110fa4c:	10001e26 	beq	r2,zero,8110fac8 <vQCmdFeeRMAPinStandBy+0x2a0>
				case 0b01:
					pxNFeeP->xControl.eSide = sLeft;
8110fa50:	e0bffe17 	ldw	r2,-8(fp)
8110fa54:	10002e15 	stw	zero,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Left side\n");
8110fa58:	d0a06117 	ldw	r2,-32380(gp)
8110fa5c:	100f883a 	mov	r7,r2
8110fa60:	01800344 	movi	r6,13
8110fa64:	01400044 	movi	r5,1
8110fa68:	01204574 	movhi	r4,33045
8110fa6c:	212f3604 	addi	r4,r4,-17192
8110fa70:	1120e540 	call	81120e54 <fwrite>
					#endif
					break;
8110fa74:	00002c06 	br	8110fb28 <vQCmdFeeRMAPinStandBy+0x300>
				case 0b10:
					pxNFeeP->xControl.eSide = sRight;
8110fa78:	e0bffe17 	ldw	r2,-8(fp)
8110fa7c:	00c00044 	movi	r3,1
8110fa80:	10c02e15 	stw	r3,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Right side\n");
8110fa84:	d0a06117 	ldw	r2,-32380(gp)
8110fa88:	100f883a 	mov	r7,r2
8110fa8c:	01800384 	movi	r6,14
8110fa90:	01400044 	movi	r5,1
8110fa94:	01204574 	movhi	r4,33045
8110fa98:	212f3a04 	addi	r4,r4,-17176
8110fa9c:	1120e540 	call	81120e54 <fwrite>
					#endif
					break;
8110faa0:	00002106 	br	8110fb28 <vQCmdFeeRMAPinStandBy+0x300>
				case 0b11:
					pxNFeeP->xControl.eSide = sLeft;
8110faa4:	e0bffe17 	ldw	r2,-8(fp)
8110faa8:	10002e15 	stw	zero,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
8110faac:	d0a06117 	ldw	r2,-32380(gp)
8110fab0:	100f883a 	mov	r7,r2
8110fab4:	01800f44 	movi	r6,61
8110fab8:	01400044 	movi	r5,1
8110fabc:	01204574 	movhi	r4,33045
8110fac0:	212f3e04 	addi	r4,r4,-17160
8110fac4:	1120e540 	call	81120e54 <fwrite>
					#endif
				default:
					pxNFeeP->xControl.eSide = sLeft;
8110fac8:	e0bffe17 	ldw	r2,-8(fp)
8110facc:	10002e15 	stw	zero,184(r2)

					bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110fad0:	e0bffe17 	ldw	r2,-8(fp)
8110fad4:	10804304 	addi	r2,r2,268
8110fad8:	1009883a 	mov	r4,r2
8110fadc:	110815c0 	call	8110815c <bRmapGetMemConfigArea>
					pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
8110fae0:	e0bffe17 	ldw	r2,-8(fp)
8110fae4:	10c05717 	ldw	r3,348(r2)
8110fae8:	00bffdc4 	movi	r2,-9
8110faec:	1886703a 	and	r3,r3,r2
8110faf0:	e0bffe17 	ldw	r2,-8(fp)
8110faf4:	10c05715 	stw	r3,348(r2)
					bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110faf8:	e0bffe17 	ldw	r2,-8(fp)
8110fafc:	10804304 	addi	r2,r2,268
8110fb00:	1009883a 	mov	r4,r2
8110fb04:	1107e700 	call	81107e70 <bRmapSetMemConfigArea>
					#ifdef DEBUG_ON
						fprintf(fp," - Switching to Left side\n");
8110fb08:	d0a06117 	ldw	r2,-32380(gp)
8110fb0c:	100f883a 	mov	r7,r2
8110fb10:	01800684 	movi	r6,26
8110fb14:	01400044 	movi	r5,1
8110fb18:	01204574 	movhi	r4,33045
8110fb1c:	212f4e04 	addi	r4,r4,-17096
8110fb20:	1120e540 	call	81120e54 <fwrite>
					#endif
					break;
8110fb24:	0001883a 	nop
			}
			break;
8110fb28:	00006306 	br	8110fcb8 <vQCmdFeeRMAPinStandBy+0x490>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#ifdef DEBUG_ON
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucValueMasked);
8110fb2c:	d0a06117 	ldw	r2,-32380(gp)
8110fb30:	e1bffb17 	ldw	r6,-20(fp)
8110fb34:	01604574 	movhi	r5,33045
8110fb38:	296f5504 	addi	r5,r5,-17068
8110fb3c:	1009883a 	mov	r4,r2
8110fb40:	11207b80 	call	811207b8 <fprintf>
			#endif
				break;
8110fb44:	00005c06 	br	8110fcb8 <vQCmdFeeRMAPinStandBy+0x490>
		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8110fb48:	e0bffa17 	ldw	r2,-24(fp)
8110fb4c:	10803c0c 	andi	r2,r2,240
8110fb50:	1004d13a 	srli	r2,r2,4
8110fb54:	e0bffb15 	stw	r2,-20(fp)

			switch (ucValueMasked) {
8110fb58:	e0bffb17 	ldw	r2,-20(fp)
8110fb5c:	10c000a0 	cmpeqi	r3,r2,2
8110fb60:	18000d1e 	bne	r3,zero,8110fb98 <vQCmdFeeRMAPinStandBy+0x370>
8110fb64:	10c001a0 	cmpeqi	r3,r2,6
8110fb68:	18001c1e 	bne	r3,zero,8110fbdc <vQCmdFeeRMAPinStandBy+0x3b4>
8110fb6c:	1000231e 	bne	r2,zero,8110fbfc <vQCmdFeeRMAPinStandBy+0x3d4>
				case 0: /* Standby */

				#ifdef DEBUG_ON
					fprintf(fp,"- already in Stand by mode\n", pxNFeeP->ucId);
8110fb70:	d0e06117 	ldw	r3,-32380(gp)
8110fb74:	e0bffe17 	ldw	r2,-8(fp)
8110fb78:	10800003 	ldbu	r2,0(r2)
8110fb7c:	10803fcc 	andi	r2,r2,255
8110fb80:	100d883a 	mov	r6,r2
8110fb84:	01604574 	movhi	r5,33045
8110fb88:	296f5e04 	addi	r5,r5,-17032
8110fb8c:	1809883a 	mov	r4,r3
8110fb90:	11207b80 	call	811207b8 <fprintf>
				#endif

					break;
8110fb94:	00002006 	br	8110fc18 <vQCmdFeeRMAPinStandBy+0x3f0>
				case 2: /* PAttern Full image */
				#ifdef DEBUG_ON
					fprintf(fp,"- to Full-Image-Pattern\n");
8110fb98:	d0a06117 	ldw	r2,-32380(gp)
8110fb9c:	100f883a 	mov	r7,r2
8110fba0:	01800604 	movi	r6,24
8110fba4:	01400044 	movi	r5,1
8110fba8:	01204574 	movhi	r4,33045
8110fbac:	212f6504 	addi	r4,r4,-17004
8110fbb0:	1120e540 	call	81120e54 <fwrite>
				#endif

					pxNFeeP->xControl.bWatingSync = TRUE;
8110fbb4:	e0bffe17 	ldw	r2,-8(fp)
8110fbb8:	00c00044 	movi	r3,1
8110fbbc:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110fbc0:	e0bffe17 	ldw	r2,-8(fp)
8110fbc4:	00c00284 	movi	r3,10
8110fbc8:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110fbcc:	e0bffe17 	ldw	r2,-8(fp)
8110fbd0:	00c00304 	movi	r3,12
8110fbd4:	10c02d15 	stw	r3,180(r2)

					break;
8110fbd8:	00000f06 	br	8110fc18 <vQCmdFeeRMAPinStandBy+0x3f0>
				case 6:
				#ifdef DEBUG_ON
					fprintf(fp,"- Off-Mode not allowed.\n");
8110fbdc:	d0a06117 	ldw	r2,-32380(gp)
8110fbe0:	100f883a 	mov	r7,r2
8110fbe4:	01800604 	movi	r6,24
8110fbe8:	01400044 	movi	r5,1
8110fbec:	01204574 	movhi	r4,33045
8110fbf0:	212f6c04 	addi	r4,r4,-16976
8110fbf4:	1120e540 	call	81120e54 <fwrite>
				#endif
					break;
8110fbf8:	00000706 	br	8110fc18 <vQCmdFeeRMAPinStandBy+0x3f0>
				case 3:
				case 4:
				case 5:
				default:
					#ifdef DEBUG_ON
						fprintf(fp,"- mode not allowed yet ( %hhu )\n", ucValueMasked);
8110fbfc:	d0a06117 	ldw	r2,-32380(gp)
8110fc00:	e1bffb17 	ldw	r6,-20(fp)
8110fc04:	01604574 	movhi	r5,33045
8110fc08:	296f7304 	addi	r5,r5,-16948
8110fc0c:	1009883a 	mov	r4,r2
8110fc10:	11207b80 	call	811207b8 <fprintf>
					#endif
					break;
8110fc14:	0001883a 	nop
			}

			break;
8110fc18:	00002706 	br	8110fcb8 <vQCmdFeeRMAPinStandBy+0x490>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8110fc1c:	e0bffa17 	ldw	r2,-24(fp)
8110fc20:	1080010c 	andi	r2,r2,4
8110fc24:	1004d0ba 	srli	r2,r2,2
8110fc28:	e0bffb15 	stw	r2,-20(fp)

			/* Cannot perform this operation */
			if ( ucValueMasked ) {
8110fc2c:	e0bffb17 	ldw	r2,-20(fp)
8110fc30:	10002026 	beq	r2,zero,8110fcb4 <vQCmdFeeRMAPinStandBy+0x48c>
				#ifdef DEBUG_ON
					fprintf(fp," - operation not allowed (StandBy-Mode)\n");
8110fc34:	d0a06117 	ldw	r2,-32380(gp)
8110fc38:	100f883a 	mov	r7,r2
8110fc3c:	01800a04 	movi	r6,40
8110fc40:	01400044 	movi	r5,1
8110fc44:	01204574 	movhi	r4,33045
8110fc48:	212f7c04 	addi	r4,r4,-16912
8110fc4c:	1120e540 	call	81120e54 <fwrite>
				#endif
				/* Clear the trigger */
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110fc50:	e0bffe17 	ldw	r2,-8(fp)
8110fc54:	10804304 	addi	r2,r2,268
8110fc58:	1009883a 	mov	r4,r2
8110fc5c:	110815c0 	call	8110815c <bRmapGetMemConfigArea>
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
8110fc60:	e0bffe17 	ldw	r2,-8(fp)
8110fc64:	10c06217 	ldw	r3,392(r2)
8110fc68:	00bffec4 	movi	r2,-5
8110fc6c:	1886703a 	and	r3,r3,r2
8110fc70:	e0bffe17 	ldw	r2,-8(fp)
8110fc74:	10c06215 	stw	r3,392(r2)
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110fc78:	e0bffe17 	ldw	r2,-8(fp)
8110fc7c:	10804304 	addi	r2,r2,268
8110fc80:	1009883a 	mov	r4,r2
8110fc84:	1107e700 	call	81107e70 <bRmapSetMemConfigArea>
			}

			break;
8110fc88:	00000a06 	br	8110fcb4 <vQCmdFeeRMAPinStandBy+0x48c>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
8110fc8c:	d0a06117 	ldw	r2,-32380(gp)
8110fc90:	e0fff903 	ldbu	r3,-28(fp)
8110fc94:	180d883a 	mov	r6,r3
8110fc98:	01604574 	movhi	r5,33045
8110fc9c:	296f8704 	addi	r5,r5,-16868
8110fca0:	1009883a 	mov	r4,r2
8110fca4:	11207b80 	call	811207b8 <fprintf>
			#endif
			break;
8110fca8:	00000306 	br	8110fcb8 <vQCmdFeeRMAPinStandBy+0x490>
				fprintf(fp,"- Rows: %u\n - Columns: %u\n", ucValueMasked, ucValueMasked2);
			#endif

			break;
		case 0x041://0x00000004:ccd_seq_2_config
			break;
8110fcac:	0001883a 	nop
8110fcb0:	00000106 	br	8110fcb8 <vQCmdFeeRMAPinStandBy+0x490>
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
8110fcb4:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
8110fcb8:	0001883a 	nop
8110fcbc:	e037883a 	mov	sp,fp
8110fcc0:	dfc00117 	ldw	ra,4(sp)
8110fcc4:	df000017 	ldw	fp,0(sp)
8110fcc8:	dec00204 	addi	sp,sp,8
8110fccc:	f800283a 	ret

8110fcd0 <vQCmdFeeRMAPinFullPattern>:

void vQCmdFeeRMAPinFullPattern( TNFee *pxNFeeP, unsigned int cmd ) {
8110fcd0:	defff904 	addi	sp,sp,-28
8110fcd4:	de00012e 	bgeu	sp,et,8110fcdc <vQCmdFeeRMAPinFullPattern+0xc>
8110fcd8:	003b68fa 	trap	3
8110fcdc:	dfc00615 	stw	ra,24(sp)
8110fce0:	df000515 	stw	fp,20(sp)
8110fce4:	df000504 	addi	fp,sp,20
8110fce8:	e13ffe15 	stw	r4,-8(fp)
8110fcec:	e17fff15 	stw	r5,-4(fp)
	INT8U ucADDRReg;
	INT8U ucValueReg;
	INT32U ucValueMasked;

	#ifdef DEBUG_ON
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (FullPattern)\n", pxNFeeP->ucId);
8110fcf0:	d0e06117 	ldw	r3,-32380(gp)
8110fcf4:	e0bffe17 	ldw	r2,-8(fp)
8110fcf8:	10800003 	ldbu	r2,0(r2)
8110fcfc:	10803fcc 	andi	r2,r2,255
8110fd00:	100d883a 	mov	r6,r2
8110fd04:	01604574 	movhi	r5,33045
8110fd08:	296f9004 	addi	r5,r5,-16832
8110fd0c:	1809883a 	mov	r4,r3
8110fd10:	11207b80 	call	811207b8 <fprintf>
	#endif

	uiCmdFEEL.ulWord = cmd;
8110fd14:	e0bfff17 	ldw	r2,-4(fp)
8110fd18:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110fd1c:	e0bffd43 	ldbu	r2,-11(fp)
8110fd20:	e0bffb05 	stb	r2,-20(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110fd24:	e0bffe17 	ldw	r2,-8(fp)
8110fd28:	10804317 	ldw	r2,268(r2)
8110fd2c:	e0fffb03 	ldbu	r3,-20(fp)
8110fd30:	180b883a 	mov	r5,r3
8110fd34:	1009883a 	mov	r4,r2
8110fd38:	1109ed40 	call	81109ed4 <uliRmapReadReg>
8110fd3c:	e0bffb45 	stb	r2,-19(fp)


	switch (ucADDRReg) {
8110fd40:	e0bffb03 	ldbu	r2,-20(fp)
8110fd44:	10c01320 	cmpeqi	r3,r2,76
8110fd48:	18000f1e 	bne	r3,zero,8110fd88 <vQCmdFeeRMAPinFullPattern+0xb8>
8110fd4c:	10c01348 	cmpgei	r3,r2,77
8110fd50:	1800031e 	bne	r3,zero,8110fd60 <vQCmdFeeRMAPinFullPattern+0x90>
8110fd54:	10801010 	cmplti	r2,r2,64
8110fd58:	1000681e 	bne	r2,zero,8110fefc <vQCmdFeeRMAPinFullPattern+0x22c>
8110fd5c:	00000306 	br	8110fd6c <vQCmdFeeRMAPinFullPattern+0x9c>
8110fd60:	10801360 	cmpeqi	r2,r2,77
8110fd64:	10004b1e 	bne	r2,zero,8110fe94 <vQCmdFeeRMAPinFullPattern+0x1c4>
8110fd68:	00006406 	br	8110fefc <vQCmdFeeRMAPinFullPattern+0x22c>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucValueMasked);
8110fd6c:	d0a06117 	ldw	r2,-32380(gp)
8110fd70:	e1bffc17 	ldw	r6,-16(fp)
8110fd74:	01604574 	movhi	r5,33045
8110fd78:	296f8704 	addi	r5,r5,-16868
8110fd7c:	1009883a 	mov	r4,r2
8110fd80:	11207b80 	call	811207b8 <fprintf>
			#endif
				break;
8110fd84:	00006606 	br	8110ff20 <vQCmdFeeRMAPinFullPattern+0x250>

		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8110fd88:	e0bffb43 	ldbu	r2,-19(fp)
8110fd8c:	1004d13a 	srli	r2,r2,4
8110fd90:	10803fcc 	andi	r2,r2,255
8110fd94:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked) {
8110fd98:	e0bffc17 	ldw	r2,-16(fp)
8110fd9c:	10c000a0 	cmpeqi	r3,r2,2
8110fda0:	1800221e 	bne	r3,zero,8110fe2c <vQCmdFeeRMAPinFullPattern+0x15c>
8110fda4:	10c001a0 	cmpeqi	r3,r2,6
8110fda8:	18002a1e 	bne	r3,zero,8110fe54 <vQCmdFeeRMAPinFullPattern+0x184>
8110fdac:	1000311e 	bne	r2,zero,8110fe74 <vQCmdFeeRMAPinFullPattern+0x1a4>
				case 0: /* Standby */
				#ifdef DEBUG_ON
					fprintf(fp,"- to Stand-By\n");
8110fdb0:	d0a06117 	ldw	r2,-32380(gp)
8110fdb4:	100f883a 	mov	r7,r2
8110fdb8:	01800384 	movi	r6,14
8110fdbc:	01400044 	movi	r5,1
8110fdc0:	01204574 	movhi	r4,33045
8110fdc4:	212f9d04 	addi	r4,r4,-16780
8110fdc8:	1120e540 	call	81120e54 <fwrite>
				#endif

					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
8110fdcc:	e0bffe17 	ldw	r2,-8(fp)
8110fdd0:	10802c17 	ldw	r2,176(r2)
8110fdd4:	10800298 	cmpnei	r2,r2,10
8110fdd8:	10000a1e 	bne	r2,zero,8110fe04 <vQCmdFeeRMAPinFullPattern+0x134>
						pxNFeeP->xControl.bWatingSync = TRUE;
8110fddc:	e0bffe17 	ldw	r2,-8(fp)
8110fde0:	00c00044 	movi	r3,1
8110fde4:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110fde8:	e0bffe17 	ldw	r2,-8(fp)
8110fdec:	00c00304 	movi	r3,12
8110fdf0:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110fdf4:	e0bffe17 	ldw	r2,-8(fp)
8110fdf8:	00c00184 	movi	r3,6
8110fdfc:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
8110fe00:	00002306 	br	8110fe90 <vQCmdFeeRMAPinFullPattern+0x1c0>
					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
						pxNFeeP->xControl.bWatingSync = TRUE;
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
					} else {
						pxNFeeP->xControl.bWatingSync = TRUE;
8110fe04:	e0bffe17 	ldw	r2,-8(fp)
8110fe08:	00c00044 	movi	r3,1
8110fe0c:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8110fe10:	e0bffe17 	ldw	r2,-8(fp)
8110fe14:	00c00104 	movi	r3,4
8110fe18:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110fe1c:	e0bffe17 	ldw	r2,-8(fp)
8110fe20:	00c00184 	movi	r3,6
8110fe24:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
8110fe28:	00001906 	br	8110fe90 <vQCmdFeeRMAPinFullPattern+0x1c0>
				case 2: /* PAttern Full image */
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
8110fe2c:	d0e06117 	ldw	r3,-32380(gp)
8110fe30:	e0bffe17 	ldw	r2,-8(fp)
8110fe34:	10800003 	ldbu	r2,0(r2)
8110fe38:	10803fcc 	andi	r2,r2,255
8110fe3c:	100d883a 	mov	r6,r2
8110fe40:	01604574 	movhi	r5,33045
8110fe44:	296f1004 	addi	r5,r5,-17344
8110fe48:	1809883a 	mov	r4,r3
8110fe4c:	11207b80 	call	811207b8 <fprintf>
					#endif

					break;
8110fe50:	00000f06 	br	8110fe90 <vQCmdFeeRMAPinFullPattern+0x1c0>
				case 6:
				#ifdef DEBUG_ON
					fprintf(fp," Off-Mode not allowed.\n");
8110fe54:	d0a06117 	ldw	r2,-32380(gp)
8110fe58:	100f883a 	mov	r7,r2
8110fe5c:	018005c4 	movi	r6,23
8110fe60:	01400044 	movi	r5,1
8110fe64:	01204574 	movhi	r4,33045
8110fe68:	212fa104 	addi	r4,r4,-16764
8110fe6c:	1120e540 	call	81120e54 <fwrite>
				#endif
					break;
8110fe70:	00000706 	br	8110fe90 <vQCmdFeeRMAPinFullPattern+0x1c0>
				case 3:
				case 4:
				case 5:
				default:
					#ifdef DEBUG_ON
						fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
8110fe74:	d0a06117 	ldw	r2,-32380(gp)
8110fe78:	e1bffc17 	ldw	r6,-16(fp)
8110fe7c:	01604574 	movhi	r5,33045
8110fe80:	296fa704 	addi	r5,r5,-16740
8110fe84:	1009883a 	mov	r4,r2
8110fe88:	11207b80 	call	811207b8 <fprintf>
					#endif
					break;
8110fe8c:	0001883a 	nop
			}

			break;
8110fe90:	00002306 	br	8110ff20 <vQCmdFeeRMAPinFullPattern+0x250>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8110fe94:	e0bffb43 	ldbu	r2,-19(fp)
8110fe98:	1080010c 	andi	r2,r2,4
8110fe9c:	10803fcc 	andi	r2,r2,255
8110fea0:	1004d0ba 	srli	r2,r2,2
8110fea4:	10803fcc 	andi	r2,r2,255
8110fea8:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
8110feac:	e0bffc17 	ldw	r2,-16(fp)
8110feb0:	10001a26 	beq	r2,zero,8110ff1c <vQCmdFeeRMAPinFullPattern+0x24c>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
8110feb4:	e0bffe17 	ldw	r2,-8(fp)
8110feb8:	10802d17 	ldw	r2,180(r2)
8110febc:	10800198 	cmpnei	r2,r2,6
8110fec0:	1000161e 	bne	r2,zero,8110ff1c <vQCmdFeeRMAPinFullPattern+0x24c>
					pxNFeeP->xControl.bWatingSync = FALSE;
8110fec4:	e0bffe17 	ldw	r2,-8(fp)
8110fec8:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110fecc:	e0bffe17 	ldw	r2,-8(fp)
8110fed0:	10c02d17 	ldw	r3,180(r2)
8110fed4:	e0bffe17 	ldw	r2,-8(fp)
8110fed8:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Mode Forced.\n");
8110fedc:	d0a06117 	ldw	r2,-32380(gp)
8110fee0:	100f883a 	mov	r7,r2
8110fee4:	01800404 	movi	r6,16
8110fee8:	01400044 	movi	r5,1
8110feec:	01204574 	movhi	r4,33045
8110fef0:	212faf04 	addi	r4,r4,-16708
8110fef4:	1120e540 	call	81120e54 <fwrite>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
8110fef8:	00000806 	br	8110ff1c <vQCmdFeeRMAPinFullPattern+0x24c>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
8110fefc:	d0a06117 	ldw	r2,-32380(gp)
8110ff00:	e0fffb03 	ldbu	r3,-20(fp)
8110ff04:	180d883a 	mov	r6,r3
8110ff08:	01604574 	movhi	r5,33045
8110ff0c:	296f8704 	addi	r5,r5,-16868
8110ff10:	1009883a 	mov	r4,r2
8110ff14:	11207b80 	call	811207b8 <fprintf>
			#endif
			break;
8110ff18:	00000106 	br	8110ff20 <vQCmdFeeRMAPinFullPattern+0x250>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
8110ff1c:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
8110ff20:	0001883a 	nop
8110ff24:	e037883a 	mov	sp,fp
8110ff28:	dfc00117 	ldw	ra,4(sp)
8110ff2c:	df000017 	ldw	fp,0(sp)
8110ff30:	dec00204 	addi	sp,sp,8
8110ff34:	f800283a 	ret

8110ff38 <vQCmdFeeRMAPWaitingSync>:


void vQCmdFeeRMAPWaitingSync( TNFee *pxNFeeP, unsigned int cmd ){
8110ff38:	defff904 	addi	sp,sp,-28
8110ff3c:	de00012e 	bgeu	sp,et,8110ff44 <vQCmdFeeRMAPWaitingSync+0xc>
8110ff40:	003b68fa 	trap	3
8110ff44:	dfc00615 	stw	ra,24(sp)
8110ff48:	df000515 	stw	fp,20(sp)
8110ff4c:	df000504 	addi	fp,sp,20
8110ff50:	e13ffe15 	stw	r4,-8(fp)
8110ff54:	e17fff15 	stw	r5,-4(fp)
	INT8U ucADDRReg;
	INT8U ucValueReg;
	INT32U ucValueMasked;

	#ifdef DEBUG_ON
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (WaitingSync)\n", pxNFeeP->ucId);
8110ff58:	d0e06117 	ldw	r3,-32380(gp)
8110ff5c:	e0bffe17 	ldw	r2,-8(fp)
8110ff60:	10800003 	ldbu	r2,0(r2)
8110ff64:	10803fcc 	andi	r2,r2,255
8110ff68:	100d883a 	mov	r6,r2
8110ff6c:	01604574 	movhi	r5,33045
8110ff70:	296fb404 	addi	r5,r5,-16688
8110ff74:	1809883a 	mov	r4,r3
8110ff78:	11207b80 	call	811207b8 <fprintf>
	#endif

	uiCmdFEEL.ulWord = cmd;
8110ff7c:	e0bfff17 	ldw	r2,-4(fp)
8110ff80:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110ff84:	e0bffd43 	ldbu	r2,-11(fp)
8110ff88:	e0bffb05 	stb	r2,-20(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110ff8c:	e0bffe17 	ldw	r2,-8(fp)
8110ff90:	10804317 	ldw	r2,268(r2)
8110ff94:	e0fffb03 	ldbu	r3,-20(fp)
8110ff98:	180b883a 	mov	r5,r3
8110ff9c:	1009883a 	mov	r4,r2
8110ffa0:	1109ed40 	call	81109ed4 <uliRmapReadReg>
8110ffa4:	e0bffb45 	stb	r2,-19(fp)


	switch (ucADDRReg) {
8110ffa8:	e0bffb03 	ldbu	r2,-20(fp)
8110ffac:	10c01348 	cmpgei	r3,r2,77
8110ffb0:	1800051e 	bne	r3,zero,8110ffc8 <vQCmdFeeRMAPWaitingSync+0x90>
8110ffb4:	10c01008 	cmpgei	r3,r2,64
8110ffb8:	1800061e 	bne	r3,zero,8110ffd4 <vQCmdFeeRMAPWaitingSync+0x9c>
8110ffbc:	108000a0 	cmpeqi	r2,r2,2
8110ffc0:	1000391e 	bne	r2,zero,811100a8 <vQCmdFeeRMAPWaitingSync+0x170>
8110ffc4:	00006506 	br	8111015c <vQCmdFeeRMAPWaitingSync+0x224>
8110ffc8:	10801360 	cmpeqi	r2,r2,77
8110ffcc:	1000491e 	bne	r2,zero,811100f4 <vQCmdFeeRMAPWaitingSync+0x1bc>
8110ffd0:	00006206 	br	8111015c <vQCmdFeeRMAPWaitingSync+0x224>
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
		case 0x0000004C://0x00000038:operation_mode_config

		ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8110ffd4:	e0bffb43 	ldbu	r2,-19(fp)
8110ffd8:	1004d13a 	srli	r2,r2,4
8110ffdc:	10803fcc 	andi	r2,r2,255
8110ffe0:	e0bffc15 	stw	r2,-16(fp)

		switch (ucValueMasked) {
8110ffe4:	e0bffc17 	ldw	r2,-16(fp)
8110ffe8:	10c000a0 	cmpeqi	r3,r2,2
8110ffec:	1800141e 	bne	r3,zero,81110040 <vQCmdFeeRMAPWaitingSync+0x108>
8110fff0:	10c001a0 	cmpeqi	r3,r2,6
8110fff4:	18001c1e 	bne	r3,zero,81110068 <vQCmdFeeRMAPWaitingSync+0x130>
8110fff8:	1000231e 	bne	r2,zero,81110088 <vQCmdFeeRMAPWaitingSync+0x150>
			case 0: /* Standby */
			#ifdef DEBUG_ON
				fprintf(fp,"- to Stand-By\n");
8110fffc:	d0a06117 	ldw	r2,-32380(gp)
81110000:	100f883a 	mov	r7,r2
81110004:	01800384 	movi	r6,14
81110008:	01400044 	movi	r5,1
8111000c:	01204574 	movhi	r4,33045
81110010:	212f9d04 	addi	r4,r4,-16780
81110014:	1120e540 	call	81120e54 <fwrite>
			#endif

				pxNFeeP->xControl.bWatingSync = TRUE;
81110018:	e0bffe17 	ldw	r2,-8(fp)
8111001c:	00c00044 	movi	r3,1
81110020:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
81110024:	e0bffe17 	ldw	r2,-8(fp)
81110028:	00c00304 	movi	r3,12
8111002c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
81110030:	e0bffe17 	ldw	r2,-8(fp)
81110034:	00c00184 	movi	r3,6
81110038:	10c02d15 	stw	r3,180(r2)


				break;
8111003c:	00001906 	br	811100a4 <vQCmdFeeRMAPWaitingSync+0x16c>
			case 2: /* PAttern Full image */

				pxNFeeP->xControl.bWatingSync = TRUE;
81110040:	e0bffe17 	ldw	r2,-8(fp)
81110044:	00c00044 	movi	r3,1
81110048:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
8111004c:	e0bffe17 	ldw	r2,-8(fp)
81110050:	00c00304 	movi	r3,12
81110054:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sNextPatternIteration;
81110058:	e0bffe17 	ldw	r2,-8(fp)
8111005c:	00c00284 	movi	r3,10
81110060:	10c02d15 	stw	r3,180(r2)

				break;
81110064:	00000f06 	br	811100a4 <vQCmdFeeRMAPWaitingSync+0x16c>
			case 6:
			#ifdef DEBUG_ON
				fprintf(fp," Off-Mode not allowed.\n");
81110068:	d0a06117 	ldw	r2,-32380(gp)
8111006c:	100f883a 	mov	r7,r2
81110070:	018005c4 	movi	r6,23
81110074:	01400044 	movi	r5,1
81110078:	01204574 	movhi	r4,33045
8111007c:	212fa104 	addi	r4,r4,-16764
81110080:	1120e540 	call	81120e54 <fwrite>
			#endif
				break;
81110084:	00000706 	br	811100a4 <vQCmdFeeRMAPWaitingSync+0x16c>
			case 3:
			case 4:
			case 5:
			default:
				#ifdef DEBUG_ON
					fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
81110088:	d0a06117 	ldw	r2,-32380(gp)
8111008c:	e1bffc17 	ldw	r6,-16(fp)
81110090:	01604574 	movhi	r5,33045
81110094:	296fa704 	addi	r5,r5,-16740
81110098:	1009883a 	mov	r4,r2
8111009c:	11207b80 	call	811207b8 <fprintf>
				#endif
				break;
811100a0:	0001883a 	nop
		}

			break;
811100a4:	00003606 	br	81110180 <vQCmdFeeRMAPWaitingSync+0x248>
		case 2: /* PAttern Full image */
			#ifdef DEBUG_ON
				fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
811100a8:	d0e06117 	ldw	r3,-32380(gp)
811100ac:	e0bffe17 	ldw	r2,-8(fp)
811100b0:	10800003 	ldbu	r2,0(r2)
811100b4:	10803fcc 	andi	r2,r2,255
811100b8:	100d883a 	mov	r6,r2
811100bc:	01604574 	movhi	r5,33045
811100c0:	296f1004 	addi	r5,r5,-17344
811100c4:	1809883a 	mov	r4,r3
811100c8:	11207b80 	call	811207b8 <fprintf>
			#endif

			pxNFeeP->xControl.bWatingSync = TRUE;
811100cc:	e0bffe17 	ldw	r2,-8(fp)
811100d0:	00c00044 	movi	r3,1
811100d4:	10c02815 	stw	r3,160(r2)
			pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
811100d8:	e0bffe17 	ldw	r2,-8(fp)
811100dc:	00c00284 	movi	r3,10
811100e0:	10c02c15 	stw	r3,176(r2)
			pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
811100e4:	e0bffe17 	ldw	r2,-8(fp)
811100e8:	00c00304 	movi	r3,12
811100ec:	10c02d15 	stw	r3,180(r2)

			break;
811100f0:	00002306 	br	81110180 <vQCmdFeeRMAPWaitingSync+0x248>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
811100f4:	e0bffb43 	ldbu	r2,-19(fp)
811100f8:	1080010c 	andi	r2,r2,4
811100fc:	10803fcc 	andi	r2,r2,255
81110100:	1004d0ba 	srli	r2,r2,2
81110104:	10803fcc 	andi	r2,r2,255
81110108:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
8111010c:	e0bffc17 	ldw	r2,-16(fp)
81110110:	10001a26 	beq	r2,zero,8111017c <vQCmdFeeRMAPWaitingSync+0x244>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
81110114:	e0bffe17 	ldw	r2,-8(fp)
81110118:	10802d17 	ldw	r2,180(r2)
8111011c:	10800198 	cmpnei	r2,r2,6
81110120:	1000161e 	bne	r2,zero,8111017c <vQCmdFeeRMAPWaitingSync+0x244>
					pxNFeeP->xControl.bWatingSync = FALSE;
81110124:	e0bffe17 	ldw	r2,-8(fp)
81110128:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8111012c:	e0bffe17 	ldw	r2,-8(fp)
81110130:	10c02d17 	ldw	r3,180(r2)
81110134:	e0bffe17 	ldw	r2,-8(fp)
81110138:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Mode Forced.\n");
8111013c:	d0a06117 	ldw	r2,-32380(gp)
81110140:	100f883a 	mov	r7,r2
81110144:	01800404 	movi	r6,16
81110148:	01400044 	movi	r5,1
8111014c:	01204574 	movhi	r4,33045
81110150:	212faf04 	addi	r4,r4,-16708
81110154:	1120e540 	call	81120e54 <fwrite>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
81110158:	00000806 	br	8111017c <vQCmdFeeRMAPWaitingSync+0x244>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
8111015c:	d0a06117 	ldw	r2,-32380(gp)
81110160:	e0fffb03 	ldbu	r3,-20(fp)
81110164:	180d883a 	mov	r6,r3
81110168:	01604574 	movhi	r5,33045
8111016c:	296f8704 	addi	r5,r5,-16868
81110170:	1009883a 	mov	r4,r2
81110174:	11207b80 	call	811207b8 <fprintf>
			#endif
			break;
81110178:	00000106 	br	81110180 <vQCmdFeeRMAPWaitingSync+0x248>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
8111017c:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
81110180:	0001883a 	nop
81110184:	e037883a 	mov	sp,fp
81110188:	dfc00117 	ldw	ra,4(sp)
8111018c:	df000017 	ldw	fp,0(sp)
81110190:	dec00204 	addi	sp,sp,8
81110194:	f800283a 	ret

81110198 <bDisableRmapIRQ>:


bool bDisableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
81110198:	defffc04 	addi	sp,sp,-16
8111019c:	de00012e 	bgeu	sp,et,811101a4 <bDisableRmapIRQ+0xc>
811101a0:	003b68fa 	trap	3
811101a4:	dfc00315 	stw	ra,12(sp)
811101a8:	df000215 	stw	fp,8(sp)
811101ac:	df000204 	addi	fp,sp,8
811101b0:	e13ffe15 	stw	r4,-8(fp)
811101b4:	2805883a 	mov	r2,r5
811101b8:	e0bfff05 	stb	r2,-4(fp)
	/* Disable RMAP channel */
	bRmapGetIrqControl(pxRmapCh);
811101bc:	e13ffe17 	ldw	r4,-8(fp)
811101c0:	110793c0 	call	8110793c <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
811101c4:	e0bffe17 	ldw	r2,-8(fp)
811101c8:	10001015 	stw	zero,64(r2)
	bRmapSetIrqControl(pxRmapCh);
811101cc:	e13ffe17 	ldw	r4,-8(fp)
811101d0:	11078940 	call	81107894 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
811101d4:	00800044 	movi	r2,1
}
811101d8:	e037883a 	mov	sp,fp
811101dc:	dfc00117 	ldw	ra,4(sp)
811101e0:	df000017 	ldw	fp,0(sp)
811101e4:	dec00204 	addi	sp,sp,8
811101e8:	f800283a 	ret

811101ec <bEnableRmapIRQ>:

bool bEnableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
811101ec:	defffc04 	addi	sp,sp,-16
811101f0:	de00012e 	bgeu	sp,et,811101f8 <bEnableRmapIRQ+0xc>
811101f4:	003b68fa 	trap	3
811101f8:	dfc00315 	stw	ra,12(sp)
811101fc:	df000215 	stw	fp,8(sp)
81110200:	df000204 	addi	fp,sp,8
81110204:	e13ffe15 	stw	r4,-8(fp)
81110208:	2805883a 	mov	r2,r5
8111020c:	e0bfff05 	stb	r2,-4(fp)
	/* Enable RMAP */
	/* Before Enable the IRQ for Rmap, make a copy for compare when some command arrive */
	//bRmapGetMemConfigArea(&xRmap[ucId]);

	bRmapGetIrqControl(pxRmapCh);
81110210:	e13ffe17 	ldw	r4,-8(fp)
81110214:	110793c0 	call	8110793c <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
81110218:	e0bffe17 	ldw	r2,-8(fp)
8111021c:	00c00044 	movi	r3,1
81110220:	10c01015 	stw	r3,64(r2)
	bRmapSetIrqControl(pxRmapCh);
81110224:	e13ffe17 	ldw	r4,-8(fp)
81110228:	11078940 	call	81107894 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8111022c:	00800044 	movi	r2,1
}
81110230:	e037883a 	mov	sp,fp
81110234:	dfc00117 	ldw	ra,4(sp)
81110238:	df000017 	ldw	fp,0(sp)
8111023c:	dec00204 	addi	sp,sp,8
81110240:	f800283a 	ret

81110244 <bDisableSPWChannel>:

bool bDisableSPWChannel( TSpwcChannel *xSPW ) {
81110244:	defffd04 	addi	sp,sp,-12
81110248:	de00012e 	bgeu	sp,et,81110250 <bDisableSPWChannel+0xc>
8111024c:	003b68fa 	trap	3
81110250:	dfc00215 	stw	ra,8(sp)
81110254:	df000115 	stw	fp,4(sp)
81110258:	df000104 	addi	fp,sp,4
8111025c:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bSpwcGetLink(xSPW);
81110260:	e13fff17 	ldw	r4,-4(fp)
81110264:	110a2c00 	call	8110a2c0 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
81110268:	e0bfff17 	ldw	r2,-4(fp)
8111026c:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = FALSE;
81110270:	e0bfff17 	ldw	r2,-4(fp)
81110274:	10000115 	stw	zero,4(r2)
	xSPW->xLinkConfig.bDisconnect = TRUE;
81110278:	e0bfff17 	ldw	r2,-4(fp)
8111027c:	00c00044 	movi	r3,1
81110280:	10c00315 	stw	r3,12(r2)
	bSpwcSetLink(xSPW);
81110284:	e13fff17 	ldw	r4,-4(fp)
81110288:	110a18c0 	call	8110a18c <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
8111028c:	00800044 	movi	r2,1
}
81110290:	e037883a 	mov	sp,fp
81110294:	dfc00117 	ldw	ra,4(sp)
81110298:	df000017 	ldw	fp,0(sp)
8111029c:	dec00204 	addi	sp,sp,8
811102a0:	f800283a 	ret

811102a4 <bEnableSPWChannel>:

bool bEnableSPWChannel( TSpwcChannel *xSPW ) {
811102a4:	defffd04 	addi	sp,sp,-12
811102a8:	de00012e 	bgeu	sp,et,811102b0 <bEnableSPWChannel+0xc>
811102ac:	003b68fa 	trap	3
811102b0:	dfc00215 	stw	ra,8(sp)
811102b4:	df000115 	stw	fp,4(sp)
811102b8:	df000104 	addi	fp,sp,4
811102bc:	e13fff15 	stw	r4,-4(fp)
	/* Enable SPW channel */
	bSpwcGetLink(xSPW);
811102c0:	e13fff17 	ldw	r4,-4(fp)
811102c4:	110a2c00 	call	8110a2c0 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
811102c8:	e0bfff17 	ldw	r2,-4(fp)
811102cc:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = TRUE;
811102d0:	e0bfff17 	ldw	r2,-4(fp)
811102d4:	00c00044 	movi	r3,1
811102d8:	10c00115 	stw	r3,4(r2)
	xSPW->xLinkConfig.bDisconnect = FALSE;
811102dc:	e0bfff17 	ldw	r2,-4(fp)
811102e0:	10000315 	stw	zero,12(r2)
	bSpwcSetLink(xSPW);
811102e4:	e13fff17 	ldw	r4,-4(fp)
811102e8:	110a18c0 	call	8110a18c <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
811102ec:	00800044 	movi	r2,1
}
811102f0:	e037883a 	mov	sp,fp
811102f4:	dfc00117 	ldw	ra,4(sp)
811102f8:	df000017 	ldw	fp,0(sp)
811102fc:	dec00204 	addi	sp,sp,8
81110300:	f800283a 	ret

81110304 <bEnableDbBuffer>:

bool bEnableDbBuffer( TFeebChannel *pxFeebCh ) {
81110304:	defffd04 	addi	sp,sp,-12
81110308:	de00012e 	bgeu	sp,et,81110310 <bEnableDbBuffer+0xc>
8111030c:	003b68fa 	trap	3
81110310:	dfc00215 	stw	ra,8(sp)
81110314:	df000115 	stw	fp,4(sp)
81110318:	df000104 	addi	fp,sp,4
8111031c:	e13fff15 	stw	r4,-4(fp)

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
81110320:	e13fff17 	ldw	r4,-4(fp)
81110324:	1106a840 	call	81106a84 <bFeebClrCh>

	/* Start the module Double Buffer */
	bFeebStartCh(pxFeebCh);
81110328:	e13fff17 	ldw	r4,-4(fp)
8111032c:	11069740 	call	81106974 <bFeebStartCh>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetWindowing(pxFeebCh);
81110330:	e13fff17 	ldw	r4,-4(fp)
81110334:	11068ec0 	call	811068ec <bFeebGetWindowing>
	pxFeebCh->xWindowingConfig.bMasking = DATA_PACKET;/* True= data packet;    FALSE= Transparent mode */
81110338:	e0bfff17 	ldw	r2,-4(fp)
8111033c:	00c00044 	movi	r3,1
81110340:	10c00115 	stw	r3,4(r2)
	bFeebSetWindowing(pxFeebCh);
81110344:	e13fff17 	ldw	r4,-4(fp)
81110348:	11068440 	call	81106844 <bFeebSetWindowing>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8111034c:	e13fff17 	ldw	r4,-4(fp)
81110350:	11062940 	call	81106294 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81110354:	e0bfff17 	ldw	r2,-4(fp)
81110358:	00c00044 	movi	r3,1
8111035c:	10c00215 	stw	r3,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
81110360:	e0bfff17 	ldw	r2,-4(fp)
81110364:	00c00044 	movi	r3,1
81110368:	10c00315 	stw	r3,12(r2)
	bFeebSetIrqControl(pxFeebCh);
8111036c:	e13fff17 	ldw	r4,-4(fp)
81110370:	11061c00 	call	811061c0 <bFeebSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
81110374:	00800044 	movi	r2,1
}
81110378:	e037883a 	mov	sp,fp
8111037c:	dfc00117 	ldw	ra,4(sp)
81110380:	df000017 	ldw	fp,0(sp)
81110384:	dec00204 	addi	sp,sp,8
81110388:	f800283a 	ret

8111038c <bDisAndClrDbBuffer>:


bool bDisAndClrDbBuffer( TFeebChannel *pxFeebCh ) {
8111038c:	defffd04 	addi	sp,sp,-12
81110390:	de00012e 	bgeu	sp,et,81110398 <bDisAndClrDbBuffer+0xc>
81110394:	003b68fa 	trap	3
81110398:	dfc00215 	stw	ra,8(sp)
8111039c:	df000115 	stw	fp,4(sp)
811103a0:	df000104 	addi	fp,sp,4
811103a4:	e13fff15 	stw	r4,-4(fp)

	/*Disable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
811103a8:	e13fff17 	ldw	r4,-4(fp)
811103ac:	11062940 	call	81106294 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
811103b0:	e0bfff17 	ldw	r2,-4(fp)
811103b4:	10000215 	stw	zero,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
811103b8:	e0bfff17 	ldw	r2,-4(fp)
811103bc:	10000315 	stw	zero,12(r2)
	bFeebSetIrqControl(pxFeebCh);
811103c0:	e13fff17 	ldw	r4,-4(fp)
811103c4:	11061c00 	call	811061c0 <bFeebSetIrqControl>

	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
811103c8:	e13fff17 	ldw	r4,-4(fp)
811103cc:	11069fc0 	call	811069fc <bFeebStopCh>

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
811103d0:	e13fff17 	ldw	r4,-4(fp)
811103d4:	1106a840 	call	81106a84 <bFeebClrCh>

	/*todo: No treatment for now  */
	return TRUE;
811103d8:	00800044 	movi	r2,1
}
811103dc:	e037883a 	mov	sp,fp
811103e0:	dfc00117 	ldw	ra,4(sp)
811103e4:	df000017 	ldw	fp,0(sp)
811103e8:	dec00204 	addi	sp,sp,8
811103ec:	f800283a 	ret

811103f0 <bSendRequestNFeeCtrl>:

bool bSendRequestNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811103f0:	defff804 	addi	sp,sp,-32
811103f4:	de00012e 	bgeu	sp,et,811103fc <bSendRequestNFeeCtrl+0xc>
811103f8:	003b68fa 	trap	3
811103fc:	dfc00715 	stw	ra,28(sp)
81110400:	df000615 	stw	fp,24(sp)
81110404:	df000604 	addi	fp,sp,24
81110408:	2807883a 	mov	r3,r5
8111040c:	3005883a 	mov	r2,r6
81110410:	e13ffd05 	stb	r4,-12(fp)
81110414:	e0fffe05 	stb	r3,-8(fp)
81110418:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8111041c:	00800404 	movi	r2,16
81110420:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81110424:	e0bffd03 	ldbu	r2,-12(fp)
81110428:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8111042c:	e0bffe03 	ldbu	r2,-8(fp)
81110430:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81110434:	e0bfff03 	ldbu	r2,-4(fp)
81110438:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8111043c:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81110440:	d0a05c17 	ldw	r2,-32400(gp)
81110444:	e0fffc17 	ldw	r3,-16(fp)
81110448:	180b883a 	mov	r5,r3
8111044c:	1009883a 	mov	r4,r2
81110450:	113d1e40 	call	8113d1e4 <OSQPost>
81110454:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81110458:	e0bffb03 	ldbu	r2,-20(fp)
8111045c:	10000526 	beq	r2,zero,81110474 <bSendRequestNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
81110460:	e0bfff03 	ldbu	r2,-4(fp)
81110464:	1009883a 	mov	r4,r2
81110468:	111c6540 	call	8111c654 <vFailRequestDMA>
		bSuccesL = FALSE;
8111046c:	e03ffa15 	stw	zero,-24(fp)
81110470:	00000206 	br	8111047c <bSendRequestNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
81110474:	00800044 	movi	r2,1
81110478:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
8111047c:	e0bffa17 	ldw	r2,-24(fp)
}
81110480:	e037883a 	mov	sp,fp
81110484:	dfc00117 	ldw	ra,4(sp)
81110488:	df000017 	ldw	fp,0(sp)
8111048c:	dec00204 	addi	sp,sp,8
81110490:	f800283a 	ret

81110494 <bSendGiveBackNFeeCtrl>:


bool bSendGiveBackNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81110494:	defff804 	addi	sp,sp,-32
81110498:	de00012e 	bgeu	sp,et,811104a0 <bSendGiveBackNFeeCtrl+0xc>
8111049c:	003b68fa 	trap	3
811104a0:	dfc00715 	stw	ra,28(sp)
811104a4:	df000615 	stw	fp,24(sp)
811104a8:	df000604 	addi	fp,sp,24
811104ac:	2807883a 	mov	r3,r5
811104b0:	3005883a 	mov	r2,r6
811104b4:	e13ffd05 	stb	r4,-12(fp)
811104b8:	e0fffe05 	stb	r3,-8(fp)
811104bc:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811104c0:	00800404 	movi	r2,16
811104c4:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811104c8:	e0bffd03 	ldbu	r2,-12(fp)
811104cc:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811104d0:	e0bffe03 	ldbu	r2,-8(fp)
811104d4:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811104d8:	e0bfff03 	ldbu	r2,-4(fp)
811104dc:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
811104e0:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
811104e4:	d0a06f17 	ldw	r2,-32324(gp)
811104e8:	e0fffc17 	ldw	r3,-16(fp)
811104ec:	180b883a 	mov	r5,r3
811104f0:	1009883a 	mov	r4,r2
811104f4:	113d1e40 	call	8113d1e4 <OSQPost>
811104f8:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
811104fc:	e0bffb03 	ldbu	r2,-20(fp)
81110500:	10000526 	beq	r2,zero,81110518 <bSendGiveBackNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
81110504:	e0bfff03 	ldbu	r2,-4(fp)
81110508:	1009883a 	mov	r4,r2
8111050c:	111c6540 	call	8111c654 <vFailRequestDMA>
		bSuccesL = FALSE;
81110510:	e03ffa15 	stw	zero,-24(fp)
81110514:	00000206 	br	81110520 <bSendGiveBackNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
81110518:	00800044 	movi	r2,1
8111051c:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
81110520:	e0bffa17 	ldw	r2,-24(fp)
}
81110524:	e037883a 	mov	sp,fp
81110528:	dfc00117 	ldw	ra,4(sp)
8111052c:	df000017 	ldw	fp,0(sp)
81110530:	dec00204 	addi	sp,sp,8
81110534:	f800283a 	ret

81110538 <vPrintConsoleNFee>:




#ifdef DEBUG_ON
	void vPrintConsoleNFee( TNFee *pxNFeeI ) {
81110538:	defffa04 	addi	sp,sp,-24
8111053c:	de00012e 	bgeu	sp,et,81110544 <vPrintConsoleNFee+0xc>
81110540:	003b68fa 	trap	3
81110544:	dfc00515 	stw	ra,20(sp)
81110548:	df000415 	stw	fp,16(sp)
8111054c:	df000404 	addi	fp,sp,16
81110550:	e13fff15 	stw	r4,-4(fp)
		TNFee *pxNFee;

		pxNFee = pxNFeeI;
81110554:	e0bfff17 	ldw	r2,-4(fp)
81110558:	e0bffe15 	stw	r2,-8(fp)

		fprintf(fp,"=================================NFEE %hhu=====================================\n", pxNFee->ucId);
8111055c:	d0e06117 	ldw	r3,-32380(gp)
81110560:	e0bffe17 	ldw	r2,-8(fp)
81110564:	10800003 	ldbu	r2,0(r2)
81110568:	10803fcc 	andi	r2,r2,255
8111056c:	100d883a 	mov	r6,r2
81110570:	01604574 	movhi	r5,33045
81110574:	296fc104 	addi	r5,r5,-16636
81110578:	1809883a 	mov	r4,r3
8111057c:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"\n");
81110580:	d0a06117 	ldw	r2,-32380(gp)
81110584:	100b883a 	mov	r5,r2
81110588:	01000284 	movi	r4,10
8111058c:	11208300 	call	81120830 <fputc>
		fprintf(fp,"NFEE %hhu CCD infos: \n", pxNFee->ucId);
81110590:	d0e06117 	ldw	r3,-32380(gp)
81110594:	e0bffe17 	ldw	r2,-8(fp)
81110598:	10800003 	ldbu	r2,0(r2)
8111059c:	10803fcc 	andi	r2,r2,255
811105a0:	100d883a 	mov	r6,r2
811105a4:	01604574 	movhi	r5,33045
811105a8:	296fd604 	addi	r5,r5,-16552
811105ac:	1809883a 	mov	r4,r3
811105b0:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"    PreScan = %hu \n", pxNFee->xCcdInfo.usiSPrescanN);
811105b4:	d0e06117 	ldw	r3,-32380(gp)
811105b8:	e0bffe17 	ldw	r2,-8(fp)
811105bc:	10802f0b 	ldhu	r2,188(r2)
811105c0:	10bfffcc 	andi	r2,r2,65535
811105c4:	100d883a 	mov	r6,r2
811105c8:	01604574 	movhi	r5,33045
811105cc:	296fdc04 	addi	r5,r5,-16528
811105d0:	1809883a 	mov	r4,r3
811105d4:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"    OverScan = %hu \n", pxNFee->xCcdInfo.usiSOverscanN);
811105d8:	d0e06117 	ldw	r3,-32380(gp)
811105dc:	e0bffe17 	ldw	r2,-8(fp)
811105e0:	10802f8b 	ldhu	r2,190(r2)
811105e4:	10bfffcc 	andi	r2,r2,65535
811105e8:	100d883a 	mov	r6,r2
811105ec:	01604574 	movhi	r5,33045
811105f0:	296fe104 	addi	r5,r5,-16508
811105f4:	1809883a 	mov	r4,r3
811105f8:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"    OLN = %hu \n", pxNFee->xCcdInfo.usiOLN);
811105fc:	d0e06117 	ldw	r3,-32380(gp)
81110600:	e0bffe17 	ldw	r2,-8(fp)
81110604:	1080300b 	ldhu	r2,192(r2)
81110608:	10bfffcc 	andi	r2,r2,65535
8111060c:	100d883a 	mov	r6,r2
81110610:	01604574 	movhi	r5,33045
81110614:	296fe704 	addi	r5,r5,-16484
81110618:	1809883a 	mov	r4,r3
8111061c:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"    Half Width = %hu \n", pxNFee->xCcdInfo.usiHalfWidth);
81110620:	d0e06117 	ldw	r3,-32380(gp)
81110624:	e0bffe17 	ldw	r2,-8(fp)
81110628:	1080308b 	ldhu	r2,194(r2)
8111062c:	10bfffcc 	andi	r2,r2,65535
81110630:	100d883a 	mov	r6,r2
81110634:	01604574 	movhi	r5,33045
81110638:	296feb04 	addi	r5,r5,-16468
8111063c:	1809883a 	mov	r4,r3
81110640:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"    Height = %hu \n", pxNFee->xCcdInfo.usiHeight);
81110644:	d0e06117 	ldw	r3,-32380(gp)
81110648:	e0bffe17 	ldw	r2,-8(fp)
8111064c:	1080310b 	ldhu	r2,196(r2)
81110650:	10bfffcc 	andi	r2,r2,65535
81110654:	100d883a 	mov	r6,r2
81110658:	01604574 	movhi	r5,33045
8111065c:	296ff104 	addi	r5,r5,-16444
81110660:	1809883a 	mov	r4,r3
81110664:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"\n");
81110668:	d0a06117 	ldw	r2,-32380(gp)
8111066c:	100b883a 	mov	r5,r2
81110670:	01000284 	movi	r4,10
81110674:	11208300 	call	81120830 <fputc>
		fprintf(fp,"NFEE %hhu Control: \n", pxNFee->ucId);
81110678:	d0e06117 	ldw	r3,-32380(gp)
8111067c:	e0bffe17 	ldw	r2,-8(fp)
81110680:	10800003 	ldbu	r2,0(r2)
81110684:	10803fcc 	andi	r2,r2,255
81110688:	100d883a 	mov	r6,r2
8111068c:	01604574 	movhi	r5,33045
81110690:	296ff604 	addi	r5,r5,-16424
81110694:	1809883a 	mov	r4,r3
81110698:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"    NFEE State 	= %hu \n", pxNFee->xControl.eMode);
8111069c:	d0e06117 	ldw	r3,-32380(gp)
811106a0:	e0bffe17 	ldw	r2,-8(fp)
811106a4:	10802c17 	ldw	r2,176(r2)
811106a8:	100d883a 	mov	r6,r2
811106ac:	01604574 	movhi	r5,33045
811106b0:	296ffc04 	addi	r5,r5,-16400
811106b4:	1809883a 	mov	r4,r3
811106b8:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"    NFEE Enable? = %hu \n", pxNFee->xControl.bEnabled);
811106bc:	d0e06117 	ldw	r3,-32380(gp)
811106c0:	e0bffe17 	ldw	r2,-8(fp)
811106c4:	10802117 	ldw	r2,132(r2)
811106c8:	100d883a 	mov	r6,r2
811106cc:	01604574 	movhi	r5,33045
811106d0:	29700204 	addi	r5,r5,-16376
811106d4:	1809883a 	mov	r4,r3
811106d8:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"    Using DMA?   = %hu \n", pxNFee->xControl.bUsingDMA);
811106dc:	d0e06117 	ldw	r3,-32380(gp)
811106e0:	e0bffe17 	ldw	r2,-8(fp)
811106e4:	10802317 	ldw	r2,140(r2)
811106e8:	100d883a 	mov	r6,r2
811106ec:	01604574 	movhi	r5,33045
811106f0:	29700904 	addi	r5,r5,-16348
811106f4:	1809883a 	mov	r4,r3
811106f8:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"    Logging?     = %hu \n", pxNFee->xControl.bLogging);
811106fc:	d0e06117 	ldw	r3,-32380(gp)
81110700:	e0bffe17 	ldw	r2,-8(fp)
81110704:	10802417 	ldw	r2,144(r2)
81110708:	100d883a 	mov	r6,r2
8111070c:	01604574 	movhi	r5,33045
81110710:	29701004 	addi	r5,r5,-16320
81110714:	1809883a 	mov	r4,r3
81110718:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"    Echoing?     = %hu \n", pxNFee->xControl.bEchoing);
8111071c:	d0e06117 	ldw	r3,-32380(gp)
81110720:	e0bffe17 	ldw	r2,-8(fp)
81110724:	10802517 	ldw	r2,148(r2)
81110728:	100d883a 	mov	r6,r2
8111072c:	01604574 	movhi	r5,33045
81110730:	29701704 	addi	r5,r5,-16292
81110734:	1809883a 	mov	r4,r3
81110738:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"    Channel Enable? = %hu \n", pxNFee->xControl.bChannelEnable);
8111073c:	d0e06117 	ldw	r3,-32380(gp)
81110740:	e0bffe17 	ldw	r2,-8(fp)
81110744:	10802617 	ldw	r2,152(r2)
81110748:	100d883a 	mov	r6,r2
8111074c:	01604574 	movhi	r5,33045
81110750:	29701e04 	addi	r5,r5,-16264
81110754:	1809883a 	mov	r4,r3
81110758:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"    Readout order = [ %hhu , %hhu , %hhu , %hhu ] \n", pxNFee->xControl.ucROutOrder[0], pxNFee->xControl.ucROutOrder[1], pxNFee->xControl.ucROutOrder[2], pxNFee->xControl.ucROutOrder[3]);
8111075c:	d1206117 	ldw	r4,-32380(gp)
81110760:	e0bffe17 	ldw	r2,-8(fp)
81110764:	10802a43 	ldbu	r2,169(r2)
81110768:	11403fcc 	andi	r5,r2,255
8111076c:	e0bffe17 	ldw	r2,-8(fp)
81110770:	10802a83 	ldbu	r2,170(r2)
81110774:	11803fcc 	andi	r6,r2,255
81110778:	e0bffe17 	ldw	r2,-8(fp)
8111077c:	10802ac3 	ldbu	r2,171(r2)
81110780:	10803fcc 	andi	r2,r2,255
81110784:	e0fffe17 	ldw	r3,-8(fp)
81110788:	18c02b03 	ldbu	r3,172(r3)
8111078c:	18c03fcc 	andi	r3,r3,255
81110790:	d8c00115 	stw	r3,4(sp)
81110794:	d8800015 	stw	r2,0(sp)
81110798:	300f883a 	mov	r7,r6
8111079c:	280d883a 	mov	r6,r5
811107a0:	01604574 	movhi	r5,33045
811107a4:	29702504 	addi	r5,r5,-16236
811107a8:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"    CCD Side = = %hu \n", pxNFee->xControl.eSide);
811107ac:	d0e06117 	ldw	r3,-32380(gp)
811107b0:	e0bffe17 	ldw	r2,-8(fp)
811107b4:	10802e17 	ldw	r2,184(r2)
811107b8:	100d883a 	mov	r6,r2
811107bc:	01604574 	movhi	r5,33045
811107c0:	29703204 	addi	r5,r5,-16184
811107c4:	1809883a 	mov	r4,r3
811107c8:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"\n\n");
811107cc:	d0a06117 	ldw	r2,-32380(gp)
811107d0:	100f883a 	mov	r7,r2
811107d4:	01800084 	movi	r6,2
811107d8:	01400044 	movi	r5,1
811107dc:	01204574 	movhi	r4,33045
811107e0:	21303804 	addi	r4,r4,-16160
811107e4:	1120e540 	call	81120e54 <fwrite>
		fprintf(fp,"NFEE %hhu MEMORY MAP: \n", pxNFee->ucId);
811107e8:	d0e06117 	ldw	r3,-32380(gp)
811107ec:	e0bffe17 	ldw	r2,-8(fp)
811107f0:	10800003 	ldbu	r2,0(r2)
811107f4:	10803fcc 	andi	r2,r2,255
811107f8:	100d883a 	mov	r6,r2
811107fc:	01604574 	movhi	r5,33045
81110800:	29703904 	addi	r5,r5,-16156
81110804:	1809883a 	mov	r4,r3
81110808:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"    General Info: \n");
8111080c:	d0a06117 	ldw	r2,-32380(gp)
81110810:	100f883a 	mov	r7,r2
81110814:	018004c4 	movi	r6,19
81110818:	01400044 	movi	r5,1
8111081c:	01204574 	movhi	r4,33045
81110820:	21303f04 	addi	r4,r4,-16132
81110824:	1120e540 	call	81120e54 <fwrite>
		fprintf(fp,"        Offset root 	= %lu \n", pxNFee->xMemMap.ulOffsetRoot);
81110828:	d0e06117 	ldw	r3,-32380(gp)
8111082c:	e0bffe17 	ldw	r2,-8(fp)
81110830:	10800117 	ldw	r2,4(r2)
81110834:	100d883a 	mov	r6,r2
81110838:	01604574 	movhi	r5,33045
8111083c:	29704404 	addi	r5,r5,-16112
81110840:	1809883a 	mov	r4,r3
81110844:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.ulTotalBytes);
81110848:	d0e06117 	ldw	r3,-32380(gp)
8111084c:	e0bffe17 	ldw	r2,-8(fp)
81110850:	10800217 	ldw	r2,8(r2)
81110854:	100d883a 	mov	r6,r2
81110858:	01604574 	movhi	r5,33045
8111085c:	29704c04 	addi	r5,r5,-16080
81110860:	1809883a 	mov	r4,r3
81110864:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"        LUT ADDR 	= %lu \n", pxNFee->xMemMap.ulLUTAddr);
81110868:	d0e06117 	ldw	r3,-32380(gp)
8111086c:	e0bffe17 	ldw	r2,-8(fp)
81110870:	10800317 	ldw	r2,12(r2)
81110874:	100d883a 	mov	r6,r2
81110878:	01604574 	movhi	r5,33045
8111087c:	29705404 	addi	r5,r5,-16048
81110880:	1809883a 	mov	r4,r3
81110884:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"    Common to all CCDs: \n");
81110888:	d0a06117 	ldw	r2,-32380(gp)
8111088c:	100f883a 	mov	r7,r2
81110890:	01800644 	movi	r6,25
81110894:	01400044 	movi	r5,1
81110898:	01204574 	movhi	r4,33045
8111089c:	21305b04 	addi	r4,r4,-16020
811108a0:	1120e540 	call	81120e54 <fwrite>
		fprintf(fp,"        Total Bytes 	= %hu \n", pxNFee->xMemMap.xCommon.usiTotalBytes);
811108a4:	d0e06117 	ldw	r3,-32380(gp)
811108a8:	e0bffe17 	ldw	r2,-8(fp)
811108ac:	10800517 	ldw	r2,20(r2)
811108b0:	100d883a 	mov	r6,r2
811108b4:	01604574 	movhi	r5,33045
811108b8:	29706204 	addi	r5,r5,-15992
811108bc:	1809883a 	mov	r4,r3
811108c0:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"        Total of Blocks = %hu \n", pxNFee->xMemMap.xCommon.usiNTotalBlocks);
811108c4:	d0e06117 	ldw	r3,-32380(gp)
811108c8:	e0bffe17 	ldw	r2,-8(fp)
811108cc:	10800417 	ldw	r2,16(r2)
811108d0:	100d883a 	mov	r6,r2
811108d4:	01604574 	movhi	r5,33045
811108d8:	29706a04 	addi	r5,r5,-15960
811108dc:	1809883a 	mov	r4,r3
811108e0:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"        Padding Bytes 	= %hhu\n", pxNFee->xMemMap.xCommon.ucPaddingBytes);
811108e4:	d0e06117 	ldw	r3,-32380(gp)
811108e8:	e0bffe17 	ldw	r2,-8(fp)
811108ec:	10800603 	ldbu	r2,24(r2)
811108f0:	10803fcc 	andi	r2,r2,255
811108f4:	100d883a 	mov	r6,r2
811108f8:	01604574 	movhi	r5,33045
811108fc:	29707204 	addi	r5,r5,-15928
81110900:	1809883a 	mov	r4,r3
81110904:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"        Padding MASK 	= %llu\n", pxNFee->xMemMap.xCommon.ucPaddingMask.ullWord);
81110908:	d2206117 	ldw	r8,-32380(gp)
8111090c:	e13ffe17 	ldw	r4,-8(fp)
81110910:	20800717 	ldw	r2,28(r4)
81110914:	20c00817 	ldw	r3,32(r4)
81110918:	100d883a 	mov	r6,r2
8111091c:	180f883a 	mov	r7,r3
81110920:	01604574 	movhi	r5,33045
81110924:	29707a04 	addi	r5,r5,-15896
81110928:	4009883a 	mov	r4,r8
8111092c:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"\n");
81110930:	d0a06117 	ldw	r2,-32380(gp)
81110934:	100b883a 	mov	r5,r2
81110938:	01000284 	movi	r4,10
8111093c:	11208300 	call	81120830 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 0 , pxNFee->ucId);
81110940:	d0e06117 	ldw	r3,-32380(gp)
81110944:	e0bffe17 	ldw	r2,-8(fp)
81110948:	10800003 	ldbu	r2,0(r2)
8111094c:	10803fcc 	andi	r2,r2,255
81110950:	100f883a 	mov	r7,r2
81110954:	000d883a 	mov	r6,zero
81110958:	01604574 	movhi	r5,33045
8111095c:	29708204 	addi	r5,r5,-15864
81110960:	1809883a 	mov	r4,r3
81110964:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"        Left side \n");
81110968:	d0a06117 	ldw	r2,-32380(gp)
8111096c:	100f883a 	mov	r7,r2
81110970:	018004c4 	movi	r6,19
81110974:	01400044 	movi	r5,1
81110978:	01204574 	movhi	r4,33045
8111097c:	21308c04 	addi	r4,r4,-15824
81110980:	1120e540 	call	81120e54 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulOffsetAddr);
81110984:	d0e06117 	ldw	r3,-32380(gp)
81110988:	e0bffe17 	ldw	r2,-8(fp)
8111098c:	10800917 	ldw	r2,36(r2)
81110990:	100d883a 	mov	r6,r2
81110994:	01604574 	movhi	r5,33045
81110998:	29709104 	addi	r5,r5,-15804
8111099c:	1809883a 	mov	r4,r3
811109a0:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulBlockI);
811109a4:	d0e06117 	ldw	r3,-32380(gp)
811109a8:	e0bffe17 	ldw	r2,-8(fp)
811109ac:	10800a17 	ldw	r2,40(r2)
811109b0:	100d883a 	mov	r6,r2
811109b4:	01604574 	movhi	r5,33045
811109b8:	29709a04 	addi	r5,r5,-15768
811109bc:	1809883a 	mov	r4,r3
811109c0:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulAddrI);
811109c4:	d0e06117 	ldw	r3,-32380(gp)
811109c8:	e0bffe17 	ldw	r2,-8(fp)
811109cc:	10800b17 	ldw	r2,44(r2)
811109d0:	100d883a 	mov	r6,r2
811109d4:	01604574 	movhi	r5,33045
811109d8:	2970a504 	addi	r5,r5,-15724
811109dc:	1809883a 	mov	r4,r3
811109e0:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"        Right side \n");
811109e4:	d0a06117 	ldw	r2,-32380(gp)
811109e8:	100f883a 	mov	r7,r2
811109ec:	01800504 	movi	r6,20
811109f0:	01400044 	movi	r5,1
811109f4:	01204574 	movhi	r4,33045
811109f8:	2130b104 	addi	r4,r4,-15676
811109fc:	1120e540 	call	81120e54 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulOffsetAddr);
81110a00:	d0e06117 	ldw	r3,-32380(gp)
81110a04:	e0bffe17 	ldw	r2,-8(fp)
81110a08:	10800c17 	ldw	r2,48(r2)
81110a0c:	100d883a 	mov	r6,r2
81110a10:	01604574 	movhi	r5,33045
81110a14:	29709104 	addi	r5,r5,-15804
81110a18:	1809883a 	mov	r4,r3
81110a1c:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulBlockI);
81110a20:	d0e06117 	ldw	r3,-32380(gp)
81110a24:	e0bffe17 	ldw	r2,-8(fp)
81110a28:	10800d17 	ldw	r2,52(r2)
81110a2c:	100d883a 	mov	r6,r2
81110a30:	01604574 	movhi	r5,33045
81110a34:	29709a04 	addi	r5,r5,-15768
81110a38:	1809883a 	mov	r4,r3
81110a3c:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulAddrI);
81110a40:	d0e06117 	ldw	r3,-32380(gp)
81110a44:	e0bffe17 	ldw	r2,-8(fp)
81110a48:	10800e17 	ldw	r2,56(r2)
81110a4c:	100d883a 	mov	r6,r2
81110a50:	01604574 	movhi	r5,33045
81110a54:	2970a504 	addi	r5,r5,-15724
81110a58:	1809883a 	mov	r4,r3
81110a5c:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"\n");
81110a60:	d0a06117 	ldw	r2,-32380(gp)
81110a64:	100b883a 	mov	r5,r2
81110a68:	01000284 	movi	r4,10
81110a6c:	11208300 	call	81120830 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 1 , pxNFee->ucId);
81110a70:	d0e06117 	ldw	r3,-32380(gp)
81110a74:	e0bffe17 	ldw	r2,-8(fp)
81110a78:	10800003 	ldbu	r2,0(r2)
81110a7c:	10803fcc 	andi	r2,r2,255
81110a80:	100f883a 	mov	r7,r2
81110a84:	01800044 	movi	r6,1
81110a88:	01604574 	movhi	r5,33045
81110a8c:	29708204 	addi	r5,r5,-15864
81110a90:	1809883a 	mov	r4,r3
81110a94:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"        Left side \n");
81110a98:	d0a06117 	ldw	r2,-32380(gp)
81110a9c:	100f883a 	mov	r7,r2
81110aa0:	018004c4 	movi	r6,19
81110aa4:	01400044 	movi	r5,1
81110aa8:	01204574 	movhi	r4,33045
81110aac:	21308c04 	addi	r4,r4,-15824
81110ab0:	1120e540 	call	81120e54 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulOffsetAddr);
81110ab4:	d0e06117 	ldw	r3,-32380(gp)
81110ab8:	e0bffe17 	ldw	r2,-8(fp)
81110abc:	10800f17 	ldw	r2,60(r2)
81110ac0:	100d883a 	mov	r6,r2
81110ac4:	01604574 	movhi	r5,33045
81110ac8:	29709104 	addi	r5,r5,-15804
81110acc:	1809883a 	mov	r4,r3
81110ad0:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulBlockI);
81110ad4:	d0e06117 	ldw	r3,-32380(gp)
81110ad8:	e0bffe17 	ldw	r2,-8(fp)
81110adc:	10801017 	ldw	r2,64(r2)
81110ae0:	100d883a 	mov	r6,r2
81110ae4:	01604574 	movhi	r5,33045
81110ae8:	29709a04 	addi	r5,r5,-15768
81110aec:	1809883a 	mov	r4,r3
81110af0:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulAddrI);
81110af4:	d0e06117 	ldw	r3,-32380(gp)
81110af8:	e0bffe17 	ldw	r2,-8(fp)
81110afc:	10801117 	ldw	r2,68(r2)
81110b00:	100d883a 	mov	r6,r2
81110b04:	01604574 	movhi	r5,33045
81110b08:	2970a504 	addi	r5,r5,-15724
81110b0c:	1809883a 	mov	r4,r3
81110b10:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"        Right side \n");
81110b14:	d0a06117 	ldw	r2,-32380(gp)
81110b18:	100f883a 	mov	r7,r2
81110b1c:	01800504 	movi	r6,20
81110b20:	01400044 	movi	r5,1
81110b24:	01204574 	movhi	r4,33045
81110b28:	2130b104 	addi	r4,r4,-15676
81110b2c:	1120e540 	call	81120e54 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulOffsetAddr);
81110b30:	d0e06117 	ldw	r3,-32380(gp)
81110b34:	e0bffe17 	ldw	r2,-8(fp)
81110b38:	10801217 	ldw	r2,72(r2)
81110b3c:	100d883a 	mov	r6,r2
81110b40:	01604574 	movhi	r5,33045
81110b44:	29709104 	addi	r5,r5,-15804
81110b48:	1809883a 	mov	r4,r3
81110b4c:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulBlockI);
81110b50:	d0e06117 	ldw	r3,-32380(gp)
81110b54:	e0bffe17 	ldw	r2,-8(fp)
81110b58:	10801317 	ldw	r2,76(r2)
81110b5c:	100d883a 	mov	r6,r2
81110b60:	01604574 	movhi	r5,33045
81110b64:	29709a04 	addi	r5,r5,-15768
81110b68:	1809883a 	mov	r4,r3
81110b6c:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulAddrI);
81110b70:	d0e06117 	ldw	r3,-32380(gp)
81110b74:	e0bffe17 	ldw	r2,-8(fp)
81110b78:	10801417 	ldw	r2,80(r2)
81110b7c:	100d883a 	mov	r6,r2
81110b80:	01604574 	movhi	r5,33045
81110b84:	2970a504 	addi	r5,r5,-15724
81110b88:	1809883a 	mov	r4,r3
81110b8c:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"\n");
81110b90:	d0a06117 	ldw	r2,-32380(gp)
81110b94:	100b883a 	mov	r5,r2
81110b98:	01000284 	movi	r4,10
81110b9c:	11208300 	call	81120830 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 2 , pxNFee->ucId);
81110ba0:	d0e06117 	ldw	r3,-32380(gp)
81110ba4:	e0bffe17 	ldw	r2,-8(fp)
81110ba8:	10800003 	ldbu	r2,0(r2)
81110bac:	10803fcc 	andi	r2,r2,255
81110bb0:	100f883a 	mov	r7,r2
81110bb4:	01800084 	movi	r6,2
81110bb8:	01604574 	movhi	r5,33045
81110bbc:	29708204 	addi	r5,r5,-15864
81110bc0:	1809883a 	mov	r4,r3
81110bc4:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"        Left side \n");
81110bc8:	d0a06117 	ldw	r2,-32380(gp)
81110bcc:	100f883a 	mov	r7,r2
81110bd0:	018004c4 	movi	r6,19
81110bd4:	01400044 	movi	r5,1
81110bd8:	01204574 	movhi	r4,33045
81110bdc:	21308c04 	addi	r4,r4,-15824
81110be0:	1120e540 	call	81120e54 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulOffsetAddr);
81110be4:	d0e06117 	ldw	r3,-32380(gp)
81110be8:	e0bffe17 	ldw	r2,-8(fp)
81110bec:	10801517 	ldw	r2,84(r2)
81110bf0:	100d883a 	mov	r6,r2
81110bf4:	01604574 	movhi	r5,33045
81110bf8:	29709104 	addi	r5,r5,-15804
81110bfc:	1809883a 	mov	r4,r3
81110c00:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulBlockI);
81110c04:	d0e06117 	ldw	r3,-32380(gp)
81110c08:	e0bffe17 	ldw	r2,-8(fp)
81110c0c:	10801617 	ldw	r2,88(r2)
81110c10:	100d883a 	mov	r6,r2
81110c14:	01604574 	movhi	r5,33045
81110c18:	29709a04 	addi	r5,r5,-15768
81110c1c:	1809883a 	mov	r4,r3
81110c20:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulAddrI);
81110c24:	d0e06117 	ldw	r3,-32380(gp)
81110c28:	e0bffe17 	ldw	r2,-8(fp)
81110c2c:	10801717 	ldw	r2,92(r2)
81110c30:	100d883a 	mov	r6,r2
81110c34:	01604574 	movhi	r5,33045
81110c38:	2970a504 	addi	r5,r5,-15724
81110c3c:	1809883a 	mov	r4,r3
81110c40:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"        Right side \n");
81110c44:	d0a06117 	ldw	r2,-32380(gp)
81110c48:	100f883a 	mov	r7,r2
81110c4c:	01800504 	movi	r6,20
81110c50:	01400044 	movi	r5,1
81110c54:	01204574 	movhi	r4,33045
81110c58:	2130b104 	addi	r4,r4,-15676
81110c5c:	1120e540 	call	81120e54 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulOffsetAddr);
81110c60:	d0e06117 	ldw	r3,-32380(gp)
81110c64:	e0bffe17 	ldw	r2,-8(fp)
81110c68:	10801817 	ldw	r2,96(r2)
81110c6c:	100d883a 	mov	r6,r2
81110c70:	01604574 	movhi	r5,33045
81110c74:	29709104 	addi	r5,r5,-15804
81110c78:	1809883a 	mov	r4,r3
81110c7c:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulBlockI);
81110c80:	d0e06117 	ldw	r3,-32380(gp)
81110c84:	e0bffe17 	ldw	r2,-8(fp)
81110c88:	10801917 	ldw	r2,100(r2)
81110c8c:	100d883a 	mov	r6,r2
81110c90:	01604574 	movhi	r5,33045
81110c94:	29709a04 	addi	r5,r5,-15768
81110c98:	1809883a 	mov	r4,r3
81110c9c:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulAddrI);
81110ca0:	d0e06117 	ldw	r3,-32380(gp)
81110ca4:	e0bffe17 	ldw	r2,-8(fp)
81110ca8:	10801a17 	ldw	r2,104(r2)
81110cac:	100d883a 	mov	r6,r2
81110cb0:	01604574 	movhi	r5,33045
81110cb4:	2970a504 	addi	r5,r5,-15724
81110cb8:	1809883a 	mov	r4,r3
81110cbc:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"\n");
81110cc0:	d0a06117 	ldw	r2,-32380(gp)
81110cc4:	100b883a 	mov	r5,r2
81110cc8:	01000284 	movi	r4,10
81110ccc:	11208300 	call	81120830 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 3 , pxNFee->ucId);
81110cd0:	d0e06117 	ldw	r3,-32380(gp)
81110cd4:	e0bffe17 	ldw	r2,-8(fp)
81110cd8:	10800003 	ldbu	r2,0(r2)
81110cdc:	10803fcc 	andi	r2,r2,255
81110ce0:	100f883a 	mov	r7,r2
81110ce4:	018000c4 	movi	r6,3
81110ce8:	01604574 	movhi	r5,33045
81110cec:	29708204 	addi	r5,r5,-15864
81110cf0:	1809883a 	mov	r4,r3
81110cf4:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"        Left side \n");
81110cf8:	d0a06117 	ldw	r2,-32380(gp)
81110cfc:	100f883a 	mov	r7,r2
81110d00:	018004c4 	movi	r6,19
81110d04:	01400044 	movi	r5,1
81110d08:	01204574 	movhi	r4,33045
81110d0c:	21308c04 	addi	r4,r4,-15824
81110d10:	1120e540 	call	81120e54 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulOffsetAddr);
81110d14:	d0e06117 	ldw	r3,-32380(gp)
81110d18:	e0bffe17 	ldw	r2,-8(fp)
81110d1c:	10801b17 	ldw	r2,108(r2)
81110d20:	100d883a 	mov	r6,r2
81110d24:	01604574 	movhi	r5,33045
81110d28:	29709104 	addi	r5,r5,-15804
81110d2c:	1809883a 	mov	r4,r3
81110d30:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulBlockI);
81110d34:	d0e06117 	ldw	r3,-32380(gp)
81110d38:	e0bffe17 	ldw	r2,-8(fp)
81110d3c:	10801c17 	ldw	r2,112(r2)
81110d40:	100d883a 	mov	r6,r2
81110d44:	01604574 	movhi	r5,33045
81110d48:	29709a04 	addi	r5,r5,-15768
81110d4c:	1809883a 	mov	r4,r3
81110d50:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulAddrI);
81110d54:	d0e06117 	ldw	r3,-32380(gp)
81110d58:	e0bffe17 	ldw	r2,-8(fp)
81110d5c:	10801d17 	ldw	r2,116(r2)
81110d60:	100d883a 	mov	r6,r2
81110d64:	01604574 	movhi	r5,33045
81110d68:	2970a504 	addi	r5,r5,-15724
81110d6c:	1809883a 	mov	r4,r3
81110d70:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"        Right side \n");
81110d74:	d0a06117 	ldw	r2,-32380(gp)
81110d78:	100f883a 	mov	r7,r2
81110d7c:	01800504 	movi	r6,20
81110d80:	01400044 	movi	r5,1
81110d84:	01204574 	movhi	r4,33045
81110d88:	2130b104 	addi	r4,r4,-15676
81110d8c:	1120e540 	call	81120e54 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulOffsetAddr);
81110d90:	d0e06117 	ldw	r3,-32380(gp)
81110d94:	e0bffe17 	ldw	r2,-8(fp)
81110d98:	10801e17 	ldw	r2,120(r2)
81110d9c:	100d883a 	mov	r6,r2
81110da0:	01604574 	movhi	r5,33045
81110da4:	29709104 	addi	r5,r5,-15804
81110da8:	1809883a 	mov	r4,r3
81110dac:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulBlockI);
81110db0:	d0e06117 	ldw	r3,-32380(gp)
81110db4:	e0bffe17 	ldw	r2,-8(fp)
81110db8:	10801f17 	ldw	r2,124(r2)
81110dbc:	100d883a 	mov	r6,r2
81110dc0:	01604574 	movhi	r5,33045
81110dc4:	29709a04 	addi	r5,r5,-15768
81110dc8:	1809883a 	mov	r4,r3
81110dcc:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulAddrI);
81110dd0:	d0e06117 	ldw	r3,-32380(gp)
81110dd4:	e0bffe17 	ldw	r2,-8(fp)
81110dd8:	10802017 	ldw	r2,128(r2)
81110ddc:	100d883a 	mov	r6,r2
81110de0:	01604574 	movhi	r5,33045
81110de4:	2970a504 	addi	r5,r5,-15724
81110de8:	1809883a 	mov	r4,r3
81110dec:	11207b80 	call	811207b8 <fprintf>
		fprintf(fp,"\n");
81110df0:	d0a06117 	ldw	r2,-32380(gp)
81110df4:	100b883a 	mov	r5,r2
81110df8:	01000284 	movi	r4,10
81110dfc:	11208300 	call	81120830 <fputc>
		fprintf(fp,"==============================================================================\n");
81110e00:	d0a06117 	ldw	r2,-32380(gp)
81110e04:	100f883a 	mov	r7,r2
81110e08:	018013c4 	movi	r6,79
81110e0c:	01400044 	movi	r5,1
81110e10:	01204574 	movhi	r4,33045
81110e14:	2130b704 	addi	r4,r4,-15652
81110e18:	1120e540 	call	81120e54 <fwrite>
		fprintf(fp,"==============================================================================\n");
81110e1c:	d0a06117 	ldw	r2,-32380(gp)
81110e20:	100f883a 	mov	r7,r2
81110e24:	018013c4 	movi	r6,79
81110e28:	01400044 	movi	r5,1
81110e2c:	01204574 	movhi	r4,33045
81110e30:	2130b704 	addi	r4,r4,-15652
81110e34:	1120e540 	call	81120e54 <fwrite>
		fprintf(fp,"\n");
81110e38:	d0a06117 	ldw	r2,-32380(gp)
81110e3c:	100b883a 	mov	r5,r2
81110e40:	01000284 	movi	r4,10
81110e44:	11208300 	call	81120830 <fputc>
		fprintf(fp,"\n");
81110e48:	d0a06117 	ldw	r2,-32380(gp)
81110e4c:	100b883a 	mov	r5,r2
81110e50:	01000284 	movi	r4,10
81110e54:	11208300 	call	81120830 <fputc>
		fprintf(fp,"\n");
81110e58:	d0a06117 	ldw	r2,-32380(gp)
81110e5c:	100b883a 	mov	r5,r2
81110e60:	01000284 	movi	r4,10
81110e64:	11208300 	call	81120830 <fputc>
		fprintf(fp,"\n");
81110e68:	d0a06117 	ldw	r2,-32380(gp)
81110e6c:	100b883a 	mov	r5,r2
81110e70:	01000284 	movi	r4,10
81110e74:	11208300 	call	81120830 <fputc>
		fprintf(fp,"\n");
81110e78:	d0a06117 	ldw	r2,-32380(gp)
81110e7c:	100b883a 	mov	r5,r2
81110e80:	01000284 	movi	r4,10
81110e84:	11208300 	call	81120830 <fputc>
	}
81110e88:	0001883a 	nop
81110e8c:	e037883a 	mov	sp,fp
81110e90:	dfc00117 	ldw	ra,4(sp)
81110e94:	df000017 	ldw	fp,0(sp)
81110e98:	dec00204 	addi	sp,sp,8
81110e9c:	f800283a 	ret

81110ea0 <vLoadCtemp>:

*/



void vLoadCtemp(void) {
81110ea0:	deffff04 	addi	sp,sp,-4
81110ea4:	de00012e 	bgeu	sp,et,81110eac <vLoadCtemp+0xc>
81110ea8:	003b68fa 	trap	3
81110eac:	df000015 	stw	fp,0(sp)
81110eb0:	d839883a 	mov	fp,sp
	cTemp[0]="usiHkCcd1VodE";
81110eb4:	00a04574 	movhi	r2,33045
81110eb8:	108afb04 	addi	r2,r2,11244
81110ebc:	00e04574 	movhi	r3,33045
81110ec0:	18f0cb04 	addi	r3,r3,-15572
81110ec4:	10c00015 	stw	r3,0(r2)
	cTemp[1]="usiHkCcd1VodF";
81110ec8:	00a04574 	movhi	r2,33045
81110ecc:	108afb04 	addi	r2,r2,11244
81110ed0:	00e04574 	movhi	r3,33045
81110ed4:	18f0cf04 	addi	r3,r3,-15556
81110ed8:	10c00115 	stw	r3,4(r2)
	cTemp[2]="usiHkCcd1VrdMon";
81110edc:	00a04574 	movhi	r2,33045
81110ee0:	108afb04 	addi	r2,r2,11244
81110ee4:	00e04574 	movhi	r3,33045
81110ee8:	18f0d304 	addi	r3,r3,-15540
81110eec:	10c00215 	stw	r3,8(r2)
	cTemp[3]="usiHkCcd2VodE";
81110ef0:	00a04574 	movhi	r2,33045
81110ef4:	108afb04 	addi	r2,r2,11244
81110ef8:	00e04574 	movhi	r3,33045
81110efc:	18f0d704 	addi	r3,r3,-15524
81110f00:	10c00315 	stw	r3,12(r2)
	cTemp[4]="usiHkCcd2VodF";
81110f04:	00a04574 	movhi	r2,33045
81110f08:	108afb04 	addi	r2,r2,11244
81110f0c:	00e04574 	movhi	r3,33045
81110f10:	18f0db04 	addi	r3,r3,-15508
81110f14:	10c00415 	stw	r3,16(r2)
	cTemp[5]="usiHkCcd2VrdMon";
81110f18:	00a04574 	movhi	r2,33045
81110f1c:	108afb04 	addi	r2,r2,11244
81110f20:	00e04574 	movhi	r3,33045
81110f24:	18f0df04 	addi	r3,r3,-15492
81110f28:	10c00515 	stw	r3,20(r2)
	cTemp[6]="usiHkCcd3VodE";
81110f2c:	00a04574 	movhi	r2,33045
81110f30:	108afb04 	addi	r2,r2,11244
81110f34:	00e04574 	movhi	r3,33045
81110f38:	18f0e304 	addi	r3,r3,-15476
81110f3c:	10c00615 	stw	r3,24(r2)
	cTemp[7]="usiHkCcd3VodF";
81110f40:	00a04574 	movhi	r2,33045
81110f44:	108afb04 	addi	r2,r2,11244
81110f48:	00e04574 	movhi	r3,33045
81110f4c:	18f0e704 	addi	r3,r3,-15460
81110f50:	10c00715 	stw	r3,28(r2)
	cTemp[8]="usiHkCcd3VrdMon";
81110f54:	00a04574 	movhi	r2,33045
81110f58:	108afb04 	addi	r2,r2,11244
81110f5c:	00e04574 	movhi	r3,33045
81110f60:	18f0eb04 	addi	r3,r3,-15444
81110f64:	10c00815 	stw	r3,32(r2)
	cTemp[9]="usiHkCcd4VodE";
81110f68:	00a04574 	movhi	r2,33045
81110f6c:	108afb04 	addi	r2,r2,11244
81110f70:	00e04574 	movhi	r3,33045
81110f74:	18f0ef04 	addi	r3,r3,-15428
81110f78:	10c00915 	stw	r3,36(r2)
	cTemp[10]="usiHkCcd4VodF";
81110f7c:	00a04574 	movhi	r2,33045
81110f80:	108afb04 	addi	r2,r2,11244
81110f84:	00e04574 	movhi	r3,33045
81110f88:	18f0f304 	addi	r3,r3,-15412
81110f8c:	10c00a15 	stw	r3,40(r2)
	cTemp[11]="usiHkCcd4VrdMon";
81110f90:	00a04574 	movhi	r2,33045
81110f94:	108afb04 	addi	r2,r2,11244
81110f98:	00e04574 	movhi	r3,33045
81110f9c:	18f0f704 	addi	r3,r3,-15396
81110fa0:	10c00b15 	stw	r3,44(r2)
	cTemp[12]="usiHkVccd";
81110fa4:	00a04574 	movhi	r2,33045
81110fa8:	108afb04 	addi	r2,r2,11244
81110fac:	00e04574 	movhi	r3,33045
81110fb0:	18f0fb04 	addi	r3,r3,-15380
81110fb4:	10c00c15 	stw	r3,48(r2)
	cTemp[13]="usiHkVrclk";
81110fb8:	00a04574 	movhi	r2,33045
81110fbc:	108afb04 	addi	r2,r2,11244
81110fc0:	00e04574 	movhi	r3,33045
81110fc4:	18f0fe04 	addi	r3,r3,-15368
81110fc8:	10c00d15 	stw	r3,52(r2)
	cTemp[14]="usiHkViclk";
81110fcc:	00a04574 	movhi	r2,33045
81110fd0:	108afb04 	addi	r2,r2,11244
81110fd4:	00e04574 	movhi	r3,33045
81110fd8:	18f10104 	addi	r3,r3,-15356
81110fdc:	10c00e15 	stw	r3,56(r2)
	cTemp[15]="usiHkVrclkLow";
81110fe0:	00a04574 	movhi	r2,33045
81110fe4:	108afb04 	addi	r2,r2,11244
81110fe8:	00e04574 	movhi	r3,33045
81110fec:	18f10404 	addi	r3,r3,-15344
81110ff0:	10c00f15 	stw	r3,60(r2)
	cTemp[16]="usiHk5vbPos";
81110ff4:	00a04574 	movhi	r2,33045
81110ff8:	108afb04 	addi	r2,r2,11244
81110ffc:	00e04574 	movhi	r3,33045
81111000:	18f10804 	addi	r3,r3,-15328
81111004:	10c01015 	stw	r3,64(r2)
	cTemp[17]="usiHk5vbNeg";
81111008:	00a04574 	movhi	r2,33045
8111100c:	108afb04 	addi	r2,r2,11244
81111010:	00e04574 	movhi	r3,33045
81111014:	18f10b04 	addi	r3,r3,-15316
81111018:	10c01115 	stw	r3,68(r2)
	cTemp[18]="usiHk33vbPos";
8111101c:	00a04574 	movhi	r2,33045
81111020:	108afb04 	addi	r2,r2,11244
81111024:	00e04574 	movhi	r3,33045
81111028:	18f10e04 	addi	r3,r3,-15304
8111102c:	10c01215 	stw	r3,72(r2)
	cTemp[19]="usiHk25vaPos";
81111030:	00a04574 	movhi	r2,33045
81111034:	108afb04 	addi	r2,r2,11244
81111038:	00e04574 	movhi	r3,33045
8111103c:	18f11204 	addi	r3,r3,-15288
81111040:	10c01315 	stw	r3,76(r2)
	cTemp[20]="usiHk33vdPos";
81111044:	00a04574 	movhi	r2,33045
81111048:	108afb04 	addi	r2,r2,11244
8111104c:	00e04574 	movhi	r3,33045
81111050:	18f11604 	addi	r3,r3,-15272
81111054:	10c01415 	stw	r3,80(r2)
	cTemp[21]="usiHk25vdPos";
81111058:	00a04574 	movhi	r2,33045
8111105c:	108afb04 	addi	r2,r2,11244
81111060:	00e04574 	movhi	r3,33045
81111064:	18f11a04 	addi	r3,r3,-15256
81111068:	10c01515 	stw	r3,84(r2)
	cTemp[22]="usiHk15vdPos";
8111106c:	00a04574 	movhi	r2,33045
81111070:	108afb04 	addi	r2,r2,11244
81111074:	00e04574 	movhi	r3,33045
81111078:	18f11e04 	addi	r3,r3,-15240
8111107c:	10c01615 	stw	r3,88(r2)
	cTemp[23]="usiHk5vref";
81111080:	00a04574 	movhi	r2,33045
81111084:	108afb04 	addi	r2,r2,11244
81111088:	00e04574 	movhi	r3,33045
8111108c:	18f12204 	addi	r3,r3,-15224
81111090:	10c01715 	stw	r3,92(r2)
	cTemp[24]="usiHkVccdPosRaw";
81111094:	00a04574 	movhi	r2,33045
81111098:	108afb04 	addi	r2,r2,11244
8111109c:	00e04574 	movhi	r3,33045
811110a0:	18f12504 	addi	r3,r3,-15212
811110a4:	10c01815 	stw	r3,96(r2)
	cTemp[25]="usiHkVclkPosRaw";
811110a8:	00a04574 	movhi	r2,33045
811110ac:	108afb04 	addi	r2,r2,11244
811110b0:	00e04574 	movhi	r3,33045
811110b4:	18f12904 	addi	r3,r3,-15196
811110b8:	10c01915 	stw	r3,100(r2)
	cTemp[26]="usiHkVan1PosRaw";
811110bc:	00a04574 	movhi	r2,33045
811110c0:	108afb04 	addi	r2,r2,11244
811110c4:	00e04574 	movhi	r3,33045
811110c8:	18f12d04 	addi	r3,r3,-15180
811110cc:	10c01a15 	stw	r3,104(r2)
	cTemp[27]="usiHkVan3NegRaw";
811110d0:	00a04574 	movhi	r2,33045
811110d4:	108afb04 	addi	r2,r2,11244
811110d8:	00e04574 	movhi	r3,33045
811110dc:	18f13104 	addi	r3,r3,-15164
811110e0:	10c01b15 	stw	r3,108(r2)
	cTemp[28]="usiHkVan2PosRaw";
811110e4:	00a04574 	movhi	r2,33045
811110e8:	108afb04 	addi	r2,r2,11244
811110ec:	00e04574 	movhi	r3,33045
811110f0:	18f13504 	addi	r3,r3,-15148
811110f4:	10c01c15 	stw	r3,112(r2)
	cTemp[29]="usiHkVdigFpgaRaw";
811110f8:	00a04574 	movhi	r2,33045
811110fc:	108afb04 	addi	r2,r2,11244
81111100:	00e04574 	movhi	r3,33045
81111104:	18f13904 	addi	r3,r3,-15132
81111108:	10c01d15 	stw	r3,116(r2)
	cTemp[30]="usiHkVdigSpwRaw";
8111110c:	00a04574 	movhi	r2,33045
81111110:	108afb04 	addi	r2,r2,11244
81111114:	00e04574 	movhi	r3,33045
81111118:	18f13e04 	addi	r3,r3,-15112
8111111c:	10c01e15 	stw	r3,120(r2)
	cTemp[31]="usiHkViclkLow";
81111120:	00a04574 	movhi	r2,33045
81111124:	108afb04 	addi	r2,r2,11244
81111128:	00e04574 	movhi	r3,33045
8111112c:	18f14204 	addi	r3,r3,-15096
81111130:	10c01f15 	stw	r3,124(r2)
	cTemp[32]="usiHkAdcTempAE";
81111134:	00a04574 	movhi	r2,33045
81111138:	108afb04 	addi	r2,r2,11244
8111113c:	00e04574 	movhi	r3,33045
81111140:	18f14604 	addi	r3,r3,-15080
81111144:	10c02015 	stw	r3,128(r2)
	cTemp[33]="usiHkAdcTempAF";
81111148:	00a04574 	movhi	r2,33045
8111114c:	108afb04 	addi	r2,r2,11244
81111150:	00e04574 	movhi	r3,33045
81111154:	18f14a04 	addi	r3,r3,-15064
81111158:	10c02115 	stw	r3,132(r2)
	cTemp[34]="usiHkCcd1Temp";
8111115c:	00a04574 	movhi	r2,33045
81111160:	108afb04 	addi	r2,r2,11244
81111164:	00e04574 	movhi	r3,33045
81111168:	18f14e04 	addi	r3,r3,-15048
8111116c:	10c02215 	stw	r3,136(r2)
	cTemp[35]="usiHkCcd2Temp";
81111170:	00a04574 	movhi	r2,33045
81111174:	108afb04 	addi	r2,r2,11244
81111178:	00e04574 	movhi	r3,33045
8111117c:	18f15204 	addi	r3,r3,-15032
81111180:	10c02315 	stw	r3,140(r2)
	cTemp[36]="usiHkCcd3Temp";
81111184:	00a04574 	movhi	r2,33045
81111188:	108afb04 	addi	r2,r2,11244
8111118c:	00e04574 	movhi	r3,33045
81111190:	18f15604 	addi	r3,r3,-15016
81111194:	10c02415 	stw	r3,144(r2)
	cTemp[37]="usiHkCcd4Temp";
81111198:	00a04574 	movhi	r2,33045
8111119c:	108afb04 	addi	r2,r2,11244
811111a0:	00e04574 	movhi	r3,33045
811111a4:	18f15a04 	addi	r3,r3,-15000
811111a8:	10c02515 	stw	r3,148(r2)
	cTemp[38]="usiHkWp605Spare";
811111ac:	00a04574 	movhi	r2,33045
811111b0:	108afb04 	addi	r2,r2,11244
811111b4:	00e04574 	movhi	r3,33045
811111b8:	18f15e04 	addi	r3,r3,-14984
811111bc:	10c02615 	stw	r3,152(r2)
	cTemp[39]="usiLowresPrtA0";
811111c0:	00a04574 	movhi	r2,33045
811111c4:	108afb04 	addi	r2,r2,11244
811111c8:	00e04574 	movhi	r3,33045
811111cc:	18f16204 	addi	r3,r3,-14968
811111d0:	10c02715 	stw	r3,156(r2)
	cTemp[40]="usiLowresPrtA1";
811111d4:	00a04574 	movhi	r2,33045
811111d8:	108afb04 	addi	r2,r2,11244
811111dc:	00e04574 	movhi	r3,33045
811111e0:	18f16604 	addi	r3,r3,-14952
811111e4:	10c02815 	stw	r3,160(r2)
	cTemp[41]="usiLowresPrtA2";
811111e8:	00a04574 	movhi	r2,33045
811111ec:	108afb04 	addi	r2,r2,11244
811111f0:	00e04574 	movhi	r3,33045
811111f4:	18f16a04 	addi	r3,r3,-14936
811111f8:	10c02915 	stw	r3,164(r2)
	cTemp[42]="usiLowresPrtA3";
811111fc:	00a04574 	movhi	r2,33045
81111200:	108afb04 	addi	r2,r2,11244
81111204:	00e04574 	movhi	r3,33045
81111208:	18f16e04 	addi	r3,r3,-14920
8111120c:	10c02a15 	stw	r3,168(r2)
	cTemp[43]="usiLowresPrtA4";
81111210:	00a04574 	movhi	r2,33045
81111214:	108afb04 	addi	r2,r2,11244
81111218:	00e04574 	movhi	r3,33045
8111121c:	18f17204 	addi	r3,r3,-14904
81111220:	10c02b15 	stw	r3,172(r2)
	cTemp[44]="usiLowresPrtA5";
81111224:	00a04574 	movhi	r2,33045
81111228:	108afb04 	addi	r2,r2,11244
8111122c:	00e04574 	movhi	r3,33045
81111230:	18f17604 	addi	r3,r3,-14888
81111234:	10c02c15 	stw	r3,176(r2)
	cTemp[45]="usiLowresPrtA6";
81111238:	00a04574 	movhi	r2,33045
8111123c:	108afb04 	addi	r2,r2,11244
81111240:	00e04574 	movhi	r3,33045
81111244:	18f17a04 	addi	r3,r3,-14872
81111248:	10c02d15 	stw	r3,180(r2)
	cTemp[46]="usiLowresPrtA7";
8111124c:	00a04574 	movhi	r2,33045
81111250:	108afb04 	addi	r2,r2,11244
81111254:	00e04574 	movhi	r3,33045
81111258:	18f17e04 	addi	r3,r3,-14856
8111125c:	10c02e15 	stw	r3,184(r2)
	cTemp[47]="usiLowresPrtA8";
81111260:	00a04574 	movhi	r2,33045
81111264:	108afb04 	addi	r2,r2,11244
81111268:	00e04574 	movhi	r3,33045
8111126c:	18f18204 	addi	r3,r3,-14840
81111270:	10c02f15 	stw	r3,188(r2)
	cTemp[48]="usiLowresPrtA9";
81111274:	00a04574 	movhi	r2,33045
81111278:	108afb04 	addi	r2,r2,11244
8111127c:	00e04574 	movhi	r3,33045
81111280:	18f18604 	addi	r3,r3,-14824
81111284:	10c03015 	stw	r3,192(r2)
	cTemp[49]="usiLowresPrtA10";
81111288:	00a04574 	movhi	r2,33045
8111128c:	108afb04 	addi	r2,r2,11244
81111290:	00e04574 	movhi	r3,33045
81111294:	18f18a04 	addi	r3,r3,-14808
81111298:	10c03115 	stw	r3,196(r2)
	cTemp[50]="usiLowresPrtA11";
8111129c:	00a04574 	movhi	r2,33045
811112a0:	108afb04 	addi	r2,r2,11244
811112a4:	00e04574 	movhi	r3,33045
811112a8:	18f18e04 	addi	r3,r3,-14792
811112ac:	10c03215 	stw	r3,200(r2)
	cTemp[51]="usiLowresPrtA12";
811112b0:	00a04574 	movhi	r2,33045
811112b4:	108afb04 	addi	r2,r2,11244
811112b8:	00e04574 	movhi	r3,33045
811112bc:	18f19204 	addi	r3,r3,-14776
811112c0:	10c03315 	stw	r3,204(r2)
	cTemp[52]="usiLowresPrtA13";
811112c4:	00a04574 	movhi	r2,33045
811112c8:	108afb04 	addi	r2,r2,11244
811112cc:	00e04574 	movhi	r3,33045
811112d0:	18f19604 	addi	r3,r3,-14760
811112d4:	10c03415 	stw	r3,208(r2)
	cTemp[53]="usiLowresPrtA14";
811112d8:	00a04574 	movhi	r2,33045
811112dc:	108afb04 	addi	r2,r2,11244
811112e0:	00e04574 	movhi	r3,33045
811112e4:	18f19a04 	addi	r3,r3,-14744
811112e8:	10c03515 	stw	r3,212(r2)
	cTemp[54]="usiLowresPrtA15";
811112ec:	00a04574 	movhi	r2,33045
811112f0:	108afb04 	addi	r2,r2,11244
811112f4:	00e04574 	movhi	r3,33045
811112f8:	18f19e04 	addi	r3,r3,-14728
811112fc:	10c03615 	stw	r3,216(r2)
	cTemp[55]="usiSelHiresPrt0";
81111300:	00a04574 	movhi	r2,33045
81111304:	108afb04 	addi	r2,r2,11244
81111308:	00e04574 	movhi	r3,33045
8111130c:	18f1a204 	addi	r3,r3,-14712
81111310:	10c03715 	stw	r3,220(r2)
	cTemp[56]="usiSelHiresPrt1";
81111314:	00a04574 	movhi	r2,33045
81111318:	108afb04 	addi	r2,r2,11244
8111131c:	00e04574 	movhi	r3,33045
81111320:	18f1a604 	addi	r3,r3,-14696
81111324:	10c03815 	stw	r3,224(r2)
	cTemp[57]="usiSelHiresPrt2";
81111328:	00a04574 	movhi	r2,33045
8111132c:	108afb04 	addi	r2,r2,11244
81111330:	00e04574 	movhi	r3,33045
81111334:	18f1aa04 	addi	r3,r3,-14680
81111338:	10c03915 	stw	r3,228(r2)
	cTemp[58]="usiSelHiresPrt3";
8111133c:	00a04574 	movhi	r2,33045
81111340:	108afb04 	addi	r2,r2,11244
81111344:	00e04574 	movhi	r3,33045
81111348:	18f1ae04 	addi	r3,r3,-14664
8111134c:	10c03a15 	stw	r3,232(r2)
	cTemp[59]="usiSelHiresPrt4";
81111350:	00a04574 	movhi	r2,33045
81111354:	108afb04 	addi	r2,r2,11244
81111358:	00e04574 	movhi	r3,33045
8111135c:	18f1b204 	addi	r3,r3,-14648
81111360:	10c03b15 	stw	r3,236(r2)
	cTemp[60]="usiSelHiresPrt5";
81111364:	00a04574 	movhi	r2,33045
81111368:	108afb04 	addi	r2,r2,11244
8111136c:	00e04574 	movhi	r3,33045
81111370:	18f1b604 	addi	r3,r3,-14632
81111374:	10c03c15 	stw	r3,240(r2)
	cTemp[61]="usiSelHiresPrt6";
81111378:	00a04574 	movhi	r2,33045
8111137c:	108afb04 	addi	r2,r2,11244
81111380:	00e04574 	movhi	r3,33045
81111384:	18f1ba04 	addi	r3,r3,-14616
81111388:	10c03d15 	stw	r3,244(r2)
	cTemp[62]="usiSelHiresPrt7";
8111138c:	00a04574 	movhi	r2,33045
81111390:	108afb04 	addi	r2,r2,11244
81111394:	00e04574 	movhi	r3,33045
81111398:	18f1be04 	addi	r3,r3,-14600
8111139c:	10c03e15 	stw	r3,248(r2)
	cTemp[63]="usiZeroHiresAmp";
811113a0:	00a04574 	movhi	r2,33045
811113a4:	108afb04 	addi	r2,r2,11244
811113a8:	00e04574 	movhi	r3,33045
811113ac:	18f1c204 	addi	r3,r3,-14584
811113b0:	10c03f15 	stw	r3,252(r2)
}
811113b4:	0001883a 	nop
811113b8:	e037883a 	mov	sp,fp
811113bc:	df000017 	ldw	fp,0(sp)
811113c0:	dec00104 	addi	sp,sp,4
811113c4:	f800283a 	ret

811113c8 <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
811113c8:	defff604 	addi	sp,sp,-40
811113cc:	de00012e 	bgeu	sp,et,811113d4 <vInAckHandlerTaskV2+0xc>
811113d0:	003b68fa 	trap	3
811113d4:	dfc00915 	stw	ra,36(sp)
811113d8:	df000815 	stw	fp,32(sp)
811113dc:	df000804 	addi	fp,sp,32
811113e0:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
811113e4:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
811113e8:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
811113ec:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
811113f0:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
811113f4:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
811113f8:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
811113fc:	e03ffa45 	stb	zero,-23(fp)

    #ifdef DEBUG_ON
        debug(fp,"In Ack Handler Task. (Task on)\n");
81111400:	d0a06117 	ldw	r2,-32380(gp)
81111404:	100f883a 	mov	r7,r2
81111408:	018007c4 	movi	r6,31
8111140c:	01400044 	movi	r5,1
81111410:	01204574 	movhi	r4,33045
81111414:	2131c604 	addi	r4,r4,-14568
81111418:	1120e540 	call	81120e54 <fwrite>
    #endif

	eReceiverAckState = sRAConfiguring;
8111141c:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
81111420:	e0bff917 	ldw	r2,-28(fp)
81111424:	10c00060 	cmpeqi	r3,r2,1
81111428:	1800071e 	bne	r3,zero,81111448 <vInAckHandlerTaskV2+0x80>
8111142c:	0080032e 	bgeu	zero,r2,8111143c <vInAckHandlerTaskV2+0x74>
81111430:	108000a0 	cmpeqi	r2,r2,2
81111434:	10004a1e 	bne	r2,zero,81111560 <vInAckHandlerTaskV2+0x198>
81111438:	0000ac06 	br	811116ec <vInAckHandlerTaskV2+0x324>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
8111143c:	00800044 	movi	r2,1
81111440:	e0bff915 	stw	r2,-28(fp)
				break;
81111444:	0000b306 	br	81111714 <vInAckHandlerTaskV2+0x34c>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
81111448:	00800044 	movi	r2,1
8111144c:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
81111450:	d0a06517 	ldw	r2,-32364(gp)
81111454:	e0fffe04 	addi	r3,fp,-8
81111458:	180d883a 	mov	r6,r3
8111145c:	000b883a 	mov	r5,zero
81111460:	1009883a 	mov	r4,r2
81111464:	113dcd40 	call	8113dcd4 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
81111468:	e0bffe03 	ldbu	r2,-8(fp)
8111146c:	10803fcc 	andi	r2,r2,255
81111470:	1000391e 	bne	r2,zero,81111558 <vInAckHandlerTaskV2+0x190>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
81111474:	d0a06417 	ldw	r2,-32368(gp)
81111478:	e0fffe04 	addi	r3,fp,-8
8111147c:	180d883a 	mov	r6,r3
81111480:	000b883a 	mov	r5,zero
81111484:	1009883a 	mov	r4,r2
81111488:	113bcc80 	call	8113bcc8 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8111148c:	e0bffe03 	ldbu	r2,-8(fp)
81111490:	10803fcc 	andi	r2,r2,255
81111494:	10002b1e 	bne	r2,zero,81111544 <vInAckHandlerTaskV2+0x17c>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
81111498:	e03ffa45 	stb	zero,-23(fp)
8111149c:	00002206 	br	81111528 <vInAckHandlerTaskV2+0x160>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
811114a0:	e0fffa43 	ldbu	r3,-23(fp)
811114a4:	00a045b4 	movhi	r2,33046
811114a8:	10809704 	addi	r2,r2,604
811114ac:	18c7883a 	add	r3,r3,r3
811114b0:	18c7883a 	add	r3,r3,r3
811114b4:	10c5883a 	add	r2,r2,r3
811114b8:	10800003 	ldbu	r2,0(r2)
811114bc:	10803fcc 	andi	r2,r2,255
811114c0:	1080201c 	xori	r2,r2,128
811114c4:	10bfe004 	addi	r2,r2,-128
811114c8:	10001426 	beq	r2,zero,8111151c <vInAckHandlerTaskV2+0x154>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
811114cc:	e0fffa43 	ldbu	r3,-23(fp)
811114d0:	00a045b4 	movhi	r2,33046
811114d4:	10809704 	addi	r2,r2,604
811114d8:	18c7883a 	add	r3,r3,r3
811114dc:	18c7883a 	add	r3,r3,r3
811114e0:	10c5883a 	add	r2,r2,r3
811114e4:	10c0000b 	ldhu	r3,0(r2)
811114e8:	d0e0560d 	sth	r3,-32424(gp)
811114ec:	1080008b 	ldhu	r2,2(r2)
811114f0:	d0a0568d 	sth	r2,-32422(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
811114f4:	e0fffa43 	ldbu	r3,-23(fp)
811114f8:	00a045b4 	movhi	r2,33046
811114fc:	10809704 	addi	r2,r2,604
81111500:	18c7883a 	add	r3,r3,r3
81111504:	18c7883a 	add	r3,r3,r3
81111508:	10c5883a 	add	r2,r2,r3
8111150c:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
81111510:	00800084 	movi	r2,2
81111514:	e0bff915 	stw	r2,-28(fp)
                                break;                                
81111518:	00000606 	br	81111534 <vInAckHandlerTaskV2+0x16c>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8111151c:	e0bffa43 	ldbu	r2,-23(fp)
81111520:	10800044 	addi	r2,r2,1
81111524:	e0bffa45 	stb	r2,-23(fp)
81111528:	e0bffa43 	ldbu	r2,-23(fp)
8111152c:	108001b0 	cmpltui	r2,r2,6
81111530:	103fdb1e 	bne	r2,zero,811114a0 <__reset+0xfb0f14a0>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
81111534:	d0a06417 	ldw	r2,-32368(gp)
81111538:	1009883a 	mov	r4,r2
8111153c:	113c26c0 	call	8113c26c <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
81111540:	00007406 	br	81111714 <vInAckHandlerTaskV2+0x34c>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
81111544:	d0a06517 	ldw	r2,-32364(gp)
81111548:	1009883a 	mov	r4,r2
8111154c:	113e05c0 	call	8113e05c <OSSemPost>
                    	vFailGetMutexReceiverTask();
81111550:	111aee40 	call	8111aee4 <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
81111554:	00006f06 	br	81111714 <vInAckHandlerTaskV2+0x34c>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
81111558:	111ae7c0 	call	8111ae7c <vFailGetCountSemaphoreReceiverTask>
                }
                break;
8111155c:	00006d06 	br	81111714 <vInAckHandlerTaskV2+0x34c>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
81111560:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81111564:	d0a06783 	ldbu	r2,-32354(gp)
81111568:	10803fcc 	andi	r2,r2,255
8111156c:	10800218 	cmpnei	r2,r2,8
81111570:	1000021e 	bne	r2,zero,8111157c <vInAckHandlerTaskV2+0x1b4>
81111574:	00c00104 	movi	r3,4
81111578:	00000106 	br	81111580 <vInAckHandlerTaskV2+0x1b8>
8111157c:	0007883a 	mov	r3,zero
81111580:	d0a07403 	ldbu	r2,-32304(gp)
81111584:	10803fcc 	andi	r2,r2,255
81111588:	10800218 	cmpnei	r2,r2,8
8111158c:	1000021e 	bne	r2,zero,81111598 <vInAckHandlerTaskV2+0x1d0>
81111590:	00800084 	movi	r2,2
81111594:	00000106 	br	8111159c <vInAckHandlerTaskV2+0x1d4>
81111598:	0005883a 	mov	r2,zero
8111159c:	1884b03a 	or	r2,r3,r2
811115a0:	1007883a 	mov	r3,r2
811115a4:	d0a07443 	ldbu	r2,-32303(gp)
811115a8:	10803fcc 	andi	r2,r2,255
811115ac:	108001a0 	cmpeqi	r2,r2,6
811115b0:	1884b03a 	or	r2,r3,r2
811115b4:	1007883a 	mov	r3,r2
811115b8:	e0bffa83 	ldbu	r2,-22(fp)
811115bc:	1884b03a 	or	r2,r3,r2
811115c0:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
811115c4:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
811115c8:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
811115cc:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
811115d0:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
811115d4:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
811115d8:	e0bffa03 	ldbu	r2,-24(fp)
811115dc:	10800044 	addi	r2,r2,1
811115e0:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
811115e4:	e0bffa83 	ldbu	r2,-22(fp)
811115e8:	1080004c 	andi	r2,r2,1
811115ec:	10803fcc 	andi	r2,r2,255
811115f0:	1000061e 	bne	r2,zero,8111160c <vInAckHandlerTaskV2+0x244>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
811115f4:	e0bffd04 	addi	r2,fp,-12
811115f8:	100b883a 	mov	r5,r2
811115fc:	d1205604 	addi	r4,gp,-32424
81111600:	11117180 	call	81111718 <bCheckInAck128>
81111604:	e0bff815 	stw	r2,-32(fp)
81111608:	00000206 	br	81111614 <vInAckHandlerTaskV2+0x24c>
                    else
                        bFinished128 = TRUE;
8111160c:	00800044 	movi	r2,1
81111610:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
81111614:	e0bffa83 	ldbu	r2,-22(fp)
81111618:	1080008c 	andi	r2,r2,2
8111161c:	10803fcc 	andi	r2,r2,255
81111620:	1000081e 	bne	r2,zero,81111644 <vInAckHandlerTaskV2+0x27c>
81111624:	e0bff817 	ldw	r2,-32(fp)
81111628:	1000061e 	bne	r2,zero,81111644 <vInAckHandlerTaskV2+0x27c>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
8111162c:	e0bffc04 	addi	r2,fp,-16
81111630:	100b883a 	mov	r5,r2
81111634:	d1205604 	addi	r4,gp,-32424
81111638:	11118600 	call	81111860 <bCheckInAck64>
8111163c:	e0bff815 	stw	r2,-32(fp)
81111640:	00000206 	br	8111164c <vInAckHandlerTaskV2+0x284>
                    else
                        bFinished64 = TRUE;
81111644:	00800044 	movi	r2,1
81111648:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
8111164c:	e0bffa83 	ldbu	r2,-22(fp)
81111650:	1080010c 	andi	r2,r2,4
81111654:	10803fcc 	andi	r2,r2,255
81111658:	1000081e 	bne	r2,zero,8111167c <vInAckHandlerTaskV2+0x2b4>
8111165c:	e0bff817 	ldw	r2,-32(fp)
81111660:	1000061e 	bne	r2,zero,8111167c <vInAckHandlerTaskV2+0x2b4>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
81111664:	e0bffb04 	addi	r2,fp,-20
81111668:	100b883a 	mov	r5,r2
8111166c:	d1205604 	addi	r4,gp,-32424
81111670:	11119ac0 	call	811119ac <bCheckInAck32>
81111674:	e0bff815 	stw	r2,-32(fp)
81111678:	00000206 	br	81111684 <vInAckHandlerTaskV2+0x2bc>
                    else
                        bFinished32 = TRUE;
8111167c:	00800044 	movi	r2,1
81111680:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
81111684:	e0bffa03 	ldbu	r2,-24(fp)
81111688:	10c00044 	addi	r3,r2,1
8111168c:	e0fffa05 	stb	r3,-24(fp)
81111690:	10803fcc 	andi	r2,r2,255
81111694:	10800ca8 	cmpgeui	r2,r2,50
81111698:	10000e1e 	bne	r2,zero,811116d4 <vInAckHandlerTaskV2+0x30c>
8111169c:	e0bff817 	ldw	r2,-32(fp)
811116a0:	10000c1e 	bne	r2,zero,811116d4 <vInAckHandlerTaskV2+0x30c>
811116a4:	e0bffb17 	ldw	r2,-20(fp)
811116a8:	1005003a 	cmpeq	r2,r2,zero
811116ac:	1007883a 	mov	r3,r2
811116b0:	e0bffc17 	ldw	r2,-16(fp)
811116b4:	1005003a 	cmpeq	r2,r2,zero
811116b8:	1884b03a 	or	r2,r3,r2
811116bc:	10c03fcc 	andi	r3,r2,255
811116c0:	e0bffd17 	ldw	r2,-12(fp)
811116c4:	1005003a 	cmpeq	r2,r2,zero
811116c8:	10803fcc 	andi	r2,r2,255
811116cc:	1884b03a 	or	r2,r3,r2
811116d0:	103fc11e 	bne	r2,zero,811115d8 <__reset+0xfb0f15d8>
                
                if (bFound == FALSE) {
811116d4:	e0bff817 	ldw	r2,-32(fp)
811116d8:	1000011e 	bne	r2,zero,811116e0 <vInAckHandlerTaskV2+0x318>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
811116dc:	111b3a00 	call	8111b3a0 <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
811116e0:	00800044 	movi	r2,1
811116e4:	e0bff915 	stw	r2,-28(fp)
				break;
811116e8:	00000a06 	br	81111714 <vInAckHandlerTaskV2+0x34c>
			default:
                #ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
811116ec:	d0a06117 	ldw	r2,-32380(gp)
811116f0:	100f883a 	mov	r7,r2
811116f4:	01801144 	movi	r6,69
811116f8:	01400044 	movi	r5,1
811116fc:	01204574 	movhi	r4,33045
81111700:	2131ce04 	addi	r4,r4,-14536
81111704:	1120e540 	call	81120e54 <fwrite>
	            #endif
                eReceiverAckState = sRAGettingACK;
81111708:	00800044 	movi	r2,1
8111170c:	e0bff915 	stw	r2,-28(fp)
				break;
81111710:	0001883a 	nop
		}
	}
81111714:	003f4206 	br	81111420 <__reset+0xfb0f1420>

81111718 <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
81111718:	defffa04 	addi	sp,sp,-24
8111171c:	de00012e 	bgeu	sp,et,81111724 <bCheckInAck128+0xc>
81111720:	003b68fa 	trap	3
81111724:	dfc00515 	stw	ra,20(sp)
81111728:	df000415 	stw	fp,16(sp)
8111172c:	df000404 	addi	fp,sp,16
81111730:	e13ffe15 	stw	r4,-8(fp)
81111734:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81111738:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8111173c:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81111740:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81111744:	e0bfff17 	ldw	r2,-4(fp)
81111748:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
8111174c:	d0a06d17 	ldw	r2,-32332(gp)
81111750:	e0fffd44 	addi	r3,fp,-11
81111754:	180d883a 	mov	r6,r3
81111758:	01400144 	movi	r5,5
8111175c:	1009883a 	mov	r4,r2
81111760:	113bcc80 	call	8113bcc8 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81111764:	e0bffd43 	ldbu	r2,-11(fp)
81111768:	10803fcc 	andi	r2,r2,255
8111176c:	10000226 	beq	r2,zero,81111778 <bCheckInAck128+0x60>
        return bFound;
81111770:	e0bffc17 	ldw	r2,-16(fp)
81111774:	00003506 	br	8111184c <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81111778:	e03ffd05 	stb	zero,-12(fp)
8111177c:	00002706 	br	8111181c <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
81111780:	e0fffd03 	ldbu	r3,-12(fp)
81111784:	00a045b4 	movhi	r2,33046
81111788:	10b79504 	addi	r2,r2,-8620
8111178c:	18c02324 	muli	r3,r3,140
81111790:	10c5883a 	add	r2,r2,r3
81111794:	10802104 	addi	r2,r2,132
81111798:	10c0000b 	ldhu	r3,0(r2)
8111179c:	e0bffe17 	ldw	r2,-8(fp)
811117a0:	1080008b 	ldhu	r2,2(r2)
811117a4:	18ffffcc 	andi	r3,r3,65535
811117a8:	10bfffcc 	andi	r2,r2,65535
811117ac:	1880181e 	bne	r3,r2,81111810 <bCheckInAck128+0xf8>
            bFound = TRUE;
811117b0:	00800044 	movi	r2,1
811117b4:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
811117b8:	e0fffd03 	ldbu	r3,-12(fp)
811117bc:	00a045b4 	movhi	r2,33046
811117c0:	10b77704 	addi	r2,r2,-8740
811117c4:	18c7883a 	add	r3,r3,r3
811117c8:	18c7883a 	add	r3,r3,r3
811117cc:	10c5883a 	add	r2,r2,r3
811117d0:	10000015 	stw	zero,0(r2)
            SemCount128++;
811117d4:	d0a07443 	ldbu	r2,-32303(gp)
811117d8:	10800044 	addi	r2,r2,1
811117dc:	d0a07445 	stb	r2,-32303(gp)
            error_code = OSSemPost(xSemCountBuffer128);
811117e0:	d0a06217 	ldw	r2,-32376(gp)
811117e4:	1009883a 	mov	r4,r2
811117e8:	113e05c0 	call	8113e05c <OSSemPost>
811117ec:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
811117f0:	e0bffd43 	ldbu	r2,-11(fp)
811117f4:	10803fcc 	andi	r2,r2,255
811117f8:	10000c26 	beq	r2,zero,8111182c <bCheckInAck128+0x114>
                SemCount128--;
811117fc:	d0a07443 	ldbu	r2,-32303(gp)
81111800:	10bfffc4 	addi	r2,r2,-1
81111804:	d0a07445 	stb	r2,-32303(gp)
                vFailSetCountSemaphorexBuffer128();
81111808:	111b2000 	call	8111b200 <vFailSetCountSemaphorexBuffer128>
            }
            break;
8111180c:	00000706 	br	8111182c <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
81111810:	e0bffd03 	ldbu	r2,-12(fp)
81111814:	10800044 	addi	r2,r2,1
81111818:	e0bffd05 	stb	r2,-12(fp)
8111181c:	e0bffd03 	ldbu	r2,-12(fp)
81111820:	108001b0 	cmpltui	r2,r2,6
81111824:	103fd61e 	bne	r2,zero,81111780 <__reset+0xfb0f1780>
81111828:	00000106 	br	81111830 <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
8111182c:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81111830:	d0a06d17 	ldw	r2,-32332(gp)
81111834:	1009883a 	mov	r4,r2
81111838:	113c26c0 	call	8113c26c <OSMutexPost>
    (*bFinished) = TRUE;
8111183c:	e0bfff17 	ldw	r2,-4(fp)
81111840:	00c00044 	movi	r3,1
81111844:	10c00015 	stw	r3,0(r2)

    return bFound;
81111848:	e0bffc17 	ldw	r2,-16(fp)
}
8111184c:	e037883a 	mov	sp,fp
81111850:	dfc00117 	ldw	ra,4(sp)
81111854:	df000017 	ldw	fp,0(sp)
81111858:	dec00204 	addi	sp,sp,8
8111185c:	f800283a 	ret

81111860 <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
81111860:	defffa04 	addi	sp,sp,-24
81111864:	de00012e 	bgeu	sp,et,8111186c <bCheckInAck64+0xc>
81111868:	003b68fa 	trap	3
8111186c:	dfc00515 	stw	ra,20(sp)
81111870:	df000415 	stw	fp,16(sp)
81111874:	df000404 	addi	fp,sp,16
81111878:	e13ffe15 	stw	r4,-8(fp)
8111187c:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81111880:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81111884:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81111888:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8111188c:	e0bfff17 	ldw	r2,-4(fp)
81111890:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
81111894:	d0a07017 	ldw	r2,-32320(gp)
81111898:	e0fffd44 	addi	r3,fp,-11
8111189c:	180d883a 	mov	r6,r3
811118a0:	01400044 	movi	r5,1
811118a4:	1009883a 	mov	r4,r2
811118a8:	113bcc80 	call	8113bcc8 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
811118ac:	e0bffd43 	ldbu	r2,-11(fp)
811118b0:	10803fcc 	andi	r2,r2,255
811118b4:	10000226 	beq	r2,zero,811118c0 <bCheckInAck64+0x60>
        return bFound;
811118b8:	e0bffc17 	ldw	r2,-16(fp)
811118bc:	00003606 	br	81111998 <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
811118c0:	e03ffd05 	stb	zero,-12(fp)
811118c4:	00002806 	br	81111968 <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
811118c8:	e0fffd03 	ldbu	r3,-12(fp)
811118cc:	00a04574 	movhi	r2,33045
811118d0:	10933b04 	addi	r2,r2,19692
811118d4:	18c01324 	muli	r3,r3,76
811118d8:	10c5883a 	add	r2,r2,r3
811118dc:	10801104 	addi	r2,r2,68
811118e0:	10c0000b 	ldhu	r3,0(r2)
811118e4:	e0bffe17 	ldw	r2,-8(fp)
811118e8:	1080008b 	ldhu	r2,2(r2)
811118ec:	18ffffcc 	andi	r3,r3,65535
811118f0:	10bfffcc 	andi	r2,r2,65535
811118f4:	1880191e 	bne	r3,r2,8111195c <bCheckInAck64+0xfc>
            bFound = TRUE;
811118f8:	00800044 	movi	r2,1
811118fc:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
81111900:	e0fffd03 	ldbu	r3,-12(fp)
81111904:	00a045b4 	movhi	r2,33046
81111908:	10b77704 	addi	r2,r2,-8740
8111190c:	18c00184 	addi	r3,r3,6
81111910:	18c7883a 	add	r3,r3,r3
81111914:	18c7883a 	add	r3,r3,r3
81111918:	10c5883a 	add	r2,r2,r3
8111191c:	10000015 	stw	zero,0(r2)
            SemCount64++;
81111920:	d0a07403 	ldbu	r2,-32304(gp)
81111924:	10800044 	addi	r2,r2,1
81111928:	d0a07405 	stb	r2,-32304(gp)
            error_code = OSSemPost(xSemCountBuffer64);
8111192c:	d0a05d17 	ldw	r2,-32396(gp)
81111930:	1009883a 	mov	r4,r2
81111934:	113e05c0 	call	8113e05c <OSSemPost>
81111938:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8111193c:	e0bffd43 	ldbu	r2,-11(fp)
81111940:	10803fcc 	andi	r2,r2,255
81111944:	10000c26 	beq	r2,zero,81111978 <bCheckInAck64+0x118>
                SemCount64--;
81111948:	d0a07403 	ldbu	r2,-32304(gp)
8111194c:	10bfffc4 	addi	r2,r2,-1
81111950:	d0a07405 	stb	r2,-32304(gp)
                vFailSetCountSemaphorexBuffer64();
81111954:	111b1980 	call	8111b198 <vFailSetCountSemaphorexBuffer64>
            }
            break;
81111958:	00000706 	br	81111978 <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
8111195c:	e0bffd03 	ldbu	r2,-12(fp)
81111960:	10800044 	addi	r2,r2,1
81111964:	e0bffd05 	stb	r2,-12(fp)
81111968:	e0bffd03 	ldbu	r2,-12(fp)
8111196c:	10800230 	cmpltui	r2,r2,8
81111970:	103fd51e 	bne	r2,zero,811118c8 <__reset+0xfb0f18c8>
81111974:	00000106 	br	8111197c <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
81111978:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
8111197c:	d0a07017 	ldw	r2,-32320(gp)
81111980:	1009883a 	mov	r4,r2
81111984:	113c26c0 	call	8113c26c <OSMutexPost>
    (*bFinished) = TRUE;
81111988:	e0bfff17 	ldw	r2,-4(fp)
8111198c:	00c00044 	movi	r3,1
81111990:	10c00015 	stw	r3,0(r2)

    return bFound;
81111994:	e0bffc17 	ldw	r2,-16(fp)
}
81111998:	e037883a 	mov	sp,fp
8111199c:	dfc00117 	ldw	ra,4(sp)
811119a0:	df000017 	ldw	fp,0(sp)
811119a4:	dec00204 	addi	sp,sp,8
811119a8:	f800283a 	ret

811119ac <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
811119ac:	defffa04 	addi	sp,sp,-24
811119b0:	de00012e 	bgeu	sp,et,811119b8 <bCheckInAck32+0xc>
811119b4:	003b68fa 	trap	3
811119b8:	dfc00515 	stw	ra,20(sp)
811119bc:	df000415 	stw	fp,16(sp)
811119c0:	df000404 	addi	fp,sp,16
811119c4:	e13ffe15 	stw	r4,-8(fp)
811119c8:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
811119cc:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
811119d0:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
811119d4:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
811119d8:	e0bfff17 	ldw	r2,-4(fp)
811119dc:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
811119e0:	d0a06b17 	ldw	r2,-32340(gp)
811119e4:	e0fffd44 	addi	r3,fp,-11
811119e8:	180d883a 	mov	r6,r3
811119ec:	01400044 	movi	r5,1
811119f0:	1009883a 	mov	r4,r2
811119f4:	113bcc80 	call	8113bcc8 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
811119f8:	e0bffd43 	ldbu	r2,-11(fp)
811119fc:	10803fcc 	andi	r2,r2,255
81111a00:	10000226 	beq	r2,zero,81111a0c <bCheckInAck32+0x60>
        return bFound;
81111a04:	e0bffc17 	ldw	r2,-16(fp)
81111a08:	00003606 	br	81111ae4 <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
81111a0c:	e03ffd05 	stb	zero,-12(fp)
81111a10:	00002806 	br	81111ab4 <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
81111a14:	e0fffd03 	ldbu	r3,-12(fp)
81111a18:	00a045b4 	movhi	r2,33046
81111a1c:	10a4f704 	addi	r2,r2,-27684
81111a20:	18c00b24 	muli	r3,r3,44
81111a24:	10c5883a 	add	r2,r2,r3
81111a28:	10800904 	addi	r2,r2,36
81111a2c:	10c0000b 	ldhu	r3,0(r2)
81111a30:	e0bffe17 	ldw	r2,-8(fp)
81111a34:	1080008b 	ldhu	r2,2(r2)
81111a38:	18ffffcc 	andi	r3,r3,65535
81111a3c:	10bfffcc 	andi	r2,r2,65535
81111a40:	1880191e 	bne	r3,r2,81111aa8 <bCheckInAck32+0xfc>
            bFound = TRUE;
81111a44:	00800044 	movi	r2,1
81111a48:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
81111a4c:	e0fffd03 	ldbu	r3,-12(fp)
81111a50:	00a045b4 	movhi	r2,33046
81111a54:	10b77704 	addi	r2,r2,-8740
81111a58:	18c00384 	addi	r3,r3,14
81111a5c:	18c7883a 	add	r3,r3,r3
81111a60:	18c7883a 	add	r3,r3,r3
81111a64:	10c5883a 	add	r2,r2,r3
81111a68:	10000015 	stw	zero,0(r2)
            SemCount32++;
81111a6c:	d0a06783 	ldbu	r2,-32354(gp)
81111a70:	10800044 	addi	r2,r2,1
81111a74:	d0a06785 	stb	r2,-32354(gp)
            error_code = OSSemPost(xSemCountBuffer32);
81111a78:	d0a06e17 	ldw	r2,-32328(gp)
81111a7c:	1009883a 	mov	r4,r2
81111a80:	113e05c0 	call	8113e05c <OSSemPost>
81111a84:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81111a88:	e0bffd43 	ldbu	r2,-11(fp)
81111a8c:	10803fcc 	andi	r2,r2,255
81111a90:	10000c26 	beq	r2,zero,81111ac4 <bCheckInAck32+0x118>
                SemCount32--;
81111a94:	d0a06783 	ldbu	r2,-32354(gp)
81111a98:	10bfffc4 	addi	r2,r2,-1
81111a9c:	d0a06785 	stb	r2,-32354(gp)
                vFailSetCountSemaphorexBuffer32();
81111aa0:	111b1300 	call	8111b130 <vFailSetCountSemaphorexBuffer32>
            }
            break;
81111aa4:	00000706 	br	81111ac4 <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
81111aa8:	e0bffd03 	ldbu	r2,-12(fp)
81111aac:	10800044 	addi	r2,r2,1
81111ab0:	e0bffd05 	stb	r2,-12(fp)
81111ab4:	e0bffd03 	ldbu	r2,-12(fp)
81111ab8:	10800230 	cmpltui	r2,r2,8
81111abc:	103fd51e 	bne	r2,zero,81111a14 <__reset+0xfb0f1a14>
81111ac0:	00000106 	br	81111ac8 <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
81111ac4:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
81111ac8:	d0a06b17 	ldw	r2,-32340(gp)
81111acc:	1009883a 	mov	r4,r2
81111ad0:	113c26c0 	call	8113c26c <OSMutexPost>
    (*bFinished) = TRUE;
81111ad4:	e0bfff17 	ldw	r2,-4(fp)
81111ad8:	00c00044 	movi	r3,1
81111adc:	10c00015 	stw	r3,0(r2)

    return bFound;
81111ae0:	e0bffc17 	ldw	r2,-16(fp)
}
81111ae4:	e037883a 	mov	sp,fp
81111ae8:	dfc00117 	ldw	ra,4(sp)
81111aec:	df000017 	ldw	fp,0(sp)
81111af0:	dec00204 	addi	sp,sp,8
81111af4:	f800283a 	ret

81111af8 <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
81111af8:	defff704 	addi	sp,sp,-36
81111afc:	de00012e 	bgeu	sp,et,81111b04 <vInitialTask+0xc>
81111b00:	003b68fa 	trap	3
81111b04:	dfc00815 	stw	ra,32(sp)
81111b08:	df000715 	stw	fp,28(sp)
81111b0c:	df000704 	addi	fp,sp,28
81111b10:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
81111b14:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
81111b18:	d8000415 	stw	zero,16(sp)
81111b1c:	d8000315 	stw	zero,12(sp)
81111b20:	00810004 	movi	r2,1024
81111b24:	d8800215 	stw	r2,8(sp)
81111b28:	00a04574 	movhi	r2,33045
81111b2c:	108b3b04 	addi	r2,r2,11500
81111b30:	d8800115 	stw	r2,4(sp)
81111b34:	008002c4 	movi	r2,11
81111b38:	d8800015 	stw	r2,0(sp)
81111b3c:	01c002c4 	movi	r7,11
81111b40:	01a04574 	movhi	r6,33045
81111b44:	318f3a04 	addi	r6,r6,15592
81111b48:	016045b4 	movhi	r5,33046
81111b4c:	29605b04 	addi	r5,r5,-32404
81111b50:	01204474 	movhi	r4,33041
81111b54:	2136c804 	addi	r4,r4,-9440
81111b58:	113ea400 	call	8113ea40 <OSTaskCreateExt>
81111b5c:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81111b60:	e0bffe03 	ldbu	r2,-8(fp)
81111b64:	10803fcc 	andi	r2,r2,255
81111b68:	10000526 	beq	r2,zero,81111b80 <vInitialTask+0x88>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81111b6c:	e0bffe03 	ldbu	r2,-8(fp)
81111b70:	10803fcc 	andi	r2,r2,255
81111b74:	1009883a 	mov	r4,r2
81111b78:	111aaac0 	call	8111aaac <printErrorTask>
		#endif
			vCoudlNotCreateNFee0Task();
81111b7c:	111bf580 	call	8111bf58 <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81111b80:	01c17704 	movi	r7,1500
81111b84:	000d883a 	mov	r6,zero
81111b88:	000b883a 	mov	r5,zero
81111b8c:	0009883a 	mov	r4,zero
81111b90:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
81111b94:	d8000415 	stw	zero,16(sp)
81111b98:	d8000315 	stw	zero,12(sp)
81111b9c:	00810004 	movi	r2,1024
81111ba0:	d8800215 	stw	r2,8(sp)
81111ba4:	00a04574 	movhi	r2,33045
81111ba8:	109c4904 	addi	r2,r2,28964
81111bac:	d8800115 	stw	r2,4(sp)
81111bb0:	00800284 	movi	r2,10
81111bb4:	d8800015 	stw	r2,0(sp)
81111bb8:	01c00284 	movi	r7,10
81111bbc:	01a045b4 	movhi	r6,33046
81111bc0:	31a04804 	addi	r6,r6,-32480
81111bc4:	016045b4 	movhi	r5,33046
81111bc8:	29605304 	addi	r5,r5,-32436
81111bcc:	01204474 	movhi	r4,33041
81111bd0:	2136a004 	addi	r4,r4,-9600
81111bd4:	113ea400 	call	8113ea40 <OSTaskCreateExt>
81111bd8:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81111bdc:	e0bffe03 	ldbu	r2,-8(fp)
81111be0:	10803fcc 	andi	r2,r2,255
81111be4:	10000526 	beq	r2,zero,81111bfc <vInitialTask+0x104>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81111be8:	e0bffe03 	ldbu	r2,-8(fp)
81111bec:	10803fcc 	andi	r2,r2,255
81111bf0:	1009883a 	mov	r4,r2
81111bf4:	111aaac0 	call	8111aaac <printErrorTask>
		#endif
			vCoudlNotCreateDataControllerTask();
81111bf8:	111c2300 	call	8111c230 <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81111bfc:	01c17704 	movi	r7,1500
81111c00:	000d883a 	mov	r6,zero
81111c04:	000b883a 	mov	r5,zero
81111c08:	0009883a 	mov	r4,zero
81111c0c:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
81111c10:	d8000415 	stw	zero,16(sp)
81111c14:	d8000315 	stw	zero,12(sp)
81111c18:	00810004 	movi	r2,1024
81111c1c:	d8800215 	stw	r2,8(sp)
81111c20:	00a045b4 	movhi	r2,33046
81111c24:	10b87f04 	addi	r2,r2,-7684
81111c28:	d8800115 	stw	r2,4(sp)
81111c2c:	00800244 	movi	r2,9
81111c30:	d8800015 	stw	r2,0(sp)
81111c34:	01c00244 	movi	r7,9
81111c38:	01a045b4 	movhi	r6,33046
81111c3c:	31bc7e04 	addi	r6,r6,-3592
81111c40:	016045b4 	movhi	r5,33046
81111c44:	29605b04 	addi	r5,r5,-32404
81111c48:	01204474 	movhi	r4,33041
81111c4c:	21081f04 	addi	r4,r4,8316
81111c50:	113ea400 	call	8113ea40 <OSTaskCreateExt>
81111c54:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81111c58:	e0bffe03 	ldbu	r2,-8(fp)
81111c5c:	10803fcc 	andi	r2,r2,255
81111c60:	10000526 	beq	r2,zero,81111c78 <vInitialTask+0x180>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81111c64:	e0bffe03 	ldbu	r2,-8(fp)
81111c68:	10803fcc 	andi	r2,r2,255
81111c6c:	1009883a 	mov	r4,r2
81111c70:	111aaac0 	call	8111aaac <printErrorTask>
		#endif
			vCoudlNotCreateNFeeControllerTask();
81111c74:	111c1c80 	call	8111c1c8 <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81111c78:	01c17704 	movi	r7,1500
81111c7c:	000d883a 	mov	r6,zero
81111c80:	000b883a 	mov	r5,zero
81111c84:	0009883a 	mov	r4,zero
81111c88:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
81111c8c:	d8000415 	stw	zero,16(sp)
81111c90:	d8000315 	stw	zero,12(sp)
81111c94:	00810004 	movi	r2,1024
81111c98:	d8800215 	stw	r2,8(sp)
81111c9c:	00a045b4 	movhi	r2,33046
81111ca0:	108aa104 	addi	r2,r2,10884
81111ca4:	d8800115 	stw	r2,4(sp)
81111ca8:	00800204 	movi	r2,8
81111cac:	d8800015 	stw	r2,0(sp)
81111cb0:	01c00204 	movi	r7,8
81111cb4:	01a045b4 	movhi	r6,33046
81111cb8:	318ea004 	addi	r6,r6,14976
81111cbc:	016045b4 	movhi	r5,33046
81111cc0:	29604904 	addi	r5,r5,-32476
81111cc4:	01204474 	movhi	r4,33041
81111cc8:	2111c204 	addi	r4,r4,18184
81111ccc:	113ea400 	call	8113ea40 <OSTaskCreateExt>
81111cd0:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81111cd4:	e0bffe03 	ldbu	r2,-8(fp)
81111cd8:	10803fcc 	andi	r2,r2,255
81111cdc:	10000526 	beq	r2,zero,81111cf4 <vInitialTask+0x1fc>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81111ce0:	e0bffe03 	ldbu	r2,-8(fp)
81111ce4:	10803fcc 	andi	r2,r2,255
81111ce8:	1009883a 	mov	r4,r2
81111cec:	111aaac0 	call	8111aaac <printErrorTask>
		#endif
			vCoudlNotCreateMebTask();
81111cf0:	111c2980 	call	8111c298 <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81111cf4:	01c17704 	movi	r7,1500
81111cf8:	000d883a 	mov	r6,zero
81111cfc:	000b883a 	mov	r5,zero
81111d00:	0009883a 	mov	r4,zero
81111d04:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
81111d08:	d8000415 	stw	zero,16(sp)
81111d0c:	d8000315 	stw	zero,12(sp)
81111d10:	00810004 	movi	r2,1024
81111d14:	d8800215 	stw	r2,8(sp)
81111d18:	00a04574 	movhi	r2,33045
81111d1c:	10984904 	addi	r2,r2,24868
81111d20:	d8800115 	stw	r2,4(sp)
81111d24:	00800784 	movi	r2,30
81111d28:	d8800015 	stw	r2,0(sp)
81111d2c:	01c00784 	movi	r7,30
81111d30:	01a04574 	movhi	r6,33045
81111d34:	319c4804 	addi	r6,r6,28960
81111d38:	000b883a 	mov	r5,zero
81111d3c:	01204474 	movhi	r4,33041
81111d40:	21188e04 	addi	r4,r4,25144
81111d44:	113ea400 	call	8113ea40 <OSTaskCreateExt>
81111d48:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81111d4c:	e0bffe03 	ldbu	r2,-8(fp)
81111d50:	10803fcc 	andi	r2,r2,255
81111d54:	10000526 	beq	r2,zero,81111d6c <vInitialTask+0x274>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81111d58:	e0bffe03 	ldbu	r2,-8(fp)
81111d5c:	10803fcc 	andi	r2,r2,255
81111d60:	1009883a 	mov	r4,r2
81111d64:	111aaac0 	call	8111aaac <printErrorTask>
		#endif
		vFailTimeoutCheckerTaskCreate();
81111d68:	111b8c40 	call	8111b8c4 <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81111d6c:	01c03204 	movi	r7,200
81111d70:	000d883a 	mov	r6,zero
81111d74:	000b883a 	mov	r5,zero
81111d78:	0009883a 	mov	r4,zero
81111d7c:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
81111d80:	d8000415 	stw	zero,16(sp)
81111d84:	d8000315 	stw	zero,12(sp)
81111d88:	00810004 	movi	r2,1024
81111d8c:	d8800215 	stw	r2,8(sp)
81111d90:	00a045b4 	movhi	r2,33046
81111d94:	10ab5f04 	addi	r2,r2,-21124
81111d98:	d8800115 	stw	r2,4(sp)
81111d9c:	008006c4 	movi	r2,27
81111da0:	d8800015 	stw	r2,0(sp)
81111da4:	01c006c4 	movi	r7,27
81111da8:	01a045b4 	movhi	r6,33046
81111dac:	31af5e04 	addi	r6,r6,-17032
81111db0:	000b883a 	mov	r5,zero
81111db4:	01204474 	movhi	r4,33041
81111db8:	210a0804 	addi	r4,r4,10272
81111dbc:	113ea400 	call	8113ea40 <OSTaskCreateExt>
81111dc0:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81111dc4:	e0bffe03 	ldbu	r2,-8(fp)
81111dc8:	10803fcc 	andi	r2,r2,255
81111dcc:	10000526 	beq	r2,zero,81111de4 <vInitialTask+0x2ec>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81111dd0:	e0bffe03 	ldbu	r2,-8(fp)
81111dd4:	10803fcc 	andi	r2,r2,255
81111dd8:	1009883a 	mov	r4,r2
81111ddc:	111aaac0 	call	8111aaac <printErrorTask>
		#endif
		vFailOutAckHandlerTaskCreate();
81111de0:	111b7e00 	call	8111b7e0 <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81111de4:	01c03204 	movi	r7,200
81111de8:	000d883a 	mov	r6,zero
81111dec:	000b883a 	mov	r5,zero
81111df0:	0009883a 	mov	r4,zero
81111df4:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
81111df8:	d8000415 	stw	zero,16(sp)
81111dfc:	d8000315 	stw	zero,12(sp)
81111e00:	00810004 	movi	r2,1024
81111e04:	d8800215 	stw	r2,8(sp)
81111e08:	00a04574 	movhi	r2,33045
81111e0c:	108f3b04 	addi	r2,r2,15596
81111e10:	d8800115 	stw	r2,4(sp)
81111e14:	00800644 	movi	r2,25
81111e18:	d8800015 	stw	r2,0(sp)
81111e1c:	01c00644 	movi	r7,25
81111e20:	01a04574 	movhi	r6,33045
81111e24:	31933a04 	addi	r6,r6,19688
81111e28:	000b883a 	mov	r5,zero
81111e2c:	01204474 	movhi	r4,33041
81111e30:	2104f204 	addi	r4,r4,5064
81111e34:	113ea400 	call	8113ea40 <OSTaskCreateExt>
81111e38:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81111e3c:	e0bffe03 	ldbu	r2,-8(fp)
81111e40:	10803fcc 	andi	r2,r2,255
81111e44:	10000526 	beq	r2,zero,81111e5c <vInitialTask+0x364>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81111e48:	e0bffe03 	ldbu	r2,-8(fp)
81111e4c:	10803fcc 	andi	r2,r2,255
81111e50:	1009883a 	mov	r4,r2
81111e54:	111aaac0 	call	8111aaac <printErrorTask>
		#endif
		vFailInAckHandlerTaskCreate();
81111e58:	111b7940 	call	8111b794 <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81111e5c:	01c03204 	movi	r7,200
81111e60:	000d883a 	mov	r6,zero
81111e64:	000b883a 	mov	r5,zero
81111e68:	0009883a 	mov	r4,zero
81111e6c:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
81111e70:	d8000415 	stw	zero,16(sp)
81111e74:	d8000315 	stw	zero,12(sp)
81111e78:	00818004 	movi	r2,1536
81111e7c:	d8800215 	stw	r2,8(sp)
81111e80:	00a045b4 	movhi	r2,33046
81111e84:	10849d04 	addi	r2,r2,4724
81111e88:	d8800115 	stw	r2,4(sp)
81111e8c:	00800704 	movi	r2,28
81111e90:	d8800015 	stw	r2,0(sp)
81111e94:	01c00704 	movi	r7,28
81111e98:	01a045b4 	movhi	r6,33046
81111e9c:	318a9c04 	addi	r6,r6,10864
81111ea0:	000b883a 	mov	r5,zero
81111ea4:	01204474 	movhi	r4,33041
81111ea8:	210ac604 	addi	r4,r4,11032
81111eac:	113ea400 	call	8113ea40 <OSTaskCreateExt>
81111eb0:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81111eb4:	e0bffe03 	ldbu	r2,-8(fp)
81111eb8:	10803fcc 	andi	r2,r2,255
81111ebc:	10000526 	beq	r2,zero,81111ed4 <vInitialTask+0x3dc>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81111ec0:	e0bffe03 	ldbu	r2,-8(fp)
81111ec4:	10803fcc 	andi	r2,r2,255
81111ec8:	1009883a 	mov	r4,r2
81111ecc:	111aaac0 	call	8111aaac <printErrorTask>
		#endif
		vFailParserCommTaskCreate();
81111ed0:	111b7480 	call	8111b748 <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81111ed4:	01c03204 	movi	r7,200
81111ed8:	000d883a 	mov	r6,zero
81111edc:	000b883a 	mov	r5,zero
81111ee0:	0009883a 	mov	r4,zero
81111ee4:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
81111ee8:	d8000415 	stw	zero,16(sp)
81111eec:	d8000315 	stw	zero,12(sp)
81111ef0:	00818004 	movi	r2,1536
81111ef4:	d8800215 	stw	r2,8(sp)
81111ef8:	00a045b4 	movhi	r2,33046
81111efc:	10a54f04 	addi	r2,r2,-27332
81111f00:	d8800115 	stw	r2,4(sp)
81111f04:	00800804 	movi	r2,32
81111f08:	d8800015 	stw	r2,0(sp)
81111f0c:	01c00804 	movi	r7,32
81111f10:	01a045b4 	movhi	r6,33046
81111f14:	31ab4e04 	addi	r6,r6,-21192
81111f18:	000b883a 	mov	r5,zero
81111f1c:	01204474 	movhi	r4,33041
81111f20:	210ee204 	addi	r4,r4,15240
81111f24:	113ea400 	call	8113ea40 <OSTaskCreateExt>
81111f28:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81111f2c:	e0bffe03 	ldbu	r2,-8(fp)
81111f30:	10803fcc 	andi	r2,r2,255
81111f34:	10000526 	beq	r2,zero,81111f4c <vInitialTask+0x454>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
81111f38:	e0bffe03 	ldbu	r2,-8(fp)
81111f3c:	10803fcc 	andi	r2,r2,255
81111f40:	1009883a 	mov	r4,r2
81111f44:	111aaac0 	call	8111aaac <printErrorTask>
		#endif
		vFailReceiverCreate();
81111f48:	111b04c0 	call	8111b04c <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81111f4c:	01c03204 	movi	r7,200
81111f50:	000d883a 	mov	r6,zero
81111f54:	000b883a 	mov	r5,zero
81111f58:	0009883a 	mov	r4,zero
81111f5c:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
81111f60:	d8000415 	stw	zero,16(sp)
81111f64:	d8000315 	stw	zero,12(sp)
81111f68:	00810004 	movi	r2,1024
81111f6c:	d8800215 	stw	r2,8(sp)
81111f70:	00a04574 	movhi	r2,33045
81111f74:	10943704 	addi	r2,r2,20700
81111f78:	d8800115 	stw	r2,4(sp)
81111f7c:	00800684 	movi	r2,26
81111f80:	d8800015 	stw	r2,0(sp)
81111f84:	01c00684 	movi	r7,26
81111f88:	01a04574 	movhi	r6,33045
81111f8c:	31983604 	addi	r6,r6,24792
81111f90:	000b883a 	mov	r5,zero
81111f94:	01204474 	movhi	r4,33041
81111f98:	21116404 	addi	r4,r4,17808
81111f9c:	113ea400 	call	8113ea40 <OSTaskCreateExt>
81111fa0:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
81111fa4:	01c03204 	movi	r7,200
81111fa8:	000d883a 	mov	r6,zero
81111fac:	000b883a 	mov	r5,zero
81111fb0:	0009883a 	mov	r4,zero
81111fb4:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
81111fb8:	e0bffe03 	ldbu	r2,-8(fp)
81111fbc:	10803fcc 	andi	r2,r2,255
81111fc0:	10000526 	beq	r2,zero,81111fd8 <vInitialTask+0x4e0>
		/* Can't create Task for sender comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
81111fc4:	e0bffe03 	ldbu	r2,-8(fp)
81111fc8:	10803fcc 	andi	r2,r2,255
81111fcc:	1009883a 	mov	r4,r2
81111fd0:	111aaac0 	call	8111aaac <printErrorTask>
		#endif
		vFailSenderCreate();
81111fd4:	111b0980 	call	8111b098 <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
81111fd8:	d0a06c17 	ldw	r2,-32336(gp)
81111fdc:	e17ffe04 	addi	r5,fp,-8
81111fe0:	1009883a 	mov	r4,r2
81111fe4:	11407600 	call	81140760 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
81111fe8:	e0bffe03 	ldbu	r2,-8(fp)
81111fec:	10803fcc 	andi	r2,r2,255
81111ff0:	10000126 	beq	r2,zero,81111ff8 <vInitialTask+0x500>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
81111ff4:	111bb800 	call	8111bb80 <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
81111ff8:	01c00084 	movi	r7,2
81111ffc:	01800784 	movi	r6,30
81112000:	000b883a 	mov	r5,zero
81112004:	0009883a 	mov	r4,zero
81112008:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
8111200c:	01003fc4 	movi	r4,255
81112010:	113ec2c0 	call	8113ec2c <OSTaskDel>
81112014:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
81112018:	e0bffe03 	ldbu	r2,-8(fp)
8111201c:	10803fcc 	andi	r2,r2,255
81112020:	10001026 	beq	r2,zero,81112064 <vInitialTask+0x56c>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
81112024:	e0bffe03 	ldbu	r2,-8(fp)
81112028:	10803fcc 	andi	r2,r2,255
8111202c:	1009883a 	mov	r4,r2
81112030:	111aaac0 	call	8111aaac <printErrorTask>
		#endif
		vFailDeleteInitialization();
81112034:	111b0e40 	call	8111b0e4 <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
81112038:	014009c4 	movi	r5,39
8111203c:	01000044 	movi	r4,1
81112040:	113e3940 	call	8113e394 <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
81112044:	01003fc4 	movi	r4,255
81112048:	113ec2c0 	call	8113ec2c <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
8111204c:	000f883a 	mov	r7,zero
81112050:	01800284 	movi	r6,10
81112054:	000b883a 	mov	r5,zero
81112058:	0009883a 	mov	r4,zero
8111205c:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>
		}
81112060:	003ff806 	br	81112044 <__reset+0xfb0f2044>
	}

}
81112064:	0001883a 	nop
81112068:	e037883a 	mov	sp,fp
8111206c:	dfc00117 	ldw	ra,4(sp)
81112070:	df000017 	ldw	fp,0(sp)
81112074:	dec00204 	addi	sp,sp,8
81112078:	f800283a 	ret

8111207c <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
8111207c:	defff804 	addi	sp,sp,-32
81112080:	de00012e 	bgeu	sp,et,81112088 <vNFeeControlTask+0xc>
81112084:	003b68fa 	trap	3
81112088:	dfc00715 	stw	ra,28(sp)
8111208c:	df000615 	stw	fp,24(sp)
81112090:	df000604 	addi	fp,sp,24
81112094:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucFeeInstL;
	static bool bDmaBack;
	static unsigned char ucWhoGetDMA;
	unsigned char ucIL;

	pxFeeC = (TNFee_Control *) task_data;
81112098:	e0bfff17 	ldw	r2,-4(fp)
8111209c:	e0bffb15 	stw	r2,-20(fp)

	#ifdef DEBUG_ON
        debug(fp,"NFee Controller Task. (Task on)\n");
811120a0:	d0a06117 	ldw	r2,-32380(gp)
811120a4:	100f883a 	mov	r7,r2
811120a8:	01800804 	movi	r6,32
811120ac:	01400044 	movi	r5,1
811120b0:	01204574 	movhi	r4,33045
811120b4:	2131e004 	addi	r4,r4,-14464
811120b8:	1120e540 	call	81120e54 <fwrite>
    #endif

	for (;;) {

		switch (pxFeeC->sMode)
811120bc:	e0bffb17 	ldw	r2,-20(fp)
811120c0:	10809a17 	ldw	r2,616(r2)
811120c4:	10c00168 	cmpgeui	r3,r2,5
811120c8:	1800e81e 	bne	r3,zero,8111246c <vNFeeControlTask+0x3f0>
811120cc:	100690ba 	slli	r3,r2,2
811120d0:	00a04474 	movhi	r2,33041
811120d4:	10883904 	addi	r2,r2,8420
811120d8:	1885883a 	add	r2,r3,r2
811120dc:	10800017 	ldw	r2,0(r2)
811120e0:	1000683a 	jmp	r2
811120e4:	811120f8 	rdprs	r4,r16,17539
811120e8:	81112128 	cmpgeui	r4,r16,17540
811120ec:	81112188 	cmpgei	r4,r16,17542
811120f0:	8111223c 	xorhi	r4,r16,17544
811120f4:	8111229c 	xori	r4,r16,17546
		{
			case sMebInit:
				/* Starting the NFEE Controller */

				/* Clear in CMD Queue  */
				error_codeCtrl = OSQFlush(xQMaskFeeCtrl);
811120f8:	d0a06f17 	ldw	r2,-32324(gp)
811120fc:	1009883a 	mov	r4,r2
81112100:	113cd1c0 	call	8113cd1c <OSQFlush>
81112104:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81112108:	e0bffe03 	ldbu	r2,-8(fp)
8111210c:	10803fcc 	andi	r2,r2,255
81112110:	10000126 	beq	r2,zero,81112118 <vNFeeControlTask+0x9c>
					vFailFlushQueue();
81112114:	111c8dc0 	call	8111c8dc <vFailFlushQueue>
				}

				pxFeeC->sMode = sMebToConfig;
81112118:	e0bffb17 	ldw	r2,-20(fp)
8111211c:	00c00044 	movi	r3,1
81112120:	10c09a15 	stw	r3,616(r2)
				break;
81112124:	0000dd06 	br	8111249c <vNFeeControlTask+0x420>


			case sMebToConfig:
				/* Transition state */
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: Config Mode\n");
81112128:	d0a06117 	ldw	r2,-32380(gp)
8111212c:	100f883a 	mov	r7,r2
81112130:	018008c4 	movi	r6,35
81112134:	01400044 	movi	r5,1
81112138:	01204574 	movhi	r4,33045
8111213c:	2131e904 	addi	r4,r4,-14428
81112140:	1120e540 	call	81120e54 <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
81112144:	d0a05c17 	ldw	r2,-32400(gp)
81112148:	1009883a 	mov	r4,r2
8111214c:	113cd1c0 	call	8113cd1c <OSQFlush>
81112150:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
81112154:	e0bffe03 	ldbu	r2,-8(fp)
81112158:	10803fcc 	andi	r2,r2,255
8111215c:	10000126 	beq	r2,zero,81112164 <vNFeeControlTask+0xe8>
					vFailFlushQueue();
81112160:	111c8dc0 	call	8111c8dc <vFailFlushQueue>
				}

				bCmdSent = FALSE;
81112164:	e03ffc15 	stw	zero,-16(fp)
				bDmaBack = TRUE;
81112168:	00800044 	movi	r2,1
8111216c:	d0a05715 	stw	r2,-32420(gp)
				ucWhoGetDMA = 255;
81112170:	00bfffc4 	movi	r2,-1
81112174:	d0a05805 	stb	r2,-32416(gp)
				pxFeeC->sMode = sMebConfig;
81112178:	e0bffb17 	ldw	r2,-20(fp)
8111217c:	00c000c4 	movi	r3,3
81112180:	10c09a15 	stw	r3,616(r2)
				break;
81112184:	0000c506 	br	8111249c <vNFeeControlTask+0x420>


			case sMebToRun:
				/* Transition state */
				vEvtChangeFeeControllerMode();
81112188:	111ca340 	call	8111ca34 <vEvtChangeFeeControllerMode>
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: RUN Mode\n");
8111218c:	d0a06117 	ldw	r2,-32380(gp)
81112190:	100f883a 	mov	r7,r2
81112194:	01800804 	movi	r6,32
81112198:	01400044 	movi	r5,1
8111219c:	01204574 	movhi	r4,33045
811121a0:	2131f204 	addi	r4,r4,-14392
811121a4:	1120e540 	call	81120e54 <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
811121a8:	d0a05c17 	ldw	r2,-32400(gp)
811121ac:	1009883a 	mov	r4,r2
811121b0:	113cd1c0 	call	8113cd1c <OSQFlush>
811121b4:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
811121b8:	e0bffe03 	ldbu	r2,-8(fp)
811121bc:	10803fcc 	andi	r2,r2,255
811121c0:	10000126 	beq	r2,zero,811121c8 <vNFeeControlTask+0x14c>
					vFailFlushQueue();
811121c4:	111c8dc0 	call	8111c8dc <vFailFlushQueue>
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
811121c8:	e03ffa45 	stb	zero,-23(fp)
811121cc:	00001006 	br	81112210 <vNFeeControlTask+0x194>
				{
					error_codeCtrl = OSQFlush( xFeeQ[ ucIL ] );
811121d0:	e0bffa43 	ldbu	r2,-23(fp)
811121d4:	1085883a 	add	r2,r2,r2
811121d8:	1087883a 	add	r3,r2,r2
811121dc:	d0a06904 	addi	r2,gp,-32348
811121e0:	1885883a 	add	r2,r3,r2
811121e4:	10800017 	ldw	r2,0(r2)
811121e8:	1009883a 	mov	r4,r2
811121ec:	113cd1c0 	call	8113cd1c <OSQFlush>
811121f0:	e0bffe05 	stb	r2,-8(fp)
					if ( error_codeCtrl != OS_NO_ERR ) {
811121f4:	e0bffe03 	ldbu	r2,-8(fp)
811121f8:	10803fcc 	andi	r2,r2,255
811121fc:	10000126 	beq	r2,zero,81112204 <vNFeeControlTask+0x188>
						vFailFlushQueue();
81112200:	111c8dc0 	call	8111c8dc <vFailFlushQueue>
				if ( error_codeCtrl != OS_NO_ERR ) {
					vFailFlushQueue();
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
81112204:	e0bffa43 	ldbu	r2,-23(fp)
81112208:	10800044 	addi	r2,r2,1
8111220c:	e0bffa45 	stb	r2,-23(fp)
81112210:	e0bffa43 	ldbu	r2,-23(fp)
81112214:	103fee26 	beq	r2,zero,811121d0 <__reset+0xfb0f21d0>
					if ( error_codeCtrl != OS_NO_ERR ) {
						vFailFlushQueue();
					}
				}

				bCmdSent = FALSE;
81112218:	e03ffc15 	stw	zero,-16(fp)
				bDmaBack = TRUE;
8111221c:	00800044 	movi	r2,1
81112220:	d0a05715 	stw	r2,-32420(gp)
				ucWhoGetDMA = 255;
81112224:	00bfffc4 	movi	r2,-1
81112228:	d0a05805 	stb	r2,-32416(gp)
				pxFeeC->sMode = sMebRun;
8111222c:	e0bffb17 	ldw	r2,-20(fp)
81112230:	00c00104 	movi	r3,4
81112234:	10c09a15 	stw	r3,616(r2)
				break;
81112238:	00009806 	br	8111249c <vNFeeControlTask+0x420>


			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl); /* Blocking operation */
8111223c:	d0a06f17 	ldw	r2,-32324(gp)
81112240:	e0fffe04 	addi	r3,fp,-8
81112244:	180d883a 	mov	r6,r3
81112248:	000b883a 	mov	r5,zero
8111224c:	1009883a 	mov	r4,r2
81112250:	113cddc0 	call	8113cddc <OSQPend>
81112254:	e0bffd15 	stw	r2,-12(fp)
				if ( error_codeCtrl == OS_ERR_NONE ) {
81112258:	e0bffe03 	ldbu	r2,-8(fp)
8111225c:	10803fcc 	andi	r2,r2,255
81112260:	10000c1e 	bne	r2,zero,81112294 <vNFeeControlTask+0x218>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81112264:	e0bffdc3 	ldbu	r2,-9(fp)
81112268:	10803fcc 	andi	r2,r2,255
8111226c:	10800418 	cmpnei	r2,r2,16
81112270:	1000041e 	bne	r2,zero,81112284 <vNFeeControlTask+0x208>
						
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
81112274:	e0bffd17 	ldw	r2,-12(fp)
81112278:	e17ffb17 	ldw	r5,-20(fp)
8111227c:	1009883a 	mov	r4,r2
81112280:	11124a00 	call	811124a0 <vPerformActionNFCConfig>

					};
					bCmdSent = FALSE;
81112284:	e03ffc15 	stw	zero,-16(fp)
					bDmaBack = TRUE;
81112288:	00800044 	movi	r2,1
8111228c:	d0a05715 	stw	r2,-32420(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
81112290:	00008206 	br	8111249c <vNFeeControlTask+0x420>
					};
					bCmdSent = FALSE;
					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
81112294:	111c5300 	call	8111c530 <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
81112298:	00008006 	br	8111249c <vNFeeControlTask+0x420>
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fat way and 
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				

				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
8111229c:	d0a05717 	ldw	r2,-32420(gp)
811122a0:	10800058 	cmpnei	r2,r2,1
811122a4:	1000221e 	bne	r2,zero,81112330 <vNFeeControlTask+0x2b4>

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 4, &error_codeCtrl);
811122a8:	d0a05c17 	ldw	r2,-32400(gp)
811122ac:	e0fffe04 	addi	r3,fp,-8
811122b0:	180d883a 	mov	r6,r3
811122b4:	01400104 	movi	r5,4
811122b8:	1009883a 	mov	r4,r2
811122bc:	113cddc0 	call	8113cddc <OSQPend>
811122c0:	e0bffd15 	stw	r2,-12(fp)
					if ( error_codeCtrl == OS_ERR_NONE ) {
811122c4:	e0bffe03 	ldbu	r2,-8(fp)
811122c8:	10803fcc 	andi	r2,r2,255
811122cc:	1000181e 	bne	r2,zero,81112330 <vNFeeControlTask+0x2b4>
						ucFeeInstL = uiCmdNFC.ucByte[0];
811122d0:	e0bffd03 	ldbu	r2,-12(fp)
811122d4:	e0bffa05 	stb	r2,-24(fp)


						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
811122d8:	e0bffa03 	ldbu	r2,-24(fp)
811122dc:	e0fffb17 	ldw	r3,-20(fp)
811122e0:	10809624 	muli	r2,r2,600
811122e4:	1885883a 	add	r2,r3,r2
811122e8:	10802304 	addi	r2,r2,140
811122ec:	10800017 	ldw	r2,0(r2)
811122f0:	10800058 	cmpnei	r2,r2,1
811122f4:	10000e1e 	bne	r2,zero,81112330 <vNFeeControlTask+0x2b4>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
811122f8:	e0bffa03 	ldbu	r2,-24(fp)
811122fc:	e0fffa03 	ldbu	r3,-24(fp)
81112300:	180f883a 	mov	r7,r3
81112304:	000d883a 	mov	r6,zero
81112308:	014023c4 	movi	r5,143
8111230c:	1009883a 	mov	r4,r2
81112310:	11126900 	call	81112690 <bSendCmdQToNFeeInst>
81112314:	e0bffc15 	stw	r2,-16(fp)
							if ( bCmdSent == TRUE ) {
81112318:	e0bffc17 	ldw	r2,-16(fp)
8111231c:	10800058 	cmpnei	r2,r2,1
81112320:	1000031e 	bne	r2,zero,81112330 <vNFeeControlTask+0x2b4>
								bDmaBack = FALSE;
81112324:	d0205715 	stw	zero,-32420(gp)
								ucWhoGetDMA = ucFeeInstL;
81112328:	e0bffa03 	ldbu	r2,-24(fp)
8111232c:	d0a05805 	stb	r2,-32416(gp)
							}
						}
					}
				} 

				if ( bDmaBack == FALSE ) {
81112330:	d0a05717 	ldw	r2,-32420(gp)
81112334:	1000081e 	bne	r2,zero,81112358 <vNFeeControlTask+0x2dc>

					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
81112338:	d0a06f17 	ldw	r2,-32324(gp)
8111233c:	e0fffe04 	addi	r3,fp,-8
81112340:	180d883a 	mov	r6,r3
81112344:	000b883a 	mov	r5,zero
81112348:	1009883a 	mov	r4,r2
8111234c:	113cddc0 	call	8113cddc <OSQPend>
81112350:	e0bffd15 	stw	r2,-12(fp)
81112354:	00000706 	br	81112374 <vNFeeControlTask+0x2f8>
				} else {
					/* If No FEE has the DMA */

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 4, &error_codeCtrl);
81112358:	d0a06f17 	ldw	r2,-32324(gp)
8111235c:	e0fffe04 	addi	r3,fp,-8
81112360:	180d883a 	mov	r6,r3
81112364:	01400104 	movi	r5,4
81112368:	1009883a 	mov	r4,r2
8111236c:	113cddc0 	call	8113cddc <OSQPend>
81112370:	e0bffd15 	stw	r2,-12(fp)
				}

				if ( error_codeCtrl == OS_ERR_NONE ){
81112374:	e0bffe03 	ldbu	r2,-8(fp)
81112378:	10803fcc 	andi	r2,r2,255
8111237c:	10002c1e 	bne	r2,zero,81112430 <vNFeeControlTask+0x3b4>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
81112380:	e0bffd83 	ldbu	r2,-10(fp)
81112384:	10803fcc 	andi	r2,r2,255
81112388:	10802058 	cmpnei	r2,r2,129
8111238c:	1000091e 	bne	r2,zero,811123b4 <vNFeeControlTask+0x338>
						if ( uiCmdNFC.ucByte[0] == ucFeeInstL ){
81112390:	e0bffd03 	ldbu	r2,-12(fp)
81112394:	10c03fcc 	andi	r3,r2,255
81112398:	e0bffa03 	ldbu	r2,-24(fp)
8111239c:	1880241e 	bne	r3,r2,81112430 <vNFeeControlTask+0x3b4>
							bDmaBack = TRUE;
811123a0:	00800044 	movi	r2,1
811123a4:	d0a05715 	stw	r2,-32420(gp)
							ucFeeInstL = 255;
811123a8:	00bfffc4 	movi	r2,-1
811123ac:	e0bffa05 	stb	r2,-24(fp)
811123b0:	00001f06 	br	81112430 <vNFeeControlTask+0x3b4>
						}

					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
811123b4:	e0bffdc3 	ldbu	r2,-9(fp)
811123b8:	10803fcc 	andi	r2,r2,255
811123bc:	10800418 	cmpnei	r2,r2,16
811123c0:	1000051e 	bne	r2,zero,811123d8 <vNFeeControlTask+0x35c>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
811123c4:	e0bffd17 	ldw	r2,-12(fp)
811123c8:	e17ffb17 	ldw	r5,-20(fp)
811123cc:	1009883a 	mov	r4,r2
811123d0:	11125680 	call	81112568 <vPerformActionNFCRunning>
811123d4:	00001606 	br	81112430 <vNFeeControlTask+0x3b4>

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
811123d8:	e0bffdc3 	ldbu	r2,-9(fp)
811123dc:	10803fcc 	andi	r2,r2,255
811123e0:	10800470 	cmpltui	r2,r2,17
811123e4:	1000121e 	bne	r2,zero,81112430 <vNFeeControlTask+0x3b4>
811123e8:	e0bffdc3 	ldbu	r2,-9(fp)
811123ec:	10803fcc 	andi	r2,r2,255
811123f0:	108004e8 	cmpgeui	r2,r2,19
811123f4:	10000e1e 	bne	r2,zero,81112430 <vNFeeControlTask+0x3b4>

								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
811123f8:	e0bffdc3 	ldbu	r2,-9(fp)
811123fc:	10bffbc4 	addi	r2,r2,-17
81112400:	10803fcc 	andi	r2,r2,255
81112404:	e0fffd83 	ldbu	r3,-10(fp)
81112408:	18c03fcc 	andi	r3,r3,255
8111240c:	e13ffd43 	ldbu	r4,-11(fp)
81112410:	21003fcc 	andi	r4,r4,255
81112414:	e17ffd03 	ldbu	r5,-12(fp)
81112418:	29403fcc 	andi	r5,r5,255
8111241c:	280f883a 	mov	r7,r5
81112420:	200d883a 	mov	r6,r4
81112424:	180b883a 	mov	r5,r3
81112428:	1009883a 	mov	r4,r2
8111242c:	11126900 	call	81112690 <bSendCmdQToNFeeInst>

							}
						}
					}
				}
				if ( xDefaults.usiDelay == 0 ) {
81112430:	00a045b4 	movhi	r2,33046
81112434:	10975904 	addi	r2,r2,23908
81112438:	1080070b 	ldhu	r2,28(r2)
8111243c:	10bfffcc 	andi	r2,r2,65535
81112440:	1000151e 	bne	r2,zero,81112498 <vNFeeControlTask+0x41c>
					OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
81112444:	00a045b4 	movhi	r2,33046
81112448:	10975904 	addi	r2,r2,23908
8111244c:	1080070b 	ldhu	r2,28(r2)
81112450:	10bfffcc 	andi	r2,r2,65535
81112454:	100f883a 	mov	r7,r2
81112458:	000d883a 	mov	r6,zero
8111245c:	000b883a 	mov	r5,zero
81112460:	0009883a 	mov	r4,zero
81112464:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>
				}
				
				break;		
81112468:	00000b06 	br	81112498 <vNFeeControlTask+0x41c>
			default:
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task: Unknown state, backing to Config Mode.\n");
8111246c:	d0a06117 	ldw	r2,-32380(gp)
81112470:	100f883a 	mov	r7,r2
81112474:	01800f44 	movi	r6,61
81112478:	01400044 	movi	r5,1
8111247c:	01204574 	movhi	r4,33045
81112480:	2131fb04 	addi	r4,r4,-14356
81112484:	1120e540 	call	81120e54 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
81112488:	e0bffb17 	ldw	r2,-20(fp)
8111248c:	00c000c4 	movi	r3,3
81112490:	10c09a15 	stw	r3,616(r2)
				break;
81112494:	00000106 	br	8111249c <vNFeeControlTask+0x420>
				}
				if ( xDefaults.usiDelay == 0 ) {
					OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				}
				
				break;		
81112498:	0001883a 	nop
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
				break;
		}
	}
8111249c:	003f0706 	br	811120bc <__reset+0xfb0f20bc>

811124a0 <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
811124a0:	defffb04 	addi	sp,sp,-20
811124a4:	de00012e 	bgeu	sp,et,811124ac <vPerformActionNFCConfig+0xc>
811124a8:	003b68fa 	trap	3
811124ac:	dfc00415 	stw	ra,16(sp)
811124b0:	df000315 	stw	fp,12(sp)
811124b4:	df000304 	addi	fp,sp,12
811124b8:	e13ffe15 	stw	r4,-8(fp)
811124bc:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	INT8U errorCodeL;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
811124c0:	e0bffe17 	ldw	r2,-8(fp)
811124c4:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
811124c8:	e0bffd83 	ldbu	r2,-10(fp)
811124cc:	10803fcc 	andi	r2,r2,255
811124d0:	10c000a0 	cmpeqi	r3,r2,2
811124d4:	1800121e 	bne	r3,zero,81112520 <vPerformActionNFCConfig+0x80>
811124d8:	10c000c8 	cmpgei	r3,r2,3
811124dc:	1800031e 	bne	r3,zero,811124ec <vPerformActionNFCConfig+0x4c>
811124e0:	10800060 	cmpeqi	r2,r2,1
811124e4:	1000061e 	bne	r2,zero,81112500 <vPerformActionNFCConfig+0x60>
811124e8:	00001106 	br	81112530 <vPerformActionNFCConfig+0x90>
811124ec:	10c02860 	cmpeqi	r3,r2,161
811124f0:	1800031e 	bne	r3,zero,81112500 <vPerformActionNFCConfig+0x60>
811124f4:	108028a0 	cmpeqi	r2,r2,162
811124f8:	1000091e 	bne	r2,zero,81112520 <vPerformActionNFCConfig+0x80>
811124fc:	00000c06 	br	81112530 <vPerformActionNFCConfig+0x90>
		case M_NFC_CONFIG_FORCED:
		case M_NFC_CONFIG:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
81112500:	d0a06117 	ldw	r2,-32380(gp)
81112504:	100f883a 	mov	r7,r2
81112508:	01800d44 	movi	r6,53
8111250c:	01400044 	movi	r5,1
81112510:	01204574 	movhi	r4,33045
81112514:	21320b04 	addi	r4,r4,-14292
81112518:	1120e540 	call	81120e54 <fwrite>
			#endif
			/* Do nothing for now */
			break;
8111251c:	00000c06 	br	81112550 <vPerformActionNFCConfig+0xb0>

		case M_NFC_RUN_FORCED:
		case M_NFC_RUN:
			pxFeeCP->sMode = sMebToRun;
81112520:	e0bfff17 	ldw	r2,-4(fp)
81112524:	00c00084 	movi	r3,2
81112528:	10c09a15 	stw	r3,616(r2)
			break;
8111252c:	00000806 	br	81112550 <vPerformActionNFCConfig+0xb0>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:

		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
81112530:	d0a06117 	ldw	r2,-32380(gp)
81112534:	100f883a 	mov	r7,r2
81112538:	018009c4 	movi	r6,39
8111253c:	01400044 	movi	r5,1
81112540:	01204574 	movhi	r4,33045
81112544:	21321904 	addi	r4,r4,-14236
81112548:	1120e540 	call	81120e54 <fwrite>
			#endif	
			break;
8111254c:	0001883a 	nop
	}

}
81112550:	0001883a 	nop
81112554:	e037883a 	mov	sp,fp
81112558:	dfc00117 	ldw	ra,4(sp)
8111255c:	df000017 	ldw	fp,0(sp)
81112560:	dec00204 	addi	sp,sp,8
81112564:	f800283a 	ret

81112568 <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
81112568:	defffa04 	addi	sp,sp,-24
8111256c:	de00012e 	bgeu	sp,et,81112574 <vPerformActionNFCRunning+0xc>
81112570:	003b68fa 	trap	3
81112574:	dfc00515 	stw	ra,20(sp)
81112578:	df000415 	stw	fp,16(sp)
8111257c:	df000404 	addi	fp,sp,16
81112580:	e13ffe15 	stw	r4,-8(fp)
81112584:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;
	bool bCheckSimulation;

	uiCmdLocal.ulWord = uiCmdParam;
81112588:	e0bffe17 	ldw	r2,-8(fp)
8111258c:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81112590:	e0bffd83 	ldbu	r2,-10(fp)
81112594:	10803fcc 	andi	r2,r2,255
81112598:	10c02088 	cmpgei	r3,r2,130
8111259c:	1800071e 	bne	r3,zero,811125bc <vPerformActionNFCRunning+0x54>
811125a0:	10c02008 	cmpgei	r3,r2,128
811125a4:	1800331e 	bne	r3,zero,81112674 <vPerformActionNFCRunning+0x10c>
811125a8:	10c00060 	cmpeqi	r3,r2,1
811125ac:	1800051e 	bne	r3,zero,811125c4 <vPerformActionNFCRunning+0x5c>
811125b0:	108000a0 	cmpeqi	r2,r2,2
811125b4:	10001f1e 	bne	r2,zero,81112634 <vPerformActionNFCRunning+0xcc>
811125b8:	00002606 	br	81112654 <vPerformActionNFCRunning+0xec>
811125bc:	10802860 	cmpeqi	r2,r2,161
811125c0:	10002426 	beq	r2,zero,81112654 <vPerformActionNFCRunning+0xec>
		case M_NFC_CONFIG:
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;
811125c4:	e0bfff17 	ldw	r2,-4(fp)
811125c8:	00c00044 	movi	r3,1
811125cc:	10c09a15 	stw	r3,616(r2)

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
811125d0:	e03ffc05 	stb	zero,-16(fp)
811125d4:	00001406 	br	81112628 <vPerformActionNFCRunning+0xc0>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
811125d8:	e0bffc03 	ldbu	r2,-16(fp)
811125dc:	e0ffff17 	ldw	r3,-4(fp)
811125e0:	108025c4 	addi	r2,r2,151
811125e4:	1085883a 	add	r2,r2,r2
811125e8:	1085883a 	add	r2,r2,r2
811125ec:	1885883a 	add	r2,r3,r2
811125f0:	10800017 	ldw	r2,0(r2)
811125f4:	10800017 	ldw	r2,0(r2)
811125f8:	10800058 	cmpnei	r2,r2,1
811125fc:	1000071e 	bne	r2,zero,8111261c <vPerformActionNFCRunning+0xb4>
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
81112600:	e0bffc03 	ldbu	r2,-16(fp)
81112604:	e0fffc03 	ldbu	r3,-16(fp)
81112608:	180f883a 	mov	r7,r3
8111260c:	000d883a 	mov	r6,zero
81112610:	01402844 	movi	r5,161
81112614:	1009883a 	mov	r4,r2
81112618:	11127580 	call	81112758 <bSendCmdQToNFeeInst_Prio>
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
8111261c:	e0bffc03 	ldbu	r2,-16(fp)
81112620:	10800044 	addi	r2,r2,1
81112624:	e0bffc05 	stb	r2,-16(fp)
81112628:	e0bffc03 	ldbu	r2,-16(fp)
8111262c:	103fea26 	beq	r2,zero,811125d8 <__reset+0xfb0f25d8>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
				}
			}

			break;
81112630:	00001106 	br	81112678 <vPerformActionNFCRunning+0x110>
		case M_NFC_RUN:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
81112634:	d0a06117 	ldw	r2,-32380(gp)
81112638:	100f883a 	mov	r7,r2
8111263c:	01800d84 	movi	r6,54
81112640:	01400044 	movi	r5,1
81112644:	01204574 	movhi	r4,33045
81112648:	21322304 	addi	r4,r4,-14196
8111264c:	1120e540 	call	81120e54 <fwrite>
			#endif		
			/* Do nothing for now */

			break;
81112650:	00000906 	br	81112678 <vPerformActionNFCRunning+0x110>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
81112654:	d0a06117 	ldw	r2,-32380(gp)
81112658:	100f883a 	mov	r7,r2
8111265c:	018009c4 	movi	r6,39
81112660:	01400044 	movi	r5,1
81112664:	01204574 	movhi	r4,33045
81112668:	21321904 	addi	r4,r4,-14236
8111266c:	1120e540 	call	81120e54 <fwrite>
			#endif	
			break;
81112670:	00000106 	br	81112678 <vPerformActionNFCRunning+0x110>
			/* Do nothing for now */

			break;
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
81112674:	0001883a 	nop
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			#endif	
			break;
	}
}
81112678:	0001883a 	nop
8111267c:	e037883a 	mov	sp,fp
81112680:	dfc00117 	ldw	ra,4(sp)
81112684:	df000017 	ldw	fp,0(sp)
81112688:	dec00204 	addi	sp,sp,8
8111268c:	f800283a 	ret

81112690 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81112690:	defff704 	addi	sp,sp,-36
81112694:	de00012e 	bgeu	sp,et,8111269c <bSendCmdQToNFeeInst+0xc>
81112698:	003b68fa 	trap	3
8111269c:	dfc00815 	stw	ra,32(sp)
811126a0:	df000715 	stw	fp,28(sp)
811126a4:	df000704 	addi	fp,sp,28
811126a8:	2011883a 	mov	r8,r4
811126ac:	2809883a 	mov	r4,r5
811126b0:	3007883a 	mov	r3,r6
811126b4:	3805883a 	mov	r2,r7
811126b8:	e23ffc05 	stb	r8,-16(fp)
811126bc:	e13ffd05 	stb	r4,-12(fp)
811126c0:	e0fffe05 	stb	r3,-8(fp)
811126c4:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
811126c8:	e0bffc03 	ldbu	r2,-16(fp)
811126cc:	10800444 	addi	r2,r2,17
811126d0:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811126d4:	e0bffd03 	ldbu	r2,-12(fp)
811126d8:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811126dc:	e0bffe03 	ldbu	r2,-8(fp)
811126e0:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811126e4:	e0bfff03 	ldbu	r2,-4(fp)
811126e8:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
811126ec:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
811126f0:	e0bffc03 	ldbu	r2,-16(fp)
811126f4:	1085883a 	add	r2,r2,r2
811126f8:	1087883a 	add	r3,r2,r2
811126fc:	d0a06904 	addi	r2,gp,-32348
81112700:	1885883a 	add	r2,r3,r2
81112704:	10800017 	ldw	r2,0(r2)
81112708:	e0fffb17 	ldw	r3,-20(fp)
8111270c:	180b883a 	mov	r5,r3
81112710:	1009883a 	mov	r4,r2
81112714:	113d1e40 	call	8113d1e4 <OSQPost>
81112718:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
8111271c:	e0bffa03 	ldbu	r2,-24(fp)
81112720:	10000526 	beq	r2,zero,81112738 <bSendCmdQToNFeeInst+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
81112724:	e0bffc03 	ldbu	r2,-16(fp)
81112728:	1009883a 	mov	r4,r2
8111272c:	111c6000 	call	8111c600 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
81112730:	e03ff915 	stw	zero,-28(fp)
81112734:	00000206 	br	81112740 <bSendCmdQToNFeeInst+0xb0>
	} else {
		bSuccesL =  TRUE;
81112738:	00800044 	movi	r2,1
8111273c:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
81112740:	e0bff917 	ldw	r2,-28(fp)
}
81112744:	e037883a 	mov	sp,fp
81112748:	dfc00117 	ldw	ra,4(sp)
8111274c:	df000017 	ldw	fp,0(sp)
81112750:	dec00204 	addi	sp,sp,8
81112754:	f800283a 	ret

81112758 <bSendCmdQToNFeeInst_Prio>:


bool bSendCmdQToNFeeInst_Prio( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81112758:	defff704 	addi	sp,sp,-36
8111275c:	de00012e 	bgeu	sp,et,81112764 <bSendCmdQToNFeeInst_Prio+0xc>
81112760:	003b68fa 	trap	3
81112764:	dfc00815 	stw	ra,32(sp)
81112768:	df000715 	stw	fp,28(sp)
8111276c:	df000704 	addi	fp,sp,28
81112770:	2011883a 	mov	r8,r4
81112774:	2809883a 	mov	r4,r5
81112778:	3007883a 	mov	r3,r6
8111277c:	3805883a 	mov	r2,r7
81112780:	e23ffc05 	stb	r8,-16(fp)
81112784:	e13ffd05 	stb	r4,-12(fp)
81112788:	e0fffe05 	stb	r3,-8(fp)
8111278c:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
81112790:	e0bffc03 	ldbu	r2,-16(fp)
81112794:	10800444 	addi	r2,r2,17
81112798:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8111279c:	e0bffd03 	ldbu	r2,-12(fp)
811127a0:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811127a4:	e0bffe03 	ldbu	r2,-8(fp)
811127a8:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811127ac:	e0bfff03 	ldbu	r2,-4(fp)
811127b0:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
811127b4:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPostFront(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
811127b8:	e0bffc03 	ldbu	r2,-16(fp)
811127bc:	1085883a 	add	r2,r2,r2
811127c0:	1087883a 	add	r3,r2,r2
811127c4:	d0a06904 	addi	r2,gp,-32348
811127c8:	1885883a 	add	r2,r3,r2
811127cc:	10800017 	ldw	r2,0(r2)
811127d0:	e0fffb17 	ldw	r3,-20(fp)
811127d4:	180b883a 	mov	r5,r3
811127d8:	1009883a 	mov	r4,r2
811127dc:	113d3540 	call	8113d354 <OSQPostFront>
811127e0:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
811127e4:	e0bffa03 	ldbu	r2,-24(fp)
811127e8:	10000526 	beq	r2,zero,81112800 <bSendCmdQToNFeeInst_Prio+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
811127ec:	e0bffc03 	ldbu	r2,-16(fp)
811127f0:	1009883a 	mov	r4,r2
811127f4:	111c6000 	call	8111c600 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
811127f8:	e03ff915 	stw	zero,-28(fp)
811127fc:	00000206 	br	81112808 <bSendCmdQToNFeeInst_Prio+0xb0>
	} else {
		bSuccesL =  TRUE;
81112800:	00800044 	movi	r2,1
81112804:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
81112808:	e0bff917 	ldw	r2,-28(fp)
}
8111280c:	e037883a 	mov	sp,fp
81112810:	dfc00117 	ldw	ra,4(sp)
81112814:	df000017 	ldw	fp,0(sp)
81112818:	dec00204 	addi	sp,sp,8
8111281c:	f800283a 	ret

81112820 <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
81112820:	defff704 	addi	sp,sp,-36
81112824:	de00012e 	bgeu	sp,et,8111282c <vOutAckHandlerTask+0xc>
81112828:	003b68fa 	trap	3
8111282c:	dfc00815 	stw	ra,32(sp)
81112830:	df000715 	stw	fp,28(sp)
81112834:	df000704 	addi	fp,sp,28
81112838:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
8111283c:	e03ffac5 	stb	zero,-21(fp)
81112840:	e03ffb05 	stb	zero,-20(fp)
81112844:	e03ffb45 	stb	zero,-19(fp)
81112848:	e03ffb85 	stb	zero,-18(fp)
8111284c:	e03ffbc5 	stb	zero,-17(fp)
81112850:	e03ffc05 	stb	zero,-16(fp)
81112854:	e03ffc45 	stb	zero,-15(fp)
81112858:	e03ffc85 	stb	zero,-14(fp)
8111285c:	e03ffcc5 	stb	zero,-13(fp)
81112860:	e03ffd05 	stb	zero,-12(fp)
81112864:	e03ffd45 	stb	zero,-11(fp)
81112868:	e03ffd85 	stb	zero,-10(fp)
8111286c:	e03ffdc5 	stb	zero,-9(fp)
81112870:	e03ffe05 	stb	zero,-8(fp)
81112874:	e03ffe45 	stb	zero,-7(fp)
81112878:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
8111287c:	e03ffa45 	stb	zero,-23(fp)

	#ifdef DEBUG_ON
		debug(fp,"Out Ack Handler Task. (Task on)\n");
81112880:	d0a06117 	ldw	r2,-32380(gp)
81112884:	100f883a 	mov	r7,r2
81112888:	01800804 	movi	r6,32
8111288c:	01400044 	movi	r5,1
81112890:	01204574 	movhi	r4,33045
81112894:	21323104 	addi	r4,r4,-14140
81112898:	1120e540 	call	81120e54 <fwrite>
	#endif

	eSenderAckState = sSAConfiguring;
8111289c:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
811128a0:	e0bff917 	ldw	r2,-28(fp)
811128a4:	10c00060 	cmpeqi	r3,r2,1
811128a8:	1800071e 	bne	r3,zero,811128c8 <vOutAckHandlerTask+0xa8>
811128ac:	0080032e 	bgeu	zero,r2,811128bc <vOutAckHandlerTask+0x9c>
811128b0:	108000a0 	cmpeqi	r2,r2,2
811128b4:	1000471e 	bne	r2,zero,811129d4 <vOutAckHandlerTask+0x1b4>
811128b8:	00008c06 	br	81112aec <vOutAckHandlerTask+0x2cc>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
811128bc:	00800044 	movi	r2,1
811128c0:	e0bff915 	stw	r2,-28(fp)
				break;
811128c4:	00009306 	br	81112b14 <vOutAckHandlerTask+0x2f4>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
811128c8:	00800044 	movi	r2,1
811128cc:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
811128d0:	d0a06017 	ldw	r2,-32384(gp)
811128d4:	e0fffa84 	addi	r3,fp,-22
811128d8:	180d883a 	mov	r6,r3
811128dc:	000b883a 	mov	r5,zero
811128e0:	1009883a 	mov	r4,r2
811128e4:	113dcd40 	call	8113dcd4 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
811128e8:	e0bffa83 	ldbu	r2,-22(fp)
811128ec:	10803fcc 	andi	r2,r2,255
811128f0:	1000361e 	bne	r2,zero,811129cc <vOutAckHandlerTask+0x1ac>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
811128f4:	d0a07117 	ldw	r2,-32316(gp)
811128f8:	e0fffa84 	addi	r3,fp,-22
811128fc:	180d883a 	mov	r6,r3
81112900:	000b883a 	mov	r5,zero
81112904:	1009883a 	mov	r4,r2
81112908:	113bcc80 	call	8113bcc8 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8111290c:	e0bffa83 	ldbu	r2,-22(fp)
81112910:	10803fcc 	andi	r2,r2,255
81112914:	10002b1e 	bne	r2,zero,811129c4 <vOutAckHandlerTask+0x1a4>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
81112918:	e03ffa05 	stb	zero,-24(fp)
8111291c:	00002206 	br	811129a8 <vOutAckHandlerTask+0x188>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
81112920:	e0fffa03 	ldbu	r3,-24(fp)
81112924:	00a045b4 	movhi	r2,33046
81112928:	1096a904 	addi	r2,r2,23204
8111292c:	18c7883a 	add	r3,r3,r3
81112930:	18c7883a 	add	r3,r3,r3
81112934:	10c5883a 	add	r2,r2,r3
81112938:	10800003 	ldbu	r2,0(r2)
8111293c:	10803fcc 	andi	r2,r2,255
81112940:	1080201c 	xori	r2,r2,128
81112944:	10bfe004 	addi	r2,r2,-128
81112948:	10001426 	beq	r2,zero,8111299c <vOutAckHandlerTask+0x17c>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
8111294c:	e0fffa03 	ldbu	r3,-24(fp)
81112950:	00a045b4 	movhi	r2,33046
81112954:	1096a904 	addi	r2,r2,23204
81112958:	18c7883a 	add	r3,r3,r3
8111295c:	18c7883a 	add	r3,r3,r3
81112960:	10c5883a 	add	r2,r2,r3
81112964:	10c0000b 	ldhu	r3,0(r2)
81112968:	d0e0588d 	sth	r3,-32414(gp)
8111296c:	1080008b 	ldhu	r2,2(r2)
81112970:	d0a0590d 	sth	r2,-32412(gp)
                                eSenderAckState = sSASending;
81112974:	00800084 	movi	r2,2
81112978:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
8111297c:	e0fffa03 	ldbu	r3,-24(fp)
81112980:	00a045b4 	movhi	r2,33046
81112984:	1096a904 	addi	r2,r2,23204
81112988:	18c7883a 	add	r3,r3,r3
8111298c:	18c7883a 	add	r3,r3,r3
81112990:	10c5883a 	add	r2,r2,r3
81112994:	10000005 	stb	zero,0(r2)
                                break;
81112998:	00000606 	br	811129b4 <vOutAckHandlerTask+0x194>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8111299c:	e0bffa03 	ldbu	r2,-24(fp)
811129a0:	10800044 	addi	r2,r2,1
811129a4:	e0bffa05 	stb	r2,-24(fp)
811129a8:	e0bffa03 	ldbu	r2,-24(fp)
811129ac:	10800230 	cmpltui	r2,r2,8
811129b0:	103fdb1e 	bne	r2,zero,81112920 <__reset+0xfb0f2920>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
811129b4:	d0a07117 	ldw	r2,-32316(gp)
811129b8:	1009883a 	mov	r4,r2
811129bc:	113c26c0 	call	8113c26c <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
811129c0:	00005406 	br	81112b14 <vOutAckHandlerTask+0x2f4>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
811129c4:	111ae140 	call	8111ae14 <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
811129c8:	00005206 	br	81112b14 <vOutAckHandlerTask+0x2f4>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
811129cc:	111adac0 	call	8111adac <vFailGetCountSemaphoreSenderTask>
                }

                break;
811129d0:	00005006 	br	81112b14 <vOutAckHandlerTask+0x2f4>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
811129d4:	d0a05883 	ldbu	r2,-32414(gp)
811129d8:	10803fcc 	andi	r2,r2,255
811129dc:	1080201c 	xori	r2,r2,128
811129e0:	10bfe004 	addi	r2,r2,-128
811129e4:	108008e0 	cmpeqi	r2,r2,35
811129e8:	1000201e 	bne	r2,zero,81112a6c <vOutAckHandlerTask+0x24c>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
811129ec:	d0a058c3 	ldbu	r2,-32413(gp)
811129f0:	10c03fcc 	andi	r3,r2,255
811129f4:	18c0201c 	xori	r3,r3,128
811129f8:	18ffe004 	addi	r3,r3,-128
811129fc:	d0a0590b 	ldhu	r2,-32412(gp)
81112a00:	113fffcc 	andi	r4,r2,65535
81112a04:	e0bffac4 	addi	r2,fp,-21
81112a08:	200f883a 	mov	r7,r4
81112a0c:	180d883a 	mov	r6,r3
81112a10:	01604574 	movhi	r5,33045
81112a14:	29723a04 	addi	r5,r5,-14104
81112a18:	1009883a 	mov	r4,r2
81112a1c:	11221480 	call	81122148 <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
81112a20:	e0bffac4 	addi	r2,fp,-21
81112a24:	1009883a 	mov	r4,r2
81112a28:	112235c0 	call	8112235c <strlen>
81112a2c:	1007883a 	mov	r3,r2
81112a30:	e0bffac4 	addi	r2,fp,-21
81112a34:	180b883a 	mov	r5,r3
81112a38:	1009883a 	mov	r4,r2
81112a3c:	111a9700 	call	8111a970 <ucCrc8wInit>
81112a40:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
81112a44:	e13ffa43 	ldbu	r4,-23(fp)
81112a48:	e0fffac4 	addi	r3,fp,-21
81112a4c:	e0bffac4 	addi	r2,fp,-21
81112a50:	200f883a 	mov	r7,r4
81112a54:	180d883a 	mov	r6,r3
81112a58:	01604574 	movhi	r5,33045
81112a5c:	29723c04 	addi	r5,r5,-14096
81112a60:	1009883a 	mov	r4,r2
81112a64:	11221480 	call	81122148 <sprintf>
81112a68:	00000c06 	br	81112a9c <vOutAckHandlerTask+0x27c>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
81112a6c:	e0bffac4 	addi	r2,fp,-21
81112a70:	00c008c4 	movi	r3,35
81112a74:	10c00005 	stb	r3,0(r2)
81112a78:	00c01f04 	movi	r3,124
81112a7c:	10c00045 	stb	r3,1(r2)
81112a80:	00c00d44 	movi	r3,53
81112a84:	10c00085 	stb	r3,2(r2)
81112a88:	00c00d04 	movi	r3,52
81112a8c:	10c000c5 	stb	r3,3(r2)
81112a90:	00c00ec4 	movi	r3,59
81112a94:	10c00105 	stb	r3,4(r2)
81112a98:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
81112a9c:	d0a07317 	ldw	r2,-32308(gp)
81112aa0:	e0fffa84 	addi	r3,fp,-22
81112aa4:	180d883a 	mov	r6,r3
81112aa8:	01401904 	movi	r5,100
81112aac:	1009883a 	mov	r4,r2
81112ab0:	113bcc80 	call	8113bcc8 <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
81112ab4:	e0bffa83 	ldbu	r2,-22(fp)
81112ab8:	10803fcc 	andi	r2,r2,255
81112abc:	1000071e 	bne	r2,zero,81112adc <vOutAckHandlerTask+0x2bc>
                    puts(cBufferAck);
81112ac0:	e0bffac4 	addi	r2,fp,-21
81112ac4:	1009883a 	mov	r4,r2
81112ac8:	1121e040 	call	81121e04 <puts>
                    OSMutexPost(xTxUARTMutex);
81112acc:	d0a07317 	ldw	r2,-32308(gp)
81112ad0:	1009883a 	mov	r4,r2
81112ad4:	113c26c0 	call	8113c26c <OSMutexPost>
81112ad8:	00000106 	br	81112ae0 <vOutAckHandlerTask+0x2c0>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
81112adc:	111af4c0 	call	8111af4c <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
81112ae0:	00800044 	movi	r2,1
81112ae4:	e0bff915 	stw	r2,-28(fp)
                
				break;
81112ae8:	00000a06 	br	81112b14 <vOutAckHandlerTask+0x2f4>
			default:
            	#ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
81112aec:	d0a06117 	ldw	r2,-32380(gp)
81112af0:	100f883a 	mov	r7,r2
81112af4:	01801104 	movi	r6,68
81112af8:	01400044 	movi	r5,1
81112afc:	01204574 	movhi	r4,33045
81112b00:	21323f04 	addi	r4,r4,-14084
81112b04:	1120e540 	call	81120e54 <fwrite>
	            #endif
                eSenderAckState = sSAGettingACK;
81112b08:	00800044 	movi	r2,1
81112b0c:	e0bff915 	stw	r2,-28(fp)
				break;
81112b10:	0001883a 	nop
		}
	}
81112b14:	003f6206 	br	811128a0 <__reset+0xfb0f28a0>

81112b18 <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
81112b18:	deffd704 	addi	sp,sp,-164
81112b1c:	de00012e 	bgeu	sp,et,81112b24 <vParserCommTask+0xc>
81112b20:	003b68fa 	trap	3
81112b24:	dfc02815 	stw	ra,160(sp)
81112b28:	df002715 	stw	fp,156(sp)
81112b2c:	df002704 	addi	fp,sp,156
81112b30:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
81112b34:	e03fdd15 	stw	zero,-140(fp)
	#ifdef DEBUG_ON
		char cPUSDebug[128];
	#endif

    #ifdef DEBUG_ON
        debug(fp,"Parser Comm Task. (Task on)\n");
81112b38:	d0a06117 	ldw	r2,-32380(gp)
81112b3c:	100f883a 	mov	r7,r2
81112b40:	01800704 	movi	r6,28
81112b44:	01400044 	movi	r5,1
81112b48:	01204574 	movhi	r4,33045
81112b4c:	21325104 	addi	r4,r4,-14012
81112b50:	1120e540 	call	81120e54 <fwrite>
    #endif

	eParserMode = sConfiguring;
81112b54:	e03fdc15 	stw	zero,-144(fp)

	for(;;){

		switch (eParserMode) {
81112b58:	e0bfdc17 	ldw	r2,-144(fp)
81112b5c:	10800168 	cmpgeui	r2,r2,5
81112b60:	1003651e 	bne	r2,zero,811138f8 <vParserCommTask+0xde0>
81112b64:	e0bfdc17 	ldw	r2,-144(fp)
81112b68:	100690ba 	slli	r3,r2,2
81112b6c:	00a04474 	movhi	r2,33041
81112b70:	108ae004 	addi	r2,r2,11136
81112b74:	1885883a 	add	r2,r3,r2
81112b78:	10800017 	ldw	r2,0(r2)
81112b7c:	1000683a 	jmp	r2
81112b80:	81112b94 	ori	r4,r16,17582
81112b84:	81112ba0 	cmpeqi	r4,r16,17582
81112b88:	81112c34 	orhi	r4,r16,17584
81112b8c:	81112d98 	cmpnei	r4,r16,17590
81112b90:	81112ddc 	xori	r4,r16,17591
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
81112b94:	00800044 	movi	r2,1
81112b98:	e0bfdc15 	stw	r2,-144(fp)
				break;
81112b9c:	00035906 	br	81113904 <vParserCommTask+0xdec>
			case sWaitingMessage:

				bSuccess = FALSE;
81112ba0:	e03fdd15 	stw	zero,-140(fp)
				eParserMode = sWaitingMessage;
81112ba4:	00800044 	movi	r2,1
81112ba8:	e0bfdc15 	stw	r2,-144(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
81112bac:	d0a06317 	ldw	r2,-32372(gp)
81112bb0:	e0ffde84 	addi	r3,fp,-134
81112bb4:	180d883a 	mov	r6,r3
81112bb8:	000b883a 	mov	r5,zero
81112bbc:	1009883a 	mov	r4,r2
81112bc0:	113dcd40 	call	8113dcd4 <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
81112bc4:	e0bfde83 	ldbu	r2,-134(fp)
81112bc8:	10803fcc 	andi	r2,r2,255
81112bcc:	1000171e 	bne	r2,zero,81112c2c <vParserCommTask+0x114>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
81112bd0:	01204574 	movhi	r4,33045
81112bd4:	21091b04 	addi	r4,r4,9324
81112bd8:	11139080 	call	81113908 <getPreParsedPacket>
81112bdc:	e0bfdd15 	stw	r2,-140(fp)
					if (bSuccess == TRUE) {
81112be0:	e0bfdd17 	ldw	r2,-140(fp)
81112be4:	10800058 	cmpnei	r2,r2,1
81112be8:	10000e1e 	bne	r2,zero,81112c24 <vParserCommTask+0x10c>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
81112bec:	00a04574 	movhi	r2,33045
81112bf0:	10891b04 	addi	r2,r2,9324
81112bf4:	10800103 	ldbu	r2,4(r2)
81112bf8:	10803fcc 	andi	r2,r2,255
81112bfc:	1080201c 	xori	r2,r2,128
81112c00:	10bfe004 	addi	r2,r2,-128
81112c04:	10800858 	cmpnei	r2,r2,33
81112c08:	1000031e 	bne	r2,zero,81112c18 <vParserCommTask+0x100>
							eParserMode = sReplyParsing;
81112c0c:	008000c4 	movi	r2,3
81112c10:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81112c14:	00033b06 	br	81113904 <vParserCommTask+0xdec>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
81112c18:	00800084 	movi	r2,2
81112c1c:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81112c20:	00033806 	br	81113904 <vParserCommTask+0xdec>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
81112c24:	111b4d80 	call	8111b4d8 <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81112c28:	00033606 	br	81113904 <vParserCommTask+0xdec>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
81112c2c:	111b4080 	call	8111b408 <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
81112c30:	00033406 	br	81113904 <vParserCommTask+0xdec>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
81112c34:	00a04574 	movhi	r2,33045
81112c38:	10891b04 	addi	r2,r2,9324
81112c3c:	10800143 	ldbu	r2,5(r2)
81112c40:	10803fcc 	andi	r2,r2,255
81112c44:	1080201c 	xori	r2,r2,128
81112c48:	10bfe004 	addi	r2,r2,-128
81112c4c:	10c010e0 	cmpeqi	r3,r2,67
81112c50:	1800031e 	bne	r3,zero,81112c60 <vParserCommTask+0x148>
81112c54:	10801420 	cmpeqi	r2,r2,80
81112c58:	1000051e 	bne	r2,zero,81112c70 <vParserCommTask+0x158>
81112c5c:	00004a06 	br	81112d88 <vParserCommTask+0x270>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
81112c60:	11183f80 	call	811183f8 <vSendEthConf>
						eParserMode = sWaitingMessage;
81112c64:	00800044 	movi	r2,1
81112c68:	e0bfdc15 	stw	r2,-144(fp)
						break;
81112c6c:	00004906 	br	81112d94 <vParserCommTask+0x27c>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#ifdef DEBUG_ON
							memset(cPUSDebug,0,128);
81112c70:	e0bfdec4 	addi	r2,fp,-133
81112c74:	01802004 	movi	r6,128
81112c78:	000b883a 	mov	r5,zero
81112c7c:	1009883a 	mov	r4,r2
81112c80:	11219b80 	call	811219b8 <memset>
							sprintf(cPUSDebug, "\nParser Task: TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
81112c84:	00a04574 	movhi	r2,33045
81112c88:	10891b04 	addi	r2,r2,9324
81112c8c:	1080028b 	ldhu	r2,10(r2)
81112c90:	117fffcc 	andi	r5,r2,65535
81112c94:	00a04574 	movhi	r2,33045
81112c98:	10891b04 	addi	r2,r2,9324
81112c9c:	1080030b 	ldhu	r2,12(r2)
81112ca0:	11bfffcc 	andi	r6,r2,65535
81112ca4:	00a04574 	movhi	r2,33045
81112ca8:	10891b04 	addi	r2,r2,9324
81112cac:	1080038b 	ldhu	r2,14(r2)
81112cb0:	10ffffcc 	andi	r3,r2,65535
81112cb4:	00a04574 	movhi	r2,33045
81112cb8:	10891b04 	addi	r2,r2,9324
81112cbc:	1080040b 	ldhu	r2,16(r2)
81112cc0:	113fffcc 	andi	r4,r2,65535
81112cc4:	00a04574 	movhi	r2,33045
81112cc8:	10891b04 	addi	r2,r2,9324
81112ccc:	1080048b 	ldhu	r2,18(r2)
81112cd0:	10bfffcc 	andi	r2,r2,65535
81112cd4:	e23fdec4 	addi	r8,fp,-133
81112cd8:	d8800215 	stw	r2,8(sp)
81112cdc:	d9000115 	stw	r4,4(sp)
81112ce0:	d8c00015 	stw	r3,0(sp)
81112ce4:	300f883a 	mov	r7,r6
81112ce8:	280d883a 	mov	r6,r5
81112cec:	01604574 	movhi	r5,33045
81112cf0:	29725904 	addi	r5,r5,-13980
81112cf4:	4009883a 	mov	r4,r8
81112cf8:	11221480 	call	81122148 <sprintf>
							debug(fp, cPUSDebug );
81112cfc:	d0a06117 	ldw	r2,-32380(gp)
81112d00:	e0ffdec4 	addi	r3,fp,-133
81112d04:	180b883a 	mov	r5,r3
81112d08:	1009883a 	mov	r4,r2
81112d0c:	11207b80 	call	811207b8 <fprintf>
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
81112d10:	00a04574 	movhi	r2,33045
81112d14:	10891b04 	addi	r2,r2,9324
81112d18:	10c0030b 	ldhu	r3,12(r2)
81112d1c:	00a04574 	movhi	r2,33045
81112d20:	10892e04 	addi	r2,r2,9400
81112d24:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
81112d28:	00a04574 	movhi	r2,33045
81112d2c:	10891b04 	addi	r2,r2,9324
81112d30:	10c0038b 	ldhu	r3,14(r2)
81112d34:	00a04574 	movhi	r2,33045
81112d38:	10892e04 	addi	r2,r2,9400
81112d3c:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
81112d40:	00a04574 	movhi	r2,33045
81112d44:	10891b04 	addi	r2,r2,9324
81112d48:	10c0040b 	ldhu	r3,16(r2)
81112d4c:	00a04574 	movhi	r2,33045
81112d50:	10892e04 	addi	r2,r2,9400
81112d54:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
81112d58:	00a04574 	movhi	r2,33045
81112d5c:	10891b04 	addi	r2,r2,9324
81112d60:	10c0048b 	ldhu	r3,18(r2)
81112d64:	00a04574 	movhi	r2,33045
81112d68:	10892e04 	addi	r2,r2,9400
81112d6c:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
81112d70:	00a04574 	movhi	r2,33045
81112d74:	10892e04 	addi	r2,r2,9400
81112d78:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
81112d7c:	00800104 	movi	r2,4
81112d80:	e0bfdc15 	stw	r2,-144(fp)
                        break;						
81112d84:	00000306 	br	81112d94 <vParserCommTask+0x27c>
					default:
						eParserMode = sWaitingMessage;
81112d88:	00800044 	movi	r2,1
81112d8c:	e0bfdc15 	stw	r2,-144(fp)
						break;
81112d90:	0001883a 	nop
				}
				break;
81112d94:	0002db06 	br	81113904 <vParserCommTask+0xdec>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
81112d98:	00800044 	movi	r2,1
81112d9c:	e0bfdc15 	stw	r2,-144(fp)
                switch ( xTcPusL.usiType )
81112da0:	00a04574 	movhi	r2,33045
81112da4:	10892e04 	addi	r2,r2,9400
81112da8:	1080030b 	ldhu	r2,12(r2)
81112dac:	10bfffcc 	andi	r2,r2,65535
81112db0:	10c01220 	cmpeqi	r3,r2,72
81112db4:	1800051e 	bne	r3,zero,81112dcc <vParserCommTask+0x2b4>
81112db8:	108014e0 	cmpeqi	r2,r2,83
81112dbc:	1000051e 	bne	r2,zero,81112dd4 <vParserCommTask+0x2bc>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
81112dc0:	00800044 	movi	r2,1
81112dc4:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81112dc8:	00000306 	br	81112dd8 <vParserCommTask+0x2c0>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
81112dcc:	0001883a 	nop
81112dd0:	0002cc06 	br	81113904 <vParserCommTask+0xdec>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
81112dd4:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
81112dd8:	0002ca06 	br	81113904 <vParserCommTask+0xdec>
			case sPusHandling:
				eParserMode = sWaitingMessage;
81112ddc:	00800044 	movi	r2,1
81112de0:	e0bfdc15 	stw	r2,-144(fp)
				
                switch ( xTcPusL.usiType )
81112de4:	00a04574 	movhi	r2,33045
81112de8:	10892e04 	addi	r2,r2,9400
81112dec:	1080030b 	ldhu	r2,12(r2)
81112df0:	10bfffcc 	andi	r2,r2,65535
81112df4:	10c03ea0 	cmpeqi	r3,r2,250
81112df8:	1800401e 	bne	r3,zero,81112efc <vParserCommTask+0x3e4>
81112dfc:	10c03ec8 	cmpgei	r3,r2,251
81112e00:	1800031e 	bne	r3,zero,81112e10 <vParserCommTask+0x2f8>
81112e04:	10800460 	cmpeqi	r2,r2,17
81112e08:	1000061e 	bne	r2,zero,81112e24 <vParserCommTask+0x30c>
81112e0c:	0002b606 	br	811138e8 <vParserCommTask+0xdd0>
81112e10:	10c03ee0 	cmpeqi	r3,r2,251
81112e14:	18009d1e 	bne	r3,zero,8111308c <vParserCommTask+0x574>
81112e18:	10803f20 	cmpeqi	r2,r2,252
81112e1c:	1001321e 	bne	r2,zero,811132e8 <vParserCommTask+0x7d0>
81112e20:	0002b106 	br	811138e8 <vParserCommTask+0xdd0>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
81112e24:	00a04574 	movhi	r2,33045
81112e28:	10892e04 	addi	r2,r2,9400
81112e2c:	1080038b 	ldhu	r2,14(r2)
81112e30:	10bfffcc 	andi	r2,r2,65535
81112e34:	10800060 	cmpeqi	r2,r2,1
81112e38:	10000e26 	beq	r2,zero,81112e74 <vParserCommTask+0x35c>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TEST_CONNECTION\n");
81112e3c:	d0a06117 	ldw	r2,-32380(gp)
81112e40:	100f883a 	mov	r7,r2
81112e44:	01800944 	movi	r6,37
81112e48:	01400044 	movi	r5,1
81112e4c:	01204574 	movhi	r4,33045
81112e50:	21326f04 	addi	r4,r4,-13892
81112e54:	1120e540 	call	81120e54 <fwrite>
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
81112e58:	00a04574 	movhi	r2,33045
81112e5c:	10892e04 	addi	r2,r2,9400
81112e60:	1080040b 	ldhu	r2,16(r2)
81112e64:	10bfffcc 	andi	r2,r2,65535
81112e68:	1009883a 	mov	r4,r2
81112e6c:	1118df80 	call	81118df8 <vTMPusTestConnection>

								break;
81112e70:	00002106 	br	81112ef8 <vParserCommTask+0x3e0>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81112e74:	e0bfdec4 	addi	r2,fp,-133
81112e78:	01802004 	movi	r6,128
81112e7c:	000b883a 	mov	r5,zero
81112e80:	1009883a 	mov	r4,r2
81112e84:	11219b80 	call	811219b8 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81112e88:	00a04574 	movhi	r2,33045
81112e8c:	10892e04 	addi	r2,r2,9400
81112e90:	1080030b 	ldhu	r2,12(r2)
81112e94:	113fffcc 	andi	r4,r2,65535
81112e98:	00a04574 	movhi	r2,33045
81112e9c:	10892e04 	addi	r2,r2,9400
81112ea0:	1080038b 	ldhu	r2,14(r2)
81112ea4:	117fffcc 	andi	r5,r2,65535
81112ea8:	00a04574 	movhi	r2,33045
81112eac:	10892e04 	addi	r2,r2,9400
81112eb0:	1080040b 	ldhu	r2,16(r2)
81112eb4:	10bfffcc 	andi	r2,r2,65535
81112eb8:	e0ffdec4 	addi	r3,fp,-133
81112ebc:	d8800015 	stw	r2,0(sp)
81112ec0:	280f883a 	mov	r7,r5
81112ec4:	200d883a 	mov	r6,r4
81112ec8:	01604574 	movhi	r5,33045
81112ecc:	29727904 	addi	r5,r5,-13852
81112ed0:	1809883a 	mov	r4,r3
81112ed4:	11221480 	call	81122148 <sprintf>
									debug(fp, cPUSDebug );
81112ed8:	d0a06117 	ldw	r2,-32380(gp)
81112edc:	e0ffdec4 	addi	r3,fp,-133
81112ee0:	180b883a 	mov	r5,r3
81112ee4:	1009883a 	mov	r4,r2
81112ee8:	11207b80 	call	811207b8 <fprintf>
								#endif
								eParserMode = sWaitingMessage;
81112eec:	00800044 	movi	r2,1
81112ef0:	e0bfdc15 	stw	r2,-144(fp)
								break;
81112ef4:	0001883a 	nop
						}
                        break;
81112ef8:	00027e06 	br	811138f4 <vParserCommTask+0xddc>


                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
81112efc:	00a04574 	movhi	r2,33045
81112f00:	10892e04 	addi	r2,r2,9400
81112f04:	1080038b 	ldhu	r2,14(r2)
81112f08:	10bfffcc 	andi	r2,r2,65535
81112f0c:	10c00f20 	cmpeqi	r3,r2,60
81112f10:	18001a1e 	bne	r3,zero,81112f7c <vParserCommTask+0x464>
81112f14:	10c00f48 	cmpgei	r3,r2,61
81112f18:	1800031e 	bne	r3,zero,81112f28 <vParserCommTask+0x410>
81112f1c:	10800ee0 	cmpeqi	r2,r2,59
81112f20:	1000061e 	bne	r2,zero,81112f3c <vParserCommTask+0x424>
81112f24:	00003706 	br	81113004 <vParserCommTask+0x4ec>
81112f28:	10c00f60 	cmpeqi	r3,r2,61
81112f2c:	18001e1e 	bne	r3,zero,81112fa8 <vParserCommTask+0x490>
81112f30:	10800fa0 	cmpeqi	r2,r2,62
81112f34:	1000271e 	bne	r2,zero,81112fd4 <vParserCommTask+0x4bc>
81112f38:	00003206 	br	81113004 <vParserCommTask+0x4ec>
						{
							case 59: /* TC_SCAM_RESET */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RESET\n");
81112f3c:	d0a06117 	ldw	r2,-32380(gp)
81112f40:	100f883a 	mov	r7,r2
81112f44:	018006c4 	movi	r6,27
81112f48:	01400044 	movi	r5,1
81112f4c:	01204574 	movhi	r4,33045
81112f50:	21328c04 	addi	r4,r4,-13776
81112f54:	1120e540 	call	81120e54 <fwrite>
								#endif
								vSendReset();
81112f58:	11187a00 	call	811187a0 <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,3,0);
81112f5c:	000f883a 	mov	r7,zero
81112f60:	018000c4 	movi	r6,3
81112f64:	000b883a 	mov	r5,zero
81112f68:	0009883a 	mov	r4,zero
81112f6c:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>
								vRstcSimucamReset( 5000 );
81112f70:	0104e204 	movi	r4,5000
81112f74:	110c32c0 	call	8110c32c <vRstcSimucamReset>

								break;
81112f78:	00004306 	br	81113088 <vParserCommTask+0x570>
							case 60: /* TC_SCAM_CONFIG */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_CONFIG\n");
81112f7c:	d0a06117 	ldw	r2,-32380(gp)
81112f80:	100f883a 	mov	r7,r2
81112f84:	01800704 	movi	r6,28
81112f88:	01400044 	movi	r5,1
81112f8c:	01204574 	movhi	r4,33045
81112f90:	21329304 	addi	r4,r4,-13748
81112f94:	1120e540 	call	81120e54 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81112f98:	01204574 	movhi	r4,33045
81112f9c:	21092e04 	addi	r4,r4,9400
81112fa0:	1113a200 	call	81113a20 <bSendMessagePUStoMebTask>

								break;
81112fa4:	00003806 	br	81113088 <vParserCommTask+0x570>
							case 61: /* TC_SCAM_RUN */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RUN\n");
81112fa8:	d0a06117 	ldw	r2,-32380(gp)
81112fac:	100f883a 	mov	r7,r2
81112fb0:	01800644 	movi	r6,25
81112fb4:	01400044 	movi	r5,1
81112fb8:	01204574 	movhi	r4,33045
81112fbc:	21329b04 	addi	r4,r4,-13716
81112fc0:	1120e540 	call	81120e54 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81112fc4:	01204574 	movhi	r4,33045
81112fc8:	21092e04 	addi	r4,r4,9400
81112fcc:	1113a200 	call	81113a20 <bSendMessagePUStoMebTask>

								break;
81112fd0:	00002d06 	br	81113088 <vParserCommTask+0x570>
							case 62: /* TC_SCAM_TURNOFF */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TURNOFF\n");
81112fd4:	d0a06117 	ldw	r2,-32380(gp)
81112fd8:	100f883a 	mov	r7,r2
81112fdc:	01800744 	movi	r6,29
81112fe0:	01400044 	movi	r5,1
81112fe4:	01204574 	movhi	r4,33045
81112fe8:	2132a204 	addi	r4,r4,-13688
81112fec:	1120e540 	call	81120e54 <fwrite>
								#endif
								vSendTurnOff();
81112ff0:	11186880 	call	81118688 <vSendTurnOff>

								/* Send to Meb the shutdown command */
								bSendMessagePUStoMebTask(&xTcPusL);
81112ff4:	01204574 	movhi	r4,33045
81112ff8:	21092e04 	addi	r4,r4,9400
81112ffc:	1113a200 	call	81113a20 <bSendMessagePUStoMebTask>

								break;
81113000:	00002106 	br	81113088 <vParserCommTask+0x570>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113004:	e0bfdec4 	addi	r2,fp,-133
81113008:	01802004 	movi	r6,128
8111300c:	000b883a 	mov	r5,zero
81113010:	1009883a 	mov	r4,r2
81113014:	11219b80 	call	811219b8 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81113018:	00a04574 	movhi	r2,33045
8111301c:	10892e04 	addi	r2,r2,9400
81113020:	1080030b 	ldhu	r2,12(r2)
81113024:	113fffcc 	andi	r4,r2,65535
81113028:	00a04574 	movhi	r2,33045
8111302c:	10892e04 	addi	r2,r2,9400
81113030:	1080038b 	ldhu	r2,14(r2)
81113034:	117fffcc 	andi	r5,r2,65535
81113038:	00a04574 	movhi	r2,33045
8111303c:	10892e04 	addi	r2,r2,9400
81113040:	1080040b 	ldhu	r2,16(r2)
81113044:	10bfffcc 	andi	r2,r2,65535
81113048:	e0ffdec4 	addi	r3,fp,-133
8111304c:	d8800015 	stw	r2,0(sp)
81113050:	280f883a 	mov	r7,r5
81113054:	200d883a 	mov	r6,r4
81113058:	01604574 	movhi	r5,33045
8111305c:	29727904 	addi	r5,r5,-13852
81113060:	1809883a 	mov	r4,r3
81113064:	11221480 	call	81122148 <sprintf>
									debug(fp, cPUSDebug );
81113068:	d0a06117 	ldw	r2,-32380(gp)
8111306c:	e0ffdec4 	addi	r3,fp,-133
81113070:	180b883a 	mov	r5,r3
81113074:	1009883a 	mov	r4,r2
81113078:	11207b80 	call	811207b8 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
8111307c:	00800044 	movi	r2,1
81113080:	e0bfdc15 	stw	r2,-144(fp)
								break;
81113084:	0001883a 	nop
						}
                        break;
81113088:	00021a06 	br	811138f4 <vParserCommTask+0xddc>


                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
8111308c:	00a04574 	movhi	r2,33045
81113090:	10891b04 	addi	r2,r2,9324
81113094:	1080050b 	ldhu	r2,20(r2)
81113098:	e0bfde0d 	sth	r2,-136(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
8111309c:	e0bfde0b 	ldhu	r2,-136(fp)
811130a0:	108000b0 	cmpltui	r2,r2,2
811130a4:	1000121e 	bne	r2,zero,811130f0 <vParserCommTask+0x5d8>
							#ifdef DEBUG_ON
								memset(cPUSDebug,0,128);
811130a8:	e0bfdec4 	addi	r2,fp,-133
811130ac:	01802004 	movi	r6,128
811130b0:	000b883a 	mov	r5,zero
811130b4:	1009883a 	mov	r4,r2
811130b8:	11219b80 	call	811219b8 <memset>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
811130bc:	e0ffde0b 	ldhu	r3,-136(fp)
811130c0:	e0bfdec4 	addi	r2,fp,-133
811130c4:	180d883a 	mov	r6,r3
811130c8:	01604574 	movhi	r5,33045
811130cc:	2972aa04 	addi	r5,r5,-13656
811130d0:	1009883a 	mov	r4,r2
811130d4:	11221480 	call	81122148 <sprintf>
								debug(fp, cPUSDebug );
811130d8:	d0a06117 	ldw	r2,-32380(gp)
811130dc:	e0ffdec4 	addi	r3,fp,-133
811130e0:	180b883a 	mov	r5,r3
811130e4:	1009883a 	mov	r4,r2
811130e8:	11207b80 	call	811207b8 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
811130ec:	00020106 	br	811138f4 <vParserCommTask+0xddc>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
								debug(fp, cPUSDebug );
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
811130f0:	00a04574 	movhi	r2,33045
811130f4:	10892e04 	addi	r2,r2,9400
811130f8:	10800483 	ldbu	r2,18(r2)
811130fc:	10c03fcc 	andi	r3,r2,255
81113100:	00a04574 	movhi	r2,33045
81113104:	10892e04 	addi	r2,r2,9400
81113108:	18c00284 	addi	r3,r3,10
8111310c:	18c7883a 	add	r3,r3,r3
81113110:	10c5883a 	add	r2,r2,r3
81113114:	e0ffde0b 	ldhu	r3,-136(fp)
81113118:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
8111311c:	00a04574 	movhi	r2,33045
81113120:	10892e04 	addi	r2,r2,9400
81113124:	10800483 	ldbu	r2,18(r2)
81113128:	10800044 	addi	r2,r2,1
8111312c:	1007883a 	mov	r3,r2
81113130:	00a04574 	movhi	r2,33045
81113134:	10892e04 	addi	r2,r2,9400
81113138:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
8111313c:	00a04574 	movhi	r2,33045
81113140:	10892e04 	addi	r2,r2,9400
81113144:	1080038b 	ldhu	r2,14(r2)
81113148:	10bfffcc 	andi	r2,r2,65535
8111314c:	10c000a0 	cmpeqi	r3,r2,2
81113150:	1800191e 	bne	r3,zero,811131b8 <vParserCommTask+0x6a0>
81113154:	10c00160 	cmpeqi	r3,r2,5
81113158:	18002c1e 	bne	r3,zero,8111320c <vParserCommTask+0x6f4>
8111315c:	10800060 	cmpeqi	r2,r2,1
81113160:	10003f26 	beq	r2,zero,81113260 <vParserCommTask+0x748>
							{
								case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81113164:	e0bfdec4 	addi	r2,fp,-133
81113168:	01802004 	movi	r6,128
8111316c:	000b883a 	mov	r5,zero
81113170:	1009883a 	mov	r4,r2
81113174:	11219b80 	call	811219b8 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CONFIG_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113178:	e0ffde0b 	ldhu	r3,-136(fp)
8111317c:	e0bfdec4 	addi	r2,fp,-133
81113180:	180d883a 	mov	r6,r3
81113184:	01604574 	movhi	r5,33045
81113188:	2972b904 	addi	r5,r5,-13596
8111318c:	1009883a 	mov	r4,r2
81113190:	11221480 	call	81122148 <sprintf>
										debug(fp, cPUSDebug );
81113194:	d0a06117 	ldw	r2,-32380(gp)
81113198:	e0ffdec4 	addi	r3,fp,-133
8111319c:	180b883a 	mov	r5,r3
811131a0:	1009883a 	mov	r4,r2
811131a4:	11207b80 	call	811207b8 <fprintf>
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
811131a8:	01204574 	movhi	r4,33045
811131ac:	21092e04 	addi	r4,r4,9400
811131b0:	1113a200 	call	81113a20 <bSendMessagePUStoMebTask>

									break;
811131b4:	00004b06 	br	811132e4 <vParserCommTask+0x7cc>
								case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
811131b8:	e0bfdec4 	addi	r2,fp,-133
811131bc:	01802004 	movi	r6,128
811131c0:	000b883a 	mov	r5,zero
811131c4:	1009883a 	mov	r4,r2
811131c8:	11219b80 	call	811219b8 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_STANDBY_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811131cc:	e0ffde0b 	ldhu	r3,-136(fp)
811131d0:	e0bfdec4 	addi	r2,fp,-133
811131d4:	180d883a 	mov	r6,r3
811131d8:	01604574 	movhi	r5,33045
811131dc:	2972c904 	addi	r5,r5,-13532
811131e0:	1009883a 	mov	r4,r2
811131e4:	11221480 	call	81122148 <sprintf>
										debug(fp, cPUSDebug );
811131e8:	d0a06117 	ldw	r2,-32380(gp)
811131ec:	e0ffdec4 	addi	r3,fp,-133
811131f0:	180b883a 	mov	r5,r3
811131f4:	1009883a 	mov	r4,r2
811131f8:	11207b80 	call	811207b8 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
811131fc:	01204574 	movhi	r4,33045
81113200:	21092e04 	addi	r4,r4,9400
81113204:	1113a200 	call	81113a20 <bSendMessagePUStoMebTask>

									break;
81113208:	00003606 	br	811132e4 <vParserCommTask+0x7cc>
								case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8111320c:	e0bfdec4 	addi	r2,fp,-133
81113210:	01802004 	movi	r6,128
81113214:	000b883a 	mov	r5,zero
81113218:	1009883a 	mov	r4,r2
8111321c:	11219b80 	call	811219b8 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CALIBRATION_TEST_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113220:	e0ffde0b 	ldhu	r3,-136(fp)
81113224:	e0bfdec4 	addi	r2,fp,-133
81113228:	180d883a 	mov	r6,r3
8111322c:	01604574 	movhi	r5,33045
81113230:	2972d904 	addi	r5,r5,-13468
81113234:	1009883a 	mov	r4,r2
81113238:	11221480 	call	81122148 <sprintf>
										debug(fp, cPUSDebug );
8111323c:	d0a06117 	ldw	r2,-32380(gp)
81113240:	e0ffdec4 	addi	r3,fp,-133
81113244:	180b883a 	mov	r5,r3
81113248:	1009883a 	mov	r4,r2
8111324c:	11207b80 	call	811207b8 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
81113250:	01204574 	movhi	r4,33045
81113254:	21092e04 	addi	r4,r4,9400
81113258:	1113a200 	call	81113a20 <bSendMessagePUStoMebTask>

									break;
8111325c:	00002106 	br	811132e4 <vParserCommTask+0x7cc>
								default:
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81113260:	e0bfdec4 	addi	r2,fp,-133
81113264:	01802004 	movi	r6,128
81113268:	000b883a 	mov	r5,zero
8111326c:	1009883a 	mov	r4,r2
81113270:	11219b80 	call	811219b8 <memset>
										sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81113274:	00a04574 	movhi	r2,33045
81113278:	10892e04 	addi	r2,r2,9400
8111327c:	1080030b 	ldhu	r2,12(r2)
81113280:	113fffcc 	andi	r4,r2,65535
81113284:	00a04574 	movhi	r2,33045
81113288:	10892e04 	addi	r2,r2,9400
8111328c:	1080038b 	ldhu	r2,14(r2)
81113290:	117fffcc 	andi	r5,r2,65535
81113294:	00a04574 	movhi	r2,33045
81113298:	10892e04 	addi	r2,r2,9400
8111329c:	1080040b 	ldhu	r2,16(r2)
811132a0:	10bfffcc 	andi	r2,r2,65535
811132a4:	e0ffdec4 	addi	r3,fp,-133
811132a8:	d8800015 	stw	r2,0(sp)
811132ac:	280f883a 	mov	r7,r5
811132b0:	200d883a 	mov	r6,r4
811132b4:	01604574 	movhi	r5,33045
811132b8:	29727904 	addi	r5,r5,-13852
811132bc:	1809883a 	mov	r4,r3
811132c0:	11221480 	call	81122148 <sprintf>
										debug(fp, cPUSDebug );
811132c4:	d0a06117 	ldw	r2,-32380(gp)
811132c8:	e0ffdec4 	addi	r3,fp,-133
811132cc:	180b883a 	mov	r5,r3
811132d0:	1009883a 	mov	r4,r2
811132d4:	11207b80 	call	811207b8 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
811132d8:	00800044 	movi	r2,1
811132dc:	e0bfdc15 	stw	r2,-144(fp)
									break;
811132e0:	0001883a 	nop
							}
						}
                        break;
811132e4:	00018306 	br	811138f4 <vParserCommTask+0xddc>


					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
811132e8:	00a04574 	movhi	r2,33045
811132ec:	10891b04 	addi	r2,r2,9324
811132f0:	1080050b 	ldhu	r2,20(r2)
811132f4:	e0bfde0d 	sth	r2,-136(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
811132f8:	00a04574 	movhi	r2,33045
811132fc:	10892e04 	addi	r2,r2,9400
81113300:	10800483 	ldbu	r2,18(r2)
81113304:	10c03fcc 	andi	r3,r2,255
81113308:	00a04574 	movhi	r2,33045
8111330c:	10892e04 	addi	r2,r2,9400
81113310:	18c00284 	addi	r3,r3,10
81113314:	18c7883a 	add	r3,r3,r3
81113318:	10c5883a 	add	r2,r2,r3
8111331c:	e0ffde0b 	ldhu	r3,-136(fp)
81113320:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
81113324:	00a04574 	movhi	r2,33045
81113328:	10892e04 	addi	r2,r2,9400
8111332c:	10800483 	ldbu	r2,18(r2)
81113330:	10800044 	addi	r2,r2,1
81113334:	1007883a 	mov	r3,r2
81113338:	00a04574 	movhi	r2,33045
8111333c:	10892e04 	addi	r2,r2,9400
81113340:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
81113344:	00a04574 	movhi	r2,33045
81113348:	10892e04 	addi	r2,r2,9400
8111334c:	1080038b 	ldhu	r2,14(r2)
81113350:	10bfffcc 	andi	r2,r2,65535
81113354:	10c000e0 	cmpeqi	r3,r2,3
81113358:	18000a1e 	bne	r3,zero,81113384 <vParserCommTask+0x86c>
8111335c:	10c00108 	cmpgei	r3,r2,4
81113360:	1800031e 	bne	r3,zero,81113370 <vParserCommTask+0x858>
81113364:	108000a0 	cmpeqi	r2,r2,2
81113368:	1000451e 	bne	r2,zero,81113480 <vParserCommTask+0x968>
8111336c:	00013c06 	br	81113860 <vParserCommTask+0xd48>
81113370:	10c00120 	cmpeqi	r3,r2,4
81113374:	1800181e 	bne	r3,zero,811133d8 <vParserCommTask+0x8c0>
81113378:	10800160 	cmpeqi	r2,r2,5
8111337c:	10002b1e 	bne	r2,zero,8111342c <vParserCommTask+0x914>
81113380:	00013706 	br	81113860 <vParserCommTask+0xd48>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113384:	e0bfdec4 	addi	r2,fp,-133
81113388:	01802004 	movi	r6,128
8111338c:	000b883a 	mov	r5,zero
81113390:	1009883a 	mov	r4,r2
81113394:	11219b80 	call	811219b8 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_ENABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113398:	e0ffde0b 	ldhu	r3,-136(fp)
8111339c:	e0bfdec4 	addi	r2,fp,-133
811133a0:	180d883a 	mov	r6,r3
811133a4:	01604574 	movhi	r5,33045
811133a8:	2972eb04 	addi	r5,r5,-13396
811133ac:	1009883a 	mov	r4,r2
811133b0:	11221480 	call	81122148 <sprintf>
									debug(fp, cPUSDebug );
811133b4:	d0a06117 	ldw	r2,-32380(gp)
811133b8:	e0ffdec4 	addi	r3,fp,-133
811133bc:	180b883a 	mov	r5,r3
811133c0:	1009883a 	mov	r4,r2
811133c4:	11207b80 	call	811207b8 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
811133c8:	01204574 	movhi	r4,33045
811133cc:	21092e04 	addi	r4,r4,9400
811133d0:	1113a200 	call	81113a20 <bSendMessagePUStoMebTask>

								break;
811133d4:	00014306 	br	811138e4 <vParserCommTask+0xdcc>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811133d8:	e0bfdec4 	addi	r2,fp,-133
811133dc:	01802004 	movi	r6,128
811133e0:	000b883a 	mov	r5,zero
811133e4:	1009883a 	mov	r4,r2
811133e8:	11219b80 	call	811219b8 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_DISABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811133ec:	e0ffde0b 	ldhu	r3,-136(fp)
811133f0:	e0bfdec4 	addi	r2,fp,-133
811133f4:	180d883a 	mov	r6,r3
811133f8:	01604574 	movhi	r5,33045
811133fc:	2972fb04 	addi	r5,r5,-13332
81113400:	1009883a 	mov	r4,r2
81113404:	11221480 	call	81122148 <sprintf>
									debug(fp, cPUSDebug );
81113408:	d0a06117 	ldw	r2,-32380(gp)
8111340c:	e0ffdec4 	addi	r3,fp,-133
81113410:	180b883a 	mov	r5,r3
81113414:	1009883a 	mov	r4,r2
81113418:	11207b80 	call	811207b8 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8111341c:	01204574 	movhi	r4,33045
81113420:	21092e04 	addi	r4,r4,9400
81113424:	1113a200 	call	81113a20 <bSendMessagePUStoMebTask>

								break;
81113428:	00012e06 	br	811138e4 <vParserCommTask+0xdcc>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8111342c:	e0bfdec4 	addi	r2,fp,-133
81113430:	01802004 	movi	r6,128
81113434:	000b883a 	mov	r5,zero
81113438:	1009883a 	mov	r4,r2
8111343c:	11219b80 	call	811219b8 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_RESET (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81113440:	e0ffde0b 	ldhu	r3,-136(fp)
81113444:	e0bfdec4 	addi	r2,fp,-133
81113448:	180d883a 	mov	r6,r3
8111344c:	01604574 	movhi	r5,33045
81113450:	29730b04 	addi	r5,r5,-13268
81113454:	1009883a 	mov	r4,r2
81113458:	11221480 	call	81122148 <sprintf>
									debug(fp, cPUSDebug );
8111345c:	d0a06117 	ldw	r2,-32380(gp)
81113460:	e0ffdec4 	addi	r3,fp,-133
81113464:	180b883a 	mov	r5,r3
81113468:	1009883a 	mov	r4,r2
8111346c:	11207b80 	call	811207b8 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81113470:	01204574 	movhi	r4,33045
81113474:	21092e04 	addi	r4,r4,9400
81113478:	1113a200 	call	81113a20 <bSendMessagePUStoMebTask>

								break;
8111347c:	00011906 	br	811138e4 <vParserCommTask+0xdcc>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
81113480:	00a04574 	movhi	r2,33045
81113484:	10892e04 	addi	r2,r2,9400
81113488:	10800483 	ldbu	r2,18(r2)
8111348c:	10c03fcc 	andi	r3,r2,255
81113490:	00a04574 	movhi	r2,33045
81113494:	10891b04 	addi	r2,r2,9324
81113498:	1100058b 	ldhu	r4,22(r2)
8111349c:	00a04574 	movhi	r2,33045
811134a0:	10892e04 	addi	r2,r2,9400
811134a4:	18c00284 	addi	r3,r3,10
811134a8:	18c7883a 	add	r3,r3,r3
811134ac:	10c5883a 	add	r2,r2,r3
811134b0:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811134b4:	00a04574 	movhi	r2,33045
811134b8:	10892e04 	addi	r2,r2,9400
811134bc:	10800483 	ldbu	r2,18(r2)
811134c0:	10800044 	addi	r2,r2,1
811134c4:	1007883a 	mov	r3,r2
811134c8:	00a04574 	movhi	r2,33045
811134cc:	10892e04 	addi	r2,r2,9400
811134d0:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
811134d4:	00a04574 	movhi	r2,33045
811134d8:	10892e04 	addi	r2,r2,9400
811134dc:	10800483 	ldbu	r2,18(r2)
811134e0:	10c03fcc 	andi	r3,r2,255
811134e4:	00a04574 	movhi	r2,33045
811134e8:	10891b04 	addi	r2,r2,9324
811134ec:	1100060b 	ldhu	r4,24(r2)
811134f0:	00a04574 	movhi	r2,33045
811134f4:	10892e04 	addi	r2,r2,9400
811134f8:	18c00284 	addi	r3,r3,10
811134fc:	18c7883a 	add	r3,r3,r3
81113500:	10c5883a 	add	r2,r2,r3
81113504:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113508:	00a04574 	movhi	r2,33045
8111350c:	10892e04 	addi	r2,r2,9400
81113510:	10800483 	ldbu	r2,18(r2)
81113514:	10800044 	addi	r2,r2,1
81113518:	1007883a 	mov	r3,r2
8111351c:	00a04574 	movhi	r2,33045
81113520:	10892e04 	addi	r2,r2,9400
81113524:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
81113528:	00a04574 	movhi	r2,33045
8111352c:	10892e04 	addi	r2,r2,9400
81113530:	10800483 	ldbu	r2,18(r2)
81113534:	10c03fcc 	andi	r3,r2,255
81113538:	00a04574 	movhi	r2,33045
8111353c:	10891b04 	addi	r2,r2,9324
81113540:	1100068b 	ldhu	r4,26(r2)
81113544:	00a04574 	movhi	r2,33045
81113548:	10892e04 	addi	r2,r2,9400
8111354c:	18c00284 	addi	r3,r3,10
81113550:	18c7883a 	add	r3,r3,r3
81113554:	10c5883a 	add	r2,r2,r3
81113558:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8111355c:	00a04574 	movhi	r2,33045
81113560:	10892e04 	addi	r2,r2,9400
81113564:	10800483 	ldbu	r2,18(r2)
81113568:	10800044 	addi	r2,r2,1
8111356c:	1007883a 	mov	r3,r2
81113570:	00a04574 	movhi	r2,33045
81113574:	10892e04 	addi	r2,r2,9400
81113578:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
8111357c:	00a04574 	movhi	r2,33045
81113580:	10892e04 	addi	r2,r2,9400
81113584:	10800483 	ldbu	r2,18(r2)
81113588:	10c03fcc 	andi	r3,r2,255
8111358c:	00a04574 	movhi	r2,33045
81113590:	10891b04 	addi	r2,r2,9324
81113594:	1100070b 	ldhu	r4,28(r2)
81113598:	00a04574 	movhi	r2,33045
8111359c:	10892e04 	addi	r2,r2,9400
811135a0:	18c00284 	addi	r3,r3,10
811135a4:	18c7883a 	add	r3,r3,r3
811135a8:	10c5883a 	add	r2,r2,r3
811135ac:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811135b0:	00a04574 	movhi	r2,33045
811135b4:	10892e04 	addi	r2,r2,9400
811135b8:	10800483 	ldbu	r2,18(r2)
811135bc:	10800044 	addi	r2,r2,1
811135c0:	1007883a 	mov	r3,r2
811135c4:	00a04574 	movhi	r2,33045
811135c8:	10892e04 	addi	r2,r2,9400
811135cc:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
811135d0:	00a04574 	movhi	r2,33045
811135d4:	10892e04 	addi	r2,r2,9400
811135d8:	10800483 	ldbu	r2,18(r2)
811135dc:	10c03fcc 	andi	r3,r2,255
811135e0:	00a04574 	movhi	r2,33045
811135e4:	10891b04 	addi	r2,r2,9324
811135e8:	1100078b 	ldhu	r4,30(r2)
811135ec:	00a04574 	movhi	r2,33045
811135f0:	10892e04 	addi	r2,r2,9400
811135f4:	18c00284 	addi	r3,r3,10
811135f8:	18c7883a 	add	r3,r3,r3
811135fc:	10c5883a 	add	r2,r2,r3
81113600:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113604:	00a04574 	movhi	r2,33045
81113608:	10892e04 	addi	r2,r2,9400
8111360c:	10800483 	ldbu	r2,18(r2)
81113610:	10800044 	addi	r2,r2,1
81113614:	1007883a 	mov	r3,r2
81113618:	00a04574 	movhi	r2,33045
8111361c:	10892e04 	addi	r2,r2,9400
81113620:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
81113624:	00a04574 	movhi	r2,33045
81113628:	10892e04 	addi	r2,r2,9400
8111362c:	10800483 	ldbu	r2,18(r2)
81113630:	10c03fcc 	andi	r3,r2,255
81113634:	00a04574 	movhi	r2,33045
81113638:	10891b04 	addi	r2,r2,9324
8111363c:	1100080b 	ldhu	r4,32(r2)
81113640:	00a04574 	movhi	r2,33045
81113644:	10892e04 	addi	r2,r2,9400
81113648:	18c00284 	addi	r3,r3,10
8111364c:	18c7883a 	add	r3,r3,r3
81113650:	10c5883a 	add	r2,r2,r3
81113654:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81113658:	00a04574 	movhi	r2,33045
8111365c:	10892e04 	addi	r2,r2,9400
81113660:	10800483 	ldbu	r2,18(r2)
81113664:	10800044 	addi	r2,r2,1
81113668:	1007883a 	mov	r3,r2
8111366c:	00a04574 	movhi	r2,33045
81113670:	10892e04 	addi	r2,r2,9400
81113674:	10c00485 	stb	r3,18(r2)


								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113678:	e0bfdec4 	addi	r2,fp,-133
8111367c:	01802004 	movi	r6,128
81113680:	000b883a 	mov	r5,zero
81113684:	1009883a 	mov	r4,r2
81113688:	11219b80 	call	811219b8 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_RMAP_CONFIG_UPDATE:\n");
8111368c:	e0ffdec4 	addi	r3,fp,-133
81113690:	00a04574 	movhi	r2,33045
81113694:	10b31a04 	addi	r2,r2,-13208
81113698:	1009883a 	mov	r4,r2
8111369c:	00800b84 	movi	r2,46
811136a0:	100d883a 	mov	r6,r2
811136a4:	200b883a 	mov	r5,r4
811136a8:	1809883a 	mov	r4,r3
811136ac:	11218680 	call	81121868 <memcpy>
									debug(fp, cPUSDebug );
811136b0:	d0a06117 	ldw	r2,-32380(gp)
811136b4:	e0ffdec4 	addi	r3,fp,-133
811136b8:	180b883a 	mov	r5,r3
811136bc:	1009883a 	mov	r4,r2
811136c0:	11207b80 	call	811207b8 <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
811136c4:	e0ffde0b 	ldhu	r3,-136(fp)
811136c8:	e0bfdec4 	addi	r2,fp,-133
811136cc:	180d883a 	mov	r6,r3
811136d0:	01604574 	movhi	r5,33045
811136d4:	29732604 	addi	r5,r5,-13160
811136d8:	1009883a 	mov	r4,r2
811136dc:	11221480 	call	81122148 <sprintf>
									debug(fp, cPUSDebug );
811136e0:	d0a06117 	ldw	r2,-32380(gp)
811136e4:	e0ffdec4 	addi	r3,fp,-133
811136e8:	180b883a 	mov	r5,r3
811136ec:	1009883a 	mov	r4,r2
811136f0:	11207b80 	call	811207b8 <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
811136f4:	00a04574 	movhi	r2,33045
811136f8:	10891b04 	addi	r2,r2,9324
811136fc:	1080058b 	ldhu	r2,22(r2)
81113700:	10ffffcc 	andi	r3,r2,65535
81113704:	e0bfdec4 	addi	r2,fp,-133
81113708:	180d883a 	mov	r6,r3
8111370c:	01604574 	movhi	r5,33045
81113710:	29732d04 	addi	r5,r5,-13132
81113714:	1009883a 	mov	r4,r2
81113718:	11221480 	call	81122148 <sprintf>
									debug(fp, cPUSDebug );
8111371c:	d0a06117 	ldw	r2,-32380(gp)
81113720:	e0ffdec4 	addi	r3,fp,-133
81113724:	180b883a 	mov	r5,r3
81113728:	1009883a 	mov	r4,r2
8111372c:	11207b80 	call	811207b8 <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
81113730:	00a04574 	movhi	r2,33045
81113734:	10891b04 	addi	r2,r2,9324
81113738:	1080060b 	ldhu	r2,24(r2)
8111373c:	10ffffcc 	andi	r3,r2,65535
81113740:	e0bfdec4 	addi	r2,fp,-133
81113744:	180d883a 	mov	r6,r3
81113748:	01604574 	movhi	r5,33045
8111374c:	29733104 	addi	r5,r5,-13116
81113750:	1009883a 	mov	r4,r2
81113754:	11221480 	call	81122148 <sprintf>
									debug(fp, cPUSDebug );
81113758:	d0a06117 	ldw	r2,-32380(gp)
8111375c:	e0ffdec4 	addi	r3,fp,-133
81113760:	180b883a 	mov	r5,r3
81113764:	1009883a 	mov	r4,r2
81113768:	11207b80 	call	811207b8 <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
8111376c:	00a04574 	movhi	r2,33045
81113770:	10891b04 	addi	r2,r2,9324
81113774:	1080068b 	ldhu	r2,26(r2)
81113778:	10ffffcc 	andi	r3,r2,65535
8111377c:	e0bfdec4 	addi	r2,fp,-133
81113780:	180d883a 	mov	r6,r3
81113784:	01604574 	movhi	r5,33045
81113788:	29733604 	addi	r5,r5,-13096
8111378c:	1009883a 	mov	r4,r2
81113790:	11221480 	call	81122148 <sprintf>
									debug(fp, cPUSDebug );
81113794:	d0a06117 	ldw	r2,-32380(gp)
81113798:	e0ffdec4 	addi	r3,fp,-133
8111379c:	180b883a 	mov	r5,r3
811137a0:	1009883a 	mov	r4,r2
811137a4:	11207b80 	call	811207b8 <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
811137a8:	00a04574 	movhi	r2,33045
811137ac:	10891b04 	addi	r2,r2,9324
811137b0:	1080070b 	ldhu	r2,28(r2)
811137b4:	10ffffcc 	andi	r3,r2,65535
811137b8:	e0bfdec4 	addi	r2,fp,-133
811137bc:	180d883a 	mov	r6,r3
811137c0:	01604574 	movhi	r5,33045
811137c4:	29733d04 	addi	r5,r5,-13068
811137c8:	1009883a 	mov	r4,r2
811137cc:	11221480 	call	81122148 <sprintf>
									debug(fp, cPUSDebug );
811137d0:	d0a06117 	ldw	r2,-32380(gp)
811137d4:	e0ffdec4 	addi	r3,fp,-133
811137d8:	180b883a 	mov	r5,r3
811137dc:	1009883a 	mov	r4,r2
811137e0:	11207b80 	call	811207b8 <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
811137e4:	00a04574 	movhi	r2,33045
811137e8:	10891b04 	addi	r2,r2,9324
811137ec:	1080078b 	ldhu	r2,30(r2)
811137f0:	10ffffcc 	andi	r3,r2,65535
811137f4:	e0bfdec4 	addi	r2,fp,-133
811137f8:	180d883a 	mov	r6,r3
811137fc:	01604574 	movhi	r5,33045
81113800:	29734404 	addi	r5,r5,-13040
81113804:	1009883a 	mov	r4,r2
81113808:	11221480 	call	81122148 <sprintf>
									debug(fp, cPUSDebug );
8111380c:	d0a06117 	ldw	r2,-32380(gp)
81113810:	e0ffdec4 	addi	r3,fp,-133
81113814:	180b883a 	mov	r5,r3
81113818:	1009883a 	mov	r4,r2
8111381c:	11207b80 	call	811207b8 <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
81113820:	00a04574 	movhi	r2,33045
81113824:	10891b04 	addi	r2,r2,9324
81113828:	1080080b 	ldhu	r2,32(r2)
8111382c:	10ffffcc 	andi	r3,r2,65535
81113830:	e0bfdec4 	addi	r2,fp,-133
81113834:	180d883a 	mov	r6,r3
81113838:	01604574 	movhi	r5,33045
8111383c:	29734a04 	addi	r5,r5,-13016
81113840:	1009883a 	mov	r4,r2
81113844:	11221480 	call	81122148 <sprintf>
									debug(fp, cPUSDebug );
81113848:	d0a06117 	ldw	r2,-32380(gp)
8111384c:	e0ffdec4 	addi	r3,fp,-133
81113850:	180b883a 	mov	r5,r3
81113854:	1009883a 	mov	r4,r2
81113858:	11207b80 	call	811207b8 <fprintf>
								#endif

								break;
8111385c:	00002106 	br	811138e4 <vParserCommTask+0xdcc>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81113860:	e0bfdec4 	addi	r2,fp,-133
81113864:	01802004 	movi	r6,128
81113868:	000b883a 	mov	r5,zero
8111386c:	1009883a 	mov	r4,r2
81113870:	11219b80 	call	811219b8 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81113874:	00a04574 	movhi	r2,33045
81113878:	10892e04 	addi	r2,r2,9400
8111387c:	1080030b 	ldhu	r2,12(r2)
81113880:	113fffcc 	andi	r4,r2,65535
81113884:	00a04574 	movhi	r2,33045
81113888:	10892e04 	addi	r2,r2,9400
8111388c:	1080038b 	ldhu	r2,14(r2)
81113890:	117fffcc 	andi	r5,r2,65535
81113894:	00a04574 	movhi	r2,33045
81113898:	10892e04 	addi	r2,r2,9400
8111389c:	1080040b 	ldhu	r2,16(r2)
811138a0:	10bfffcc 	andi	r2,r2,65535
811138a4:	e0ffdec4 	addi	r3,fp,-133
811138a8:	d8800015 	stw	r2,0(sp)
811138ac:	280f883a 	mov	r7,r5
811138b0:	200d883a 	mov	r6,r4
811138b4:	01604574 	movhi	r5,33045
811138b8:	29727904 	addi	r5,r5,-13852
811138bc:	1809883a 	mov	r4,r3
811138c0:	11221480 	call	81122148 <sprintf>
									debug(fp, cPUSDebug );
811138c4:	d0a06117 	ldw	r2,-32380(gp)
811138c8:	e0ffdec4 	addi	r3,fp,-133
811138cc:	180b883a 	mov	r5,r3
811138d0:	1009883a 	mov	r4,r2
811138d4:	11207b80 	call	811207b8 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
811138d8:	00800044 	movi	r2,1
811138dc:	e0bfdc15 	stw	r2,-144(fp)
								break;
811138e0:	0001883a 	nop
						}
                        break;
811138e4:	00000306 	br	811138f4 <vParserCommTask+0xddc>
                    default:
						eParserMode = sWaitingMessage;
811138e8:	00800044 	movi	r2,1
811138ec:	e0bfdc15 	stw	r2,-144(fp)
                        break;
811138f0:	0001883a 	nop
                }
				break;				
811138f4:	00000306 	br	81113904 <vParserCommTask+0xdec>
			default:
				eParserMode = sWaitingMessage;
811138f8:	00800044 	movi	r2,1
811138fc:	e0bfdc15 	stw	r2,-144(fp)
				break;
81113900:	0001883a 	nop
		}
	}
81113904:	003c9406 	br	81112b58 <__reset+0xfb0f2b58>

81113908 <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
81113908:	defffb04 	addi	sp,sp,-20
8111390c:	de00012e 	bgeu	sp,et,81113914 <getPreParsedPacket+0xc>
81113910:	003b68fa 	trap	3
81113914:	dfc00415 	stw	ra,16(sp)
81113918:	df000315 	stw	fp,12(sp)
8111391c:	df000304 	addi	fp,sp,12
81113920:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81113924:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
81113928:	d0a06a17 	ldw	r2,-32344(gp)
8111392c:	e0fffe44 	addi	r3,fp,-7
81113930:	180d883a 	mov	r6,r3
81113934:	000b883a 	mov	r5,zero
81113938:	1009883a 	mov	r4,r2
8111393c:	113bcc80 	call	8113bcc8 <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
81113940:	e0bffe43 	ldbu	r2,-7(fp)
81113944:	10803fcc 	andi	r2,r2,255
81113948:	10002e1e 	bne	r2,zero,81113a04 <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
8111394c:	e03ffe05 	stb	zero,-8(fp)
81113950:	00002506 	br	811139e8 <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
81113954:	e0fffe03 	ldbu	r3,-8(fp)
81113958:	00a045b4 	movhi	r2,33046
8111395c:	1096b104 	addi	r2,r2,23236
81113960:	18c01324 	muli	r3,r3,76
81113964:	10c5883a 	add	r2,r2,r3
81113968:	10800104 	addi	r2,r2,4
8111396c:	10800003 	ldbu	r2,0(r2)
81113970:	10803fcc 	andi	r2,r2,255
81113974:	1080201c 	xori	r2,r2,128
81113978:	10bfe004 	addi	r2,r2,-128
8111397c:	10001726 	beq	r2,zero,811139dc <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
81113980:	e0fffe03 	ldbu	r3,-8(fp)
81113984:	e13fff17 	ldw	r4,-4(fp)
81113988:	00a045b4 	movhi	r2,33046
8111398c:	1096b104 	addi	r2,r2,23236
81113990:	18c01324 	muli	r3,r3,76
81113994:	10c5883a 	add	r2,r2,r3
81113998:	2007883a 	mov	r3,r4
8111399c:	1009883a 	mov	r4,r2
811139a0:	00801304 	movi	r2,76
811139a4:	100d883a 	mov	r6,r2
811139a8:	200b883a 	mov	r5,r4
811139ac:	1809883a 	mov	r4,r3
811139b0:	11218680 	call	81121868 <memcpy>
                bSuccess = TRUE;
811139b4:	00800044 	movi	r2,1
811139b8:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
811139bc:	e0fffe03 	ldbu	r3,-8(fp)
811139c0:	00a045b4 	movhi	r2,33046
811139c4:	1096b104 	addi	r2,r2,23236
811139c8:	18c01324 	muli	r3,r3,76
811139cc:	10c5883a 	add	r2,r2,r3
811139d0:	10800104 	addi	r2,r2,4
811139d4:	10000005 	stb	zero,0(r2)
                break;
811139d8:	00000606 	br	811139f4 <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
811139dc:	e0bffe03 	ldbu	r2,-8(fp)
811139e0:	10800044 	addi	r2,r2,1
811139e4:	e0bffe05 	stb	r2,-8(fp)
811139e8:	e0bffe03 	ldbu	r2,-8(fp)
811139ec:	10800230 	cmpltui	r2,r2,8
811139f0:	103fd81e 	bne	r2,zero,81113954 <__reset+0xfb0f3954>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
811139f4:	d0a06a17 	ldw	r2,-32344(gp)
811139f8:	1009883a 	mov	r4,r2
811139fc:	113c26c0 	call	8113c26c <OSMutexPost>
81113a00:	00000106 	br	81113a08 <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
81113a04:	111b4700 	call	8111b470 <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
81113a08:	e0bffd17 	ldw	r2,-12(fp)
}
81113a0c:	e037883a 	mov	sp,fp
81113a10:	dfc00117 	ldw	ra,4(sp)
81113a14:	df000017 	ldw	fp,0(sp)
81113a18:	dec00204 	addi	sp,sp,8
81113a1c:	f800283a 	ret

81113a20 <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
81113a20:	defffa04 	addi	sp,sp,-24
81113a24:	de00012e 	bgeu	sp,et,81113a2c <bSendMessagePUStoMebTask+0xc>
81113a28:	003b68fa 	trap	3
81113a2c:	dfc00515 	stw	ra,20(sp)
81113a30:	df000415 	stw	fp,16(sp)
81113a34:	df000404 	addi	fp,sp,16
81113a38:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81113a3c:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
81113a40:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
81113a44:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
81113a48:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
81113a4c:	d0a07217 	ldw	r2,-32312(gp)
81113a50:	e0fffd44 	addi	r3,fp,-11
81113a54:	180d883a 	mov	r6,r3
81113a58:	01400284 	movi	r5,10
81113a5c:	1009883a 	mov	r4,r2
81113a60:	113bcc80 	call	8113bcc8 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81113a64:	e0bffd43 	ldbu	r2,-11(fp)
81113a68:	10803fcc 	andi	r2,r2,255
81113a6c:	1000401e 	bne	r2,zero,81113b70 <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
81113a70:	e03ffd05 	stb	zero,-12(fp)
81113a74:	00003806 	br	81113b58 <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
81113a78:	e0fffd03 	ldbu	r3,-12(fp)
81113a7c:	00a04574 	movhi	r2,33045
81113a80:	1093d304 	addi	r2,r2,20300
81113a84:	18c01524 	muli	r3,r3,84
81113a88:	10c5883a 	add	r2,r2,r3
81113a8c:	10800104 	addi	r2,r2,4
81113a90:	10800017 	ldw	r2,0(r2)
81113a94:	10002d1e 	bne	r2,zero,81113b4c <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
81113a98:	e0fffd03 	ldbu	r3,-12(fp)
81113a9c:	00a04574 	movhi	r2,33045
81113aa0:	1093d304 	addi	r2,r2,20300
81113aa4:	18c01524 	muli	r3,r3,84
81113aa8:	10c7883a 	add	r3,r2,r3
81113aac:	e0bfff17 	ldw	r2,-4(fp)
81113ab0:	1009883a 	mov	r4,r2
81113ab4:	00801504 	movi	r2,84
81113ab8:	100d883a 	mov	r6,r2
81113abc:	200b883a 	mov	r5,r4
81113ac0:	1809883a 	mov	r4,r3
81113ac4:	11218680 	call	81121868 <memcpy>
            	xPus[i].bInUse = TRUE;
81113ac8:	e0fffd03 	ldbu	r3,-12(fp)
81113acc:	00a04574 	movhi	r2,33045
81113ad0:	1093d304 	addi	r2,r2,20300
81113ad4:	18c01524 	muli	r3,r3,84
81113ad8:	10c5883a 	add	r2,r2,r3
81113adc:	10800104 	addi	r2,r2,4
81113ae0:	00c00044 	movi	r3,1
81113ae4:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
81113ae8:	00800044 	movi	r2,1
81113aec:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
81113af0:	00800044 	movi	r2,1
81113af4:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
81113af8:	d0a06817 	ldw	r2,-32352(gp)
81113afc:	e0fffe17 	ldw	r3,-8(fp)
81113b00:	180b883a 	mov	r5,r3
81113b04:	1009883a 	mov	r4,r2
81113b08:	113d1e40 	call	8113d1e4 <OSQPost>
81113b0c:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
81113b10:	e0bffd43 	ldbu	r2,-11(fp)
81113b14:	10803fcc 	andi	r2,r2,255
81113b18:	10000926 	beq	r2,zero,81113b40 <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
81113b1c:	111c3600 	call	8111c360 <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
81113b20:	e0fffd03 	ldbu	r3,-12(fp)
81113b24:	00a04574 	movhi	r2,33045
81113b28:	1093d304 	addi	r2,r2,20300
81113b2c:	18c01524 	muli	r3,r3,84
81113b30:	10c5883a 	add	r2,r2,r3
81113b34:	10800104 	addi	r2,r2,4
81113b38:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81113b3c:	00000906 	br	81113b64 <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
81113b40:	00800044 	movi	r2,1
81113b44:	e0bffc15 	stw	r2,-16(fp)
                break;
81113b48:	00000606 	br	81113b64 <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
81113b4c:	e0bffd03 	ldbu	r2,-12(fp)
81113b50:	10800044 	addi	r2,r2,1
81113b54:	e0bffd05 	stb	r2,-12(fp)
81113b58:	e0bffd03 	ldbu	r2,-12(fp)
81113b5c:	10800130 	cmpltui	r2,r2,4
81113b60:	103fc51e 	bne	r2,zero,81113a78 <__reset+0xfb0f3a78>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
81113b64:	d0a07217 	ldw	r2,-32312(gp)
81113b68:	1009883a 	mov	r4,r2
81113b6c:	113c26c0 	call	8113c26c <OSMutexPost>
    }

    return bSuccess;
81113b70:	e0bffc17 	ldw	r2,-16(fp)
}
81113b74:	e037883a 	mov	sp,fp
81113b78:	dfc00117 	ldw	ra,4(sp)
81113b7c:	df000017 	ldw	fp,0(sp)
81113b80:	dec00204 	addi	sp,sp,8
81113b84:	f800283a 	ret

81113b88 <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
81113b88:	deffab04 	addi	sp,sp,-340
81113b8c:	de00012e 	bgeu	sp,et,81113b94 <vReceiverUartTask+0xc>
81113b90:	003b68fa 	trap	3
81113b94:	dfc05415 	stw	ra,336(sp)
81113b98:	df005315 	stw	fp,332(sp)
81113b9c:	df005304 	addi	fp,sp,332
81113ba0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81113ba4:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #ifdef DEBUG_ON
        debug(fp,"Receiver UART Task. (Task on)\n");
81113ba8:	d0a06117 	ldw	r2,-32380(gp)
81113bac:	100f883a 	mov	r7,r2
81113bb0:	01800784 	movi	r6,30
81113bb4:	01400044 	movi	r5,1
81113bb8:	01204574 	movhi	r4,33045
81113bbc:	21335004 	addi	r4,r4,-12992
81113bc0:	1120e540 	call	81120e54 <fwrite>
    #endif

    eReaderRXMode = sRConfiguring;
81113bc4:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
81113bc8:	e0bfad17 	ldw	r2,-332(fp)
81113bcc:	10c00060 	cmpeqi	r3,r2,1
81113bd0:	1800091e 	bne	r3,zero,81113bf8 <vReceiverUartTask+0x70>
81113bd4:	0080052e 	bgeu	zero,r2,81113bec <vReceiverUartTask+0x64>
81113bd8:	10c000a0 	cmpeqi	r3,r2,2
81113bdc:	18005d1e 	bne	r3,zero,81113d54 <vReceiverUartTask+0x1cc>
81113be0:	108000e0 	cmpeqi	r2,r2,3
81113be4:	10006e1e 	bne	r2,zero,81113da0 <vReceiverUartTask+0x218>
81113be8:	00007706 	br	81113dc8 <vReceiverUartTask+0x240>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
81113bec:	00800044 	movi	r2,1
81113bf0:	e0bfad15 	stw	r2,-332(fp)
                break;
81113bf4:	00007706 	br	81113dd4 <vReceiverUartTask+0x24c>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
81113bf8:	e0bfaf04 	addi	r2,fp,-324
81113bfc:	01802004 	movi	r6,128
81113c00:	000b883a 	mov	r5,zero
81113c04:	1009883a 	mov	r4,r2
81113c08:	11219b80 	call	811219b8 <memset>
                scanf("%s", cReceive);
81113c0c:	e0bfcf04 	addi	r2,fp,-196
81113c10:	100b883a 	mov	r5,r2
81113c14:	01204574 	movhi	r4,33045
81113c18:	21335804 	addi	r4,r4,-12960
81113c1c:	112206c0 	call	8112206c <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
81113c20:	e0ffcf04 	addi	r3,fp,-196
81113c24:	e0bfaf04 	addi	r2,fp,-324
81113c28:	01801fc4 	movi	r6,127
81113c2c:	180b883a 	mov	r5,r3
81113c30:	1009883a 	mov	r4,r2
81113c34:	11218680 	call	81121868 <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
81113c38:	e0bfaf04 	addi	r2,fp,-324
81113c3c:	01604574 	movhi	r5,33045
81113c40:	29494304 	addi	r5,r5,9484
81113c44:	1009883a 	mov	r4,r2
81113c48:	111422c0 	call	8111422c <bPreParserV2>
81113c4c:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
81113c50:	e0bfae17 	ldw	r2,-328(fp)
81113c54:	10800058 	cmpnei	r2,r2,1
81113c58:	1000281e 	bne	r2,zero,81113cfc <vReceiverUartTask+0x174>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
81113c5c:	00a04574 	movhi	r2,33045
81113c60:	10894304 	addi	r2,r2,9484
81113c64:	10800103 	ldbu	r2,4(r2)
81113c68:	10803fcc 	andi	r2,r2,255
81113c6c:	1080201c 	xori	r2,r2,128
81113c70:	10bfe004 	addi	r2,r2,-128
81113c74:	10800fe0 	cmpeqi	r2,r2,63
81113c78:	1000081e 	bne	r2,zero,81113c9c <vReceiverUartTask+0x114>
81113c7c:	00a04574 	movhi	r2,33045
81113c80:	10894304 	addi	r2,r2,9484
81113c84:	10800103 	ldbu	r2,4(r2)
81113c88:	10803fcc 	andi	r2,r2,255
81113c8c:	1080201c 	xori	r2,r2,128
81113c90:	10bfe004 	addi	r2,r2,-128
81113c94:	10800858 	cmpnei	r2,r2,33
81113c98:	1000031e 	bne	r2,zero,81113ca8 <vReceiverUartTask+0x120>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
81113c9c:	00800084 	movi	r2,2
81113ca0:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81113ca4:	00004b06 	br	81113dd4 <vReceiverUartTask+0x24c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
81113ca8:	00a04574 	movhi	r2,33045
81113cac:	10894304 	addi	r2,r2,9484
81113cb0:	10800103 	ldbu	r2,4(r2)
81113cb4:	10803fcc 	andi	r2,r2,255
81113cb8:	1080201c 	xori	r2,r2,128
81113cbc:	10bfe004 	addi	r2,r2,-128
81113cc0:	108008d8 	cmpnei	r2,r2,35
81113cc4:	10000a1e 	bne	r2,zero,81113cf0 <vReceiverUartTask+0x168>
                            eReaderRXMode = sGetRxUart;
81113cc8:	00800044 	movi	r2,1
81113ccc:	e0bfad15 	stw	r2,-332(fp)
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
81113cd0:	d0a06117 	ldw	r2,-32380(gp)
81113cd4:	100f883a 	mov	r7,r2
81113cd8:	018006c4 	movi	r6,27
81113cdc:	01400044 	movi	r5,1
81113ce0:	01204574 	movhi	r4,33045
81113ce4:	21335904 	addi	r4,r4,-12956
81113ce8:	1120e540 	call	81120e54 <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81113cec:	00003906 	br	81113dd4 <vReceiverUartTask+0x24c>
                            eReaderRXMode = sGetRxUart;
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
81113cf0:	008000c4 	movi	r2,3
81113cf4:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81113cf8:	00003606 	br	81113dd4 <vReceiverUartTask+0x24c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
81113cfc:	00a04574 	movhi	r2,33045
81113d00:	10894304 	addi	r2,r2,9484
81113d04:	00c008c4 	movi	r3,35
81113d08:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
81113d0c:	00a04574 	movhi	r2,33045
81113d10:	10894304 	addi	r2,r2,9484
81113d14:	00c00b84 	movi	r3,46
81113d18:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
81113d1c:	00a04574 	movhi	r2,33045
81113d20:	10894304 	addi	r2,r2,9484
81113d24:	00c00044 	movi	r3,1
81113d28:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81113d2c:	01204574 	movhi	r4,33045
81113d30:	21094304 	addi	r4,r4,9484
81113d34:	1113f140 	call	81113f14 <setPreAckSenderFreePos>
81113d38:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81113d3c:	e0bfae17 	ldw	r2,-328(fp)
81113d40:	1000011e 	bne	r2,zero,81113d48 <vReceiverUartTask+0x1c0>
                        vFailSendNack();
81113d44:	111b5a80 	call	8111b5a8 <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
81113d48:	00800044 	movi	r2,1
81113d4c:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
81113d50:	00002006 	br	81113dd4 <vReceiverUartTask+0x24c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81113d54:	01204574 	movhi	r4,33045
81113d58:	21094304 	addi	r4,r4,9484
81113d5c:	1113f140 	call	81113f14 <setPreAckSenderFreePos>
81113d60:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
81113d64:	e0bfae17 	ldw	r2,-328(fp)
81113d68:	10800058 	cmpnei	r2,r2,1
81113d6c:	1000081e 	bne	r2,zero,81113d90 <vReceiverUartTask+0x208>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
81113d70:	01204574 	movhi	r4,33045
81113d74:	21094304 	addi	r4,r4,9484
81113d78:	1113dd80 	call	81113dd8 <setPreParsedFreePos>
81113d7c:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81113d80:	e0bfae17 	ldw	r2,-328(fp)
81113d84:	1000031e 	bne	r2,zero,81113d94 <vReceiverUartTask+0x20c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
81113d88:	111b6780 	call	8111b678 <vFailSetPreParsedBuffer>
81113d8c:	00000106 	br	81113d94 <vReceiverUartTask+0x20c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
81113d90:	111b6100 	call	8111b610 <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
81113d94:	00800044 	movi	r2,1
81113d98:	e0bfad15 	stw	r2,-332(fp)
                break;
81113d9c:	00000d06 	br	81113dd4 <vReceiverUartTask+0x24c>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
81113da0:	01204574 	movhi	r4,33045
81113da4:	21094304 	addi	r4,r4,9484
81113da8:	11140900 	call	81114090 <setPreAckReceiverFreePos>
81113dac:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
81113db0:	e0bfae17 	ldw	r2,-328(fp)
81113db4:	1000011e 	bne	r2,zero,81113dbc <vReceiverUartTask+0x234>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
81113db8:	111b6e00 	call	8111b6e0 <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
81113dbc:	00800044 	movi	r2,1
81113dc0:	e0bfad15 	stw	r2,-332(fp)
                break;
81113dc4:	00000306 	br	81113dd4 <vReceiverUartTask+0x24c>
            default:
                eReaderRXMode = sGetRxUart;
81113dc8:	00800044 	movi	r2,1
81113dcc:	e0bfad15 	stw	r2,-332(fp)
                break;
81113dd0:	0001883a 	nop
        }

    }
81113dd4:	003f7c06 	br	81113bc8 <__reset+0xfb0f3bc8>

81113dd8 <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
81113dd8:	defffb04 	addi	sp,sp,-20
81113ddc:	de00012e 	bgeu	sp,et,81113de4 <setPreParsedFreePos+0xc>
81113de0:	003b68fa 	trap	3
81113de4:	dfc00415 	stw	ra,16(sp)
81113de8:	df000315 	stw	fp,12(sp)
81113dec:	df000304 	addi	fp,sp,12
81113df0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81113df4:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81113df8:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81113dfc:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81113e00:	d0a06a17 	ldw	r2,-32344(gp)
81113e04:	e0fffe44 	addi	r3,fp,-7
81113e08:	180d883a 	mov	r6,r3
81113e0c:	01400284 	movi	r5,10
81113e10:	1009883a 	mov	r4,r2
81113e14:	113bcc80 	call	8113bcc8 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81113e18:	e0bffe43 	ldbu	r2,-7(fp)
81113e1c:	10803fcc 	andi	r2,r2,255
81113e20:	1000361e 	bne	r2,zero,81113efc <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81113e24:	e03ffe05 	stb	zero,-8(fp)
81113e28:	00002e06 	br	81113ee4 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
81113e2c:	e0fffe03 	ldbu	r3,-8(fp)
81113e30:	00a045b4 	movhi	r2,33046
81113e34:	1096b104 	addi	r2,r2,23236
81113e38:	18c01324 	muli	r3,r3,76
81113e3c:	10c5883a 	add	r2,r2,r3
81113e40:	10800104 	addi	r2,r2,4
81113e44:	10800003 	ldbu	r2,0(r2)
81113e48:	10803fcc 	andi	r2,r2,255
81113e4c:	1080201c 	xori	r2,r2,128
81113e50:	10bfe004 	addi	r2,r2,-128
81113e54:	1000201e 	bne	r2,zero,81113ed8 <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
81113e58:	e0fffe03 	ldbu	r3,-8(fp)
81113e5c:	00a045b4 	movhi	r2,33046
81113e60:	1096b104 	addi	r2,r2,23236
81113e64:	18c01324 	muli	r3,r3,76
81113e68:	10c7883a 	add	r3,r2,r3
81113e6c:	e0bfff17 	ldw	r2,-4(fp)
81113e70:	1009883a 	mov	r4,r2
81113e74:	00801304 	movi	r2,76
81113e78:	100d883a 	mov	r6,r2
81113e7c:	200b883a 	mov	r5,r4
81113e80:	1809883a 	mov	r4,r3
81113e84:	11218680 	call	81121868 <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
81113e88:	d0a06317 	ldw	r2,-32372(gp)
81113e8c:	1009883a 	mov	r4,r2
81113e90:	113e05c0 	call	8113e05c <OSSemPost>
81113e94:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81113e98:	e0bffe43 	ldbu	r2,-7(fp)
81113e9c:	10803fcc 	andi	r2,r2,255
81113ea0:	1000031e 	bne	r2,zero,81113eb0 <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
81113ea4:	00800044 	movi	r2,1
81113ea8:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
81113eac:	00001006 	br	81113ef0 <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
81113eb0:	111acc80 	call	8111acc8 <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
81113eb4:	e0fffe03 	ldbu	r3,-8(fp)
81113eb8:	00a045b4 	movhi	r2,33046
81113ebc:	1096b104 	addi	r2,r2,23236
81113ec0:	18c01324 	muli	r3,r3,76
81113ec4:	10c5883a 	add	r2,r2,r3
81113ec8:	10800104 	addi	r2,r2,4
81113ecc:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
81113ed0:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
81113ed4:	00000606 	br	81113ef0 <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81113ed8:	e0bffe03 	ldbu	r2,-8(fp)
81113edc:	10800044 	addi	r2,r2,1
81113ee0:	e0bffe05 	stb	r2,-8(fp)
81113ee4:	e0bffe03 	ldbu	r2,-8(fp)
81113ee8:	10800230 	cmpltui	r2,r2,8
81113eec:	103fcf1e 	bne	r2,zero,81113e2c <__reset+0xfb0f3e2c>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
81113ef0:	d0a06a17 	ldw	r2,-32344(gp)
81113ef4:	1009883a 	mov	r4,r2
81113ef8:	113c26c0 	call	8113c26c <OSMutexPost>
    }
    return bSuccess;
81113efc:	e0bffd17 	ldw	r2,-12(fp)
}
81113f00:	e037883a 	mov	sp,fp
81113f04:	dfc00117 	ldw	ra,4(sp)
81113f08:	df000017 	ldw	fp,0(sp)
81113f0c:	dec00204 	addi	sp,sp,8
81113f10:	f800283a 	ret

81113f14 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
81113f14:	defffb04 	addi	sp,sp,-20
81113f18:	de00012e 	bgeu	sp,et,81113f20 <setPreAckSenderFreePos+0xc>
81113f1c:	003b68fa 	trap	3
81113f20:	dfc00415 	stw	ra,16(sp)
81113f24:	df000315 	stw	fp,12(sp)
81113f28:	df000304 	addi	fp,sp,12
81113f2c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81113f30:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81113f34:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81113f38:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81113f3c:	d0a07117 	ldw	r2,-32316(gp)
81113f40:	e0fffe44 	addi	r3,fp,-7
81113f44:	180d883a 	mov	r6,r3
81113f48:	01400284 	movi	r5,10
81113f4c:	1009883a 	mov	r4,r2
81113f50:	113bcc80 	call	8113bcc8 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81113f54:	e0bffe43 	ldbu	r2,-7(fp)
81113f58:	10803fcc 	andi	r2,r2,255
81113f5c:	1000461e 	bne	r2,zero,81114078 <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81113f60:	e03ffe05 	stb	zero,-8(fp)
81113f64:	00003e06 	br	81114060 <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
81113f68:	e0fffe03 	ldbu	r3,-8(fp)
81113f6c:	00a045b4 	movhi	r2,33046
81113f70:	1096a904 	addi	r2,r2,23204
81113f74:	18c7883a 	add	r3,r3,r3
81113f78:	18c7883a 	add	r3,r3,r3
81113f7c:	10c5883a 	add	r2,r2,r3
81113f80:	10800003 	ldbu	r2,0(r2)
81113f84:	10803fcc 	andi	r2,r2,255
81113f88:	1080201c 	xori	r2,r2,128
81113f8c:	10bfe004 	addi	r2,r2,-128
81113f90:	1000301e 	bne	r2,zero,81114054 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
81113f94:	e0fffe03 	ldbu	r3,-8(fp)
81113f98:	e0bfff17 	ldw	r2,-4(fp)
81113f9c:	11000103 	ldbu	r4,4(r2)
81113fa0:	00a045b4 	movhi	r2,33046
81113fa4:	1096a904 	addi	r2,r2,23204
81113fa8:	18c7883a 	add	r3,r3,r3
81113fac:	18c7883a 	add	r3,r3,r3
81113fb0:	10c5883a 	add	r2,r2,r3
81113fb4:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
81113fb8:	e0fffe03 	ldbu	r3,-8(fp)
81113fbc:	e0bfff17 	ldw	r2,-4(fp)
81113fc0:	11000143 	ldbu	r4,5(r2)
81113fc4:	00a045b4 	movhi	r2,33046
81113fc8:	1096a904 	addi	r2,r2,23204
81113fcc:	18c7883a 	add	r3,r3,r3
81113fd0:	18c7883a 	add	r3,r3,r3
81113fd4:	10c5883a 	add	r2,r2,r3
81113fd8:	10800044 	addi	r2,r2,1
81113fdc:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
81113fe0:	e0fffe03 	ldbu	r3,-8(fp)
81113fe4:	e0bfff17 	ldw	r2,-4(fp)
81113fe8:	1100020b 	ldhu	r4,8(r2)
81113fec:	00a045b4 	movhi	r2,33046
81113ff0:	1096a904 	addi	r2,r2,23204
81113ff4:	18c7883a 	add	r3,r3,r3
81113ff8:	18c7883a 	add	r3,r3,r3
81113ffc:	10c5883a 	add	r2,r2,r3
81114000:	10800084 	addi	r2,r2,2
81114004:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
81114008:	d0a06017 	ldw	r2,-32384(gp)
8111400c:	1009883a 	mov	r4,r2
81114010:	113e05c0 	call	8113e05c <OSSemPost>
81114014:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
81114018:	e0bffe43 	ldbu	r2,-7(fp)
8111401c:	10803fcc 	andi	r2,r2,255
81114020:	10000926 	beq	r2,zero,81114048 <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
81114024:	111ad600 	call	8111ad60 <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
81114028:	e0fffe03 	ldbu	r3,-8(fp)
8111402c:	00a045b4 	movhi	r2,33046
81114030:	1096a904 	addi	r2,r2,23204
81114034:	18c7883a 	add	r3,r3,r3
81114038:	18c7883a 	add	r3,r3,r3
8111403c:	10c5883a 	add	r2,r2,r3
81114040:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81114044:	00000906 	br	8111406c <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
81114048:	00800044 	movi	r2,1
8111404c:	e0bffd15 	stw	r2,-12(fp)
                break;
81114050:	00000606 	br	8111406c <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81114054:	e0bffe03 	ldbu	r2,-8(fp)
81114058:	10800044 	addi	r2,r2,1
8111405c:	e0bffe05 	stb	r2,-8(fp)
81114060:	e0bffe03 	ldbu	r2,-8(fp)
81114064:	10800230 	cmpltui	r2,r2,8
81114068:	103fbf1e 	bne	r2,zero,81113f68 <__reset+0xfb0f3f68>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
8111406c:	d0a07117 	ldw	r2,-32316(gp)
81114070:	1009883a 	mov	r4,r2
81114074:	113c26c0 	call	8113c26c <OSMutexPost>
    }

    return bSuccess;
81114078:	e0bffd17 	ldw	r2,-12(fp)
}
8111407c:	e037883a 	mov	sp,fp
81114080:	dfc00117 	ldw	ra,4(sp)
81114084:	df000017 	ldw	fp,0(sp)
81114088:	dec00204 	addi	sp,sp,8
8111408c:	f800283a 	ret

81114090 <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
81114090:	defffb04 	addi	sp,sp,-20
81114094:	de00012e 	bgeu	sp,et,8111409c <setPreAckReceiverFreePos+0xc>
81114098:	003b68fa 	trap	3
8111409c:	dfc00415 	stw	ra,16(sp)
811140a0:	df000315 	stw	fp,12(sp)
811140a4:	df000304 	addi	fp,sp,12
811140a8:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811140ac:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
811140b0:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
811140b4:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
811140b8:	d0a06417 	ldw	r2,-32368(gp)
811140bc:	e0fffe44 	addi	r3,fp,-7
811140c0:	180d883a 	mov	r6,r3
811140c4:	01400504 	movi	r5,20
811140c8:	1009883a 	mov	r4,r2
811140cc:	113bcc80 	call	8113bcc8 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811140d0:	e0bffe43 	ldbu	r2,-7(fp)
811140d4:	10803fcc 	andi	r2,r2,255
811140d8:	1000471e 	bne	r2,zero,811141f8 <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
811140dc:	e03ffe05 	stb	zero,-8(fp)
811140e0:	00003e06 	br	811141dc <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
811140e4:	e0fffe03 	ldbu	r3,-8(fp)
811140e8:	00a045b4 	movhi	r2,33046
811140ec:	10809704 	addi	r2,r2,604
811140f0:	18c7883a 	add	r3,r3,r3
811140f4:	18c7883a 	add	r3,r3,r3
811140f8:	10c5883a 	add	r2,r2,r3
811140fc:	10800003 	ldbu	r2,0(r2)
81114100:	10803fcc 	andi	r2,r2,255
81114104:	1080201c 	xori	r2,r2,128
81114108:	10bfe004 	addi	r2,r2,-128
8111410c:	1000301e 	bne	r2,zero,811141d0 <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
81114110:	e0fffe03 	ldbu	r3,-8(fp)
81114114:	e0bfff17 	ldw	r2,-4(fp)
81114118:	11000103 	ldbu	r4,4(r2)
8111411c:	00a045b4 	movhi	r2,33046
81114120:	10809704 	addi	r2,r2,604
81114124:	18c7883a 	add	r3,r3,r3
81114128:	18c7883a 	add	r3,r3,r3
8111412c:	10c5883a 	add	r2,r2,r3
81114130:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
81114134:	e0fffe03 	ldbu	r3,-8(fp)
81114138:	e0bfff17 	ldw	r2,-4(fp)
8111413c:	11000143 	ldbu	r4,5(r2)
81114140:	00a045b4 	movhi	r2,33046
81114144:	10809704 	addi	r2,r2,604
81114148:	18c7883a 	add	r3,r3,r3
8111414c:	18c7883a 	add	r3,r3,r3
81114150:	10c5883a 	add	r2,r2,r3
81114154:	10800044 	addi	r2,r2,1
81114158:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
8111415c:	e0fffe03 	ldbu	r3,-8(fp)
81114160:	e0bfff17 	ldw	r2,-4(fp)
81114164:	1100020b 	ldhu	r4,8(r2)
81114168:	00a045b4 	movhi	r2,33046
8111416c:	10809704 	addi	r2,r2,604
81114170:	18c7883a 	add	r3,r3,r3
81114174:	18c7883a 	add	r3,r3,r3
81114178:	10c5883a 	add	r2,r2,r3
8111417c:	10800084 	addi	r2,r2,2
81114180:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
81114184:	d0a06517 	ldw	r2,-32364(gp)
81114188:	1009883a 	mov	r4,r2
8111418c:	113e05c0 	call	8113e05c <OSSemPost>
81114190:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81114194:	e0bffe43 	ldbu	r2,-7(fp)
81114198:	10803fcc 	andi	r2,r2,255
8111419c:	1000031e 	bne	r2,zero,811141ac <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
811141a0:	00800044 	movi	r2,1
811141a4:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
811141a8:	00000f06 	br	811141e8 <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
811141ac:	111ad140 	call	8111ad14 <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
811141b0:	e0fffe03 	ldbu	r3,-8(fp)
811141b4:	00a045b4 	movhi	r2,33046
811141b8:	10809704 	addi	r2,r2,604
811141bc:	18c7883a 	add	r3,r3,r3
811141c0:	18c7883a 	add	r3,r3,r3
811141c4:	10c5883a 	add	r2,r2,r3
811141c8:	10000005 	stb	zero,0(r2)
                }
                break;
811141cc:	00000606 	br	811141e8 <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
811141d0:	e0bffe03 	ldbu	r2,-8(fp)
811141d4:	10800044 	addi	r2,r2,1
811141d8:	e0bffe05 	stb	r2,-8(fp)
811141dc:	e0bffe03 	ldbu	r2,-8(fp)
811141e0:	108001b0 	cmpltui	r2,r2,6
811141e4:	103fbf1e 	bne	r2,zero,811140e4 <__reset+0xfb0f40e4>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
811141e8:	d0a06417 	ldw	r2,-32368(gp)
811141ec:	1009883a 	mov	r4,r2
811141f0:	113c26c0 	call	8113c26c <OSMutexPost>
811141f4:	00000706 	br	81114214 <setPreAckReceiverFreePos+0x184>
    } else {
        /* Could not  */
        #ifdef DEBUG_ON
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
811141f8:	d0a06117 	ldw	r2,-32380(gp)
811141fc:	100f883a 	mov	r7,r2
81114200:	01801404 	movi	r6,80
81114204:	01400044 	movi	r5,1
81114208:	01204574 	movhi	r4,33045
8111420c:	21336004 	addi	r4,r4,-12928
81114210:	1120e540 	call	81120e54 <fwrite>
        #endif
    }

    return bSuccess;
81114214:	e0bffd17 	ldw	r2,-12(fp)
}
81114218:	e037883a 	mov	sp,fp
8111421c:	dfc00117 	ldw	ra,4(sp)
81114220:	df000017 	ldw	fp,0(sp)
81114224:	dec00204 	addi	sp,sp,8
81114228:	f800283a 	ret

8111422c <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
8111422c:	defff404 	addi	sp,sp,-48
81114230:	de00012e 	bgeu	sp,et,81114238 <bPreParserV2+0xc>
81114234:	003b68fa 	trap	3
81114238:	dfc00b15 	stw	ra,44(sp)
8111423c:	df000a15 	stw	fp,40(sp)
81114240:	dc000915 	stw	r16,36(sp)
81114244:	df000a04 	addi	fp,sp,40
81114248:	e13ffd15 	stw	r4,-12(fp)
8111424c:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
81114250:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
81114254:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
81114258:	01402004 	movi	r5,128
8111425c:	e13ffd17 	ldw	r4,-12(fp)
81114260:	11223f40 	call	811223f4 <strnlen>
81114264:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
81114268:	01400ec4 	movi	r5,59
8111426c:	e13ffd17 	ldw	r4,-12(fp)
81114270:	1118a080 	call	81118a08 <siPosStr>
81114274:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
81114278:	e0fff98f 	ldh	r3,-26(fp)
8111427c:	e0bff90f 	ldh	r2,-28(fp)
81114280:	10bfffc4 	addi	r2,r2,-1
81114284:	18800226 	beq	r3,r2,81114290 <bPreParserV2+0x64>
        return bSuccess;
81114288:	e0bff617 	ldw	r2,-40(fp)
8111428c:	0000ba06 	br	81114578 <bPreParserV2+0x34c>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
81114290:	01401f04 	movi	r5,124
81114294:	e13ffd17 	ldw	r4,-12(fp)
81114298:	1118a080 	call	81118a08 <siPosStr>
8111429c:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
811142a0:	e0bffa0f 	ldh	r2,-24(fp)
811142a4:	e0fff98f 	ldh	r3,-26(fp)
811142a8:	1880020e 	bge	r3,r2,811142b4 <bPreParserV2+0x88>
        return bSuccess;
811142ac:	e0bff617 	ldw	r2,-40(fp)
811142b0:	0000b106 	br	81114578 <bPreParserV2+0x34c>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
811142b4:	01604574 	movhi	r5,33045
811142b8:	29737504 	addi	r5,r5,-12844
811142bc:	e13ffd17 	ldw	r4,-12(fp)
811142c0:	11223100 	call	81122310 <strcspn>
811142c4:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
811142c8:	e0bffa8f 	ldh	r2,-22(fp)
811142cc:	e0fffa0f 	ldh	r3,-24(fp)
811142d0:	1880020e 	bge	r3,r2,811142dc <bPreParserV2+0xb0>
        return bSuccess;
811142d4:	e0bff617 	ldw	r2,-40(fp)
811142d8:	0000a706 	br	81114578 <bPreParserV2+0x34c>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
811142dc:	e0bffa8f 	ldh	r2,-22(fp)
811142e0:	e0fffd17 	ldw	r3,-12(fp)
811142e4:	1885883a 	add	r2,r3,r2
811142e8:	10c00003 	ldbu	r3,0(r2)
811142ec:	e0bffe17 	ldw	r2,-8(fp)
811142f0:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
811142f4:	e0bffe17 	ldw	r2,-8(fp)
811142f8:	10800103 	ldbu	r2,4(r2)
811142fc:	10803fcc 	andi	r2,r2,255
81114300:	1080201c 	xori	r2,r2,128
81114304:	10bfe004 	addi	r2,r2,-128
81114308:	108008d8 	cmpnei	r2,r2,35
8111430c:	1000041e 	bne	r2,zero,81114320 <bPreParserV2+0xf4>
        bSuccess = TRUE;
81114310:	00800044 	movi	r2,1
81114314:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
81114318:	e0bff617 	ldw	r2,-40(fp)
8111431c:	00009606 	br	81114578 <bPreParserV2+0x34c>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
81114320:	e0bffa8f 	ldh	r2,-22(fp)
81114324:	e0fffd17 	ldw	r3,-12(fp)
81114328:	1889883a 	add	r4,r3,r2
8111432c:	e0fffa0f 	ldh	r3,-24(fp)
81114330:	e0bffa8f 	ldh	r2,-22(fp)
81114334:	1885c83a 	sub	r2,r3,r2
81114338:	100b883a 	mov	r5,r2
8111433c:	111a9700 	call	8111a970 <ucCrc8wInit>
81114340:	1007883a 	mov	r3,r2
81114344:	e0bffe17 	ldw	r2,-8(fp)
81114348:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
8111434c:	e0bffa8f 	ldh	r2,-22(fp)
81114350:	10800044 	addi	r2,r2,1
81114354:	e0fffd17 	ldw	r3,-12(fp)
81114358:	1885883a 	add	r2,r3,r2
8111435c:	10c00003 	ldbu	r3,0(r2)
81114360:	e0bffe17 	ldw	r2,-8(fp)
81114364:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
81114368:	e0bffe17 	ldw	r2,-8(fp)
8111436c:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
81114370:	e0bffe17 	ldw	r2,-8(fp)
81114374:	10800204 	addi	r2,r2,8
81114378:	01801004 	movi	r6,64
8111437c:	000b883a 	mov	r5,zero
81114380:	1009883a 	mov	r4,r2
81114384:	11219b80 	call	811219b8 <memset>

    i = siIni + 3; /* "?C:i..." */
81114388:	e0bffa8b 	ldhu	r2,-22(fp)
8111438c:	108000c4 	addi	r2,r2,3
81114390:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
81114394:	e0bffb44 	addi	r2,fp,-19
81114398:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
8111439c:	e0bffb44 	addi	r2,fp,-19
811143a0:	01800184 	movi	r6,6
811143a4:	000b883a 	mov	r5,zero
811143a8:	1009883a 	mov	r4,r2
811143ac:	11219b80 	call	811219b8 <memset>
        do {
            c = buffer[i];
811143b0:	e0bff703 	ldbu	r2,-36(fp)
811143b4:	e0fffd17 	ldw	r3,-12(fp)
811143b8:	1885883a 	add	r2,r3,r2
811143bc:	10800003 	ldbu	r2,0(r2)
811143c0:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
811143c4:	d0e00317 	ldw	r3,-32756(gp)
811143c8:	e0bffb07 	ldb	r2,-20(fp)
811143cc:	10800044 	addi	r2,r2,1
811143d0:	1885883a 	add	r2,r3,r2
811143d4:	10800003 	ldbu	r2,0(r2)
811143d8:	10803fcc 	andi	r2,r2,255
811143dc:	1080010c 	andi	r2,r2,4
811143e0:	10000626 	beq	r2,zero,811143fc <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
811143e4:	e0bff817 	ldw	r2,-32(fp)
811143e8:	e0fffb03 	ldbu	r3,-20(fp)
811143ec:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
811143f0:	e0bff817 	ldw	r2,-32(fp)
811143f4:	10800044 	addi	r2,r2,1
811143f8:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
811143fc:	e0bff703 	ldbu	r2,-36(fp)
81114400:	10800044 	addi	r2,r2,1
81114404:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
81114408:	e0bff90f 	ldh	r2,-28(fp)
8111440c:	e0fff703 	ldbu	r3,-36(fp)
81114410:	1880090e 	bge	r3,r2,81114438 <bPreParserV2+0x20c>
81114414:	e0bffb07 	ldb	r2,-20(fp)
81114418:	10800ea0 	cmpeqi	r2,r2,58
8111441c:	1000061e 	bne	r2,zero,81114438 <bPreParserV2+0x20c>
81114420:	e0bffb07 	ldb	r2,-20(fp)
81114424:	10800ee0 	cmpeqi	r2,r2,59
81114428:	1000031e 	bne	r2,zero,81114438 <bPreParserV2+0x20c>
8111442c:	e0bffb07 	ldb	r2,-20(fp)
81114430:	10801f18 	cmpnei	r2,r2,124
81114434:	103fde1e 	bne	r2,zero,811143b0 <__reset+0xfb0f43b0>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81114438:	e0bff817 	ldw	r2,-32(fp)
8111443c:	00c00284 	movi	r3,10
81114440:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
81114444:	e0bffb07 	ldb	r2,-20(fp)
81114448:	10800ea0 	cmpeqi	r2,r2,58
8111444c:	1000031e 	bne	r2,zero,8111445c <bPreParserV2+0x230>
81114450:	e0bffb07 	ldb	r2,-20(fp)
81114454:	10801f18 	cmpnei	r2,r2,124
81114458:	10001a1e 	bne	r2,zero,811144c4 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
8111445c:	e0bffe17 	ldw	r2,-8(fp)
81114460:	10800183 	ldbu	r2,6(r2)
81114464:	10803fcc 	andi	r2,r2,255
81114468:	10800828 	cmpgeui	r2,r2,32
8111446c:	1000041e 	bne	r2,zero,81114480 <bPreParserV2+0x254>
81114470:	e0bffe17 	ldw	r2,-8(fp)
81114474:	10800183 	ldbu	r2,6(r2)
81114478:	14003fcc 	andi	r16,r2,255
8111447c:	00000106 	br	81114484 <bPreParserV2+0x258>
81114480:	04000804 	movi	r16,32
81114484:	e0bffb44 	addi	r2,fp,-19
81114488:	1009883a 	mov	r4,r2
8111448c:	112065c0 	call	8112065c <atoi>
81114490:	1009883a 	mov	r4,r2
81114494:	e0fffe17 	ldw	r3,-8(fp)
81114498:	80800104 	addi	r2,r16,4
8111449c:	1085883a 	add	r2,r2,r2
811144a0:	1885883a 	add	r2,r3,r2
811144a4:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
811144a8:	e0bffe17 	ldw	r2,-8(fp)
811144ac:	10800183 	ldbu	r2,6(r2)
811144b0:	10800044 	addi	r2,r2,1
811144b4:	1007883a 	mov	r3,r2
811144b8:	e0bffe17 	ldw	r2,-8(fp)
811144bc:	10c00185 	stb	r3,6(r2)
811144c0:	00000906 	br	811144e8 <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
811144c4:	e0bffb07 	ldb	r2,-20(fp)
811144c8:	10800ed8 	cmpnei	r2,r2,59
811144cc:	1000061e 	bne	r2,zero,811144e8 <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
811144d0:	e0bffb44 	addi	r2,fp,-19
811144d4:	1009883a 	mov	r4,r2
811144d8:	112065c0 	call	8112065c <atoi>
811144dc:	1007883a 	mov	r3,r2
811144e0:	e0bffe17 	ldw	r2,-8(fp)
811144e4:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
811144e8:	e0bffb07 	ldb	r2,-20(fp)
811144ec:	10800ee0 	cmpeqi	r2,r2,59
811144f0:	1000031e 	bne	r2,zero,81114500 <bPreParserV2+0x2d4>
811144f4:	e0bff90f 	ldh	r2,-28(fp)
811144f8:	e0fff703 	ldbu	r3,-36(fp)
811144fc:	18bfa516 	blt	r3,r2,81114394 <__reset+0xfb0f4394>


    if ( c == FINAL_CHAR )
81114500:	e0bffb07 	ldb	r2,-20(fp)
81114504:	10800ed8 	cmpnei	r2,r2,59
81114508:	1000191e 	bne	r2,zero,81114570 <bPreParserV2+0x344>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
8111450c:	e0bffe17 	ldw	r2,-8(fp)
81114510:	10c01243 	ldbu	r3,73(r2)
81114514:	e0bffe17 	ldw	r2,-8(fp)
81114518:	10801203 	ldbu	r2,72(r2)
8111451c:	18c03fcc 	andi	r3,r3,255
81114520:	10803fcc 	andi	r2,r2,255
81114524:	1880031e 	bne	r3,r2,81114534 <bPreParserV2+0x308>
            bSuccess = TRUE;
81114528:	00800044 	movi	r2,1
8111452c:	e0bff615 	stw	r2,-40(fp)
81114530:	00001006 	br	81114574 <bPreParserV2+0x348>
        } else {
            /* Wrong CRC */
            #ifdef DEBUG_ON
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
81114534:	d0e06117 	ldw	r3,-32380(gp)
81114538:	e0bffe17 	ldw	r2,-8(fp)
8111453c:	10801203 	ldbu	r2,72(r2)
81114540:	11003fcc 	andi	r4,r2,255
81114544:	e0bffe17 	ldw	r2,-8(fp)
81114548:	10801243 	ldbu	r2,73(r2)
8111454c:	10803fcc 	andi	r2,r2,255
81114550:	100f883a 	mov	r7,r2
81114554:	200d883a 	mov	r6,r4
81114558:	01604574 	movhi	r5,33045
8111455c:	29737704 	addi	r5,r5,-12836
81114560:	1809883a 	mov	r4,r3
81114564:	11207b80 	call	811207b8 <fprintf>
            #endif
            bSuccess = FALSE;
81114568:	e03ff615 	stw	zero,-40(fp)
8111456c:	00000106 	br	81114574 <bPreParserV2+0x348>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
81114570:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
81114574:	e0bff617 	ldw	r2,-40(fp)
}
81114578:	e6ffff04 	addi	sp,fp,-4
8111457c:	dfc00217 	ldw	ra,8(sp)
81114580:	df000117 	ldw	fp,4(sp)
81114584:	dc000017 	ldw	r16,0(sp)
81114588:	dec00304 	addi	sp,sp,12
8111458c:	f800283a 	ret

81114590 <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
81114590:	defffb04 	addi	sp,sp,-20
81114594:	de00012e 	bgeu	sp,et,8111459c <vSenderComTask+0xc>
81114598:	003b68fa 	trap	3
8111459c:	dfc00415 	stw	ra,16(sp)
811145a0:	df000315 	stw	fp,12(sp)
811145a4:	df000304 	addi	fp,sp,12
811145a8:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
811145ac:	e03ffd15 	stw	zero,-12(fp)

    #ifdef DEBUG_ON
        debug(fp,"Sender Comm Task. (Task on)\n");
811145b0:	d0a06117 	ldw	r2,-32380(gp)
811145b4:	100f883a 	mov	r7,r2
811145b8:	01800704 	movi	r6,28
811145bc:	01400044 	movi	r5,1
811145c0:	01204574 	movhi	r4,33045
811145c4:	21338304 	addi	r4,r4,-12788
811145c8:	1120e540 	call	81120e54 <fwrite>
    #endif

    for (;;){
        
        switch (eSenderMode)
811145cc:	e0bffd17 	ldw	r2,-12(fp)
811145d0:	10c00060 	cmpeqi	r3,r2,1
811145d4:	1800091e 	bne	r3,zero,811145fc <vSenderComTask+0x6c>
811145d8:	0080052e 	bgeu	zero,r2,811145f0 <vSenderComTask+0x60>
811145dc:	10c000a0 	cmpeqi	r3,r2,2
811145e0:	1800471e 	bne	r3,zero,81114700 <vSenderComTask+0x170>
811145e4:	10800160 	cmpeqi	r2,r2,5
811145e8:	10002c1e 	bne	r2,zero,8111469c <vSenderComTask+0x10c>
811145ec:	00003a06 	br	811146d8 <vSenderComTask+0x148>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
811145f0:	00800044 	movi	r2,1
811145f4:	e0bffd15 	stw	r2,-12(fp)
                break;
811145f8:	00004206 	br	81114704 <vSenderComTask+0x174>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #ifdef DEBUG_ON
                    debug(fp,"Preparing the Start Sequence.\n");
811145fc:	d0a06117 	ldw	r2,-32380(gp)
81114600:	100f883a 	mov	r7,r2
81114604:	01800784 	movi	r6,30
81114608:	01400044 	movi	r5,1
8111460c:	01204574 	movhi	r4,33045
81114610:	21338b04 	addi	r4,r4,-12756
81114614:	1120e540 	call	81120e54 <fwrite>
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
81114618:	01400044 	movi	r5,1
8111461c:	01204574 	movhi	r4,33045
81114620:	21339304 	addi	r4,r4,-12724
81114624:	11181000 	call	81118100 <bSendUART32v2>
81114628:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
8111462c:	e0bffe17 	ldw	r2,-8(fp)
81114630:	10800058 	cmpnei	r2,r2,1
81114634:	10000a1e 	bne	r2,zero,81114660 <vSenderComTask+0xd0>
                    eSenderMode = sDummySender;
81114638:	00800144 	movi	r2,5
8111463c:	e0bffd15 	stw	r2,-12(fp)
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
81114640:	d0a06117 	ldw	r2,-32380(gp)
81114644:	100f883a 	mov	r7,r2
81114648:	01800d44 	movi	r6,53
8111464c:	01400044 	movi	r5,1
81114650:	01204574 	movhi	r4,33045
81114654:	21339604 	addi	r4,r4,-12712
81114658:	1120e540 	call	81120e54 <fwrite>
                        debug(fp,"Fail, try again in 5 seconds.\n");
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
8111465c:	00002906 	br	81114704 <vSenderComTask+0x174>
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    #endif                    
                } else {
                    #ifdef DEBUG_ON
                        debug(fp,"Fail, try again in 5 seconds.\n");
81114660:	d0a06117 	ldw	r2,-32380(gp)
81114664:	100f883a 	mov	r7,r2
81114668:	01800784 	movi	r6,30
8111466c:	01400044 	movi	r5,1
81114670:	01204574 	movhi	r4,33045
81114674:	2133a404 	addi	r4,r4,-12656
81114678:	1120e540 	call	81120e54 <fwrite>
                    #endif 
                    eSenderMode = sStartingConnSender;
8111467c:	00800044 	movi	r2,1
81114680:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
81114684:	000f883a 	mov	r7,zero
81114688:	01800144 	movi	r6,5
8111468c:	000b883a 	mov	r5,zero
81114690:	0009883a 	mov	r4,zero
81114694:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>
                }
                break;
81114698:	00001a06 	br	81114704 <vSenderComTask+0x174>
                

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
8111469c:	00800144 	movi	r2,5
811146a0:	e0bffd15 	stw	r2,-12(fp)

                #ifdef DEBUG_ON
                    debug(fp,"Working...\n");
811146a4:	d0a06117 	ldw	r2,-32380(gp)
811146a8:	100f883a 	mov	r7,r2
811146ac:	018002c4 	movi	r6,11
811146b0:	01400044 	movi	r5,1
811146b4:	01204574 	movhi	r4,33045
811146b8:	2133ac04 	addi	r4,r4,-12624
811146bc:	1120e540 	call	81120e54 <fwrite>
                #endif

				OSTimeDlyHMSM(0, 0, 25, 0); /*Sleeps for 3 second*/
811146c0:	000f883a 	mov	r7,zero
811146c4:	01800644 	movi	r6,25
811146c8:	000b883a 	mov	r5,zero
811146cc:	0009883a 	mov	r4,zero
811146d0:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>

                break;
811146d4:	00000b06 	br	81114704 <vSenderComTask+0x174>
            default:
                #ifdef DEBUG_ON
                    debug(fp,"Sender default\n");
811146d8:	d0a06117 	ldw	r2,-32380(gp)
811146dc:	100f883a 	mov	r7,r2
811146e0:	018003c4 	movi	r6,15
811146e4:	01400044 	movi	r5,1
811146e8:	01204574 	movhi	r4,33045
811146ec:	2133af04 	addi	r4,r4,-12612
811146f0:	1120e540 	call	81120e54 <fwrite>
                #endif
                eSenderMode = sDummySender;
811146f4:	00800144 	movi	r2,5
811146f8:	e0bffd15 	stw	r2,-12(fp)
                break;
811146fc:	00000106 	br	81114704 <vSenderComTask+0x174>

                //pPointer = OSQPend(xQSenderTask, 0, &error_code);

                

                break;
81114700:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
81114704:	003fb106 	br	811145cc <__reset+0xfb0f45cc>

81114708 <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
81114708:	defff804 	addi	sp,sp,-32
8111470c:	de00012e 	bgeu	sp,et,81114714 <vSimMebTask+0xc>
81114710:	003b68fa 	trap	3
81114714:	dfc00715 	stw	ra,28(sp)
81114718:	df000615 	stw	fp,24(sp)
8111471c:	df000604 	addi	fp,sp,24
81114720:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	tQMask uiCmdMeb;
	INT8U error_code;
	INT8U ucFrameNumber;

	pxMebC = (TSimucam_MEB *) task_data;
81114724:	e0bfff17 	ldw	r2,-4(fp)
81114728:	e0bffb15 	stw	r2,-20(fp)

	#ifdef DEBUG_ON
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
8111472c:	d0a06117 	ldw	r2,-32380(gp)
81114730:	100f883a 	mov	r7,r2
81114734:	018008c4 	movi	r6,35
81114738:	01400044 	movi	r5,1
8111473c:	01204574 	movhi	r4,33045
81114740:	2133b304 	addi	r4,r4,-12596
81114744:	1120e540 	call	81120e54 <fwrite>
    #endif


	for (;;) {
		switch ( pxMebC->eMode ) {
81114748:	e0bffb17 	ldw	r2,-20(fp)
8111474c:	10800117 	ldw	r2,4(r2)
81114750:	10c00168 	cmpgeui	r3,r2,5
81114754:	1800ed1e 	bne	r3,zero,81114b0c <vSimMebTask+0x404>
81114758:	100690ba 	slli	r3,r2,2
8111475c:	00a04474 	movhi	r2,33041
81114760:	1091dc04 	addi	r2,r2,18288
81114764:	1885883a 	add	r2,r3,r2
81114768:	10800017 	ldw	r2,0(r2)
8111476c:	1000683a 	jmp	r2
81114770:	81114784 	addi	r4,r16,17694
81114774:	8111479c 	xori	r4,r16,17694
81114778:	8111481c 	xori	r4,r16,17696
8111477c:	811148e8 	cmpgeui	r4,r16,17699
81114780:	811149c0 	call	8811149c <__reset+0x20f149c>
			case sMebInit:
				/* Turn on Meb */
				vMebInit( pxMebC );
81114784:	e13ffb17 	ldw	r4,-20(fp)
81114788:	11158b00 	call	811158b0 <vMebInit>
				pxMebC->eMode = sMebToConfig;
8111478c:	e0bffb17 	ldw	r2,-20(fp)
81114790:	00c00044 	movi	r3,1
81114794:	10c00115 	stw	r3,4(r2)
				break;
81114798:	0000e706 	br	81114b38 <vSimMebTask+0x430>


			case sMebToConfig:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Config Mode\n");
8111479c:	d0a06117 	ldw	r2,-32380(gp)
811147a0:	100f883a 	mov	r7,r2
811147a4:	01800584 	movi	r6,22
811147a8:	01400044 	movi	r5,1
811147ac:	01204574 	movhi	r4,33045
811147b0:	2133bc04 	addi	r4,r4,-12560
811147b4:	1120e540 	call	81120e54 <fwrite>
				#endif

				/* Stop the Sync (Stopping the simulation) */
				bStopSync();
811147b8:	111e0a00 	call	8111e0a0 <bStopSync>
				vSyncClearCounter();
811147bc:	110caf00 	call	8110caf0 <vSyncClearCounter>

				/* If any Task is locked waiting Sync, should be released */
				vReleaseSyncMessages();
811147c0:	11159b80 	call	811159b8 <vReleaseSyncMessages>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 10);
811147c4:	01c00284 	movi	r7,10
811147c8:	000d883a 	mov	r6,zero
811147cc:	000b883a 	mov	r5,zero
811147d0:	0009883a 	mov	r4,zero
811147d4:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>

				/* Transition to Config Mode (Ending the simulation) */
				/* Send a message to the NFEE Controller forcing the mode */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_CONFIG_FORCED, 0, 0 );
811147d8:	000d883a 	mov	r6,zero
811147dc:	000b883a 	mov	r5,zero
811147e0:	01002844 	movi	r4,161
811147e4:	11156840 	call	81115684 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_CONFIG_FORCED, 0, 0 );
811147e8:	000d883a 	mov	r6,zero
811147ec:	000b883a 	mov	r5,zero
811147f0:	01002844 	movi	r4,161
811147f4:	11158280 	call	81115828 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 250);
811147f8:	01c03e84 	movi	r7,250
811147fc:	000d883a 	mov	r6,zero
81114800:	000b883a 	mov	r5,zero
81114804:	0009883a 	mov	r4,zero
81114808:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>

				pxMebC->eMode = sMebConfig;
8111480c:	e0bffb17 	ldw	r2,-20(fp)
81114810:	00c000c4 	movi	r3,3
81114814:	10c00115 	stw	r3,4(r2)
				break;
81114818:	0000c706 	br	81114b38 <vSimMebTask+0x430>


			case sMebToRun:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Run Mode\n");
8111481c:	d0a06117 	ldw	r2,-32380(gp)
81114820:	100f883a 	mov	r7,r2
81114824:	018004c4 	movi	r6,19
81114828:	01400044 	movi	r5,1
8111482c:	01204574 	movhi	r4,33045
81114830:	2133c204 	addi	r4,r4,-12536
81114834:	1120e540 	call	81120e54 <fwrite>
				#endif
				/* Transition to Run Mode (Starting the Simulation) */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_RUN_FORCED, 0, 0 );
81114838:	000d883a 	mov	r6,zero
8111483c:	000b883a 	mov	r5,zero
81114840:	01002884 	movi	r4,162
81114844:	11156840 	call	81115684 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_RUN_FORCED, 0, 0 );
81114848:	000d883a 	mov	r6,zero
8111484c:	000b883a 	mov	r5,zero
81114850:	01002884 	movi	r4,162
81114854:	11158280 	call	81115828 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);
81114858:	e0bffb17 	ldw	r2,-20(fp)
8111485c:	1080050b 	ldhu	r2,20(r2)
81114860:	10bfffcc 	andi	r2,r2,65535
81114864:	100f883a 	mov	r7,r2
81114868:	000d883a 	mov	r6,zero
8111486c:	000b883a 	mov	r5,zero
81114870:	0009883a 	mov	r4,zero
81114874:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
81114878:	e03ffa05 	stb	zero,-24(fp)
8111487c:	00001006 	br	811148c0 <vSimMebTask+0x1b8>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
81114880:	e0bffa03 	ldbu	r2,-24(fp)
81114884:	10809624 	muli	r2,r2,600
81114888:	10809b04 	addi	r2,r2,620
8111488c:	e0fffb17 	ldw	r3,-20(fp)
81114890:	1885883a 	add	r2,r3,r2
81114894:	1009883a 	mov	r4,r2
81114898:	110a5f80 	call	8110a5f8 <bSpwcClearTimecode>
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
8111489c:	e0bffa03 	ldbu	r2,-24(fp)
811148a0:	e0fffb17 	ldw	r3,-20(fp)
811148a4:	10809624 	muli	r2,r2,600
811148a8:	1885883a 	add	r2,r3,r2
811148ac:	10803c04 	addi	r2,r2,240
811148b0:	10000005 	stb	zero,0(r2)
				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
811148b4:	e0bffa03 	ldbu	r2,-24(fp)
811148b8:	10800044 	addi	r2,r2,1
811148bc:	e0bffa05 	stb	r2,-24(fp)
811148c0:	e0bffa03 	ldbu	r2,-24(fp)
811148c4:	103fee26 	beq	r2,zero,81114880 <__reset+0xfb0f4880>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
				}

				bSyncCtrReset();
811148c8:	110d1400 	call	8110d140 <bSyncCtrReset>
				vSyncClearCounter();
811148cc:	110caf00 	call	8110caf0 <vSyncClearCounter>
				bStartSync();
811148d0:	111e0640 	call	8111e064 <bStartSync>

				vEvtChangeMebMode();
811148d4:	111ca0c0 	call	8111ca0c <vEvtChangeMebMode>
				pxMebC->eMode = sMebRun;
811148d8:	e0bffb17 	ldw	r2,-20(fp)
811148dc:	00c00104 	movi	r3,4
811148e0:	10c00115 	stw	r3,4(r2)
				break;
811148e4:	00009406 	br	81114b38 <vSimMebTask+0x430>


			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
811148e8:	d0a06817 	ldw	r2,-32352(gp)
811148ec:	e0fffe04 	addi	r3,fp,-8
811148f0:	180d883a 	mov	r6,r3
811148f4:	000b883a 	mov	r5,zero
811148f8:	1009883a 	mov	r4,r2
811148fc:	113cddc0 	call	8113cddc <OSQPend>
81114900:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81114904:	e0bffe03 	ldbu	r2,-8(fp)
81114908:	10803fcc 	andi	r2,r2,255
8111490c:	1000291e 	bne	r2,zero,811149b4 <vSimMebTask+0x2ac>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81114910:	e0bffdc3 	ldbu	r2,-9(fp)
81114914:	10803fcc 	andi	r2,r2,255
81114918:	10800058 	cmpnei	r2,r2,1
8111491c:	10001c1e 	bne	r2,zero,81114990 <vSimMebTask+0x288>
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
81114920:	e0bffd83 	ldbu	r2,-10(fp)
81114924:	10803fcc 	andi	r2,r2,255
81114928:	10c00060 	cmpeqi	r3,r2,1
8111492c:	1800031e 	bne	r3,zero,8111493c <vSimMebTask+0x234>
81114930:	10803820 	cmpeqi	r2,r2,224
81114934:	1000041e 	bne	r2,zero,81114948 <vSimMebTask+0x240>
81114938:	00000b06 	br	81114968 <vSimMebTask+0x260>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
8111493c:	e13ffb17 	ldw	r4,-20(fp)
81114940:	1114b3c0 	call	81114b3c <vPusMebTask>
								break;
81114944:	00001d06 	br	811149bc <vSimMebTask+0x2b4>
							case M_MASTER_SYNC:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
81114948:	d0a06117 	ldw	r2,-32380(gp)
8111494c:	100f883a 	mov	r7,r2
81114950:	018012c4 	movi	r6,75
81114954:	01400044 	movi	r5,1
81114958:	01204574 	movhi	r4,33045
8111495c:	2133c704 	addi	r4,r4,-12516
81114960:	1120e540 	call	81120e54 <fwrite>
								#endif
								break;
81114964:	00001506 	br	811149bc <vSimMebTask+0x2b4>
							default:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
81114968:	d0a06117 	ldw	r2,-32380(gp)
8111496c:	e0fffd83 	ldbu	r3,-10(fp)
81114970:	18c03fcc 	andi	r3,r3,255
81114974:	180d883a 	mov	r6,r3
81114978:	01604574 	movhi	r5,33045
8111497c:	2973da04 	addi	r5,r5,-12440
81114980:	1009883a 	mov	r4,r2
81114984:	11207b80 	call	811207b8 <fprintf>
								#endif
								break;
81114988:	0001883a 	nop
8111498c:	00000b06 	br	811149bc <vSimMebTask+0x2b4>
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81114990:	d0a06117 	ldw	r2,-32380(gp)
81114994:	e0fffdc3 	ldbu	r3,-9(fp)
81114998:	18c03fcc 	andi	r3,r3,255
8111499c:	180d883a 	mov	r6,r3
811149a0:	01604574 	movhi	r5,33045
811149a4:	2973ec04 	addi	r5,r5,-12368
811149a8:	1009883a 	mov	r4,r2
811149ac:	11207b80 	call	811207b8 <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
811149b0:	00006106 	br	81114b38 <vSimMebTask+0x430>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
						#endif
					}
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
811149b4:	111c3ac0 	call	8111c3ac <vCouldNotGetCmdQueueMeb>
				}

				break;
811149b8:	00005f06 	br	81114b38 <vSimMebTask+0x430>
811149bc:	00005e06 	br	81114b38 <vSimMebTask+0x430>

			case sMebRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
811149c0:	d0a06817 	ldw	r2,-32352(gp)
811149c4:	e0fffe04 	addi	r3,fp,-8
811149c8:	180d883a 	mov	r6,r3
811149cc:	000b883a 	mov	r5,zero
811149d0:	1009883a 	mov	r4,r2
811149d4:	113cddc0 	call	8113cddc <OSQPend>
811149d8:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
811149dc:	e0bffe03 	ldbu	r2,-8(fp)
811149e0:	10803fcc 	andi	r2,r2,255
811149e4:	1000461e 	bne	r2,zero,81114b00 <vSimMebTask+0x3f8>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
811149e8:	e0bffdc3 	ldbu	r2,-9(fp)
811149ec:	10803fcc 	andi	r2,r2,255
811149f0:	10800058 	cmpnei	r2,r2,1
811149f4:	1000391e 	bne	r2,zero,81114adc <vSimMebTask+0x3d4>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
811149f8:	e0bffd83 	ldbu	r2,-10(fp)
811149fc:	10803fcc 	andi	r2,r2,255
81114a00:	10c03820 	cmpeqi	r3,r2,224
81114a04:	1800071e 	bne	r3,zero,81114a24 <vSimMebTask+0x31c>
81114a08:	10c03860 	cmpeqi	r3,r2,225
81114a0c:	1800071e 	bne	r3,zero,81114a2c <vSimMebTask+0x324>
81114a10:	10800060 	cmpeqi	r2,r2,1
81114a14:	10002726 	beq	r2,zero,81114ab4 <vSimMebTask+0x3ac>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81114a18:	e13ffb17 	ldw	r4,-20(fp)
81114a1c:	1114b3c0 	call	81114b3c <vPusMebTask>
								break;
81114a20:	00003906 	br	81114b08 <vSimMebTask+0x400>
							case M_MASTER_SYNC:
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);
81114a24:	e13ffb17 	ldw	r4,-20(fp)
81114a28:	11159140 	call	81115914 <vSwapMemmory>
							case M_SYNC:
								#ifdef DEBUG_ON
									bSpwcGetTimecode(&pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire);
81114a2c:	e0bffb17 	ldw	r2,-20(fp)
81114a30:	10809b04 	addi	r2,r2,620
81114a34:	1009883a 	mov	r4,r2
81114a38:	110a5680 	call	8110a568 <bSpwcGetTimecode>
									tCode = ( pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire.xTimecode.ucCounter);
81114a3c:	e0bffb17 	ldw	r2,-20(fp)
81114a40:	1080a743 	ldbu	r2,669(r2)
81114a44:	e0bffc05 	stb	r2,-16(fp)
									tCodeNext = ( tCode ) % 4;
81114a48:	e0bffc03 	ldbu	r2,-16(fp)
81114a4c:	108000cc 	andi	r2,r2,3
81114a50:	e0bffc45 	stb	r2,-15(fp)

									fprintf(fp,"\n\nMEB TASK:  TC: %hhu ( %hhu )\n ", tCode, tCodeNext);
81114a54:	d0a06117 	ldw	r2,-32380(gp)
81114a58:	e0fffc03 	ldbu	r3,-16(fp)
81114a5c:	e13ffc43 	ldbu	r4,-15(fp)
81114a60:	200f883a 	mov	r7,r4
81114a64:	180d883a 	mov	r6,r3
81114a68:	01604574 	movhi	r5,33045
81114a6c:	2973fa04 	addi	r5,r5,-12312
81114a70:	1009883a 	mov	r4,r2
81114a74:	11207b80 	call	811207b8 <fprintf>


									bRmapGetMemConfigArea(&pxMebC->xFeeControl.xNfee[0].xChannel.xRmap);
81114a78:	e0bffb17 	ldw	r2,-20(fp)
81114a7c:	10805504 	addi	r2,r2,340
81114a80:	1009883a 	mov	r4,r2
81114a84:	110815c0 	call	8110815c <bRmapGetMemConfigArea>
									ucFrameNumber = pxMebC->xFeeControl.xNfee[0].xChannel.xRmap.xRmapMemConfigArea.uliFrameNumber;
81114a88:	e0bffb17 	ldw	r2,-20(fp)
81114a8c:	10807717 	ldw	r2,476(r2)
81114a90:	e0bffc85 	stb	r2,-14(fp)

									//bRmapSetMemConfigArea(&pxMebC->xFeeControl.xNfee[0].xChannel.xRmap);

									fprintf(fp,"MEB TASK:  Frame Number: %hhu \n ", ucFrameNumber);
81114a94:	d0a06117 	ldw	r2,-32380(gp)
81114a98:	e0fffc83 	ldbu	r3,-14(fp)
81114a9c:	180d883a 	mov	r6,r3
81114aa0:	01604574 	movhi	r5,33045
81114aa4:	29740304 	addi	r5,r5,-12276
81114aa8:	1009883a 	mov	r4,r2
81114aac:	11207b80 	call	811207b8 <fprintf>

								#endif

								break;
81114ab0:	00001506 	br	81114b08 <vSimMebTask+0x400>
							default:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command (%hhu)\n", uiCmdMeb.ucByte[2]);
81114ab4:	d0a06117 	ldw	r2,-32380(gp)
81114ab8:	e0fffd83 	ldbu	r3,-10(fp)
81114abc:	18c03fcc 	andi	r3,r3,255
81114ac0:	180d883a 	mov	r6,r3
81114ac4:	01604574 	movhi	r5,33045
81114ac8:	29740c04 	addi	r5,r5,-12240
81114acc:	1009883a 	mov	r4,r2
81114ad0:	11207b80 	call	811207b8 <fprintf>
								#endif
								break;
81114ad4:	0001883a 	nop
81114ad8:	00000b06 	br	81114b08 <vSimMebTask+0x400>
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81114adc:	d0a06117 	ldw	r2,-32380(gp)
81114ae0:	e0fffdc3 	ldbu	r3,-9(fp)
81114ae4:	18c03fcc 	andi	r3,r3,255
81114ae8:	180d883a 	mov	r6,r3
81114aec:	01604574 	movhi	r5,33045
81114af0:	2973ec04 	addi	r5,r5,-12368
81114af4:	1009883a 	mov	r4,r2
81114af8:	11207b80 	call	811207b8 <fprintf>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
81114afc:	00000e06 	br	81114b38 <vSimMebTask+0x430>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81114b00:	111c3ac0 	call	8111c3ac <vCouldNotGetCmdQueueMeb>
				}			
				break;
81114b04:	00000c06 	br	81114b38 <vSimMebTask+0x430>
81114b08:	00000b06 	br	81114b38 <vSimMebTask+0x430>

			default:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Unknow state, backing to Config Mode\n");
81114b0c:	d0a06117 	ldw	r2,-32380(gp)
81114b10:	100f883a 	mov	r7,r2
81114b14:	01800bc4 	movi	r6,47
81114b18:	01400044 	movi	r5,1
81114b1c:	01204574 	movhi	r4,33045
81114b20:	21341504 	addi	r4,r4,-12204
81114b24:	1120e540 	call	81120e54 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
81114b28:	e0bffb17 	ldw	r2,-20(fp)
81114b2c:	00c00044 	movi	r3,1
81114b30:	10c00115 	stw	r3,4(r2)
				break;
81114b34:	0001883a 	nop
		}
	}
81114b38:	003f0306 	br	81114748 <__reset+0xfb0f4748>

81114b3c <vPusMebTask>:
}

void vPusMebTask( TSimucam_MEB *pxMebCLocal ) {
81114b3c:	defffb04 	addi	sp,sp,-20
81114b40:	de00012e 	bgeu	sp,et,81114b48 <vPusMebTask+0xc>
81114b44:	003b68fa 	trap	3
81114b48:	dfc00415 	stw	ra,16(sp)
81114b4c:	df000315 	stw	fp,12(sp)
81114b50:	df000304 	addi	fp,sp,12
81114b54:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess;
	INT8U error_code;
	unsigned char ucIL;
	static tTMPus xPusLocal;

	bSuccess = FALSE;
81114b58:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 2, &error_code);
81114b5c:	d0a07217 	ldw	r2,-32312(gp)
81114b60:	e0fffe44 	addi	r3,fp,-7
81114b64:	180d883a 	mov	r6,r3
81114b68:	01400084 	movi	r5,2
81114b6c:	1009883a 	mov	r4,r2
81114b70:	113bcc80 	call	8113bcc8 <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
81114b74:	e0bffe43 	ldbu	r2,-7(fp)
81114b78:	10803fcc 	andi	r2,r2,255
81114b7c:	10002c1e 	bne	r2,zero,81114c30 <vPusMebTask+0xf4>

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81114b80:	e03ffe05 	stb	zero,-8(fp)
81114b84:	00002306 	br	81114c14 <vPusMebTask+0xd8>
	    {
            if ( xPus[ucIL].bInUse == TRUE ) {
81114b88:	e0fffe03 	ldbu	r3,-8(fp)
81114b8c:	00a04574 	movhi	r2,33045
81114b90:	1093d304 	addi	r2,r2,20300
81114b94:	18c01524 	muli	r3,r3,84
81114b98:	10c5883a 	add	r2,r2,r3
81114b9c:	10800104 	addi	r2,r2,4
81114ba0:	10800017 	ldw	r2,0(r2)
81114ba4:	10800058 	cmpnei	r2,r2,1
81114ba8:	1000171e 	bne	r2,zero,81114c08 <vPusMebTask+0xcc>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[ucIL];
81114bac:	e13ffe03 	ldbu	r4,-8(fp)
81114bb0:	00e04574 	movhi	r3,33045
81114bb4:	18c95604 	addi	r3,r3,9560
81114bb8:	00a04574 	movhi	r2,33045
81114bbc:	1093d304 	addi	r2,r2,20300
81114bc0:	21001524 	muli	r4,r4,84
81114bc4:	1105883a 	add	r2,r2,r4
81114bc8:	1009883a 	mov	r4,r2
81114bcc:	00801504 	movi	r2,84
81114bd0:	100d883a 	mov	r6,r2
81114bd4:	200b883a 	mov	r5,r4
81114bd8:	1809883a 	mov	r4,r3
81114bdc:	11218680 	call	81121868 <memcpy>
            	xPus[ucIL].bInUse = FALSE;
81114be0:	e0fffe03 	ldbu	r3,-8(fp)
81114be4:	00a04574 	movhi	r2,33045
81114be8:	1093d304 	addi	r2,r2,20300
81114bec:	18c01524 	muli	r3,r3,84
81114bf0:	10c5883a 	add	r2,r2,r3
81114bf4:	10800104 	addi	r2,r2,4
81114bf8:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
81114bfc:	00800044 	movi	r2,1
81114c00:	e0bffd15 	stw	r2,-12(fp)
                break;
81114c04:	00000606 	br	81114c20 <vPusMebTask+0xe4>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 2, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81114c08:	e0bffe03 	ldbu	r2,-8(fp)
81114c0c:	10800044 	addi	r2,r2,1
81114c10:	e0bffe05 	stb	r2,-8(fp)
81114c14:	e0bffe03 	ldbu	r2,-8(fp)
81114c18:	10800130 	cmpltui	r2,r2,4
81114c1c:	103fda1e 	bne	r2,zero,81114b88 <__reset+0xfb0f4b88>
            	xPus[ucIL].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
81114c20:	d0a07217 	ldw	r2,-32312(gp)
81114c24:	1009883a 	mov	r4,r2
81114c28:	113c26c0 	call	8113c26c <OSMutexPost>
81114c2c:	00000106 	br	81114c34 <vPusMebTask+0xf8>
	} else {
		vCouldNotGetMutexMebPus();
81114c30:	111c4140 	call	8111c414 <vCouldNotGetMutexMebPus>
	}

	if ( bSuccess ) {
81114c34:	e0bffd17 	ldw	r2,-12(fp)
81114c38:	10001126 	beq	r2,zero,81114c80 <vPusMebTask+0x144>

		switch (pxMebCLocal->eMode) {
81114c3c:	e0bfff17 	ldw	r2,-4(fp)
81114c40:	10800117 	ldw	r2,4(r2)
81114c44:	10c000e0 	cmpeqi	r3,r2,3
81114c48:	1800031e 	bne	r3,zero,81114c58 <vPusMebTask+0x11c>
81114c4c:	10800120 	cmpeqi	r2,r2,4
81114c50:	1000061e 	bne	r2,zero,81114c6c <vPusMebTask+0x130>
				break;
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
				break;
			default:
				break;
81114c54:	00000a06 	br	81114c80 <vPusMebTask+0x144>

	if ( bSuccess ) {

		switch (pxMebCLocal->eMode) {
			case sMebConfig:
				vPusMebInTaskConfigMode(pxMebCLocal, &xPusLocal);
81114c58:	01604574 	movhi	r5,33045
81114c5c:	29495604 	addi	r5,r5,9560
81114c60:	e13fff17 	ldw	r4,-4(fp)
81114c64:	1114c980 	call	81114c98 <vPusMebInTaskConfigMode>
				break;
81114c68:	00000506 	br	81114c80 <vPusMebTask+0x144>
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
81114c6c:	01604574 	movhi	r5,33045
81114c70:	29495604 	addi	r5,r5,9560
81114c74:	e13fff17 	ldw	r4,-4(fp)
81114c78:	11150280 	call	81115028 <vPusMebInTaskRunningMode>
				break;
81114c7c:	0001883a 	nop
			default:
				break;
		}
	}
}
81114c80:	0001883a 	nop
81114c84:	e037883a 	mov	sp,fp
81114c88:	dfc00117 	ldw	ra,4(sp)
81114c8c:	df000017 	ldw	fp,0(sp)
81114c90:	dec00204 	addi	sp,sp,8
81114c94:	f800283a 	ret

81114c98 <vPusMebInTaskConfigMode>:


/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81114c98:	defffc04 	addi	sp,sp,-16
81114c9c:	de00012e 	bgeu	sp,et,81114ca4 <vPusMebInTaskConfigMode+0xc>
81114ca0:	003b68fa 	trap	3
81114ca4:	dfc00315 	stw	ra,12(sp)
81114ca8:	df000215 	stw	fp,8(sp)
81114cac:	df000204 	addi	fp,sp,8
81114cb0:	e13ffe15 	stw	r4,-8(fp)
81114cb4:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81114cb8:	e0bfff17 	ldw	r2,-4(fp)
81114cbc:	1080030b 	ldhu	r2,12(r2)
81114cc0:	10bfffcc 	andi	r2,r2,65535
81114cc4:	10c03ee0 	cmpeqi	r3,r2,251
81114cc8:	1800081e 	bne	r3,zero,81114cec <vPusMebInTaskConfigMode+0x54>
81114ccc:	10c03f20 	cmpeqi	r3,r2,252
81114cd0:	18000a1e 	bne	r3,zero,81114cfc <vPusMebInTaskConfigMode+0x64>
81114cd4:	10803ea0 	cmpeqi	r2,r2,250
81114cd8:	10000c26 	beq	r2,zero,81114d0c <vPusMebInTaskConfigMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250conf(pxMebCLocal, xPusL);
81114cdc:	e17fff17 	ldw	r5,-4(fp)
81114ce0:	e13ffe17 	ldw	r4,-8(fp)
81114ce4:	1114d440 	call	81114d44 <vPusType250conf>
			break;
81114ce8:	00001006 	br	81114d2c <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251conf(pxMebCLocal, xPusL);
81114cec:	e17fff17 	ldw	r5,-4(fp)
81114cf0:	e13ffe17 	ldw	r4,-8(fp)
81114cf4:	1114dd00 	call	81114dd0 <vPusType251conf>
			break;
81114cf8:	00000c06 	br	81114d2c <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252conf(pxMebCLocal, xPusL);
81114cfc:	e17fff17 	ldw	r5,-4(fp)
81114d00:	e13ffe17 	ldw	r4,-8(fp)
81114d04:	1114e240 	call	81114e24 <vPusType252conf>
			break;
81114d08:	00000806 	br	81114d2c <vPusMebInTaskConfigMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
81114d0c:	d0a06117 	ldw	r2,-32380(gp)
81114d10:	100f883a 	mov	r7,r2
81114d14:	01800d84 	movi	r6,54
81114d18:	01400044 	movi	r5,1
81114d1c:	01204574 	movhi	r4,33045
81114d20:	21342104 	addi	r4,r4,-12156
81114d24:	1120e540 	call	81120e54 <fwrite>
			#endif
			break;
81114d28:	0001883a 	nop
	}
}
81114d2c:	0001883a 	nop
81114d30:	e037883a 	mov	sp,fp
81114d34:	dfc00117 	ldw	ra,4(sp)
81114d38:	df000017 	ldw	fp,0(sp)
81114d3c:	dec00204 	addi	sp,sp,8
81114d40:	f800283a 	ret

81114d44 <vPusType250conf>:

void vPusType250conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81114d44:	defffc04 	addi	sp,sp,-16
81114d48:	de00012e 	bgeu	sp,et,81114d50 <vPusType250conf+0xc>
81114d4c:	003b68fa 	trap	3
81114d50:	dfc00315 	stw	ra,12(sp)
81114d54:	df000215 	stw	fp,8(sp)
81114d58:	df000204 	addi	fp,sp,8
81114d5c:	e13ffe15 	stw	r4,-8(fp)
81114d60:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81114d64:	e0bfff17 	ldw	r2,-4(fp)
81114d68:	1080038b 	ldhu	r2,14(r2)
81114d6c:	10bfffcc 	andi	r2,r2,65535
81114d70:	10c00f60 	cmpeqi	r3,r2,61
81114d74:	1800031e 	bne	r3,zero,81114d84 <vPusType250conf+0x40>
81114d78:	10800fa0 	cmpeqi	r2,r2,62
81114d7c:	10000d1e 	bne	r2,zero,81114db4 <vPusType250conf+0x70>
81114d80:	00000406 	br	81114d94 <vPusType250conf+0x50>
		/* TC_SCAM_RUN */
		case 61:
			pxMebCLocal->eMode = sMebToRun;
81114d84:	e0bffe17 	ldw	r2,-8(fp)
81114d88:	00c00084 	movi	r3,2
81114d8c:	10c00115 	stw	r3,4(r2)
			break;
81114d90:	00000906 	br	81114db8 <vPusType250conf+0x74>
			break;
		/* TC_SCAM_CONFIG */
		case 60:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
81114d94:	d0a06117 	ldw	r2,-32380(gp)
81114d98:	100f883a 	mov	r7,r2
81114d9c:	01800b04 	movi	r6,44
81114da0:	01400044 	movi	r5,1
81114da4:	01204574 	movhi	r4,33045
81114da8:	21342f04 	addi	r4,r4,-12100
81114dac:	1120e540 	call	81120e54 <fwrite>
			#endif
			break;
81114db0:	00000106 	br	81114db8 <vPusType250conf+0x74>
			pxMebCLocal->eMode = sMebToRun;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81114db4:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			#endif
			break;
	}
}
81114db8:	0001883a 	nop
81114dbc:	e037883a 	mov	sp,fp
81114dc0:	dfc00117 	ldw	ra,4(sp)
81114dc4:	df000017 	ldw	fp,0(sp)
81114dc8:	dec00204 	addi	sp,sp,8
81114dcc:	f800283a 	ret

81114dd0 <vPusType251conf>:

void vPusType251conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81114dd0:	defffc04 	addi	sp,sp,-16
81114dd4:	de00012e 	bgeu	sp,et,81114ddc <vPusType251conf+0xc>
81114dd8:	003b68fa 	trap	3
81114ddc:	dfc00315 	stw	ra,12(sp)
81114de0:	df000215 	stw	fp,8(sp)
81114de4:	df000204 	addi	fp,sp,8
81114de8:	e13ffe15 	stw	r4,-8(fp)
81114dec:	e17fff15 	stw	r5,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp, "MEB Task: Can't change the mode of the NFEE while MEB is Config mode\n\n" );
81114df0:	d0a06117 	ldw	r2,-32380(gp)
81114df4:	100f883a 	mov	r7,r2
81114df8:	01801184 	movi	r6,70
81114dfc:	01400044 	movi	r5,1
81114e00:	01204574 	movhi	r4,33045
81114e04:	21343b04 	addi	r4,r4,-12052
81114e08:	1120e540 	call	81120e54 <fwrite>
	#endif
}
81114e0c:	0001883a 	nop
81114e10:	e037883a 	mov	sp,fp
81114e14:	dfc00117 	ldw	ra,4(sp)
81114e18:	df000017 	ldw	fp,0(sp)
81114e1c:	dec00204 	addi	sp,sp,8
81114e20:	f800283a 	ret

81114e24 <vPusType252conf>:

void vPusType252conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81114e24:	defffb04 	addi	sp,sp,-20
81114e28:	de00012e 	bgeu	sp,et,81114e30 <vPusType252conf+0xc>
81114e2c:	003b68fa 	trap	3
81114e30:	dfc00415 	stw	ra,16(sp)
81114e34:	df000315 	stw	fp,12(sp)
81114e38:	df000304 	addi	fp,sp,12
81114e3c:	e13ffe15 	stw	r4,-8(fp)
81114e40:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81114e44:	e0bfff17 	ldw	r2,-4(fp)
81114e48:	1080050b 	ldhu	r2,20(r2)
81114e4c:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81114e50:	e0bfff17 	ldw	r2,-4(fp)
81114e54:	1080038b 	ldhu	r2,14(r2)
81114e58:	10bfffcc 	andi	r2,r2,65535
81114e5c:	10c000a0 	cmpeqi	r3,r2,2
81114e60:	18000c1e 	bne	r3,zero,81114e94 <vPusType252conf+0x70>
81114e64:	10c00090 	cmplti	r3,r2,2
81114e68:	1800611e 	bne	r3,zero,81114ff0 <vPusType252conf+0x1cc>
81114e6c:	10800188 	cmpgei	r2,r2,6
81114e70:	10005f1e 	bne	r2,zero,81114ff0 <vPusType252conf+0x1cc>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
		case 5: /* TC_SCAM_SPW_LINK_RESET */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
81114e74:	d0a06117 	ldw	r2,-32380(gp)
81114e78:	100f883a 	mov	r7,r2
81114e7c:	01801384 	movi	r6,78
81114e80:	01400044 	movi	r5,1
81114e84:	01204574 	movhi	r4,33045
81114e88:	21344d04 	addi	r4,r4,-11980
81114e8c:	1120e540 	call	81120e54 <fwrite>
			#endif
			break;
81114e90:	00005f06 	br	81115010 <vPusType252conf+0x1ec>
		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */

			/* Disable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81114e94:	e0bffd0b 	ldhu	r2,-12(fp)
81114e98:	10809624 	muli	r2,r2,600
81114e9c:	10805504 	addi	r2,r2,340
81114ea0:	e0fffe17 	ldw	r3,-8(fp)
81114ea4:	1885883a 	add	r2,r3,r2
81114ea8:	1009883a 	mov	r4,r2
81114eac:	110793c0 	call	8110793c <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81114eb0:	e0bffd0b 	ldhu	r2,-12(fp)
81114eb4:	e0fffe17 	ldw	r3,-8(fp)
81114eb8:	10809624 	muli	r2,r2,600
81114ebc:	1885883a 	add	r2,r3,r2
81114ec0:	10806504 	addi	r2,r2,404
81114ec4:	10000015 	stw	zero,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81114ec8:	e0bffd0b 	ldhu	r2,-12(fp)
81114ecc:	10809624 	muli	r2,r2,600
81114ed0:	10805504 	addi	r2,r2,340
81114ed4:	e0fffe17 	ldw	r3,-8(fp)
81114ed8:	1885883a 	add	r2,r3,r2
81114edc:	1009883a 	mov	r4,r2
81114ee0:	11078940 	call	81107894 <bRmapSetIrqControl>

			/* Change the configuration */
			bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81114ee4:	e0bffd0b 	ldhu	r2,-12(fp)
81114ee8:	10809624 	muli	r2,r2,600
81114eec:	10805504 	addi	r2,r2,340
81114ef0:	e0fffe17 	ldw	r3,-8(fp)
81114ef4:	1885883a 	add	r2,r3,r2
81114ef8:	1009883a 	mov	r4,r2
81114efc:	1107b240 	call	81107b24 <bRmapGetCodecConfig>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
81114f00:	e0bffd0b 	ldhu	r2,-12(fp)
81114f04:	e0ffff17 	ldw	r3,-4(fp)
81114f08:	18c00b0b 	ldhu	r3,44(r3)
81114f0c:	1809883a 	mov	r4,r3
81114f10:	e0fffe17 	ldw	r3,-8(fp)
81114f14:	10809624 	muli	r2,r2,600
81114f18:	1885883a 	add	r2,r3,r2
81114f1c:	10805604 	addi	r2,r2,344
81114f20:	11000005 	stb	r4,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81114f24:	e0bffd0b 	ldhu	r2,-12(fp)
81114f28:	e0ffff17 	ldw	r3,-4(fp)
81114f2c:	18c0098b 	ldhu	r3,38(r3)
81114f30:	1809883a 	mov	r4,r3
81114f34:	e0fffe17 	ldw	r3,-8(fp)
81114f38:	10809624 	muli	r2,r2,600
81114f3c:	1885883a 	add	r2,r3,r2
81114f40:	10805644 	addi	r2,r2,345
81114f44:	11000005 	stb	r4,0(r2)
			bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81114f48:	e0bffd0b 	ldhu	r2,-12(fp)
81114f4c:	10809624 	muli	r2,r2,600
81114f50:	10805504 	addi	r2,r2,340
81114f54:	e0fffe17 	ldw	r3,-8(fp)
81114f58:	1885883a 	add	r2,r3,r2
81114f5c:	1009883a 	mov	r4,r2
81114f60:	1107a4c0 	call	81107a4c <bRmapSetCodecConfig>


			/* Enable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81114f64:	e0bffd0b 	ldhu	r2,-12(fp)
81114f68:	10809624 	muli	r2,r2,600
81114f6c:	10805504 	addi	r2,r2,340
81114f70:	e0fffe17 	ldw	r3,-8(fp)
81114f74:	1885883a 	add	r2,r3,r2
81114f78:	1009883a 	mov	r4,r2
81114f7c:	110793c0 	call	8110793c <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81114f80:	e0bffd0b 	ldhu	r2,-12(fp)
81114f84:	e0fffe17 	ldw	r3,-8(fp)
81114f88:	10809624 	muli	r2,r2,600
81114f8c:	1885883a 	add	r2,r3,r2
81114f90:	10806504 	addi	r2,r2,404
81114f94:	00c00044 	movi	r3,1
81114f98:	10c00015 	stw	r3,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81114f9c:	e0bffd0b 	ldhu	r2,-12(fp)
81114fa0:	10809624 	muli	r2,r2,600
81114fa4:	10805504 	addi	r2,r2,340
81114fa8:	e0fffe17 	ldw	r3,-8(fp)
81114fac:	1885883a 	add	r2,r3,r2
81114fb0:	1009883a 	mov	r4,r2
81114fb4:	11078940 	call	81107894 <bRmapSetIrqControl>

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81114fb8:	d0e06117 	ldw	r3,-32380(gp)
81114fbc:	e0bfff17 	ldw	r2,-4(fp)
81114fc0:	10800b0b 	ldhu	r2,44(r2)
81114fc4:	113fffcc 	andi	r4,r2,65535
81114fc8:	e0bfff17 	ldw	r2,-4(fp)
81114fcc:	1080098b 	ldhu	r2,38(r2)
81114fd0:	10bfffcc 	andi	r2,r2,65535
81114fd4:	100f883a 	mov	r7,r2
81114fd8:	200d883a 	mov	r6,r4
81114fdc:	01604574 	movhi	r5,33045
81114fe0:	29746104 	addi	r5,r5,-11900
81114fe4:	1809883a 	mov	r4,r3
81114fe8:	11207b80 	call	811207b8 <fprintf>
			#endif

			break;
81114fec:	00000806 	br	81115010 <vPusType252conf+0x1ec>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
81114ff0:	d0a06117 	ldw	r2,-32380(gp)
81114ff4:	100f883a 	mov	r7,r2
81114ff8:	01800b04 	movi	r6,44
81114ffc:	01400044 	movi	r5,1
81115000:	01204574 	movhi	r4,33045
81115004:	21342f04 	addi	r4,r4,-12100
81115008:	1120e540 	call	81120e54 <fwrite>
			#endif
			break;
8111500c:	0001883a 	nop
	}
}
81115010:	0001883a 	nop
81115014:	e037883a 	mov	sp,fp
81115018:	dfc00117 	ldw	ra,4(sp)
8111501c:	df000017 	ldw	fp,0(sp)
81115020:	dec00204 	addi	sp,sp,8
81115024:	f800283a 	ret

81115028 <vPusMebInTaskRunningMode>:




/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115028:	defffc04 	addi	sp,sp,-16
8111502c:	de00012e 	bgeu	sp,et,81115034 <vPusMebInTaskRunningMode+0xc>
81115030:	003b68fa 	trap	3
81115034:	dfc00315 	stw	ra,12(sp)
81115038:	df000215 	stw	fp,8(sp)
8111503c:	df000204 	addi	fp,sp,8
81115040:	e13ffe15 	stw	r4,-8(fp)
81115044:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81115048:	e0bfff17 	ldw	r2,-4(fp)
8111504c:	1080030b 	ldhu	r2,12(r2)
81115050:	10bfffcc 	andi	r2,r2,65535
81115054:	10c03ee0 	cmpeqi	r3,r2,251
81115058:	1800081e 	bne	r3,zero,8111507c <vPusMebInTaskRunningMode+0x54>
8111505c:	10c03f20 	cmpeqi	r3,r2,252
81115060:	18000a1e 	bne	r3,zero,8111508c <vPusMebInTaskRunningMode+0x64>
81115064:	10803ea0 	cmpeqi	r2,r2,250
81115068:	10000c26 	beq	r2,zero,8111509c <vPusMebInTaskRunningMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250run(pxMebCLocal, xPusL);
8111506c:	e17fff17 	ldw	r5,-4(fp)
81115070:	e13ffe17 	ldw	r4,-8(fp)
81115074:	11150d40 	call	811150d4 <vPusType250run>
			break;
81115078:	00001006 	br	811150bc <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251run(pxMebCLocal, xPusL);
8111507c:	e17fff17 	ldw	r5,-4(fp)
81115080:	e13ffe17 	ldw	r4,-8(fp)
81115084:	11151600 	call	81115160 <vPusType251run>
			break;
81115088:	00000c06 	br	811150bc <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252run(pxMebCLocal, xPusL);
8111508c:	e17fff17 	ldw	r5,-4(fp)
81115090:	e13ffe17 	ldw	r4,-8(fp)
81115094:	11152740 	call	81115274 <vPusType252run>
			break;
81115098:	00000806 	br	811150bc <vPusMebInTaskRunningMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
8111509c:	d0a06117 	ldw	r2,-32380(gp)
811150a0:	100f883a 	mov	r7,r2
811150a4:	01800cc4 	movi	r6,51
811150a8:	01400044 	movi	r5,1
811150ac:	01204574 	movhi	r4,33045
811150b0:	21347104 	addi	r4,r4,-11836
811150b4:	1120e540 	call	81120e54 <fwrite>
			#endif
			break;
811150b8:	0001883a 	nop
	}
}
811150bc:	0001883a 	nop
811150c0:	e037883a 	mov	sp,fp
811150c4:	dfc00117 	ldw	ra,4(sp)
811150c8:	df000017 	ldw	fp,0(sp)
811150cc:	dec00204 	addi	sp,sp,8
811150d0:	f800283a 	ret

811150d4 <vPusType250run>:


void vPusType250run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811150d4:	defffc04 	addi	sp,sp,-16
811150d8:	de00012e 	bgeu	sp,et,811150e0 <vPusType250run+0xc>
811150dc:	003b68fa 	trap	3
811150e0:	dfc00315 	stw	ra,12(sp)
811150e4:	df000215 	stw	fp,8(sp)
811150e8:	df000204 	addi	fp,sp,8
811150ec:	e13ffe15 	stw	r4,-8(fp)
811150f0:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
811150f4:	e0bfff17 	ldw	r2,-4(fp)
811150f8:	1080038b 	ldhu	r2,14(r2)
811150fc:	10bfffcc 	andi	r2,r2,65535
81115100:	10c00f20 	cmpeqi	r3,r2,60
81115104:	1800031e 	bne	r3,zero,81115114 <vPusType250run+0x40>
81115108:	10800fa0 	cmpeqi	r2,r2,62
8111510c:	10000d1e 	bne	r2,zero,81115144 <vPusType250run+0x70>
81115110:	00000406 	br	81115124 <vPusType250run+0x50>
		/* TC_SCAM_CONFIG */
		case 60:
			pxMebCLocal->eMode = sMebToConfig;
81115114:	e0bffe17 	ldw	r2,-8(fp)
81115118:	00c00044 	movi	r3,1
8111511c:	10c00115 	stw	r3,4(r2)
			break;
81115120:	00000906 	br	81115148 <vPusType250run+0x74>
			break;
		/* TC_SCAM_RUN */
		case 61:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
81115124:	d0a06117 	ldw	r2,-32380(gp)
81115128:	100f883a 	mov	r7,r2
8111512c:	01800c84 	movi	r6,50
81115130:	01400044 	movi	r5,1
81115134:	01204574 	movhi	r4,33045
81115138:	21347e04 	addi	r4,r4,-11784
8111513c:	1120e540 	call	81120e54 <fwrite>
			#endif
			break;
81115140:	00000106 	br	81115148 <vPusType250run+0x74>
			pxMebCLocal->eMode = sMebToConfig;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81115144:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
81115148:	0001883a 	nop
8111514c:	e037883a 	mov	sp,fp
81115150:	dfc00117 	ldw	ra,4(sp)
81115154:	df000017 	ldw	fp,0(sp)
81115158:	dec00204 	addi	sp,sp,8
8111515c:	f800283a 	ret

81115160 <vPusType251run>:

void vPusType251run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115160:	defffb04 	addi	sp,sp,-20
81115164:	de00012e 	bgeu	sp,et,8111516c <vPusType251run+0xc>
81115168:	003b68fa 	trap	3
8111516c:	dfc00415 	stw	ra,16(sp)
81115170:	df000315 	stw	fp,12(sp)
81115174:	df000304 	addi	fp,sp,12
81115178:	e13ffe15 	stw	r4,-8(fp)
8111517c:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81115180:	e0bfff17 	ldw	r2,-4(fp)
81115184:	1080050b 	ldhu	r2,20(r2)
81115188:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
8111518c:	e0bfff17 	ldw	r2,-4(fp)
81115190:	1080038b 	ldhu	r2,14(r2)
81115194:	10bfffcc 	andi	r2,r2,65535
81115198:	10c000a0 	cmpeqi	r3,r2,2
8111519c:	18000f1e 	bne	r3,zero,811151dc <vPusType251run+0x7c>
811151a0:	10c00160 	cmpeqi	r3,r2,5
811151a4:	1800181e 	bne	r3,zero,81115208 <vPusType251run+0xa8>
811151a8:	10800060 	cmpeqi	r2,r2,1
811151ac:	10002126 	beq	r2,zero,81115234 <vPusType251run+0xd4>
		/* TC_SCAM_FEE_CONFIG_ENTER */
		case 1:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
811151b0:	e0bffd0b 	ldhu	r2,-12(fp)
811151b4:	10800444 	addi	r2,r2,17
811151b8:	10803fcc 	andi	r2,r2,255
811151bc:	e0fffd0b 	ldhu	r3,-12(fp)
811151c0:	18c03fcc 	andi	r3,r3,255
811151c4:	180f883a 	mov	r7,r3
811151c8:	000d883a 	mov	r6,zero
811151cc:	01400044 	movi	r5,1
811151d0:	1009883a 	mov	r4,r2
811151d4:	111570c0 	call	8111570c <vSendCmdQToNFeeCTRL_GEN>
			break;
811151d8:	00002006 	br	8111525c <vPusType251run+0xfc>
		/* TC_SCAM_FEE_STANDBY_ENTER */
		case 2:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
811151dc:	e0bffd0b 	ldhu	r2,-12(fp)
811151e0:	10800444 	addi	r2,r2,17
811151e4:	10803fcc 	andi	r2,r2,255
811151e8:	e0fffd0b 	ldhu	r3,-12(fp)
811151ec:	18c03fcc 	andi	r3,r3,255
811151f0:	180f883a 	mov	r7,r3
811151f4:	000d883a 	mov	r6,zero
811151f8:	01400104 	movi	r5,4
811151fc:	1009883a 	mov	r4,r2
81115200:	111570c0 	call	8111570c <vSendCmdQToNFeeCTRL_GEN>
			break;
81115204:	00001506 	br	8111525c <vPusType251run+0xfc>
		/* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
		case 5:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
81115208:	e0bffd0b 	ldhu	r2,-12(fp)
8111520c:	10800444 	addi	r2,r2,17
81115210:	10803fcc 	andi	r2,r2,255
81115214:	e0fffd0b 	ldhu	r3,-12(fp)
81115218:	18c03fcc 	andi	r3,r3,255
8111521c:	180f883a 	mov	r7,r3
81115220:	000d883a 	mov	r6,zero
81115224:	01400204 	movi	r5,8
81115228:	1009883a 	mov	r4,r2
8111522c:	111570c0 	call	8111570c <vSendCmdQToNFeeCTRL_GEN>
			break;
81115230:	00000a06 	br	8111525c <vPusType251run+0xfc>
		case 3:
		case 4:
		case 6:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
81115234:	d0e06117 	ldw	r3,-32380(gp)
81115238:	e0bfff17 	ldw	r2,-4(fp)
8111523c:	1080038b 	ldhu	r2,14(r2)
81115240:	10bfffcc 	andi	r2,r2,65535
81115244:	100d883a 	mov	r6,r2
81115248:	01604574 	movhi	r5,33045
8111524c:	29748b04 	addi	r5,r5,-11732
81115250:	1809883a 	mov	r4,r3
81115254:	11207b80 	call	811207b8 <fprintf>
			#endif
			break;
81115258:	0001883a 	nop
	}
}
8111525c:	0001883a 	nop
81115260:	e037883a 	mov	sp,fp
81115264:	dfc00117 	ldw	ra,4(sp)
81115268:	df000017 	ldw	fp,0(sp)
8111526c:	dec00204 	addi	sp,sp,8
81115270:	f800283a 	ret

81115274 <vPusType252run>:

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81115274:	defffb04 	addi	sp,sp,-20
81115278:	de00012e 	bgeu	sp,et,81115280 <vPusType252run+0xc>
8111527c:	003b68fa 	trap	3
81115280:	dfc00415 	stw	ra,16(sp)
81115284:	df000315 	stw	fp,12(sp)
81115288:	df000304 	addi	fp,sp,12
8111528c:	e13ffe15 	stw	r4,-8(fp)
81115290:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81115294:	e0bfff17 	ldw	r2,-4(fp)
81115298:	1080050b 	ldhu	r2,20(r2)
8111529c:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
811152a0:	e0bfff17 	ldw	r2,-4(fp)
811152a4:	1080038b 	ldhu	r2,14(r2)
811152a8:	10bfffcc 	andi	r2,r2,65535
811152ac:	10c000e0 	cmpeqi	r3,r2,3
811152b0:	18000a1e 	bne	r3,zero,811152dc <vPusType252run+0x68>
811152b4:	10c00108 	cmpgei	r3,r2,4
811152b8:	1800031e 	bne	r3,zero,811152c8 <vPusType252run+0x54>
811152bc:	108000a0 	cmpeqi	r2,r2,2
811152c0:	1000581e 	bne	r2,zero,81115424 <vPusType252run+0x1b0>
811152c4:	0000be06 	br	811155c0 <vPusType252run+0x34c>
811152c8:	10c00120 	cmpeqi	r3,r2,4
811152cc:	18002c1e 	bne	r3,zero,81115380 <vPusType252run+0x10c>
811152d0:	10800160 	cmpeqi	r2,r2,5
811152d4:	1000c21e 	bne	r2,zero,811155e0 <vPusType252run+0x36c>
811152d8:	0000b906 	br	811155c0 <vPusType252run+0x34c>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
811152dc:	e0bffd0b 	ldhu	r2,-12(fp)
811152e0:	10809624 	muli	r2,r2,600
811152e4:	10809b04 	addi	r2,r2,620
811152e8:	e0fffe17 	ldw	r3,-8(fp)
811152ec:	1885883a 	add	r2,r3,r2
811152f0:	1009883a 	mov	r4,r2
811152f4:	110a2c00 	call	8110a2c0 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
811152f8:	e0bffd0b 	ldhu	r2,-12(fp)
811152fc:	e0fffe17 	ldw	r3,-8(fp)
81115300:	10809624 	muli	r2,r2,600
81115304:	1885883a 	add	r2,r3,r2
81115308:	10809d04 	addi	r2,r2,628
8111530c:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
81115310:	e0bffd0b 	ldhu	r2,-12(fp)
81115314:	e0fffe17 	ldw	r3,-8(fp)
81115318:	10809624 	muli	r2,r2,600
8111531c:	1885883a 	add	r2,r3,r2
81115320:	10809c04 	addi	r2,r2,624
81115324:	00c00044 	movi	r3,1
81115328:	10c00015 	stw	r3,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
8111532c:	e0bffd0b 	ldhu	r2,-12(fp)
81115330:	e0fffe17 	ldw	r3,-8(fp)
81115334:	10809624 	muli	r2,r2,600
81115338:	1885883a 	add	r2,r3,r2
8111533c:	10809e04 	addi	r2,r2,632
81115340:	10000015 	stw	zero,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81115344:	e0bffd0b 	ldhu	r2,-12(fp)
81115348:	10809624 	muli	r2,r2,600
8111534c:	10809b04 	addi	r2,r2,620
81115350:	e0fffe17 	ldw	r3,-8(fp)
81115354:	1885883a 	add	r2,r3,r2
81115358:	1009883a 	mov	r4,r2
8111535c:	110a18c0 	call	8110a18c <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
81115360:	d0a06117 	ldw	r2,-32380(gp)
81115364:	e0fffd0b 	ldhu	r3,-12(fp)
81115368:	180d883a 	mov	r6,r3
8111536c:	01604574 	movhi	r5,33045
81115370:	29749904 	addi	r5,r5,-11676
81115374:	1009883a 	mov	r4,r2
81115378:	11207b80 	call	811207b8 <fprintf>
			#endif

			break;
8111537c:	00009906 	br	811155e4 <vPusType252run+0x370>

		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81115380:	e0bffd0b 	ldhu	r2,-12(fp)
81115384:	10809624 	muli	r2,r2,600
81115388:	10809b04 	addi	r2,r2,620
8111538c:	e0fffe17 	ldw	r3,-8(fp)
81115390:	1885883a 	add	r2,r3,r2
81115394:	1009883a 	mov	r4,r2
81115398:	110a2c00 	call	8110a2c0 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
8111539c:	e0bffd0b 	ldhu	r2,-12(fp)
811153a0:	e0fffe17 	ldw	r3,-8(fp)
811153a4:	10809624 	muli	r2,r2,600
811153a8:	1885883a 	add	r2,r3,r2
811153ac:	10809d04 	addi	r2,r2,628
811153b0:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
811153b4:	e0bffd0b 	ldhu	r2,-12(fp)
811153b8:	e0fffe17 	ldw	r3,-8(fp)
811153bc:	10809624 	muli	r2,r2,600
811153c0:	1885883a 	add	r2,r3,r2
811153c4:	10809c04 	addi	r2,r2,624
811153c8:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
811153cc:	e0bffd0b 	ldhu	r2,-12(fp)
811153d0:	e0fffe17 	ldw	r3,-8(fp)
811153d4:	10809624 	muli	r2,r2,600
811153d8:	1885883a 	add	r2,r3,r2
811153dc:	10809e04 	addi	r2,r2,632
811153e0:	00c00044 	movi	r3,1
811153e4:	10c00015 	stw	r3,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
811153e8:	e0bffd0b 	ldhu	r2,-12(fp)
811153ec:	10809624 	muli	r2,r2,600
811153f0:	10809b04 	addi	r2,r2,620
811153f4:	e0fffe17 	ldw	r3,-8(fp)
811153f8:	1885883a 	add	r2,r3,r2
811153fc:	1009883a 	mov	r4,r2
81115400:	110a18c0 	call	8110a18c <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
81115404:	d0a06117 	ldw	r2,-32380(gp)
81115408:	e0fffd0b 	ldhu	r3,-12(fp)
8111540c:	180d883a 	mov	r6,r3
81115410:	01604574 	movhi	r5,33045
81115414:	2974a204 	addi	r5,r5,-11640
81115418:	1009883a 	mov	r4,r2
8111541c:	11207b80 	call	811207b8 <fprintf>
			#endif

			break;
81115420:	00007006 	br	811155e4 <vPusType252run+0x370>
			break;

		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */
			if ( pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xControl.eMode == sFeeConfig ) {
81115424:	e0bffd0b 	ldhu	r2,-12(fp)
81115428:	e0fffe17 	ldw	r3,-8(fp)
8111542c:	10809624 	muli	r2,r2,600
81115430:	1885883a 	add	r2,r3,r2
81115434:	10803e04 	addi	r2,r2,248
81115438:	10800017 	ldw	r2,0(r2)
8111543c:	10800058 	cmpnei	r2,r2,1
81115440:	10004a1e 	bne	r2,zero,8111556c <vPusType252run+0x2f8>
				/* Disable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115444:	e0bffd0b 	ldhu	r2,-12(fp)
81115448:	10809624 	muli	r2,r2,600
8111544c:	10805504 	addi	r2,r2,340
81115450:	e0fffe17 	ldw	r3,-8(fp)
81115454:	1885883a 	add	r2,r3,r2
81115458:	1009883a 	mov	r4,r2
8111545c:	110793c0 	call	8110793c <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81115460:	e0bffd0b 	ldhu	r2,-12(fp)
81115464:	e0fffe17 	ldw	r3,-8(fp)
81115468:	10809624 	muli	r2,r2,600
8111546c:	1885883a 	add	r2,r3,r2
81115470:	10806504 	addi	r2,r2,404
81115474:	10000015 	stw	zero,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115478:	e0bffd0b 	ldhu	r2,-12(fp)
8111547c:	10809624 	muli	r2,r2,600
81115480:	10805504 	addi	r2,r2,340
81115484:	e0fffe17 	ldw	r3,-8(fp)
81115488:	1885883a 	add	r2,r3,r2
8111548c:	1009883a 	mov	r4,r2
81115490:	11078940 	call	81107894 <bRmapSetIrqControl>

				/* Change the configuration */
				bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81115494:	e0bffd0b 	ldhu	r2,-12(fp)
81115498:	10809624 	muli	r2,r2,600
8111549c:	10805504 	addi	r2,r2,340
811154a0:	e0fffe17 	ldw	r3,-8(fp)
811154a4:	1885883a 	add	r2,r3,r2
811154a8:	1009883a 	mov	r4,r2
811154ac:	1107b240 	call	81107b24 <bRmapGetCodecConfig>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
811154b0:	e0bffd0b 	ldhu	r2,-12(fp)
811154b4:	e0ffff17 	ldw	r3,-4(fp)
811154b8:	18c00b0b 	ldhu	r3,44(r3)
811154bc:	1809883a 	mov	r4,r3
811154c0:	e0fffe17 	ldw	r3,-8(fp)
811154c4:	10809624 	muli	r2,r2,600
811154c8:	1885883a 	add	r2,r3,r2
811154cc:	10805604 	addi	r2,r2,344
811154d0:	11000005 	stb	r4,0(r2)
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
811154d4:	e0bffd0b 	ldhu	r2,-12(fp)
811154d8:	e0ffff17 	ldw	r3,-4(fp)
811154dc:	18c0098b 	ldhu	r3,38(r3)
811154e0:	1809883a 	mov	r4,r3
811154e4:	e0fffe17 	ldw	r3,-8(fp)
811154e8:	10809624 	muli	r2,r2,600
811154ec:	1885883a 	add	r2,r3,r2
811154f0:	10805644 	addi	r2,r2,345
811154f4:	11000005 	stb	r4,0(r2)
				bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
811154f8:	e0bffd0b 	ldhu	r2,-12(fp)
811154fc:	10809624 	muli	r2,r2,600
81115500:	10805504 	addi	r2,r2,340
81115504:	e0fffe17 	ldw	r3,-8(fp)
81115508:	1885883a 	add	r2,r3,r2
8111550c:	1009883a 	mov	r4,r2
81115510:	1107a4c0 	call	81107a4c <bRmapSetCodecConfig>


				/* Enable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81115514:	e0bffd0b 	ldhu	r2,-12(fp)
81115518:	10809624 	muli	r2,r2,600
8111551c:	10805504 	addi	r2,r2,340
81115520:	e0fffe17 	ldw	r3,-8(fp)
81115524:	1885883a 	add	r2,r3,r2
81115528:	1009883a 	mov	r4,r2
8111552c:	110793c0 	call	8110793c <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81115530:	e0bffd0b 	ldhu	r2,-12(fp)
81115534:	e0fffe17 	ldw	r3,-8(fp)
81115538:	10809624 	muli	r2,r2,600
8111553c:	1885883a 	add	r2,r3,r2
81115540:	10806504 	addi	r2,r2,404
81115544:	00c00044 	movi	r3,1
81115548:	10c00015 	stw	r3,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
8111554c:	e0bffd0b 	ldhu	r2,-12(fp)
81115550:	10809624 	muli	r2,r2,600
81115554:	10805504 	addi	r2,r2,340
81115558:	e0fffe17 	ldw	r3,-8(fp)
8111555c:	1885883a 	add	r2,r3,r2
81115560:	1009883a 	mov	r4,r2
81115564:	11078940 	call	81107894 <bRmapSetIrqControl>
81115568:	00000706 	br	81115588 <vPusType252run+0x314>
			} else {
				#ifdef DEBUG_ON
					fprintf(fp,"MEB Task: NFEE-%hu is not in the Config Mode ( Changes not performed )\n\n", usiFeeInstL);
8111556c:	d0a06117 	ldw	r2,-32380(gp)
81115570:	e0fffd0b 	ldhu	r3,-12(fp)
81115574:	180d883a 	mov	r6,r3
81115578:	01604574 	movhi	r5,33045
8111557c:	2974ab04 	addi	r5,r5,-11604
81115580:	1009883a 	mov	r4,r2
81115584:	11207b80 	call	811207b8 <fprintf>
				#endif
			}

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81115588:	d0e06117 	ldw	r3,-32380(gp)
8111558c:	e0bfff17 	ldw	r2,-4(fp)
81115590:	10800b0b 	ldhu	r2,44(r2)
81115594:	113fffcc 	andi	r4,r2,65535
81115598:	e0bfff17 	ldw	r2,-4(fp)
8111559c:	1080098b 	ldhu	r2,38(r2)
811155a0:	10bfffcc 	andi	r2,r2,65535
811155a4:	100f883a 	mov	r7,r2
811155a8:	200d883a 	mov	r6,r4
811155ac:	01604574 	movhi	r5,33045
811155b0:	29746104 	addi	r5,r5,-11900
811155b4:	1809883a 	mov	r4,r3
811155b8:	11207b80 	call	811207b8 <fprintf>
			#endif
			break;
811155bc:	00000906 	br	811155e4 <vPusType252run+0x370>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
811155c0:	d0a06117 	ldw	r2,-32380(gp)
811155c4:	100f883a 	mov	r7,r2
811155c8:	01800c84 	movi	r6,50
811155cc:	01400044 	movi	r5,1
811155d0:	01204574 	movhi	r4,33045
811155d4:	21347e04 	addi	r4,r4,-11784
811155d8:	1120e540 	call	81120e54 <fwrite>
			#endif
			break;
811155dc:	00000106 	br	811155e4 <vPusType252run+0x370>

			break;

		case 5: /* TC_SCAM_SPW_LINK_RESET */
			/* todo:Do nothing, don't know what is reset spw link */
			break;
811155e0:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
811155e4:	0001883a 	nop
811155e8:	e037883a 	mov	sp,fp
811155ec:	dfc00117 	ldw	ra,4(sp)
811155f0:	df000017 	ldw	fp,0(sp)
811155f4:	dec00204 	addi	sp,sp,8
811155f8:	f800283a 	ret

811155fc <vSendCmdQToNFeeCTRL>:



void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811155fc:	defff904 	addi	sp,sp,-28
81115600:	de00012e 	bgeu	sp,et,81115608 <vSendCmdQToNFeeCTRL+0xc>
81115604:	003b68fa 	trap	3
81115608:	dfc00615 	stw	ra,24(sp)
8111560c:	df000515 	stw	fp,20(sp)
81115610:	df000504 	addi	fp,sp,20
81115614:	2807883a 	mov	r3,r5
81115618:	3005883a 	mov	r2,r6
8111561c:	e13ffd05 	stb	r4,-12(fp)
81115620:	e0fffe05 	stb	r3,-8(fp)
81115624:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81115628:	00800404 	movi	r2,16
8111562c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81115630:	e0bffd03 	ldbu	r2,-12(fp)
81115634:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81115638:	e0bffe03 	ldbu	r2,-8(fp)
8111563c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81115640:	e0bfff03 	ldbu	r2,-4(fp)
81115644:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81115648:	d0a06f17 	ldw	r2,-32324(gp)
8111564c:	e0fffc17 	ldw	r3,-16(fp)
81115650:	180b883a 	mov	r5,r3
81115654:	1009883a 	mov	r4,r2
81115658:	113d1e40 	call	8113d1e4 <OSQPost>
8111565c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81115660:	e0bffb03 	ldbu	r2,-20(fp)
81115664:	10000126 	beq	r2,zero,8111566c <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
81115668:	111c8440 	call	8111c844 <vFailSendMsgFeeCTRL>
	}
}
8111566c:	0001883a 	nop
81115670:	e037883a 	mov	sp,fp
81115674:	dfc00117 	ldw	ra,4(sp)
81115678:	df000017 	ldw	fp,0(sp)
8111567c:	dec00204 	addi	sp,sp,8
81115680:	f800283a 	ret

81115684 <vSendCmdQToNFeeCTRL_PRIO>:

void vSendCmdQToNFeeCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81115684:	defff904 	addi	sp,sp,-28
81115688:	de00012e 	bgeu	sp,et,81115690 <vSendCmdQToNFeeCTRL_PRIO+0xc>
8111568c:	003b68fa 	trap	3
81115690:	dfc00615 	stw	ra,24(sp)
81115694:	df000515 	stw	fp,20(sp)
81115698:	df000504 	addi	fp,sp,20
8111569c:	2807883a 	mov	r3,r5
811156a0:	3005883a 	mov	r2,r6
811156a4:	e13ffd05 	stb	r4,-12(fp)
811156a8:	e0fffe05 	stb	r3,-8(fp)
811156ac:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811156b0:	00800404 	movi	r2,16
811156b4:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811156b8:	e0bffd03 	ldbu	r2,-12(fp)
811156bc:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811156c0:	e0bffe03 	ldbu	r2,-8(fp)
811156c4:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811156c8:	e0bfff03 	ldbu	r2,-4(fp)
811156cc:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPostFront(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
811156d0:	d0a06f17 	ldw	r2,-32324(gp)
811156d4:	e0fffc17 	ldw	r3,-16(fp)
811156d8:	180b883a 	mov	r5,r3
811156dc:	1009883a 	mov	r4,r2
811156e0:	113d3540 	call	8113d354 <OSQPostFront>
811156e4:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
811156e8:	e0bffb03 	ldbu	r2,-20(fp)
811156ec:	10000126 	beq	r2,zero,811156f4 <vSendCmdQToNFeeCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
811156f0:	111c8440 	call	8111c844 <vFailSendMsgFeeCTRL>
	}
}
811156f4:	0001883a 	nop
811156f8:	e037883a 	mov	sp,fp
811156fc:	dfc00117 	ldw	ra,4(sp)
81115700:	df000017 	ldw	fp,0(sp)
81115704:	dec00204 	addi	sp,sp,8
81115708:	f800283a 	ret

8111570c <vSendCmdQToNFeeCTRL_GEN>:


/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8111570c:	defff804 	addi	sp,sp,-32
81115710:	de00012e 	bgeu	sp,et,81115718 <vSendCmdQToNFeeCTRL_GEN+0xc>
81115714:	003b68fa 	trap	3
81115718:	dfc00715 	stw	ra,28(sp)
8111571c:	df000615 	stw	fp,24(sp)
81115720:	df000604 	addi	fp,sp,24
81115724:	2011883a 	mov	r8,r4
81115728:	2809883a 	mov	r4,r5
8111572c:	3007883a 	mov	r3,r6
81115730:	3805883a 	mov	r2,r7
81115734:	e23ffc05 	stb	r8,-16(fp)
81115738:	e13ffd05 	stb	r4,-12(fp)
8111573c:	e0fffe05 	stb	r3,-8(fp)
81115740:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
81115744:	e0bffc03 	ldbu	r2,-16(fp)
81115748:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8111574c:	e0bffd03 	ldbu	r2,-12(fp)
81115750:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81115754:	e0bffe03 	ldbu	r2,-8(fp)
81115758:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8111575c:	e0bfff03 	ldbu	r2,-4(fp)
81115760:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81115764:	d0a06f17 	ldw	r2,-32324(gp)
81115768:	e0fffb17 	ldw	r3,-20(fp)
8111576c:	180b883a 	mov	r5,r3
81115770:	1009883a 	mov	r4,r2
81115774:	113d1e40 	call	8113d1e4 <OSQPost>
81115778:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
8111577c:	e0bffa03 	ldbu	r2,-24(fp)
81115780:	10000126 	beq	r2,zero,81115788 <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
81115784:	111c8440 	call	8111c844 <vFailSendMsgFeeCTRL>
	}
}
81115788:	0001883a 	nop
8111578c:	e037883a 	mov	sp,fp
81115790:	dfc00117 	ldw	ra,4(sp)
81115794:	df000017 	ldw	fp,0(sp)
81115798:	dec00204 	addi	sp,sp,8
8111579c:	f800283a 	ret

811157a0 <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811157a0:	defff904 	addi	sp,sp,-28
811157a4:	de00012e 	bgeu	sp,et,811157ac <vSendCmdQToDataCTRL+0xc>
811157a8:	003b68fa 	trap	3
811157ac:	dfc00615 	stw	ra,24(sp)
811157b0:	df000515 	stw	fp,20(sp)
811157b4:	df000504 	addi	fp,sp,20
811157b8:	2807883a 	mov	r3,r5
811157bc:	3005883a 	mov	r2,r6
811157c0:	e13ffd05 	stb	r4,-12(fp)
811157c4:	e0fffe05 	stb	r3,-8(fp)
811157c8:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
811157cc:	00800804 	movi	r2,32
811157d0:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811157d4:	e0bffd03 	ldbu	r2,-12(fp)
811157d8:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811157dc:	e0bffe03 	ldbu	r2,-8(fp)
811157e0:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811157e4:	e0bfff03 	ldbu	r2,-4(fp)
811157e8:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
811157ec:	d0a05e17 	ldw	r2,-32392(gp)
811157f0:	e0fffc17 	ldw	r3,-16(fp)
811157f4:	180b883a 	mov	r5,r3
811157f8:	1009883a 	mov	r4,r2
811157fc:	113d1e40 	call	8113d1e4 <OSQPost>
81115800:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81115804:	e0bffb03 	ldbu	r2,-20(fp)
81115808:	10000126 	beq	r2,zero,81115810 <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgDataCTRL();
8111580c:	111c8900 	call	8111c890 <vFailSendMsgDataCTRL>
	}
}
81115810:	0001883a 	nop
81115814:	e037883a 	mov	sp,fp
81115818:	dfc00117 	ldw	ra,4(sp)
8111581c:	df000017 	ldw	fp,0(sp)
81115820:	dec00204 	addi	sp,sp,8
81115824:	f800283a 	ret

81115828 <vSendCmdQToDataCTRL_PRIO>:

void vSendCmdQToDataCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81115828:	defff904 	addi	sp,sp,-28
8111582c:	de00012e 	bgeu	sp,et,81115834 <vSendCmdQToDataCTRL_PRIO+0xc>
81115830:	003b68fa 	trap	3
81115834:	dfc00615 	stw	ra,24(sp)
81115838:	df000515 	stw	fp,20(sp)
8111583c:	df000504 	addi	fp,sp,20
81115840:	2807883a 	mov	r3,r5
81115844:	3005883a 	mov	r2,r6
81115848:	e13ffd05 	stb	r4,-12(fp)
8111584c:	e0fffe05 	stb	r3,-8(fp)
81115850:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81115854:	00800404 	movi	r2,16
81115858:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8111585c:	e0bffd03 	ldbu	r2,-12(fp)
81115860:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81115864:	e0bffe03 	ldbu	r2,-8(fp)
81115868:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8111586c:	e0bfff03 	ldbu	r2,-4(fp)
81115870:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPostFront(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81115874:	d0a05e17 	ldw	r2,-32392(gp)
81115878:	e0fffc17 	ldw	r3,-16(fp)
8111587c:	180b883a 	mov	r5,r3
81115880:	1009883a 	mov	r4,r2
81115884:	113d3540 	call	8113d354 <OSQPostFront>
81115888:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8111588c:	e0bffb03 	ldbu	r2,-20(fp)
81115890:	10000126 	beq	r2,zero,81115898 <vSendCmdQToDataCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81115894:	111c8440 	call	8111c844 <vFailSendMsgFeeCTRL>
	}
}
81115898:	0001883a 	nop
8111589c:	e037883a 	mov	sp,fp
811158a0:	dfc00117 	ldw	ra,4(sp)
811158a4:	df000017 	ldw	fp,0(sp)
811158a8:	dec00204 	addi	sp,sp,8
811158ac:	f800283a 	ret

811158b0 <vMebInit>:


void vMebInit(TSimucam_MEB *pxMebCLocal) {
811158b0:	defffc04 	addi	sp,sp,-16
811158b4:	de00012e 	bgeu	sp,et,811158bc <vMebInit+0xc>
811158b8:	003b68fa 	trap	3
811158bc:	dfc00315 	stw	ra,12(sp)
811158c0:	df000215 	stw	fp,8(sp)
811158c4:	df000204 	addi	fp,sp,8
811158c8:	e13fff15 	stw	r4,-4(fp)
	INT8U errorCodeL;

	pxMebCLocal->ucActualDDR = 0;
811158cc:	e0bfff17 	ldw	r2,-4(fp)
811158d0:	10000205 	stb	zero,8(r2)
	pxMebCLocal->ucNextDDR = 1;
811158d4:	e0bfff17 	ldw	r2,-4(fp)
811158d8:	00c00044 	movi	r3,1
811158dc:	10c00245 	stb	r3,9(r2)
	/* Flush all communication Queues */
	errorCodeL = OSQFlush(xMebQ);
811158e0:	d0a06817 	ldw	r2,-32352(gp)
811158e4:	1009883a 	mov	r4,r2
811158e8:	113cd1c0 	call	8113cd1c <OSQFlush>
811158ec:	e0bffe05 	stb	r2,-8(fp)
	if ( errorCodeL != OS_NO_ERR ) {
811158f0:	e0bffe03 	ldbu	r2,-8(fp)
811158f4:	10000126 	beq	r2,zero,811158fc <vMebInit+0x4c>
		vFailFlushMEBQueue();
811158f8:	111c9740 	call	8111c974 <vFailFlushMEBQueue>
	}
}
811158fc:	0001883a 	nop
81115900:	e037883a 	mov	sp,fp
81115904:	dfc00117 	ldw	ra,4(sp)
81115908:	df000017 	ldw	fp,0(sp)
8111590c:	dec00204 	addi	sp,sp,8
81115910:	f800283a 	ret

81115914 <vSwapMemmory>:

/* Swap memory reference */
void vSwapMemmory(TSimucam_MEB *pxMebCLocal) {
81115914:	defffe04 	addi	sp,sp,-8
81115918:	de00012e 	bgeu	sp,et,81115920 <vSwapMemmory+0xc>
8111591c:	003b68fa 	trap	3
81115920:	df000115 	stw	fp,4(sp)
81115924:	df000104 	addi	fp,sp,4
81115928:	e13fff15 	stw	r4,-4(fp)

	pxMebCLocal->ucActualDDR = (pxMebCLocal->ucActualDDR + 1) % 2 ;
8111592c:	e0bfff17 	ldw	r2,-4(fp)
81115930:	10800203 	ldbu	r2,8(r2)
81115934:	10803fcc 	andi	r2,r2,255
81115938:	10c00044 	addi	r3,r2,1
8111593c:	00a00034 	movhi	r2,32768
81115940:	10800044 	addi	r2,r2,1
81115944:	1884703a 	and	r2,r3,r2
81115948:	1000040e 	bge	r2,zero,8111595c <vSwapMemmory+0x48>
8111594c:	10bfffc4 	addi	r2,r2,-1
81115950:	00ffff84 	movi	r3,-2
81115954:	10c4b03a 	or	r2,r2,r3
81115958:	10800044 	addi	r2,r2,1
8111595c:	1007883a 	mov	r3,r2
81115960:	e0bfff17 	ldw	r2,-4(fp)
81115964:	10c00205 	stb	r3,8(r2)
	pxMebCLocal->ucNextDDR = (pxMebCLocal->ucNextDDR + 1) % 2 ;
81115968:	e0bfff17 	ldw	r2,-4(fp)
8111596c:	10800243 	ldbu	r2,9(r2)
81115970:	10803fcc 	andi	r2,r2,255
81115974:	10c00044 	addi	r3,r2,1
81115978:	00a00034 	movhi	r2,32768
8111597c:	10800044 	addi	r2,r2,1
81115980:	1884703a 	and	r2,r3,r2
81115984:	1000040e 	bge	r2,zero,81115998 <vSwapMemmory+0x84>
81115988:	10bfffc4 	addi	r2,r2,-1
8111598c:	00ffff84 	movi	r3,-2
81115990:	10c4b03a 	or	r2,r2,r3
81115994:	10800044 	addi	r2,r2,1
81115998:	1007883a 	mov	r3,r2
8111599c:	e0bfff17 	ldw	r2,-4(fp)
811159a0:	10c00245 	stb	r3,9(r2)

}
811159a4:	0001883a 	nop
811159a8:	e037883a 	mov	sp,fp
811159ac:	df000017 	ldw	fp,0(sp)
811159b0:	dec00104 	addi	sp,sp,4
811159b4:	f800283a 	ret

811159b8 <vReleaseSyncMessages>:

/* After stop the Sync signal generation, maybe some FEE task could be locked waiting for this signal. So we send to everyone, and after that they will flush the queue */
void vReleaseSyncMessages(void) {
811159b8:	defffc04 	addi	sp,sp,-16
811159bc:	de00012e 	bgeu	sp,et,811159c4 <vReleaseSyncMessages+0xc>
811159c0:	003b68fa 	trap	3
811159c4:	dfc00315 	stw	ra,12(sp)
811159c8:	df000215 	stw	fp,8(sp)
811159cc:	df000204 	addi	fp,sp,8
	unsigned char ucIL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ulWord = 0;
811159d0:	e03fff15 	stw	zero,-4(fp)
	uiCmdtoSend.ucByte[2] = M_SYNC;
811159d4:	00bff844 	movi	r2,-31
811159d8:	e0bfff85 	stb	r2,-2(fp)
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
811159dc:	e03ffe05 	stb	zero,-8(fp)
811159e0:	00001606 	br	81115a3c <vReleaseSyncMessages+0x84>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
811159e4:	e0bffe03 	ldbu	r2,-8(fp)
811159e8:	10800444 	addi	r2,r2,17
811159ec:	e0bfffc5 	stb	r2,-1(fp)
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
811159f0:	e0bffe03 	ldbu	r2,-8(fp)
811159f4:	1085883a 	add	r2,r2,r2
811159f8:	1087883a 	add	r3,r2,r2
811159fc:	d0a05b04 	addi	r2,gp,-32404
81115a00:	1885883a 	add	r2,r3,r2
81115a04:	10800017 	ldw	r2,0(r2)
81115a08:	e0ffff17 	ldw	r3,-4(fp)
81115a0c:	180b883a 	mov	r5,r3
81115a10:	1009883a 	mov	r4,r2
81115a14:	113d1e40 	call	8113d1e4 <OSQPost>
81115a18:	e0bffe45 	stb	r2,-7(fp)
		if ( error_codel != OS_ERR_NONE ) {
81115a1c:	e0bffe43 	ldbu	r2,-7(fp)
81115a20:	10000326 	beq	r2,zero,81115a30 <vReleaseSyncMessages+0x78>
			vFailSendMsgSync( ucIL );
81115a24:	e0bffe03 	ldbu	r2,-8(fp)
81115a28:	1009883a 	mov	r4,r2
81115a2c:	111c7500 	call	8111c750 <vFailSendMsgSync>

	uiCmdtoSend.ulWord = 0;
	uiCmdtoSend.ucByte[2] = M_SYNC;
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81115a30:	e0bffe03 	ldbu	r2,-8(fp)
81115a34:	10800044 	addi	r2,r2,1
81115a38:	e0bffe05 	stb	r2,-8(fp)
81115a3c:	e0bffe03 	ldbu	r2,-8(fp)
81115a40:	103fe826 	beq	r2,zero,811159e4 <__reset+0xfb0f59e4>
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}
}
81115a44:	0001883a 	nop
81115a48:	e037883a 	mov	sp,fp
81115a4c:	dfc00117 	ldw	ra,4(sp)
81115a50:	df000017 	ldw	fp,0(sp)
81115a54:	dec00204 	addi	sp,sp,8
81115a58:	f800283a 	ret

81115a5c <vStackMonitor>:
    }
}

#else
#ifdef DEBUG_ON
void vStackMonitor(void *task_data) {
81115a5c:	defff804 	addi	sp,sp,-32
81115a60:	de00012e 	bgeu	sp,et,81115a68 <vStackMonitor+0xc>
81115a64:	003b68fa 	trap	3
81115a68:	dfc00715 	stw	ra,28(sp)
81115a6c:	df000615 	stw	fp,24(sp)
81115a70:	df000604 	addi	fp,sp,24
81115a74:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81115a78:	e03ffc05 	stb	zero,-16(fp)
	OS_STK_DATA data;


        debug(fp,"vStackMonitor, enter task.\n");
81115a7c:	d0a06117 	ldw	r2,-32380(gp)
81115a80:	100f883a 	mov	r7,r2
81115a84:	018006c4 	movi	r6,27
81115a88:	01400044 	movi	r5,1
81115a8c:	01204574 	movhi	r4,33045
81115a90:	2134be04 	addi	r4,r4,-11528
81115a94:	1120e540 	call	81120e54 <fwrite>


    for (;;) {

    	fprintf(fp, "=========== STACK MONITOR =================\n" );
81115a98:	d0a06117 	ldw	r2,-32380(gp)
81115a9c:	100f883a 	mov	r7,r2
81115aa0:	01800b04 	movi	r6,44
81115aa4:	01400044 	movi	r5,1
81115aa8:	01204574 	movhi	r4,33045
81115aac:	2134c504 	addi	r4,r4,-11500
81115ab0:	1120e540 	call	81120e54 <fwrite>
    	fprintf(fp, " Task           Total               Free             In use  \n" );
81115ab4:	d0a06117 	ldw	r2,-32380(gp)
81115ab8:	100f883a 	mov	r7,r2
81115abc:	01800f84 	movi	r6,62
81115ac0:	01400044 	movi	r5,1
81115ac4:	01204574 	movhi	r4,33045
81115ac8:	2134d104 	addi	r4,r4,-11452
81115acc:	1120e540 	call	81120e54 <fwrite>

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
81115ad0:	e0bffd04 	addi	r2,fp,-12
81115ad4:	100b883a 	mov	r5,r2
81115ad8:	01000804 	movi	r4,32
81115adc:	113f6080 	call	8113f608 <OSTaskStkChk>
81115ae0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE ) {
81115ae4:	e0bffc03 	ldbu	r2,-16(fp)
81115ae8:	10000f1e 	bne	r2,zero,81115b28 <vStackMonitor+0xcc>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115aec:	d1206117 	ldw	r4,-32380(gp)
    				"RECEIVER_TASK",
    				data.OSFree + data.OSUsed,
81115af0:	e0fffd17 	ldw	r3,-12(fp)
81115af4:	e0bffe17 	ldw	r2,-8(fp)
    	fprintf(fp, " Task           Total               Free             In use  \n" );

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115af8:	188b883a 	add	r5,r3,r2
81115afc:	e0bffd17 	ldw	r2,-12(fp)
81115b00:	e0fffe17 	ldw	r3,-8(fp)
81115b04:	d8c00115 	stw	r3,4(sp)
81115b08:	d8800015 	stw	r2,0(sp)
81115b0c:	280f883a 	mov	r7,r5
81115b10:	01a04574 	movhi	r6,33045
81115b14:	31b4e104 	addi	r6,r6,-11388
81115b18:	01604574 	movhi	r5,33045
81115b1c:	2974e504 	addi	r5,r5,-11372
81115b20:	11207b80 	call	811207b8 <fprintf>
81115b24:	00000706 	br	81115b44 <vStackMonitor+0xe8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get RECEIVER_TASK stack \n" );
81115b28:	d0a06117 	ldw	r2,-32380(gp)
81115b2c:	100f883a 	mov	r7,r2
81115b30:	01800904 	movi	r6,36
81115b34:	01400044 	movi	r5,1
81115b38:	01204574 	movhi	r4,33045
81115b3c:	2134f404 	addi	r4,r4,-11312
81115b40:	1120e540 	call	81120e54 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
81115b44:	e0bffd04 	addi	r2,fp,-12
81115b48:	100b883a 	mov	r5,r2
81115b4c:	01000784 	movi	r4,30
81115b50:	113f6080 	call	8113f608 <OSTaskStkChk>
81115b54:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81115b58:	e0bffc03 	ldbu	r2,-16(fp)
81115b5c:	10000f1e 	bne	r2,zero,81115b9c <vStackMonitor+0x140>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115b60:	d1206117 	ldw	r4,-32380(gp)
    				"TIMEOUT_CHECKER",
    				data.OSFree + data.OSUsed,
81115b64:	e0fffd17 	ldw	r3,-12(fp)
81115b68:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115b6c:	188b883a 	add	r5,r3,r2
81115b70:	e0bffd17 	ldw	r2,-12(fp)
81115b74:	e0fffe17 	ldw	r3,-8(fp)
81115b78:	d8c00115 	stw	r3,4(sp)
81115b7c:	d8800015 	stw	r2,0(sp)
81115b80:	280f883a 	mov	r7,r5
81115b84:	01a04574 	movhi	r6,33045
81115b88:	31b4fe04 	addi	r6,r6,-11272
81115b8c:	01604574 	movhi	r5,33045
81115b90:	2974e504 	addi	r5,r5,-11372
81115b94:	11207b80 	call	811207b8 <fprintf>
81115b98:	00000706 	br	81115bb8 <vStackMonitor+0x15c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get TIMEOUT_CHECKER stack \n" );
81115b9c:	d0a06117 	ldw	r2,-32380(gp)
81115ba0:	100f883a 	mov	r7,r2
81115ba4:	01800984 	movi	r6,38
81115ba8:	01400044 	movi	r5,1
81115bac:	01204574 	movhi	r4,33045
81115bb0:	21350204 	addi	r4,r4,-11256
81115bb4:	1120e540 	call	81120e54 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
81115bb8:	e0bffd04 	addi	r2,fp,-12
81115bbc:	100b883a 	mov	r5,r2
81115bc0:	01000704 	movi	r4,28
81115bc4:	113f6080 	call	8113f608 <OSTaskStkChk>
81115bc8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81115bcc:	e0bffc03 	ldbu	r2,-16(fp)
81115bd0:	10000f1e 	bne	r2,zero,81115c10 <vStackMonitor+0x1b4>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115bd4:	d1206117 	ldw	r4,-32380(gp)
    				"PARSER_TASK",
    				data.OSFree + data.OSUsed,
81115bd8:	e0fffd17 	ldw	r3,-12(fp)
81115bdc:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115be0:	188b883a 	add	r5,r3,r2
81115be4:	e0bffd17 	ldw	r2,-12(fp)
81115be8:	e0fffe17 	ldw	r3,-8(fp)
81115bec:	d8c00115 	stw	r3,4(sp)
81115bf0:	d8800015 	stw	r2,0(sp)
81115bf4:	280f883a 	mov	r7,r5
81115bf8:	01a04574 	movhi	r6,33045
81115bfc:	31b50c04 	addi	r6,r6,-11216
81115c00:	01604574 	movhi	r5,33045
81115c04:	2974e504 	addi	r5,r5,-11372
81115c08:	11207b80 	call	811207b8 <fprintf>
81115c0c:	00000706 	br	81115c2c <vStackMonitor+0x1d0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get PARSER_TASK stack \n" );
81115c10:	d0a06117 	ldw	r2,-32380(gp)
81115c14:	100f883a 	mov	r7,r2
81115c18:	01800884 	movi	r6,34
81115c1c:	01400044 	movi	r5,1
81115c20:	01204574 	movhi	r4,33045
81115c24:	21350f04 	addi	r4,r4,-11204
81115c28:	1120e540 	call	81120e54 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
81115c2c:	e0bffd04 	addi	r2,fp,-12
81115c30:	100b883a 	mov	r5,r2
81115c34:	010006c4 	movi	r4,27
81115c38:	113f6080 	call	8113f608 <OSTaskStkChk>
81115c3c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81115c40:	e0bffc03 	ldbu	r2,-16(fp)
81115c44:	10000f1e 	bne	r2,zero,81115c84 <vStackMonitor+0x228>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115c48:	d1206117 	ldw	r4,-32380(gp)
    				"OUT_ACK_TASK",
    				data.OSFree + data.OSUsed,
81115c4c:	e0fffd17 	ldw	r3,-12(fp)
81115c50:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115c54:	188b883a 	add	r5,r3,r2
81115c58:	e0bffd17 	ldw	r2,-12(fp)
81115c5c:	e0fffe17 	ldw	r3,-8(fp)
81115c60:	d8c00115 	stw	r3,4(sp)
81115c64:	d8800015 	stw	r2,0(sp)
81115c68:	280f883a 	mov	r7,r5
81115c6c:	01a04574 	movhi	r6,33045
81115c70:	31b51804 	addi	r6,r6,-11168
81115c74:	01604574 	movhi	r5,33045
81115c78:	2974e504 	addi	r5,r5,-11372
81115c7c:	11207b80 	call	811207b8 <fprintf>
81115c80:	00000706 	br	81115ca0 <vStackMonitor+0x244>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get OUT_ACK_TASK stack \n" );
81115c84:	d0a06117 	ldw	r2,-32380(gp)
81115c88:	100f883a 	mov	r7,r2
81115c8c:	018008c4 	movi	r6,35
81115c90:	01400044 	movi	r5,1
81115c94:	01204574 	movhi	r4,33045
81115c98:	21351c04 	addi	r4,r4,-11152
81115c9c:	1120e540 	call	81120e54 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
81115ca0:	e0bffd04 	addi	r2,fp,-12
81115ca4:	100b883a 	mov	r5,r2
81115ca8:	01000684 	movi	r4,26
81115cac:	113f6080 	call	8113f608 <OSTaskStkChk>
81115cb0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81115cb4:	e0bffc03 	ldbu	r2,-16(fp)
81115cb8:	10000f1e 	bne	r2,zero,81115cf8 <vStackMonitor+0x29c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115cbc:	d1206117 	ldw	r4,-32380(gp)
    				"SENDER_TASK",
    				data.OSFree + data.OSUsed,
81115cc0:	e0fffd17 	ldw	r3,-12(fp)
81115cc4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115cc8:	188b883a 	add	r5,r3,r2
81115ccc:	e0bffd17 	ldw	r2,-12(fp)
81115cd0:	e0fffe17 	ldw	r3,-8(fp)
81115cd4:	d8c00115 	stw	r3,4(sp)
81115cd8:	d8800015 	stw	r2,0(sp)
81115cdc:	280f883a 	mov	r7,r5
81115ce0:	01a04574 	movhi	r6,33045
81115ce4:	31b52504 	addi	r6,r6,-11116
81115ce8:	01604574 	movhi	r5,33045
81115cec:	2974e504 	addi	r5,r5,-11372
81115cf0:	11207b80 	call	811207b8 <fprintf>
81115cf4:	00000706 	br	81115d14 <vStackMonitor+0x2b8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get SENDER_TASK stack \n" );
81115cf8:	d0a06117 	ldw	r2,-32380(gp)
81115cfc:	100f883a 	mov	r7,r2
81115d00:	01800884 	movi	r6,34
81115d04:	01400044 	movi	r5,1
81115d08:	01204574 	movhi	r4,33045
81115d0c:	21352804 	addi	r4,r4,-11104
81115d10:	1120e540 	call	81120e54 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
81115d14:	e0bffd04 	addi	r2,fp,-12
81115d18:	100b883a 	mov	r5,r2
81115d1c:	01000644 	movi	r4,25
81115d20:	113f6080 	call	8113f608 <OSTaskStkChk>
81115d24:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81115d28:	e0bffc03 	ldbu	r2,-16(fp)
81115d2c:	10000f1e 	bne	r2,zero,81115d6c <vStackMonitor+0x310>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115d30:	d1206117 	ldw	r4,-32380(gp)
    				"IN_ACK_TASK",
    				data.OSFree + data.OSUsed,
81115d34:	e0fffd17 	ldw	r3,-12(fp)
81115d38:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115d3c:	188b883a 	add	r5,r3,r2
81115d40:	e0bffd17 	ldw	r2,-12(fp)
81115d44:	e0fffe17 	ldw	r3,-8(fp)
81115d48:	d8c00115 	stw	r3,4(sp)
81115d4c:	d8800015 	stw	r2,0(sp)
81115d50:	280f883a 	mov	r7,r5
81115d54:	01a04574 	movhi	r6,33045
81115d58:	31b53104 	addi	r6,r6,-11068
81115d5c:	01604574 	movhi	r5,33045
81115d60:	2974e504 	addi	r5,r5,-11372
81115d64:	11207b80 	call	811207b8 <fprintf>
81115d68:	00000706 	br	81115d88 <vStackMonitor+0x32c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get IN_ACK_TASK stack \n" );
81115d6c:	d0a06117 	ldw	r2,-32380(gp)
81115d70:	100f883a 	mov	r7,r2
81115d74:	01800884 	movi	r6,34
81115d78:	01400044 	movi	r5,1
81115d7c:	01204574 	movhi	r4,33045
81115d80:	21353404 	addi	r4,r4,-11056
81115d84:	1120e540 	call	81120e54 <fwrite>
    	}

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
81115d88:	e0bffd04 	addi	r2,fp,-12
81115d8c:	100b883a 	mov	r5,r2
81115d90:	01000044 	movi	r4,1
81115d94:	113f6080 	call	8113f608 <OSTaskStkChk>
81115d98:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81115d9c:	e0bffc03 	ldbu	r2,-16(fp)
81115da0:	10000f1e 	bne	r2,zero,81115de0 <vStackMonitor+0x384>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115da4:	d1206117 	ldw	r4,-32380(gp)
    				"INITI_TASK",
    				data.OSFree + data.OSUsed,
81115da8:	e0fffd17 	ldw	r3,-12(fp)
81115dac:	e0bffe17 	ldw	r2,-8(fp)

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115db0:	188b883a 	add	r5,r3,r2
81115db4:	e0bffd17 	ldw	r2,-12(fp)
81115db8:	e0fffe17 	ldw	r3,-8(fp)
81115dbc:	d8c00115 	stw	r3,4(sp)
81115dc0:	d8800015 	stw	r2,0(sp)
81115dc4:	280f883a 	mov	r7,r5
81115dc8:	01a04574 	movhi	r6,33045
81115dcc:	31b53d04 	addi	r6,r6,-11020
81115dd0:	01604574 	movhi	r5,33045
81115dd4:	2974e504 	addi	r5,r5,-11372
81115dd8:	11207b80 	call	811207b8 <fprintf>
81115ddc:	00000706 	br	81115dfc <vStackMonitor+0x3a0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get INIT_TASK stack \n" );
81115de0:	d0a06117 	ldw	r2,-32380(gp)
81115de4:	100f883a 	mov	r7,r2
81115de8:	01800804 	movi	r6,32
81115dec:	01400044 	movi	r5,1
81115df0:	01204574 	movhi	r4,33045
81115df4:	21354004 	addi	r4,r4,-11008
81115df8:	1120e540 	call	81120e54 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
81115dfc:	e0bffd04 	addi	r2,fp,-12
81115e00:	100b883a 	mov	r5,r2
81115e04:	010002c4 	movi	r4,11
81115e08:	113f6080 	call	8113f608 <OSTaskStkChk>
81115e0c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81115e10:	e0bffc03 	ldbu	r2,-16(fp)
81115e14:	10000f1e 	bne	r2,zero,81115e54 <vStackMonitor+0x3f8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115e18:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-0",
    				data.OSFree + data.OSUsed,
81115e1c:	e0fffd17 	ldw	r3,-12(fp)
81115e20:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115e24:	188b883a 	add	r5,r3,r2
81115e28:	e0bffd17 	ldw	r2,-12(fp)
81115e2c:	e0fffe17 	ldw	r3,-8(fp)
81115e30:	d8c00115 	stw	r3,4(sp)
81115e34:	d8800015 	stw	r2,0(sp)
81115e38:	280f883a 	mov	r7,r5
81115e3c:	01a04574 	movhi	r6,33045
81115e40:	31b54904 	addi	r6,r6,-10972
81115e44:	01604574 	movhi	r5,33045
81115e48:	2974e504 	addi	r5,r5,-11372
81115e4c:	11207b80 	call	811207b8 <fprintf>
81115e50:	00000706 	br	81115e70 <vStackMonitor+0x414>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 0 stack \n" );
81115e54:	d0a06117 	ldw	r2,-32380(gp)
81115e58:	100f883a 	mov	r7,r2
81115e5c:	018008c4 	movi	r6,35
81115e60:	01400044 	movi	r5,1
81115e64:	01204574 	movhi	r4,33045
81115e68:	21354c04 	addi	r4,r4,-10960
81115e6c:	1120e540 	call	81120e54 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
81115e70:	e0bffd04 	addi	r2,fp,-12
81115e74:	100b883a 	mov	r5,r2
81115e78:	01000304 	movi	r4,12
81115e7c:	113f6080 	call	8113f608 <OSTaskStkChk>
81115e80:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81115e84:	e0bffc03 	ldbu	r2,-16(fp)
81115e88:	10000f1e 	bne	r2,zero,81115ec8 <vStackMonitor+0x46c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115e8c:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-1",
    				data.OSFree + data.OSUsed,
81115e90:	e0fffd17 	ldw	r3,-12(fp)
81115e94:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115e98:	188b883a 	add	r5,r3,r2
81115e9c:	e0bffd17 	ldw	r2,-12(fp)
81115ea0:	e0fffe17 	ldw	r3,-8(fp)
81115ea4:	d8c00115 	stw	r3,4(sp)
81115ea8:	d8800015 	stw	r2,0(sp)
81115eac:	280f883a 	mov	r7,r5
81115eb0:	01a04574 	movhi	r6,33045
81115eb4:	31b55504 	addi	r6,r6,-10924
81115eb8:	01604574 	movhi	r5,33045
81115ebc:	2974e504 	addi	r5,r5,-11372
81115ec0:	11207b80 	call	811207b8 <fprintf>
81115ec4:	00000706 	br	81115ee4 <vStackMonitor+0x488>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 1 stack \n" );
81115ec8:	d0a06117 	ldw	r2,-32380(gp)
81115ecc:	100f883a 	mov	r7,r2
81115ed0:	018008c4 	movi	r6,35
81115ed4:	01400044 	movi	r5,1
81115ed8:	01204574 	movhi	r4,33045
81115edc:	21355804 	addi	r4,r4,-10912
81115ee0:	1120e540 	call	81120e54 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
81115ee4:	e0bffd04 	addi	r2,fp,-12
81115ee8:	100b883a 	mov	r5,r2
81115eec:	01000344 	movi	r4,13
81115ef0:	113f6080 	call	8113f608 <OSTaskStkChk>
81115ef4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81115ef8:	e0bffc03 	ldbu	r2,-16(fp)
81115efc:	10000f1e 	bne	r2,zero,81115f3c <vStackMonitor+0x4e0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115f00:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-2",
    				data.OSFree + data.OSUsed,
81115f04:	e0fffd17 	ldw	r3,-12(fp)
81115f08:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115f0c:	188b883a 	add	r5,r3,r2
81115f10:	e0bffd17 	ldw	r2,-12(fp)
81115f14:	e0fffe17 	ldw	r3,-8(fp)
81115f18:	d8c00115 	stw	r3,4(sp)
81115f1c:	d8800015 	stw	r2,0(sp)
81115f20:	280f883a 	mov	r7,r5
81115f24:	01a04574 	movhi	r6,33045
81115f28:	31b56104 	addi	r6,r6,-10876
81115f2c:	01604574 	movhi	r5,33045
81115f30:	2974e504 	addi	r5,r5,-11372
81115f34:	11207b80 	call	811207b8 <fprintf>
81115f38:	00000706 	br	81115f58 <vStackMonitor+0x4fc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 2 stack \n" );
81115f3c:	d0a06117 	ldw	r2,-32380(gp)
81115f40:	100f883a 	mov	r7,r2
81115f44:	018008c4 	movi	r6,35
81115f48:	01400044 	movi	r5,1
81115f4c:	01204574 	movhi	r4,33045
81115f50:	21356404 	addi	r4,r4,-10864
81115f54:	1120e540 	call	81120e54 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
81115f58:	e0bffd04 	addi	r2,fp,-12
81115f5c:	100b883a 	mov	r5,r2
81115f60:	01000384 	movi	r4,14
81115f64:	113f6080 	call	8113f608 <OSTaskStkChk>
81115f68:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81115f6c:	e0bffc03 	ldbu	r2,-16(fp)
81115f70:	10000f1e 	bne	r2,zero,81115fb0 <vStackMonitor+0x554>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115f74:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-3",
    				data.OSFree + data.OSUsed,
81115f78:	e0fffd17 	ldw	r3,-12(fp)
81115f7c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115f80:	188b883a 	add	r5,r3,r2
81115f84:	e0bffd17 	ldw	r2,-12(fp)
81115f88:	e0fffe17 	ldw	r3,-8(fp)
81115f8c:	d8c00115 	stw	r3,4(sp)
81115f90:	d8800015 	stw	r2,0(sp)
81115f94:	280f883a 	mov	r7,r5
81115f98:	01a04574 	movhi	r6,33045
81115f9c:	31b56d04 	addi	r6,r6,-10828
81115fa0:	01604574 	movhi	r5,33045
81115fa4:	2974e504 	addi	r5,r5,-11372
81115fa8:	11207b80 	call	811207b8 <fprintf>
81115fac:	00000706 	br	81115fcc <vStackMonitor+0x570>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 3 stack \n" );
81115fb0:	d0a06117 	ldw	r2,-32380(gp)
81115fb4:	100f883a 	mov	r7,r2
81115fb8:	018008c4 	movi	r6,35
81115fbc:	01400044 	movi	r5,1
81115fc0:	01204574 	movhi	r4,33045
81115fc4:	21357004 	addi	r4,r4,-10816
81115fc8:	1120e540 	call	81120e54 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
81115fcc:	e0bffd04 	addi	r2,fp,-12
81115fd0:	100b883a 	mov	r5,r2
81115fd4:	010003c4 	movi	r4,15
81115fd8:	113f6080 	call	8113f608 <OSTaskStkChk>
81115fdc:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81115fe0:	e0bffc03 	ldbu	r2,-16(fp)
81115fe4:	10000f1e 	bne	r2,zero,81116024 <vStackMonitor+0x5c8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115fe8:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-4",
    				data.OSFree + data.OSUsed,
81115fec:	e0fffd17 	ldw	r3,-12(fp)
81115ff0:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115ff4:	188b883a 	add	r5,r3,r2
81115ff8:	e0bffd17 	ldw	r2,-12(fp)
81115ffc:	e0fffe17 	ldw	r3,-8(fp)
81116000:	d8c00115 	stw	r3,4(sp)
81116004:	d8800015 	stw	r2,0(sp)
81116008:	280f883a 	mov	r7,r5
8111600c:	01a04574 	movhi	r6,33045
81116010:	31b57904 	addi	r6,r6,-10780
81116014:	01604574 	movhi	r5,33045
81116018:	2974e504 	addi	r5,r5,-11372
8111601c:	11207b80 	call	811207b8 <fprintf>
81116020:	00000706 	br	81116040 <vStackMonitor+0x5e4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 4 stack \n" );
81116024:	d0a06117 	ldw	r2,-32380(gp)
81116028:	100f883a 	mov	r7,r2
8111602c:	018008c4 	movi	r6,35
81116030:	01400044 	movi	r5,1
81116034:	01204574 	movhi	r4,33045
81116038:	21357c04 	addi	r4,r4,-10768
8111603c:	1120e540 	call	81120e54 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
81116040:	e0bffd04 	addi	r2,fp,-12
81116044:	100b883a 	mov	r5,r2
81116048:	01000404 	movi	r4,16
8111604c:	113f6080 	call	8113f608 <OSTaskStkChk>
81116050:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81116054:	e0bffc03 	ldbu	r2,-16(fp)
81116058:	10000f1e 	bne	r2,zero,81116098 <vStackMonitor+0x63c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111605c:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-5",
    				data.OSFree + data.OSUsed,
81116060:	e0fffd17 	ldw	r3,-12(fp)
81116064:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116068:	188b883a 	add	r5,r3,r2
8111606c:	e0bffd17 	ldw	r2,-12(fp)
81116070:	e0fffe17 	ldw	r3,-8(fp)
81116074:	d8c00115 	stw	r3,4(sp)
81116078:	d8800015 	stw	r2,0(sp)
8111607c:	280f883a 	mov	r7,r5
81116080:	01a04574 	movhi	r6,33045
81116084:	31b58504 	addi	r6,r6,-10732
81116088:	01604574 	movhi	r5,33045
8111608c:	2974e504 	addi	r5,r5,-11372
81116090:	11207b80 	call	811207b8 <fprintf>
81116094:	00000706 	br	811160b4 <vStackMonitor+0x658>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 5 stack \n" );
81116098:	d0a06117 	ldw	r2,-32380(gp)
8111609c:	100f883a 	mov	r7,r2
811160a0:	018008c4 	movi	r6,35
811160a4:	01400044 	movi	r5,1
811160a8:	01204574 	movhi	r4,33045
811160ac:	21358804 	addi	r4,r4,-10720
811160b0:	1120e540 	call	81120e54 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
811160b4:	e0bffd04 	addi	r2,fp,-12
811160b8:	100b883a 	mov	r5,r2
811160bc:	01000284 	movi	r4,10
811160c0:	113f6080 	call	8113f608 <OSTaskStkChk>
811160c4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811160c8:	e0bffc03 	ldbu	r2,-16(fp)
811160cc:	10000f1e 	bne	r2,zero,8111610c <vStackMonitor+0x6b0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811160d0:	d1206117 	ldw	r4,-32380(gp)
    				"DATA_COTROL",
    				data.OSFree + data.OSUsed,
811160d4:	e0fffd17 	ldw	r3,-12(fp)
811160d8:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811160dc:	188b883a 	add	r5,r3,r2
811160e0:	e0bffd17 	ldw	r2,-12(fp)
811160e4:	e0fffe17 	ldw	r3,-8(fp)
811160e8:	d8c00115 	stw	r3,4(sp)
811160ec:	d8800015 	stw	r2,0(sp)
811160f0:	280f883a 	mov	r7,r5
811160f4:	01a04574 	movhi	r6,33045
811160f8:	31b59104 	addi	r6,r6,-10684
811160fc:	01604574 	movhi	r5,33045
81116100:	2974e504 	addi	r5,r5,-11372
81116104:	11207b80 	call	811207b8 <fprintf>
81116108:	00000706 	br	81116128 <vStackMonitor+0x6cc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get DATA_COTROL stack \n" );
8111610c:	d0a06117 	ldw	r2,-32380(gp)
81116110:	100f883a 	mov	r7,r2
81116114:	01800884 	movi	r6,34
81116118:	01400044 	movi	r5,1
8111611c:	01204574 	movhi	r4,33045
81116120:	21359404 	addi	r4,r4,-10672
81116124:	1120e540 	call	81120e54 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
81116128:	e0bffd04 	addi	r2,fp,-12
8111612c:	100b883a 	mov	r5,r2
81116130:	01000244 	movi	r4,9
81116134:	113f6080 	call	8113f608 <OSTaskStkChk>
81116138:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111613c:	e0bffc03 	ldbu	r2,-16(fp)
81116140:	10000f1e 	bne	r2,zero,81116180 <vStackMonitor+0x724>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116144:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_COTROL",
    				data.OSFree + data.OSUsed,
81116148:	e0fffd17 	ldw	r3,-12(fp)
8111614c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81116150:	188b883a 	add	r5,r3,r2
81116154:	e0bffd17 	ldw	r2,-12(fp)
81116158:	e0fffe17 	ldw	r3,-8(fp)
8111615c:	d8c00115 	stw	r3,4(sp)
81116160:	d8800015 	stw	r2,0(sp)
81116164:	280f883a 	mov	r7,r5
81116168:	01a04574 	movhi	r6,33045
8111616c:	31b59d04 	addi	r6,r6,-10636
81116170:	01604574 	movhi	r5,33045
81116174:	2974e504 	addi	r5,r5,-11372
81116178:	11207b80 	call	811207b8 <fprintf>
8111617c:	00000706 	br	8111619c <vStackMonitor+0x740>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_COTROL stack \n" );
81116180:	d0a06117 	ldw	r2,-32380(gp)
81116184:	100f883a 	mov	r7,r2
81116188:	01800844 	movi	r6,33
8111618c:	01400044 	movi	r5,1
81116190:	01204574 	movhi	r4,33045
81116194:	2135a004 	addi	r4,r4,-10624
81116198:	1120e540 	call	81120e54 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
8111619c:	e0bffd04 	addi	r2,fp,-12
811161a0:	100b883a 	mov	r5,r2
811161a4:	01000204 	movi	r4,8
811161a8:	113f6080 	call	8113f608 <OSTaskStkChk>
811161ac:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811161b0:	e0bffc03 	ldbu	r2,-16(fp)
811161b4:	10000f1e 	bne	r2,zero,811161f4 <vStackMonitor+0x798>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811161b8:	d1206117 	ldw	r4,-32380(gp)
    				"MEB_TASK",
    				data.OSFree + data.OSUsed,
811161bc:	e0fffd17 	ldw	r3,-12(fp)
811161c0:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811161c4:	188b883a 	add	r5,r3,r2
811161c8:	e0bffd17 	ldw	r2,-12(fp)
811161cc:	e0fffe17 	ldw	r3,-8(fp)
811161d0:	d8c00115 	stw	r3,4(sp)
811161d4:	d8800015 	stw	r2,0(sp)
811161d8:	280f883a 	mov	r7,r5
811161dc:	01a04574 	movhi	r6,33045
811161e0:	31b5a904 	addi	r6,r6,-10588
811161e4:	01604574 	movhi	r5,33045
811161e8:	2974e504 	addi	r5,r5,-11372
811161ec:	11207b80 	call	811207b8 <fprintf>
811161f0:	00000706 	br	81116210 <vStackMonitor+0x7b4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get MEB_TASK stack \n" );
811161f4:	d0a06117 	ldw	r2,-32380(gp)
811161f8:	100f883a 	mov	r7,r2
811161fc:	018007c4 	movi	r6,31
81116200:	01400044 	movi	r5,1
81116204:	01204574 	movhi	r4,33045
81116208:	2135ac04 	addi	r4,r4,-10576
8111620c:	1120e540 	call	81120e54 <fwrite>
    	}		


    	fprintf(fp, "\n" );
81116210:	d0a06117 	ldw	r2,-32380(gp)
81116214:	100b883a 	mov	r5,r2
81116218:	01000284 	movi	r4,10
8111621c:	11208300 	call	81120830 <fputc>

    	OSTimeDlyHMSM(0, 0, 10, 0);
81116220:	000f883a 	mov	r7,zero
81116224:	01800284 	movi	r6,10
81116228:	000b883a 	mov	r5,zero
8111622c:	0009883a 	mov	r4,zero
81116230:	113fc6c0 	call	8113fc6c <OSTimeDlyHMSM>
    }
81116234:	003e1806 	br	81115a98 <__reset+0xfb0f5a98>

81116238 <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
81116238:	defffc04 	addi	sp,sp,-16
8111623c:	de00012e 	bgeu	sp,et,81116244 <vTimeoutCheckerTaskv2+0xc>
81116240:	003b68fa 	trap	3
81116244:	dfc00315 	stw	ra,12(sp)
81116248:	df000215 	stw	fp,8(sp)
8111624c:	df000204 	addi	fp,sp,8
81116250:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81116254:	e03ffe05 	stb	zero,-8(fp)

    #ifdef DEBUG_ON
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
81116258:	d0a06117 	ldw	r2,-32380(gp)
8111625c:	100f883a 	mov	r7,r2
81116260:	01800844 	movi	r6,33
81116264:	01400044 	movi	r5,1
81116268:	01204574 	movhi	r4,33045
8111626c:	2135b404 	addi	r4,r4,-10544
81116270:	1120e540 	call	81120e54 <fwrite>
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
81116274:	d0a06617 	ldw	r2,-32360(gp)
81116278:	e1bffe04 	addi	r6,fp,-8
8111627c:	000b883a 	mov	r5,zero
81116280:	1009883a 	mov	r4,r2
81116284:	113dcd40 	call	8113dcd4 <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
81116288:	e0bffe03 	ldbu	r2,-8(fp)
8111628c:	10803fcc 	andi	r2,r2,255
81116290:	1000021e 	bne	r2,zero,8111629c <vTimeoutCheckerTaskv2+0x64>
            /* Just check the restransmission buffer */
            vCheck();
81116294:	11162a40 	call	811162a4 <vCheck>
81116298:	003ff606 	br	81116274 <__reset+0xfb0f6274>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
8111629c:	111b9100 	call	8111b910 <vFailGetBlockingSemTimeoutTask>
        }
    }
811162a0:	003ff406 	br	81116274 <__reset+0xfb0f6274>

811162a4 <vCheck>:
}


void vCheck( void ) {
811162a4:	defffd04 	addi	sp,sp,-12
811162a8:	de00012e 	bgeu	sp,et,811162b0 <vCheck+0xc>
811162ac:	003b68fa 	trap	3
811162b0:	dfc00215 	stw	ra,8(sp)
811162b4:	df000115 	stw	fp,4(sp)
811162b8:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
811162bc:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
811162c0:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
811162c4:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
811162c8:	d0a06783 	ldbu	r2,-32354(gp)
811162cc:	10803fcc 	andi	r2,r2,255
811162d0:	10800218 	cmpnei	r2,r2,8
811162d4:	1000021e 	bne	r2,zero,811162e0 <vCheck+0x3c>
811162d8:	00c00104 	movi	r3,4
811162dc:	00000106 	br	811162e4 <vCheck+0x40>
811162e0:	0007883a 	mov	r3,zero
811162e4:	d0a07403 	ldbu	r2,-32304(gp)
811162e8:	10803fcc 	andi	r2,r2,255
811162ec:	10800218 	cmpnei	r2,r2,8
811162f0:	1000021e 	bne	r2,zero,811162fc <vCheck+0x58>
811162f4:	00800084 	movi	r2,2
811162f8:	00000106 	br	81116300 <vCheck+0x5c>
811162fc:	0005883a 	mov	r2,zero
81116300:	1884b03a 	or	r2,r3,r2
81116304:	1007883a 	mov	r3,r2
81116308:	d0a07443 	ldbu	r2,-32303(gp)
8111630c:	10803fcc 	andi	r2,r2,255
81116310:	108001a0 	cmpeqi	r2,r2,6
81116314:	1884b03a 	or	r2,r3,r2
81116318:	1007883a 	mov	r3,r2
8111631c:	e0bfff03 	ldbu	r2,-4(fp)
81116320:	1884b03a 	or	r2,r3,r2
81116324:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
81116328:	e0bfff03 	ldbu	r2,-4(fp)
8111632c:	108001d8 	cmpnei	r2,r2,7
81116330:	10003726 	beq	r2,zero,81116410 <vCheck+0x16c>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
81116334:	d0a07317 	ldw	r2,-32308(gp)
81116338:	e0ffff44 	addi	r3,fp,-3
8111633c:	180d883a 	mov	r6,r3
81116340:	000b883a 	mov	r5,zero
81116344:	1009883a 	mov	r4,r2
81116348:	113bcc80 	call	8113bcc8 <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
8111634c:	e0bfff43 	ldbu	r2,-3(fp)
81116350:	10803fcc 	andi	r2,r2,255
81116354:	10000826 	beq	r2,zero,81116378 <vCheck+0xd4>
        /* Should never get here, is a blocking operation */
		#ifdef DEBUG_ON
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
81116358:	d0a06117 	ldw	r2,-32380(gp)
8111635c:	100f883a 	mov	r7,r2
81116360:	01800f04 	movi	r6,60
81116364:	01400044 	movi	r5,1
81116368:	01204574 	movhi	r4,33045
8111636c:	2135bd04 	addi	r4,r4,-10508
81116370:	1120e540 	call	81120e54 <fwrite>
		#endif
        return;
81116374:	00002706 	br	81116414 <vCheck+0x170>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81116378:	e0bfff03 	ldbu	r2,-4(fp)
8111637c:	1080004c 	andi	r2,r2,1
81116380:	10803fcc 	andi	r2,r2,255
81116384:	1000021e 	bne	r2,zero,81116390 <vCheck+0xec>
        vCheckRetransmission128();
81116388:	11164280 	call	81116428 <vCheckRetransmission128>
8111638c:	00000506 	br	811163a4 <vCheck+0x100>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
81116390:	01800604 	movi	r6,24
81116394:	000b883a 	mov	r5,zero
81116398:	012045b4 	movhi	r4,33046
8111639c:	21377704 	addi	r4,r4,-8740
811163a0:	11219b80 	call	811219b8 <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
811163a4:	e0bfff03 	ldbu	r2,-4(fp)
811163a8:	1080008c 	andi	r2,r2,2
811163ac:	10803fcc 	andi	r2,r2,255
811163b0:	1000021e 	bne	r2,zero,811163bc <vCheck+0x118>
        vCheckRetransmission64();
811163b4:	11166ac0 	call	811166ac <vCheckRetransmission64>
811163b8:	00000506 	br	811163d0 <vCheck+0x12c>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
811163bc:	01800804 	movi	r6,32
811163c0:	000b883a 	mov	r5,zero
811163c4:	012045b4 	movhi	r4,33046
811163c8:	21377d04 	addi	r4,r4,-8716
811163cc:	11219b80 	call	811219b8 <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
811163d0:	e0bfff03 	ldbu	r2,-4(fp)
811163d4:	1080010c 	andi	r2,r2,4
811163d8:	10803fcc 	andi	r2,r2,255
811163dc:	1000021e 	bne	r2,zero,811163e8 <vCheck+0x144>
        vCheckRetransmission32();
811163e0:	11169380 	call	81116938 <vCheckRetransmission32>
811163e4:	00000506 	br	811163fc <vCheck+0x158>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
811163e8:	01800804 	movi	r6,32
811163ec:	000b883a 	mov	r5,zero
811163f0:	012045b4 	movhi	r4,33046
811163f4:	21378504 	addi	r4,r4,-8684
811163f8:	11219b80 	call	811219b8 <memset>


    OSMutexPost(xTxUARTMutex);
811163fc:	d0a07317 	ldw	r2,-32308(gp)
81116400:	1009883a 	mov	r4,r2
81116404:	113c26c0 	call	8113c26c <OSMutexPost>

    return;
81116408:	0001883a 	nop
8111640c:	00000106 	br	81116414 <vCheck+0x170>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
81116410:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
81116414:	e037883a 	mov	sp,fp
81116418:	dfc00117 	ldw	ra,4(sp)
8111641c:	df000017 	ldw	fp,0(sp)
81116420:	dec00204 	addi	sp,sp,8
81116424:	f800283a 	ret

81116428 <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
81116428:	defffd04 	addi	sp,sp,-12
8111642c:	de00012e 	bgeu	sp,et,81116434 <vCheckRetransmission128+0xc>
81116430:	003b68fa 	trap	3
81116434:	dfc00215 	stw	ra,8(sp)
81116438:	df000115 	stw	fp,4(sp)
8111643c:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81116440:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81116444:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81116448:	d0a06d17 	ldw	r2,-32332(gp)
8111644c:	e0ffff44 	addi	r3,fp,-3
81116450:	180b883a 	mov	r5,r3
81116454:	1009883a 	mov	r4,r2
81116458:	113b6480 	call	8113b648 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
8111645c:	e0bfff43 	ldbu	r2,-3(fp)
81116460:	10803fcc 	andi	r2,r2,255
81116464:	10008b1e 	bne	r2,zero,81116694 <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81116468:	e03fff05 	stb	zero,-4(fp)
8111646c:	00008106 	br	81116674 <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
81116470:	e0ffff03 	ldbu	r3,-4(fp)
81116474:	00a045b4 	movhi	r2,33046
81116478:	10b77704 	addi	r2,r2,-8740
8111647c:	18c7883a 	add	r3,r3,r3
81116480:	18c7883a 	add	r3,r3,r3
81116484:	10c5883a 	add	r2,r2,r3
81116488:	10800017 	ldw	r2,0(r2)
8111648c:	10800058 	cmpnei	r2,r2,1
81116490:	1000751e 	bne	r2,zero,81116668 <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
81116494:	e0ffff03 	ldbu	r3,-4(fp)
81116498:	00a045b4 	movhi	r2,33046
8111649c:	10b79504 	addi	r2,r2,-8620
811164a0:	18c02324 	muli	r3,r3,140
811164a4:	10c5883a 	add	r2,r2,r3
811164a8:	10802004 	addi	r2,r2,128
811164ac:	10800017 	ldw	r2,0(r2)
811164b0:	10800058 	cmpnei	r2,r2,1
811164b4:	1000211e 	bne	r2,zero,8111653c <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
811164b8:	e0ffff03 	ldbu	r3,-4(fp)
811164bc:	00a045b4 	movhi	r2,33046
811164c0:	10b79504 	addi	r2,r2,-8620
811164c4:	19002324 	muli	r4,r3,140
811164c8:	1105883a 	add	r2,r2,r4
811164cc:	10802184 	addi	r2,r2,134
811164d0:	1080000b 	ldhu	r2,0(r2)
811164d4:	10800044 	addi	r2,r2,1
811164d8:	100b883a 	mov	r5,r2
811164dc:	00a045b4 	movhi	r2,33046
811164e0:	10b79504 	addi	r2,r2,-8620
811164e4:	19002324 	muli	r4,r3,140
811164e8:	1105883a 	add	r2,r2,r4
811164ec:	10802184 	addi	r2,r2,134
811164f0:	1140000d 	sth	r5,0(r2)
811164f4:	00a045b4 	movhi	r2,33046
811164f8:	10b79504 	addi	r2,r2,-8620
811164fc:	18c02324 	muli	r3,r3,140
81116500:	10c5883a 	add	r2,r2,r3
81116504:	10802184 	addi	r2,r2,134
81116508:	1080000b 	ldhu	r2,0(r2)
8111650c:	10bfffcc 	andi	r2,r2,65535
81116510:	10a0001c 	xori	r2,r2,32768
81116514:	10a00004 	addi	r2,r2,-32768
81116518:	10800090 	cmplti	r2,r2,2
8111651c:	1000071e 	bne	r2,zero,8111653c <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
81116520:	e0ffff03 	ldbu	r3,-4(fp)
81116524:	00a045b4 	movhi	r2,33046
81116528:	10b79504 	addi	r2,r2,-8620
8111652c:	18c02324 	muli	r3,r3,140
81116530:	10c5883a 	add	r2,r2,r3
81116534:	10802004 	addi	r2,r2,128
81116538:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
8111653c:	e0ffff03 	ldbu	r3,-4(fp)
81116540:	00a045b4 	movhi	r2,33046
81116544:	10b79504 	addi	r2,r2,-8620
81116548:	18c02324 	muli	r3,r3,140
8111654c:	10c5883a 	add	r2,r2,r3
81116550:	10802004 	addi	r2,r2,128
81116554:	10800017 	ldw	r2,0(r2)
81116558:	1000431e 	bne	r2,zero,81116668 <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
8111655c:	e0bfff03 	ldbu	r2,-4(fp)
81116560:	10c02324 	muli	r3,r2,140
81116564:	00a045b4 	movhi	r2,33046
81116568:	10b79504 	addi	r2,r2,-8620
8111656c:	1885883a 	add	r2,r3,r2
81116570:	1009883a 	mov	r4,r2
81116574:	1121e040 	call	81121e04 <puts>
                xBuffer128[ucIL].bSent = TRUE;
81116578:	e0ffff03 	ldbu	r3,-4(fp)
8111657c:	00a045b4 	movhi	r2,33046
81116580:	10b79504 	addi	r2,r2,-8620
81116584:	18c02324 	muli	r3,r3,140
81116588:	10c5883a 	add	r2,r2,r3
8111658c:	10802004 	addi	r2,r2,128
81116590:	00c00044 	movi	r3,1
81116594:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
81116598:	e0ffff03 	ldbu	r3,-4(fp)
8111659c:	00a045b4 	movhi	r2,33046
811165a0:	10b79504 	addi	r2,r2,-8620
811165a4:	18c02324 	muli	r3,r3,140
811165a8:	10c5883a 	add	r2,r2,r3
811165ac:	10802184 	addi	r2,r2,134
811165b0:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
811165b4:	e0ffff03 	ldbu	r3,-4(fp)
811165b8:	00a045b4 	movhi	r2,33046
811165bc:	10b79504 	addi	r2,r2,-8620
811165c0:	19002324 	muli	r4,r3,140
811165c4:	1105883a 	add	r2,r2,r4
811165c8:	10802204 	addi	r2,r2,136
811165cc:	10800003 	ldbu	r2,0(r2)
811165d0:	10800044 	addi	r2,r2,1
811165d4:	100b883a 	mov	r5,r2
811165d8:	00a045b4 	movhi	r2,33046
811165dc:	10b79504 	addi	r2,r2,-8620
811165e0:	19002324 	muli	r4,r3,140
811165e4:	1105883a 	add	r2,r2,r4
811165e8:	10802204 	addi	r2,r2,136
811165ec:	11400005 	stb	r5,0(r2)
811165f0:	00a045b4 	movhi	r2,33046
811165f4:	10b79504 	addi	r2,r2,-8620
811165f8:	18c02324 	muli	r3,r3,140
811165fc:	10c5883a 	add	r2,r2,r3
81116600:	10802204 	addi	r2,r2,136
81116604:	10800003 	ldbu	r2,0(r2)
81116608:	10803fcc 	andi	r2,r2,255
8111660c:	108000b0 	cmpltui	r2,r2,2
81116610:	1000151e 	bne	r2,zero,81116668 <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
81116614:	e0ffff03 	ldbu	r3,-4(fp)
81116618:	00a045b4 	movhi	r2,33046
8111661c:	10b77704 	addi	r2,r2,-8740
81116620:	18c7883a 	add	r3,r3,r3
81116624:	18c7883a 	add	r3,r3,r3
81116628:	10c5883a 	add	r2,r2,r3
8111662c:	10000015 	stw	zero,0(r2)
                    SemCount128++;
81116630:	d0a07443 	ldbu	r2,-32303(gp)
81116634:	10800044 	addi	r2,r2,1
81116638:	d0a07445 	stb	r2,-32303(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
8111663c:	d0a06217 	ldw	r2,-32376(gp)
81116640:	1009883a 	mov	r4,r2
81116644:	113e05c0 	call	8113e05c <OSSemPost>
81116648:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
8111664c:	e0bfff43 	ldbu	r2,-3(fp)
81116650:	10803fcc 	andi	r2,r2,255
81116654:	10000426 	beq	r2,zero,81116668 <vCheckRetransmission128+0x240>
                        SemCount128--;
81116658:	d0a07443 	ldbu	r2,-32303(gp)
8111665c:	10bfffc4 	addi	r2,r2,-1
81116660:	d0a07445 	stb	r2,-32303(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81116664:	111b2000 	call	8111b200 <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81116668:	e0bfff03 	ldbu	r2,-4(fp)
8111666c:	10800044 	addi	r2,r2,1
81116670:	e0bfff05 	stb	r2,-4(fp)
81116674:	e0bfff03 	ldbu	r2,-4(fp)
81116678:	108001b0 	cmpltui	r2,r2,6
8111667c:	103f7c1e 	bne	r2,zero,81116470 <__reset+0xfb0f6470>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
81116680:	d0a06d17 	ldw	r2,-32332(gp)
81116684:	1009883a 	mov	r4,r2
81116688:	113c26c0 	call	8113c26c <OSMutexPost>

    return;
8111668c:	0001883a 	nop
81116690:	00000106 	br	81116698 <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81116694:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
81116698:	e037883a 	mov	sp,fp
8111669c:	dfc00117 	ldw	ra,4(sp)
811166a0:	df000017 	ldw	fp,0(sp)
811166a4:	dec00204 	addi	sp,sp,8
811166a8:	f800283a 	ret

811166ac <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
811166ac:	defffd04 	addi	sp,sp,-12
811166b0:	de00012e 	bgeu	sp,et,811166b8 <vCheckRetransmission64+0xc>
811166b4:	003b68fa 	trap	3
811166b8:	dfc00215 	stw	ra,8(sp)
811166bc:	df000115 	stw	fp,4(sp)
811166c0:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
811166c4:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
811166c8:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
811166cc:	d0a07017 	ldw	r2,-32320(gp)
811166d0:	e0ffff44 	addi	r3,fp,-3
811166d4:	180b883a 	mov	r5,r3
811166d8:	1009883a 	mov	r4,r2
811166dc:	113b6480 	call	8113b648 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
811166e0:	e0bfff43 	ldbu	r2,-3(fp)
811166e4:	10803fcc 	andi	r2,r2,255
811166e8:	10008d1e 	bne	r2,zero,81116920 <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
811166ec:	e03fff05 	stb	zero,-4(fp)
811166f0:	00008306 	br	81116900 <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
811166f4:	e0ffff03 	ldbu	r3,-4(fp)
811166f8:	00a045b4 	movhi	r2,33046
811166fc:	10b77704 	addi	r2,r2,-8740
81116700:	18c00184 	addi	r3,r3,6
81116704:	18c7883a 	add	r3,r3,r3
81116708:	18c7883a 	add	r3,r3,r3
8111670c:	10c5883a 	add	r2,r2,r3
81116710:	10800017 	ldw	r2,0(r2)
81116714:	10800058 	cmpnei	r2,r2,1
81116718:	1000761e 	bne	r2,zero,811168f4 <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
8111671c:	e0ffff03 	ldbu	r3,-4(fp)
81116720:	00a04574 	movhi	r2,33045
81116724:	10933b04 	addi	r2,r2,19692
81116728:	18c01324 	muli	r3,r3,76
8111672c:	10c5883a 	add	r2,r2,r3
81116730:	10801004 	addi	r2,r2,64
81116734:	10800017 	ldw	r2,0(r2)
81116738:	10800058 	cmpnei	r2,r2,1
8111673c:	1000211e 	bne	r2,zero,811167c4 <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
81116740:	e0ffff03 	ldbu	r3,-4(fp)
81116744:	00a04574 	movhi	r2,33045
81116748:	10933b04 	addi	r2,r2,19692
8111674c:	19001324 	muli	r4,r3,76
81116750:	1105883a 	add	r2,r2,r4
81116754:	10801184 	addi	r2,r2,70
81116758:	1080000b 	ldhu	r2,0(r2)
8111675c:	10800044 	addi	r2,r2,1
81116760:	100b883a 	mov	r5,r2
81116764:	00a04574 	movhi	r2,33045
81116768:	10933b04 	addi	r2,r2,19692
8111676c:	19001324 	muli	r4,r3,76
81116770:	1105883a 	add	r2,r2,r4
81116774:	10801184 	addi	r2,r2,70
81116778:	1140000d 	sth	r5,0(r2)
8111677c:	00a04574 	movhi	r2,33045
81116780:	10933b04 	addi	r2,r2,19692
81116784:	18c01324 	muli	r3,r3,76
81116788:	10c5883a 	add	r2,r2,r3
8111678c:	10801184 	addi	r2,r2,70
81116790:	1080000b 	ldhu	r2,0(r2)
81116794:	10bfffcc 	andi	r2,r2,65535
81116798:	10a0001c 	xori	r2,r2,32768
8111679c:	10a00004 	addi	r2,r2,-32768
811167a0:	10800090 	cmplti	r2,r2,2
811167a4:	1000071e 	bne	r2,zero,811167c4 <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
811167a8:	e0ffff03 	ldbu	r3,-4(fp)
811167ac:	00a04574 	movhi	r2,33045
811167b0:	10933b04 	addi	r2,r2,19692
811167b4:	18c01324 	muli	r3,r3,76
811167b8:	10c5883a 	add	r2,r2,r3
811167bc:	10801004 	addi	r2,r2,64
811167c0:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
811167c4:	e0ffff03 	ldbu	r3,-4(fp)
811167c8:	00a04574 	movhi	r2,33045
811167cc:	10933b04 	addi	r2,r2,19692
811167d0:	18c01324 	muli	r3,r3,76
811167d4:	10c5883a 	add	r2,r2,r3
811167d8:	10801004 	addi	r2,r2,64
811167dc:	10800017 	ldw	r2,0(r2)
811167e0:	1000441e 	bne	r2,zero,811168f4 <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
811167e4:	e0bfff03 	ldbu	r2,-4(fp)
811167e8:	10c01324 	muli	r3,r2,76
811167ec:	00a04574 	movhi	r2,33045
811167f0:	10933b04 	addi	r2,r2,19692
811167f4:	1885883a 	add	r2,r3,r2
811167f8:	1009883a 	mov	r4,r2
811167fc:	1121e040 	call	81121e04 <puts>
                xBuffer64[ucIL].bSent = TRUE;
81116800:	e0ffff03 	ldbu	r3,-4(fp)
81116804:	00a04574 	movhi	r2,33045
81116808:	10933b04 	addi	r2,r2,19692
8111680c:	18c01324 	muli	r3,r3,76
81116810:	10c5883a 	add	r2,r2,r3
81116814:	10801004 	addi	r2,r2,64
81116818:	00c00044 	movi	r3,1
8111681c:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
81116820:	e0ffff03 	ldbu	r3,-4(fp)
81116824:	00a04574 	movhi	r2,33045
81116828:	10933b04 	addi	r2,r2,19692
8111682c:	18c01324 	muli	r3,r3,76
81116830:	10c5883a 	add	r2,r2,r3
81116834:	10801184 	addi	r2,r2,70
81116838:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
8111683c:	e0ffff03 	ldbu	r3,-4(fp)
81116840:	00a04574 	movhi	r2,33045
81116844:	10933b04 	addi	r2,r2,19692
81116848:	19001324 	muli	r4,r3,76
8111684c:	1105883a 	add	r2,r2,r4
81116850:	10801204 	addi	r2,r2,72
81116854:	10800003 	ldbu	r2,0(r2)
81116858:	10800044 	addi	r2,r2,1
8111685c:	100b883a 	mov	r5,r2
81116860:	00a04574 	movhi	r2,33045
81116864:	10933b04 	addi	r2,r2,19692
81116868:	19001324 	muli	r4,r3,76
8111686c:	1105883a 	add	r2,r2,r4
81116870:	10801204 	addi	r2,r2,72
81116874:	11400005 	stb	r5,0(r2)
81116878:	00a04574 	movhi	r2,33045
8111687c:	10933b04 	addi	r2,r2,19692
81116880:	18c01324 	muli	r3,r3,76
81116884:	10c5883a 	add	r2,r2,r3
81116888:	10801204 	addi	r2,r2,72
8111688c:	10800003 	ldbu	r2,0(r2)
81116890:	10803fcc 	andi	r2,r2,255
81116894:	108000b0 	cmpltui	r2,r2,2
81116898:	1000161e 	bne	r2,zero,811168f4 <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
8111689c:	e0ffff03 	ldbu	r3,-4(fp)
811168a0:	00a045b4 	movhi	r2,33046
811168a4:	10b77704 	addi	r2,r2,-8740
811168a8:	18c00184 	addi	r3,r3,6
811168ac:	18c7883a 	add	r3,r3,r3
811168b0:	18c7883a 	add	r3,r3,r3
811168b4:	10c5883a 	add	r2,r2,r3
811168b8:	10000015 	stw	zero,0(r2)
                    SemCount64++;
811168bc:	d0a07403 	ldbu	r2,-32304(gp)
811168c0:	10800044 	addi	r2,r2,1
811168c4:	d0a07405 	stb	r2,-32304(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
811168c8:	d0a05d17 	ldw	r2,-32396(gp)
811168cc:	1009883a 	mov	r4,r2
811168d0:	113e05c0 	call	8113e05c <OSSemPost>
811168d4:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
811168d8:	e0bfff43 	ldbu	r2,-3(fp)
811168dc:	10803fcc 	andi	r2,r2,255
811168e0:	10000426 	beq	r2,zero,811168f4 <vCheckRetransmission64+0x248>
                        SemCount64--;
811168e4:	d0a07403 	ldbu	r2,-32304(gp)
811168e8:	10bfffc4 	addi	r2,r2,-1
811168ec:	d0a07405 	stb	r2,-32304(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
811168f0:	111b1980 	call	8111b198 <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
811168f4:	e0bfff03 	ldbu	r2,-4(fp)
811168f8:	10800044 	addi	r2,r2,1
811168fc:	e0bfff05 	stb	r2,-4(fp)
81116900:	e0bfff03 	ldbu	r2,-4(fp)
81116904:	10800230 	cmpltui	r2,r2,8
81116908:	103f7a1e 	bne	r2,zero,811166f4 <__reset+0xfb0f66f4>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
8111690c:	d0a07017 	ldw	r2,-32320(gp)
81116910:	1009883a 	mov	r4,r2
81116914:	113c26c0 	call	8113c26c <OSMutexPost>

    return;
81116918:	0001883a 	nop
8111691c:	00000106 	br	81116924 <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81116920:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
81116924:	e037883a 	mov	sp,fp
81116928:	dfc00117 	ldw	ra,4(sp)
8111692c:	df000017 	ldw	fp,0(sp)
81116930:	dec00204 	addi	sp,sp,8
81116934:	f800283a 	ret

81116938 <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
81116938:	defffd04 	addi	sp,sp,-12
8111693c:	de00012e 	bgeu	sp,et,81116944 <vCheckRetransmission32+0xc>
81116940:	003b68fa 	trap	3
81116944:	dfc00215 	stw	ra,8(sp)
81116948:	df000115 	stw	fp,4(sp)
8111694c:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81116950:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
81116954:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
81116958:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
8111695c:	d0a06b17 	ldw	r2,-32340(gp)
81116960:	e0ffff84 	addi	r3,fp,-2
81116964:	180b883a 	mov	r5,r3
81116968:	1009883a 	mov	r4,r2
8111696c:	113b6480 	call	8113b648 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81116970:	e0bfff83 	ldbu	r2,-2(fp)
81116974:	10803fcc 	andi	r2,r2,255
81116978:	10009b1e 	bne	r2,zero,81116be8 <vCheckRetransmission32+0x2b0>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
8111697c:	e03fff05 	stb	zero,-4(fp)
81116980:	00009106 	br	81116bc8 <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
81116984:	e0ffff03 	ldbu	r3,-4(fp)
81116988:	00a045b4 	movhi	r2,33046
8111698c:	10b77704 	addi	r2,r2,-8740
81116990:	18c00384 	addi	r3,r3,14
81116994:	18c7883a 	add	r3,r3,r3
81116998:	18c7883a 	add	r3,r3,r3
8111699c:	10c5883a 	add	r2,r2,r3
811169a0:	10800017 	ldw	r2,0(r2)
811169a4:	10800058 	cmpnei	r2,r2,1
811169a8:	1000841e 	bne	r2,zero,81116bbc <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
811169ac:	e0ffff03 	ldbu	r3,-4(fp)
811169b0:	00a045b4 	movhi	r2,33046
811169b4:	10a4f704 	addi	r2,r2,-27684
811169b8:	18c00b24 	muli	r3,r3,44
811169bc:	10c5883a 	add	r2,r2,r3
811169c0:	10800804 	addi	r2,r2,32
811169c4:	10800017 	ldw	r2,0(r2)
811169c8:	10800058 	cmpnei	r2,r2,1
811169cc:	1000211e 	bne	r2,zero,81116a54 <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
811169d0:	e0ffff03 	ldbu	r3,-4(fp)
811169d4:	00a045b4 	movhi	r2,33046
811169d8:	10a4f704 	addi	r2,r2,-27684
811169dc:	19000b24 	muli	r4,r3,44
811169e0:	1105883a 	add	r2,r2,r4
811169e4:	10800984 	addi	r2,r2,38
811169e8:	1080000b 	ldhu	r2,0(r2)
811169ec:	10800044 	addi	r2,r2,1
811169f0:	100b883a 	mov	r5,r2
811169f4:	00a045b4 	movhi	r2,33046
811169f8:	10a4f704 	addi	r2,r2,-27684
811169fc:	19000b24 	muli	r4,r3,44
81116a00:	1105883a 	add	r2,r2,r4
81116a04:	10800984 	addi	r2,r2,38
81116a08:	1140000d 	sth	r5,0(r2)
81116a0c:	00a045b4 	movhi	r2,33046
81116a10:	10a4f704 	addi	r2,r2,-27684
81116a14:	18c00b24 	muli	r3,r3,44
81116a18:	10c5883a 	add	r2,r2,r3
81116a1c:	10800984 	addi	r2,r2,38
81116a20:	1080000b 	ldhu	r2,0(r2)
81116a24:	10bfffcc 	andi	r2,r2,65535
81116a28:	10a0001c 	xori	r2,r2,32768
81116a2c:	10a00004 	addi	r2,r2,-32768
81116a30:	10800090 	cmplti	r2,r2,2
81116a34:	1000071e 	bne	r2,zero,81116a54 <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
81116a38:	e0ffff03 	ldbu	r3,-4(fp)
81116a3c:	00a045b4 	movhi	r2,33046
81116a40:	10a4f704 	addi	r2,r2,-27684
81116a44:	18c00b24 	muli	r3,r3,44
81116a48:	10c5883a 	add	r2,r2,r3
81116a4c:	10800804 	addi	r2,r2,32
81116a50:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
81116a54:	e0ffff03 	ldbu	r3,-4(fp)
81116a58:	00a045b4 	movhi	r2,33046
81116a5c:	10a4f704 	addi	r2,r2,-27684
81116a60:	18c00b24 	muli	r3,r3,44
81116a64:	10c5883a 	add	r2,r2,r3
81116a68:	10800804 	addi	r2,r2,32
81116a6c:	10800017 	ldw	r2,0(r2)
81116a70:	1000521e 	bne	r2,zero,81116bbc <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
81116a74:	e0bfff03 	ldbu	r2,-4(fp)
81116a78:	10c00b24 	muli	r3,r2,44
81116a7c:	00a045b4 	movhi	r2,33046
81116a80:	10a4f704 	addi	r2,r2,-27684
81116a84:	1885883a 	add	r2,r3,r2
81116a88:	1009883a 	mov	r4,r2
81116a8c:	1121e040 	call	81121e04 <puts>
                xBuffer32[ucIL].bSent = TRUE;
81116a90:	e0ffff03 	ldbu	r3,-4(fp)
81116a94:	00a045b4 	movhi	r2,33046
81116a98:	10a4f704 	addi	r2,r2,-27684
81116a9c:	18c00b24 	muli	r3,r3,44
81116aa0:	10c5883a 	add	r2,r2,r3
81116aa4:	10800804 	addi	r2,r2,32
81116aa8:	00c00044 	movi	r3,1
81116aac:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
81116ab0:	e0ffff03 	ldbu	r3,-4(fp)
81116ab4:	00a045b4 	movhi	r2,33046
81116ab8:	10a4f704 	addi	r2,r2,-27684
81116abc:	18c00b24 	muli	r3,r3,44
81116ac0:	10c5883a 	add	r2,r2,r3
81116ac4:	10800984 	addi	r2,r2,38
81116ac8:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
81116acc:	e0ffff03 	ldbu	r3,-4(fp)
81116ad0:	00a045b4 	movhi	r2,33046
81116ad4:	10a4f704 	addi	r2,r2,-27684
81116ad8:	18c00b24 	muli	r3,r3,44
81116adc:	10c5883a 	add	r2,r2,r3
81116ae0:	10800904 	addi	r2,r2,36
81116ae4:	1080000b 	ldhu	r2,0(r2)
81116ae8:	10bfffcc 	andi	r2,r2,65535
81116aec:	10800058 	cmpnei	r2,r2,1
81116af0:	1000021e 	bne	r2,zero,81116afc <vCheckRetransmission32+0x1c4>
81116af4:	00bffe84 	movi	r2,-6
81116af8:	00000106 	br	81116b00 <vCheckRetransmission32+0x1c8>
81116afc:	00800044 	movi	r2,1
81116b00:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
81116b04:	e0ffff03 	ldbu	r3,-4(fp)
81116b08:	00a045b4 	movhi	r2,33046
81116b0c:	10a4f704 	addi	r2,r2,-27684
81116b10:	19000b24 	muli	r4,r3,44
81116b14:	1105883a 	add	r2,r2,r4
81116b18:	10800a04 	addi	r2,r2,40
81116b1c:	10800003 	ldbu	r2,0(r2)
81116b20:	10800044 	addi	r2,r2,1
81116b24:	100b883a 	mov	r5,r2
81116b28:	00a045b4 	movhi	r2,33046
81116b2c:	10a4f704 	addi	r2,r2,-27684
81116b30:	19000b24 	muli	r4,r3,44
81116b34:	1105883a 	add	r2,r2,r4
81116b38:	10800a04 	addi	r2,r2,40
81116b3c:	11400005 	stb	r5,0(r2)
81116b40:	00a045b4 	movhi	r2,33046
81116b44:	10a4f704 	addi	r2,r2,-27684
81116b48:	18c00b24 	muli	r3,r3,44
81116b4c:	10c5883a 	add	r2,r2,r3
81116b50:	10800a04 	addi	r2,r2,40
81116b54:	10800003 	ldbu	r2,0(r2)
81116b58:	10803fcc 	andi	r2,r2,255
81116b5c:	e0ffff43 	ldbu	r3,-3(fp)
81116b60:	1880162e 	bgeu	r3,r2,81116bbc <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
81116b64:	e0ffff03 	ldbu	r3,-4(fp)
81116b68:	00a045b4 	movhi	r2,33046
81116b6c:	10b77704 	addi	r2,r2,-8740
81116b70:	18c00384 	addi	r3,r3,14
81116b74:	18c7883a 	add	r3,r3,r3
81116b78:	18c7883a 	add	r3,r3,r3
81116b7c:	10c5883a 	add	r2,r2,r3
81116b80:	10000015 	stw	zero,0(r2)
                    SemCount32++;
81116b84:	d0a06783 	ldbu	r2,-32354(gp)
81116b88:	10800044 	addi	r2,r2,1
81116b8c:	d0a06785 	stb	r2,-32354(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
81116b90:	d0a06e17 	ldw	r2,-32328(gp)
81116b94:	1009883a 	mov	r4,r2
81116b98:	113e05c0 	call	8113e05c <OSSemPost>
81116b9c:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81116ba0:	e0bfff83 	ldbu	r2,-2(fp)
81116ba4:	10803fcc 	andi	r2,r2,255
81116ba8:	10000426 	beq	r2,zero,81116bbc <vCheckRetransmission32+0x284>
                        SemCount32--;
81116bac:	d0a06783 	ldbu	r2,-32354(gp)
81116bb0:	10bfffc4 	addi	r2,r2,-1
81116bb4:	d0a06785 	stb	r2,-32354(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81116bb8:	111b1300 	call	8111b130 <vFailSetCountSemaphorexBuffer32>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81116bbc:	e0bfff03 	ldbu	r2,-4(fp)
81116bc0:	10800044 	addi	r2,r2,1
81116bc4:	e0bfff05 	stb	r2,-4(fp)
81116bc8:	e0bfff03 	ldbu	r2,-4(fp)
81116bcc:	10800230 	cmpltui	r2,r2,8
81116bd0:	103f6c1e 	bne	r2,zero,81116984 <__reset+0xfb0f6984>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
81116bd4:	d0a06b17 	ldw	r2,-32340(gp)
81116bd8:	1009883a 	mov	r4,r2
81116bdc:	113c26c0 	call	8113c26c <OSMutexPost>

    return;
81116be0:	0001883a 	nop
81116be4:	00000106 	br	81116bec <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81116be8:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
81116bec:	e037883a 	mov	sp,fp
81116bf0:	dfc00117 	ldw	ra,4(sp)
81116bf4:	df000017 	ldw	fp,0(sp)
81116bf8:	dec00204 	addi	sp,sp,8
81116bfc:	f800283a 	ret

81116c00 <bResourcesInitRTOS>:
 */
TSimucam_MEB xSimMeb; /* Struct */
tDmaSim xDma[2];		  /* Control of the DMA */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
81116c00:	defff904 	addi	sp,sp,-28
81116c04:	de00012e 	bgeu	sp,et,81116c0c <bResourcesInitRTOS+0xc>
81116c08:	003b68fa 	trap	3
81116c0c:	dfc00615 	stw	ra,24(sp)
81116c10:	df000515 	stw	fp,20(sp)
81116c14:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
81116c18:	00800044 	movi	r2,1
81116c1c:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
81116c20:	0009883a 	mov	r4,zero
81116c24:	113d9ac0 	call	8113d9ac <OSSemCreate>
81116c28:	d0a05f15 	stw	r2,-32388(gp)
	if (!xSemCommInit) {
81116c2c:	d0a05f17 	ldw	r2,-32388(gp)
81116c30:	1000021e 	bne	r2,zero,81116c3c <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
81116c34:	111abc80 	call	8111abc8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81116c38:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
81116c3c:	e0bfff04 	addi	r2,fp,-4
81116c40:	100b883a 	mov	r5,r2
81116c44:	01000444 	movi	r4,17
81116c48:	113b7f40 	call	8113b7f4 <OSMutexCreate>
81116c4c:	d0a07315 	stw	r2,-32308(gp)
	if ( err != OS_ERR_NONE ) {
81116c50:	e0bfff03 	ldbu	r2,-4(fp)
81116c54:	10803fcc 	andi	r2,r2,255
81116c58:	10000526 	beq	r2,zero,81116c70 <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
81116c5c:	e0bfff03 	ldbu	r2,-4(fp)
81116c60:	10803fcc 	andi	r2,r2,255
81116c64:	1009883a 	mov	r4,r2
81116c68:	111ab1c0 	call	8111ab1c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81116c6c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
81116c70:	e0bfff04 	addi	r2,fp,-4
81116c74:	100b883a 	mov	r5,r2
81116c78:	01000504 	movi	r4,20
81116c7c:	113b7f40 	call	8113b7f4 <OSMutexCreate>
81116c80:	d0a06d15 	stw	r2,-32332(gp)
	if ( err != OS_ERR_NONE ) {
81116c84:	e0bfff03 	ldbu	r2,-4(fp)
81116c88:	10803fcc 	andi	r2,r2,255
81116c8c:	10000526 	beq	r2,zero,81116ca4 <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
81116c90:	e0bfff03 	ldbu	r2,-4(fp)
81116c94:	10803fcc 	andi	r2,r2,255
81116c98:	1009883a 	mov	r4,r2
81116c9c:	111ab1c0 	call	8111ab1c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81116ca0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
81116ca4:	e0bfff04 	addi	r2,fp,-4
81116ca8:	100b883a 	mov	r5,r2
81116cac:	01000544 	movi	r4,21
81116cb0:	113b7f40 	call	8113b7f4 <OSMutexCreate>
81116cb4:	d0a07015 	stw	r2,-32320(gp)
	if ( err != OS_ERR_NONE ) {
81116cb8:	e0bfff03 	ldbu	r2,-4(fp)
81116cbc:	10803fcc 	andi	r2,r2,255
81116cc0:	10000526 	beq	r2,zero,81116cd8 <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
81116cc4:	e0bfff03 	ldbu	r2,-4(fp)
81116cc8:	10803fcc 	andi	r2,r2,255
81116ccc:	1009883a 	mov	r4,r2
81116cd0:	111ab1c0 	call	8111ab1c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81116cd4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
81116cd8:	e0bfff04 	addi	r2,fp,-4
81116cdc:	100b883a 	mov	r5,r2
81116ce0:	01000584 	movi	r4,22
81116ce4:	113b7f40 	call	8113b7f4 <OSMutexCreate>
81116ce8:	d0a06b15 	stw	r2,-32340(gp)
	if ( err != OS_ERR_NONE ) {
81116cec:	e0bfff03 	ldbu	r2,-4(fp)
81116cf0:	10803fcc 	andi	r2,r2,255
81116cf4:	10000526 	beq	r2,zero,81116d0c <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
81116cf8:	e0bfff03 	ldbu	r2,-4(fp)
81116cfc:	10803fcc 	andi	r2,r2,255
81116d00:	1009883a 	mov	r4,r2
81116d04:	111ab1c0 	call	8111ab1c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81116d08:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
81116d0c:	00800184 	movi	r2,6
81116d10:	d0a07445 	stb	r2,-32303(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
81116d14:	01000184 	movi	r4,6
81116d18:	113d9ac0 	call	8113d9ac <OSSemCreate>
81116d1c:	d0a06215 	stw	r2,-32376(gp)
	if (!xSemCountBuffer128) {
81116d20:	d0a06217 	ldw	r2,-32376(gp)
81116d24:	1000031e 	bne	r2,zero,81116d34 <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
81116d28:	d0207445 	stb	zero,-32303(gp)
		vFailCreateSemaphoreResources();
81116d2c:	111abc80 	call	8111abc8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81116d30:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
81116d34:	00800204 	movi	r2,8
81116d38:	d0a07405 	stb	r2,-32304(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
81116d3c:	01000204 	movi	r4,8
81116d40:	113d9ac0 	call	8113d9ac <OSSemCreate>
81116d44:	d0a05d15 	stw	r2,-32396(gp)
	if (!xSemCountBuffer64) {
81116d48:	d0a05d17 	ldw	r2,-32396(gp)
81116d4c:	1000031e 	bne	r2,zero,81116d5c <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
81116d50:	d0207405 	stb	zero,-32304(gp)
		vFailCreateSemaphoreResources();
81116d54:	111abc80 	call	8111abc8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81116d58:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
81116d5c:	00800204 	movi	r2,8
81116d60:	d0a06785 	stb	r2,-32354(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
81116d64:	01000204 	movi	r4,8
81116d68:	113d9ac0 	call	8113d9ac <OSSemCreate>
81116d6c:	d0a06e15 	stw	r2,-32328(gp)
	if (!xSemCountBuffer32) {
81116d70:	d0a06e17 	ldw	r2,-32328(gp)
81116d74:	1000031e 	bne	r2,zero,81116d84 <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
81116d78:	d0206785 	stb	zero,-32354(gp)
		vFailCreateSemaphoreResources();
81116d7c:	111abc80 	call	8111abc8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81116d80:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
81116d84:	e0bfff04 	addi	r2,fp,-4
81116d88:	100b883a 	mov	r5,r2
81116d8c:	010004c4 	movi	r4,19
81116d90:	113b7f40 	call	8113b7f4 <OSMutexCreate>
81116d94:	d0a06415 	stw	r2,-32368(gp)
	if ( err != OS_ERR_NONE ) {
81116d98:	e0bfff03 	ldbu	r2,-4(fp)
81116d9c:	10803fcc 	andi	r2,r2,255
81116da0:	10000526 	beq	r2,zero,81116db8 <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
81116da4:	e0bfff03 	ldbu	r2,-4(fp)
81116da8:	10803fcc 	andi	r2,r2,255
81116dac:	1009883a 	mov	r4,r2
81116db0:	111ab1c0 	call	8111ab1c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81116db4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
81116db8:	e0bfff04 	addi	r2,fp,-4
81116dbc:	100b883a 	mov	r5,r2
81116dc0:	010005c4 	movi	r4,23
81116dc4:	113b7f40 	call	8113b7f4 <OSMutexCreate>
81116dc8:	d0a06a15 	stw	r2,-32344(gp)
	if ( err != OS_ERR_NONE ) {
81116dcc:	e0bfff03 	ldbu	r2,-4(fp)
81116dd0:	10803fcc 	andi	r2,r2,255
81116dd4:	10000526 	beq	r2,zero,81116dec <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
81116dd8:	e0bfff03 	ldbu	r2,-4(fp)
81116ddc:	10803fcc 	andi	r2,r2,255
81116de0:	1009883a 	mov	r4,r2
81116de4:	111ab1c0 	call	8111ab1c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81116de8:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
81116dec:	0009883a 	mov	r4,zero
81116df0:	113d9ac0 	call	8113d9ac <OSSemCreate>
81116df4:	d0a06515 	stw	r2,-32364(gp)
	if (!xSemCountReceivedACK) {
81116df8:	d0a06517 	ldw	r2,-32364(gp)
81116dfc:	1000021e 	bne	r2,zero,81116e08 <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
81116e00:	111abc80 	call	8111abc8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81116e04:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
81116e08:	0009883a 	mov	r4,zero
81116e0c:	113d9ac0 	call	8113d9ac <OSSemCreate>
81116e10:	d0a06315 	stw	r2,-32372(gp)
	if (!xSemCountPreParsed) {
81116e14:	d0a06317 	ldw	r2,-32372(gp)
81116e18:	1000021e 	bne	r2,zero,81116e24 <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
81116e1c:	111abc80 	call	8111abc8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81116e20:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
81116e24:	0009883a 	mov	r4,zero
81116e28:	113d9ac0 	call	8113d9ac <OSSemCreate>
81116e2c:	d0a06015 	stw	r2,-32384(gp)
	if (!xSemCountSenderACK) {
81116e30:	d0a06017 	ldw	r2,-32384(gp)
81116e34:	1000021e 	bne	r2,zero,81116e40 <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
81116e38:	111abc80 	call	8111abc8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81116e3c:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
81116e40:	e0bfff04 	addi	r2,fp,-4
81116e44:	100b883a 	mov	r5,r2
81116e48:	01000484 	movi	r4,18
81116e4c:	113b7f40 	call	8113b7f4 <OSMutexCreate>
81116e50:	d0a07115 	stw	r2,-32316(gp)
	if ( err != OS_ERR_NONE ) {
81116e54:	e0bfff03 	ldbu	r2,-4(fp)
81116e58:	10803fcc 	andi	r2,r2,255
81116e5c:	10000526 	beq	r2,zero,81116e74 <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
81116e60:	e0bfff03 	ldbu	r2,-4(fp)
81116e64:	10803fcc 	andi	r2,r2,255
81116e68:	1009883a 	mov	r4,r2
81116e6c:	111ab1c0 	call	8111ab1c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81116e70:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
81116e74:	0009883a 	mov	r4,zero
81116e78:	113d9ac0 	call	8113d9ac <OSSemCreate>
81116e7c:	d0a06615 	stw	r2,-32360(gp)
	if (!xSemTimeoutChecker) {
81116e80:	d0a06617 	ldw	r2,-32360(gp)
81116e84:	1000021e 	bne	r2,zero,81116e90 <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
81116e88:	111abc80 	call	8111abc8 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81116e8c:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
81116e90:	e0bfff04 	addi	r2,fp,-4
81116e94:	d8800215 	stw	r2,8(sp)
81116e98:	00a04574 	movhi	r2,33045
81116e9c:	10b5cd04 	addi	r2,r2,-10444
81116ea0:	d8800115 	stw	r2,4(sp)
81116ea4:	d8000015 	stw	zero,0(sp)
81116ea8:	01e044b4 	movhi	r7,33042
81116eac:	39e29604 	addi	r7,r7,-30120
81116eb0:	01800084 	movi	r6,2
81116eb4:	01400104 	movi	r5,4
81116eb8:	01000284 	movi	r4,10
81116ebc:	11400780 	call	81140078 <OSTmrCreate>
81116ec0:	d0a06c15 	stw	r2,-32336(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
81116ec4:	e0bfff03 	ldbu	r2,-4(fp)
81116ec8:	10803fcc 	andi	r2,r2,255
81116ecc:	10000226 	beq	r2,zero,81116ed8 <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
81116ed0:	111b82c0 	call	8111b82c <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
81116ed4:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
81116ed8:	01400484 	movi	r5,18
81116edc:	01204574 	movhi	r4,33045
81116ee0:	21183704 	addi	r4,r4,24796
81116ee4:	113c8e00 	call	8113c8e0 <OSQCreate>
81116ee8:	d0a05c15 	stw	r2,-32400(gp)
	if ( xNfeeSchedule == NULL ) {
81116eec:	d0a05c17 	ldw	r2,-32400(gp)
81116ef0:	1000021e 	bne	r2,zero,81116efc <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
81116ef4:	111be100 	call	8111be10 <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
81116ef8:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
81116efc:	01400204 	movi	r5,8
81116f00:	012045b4 	movhi	r4,33046
81116f04:	21174904 	addi	r4,r4,23844
81116f08:	113c8e00 	call	8113c8e0 <OSQCreate>
81116f0c:	d0a06915 	stw	r2,-32348(gp)
	if ( xFeeQ[0] == NULL ) {
81116f10:	d0a06917 	ldw	r2,-32348(gp)
81116f14:	1000031e 	bne	r2,zero,81116f24 <bResourcesInitRTOS+0x324>
		vFailCreateNFEEQueue( 0 );
81116f18:	0009883a 	mov	r4,zero
81116f1c:	111be780 	call	8111be78 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81116f20:	e03ffe15 	stw	zero,-8(fp)
		bSuccess = FALSE;		
	}
*/


	xWaitSyncQFee[0] = OSQCreate(&SyncTBL0[0], N_MSG_SYNC);
81116f24:	01400204 	movi	r5,8
81116f28:	012045b4 	movhi	r4,33046
81116f2c:	213c8f04 	addi	r4,r4,-3524
81116f30:	113c8e00 	call	8113c8e0 <OSQCreate>
81116f34:	d0a05b15 	stw	r2,-32404(gp)
	if ( xWaitSyncQFee[0] == NULL ) {
81116f38:	d0a05b17 	ldw	r2,-32404(gp)
81116f3c:	1000031e 	bne	r2,zero,81116f4c <bResourcesInitRTOS+0x34c>
		vFailCreateNFEESyncQueue( 0 );
81116f40:	0009883a 	mov	r4,zero
81116f44:	111bee80 	call	8111bee8 <vFailCreateNFEESyncQueue>
		bSuccess = FALSE;
81116f48:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
81116f4c:	01400204 	movi	r5,8
81116f50:	012045b4 	movhi	r4,33046
81116f54:	21378d04 	addi	r4,r4,-8652
81116f58:	113c8e00 	call	8113c8e0 <OSQCreate>
81116f5c:	d0a06815 	stw	r2,-32352(gp)
	if ( xMebQ == NULL ) {
81116f60:	d0a06817 	ldw	r2,-32352(gp)
81116f64:	1000031e 	bne	r2,zero,81116f74 <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 5 );
81116f68:	01000144 	movi	r4,5
81116f6c:	111be780 	call	8111be78 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81116f70:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
81116f74:	e0bfff04 	addi	r2,fp,-4
81116f78:	100b883a 	mov	r5,r2
81116f7c:	010001c4 	movi	r4,7
81116f80:	113b7f40 	call	8113b7f4 <OSMutexCreate>
81116f84:	d0a07215 	stw	r2,-32312(gp)
	if ( err != OS_ERR_NONE ) {
81116f88:	e0bfff03 	ldbu	r2,-4(fp)
81116f8c:	10803fcc 	andi	r2,r2,255
81116f90:	10000526 	beq	r2,zero,81116fa8 <bResourcesInitRTOS+0x3a8>
		vFailCreateMutexSPUSQueueMeb(err);
81116f94:	e0bfff03 	ldbu	r2,-4(fp)
81116f98:	10803fcc 	andi	r2,r2,255
81116f9c:	1009883a 	mov	r4,r2
81116fa0:	111c3000 	call	8111c300 <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
81116fa4:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81116fa8:	01400404 	movi	r5,16
81116fac:	012045b4 	movhi	r4,33046
81116fb0:	21386704 	addi	r4,r4,-7780
81116fb4:	113c8e00 	call	8113c8e0 <OSQCreate>
81116fb8:	d0a06f15 	stw	r2,-32324(gp)
	if ( xQMaskFeeCtrl == NULL ) {
81116fbc:	d0a06f17 	ldw	r2,-32324(gp)
81116fc0:	1000021e 	bne	r2,zero,81116fcc <bResourcesInitRTOS+0x3cc>
		vCouldNotCreateQueueMaskNfeeCtrl( );
81116fc4:	111c4600 	call	8111c460 <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
81116fc8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskDataCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81116fcc:	01400404 	movi	r5,16
81116fd0:	012045b4 	movhi	r4,33046
81116fd4:	212b4f04 	addi	r4,r4,-21188
81116fd8:	113c8e00 	call	8113c8e0 <OSQCreate>
81116fdc:	d0a05e15 	stw	r2,-32392(gp)
	if ( xQMaskDataCtrl == NULL ) {
81116fe0:	d0a05e17 	ldw	r2,-32392(gp)
81116fe4:	1000021e 	bne	r2,zero,81116ff0 <bResourcesInitRTOS+0x3f0>
		vCouldNotCreateQueueMaskDataCtrl( );
81116fe8:	111c4c80 	call	8111c4c8 <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
81116fec:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[0].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_0, &err);
81116ff0:	e0bfff04 	addi	r2,fp,-4
81116ff4:	100b883a 	mov	r5,r2
81116ff8:	01000104 	movi	r4,4
81116ffc:	113b7f40 	call	8113b7f4 <OSMutexCreate>
81117000:	1007883a 	mov	r3,r2
81117004:	00a045b4 	movhi	r2,33046
81117008:	108a9d04 	addi	r2,r2,10868
8111700c:	10c00015 	stw	r3,0(r2)
	if ( err != OS_ERR_NONE ) {
81117010:	e0bfff03 	ldbu	r2,-4(fp)
81117014:	10803fcc 	andi	r2,r2,255
81117018:	10000226 	beq	r2,zero,81117024 <bResourcesInitRTOS+0x424>
		vFailCreateMutexDMA();
8111701c:	111ab7c0 	call	8111ab7c <vFailCreateMutexDMA>
		bSuccess = FALSE;
81117020:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[1].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_1, &err);
81117024:	e0bfff04 	addi	r2,fp,-4
81117028:	100b883a 	mov	r5,r2
8111702c:	01000184 	movi	r4,6
81117030:	113b7f40 	call	8113b7f4 <OSMutexCreate>
81117034:	1007883a 	mov	r3,r2
81117038:	00a045b4 	movhi	r2,33046
8111703c:	108a9d04 	addi	r2,r2,10868
81117040:	10c00215 	stw	r3,8(r2)
	if ( err != OS_ERR_NONE ) {
81117044:	e0bfff03 	ldbu	r2,-4(fp)
81117048:	10803fcc 	andi	r2,r2,255
8111704c:	10000226 	beq	r2,zero,81117058 <bResourcesInitRTOS+0x458>
		vFailCreateMutexDMA();
81117050:	111ab7c0 	call	8111ab7c <vFailCreateMutexDMA>
		bSuccess = FALSE;
81117054:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
81117058:	e0bffe17 	ldw	r2,-8(fp)
}
8111705c:	e037883a 	mov	sp,fp
81117060:	dfc00117 	ldw	ra,4(sp)
81117064:	df000017 	ldw	fp,0(sp)
81117068:	dec00204 	addi	sp,sp,8
8111706c:	f800283a 	ret

81117070 <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
81117070:	defffd04 	addi	sp,sp,-12
81117074:	de00012e 	bgeu	sp,et,8111707c <vVariablesInitialization+0xc>
81117078:	003b68fa 	trap	3
8111707c:	dfc00215 	stw	ra,8(sp)
81117080:	df000115 	stw	fp,4(sp)
81117084:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
81117088:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
8111708c:	00800084 	movi	r2,2
81117090:	d0a0670d 	sth	r2,-32356(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
81117094:	01800604 	movi	r6,24
81117098:	000b883a 	mov	r5,zero
8111709c:	012045b4 	movhi	r4,33046
811170a0:	21377704 	addi	r4,r4,-8740
811170a4:	11219b80 	call	811219b8 <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
811170a8:	01800804 	movi	r6,32
811170ac:	000b883a 	mov	r5,zero
811170b0:	012045b4 	movhi	r4,33046
811170b4:	21377d04 	addi	r4,r4,-8716
811170b8:	11219b80 	call	811219b8 <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
811170bc:	01800804 	movi	r6,32
811170c0:	000b883a 	mov	r5,zero
811170c4:	012045b4 	movhi	r4,33046
811170c8:	21378504 	addi	r4,r4,-8684
811170cc:	11219b80 	call	811219b8 <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
811170d0:	e03fff05 	stb	zero,-4(fp)
811170d4:	00002806 	br	81117178 <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
811170d8:	e0bfff03 	ldbu	r2,-4(fp)
811170dc:	10c02324 	muli	r3,r2,140
811170e0:	00a045b4 	movhi	r2,33046
811170e4:	10b79504 	addi	r2,r2,-8620
811170e8:	1885883a 	add	r2,r3,r2
811170ec:	01802004 	movi	r6,128
811170f0:	000b883a 	mov	r5,zero
811170f4:	1009883a 	mov	r4,r2
811170f8:	11219b80 	call	811219b8 <memset>
		xBuffer128[ucIL].bSent = FALSE;
811170fc:	e0ffff03 	ldbu	r3,-4(fp)
81117100:	00a045b4 	movhi	r2,33046
81117104:	10b79504 	addi	r2,r2,-8620
81117108:	18c02324 	muli	r3,r3,140
8111710c:	10c5883a 	add	r2,r2,r3
81117110:	10802004 	addi	r2,r2,128
81117114:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
81117118:	e0ffff03 	ldbu	r3,-4(fp)
8111711c:	00a045b4 	movhi	r2,33046
81117120:	10b79504 	addi	r2,r2,-8620
81117124:	18c02324 	muli	r3,r3,140
81117128:	10c5883a 	add	r2,r2,r3
8111712c:	10802104 	addi	r2,r2,132
81117130:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
81117134:	e0ffff03 	ldbu	r3,-4(fp)
81117138:	00a045b4 	movhi	r2,33046
8111713c:	10b79504 	addi	r2,r2,-8620
81117140:	18c02324 	muli	r3,r3,140
81117144:	10c5883a 	add	r2,r2,r3
81117148:	10802184 	addi	r2,r2,134
8111714c:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
81117150:	e0ffff03 	ldbu	r3,-4(fp)
81117154:	00a045b4 	movhi	r2,33046
81117158:	10b79504 	addi	r2,r2,-8620
8111715c:	18c02324 	muli	r3,r3,140
81117160:	10c5883a 	add	r2,r2,r3
81117164:	10802204 	addi	r2,r2,136
81117168:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
8111716c:	e0bfff03 	ldbu	r2,-4(fp)
81117170:	10800044 	addi	r2,r2,1
81117174:	e0bfff05 	stb	r2,-4(fp)
81117178:	e0bfff03 	ldbu	r2,-4(fp)
8111717c:	108001b0 	cmpltui	r2,r2,6
81117180:	103fd51e 	bne	r2,zero,811170d8 <__reset+0xfb0f70d8>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81117184:	e03fff05 	stb	zero,-4(fp)
81117188:	00002806 	br	8111722c <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
8111718c:	e0bfff03 	ldbu	r2,-4(fp)
81117190:	10c01324 	muli	r3,r2,76
81117194:	00a04574 	movhi	r2,33045
81117198:	10933b04 	addi	r2,r2,19692
8111719c:	1885883a 	add	r2,r3,r2
811171a0:	01801004 	movi	r6,64
811171a4:	000b883a 	mov	r5,zero
811171a8:	1009883a 	mov	r4,r2
811171ac:	11219b80 	call	811219b8 <memset>
		xBuffer64[ucIL].bSent = FALSE;
811171b0:	e0ffff03 	ldbu	r3,-4(fp)
811171b4:	00a04574 	movhi	r2,33045
811171b8:	10933b04 	addi	r2,r2,19692
811171bc:	18c01324 	muli	r3,r3,76
811171c0:	10c5883a 	add	r2,r2,r3
811171c4:	10801004 	addi	r2,r2,64
811171c8:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
811171cc:	e0ffff03 	ldbu	r3,-4(fp)
811171d0:	00a04574 	movhi	r2,33045
811171d4:	10933b04 	addi	r2,r2,19692
811171d8:	18c01324 	muli	r3,r3,76
811171dc:	10c5883a 	add	r2,r2,r3
811171e0:	10801104 	addi	r2,r2,68
811171e4:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
811171e8:	e0ffff03 	ldbu	r3,-4(fp)
811171ec:	00a04574 	movhi	r2,33045
811171f0:	10933b04 	addi	r2,r2,19692
811171f4:	18c01324 	muli	r3,r3,76
811171f8:	10c5883a 	add	r2,r2,r3
811171fc:	10801184 	addi	r2,r2,70
81117200:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
81117204:	e0ffff03 	ldbu	r3,-4(fp)
81117208:	00a04574 	movhi	r2,33045
8111720c:	10933b04 	addi	r2,r2,19692
81117210:	18c01324 	muli	r3,r3,76
81117214:	10c5883a 	add	r2,r2,r3
81117218:	10801204 	addi	r2,r2,72
8111721c:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81117220:	e0bfff03 	ldbu	r2,-4(fp)
81117224:	10800044 	addi	r2,r2,1
81117228:	e0bfff05 	stb	r2,-4(fp)
8111722c:	e0bfff03 	ldbu	r2,-4(fp)
81117230:	10800230 	cmpltui	r2,r2,8
81117234:	103fd51e 	bne	r2,zero,8111718c <__reset+0xfb0f718c>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81117238:	e03fff05 	stb	zero,-4(fp)
8111723c:	00002806 	br	811172e0 <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
81117240:	e0bfff03 	ldbu	r2,-4(fp)
81117244:	10c00b24 	muli	r3,r2,44
81117248:	00a045b4 	movhi	r2,33046
8111724c:	10a4f704 	addi	r2,r2,-27684
81117250:	1885883a 	add	r2,r3,r2
81117254:	01800804 	movi	r6,32
81117258:	000b883a 	mov	r5,zero
8111725c:	1009883a 	mov	r4,r2
81117260:	11219b80 	call	811219b8 <memset>
		xBuffer32[ucIL].bSent = FALSE;
81117264:	e0ffff03 	ldbu	r3,-4(fp)
81117268:	00a045b4 	movhi	r2,33046
8111726c:	10a4f704 	addi	r2,r2,-27684
81117270:	18c00b24 	muli	r3,r3,44
81117274:	10c5883a 	add	r2,r2,r3
81117278:	10800804 	addi	r2,r2,32
8111727c:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
81117280:	e0ffff03 	ldbu	r3,-4(fp)
81117284:	00a045b4 	movhi	r2,33046
81117288:	10a4f704 	addi	r2,r2,-27684
8111728c:	18c00b24 	muli	r3,r3,44
81117290:	10c5883a 	add	r2,r2,r3
81117294:	10800904 	addi	r2,r2,36
81117298:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
8111729c:	e0ffff03 	ldbu	r3,-4(fp)
811172a0:	00a045b4 	movhi	r2,33046
811172a4:	10a4f704 	addi	r2,r2,-27684
811172a8:	18c00b24 	muli	r3,r3,44
811172ac:	10c5883a 	add	r2,r2,r3
811172b0:	10800984 	addi	r2,r2,38
811172b4:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
811172b8:	e0ffff03 	ldbu	r3,-4(fp)
811172bc:	00a045b4 	movhi	r2,33046
811172c0:	10a4f704 	addi	r2,r2,-27684
811172c4:	18c00b24 	muli	r3,r3,44
811172c8:	10c5883a 	add	r2,r2,r3
811172cc:	10800a04 	addi	r2,r2,40
811172d0:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
811172d4:	e0bfff03 	ldbu	r2,-4(fp)
811172d8:	10800044 	addi	r2,r2,1
811172dc:	e0bfff05 	stb	r2,-4(fp)
811172e0:	e0bfff03 	ldbu	r2,-4(fp)
811172e4:	10800230 	cmpltui	r2,r2,8
811172e8:	103fd51e 	bne	r2,zero,81117240 <__reset+0xfb0f7240>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
811172ec:	e03fff05 	stb	zero,-4(fp)
811172f0:	00001b06 	br	81117360 <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
811172f4:	e0ffff03 	ldbu	r3,-4(fp)
811172f8:	00a04574 	movhi	r2,33045
811172fc:	1093d304 	addi	r2,r2,20300
81117300:	18c01524 	muli	r3,r3,84
81117304:	10c5883a 	add	r2,r2,r3
81117308:	10800104 	addi	r2,r2,4
8111730c:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
81117310:	e0ffff03 	ldbu	r3,-4(fp)
81117314:	00a04574 	movhi	r2,33045
81117318:	1093d304 	addi	r2,r2,20300
8111731c:	18c01524 	muli	r3,r3,84
81117320:	10c5883a 	add	r2,r2,r3
81117324:	10800484 	addi	r2,r2,18
81117328:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
8111732c:	e0bfff03 	ldbu	r2,-4(fp)
81117330:	10801524 	muli	r2,r2,84
81117334:	10c00504 	addi	r3,r2,20
81117338:	00a04574 	movhi	r2,33045
8111733c:	1093d304 	addi	r2,r2,20300
81117340:	1885883a 	add	r2,r3,r2
81117344:	01801004 	movi	r6,64
81117348:	000b883a 	mov	r5,zero
8111734c:	1009883a 	mov	r4,r2
81117350:	11219b80 	call	811219b8 <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81117354:	e0bfff03 	ldbu	r2,-4(fp)
81117358:	10800044 	addi	r2,r2,1
8111735c:	e0bfff05 	stb	r2,-4(fp)
81117360:	e0bfff03 	ldbu	r2,-4(fp)
81117364:	10800130 	cmpltui	r2,r2,4
81117368:	103fe21e 	bne	r2,zero,811172f4 <__reset+0xfb0f72f4>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
8111736c:	0001883a 	nop
81117370:	e037883a 	mov	sp,fp
81117374:	dfc00117 	ldw	ra,4(sp)
81117378:	df000017 	ldw	fp,0(sp)
8111737c:	dec00204 	addi	sp,sp,8
81117380:	f800283a 	ret

81117384 <main>:
void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
81117384:	defff704 	addi	sp,sp,-36
81117388:	de00012e 	bgeu	sp,et,81117390 <main+0xc>
8111738c:	003b68fa 	trap	3
81117390:	dfc00815 	stw	ra,32(sp)
81117394:	df000715 	stw	fp,28(sp)
81117398:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
8111739c:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
811173a0:	1137c900 	call	81137c90 <OSInit>

	/* Debug device initialization - JTAG USB */
	#ifdef DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
811173a4:	01604574 	movhi	r5,33045
811173a8:	2975d104 	addi	r5,r5,-10428
811173ac:	01204574 	movhi	r4,33045
811173b0:	2135d204 	addi	r4,r4,-10424
811173b4:	11207700 	call	81120770 <fopen>
811173b8:	d0a06115 	stw	r2,-32380(gp)
	#endif	

	#ifdef DEBUG_ON
		debug(fp, "Main entry point.\n");
811173bc:	d0a06117 	ldw	r2,-32380(gp)
811173c0:	100f883a 	mov	r7,r2
811173c4:	01800484 	movi	r6,18
811173c8:	01400044 	movi	r5,1
811173cc:	01204574 	movhi	r4,33045
811173d0:	2135d704 	addi	r4,r4,-10404
811173d4:	1120e540 	call	81120e54 <fwrite>
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
811173d8:	111d4ac0 	call	8111d4ac <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
811173dc:	111e1040 	call	8111e104 <bTestSimucamCriticalHW>
811173e0:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811173e4:	e0bffe17 	ldw	r2,-8(fp)
811173e8:	1000031e 	bne	r2,zero,811173f8 <main+0x74>
		vFailTestCriticasParts();
811173ec:	111ac140 	call	8111ac14 <vFailTestCriticasParts>
		return -1;
811173f0:	00bfffc4 	movi	r2,-1
811173f4:	00004b06 	br	81117524 <main+0x1a0>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
811173f8:	111dc2c0 	call	8111dc2c <bInitializeSDCard>
811173fc:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117400:	e0bffe17 	ldw	r2,-8(fp)
81117404:	1000031e 	bne	r2,zero,81117414 <main+0x90>
		vFailTestCriticasParts();
81117408:	111ac140 	call	8111ac14 <vFailTestCriticasParts>
		return -1;
8111740c:	00bfffc4 	movi	r2,-1
81117410:	00004406 	br	81117524 <main+0x1a0>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
81117414:	1118e800 	call	81118e80 <vLoadDefaultETHConf>
81117418:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
8111741c:	e0bffe17 	ldw	r2,-8(fp)
81117420:	1000091e 	bne	r2,zero,81117448 <main+0xc4>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. \n");
81117424:	d0a06117 	ldw	r2,-32380(gp)
81117428:	100f883a 	mov	r7,r2
8111742c:	01801484 	movi	r6,82
81117430:	01400044 	movi	r5,1
81117434:	01204574 	movhi	r4,33045
81117438:	2135dc04 	addi	r4,r4,-10384
8111743c:	1120e540 	call	81120e54 <fwrite>
		#endif
		return -1;
81117440:	00bfffc4 	movi	r2,-1
81117444:	00003706 	br	81117524 <main+0x1a0>
	}

	bIniSimucamStatus = vLoadDebugConfs();
81117448:	1119b880 	call	81119b88 <vLoadDebugConfs>
8111744c:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117450:	e0bffe17 	ldw	r2,-8(fp)
81117454:	1000091e 	bne	r2,zero,8111747c <main+0xf8>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load DEBUG configuration from SDCard. Default configuration will be loaded. \n");
81117458:	d0a06117 	ldw	r2,-32380(gp)
8111745c:	100f883a 	mov	r7,r2
81117460:	01801504 	movi	r6,84
81117464:	01400044 	movi	r5,1
81117468:	01204574 	movhi	r4,33045
8111746c:	2135f104 	addi	r4,r4,-10300
81117470:	1120e540 	call	81120e54 <fwrite>
		#endif
		return -1;
81117474:	00bfffc4 	movi	r2,-1
81117478:	00002a06 	br	81117524 <main+0x1a0>



	/* If debug is enable, will print the eth configuration in the*/
	#ifdef DEBUG_ON
		vShowEthConfig();
8111747c:	11198580 	call	81119858 <vShowEthConfig>
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
81117480:	1116c000 	call	81116c00 <bResourcesInitRTOS>
81117484:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81117488:	e0bffe17 	ldw	r2,-8(fp)
8111748c:	1000091e 	bne	r2,zero,811174b4 <main+0x130>
		/* Default configuration for eth connection loaded */
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
81117490:	d0a06117 	ldw	r2,-32380(gp)
81117494:	100f883a 	mov	r7,r2
81117498:	01800ac4 	movi	r6,43
8111749c:	01400044 	movi	r5,1
811174a0:	01204574 	movhi	r4,33045
811174a4:	21360704 	addi	r4,r4,-10212
811174a8:	1120e540 	call	81120e54 <fwrite>
		return -1;
811174ac:	00bfffc4 	movi	r2,-1
811174b0:	00001c06 	br	81117524 <main+0x1a0>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
811174b4:	012045b4 	movhi	r4,33046
811174b8:	21204904 	addi	r4,r4,-32476
811174bc:	111d5ec0 	call	8111d5ec <vSimucamStructureInit>

	vVariablesInitialization();
811174c0:	11170700 	call	81117070 <vVariablesInitialization>

	bInitSync();
811174c4:	111dde00 	call	8111dde0 <bInitSync>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
811174c8:	d8000415 	stw	zero,16(sp)
811174cc:	d8000315 	stw	zero,12(sp)
811174d0:	00810004 	movi	r2,1024
811174d4:	d8800215 	stw	r2,8(sp)
811174d8:	00a045b4 	movhi	r2,33046
811174dc:	10af6f04 	addi	r2,r2,-16964
811174e0:	d8800115 	stw	r2,4(sp)
811174e4:	00800044 	movi	r2,1
811174e8:	d8800015 	stw	r2,0(sp)
811174ec:	01c00044 	movi	r7,1
811174f0:	01a045b4 	movhi	r6,33046
811174f4:	31b36e04 	addi	r6,r6,-12872
811174f8:	000b883a 	mov	r5,zero
811174fc:	01204474 	movhi	r4,33041
81117500:	2106be04 	addi	r4,r4,6904
81117504:	113ea400 	call	8113ea40 <OSTaskCreateExt>
81117508:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
8111750c:	e0bfff03 	ldbu	r2,-4(fp)
81117510:	1000021e 	bne	r2,zero,8111751c <main+0x198>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
81117514:	1137fc00 	call	81137fc0 <OSStart>
81117518:	00000106 	br	81117520 <main+0x19c>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
8111751c:	111b0000 	call	8111b000 <vFailInitialization>
	}
  
	return 0;
81117520:	0005883a 	mov	r2,zero
}
81117524:	e037883a 	mov	sp,fp
81117528:	dfc00117 	ldw	ra,4(sp)
8111752c:	df000017 	ldw	fp,0(sp)
81117530:	dec00204 	addi	sp,sp,8
81117534:	f800283a 	ret

81117538 <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81117538:	defff604 	addi	sp,sp,-40
8111753c:	de00012e 	bgeu	sp,et,81117544 <vFillMemmoryPattern+0xc>
81117540:	003b68fa 	trap	3
81117544:	dfc00915 	stw	ra,36(sp)
81117548:	df000815 	stw	fp,32(sp)
8111754c:	df000804 	addi	fp,sp,32
81117550:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
81117554:	00800044 	movi	r2,1
81117558:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
8111755c:	d0a06117 	ldw	r2,-32380(gp)
81117560:	100f883a 	mov	r7,r2
81117564:	018009c4 	movi	r6,39
81117568:	01400044 	movi	r5,1
8111756c:	01204574 	movhi	r4,33045
81117570:	21361204 	addi	r4,r4,-10168
81117574:	1120e540 	call	81120e54 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81117578:	e03ffa05 	stb	zero,-24(fp)
8111757c:	00007606 	br	81117758 <vFillMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81117580:	e03ffc85 	stb	zero,-14(fp)
81117584:	00006706 	br	81117724 <vFillMemmoryPattern+0x1ec>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81117588:	e0bffc83 	ldbu	r2,-14(fp)
8111758c:	e0ffff17 	ldw	r3,-4(fp)
81117590:	10809624 	muli	r2,r2,600
81117594:	1885883a 	add	r2,r3,r2
81117598:	10804304 	addi	r2,r2,268
8111759c:	1080000b 	ldhu	r2,0(r2)
811175a0:	10ffffcc 	andi	r3,r2,65535
811175a4:	e0bffc83 	ldbu	r2,-14(fp)
811175a8:	e13fff17 	ldw	r4,-4(fp)
811175ac:	10809624 	muli	r2,r2,600
811175b0:	2085883a 	add	r2,r4,r2
811175b4:	10804204 	addi	r2,r2,264
811175b8:	1080000b 	ldhu	r2,0(r2)
811175bc:	10bfffcc 	andi	r2,r2,65535
811175c0:	1885883a 	add	r2,r3,r2
811175c4:	e0bffd15 	stw	r2,-12(fp)
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
811175c8:	e0bffc83 	ldbu	r2,-14(fp)
811175cc:	e0ffff17 	ldw	r3,-4(fp)
811175d0:	10809624 	muli	r2,r2,600
811175d4:	1885883a 	add	r2,r3,r2
811175d8:	10804284 	addi	r2,r2,266
811175dc:	1080000b 	ldhu	r2,0(r2)
811175e0:	10ffffcc 	andi	r3,r2,65535
811175e4:	e0bffc83 	ldbu	r2,-14(fp)
811175e8:	e13fff17 	ldw	r4,-4(fp)
811175ec:	10809624 	muli	r2,r2,600
811175f0:	2085883a 	add	r2,r4,r2
811175f4:	10804184 	addi	r2,r2,262
811175f8:	1080000b 	ldhu	r2,0(r2)
811175fc:	10bfffcc 	andi	r2,r2,65535
81117600:	1887883a 	add	r3,r3,r2
81117604:	e0bffc83 	ldbu	r2,-14(fp)
81117608:	e13fff17 	ldw	r4,-4(fp)
8111760c:	10809624 	muli	r2,r2,600
81117610:	2085883a 	add	r2,r4,r2
81117614:	10804104 	addi	r2,r2,260
81117618:	1080000b 	ldhu	r2,0(r2)
8111761c:	10bfffcc 	andi	r2,r2,65535
81117620:	1885883a 	add	r2,r3,r2
81117624:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81117628:	e03ffc05 	stb	zero,-16(fp)
8111762c:	00003706 	br	8111770c <vFillMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81117630:	e03ffc45 	stb	zero,-15(fp)
81117634:	00002606 	br	811176d0 <vFillMemmoryPattern+0x198>
					if (ccd_side == 0){
81117638:	e0bffc43 	ldbu	r2,-15(fp)
8111763c:	10000b1e 	bne	r2,zero,8111766c <vFillMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81117640:	e0bffc83 	ldbu	r2,-14(fp)
81117644:	e13ffc03 	ldbu	r4,-16(fp)
81117648:	e0ffff17 	ldw	r3,-4(fp)
8111764c:	21000624 	muli	r4,r4,24
81117650:	10809624 	muli	r2,r2,600
81117654:	2085883a 	add	r2,r4,r2
81117658:	1885883a 	add	r2,r3,r2
8111765c:	10801b04 	addi	r2,r2,108
81117660:	10800017 	ldw	r2,0(r2)
81117664:	e0bffb15 	stw	r2,-20(fp)
81117668:	00000a06 	br	81117694 <vFillMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
8111766c:	e0bffc83 	ldbu	r2,-14(fp)
81117670:	e13ffc03 	ldbu	r4,-16(fp)
81117674:	e0ffff17 	ldw	r3,-4(fp)
81117678:	21000624 	muli	r4,r4,24
8111767c:	10809624 	muli	r2,r2,600
81117680:	2085883a 	add	r2,r4,r2
81117684:	1885883a 	add	r2,r3,r2
81117688:	10801e04 	addi	r2,r2,120
8111768c:	10800017 	ldw	r2,0(r2)
81117690:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
81117694:	e0fffa03 	ldbu	r3,-24(fp)
81117698:	e13ffc03 	ldbu	r4,-16(fp)
8111769c:	e17ffc43 	ldbu	r5,-15(fp)
811176a0:	e0bffd17 	ldw	r2,-12(fp)
811176a4:	d8800115 	stw	r2,4(sp)
811176a8:	e0bffe17 	ldw	r2,-8(fp)
811176ac:	d8800015 	stw	r2,0(sp)
811176b0:	280f883a 	mov	r7,r5
811176b4:	200d883a 	mov	r6,r4
811176b8:	e17ffb17 	ldw	r5,-20(fp)
811176bc:	1809883a 	mov	r4,r3
811176c0:	111d9b00 	call	8111d9b0 <pattern_createPattern>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
811176c4:	e0bffc43 	ldbu	r2,-15(fp)
811176c8:	10800044 	addi	r2,r2,1
811176cc:	e0bffc45 	stb	r2,-15(fp)
811176d0:	e0bffc43 	ldbu	r2,-15(fp)
811176d4:	108000b0 	cmpltui	r2,r2,2
811176d8:	103fd71e 	bne	r2,zero,81117638 <__reset+0xfb0f7638>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
811176dc:	d0a06117 	ldw	r2,-32380(gp)
811176e0:	e0fffc83 	ldbu	r3,-14(fp)
811176e4:	e13ffc03 	ldbu	r4,-16(fp)
811176e8:	200f883a 	mov	r7,r4
811176ec:	180d883a 	mov	r6,r3
811176f0:	01604574 	movhi	r5,33045
811176f4:	29761c04 	addi	r5,r5,-10128
811176f8:	1009883a 	mov	r4,r2
811176fc:	11207b80 	call	811207b8 <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81117700:	e0bffc03 	ldbu	r2,-16(fp)
81117704:	10800044 	addi	r2,r2,1
81117708:	e0bffc05 	stb	r2,-16(fp)
8111770c:	e0bffc03 	ldbu	r2,-16(fp)
81117710:	10800130 	cmpltui	r2,r2,4
81117714:	103fc61e 	bne	r2,zero,81117630 <__reset+0xfb0f7630>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81117718:	e0bffc83 	ldbu	r2,-14(fp)
8111771c:	10800044 	addi	r2,r2,1
81117720:	e0bffc85 	stb	r2,-14(fp)
81117724:	e0fffc83 	ldbu	r3,-14(fp)
81117728:	e0bffcc3 	ldbu	r2,-13(fp)
8111772c:	18bf9636 	bltu	r3,r2,81117588 <__reset+0xfb0f7588>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
81117730:	d0a06117 	ldw	r2,-32380(gp)
81117734:	e0fffa03 	ldbu	r3,-24(fp)
81117738:	180d883a 	mov	r6,r3
8111773c:	01604574 	movhi	r5,33045
81117740:	29762104 	addi	r5,r5,-10108
81117744:	1009883a 	mov	r4,r2
81117748:	11207b80 	call	811207b8 <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
8111774c:	e0bffa03 	ldbu	r2,-24(fp)
81117750:	10800044 	addi	r2,r2,1
81117754:	e0bffa05 	stb	r2,-24(fp)
81117758:	e0bffa03 	ldbu	r2,-24(fp)
8111775c:	108000b0 	cmpltui	r2,r2,2
81117760:	103f871e 	bne	r2,zero,81117580 <__reset+0xfb0f7580>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
81117764:	d0a06117 	ldw	r2,-32380(gp)
81117768:	100f883a 	mov	r7,r2
8111776c:	01800404 	movi	r6,16
81117770:	01400044 	movi	r5,1
81117774:	01204574 	movhi	r4,33045
81117778:	21362504 	addi	r4,r4,-10092
8111777c:	1120e540 	call	81120e54 <fwrite>
#endif


}
81117780:	0001883a 	nop
81117784:	e037883a 	mov	sp,fp
81117788:	dfc00117 	ldw	ra,4(sp)
8111778c:	df000017 	ldw	fp,0(sp)
81117790:	dec00204 	addi	sp,sp,8
81117794:	f800283a 	ret

81117798 <vPrintMemmoryPattern>:

void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81117798:	defff604 	addi	sp,sp,-40
8111779c:	de00012e 	bgeu	sp,et,811177a4 <vPrintMemmoryPattern+0xc>
811177a0:	003b68fa 	trap	3
811177a4:	dfc00915 	stw	ra,36(sp)
811177a8:	df000815 	stw	fp,32(sp)
811177ac:	df000804 	addi	fp,sp,32
811177b0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
811177b4:	00800044 	movi	r2,1
811177b8:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
811177bc:	d0a06117 	ldw	r2,-32380(gp)
811177c0:	100f883a 	mov	r7,r2
811177c4:	018009c4 	movi	r6,39
811177c8:	01400044 	movi	r5,1
811177cc:	01204574 	movhi	r4,33045
811177d0:	21361204 	addi	r4,r4,-10168
811177d4:	1120e540 	call	81120e54 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
811177d8:	e03ffa05 	stb	zero,-24(fp)
811177dc:	00007606 	br	811179b8 <vPrintMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
811177e0:	e03ffc85 	stb	zero,-14(fp)
811177e4:	00006706 	br	81117984 <vPrintMemmoryPattern+0x1ec>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
811177e8:	e0bffc83 	ldbu	r2,-14(fp)
811177ec:	e0ffff17 	ldw	r3,-4(fp)
811177f0:	10809624 	muli	r2,r2,600
811177f4:	1885883a 	add	r2,r3,r2
811177f8:	10804304 	addi	r2,r2,268
811177fc:	1080000b 	ldhu	r2,0(r2)
81117800:	10ffffcc 	andi	r3,r2,65535
81117804:	e0bffc83 	ldbu	r2,-14(fp)
81117808:	e13fff17 	ldw	r4,-4(fp)
8111780c:	10809624 	muli	r2,r2,600
81117810:	2085883a 	add	r2,r4,r2
81117814:	10804204 	addi	r2,r2,264
81117818:	1080000b 	ldhu	r2,0(r2)
8111781c:	10bfffcc 	andi	r2,r2,65535
81117820:	1885883a 	add	r2,r3,r2
81117824:	e0bffd15 	stw	r2,-12(fp)
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81117828:	e0bffc83 	ldbu	r2,-14(fp)
8111782c:	e0ffff17 	ldw	r3,-4(fp)
81117830:	10809624 	muli	r2,r2,600
81117834:	1885883a 	add	r2,r3,r2
81117838:	10804284 	addi	r2,r2,266
8111783c:	1080000b 	ldhu	r2,0(r2)
81117840:	10ffffcc 	andi	r3,r2,65535
81117844:	e0bffc83 	ldbu	r2,-14(fp)
81117848:	e13fff17 	ldw	r4,-4(fp)
8111784c:	10809624 	muli	r2,r2,600
81117850:	2085883a 	add	r2,r4,r2
81117854:	10804184 	addi	r2,r2,262
81117858:	1080000b 	ldhu	r2,0(r2)
8111785c:	10bfffcc 	andi	r2,r2,65535
81117860:	1887883a 	add	r3,r3,r2
81117864:	e0bffc83 	ldbu	r2,-14(fp)
81117868:	e13fff17 	ldw	r4,-4(fp)
8111786c:	10809624 	muli	r2,r2,600
81117870:	2085883a 	add	r2,r4,r2
81117874:	10804104 	addi	r2,r2,260
81117878:	1080000b 	ldhu	r2,0(r2)
8111787c:	10bfffcc 	andi	r2,r2,65535
81117880:	1885883a 	add	r2,r3,r2
81117884:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81117888:	e03ffc05 	stb	zero,-16(fp)
8111788c:	00003706 	br	8111796c <vPrintMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81117890:	e03ffc45 	stb	zero,-15(fp)
81117894:	00002606 	br	81117930 <vPrintMemmoryPattern+0x198>
					if (ccd_side == 0){
81117898:	e0bffc43 	ldbu	r2,-15(fp)
8111789c:	10000b1e 	bne	r2,zero,811178cc <vPrintMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
811178a0:	e0bffc83 	ldbu	r2,-14(fp)
811178a4:	e13ffc03 	ldbu	r4,-16(fp)
811178a8:	e0ffff17 	ldw	r3,-4(fp)
811178ac:	21000624 	muli	r4,r4,24
811178b0:	10809624 	muli	r2,r2,600
811178b4:	2085883a 	add	r2,r4,r2
811178b8:	1885883a 	add	r2,r3,r2
811178bc:	10801b04 	addi	r2,r2,108
811178c0:	10800017 	ldw	r2,0(r2)
811178c4:	e0bffb15 	stw	r2,-20(fp)
811178c8:	00000a06 	br	811178f4 <vPrintMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
811178cc:	e0bffc83 	ldbu	r2,-14(fp)
811178d0:	e13ffc03 	ldbu	r4,-16(fp)
811178d4:	e0ffff17 	ldw	r3,-4(fp)
811178d8:	21000624 	muli	r4,r4,24
811178dc:	10809624 	muli	r2,r2,600
811178e0:	2085883a 	add	r2,r4,r2
811178e4:	1885883a 	add	r2,r3,r2
811178e8:	10801e04 	addi	r2,r2,120
811178ec:	10800017 	ldw	r2,0(r2)
811178f0:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
811178f4:	e0fffa03 	ldbu	r3,-24(fp)
811178f8:	e13ffc03 	ldbu	r4,-16(fp)
811178fc:	e17ffc43 	ldbu	r5,-15(fp)
81117900:	e0bffe17 	ldw	r2,-8(fp)
81117904:	d8800115 	stw	r2,4(sp)
81117908:	e0bffd17 	ldw	r2,-12(fp)
8111790c:	d8800015 	stw	r2,0(sp)
81117910:	280f883a 	mov	r7,r5
81117914:	200d883a 	mov	r6,r4
81117918:	e17ffb17 	ldw	r5,-20(fp)
8111791c:	1809883a 	mov	r4,r3
81117920:	111d9b00 	call	8111d9b0 <pattern_createPattern>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81117924:	e0bffc43 	ldbu	r2,-15(fp)
81117928:	10800044 	addi	r2,r2,1
8111792c:	e0bffc45 	stb	r2,-15(fp)
81117930:	e0bffc43 	ldbu	r2,-15(fp)
81117934:	108000b0 	cmpltui	r2,r2,2
81117938:	103fd71e 	bne	r2,zero,81117898 <__reset+0xfb0f7898>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
8111793c:	d0a06117 	ldw	r2,-32380(gp)
81117940:	e0fffc83 	ldbu	r3,-14(fp)
81117944:	e13ffc03 	ldbu	r4,-16(fp)
81117948:	200f883a 	mov	r7,r4
8111794c:	180d883a 	mov	r6,r3
81117950:	01604574 	movhi	r5,33045
81117954:	29761c04 	addi	r5,r5,-10128
81117958:	1009883a 	mov	r4,r2
8111795c:	11207b80 	call	811207b8 <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81117960:	e0bffc03 	ldbu	r2,-16(fp)
81117964:	10800044 	addi	r2,r2,1
81117968:	e0bffc05 	stb	r2,-16(fp)
8111796c:	e0bffc03 	ldbu	r2,-16(fp)
81117970:	10800130 	cmpltui	r2,r2,4
81117974:	103fc61e 	bne	r2,zero,81117890 <__reset+0xfb0f7890>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81117978:	e0bffc83 	ldbu	r2,-14(fp)
8111797c:	10800044 	addi	r2,r2,1
81117980:	e0bffc85 	stb	r2,-14(fp)
81117984:	e0fffc83 	ldbu	r3,-14(fp)
81117988:	e0bffcc3 	ldbu	r2,-13(fp)
8111798c:	18bf9636 	bltu	r3,r2,811177e8 <__reset+0xfb0f77e8>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
81117990:	d0a06117 	ldw	r2,-32380(gp)
81117994:	e0fffa03 	ldbu	r3,-24(fp)
81117998:	180d883a 	mov	r6,r3
8111799c:	01604574 	movhi	r5,33045
811179a0:	29762104 	addi	r5,r5,-10108
811179a4:	1009883a 	mov	r4,r2
811179a8:	11207b80 	call	811207b8 <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
811179ac:	e0bffa03 	ldbu	r2,-24(fp)
811179b0:	10800044 	addi	r2,r2,1
811179b4:	e0bffa05 	stb	r2,-24(fp)
811179b8:	e0bffa03 	ldbu	r2,-24(fp)
811179bc:	108000b0 	cmpltui	r2,r2,2
811179c0:	103f871e 	bne	r2,zero,811177e0 <__reset+0xfb0f77e0>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
811179c4:	d0a06117 	ldw	r2,-32380(gp)
811179c8:	100f883a 	mov	r7,r2
811179cc:	01800404 	movi	r6,16
811179d0:	01400044 	movi	r5,1
811179d4:	01204574 	movhi	r4,33045
811179d8:	21362504 	addi	r4,r4,-10092
811179dc:	1120e540 	call	81120e54 <fwrite>
#endif


}
811179e0:	0001883a 	nop
811179e4:	e037883a 	mov	sp,fp
811179e8:	dfc00117 	ldw	ra,4(sp)
811179ec:	df000017 	ldw	fp,0(sp)
811179f0:	dec00204 	addi	sp,sp,8
811179f4:	f800283a 	ret

811179f8 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
811179f8:	defffe04 	addi	sp,sp,-8
811179fc:	de00012e 	bgeu	sp,et,81117a04 <vCCDLoadDefaultValues+0xc>
81117a00:	003b68fa 	trap	3
81117a04:	df000115 	stw	fp,4(sp)
81117a08:	df000104 	addi	fp,sp,4
81117a0c:	e13fff15 	stw	r4,-4(fp)
	ccdDef->usiHalfWidth = 2255;
	ccdDef->usiSOverscanN = 15;
	ccdDef->usiSPrescanN = 25;
*/

	ccdDef->usiHeight = xDefaults.usiRows;
81117a10:	00a045b4 	movhi	r2,33046
81117a14:	10975904 	addi	r2,r2,23908
81117a18:	10c0060b 	ldhu	r3,24(r2)
81117a1c:	e0bfff17 	ldw	r2,-4(fp)
81117a20:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = xDefaults.usiOLN;
81117a24:	00a045b4 	movhi	r2,33046
81117a28:	10975904 	addi	r2,r2,23908
81117a2c:	10c0050b 	ldhu	r3,20(r2)
81117a30:	e0bfff17 	ldw	r2,-4(fp)
81117a34:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = xDefaults.usiCols;
81117a38:	00a045b4 	movhi	r2,33046
81117a3c:	10975904 	addi	r2,r2,23908
81117a40:	10c0058b 	ldhu	r3,22(r2)
81117a44:	e0bfff17 	ldw	r2,-4(fp)
81117a48:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = xDefaults.usiOverScanSerial;
81117a4c:	00a045b4 	movhi	r2,33046
81117a50:	10975904 	addi	r2,r2,23908
81117a54:	10c0040b 	ldhu	r3,16(r2)
81117a58:	e0bfff17 	ldw	r2,-4(fp)
81117a5c:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = xDefaults.usiPreScanSerial;
81117a60:	00a045b4 	movhi	r2,33046
81117a64:	10975904 	addi	r2,r2,23908
81117a68:	10c0048b 	ldhu	r3,18(r2)
81117a6c:	e0bfff17 	ldw	r2,-4(fp)
81117a70:	10c0000d 	sth	r3,0(r2)

}
81117a74:	0001883a 	nop
81117a78:	e037883a 	mov	sp,fp
81117a7c:	df000017 	ldw	fp,0(sp)
81117a80:	dec00104 	addi	sp,sp,4
81117a84:	f800283a 	ret

81117a88 <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
81117a88:	defff904 	addi	sp,sp,-28
81117a8c:	de00012e 	bgeu	sp,et,81117a94 <vCCDChangeValues+0xc>
81117a90:	003b68fa 	trap	3
81117a94:	df000615 	stw	fp,24(sp)
81117a98:	df000604 	addi	fp,sp,24
81117a9c:	e13ffa15 	stw	r4,-24(fp)
81117aa0:	2811883a 	mov	r8,r5
81117aa4:	300b883a 	mov	r5,r6
81117aa8:	3809883a 	mov	r4,r7
81117aac:	e0c00117 	ldw	r3,4(fp)
81117ab0:	e0800217 	ldw	r2,8(fp)
81117ab4:	e23ffb0d 	sth	r8,-20(fp)
81117ab8:	e17ffc0d 	sth	r5,-16(fp)
81117abc:	e13ffd0d 	sth	r4,-12(fp)
81117ac0:	e0fffe0d 	sth	r3,-8(fp)
81117ac4:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
81117ac8:	e0bffa17 	ldw	r2,-24(fp)
81117acc:	e0fffb0b 	ldhu	r3,-20(fp)
81117ad0:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
81117ad4:	e0bffa17 	ldw	r2,-24(fp)
81117ad8:	e0fffc0b 	ldhu	r3,-16(fp)
81117adc:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
81117ae0:	e0bffa17 	ldw	r2,-24(fp)
81117ae4:	e0fffd0b 	ldhu	r3,-12(fp)
81117ae8:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
81117aec:	e0bffa17 	ldw	r2,-24(fp)
81117af0:	e0fffe0b 	ldhu	r3,-8(fp)
81117af4:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
81117af8:	e0bffa17 	ldw	r2,-24(fp)
81117afc:	e0ffff0b 	ldhu	r3,-4(fp)
81117b00:	10c0000d 	sth	r3,0(r2)
}
81117b04:	0001883a 	nop
81117b08:	e037883a 	mov	sp,fp
81117b0c:	df000017 	ldw	fp,0(sp)
81117b10:	dec00104 	addi	sp,sp,4
81117b14:	f800283a 	ret

81117b18 <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
81117b18:	defff904 	addi	sp,sp,-28
81117b1c:	de00012e 	bgeu	sp,et,81117b24 <bSendUART128v2+0xc>
81117b20:	003b68fa 	trap	3
81117b24:	dfc00615 	stw	ra,24(sp)
81117b28:	df000515 	stw	fp,20(sp)
81117b2c:	df000504 	addi	fp,sp,20
81117b30:	e13ffe15 	stw	r4,-8(fp)
81117b34:	2805883a 	mov	r2,r5
81117b38:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
81117b3c:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81117b40:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81117b44:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81117b48:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81117b4c:	d0a06217 	ldw	r2,-32376(gp)
81117b50:	e0fffd04 	addi	r3,fp,-12
81117b54:	180d883a 	mov	r6,r3
81117b58:	01400504 	movi	r5,20
81117b5c:	1009883a 	mov	r4,r2
81117b60:	113dcd40 	call	8113dcd4 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81117b64:	e0bffd03 	ldbu	r2,-12(fp)
81117b68:	10803fcc 	andi	r2,r2,255
81117b6c:	10000326 	beq	r2,zero,81117b7c <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81117b70:	111b2680 	call	8111b268 <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
81117b74:	e0bffc17 	ldw	r2,-16(fp)
81117b78:	00009e06 	br	81117df4 <bSendUART128v2+0x2dc>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81117b7c:	d0a06d17 	ldw	r2,-32332(gp)
81117b80:	e0fffd04 	addi	r3,fp,-12
81117b84:	180d883a 	mov	r6,r3
81117b88:	01400104 	movi	r5,4
81117b8c:	1009883a 	mov	r4,r2
81117b90:	113bcc80 	call	8113bcc8 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81117b94:	e0bffd03 	ldbu	r2,-12(fp)
81117b98:	10803fcc 	andi	r2,r2,255
81117b9c:	10001126 	beq	r2,zero,81117be4 <bSendUART128v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
81117ba0:	d0a06117 	ldw	r2,-32380(gp)
81117ba4:	100f883a 	mov	r7,r2
81117ba8:	01801484 	movi	r6,82
81117bac:	01400044 	movi	r5,1
81117bb0:	01204574 	movhi	r4,33045
81117bb4:	21362a04 	addi	r4,r4,-10072
81117bb8:	1120e540 	call	81120e54 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81117bbc:	d0a06217 	ldw	r2,-32376(gp)
81117bc0:	1009883a 	mov	r4,r2
81117bc4:	113e05c0 	call	8113e05c <OSSemPost>
81117bc8:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81117bcc:	e0bffd03 	ldbu	r2,-12(fp)
81117bd0:	10803fcc 	andi	r2,r2,255
81117bd4:	10000126 	beq	r2,zero,81117bdc <bSendUART128v2+0xc4>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81117bd8:	111b2000 	call	8111b200 <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
81117bdc:	e0bffc17 	ldw	r2,-16(fp)
81117be0:	00008406 	br	81117df4 <bSendUART128v2+0x2dc>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81117be4:	e03ffb05 	stb	zero,-20(fp)
81117be8:	00004306 	br	81117cf8 <bSendUART128v2+0x1e0>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
81117bec:	e0fffb03 	ldbu	r3,-20(fp)
81117bf0:	00a045b4 	movhi	r2,33046
81117bf4:	10b77704 	addi	r2,r2,-8740
81117bf8:	18c7883a 	add	r3,r3,r3
81117bfc:	18c7883a 	add	r3,r3,r3
81117c00:	10c5883a 	add	r2,r2,r3
81117c04:	10800017 	ldw	r2,0(r2)
81117c08:	1000381e 	bne	r2,zero,81117cec <bSendUART128v2+0x1d4>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
81117c0c:	e0bffb03 	ldbu	r2,-20(fp)
81117c10:	10c02324 	muli	r3,r2,140
81117c14:	00a045b4 	movhi	r2,33046
81117c18:	10b79504 	addi	r2,r2,-8620
81117c1c:	1885883a 	add	r2,r3,r2
81117c20:	01802004 	movi	r6,128
81117c24:	000b883a 	mov	r5,zero
81117c28:	1009883a 	mov	r4,r2
81117c2c:	11219b80 	call	811219b8 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
81117c30:	e0bffb03 	ldbu	r2,-20(fp)
81117c34:	10c02324 	muli	r3,r2,140
81117c38:	00a045b4 	movhi	r2,33046
81117c3c:	10b79504 	addi	r2,r2,-8620
81117c40:	1885883a 	add	r2,r3,r2
81117c44:	01801fc4 	movi	r6,127
81117c48:	e17ffe17 	ldw	r5,-8(fp)
81117c4c:	1009883a 	mov	r4,r2
81117c50:	11218680 	call	81121868 <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
81117c54:	e13ffb03 	ldbu	r4,-20(fp)
81117c58:	e0ffff0b 	ldhu	r3,-4(fp)
81117c5c:	00a045b4 	movhi	r2,33046
81117c60:	10b79504 	addi	r2,r2,-8620
81117c64:	21002324 	muli	r4,r4,140
81117c68:	1105883a 	add	r2,r2,r4
81117c6c:	10802104 	addi	r2,r2,132
81117c70:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
81117c74:	e0fffb03 	ldbu	r3,-20(fp)
81117c78:	00a045b4 	movhi	r2,33046
81117c7c:	10b79504 	addi	r2,r2,-8620
81117c80:	18c02324 	muli	r3,r3,140
81117c84:	10c5883a 	add	r2,r2,r3
81117c88:	10802204 	addi	r2,r2,136
81117c8c:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
81117c90:	e0fffb03 	ldbu	r3,-20(fp)
81117c94:	00a045b4 	movhi	r2,33046
81117c98:	10b79504 	addi	r2,r2,-8620
81117c9c:	18c02324 	muli	r3,r3,140
81117ca0:	10c5883a 	add	r2,r2,r3
81117ca4:	10802184 	addi	r2,r2,134
81117ca8:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
81117cac:	e0fffb03 	ldbu	r3,-20(fp)
81117cb0:	00a045b4 	movhi	r2,33046
81117cb4:	10b79504 	addi	r2,r2,-8620
81117cb8:	18c02324 	muli	r3,r3,140
81117cbc:	10c5883a 	add	r2,r2,r3
81117cc0:	10802004 	addi	r2,r2,128
81117cc4:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
81117cc8:	e0fffb03 	ldbu	r3,-20(fp)
81117ccc:	00a045b4 	movhi	r2,33046
81117cd0:	10b77704 	addi	r2,r2,-8740
81117cd4:	18c7883a 	add	r3,r3,r3
81117cd8:	18c7883a 	add	r3,r3,r3
81117cdc:	10c5883a 	add	r2,r2,r3
81117ce0:	00c00044 	movi	r3,1
81117ce4:	10c00015 	stw	r3,0(r2)
			break;
81117ce8:	00000606 	br	81117d04 <bSendUART128v2+0x1ec>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81117cec:	e0bffb03 	ldbu	r2,-20(fp)
81117cf0:	10800044 	addi	r2,r2,1
81117cf4:	e0bffb05 	stb	r2,-20(fp)
81117cf8:	e0bffb03 	ldbu	r2,-20(fp)
81117cfc:	108001b0 	cmpltui	r2,r2,6
81117d00:	103fba1e 	bne	r2,zero,81117bec <__reset+0xfb0f7bec>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
81117d04:	e0bffb03 	ldbu	r2,-20(fp)
81117d08:	108001b0 	cmpltui	r2,r2,6
81117d0c:	1000091e 	bne	r2,zero,81117d34 <bSendUART128v2+0x21c>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81117d10:	d0a06217 	ldw	r2,-32376(gp)
81117d14:	1009883a 	mov	r4,r2
81117d18:	113e05c0 	call	8113e05c <OSSemPost>
81117d1c:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
81117d20:	d0a06d17 	ldw	r2,-32332(gp)
81117d24:	1009883a 	mov	r4,r2
81117d28:	113c26c0 	call	8113c26c <OSMutexPost>
		return bSuccessL;
81117d2c:	e0bffc17 	ldw	r2,-16(fp)
81117d30:	00003006 	br	81117df4 <bSendUART128v2+0x2dc>
	}

	bSuccessL = TRUE;
81117d34:	00800044 	movi	r2,1
81117d38:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
81117d3c:	d0a07443 	ldbu	r2,-32303(gp)
81117d40:	10bfffc4 	addi	r2,r2,-1
81117d44:	d0a07445 	stb	r2,-32303(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81117d48:	d0a07317 	ldw	r2,-32308(gp)
81117d4c:	e0fffd04 	addi	r3,fp,-12
81117d50:	180d883a 	mov	r6,r3
81117d54:	01400084 	movi	r5,2
81117d58:	1009883a 	mov	r4,r2
81117d5c:	113bcc80 	call	8113bcc8 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81117d60:	e0bffd03 	ldbu	r2,-12(fp)
81117d64:	10803fcc 	andi	r2,r2,255
81117d68:	10000c26 	beq	r2,zero,81117d9c <bSendUART128v2+0x284>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
81117d6c:	d0a06117 	ldw	r2,-32380(gp)
81117d70:	100f883a 	mov	r7,r2
81117d74:	01801c04 	movi	r6,112
81117d78:	01400044 	movi	r5,1
81117d7c:	01204574 	movhi	r4,33045
81117d80:	21363f04 	addi	r4,r4,-9988
81117d84:	1120e540 	call	81120e54 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81117d88:	d0a06d17 	ldw	r2,-32332(gp)
81117d8c:	1009883a 	mov	r4,r2
81117d90:	113c26c0 	call	8113c26c <OSMutexPost>
		return bSuccessL;
81117d94:	e0bffc17 	ldw	r2,-16(fp)
81117d98:	00001606 	br	81117df4 <bSendUART128v2+0x2dc>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
81117d9c:	e0bffb03 	ldbu	r2,-20(fp)
81117da0:	10c02324 	muli	r3,r2,140
81117da4:	00a045b4 	movhi	r2,33046
81117da8:	10b79504 	addi	r2,r2,-8620
81117dac:	1885883a 	add	r2,r3,r2
81117db0:	1009883a 	mov	r4,r2
81117db4:	1121e040 	call	81121e04 <puts>
	xBuffer128[ucIL].bSent = TRUE;
81117db8:	e0fffb03 	ldbu	r3,-20(fp)
81117dbc:	00a045b4 	movhi	r2,33046
81117dc0:	10b79504 	addi	r2,r2,-8620
81117dc4:	18c02324 	muli	r3,r3,140
81117dc8:	10c5883a 	add	r2,r2,r3
81117dcc:	10802004 	addi	r2,r2,128
81117dd0:	00c00044 	movi	r3,1
81117dd4:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
81117dd8:	d0a07317 	ldw	r2,-32308(gp)
81117ddc:	1009883a 	mov	r4,r2
81117de0:	113c26c0 	call	8113c26c <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
81117de4:	d0a06d17 	ldw	r2,-32332(gp)
81117de8:	1009883a 	mov	r4,r2
81117dec:	113c26c0 	call	8113c26c <OSMutexPost>

	return bSuccessL;
81117df0:	e0bffc17 	ldw	r2,-16(fp)
}
81117df4:	e037883a 	mov	sp,fp
81117df8:	dfc00117 	ldw	ra,4(sp)
81117dfc:	df000017 	ldw	fp,0(sp)
81117e00:	dec00204 	addi	sp,sp,8
81117e04:	f800283a 	ret

81117e08 <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
81117e08:	defff904 	addi	sp,sp,-28
81117e0c:	de00012e 	bgeu	sp,et,81117e14 <bSendUART64v2+0xc>
81117e10:	003b68fa 	trap	3
81117e14:	dfc00615 	stw	ra,24(sp)
81117e18:	df000515 	stw	fp,20(sp)
81117e1c:	df000504 	addi	fp,sp,20
81117e20:	e13ffe15 	stw	r4,-8(fp)
81117e24:	2805883a 	mov	r2,r5
81117e28:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81117e2c:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81117e30:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81117e34:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81117e38:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81117e3c:	d0a05d17 	ldw	r2,-32396(gp)
81117e40:	e0fffd04 	addi	r3,fp,-12
81117e44:	180d883a 	mov	r6,r3
81117e48:	01400504 	movi	r5,20
81117e4c:	1009883a 	mov	r4,r2
81117e50:	113dcd40 	call	8113dcd4 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81117e54:	e0bffd03 	ldbu	r2,-12(fp)
81117e58:	10803fcc 	andi	r2,r2,255
81117e5c:	10000326 	beq	r2,zero,81117e6c <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81117e60:	111b2d00 	call	8111b2d0 <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
81117e64:	e0bffc17 	ldw	r2,-16(fp)
81117e68:	0000a006 	br	811180ec <bSendUART64v2+0x2e4>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81117e6c:	d0a07017 	ldw	r2,-32320(gp)
81117e70:	e0fffd04 	addi	r3,fp,-12
81117e74:	180d883a 	mov	r6,r3
81117e78:	01400104 	movi	r5,4
81117e7c:	1009883a 	mov	r4,r2
81117e80:	113bcc80 	call	8113bcc8 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81117e84:	e0bffd03 	ldbu	r2,-12(fp)
81117e88:	10803fcc 	andi	r2,r2,255
81117e8c:	10001126 	beq	r2,zero,81117ed4 <bSendUART64v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
81117e90:	d0a06117 	ldw	r2,-32380(gp)
81117e94:	100f883a 	mov	r7,r2
81117e98:	018013c4 	movi	r6,79
81117e9c:	01400044 	movi	r5,1
81117ea0:	01204574 	movhi	r4,33045
81117ea4:	21365c04 	addi	r4,r4,-9872
81117ea8:	1120e540 	call	81120e54 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81117eac:	d0a05d17 	ldw	r2,-32396(gp)
81117eb0:	1009883a 	mov	r4,r2
81117eb4:	113e05c0 	call	8113e05c <OSSemPost>
81117eb8:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81117ebc:	e0bffd03 	ldbu	r2,-12(fp)
81117ec0:	10803fcc 	andi	r2,r2,255
81117ec4:	10000126 	beq	r2,zero,81117ecc <bSendUART64v2+0xc4>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81117ec8:	111b1980 	call	8111b198 <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
81117ecc:	e0bffc17 	ldw	r2,-16(fp)
81117ed0:	00008606 	br	811180ec <bSendUART64v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81117ed4:	e03ffb05 	stb	zero,-20(fp)
81117ed8:	00004506 	br	81117ff0 <bSendUART64v2+0x1e8>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
81117edc:	e0fffb03 	ldbu	r3,-20(fp)
81117ee0:	00a045b4 	movhi	r2,33046
81117ee4:	10b77704 	addi	r2,r2,-8740
81117ee8:	18c00184 	addi	r3,r3,6
81117eec:	18c7883a 	add	r3,r3,r3
81117ef0:	18c7883a 	add	r3,r3,r3
81117ef4:	10c5883a 	add	r2,r2,r3
81117ef8:	10800017 	ldw	r2,0(r2)
81117efc:	1000391e 	bne	r2,zero,81117fe4 <bSendUART64v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
81117f00:	e0bffb03 	ldbu	r2,-20(fp)
81117f04:	10c01324 	muli	r3,r2,76
81117f08:	00a04574 	movhi	r2,33045
81117f0c:	10933b04 	addi	r2,r2,19692
81117f10:	1885883a 	add	r2,r3,r2
81117f14:	01801004 	movi	r6,64
81117f18:	000b883a 	mov	r5,zero
81117f1c:	1009883a 	mov	r4,r2
81117f20:	11219b80 	call	811219b8 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
81117f24:	e0bffb03 	ldbu	r2,-20(fp)
81117f28:	10c01324 	muli	r3,r2,76
81117f2c:	00a04574 	movhi	r2,33045
81117f30:	10933b04 	addi	r2,r2,19692
81117f34:	1885883a 	add	r2,r3,r2
81117f38:	01800fc4 	movi	r6,63
81117f3c:	e17ffe17 	ldw	r5,-8(fp)
81117f40:	1009883a 	mov	r4,r2
81117f44:	11218680 	call	81121868 <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
81117f48:	e13ffb03 	ldbu	r4,-20(fp)
81117f4c:	e0ffff0b 	ldhu	r3,-4(fp)
81117f50:	00a04574 	movhi	r2,33045
81117f54:	10933b04 	addi	r2,r2,19692
81117f58:	21001324 	muli	r4,r4,76
81117f5c:	1105883a 	add	r2,r2,r4
81117f60:	10801104 	addi	r2,r2,68
81117f64:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
81117f68:	e0fffb03 	ldbu	r3,-20(fp)
81117f6c:	00a04574 	movhi	r2,33045
81117f70:	10933b04 	addi	r2,r2,19692
81117f74:	18c01324 	muli	r3,r3,76
81117f78:	10c5883a 	add	r2,r2,r3
81117f7c:	10801204 	addi	r2,r2,72
81117f80:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
81117f84:	e0fffb03 	ldbu	r3,-20(fp)
81117f88:	00a04574 	movhi	r2,33045
81117f8c:	10933b04 	addi	r2,r2,19692
81117f90:	18c01324 	muli	r3,r3,76
81117f94:	10c5883a 	add	r2,r2,r3
81117f98:	10801184 	addi	r2,r2,70
81117f9c:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
81117fa0:	e0fffb03 	ldbu	r3,-20(fp)
81117fa4:	00a04574 	movhi	r2,33045
81117fa8:	10933b04 	addi	r2,r2,19692
81117fac:	18c01324 	muli	r3,r3,76
81117fb0:	10c5883a 	add	r2,r2,r3
81117fb4:	10801004 	addi	r2,r2,64
81117fb8:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
81117fbc:	e0fffb03 	ldbu	r3,-20(fp)
81117fc0:	00a045b4 	movhi	r2,33046
81117fc4:	10b77704 	addi	r2,r2,-8740
81117fc8:	18c00184 	addi	r3,r3,6
81117fcc:	18c7883a 	add	r3,r3,r3
81117fd0:	18c7883a 	add	r3,r3,r3
81117fd4:	10c5883a 	add	r2,r2,r3
81117fd8:	00c00044 	movi	r3,1
81117fdc:	10c00015 	stw	r3,0(r2)
			break;
81117fe0:	00000606 	br	81117ffc <bSendUART64v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81117fe4:	e0bffb03 	ldbu	r2,-20(fp)
81117fe8:	10800044 	addi	r2,r2,1
81117fec:	e0bffb05 	stb	r2,-20(fp)
81117ff0:	e0bffb03 	ldbu	r2,-20(fp)
81117ff4:	10800230 	cmpltui	r2,r2,8
81117ff8:	103fb81e 	bne	r2,zero,81117edc <__reset+0xfb0f7edc>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
81117ffc:	e0bffb03 	ldbu	r2,-20(fp)
81118000:	10800230 	cmpltui	r2,r2,8
81118004:	1000091e 	bne	r2,zero,8111802c <bSendUART64v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81118008:	d0a05d17 	ldw	r2,-32396(gp)
8111800c:	1009883a 	mov	r4,r2
81118010:	113e05c0 	call	8113e05c <OSSemPost>
81118014:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
81118018:	d0a07017 	ldw	r2,-32320(gp)
8111801c:	1009883a 	mov	r4,r2
81118020:	113c26c0 	call	8113c26c <OSMutexPost>
		return bSuccessL;
81118024:	e0bffc17 	ldw	r2,-16(fp)
81118028:	00003006 	br	811180ec <bSendUART64v2+0x2e4>
	}

	bSuccessL = TRUE;
8111802c:	00800044 	movi	r2,1
81118030:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
81118034:	d0a07403 	ldbu	r2,-32304(gp)
81118038:	10bfffc4 	addi	r2,r2,-1
8111803c:	d0a07405 	stb	r2,-32304(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81118040:	d0a07317 	ldw	r2,-32308(gp)
81118044:	e0fffd04 	addi	r3,fp,-12
81118048:	180d883a 	mov	r6,r3
8111804c:	01400084 	movi	r5,2
81118050:	1009883a 	mov	r4,r2
81118054:	113bcc80 	call	8113bcc8 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81118058:	e0bffd03 	ldbu	r2,-12(fp)
8111805c:	10803fcc 	andi	r2,r2,255
81118060:	10000c26 	beq	r2,zero,81118094 <bSendUART64v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
81118064:	d0a06117 	ldw	r2,-32380(gp)
81118068:	100f883a 	mov	r7,r2
8111806c:	01801bc4 	movi	r6,111
81118070:	01400044 	movi	r5,1
81118074:	01204574 	movhi	r4,33045
81118078:	21367004 	addi	r4,r4,-9792
8111807c:	1120e540 	call	81120e54 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
81118080:	d0a07017 	ldw	r2,-32320(gp)
81118084:	1009883a 	mov	r4,r2
81118088:	113c26c0 	call	8113c26c <OSMutexPost>
		return bSuccessL;
8111808c:	e0bffc17 	ldw	r2,-16(fp)
81118090:	00001606 	br	811180ec <bSendUART64v2+0x2e4>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
81118094:	e0bffb03 	ldbu	r2,-20(fp)
81118098:	10c01324 	muli	r3,r2,76
8111809c:	00a04574 	movhi	r2,33045
811180a0:	10933b04 	addi	r2,r2,19692
811180a4:	1885883a 	add	r2,r3,r2
811180a8:	1009883a 	mov	r4,r2
811180ac:	1121e040 	call	81121e04 <puts>
	xBuffer64[ucIL].bSent = TRUE;
811180b0:	e0fffb03 	ldbu	r3,-20(fp)
811180b4:	00a04574 	movhi	r2,33045
811180b8:	10933b04 	addi	r2,r2,19692
811180bc:	18c01324 	muli	r3,r3,76
811180c0:	10c5883a 	add	r2,r2,r3
811180c4:	10801004 	addi	r2,r2,64
811180c8:	00c00044 	movi	r3,1
811180cc:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
811180d0:	d0a07317 	ldw	r2,-32308(gp)
811180d4:	1009883a 	mov	r4,r2
811180d8:	113c26c0 	call	8113c26c <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
811180dc:	d0a07017 	ldw	r2,-32320(gp)
811180e0:	1009883a 	mov	r4,r2
811180e4:	113c26c0 	call	8113c26c <OSMutexPost>

	return bSuccessL;
811180e8:	e0bffc17 	ldw	r2,-16(fp)
}
811180ec:	e037883a 	mov	sp,fp
811180f0:	dfc00117 	ldw	ra,4(sp)
811180f4:	df000017 	ldw	fp,0(sp)
811180f8:	dec00204 	addi	sp,sp,8
811180fc:	f800283a 	ret

81118100 <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
81118100:	defff904 	addi	sp,sp,-28
81118104:	de00012e 	bgeu	sp,et,8111810c <bSendUART32v2+0xc>
81118108:	003b68fa 	trap	3
8111810c:	dfc00615 	stw	ra,24(sp)
81118110:	df000515 	stw	fp,20(sp)
81118114:	df000504 	addi	fp,sp,20
81118118:	e13ffe15 	stw	r4,-8(fp)
8111811c:	2805883a 	mov	r2,r5
81118120:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81118124:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81118128:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
8111812c:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81118130:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81118134:	d0a06e17 	ldw	r2,-32328(gp)
81118138:	e0fffd04 	addi	r3,fp,-12
8111813c:	180d883a 	mov	r6,r3
81118140:	01400504 	movi	r5,20
81118144:	1009883a 	mov	r4,r2
81118148:	113dcd40 	call	8113dcd4 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
8111814c:	e0bffd03 	ldbu	r2,-12(fp)
81118150:	10803fcc 	andi	r2,r2,255
81118154:	10000326 	beq	r2,zero,81118164 <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81118158:	111b3380 	call	8111b338 <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
8111815c:	e0bffc17 	ldw	r2,-16(fp)
81118160:	0000a006 	br	811183e4 <bSendUART32v2+0x2e4>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81118164:	d0a06b17 	ldw	r2,-32340(gp)
81118168:	e0fffd04 	addi	r3,fp,-12
8111816c:	180d883a 	mov	r6,r3
81118170:	01400104 	movi	r5,4
81118174:	1009883a 	mov	r4,r2
81118178:	113bcc80 	call	8113bcc8 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111817c:	e0bffd03 	ldbu	r2,-12(fp)
81118180:	10803fcc 	andi	r2,r2,255
81118184:	10001126 	beq	r2,zero,811181cc <bSendUART32v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
81118188:	d0a06117 	ldw	r2,-32380(gp)
8111818c:	100f883a 	mov	r7,r2
81118190:	018013c4 	movi	r6,79
81118194:	01400044 	movi	r5,1
81118198:	01204574 	movhi	r4,33045
8111819c:	21368c04 	addi	r4,r4,-9680
811181a0:	1120e540 	call	81120e54 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
811181a4:	d0a06e17 	ldw	r2,-32328(gp)
811181a8:	1009883a 	mov	r4,r2
811181ac:	113e05c0 	call	8113e05c <OSSemPost>
811181b0:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
811181b4:	e0bffd03 	ldbu	r2,-12(fp)
811181b8:	10803fcc 	andi	r2,r2,255
811181bc:	10000126 	beq	r2,zero,811181c4 <bSendUART32v2+0xc4>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
811181c0:	111b1300 	call	8111b130 <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
811181c4:	e0bffc17 	ldw	r2,-16(fp)
811181c8:	00008606 	br	811183e4 <bSendUART32v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
811181cc:	e03ffb05 	stb	zero,-20(fp)
811181d0:	00004506 	br	811182e8 <bSendUART32v2+0x1e8>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
811181d4:	e0fffb03 	ldbu	r3,-20(fp)
811181d8:	00a045b4 	movhi	r2,33046
811181dc:	10b77704 	addi	r2,r2,-8740
811181e0:	18c00384 	addi	r3,r3,14
811181e4:	18c7883a 	add	r3,r3,r3
811181e8:	18c7883a 	add	r3,r3,r3
811181ec:	10c5883a 	add	r2,r2,r3
811181f0:	10800017 	ldw	r2,0(r2)
811181f4:	1000391e 	bne	r2,zero,811182dc <bSendUART32v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
811181f8:	e0bffb03 	ldbu	r2,-20(fp)
811181fc:	10c00b24 	muli	r3,r2,44
81118200:	00a045b4 	movhi	r2,33046
81118204:	10a4f704 	addi	r2,r2,-27684
81118208:	1885883a 	add	r2,r3,r2
8111820c:	01800804 	movi	r6,32
81118210:	000b883a 	mov	r5,zero
81118214:	1009883a 	mov	r4,r2
81118218:	11219b80 	call	811219b8 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
8111821c:	e0bffb03 	ldbu	r2,-20(fp)
81118220:	10c00b24 	muli	r3,r2,44
81118224:	00a045b4 	movhi	r2,33046
81118228:	10a4f704 	addi	r2,r2,-27684
8111822c:	1885883a 	add	r2,r3,r2
81118230:	018007c4 	movi	r6,31
81118234:	e17ffe17 	ldw	r5,-8(fp)
81118238:	1009883a 	mov	r4,r2
8111823c:	11218680 	call	81121868 <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
81118240:	e13ffb03 	ldbu	r4,-20(fp)
81118244:	e0ffff0b 	ldhu	r3,-4(fp)
81118248:	00a045b4 	movhi	r2,33046
8111824c:	10a4f704 	addi	r2,r2,-27684
81118250:	21000b24 	muli	r4,r4,44
81118254:	1105883a 	add	r2,r2,r4
81118258:	10800904 	addi	r2,r2,36
8111825c:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
81118260:	e0fffb03 	ldbu	r3,-20(fp)
81118264:	00a045b4 	movhi	r2,33046
81118268:	10a4f704 	addi	r2,r2,-27684
8111826c:	18c00b24 	muli	r3,r3,44
81118270:	10c5883a 	add	r2,r2,r3
81118274:	10800a04 	addi	r2,r2,40
81118278:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
8111827c:	e0fffb03 	ldbu	r3,-20(fp)
81118280:	00a045b4 	movhi	r2,33046
81118284:	10a4f704 	addi	r2,r2,-27684
81118288:	18c00b24 	muli	r3,r3,44
8111828c:	10c5883a 	add	r2,r2,r3
81118290:	10800984 	addi	r2,r2,38
81118294:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
81118298:	e0fffb03 	ldbu	r3,-20(fp)
8111829c:	00a045b4 	movhi	r2,33046
811182a0:	10a4f704 	addi	r2,r2,-27684
811182a4:	18c00b24 	muli	r3,r3,44
811182a8:	10c5883a 	add	r2,r2,r3
811182ac:	10800804 	addi	r2,r2,32
811182b0:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
811182b4:	e0fffb03 	ldbu	r3,-20(fp)
811182b8:	00a045b4 	movhi	r2,33046
811182bc:	10b77704 	addi	r2,r2,-8740
811182c0:	18c00384 	addi	r3,r3,14
811182c4:	18c7883a 	add	r3,r3,r3
811182c8:	18c7883a 	add	r3,r3,r3
811182cc:	10c5883a 	add	r2,r2,r3
811182d0:	00c00044 	movi	r3,1
811182d4:	10c00015 	stw	r3,0(r2)
			break;
811182d8:	00000606 	br	811182f4 <bSendUART32v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
811182dc:	e0bffb03 	ldbu	r2,-20(fp)
811182e0:	10800044 	addi	r2,r2,1
811182e4:	e0bffb05 	stb	r2,-20(fp)
811182e8:	e0bffb03 	ldbu	r2,-20(fp)
811182ec:	10800230 	cmpltui	r2,r2,8
811182f0:	103fb81e 	bne	r2,zero,811181d4 <__reset+0xfb0f81d4>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
811182f4:	e0bffb03 	ldbu	r2,-20(fp)
811182f8:	10800230 	cmpltui	r2,r2,8
811182fc:	1000091e 	bne	r2,zero,81118324 <bSendUART32v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81118300:	d0a06e17 	ldw	r2,-32328(gp)
81118304:	1009883a 	mov	r4,r2
81118308:	113e05c0 	call	8113e05c <OSSemPost>
8111830c:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
81118310:	d0a06b17 	ldw	r2,-32340(gp)
81118314:	1009883a 	mov	r4,r2
81118318:	113c26c0 	call	8113c26c <OSMutexPost>
		return bSuccessL;
8111831c:	e0bffc17 	ldw	r2,-16(fp)
81118320:	00003006 	br	811183e4 <bSendUART32v2+0x2e4>
	}
	
	bSuccessL = TRUE;
81118324:	00800044 	movi	r2,1
81118328:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
8111832c:	d0a06783 	ldbu	r2,-32354(gp)
81118330:	10bfffc4 	addi	r2,r2,-1
81118334:	d0a06785 	stb	r2,-32354(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81118338:	d0a07317 	ldw	r2,-32308(gp)
8111833c:	e0fffd04 	addi	r3,fp,-12
81118340:	180d883a 	mov	r6,r3
81118344:	01400084 	movi	r5,2
81118348:	1009883a 	mov	r4,r2
8111834c:	113bcc80 	call	8113bcc8 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81118350:	e0bffd03 	ldbu	r2,-12(fp)
81118354:	10803fcc 	andi	r2,r2,255
81118358:	10000c26 	beq	r2,zero,8111838c <bSendUART32v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
8111835c:	d0a06117 	ldw	r2,-32380(gp)
81118360:	100f883a 	mov	r7,r2
81118364:	01801bc4 	movi	r6,111
81118368:	01400044 	movi	r5,1
8111836c:	01204574 	movhi	r4,33045
81118370:	2136a004 	addi	r4,r4,-9600
81118374:	1120e540 	call	81120e54 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
81118378:	d0a06b17 	ldw	r2,-32340(gp)
8111837c:	1009883a 	mov	r4,r2
81118380:	113c26c0 	call	8113c26c <OSMutexPost>
		return bSuccessL;
81118384:	e0bffc17 	ldw	r2,-16(fp)
81118388:	00001606 	br	811183e4 <bSendUART32v2+0x2e4>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
8111838c:	e0bffb03 	ldbu	r2,-20(fp)
81118390:	10c00b24 	muli	r3,r2,44
81118394:	00a045b4 	movhi	r2,33046
81118398:	10a4f704 	addi	r2,r2,-27684
8111839c:	1885883a 	add	r2,r3,r2
811183a0:	1009883a 	mov	r4,r2
811183a4:	1121e040 	call	81121e04 <puts>
	xBuffer32[ucIL].bSent = TRUE;
811183a8:	e0fffb03 	ldbu	r3,-20(fp)
811183ac:	00a045b4 	movhi	r2,33046
811183b0:	10a4f704 	addi	r2,r2,-27684
811183b4:	18c00b24 	muli	r3,r3,44
811183b8:	10c5883a 	add	r2,r2,r3
811183bc:	10800804 	addi	r2,r2,32
811183c0:	00c00044 	movi	r3,1
811183c4:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
811183c8:	d0a07317 	ldw	r2,-32308(gp)
811183cc:	1009883a 	mov	r4,r2
811183d0:	113c26c0 	call	8113c26c <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
811183d4:	d0a06b17 	ldw	r2,-32340(gp)
811183d8:	1009883a 	mov	r4,r2
811183dc:	113c26c0 	call	8113c26c <OSMutexPost>

	return bSuccessL;
811183e0:	e0bffc17 	ldw	r2,-16(fp)
}
811183e4:	e037883a 	mov	sp,fp
811183e8:	dfc00117 	ldw	ra,4(sp)
811183ec:	df000017 	ldw	fp,0(sp)
811183f0:	dec00204 	addi	sp,sp,8
811183f4:	f800283a 	ret

811183f8 <vSendEthConf>:


void vSendEthConf ( void ) {
811183f8:	deffc304 	addi	sp,sp,-244
811183fc:	de00012e 	bgeu	sp,et,81118404 <vSendEthConf+0xc>
81118400:	003b68fa 	trap	3
81118404:	dfc03c15 	stw	ra,240(sp)
81118408:	df003b15 	stw	fp,236(sp)
8111840c:	dd403a15 	stw	r21,232(sp)
81118410:	dd003915 	stw	r20,228(sp)
81118414:	dcc03815 	stw	r19,224(sp)
81118418:	dc803715 	stw	r18,220(sp)
8111841c:	dc403615 	stw	r17,216(sp)
81118420:	dc003515 	stw	r16,212(sp)
81118424:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
81118428:	e03fd98d 	sth	zero,-154(fp)
8111842c:	e03fda0d 	sth	zero,-152(fp)
81118430:	e0bfda84 	addi	r2,fp,-150
81118434:	00c01f04 	movi	r3,124
81118438:	180d883a 	mov	r6,r3
8111843c:	000b883a 	mov	r5,zero
81118440:	1009883a 	mov	r4,r2
81118444:	11219b80 	call	811219b8 <memset>
    unsigned char crc = 0;
81118448:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111844c:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
81118450:	11189b80 	call	811189b8 <usiGetIdCMD>
81118454:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118458:	e57fd90b 	ldhu	r21,-156(fp)
8111845c:	00a045b4 	movhi	r2,33046
81118460:	10976604 	addi	r2,r2,23960
81118464:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81118468:	00a045b4 	movhi	r2,33046
8111846c:	10976604 	addi	r2,r2,23960
81118470:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118474:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81118478:	00a045b4 	movhi	r2,33046
8111847c:	10976604 	addi	r2,r2,23960
81118480:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118484:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81118488:	00a045b4 	movhi	r2,33046
8111848c:	10976604 	addi	r2,r2,23960
81118490:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118494:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81118498:	00a045b4 	movhi	r2,33046
8111849c:	10976604 	addi	r2,r2,23960
811184a0:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811184a4:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
811184a8:	00a045b4 	movhi	r2,33046
811184ac:	10976604 	addi	r2,r2,23960
811184b0:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811184b4:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
811184b8:	00a045b4 	movhi	r2,33046
811184bc:	10976604 	addi	r2,r2,23960
811184c0:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811184c4:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
811184c8:	00a045b4 	movhi	r2,33046
811184cc:	10976604 	addi	r2,r2,23960
811184d0:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811184d4:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
811184d8:	00a045b4 	movhi	r2,33046
811184dc:	10976604 	addi	r2,r2,23960
811184e0:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811184e4:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
811184e8:	00a045b4 	movhi	r2,33046
811184ec:	10976604 	addi	r2,r2,23960
811184f0:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811184f4:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
811184f8:	00a045b4 	movhi	r2,33046
811184fc:	10976604 	addi	r2,r2,23960
81118500:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118504:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81118508:	00a045b4 	movhi	r2,33046
8111850c:	10976604 	addi	r2,r2,23960
81118510:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118514:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81118518:	00a045b4 	movhi	r2,33046
8111851c:	10976604 	addi	r2,r2,23960
81118520:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118524:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81118528:	00a045b4 	movhi	r2,33046
8111852c:	10976604 	addi	r2,r2,23960
81118530:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118534:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81118538:	00a045b4 	movhi	r2,33046
8111853c:	10976604 	addi	r2,r2,23960
81118540:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118544:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81118548:	00a045b4 	movhi	r2,33046
8111854c:	10976604 	addi	r2,r2,23960
81118550:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118554:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
81118558:	00a045b4 	movhi	r2,33046
8111855c:	10976604 	addi	r2,r2,23960
81118560:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118564:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
81118568:	00a045b4 	movhi	r2,33046
8111856c:	10976604 	addi	r2,r2,23960
81118570:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81118574:	10bfffcc 	andi	r2,r2,65535
81118578:	e53fd984 	addi	r20,fp,-154
8111857c:	d8801115 	stw	r2,68(sp)
81118580:	dcc01015 	stw	r19,64(sp)
81118584:	dc800f15 	stw	r18,60(sp)
81118588:	dc400e15 	stw	r17,56(sp)
8111858c:	dc000d15 	stw	r16,52(sp)
81118590:	dbc00c15 	stw	r15,48(sp)
81118594:	db800b15 	stw	r14,44(sp)
81118598:	db400a15 	stw	r13,40(sp)
8111859c:	db000915 	stw	r12,36(sp)
811185a0:	dac00815 	stw	r11,32(sp)
811185a4:	da800715 	stw	r10,28(sp)
811185a8:	da400615 	stw	r9,24(sp)
811185ac:	da000515 	stw	r8,20(sp)
811185b0:	d9c00415 	stw	r7,16(sp)
811185b4:	d9800315 	stw	r6,12(sp)
811185b8:	d9400215 	stw	r5,8(sp)
811185bc:	d9000115 	stw	r4,4(sp)
811185c0:	d8c00015 	stw	r3,0(sp)
811185c4:	a80f883a 	mov	r7,r21
811185c8:	018010c4 	movi	r6,67
811185cc:	01604574 	movhi	r5,33045
811185d0:	2976bc04 	addi	r5,r5,-9488
811185d4:	a009883a 	mov	r4,r20
811185d8:	11221480 	call	81122148 <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
811185dc:	e0bfd984 	addi	r2,fp,-154
811185e0:	1009883a 	mov	r4,r2
811185e4:	112235c0 	call	8112235c <strlen>
811185e8:	1007883a 	mov	r3,r2
811185ec:	e0bfd984 	addi	r2,fp,-154
811185f0:	180b883a 	mov	r5,r3
811185f4:	1009883a 	mov	r4,r2
811185f8:	111a9700 	call	8111a970 <ucCrc8wInit>
811185fc:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
81118600:	e13fd703 	ldbu	r4,-164(fp)
81118604:	e0ffd984 	addi	r3,fp,-154
81118608:	e0bfd984 	addi	r2,fp,-154
8111860c:	200f883a 	mov	r7,r4
81118610:	180d883a 	mov	r6,r3
81118614:	01604574 	movhi	r5,33045
81118618:	2976d404 	addi	r5,r5,-9392
8111861c:	1009883a 	mov	r4,r2
81118620:	11221480 	call	81122148 <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
81118624:	e0bfd90b 	ldhu	r2,-156(fp)
81118628:	10ffffcc 	andi	r3,r2,65535
8111862c:	18e0001c 	xori	r3,r3,32768
81118630:	18e00004 	addi	r3,r3,-32768
81118634:	e0bfd984 	addi	r2,fp,-154
81118638:	180b883a 	mov	r5,r3
8111863c:	1009883a 	mov	r4,r2
81118640:	1117b180 	call	81117b18 <bSendUART128v2>
81118644:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
81118648:	e0bfd817 	ldw	r2,-160(fp)
8111864c:	10800060 	cmpeqi	r2,r2,1
81118650:	1000011e 	bne	r2,zero,81118658 <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
81118654:	111b5400 	call	8111b540 <vCouldNotSendEthConfUART>
	}
}
81118658:	0001883a 	nop
8111865c:	e6fffa04 	addi	sp,fp,-24
81118660:	dfc00717 	ldw	ra,28(sp)
81118664:	df000617 	ldw	fp,24(sp)
81118668:	dd400517 	ldw	r21,20(sp)
8111866c:	dd000417 	ldw	r20,16(sp)
81118670:	dcc00317 	ldw	r19,12(sp)
81118674:	dc800217 	ldw	r18,8(sp)
81118678:	dc400117 	ldw	r17,4(sp)
8111867c:	dc000017 	ldw	r16,0(sp)
81118680:	dec00804 	addi	sp,sp,32
81118684:	f800283a 	ret

81118688 <vSendTurnOff>:


void vSendTurnOff ( void ) {
81118688:	defff304 	addi	sp,sp,-52
8111868c:	de00012e 	bgeu	sp,et,81118694 <vSendTurnOff+0xc>
81118690:	003b68fa 	trap	3
81118694:	dfc00c15 	stw	ra,48(sp)
81118698:	df000b15 	stw	fp,44(sp)
8111869c:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
811186a0:	e03ff78d 	sth	zero,-34(fp)
811186a4:	e03ff80d 	sth	zero,-32(fp)
811186a8:	e03ff88d 	sth	zero,-30(fp)
811186ac:	e03ff90d 	sth	zero,-28(fp)
811186b0:	e03ff98d 	sth	zero,-26(fp)
811186b4:	e03ffa0d 	sth	zero,-24(fp)
811186b8:	e03ffa8d 	sth	zero,-22(fp)
811186bc:	e03ffb0d 	sth	zero,-20(fp)
811186c0:	e03ffb8d 	sth	zero,-18(fp)
811186c4:	e03ffc0d 	sth	zero,-16(fp)
811186c8:	e03ffc8d 	sth	zero,-14(fp)
811186cc:	e03ffd0d 	sth	zero,-12(fp)
811186d0:	e03ffd8d 	sth	zero,-10(fp)
811186d4:	e03ffe0d 	sth	zero,-8(fp)
811186d8:	e03ffe8d 	sth	zero,-6(fp)
811186dc:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
811186e0:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
811186e4:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
811186e8:	11189b80 	call	811189b8 <usiGetIdCMD>
811186ec:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
811186f0:	e0fff70b 	ldhu	r3,-36(fp)
811186f4:	e0bff784 	addi	r2,fp,-34
811186f8:	180d883a 	mov	r6,r3
811186fc:	01604574 	movhi	r5,33045
81118700:	2976d704 	addi	r5,r5,-9380
81118704:	1009883a 	mov	r4,r2
81118708:	11221480 	call	81122148 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
8111870c:	e0bff784 	addi	r2,fp,-34
81118710:	1009883a 	mov	r4,r2
81118714:	112235c0 	call	8112235c <strlen>
81118718:	1007883a 	mov	r3,r2
8111871c:	e0bff784 	addi	r2,fp,-34
81118720:	180b883a 	mov	r5,r3
81118724:	1009883a 	mov	r4,r2
81118728:	111a9700 	call	8111a970 <ucCrc8wInit>
8111872c:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
81118730:	e13ff503 	ldbu	r4,-44(fp)
81118734:	e0fff784 	addi	r3,fp,-34
81118738:	e0bff784 	addi	r2,fp,-34
8111873c:	200f883a 	mov	r7,r4
81118740:	180d883a 	mov	r6,r3
81118744:	01604574 	movhi	r5,33045
81118748:	2976d404 	addi	r5,r5,-9392
8111874c:	1009883a 	mov	r4,r2
81118750:	11221480 	call	81122148 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
81118754:	e0bff70b 	ldhu	r2,-36(fp)
81118758:	10ffffcc 	andi	r3,r2,65535
8111875c:	18e0001c 	xori	r3,r3,32768
81118760:	18e00004 	addi	r3,r3,-32768
81118764:	e0bff784 	addi	r2,fp,-34
81118768:	180b883a 	mov	r5,r3
8111876c:	1009883a 	mov	r4,r2
81118770:	11181000 	call	81118100 <bSendUART32v2>
81118774:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81118778:	e0bff617 	ldw	r2,-40(fp)
8111877c:	10800060 	cmpeqi	r2,r2,1
81118780:	1000011e 	bne	r2,zero,81118788 <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
81118784:	111bbe80 	call	8111bbe8 <vCouldNotSendTurnOff>
	}
}
81118788:	0001883a 	nop
8111878c:	e037883a 	mov	sp,fp
81118790:	dfc00117 	ldw	ra,4(sp)
81118794:	df000017 	ldw	fp,0(sp)
81118798:	dec00204 	addi	sp,sp,8
8111879c:	f800283a 	ret

811187a0 <vSendReset>:

void vSendReset ( void ) {
811187a0:	defff304 	addi	sp,sp,-52
811187a4:	de00012e 	bgeu	sp,et,811187ac <vSendReset+0xc>
811187a8:	003b68fa 	trap	3
811187ac:	dfc00c15 	stw	ra,48(sp)
811187b0:	df000b15 	stw	fp,44(sp)
811187b4:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
811187b8:	e03ff78d 	sth	zero,-34(fp)
811187bc:	e03ff80d 	sth	zero,-32(fp)
811187c0:	e03ff88d 	sth	zero,-30(fp)
811187c4:	e03ff90d 	sth	zero,-28(fp)
811187c8:	e03ff98d 	sth	zero,-26(fp)
811187cc:	e03ffa0d 	sth	zero,-24(fp)
811187d0:	e03ffa8d 	sth	zero,-22(fp)
811187d4:	e03ffb0d 	sth	zero,-20(fp)
811187d8:	e03ffb8d 	sth	zero,-18(fp)
811187dc:	e03ffc0d 	sth	zero,-16(fp)
811187e0:	e03ffc8d 	sth	zero,-14(fp)
811187e4:	e03ffd0d 	sth	zero,-12(fp)
811187e8:	e03ffd8d 	sth	zero,-10(fp)
811187ec:	e03ffe0d 	sth	zero,-8(fp)
811187f0:	e03ffe8d 	sth	zero,-6(fp)
811187f4:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
811187f8:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
811187fc:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81118800:	11189b80 	call	811189b8 <usiGetIdCMD>
81118804:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
81118808:	e0fff70b 	ldhu	r3,-36(fp)
8111880c:	e0bff784 	addi	r2,fp,-34
81118810:	180d883a 	mov	r6,r3
81118814:	01604574 	movhi	r5,33045
81118818:	2976d904 	addi	r5,r5,-9372
8111881c:	1009883a 	mov	r4,r2
81118820:	11221480 	call	81122148 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81118824:	e0bff784 	addi	r2,fp,-34
81118828:	1009883a 	mov	r4,r2
8111882c:	112235c0 	call	8112235c <strlen>
81118830:	1007883a 	mov	r3,r2
81118834:	e0bff784 	addi	r2,fp,-34
81118838:	180b883a 	mov	r5,r3
8111883c:	1009883a 	mov	r4,r2
81118840:	111a9700 	call	8111a970 <ucCrc8wInit>
81118844:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
81118848:	e13ff503 	ldbu	r4,-44(fp)
8111884c:	e0fff784 	addi	r3,fp,-34
81118850:	e0bff784 	addi	r2,fp,-34
81118854:	200f883a 	mov	r7,r4
81118858:	180d883a 	mov	r6,r3
8111885c:	01604574 	movhi	r5,33045
81118860:	2976d404 	addi	r5,r5,-9392
81118864:	1009883a 	mov	r4,r2
81118868:	11221480 	call	81122148 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
8111886c:	e0bff70b 	ldhu	r2,-36(fp)
81118870:	10ffffcc 	andi	r3,r2,65535
81118874:	18e0001c 	xori	r3,r3,32768
81118878:	18e00004 	addi	r3,r3,-32768
8111887c:	e0bff784 	addi	r2,fp,-34
81118880:	180b883a 	mov	r5,r3
81118884:	1009883a 	mov	r4,r2
81118888:	11181000 	call	81118100 <bSendUART32v2>
8111888c:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81118890:	e0bff617 	ldw	r2,-40(fp)
81118894:	10800060 	cmpeqi	r2,r2,1
81118898:	1000011e 	bne	r2,zero,811188a0 <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8111889c:	111bbe80 	call	8111bbe8 <vCouldNotSendTurnOff>
	}
}
811188a0:	0001883a 	nop
811188a4:	e037883a 	mov	sp,fp
811188a8:	dfc00117 	ldw	ra,4(sp)
811188ac:	df000017 	ldw	fp,0(sp)
811188b0:	dec00204 	addi	sp,sp,8
811188b4:	f800283a 	ret

811188b8 <vSendLog>:

void vSendLog ( const char * cDataIn ) {
811188b8:	deffda04 	addi	sp,sp,-152
811188bc:	de00012e 	bgeu	sp,et,811188c4 <vSendLog+0xc>
811188c0:	003b68fa 	trap	3
811188c4:	dfc02515 	stw	ra,148(sp)
811188c8:	df002415 	stw	fp,144(sp)
811188cc:	df002404 	addi	fp,sp,144
811188d0:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
811188d4:	e03fde8d 	sth	zero,-134(fp)
811188d8:	e03fdf0d 	sth	zero,-132(fp)
811188dc:	e0bfdf84 	addi	r2,fp,-130
811188e0:	00c01f04 	movi	r3,124
811188e4:	180d883a 	mov	r6,r3
811188e8:	000b883a 	mov	r5,zero
811188ec:	1009883a 	mov	r4,r2
811188f0:	11219b80 	call	811219b8 <memset>
    unsigned char crc = 0;
811188f4:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
811188f8:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
811188fc:	11189b80 	call	811189b8 <usiGetIdCMD>
81118900:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
81118904:	e0ffde0b 	ldhu	r3,-136(fp)
81118908:	e0bfde84 	addi	r2,fp,-134
8111890c:	e1ffff17 	ldw	r7,-4(fp)
81118910:	180d883a 	mov	r6,r3
81118914:	01604574 	movhi	r5,33045
81118918:	2976db04 	addi	r5,r5,-9364
8111891c:	1009883a 	mov	r4,r2
81118920:	11221480 	call	81122148 <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
81118924:	e0bfde84 	addi	r2,fp,-134
81118928:	1009883a 	mov	r4,r2
8111892c:	112235c0 	call	8112235c <strlen>
81118930:	1007883a 	mov	r3,r2
81118934:	e0bfde84 	addi	r2,fp,-134
81118938:	180b883a 	mov	r5,r3
8111893c:	1009883a 	mov	r4,r2
81118940:	111a9700 	call	8111a970 <ucCrc8wInit>
81118944:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
81118948:	e13fdc03 	ldbu	r4,-144(fp)
8111894c:	e0ffde84 	addi	r3,fp,-134
81118950:	e0bfde84 	addi	r2,fp,-134
81118954:	200f883a 	mov	r7,r4
81118958:	180d883a 	mov	r6,r3
8111895c:	01604574 	movhi	r5,33045
81118960:	2976d404 	addi	r5,r5,-9392
81118964:	1009883a 	mov	r4,r2
81118968:	11221480 	call	81122148 <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
8111896c:	e0bfde0b 	ldhu	r2,-136(fp)
81118970:	10ffffcc 	andi	r3,r2,65535
81118974:	18e0001c 	xori	r3,r3,32768
81118978:	18e00004 	addi	r3,r3,-32768
8111897c:	e0bfde84 	addi	r2,fp,-134
81118980:	180b883a 	mov	r5,r3
81118984:	1009883a 	mov	r4,r2
81118988:	1117b180 	call	81117b18 <bSendUART128v2>
8111898c:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
81118990:	e0bfdd17 	ldw	r2,-140(fp)
81118994:	10800060 	cmpeqi	r2,r2,1
81118998:	1000011e 	bne	r2,zero,811189a0 <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
8111899c:	111bcb80 	call	8111bcb8 <vCouldNotSendLog>
	}
}
811189a0:	0001883a 	nop
811189a4:	e037883a 	mov	sp,fp
811189a8:	dfc00117 	ldw	ra,4(sp)
811189ac:	df000017 	ldw	fp,0(sp)
811189b0:	dec00204 	addi	sp,sp,8
811189b4:	f800283a 	ret

811189b8 <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
811189b8:	deffff04 	addi	sp,sp,-4
811189bc:	de00012e 	bgeu	sp,et,811189c4 <usiGetIdCMD+0xc>
811189c0:	003b68fa 	trap	3
811189c4:	df000015 	stw	fp,0(sp)
811189c8:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
811189cc:	d0a0670b 	ldhu	r2,-32356(gp)
811189d0:	10ffffcc 	andi	r3,r2,65535
811189d4:	00bfffd4 	movui	r2,65535
811189d8:	1880031e 	bne	r3,r2,811189e8 <usiGetIdCMD+0x30>
        usiIdCMD = 2;
811189dc:	00800084 	movi	r2,2
811189e0:	d0a0670d 	sth	r2,-32356(gp)
811189e4:	00000306 	br	811189f4 <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
811189e8:	d0a0670b 	ldhu	r2,-32356(gp)
811189ec:	10800044 	addi	r2,r2,1
811189f0:	d0a0670d 	sth	r2,-32356(gp)

    return usiIdCMD;
811189f4:	d0a0670b 	ldhu	r2,-32356(gp)
}
811189f8:	e037883a 	mov	sp,fp
811189fc:	df000017 	ldw	fp,0(sp)
81118a00:	dec00104 	addi	sp,sp,4
81118a04:	f800283a 	ret

81118a08 <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
81118a08:	defffb04 	addi	sp,sp,-20
81118a0c:	de00012e 	bgeu	sp,et,81118a14 <siPosStr+0xc>
81118a10:	003b68fa 	trap	3
81118a14:	dfc00415 	stw	ra,16(sp)
81118a18:	df000315 	stw	fp,12(sp)
81118a1c:	df000304 	addi	fp,sp,12
81118a20:	e13ffe15 	stw	r4,-8(fp)
81118a24:	2805883a 	mov	r2,r5
81118a28:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
81118a2c:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
81118a30:	e0bfff03 	ldbu	r2,-4(fp)
81118a34:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
81118a38:	e17ffd04 	addi	r5,fp,-12
81118a3c:	e13ffe17 	ldw	r4,-8(fp)
81118a40:	11223100 	call	81122310 <strcspn>
}
81118a44:	e037883a 	mov	sp,fp
81118a48:	dfc00117 	ldw	ra,4(sp)
81118a4c:	df000017 	ldw	fp,0(sp)
81118a50:	dec00204 	addi	sp,sp,8
81118a54:	f800283a 	ret

81118a58 <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
81118a58:	defffc04 	addi	sp,sp,-16
81118a5c:	de00012e 	bgeu	sp,et,81118a64 <vTimeoutCheck+0xc>
81118a60:	003b68fa 	trap	3
81118a64:	dfc00315 	stw	ra,12(sp)
81118a68:	df000215 	stw	fp,8(sp)
81118a6c:	df000204 	addi	fp,sp,8
81118a70:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
81118a74:	d0a06617 	ldw	r2,-32360(gp)
81118a78:	1009883a 	mov	r4,r2
81118a7c:	113e05c0 	call	8113e05c <OSSemPost>
81118a80:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
81118a84:	e0bffe03 	ldbu	r2,-8(fp)
81118a88:	10000126 	beq	r2,zero,81118a90 <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
81118a8c:	111b9780 	call	8111b978 <vFailPostBlockingSemTimeoutTask>
	}
}
81118a90:	0001883a 	nop
81118a94:	e037883a 	mov	sp,fp
81118a98:	dfc00117 	ldw	ra,4(sp)
81118a9c:	df000017 	ldw	fp,0(sp)
81118aa0:	dec00204 	addi	sp,sp,8
81118aa4:	f800283a 	ret

81118aa8 <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
81118aa8:	deffe304 	addi	sp,sp,-116
81118aac:	de00012e 	bgeu	sp,et,81118ab4 <vSendPusTM64+0xc>
81118ab0:	003b68fa 	trap	3
81118ab4:	dfc01815 	stw	ra,96(sp)
81118ab8:	df001715 	stw	fp,92(sp)
81118abc:	df001704 	addi	fp,sp,92
81118ac0:	e1000215 	stw	r4,8(fp)
81118ac4:	e1400315 	stw	r5,12(fp)
81118ac8:	e1800415 	stw	r6,16(fp)
81118acc:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
81118ad0:	e03fef8d 	sth	zero,-66(fp)
81118ad4:	e03ff00d 	sth	zero,-64(fp)
81118ad8:	e0bff084 	addi	r2,fp,-62
81118adc:	00c00f04 	movi	r3,60
81118ae0:	180d883a 	mov	r6,r3
81118ae4:	000b883a 	mov	r5,zero
81118ae8:	1009883a 	mov	r4,r2
81118aec:	11219b80 	call	811219b8 <memset>
    unsigned char crc = 0;
81118af0:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
81118af4:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81118af8:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
81118afc:	11189b80 	call	811189b8 <usiGetIdCMD>
81118b00:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
81118b04:	e1bfef0b 	ldhu	r6,-68(fp)
81118b08:	e080040b 	ldhu	r2,16(fp)
81118b0c:	11ffffcc 	andi	r7,r2,65535
81118b10:	e080048b 	ldhu	r2,18(fp)
81118b14:	10bfffcc 	andi	r2,r2,65535
81118b18:	e0c0050b 	ldhu	r3,20(fp)
81118b1c:	18ffffcc 	andi	r3,r3,65535
81118b20:	e100058b 	ldhu	r4,22(fp)
81118b24:	213fffcc 	andi	r4,r4,65535
81118b28:	e140060b 	ldhu	r5,24(fp)
81118b2c:	297fffcc 	andi	r5,r5,65535
81118b30:	e23fef84 	addi	r8,fp,-66
81118b34:	d9400315 	stw	r5,12(sp)
81118b38:	d9000215 	stw	r4,8(sp)
81118b3c:	d8c00115 	stw	r3,4(sp)
81118b40:	d8800015 	stw	r2,0(sp)
81118b44:	01604574 	movhi	r5,33045
81118b48:	2976de04 	addi	r5,r5,-9352
81118b4c:	4009883a 	mov	r4,r8
81118b50:	11221480 	call	81122148 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81118b54:	e03fed05 	stb	zero,-76(fp)
81118b58:	00001206 	br	81118ba4 <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
81118b5c:	e0bfed03 	ldbu	r2,-76(fp)
81118b60:	10800284 	addi	r2,r2,10
81118b64:	1085883a 	add	r2,r2,r2
81118b68:	e0c00204 	addi	r3,fp,8
81118b6c:	1885883a 	add	r2,r3,r2
81118b70:	1080000b 	ldhu	r2,0(r2)
81118b74:	113fffcc 	andi	r4,r2,65535
81118b78:	e0ffef84 	addi	r3,fp,-66
81118b7c:	e0bfef84 	addi	r2,fp,-66
81118b80:	200f883a 	mov	r7,r4
81118b84:	180d883a 	mov	r6,r3
81118b88:	01604574 	movhi	r5,33045
81118b8c:	2976e504 	addi	r5,r5,-9324
81118b90:	1009883a 	mov	r4,r2
81118b94:	11221480 	call	81122148 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81118b98:	e0bfed03 	ldbu	r2,-76(fp)
81118b9c:	10800044 	addi	r2,r2,1
81118ba0:	e0bfed05 	stb	r2,-76(fp)
81118ba4:	e0800683 	ldbu	r2,26(fp)
81118ba8:	10803fcc 	andi	r2,r2,255
81118bac:	e0ffed03 	ldbu	r3,-76(fp)
81118bb0:	18bfea36 	bltu	r3,r2,81118b5c <__reset+0xfb0f8b5c>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
81118bb4:	e0bfef84 	addi	r2,fp,-66
81118bb8:	1009883a 	mov	r4,r2
81118bbc:	112235c0 	call	8112235c <strlen>
81118bc0:	1007883a 	mov	r3,r2
81118bc4:	e0bfef84 	addi	r2,fp,-66
81118bc8:	180b883a 	mov	r5,r3
81118bcc:	1009883a 	mov	r4,r2
81118bd0:	111a9700 	call	8111a970 <ucCrc8wInit>
81118bd4:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81118bd8:	e13fed43 	ldbu	r4,-75(fp)
81118bdc:	e0ffef84 	addi	r3,fp,-66
81118be0:	e0bfef84 	addi	r2,fp,-66
81118be4:	200f883a 	mov	r7,r4
81118be8:	180d883a 	mov	r6,r3
81118bec:	01604574 	movhi	r5,33045
81118bf0:	2976d404 	addi	r5,r5,-9392
81118bf4:	1009883a 	mov	r4,r2
81118bf8:	11221480 	call	81122148 <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
81118bfc:	e0bfef0b 	ldhu	r2,-68(fp)
81118c00:	10ffffcc 	andi	r3,r2,65535
81118c04:	18e0001c 	xori	r3,r3,32768
81118c08:	18e00004 	addi	r3,r3,-32768
81118c0c:	e0bfef84 	addi	r2,fp,-66
81118c10:	180b883a 	mov	r5,r3
81118c14:	1009883a 	mov	r4,r2
81118c18:	1117e080 	call	81117e08 <bSendUART64v2>
81118c1c:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
81118c20:	e0bfee17 	ldw	r2,-72(fp)
81118c24:	10800060 	cmpeqi	r2,r2,1
81118c28:	1000031e 	bne	r2,zero,81118c38 <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
81118c2c:	e0bfef84 	addi	r2,fp,-66
81118c30:	1009883a 	mov	r4,r2
81118c34:	111bd200 	call	8111bd20 <vCouldNotSendTMPusCommand>
	}
}
81118c38:	0001883a 	nop
81118c3c:	e037883a 	mov	sp,fp
81118c40:	dfc00117 	ldw	ra,4(sp)
81118c44:	df000017 	ldw	fp,0(sp)
81118c48:	dec00604 	addi	sp,sp,24
81118c4c:	f800283a 	ret

81118c50 <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
81118c50:	deffd304 	addi	sp,sp,-180
81118c54:	de00012e 	bgeu	sp,et,81118c5c <vSendPusTM128+0xc>
81118c58:	003b68fa 	trap	3
81118c5c:	dfc02815 	stw	ra,160(sp)
81118c60:	df002715 	stw	fp,156(sp)
81118c64:	df002704 	addi	fp,sp,156
81118c68:	e1000215 	stw	r4,8(fp)
81118c6c:	e1400315 	stw	r5,12(fp)
81118c70:	e1800415 	stw	r6,16(fp)
81118c74:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
81118c78:	e03fdf8d 	sth	zero,-130(fp)
81118c7c:	e03fe00d 	sth	zero,-128(fp)
81118c80:	e0bfe084 	addi	r2,fp,-126
81118c84:	00c01f04 	movi	r3,124
81118c88:	180d883a 	mov	r6,r3
81118c8c:	000b883a 	mov	r5,zero
81118c90:	1009883a 	mov	r4,r2
81118c94:	11219b80 	call	811219b8 <memset>
    unsigned char crc = 0;
81118c98:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
81118c9c:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
81118ca0:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
81118ca4:	11189b80 	call	811189b8 <usiGetIdCMD>
81118ca8:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
81118cac:	e1bfdf0b 	ldhu	r6,-132(fp)
81118cb0:	e080040b 	ldhu	r2,16(fp)
81118cb4:	11ffffcc 	andi	r7,r2,65535
81118cb8:	e080048b 	ldhu	r2,18(fp)
81118cbc:	10bfffcc 	andi	r2,r2,65535
81118cc0:	e0c0050b 	ldhu	r3,20(fp)
81118cc4:	18ffffcc 	andi	r3,r3,65535
81118cc8:	e100058b 	ldhu	r4,22(fp)
81118ccc:	213fffcc 	andi	r4,r4,65535
81118cd0:	e140060b 	ldhu	r5,24(fp)
81118cd4:	297fffcc 	andi	r5,r5,65535
81118cd8:	e23fdf84 	addi	r8,fp,-130
81118cdc:	d9400315 	stw	r5,12(sp)
81118ce0:	d9000215 	stw	r4,8(sp)
81118ce4:	d8c00115 	stw	r3,4(sp)
81118ce8:	d8800015 	stw	r2,0(sp)
81118cec:	01604574 	movhi	r5,33045
81118cf0:	2976de04 	addi	r5,r5,-9352
81118cf4:	4009883a 	mov	r4,r8
81118cf8:	11221480 	call	81122148 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81118cfc:	e03fdd05 	stb	zero,-140(fp)
81118d00:	00001206 	br	81118d4c <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
81118d04:	e0bfdd03 	ldbu	r2,-140(fp)
81118d08:	10800284 	addi	r2,r2,10
81118d0c:	1085883a 	add	r2,r2,r2
81118d10:	e0c00204 	addi	r3,fp,8
81118d14:	1885883a 	add	r2,r3,r2
81118d18:	1080000b 	ldhu	r2,0(r2)
81118d1c:	113fffcc 	andi	r4,r2,65535
81118d20:	e0ffdf84 	addi	r3,fp,-130
81118d24:	e0bfdf84 	addi	r2,fp,-130
81118d28:	200f883a 	mov	r7,r4
81118d2c:	180d883a 	mov	r6,r3
81118d30:	01604574 	movhi	r5,33045
81118d34:	2976e504 	addi	r5,r5,-9324
81118d38:	1009883a 	mov	r4,r2
81118d3c:	11221480 	call	81122148 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81118d40:	e0bfdd03 	ldbu	r2,-140(fp)
81118d44:	10800044 	addi	r2,r2,1
81118d48:	e0bfdd05 	stb	r2,-140(fp)
81118d4c:	e0800683 	ldbu	r2,26(fp)
81118d50:	10803fcc 	andi	r2,r2,255
81118d54:	e0ffdd03 	ldbu	r3,-140(fp)
81118d58:	18bfea36 	bltu	r3,r2,81118d04 <__reset+0xfb0f8d04>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
81118d5c:	e0bfdf84 	addi	r2,fp,-130
81118d60:	1009883a 	mov	r4,r2
81118d64:	112235c0 	call	8112235c <strlen>
81118d68:	1007883a 	mov	r3,r2
81118d6c:	e0bfdf84 	addi	r2,fp,-130
81118d70:	180b883a 	mov	r5,r3
81118d74:	1009883a 	mov	r4,r2
81118d78:	111a9700 	call	8111a970 <ucCrc8wInit>
81118d7c:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81118d80:	e13fdd43 	ldbu	r4,-139(fp)
81118d84:	e0ffdf84 	addi	r3,fp,-130
81118d88:	e0bfdf84 	addi	r2,fp,-130
81118d8c:	200f883a 	mov	r7,r4
81118d90:	180d883a 	mov	r6,r3
81118d94:	01604574 	movhi	r5,33045
81118d98:	2976d404 	addi	r5,r5,-9392
81118d9c:	1009883a 	mov	r4,r2
81118da0:	11221480 	call	81122148 <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
81118da4:	e0bfdf0b 	ldhu	r2,-132(fp)
81118da8:	10ffffcc 	andi	r3,r2,65535
81118dac:	18e0001c 	xori	r3,r3,32768
81118db0:	18e00004 	addi	r3,r3,-32768
81118db4:	e0bfdf84 	addi	r2,fp,-130
81118db8:	180b883a 	mov	r5,r3
81118dbc:	1009883a 	mov	r4,r2
81118dc0:	1117b180 	call	81117b18 <bSendUART128v2>
81118dc4:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
81118dc8:	e0bfde17 	ldw	r2,-136(fp)
81118dcc:	10800060 	cmpeqi	r2,r2,1
81118dd0:	1000031e 	bne	r2,zero,81118de0 <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
81118dd4:	e0bfdf84 	addi	r2,fp,-130
81118dd8:	1009883a 	mov	r4,r2
81118ddc:	111bd200 	call	8111bd20 <vCouldNotSendTMPusCommand>
	}
}
81118de0:	0001883a 	nop
81118de4:	e037883a 	mov	sp,fp
81118de8:	dfc00117 	ldw	ra,4(sp)
81118dec:	df000017 	ldw	fp,0(sp)
81118df0:	dec00604 	addi	sp,sp,24
81118df4:	f800283a 	ret

81118df8 <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
81118df8:	deffd704 	addi	sp,sp,-164
81118dfc:	de00012e 	bgeu	sp,et,81118e04 <vTMPusTestConnection+0xc>
81118e00:	003b68fa 	trap	3
81118e04:	dfc02815 	stw	ra,160(sp)
81118e08:	df002715 	stw	fp,156(sp)
81118e0c:	df002704 	addi	fp,sp,156
81118e10:	2005883a 	mov	r2,r4
81118e14:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
81118e18:	e0bfff0b 	ldhu	r2,-4(fp)
81118e1c:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
81118e20:	00801c04 	movi	r2,112
81118e24:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
81118e28:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
81118e2c:	00800444 	movi	r2,17
81118e30:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
81118e34:	00800084 	movi	r2,2
81118e38:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
81118e3c:	d809883a 	mov	r4,sp
81118e40:	e0bfee04 	addi	r2,fp,-72
81118e44:	00c01104 	movi	r3,68
81118e48:	180d883a 	mov	r6,r3
81118e4c:	100b883a 	mov	r5,r2
81118e50:	11218680 	call	81121868 <memcpy>
81118e54:	e13fea17 	ldw	r4,-88(fp)
81118e58:	e17feb17 	ldw	r5,-84(fp)
81118e5c:	e1bfec17 	ldw	r6,-80(fp)
81118e60:	e1ffed17 	ldw	r7,-76(fp)
81118e64:	1118aa80 	call	81118aa8 <vSendPusTM64>
}
81118e68:	0001883a 	nop
81118e6c:	e037883a 	mov	sp,fp
81118e70:	dfc00117 	ldw	ra,4(sp)
81118e74:	df000017 	ldw	fp,0(sp)
81118e78:	dec00204 	addi	sp,sp,8
81118e7c:	f800283a 	ret

81118e80 <vLoadDefaultETHConf>:
/*Configuration related to the eth connection*/
TConfEth xConfEth;
TDefaults xDefaults;


bool vLoadDefaultETHConf( void ){
81118e80:	defff504 	addi	sp,sp,-44
81118e84:	de00012e 	bgeu	sp,et,81118e8c <vLoadDefaultETHConf+0xc>
81118e88:	003b68fa 	trap	3
81118e8c:	dfc00a15 	stw	ra,40(sp)
81118e90:	df000915 	stw	fp,36(sp)
81118e94:	dc000815 	stw	r16,32(sp)
81118e98:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
81118e9c:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
81118ea0:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
81118ea4:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
81118ea8:	d0a07517 	ldw	r2,-32300(gp)
81118eac:	10800058 	cmpnei	r2,r2,1
81118eb0:	1002051e 	bne	r2,zero,811196c8 <vLoadDefaultETHConf+0x848>
81118eb4:	111dbcc0 	call	8111dbcc <bSDcardIsPresent>
81118eb8:	10020326 	beq	r2,zero,811196c8 <vLoadDefaultETHConf+0x848>
81118ebc:	111dbfc0 	call	8111dbfc <bSDcardFAT16Check>
81118ec0:	10020126 	beq	r2,zero,811196c8 <vLoadDefaultETHConf+0x848>

		siFile = siOpenFile( ETH_FILE_NAME );
81118ec4:	01204574 	movhi	r4,33045
81118ec8:	2136e704 	addi	r4,r4,-9316
81118ecc:	111dd240 	call	8111dd24 <siOpenFile>
81118ed0:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
81118ed4:	e0bffc0f 	ldh	r2,-16(fp)
81118ed8:	1001f316 	blt	r2,zero,811196a8 <vLoadDefaultETHConf+0x828>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
81118edc:	e0bffd04 	addi	r2,fp,-12
81118ee0:	01800204 	movi	r6,8
81118ee4:	01400284 	movi	r5,10
81118ee8:	1009883a 	mov	r4,r2
81118eec:	11219b80 	call	811219b8 <memset>
			p_inteiro = inteiro;
81118ef0:	e0bffd04 	addi	r2,fp,-12
81118ef4:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
81118ef8:	e0bffc0f 	ldh	r2,-16(fp)
81118efc:	1009883a 	mov	r4,r2
81118f00:	111dda00 	call	8111dda0 <cGetNextChar>
81118f04:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
81118f08:	e0bff947 	ldb	r2,-27(fp)
81118f0c:	10800084 	addi	r2,r2,2
81118f10:	10c015a8 	cmpgeui	r3,r2,86
81118f14:	1801d81e 	bne	r3,zero,81119678 <vLoadDefaultETHConf+0x7f8>
81118f18:	100690ba 	slli	r3,r2,2
81118f1c:	00a044b4 	movhi	r2,33042
81118f20:	10a3cc04 	addi	r2,r2,-28880
81118f24:	1885883a 	add	r2,r3,r2
81118f28:	10800017 	ldw	r2,0(r2)
81118f2c:	1000683a 	jmp	r2
81118f30:	811190c8 	cmpgei	r4,r16,17987
81118f34:	811190bc 	xorhi	r4,r16,17986
81118f38:	81119678 	rdprs	r4,r16,18009
81118f3c:	81119678 	rdprs	r4,r16,18009
81118f40:	81119678 	rdprs	r4,r16,18009
81118f44:	81119678 	rdprs	r4,r16,18009
81118f48:	81119678 	rdprs	r4,r16,18009
81118f4c:	81119678 	rdprs	r4,r16,18009
81118f50:	81119678 	rdprs	r4,r16,18009
81118f54:	81119678 	rdprs	r4,r16,18009
81118f58:	81119678 	rdprs	r4,r16,18009
81118f5c:	81119678 	rdprs	r4,r16,18009
81118f60:	81119698 	cmpnei	r4,r16,18010
81118f64:	81119678 	rdprs	r4,r16,18009
81118f68:	81119678 	rdprs	r4,r16,18009
81118f6c:	81119698 	cmpnei	r4,r16,18010
81118f70:	81119678 	rdprs	r4,r16,18009
81118f74:	81119678 	rdprs	r4,r16,18009
81118f78:	81119678 	rdprs	r4,r16,18009
81118f7c:	81119678 	rdprs	r4,r16,18009
81118f80:	81119678 	rdprs	r4,r16,18009
81118f84:	81119678 	rdprs	r4,r16,18009
81118f88:	81119678 	rdprs	r4,r16,18009
81118f8c:	81119678 	rdprs	r4,r16,18009
81118f90:	81119678 	rdprs	r4,r16,18009
81118f94:	81119678 	rdprs	r4,r16,18009
81118f98:	81119678 	rdprs	r4,r16,18009
81118f9c:	81119678 	rdprs	r4,r16,18009
81118fa0:	81119678 	rdprs	r4,r16,18009
81118fa4:	81119678 	rdprs	r4,r16,18009
81118fa8:	81119678 	rdprs	r4,r16,18009
81118fac:	81119678 	rdprs	r4,r16,18009
81118fb0:	81119678 	rdprs	r4,r16,18009
81118fb4:	81119678 	rdprs	r4,r16,18009
81118fb8:	81119698 	cmpnei	r4,r16,18010
81118fbc:	81119678 	rdprs	r4,r16,18009
81118fc0:	81119678 	rdprs	r4,r16,18009
81118fc4:	81119678 	rdprs	r4,r16,18009
81118fc8:	81119678 	rdprs	r4,r16,18009
81118fcc:	81119678 	rdprs	r4,r16,18009
81118fd0:	81119678 	rdprs	r4,r16,18009
81118fd4:	81119088 	cmpgei	r4,r16,17986
81118fd8:	81119678 	rdprs	r4,r16,18009
81118fdc:	81119678 	rdprs	r4,r16,18009
81118fe0:	81119678 	rdprs	r4,r16,18009
81118fe4:	81119678 	rdprs	r4,r16,18009
81118fe8:	81119678 	rdprs	r4,r16,18009
81118fec:	81119678 	rdprs	r4,r16,18009
81118ff0:	81119678 	rdprs	r4,r16,18009
81118ff4:	81119678 	rdprs	r4,r16,18009
81118ff8:	81119678 	rdprs	r4,r16,18009
81118ffc:	81119678 	rdprs	r4,r16,18009
81119000:	81119678 	rdprs	r4,r16,18009
81119004:	81119678 	rdprs	r4,r16,18009
81119008:	81119678 	rdprs	r4,r16,18009
8111900c:	81119678 	rdprs	r4,r16,18009
81119010:	81119678 	rdprs	r4,r16,18009
81119014:	81119678 	rdprs	r4,r16,18009
81119018:	81119678 	rdprs	r4,r16,18009
8111901c:	81119678 	rdprs	r4,r16,18009
81119020:	81119678 	rdprs	r4,r16,18009
81119024:	81119678 	rdprs	r4,r16,18009
81119028:	81119630 	cmpltui	r4,r16,18008
8111902c:	81119678 	rdprs	r4,r16,18009
81119030:	81119678 	rdprs	r4,r16,18009
81119034:	81119678 	rdprs	r4,r16,18009
81119038:	81119678 	rdprs	r4,r16,18009
8111903c:	81119678 	rdprs	r4,r16,18009
81119040:	81119678 	rdprs	r4,r16,18009
81119044:	81119678 	rdprs	r4,r16,18009
81119048:	81119560 	cmpeqi	r4,r16,18005
8111904c:	81119678 	rdprs	r4,r16,18009
81119050:	81119678 	rdprs	r4,r16,18009
81119054:	8111928c 	andi	r4,r16,17994
81119058:	811193e8 	cmpgeui	r4,r16,17999
8111905c:	811191c0 	call	8811191c <__reset+0x20f191c>
81119060:	81119678 	rdprs	r4,r16,18009
81119064:	81119678 	rdprs	r4,r16,18009
81119068:	81119678 	rdprs	r4,r16,18009
8111906c:	811190f0 	cmpltui	r4,r16,17987
81119070:	81119678 	rdprs	r4,r16,18009
81119074:	81119678 	rdprs	r4,r16,18009
81119078:	8111935c 	xori	r4,r16,17997
8111907c:	81119678 	rdprs	r4,r16,18009
81119080:	81119678 	rdprs	r4,r16,18009
81119084:	81119490 	cmplti	r4,r16,18002
					case 39:// single quote '
						c = cGetNextChar(siFile);
81119088:	e0bffc0f 	ldh	r2,-16(fp)
8111908c:	1009883a 	mov	r4,r2
81119090:	111dda00 	call	8111dda0 <cGetNextChar>
81119094:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
81119098:	00000406 	br	811190ac <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
8111909c:	e0bffc0f 	ldh	r2,-16(fp)
811190a0:	1009883a 	mov	r4,r2
811190a4:	111dda00 	call	8111dda0 <cGetNextChar>
811190a8:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
811190ac:	e0bff947 	ldb	r2,-27(fp)
811190b0:	108009d8 	cmpnei	r2,r2,39
811190b4:	103ff91e 	bne	r2,zero,8111909c <__reset+0xfb0f909c>
							c = cGetNextChar(siFile);
						}
						break;
811190b8:	00017806 	br	8111969c <vLoadDefaultETHConf+0x81c>
					case -1: 	//EOF
						bEOF = TRUE;
811190bc:	00800044 	movi	r2,1
811190c0:	e0bff815 	stw	r2,-32(fp)
						break;
811190c4:	00017506 	br	8111969c <vLoadDefaultETHConf+0x81c>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
811190c8:	d0a06117 	ldw	r2,-32380(gp)
811190cc:	100f883a 	mov	r7,r2
811190d0:	018006c4 	movi	r6,27
811190d4:	01400044 	movi	r5,1
811190d8:	01204574 	movhi	r4,33045
811190dc:	2136e904 	addi	r4,r4,-9308
811190e0:	1120e540 	call	81120e54 <fwrite>
						#endif
						bEOF = TRUE;
811190e4:	00800044 	movi	r2,1
811190e8:	e0bff815 	stw	r2,-32(fp)
						break;
811190ec:	00016b06 	br	8111969c <vLoadDefaultETHConf+0x81c>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
811190f0:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811190f4:	e0bffc0f 	ldh	r2,-16(fp)
811190f8:	1009883a 	mov	r4,r2
811190fc:	111dda00 	call	8111dda0 <cGetNextChar>
81119100:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119104:	d0e00317 	ldw	r3,-32756(gp)
81119108:	e0bff947 	ldb	r2,-27(fp)
8111910c:	10800044 	addi	r2,r2,1
81119110:	1885883a 	add	r2,r3,r2
81119114:	10800003 	ldbu	r2,0(r2)
81119118:	10803fcc 	andi	r2,r2,255
8111911c:	1080010c 	andi	r2,r2,4
81119120:	10000626 	beq	r2,zero,8111913c <vLoadDefaultETHConf+0x2bc>
									(*p_inteiro) = c;
81119124:	e0bffa17 	ldw	r2,-24(fp)
81119128:	e0fff943 	ldbu	r3,-27(fp)
8111912c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119130:	e0bffa17 	ldw	r2,-24(fp)
81119134:	10800044 	addi	r2,r2,1
81119138:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
8111913c:	e0bff947 	ldb	r2,-27(fp)
81119140:	10800ea0 	cmpeqi	r2,r2,58
81119144:	1000031e 	bne	r2,zero,81119154 <vLoadDefaultETHConf+0x2d4>
81119148:	e0bff947 	ldb	r2,-27(fp)
8111914c:	10800ed8 	cmpnei	r2,r2,59
81119150:	103fe81e 	bne	r2,zero,811190f4 <__reset+0xfb0f90f4>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119154:	e0bffa17 	ldw	r2,-24(fp)
81119158:	00c00284 	movi	r3,10
8111915c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = atoi( inteiro );
81119160:	e0bff903 	ldbu	r2,-28(fp)
81119164:	10800168 	cmpgeui	r2,r2,5
81119168:	1000021e 	bne	r2,zero,81119174 <vLoadDefaultETHConf+0x2f4>
8111916c:	e43ff903 	ldbu	r16,-28(fp)
81119170:	00000106 	br	81119178 <vLoadDefaultETHConf+0x2f8>
81119174:	04000144 	movi	r16,5
81119178:	e0bffd04 	addi	r2,fp,-12
8111917c:	1009883a 	mov	r4,r2
81119180:	112065c0 	call	8112065c <atoi>
81119184:	1007883a 	mov	r3,r2
81119188:	00a045b4 	movhi	r2,33046
8111918c:	10976604 	addi	r2,r2,23960
81119190:	1405883a 	add	r2,r2,r16
81119194:	10800404 	addi	r2,r2,16
81119198:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111919c:	e0bffd04 	addi	r2,fp,-12
811191a0:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811191a4:	e0bff903 	ldbu	r2,-28(fp)
811191a8:	10800044 	addi	r2,r2,1
811191ac:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811191b0:	e0bff947 	ldb	r2,-27(fp)
811191b4:	10800ed8 	cmpnei	r2,r2,59
811191b8:	103fce1e 	bne	r2,zero,811190f4 <__reset+0xfb0f90f4>

						break;
811191bc:	00013706 	br	8111969c <vLoadDefaultETHConf+0x81c>
					case 'I':

						ucParser = 0;
811191c0:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811191c4:	e0bffc0f 	ldh	r2,-16(fp)
811191c8:	1009883a 	mov	r4,r2
811191cc:	111dda00 	call	8111dda0 <cGetNextChar>
811191d0:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811191d4:	d0e00317 	ldw	r3,-32756(gp)
811191d8:	e0bff947 	ldb	r2,-27(fp)
811191dc:	10800044 	addi	r2,r2,1
811191e0:	1885883a 	add	r2,r3,r2
811191e4:	10800003 	ldbu	r2,0(r2)
811191e8:	10803fcc 	andi	r2,r2,255
811191ec:	1080010c 	andi	r2,r2,4
811191f0:	10000626 	beq	r2,zero,8111920c <vLoadDefaultETHConf+0x38c>
									(*p_inteiro) = c;
811191f4:	e0bffa17 	ldw	r2,-24(fp)
811191f8:	e0fff943 	ldbu	r3,-27(fp)
811191fc:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119200:	e0bffa17 	ldw	r2,-24(fp)
81119204:	10800044 	addi	r2,r2,1
81119208:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111920c:	e0bff947 	ldb	r2,-27(fp)
81119210:	10800ba0 	cmpeqi	r2,r2,46
81119214:	1000031e 	bne	r2,zero,81119224 <vLoadDefaultETHConf+0x3a4>
81119218:	e0bff947 	ldb	r2,-27(fp)
8111921c:	10800ed8 	cmpnei	r2,r2,59
81119220:	103fe81e 	bne	r2,zero,811191c4 <__reset+0xfb0f91c4>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119224:	e0bffa17 	ldw	r2,-24(fp)
81119228:	00c00284 	movi	r3,10
8111922c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = atoi( inteiro );
81119230:	e0bff903 	ldbu	r2,-28(fp)
81119234:	108000e8 	cmpgeui	r2,r2,3
81119238:	1000021e 	bne	r2,zero,81119244 <vLoadDefaultETHConf+0x3c4>
8111923c:	e43ff903 	ldbu	r16,-28(fp)
81119240:	00000106 	br	81119248 <vLoadDefaultETHConf+0x3c8>
81119244:	040000c4 	movi	r16,3
81119248:	e0bffd04 	addi	r2,fp,-12
8111924c:	1009883a 	mov	r4,r2
81119250:	112065c0 	call	8112065c <atoi>
81119254:	1007883a 	mov	r3,r2
81119258:	00a045b4 	movhi	r2,33046
8111925c:	10976604 	addi	r2,r2,23960
81119260:	1405883a 	add	r2,r2,r16
81119264:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119268:	e0bffd04 	addi	r2,fp,-12
8111926c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119270:	e0bff903 	ldbu	r2,-28(fp)
81119274:	10800044 	addi	r2,r2,1
81119278:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111927c:	e0bff947 	ldb	r2,-27(fp)
81119280:	10800ed8 	cmpnei	r2,r2,59
81119284:	103fcf1e 	bne	r2,zero,811191c4 <__reset+0xfb0f91c4>

						break;
81119288:	00010406 	br	8111969c <vLoadDefaultETHConf+0x81c>
					case 'G':

						ucParser = 0;
8111928c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119290:	e0bffc0f 	ldh	r2,-16(fp)
81119294:	1009883a 	mov	r4,r2
81119298:	111dda00 	call	8111dda0 <cGetNextChar>
8111929c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811192a0:	d0e00317 	ldw	r3,-32756(gp)
811192a4:	e0bff947 	ldb	r2,-27(fp)
811192a8:	10800044 	addi	r2,r2,1
811192ac:	1885883a 	add	r2,r3,r2
811192b0:	10800003 	ldbu	r2,0(r2)
811192b4:	10803fcc 	andi	r2,r2,255
811192b8:	1080010c 	andi	r2,r2,4
811192bc:	10000626 	beq	r2,zero,811192d8 <vLoadDefaultETHConf+0x458>
									(*p_inteiro) = c;
811192c0:	e0bffa17 	ldw	r2,-24(fp)
811192c4:	e0fff943 	ldbu	r3,-27(fp)
811192c8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811192cc:	e0bffa17 	ldw	r2,-24(fp)
811192d0:	10800044 	addi	r2,r2,1
811192d4:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
811192d8:	e0bff947 	ldb	r2,-27(fp)
811192dc:	10800ba0 	cmpeqi	r2,r2,46
811192e0:	1000031e 	bne	r2,zero,811192f0 <vLoadDefaultETHConf+0x470>
811192e4:	e0bff947 	ldb	r2,-27(fp)
811192e8:	10800ed8 	cmpnei	r2,r2,59
811192ec:	103fe81e 	bne	r2,zero,81119290 <__reset+0xfb0f9290>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811192f0:	e0bffa17 	ldw	r2,-24(fp)
811192f4:	00c00284 	movi	r3,10
811192f8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = atoi( inteiro );
811192fc:	e0bff903 	ldbu	r2,-28(fp)
81119300:	108000e8 	cmpgeui	r2,r2,3
81119304:	1000021e 	bne	r2,zero,81119310 <vLoadDefaultETHConf+0x490>
81119308:	e43ff903 	ldbu	r16,-28(fp)
8111930c:	00000106 	br	81119314 <vLoadDefaultETHConf+0x494>
81119310:	040000c4 	movi	r16,3
81119314:	e0bffd04 	addi	r2,fp,-12
81119318:	1009883a 	mov	r4,r2
8111931c:	112065c0 	call	8112065c <atoi>
81119320:	1007883a 	mov	r3,r2
81119324:	00a045b4 	movhi	r2,33046
81119328:	10976604 	addi	r2,r2,23960
8111932c:	1405883a 	add	r2,r2,r16
81119330:	10800104 	addi	r2,r2,4
81119334:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119338:	e0bffd04 	addi	r2,fp,-12
8111933c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119340:	e0bff903 	ldbu	r2,-28(fp)
81119344:	10800044 	addi	r2,r2,1
81119348:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111934c:	e0bff947 	ldb	r2,-27(fp)
81119350:	10800ed8 	cmpnei	r2,r2,59
81119354:	103fce1e 	bne	r2,zero,81119290 <__reset+0xfb0f9290>

						break;
81119358:	0000d006 	br	8111969c <vLoadDefaultETHConf+0x81c>
					case 'P':
						ucParser = 0;
8111935c:	e03ff905 	stb	zero,-28(fp)
						do {
							c = cGetNextChar(siFile);
81119360:	e0bffc0f 	ldh	r2,-16(fp)
81119364:	1009883a 	mov	r4,r2
81119368:	111dda00 	call	8111dda0 <cGetNextChar>
8111936c:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81119370:	d0e00317 	ldw	r3,-32756(gp)
81119374:	e0bff947 	ldb	r2,-27(fp)
81119378:	10800044 	addi	r2,r2,1
8111937c:	1885883a 	add	r2,r3,r2
81119380:	10800003 	ldbu	r2,0(r2)
81119384:	10803fcc 	andi	r2,r2,255
81119388:	1080010c 	andi	r2,r2,4
8111938c:	10000626 	beq	r2,zero,811193a8 <vLoadDefaultETHConf+0x528>
								(*p_inteiro) = c;
81119390:	e0bffa17 	ldw	r2,-24(fp)
81119394:	e0fff943 	ldbu	r3,-27(fp)
81119398:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111939c:	e0bffa17 	ldw	r2,-24(fp)
811193a0:	10800044 	addi	r2,r2,1
811193a4:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
811193a8:	e0bff947 	ldb	r2,-27(fp)
811193ac:	10800ed8 	cmpnei	r2,r2,59
811193b0:	103feb1e 	bne	r2,zero,81119360 <__reset+0xfb0f9360>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811193b4:	e0bffa17 	ldw	r2,-24(fp)
811193b8:	00c00284 	movi	r3,10
811193bc:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = atoi( inteiro );
811193c0:	e0bffd04 	addi	r2,fp,-12
811193c4:	1009883a 	mov	r4,r2
811193c8:	112065c0 	call	8112065c <atoi>
811193cc:	1007883a 	mov	r3,r2
811193d0:	00a045b4 	movhi	r2,33046
811193d4:	10976604 	addi	r2,r2,23960
811193d8:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
811193dc:	e0bffd04 	addi	r2,fp,-12
811193e0:	e0bffa15 	stw	r2,-24(fp)

						break;
811193e4:	0000ad06 	br	8111969c <vLoadDefaultETHConf+0x81c>
					case 'H':

						do {
							c = cGetNextChar(siFile);
811193e8:	e0bffc0f 	ldh	r2,-16(fp)
811193ec:	1009883a 	mov	r4,r2
811193f0:	111dda00 	call	8111dda0 <cGetNextChar>
811193f4:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
811193f8:	d0e00317 	ldw	r3,-32756(gp)
811193fc:	e0bff947 	ldb	r2,-27(fp)
81119400:	10800044 	addi	r2,r2,1
81119404:	1885883a 	add	r2,r3,r2
81119408:	10800003 	ldbu	r2,0(r2)
8111940c:	10803fcc 	andi	r2,r2,255
81119410:	1080010c 	andi	r2,r2,4
81119414:	10000626 	beq	r2,zero,81119430 <vLoadDefaultETHConf+0x5b0>
								(*p_inteiro) = c;
81119418:	e0bffa17 	ldw	r2,-24(fp)
8111941c:	e0fff943 	ldbu	r3,-27(fp)
81119420:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81119424:	e0bffa17 	ldw	r2,-24(fp)
81119428:	10800044 	addi	r2,r2,1
8111942c:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81119430:	e0bff947 	ldb	r2,-27(fp)
81119434:	10800ed8 	cmpnei	r2,r2,59
81119438:	103feb1e 	bne	r2,zero,811193e8 <__reset+0xfb0f93e8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111943c:	e0bffa17 	ldw	r2,-24(fp)
81119440:	00c00284 	movi	r3,10
81119444:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
81119448:	e0bffd04 	addi	r2,fp,-12
8111944c:	1009883a 	mov	r4,r2
81119450:	112065c0 	call	8112065c <atoi>
81119454:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
81119458:	e0bffc8f 	ldh	r2,-14(fp)
8111945c:	10800058 	cmpnei	r2,r2,1
81119460:	1000051e 	bne	r2,zero,81119478 <vLoadDefaultETHConf+0x5f8>
							xConfEth.bDHCP = TRUE;
81119464:	00a045b4 	movhi	r2,33046
81119468:	10976604 	addi	r2,r2,23960
8111946c:	00c00044 	movi	r3,1
81119470:	10c00615 	stw	r3,24(r2)
81119474:	00000306 	br	81119484 <vLoadDefaultETHConf+0x604>
						else
							xConfEth.bDHCP = FALSE;
81119478:	00a045b4 	movhi	r2,33046
8111947c:	10976604 	addi	r2,r2,23960
81119480:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81119484:	e0bffd04 	addi	r2,fp,-12
81119488:	e0bffa15 	stw	r2,-24(fp)

						break;
8111948c:	00008306 	br	8111969c <vLoadDefaultETHConf+0x81c>

					case 'S':

						ucParser = 0;
81119490:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119494:	e0bffc0f 	ldh	r2,-16(fp)
81119498:	1009883a 	mov	r4,r2
8111949c:	111dda00 	call	8111dda0 <cGetNextChar>
811194a0:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811194a4:	d0e00317 	ldw	r3,-32756(gp)
811194a8:	e0bff947 	ldb	r2,-27(fp)
811194ac:	10800044 	addi	r2,r2,1
811194b0:	1885883a 	add	r2,r3,r2
811194b4:	10800003 	ldbu	r2,0(r2)
811194b8:	10803fcc 	andi	r2,r2,255
811194bc:	1080010c 	andi	r2,r2,4
811194c0:	10000626 	beq	r2,zero,811194dc <vLoadDefaultETHConf+0x65c>
									(*p_inteiro) = c;
811194c4:	e0bffa17 	ldw	r2,-24(fp)
811194c8:	e0fff943 	ldbu	r3,-27(fp)
811194cc:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811194d0:	e0bffa17 	ldw	r2,-24(fp)
811194d4:	10800044 	addi	r2,r2,1
811194d8:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
811194dc:	e0bff947 	ldb	r2,-27(fp)
811194e0:	10800ba0 	cmpeqi	r2,r2,46
811194e4:	1000031e 	bne	r2,zero,811194f4 <vLoadDefaultETHConf+0x674>
811194e8:	e0bff947 	ldb	r2,-27(fp)
811194ec:	10800ed8 	cmpnei	r2,r2,59
811194f0:	103fe81e 	bne	r2,zero,81119494 <__reset+0xfb0f9494>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811194f4:	e0bffa17 	ldw	r2,-24(fp)
811194f8:	00c00284 	movi	r3,10
811194fc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = atoi( inteiro );
81119500:	e0bff903 	ldbu	r2,-28(fp)
81119504:	108000e8 	cmpgeui	r2,r2,3
81119508:	1000021e 	bne	r2,zero,81119514 <vLoadDefaultETHConf+0x694>
8111950c:	e43ff903 	ldbu	r16,-28(fp)
81119510:	00000106 	br	81119518 <vLoadDefaultETHConf+0x698>
81119514:	040000c4 	movi	r16,3
81119518:	e0bffd04 	addi	r2,fp,-12
8111951c:	1009883a 	mov	r4,r2
81119520:	112065c0 	call	8112065c <atoi>
81119524:	1007883a 	mov	r3,r2
81119528:	00a045b4 	movhi	r2,33046
8111952c:	10976604 	addi	r2,r2,23960
81119530:	1405883a 	add	r2,r2,r16
81119534:	10800204 	addi	r2,r2,8
81119538:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111953c:	e0bffd04 	addi	r2,fp,-12
81119540:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119544:	e0bff903 	ldbu	r2,-28(fp)
81119548:	10800044 	addi	r2,r2,1
8111954c:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119550:	e0bff947 	ldb	r2,-27(fp)
81119554:	10800ed8 	cmpnei	r2,r2,59
81119558:	103fce1e 	bne	r2,zero,81119494 <__reset+0xfb0f9494>

						break;
8111955c:	00004f06 	br	8111969c <vLoadDefaultETHConf+0x81c>
					case 'D':

						ucParser = 0;
81119560:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119564:	e0bffc0f 	ldh	r2,-16(fp)
81119568:	1009883a 	mov	r4,r2
8111956c:	111dda00 	call	8111dda0 <cGetNextChar>
81119570:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119574:	d0e00317 	ldw	r3,-32756(gp)
81119578:	e0bff947 	ldb	r2,-27(fp)
8111957c:	10800044 	addi	r2,r2,1
81119580:	1885883a 	add	r2,r3,r2
81119584:	10800003 	ldbu	r2,0(r2)
81119588:	10803fcc 	andi	r2,r2,255
8111958c:	1080010c 	andi	r2,r2,4
81119590:	10000626 	beq	r2,zero,811195ac <vLoadDefaultETHConf+0x72c>
									(*p_inteiro) = c;
81119594:	e0bffa17 	ldw	r2,-24(fp)
81119598:	e0fff943 	ldbu	r3,-27(fp)
8111959c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811195a0:	e0bffa17 	ldw	r2,-24(fp)
811195a4:	10800044 	addi	r2,r2,1
811195a8:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
811195ac:	e0bff947 	ldb	r2,-27(fp)
811195b0:	10800ba0 	cmpeqi	r2,r2,46
811195b4:	1000031e 	bne	r2,zero,811195c4 <vLoadDefaultETHConf+0x744>
811195b8:	e0bff947 	ldb	r2,-27(fp)
811195bc:	10800ed8 	cmpnei	r2,r2,59
811195c0:	103fe81e 	bne	r2,zero,81119564 <__reset+0xfb0f9564>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811195c4:	e0bffa17 	ldw	r2,-24(fp)
811195c8:	00c00284 	movi	r3,10
811195cc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = atoi( inteiro );
811195d0:	e0bff903 	ldbu	r2,-28(fp)
811195d4:	108000e8 	cmpgeui	r2,r2,3
811195d8:	1000021e 	bne	r2,zero,811195e4 <vLoadDefaultETHConf+0x764>
811195dc:	e43ff903 	ldbu	r16,-28(fp)
811195e0:	00000106 	br	811195e8 <vLoadDefaultETHConf+0x768>
811195e4:	040000c4 	movi	r16,3
811195e8:	e0bffd04 	addi	r2,fp,-12
811195ec:	1009883a 	mov	r4,r2
811195f0:	112065c0 	call	8112065c <atoi>
811195f4:	1007883a 	mov	r3,r2
811195f8:	00a045b4 	movhi	r2,33046
811195fc:	10976604 	addi	r2,r2,23960
81119600:	1405883a 	add	r2,r2,r16
81119604:	10800304 	addi	r2,r2,12
81119608:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111960c:	e0bffd04 	addi	r2,fp,-12
81119610:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119614:	e0bff903 	ldbu	r2,-28(fp)
81119618:	10800044 	addi	r2,r2,1
8111961c:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119620:	e0bff947 	ldb	r2,-27(fp)
81119624:	10800ed8 	cmpnei	r2,r2,59
81119628:	103fce1e 	bne	r2,zero,81119564 <__reset+0xfb0f9564>

						break;						
8111962c:	00001b06 	br	8111969c <vLoadDefaultETHConf+0x81c>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
81119630:	e0bffc0f 	ldh	r2,-16(fp)
81119634:	1009883a 	mov	r4,r2
81119638:	111dd600 	call	8111dd60 <siCloseFile>
8111963c:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
81119640:	e0bffb17 	ldw	r2,-20(fp)
81119644:	1000071e 	bne	r2,zero,81119664 <vLoadDefaultETHConf+0x7e4>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
81119648:	d0a06117 	ldw	r2,-32380(gp)
8111964c:	100f883a 	mov	r7,r2
81119650:	01800784 	movi	r6,30
81119654:	01400044 	movi	r5,1
81119658:	01204574 	movhi	r4,33045
8111965c:	2136f004 	addi	r4,r4,-9280
81119660:	1120e540 	call	81120e54 <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
81119664:	00800044 	movi	r2,1
81119668:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
8111966c:	00800044 	movi	r2,1
81119670:	e0bff715 	stw	r2,-36(fp)
						break;
81119674:	00000906 	br	8111969c <vLoadDefaultETHConf+0x81c>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
81119678:	d0a06117 	ldw	r2,-32380(gp)
8111967c:	100f883a 	mov	r7,r2
81119680:	01800844 	movi	r6,33
81119684:	01400044 	movi	r5,1
81119688:	01204574 	movhi	r4,33045
8111968c:	2136f804 	addi	r4,r4,-9248
81119690:	1120e540 	call	81120e54 <fwrite>
						#endif
						break;
81119694:	00000106 	br	8111969c <vLoadDefaultETHConf+0x81c>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
81119698:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
8111969c:	e0bff817 	ldw	r2,-32(fp)
811196a0:	103e1526 	beq	r2,zero,81118ef8 <__reset+0xfb0f8ef8>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
811196a4:	00000f06 	br	811196e4 <vLoadDefaultETHConf+0x864>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
811196a8:	d0a06117 	ldw	r2,-32380(gp)
811196ac:	100f883a 	mov	r7,r2
811196b0:	01800604 	movi	r6,24
811196b4:	01400044 	movi	r5,1
811196b8:	01204574 	movhi	r4,33045
811196bc:	21370104 	addi	r4,r4,-9212
811196c0:	1120e540 	call	81120e54 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
811196c4:	00000706 	br	811196e4 <vLoadDefaultETHConf+0x864>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
811196c8:	d0a06117 	ldw	r2,-32380(gp)
811196cc:	100f883a 	mov	r7,r2
811196d0:	018004c4 	movi	r6,19
811196d4:	01400044 	movi	r5,1
811196d8:	01204574 	movhi	r4,33045
811196dc:	21370804 	addi	r4,r4,-9184
811196e0:	1120e540 	call	81120e54 <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
811196e4:	e0bff717 	ldw	r2,-36(fp)
811196e8:	1000541e 	bne	r2,zero,8111983c <vLoadDefaultETHConf+0x9bc>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Ateno: Arquivo de conexo no foi encontrado. Carregando conf padrao\n");
811196ec:	01204574 	movhi	r4,33045
811196f0:	21370d04 	addi	r4,r4,-9164
811196f4:	1121e040 	call	81121e04 <puts>
		printf("No encontrou:'%s'.\n", ETH_FILE_NAME);
811196f8:	01604574 	movhi	r5,33045
811196fc:	2976e704 	addi	r5,r5,-9316
81119700:	01204574 	movhi	r4,33045
81119704:	21372104 	addi	r4,r4,-9084
81119708:	1121b800 	call	81121b80 <printf>


		xConfEth.siPortPUS = 17000;
8111970c:	00a045b4 	movhi	r2,33046
81119710:	10976604 	addi	r2,r2,23960
81119714:	00d09a04 	movi	r3,17000
81119718:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
8111971c:	00a045b4 	movhi	r2,33046
81119720:	10976604 	addi	r2,r2,23960
81119724:	00fff004 	movi	r3,-64
81119728:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
8111972c:	00a045b4 	movhi	r2,33046
81119730:	10976604 	addi	r2,r2,23960
81119734:	00ffea04 	movi	r3,-88
81119738:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
8111973c:	00a045b4 	movhi	r2,33046
81119740:	10976604 	addi	r2,r2,23960
81119744:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
81119748:	00a045b4 	movhi	r2,33046
8111974c:	10976604 	addi	r2,r2,23960
81119750:	00c00144 	movi	r3,5
81119754:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
81119758:	00a045b4 	movhi	r2,33046
8111975c:	10976604 	addi	r2,r2,23960
81119760:	00fff004 	movi	r3,-64
81119764:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
81119768:	00a045b4 	movhi	r2,33046
8111976c:	10976604 	addi	r2,r2,23960
81119770:	00ffea04 	movi	r3,-88
81119774:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
81119778:	00a045b4 	movhi	r2,33046
8111977c:	10976604 	addi	r2,r2,23960
81119780:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
81119784:	00a045b4 	movhi	r2,33046
81119788:	10976604 	addi	r2,r2,23960
8111978c:	00c00044 	movi	r3,1
81119790:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
81119794:	00a045b4 	movhi	r2,33046
81119798:	10976604 	addi	r2,r2,23960
8111979c:	00ffffc4 	movi	r3,-1
811197a0:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
811197a4:	00a045b4 	movhi	r2,33046
811197a8:	10976604 	addi	r2,r2,23960
811197ac:	00ffffc4 	movi	r3,-1
811197b0:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
811197b4:	00a045b4 	movhi	r2,33046
811197b8:	10976604 	addi	r2,r2,23960
811197bc:	00ffffc4 	movi	r3,-1
811197c0:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
811197c4:	00a045b4 	movhi	r2,33046
811197c8:	10976604 	addi	r2,r2,23960
811197cc:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
811197d0:	00a045b4 	movhi	r2,33046
811197d4:	10976604 	addi	r2,r2,23960
811197d8:	00ffff04 	movi	r3,-4
811197dc:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
811197e0:	00a045b4 	movhi	r2,33046
811197e4:	10976604 	addi	r2,r2,23960
811197e8:	00fffdc4 	movi	r3,-9
811197ec:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
811197f0:	00a045b4 	movhi	r2,33046
811197f4:	10976604 	addi	r2,r2,23960
811197f8:	00c018c4 	movi	r3,99
811197fc:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
81119800:	00a045b4 	movhi	r2,33046
81119804:	10976604 	addi	r2,r2,23960
81119808:	00c01344 	movi	r3,77
8111980c:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
81119810:	00a045b4 	movhi	r2,33046
81119814:	10976604 	addi	r2,r2,23960
81119818:	00c007c4 	movi	r3,31
8111981c:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
81119820:	00a045b4 	movhi	r2,33046
81119824:	10976604 	addi	r2,r2,23960
81119828:	00c01084 	movi	r3,66
8111982c:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
81119830:	00a045b4 	movhi	r2,33046
81119834:	10976604 	addi	r2,r2,23960
81119838:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
8111983c:	e0bff717 	ldw	r2,-36(fp)
}
81119840:	e6ffff04 	addi	sp,fp,-4
81119844:	dfc00217 	ldw	ra,8(sp)
81119848:	df000117 	ldw	fp,4(sp)
8111984c:	dc000017 	ldw	r16,0(sp)
81119850:	dec00304 	addi	sp,sp,12
81119854:	f800283a 	ret

81119858 <vShowEthConfig>:

#ifdef DEBUG_ON
	void vShowEthConfig( void ) {
81119858:	defff004 	addi	sp,sp,-64
8111985c:	de00012e 	bgeu	sp,et,81119864 <vShowEthConfig+0xc>
81119860:	003b68fa 	trap	3
81119864:	dfc00f15 	stw	ra,60(sp)
81119868:	df000e15 	stw	fp,56(sp)
8111986c:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
81119870:	d0a06117 	ldw	r2,-32380(gp)
81119874:	100f883a 	mov	r7,r2
81119878:	018007c4 	movi	r6,31
8111987c:	01400044 	movi	r5,1
81119880:	01204574 	movhi	r4,33045
81119884:	21372704 	addi	r4,r4,-9060
81119888:	1120e540 	call	81120e54 <fwrite>

		memset(buffer,0,40);
8111988c:	01800a04 	movi	r6,40
81119890:	000b883a 	mov	r5,zero
81119894:	e13ff604 	addi	r4,fp,-40
81119898:	11219b80 	call	811219b8 <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
8111989c:	00a045b4 	movhi	r2,33046
811198a0:	10976604 	addi	r2,r2,23960
811198a4:	10800403 	ldbu	r2,16(r2)
811198a8:	11803fcc 	andi	r6,r2,255
811198ac:	00a045b4 	movhi	r2,33046
811198b0:	10976604 	addi	r2,r2,23960
811198b4:	10800443 	ldbu	r2,17(r2)
811198b8:	11c03fcc 	andi	r7,r2,255
811198bc:	00a045b4 	movhi	r2,33046
811198c0:	10976604 	addi	r2,r2,23960
811198c4:	10800483 	ldbu	r2,18(r2)
811198c8:	10c03fcc 	andi	r3,r2,255
811198cc:	00a045b4 	movhi	r2,33046
811198d0:	10976604 	addi	r2,r2,23960
811198d4:	108004c3 	ldbu	r2,19(r2)
811198d8:	11003fcc 	andi	r4,r2,255
811198dc:	00a045b4 	movhi	r2,33046
811198e0:	10976604 	addi	r2,r2,23960
811198e4:	10800503 	ldbu	r2,20(r2)
811198e8:	11403fcc 	andi	r5,r2,255
811198ec:	00a045b4 	movhi	r2,33046
811198f0:	10976604 	addi	r2,r2,23960
811198f4:	10800543 	ldbu	r2,21(r2)
811198f8:	10803fcc 	andi	r2,r2,255
811198fc:	d8800315 	stw	r2,12(sp)
81119900:	d9400215 	stw	r5,8(sp)
81119904:	d9000115 	stw	r4,4(sp)
81119908:	d8c00015 	stw	r3,0(sp)
8111990c:	01604574 	movhi	r5,33045
81119910:	29772f04 	addi	r5,r5,-9028
81119914:	e13ff604 	addi	r4,fp,-40
81119918:	11221480 	call	81122148 <sprintf>
		debug(fp, buffer );
8111991c:	d0a06117 	ldw	r2,-32380(gp)
81119920:	e17ff604 	addi	r5,fp,-40
81119924:	1009883a 	mov	r4,r2
81119928:	11207b80 	call	811207b8 <fprintf>

		memset(buffer,0,40);
8111992c:	01800a04 	movi	r6,40
81119930:	000b883a 	mov	r5,zero
81119934:	e13ff604 	addi	r4,fp,-40
81119938:	11219b80 	call	811219b8 <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
8111993c:	00a045b4 	movhi	r2,33046
81119940:	10976604 	addi	r2,r2,23960
81119944:	10800003 	ldbu	r2,0(r2)
81119948:	11003fcc 	andi	r4,r2,255
8111994c:	00a045b4 	movhi	r2,33046
81119950:	10976604 	addi	r2,r2,23960
81119954:	10800043 	ldbu	r2,1(r2)
81119958:	11403fcc 	andi	r5,r2,255
8111995c:	00a045b4 	movhi	r2,33046
81119960:	10976604 	addi	r2,r2,23960
81119964:	10800083 	ldbu	r2,2(r2)
81119968:	10c03fcc 	andi	r3,r2,255
8111996c:	00a045b4 	movhi	r2,33046
81119970:	10976604 	addi	r2,r2,23960
81119974:	108000c3 	ldbu	r2,3(r2)
81119978:	10803fcc 	andi	r2,r2,255
8111997c:	d8800115 	stw	r2,4(sp)
81119980:	d8c00015 	stw	r3,0(sp)
81119984:	280f883a 	mov	r7,r5
81119988:	200d883a 	mov	r6,r4
8111998c:	01604574 	movhi	r5,33045
81119990:	29773804 	addi	r5,r5,-8992
81119994:	e13ff604 	addi	r4,fp,-40
81119998:	11221480 	call	81122148 <sprintf>
		debug(fp, buffer );
8111999c:	d0a06117 	ldw	r2,-32380(gp)
811199a0:	e17ff604 	addi	r5,fp,-40
811199a4:	1009883a 	mov	r4,r2
811199a8:	11207b80 	call	811207b8 <fprintf>

		memset(buffer,0,40);
811199ac:	01800a04 	movi	r6,40
811199b0:	000b883a 	mov	r5,zero
811199b4:	e13ff604 	addi	r4,fp,-40
811199b8:	11219b80 	call	811219b8 <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
811199bc:	00a045b4 	movhi	r2,33046
811199c0:	10976604 	addi	r2,r2,23960
811199c4:	10800103 	ldbu	r2,4(r2)
811199c8:	11003fcc 	andi	r4,r2,255
811199cc:	00a045b4 	movhi	r2,33046
811199d0:	10976604 	addi	r2,r2,23960
811199d4:	10800143 	ldbu	r2,5(r2)
811199d8:	11403fcc 	andi	r5,r2,255
811199dc:	00a045b4 	movhi	r2,33046
811199e0:	10976604 	addi	r2,r2,23960
811199e4:	10800183 	ldbu	r2,6(r2)
811199e8:	10c03fcc 	andi	r3,r2,255
811199ec:	00a045b4 	movhi	r2,33046
811199f0:	10976604 	addi	r2,r2,23960
811199f4:	108001c3 	ldbu	r2,7(r2)
811199f8:	10803fcc 	andi	r2,r2,255
811199fc:	d8800115 	stw	r2,4(sp)
81119a00:	d8c00015 	stw	r3,0(sp)
81119a04:	280f883a 	mov	r7,r5
81119a08:	200d883a 	mov	r6,r4
81119a0c:	01604574 	movhi	r5,33045
81119a10:	29773e04 	addi	r5,r5,-8968
81119a14:	e13ff604 	addi	r4,fp,-40
81119a18:	11221480 	call	81122148 <sprintf>
		debug(fp, buffer );
81119a1c:	d0a06117 	ldw	r2,-32380(gp)
81119a20:	e17ff604 	addi	r5,fp,-40
81119a24:	1009883a 	mov	r4,r2
81119a28:	11207b80 	call	811207b8 <fprintf>

		memset(buffer,0,40);
81119a2c:	01800a04 	movi	r6,40
81119a30:	000b883a 	mov	r5,zero
81119a34:	e13ff604 	addi	r4,fp,-40
81119a38:	11219b80 	call	811219b8 <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
81119a3c:	00a045b4 	movhi	r2,33046
81119a40:	10976604 	addi	r2,r2,23960
81119a44:	10800203 	ldbu	r2,8(r2)
81119a48:	11003fcc 	andi	r4,r2,255
81119a4c:	00a045b4 	movhi	r2,33046
81119a50:	10976604 	addi	r2,r2,23960
81119a54:	10800243 	ldbu	r2,9(r2)
81119a58:	11403fcc 	andi	r5,r2,255
81119a5c:	00a045b4 	movhi	r2,33046
81119a60:	10976604 	addi	r2,r2,23960
81119a64:	10800283 	ldbu	r2,10(r2)
81119a68:	10c03fcc 	andi	r3,r2,255
81119a6c:	00a045b4 	movhi	r2,33046
81119a70:	10976604 	addi	r2,r2,23960
81119a74:	108002c3 	ldbu	r2,11(r2)
81119a78:	10803fcc 	andi	r2,r2,255
81119a7c:	d8800115 	stw	r2,4(sp)
81119a80:	d8c00015 	stw	r3,0(sp)
81119a84:	280f883a 	mov	r7,r5
81119a88:	200d883a 	mov	r6,r4
81119a8c:	01604574 	movhi	r5,33045
81119a90:	29774504 	addi	r5,r5,-8940
81119a94:	e13ff604 	addi	r4,fp,-40
81119a98:	11221480 	call	81122148 <sprintf>
		debug(fp, buffer );
81119a9c:	d0a06117 	ldw	r2,-32380(gp)
81119aa0:	e17ff604 	addi	r5,fp,-40
81119aa4:	1009883a 	mov	r4,r2
81119aa8:	11207b80 	call	811207b8 <fprintf>

		memset(buffer,0,40);
81119aac:	01800a04 	movi	r6,40
81119ab0:	000b883a 	mov	r5,zero
81119ab4:	e13ff604 	addi	r4,fp,-40
81119ab8:	11219b80 	call	811219b8 <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
81119abc:	00a045b4 	movhi	r2,33046
81119ac0:	10976604 	addi	r2,r2,23960
81119ac4:	10800303 	ldbu	r2,12(r2)
81119ac8:	11003fcc 	andi	r4,r2,255
81119acc:	00a045b4 	movhi	r2,33046
81119ad0:	10976604 	addi	r2,r2,23960
81119ad4:	10800343 	ldbu	r2,13(r2)
81119ad8:	11403fcc 	andi	r5,r2,255
81119adc:	00a045b4 	movhi	r2,33046
81119ae0:	10976604 	addi	r2,r2,23960
81119ae4:	10800383 	ldbu	r2,14(r2)
81119ae8:	10c03fcc 	andi	r3,r2,255
81119aec:	00a045b4 	movhi	r2,33046
81119af0:	10976604 	addi	r2,r2,23960
81119af4:	108003c3 	ldbu	r2,15(r2)
81119af8:	10803fcc 	andi	r2,r2,255
81119afc:	d8800115 	stw	r2,4(sp)
81119b00:	d8c00015 	stw	r3,0(sp)
81119b04:	280f883a 	mov	r7,r5
81119b08:	200d883a 	mov	r6,r4
81119b0c:	01604574 	movhi	r5,33045
81119b10:	29774c04 	addi	r5,r5,-8912
81119b14:	e13ff604 	addi	r4,fp,-40
81119b18:	11221480 	call	81122148 <sprintf>
		debug(fp, buffer );
81119b1c:	d0a06117 	ldw	r2,-32380(gp)
81119b20:	e17ff604 	addi	r5,fp,-40
81119b24:	1009883a 	mov	r4,r2
81119b28:	11207b80 	call	811207b8 <fprintf>

		memset(buffer,0,40);
81119b2c:	01800a04 	movi	r6,40
81119b30:	000b883a 	mov	r5,zero
81119b34:	e13ff604 	addi	r4,fp,-40
81119b38:	11219b80 	call	811219b8 <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
81119b3c:	00a045b4 	movhi	r2,33046
81119b40:	10976604 	addi	r2,r2,23960
81119b44:	1080058b 	ldhu	r2,22(r2)
81119b48:	10bfffcc 	andi	r2,r2,65535
81119b4c:	100d883a 	mov	r6,r2
81119b50:	01604574 	movhi	r5,33045
81119b54:	29775304 	addi	r5,r5,-8884
81119b58:	e13ff604 	addi	r4,fp,-40
81119b5c:	11221480 	call	81122148 <sprintf>
		debug(fp, buffer );
81119b60:	d0a06117 	ldw	r2,-32380(gp)
81119b64:	e17ff604 	addi	r5,fp,-40
81119b68:	1009883a 	mov	r4,r2
81119b6c:	11207b80 	call	811207b8 <fprintf>

	}
81119b70:	0001883a 	nop
81119b74:	e037883a 	mov	sp,fp
81119b78:	dfc00117 	ldw	ra,4(sp)
81119b7c:	df000017 	ldw	fp,0(sp)
81119b80:	dec00204 	addi	sp,sp,8
81119b84:	f800283a 	ret

81119b88 <vLoadDebugConfs>:
#endif




bool vLoadDebugConfs( void ){
81119b88:	defff504 	addi	sp,sp,-44
81119b8c:	de00012e 	bgeu	sp,et,81119b94 <vLoadDebugConfs+0xc>
81119b90:	003b68fa 	trap	3
81119b94:	dfc00a15 	stw	ra,40(sp)
81119b98:	df000915 	stw	fp,36(sp)
81119b9c:	dc000815 	stw	r16,32(sp)
81119ba0:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
81119ba4:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
81119ba8:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
81119bac:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
81119bb0:	d0a07517 	ldw	r2,-32300(gp)
81119bb4:	10800058 	cmpnei	r2,r2,1
81119bb8:	1002fb1e 	bne	r2,zero,8111a7a8 <vLoadDebugConfs+0xc20>
81119bbc:	111dbcc0 	call	8111dbcc <bSDcardIsPresent>
81119bc0:	1002f926 	beq	r2,zero,8111a7a8 <vLoadDebugConfs+0xc20>
81119bc4:	111dbfc0 	call	8111dbfc <bSDcardFAT16Check>
81119bc8:	1002f726 	beq	r2,zero,8111a7a8 <vLoadDebugConfs+0xc20>

		siFile = siOpenFile( DEBUG_FILE_NAME );
81119bcc:	01204574 	movhi	r4,33045
81119bd0:	21375704 	addi	r4,r4,-8868
81119bd4:	111dd240 	call	8111dd24 <siOpenFile>
81119bd8:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
81119bdc:	e0bffc0f 	ldh	r2,-16(fp)
81119be0:	1002e916 	blt	r2,zero,8111a788 <vLoadDebugConfs+0xc00>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
81119be4:	e0bffd04 	addi	r2,fp,-12
81119be8:	01800204 	movi	r6,8
81119bec:	01400284 	movi	r5,10
81119bf0:	1009883a 	mov	r4,r2
81119bf4:	11219b80 	call	811219b8 <memset>
			p_inteiro = inteiro;
81119bf8:	e0bffd04 	addi	r2,fp,-12
81119bfc:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
81119c00:	e0bffc0f 	ldh	r2,-16(fp)
81119c04:	1009883a 	mov	r4,r2
81119c08:	111dda00 	call	8111dda0 <cGetNextChar>
81119c0c:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
81119c10:	e0bff947 	ldb	r2,-27(fp)
81119c14:	10800084 	addi	r2,r2,2
81119c18:	10c015e8 	cmpgeui	r3,r2,87
81119c1c:	1802ce1e 	bne	r3,zero,8111a758 <vLoadDebugConfs+0xbd0>
81119c20:	100690ba 	slli	r3,r2,2
81119c24:	00a044b4 	movhi	r2,33042
81119c28:	10a70e04 	addi	r2,r2,-25544
81119c2c:	1885883a 	add	r2,r3,r2
81119c30:	10800017 	ldw	r2,0(r2)
81119c34:	1000683a 	jmp	r2
81119c38:	81119dd4 	ori	r4,r16,18039
81119c3c:	81119dc8 	cmpgei	r4,r16,18039
81119c40:	8111a758 	cmpnei	r4,r16,18077
81119c44:	8111a758 	cmpnei	r4,r16,18077
81119c48:	8111a758 	cmpnei	r4,r16,18077
81119c4c:	8111a758 	cmpnei	r4,r16,18077
81119c50:	8111a758 	cmpnei	r4,r16,18077
81119c54:	8111a758 	cmpnei	r4,r16,18077
81119c58:	8111a758 	cmpnei	r4,r16,18077
81119c5c:	8111a758 	cmpnei	r4,r16,18077
81119c60:	8111a758 	cmpnei	r4,r16,18077
81119c64:	8111a758 	cmpnei	r4,r16,18077
81119c68:	8111a778 	rdprs	r4,r16,18077
81119c6c:	8111a758 	cmpnei	r4,r16,18077
81119c70:	8111a758 	cmpnei	r4,r16,18077
81119c74:	8111a778 	rdprs	r4,r16,18077
81119c78:	8111a758 	cmpnei	r4,r16,18077
81119c7c:	8111a758 	cmpnei	r4,r16,18077
81119c80:	8111a758 	cmpnei	r4,r16,18077
81119c84:	8111a758 	cmpnei	r4,r16,18077
81119c88:	8111a758 	cmpnei	r4,r16,18077
81119c8c:	8111a758 	cmpnei	r4,r16,18077
81119c90:	8111a758 	cmpnei	r4,r16,18077
81119c94:	8111a758 	cmpnei	r4,r16,18077
81119c98:	8111a758 	cmpnei	r4,r16,18077
81119c9c:	8111a758 	cmpnei	r4,r16,18077
81119ca0:	8111a758 	cmpnei	r4,r16,18077
81119ca4:	8111a758 	cmpnei	r4,r16,18077
81119ca8:	8111a758 	cmpnei	r4,r16,18077
81119cac:	8111a758 	cmpnei	r4,r16,18077
81119cb0:	8111a758 	cmpnei	r4,r16,18077
81119cb4:	8111a758 	cmpnei	r4,r16,18077
81119cb8:	8111a758 	cmpnei	r4,r16,18077
81119cbc:	8111a758 	cmpnei	r4,r16,18077
81119cc0:	8111a778 	rdprs	r4,r16,18077
81119cc4:	8111a758 	cmpnei	r4,r16,18077
81119cc8:	8111a758 	cmpnei	r4,r16,18077
81119ccc:	8111a758 	cmpnei	r4,r16,18077
81119cd0:	8111a758 	cmpnei	r4,r16,18077
81119cd4:	8111a758 	cmpnei	r4,r16,18077
81119cd8:	8111a758 	cmpnei	r4,r16,18077
81119cdc:	81119d94 	ori	r4,r16,18038
81119ce0:	8111a758 	cmpnei	r4,r16,18077
81119ce4:	8111a758 	cmpnei	r4,r16,18077
81119ce8:	8111a758 	cmpnei	r4,r16,18077
81119cec:	8111a758 	cmpnei	r4,r16,18077
81119cf0:	8111a758 	cmpnei	r4,r16,18077
81119cf4:	8111a758 	cmpnei	r4,r16,18077
81119cf8:	8111a758 	cmpnei	r4,r16,18077
81119cfc:	8111a758 	cmpnei	r4,r16,18077
81119d00:	8111a758 	cmpnei	r4,r16,18077
81119d04:	8111a758 	cmpnei	r4,r16,18077
81119d08:	8111a758 	cmpnei	r4,r16,18077
81119d0c:	8111a758 	cmpnei	r4,r16,18077
81119d10:	8111a758 	cmpnei	r4,r16,18077
81119d14:	8111a758 	cmpnei	r4,r16,18077
81119d18:	8111a758 	cmpnei	r4,r16,18077
81119d1c:	8111a758 	cmpnei	r4,r16,18077
81119d20:	8111a758 	cmpnei	r4,r16,18077
81119d24:	8111a758 	cmpnei	r4,r16,18077
81119d28:	8111a758 	cmpnei	r4,r16,18077
81119d2c:	8111a758 	cmpnei	r4,r16,18077
81119d30:	8111a710 	cmplti	r4,r16,18076
81119d34:	8111a758 	cmpnei	r4,r16,18077
81119d38:	8111a758 	cmpnei	r4,r16,18077
81119d3c:	8111a758 	cmpnei	r4,r16,18077
81119d40:	8111a758 	cmpnei	r4,r16,18077
81119d44:	8111a0bc 	xorhi	r4,r16,18050
81119d48:	8111a758 	cmpnei	r4,r16,18077
81119d4c:	8111a2cc 	andi	r4,r16,18059
81119d50:	8111a448 	cmpgei	r4,r16,18065
81119d54:	8111a758 	cmpnei	r4,r16,18077
81119d58:	8111a758 	cmpnei	r4,r16,18077
81119d5c:	8111a758 	cmpnei	r4,r16,18077
81119d60:	8111a37c 	xorhi	r4,r16,18061
81119d64:	8111a758 	cmpnei	r4,r16,18077
81119d68:	8111a5e0 	cmpeqi	r4,r16,18071
81119d6c:	8111a4d0 	cmplti	r4,r16,18067
81119d70:	8111a16c 	andhi	r4,r16,18053
81119d74:	8111a558 	cmpnei	r4,r16,18069
81119d78:	81119f5c 	xori	r4,r16,18045
81119d7c:	8111a21c 	xori	r4,r16,18056
81119d80:	81119eac 	andhi	r4,r16,18042
81119d84:	8111a758 	cmpnei	r4,r16,18077
81119d88:	8111a00c 	andi	r4,r16,18048
81119d8c:	81119dfc 	xorhi	r4,r16,18039
81119d90:	8111a668 	cmpgeui	r4,r16,18073
					case 39:// single quote '
						c = cGetNextChar(siFile);
81119d94:	e0bffc0f 	ldh	r2,-16(fp)
81119d98:	1009883a 	mov	r4,r2
81119d9c:	111dda00 	call	8111dda0 <cGetNextChar>
81119da0:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
81119da4:	00000406 	br	81119db8 <vLoadDebugConfs+0x230>
							c = cGetNextChar(siFile);
81119da8:	e0bffc0f 	ldh	r2,-16(fp)
81119dac:	1009883a 	mov	r4,r2
81119db0:	111dda00 	call	8111dda0 <cGetNextChar>
81119db4:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
81119db8:	e0bff947 	ldb	r2,-27(fp)
81119dbc:	108009d8 	cmpnei	r2,r2,39
81119dc0:	103ff91e 	bne	r2,zero,81119da8 <__reset+0xfb0f9da8>
							c = cGetNextChar(siFile);
						}
						break;
81119dc4:	00026d06 	br	8111a77c <vLoadDebugConfs+0xbf4>
					case -1: 	//EOF
						bEOF = TRUE;
81119dc8:	00800044 	movi	r2,1
81119dcc:	e0bff815 	stw	r2,-32(fp)
						break;
81119dd0:	00026a06 	br	8111a77c <vLoadDebugConfs+0xbf4>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
81119dd4:	d0a06117 	ldw	r2,-32380(gp)
81119dd8:	100f883a 	mov	r7,r2
81119ddc:	018006c4 	movi	r6,27
81119de0:	01400044 	movi	r5,1
81119de4:	01204574 	movhi	r4,33045
81119de8:	2136e904 	addi	r4,r4,-9308
81119dec:	1120e540 	call	81120e54 <fwrite>
						#endif
						bEOF = TRUE;
81119df0:	00800044 	movi	r2,1
81119df4:	e0bff815 	stw	r2,-32(fp)
						break;
81119df8:	00026006 	br	8111a77c <vLoadDebugConfs+0xbf4>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;

					case 'S':
						ucParser = 0;
81119dfc:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119e00:	e0bffc0f 	ldh	r2,-16(fp)
81119e04:	1009883a 	mov	r4,r2
81119e08:	111dda00 	call	8111dda0 <cGetNextChar>
81119e0c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119e10:	d0e00317 	ldw	r3,-32756(gp)
81119e14:	e0bff947 	ldb	r2,-27(fp)
81119e18:	10800044 	addi	r2,r2,1
81119e1c:	1885883a 	add	r2,r3,r2
81119e20:	10800003 	ldbu	r2,0(r2)
81119e24:	10803fcc 	andi	r2,r2,255
81119e28:	1080010c 	andi	r2,r2,4
81119e2c:	10000626 	beq	r2,zero,81119e48 <vLoadDebugConfs+0x2c0>
									(*p_inteiro) = c;
81119e30:	e0bffa17 	ldw	r2,-24(fp)
81119e34:	e0fff943 	ldbu	r3,-27(fp)
81119e38:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119e3c:	e0bffa17 	ldw	r2,-24(fp)
81119e40:	10800044 	addi	r2,r2,1
81119e44:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81119e48:	e0bff947 	ldb	r2,-27(fp)
81119e4c:	10800ba0 	cmpeqi	r2,r2,46
81119e50:	1000031e 	bne	r2,zero,81119e60 <vLoadDebugConfs+0x2d8>
81119e54:	e0bff947 	ldb	r2,-27(fp)
81119e58:	10800ed8 	cmpnei	r2,r2,59
81119e5c:	103fe81e 	bne	r2,zero,81119e00 <__reset+0xfb0f9e00>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119e60:	e0bffa17 	ldw	r2,-24(fp)
81119e64:	00c00284 	movi	r3,10
81119e68:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiSyncPeriod = atoi( inteiro );
81119e6c:	e0bffd04 	addi	r2,fp,-12
81119e70:	1009883a 	mov	r4,r2
81119e74:	112065c0 	call	8112065c <atoi>
81119e78:	1007883a 	mov	r3,r2
81119e7c:	00a045b4 	movhi	r2,33046
81119e80:	10975904 	addi	r2,r2,23908
81119e84:	10c0068d 	sth	r3,26(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119e88:	e0bffd04 	addi	r2,fp,-12
81119e8c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119e90:	e0bff903 	ldbu	r2,-28(fp)
81119e94:	10800044 	addi	r2,r2,1
81119e98:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119e9c:	e0bff947 	ldb	r2,-27(fp)
81119ea0:	10800ed8 	cmpnei	r2,r2,59
81119ea4:	103fd61e 	bne	r2,zero,81119e00 <__reset+0xfb0f9e00>

						break;
81119ea8:	00023406 	br	8111a77c <vLoadDebugConfs+0xbf4>
					case 'P':
						ucParser = 0;
81119eac:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119eb0:	e0bffc0f 	ldh	r2,-16(fp)
81119eb4:	1009883a 	mov	r4,r2
81119eb8:	111dda00 	call	8111dda0 <cGetNextChar>
81119ebc:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119ec0:	d0e00317 	ldw	r3,-32756(gp)
81119ec4:	e0bff947 	ldb	r2,-27(fp)
81119ec8:	10800044 	addi	r2,r2,1
81119ecc:	1885883a 	add	r2,r3,r2
81119ed0:	10800003 	ldbu	r2,0(r2)
81119ed4:	10803fcc 	andi	r2,r2,255
81119ed8:	1080010c 	andi	r2,r2,4
81119edc:	10000626 	beq	r2,zero,81119ef8 <vLoadDebugConfs+0x370>
									(*p_inteiro) = c;
81119ee0:	e0bffa17 	ldw	r2,-24(fp)
81119ee4:	e0fff943 	ldbu	r3,-27(fp)
81119ee8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119eec:	e0bffa17 	ldw	r2,-24(fp)
81119ef0:	10800044 	addi	r2,r2,1
81119ef4:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81119ef8:	e0bff947 	ldb	r2,-27(fp)
81119efc:	10800ba0 	cmpeqi	r2,r2,46
81119f00:	1000031e 	bne	r2,zero,81119f10 <vLoadDebugConfs+0x388>
81119f04:	e0bff947 	ldb	r2,-27(fp)
81119f08:	10800ed8 	cmpnei	r2,r2,59
81119f0c:	103fe81e 	bne	r2,zero,81119eb0 <__reset+0xfb0f9eb0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119f10:	e0bffa17 	ldw	r2,-24(fp)
81119f14:	00c00284 	movi	r3,10
81119f18:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiPreScanSerial = atoi( inteiro );
81119f1c:	e0bffd04 	addi	r2,fp,-12
81119f20:	1009883a 	mov	r4,r2
81119f24:	112065c0 	call	8112065c <atoi>
81119f28:	1007883a 	mov	r3,r2
81119f2c:	00a045b4 	movhi	r2,33046
81119f30:	10975904 	addi	r2,r2,23908
81119f34:	10c0048d 	sth	r3,18(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119f38:	e0bffd04 	addi	r2,fp,-12
81119f3c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119f40:	e0bff903 	ldbu	r2,-28(fp)
81119f44:	10800044 	addi	r2,r2,1
81119f48:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119f4c:	e0bff947 	ldb	r2,-27(fp)
81119f50:	10800ed8 	cmpnei	r2,r2,59
81119f54:	103fd61e 	bne	r2,zero,81119eb0 <__reset+0xfb0f9eb0>

						break;
81119f58:	00020806 	br	8111a77c <vLoadDebugConfs+0xbf4>
					case 'N':
						ucParser = 0;
81119f5c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81119f60:	e0bffc0f 	ldh	r2,-16(fp)
81119f64:	1009883a 	mov	r4,r2
81119f68:	111dda00 	call	8111dda0 <cGetNextChar>
81119f6c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81119f70:	d0e00317 	ldw	r3,-32756(gp)
81119f74:	e0bff947 	ldb	r2,-27(fp)
81119f78:	10800044 	addi	r2,r2,1
81119f7c:	1885883a 	add	r2,r3,r2
81119f80:	10800003 	ldbu	r2,0(r2)
81119f84:	10803fcc 	andi	r2,r2,255
81119f88:	1080010c 	andi	r2,r2,4
81119f8c:	10000626 	beq	r2,zero,81119fa8 <vLoadDebugConfs+0x420>
									(*p_inteiro) = c;
81119f90:	e0bffa17 	ldw	r2,-24(fp)
81119f94:	e0fff943 	ldbu	r3,-27(fp)
81119f98:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119f9c:	e0bffa17 	ldw	r2,-24(fp)
81119fa0:	10800044 	addi	r2,r2,1
81119fa4:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81119fa8:	e0bff947 	ldb	r2,-27(fp)
81119fac:	10800ba0 	cmpeqi	r2,r2,46
81119fb0:	1000031e 	bne	r2,zero,81119fc0 <vLoadDebugConfs+0x438>
81119fb4:	e0bff947 	ldb	r2,-27(fp)
81119fb8:	10800ed8 	cmpnei	r2,r2,59
81119fbc:	103fe81e 	bne	r2,zero,81119f60 <__reset+0xfb0f9f60>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119fc0:	e0bffa17 	ldw	r2,-24(fp)
81119fc4:	00c00284 	movi	r3,10
81119fc8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOverScanSerial = atoi( inteiro );
81119fcc:	e0bffd04 	addi	r2,fp,-12
81119fd0:	1009883a 	mov	r4,r2
81119fd4:	112065c0 	call	8112065c <atoi>
81119fd8:	1007883a 	mov	r3,r2
81119fdc:	00a045b4 	movhi	r2,33046
81119fe0:	10975904 	addi	r2,r2,23908
81119fe4:	10c0040d 	sth	r3,16(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119fe8:	e0bffd04 	addi	r2,fp,-12
81119fec:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81119ff0:	e0bff903 	ldbu	r2,-28(fp)
81119ff4:	10800044 	addi	r2,r2,1
81119ff8:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119ffc:	e0bff947 	ldb	r2,-27(fp)
8111a000:	10800ed8 	cmpnei	r2,r2,59
8111a004:	103fd61e 	bne	r2,zero,81119f60 <__reset+0xfb0f9f60>

						break;
8111a008:	0001dc06 	br	8111a77c <vLoadDebugConfs+0xbf4>
					case 'R':
						ucParser = 0;
8111a00c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a010:	e0bffc0f 	ldh	r2,-16(fp)
8111a014:	1009883a 	mov	r4,r2
8111a018:	111dda00 	call	8111dda0 <cGetNextChar>
8111a01c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111a020:	d0e00317 	ldw	r3,-32756(gp)
8111a024:	e0bff947 	ldb	r2,-27(fp)
8111a028:	10800044 	addi	r2,r2,1
8111a02c:	1885883a 	add	r2,r3,r2
8111a030:	10800003 	ldbu	r2,0(r2)
8111a034:	10803fcc 	andi	r2,r2,255
8111a038:	1080010c 	andi	r2,r2,4
8111a03c:	10000626 	beq	r2,zero,8111a058 <vLoadDebugConfs+0x4d0>
									(*p_inteiro) = c;
8111a040:	e0bffa17 	ldw	r2,-24(fp)
8111a044:	e0fff943 	ldbu	r3,-27(fp)
8111a048:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a04c:	e0bffa17 	ldw	r2,-24(fp)
8111a050:	10800044 	addi	r2,r2,1
8111a054:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a058:	e0bff947 	ldb	r2,-27(fp)
8111a05c:	10800ba0 	cmpeqi	r2,r2,46
8111a060:	1000031e 	bne	r2,zero,8111a070 <vLoadDebugConfs+0x4e8>
8111a064:	e0bff947 	ldb	r2,-27(fp)
8111a068:	10800ed8 	cmpnei	r2,r2,59
8111a06c:	103fe81e 	bne	r2,zero,8111a010 <__reset+0xfb0fa010>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a070:	e0bffa17 	ldw	r2,-24(fp)
8111a074:	00c00284 	movi	r3,10
8111a078:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucRmapKey = atoi( inteiro );
8111a07c:	e0bffd04 	addi	r2,fp,-12
8111a080:	1009883a 	mov	r4,r2
8111a084:	112065c0 	call	8112065c <atoi>
8111a088:	1007883a 	mov	r3,r2
8111a08c:	00a045b4 	movhi	r2,33046
8111a090:	10975904 	addi	r2,r2,23908
8111a094:	10c00c0d 	sth	r3,48(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a098:	e0bffd04 	addi	r2,fp,-12
8111a09c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111a0a0:	e0bff903 	ldbu	r2,-28(fp)
8111a0a4:	10800044 	addi	r2,r2,1
8111a0a8:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111a0ac:	e0bff947 	ldb	r2,-27(fp)
8111a0b0:	10800ed8 	cmpnei	r2,r2,59
8111a0b4:	103fd61e 	bne	r2,zero,8111a010 <__reset+0xfb0fa010>

						break;
8111a0b8:	0001b006 	br	8111a77c <vLoadDebugConfs+0xbf4>
					case 'A':
						ucParser = 0;
8111a0bc:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a0c0:	e0bffc0f 	ldh	r2,-16(fp)
8111a0c4:	1009883a 	mov	r4,r2
8111a0c8:	111dda00 	call	8111dda0 <cGetNextChar>
8111a0cc:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111a0d0:	d0e00317 	ldw	r3,-32756(gp)
8111a0d4:	e0bff947 	ldb	r2,-27(fp)
8111a0d8:	10800044 	addi	r2,r2,1
8111a0dc:	1885883a 	add	r2,r3,r2
8111a0e0:	10800003 	ldbu	r2,0(r2)
8111a0e4:	10803fcc 	andi	r2,r2,255
8111a0e8:	1080010c 	andi	r2,r2,4
8111a0ec:	10000626 	beq	r2,zero,8111a108 <vLoadDebugConfs+0x580>
									(*p_inteiro) = c;
8111a0f0:	e0bffa17 	ldw	r2,-24(fp)
8111a0f4:	e0fff943 	ldbu	r3,-27(fp)
8111a0f8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a0fc:	e0bffa17 	ldw	r2,-24(fp)
8111a100:	10800044 	addi	r2,r2,1
8111a104:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a108:	e0bff947 	ldb	r2,-27(fp)
8111a10c:	10800ba0 	cmpeqi	r2,r2,46
8111a110:	1000031e 	bne	r2,zero,8111a120 <vLoadDebugConfs+0x598>
8111a114:	e0bff947 	ldb	r2,-27(fp)
8111a118:	10800ed8 	cmpnei	r2,r2,59
8111a11c:	103fe81e 	bne	r2,zero,8111a0c0 <__reset+0xfb0fa0c0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a120:	e0bffa17 	ldw	r2,-24(fp)
8111a124:	00c00284 	movi	r3,10
8111a128:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucLogicalAddr = atoi( inteiro );
8111a12c:	e0bffd04 	addi	r2,fp,-12
8111a130:	1009883a 	mov	r4,r2
8111a134:	112065c0 	call	8112065c <atoi>
8111a138:	1007883a 	mov	r3,r2
8111a13c:	00a045b4 	movhi	r2,33046
8111a140:	10975904 	addi	r2,r2,23908
8111a144:	10c00c8d 	sth	r3,50(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a148:	e0bffd04 	addi	r2,fp,-12
8111a14c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111a150:	e0bff903 	ldbu	r2,-28(fp)
8111a154:	10800044 	addi	r2,r2,1
8111a158:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111a15c:	e0bff947 	ldb	r2,-27(fp)
8111a160:	10800ed8 	cmpnei	r2,r2,59
8111a164:	103fd61e 	bne	r2,zero,8111a0c0 <__reset+0xfb0fa0c0>

						break;
8111a168:	00018406 	br	8111a77c <vLoadDebugConfs+0xbf4>
					case 'L':
						ucParser = 0;
8111a16c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a170:	e0bffc0f 	ldh	r2,-16(fp)
8111a174:	1009883a 	mov	r4,r2
8111a178:	111dda00 	call	8111dda0 <cGetNextChar>
8111a17c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111a180:	d0e00317 	ldw	r3,-32756(gp)
8111a184:	e0bff947 	ldb	r2,-27(fp)
8111a188:	10800044 	addi	r2,r2,1
8111a18c:	1885883a 	add	r2,r3,r2
8111a190:	10800003 	ldbu	r2,0(r2)
8111a194:	10803fcc 	andi	r2,r2,255
8111a198:	1080010c 	andi	r2,r2,4
8111a19c:	10000626 	beq	r2,zero,8111a1b8 <vLoadDebugConfs+0x630>
									(*p_inteiro) = c;
8111a1a0:	e0bffa17 	ldw	r2,-24(fp)
8111a1a4:	e0fff943 	ldbu	r3,-27(fp)
8111a1a8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a1ac:	e0bffa17 	ldw	r2,-24(fp)
8111a1b0:	10800044 	addi	r2,r2,1
8111a1b4:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a1b8:	e0bff947 	ldb	r2,-27(fp)
8111a1bc:	10800ba0 	cmpeqi	r2,r2,46
8111a1c0:	1000031e 	bne	r2,zero,8111a1d0 <vLoadDebugConfs+0x648>
8111a1c4:	e0bff947 	ldb	r2,-27(fp)
8111a1c8:	10800ed8 	cmpnei	r2,r2,59
8111a1cc:	103fe81e 	bne	r2,zero,8111a170 <__reset+0xfb0fa170>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a1d0:	e0bffa17 	ldw	r2,-24(fp)
8111a1d4:	00c00284 	movi	r3,10
8111a1d8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiRows = atoi( inteiro );
8111a1dc:	e0bffd04 	addi	r2,fp,-12
8111a1e0:	1009883a 	mov	r4,r2
8111a1e4:	112065c0 	call	8112065c <atoi>
8111a1e8:	1007883a 	mov	r3,r2
8111a1ec:	00a045b4 	movhi	r2,33046
8111a1f0:	10975904 	addi	r2,r2,23908
8111a1f4:	10c0060d 	sth	r3,24(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a1f8:	e0bffd04 	addi	r2,fp,-12
8111a1fc:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111a200:	e0bff903 	ldbu	r2,-28(fp)
8111a204:	10800044 	addi	r2,r2,1
8111a208:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111a20c:	e0bff947 	ldb	r2,-27(fp)
8111a210:	10800ed8 	cmpnei	r2,r2,59
8111a214:	103fd61e 	bne	r2,zero,8111a170 <__reset+0xfb0fa170>

						break;
8111a218:	00015806 	br	8111a77c <vLoadDebugConfs+0xbf4>

					case 'O':
						ucParser = 0;
8111a21c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a220:	e0bffc0f 	ldh	r2,-16(fp)
8111a224:	1009883a 	mov	r4,r2
8111a228:	111dda00 	call	8111dda0 <cGetNextChar>
8111a22c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111a230:	d0e00317 	ldw	r3,-32756(gp)
8111a234:	e0bff947 	ldb	r2,-27(fp)
8111a238:	10800044 	addi	r2,r2,1
8111a23c:	1885883a 	add	r2,r3,r2
8111a240:	10800003 	ldbu	r2,0(r2)
8111a244:	10803fcc 	andi	r2,r2,255
8111a248:	1080010c 	andi	r2,r2,4
8111a24c:	10000626 	beq	r2,zero,8111a268 <vLoadDebugConfs+0x6e0>
									(*p_inteiro) = c;
8111a250:	e0bffa17 	ldw	r2,-24(fp)
8111a254:	e0fff943 	ldbu	r3,-27(fp)
8111a258:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a25c:	e0bffa17 	ldw	r2,-24(fp)
8111a260:	10800044 	addi	r2,r2,1
8111a264:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a268:	e0bff947 	ldb	r2,-27(fp)
8111a26c:	10800ba0 	cmpeqi	r2,r2,46
8111a270:	1000031e 	bne	r2,zero,8111a280 <vLoadDebugConfs+0x6f8>
8111a274:	e0bff947 	ldb	r2,-27(fp)
8111a278:	10800ed8 	cmpnei	r2,r2,59
8111a27c:	103fe81e 	bne	r2,zero,8111a220 <__reset+0xfb0fa220>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a280:	e0bffa17 	ldw	r2,-24(fp)
8111a284:	00c00284 	movi	r3,10
8111a288:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOLN = atoi( inteiro );
8111a28c:	e0bffd04 	addi	r2,fp,-12
8111a290:	1009883a 	mov	r4,r2
8111a294:	112065c0 	call	8112065c <atoi>
8111a298:	1007883a 	mov	r3,r2
8111a29c:	00a045b4 	movhi	r2,33046
8111a2a0:	10975904 	addi	r2,r2,23908
8111a2a4:	10c0050d 	sth	r3,20(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a2a8:	e0bffd04 	addi	r2,fp,-12
8111a2ac:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111a2b0:	e0bff903 	ldbu	r2,-28(fp)
8111a2b4:	10800044 	addi	r2,r2,1
8111a2b8:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111a2bc:	e0bff947 	ldb	r2,-27(fp)
8111a2c0:	10800ed8 	cmpnei	r2,r2,59
8111a2c4:	103fd61e 	bne	r2,zero,8111a220 <__reset+0xfb0fa220>

						break;
8111a2c8:	00012c06 	br	8111a77c <vLoadDebugConfs+0xbf4>
					case 'C':
						ucParser = 0;
8111a2cc:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a2d0:	e0bffc0f 	ldh	r2,-16(fp)
8111a2d4:	1009883a 	mov	r4,r2
8111a2d8:	111dda00 	call	8111dda0 <cGetNextChar>
8111a2dc:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111a2e0:	d0e00317 	ldw	r3,-32756(gp)
8111a2e4:	e0bff947 	ldb	r2,-27(fp)
8111a2e8:	10800044 	addi	r2,r2,1
8111a2ec:	1885883a 	add	r2,r3,r2
8111a2f0:	10800003 	ldbu	r2,0(r2)
8111a2f4:	10803fcc 	andi	r2,r2,255
8111a2f8:	1080010c 	andi	r2,r2,4
8111a2fc:	10000626 	beq	r2,zero,8111a318 <vLoadDebugConfs+0x790>
									(*p_inteiro) = c;
8111a300:	e0bffa17 	ldw	r2,-24(fp)
8111a304:	e0fff943 	ldbu	r3,-27(fp)
8111a308:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a30c:	e0bffa17 	ldw	r2,-24(fp)
8111a310:	10800044 	addi	r2,r2,1
8111a314:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a318:	e0bff947 	ldb	r2,-27(fp)
8111a31c:	10800ba0 	cmpeqi	r2,r2,46
8111a320:	1000031e 	bne	r2,zero,8111a330 <vLoadDebugConfs+0x7a8>
8111a324:	e0bff947 	ldb	r2,-27(fp)
8111a328:	10800ed8 	cmpnei	r2,r2,59
8111a32c:	103fe81e 	bne	r2,zero,8111a2d0 <__reset+0xfb0fa2d0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a330:	e0bffa17 	ldw	r2,-24(fp)
8111a334:	00c00284 	movi	r3,10
8111a338:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiCols = atoi( inteiro );
8111a33c:	e0bffd04 	addi	r2,fp,-12
8111a340:	1009883a 	mov	r4,r2
8111a344:	112065c0 	call	8112065c <atoi>
8111a348:	1007883a 	mov	r3,r2
8111a34c:	00a045b4 	movhi	r2,33046
8111a350:	10975904 	addi	r2,r2,23908
8111a354:	10c0058d 	sth	r3,22(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a358:	e0bffd04 	addi	r2,fp,-12
8111a35c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111a360:	e0bff903 	ldbu	r2,-28(fp)
8111a364:	10800044 	addi	r2,r2,1
8111a368:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111a36c:	e0bff947 	ldb	r2,-27(fp)
8111a370:	10800ed8 	cmpnei	r2,r2,59
8111a374:	103fd61e 	bne	r2,zero,8111a2d0 <__reset+0xfb0fa2d0>

						break;
8111a378:	00010006 	br	8111a77c <vLoadDebugConfs+0xbf4>
					case 'H':

						ucParser = 0;
8111a37c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111a380:	e0bffc0f 	ldh	r2,-16(fp)
8111a384:	1009883a 	mov	r4,r2
8111a388:	111dda00 	call	8111dda0 <cGetNextChar>
8111a38c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111a390:	d0e00317 	ldw	r3,-32756(gp)
8111a394:	e0bff947 	ldb	r2,-27(fp)
8111a398:	10800044 	addi	r2,r2,1
8111a39c:	1885883a 	add	r2,r3,r2
8111a3a0:	10800003 	ldbu	r2,0(r2)
8111a3a4:	10803fcc 	andi	r2,r2,255
8111a3a8:	1080010c 	andi	r2,r2,4
8111a3ac:	10000626 	beq	r2,zero,8111a3c8 <vLoadDebugConfs+0x840>
									(*p_inteiro) = c;
8111a3b0:	e0bffa17 	ldw	r2,-24(fp)
8111a3b4:	e0fff943 	ldbu	r3,-27(fp)
8111a3b8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111a3bc:	e0bffa17 	ldw	r2,-24(fp)
8111a3c0:	10800044 	addi	r2,r2,1
8111a3c4:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111a3c8:	e0bff947 	ldb	r2,-27(fp)
8111a3cc:	10800ba0 	cmpeqi	r2,r2,46
8111a3d0:	1000031e 	bne	r2,zero,8111a3e0 <vLoadDebugConfs+0x858>
8111a3d4:	e0bff947 	ldb	r2,-27(fp)
8111a3d8:	10800ed8 	cmpnei	r2,r2,59
8111a3dc:	103fe81e 	bne	r2,zero,8111a380 <__reset+0xfb0fa380>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a3e0:	e0bffa17 	ldw	r2,-24(fp)
8111a3e4:	00c00284 	movi	r3,10
8111a3e8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.HK[min_sim(ucParser,15)] = atoi( inteiro );
8111a3ec:	e0bff903 	ldbu	r2,-28(fp)
8111a3f0:	108003e8 	cmpgeui	r2,r2,15
8111a3f4:	1000021e 	bne	r2,zero,8111a400 <vLoadDebugConfs+0x878>
8111a3f8:	e43ff903 	ldbu	r16,-28(fp)
8111a3fc:	00000106 	br	8111a404 <vLoadDebugConfs+0x87c>
8111a400:	040003c4 	movi	r16,15
8111a404:	e0bffd04 	addi	r2,fp,-12
8111a408:	1009883a 	mov	r4,r2
8111a40c:	112065c0 	call	8112065c <atoi>
8111a410:	1007883a 	mov	r3,r2
8111a414:	00a045b4 	movhi	r2,33046
8111a418:	10975904 	addi	r2,r2,23908
8111a41c:	1405883a 	add	r2,r2,r16
8111a420:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
8111a424:	e0bffd04 	addi	r2,fp,-12
8111a428:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111a42c:	e0bff903 	ldbu	r2,-28(fp)
8111a430:	10800044 	addi	r2,r2,1
8111a434:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111a438:	e0bff947 	ldb	r2,-27(fp)
8111a43c:	10800ed8 	cmpnei	r2,r2,59
8111a440:	103fcf1e 	bne	r2,zero,8111a380 <__reset+0xfb0fa380>

						break;
8111a444:	0000cd06 	br	8111a77c <vLoadDebugConfs+0xbf4>
					case 'D':

						do {
							c = cGetNextChar(siFile);
8111a448:	e0bffc0f 	ldh	r2,-16(fp)
8111a44c:	1009883a 	mov	r4,r2
8111a450:	111dda00 	call	8111dda0 <cGetNextChar>
8111a454:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111a458:	d0e00317 	ldw	r3,-32756(gp)
8111a45c:	e0bff947 	ldb	r2,-27(fp)
8111a460:	10800044 	addi	r2,r2,1
8111a464:	1885883a 	add	r2,r3,r2
8111a468:	10800003 	ldbu	r2,0(r2)
8111a46c:	10803fcc 	andi	r2,r2,255
8111a470:	1080010c 	andi	r2,r2,4
8111a474:	10000626 	beq	r2,zero,8111a490 <vLoadDebugConfs+0x908>
								(*p_inteiro) = c;
8111a478:	e0bffa17 	ldw	r2,-24(fp)
8111a47c:	e0fff943 	ldbu	r3,-27(fp)
8111a480:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111a484:	e0bffa17 	ldw	r2,-24(fp)
8111a488:	10800044 	addi	r2,r2,1
8111a48c:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111a490:	e0bff947 	ldb	r2,-27(fp)
8111a494:	10800ed8 	cmpnei	r2,r2,59
8111a498:	103feb1e 	bne	r2,zero,8111a448 <__reset+0xfb0fa448>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a49c:	e0bffa17 	ldw	r2,-24(fp)
8111a4a0:	00c00284 	movi	r3,10
8111a4a4:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDelay = atoi( inteiro );
8111a4a8:	e0bffd04 	addi	r2,fp,-12
8111a4ac:	1009883a 	mov	r4,r2
8111a4b0:	112065c0 	call	8112065c <atoi>
8111a4b4:	1007883a 	mov	r3,r2
8111a4b8:	00a045b4 	movhi	r2,33046
8111a4bc:	10975904 	addi	r2,r2,23908
8111a4c0:	10c0070d 	sth	r3,28(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111a4c4:	e0bffd04 	addi	r2,fp,-12
8111a4c8:	e0bffa15 	stw	r2,-24(fp)

						break;
8111a4cc:	0000ab06 	br	8111a77c <vLoadDebugConfs+0xbf4>
					case 'K':

						do {
							c = cGetNextChar(siFile);
8111a4d0:	e0bffc0f 	ldh	r2,-16(fp)
8111a4d4:	1009883a 	mov	r4,r2
8111a4d8:	111dda00 	call	8111dda0 <cGetNextChar>
8111a4dc:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111a4e0:	d0e00317 	ldw	r3,-32756(gp)
8111a4e4:	e0bff947 	ldb	r2,-27(fp)
8111a4e8:	10800044 	addi	r2,r2,1
8111a4ec:	1885883a 	add	r2,r3,r2
8111a4f0:	10800003 	ldbu	r2,0(r2)
8111a4f4:	10803fcc 	andi	r2,r2,255
8111a4f8:	1080010c 	andi	r2,r2,4
8111a4fc:	10000626 	beq	r2,zero,8111a518 <vLoadDebugConfs+0x990>
								(*p_inteiro) = c;
8111a500:	e0bffa17 	ldw	r2,-24(fp)
8111a504:	e0fff943 	ldbu	r3,-27(fp)
8111a508:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111a50c:	e0bffa17 	ldw	r2,-24(fp)
8111a510:	10800044 	addi	r2,r2,1
8111a514:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111a518:	e0bff947 	ldb	r2,-27(fp)
8111a51c:	10800ed8 	cmpnei	r2,r2,59
8111a520:	103feb1e 	bne	r2,zero,8111a4d0 <__reset+0xfb0fa4d0>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a524:	e0bffa17 	ldw	r2,-24(fp)
8111a528:	00c00284 	movi	r3,10
8111a52c:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulColDelay = atoi( inteiro );
8111a530:	e0bffd04 	addi	r2,fp,-12
8111a534:	1009883a 	mov	r4,r2
8111a538:	112065c0 	call	8112065c <atoi>
8111a53c:	1007883a 	mov	r3,r2
8111a540:	00a045b4 	movhi	r2,33046
8111a544:	10975904 	addi	r2,r2,23908
8111a548:	10c00a15 	stw	r3,40(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111a54c:	e0bffd04 	addi	r2,fp,-12
8111a550:	e0bffa15 	stw	r2,-24(fp)

						break;
8111a554:	00008906 	br	8111a77c <vLoadDebugConfs+0xbf4>
					case 'M':

						do {
							c = cGetNextChar(siFile);
8111a558:	e0bffc0f 	ldh	r2,-16(fp)
8111a55c:	1009883a 	mov	r4,r2
8111a560:	111dda00 	call	8111dda0 <cGetNextChar>
8111a564:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111a568:	d0e00317 	ldw	r3,-32756(gp)
8111a56c:	e0bff947 	ldb	r2,-27(fp)
8111a570:	10800044 	addi	r2,r2,1
8111a574:	1885883a 	add	r2,r3,r2
8111a578:	10800003 	ldbu	r2,0(r2)
8111a57c:	10803fcc 	andi	r2,r2,255
8111a580:	1080010c 	andi	r2,r2,4
8111a584:	10000626 	beq	r2,zero,8111a5a0 <vLoadDebugConfs+0xa18>
								(*p_inteiro) = c;
8111a588:	e0bffa17 	ldw	r2,-24(fp)
8111a58c:	e0fff943 	ldbu	r3,-27(fp)
8111a590:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111a594:	e0bffa17 	ldw	r2,-24(fp)
8111a598:	10800044 	addi	r2,r2,1
8111a59c:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111a5a0:	e0bff947 	ldb	r2,-27(fp)
8111a5a4:	10800ed8 	cmpnei	r2,r2,59
8111a5a8:	103feb1e 	bne	r2,zero,8111a558 <__reset+0xfb0fa558>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a5ac:	e0bffa17 	ldw	r2,-24(fp)
8111a5b0:	00c00284 	movi	r3,10
8111a5b4:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulADCPixelDelay = atoi( inteiro );
8111a5b8:	e0bffd04 	addi	r2,fp,-12
8111a5bc:	1009883a 	mov	r4,r2
8111a5c0:	112065c0 	call	8112065c <atoi>
8111a5c4:	1007883a 	mov	r3,r2
8111a5c8:	00a045b4 	movhi	r2,33046
8111a5cc:	10975904 	addi	r2,r2,23908
8111a5d0:	10c00b15 	stw	r3,44(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111a5d4:	e0bffd04 	addi	r2,fp,-12
8111a5d8:	e0bffa15 	stw	r2,-24(fp)

						break;
8111a5dc:	00006706 	br	8111a77c <vLoadDebugConfs+0xbf4>
					case 'J':

						do {
							c = cGetNextChar(siFile);
8111a5e0:	e0bffc0f 	ldh	r2,-16(fp)
8111a5e4:	1009883a 	mov	r4,r2
8111a5e8:	111dda00 	call	8111dda0 <cGetNextChar>
8111a5ec:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111a5f0:	d0e00317 	ldw	r3,-32756(gp)
8111a5f4:	e0bff947 	ldb	r2,-27(fp)
8111a5f8:	10800044 	addi	r2,r2,1
8111a5fc:	1885883a 	add	r2,r3,r2
8111a600:	10800003 	ldbu	r2,0(r2)
8111a604:	10803fcc 	andi	r2,r2,255
8111a608:	1080010c 	andi	r2,r2,4
8111a60c:	10000626 	beq	r2,zero,8111a628 <vLoadDebugConfs+0xaa0>
								(*p_inteiro) = c;
8111a610:	e0bffa17 	ldw	r2,-24(fp)
8111a614:	e0fff943 	ldbu	r3,-27(fp)
8111a618:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111a61c:	e0bffa17 	ldw	r2,-24(fp)
8111a620:	10800044 	addi	r2,r2,1
8111a624:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111a628:	e0bff947 	ldb	r2,-27(fp)
8111a62c:	10800ed8 	cmpnei	r2,r2,59
8111a630:	103feb1e 	bne	r2,zero,8111a5e0 <__reset+0xfb0fa5e0>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a634:	e0bffa17 	ldw	r2,-24(fp)
8111a638:	00c00284 	movi	r3,10
8111a63c:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulLineDelay = atoi( inteiro );
8111a640:	e0bffd04 	addi	r2,fp,-12
8111a644:	1009883a 	mov	r4,r2
8111a648:	112065c0 	call	8112065c <atoi>
8111a64c:	1007883a 	mov	r3,r2
8111a650:	00a045b4 	movhi	r2,33046
8111a654:	10975904 	addi	r2,r2,23908
8111a658:	10c00915 	stw	r3,36(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111a65c:	e0bffd04 	addi	r2,fp,-12
8111a660:	e0bffa15 	stw	r2,-24(fp)

						break;
8111a664:	00004506 	br	8111a77c <vLoadDebugConfs+0xbf4>
					case 'T':

						do {
							c = cGetNextChar(siFile);
8111a668:	e0bffc0f 	ldh	r2,-16(fp)
8111a66c:	1009883a 	mov	r4,r2
8111a670:	111dda00 	call	8111dda0 <cGetNextChar>
8111a674:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111a678:	d0e00317 	ldw	r3,-32756(gp)
8111a67c:	e0bff947 	ldb	r2,-27(fp)
8111a680:	10800044 	addi	r2,r2,1
8111a684:	1885883a 	add	r2,r3,r2
8111a688:	10800003 	ldbu	r2,0(r2)
8111a68c:	10803fcc 	andi	r2,r2,255
8111a690:	1080010c 	andi	r2,r2,4
8111a694:	10000626 	beq	r2,zero,8111a6b0 <vLoadDebugConfs+0xb28>
								(*p_inteiro) = c;
8111a698:	e0bffa17 	ldw	r2,-24(fp)
8111a69c:	e0fff943 	ldbu	r3,-27(fp)
8111a6a0:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111a6a4:	e0bffa17 	ldw	r2,-24(fp)
8111a6a8:	10800044 	addi	r2,r2,1
8111a6ac:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111a6b0:	e0bff947 	ldb	r2,-27(fp)
8111a6b4:	10800ed8 	cmpnei	r2,r2,59
8111a6b8:	103feb1e 	bne	r2,zero,8111a668 <__reset+0xfb0fa668>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111a6bc:	e0bffa17 	ldw	r2,-24(fp)
8111a6c0:	00c00284 	movi	r3,10
8111a6c4:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111a6c8:	e0bffd04 	addi	r2,fp,-12
8111a6cc:	1009883a 	mov	r4,r2
8111a6d0:	112065c0 	call	8112065c <atoi>
8111a6d4:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
8111a6d8:	e0bffc8f 	ldh	r2,-14(fp)
8111a6dc:	10800058 	cmpnei	r2,r2,1
8111a6e0:	1000051e 	bne	r2,zero,8111a6f8 <vLoadDebugConfs+0xb70>
							xDefaults.bDataPacket = TRUE;
8111a6e4:	00a045b4 	movhi	r2,33046
8111a6e8:	10975904 	addi	r2,r2,23908
8111a6ec:	00c00044 	movi	r3,1
8111a6f0:	10c00815 	stw	r3,32(r2)
8111a6f4:	00000306 	br	8111a704 <vLoadDebugConfs+0xb7c>
						else
							xDefaults.bDataPacket = FALSE;
8111a6f8:	00a045b4 	movhi	r2,33046
8111a6fc:	10975904 	addi	r2,r2,23908
8111a700:	10000815 	stw	zero,32(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111a704:	e0bffd04 	addi	r2,fp,-12
8111a708:	e0bffa15 	stw	r2,-24(fp)

						break;
8111a70c:	00001b06 	br	8111a77c <vLoadDebugConfs+0xbf4>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
8111a710:	e0bffc0f 	ldh	r2,-16(fp)
8111a714:	1009883a 	mov	r4,r2
8111a718:	111dd600 	call	8111dd60 <siCloseFile>
8111a71c:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
8111a720:	e0bffb17 	ldw	r2,-20(fp)
8111a724:	1000071e 	bne	r2,zero,8111a744 <vLoadDebugConfs+0xbbc>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
8111a728:	d0a06117 	ldw	r2,-32380(gp)
8111a72c:	100f883a 	mov	r7,r2
8111a730:	01800784 	movi	r6,30
8111a734:	01400044 	movi	r5,1
8111a738:	01204574 	movhi	r4,33045
8111a73c:	2136f004 	addi	r4,r4,-9280
8111a740:	1120e540 	call	81120e54 <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
8111a744:	00800044 	movi	r2,1
8111a748:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
8111a74c:	00800044 	movi	r2,1
8111a750:	e0bff715 	stw	r2,-36(fp)
						break;
8111a754:	00000906 	br	8111a77c <vLoadDebugConfs+0xbf4>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
8111a758:	d0a06117 	ldw	r2,-32380(gp)
8111a75c:	100f883a 	mov	r7,r2
8111a760:	01800844 	movi	r6,33
8111a764:	01400044 	movi	r5,1
8111a768:	01204574 	movhi	r4,33045
8111a76c:	2136f804 	addi	r4,r4,-9248
8111a770:	1120e540 	call	81120e54 <fwrite>
						#endif
						break;
8111a774:	00000106 	br	8111a77c <vLoadDebugConfs+0xbf4>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
8111a778:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
8111a77c:	e0bff817 	ldw	r2,-32(fp)
8111a780:	103d1f26 	beq	r2,zero,81119c00 <__reset+0xfb0f9c00>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
8111a784:	00000f06 	br	8111a7c4 <vLoadDebugConfs+0xc3c>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
8111a788:	d0a06117 	ldw	r2,-32380(gp)
8111a78c:	100f883a 	mov	r7,r2
8111a790:	01800604 	movi	r6,24
8111a794:	01400044 	movi	r5,1
8111a798:	01204574 	movhi	r4,33045
8111a79c:	21370104 	addi	r4,r4,-9212
8111a7a0:	1120e540 	call	81120e54 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
8111a7a4:	00000706 	br	8111a7c4 <vLoadDebugConfs+0xc3c>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
8111a7a8:	d0a06117 	ldw	r2,-32380(gp)
8111a7ac:	100f883a 	mov	r7,r2
8111a7b0:	018004c4 	movi	r6,19
8111a7b4:	01400044 	movi	r5,1
8111a7b8:	01204574 	movhi	r4,33045
8111a7bc:	21370804 	addi	r4,r4,-9184
8111a7c0:	1120e540 	call	81120e54 <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
8111a7c4:	e0bff717 	ldw	r2,-36(fp)
8111a7c8:	1000391e 	bne	r2,zero,8111a8b0 <vLoadDebugConfs+0xd28>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Debug Configs: Could not load the default values from SDCard\n");
8111a7cc:	01204574 	movhi	r4,33045
8111a7d0:	21375a04 	addi	r4,r4,-8856
8111a7d4:	1121e040 	call	81121e04 <puts>
		printf("Can't find the file:'%s'.\n", ETH_FILE_NAME);
8111a7d8:	01604574 	movhi	r5,33045
8111a7dc:	2976e704 	addi	r5,r5,-9316
8111a7e0:	01204574 	movhi	r4,33045
8111a7e4:	21376a04 	addi	r4,r4,-8792
8111a7e8:	1121b800 	call	81121b80 <printf>



		xDefaults.usiRows = 4510;
8111a7ec:	00a045b4 	movhi	r2,33046
8111a7f0:	10975904 	addi	r2,r2,23908
8111a7f4:	00c46784 	movi	r3,4510
8111a7f8:	10c0060d 	sth	r3,24(r2)
		xDefaults.usiCols = 2255;
8111a7fc:	00a045b4 	movhi	r2,33046
8111a800:	10975904 	addi	r2,r2,23908
8111a804:	00c233c4 	movi	r3,2255
8111a808:	10c0058d 	sth	r3,22(r2)
		xDefaults.usiOLN = 30;
8111a80c:	00a045b4 	movhi	r2,33046
8111a810:	10975904 	addi	r2,r2,23908
8111a814:	00c00784 	movi	r3,30
8111a818:	10c0050d 	sth	r3,20(r2)
		xDefaults.usiPreScanSerial = 25;
8111a81c:	00a045b4 	movhi	r2,33046
8111a820:	10975904 	addi	r2,r2,23908
8111a824:	00c00644 	movi	r3,25
8111a828:	10c0048d 	sth	r3,18(r2)
		xDefaults.usiOverScanSerial = 15;
8111a82c:	00a045b4 	movhi	r2,33046
8111a830:	10975904 	addi	r2,r2,23908
8111a834:	00c003c4 	movi	r3,15
8111a838:	10c0040d 	sth	r3,16(r2)
		xDefaults.usiSyncPeriod = 6250;
8111a83c:	00a045b4 	movhi	r2,33046
8111a840:	10975904 	addi	r2,r2,23908
8111a844:	00c61a84 	movi	r3,6250
8111a848:	10c0068d 	sth	r3,26(r2)
		xDefaults.usiDelay = 20;
8111a84c:	00a045b4 	movhi	r2,33046
8111a850:	10975904 	addi	r2,r2,23908
8111a854:	00c00504 	movi	r3,20
8111a858:	10c0070d 	sth	r3,28(r2)
		xDefaults.bDataPacket = TRUE;
8111a85c:	00a045b4 	movhi	r2,33046
8111a860:	10975904 	addi	r2,r2,23908
8111a864:	00c00044 	movi	r3,1
8111a868:	10c00815 	stw	r3,32(r2)
		xDefaults.ulLineDelay = 0;
8111a86c:	00a045b4 	movhi	r2,33046
8111a870:	10975904 	addi	r2,r2,23908
8111a874:	10000915 	stw	zero,36(r2)
		xDefaults.ulColDelay = 0;
8111a878:	00a045b4 	movhi	r2,33046
8111a87c:	10975904 	addi	r2,r2,23908
8111a880:	10000a15 	stw	zero,40(r2)
		xDefaults.ulADCPixelDelay = 0;
8111a884:	00a045b4 	movhi	r2,33046
8111a888:	10975904 	addi	r2,r2,23908
8111a88c:	10000b15 	stw	zero,44(r2)
		xDefaults.ucLogicalAddr = 0x51;
8111a890:	00a045b4 	movhi	r2,33046
8111a894:	10975904 	addi	r2,r2,23908
8111a898:	00c01444 	movi	r3,81
8111a89c:	10c00c8d 	sth	r3,50(r2)
		xDefaults.ucRmapKey = 0xD1;
8111a8a0:	00a045b4 	movhi	r2,33046
8111a8a4:	10975904 	addi	r2,r2,23908
8111a8a8:	00c03444 	movi	r3,209
8111a8ac:	10c00c0d 	sth	r3,48(r2)

	}

	return bSuccess;
8111a8b0:	e0bff717 	ldw	r2,-36(fp)
}
8111a8b4:	e6ffff04 	addi	sp,fp,-4
8111a8b8:	dfc00217 	ldw	ra,8(sp)
8111a8bc:	df000117 	ldw	fp,4(sp)
8111a8c0:	dc000017 	ldw	r16,0(sp)
8111a8c4:	dec00304 	addi	sp,sp,12
8111a8c8:	f800283a 	ret

8111a8cc <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
8111a8cc:	defffb04 	addi	sp,sp,-20
8111a8d0:	de00012e 	bgeu	sp,et,8111a8d8 <ucCrc8+0xc>
8111a8d4:	003b68fa 	trap	3
8111a8d8:	df000415 	stw	fp,16(sp)
8111a8dc:	df000404 	addi	fp,sp,16
8111a8e0:	e13ffd15 	stw	r4,-12(fp)
8111a8e4:	e17ffe15 	stw	r5,-8(fp)
8111a8e8:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
8111a8ec:	e0bffe17 	ldw	r2,-8(fp)
8111a8f0:	1000021e 	bne	r2,zero,8111a8fc <ucCrc8+0x30>
        return 0;
8111a8f4:	0005883a 	mov	r2,zero
8111a8f8:	00001906 	br	8111a960 <ucCrc8+0x94>
    crc &= 0xff;
8111a8fc:	e0bffd17 	ldw	r2,-12(fp)
8111a900:	10803fcc 	andi	r2,r2,255
8111a904:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
8111a908:	e0fffe17 	ldw	r3,-8(fp)
8111a90c:	e0bfff17 	ldw	r2,-4(fp)
8111a910:	1885883a 	add	r2,r3,r2
8111a914:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
8111a918:	00000d06 	br	8111a950 <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
8111a91c:	e0bffe17 	ldw	r2,-8(fp)
8111a920:	10c00044 	addi	r3,r2,1
8111a924:	e0fffe15 	stw	r3,-8(fp)
8111a928:	10800003 	ldbu	r2,0(r2)
8111a92c:	10c03fcc 	andi	r3,r2,255
8111a930:	e0bffd17 	ldw	r2,-12(fp)
8111a934:	1886f03a 	xor	r3,r3,r2
8111a938:	00a04574 	movhi	r2,33045
8111a93c:	10b770c4 	addi	r2,r2,-8765
8111a940:	10c5883a 	add	r2,r2,r3
8111a944:	10800003 	ldbu	r2,0(r2)
8111a948:	10803fcc 	andi	r2,r2,255
8111a94c:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
8111a950:	e0fffe17 	ldw	r3,-8(fp)
8111a954:	e0bffc17 	ldw	r2,-16(fp)
8111a958:	18bff036 	bltu	r3,r2,8111a91c <__reset+0xfb0fa91c>
        crc = crc8_table[crc ^ *data++];
    return crc;
8111a95c:	e0bffd17 	ldw	r2,-12(fp)
}
8111a960:	e037883a 	mov	sp,fp
8111a964:	df000017 	ldw	fp,0(sp)
8111a968:	dec00104 	addi	sp,sp,4
8111a96c:	f800283a 	ret

8111a970 <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
8111a970:	defffb04 	addi	sp,sp,-20
8111a974:	de00012e 	bgeu	sp,et,8111a97c <ucCrc8wInit+0xc>
8111a978:	003b68fa 	trap	3
8111a97c:	dfc00415 	stw	ra,16(sp)
8111a980:	df000315 	stw	fp,12(sp)
8111a984:	df000304 	addi	fp,sp,12
8111a988:	e13ffe15 	stw	r4,-8(fp)
8111a98c:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
8111a990:	000d883a 	mov	r6,zero
8111a994:	000b883a 	mov	r5,zero
8111a998:	0009883a 	mov	r4,zero
8111a99c:	111a8cc0 	call	8111a8cc <ucCrc8>
8111a9a0:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
8111a9a4:	e0bffd03 	ldbu	r2,-12(fp)
8111a9a8:	e1bfff17 	ldw	r6,-4(fp)
8111a9ac:	e17ffe17 	ldw	r5,-8(fp)
8111a9b0:	1009883a 	mov	r4,r2
8111a9b4:	111a8cc0 	call	8111a8cc <ucCrc8>
}
8111a9b8:	e037883a 	mov	sp,fp
8111a9bc:	dfc00117 	ldw	ra,4(sp)
8111a9c0:	df000017 	ldw	fp,0(sp)
8111a9c4:	dec00204 	addi	sp,sp,8
8111a9c8:	f800283a 	ret

8111a9cc <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
8111a9cc:	defffc04 	addi	sp,sp,-16
8111a9d0:	de00012e 	bgeu	sp,et,8111a9d8 <vDataControllerInit+0xc>
8111a9d4:	003b68fa 	trap	3
8111a9d8:	df000315 	stw	fp,12(sp)
8111a9dc:	df000304 	addi	fp,sp,12
8111a9e0:	e13ffe15 	stw	r4,-8(fp)
8111a9e4:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;
8111a9e8:	e0bffe17 	ldw	r2,-8(fp)
8111a9ec:	10000615 	stw	zero,24(r2)

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8111a9f0:	e03ffd05 	stb	zero,-12(fp)
8111a9f4:	00001c06 	br	8111aa68 <vDataControllerInit+0x9c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
8111a9f8:	e0bffd03 	ldbu	r2,-12(fp)
8111a9fc:	e0fffd03 	ldbu	r3,-12(fp)
8111aa00:	18c09624 	muli	r3,r3,600
8111aa04:	e13fff17 	ldw	r4,-4(fp)
8111aa08:	20c7883a 	add	r3,r4,r3
8111aa0c:	e13ffe17 	ldw	r4,-8(fp)
8111aa10:	10800084 	addi	r2,r2,2
8111aa14:	1085883a 	add	r2,r2,r2
8111aa18:	1085883a 	add	r2,r2,r2
8111aa1c:	2085883a 	add	r2,r4,r2
8111aa20:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
8111aa24:	e17ffd03 	ldbu	r5,-12(fp)
8111aa28:	e0bffd03 	ldbu	r2,-12(fp)
8111aa2c:	e0ffff17 	ldw	r3,-4(fp)
8111aa30:	108025c4 	addi	r2,r2,151
8111aa34:	1085883a 	add	r2,r2,r2
8111aa38:	1085883a 	add	r2,r2,r2
8111aa3c:	1885883a 	add	r2,r3,r2
8111aa40:	10c00017 	ldw	r3,0(r2)
8111aa44:	e13ffe17 	ldw	r4,-8(fp)
8111aa48:	288000c4 	addi	r2,r5,3
8111aa4c:	1085883a 	add	r2,r2,r2
8111aa50:	1085883a 	add	r2,r2,r2
8111aa54:	2085883a 	add	r2,r4,r2
8111aa58:	10c00015 	stw	r3,0(r2)
void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8111aa5c:	e0bffd03 	ldbu	r2,-12(fp)
8111aa60:	10800044 	addi	r2,r2,1
8111aa64:	e0bffd05 	stb	r2,-12(fp)
8111aa68:	e0bffd03 	ldbu	r2,-12(fp)
8111aa6c:	103fe226 	beq	r2,zero,8111a9f8 <__reset+0xfb0fa9f8>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
8111aa70:	e0bfff17 	ldw	r2,-4(fp)
8111aa74:	10c09904 	addi	r3,r2,612
8111aa78:	e0bffe17 	ldw	r2,-8(fp)
8111aa7c:	10c00415 	stw	r3,16(r2)
	xDataControlL->bUpdateComplete = FALSE;
8111aa80:	e0bffe17 	ldw	r2,-8(fp)
8111aa84:	10000515 	stw	zero,20(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
8111aa88:	e0bffe17 	ldw	r2,-8(fp)
8111aa8c:	10c00504 	addi	r3,r2,20
8111aa90:	e0bfff17 	ldw	r2,-4(fp)
8111aa94:	10c09b15 	stw	r3,620(r2)
}
8111aa98:	0001883a 	nop
8111aa9c:	e037883a 	mov	sp,fp
8111aaa0:	df000017 	ldw	fp,0(sp)
8111aaa4:	dec00104 	addi	sp,sp,4
8111aaa8:	f800283a 	ret

8111aaac <printErrorTask>:

#include "error_handler_simucam.h"


#ifdef DEBUG_ON
    void printErrorTask( INT8U error_code ) {
8111aaac:	defff904 	addi	sp,sp,-28
8111aab0:	de00012e 	bgeu	sp,et,8111aab8 <printErrorTask+0xc>
8111aab4:	003b68fa 	trap	3
8111aab8:	dfc00615 	stw	ra,24(sp)
8111aabc:	df000515 	stw	fp,20(sp)
8111aac0:	df000504 	addi	fp,sp,20
8111aac4:	2005883a 	mov	r2,r4
8111aac8:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
8111aacc:	e03ffb15 	stw	zero,-20(fp)
8111aad0:	e03ffc15 	stw	zero,-16(fp)
8111aad4:	e03ffd15 	stw	zero,-12(fp)
8111aad8:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
8111aadc:	e0bfff03 	ldbu	r2,-4(fp)
8111aae0:	100d883a 	mov	r6,r2
8111aae4:	01604574 	movhi	r5,33045
8111aae8:	2977b104 	addi	r5,r5,-8508
8111aaec:	e13ffb04 	addi	r4,fp,-20
8111aaf0:	11221480 	call	81122148 <sprintf>
		debug(fp, buffer);
8111aaf4:	d0a06117 	ldw	r2,-32380(gp)
8111aaf8:	e17ffb04 	addi	r5,fp,-20
8111aafc:	1009883a 	mov	r4,r2
8111ab00:	11207b80 	call	811207b8 <fprintf>
	}
8111ab04:	0001883a 	nop
8111ab08:	e037883a 	mov	sp,fp
8111ab0c:	dfc00117 	ldw	ra,4(sp)
8111ab10:	df000017 	ldw	fp,0(sp)
8111ab14:	dec00204 	addi	sp,sp,8
8111ab18:	f800283a 	ret

8111ab1c <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
8111ab1c:	defffd04 	addi	sp,sp,-12
8111ab20:	de00012e 	bgeu	sp,et,8111ab28 <vFailCreateMutexSResources+0xc>
8111ab24:	003b68fa 	trap	3
8111ab28:	dfc00215 	stw	ra,8(sp)
8111ab2c:	df000115 	stw	fp,4(sp)
8111ab30:	df000104 	addi	fp,sp,4
8111ab34:	2005883a 	mov	r2,r4
8111ab38:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
8111ab3c:	d0a06117 	ldw	r2,-32380(gp)
8111ab40:	100f883a 	mov	r7,r2
8111ab44:	018008c4 	movi	r6,35
8111ab48:	01400044 	movi	r5,1
8111ab4c:	01204574 	movhi	r4,33045
8111ab50:	2137b404 	addi	r4,r4,-8496
8111ab54:	1120e540 	call	81120e54 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
8111ab58:	e0bfff03 	ldbu	r2,-4(fp)
8111ab5c:	1009883a 	mov	r4,r2
8111ab60:	111aaac0 	call	8111aaac <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ab64:	0001883a 	nop
8111ab68:	e037883a 	mov	sp,fp
8111ab6c:	dfc00117 	ldw	ra,4(sp)
8111ab70:	df000017 	ldw	fp,0(sp)
8111ab74:	dec00204 	addi	sp,sp,8
8111ab78:	f800283a 	ret

8111ab7c <vFailCreateMutexDMA>:

void vFailCreateMutexDMA( void )
{
8111ab7c:	defffe04 	addi	sp,sp,-8
8111ab80:	de00012e 	bgeu	sp,et,8111ab88 <vFailCreateMutexDMA+0xc>
8111ab84:	003b68fa 	trap	3
8111ab88:	dfc00115 	stw	ra,4(sp)
8111ab8c:	df000015 	stw	fp,0(sp)
8111ab90:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp," CRITICAL: vFailCreateMutexDMA. (exit)\n");
8111ab94:	d0a06117 	ldw	r2,-32380(gp)
8111ab98:	100f883a 	mov	r7,r2
8111ab9c:	018009c4 	movi	r6,39
8111aba0:	01400044 	movi	r5,1
8111aba4:	01204574 	movhi	r4,33045
8111aba8:	2137bd04 	addi	r4,r4,-8460
8111abac:	1120e540 	call	81120e54 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111abb0:	0001883a 	nop
8111abb4:	e037883a 	mov	sp,fp
8111abb8:	dfc00117 	ldw	ra,4(sp)
8111abbc:	df000017 	ldw	fp,0(sp)
8111abc0:	dec00204 	addi	sp,sp,8
8111abc4:	f800283a 	ret

8111abc8 <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
8111abc8:	defffe04 	addi	sp,sp,-8
8111abcc:	de00012e 	bgeu	sp,et,8111abd4 <vFailCreateSemaphoreResources+0xc>
8111abd0:	003b68fa 	trap	3
8111abd4:	dfc00115 	stw	ra,4(sp)
8111abd8:	df000015 	stw	fp,0(sp)
8111abdc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
8111abe0:	d0a06117 	ldw	r2,-32380(gp)
8111abe4:	100f883a 	mov	r7,r2
8111abe8:	01800984 	movi	r6,38
8111abec:	01400044 	movi	r5,1
8111abf0:	01204574 	movhi	r4,33045
8111abf4:	2137c704 	addi	r4,r4,-8420
8111abf8:	1120e540 	call	81120e54 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111abfc:	0001883a 	nop
8111ac00:	e037883a 	mov	sp,fp
8111ac04:	dfc00117 	ldw	ra,4(sp)
8111ac08:	df000017 	ldw	fp,0(sp)
8111ac0c:	dec00204 	addi	sp,sp,8
8111ac10:	f800283a 	ret

8111ac14 <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
8111ac14:	defffe04 	addi	sp,sp,-8
8111ac18:	de00012e 	bgeu	sp,et,8111ac20 <vFailTestCriticasParts+0xc>
8111ac1c:	003b68fa 	trap	3
8111ac20:	dfc00115 	stw	ra,4(sp)
8111ac24:	df000015 	stw	fp,0(sp)
8111ac28:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTestCriticasParts. (exit)\n");
8111ac2c:	d0a06117 	ldw	r2,-32380(gp)
8111ac30:	100f883a 	mov	r7,r2
8111ac34:	018007c4 	movi	r6,31
8111ac38:	01400044 	movi	r5,1
8111ac3c:	01204574 	movhi	r4,33045
8111ac40:	2137d104 	addi	r4,r4,-8380
8111ac44:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ac48:	0001883a 	nop
8111ac4c:	e037883a 	mov	sp,fp
8111ac50:	dfc00117 	ldw	ra,4(sp)
8111ac54:	df000017 	ldw	fp,0(sp)
8111ac58:	dec00204 	addi	sp,sp,8
8111ac5c:	f800283a 	ret

8111ac60 <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
8111ac60:	defffe04 	addi	sp,sp,-8
8111ac64:	de00012e 	bgeu	sp,et,8111ac6c <vFailSendxSemCommInit+0xc>
8111ac68:	003b68fa 	trap	3
8111ac6c:	dfc00115 	stw	ra,4(sp)
8111ac70:	df000015 	stw	fp,0(sp)
8111ac74:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendxSemCommInit. (exit)");
8111ac78:	d0a06117 	ldw	r2,-32380(gp)
8111ac7c:	100f883a 	mov	r7,r2
8111ac80:	01800744 	movi	r6,29
8111ac84:	01400044 	movi	r5,1
8111ac88:	01204574 	movhi	r4,33045
8111ac8c:	2137d904 	addi	r4,r4,-8348
8111ac90:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
8111ac94:	d0a06117 	ldw	r2,-32380(gp)
8111ac98:	100f883a 	mov	r7,r2
8111ac9c:	01800a44 	movi	r6,41
8111aca0:	01400044 	movi	r5,1
8111aca4:	01204574 	movhi	r4,33045
8111aca8:	2137e104 	addi	r4,r4,-8316
8111acac:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111acb0:	0001883a 	nop
8111acb4:	e037883a 	mov	sp,fp
8111acb8:	dfc00117 	ldw	ra,4(sp)
8111acbc:	df000017 	ldw	fp,0(sp)
8111acc0:	dec00204 	addi	sp,sp,8
8111acc4:	f800283a 	ret

8111acc8 <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
8111acc8:	defffe04 	addi	sp,sp,-8
8111accc:	de00012e 	bgeu	sp,et,8111acd4 <vFailSendPreParsedSemaphore+0xc>
8111acd0:	003b68fa 	trap	3
8111acd4:	dfc00115 	stw	ra,4(sp)
8111acd8:	df000015 	stw	fp,0(sp)
8111acdc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
8111ace0:	d0a06117 	ldw	r2,-32380(gp)
8111ace4:	100f883a 	mov	r7,r2
8111ace8:	01800904 	movi	r6,36
8111acec:	01400044 	movi	r5,1
8111acf0:	01204574 	movhi	r4,33045
8111acf4:	2137ec04 	addi	r4,r4,-8272
8111acf8:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111acfc:	0001883a 	nop
8111ad00:	e037883a 	mov	sp,fp
8111ad04:	dfc00117 	ldw	ra,4(sp)
8111ad08:	df000017 	ldw	fp,0(sp)
8111ad0c:	dec00204 	addi	sp,sp,8
8111ad10:	f800283a 	ret

8111ad14 <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
8111ad14:	defffe04 	addi	sp,sp,-8
8111ad18:	de00012e 	bgeu	sp,et,8111ad20 <vFailSendPreAckReceiverSemaphore+0xc>
8111ad1c:	003b68fa 	trap	3
8111ad20:	dfc00115 	stw	ra,4(sp)
8111ad24:	df000015 	stw	fp,0(sp)
8111ad28:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
8111ad2c:	d0a06117 	ldw	r2,-32380(gp)
8111ad30:	100f883a 	mov	r7,r2
8111ad34:	01800a44 	movi	r6,41
8111ad38:	01400044 	movi	r5,1
8111ad3c:	01204574 	movhi	r4,33045
8111ad40:	2137f604 	addi	r4,r4,-8232
8111ad44:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ad48:	0001883a 	nop
8111ad4c:	e037883a 	mov	sp,fp
8111ad50:	dfc00117 	ldw	ra,4(sp)
8111ad54:	df000017 	ldw	fp,0(sp)
8111ad58:	dec00204 	addi	sp,sp,8
8111ad5c:	f800283a 	ret

8111ad60 <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
8111ad60:	defffe04 	addi	sp,sp,-8
8111ad64:	de00012e 	bgeu	sp,et,8111ad6c <vFailSendPreAckSenderSemaphore+0xc>
8111ad68:	003b68fa 	trap	3
8111ad6c:	dfc00115 	stw	ra,4(sp)
8111ad70:	df000015 	stw	fp,0(sp)
8111ad74:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
8111ad78:	d0a06117 	ldw	r2,-32380(gp)
8111ad7c:	100f883a 	mov	r7,r2
8111ad80:	018009c4 	movi	r6,39
8111ad84:	01400044 	movi	r5,1
8111ad88:	01204574 	movhi	r4,33045
8111ad8c:	21380104 	addi	r4,r4,-8188
8111ad90:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ad94:	0001883a 	nop
8111ad98:	e037883a 	mov	sp,fp
8111ad9c:	dfc00117 	ldw	ra,4(sp)
8111ada0:	df000017 	ldw	fp,0(sp)
8111ada4:	dec00204 	addi	sp,sp,8
8111ada8:	f800283a 	ret

8111adac <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
8111adac:	defffe04 	addi	sp,sp,-8
8111adb0:	de00012e 	bgeu	sp,et,8111adb8 <vFailGetCountSemaphoreSenderTask+0xc>
8111adb4:	003b68fa 	trap	3
8111adb8:	dfc00115 	stw	ra,4(sp)
8111adbc:	df000015 	stw	fp,0(sp)
8111adc0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
8111adc4:	d0a06117 	ldw	r2,-32380(gp)
8111adc8:	100f883a 	mov	r7,r2
8111adcc:	01800a44 	movi	r6,41
8111add0:	01400044 	movi	r5,1
8111add4:	01204574 	movhi	r4,33045
8111add8:	21380b04 	addi	r4,r4,-8148
8111addc:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
8111ade0:	d0a06117 	ldw	r2,-32380(gp)
8111ade4:	100f883a 	mov	r7,r2
8111ade8:	01801104 	movi	r6,68
8111adec:	01400044 	movi	r5,1
8111adf0:	01204574 	movhi	r4,33045
8111adf4:	21381604 	addi	r4,r4,-8104
8111adf8:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111adfc:	0001883a 	nop
8111ae00:	e037883a 	mov	sp,fp
8111ae04:	dfc00117 	ldw	ra,4(sp)
8111ae08:	df000017 	ldw	fp,0(sp)
8111ae0c:	dec00204 	addi	sp,sp,8
8111ae10:	f800283a 	ret

8111ae14 <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
8111ae14:	defffe04 	addi	sp,sp,-8
8111ae18:	de00012e 	bgeu	sp,et,8111ae20 <vFailGetMutexSenderTask+0xc>
8111ae1c:	003b68fa 	trap	3
8111ae20:	dfc00115 	stw	ra,4(sp)
8111ae24:	df000015 	stw	fp,0(sp)
8111ae28:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
8111ae2c:	d0a06117 	ldw	r2,-32380(gp)
8111ae30:	100f883a 	mov	r7,r2
8111ae34:	01800804 	movi	r6,32
8111ae38:	01400044 	movi	r5,1
8111ae3c:	01204574 	movhi	r4,33045
8111ae40:	21382804 	addi	r4,r4,-8032
8111ae44:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
8111ae48:	d0a06117 	ldw	r2,-32380(gp)
8111ae4c:	100f883a 	mov	r7,r2
8111ae50:	01801084 	movi	r6,66
8111ae54:	01400044 	movi	r5,1
8111ae58:	01204574 	movhi	r4,33045
8111ae5c:	21383104 	addi	r4,r4,-7996
8111ae60:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ae64:	0001883a 	nop
8111ae68:	e037883a 	mov	sp,fp
8111ae6c:	dfc00117 	ldw	ra,4(sp)
8111ae70:	df000017 	ldw	fp,0(sp)
8111ae74:	dec00204 	addi	sp,sp,8
8111ae78:	f800283a 	ret

8111ae7c <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
8111ae7c:	defffe04 	addi	sp,sp,-8
8111ae80:	de00012e 	bgeu	sp,et,8111ae88 <vFailGetCountSemaphoreReceiverTask+0xc>
8111ae84:	003b68fa 	trap	3
8111ae88:	dfc00115 	stw	ra,4(sp)
8111ae8c:	df000015 	stw	fp,0(sp)
8111ae90:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
8111ae94:	d0a06117 	ldw	r2,-32380(gp)
8111ae98:	100f883a 	mov	r7,r2
8111ae9c:	01800ac4 	movi	r6,43
8111aea0:	01400044 	movi	r5,1
8111aea4:	01204574 	movhi	r4,33045
8111aea8:	21384204 	addi	r4,r4,-7928
8111aeac:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
8111aeb0:	d0a06117 	ldw	r2,-32380(gp)
8111aeb4:	100f883a 	mov	r7,r2
8111aeb8:	01801184 	movi	r6,70
8111aebc:	01400044 	movi	r5,1
8111aec0:	01204574 	movhi	r4,33045
8111aec4:	21384d04 	addi	r4,r4,-7884
8111aec8:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111aecc:	0001883a 	nop
8111aed0:	e037883a 	mov	sp,fp
8111aed4:	dfc00117 	ldw	ra,4(sp)
8111aed8:	df000017 	ldw	fp,0(sp)
8111aedc:	dec00204 	addi	sp,sp,8
8111aee0:	f800283a 	ret

8111aee4 <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
8111aee4:	defffe04 	addi	sp,sp,-8
8111aee8:	de00012e 	bgeu	sp,et,8111aef0 <vFailGetMutexReceiverTask+0xc>
8111aeec:	003b68fa 	trap	3
8111aef0:	dfc00115 	stw	ra,4(sp)
8111aef4:	df000015 	stw	fp,0(sp)
8111aef8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
8111aefc:	d0a06117 	ldw	r2,-32380(gp)
8111af00:	100f883a 	mov	r7,r2
8111af04:	01800884 	movi	r6,34
8111af08:	01400044 	movi	r5,1
8111af0c:	01204574 	movhi	r4,33045
8111af10:	21385f04 	addi	r4,r4,-7812
8111af14:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
8111af18:	d0a06117 	ldw	r2,-32380(gp)
8111af1c:	100f883a 	mov	r7,r2
8111af20:	01801104 	movi	r6,68
8111af24:	01400044 	movi	r5,1
8111af28:	01204574 	movhi	r4,33045
8111af2c:	21386804 	addi	r4,r4,-7776
8111af30:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111af34:	0001883a 	nop
8111af38:	e037883a 	mov	sp,fp
8111af3c:	dfc00117 	ldw	ra,4(sp)
8111af40:	df000017 	ldw	fp,0(sp)
8111af44:	dec00204 	addi	sp,sp,8
8111af48:	f800283a 	ret

8111af4c <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
8111af4c:	defffe04 	addi	sp,sp,-8
8111af50:	de00012e 	bgeu	sp,et,8111af58 <vFailGetMutexTxUARTSenderTask+0xc>
8111af54:	003b68fa 	trap	3
8111af58:	dfc00115 	stw	ra,4(sp)
8111af5c:	df000015 	stw	fp,0(sp)
8111af60:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
8111af64:	d0a06117 	ldw	r2,-32380(gp)
8111af68:	100f883a 	mov	r7,r2
8111af6c:	01800984 	movi	r6,38
8111af70:	01400044 	movi	r5,1
8111af74:	01204574 	movhi	r4,33045
8111af78:	21387a04 	addi	r4,r4,-7704
8111af7c:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
8111af80:	d0a06117 	ldw	r2,-32380(gp)
8111af84:	100f883a 	mov	r7,r2
8111af88:	01801044 	movi	r6,65
8111af8c:	01400044 	movi	r5,1
8111af90:	01204574 	movhi	r4,33045
8111af94:	21388404 	addi	r4,r4,-7664
8111af98:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111af9c:	0001883a 	nop
8111afa0:	e037883a 	mov	sp,fp
8111afa4:	dfc00117 	ldw	ra,4(sp)
8111afa8:	df000017 	ldw	fp,0(sp)
8111afac:	dec00204 	addi	sp,sp,8
8111afb0:	f800283a 	ret

8111afb4 <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
8111afb4:	defffe04 	addi	sp,sp,-8
8111afb8:	de00012e 	bgeu	sp,et,8111afc0 <vFailGetMacRTC+0xc>
8111afbc:	003b68fa 	trap	3
8111afc0:	dfc00115 	stw	ra,4(sp)
8111afc4:	df000015 	stw	fp,0(sp)
8111afc8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMacRTC\n");
8111afcc:	d0a06117 	ldw	r2,-32380(gp)
8111afd0:	100f883a 	mov	r7,r2
8111afd4:	018003c4 	movi	r6,15
8111afd8:	01400044 	movi	r5,1
8111afdc:	01204574 	movhi	r4,33045
8111afe0:	21389504 	addi	r4,r4,-7596
8111afe4:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111afe8:	0001883a 	nop
8111afec:	e037883a 	mov	sp,fp
8111aff0:	dfc00117 	ldw	ra,4(sp)
8111aff4:	df000017 	ldw	fp,0(sp)
8111aff8:	dec00204 	addi	sp,sp,8
8111affc:	f800283a 	ret

8111b000 <vFailInitialization>:


void vFailInitialization( void )
{
8111b000:	defffe04 	addi	sp,sp,-8
8111b004:	de00012e 	bgeu	sp,et,8111b00c <vFailInitialization+0xc>
8111b008:	003b68fa 	trap	3
8111b00c:	dfc00115 	stw	ra,4(sp)
8111b010:	df000015 	stw	fp,0(sp)
8111b014:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInitialization\n");
8111b018:	d0a06117 	ldw	r2,-32380(gp)
8111b01c:	100f883a 	mov	r7,r2
8111b020:	01800504 	movi	r6,20
8111b024:	01400044 	movi	r5,1
8111b028:	01204574 	movhi	r4,33045
8111b02c:	21389904 	addi	r4,r4,-7580
8111b030:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b034:	0001883a 	nop
8111b038:	e037883a 	mov	sp,fp
8111b03c:	dfc00117 	ldw	ra,4(sp)
8111b040:	df000017 	ldw	fp,0(sp)
8111b044:	dec00204 	addi	sp,sp,8
8111b048:	f800283a 	ret

8111b04c <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
8111b04c:	defffe04 	addi	sp,sp,-8
8111b050:	de00012e 	bgeu	sp,et,8111b058 <vFailReceiverCreate+0xc>
8111b054:	003b68fa 	trap	3
8111b058:	dfc00115 	stw	ra,4(sp)
8111b05c:	df000015 	stw	fp,0(sp)
8111b060:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vReceiverUartTask\n");
8111b064:	d0a06117 	ldw	r2,-32380(gp)
8111b068:	100f883a 	mov	r7,r2
8111b06c:	01800484 	movi	r6,18
8111b070:	01400044 	movi	r5,1
8111b074:	01204574 	movhi	r4,33045
8111b078:	21389f04 	addi	r4,r4,-7556
8111b07c:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b080:	0001883a 	nop
8111b084:	e037883a 	mov	sp,fp
8111b088:	dfc00117 	ldw	ra,4(sp)
8111b08c:	df000017 	ldw	fp,0(sp)
8111b090:	dec00204 	addi	sp,sp,8
8111b094:	f800283a 	ret

8111b098 <vFailSenderCreate>:


void vFailSenderCreate( void )
{
8111b098:	defffe04 	addi	sp,sp,-8
8111b09c:	de00012e 	bgeu	sp,et,8111b0a4 <vFailSenderCreate+0xc>
8111b0a0:	003b68fa 	trap	3
8111b0a4:	dfc00115 	stw	ra,4(sp)
8111b0a8:	df000015 	stw	fp,0(sp)
8111b0ac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSenderCreate\n");
8111b0b0:	d0a06117 	ldw	r2,-32380(gp)
8111b0b4:	100f883a 	mov	r7,r2
8111b0b8:	01800484 	movi	r6,18
8111b0bc:	01400044 	movi	r5,1
8111b0c0:	01204574 	movhi	r4,33045
8111b0c4:	2138a404 	addi	r4,r4,-7536
8111b0c8:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b0cc:	0001883a 	nop
8111b0d0:	e037883a 	mov	sp,fp
8111b0d4:	dfc00117 	ldw	ra,4(sp)
8111b0d8:	df000017 	ldw	fp,0(sp)
8111b0dc:	dec00204 	addi	sp,sp,8
8111b0e0:	f800283a 	ret

8111b0e4 <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
8111b0e4:	defffe04 	addi	sp,sp,-8
8111b0e8:	de00012e 	bgeu	sp,et,8111b0f0 <vFailDeleteInitialization+0xc>
8111b0ec:	003b68fa 	trap	3
8111b0f0:	dfc00115 	stw	ra,4(sp)
8111b0f4:	df000015 	stw	fp,0(sp)
8111b0f8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailDeleteInitialization\n");
8111b0fc:	d0a06117 	ldw	r2,-32380(gp)
8111b100:	100f883a 	mov	r7,r2
8111b104:	01800684 	movi	r6,26
8111b108:	01400044 	movi	r5,1
8111b10c:	01204574 	movhi	r4,33045
8111b110:	2138a904 	addi	r4,r4,-7516
8111b114:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b118:	0001883a 	nop
8111b11c:	e037883a 	mov	sp,fp
8111b120:	dfc00117 	ldw	ra,4(sp)
8111b124:	df000017 	ldw	fp,0(sp)
8111b128:	dec00204 	addi	sp,sp,8
8111b12c:	f800283a 	ret

8111b130 <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
8111b130:	defffe04 	addi	sp,sp,-8
8111b134:	de00012e 	bgeu	sp,et,8111b13c <vFailSetCountSemaphorexBuffer32+0xc>
8111b138:	003b68fa 	trap	3
8111b13c:	dfc00115 	stw	ra,4(sp)
8111b140:	df000015 	stw	fp,0(sp)
8111b144:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
8111b148:	d0a06117 	ldw	r2,-32380(gp)
8111b14c:	100f883a 	mov	r7,r2
8111b150:	01800a04 	movi	r6,40
8111b154:	01400044 	movi	r5,1
8111b158:	01204574 	movhi	r4,33045
8111b15c:	2138b004 	addi	r4,r4,-7488
8111b160:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8111b164:	d0a06117 	ldw	r2,-32380(gp)
8111b168:	100f883a 	mov	r7,r2
8111b16c:	018008c4 	movi	r6,35
8111b170:	01400044 	movi	r5,1
8111b174:	01204574 	movhi	r4,33045
8111b178:	2138bb04 	addi	r4,r4,-7444
8111b17c:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b180:	0001883a 	nop
8111b184:	e037883a 	mov	sp,fp
8111b188:	dfc00117 	ldw	ra,4(sp)
8111b18c:	df000017 	ldw	fp,0(sp)
8111b190:	dec00204 	addi	sp,sp,8
8111b194:	f800283a 	ret

8111b198 <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
8111b198:	defffe04 	addi	sp,sp,-8
8111b19c:	de00012e 	bgeu	sp,et,8111b1a4 <vFailSetCountSemaphorexBuffer64+0xc>
8111b1a0:	003b68fa 	trap	3
8111b1a4:	dfc00115 	stw	ra,4(sp)
8111b1a8:	df000015 	stw	fp,0(sp)
8111b1ac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
8111b1b0:	d0a06117 	ldw	r2,-32380(gp)
8111b1b4:	100f883a 	mov	r7,r2
8111b1b8:	01800a04 	movi	r6,40
8111b1bc:	01400044 	movi	r5,1
8111b1c0:	01204574 	movhi	r4,33045
8111b1c4:	2138c404 	addi	r4,r4,-7408
8111b1c8:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8111b1cc:	d0a06117 	ldw	r2,-32380(gp)
8111b1d0:	100f883a 	mov	r7,r2
8111b1d4:	018008c4 	movi	r6,35
8111b1d8:	01400044 	movi	r5,1
8111b1dc:	01204574 	movhi	r4,33045
8111b1e0:	2138bb04 	addi	r4,r4,-7444
8111b1e4:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b1e8:	0001883a 	nop
8111b1ec:	e037883a 	mov	sp,fp
8111b1f0:	dfc00117 	ldw	ra,4(sp)
8111b1f4:	df000017 	ldw	fp,0(sp)
8111b1f8:	dec00204 	addi	sp,sp,8
8111b1fc:	f800283a 	ret

8111b200 <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
8111b200:	defffe04 	addi	sp,sp,-8
8111b204:	de00012e 	bgeu	sp,et,8111b20c <vFailSetCountSemaphorexBuffer128+0xc>
8111b208:	003b68fa 	trap	3
8111b20c:	dfc00115 	stw	ra,4(sp)
8111b210:	df000015 	stw	fp,0(sp)
8111b214:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
8111b218:	d0a06117 	ldw	r2,-32380(gp)
8111b21c:	100f883a 	mov	r7,r2
8111b220:	01800a44 	movi	r6,41
8111b224:	01400044 	movi	r5,1
8111b228:	01204574 	movhi	r4,33045
8111b22c:	2138cf04 	addi	r4,r4,-7364
8111b230:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8111b234:	d0a06117 	ldw	r2,-32380(gp)
8111b238:	100f883a 	mov	r7,r2
8111b23c:	018008c4 	movi	r6,35
8111b240:	01400044 	movi	r5,1
8111b244:	01204574 	movhi	r4,33045
8111b248:	2138bb04 	addi	r4,r4,-7444
8111b24c:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b250:	0001883a 	nop
8111b254:	e037883a 	mov	sp,fp
8111b258:	dfc00117 	ldw	ra,4(sp)
8111b25c:	df000017 	ldw	fp,0(sp)
8111b260:	dec00204 	addi	sp,sp,8
8111b264:	f800283a 	ret

8111b268 <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
8111b268:	defffe04 	addi	sp,sp,-8
8111b26c:	de00012e 	bgeu	sp,et,8111b274 <vFailGetCountSemaphorexBuffer128+0xc>
8111b270:	003b68fa 	trap	3
8111b274:	dfc00115 	stw	ra,4(sp)
8111b278:	df000015 	stw	fp,0(sp)
8111b27c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
8111b280:	d0a06117 	ldw	r2,-32380(gp)
8111b284:	100f883a 	mov	r7,r2
8111b288:	01800a44 	movi	r6,41
8111b28c:	01400044 	movi	r5,1
8111b290:	01204574 	movhi	r4,33045
8111b294:	2138da04 	addi	r4,r4,-7320
8111b298:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8111b29c:	d0a06117 	ldw	r2,-32380(gp)
8111b2a0:	100f883a 	mov	r7,r2
8111b2a4:	01800884 	movi	r6,34
8111b2a8:	01400044 	movi	r5,1
8111b2ac:	01204574 	movhi	r4,33045
8111b2b0:	2138e504 	addi	r4,r4,-7276
8111b2b4:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b2b8:	0001883a 	nop
8111b2bc:	e037883a 	mov	sp,fp
8111b2c0:	dfc00117 	ldw	ra,4(sp)
8111b2c4:	df000017 	ldw	fp,0(sp)
8111b2c8:	dec00204 	addi	sp,sp,8
8111b2cc:	f800283a 	ret

8111b2d0 <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
8111b2d0:	defffe04 	addi	sp,sp,-8
8111b2d4:	de00012e 	bgeu	sp,et,8111b2dc <vFailGetCountSemaphorexBuffer64+0xc>
8111b2d8:	003b68fa 	trap	3
8111b2dc:	dfc00115 	stw	ra,4(sp)
8111b2e0:	df000015 	stw	fp,0(sp)
8111b2e4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
8111b2e8:	d0a06117 	ldw	r2,-32380(gp)
8111b2ec:	100f883a 	mov	r7,r2
8111b2f0:	01800a04 	movi	r6,40
8111b2f4:	01400044 	movi	r5,1
8111b2f8:	01204574 	movhi	r4,33045
8111b2fc:	2138ee04 	addi	r4,r4,-7240
8111b300:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8111b304:	d0a06117 	ldw	r2,-32380(gp)
8111b308:	100f883a 	mov	r7,r2
8111b30c:	01800884 	movi	r6,34
8111b310:	01400044 	movi	r5,1
8111b314:	01204574 	movhi	r4,33045
8111b318:	2138e504 	addi	r4,r4,-7276
8111b31c:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b320:	0001883a 	nop
8111b324:	e037883a 	mov	sp,fp
8111b328:	dfc00117 	ldw	ra,4(sp)
8111b32c:	df000017 	ldw	fp,0(sp)
8111b330:	dec00204 	addi	sp,sp,8
8111b334:	f800283a 	ret

8111b338 <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
8111b338:	defffe04 	addi	sp,sp,-8
8111b33c:	de00012e 	bgeu	sp,et,8111b344 <vFailGetCountSemaphorexBuffer32+0xc>
8111b340:	003b68fa 	trap	3
8111b344:	dfc00115 	stw	ra,4(sp)
8111b348:	df000015 	stw	fp,0(sp)
8111b34c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
8111b350:	d0a06117 	ldw	r2,-32380(gp)
8111b354:	100f883a 	mov	r7,r2
8111b358:	01800a04 	movi	r6,40
8111b35c:	01400044 	movi	r5,1
8111b360:	01204574 	movhi	r4,33045
8111b364:	2138f904 	addi	r4,r4,-7196
8111b368:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8111b36c:	d0a06117 	ldw	r2,-32380(gp)
8111b370:	100f883a 	mov	r7,r2
8111b374:	01800884 	movi	r6,34
8111b378:	01400044 	movi	r5,1
8111b37c:	01204574 	movhi	r4,33045
8111b380:	2138e504 	addi	r4,r4,-7276
8111b384:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b388:	0001883a 	nop
8111b38c:	e037883a 	mov	sp,fp
8111b390:	dfc00117 	ldw	ra,4(sp)
8111b394:	df000017 	ldw	fp,0(sp)
8111b398:	dec00204 	addi	sp,sp,8
8111b39c:	f800283a 	ret

8111b3a0 <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
8111b3a0:	defffe04 	addi	sp,sp,-8
8111b3a4:	de00012e 	bgeu	sp,et,8111b3ac <vFailFoundBufferRetransmission+0xc>
8111b3a8:	003b68fa 	trap	3
8111b3ac:	dfc00115 	stw	ra,4(sp)
8111b3b0:	df000015 	stw	fp,0(sp)
8111b3b4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
8111b3b8:	d0a06117 	ldw	r2,-32380(gp)
8111b3bc:	100f883a 	mov	r7,r2
8111b3c0:	01800a84 	movi	r6,42
8111b3c4:	01400044 	movi	r5,1
8111b3c8:	01204574 	movhi	r4,33045
8111b3cc:	21390404 	addi	r4,r4,-7152
8111b3d0:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
8111b3d4:	d0a06117 	ldw	r2,-32380(gp)
8111b3d8:	100f883a 	mov	r7,r2
8111b3dc:	01801204 	movi	r6,72
8111b3e0:	01400044 	movi	r5,1
8111b3e4:	01204574 	movhi	r4,33045
8111b3e8:	21390f04 	addi	r4,r4,-7108
8111b3ec:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b3f0:	0001883a 	nop
8111b3f4:	e037883a 	mov	sp,fp
8111b3f8:	dfc00117 	ldw	ra,4(sp)
8111b3fc:	df000017 	ldw	fp,0(sp)
8111b400:	dec00204 	addi	sp,sp,8
8111b404:	f800283a 	ret

8111b408 <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
8111b408:	defffe04 	addi	sp,sp,-8
8111b40c:	de00012e 	bgeu	sp,et,8111b414 <vFailGetCountSemaphorePreParsedBuffer+0xc>
8111b410:	003b68fa 	trap	3
8111b414:	dfc00115 	stw	ra,4(sp)
8111b418:	df000015 	stw	fp,0(sp)
8111b41c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
8111b420:	d0a06117 	ldw	r2,-32380(gp)
8111b424:	100f883a 	mov	r7,r2
8111b428:	01800b84 	movi	r6,46
8111b42c:	01400044 	movi	r5,1
8111b430:	01204574 	movhi	r4,33045
8111b434:	21392204 	addi	r4,r4,-7032
8111b438:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
8111b43c:	d0a06117 	ldw	r2,-32380(gp)
8111b440:	100f883a 	mov	r7,r2
8111b444:	018010c4 	movi	r6,67
8111b448:	01400044 	movi	r5,1
8111b44c:	01204574 	movhi	r4,33045
8111b450:	21392e04 	addi	r4,r4,-6984
8111b454:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b458:	0001883a 	nop
8111b45c:	e037883a 	mov	sp,fp
8111b460:	dfc00117 	ldw	ra,4(sp)
8111b464:	df000017 	ldw	fp,0(sp)
8111b468:	dec00204 	addi	sp,sp,8
8111b46c:	f800283a 	ret

8111b470 <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
8111b470:	defffe04 	addi	sp,sp,-8
8111b474:	de00012e 	bgeu	sp,et,8111b47c <vFailGetxMutexPreParsedParserRxTask+0xc>
8111b478:	003b68fa 	trap	3
8111b47c:	dfc00115 	stw	ra,4(sp)
8111b480:	df000015 	stw	fp,0(sp)
8111b484:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
8111b488:	d0a06117 	ldw	r2,-32380(gp)
8111b48c:	100f883a 	mov	r7,r2
8111b490:	01800b04 	movi	r6,44
8111b494:	01400044 	movi	r5,1
8111b498:	01204574 	movhi	r4,33045
8111b49c:	21393f04 	addi	r4,r4,-6916
8111b4a0:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
8111b4a4:	d0a06117 	ldw	r2,-32380(gp)
8111b4a8:	100f883a 	mov	r7,r2
8111b4ac:	01800fc4 	movi	r6,63
8111b4b0:	01400044 	movi	r5,1
8111b4b4:	01204574 	movhi	r4,33045
8111b4b8:	21394b04 	addi	r4,r4,-6868
8111b4bc:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b4c0:	0001883a 	nop
8111b4c4:	e037883a 	mov	sp,fp
8111b4c8:	dfc00117 	ldw	ra,4(sp)
8111b4cc:	df000017 	ldw	fp,0(sp)
8111b4d0:	dec00204 	addi	sp,sp,8
8111b4d4:	f800283a 	ret

8111b4d8 <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
8111b4d8:	defffe04 	addi	sp,sp,-8
8111b4dc:	de00012e 	bgeu	sp,et,8111b4e4 <vNoContentInPreParsedBuffer+0xc>
8111b4e0:	003b68fa 	trap	3
8111b4e4:	dfc00115 	stw	ra,4(sp)
8111b4e8:	df000015 	stw	fp,0(sp)
8111b4ec:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
8111b4f0:	d0a06117 	ldw	r2,-32380(gp)
8111b4f4:	100f883a 	mov	r7,r2
8111b4f8:	01800904 	movi	r6,36
8111b4fc:	01400044 	movi	r5,1
8111b500:	01204574 	movhi	r4,33045
8111b504:	21395b04 	addi	r4,r4,-6804
8111b508:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
8111b50c:	d0a06117 	ldw	r2,-32380(gp)
8111b510:	100f883a 	mov	r7,r2
8111b514:	01801684 	movi	r6,90
8111b518:	01400044 	movi	r5,1
8111b51c:	01204574 	movhi	r4,33045
8111b520:	21396504 	addi	r4,r4,-6764
8111b524:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b528:	0001883a 	nop
8111b52c:	e037883a 	mov	sp,fp
8111b530:	dfc00117 	ldw	ra,4(sp)
8111b534:	df000017 	ldw	fp,0(sp)
8111b538:	dec00204 	addi	sp,sp,8
8111b53c:	f800283a 	ret

8111b540 <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
8111b540:	defffe04 	addi	sp,sp,-8
8111b544:	de00012e 	bgeu	sp,et,8111b54c <vCouldNotSendEthConfUART+0xc>
8111b548:	003b68fa 	trap	3
8111b54c:	dfc00115 	stw	ra,4(sp)
8111b550:	df000015 	stw	fp,0(sp)
8111b554:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
8111b558:	d0a06117 	ldw	r2,-32380(gp)
8111b55c:	100f883a 	mov	r7,r2
8111b560:	01800844 	movi	r6,33
8111b564:	01400044 	movi	r5,1
8111b568:	01204574 	movhi	r4,33045
8111b56c:	21397c04 	addi	r4,r4,-6672
8111b570:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
8111b574:	d0a06117 	ldw	r2,-32380(gp)
8111b578:	100f883a 	mov	r7,r2
8111b57c:	01801784 	movi	r6,94
8111b580:	01400044 	movi	r5,1
8111b584:	01204574 	movhi	r4,33045
8111b588:	21398504 	addi	r4,r4,-6636
8111b58c:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b590:	0001883a 	nop
8111b594:	e037883a 	mov	sp,fp
8111b598:	dfc00117 	ldw	ra,4(sp)
8111b59c:	df000017 	ldw	fp,0(sp)
8111b5a0:	dec00204 	addi	sp,sp,8
8111b5a4:	f800283a 	ret

8111b5a8 <vFailSendNack>:

void vFailSendNack( void )
{
8111b5a8:	defffe04 	addi	sp,sp,-8
8111b5ac:	de00012e 	bgeu	sp,et,8111b5b4 <vFailSendNack+0xc>
8111b5b0:	003b68fa 	trap	3
8111b5b4:	dfc00115 	stw	ra,4(sp)
8111b5b8:	df000015 	stw	fp,0(sp)
8111b5bc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendNack. (exit)\n");
8111b5c0:	d0a06117 	ldw	r2,-32380(gp)
8111b5c4:	100f883a 	mov	r7,r2
8111b5c8:	01800584 	movi	r6,22
8111b5cc:	01400044 	movi	r5,1
8111b5d0:	01204574 	movhi	r4,33045
8111b5d4:	21399d04 	addi	r4,r4,-6540
8111b5d8:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
8111b5dc:	d0a06117 	ldw	r2,-32380(gp)
8111b5e0:	100f883a 	mov	r7,r2
8111b5e4:	01800a84 	movi	r6,42
8111b5e8:	01400044 	movi	r5,1
8111b5ec:	01204574 	movhi	r4,33045
8111b5f0:	2139a304 	addi	r4,r4,-6516
8111b5f4:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b5f8:	0001883a 	nop
8111b5fc:	e037883a 	mov	sp,fp
8111b600:	dfc00117 	ldw	ra,4(sp)
8111b604:	df000017 	ldw	fp,0(sp)
8111b608:	dec00204 	addi	sp,sp,8
8111b60c:	f800283a 	ret

8111b610 <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
8111b610:	defffe04 	addi	sp,sp,-8
8111b614:	de00012e 	bgeu	sp,et,8111b61c <vFailSetPreAckSenderBuffer+0xc>
8111b618:	003b68fa 	trap	3
8111b61c:	dfc00115 	stw	ra,4(sp)
8111b620:	df000015 	stw	fp,0(sp)
8111b624:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
8111b628:	d0a06117 	ldw	r2,-32380(gp)
8111b62c:	100f883a 	mov	r7,r2
8111b630:	018008c4 	movi	r6,35
8111b634:	01400044 	movi	r5,1
8111b638:	01204574 	movhi	r4,33045
8111b63c:	2139ae04 	addi	r4,r4,-6472
8111b640:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
8111b644:	d0a06117 	ldw	r2,-32380(gp)
8111b648:	100f883a 	mov	r7,r2
8111b64c:	01801584 	movi	r6,86
8111b650:	01400044 	movi	r5,1
8111b654:	01204574 	movhi	r4,33045
8111b658:	2139b704 	addi	r4,r4,-6436
8111b65c:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b660:	0001883a 	nop
8111b664:	e037883a 	mov	sp,fp
8111b668:	dfc00117 	ldw	ra,4(sp)
8111b66c:	df000017 	ldw	fp,0(sp)
8111b670:	dec00204 	addi	sp,sp,8
8111b674:	f800283a 	ret

8111b678 <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
8111b678:	defffe04 	addi	sp,sp,-8
8111b67c:	de00012e 	bgeu	sp,et,8111b684 <vFailSetPreParsedBuffer+0xc>
8111b680:	003b68fa 	trap	3
8111b684:	dfc00115 	stw	ra,4(sp)
8111b688:	df000015 	stw	fp,0(sp)
8111b68c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
8111b690:	d0a06117 	ldw	r2,-32380(gp)
8111b694:	100f883a 	mov	r7,r2
8111b698:	01800804 	movi	r6,32
8111b69c:	01400044 	movi	r5,1
8111b6a0:	01204574 	movhi	r4,33045
8111b6a4:	2139cd04 	addi	r4,r4,-6348
8111b6a8:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
8111b6ac:	d0a06117 	ldw	r2,-32380(gp)
8111b6b0:	100f883a 	mov	r7,r2
8111b6b4:	018013c4 	movi	r6,79
8111b6b8:	01400044 	movi	r5,1
8111b6bc:	01204574 	movhi	r4,33045
8111b6c0:	2139d604 	addi	r4,r4,-6312
8111b6c4:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b6c8:	0001883a 	nop
8111b6cc:	e037883a 	mov	sp,fp
8111b6d0:	dfc00117 	ldw	ra,4(sp)
8111b6d4:	df000017 	ldw	fp,0(sp)
8111b6d8:	dec00204 	addi	sp,sp,8
8111b6dc:	f800283a 	ret

8111b6e0 <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
8111b6e0:	defffe04 	addi	sp,sp,-8
8111b6e4:	de00012e 	bgeu	sp,et,8111b6ec <vFailSetPreAckReceiverBuffer+0xc>
8111b6e8:	003b68fa 	trap	3
8111b6ec:	dfc00115 	stw	ra,4(sp)
8111b6f0:	df000015 	stw	fp,0(sp)
8111b6f4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
8111b6f8:	d0a06117 	ldw	r2,-32380(gp)
8111b6fc:	100f883a 	mov	r7,r2
8111b700:	01800944 	movi	r6,37
8111b704:	01400044 	movi	r5,1
8111b708:	01204574 	movhi	r4,33045
8111b70c:	2139ea04 	addi	r4,r4,-6232
8111b710:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
8111b714:	d0a06117 	ldw	r2,-32380(gp)
8111b718:	100f883a 	mov	r7,r2
8111b71c:	018015c4 	movi	r6,87
8111b720:	01400044 	movi	r5,1
8111b724:	01204574 	movhi	r4,33045
8111b728:	2139f404 	addi	r4,r4,-6192
8111b72c:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b730:	0001883a 	nop
8111b734:	e037883a 	mov	sp,fp
8111b738:	dfc00117 	ldw	ra,4(sp)
8111b73c:	df000017 	ldw	fp,0(sp)
8111b740:	dec00204 	addi	sp,sp,8
8111b744:	f800283a 	ret

8111b748 <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
8111b748:	defffe04 	addi	sp,sp,-8
8111b74c:	de00012e 	bgeu	sp,et,8111b754 <vFailParserCommTaskCreate+0xc>
8111b750:	003b68fa 	trap	3
8111b754:	dfc00115 	stw	ra,4(sp)
8111b758:	df000015 	stw	fp,0(sp)
8111b75c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailParserCommTaskCreate\n");
8111b760:	d0a06117 	ldw	r2,-32380(gp)
8111b764:	100f883a 	mov	r7,r2
8111b768:	01800684 	movi	r6,26
8111b76c:	01400044 	movi	r5,1
8111b770:	01204574 	movhi	r4,33045
8111b774:	213a0a04 	addi	r4,r4,-6104
8111b778:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b77c:	0001883a 	nop
8111b780:	e037883a 	mov	sp,fp
8111b784:	dfc00117 	ldw	ra,4(sp)
8111b788:	df000017 	ldw	fp,0(sp)
8111b78c:	dec00204 	addi	sp,sp,8
8111b790:	f800283a 	ret

8111b794 <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
8111b794:	defffe04 	addi	sp,sp,-8
8111b798:	de00012e 	bgeu	sp,et,8111b7a0 <vFailInAckHandlerTaskCreate+0xc>
8111b79c:	003b68fa 	trap	3
8111b7a0:	dfc00115 	stw	ra,4(sp)
8111b7a4:	df000015 	stw	fp,0(sp)
8111b7a8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111b7ac:	d0a06117 	ldw	r2,-32380(gp)
8111b7b0:	100f883a 	mov	r7,r2
8111b7b4:	01800704 	movi	r6,28
8111b7b8:	01400044 	movi	r5,1
8111b7bc:	01204574 	movhi	r4,33045
8111b7c0:	213a1104 	addi	r4,r4,-6076
8111b7c4:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b7c8:	0001883a 	nop
8111b7cc:	e037883a 	mov	sp,fp
8111b7d0:	dfc00117 	ldw	ra,4(sp)
8111b7d4:	df000017 	ldw	fp,0(sp)
8111b7d8:	dec00204 	addi	sp,sp,8
8111b7dc:	f800283a 	ret

8111b7e0 <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
8111b7e0:	defffe04 	addi	sp,sp,-8
8111b7e4:	de00012e 	bgeu	sp,et,8111b7ec <vFailOutAckHandlerTaskCreate+0xc>
8111b7e8:	003b68fa 	trap	3
8111b7ec:	dfc00115 	stw	ra,4(sp)
8111b7f0:	df000015 	stw	fp,0(sp)
8111b7f4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111b7f8:	d0a06117 	ldw	r2,-32380(gp)
8111b7fc:	100f883a 	mov	r7,r2
8111b800:	01800704 	movi	r6,28
8111b804:	01400044 	movi	r5,1
8111b808:	01204574 	movhi	r4,33045
8111b80c:	213a1104 	addi	r4,r4,-6076
8111b810:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b814:	0001883a 	nop
8111b818:	e037883a 	mov	sp,fp
8111b81c:	dfc00117 	ldw	ra,4(sp)
8111b820:	df000017 	ldw	fp,0(sp)
8111b824:	dec00204 	addi	sp,sp,8
8111b828:	f800283a 	ret

8111b82c <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
8111b82c:	defffe04 	addi	sp,sp,-8
8111b830:	de00012e 	bgeu	sp,et,8111b838 <vFailCreateTimerRetransmisison+0xc>
8111b834:	003b68fa 	trap	3
8111b838:	dfc00115 	stw	ra,4(sp)
8111b83c:	df000015 	stw	fp,0(sp)
8111b840:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateTimerRetransmisison\n");
8111b844:	d0a06117 	ldw	r2,-32380(gp)
8111b848:	100f883a 	mov	r7,r2
8111b84c:	018007c4 	movi	r6,31
8111b850:	01400044 	movi	r5,1
8111b854:	01204574 	movhi	r4,33045
8111b858:	213a1904 	addi	r4,r4,-6044
8111b85c:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b860:	0001883a 	nop
8111b864:	e037883a 	mov	sp,fp
8111b868:	dfc00117 	ldw	ra,4(sp)
8111b86c:	df000017 	ldw	fp,0(sp)
8111b870:	dec00204 	addi	sp,sp,8
8111b874:	f800283a 	ret

8111b878 <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
8111b878:	defffe04 	addi	sp,sp,-8
8111b87c:	de00012e 	bgeu	sp,et,8111b884 <vCouldNotCheckBufferTimeOutFunction+0xc>
8111b880:	003b68fa 	trap	3
8111b884:	dfc00115 	stw	ra,4(sp)
8111b888:	df000015 	stw	fp,0(sp)
8111b88c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
8111b890:	d0a06117 	ldw	r2,-32380(gp)
8111b894:	100f883a 	mov	r7,r2
8111b898:	01800904 	movi	r6,36
8111b89c:	01400044 	movi	r5,1
8111b8a0:	01204574 	movhi	r4,33045
8111b8a4:	213a2104 	addi	r4,r4,-6012
8111b8a8:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b8ac:	0001883a 	nop
8111b8b0:	e037883a 	mov	sp,fp
8111b8b4:	dfc00117 	ldw	ra,4(sp)
8111b8b8:	df000017 	ldw	fp,0(sp)
8111b8bc:	dec00204 	addi	sp,sp,8
8111b8c0:	f800283a 	ret

8111b8c4 <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
8111b8c4:	defffe04 	addi	sp,sp,-8
8111b8c8:	de00012e 	bgeu	sp,et,8111b8d0 <vFailTimeoutCheckerTaskCreate+0xc>
8111b8cc:	003b68fa 	trap	3
8111b8d0:	dfc00115 	stw	ra,4(sp)
8111b8d4:	df000015 	stw	fp,0(sp)
8111b8d8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
8111b8dc:	d0a06117 	ldw	r2,-32380(gp)
8111b8e0:	100f883a 	mov	r7,r2
8111b8e4:	01800a04 	movi	r6,40
8111b8e8:	01400044 	movi	r5,1
8111b8ec:	01204574 	movhi	r4,33045
8111b8f0:	213a2b04 	addi	r4,r4,-5972
8111b8f4:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b8f8:	0001883a 	nop
8111b8fc:	e037883a 	mov	sp,fp
8111b900:	dfc00117 	ldw	ra,4(sp)
8111b904:	df000017 	ldw	fp,0(sp)
8111b908:	dec00204 	addi	sp,sp,8
8111b90c:	f800283a 	ret

8111b910 <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
8111b910:	defffe04 	addi	sp,sp,-8
8111b914:	de00012e 	bgeu	sp,et,8111b91c <vFailGetBlockingSemTimeoutTask+0xc>
8111b918:	003b68fa 	trap	3
8111b91c:	dfc00115 	stw	ra,4(sp)
8111b920:	df000015 	stw	fp,0(sp)
8111b924:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
8111b928:	d0a06117 	ldw	r2,-32380(gp)
8111b92c:	100f883a 	mov	r7,r2
8111b930:	018009c4 	movi	r6,39
8111b934:	01400044 	movi	r5,1
8111b938:	01204574 	movhi	r4,33045
8111b93c:	213a3604 	addi	r4,r4,-5928
8111b940:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
8111b944:	d0a06117 	ldw	r2,-32380(gp)
8111b948:	100f883a 	mov	r7,r2
8111b94c:	01800cc4 	movi	r6,51
8111b950:	01400044 	movi	r5,1
8111b954:	01204574 	movhi	r4,33045
8111b958:	213a4004 	addi	r4,r4,-5888
8111b95c:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b960:	0001883a 	nop
8111b964:	e037883a 	mov	sp,fp
8111b968:	dfc00117 	ldw	ra,4(sp)
8111b96c:	df000017 	ldw	fp,0(sp)
8111b970:	dec00204 	addi	sp,sp,8
8111b974:	f800283a 	ret

8111b978 <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
8111b978:	defffe04 	addi	sp,sp,-8
8111b97c:	de00012e 	bgeu	sp,et,8111b984 <vFailPostBlockingSemTimeoutTask+0xc>
8111b980:	003b68fa 	trap	3
8111b984:	dfc00115 	stw	ra,4(sp)
8111b988:	df000015 	stw	fp,0(sp)
8111b98c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
8111b990:	d0a06117 	ldw	r2,-32380(gp)
8111b994:	100f883a 	mov	r7,r2
8111b998:	01800a04 	movi	r6,40
8111b99c:	01400044 	movi	r5,1
8111b9a0:	01204574 	movhi	r4,33045
8111b9a4:	213a4d04 	addi	r4,r4,-5836
8111b9a8:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
8111b9ac:	d0a06117 	ldw	r2,-32380(gp)
8111b9b0:	100f883a 	mov	r7,r2
8111b9b4:	01800c84 	movi	r6,50
8111b9b8:	01400044 	movi	r5,1
8111b9bc:	01204574 	movhi	r4,33045
8111b9c0:	213a5804 	addi	r4,r4,-5792
8111b9c4:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b9c8:	0001883a 	nop
8111b9cc:	e037883a 	mov	sp,fp
8111b9d0:	dfc00117 	ldw	ra,4(sp)
8111b9d4:	df000017 	ldw	fp,0(sp)
8111b9d8:	dec00204 	addi	sp,sp,8
8111b9dc:	f800283a 	ret

8111b9e0 <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
8111b9e0:	defffe04 	addi	sp,sp,-8
8111b9e4:	de00012e 	bgeu	sp,et,8111b9ec <vFailCouldNotRetransmitTimeoutTask+0xc>
8111b9e8:	003b68fa 	trap	3
8111b9ec:	dfc00115 	stw	ra,4(sp)
8111b9f0:	df000015 	stw	fp,0(sp)
8111b9f4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
8111b9f8:	d0a06117 	ldw	r2,-32380(gp)
8111b9fc:	100f883a 	mov	r7,r2
8111ba00:	01800ac4 	movi	r6,43
8111ba04:	01400044 	movi	r5,1
8111ba08:	01204574 	movhi	r4,33045
8111ba0c:	213a6504 	addi	r4,r4,-5740
8111ba10:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
8111ba14:	d0a06117 	ldw	r2,-32380(gp)
8111ba18:	100f883a 	mov	r7,r2
8111ba1c:	01801644 	movi	r6,89
8111ba20:	01400044 	movi	r5,1
8111ba24:	01204574 	movhi	r4,33045
8111ba28:	213a7004 	addi	r4,r4,-5696
8111ba2c:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ba30:	0001883a 	nop
8111ba34:	e037883a 	mov	sp,fp
8111ba38:	dfc00117 	ldw	ra,4(sp)
8111ba3c:	df000017 	ldw	fp,0(sp)
8111ba40:	dec00204 	addi	sp,sp,8
8111ba44:	f800283a 	ret

8111ba48 <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
8111ba48:	defffe04 	addi	sp,sp,-8
8111ba4c:	de00012e 	bgeu	sp,et,8111ba54 <vCouldNotRetransmitB32TimeoutTask+0xc>
8111ba50:	003b68fa 	trap	3
8111ba54:	dfc00115 	stw	ra,4(sp)
8111ba58:	df000015 	stw	fp,0(sp)
8111ba5c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
8111ba60:	d0a06117 	ldw	r2,-32380(gp)
8111ba64:	100f883a 	mov	r7,r2
8111ba68:	01800a84 	movi	r6,42
8111ba6c:	01400044 	movi	r5,1
8111ba70:	01204574 	movhi	r4,33045
8111ba74:	213a8704 	addi	r4,r4,-5604
8111ba78:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
8111ba7c:	d0a06117 	ldw	r2,-32380(gp)
8111ba80:	100f883a 	mov	r7,r2
8111ba84:	01801444 	movi	r6,81
8111ba88:	01400044 	movi	r5,1
8111ba8c:	01204574 	movhi	r4,33045
8111ba90:	213a9204 	addi	r4,r4,-5560
8111ba94:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ba98:	0001883a 	nop
8111ba9c:	e037883a 	mov	sp,fp
8111baa0:	dfc00117 	ldw	ra,4(sp)
8111baa4:	df000017 	ldw	fp,0(sp)
8111baa8:	dec00204 	addi	sp,sp,8
8111baac:	f800283a 	ret

8111bab0 <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
8111bab0:	defffe04 	addi	sp,sp,-8
8111bab4:	de00012e 	bgeu	sp,et,8111babc <vCouldNotRetransmitB64TimeoutTask+0xc>
8111bab8:	003b68fa 	trap	3
8111babc:	dfc00115 	stw	ra,4(sp)
8111bac0:	df000015 	stw	fp,0(sp)
8111bac4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
8111bac8:	d0a06117 	ldw	r2,-32380(gp)
8111bacc:	100f883a 	mov	r7,r2
8111bad0:	01800a84 	movi	r6,42
8111bad4:	01400044 	movi	r5,1
8111bad8:	01204574 	movhi	r4,33045
8111badc:	213aa704 	addi	r4,r4,-5476
8111bae0:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
8111bae4:	d0a06117 	ldw	r2,-32380(gp)
8111bae8:	100f883a 	mov	r7,r2
8111baec:	01801444 	movi	r6,81
8111baf0:	01400044 	movi	r5,1
8111baf4:	01204574 	movhi	r4,33045
8111baf8:	213ab204 	addi	r4,r4,-5432
8111bafc:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bb00:	0001883a 	nop
8111bb04:	e037883a 	mov	sp,fp
8111bb08:	dfc00117 	ldw	ra,4(sp)
8111bb0c:	df000017 	ldw	fp,0(sp)
8111bb10:	dec00204 	addi	sp,sp,8
8111bb14:	f800283a 	ret

8111bb18 <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
8111bb18:	defffe04 	addi	sp,sp,-8
8111bb1c:	de00012e 	bgeu	sp,et,8111bb24 <vCouldNotRetransmitB128TimeoutTask+0xc>
8111bb20:	003b68fa 	trap	3
8111bb24:	dfc00115 	stw	ra,4(sp)
8111bb28:	df000015 	stw	fp,0(sp)
8111bb2c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
8111bb30:	d0a06117 	ldw	r2,-32380(gp)
8111bb34:	100f883a 	mov	r7,r2
8111bb38:	01800ac4 	movi	r6,43
8111bb3c:	01400044 	movi	r5,1
8111bb40:	01204574 	movhi	r4,33045
8111bb44:	213ac704 	addi	r4,r4,-5348
8111bb48:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
8111bb4c:	d0a06117 	ldw	r2,-32380(gp)
8111bb50:	100f883a 	mov	r7,r2
8111bb54:	01801484 	movi	r6,82
8111bb58:	01400044 	movi	r5,1
8111bb5c:	01204574 	movhi	r4,33045
8111bb60:	213ad204 	addi	r4,r4,-5304
8111bb64:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bb68:	0001883a 	nop
8111bb6c:	e037883a 	mov	sp,fp
8111bb70:	dfc00117 	ldw	ra,4(sp)
8111bb74:	df000017 	ldw	fp,0(sp)
8111bb78:	dec00204 	addi	sp,sp,8
8111bb7c:	f800283a 	ret

8111bb80 <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
8111bb80:	defffe04 	addi	sp,sp,-8
8111bb84:	de00012e 	bgeu	sp,et,8111bb8c <vFailStartTimerRetransmission+0xc>
8111bb88:	003b68fa 	trap	3
8111bb8c:	dfc00115 	stw	ra,4(sp)
8111bb90:	df000015 	stw	fp,0(sp)
8111bb94:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
8111bb98:	d0a06117 	ldw	r2,-32380(gp)
8111bb9c:	100f883a 	mov	r7,r2
8111bba0:	01800984 	movi	r6,38
8111bba4:	01400044 	movi	r5,1
8111bba8:	01204574 	movhi	r4,33045
8111bbac:	213ae704 	addi	r4,r4,-5220
8111bbb0:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
8111bbb4:	d0a06117 	ldw	r2,-32380(gp)
8111bbb8:	100f883a 	mov	r7,r2
8111bbbc:	01800d44 	movi	r6,53
8111bbc0:	01400044 	movi	r5,1
8111bbc4:	01204574 	movhi	r4,33045
8111bbc8:	213af104 	addi	r4,r4,-5180
8111bbcc:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bbd0:	0001883a 	nop
8111bbd4:	e037883a 	mov	sp,fp
8111bbd8:	dfc00117 	ldw	ra,4(sp)
8111bbdc:	df000017 	ldw	fp,0(sp)
8111bbe0:	dec00204 	addi	sp,sp,8
8111bbe4:	f800283a 	ret

8111bbe8 <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
8111bbe8:	defffe04 	addi	sp,sp,-8
8111bbec:	de00012e 	bgeu	sp,et,8111bbf4 <vCouldNotSendTurnOff+0xc>
8111bbf0:	003b68fa 	trap	3
8111bbf4:	dfc00115 	stw	ra,4(sp)
8111bbf8:	df000015 	stw	fp,0(sp)
8111bbfc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
8111bc00:	d0a06117 	ldw	r2,-32380(gp)
8111bc04:	100f883a 	mov	r7,r2
8111bc08:	01800744 	movi	r6,29
8111bc0c:	01400044 	movi	r5,1
8111bc10:	01204574 	movhi	r4,33045
8111bc14:	213aff04 	addi	r4,r4,-5124
8111bc18:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the turn off command. \n");
8111bc1c:	d0a06117 	ldw	r2,-32380(gp)
8111bc20:	100f883a 	mov	r7,r2
8111bc24:	01800984 	movi	r6,38
8111bc28:	01400044 	movi	r5,1
8111bc2c:	01204574 	movhi	r4,33045
8111bc30:	213b0704 	addi	r4,r4,-5092
8111bc34:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bc38:	0001883a 	nop
8111bc3c:	e037883a 	mov	sp,fp
8111bc40:	dfc00117 	ldw	ra,4(sp)
8111bc44:	df000017 	ldw	fp,0(sp)
8111bc48:	dec00204 	addi	sp,sp,8
8111bc4c:	f800283a 	ret

8111bc50 <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
8111bc50:	defffe04 	addi	sp,sp,-8
8111bc54:	de00012e 	bgeu	sp,et,8111bc5c <vCouldNotSendReset+0xc>
8111bc58:	003b68fa 	trap	3
8111bc5c:	dfc00115 	stw	ra,4(sp)
8111bc60:	df000015 	stw	fp,0(sp)
8111bc64:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendReset. (exit)\n");
8111bc68:	d0a06117 	ldw	r2,-32380(gp)
8111bc6c:	100f883a 	mov	r7,r2
8111bc70:	018006c4 	movi	r6,27
8111bc74:	01400044 	movi	r5,1
8111bc78:	01204574 	movhi	r4,33045
8111bc7c:	213b1104 	addi	r4,r4,-5052
8111bc80:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the reset command. \n");
8111bc84:	d0a06117 	ldw	r2,-32380(gp)
8111bc88:	100f883a 	mov	r7,r2
8111bc8c:	018008c4 	movi	r6,35
8111bc90:	01400044 	movi	r5,1
8111bc94:	01204574 	movhi	r4,33045
8111bc98:	213b1804 	addi	r4,r4,-5024
8111bc9c:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bca0:	0001883a 	nop
8111bca4:	e037883a 	mov	sp,fp
8111bca8:	dfc00117 	ldw	ra,4(sp)
8111bcac:	df000017 	ldw	fp,0(sp)
8111bcb0:	dec00204 	addi	sp,sp,8
8111bcb4:	f800283a 	ret

8111bcb8 <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
8111bcb8:	defffe04 	addi	sp,sp,-8
8111bcbc:	de00012e 	bgeu	sp,et,8111bcc4 <vCouldNotSendLog+0xc>
8111bcc0:	003b68fa 	trap	3
8111bcc4:	dfc00115 	stw	ra,4(sp)
8111bcc8:	df000015 	stw	fp,0(sp)
8111bccc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendLog. (exit)\n");
8111bcd0:	d0a06117 	ldw	r2,-32380(gp)
8111bcd4:	100f883a 	mov	r7,r2
8111bcd8:	01800644 	movi	r6,25
8111bcdc:	01400044 	movi	r5,1
8111bce0:	01204574 	movhi	r4,33045
8111bce4:	213b2104 	addi	r4,r4,-4988
8111bce8:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send log packet to NUC. \n");
8111bcec:	d0a06117 	ldw	r2,-32380(gp)
8111bcf0:	100f883a 	mov	r7,r2
8111bcf4:	018008c4 	movi	r6,35
8111bcf8:	01400044 	movi	r5,1
8111bcfc:	01204574 	movhi	r4,33045
8111bd00:	213b2804 	addi	r4,r4,-4960
8111bd04:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bd08:	0001883a 	nop
8111bd0c:	e037883a 	mov	sp,fp
8111bd10:	dfc00117 	ldw	ra,4(sp)
8111bd14:	df000017 	ldw	fp,0(sp)
8111bd18:	dec00204 	addi	sp,sp,8
8111bd1c:	f800283a 	ret

8111bd20 <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
8111bd20:	defffd04 	addi	sp,sp,-12
8111bd24:	de00012e 	bgeu	sp,et,8111bd2c <vCouldNotSendTMPusCommand+0xc>
8111bd28:	003b68fa 	trap	3
8111bd2c:	dfc00215 	stw	ra,8(sp)
8111bd30:	df000115 	stw	fp,4(sp)
8111bd34:	df000104 	addi	fp,sp,4
8111bd38:	e13fff15 	stw	r4,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
8111bd3c:	d0a06117 	ldw	r2,-32380(gp)
8111bd40:	100f883a 	mov	r7,r2
8111bd44:	01800884 	movi	r6,34
8111bd48:	01400044 	movi	r5,1
8111bd4c:	01204574 	movhi	r4,33045
8111bd50:	213b3104 	addi	r4,r4,-4924
8111bd54:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the TM PUS command to NUC. \n");
8111bd58:	d0a06117 	ldw	r2,-32380(gp)
8111bd5c:	100f883a 	mov	r7,r2
8111bd60:	01800ac4 	movi	r6,43
8111bd64:	01400044 	movi	r5,1
8111bd68:	01204574 	movhi	r4,33045
8111bd6c:	213b3a04 	addi	r4,r4,-4888
8111bd70:	1120e540 	call	81120e54 <fwrite>
		debug(fp,"cData");
8111bd74:	d0a06117 	ldw	r2,-32380(gp)
8111bd78:	100f883a 	mov	r7,r2
8111bd7c:	01800144 	movi	r6,5
8111bd80:	01400044 	movi	r5,1
8111bd84:	01204574 	movhi	r4,33045
8111bd88:	213b4504 	addi	r4,r4,-4844
8111bd8c:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bd90:	0001883a 	nop
8111bd94:	e037883a 	mov	sp,fp
8111bd98:	dfc00117 	ldw	ra,4(sp)
8111bd9c:	df000017 	ldw	fp,0(sp)
8111bda0:	dec00204 	addi	sp,sp,8
8111bda4:	f800283a 	ret

8111bda8 <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
8111bda8:	defffe04 	addi	sp,sp,-8
8111bdac:	de00012e 	bgeu	sp,et,8111bdb4 <vWarnCouldNotgetMutexRetrans128+0xc>
8111bdb0:	003b68fa 	trap	3
8111bdb4:	dfc00115 	stw	ra,4(sp)
8111bdb8:	df000015 	stw	fp,0(sp)
8111bdbc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
8111bdc0:	d0a06117 	ldw	r2,-32380(gp)
8111bdc4:	100f883a 	mov	r7,r2
8111bdc8:	01800a04 	movi	r6,40
8111bdcc:	01400044 	movi	r5,1
8111bdd0:	01204574 	movhi	r4,33045
8111bdd4:	213b4704 	addi	r4,r4,-4836
8111bdd8:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
8111bddc:	d0a06117 	ldw	r2,-32380(gp)
8111bde0:	100f883a 	mov	r7,r2
8111bde4:	018014c4 	movi	r6,83
8111bde8:	01400044 	movi	r5,1
8111bdec:	01204574 	movhi	r4,33045
8111bdf0:	213b5204 	addi	r4,r4,-4792
8111bdf4:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bdf8:	0001883a 	nop
8111bdfc:	e037883a 	mov	sp,fp
8111be00:	dfc00117 	ldw	ra,4(sp)
8111be04:	df000017 	ldw	fp,0(sp)
8111be08:	dec00204 	addi	sp,sp,8
8111be0c:	f800283a 	ret

8111be10 <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
8111be10:	defffe04 	addi	sp,sp,-8
8111be14:	de00012e 	bgeu	sp,et,8111be1c <vFailCreateScheduleQueue+0xc>
8111be18:	003b68fa 	trap	3
8111be1c:	dfc00115 	stw	ra,4(sp)
8111be20:	df000015 	stw	fp,0(sp)
8111be24:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateScheduleQueue. (exit)\n");
8111be28:	d0a06117 	ldw	r2,-32380(gp)
8111be2c:	100f883a 	mov	r7,r2
8111be30:	01800844 	movi	r6,33
8111be34:	01400044 	movi	r5,1
8111be38:	01204574 	movhi	r4,33045
8111be3c:	213b6704 	addi	r4,r4,-4708
8111be40:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: Could not create the Queue to shcedule the access to the DMA.\n");
8111be44:	d0a06117 	ldw	r2,-32380(gp)
8111be48:	100f883a 	mov	r7,r2
8111be4c:	01801204 	movi	r6,72
8111be50:	01400044 	movi	r5,1
8111be54:	01204574 	movhi	r4,33045
8111be58:	213b7004 	addi	r4,r4,-4672
8111be5c:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111be60:	0001883a 	nop
8111be64:	e037883a 	mov	sp,fp
8111be68:	dfc00117 	ldw	ra,4(sp)
8111be6c:	df000017 	ldw	fp,0(sp)
8111be70:	dec00204 	addi	sp,sp,8
8111be74:	f800283a 	ret

8111be78 <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
8111be78:	defffd04 	addi	sp,sp,-12
8111be7c:	de00012e 	bgeu	sp,et,8111be84 <vFailCreateNFEEQueue+0xc>
8111be80:	003b68fa 	trap	3
8111be84:	dfc00215 	stw	ra,8(sp)
8111be88:	df000115 	stw	fp,4(sp)
8111be8c:	df000104 	addi	fp,sp,4
8111be90:	2005883a 	mov	r2,r4
8111be94:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEEQueue. (exit)\n");
8111be98:	d0a06117 	ldw	r2,-32380(gp)
8111be9c:	100f883a 	mov	r7,r2
8111bea0:	01800744 	movi	r6,29
8111bea4:	01400044 	movi	r5,1
8111bea8:	01204574 	movhi	r4,33045
8111beac:	213b8304 	addi	r4,r4,-4596
8111beb0:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NSEE %hhu.\n",ucID);
8111beb4:	d0a06117 	ldw	r2,-32380(gp)
8111beb8:	e0ffff03 	ldbu	r3,-4(fp)
8111bebc:	180d883a 	mov	r6,r3
8111bec0:	01604574 	movhi	r5,33045
8111bec4:	297b8b04 	addi	r5,r5,-4564
8111bec8:	1009883a 	mov	r4,r2
8111becc:	1121b800 	call	81121b80 <printf>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bed0:	0001883a 	nop
8111bed4:	e037883a 	mov	sp,fp
8111bed8:	dfc00117 	ldw	ra,4(sp)
8111bedc:	df000017 	ldw	fp,0(sp)
8111bee0:	dec00204 	addi	sp,sp,8
8111bee4:	f800283a 	ret

8111bee8 <vFailCreateNFEESyncQueue>:

/* CRITICAL. */
void vFailCreateNFEESyncQueue( unsigned char ucID )
{
8111bee8:	defffd04 	addi	sp,sp,-12
8111beec:	de00012e 	bgeu	sp,et,8111bef4 <vFailCreateNFEESyncQueue+0xc>
8111bef0:	003b68fa 	trap	3
8111bef4:	dfc00215 	stw	ra,8(sp)
8111bef8:	df000115 	stw	fp,4(sp)
8111befc:	df000104 	addi	fp,sp,4
8111bf00:	2005883a 	mov	r2,r4
8111bf04:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEESyncQueue. (exit)\n");
8111bf08:	d0a06117 	ldw	r2,-32380(gp)
8111bf0c:	100f883a 	mov	r7,r2
8111bf10:	01800844 	movi	r6,33
8111bf14:	01400044 	movi	r5,1
8111bf18:	01204574 	movhi	r4,33045
8111bf1c:	213b9904 	addi	r4,r4,-4508
8111bf20:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NFEE %hhu.\n",ucID);
8111bf24:	d0a06117 	ldw	r2,-32380(gp)
8111bf28:	e0ffff03 	ldbu	r3,-4(fp)
8111bf2c:	180d883a 	mov	r6,r3
8111bf30:	01604574 	movhi	r5,33045
8111bf34:	297ba204 	addi	r5,r5,-4472
8111bf38:	1009883a 	mov	r4,r2
8111bf3c:	1121b800 	call	81121b80 <printf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bf40:	0001883a 	nop
8111bf44:	e037883a 	mov	sp,fp
8111bf48:	dfc00117 	ldw	ra,4(sp)
8111bf4c:	df000017 	ldw	fp,0(sp)
8111bf50:	dec00204 	addi	sp,sp,8
8111bf54:	f800283a 	ret

8111bf58 <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
8111bf58:	defffe04 	addi	sp,sp,-8
8111bf5c:	de00012e 	bgeu	sp,et,8111bf64 <vCoudlNotCreateNFee0Task+0xc>
8111bf60:	003b68fa 	trap	3
8111bf64:	dfc00115 	stw	ra,4(sp)
8111bf68:	df000015 	stw	fp,0(sp)
8111bf6c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee0Task. (exit)\n");
8111bf70:	d0a06117 	ldw	r2,-32380(gp)
8111bf74:	100f883a 	mov	r7,r2
8111bf78:	01800844 	movi	r6,33
8111bf7c:	01400044 	movi	r5,1
8111bf80:	01204574 	movhi	r4,33045
8111bf84:	213bb004 	addi	r4,r4,-4416
8111bf88:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 0 Task.\n");
8111bf8c:	d0a06117 	ldw	r2,-32380(gp)
8111bf90:	100f883a 	mov	r7,r2
8111bf94:	01800784 	movi	r6,30
8111bf98:	01400044 	movi	r5,1
8111bf9c:	01204574 	movhi	r4,33045
8111bfa0:	213bb904 	addi	r4,r4,-4380
8111bfa4:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111bfa8:	0001883a 	nop
8111bfac:	e037883a 	mov	sp,fp
8111bfb0:	dfc00117 	ldw	ra,4(sp)
8111bfb4:	df000017 	ldw	fp,0(sp)
8111bfb8:	dec00204 	addi	sp,sp,8
8111bfbc:	f800283a 	ret

8111bfc0 <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
8111bfc0:	defffe04 	addi	sp,sp,-8
8111bfc4:	de00012e 	bgeu	sp,et,8111bfcc <vCoudlNotCreateNFee1Task+0xc>
8111bfc8:	003b68fa 	trap	3
8111bfcc:	dfc00115 	stw	ra,4(sp)
8111bfd0:	df000015 	stw	fp,0(sp)
8111bfd4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee1Task. (exit)\n");
8111bfd8:	d0a06117 	ldw	r2,-32380(gp)
8111bfdc:	100f883a 	mov	r7,r2
8111bfe0:	01800844 	movi	r6,33
8111bfe4:	01400044 	movi	r5,1
8111bfe8:	01204574 	movhi	r4,33045
8111bfec:	213bc104 	addi	r4,r4,-4348
8111bff0:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 1 Task.\n");
8111bff4:	d0a06117 	ldw	r2,-32380(gp)
8111bff8:	100f883a 	mov	r7,r2
8111bffc:	01800784 	movi	r6,30
8111c000:	01400044 	movi	r5,1
8111c004:	01204574 	movhi	r4,33045
8111c008:	213bca04 	addi	r4,r4,-4312
8111c00c:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c010:	0001883a 	nop
8111c014:	e037883a 	mov	sp,fp
8111c018:	dfc00117 	ldw	ra,4(sp)
8111c01c:	df000017 	ldw	fp,0(sp)
8111c020:	dec00204 	addi	sp,sp,8
8111c024:	f800283a 	ret

8111c028 <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
8111c028:	defffe04 	addi	sp,sp,-8
8111c02c:	de00012e 	bgeu	sp,et,8111c034 <vCoudlNotCreateNFee2Task+0xc>
8111c030:	003b68fa 	trap	3
8111c034:	dfc00115 	stw	ra,4(sp)
8111c038:	df000015 	stw	fp,0(sp)
8111c03c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee2Task. (exit)\n");
8111c040:	d0a06117 	ldw	r2,-32380(gp)
8111c044:	100f883a 	mov	r7,r2
8111c048:	01800844 	movi	r6,33
8111c04c:	01400044 	movi	r5,1
8111c050:	01204574 	movhi	r4,33045
8111c054:	213bd204 	addi	r4,r4,-4280
8111c058:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 2 Task.\n");
8111c05c:	d0a06117 	ldw	r2,-32380(gp)
8111c060:	100f883a 	mov	r7,r2
8111c064:	01800784 	movi	r6,30
8111c068:	01400044 	movi	r5,1
8111c06c:	01204574 	movhi	r4,33045
8111c070:	213bdb04 	addi	r4,r4,-4244
8111c074:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c078:	0001883a 	nop
8111c07c:	e037883a 	mov	sp,fp
8111c080:	dfc00117 	ldw	ra,4(sp)
8111c084:	df000017 	ldw	fp,0(sp)
8111c088:	dec00204 	addi	sp,sp,8
8111c08c:	f800283a 	ret

8111c090 <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
8111c090:	defffe04 	addi	sp,sp,-8
8111c094:	de00012e 	bgeu	sp,et,8111c09c <vCoudlNotCreateNFee3Task+0xc>
8111c098:	003b68fa 	trap	3
8111c09c:	dfc00115 	stw	ra,4(sp)
8111c0a0:	df000015 	stw	fp,0(sp)
8111c0a4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee3Task. (exit)\n");
8111c0a8:	d0a06117 	ldw	r2,-32380(gp)
8111c0ac:	100f883a 	mov	r7,r2
8111c0b0:	01800844 	movi	r6,33
8111c0b4:	01400044 	movi	r5,1
8111c0b8:	01204574 	movhi	r4,33045
8111c0bc:	213be304 	addi	r4,r4,-4212
8111c0c0:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 3 Task.\n");
8111c0c4:	d0a06117 	ldw	r2,-32380(gp)
8111c0c8:	100f883a 	mov	r7,r2
8111c0cc:	01800784 	movi	r6,30
8111c0d0:	01400044 	movi	r5,1
8111c0d4:	01204574 	movhi	r4,33045
8111c0d8:	213bec04 	addi	r4,r4,-4176
8111c0dc:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c0e0:	0001883a 	nop
8111c0e4:	e037883a 	mov	sp,fp
8111c0e8:	dfc00117 	ldw	ra,4(sp)
8111c0ec:	df000017 	ldw	fp,0(sp)
8111c0f0:	dec00204 	addi	sp,sp,8
8111c0f4:	f800283a 	ret

8111c0f8 <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
8111c0f8:	defffe04 	addi	sp,sp,-8
8111c0fc:	de00012e 	bgeu	sp,et,8111c104 <vCoudlNotCreateNFee4Task+0xc>
8111c100:	003b68fa 	trap	3
8111c104:	dfc00115 	stw	ra,4(sp)
8111c108:	df000015 	stw	fp,0(sp)
8111c10c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee4Task. (exit)\n");
8111c110:	d0a06117 	ldw	r2,-32380(gp)
8111c114:	100f883a 	mov	r7,r2
8111c118:	01800844 	movi	r6,33
8111c11c:	01400044 	movi	r5,1
8111c120:	01204574 	movhi	r4,33045
8111c124:	213bf404 	addi	r4,r4,-4144
8111c128:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 4 Task.\n");
8111c12c:	d0a06117 	ldw	r2,-32380(gp)
8111c130:	100f883a 	mov	r7,r2
8111c134:	01800784 	movi	r6,30
8111c138:	01400044 	movi	r5,1
8111c13c:	01204574 	movhi	r4,33045
8111c140:	213bfd04 	addi	r4,r4,-4108
8111c144:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c148:	0001883a 	nop
8111c14c:	e037883a 	mov	sp,fp
8111c150:	dfc00117 	ldw	ra,4(sp)
8111c154:	df000017 	ldw	fp,0(sp)
8111c158:	dec00204 	addi	sp,sp,8
8111c15c:	f800283a 	ret

8111c160 <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
8111c160:	defffe04 	addi	sp,sp,-8
8111c164:	de00012e 	bgeu	sp,et,8111c16c <vCoudlNotCreateNFee5Task+0xc>
8111c168:	003b68fa 	trap	3
8111c16c:	dfc00115 	stw	ra,4(sp)
8111c170:	df000015 	stw	fp,0(sp)
8111c174:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee5Task. (exit)\n");
8111c178:	d0a06117 	ldw	r2,-32380(gp)
8111c17c:	100f883a 	mov	r7,r2
8111c180:	01800844 	movi	r6,33
8111c184:	01400044 	movi	r5,1
8111c188:	01204574 	movhi	r4,33045
8111c18c:	213c0504 	addi	r4,r4,-4076
8111c190:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 5 Task.\n");
8111c194:	d0a06117 	ldw	r2,-32380(gp)
8111c198:	100f883a 	mov	r7,r2
8111c19c:	01800784 	movi	r6,30
8111c1a0:	01400044 	movi	r5,1
8111c1a4:	01204574 	movhi	r4,33045
8111c1a8:	213c0e04 	addi	r4,r4,-4040
8111c1ac:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c1b0:	0001883a 	nop
8111c1b4:	e037883a 	mov	sp,fp
8111c1b8:	dfc00117 	ldw	ra,4(sp)
8111c1bc:	df000017 	ldw	fp,0(sp)
8111c1c0:	dec00204 	addi	sp,sp,8
8111c1c4:	f800283a 	ret

8111c1c8 <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
8111c1c8:	defffe04 	addi	sp,sp,-8
8111c1cc:	de00012e 	bgeu	sp,et,8111c1d4 <vCoudlNotCreateNFeeControllerTask+0xc>
8111c1d0:	003b68fa 	trap	3
8111c1d4:	dfc00115 	stw	ra,4(sp)
8111c1d8:	df000015 	stw	fp,0(sp)
8111c1dc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFeeControllerTask. (exit)\n");
8111c1e0:	d0a06117 	ldw	r2,-32380(gp)
8111c1e4:	100f883a 	mov	r7,r2
8111c1e8:	01800a84 	movi	r6,42
8111c1ec:	01400044 	movi	r5,1
8111c1f0:	01204574 	movhi	r4,33045
8111c1f4:	213c1604 	addi	r4,r4,-4008
8111c1f8:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE Controller Task.\n");
8111c1fc:	d0a06117 	ldw	r2,-32380(gp)
8111c200:	100f883a 	mov	r7,r2
8111c204:	018009c4 	movi	r6,39
8111c208:	01400044 	movi	r5,1
8111c20c:	01204574 	movhi	r4,33045
8111c210:	213c2104 	addi	r4,r4,-3964
8111c214:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c218:	0001883a 	nop
8111c21c:	e037883a 	mov	sp,fp
8111c220:	dfc00117 	ldw	ra,4(sp)
8111c224:	df000017 	ldw	fp,0(sp)
8111c228:	dec00204 	addi	sp,sp,8
8111c22c:	f800283a 	ret

8111c230 <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
8111c230:	defffe04 	addi	sp,sp,-8
8111c234:	de00012e 	bgeu	sp,et,8111c23c <vCoudlNotCreateDataControllerTask+0xc>
8111c238:	003b68fa 	trap	3
8111c23c:	dfc00115 	stw	ra,4(sp)
8111c240:	df000015 	stw	fp,0(sp)
8111c244:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateDataControllerTask. (exit)\n");
8111c248:	d0a06117 	ldw	r2,-32380(gp)
8111c24c:	100f883a 	mov	r7,r2
8111c250:	01800a84 	movi	r6,42
8111c254:	01400044 	movi	r5,1
8111c258:	01204574 	movhi	r4,33045
8111c25c:	213c2b04 	addi	r4,r4,-3924
8111c260:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Data Controller Task.\n");
8111c264:	d0a06117 	ldw	r2,-32380(gp)
8111c268:	100f883a 	mov	r7,r2
8111c26c:	018009c4 	movi	r6,39
8111c270:	01400044 	movi	r5,1
8111c274:	01204574 	movhi	r4,33045
8111c278:	213c3604 	addi	r4,r4,-3880
8111c27c:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c280:	0001883a 	nop
8111c284:	e037883a 	mov	sp,fp
8111c288:	dfc00117 	ldw	ra,4(sp)
8111c28c:	df000017 	ldw	fp,0(sp)
8111c290:	dec00204 	addi	sp,sp,8
8111c294:	f800283a 	ret

8111c298 <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
8111c298:	defffe04 	addi	sp,sp,-8
8111c29c:	de00012e 	bgeu	sp,et,8111c2a4 <vCoudlNotCreateMebTask+0xc>
8111c2a0:	003b68fa 	trap	3
8111c2a4:	dfc00115 	stw	ra,4(sp)
8111c2a8:	df000015 	stw	fp,0(sp)
8111c2ac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateMebTask. (exit)\n");
8111c2b0:	d0a06117 	ldw	r2,-32380(gp)
8111c2b4:	100f883a 	mov	r7,r2
8111c2b8:	018007c4 	movi	r6,31
8111c2bc:	01400044 	movi	r5,1
8111c2c0:	01204574 	movhi	r4,33045
8111c2c4:	213c4004 	addi	r4,r4,-3840
8111c2c8:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Meb Task.\n");
8111c2cc:	d0a06117 	ldw	r2,-32380(gp)
8111c2d0:	100f883a 	mov	r7,r2
8111c2d4:	018006c4 	movi	r6,27
8111c2d8:	01400044 	movi	r5,1
8111c2dc:	01204574 	movhi	r4,33045
8111c2e0:	213c4804 	addi	r4,r4,-3808
8111c2e4:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c2e8:	0001883a 	nop
8111c2ec:	e037883a 	mov	sp,fp
8111c2f0:	dfc00117 	ldw	ra,4(sp)
8111c2f4:	df000017 	ldw	fp,0(sp)
8111c2f8:	dec00204 	addi	sp,sp,8
8111c2fc:	f800283a 	ret

8111c300 <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
8111c300:	defffd04 	addi	sp,sp,-12
8111c304:	de00012e 	bgeu	sp,et,8111c30c <vFailCreateMutexSPUSQueueMeb+0xc>
8111c308:	003b68fa 	trap	3
8111c30c:	dfc00215 	stw	ra,8(sp)
8111c310:	df000115 	stw	fp,4(sp)
8111c314:	df000104 	addi	fp,sp,4
8111c318:	2005883a 	mov	r2,r4
8111c31c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSPUSQueueMeb. (exit)\n");
8111c320:	d0a06117 	ldw	r2,-32380(gp)
8111c324:	100f883a 	mov	r7,r2
8111c328:	01800944 	movi	r6,37
8111c32c:	01400044 	movi	r5,1
8111c330:	01204574 	movhi	r4,33045
8111c334:	213c4f04 	addi	r4,r4,-3780
8111c338:	1120e540 	call	81120e54 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
8111c33c:	e0bfff03 	ldbu	r2,-4(fp)
8111c340:	1009883a 	mov	r4,r2
8111c344:	111aaac0 	call	8111aaac <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c348:	0001883a 	nop
8111c34c:	e037883a 	mov	sp,fp
8111c350:	dfc00117 	ldw	ra,4(sp)
8111c354:	df000017 	ldw	fp,0(sp)
8111c358:	dec00204 	addi	sp,sp,8
8111c35c:	f800283a 	ret

8111c360 <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
8111c360:	defffe04 	addi	sp,sp,-8
8111c364:	de00012e 	bgeu	sp,et,8111c36c <vFailSendPUStoMebTask+0xc>
8111c368:	003b68fa 	trap	3
8111c36c:	dfc00115 	stw	ra,4(sp)
8111c370:	df000015 	stw	fp,0(sp)
8111c374:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPUStoMebTask. (exit)\n");
8111c378:	d0a06117 	ldw	r2,-32380(gp)
8111c37c:	100f883a 	mov	r7,r2
8111c380:	01800784 	movi	r6,30
8111c384:	01400044 	movi	r5,1
8111c388:	01204574 	movhi	r4,33045
8111c38c:	213c5904 	addi	r4,r4,-3740
8111c390:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c394:	0001883a 	nop
8111c398:	e037883a 	mov	sp,fp
8111c39c:	dfc00117 	ldw	ra,4(sp)
8111c3a0:	df000017 	ldw	fp,0(sp)
8111c3a4:	dec00204 	addi	sp,sp,8
8111c3a8:	f800283a 	ret

8111c3ac <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
8111c3ac:	defffe04 	addi	sp,sp,-8
8111c3b0:	de00012e 	bgeu	sp,et,8111c3b8 <vCouldNotGetCmdQueueMeb+0xc>
8111c3b4:	003b68fa 	trap	3
8111c3b8:	dfc00115 	stw	ra,4(sp)
8111c3bc:	df000015 	stw	fp,0(sp)
8111c3c0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vCouldNotGetCmdQueueMeb. (exit)\n");
8111c3c4:	d0a06117 	ldw	r2,-32380(gp)
8111c3c8:	100f883a 	mov	r7,r2
8111c3cc:	01800a84 	movi	r6,42
8111c3d0:	01400044 	movi	r5,1
8111c3d4:	01204574 	movhi	r4,33045
8111c3d8:	213c6104 	addi	r4,r4,-3708
8111c3dc:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get COmmand from Queue in the Meb Task. \n");
8111c3e0:	d0a06117 	ldw	r2,-32380(gp)
8111c3e4:	100f883a 	mov	r7,r2
8111c3e8:	01800cc4 	movi	r6,51
8111c3ec:	01400044 	movi	r5,1
8111c3f0:	01204574 	movhi	r4,33045
8111c3f4:	213c6c04 	addi	r4,r4,-3664
8111c3f8:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c3fc:	0001883a 	nop
8111c400:	e037883a 	mov	sp,fp
8111c404:	dfc00117 	ldw	ra,4(sp)
8111c408:	df000017 	ldw	fp,0(sp)
8111c40c:	dec00204 	addi	sp,sp,8
8111c410:	f800283a 	ret

8111c414 <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
8111c414:	defffe04 	addi	sp,sp,-8
8111c418:	de00012e 	bgeu	sp,et,8111c420 <vCouldNotGetMutexMebPus+0xc>
8111c41c:	003b68fa 	trap	3
8111c420:	dfc00115 	stw	ra,4(sp)
8111c424:	df000015 	stw	fp,0(sp)
8111c428:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetMutexMebPus. (exit)\n");
8111c42c:	d0a06117 	ldw	r2,-32380(gp)
8111c430:	100f883a 	mov	r7,r2
8111c434:	01800804 	movi	r6,32
8111c438:	01400044 	movi	r5,1
8111c43c:	01204574 	movhi	r4,33045
8111c440:	213c7904 	addi	r4,r4,-3612
8111c444:	1120e540 	call	81120e54 <fwrite>
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c448:	0001883a 	nop
8111c44c:	e037883a 	mov	sp,fp
8111c450:	dfc00117 	ldw	ra,4(sp)
8111c454:	df000017 	ldw	fp,0(sp)
8111c458:	dec00204 	addi	sp,sp,8
8111c45c:	f800283a 	ret

8111c460 <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
8111c460:	defffe04 	addi	sp,sp,-8
8111c464:	de00012e 	bgeu	sp,et,8111c46c <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
8111c468:	003b68fa 	trap	3
8111c46c:	dfc00115 	stw	ra,4(sp)
8111c470:	df000015 	stw	fp,0(sp)
8111c474:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskNfeeCtrl. (exit)\n");
8111c478:	d0a06117 	ldw	r2,-32380(gp)
8111c47c:	100f883a 	mov	r7,r2
8111c480:	01800a44 	movi	r6,41
8111c484:	01400044 	movi	r5,1
8111c488:	01204574 	movhi	r4,33045
8111c48c:	213c8204 	addi	r4,r4,-3576
8111c490:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for NFEE Controller. \n");
8111c494:	d0a06117 	ldw	r2,-32380(gp)
8111c498:	100f883a 	mov	r7,r2
8111c49c:	01800c84 	movi	r6,50
8111c4a0:	01400044 	movi	r5,1
8111c4a4:	01204574 	movhi	r4,33045
8111c4a8:	213c8d04 	addi	r4,r4,-3532
8111c4ac:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c4b0:	0001883a 	nop
8111c4b4:	e037883a 	mov	sp,fp
8111c4b8:	dfc00117 	ldw	ra,4(sp)
8111c4bc:	df000017 	ldw	fp,0(sp)
8111c4c0:	dec00204 	addi	sp,sp,8
8111c4c4:	f800283a 	ret

8111c4c8 <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
8111c4c8:	defffe04 	addi	sp,sp,-8
8111c4cc:	de00012e 	bgeu	sp,et,8111c4d4 <vCouldNotCreateQueueMaskDataCtrl+0xc>
8111c4d0:	003b68fa 	trap	3
8111c4d4:	dfc00115 	stw	ra,4(sp)
8111c4d8:	df000015 	stw	fp,0(sp)
8111c4dc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskDataCtrl. (exit)\n");
8111c4e0:	d0a06117 	ldw	r2,-32380(gp)
8111c4e4:	100f883a 	mov	r7,r2
8111c4e8:	01800a44 	movi	r6,41
8111c4ec:	01400044 	movi	r5,1
8111c4f0:	01204574 	movhi	r4,33045
8111c4f4:	213c9a04 	addi	r4,r4,-3480
8111c4f8:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for Data Controller. \n");
8111c4fc:	d0a06117 	ldw	r2,-32380(gp)
8111c500:	100f883a 	mov	r7,r2
8111c504:	01800c84 	movi	r6,50
8111c508:	01400044 	movi	r5,1
8111c50c:	01204574 	movhi	r4,33045
8111c510:	213ca504 	addi	r4,r4,-3436
8111c514:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c518:	0001883a 	nop
8111c51c:	e037883a 	mov	sp,fp
8111c520:	dfc00117 	ldw	ra,4(sp)
8111c524:	df000017 	ldw	fp,0(sp)
8111c528:	dec00204 	addi	sp,sp,8
8111c52c:	f800283a 	ret

8111c530 <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
8111c530:	defffe04 	addi	sp,sp,-8
8111c534:	de00012e 	bgeu	sp,et,8111c53c <vCouldNotGetQueueMaskNfeeCtrl+0xc>
8111c538:	003b68fa 	trap	3
8111c53c:	dfc00115 	stw	ra,4(sp)
8111c540:	df000015 	stw	fp,0(sp)
8111c544:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskNfeeCtrl. (exit)\n");
8111c548:	d0a06117 	ldw	r2,-32380(gp)
8111c54c:	100f883a 	mov	r7,r2
8111c550:	01800984 	movi	r6,38
8111c554:	01400044 	movi	r5,1
8111c558:	01204574 	movhi	r4,33045
8111c55c:	213cb204 	addi	r4,r4,-3384
8111c560:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for NFEE Controller. \n");
8111c564:	d0a06117 	ldw	r2,-32380(gp)
8111c568:	100f883a 	mov	r7,r2
8111c56c:	01800bc4 	movi	r6,47
8111c570:	01400044 	movi	r5,1
8111c574:	01204574 	movhi	r4,33045
8111c578:	213cbc04 	addi	r4,r4,-3344
8111c57c:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c580:	0001883a 	nop
8111c584:	e037883a 	mov	sp,fp
8111c588:	dfc00117 	ldw	ra,4(sp)
8111c58c:	df000017 	ldw	fp,0(sp)
8111c590:	dec00204 	addi	sp,sp,8
8111c594:	f800283a 	ret

8111c598 <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
8111c598:	defffe04 	addi	sp,sp,-8
8111c59c:	de00012e 	bgeu	sp,et,8111c5a4 <vCouldNotGetQueueMaskDataCtrl+0xc>
8111c5a0:	003b68fa 	trap	3
8111c5a4:	dfc00115 	stw	ra,4(sp)
8111c5a8:	df000015 	stw	fp,0(sp)
8111c5ac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskDataCtrl. (exit)\n");
8111c5b0:	d0a06117 	ldw	r2,-32380(gp)
8111c5b4:	100f883a 	mov	r7,r2
8111c5b8:	01800984 	movi	r6,38
8111c5bc:	01400044 	movi	r5,1
8111c5c0:	01204574 	movhi	r4,33045
8111c5c4:	213cc804 	addi	r4,r4,-3296
8111c5c8:	1120e540 	call	81120e54 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for Data Controller. \n");
8111c5cc:	d0a06117 	ldw	r2,-32380(gp)
8111c5d0:	100f883a 	mov	r7,r2
8111c5d4:	01800bc4 	movi	r6,47
8111c5d8:	01400044 	movi	r5,1
8111c5dc:	01204574 	movhi	r4,33045
8111c5e0:	213cd204 	addi	r4,r4,-3256
8111c5e4:	1120e540 	call	81120e54 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c5e8:	0001883a 	nop
8111c5ec:	e037883a 	mov	sp,fp
8111c5f0:	dfc00117 	ldw	ra,4(sp)
8111c5f4:	df000017 	ldw	fp,0(sp)
8111c5f8:	dec00204 	addi	sp,sp,8
8111c5fc:	f800283a 	ret

8111c600 <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
8111c600:	defffd04 	addi	sp,sp,-12
8111c604:	de00012e 	bgeu	sp,et,8111c60c <vFailSendMsgAccessDMA+0xc>
8111c608:	003b68fa 	trap	3
8111c60c:	dfc00215 	stw	ra,8(sp)
8111c610:	df000115 	stw	fp,4(sp)
8111c614:	df000104 	addi	fp,sp,4
8111c618:	2005883a 	mov	r2,r4
8111c61c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgAccessDMA. FEE n: \n", ucTemp);
8111c620:	d0a06117 	ldw	r2,-32380(gp)
8111c624:	e0ffff03 	ldbu	r3,-4(fp)
8111c628:	180d883a 	mov	r6,r3
8111c62c:	01604574 	movhi	r5,33045
8111c630:	297cde04 	addi	r5,r5,-3208
8111c634:	1009883a 	mov	r4,r2
8111c638:	11207b80 	call	811207b8 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c63c:	0001883a 	nop
8111c640:	e037883a 	mov	sp,fp
8111c644:	dfc00117 	ldw	ra,4(sp)
8111c648:	df000017 	ldw	fp,0(sp)
8111c64c:	dec00204 	addi	sp,sp,8
8111c650:	f800283a 	ret

8111c654 <vFailRequestDMA>:

void vFailRequestDMA( unsigned char ucTemp)
{
8111c654:	defffd04 	addi	sp,sp,-12
8111c658:	de00012e 	bgeu	sp,et,8111c660 <vFailRequestDMA+0xc>
8111c65c:	003b68fa 	trap	3
8111c660:	dfc00215 	stw	ra,8(sp)
8111c664:	df000115 	stw	fp,4(sp)
8111c668:	df000104 	addi	fp,sp,4
8111c66c:	2005883a 	mov	r2,r4
8111c670:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
8111c674:	d0a06117 	ldw	r2,-32380(gp)
8111c678:	e0ffff03 	ldbu	r3,-4(fp)
8111c67c:	180d883a 	mov	r6,r3
8111c680:	01604574 	movhi	r5,33045
8111c684:	297ce604 	addi	r5,r5,-3176
8111c688:	1009883a 	mov	r4,r2
8111c68c:	11207b80 	call	811207b8 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c690:	0001883a 	nop
8111c694:	e037883a 	mov	sp,fp
8111c698:	dfc00117 	ldw	ra,4(sp)
8111c69c:	df000017 	ldw	fp,0(sp)
8111c6a0:	dec00204 	addi	sp,sp,8
8111c6a4:	f800283a 	ret

8111c6a8 <vFailRequestDMAFromIRQ>:

void vFailRequestDMAFromIRQ( unsigned char ucTemp)
{
8111c6a8:	defffd04 	addi	sp,sp,-12
8111c6ac:	de00012e 	bgeu	sp,et,8111c6b4 <vFailRequestDMAFromIRQ+0xc>
8111c6b0:	003b68fa 	trap	3
8111c6b4:	dfc00215 	stw	ra,8(sp)
8111c6b8:	df000115 	stw	fp,4(sp)
8111c6bc:	df000104 	addi	fp,sp,4
8111c6c0:	2005883a 	mov	r2,r4
8111c6c4:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
8111c6c8:	d0a06117 	ldw	r2,-32380(gp)
8111c6cc:	e0ffff03 	ldbu	r3,-4(fp)
8111c6d0:	180d883a 	mov	r6,r3
8111c6d4:	01604574 	movhi	r5,33045
8111c6d8:	297ce604 	addi	r5,r5,-3176
8111c6dc:	1009883a 	mov	r4,r2
8111c6e0:	11207b80 	call	811207b8 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c6e4:	0001883a 	nop
8111c6e8:	e037883a 	mov	sp,fp
8111c6ec:	dfc00117 	ldw	ra,4(sp)
8111c6f0:	df000017 	ldw	fp,0(sp)
8111c6f4:	dec00204 	addi	sp,sp,8
8111c6f8:	f800283a 	ret

8111c6fc <vFailSendRMAPFromIRQ>:


void vFailSendRMAPFromIRQ( unsigned char ucTemp)
{
8111c6fc:	defffd04 	addi	sp,sp,-12
8111c700:	de00012e 	bgeu	sp,et,8111c708 <vFailSendRMAPFromIRQ+0xc>
8111c704:	003b68fa 	trap	3
8111c708:	dfc00215 	stw	ra,8(sp)
8111c70c:	df000115 	stw	fp,4(sp)
8111c710:	df000104 	addi	fp,sp,4
8111c714:	2005883a 	mov	r2,r4
8111c718:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendRMAPFromIRQ. FEE n: \n", ucTemp);
8111c71c:	d0a06117 	ldw	r2,-32380(gp)
8111c720:	e0ffff03 	ldbu	r3,-4(fp)
8111c724:	180d883a 	mov	r6,r3
8111c728:	01604574 	movhi	r5,33045
8111c72c:	297ced04 	addi	r5,r5,-3148
8111c730:	1009883a 	mov	r4,r2
8111c734:	11207b80 	call	811207b8 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c738:	0001883a 	nop
8111c73c:	e037883a 	mov	sp,fp
8111c740:	dfc00117 	ldw	ra,4(sp)
8111c744:	df000017 	ldw	fp,0(sp)
8111c748:	dec00204 	addi	sp,sp,8
8111c74c:	f800283a 	ret

8111c750 <vFailSendMsgSync>:


void vFailSendMsgSync( unsigned char ucTemp)
{
8111c750:	defffd04 	addi	sp,sp,-12
8111c754:	de00012e 	bgeu	sp,et,8111c75c <vFailSendMsgSync+0xc>
8111c758:	003b68fa 	trap	3
8111c75c:	dfc00215 	stw	ra,8(sp)
8111c760:	df000115 	stw	fp,4(sp)
8111c764:	df000104 	addi	fp,sp,4
8111c768:	2005883a 	mov	r2,r4
8111c76c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSync. FEE n: \n", ucTemp);
8111c770:	d0a06117 	ldw	r2,-32380(gp)
8111c774:	e0ffff03 	ldbu	r3,-4(fp)
8111c778:	180d883a 	mov	r6,r3
8111c77c:	01604574 	movhi	r5,33045
8111c780:	297cf504 	addi	r5,r5,-3116
8111c784:	1009883a 	mov	r4,r2
8111c788:	11207b80 	call	811207b8 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c78c:	0001883a 	nop
8111c790:	e037883a 	mov	sp,fp
8111c794:	dfc00117 	ldw	ra,4(sp)
8111c798:	df000017 	ldw	fp,0(sp)
8111c79c:	dec00204 	addi	sp,sp,8
8111c7a0:	f800283a 	ret

8111c7a4 <vFailSendMsgSyncRMAPTRIGGER>:

void vFailSendMsgSyncRMAPTRIGGER( unsigned char ucTemp)
{
8111c7a4:	defffd04 	addi	sp,sp,-12
8111c7a8:	de00012e 	bgeu	sp,et,8111c7b0 <vFailSendMsgSyncRMAPTRIGGER+0xc>
8111c7ac:	003b68fa 	trap	3
8111c7b0:	dfc00215 	stw	ra,8(sp)
8111c7b4:	df000115 	stw	fp,4(sp)
8111c7b8:	df000104 	addi	fp,sp,4
8111c7bc:	2005883a 	mov	r2,r4
8111c7c0:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSyncRMAPTRIGGER (FORCED MODE). FEE n: \n", ucTemp);
8111c7c4:	d0a06117 	ldw	r2,-32380(gp)
8111c7c8:	e0ffff03 	ldbu	r3,-4(fp)
8111c7cc:	180d883a 	mov	r6,r3
8111c7d0:	01604574 	movhi	r5,33045
8111c7d4:	297cfc04 	addi	r5,r5,-3088
8111c7d8:	1009883a 	mov	r4,r2
8111c7dc:	11207b80 	call	811207b8 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c7e0:	0001883a 	nop
8111c7e4:	e037883a 	mov	sp,fp
8111c7e8:	dfc00117 	ldw	ra,4(sp)
8111c7ec:	df000017 	ldw	fp,0(sp)
8111c7f0:	dec00204 	addi	sp,sp,8
8111c7f4:	f800283a 	ret

8111c7f8 <vFailSendMsgMasterSyncMeb>:

void vFailSendMsgMasterSyncMeb( void )
{
8111c7f8:	defffe04 	addi	sp,sp,-8
8111c7fc:	de00012e 	bgeu	sp,et,8111c804 <vFailSendMsgMasterSyncMeb+0xc>
8111c800:	003b68fa 	trap	3
8111c804:	dfc00115 	stw	ra,4(sp)
8111c808:	df000015 	stw	fp,0(sp)
8111c80c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgMasterSyncMeb \n");
8111c810:	d0a06117 	ldw	r2,-32380(gp)
8111c814:	100f883a 	mov	r7,r2
8111c818:	018006c4 	movi	r6,27
8111c81c:	01400044 	movi	r5,1
8111c820:	01204574 	movhi	r4,33045
8111c824:	213d0904 	addi	r4,r4,-3036
8111c828:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c82c:	0001883a 	nop
8111c830:	e037883a 	mov	sp,fp
8111c834:	dfc00117 	ldw	ra,4(sp)
8111c838:	df000017 	ldw	fp,0(sp)
8111c83c:	dec00204 	addi	sp,sp,8
8111c840:	f800283a 	ret

8111c844 <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
8111c844:	defffe04 	addi	sp,sp,-8
8111c848:	de00012e 	bgeu	sp,et,8111c850 <vFailSendMsgFeeCTRL+0xc>
8111c84c:	003b68fa 	trap	3
8111c850:	dfc00115 	stw	ra,4(sp)
8111c854:	df000015 	stw	fp,0(sp)
8111c858:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgFeeCTRL.  \n");
8111c85c:	d0a06117 	ldw	r2,-32380(gp)
8111c860:	100f883a 	mov	r7,r2
8111c864:	018005c4 	movi	r6,23
8111c868:	01400044 	movi	r5,1
8111c86c:	01204574 	movhi	r4,33045
8111c870:	213d1004 	addi	r4,r4,-3008
8111c874:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c878:	0001883a 	nop
8111c87c:	e037883a 	mov	sp,fp
8111c880:	dfc00117 	ldw	ra,4(sp)
8111c884:	df000017 	ldw	fp,0(sp)
8111c888:	dec00204 	addi	sp,sp,8
8111c88c:	f800283a 	ret

8111c890 <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
8111c890:	defffe04 	addi	sp,sp,-8
8111c894:	de00012e 	bgeu	sp,et,8111c89c <vFailSendMsgDataCTRL+0xc>
8111c898:	003b68fa 	trap	3
8111c89c:	dfc00115 	stw	ra,4(sp)
8111c8a0:	df000015 	stw	fp,0(sp)
8111c8a4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgDataCTRL.  \n");
8111c8a8:	d0a06117 	ldw	r2,-32380(gp)
8111c8ac:	100f883a 	mov	r7,r2
8111c8b0:	01800604 	movi	r6,24
8111c8b4:	01400044 	movi	r5,1
8111c8b8:	01204574 	movhi	r4,33045
8111c8bc:	213d1604 	addi	r4,r4,-2984
8111c8c0:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c8c4:	0001883a 	nop
8111c8c8:	e037883a 	mov	sp,fp
8111c8cc:	dfc00117 	ldw	ra,4(sp)
8111c8d0:	df000017 	ldw	fp,0(sp)
8111c8d4:	dec00204 	addi	sp,sp,8
8111c8d8:	f800283a 	ret

8111c8dc <vFailFlushQueue>:

void vFailFlushQueue( void )
{
8111c8dc:	defffe04 	addi	sp,sp,-8
8111c8e0:	de00012e 	bgeu	sp,et,8111c8e8 <vFailFlushQueue+0xc>
8111c8e4:	003b68fa 	trap	3
8111c8e8:	dfc00115 	stw	ra,4(sp)
8111c8ec:	df000015 	stw	fp,0(sp)
8111c8f0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueue.  \n");
8111c8f4:	d0a06117 	ldw	r2,-32380(gp)
8111c8f8:	100f883a 	mov	r7,r2
8111c8fc:	01800744 	movi	r6,29
8111c900:	01400044 	movi	r5,1
8111c904:	01204574 	movhi	r4,33045
8111c908:	213d1d04 	addi	r4,r4,-2956
8111c90c:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c910:	0001883a 	nop
8111c914:	e037883a 	mov	sp,fp
8111c918:	dfc00117 	ldw	ra,4(sp)
8111c91c:	df000017 	ldw	fp,0(sp)
8111c920:	dec00204 	addi	sp,sp,8
8111c924:	f800283a 	ret

8111c928 <vFailFlushQueueData>:

void vFailFlushQueueData( void )
{
8111c928:	defffe04 	addi	sp,sp,-8
8111c92c:	de00012e 	bgeu	sp,et,8111c934 <vFailFlushQueueData+0xc>
8111c930:	003b68fa 	trap	3
8111c934:	dfc00115 	stw	ra,4(sp)
8111c938:	df000015 	stw	fp,0(sp)
8111c93c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueueData.  \n");
8111c940:	d0a06117 	ldw	r2,-32380(gp)
8111c944:	100f883a 	mov	r7,r2
8111c948:	01800844 	movi	r6,33
8111c94c:	01400044 	movi	r5,1
8111c950:	01204574 	movhi	r4,33045
8111c954:	213d2504 	addi	r4,r4,-2924
8111c958:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c95c:	0001883a 	nop
8111c960:	e037883a 	mov	sp,fp
8111c964:	dfc00117 	ldw	ra,4(sp)
8111c968:	df000017 	ldw	fp,0(sp)
8111c96c:	dec00204 	addi	sp,sp,8
8111c970:	f800283a 	ret

8111c974 <vFailFlushMEBQueue>:


void vFailFlushMEBQueue( void )
{
8111c974:	defffe04 	addi	sp,sp,-8
8111c978:	de00012e 	bgeu	sp,et,8111c980 <vFailFlushMEBQueue+0xc>
8111c97c:	003b68fa 	trap	3
8111c980:	dfc00115 	stw	ra,4(sp)
8111c984:	df000015 	stw	fp,0(sp)
8111c988:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushMEBQueue.  \n");
8111c98c:	d0a06117 	ldw	r2,-32380(gp)
8111c990:	100f883a 	mov	r7,r2
8111c994:	01800804 	movi	r6,32
8111c998:	01400044 	movi	r5,1
8111c99c:	01204574 	movhi	r4,33045
8111c9a0:	213d2e04 	addi	r4,r4,-2888
8111c9a4:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c9a8:	0001883a 	nop
8111c9ac:	e037883a 	mov	sp,fp
8111c9b0:	dfc00117 	ldw	ra,4(sp)
8111c9b4:	df000017 	ldw	fp,0(sp)
8111c9b8:	dec00204 	addi	sp,sp,8
8111c9bc:	f800283a 	ret

8111c9c0 <vFailFlushNFEEQueue>:

void vFailFlushNFEEQueue( void )
{
8111c9c0:	defffe04 	addi	sp,sp,-8
8111c9c4:	de00012e 	bgeu	sp,et,8111c9cc <vFailFlushNFEEQueue+0xc>
8111c9c8:	003b68fa 	trap	3
8111c9cc:	dfc00115 	stw	ra,4(sp)
8111c9d0:	df000015 	stw	fp,0(sp)
8111c9d4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushNFEEQueue.  \n");
8111c9d8:	d0a06117 	ldw	r2,-32380(gp)
8111c9dc:	100f883a 	mov	r7,r2
8111c9e0:	01800844 	movi	r6,33
8111c9e4:	01400044 	movi	r5,1
8111c9e8:	01204574 	movhi	r4,33045
8111c9ec:	213d3704 	addi	r4,r4,-2852
8111c9f0:	1120e540 	call	81120e54 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111c9f4:	0001883a 	nop
8111c9f8:	e037883a 	mov	sp,fp
8111c9fc:	dfc00117 	ldw	ra,4(sp)
8111ca00:	df000017 	ldw	fp,0(sp)
8111ca04:	dec00204 	addi	sp,sp,8
8111ca08:	f800283a 	ret

8111ca0c <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( void ) {
8111ca0c:	deffff04 	addi	sp,sp,-4
8111ca10:	de00012e 	bgeu	sp,et,8111ca18 <vEvtChangeMebMode+0xc>
8111ca14:	003b68fa 	trap	3
8111ca18:	df000015 	stw	fp,0(sp)
8111ca1c:	d839883a 	mov	fp,sp

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111ca20:	0001883a 	nop
8111ca24:	e037883a 	mov	sp,fp
8111ca28:	df000017 	ldw	fp,0(sp)
8111ca2c:	dec00104 	addi	sp,sp,4
8111ca30:	f800283a 	ret

8111ca34 <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( void ) {
8111ca34:	deffff04 	addi	sp,sp,-4
8111ca38:	de00012e 	bgeu	sp,et,8111ca40 <vEvtChangeFeeControllerMode+0xc>
8111ca3c:	003b68fa 	trap	3
8111ca40:	df000015 	stw	fp,0(sp)
8111ca44:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111ca48:	0001883a 	nop
8111ca4c:	e037883a 	mov	sp,fp
8111ca50:	df000017 	ldw	fp,0(sp)
8111ca54:	dec00104 	addi	sp,sp,4
8111ca58:	f800283a 	ret

8111ca5c <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( void ) {
8111ca5c:	deffff04 	addi	sp,sp,-4
8111ca60:	de00012e 	bgeu	sp,et,8111ca68 <vEvtChangeDataControllerMode+0xc>
8111ca64:	003b68fa 	trap	3
8111ca68:	df000015 	stw	fp,0(sp)
8111ca6c:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111ca70:	0001883a 	nop
8111ca74:	e037883a 	mov	sp,fp
8111ca78:	df000017 	ldw	fp,0(sp)
8111ca7c:	dec00104 	addi	sp,sp,4
8111ca80:	f800283a 	ret

8111ca84 <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111ca84:	defffd04 	addi	sp,sp,-12
8111ca88:	de00012e 	bgeu	sp,et,8111ca90 <vNFeeNotInUse+0xc>
8111ca8c:	003b68fa 	trap	3
8111ca90:	df000215 	stw	fp,8(sp)
8111ca94:	df000204 	addi	fp,sp,8
8111ca98:	e13ffe15 	stw	r4,-8(fp)
8111ca9c:	2805883a 	mov	r2,r5
8111caa0:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
8111caa4:	e0bffe17 	ldw	r2,-8(fp)
8111caa8:	e0ffff03 	ldbu	r3,-4(fp)
8111caac:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
8111cab0:	e0bffe17 	ldw	r2,-8(fp)
8111cab4:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111cab8:	e0bffe17 	ldw	r2,-8(fp)
8111cabc:	10002315 	stw	zero,140(r2)
}
8111cac0:	0001883a 	nop
8111cac4:	e037883a 	mov	sp,fp
8111cac8:	df000017 	ldw	fp,0(sp)
8111cacc:	dec00104 	addi	sp,sp,4
8111cad0:	f800283a 	ret

8111cad4 <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111cad4:	defffb04 	addi	sp,sp,-20
8111cad8:	de00012e 	bgeu	sp,et,8111cae0 <vNFeeStructureInit+0xc>
8111cadc:	003b68fa 	trap	3
8111cae0:	dfc00415 	stw	ra,16(sp)
8111cae4:	df000315 	stw	fp,12(sp)
8111cae8:	df000304 	addi	fp,sp,12
8111caec:	e13ffe15 	stw	r4,-8(fp)
8111caf0:	2805883a 	mov	r2,r5
8111caf4:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
8111caf8:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
8111cafc:	e0bffe17 	ldw	r2,-8(fp)
8111cb00:	e0ffff03 	ldbu	r3,-4(fp)
8111cb04:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
8111cb08:	e0bffe17 	ldw	r2,-8(fp)
8111cb0c:	10802f04 	addi	r2,r2,188
8111cb10:	1009883a 	mov	r4,r2
8111cb14:	11179f80 	call	811179f8 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
8111cb18:	e13ffe17 	ldw	r4,-8(fp)
8111cb1c:	111ccb40 	call	8111ccb4 <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
8111cb20:	e0bffe17 	ldw	r2,-8(fp)
8111cb24:	00c00044 	movi	r3,1
8111cb28:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111cb2c:	e0bffe17 	ldw	r2,-8(fp)
8111cb30:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
8111cb34:	e0bffe17 	ldw	r2,-8(fp)
8111cb38:	10002615 	stw	zero,152(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
8111cb3c:	e0bffe17 	ldw	r2,-8(fp)
8111cb40:	10002715 	stw	zero,156(r2)
    pxNfeeL->xControl.bWatingSync = FALSE;
8111cb44:	e0bffe17 	ldw	r2,-8(fp)
8111cb48:	10002815 	stw	zero,160(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
8111cb4c:	e0bffe17 	ldw	r2,-8(fp)
8111cb50:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bLogging = FALSE;
8111cb54:	e0bffe17 	ldw	r2,-8(fp)
8111cb58:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bDMALocked = FALSE;
8111cb5c:	e0bffe17 	ldw	r2,-8(fp)
8111cb60:	10002215 	stw	zero,136(r2)
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
8111cb64:	e0bffe17 	ldw	r2,-8(fp)
8111cb68:	10002e15 	stw	zero,184(r2)
    pxNfeeL->xControl.ucTimeCode = 0;
8111cb6c:	e0bffe17 	ldw	r2,-8(fp)
8111cb70:	10002a05 	stb	zero,168(r2)
    

    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
8111cb74:	e0bffe17 	ldw	r2,-8(fp)
8111cb78:	10002c15 	stw	zero,176(r2)
    pxNfeeL->xControl.eNextMode = sFeeInit;
8111cb7c:	e0bffe17 	ldw	r2,-8(fp)
8111cb80:	10002d15 	stw	zero,180(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111cb84:	e03ffd05 	stb	zero,-12(fp)
8111cb88:	00000906 	br	8111cbb0 <vNFeeStructureInit+0xdc>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
8111cb8c:	e0bffd03 	ldbu	r2,-12(fp)
8111cb90:	e0fffe17 	ldw	r3,-8(fp)
8111cb94:	1885883a 	add	r2,r3,r2
8111cb98:	10802a44 	addi	r2,r2,169
8111cb9c:	e0fffd03 	ldbu	r3,-12(fp)
8111cba0:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111cba4:	e0bffd03 	ldbu	r2,-12(fp)
8111cba8:	10800044 	addi	r2,r2,1
8111cbac:	e0bffd05 	stb	r2,-12(fp)
8111cbb0:	e0bffd03 	ldbu	r2,-12(fp)
8111cbb4:	10800130 	cmpltui	r2,r2,4
8111cbb8:	103ff41e 	bne	r2,zero,8111cb8c <__reset+0xfb0fcb8c>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;

    /* Initialize the structs of the Channel, Double Buffer, RMAP and Data packet */
    if ( bCommInitCh(&pxNfeeL->xChannel, ucIdNFEE ) == FALSE ) {
8111cbbc:	e0bffe17 	ldw	r2,-8(fp)
8111cbc0:	10803204 	addi	r2,r2,200
8111cbc4:	e0ffff03 	ldbu	r3,-4(fp)
8111cbc8:	180b883a 	mov	r5,r3
8111cbcc:	1009883a 	mov	r4,r2
8111cbd0:	11046980 	call	81104698 <bCommInitCh>
8111cbd4:	1000091e 	bne	r2,zero,8111cbfc <vNFeeStructureInit+0x128>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Initialized SPW Channel %i \n", pxNfeeL->ucId);
8111cbd8:	d0e06117 	ldw	r3,-32380(gp)
8111cbdc:	e0bffe17 	ldw	r2,-8(fp)
8111cbe0:	10800003 	ldbu	r2,0(r2)
8111cbe4:	10803fcc 	andi	r2,r2,255
8111cbe8:	100d883a 	mov	r6,r2
8111cbec:	01604574 	movhi	r5,33045
8111cbf0:	297d4004 	addi	r5,r5,-2816
8111cbf4:	1809883a 	mov	r4,r3
8111cbf8:	11207b80 	call	811207b8 <fprintf>
		#endif
    }

    if ( bCommSetGlobalIrqEn( TRUE, ucIdNFEE ) == FALSE ) {
8111cbfc:	e0bfff03 	ldbu	r2,-4(fp)
8111cc00:	100b883a 	mov	r5,r2
8111cc04:	01000044 	movi	r4,1
8111cc08:	110452c0 	call	8110452c <bCommSetGlobalIrqEn>
8111cc0c:	1000091e 	bne	r2,zero,8111cc34 <vNFeeStructureInit+0x160>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Enable global interrupt for the channel %i \n", pxNfeeL->ucId);
8111cc10:	d0e06117 	ldw	r3,-32380(gp)
8111cc14:	e0bffe17 	ldw	r2,-8(fp)
8111cc18:	10800003 	ldbu	r2,0(r2)
8111cc1c:	10803fcc 	andi	r2,r2,255
8111cc20:	100d883a 	mov	r6,r2
8111cc24:	01604574 	movhi	r5,33045
8111cc28:	297d4c04 	addi	r5,r5,-2768
8111cc2c:	1809883a 	mov	r4,r3
8111cc30:	11207b80 	call	811207b8 <fprintf>
		#endif
    }

    bDpktGetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8111cc34:	e0bffe17 	ldw	r2,-8(fp)
8111cc38:	10803304 	addi	r2,r2,204
8111cc3c:	1009883a 	mov	r4,r2
8111cc40:	1104d7c0 	call	81104d7c <bDpktGetPixelDelay>
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiAdcDelay = usiAdcPxDelayCalcPeriodNs(xDefaults.ulADCPixelDelay);
8111cc44:	00a045b4 	movhi	r2,33046
8111cc48:	10975904 	addi	r2,r2,23908
8111cc4c:	10800b17 	ldw	r2,44(r2)
8111cc50:	1009883a 	mov	r4,r2
8111cc54:	11050580 	call	81105058 <usiAdcPxDelayCalcPeriodNs>
8111cc58:	1007883a 	mov	r3,r2
8111cc5c:	e0bffe17 	ldw	r2,-8(fp)
8111cc60:	10c03a0d 	sth	r3,232(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiColumnDelay = 0 ;
8111cc64:	e0bffe17 	ldw	r2,-8(fp)
8111cc68:	1000398d 	sth	zero,230(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiLineDelay = usiLineTrDelayCalcPeriodNs(xDefaults.ulLineDelay);
8111cc6c:	00a045b4 	movhi	r2,33046
8111cc70:	10975904 	addi	r2,r2,23908
8111cc74:	10800917 	ldw	r2,36(r2)
8111cc78:	1009883a 	mov	r4,r2
8111cc7c:	11050e40 	call	811050e4 <usiLineTrDelayCalcPeriodNs>
8111cc80:	1007883a 	mov	r3,r2
8111cc84:	e0bffe17 	ldw	r2,-8(fp)
8111cc88:	10c0390d 	sth	r3,228(r2)
    bDpktSetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
8111cc8c:	e0bffe17 	ldw	r2,-8(fp)
8111cc90:	10803304 	addi	r2,r2,204
8111cc94:	1009883a 	mov	r4,r2
8111cc98:	1104c340 	call	81104c34 <bDpktSetPixelDelay>


}
8111cc9c:	0001883a 	nop
8111cca0:	e037883a 	mov	sp,fp
8111cca4:	dfc00117 	ldw	ra,4(sp)
8111cca8:	df000017 	ldw	fp,0(sp)
8111ccac:	dec00204 	addi	sp,sp,8
8111ccb0:	f800283a 	ret

8111ccb4 <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
8111ccb4:	defff404 	addi	sp,sp,-48
8111ccb8:	de00012e 	bgeu	sp,et,8111ccc0 <vUpdateMemMapFEE+0xc>
8111ccbc:	003b68fa 	trap	3
8111ccc0:	df000b15 	stw	fp,44(sp)
8111ccc4:	df000b04 	addi	fp,sp,44
8111ccc8:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
8111cccc:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
8111ccd0:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
8111ccd4:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
8111ccd8:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
8111ccdc:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
8111cce0:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
8111cce4:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
8111cce8:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
8111ccec:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
8111ccf0:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
8111ccf4:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
8111ccf8:	e17fff17 	ldw	r5,-4(fp)
8111ccfc:	01035a34 	movhi	r4,3432
8111cd00:	21348c04 	addi	r4,r4,-11728
8111cd04:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
8111cd08:	e13fff17 	ldw	r4,-4(fp)
8111cd0c:	21000003 	ldbu	r4,0(r4)
8111cd10:	21403fcc 	andi	r5,r4,255
8111cd14:	01035a34 	movhi	r4,3432
8111cd18:	21348c04 	addi	r4,r4,-11728
8111cd1c:	2909383a 	mul	r4,r5,r4
8111cd20:	200b883a 	mov	r5,r4
8111cd24:	e13fff17 	ldw	r4,-4(fp)
8111cd28:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
8111cd2c:	e13fff17 	ldw	r4,-4(fp)
8111cd30:	21400117 	ldw	r5,4(r4)
8111cd34:	01033234 	movhi	r4,3272
8111cd38:	21348c04 	addi	r4,r4,-11728
8111cd3c:	290b883a 	add	r5,r5,r4
8111cd40:	e13fff17 	ldw	r4,-4(fp)
8111cd44:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111cd48:	e13fff17 	ldw	r4,-4(fp)
8111cd4c:	2100310b 	ldhu	r4,196(r4)
8111cd50:	217fffcc 	andi	r5,r4,65535
8111cd54:	e13fff17 	ldw	r4,-4(fp)
8111cd58:	2100300b 	ldhu	r4,192(r4)
8111cd5c:	213fffcc 	andi	r4,r4,65535
8111cd60:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
8111cd64:	e13fff17 	ldw	r4,-4(fp)
8111cd68:	2100308b 	ldhu	r4,194(r4)
8111cd6c:	21bfffcc 	andi	r6,r4,65535
8111cd70:	e13fff17 	ldw	r4,-4(fp)
8111cd74:	21002f8b 	ldhu	r4,190(r4)
8111cd78:	213fffcc 	andi	r4,r4,65535
8111cd7c:	310d883a 	add	r6,r6,r4
8111cd80:	e13fff17 	ldw	r4,-4(fp)
8111cd84:	21002f0b 	ldhu	r4,188(r4)
8111cd88:	213fffcc 	andi	r4,r4,65535
8111cd8c:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111cd90:	2909383a 	mul	r4,r5,r4
8111cd94:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
8111cd98:	e13ffa17 	ldw	r4,-24(fp)
8111cd9c:	2109883a 	add	r4,r4,r4
8111cda0:	200b883a 	mov	r5,r4
8111cda4:	e13fff17 	ldw	r4,-4(fp)
8111cda8:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
8111cdac:	e13fff17 	ldw	r4,-4(fp)
8111cdb0:	21000517 	ldw	r4,20(r4)
8111cdb4:	2008d0fa 	srli	r4,r4,3
8111cdb8:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
8111cdbc:	e13fff17 	ldw	r4,-4(fp)
8111cdc0:	21000517 	ldw	r4,20(r4)
8111cdc4:	210001cc 	andi	r4,r4,7
8111cdc8:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
8111cdcc:	e13ffb17 	ldw	r4,-20(fp)
8111cdd0:	20001226 	beq	r4,zero,8111ce1c <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
8111cdd4:	e13ff517 	ldw	r4,-44(fp)
8111cdd8:	21000044 	addi	r4,r4,1
8111cddc:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
8111cde0:	e13fff17 	ldw	r4,-4(fp)
8111cde4:	21400517 	ldw	r5,20(r4)
8111cde8:	e13ffb17 	ldw	r4,-20(fp)
8111cdec:	2909c83a 	sub	r4,r5,r4
8111cdf0:	21400204 	addi	r5,r4,8
8111cdf4:	e13fff17 	ldw	r4,-4(fp)
8111cdf8:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
8111cdfc:	e13ffb17 	ldw	r4,-20(fp)
8111ce00:	200b883a 	mov	r5,r4
8111ce04:	01000204 	movi	r4,8
8111ce08:	2149c83a 	sub	r4,r4,r5
8111ce0c:	200b883a 	mov	r5,r4
8111ce10:	e13fff17 	ldw	r4,-4(fp)
8111ce14:	21400605 	stb	r5,24(r4)
8111ce18:	00000206 	br	8111ce24 <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
8111ce1c:	e13fff17 	ldw	r4,-4(fp)
8111ce20:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
8111ce24:	e13ff517 	ldw	r4,-44(fp)
8111ce28:	2008d13a 	srli	r4,r4,4
8111ce2c:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
8111ce30:	e13ff517 	ldw	r4,-44(fp)
8111ce34:	210003cc 	andi	r4,r4,15
8111ce38:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
8111ce3c:	e13ffc17 	ldw	r4,-16(fp)
8111ce40:	20000b26 	beq	r4,zero,8111ce70 <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
8111ce44:	e13ff717 	ldw	r4,-36(fp)
8111ce48:	21000044 	addi	r4,r4,1
8111ce4c:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
8111ce50:	e17ff517 	ldw	r5,-44(fp)
8111ce54:	e13ffc17 	ldw	r4,-16(fp)
8111ce58:	290bc83a 	sub	r5,r5,r4
8111ce5c:	e13ff717 	ldw	r4,-36(fp)
8111ce60:	2909883a 	add	r4,r5,r4
8111ce64:	21000404 	addi	r4,r4,16
8111ce68:	e13ff615 	stw	r4,-40(fp)
8111ce6c:	00000406 	br	8111ce80 <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
8111ce70:	e17ff517 	ldw	r5,-44(fp)
8111ce74:	e13ff717 	ldw	r4,-36(fp)
8111ce78:	2909883a 	add	r4,r5,r4
8111ce7c:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
8111ce80:	e13ff617 	ldw	r4,-40(fp)
8111ce84:	200a90fa 	slli	r5,r4,3
8111ce88:	e13fff17 	ldw	r4,-4(fp)
8111ce8c:	21400515 	stw	r5,20(r4)

    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
8111ce90:	e13ffb17 	ldw	r4,-20(fp)
8111ce94:	20000926 	beq	r4,zero,8111cebc <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
8111ce98:	e13ffc17 	ldw	r4,-16(fp)
8111ce9c:	2109883a 	add	r4,r4,r4
8111cea0:	2109883a 	add	r4,r4,r4
8111cea4:	200b883a 	mov	r5,r4
8111cea8:	e13ffb17 	ldw	r4,-20(fp)
8111ceac:	2008d07a 	srli	r4,r4,1
8111ceb0:	2909883a 	add	r4,r5,r4
8111ceb4:	e13ff805 	stb	r4,-32(fp)
8111ceb8:	00000406 	br	8111cecc <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
8111cebc:	e13ffc17 	ldw	r4,-16(fp)
8111cec0:	2109883a 	add	r4,r4,r4
8111cec4:	2109883a 	add	r4,r4,r4
8111cec8:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
8111cecc:	e13ff803 	ldbu	r4,-32(fp)
8111ced0:	01401004 	movi	r5,64
8111ced4:	2909c83a 	sub	r4,r5,r4
8111ced8:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
8111cedc:	e13ffd03 	ldbu	r4,-12(fp)
8111cee0:	217ff804 	addi	r5,r4,-32
8111cee4:	28000416 	blt	r5,zero,8111cef8 <vUpdateMemMapFEE+0x244>
8111cee8:	013fffc4 	movi	r4,-1
8111ceec:	2144d83a 	srl	r2,r4,r5
8111cef0:	0007883a 	mov	r3,zero
8111cef4:	00000a06 	br	8111cf20 <vUpdateMemMapFEE+0x26c>
8111cef8:	017fffc4 	movi	r5,-1
8111cefc:	280c907a 	slli	r6,r5,1
8111cf00:	014007c4 	movi	r5,31
8111cf04:	290bc83a 	sub	r5,r5,r4
8111cf08:	314a983a 	sll	r5,r6,r5
8111cf0c:	01bfffc4 	movi	r6,-1
8111cf10:	3104d83a 	srl	r2,r6,r4
8111cf14:	2884b03a 	or	r2,r5,r2
8111cf18:	017fffc4 	movi	r5,-1
8111cf1c:	2906d83a 	srl	r3,r5,r4
8111cf20:	e13fff17 	ldw	r4,-4(fp)
8111cf24:	20800715 	stw	r2,28(r4)
8111cf28:	20c00815 	stw	r3,32(r4)

    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
8111cf2c:	e0bfff17 	ldw	r2,-4(fp)
8111cf30:	e0fff717 	ldw	r3,-36(fp)
8111cf34:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
8111cf38:	e0bfff17 	ldw	r2,-4(fp)
8111cf3c:	10c00117 	ldw	r3,4(r2)
8111cf40:	008004b4 	movhi	r2,18
8111cf44:	10a40004 	addi	r2,r2,-28672
8111cf48:	1885883a 	add	r2,r3,r2
8111cf4c:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
8111cf50:	e0bfff17 	ldw	r2,-4(fp)
8111cf54:	10c00517 	ldw	r3,20(r2)
8111cf58:	008000b4 	movhi	r2,2
8111cf5c:	10a40004 	addi	r2,r2,-28672
8111cf60:	1885883a 	add	r2,r3,r2
8111cf64:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111cf68:	e03ff845 	stb	zero,-31(fp)
8111cf6c:	00001906 	br	8111cfd4 <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
8111cf70:	e0bff843 	ldbu	r2,-31(fp)
8111cf74:	e0ffff17 	ldw	r3,-4(fp)
8111cf78:	10800624 	muli	r2,r2,24
8111cf7c:	1885883a 	add	r2,r3,r2
8111cf80:	10800904 	addi	r2,r2,36
8111cf84:	e0fff917 	ldw	r3,-28(fp)
8111cf88:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111cf8c:	e0fff917 	ldw	r3,-28(fp)
8111cf90:	e0bffe17 	ldw	r2,-8(fp)
8111cf94:	1885883a 	add	r2,r3,r2
8111cf98:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
8111cf9c:	e0bff843 	ldbu	r2,-31(fp)
8111cfa0:	e0ffff17 	ldw	r3,-4(fp)
8111cfa4:	10800624 	muli	r2,r2,24
8111cfa8:	1885883a 	add	r2,r3,r2
8111cfac:	10800c04 	addi	r2,r2,48
8111cfb0:	e0fff917 	ldw	r3,-28(fp)
8111cfb4:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111cfb8:	e0fff917 	ldw	r3,-28(fp)
8111cfbc:	e0bffe17 	ldw	r2,-8(fp)
8111cfc0:	1885883a 	add	r2,r3,r2
8111cfc4:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111cfc8:	e0bff843 	ldbu	r2,-31(fp)
8111cfcc:	10800044 	addi	r2,r2,1
8111cfd0:	e0bff845 	stb	r2,-31(fp)
8111cfd4:	e0bff843 	ldbu	r2,-31(fp)
8111cfd8:	10800130 	cmpltui	r2,r2,4
8111cfdc:	103fe41e 	bne	r2,zero,8111cf70 <__reset+0xfb0fcf70>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }
}
8111cfe0:	0001883a 	nop
8111cfe4:	e037883a 	mov	sp,fp
8111cfe8:	df000017 	ldw	fp,0(sp)
8111cfec:	dec00104 	addi	sp,sp,4
8111cff0:	f800283a 	ret

8111cff4 <vResetMemCCDFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
8111cff4:	defffd04 	addi	sp,sp,-12
8111cff8:	de00012e 	bgeu	sp,et,8111d000 <vResetMemCCDFEE+0xc>
8111cffc:	003b68fa 	trap	3
8111d000:	df000215 	stw	fp,8(sp)
8111d004:	df000204 	addi	fp,sp,8
8111d008:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL = 0;
8111d00c:	e03ffe05 	stb	zero,-8(fp)

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111d010:	e03ffe05 	stb	zero,-8(fp)
8111d014:	00001b06 	br	8111d084 <vResetMemCCDFEE+0x90>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
8111d018:	e0bffe03 	ldbu	r2,-8(fp)
8111d01c:	e0ffff17 	ldw	r3,-4(fp)
8111d020:	10800624 	muli	r2,r2,24
8111d024:	1885883a 	add	r2,r3,r2
8111d028:	10800b04 	addi	r2,r2,44
8111d02c:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
8111d030:	e0bffe03 	ldbu	r2,-8(fp)
8111d034:	e0ffff17 	ldw	r3,-4(fp)
8111d038:	10800624 	muli	r2,r2,24
8111d03c:	1885883a 	add	r2,r3,r2
8111d040:	10800a04 	addi	r2,r2,40
8111d044:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
8111d048:	e0bffe03 	ldbu	r2,-8(fp)
8111d04c:	e0ffff17 	ldw	r3,-4(fp)
8111d050:	10800624 	muli	r2,r2,24
8111d054:	1885883a 	add	r2,r3,r2
8111d058:	10800e04 	addi	r2,r2,56
8111d05c:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
8111d060:	e0bffe03 	ldbu	r2,-8(fp)
8111d064:	e0ffff17 	ldw	r3,-4(fp)
8111d068:	10800624 	muli	r2,r2,24
8111d06c:	1885883a 	add	r2,r3,r2
8111d070:	10800d04 	addi	r2,r2,52
8111d074:	10000015 	stw	zero,0(r2)

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
	unsigned char ucIL = 0;

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111d078:	e0bffe03 	ldbu	r2,-8(fp)
8111d07c:	10800044 	addi	r2,r2,1
8111d080:	e0bffe05 	stb	r2,-8(fp)
8111d084:	e0bffe03 	ldbu	r2,-8(fp)
8111d088:	10800130 	cmpltui	r2,r2,4
8111d08c:	103fe21e 	bne	r2,zero,8111d018 <__reset+0xfb0fd018>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
    }
}
8111d090:	0001883a 	nop
8111d094:	e037883a 	mov	sp,fp
8111d098:	df000017 	ldw	fp,0(sp)
8111d09c:	dec00104 	addi	sp,sp,4
8111d0a0:	f800283a 	ret

8111d0a4 <vFeeSpwRMAPLoadDefault>:



/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
8111d0a4:	defffe04 	addi	sp,sp,-8
8111d0a8:	de00012e 	bgeu	sp,et,8111d0b0 <vFeeSpwRMAPLoadDefault+0xc>
8111d0ac:	003b68fa 	trap	3
8111d0b0:	df000115 	stw	fp,4(sp)
8111d0b4:	df000104 	addi	fp,sp,4
8111d0b8:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111d0bc:	0001883a 	nop
8111d0c0:	e037883a 	mov	sp,fp
8111d0c4:	df000017 	ldw	fp,0(sp)
8111d0c8:	dec00104 	addi	sp,sp,4
8111d0cc:	f800283a 	ret

8111d0d0 <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
8111d0d0:	defffe04 	addi	sp,sp,-8
8111d0d4:	de00012e 	bgeu	sp,et,8111d0dc <vFeeSpwRMAPChangeConfig+0xc>
8111d0d8:	003b68fa 	trap	3
8111d0dc:	df000115 	stw	fp,4(sp)
8111d0e0:	df000104 	addi	fp,sp,4
8111d0e4:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111d0e8:	0001883a 	nop
8111d0ec:	e037883a 	mov	sp,fp
8111d0f0:	df000017 	ldw	fp,0(sp)
8111d0f4:	dec00104 	addi	sp,sp,4
8111d0f8:	f800283a 	ret

8111d0fc <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
8111d0fc:	defffe04 	addi	sp,sp,-8
8111d100:	de00012e 	bgeu	sp,et,8111d108 <vFeeSpwRMAPChangeDefault+0xc>
8111d104:	003b68fa 	trap	3
8111d108:	df000115 	stw	fp,4(sp)
8111d10c:	df000104 	addi	fp,sp,4
8111d110:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
8111d114:	0001883a 	nop
8111d118:	e037883a 	mov	sp,fp
8111d11c:	df000017 	ldw	fp,0(sp)
8111d120:	dec00104 	addi	sp,sp,4
8111d124:	f800283a 	ret

8111d128 <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
8111d128:	defffe04 	addi	sp,sp,-8
8111d12c:	de00012e 	bgeu	sp,et,8111d134 <cFeeSpwChannelEnable+0xc>
8111d130:	003b68fa 	trap	3
8111d134:	df000115 	stw	fp,4(sp)
8111d138:	df000104 	addi	fp,sp,4
8111d13c:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111d140:	0001883a 	nop
8111d144:	e037883a 	mov	sp,fp
8111d148:	df000017 	ldw	fp,0(sp)
8111d14c:	dec00104 	addi	sp,sp,4
8111d150:	f800283a 	ret

8111d154 <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
8111d154:	defffe04 	addi	sp,sp,-8
8111d158:	de00012e 	bgeu	sp,et,8111d160 <cFeeSpwChannelDisable+0xc>
8111d15c:	003b68fa 	trap	3
8111d160:	df000115 	stw	fp,4(sp)
8111d164:	df000104 	addi	fp,sp,4
8111d168:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111d16c:	0001883a 	nop
8111d170:	e037883a 	mov	sp,fp
8111d174:	df000017 	ldw	fp,0(sp)
8111d178:	dec00104 	addi	sp,sp,4
8111d17c:	f800283a 	ret

8111d180 <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
8111d180:	defffe04 	addi	sp,sp,-8
8111d184:	de00012e 	bgeu	sp,et,8111d18c <cFeeRMAPDump+0xc>
8111d188:	003b68fa 	trap	3
8111d18c:	df000115 	stw	fp,4(sp)
8111d190:	df000104 	addi	fp,sp,4
8111d194:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
8111d198:	0001883a 	nop
8111d19c:	e037883a 	mov	sp,fp
8111d1a0:	df000017 	ldw	fp,0(sp)
8111d1a4:	dec00104 	addi	sp,sp,4
8111d1a8:	f800283a 	ret

8111d1ac <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
8111d1ac:	defffe04 	addi	sp,sp,-8
8111d1b0:	de00012e 	bgeu	sp,et,8111d1b8 <cFeeRMAPEchoingEnable+0xc>
8111d1b4:	003b68fa 	trap	3
8111d1b8:	df000115 	stw	fp,4(sp)
8111d1bc:	df000104 	addi	fp,sp,4
8111d1c0:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
8111d1c4:	e0bfff17 	ldw	r2,-4(fp)
8111d1c8:	00c00044 	movi	r3,1
8111d1cc:	10c02515 	stw	r3,148(r2)
}
8111d1d0:	0001883a 	nop
8111d1d4:	e037883a 	mov	sp,fp
8111d1d8:	df000017 	ldw	fp,0(sp)
8111d1dc:	dec00104 	addi	sp,sp,4
8111d1e0:	f800283a 	ret

8111d1e4 <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
8111d1e4:	defffe04 	addi	sp,sp,-8
8111d1e8:	de00012e 	bgeu	sp,et,8111d1f0 <cFeeRMAPEchoingDisable+0xc>
8111d1ec:	003b68fa 	trap	3
8111d1f0:	df000115 	stw	fp,4(sp)
8111d1f4:	df000104 	addi	fp,sp,4
8111d1f8:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
8111d1fc:	e0bfff17 	ldw	r2,-4(fp)
8111d200:	10002515 	stw	zero,148(r2)
}
8111d204:	0001883a 	nop
8111d208:	e037883a 	mov	sp,fp
8111d20c:	df000017 	ldw	fp,0(sp)
8111d210:	dec00104 	addi	sp,sp,4
8111d214:	f800283a 	ret

8111d218 <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
8111d218:	defffe04 	addi	sp,sp,-8
8111d21c:	de00012e 	bgeu	sp,et,8111d224 <cFeeRMAPLogEnable+0xc>
8111d220:	003b68fa 	trap	3
8111d224:	df000115 	stw	fp,4(sp)
8111d228:	df000104 	addi	fp,sp,4
8111d22c:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
8111d230:	e0bfff17 	ldw	r2,-4(fp)
8111d234:	00c00044 	movi	r3,1
8111d238:	10c02415 	stw	r3,144(r2)
}
8111d23c:	0001883a 	nop
8111d240:	e037883a 	mov	sp,fp
8111d244:	df000017 	ldw	fp,0(sp)
8111d248:	dec00104 	addi	sp,sp,4
8111d24c:	f800283a 	ret

8111d250 <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
8111d250:	defffe04 	addi	sp,sp,-8
8111d254:	de00012e 	bgeu	sp,et,8111d25c <cFeeRMAPLogDisable+0xc>
8111d258:	003b68fa 	trap	3
8111d25c:	df000115 	stw	fp,4(sp)
8111d260:	df000104 	addi	fp,sp,4
8111d264:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
8111d268:	e0bfff17 	ldw	r2,-4(fp)
8111d26c:	10002415 	stw	zero,144(r2)
}
8111d270:	0001883a 	nop
8111d274:	e037883a 	mov	sp,fp
8111d278:	df000017 	ldw	fp,0(sp)
8111d27c:	dec00104 	addi	sp,sp,4
8111d280:	f800283a 	ret

8111d284 <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
8111d284:	defffc04 	addi	sp,sp,-16
8111d288:	de00012e 	bgeu	sp,et,8111d290 <vNFeeControlInit+0xc>
8111d28c:	003b68fa 	trap	3
8111d290:	dfc00315 	stw	ra,12(sp)
8111d294:	df000215 	stw	fp,8(sp)
8111d298:	df000204 	addi	fp,sp,8
8111d29c:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
8111d2a0:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
8111d2a4:	e13fff17 	ldw	r4,-4(fp)
8111d2a8:	111d3d00 	call	8111d3d0 <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
8111d2ac:	e13fff17 	ldw	r4,-4(fp)
8111d2b0:	111d4040 	call	8111d404 <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebInit;
8111d2b4:	e0bfff17 	ldw	r2,-4(fp)
8111d2b8:	10009a15 	stw	zero,616(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111d2bc:	e03ffe05 	stb	zero,-8(fp)
8111d2c0:	00002b06 	br	8111d370 <vNFeeControlInit+0xec>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
8111d2c4:	e0bffe03 	ldbu	r2,-8(fp)
8111d2c8:	10809624 	muli	r2,r2,600
8111d2cc:	e0ffff17 	ldw	r3,-4(fp)
8111d2d0:	1885883a 	add	r2,r3,r2
8111d2d4:	e0fffe03 	ldbu	r3,-8(fp)
8111d2d8:	180b883a 	mov	r5,r3
8111d2dc:	1009883a 	mov	r4,r2
8111d2e0:	111cad40 	call	8111cad4 <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
8111d2e4:	e0bffe03 	ldbu	r2,-8(fp)
8111d2e8:	e0fffe03 	ldbu	r3,-8(fp)
8111d2ec:	18c09624 	muli	r3,r3,600
8111d2f0:	18c02104 	addi	r3,r3,132
8111d2f4:	e13fff17 	ldw	r4,-4(fp)
8111d2f8:	20c7883a 	add	r3,r4,r3
8111d2fc:	e13fff17 	ldw	r4,-4(fp)
8111d300:	108025c4 	addi	r2,r2,151
8111d304:	1085883a 	add	r2,r2,r2
8111d308:	1085883a 	add	r2,r2,r2
8111d30c:	2085883a 	add	r2,r4,r2
8111d310:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
8111d314:	e0bffe03 	ldbu	r2,-8(fp)
8111d318:	e0fffe03 	ldbu	r3,-8(fp)
8111d31c:	18c09624 	muli	r3,r3,600
8111d320:	18c02704 	addi	r3,r3,156
8111d324:	e13fff17 	ldw	r4,-4(fp)
8111d328:	20c7883a 	add	r3,r4,r3
8111d32c:	e13fff17 	ldw	r4,-4(fp)
8111d330:	10802604 	addi	r2,r2,152
8111d334:	1085883a 	add	r2,r2,r2
8111d338:	1085883a 	add	r2,r2,r2
8111d33c:	2085883a 	add	r2,r4,r2
8111d340:	10c00015 	stw	r3,0(r2)
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
8111d344:	e0bffe03 	ldbu	r2,-8(fp)
8111d348:	e0ffff17 	ldw	r3,-4(fp)
8111d34c:	18c09617 	ldw	r3,600(r3)
8111d350:	e13fff17 	ldw	r4,-4(fp)
8111d354:	10809624 	muli	r2,r2,600
8111d358:	2085883a 	add	r2,r4,r2
8111d35c:	10802904 	addi	r2,r2,164
8111d360:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebInit;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111d364:	e0bffe03 	ldbu	r2,-8(fp)
8111d368:	10800044 	addi	r2,r2,1
8111d36c:	e0bffe05 	stb	r2,-8(fp)
8111d370:	e0bffe03 	ldbu	r2,-8(fp)
8111d374:	103fd326 	beq	r2,zero,8111d2c4 <__reset+0xfb0fd2c4>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
    }

}
8111d378:	0001883a 	nop
8111d37c:	e037883a 	mov	sp,fp
8111d380:	dfc00117 	ldw	ra,4(sp)
8111d384:	df000017 	ldw	fp,0(sp)
8111d388:	dec00204 	addi	sp,sp,8
8111d38c:	f800283a 	ret

8111d390 <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
8111d390:	defffd04 	addi	sp,sp,-12
8111d394:	de00012e 	bgeu	sp,et,8111d39c <vSetTimeCode+0xc>
8111d398:	003b68fa 	trap	3
8111d39c:	df000215 	stw	fp,8(sp)
8111d3a0:	df000204 	addi	fp,sp,8
8111d3a4:	e13ffe15 	stw	r4,-8(fp)
8111d3a8:	2805883a 	mov	r2,r5
8111d3ac:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
8111d3b0:	e0bffe17 	ldw	r2,-8(fp)
8111d3b4:	e0ffff03 	ldbu	r3,-4(fp)
8111d3b8:	10c09905 	stb	r3,612(r2)
}
8111d3bc:	0001883a 	nop
8111d3c0:	e037883a 	mov	sp,fp
8111d3c4:	df000017 	ldw	fp,0(sp)
8111d3c8:	dec00104 	addi	sp,sp,4
8111d3cc:	f800283a 	ret

8111d3d0 <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
8111d3d0:	defffe04 	addi	sp,sp,-8
8111d3d4:	de00012e 	bgeu	sp,et,8111d3dc <vResetTimeCode+0xc>
8111d3d8:	003b68fa 	trap	3
8111d3dc:	df000115 	stw	fp,4(sp)
8111d3e0:	df000104 	addi	fp,sp,4
8111d3e4:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
8111d3e8:	e0bfff17 	ldw	r2,-4(fp)
8111d3ec:	10009905 	stb	zero,612(r2)
}
8111d3f0:	0001883a 	nop
8111d3f4:	e037883a 	mov	sp,fp
8111d3f8:	df000017 	ldw	fp,0(sp)
8111d3fc:	dec00104 	addi	sp,sp,4
8111d400:	f800283a 	ret

8111d404 <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
8111d404:	defffe04 	addi	sp,sp,-8
8111d408:	de00012e 	bgeu	sp,et,8111d410 <vLoadDefaultIdNFEEMaster+0xc>
8111d40c:	003b68fa 	trap	3
8111d410:	df000115 	stw	fp,4(sp)
8111d414:	df000104 	addi	fp,sp,4
8111d418:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
8111d41c:	e0bfff17 	ldw	r2,-4(fp)
8111d420:	10009945 	stb	zero,613(r2)
}
8111d424:	0001883a 	nop
8111d428:	e037883a 	mov	sp,fp
8111d42c:	df000017 	ldw	fp,0(sp)
8111d430:	dec00104 	addi	sp,sp,4
8111d434:	f800283a 	ret

8111d438 <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111d438:	defffd04 	addi	sp,sp,-12
8111d43c:	de00012e 	bgeu	sp,et,8111d444 <vChangeIdNFEEMaster+0xc>
8111d440:	003b68fa 	trap	3
8111d444:	df000215 	stw	fp,8(sp)
8111d448:	df000204 	addi	fp,sp,8
8111d44c:	e13ffe15 	stw	r4,-8(fp)
8111d450:	2805883a 	mov	r2,r5
8111d454:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
8111d458:	e0bffe17 	ldw	r2,-8(fp)
8111d45c:	e0ffff03 	ldbu	r3,-4(fp)
8111d460:	10c09945 	stb	r3,613(r2)
}
8111d464:	0001883a 	nop
8111d468:	e037883a 	mov	sp,fp
8111d46c:	df000017 	ldw	fp,0(sp)
8111d470:	dec00104 	addi	sp,sp,4
8111d474:	f800283a 	ret

8111d478 <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111d478:	defffd04 	addi	sp,sp,-12
8111d47c:	de00012e 	bgeu	sp,et,8111d484 <vChangeDefaultIdNFEEMaster+0xc>
8111d480:	003b68fa 	trap	3
8111d484:	df000215 	stw	fp,8(sp)
8111d488:	df000204 	addi	fp,sp,8
8111d48c:	e13ffe15 	stw	r4,-8(fp)
8111d490:	2805883a 	mov	r2,r5
8111d494:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
8111d498:	0001883a 	nop
8111d49c:	e037883a 	mov	sp,fp
8111d4a0:	df000017 	ldw	fp,0(sp)
8111d4a4:	dec00104 	addi	sp,sp,4
8111d4a8:	f800283a 	ret

8111d4ac <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
8111d4ac:	defffe04 	addi	sp,sp,-8
8111d4b0:	de00012e 	bgeu	sp,et,8111d4b8 <vInitSimucamBasicHW+0xc>
8111d4b4:	003b68fa 	trap	3
8111d4b8:	dfc00115 	stw	ra,4(sp)
8111d4bc:	df000015 	stw	fp,0(sp)
8111d4c0:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
8111d4c4:	01403fc4 	movi	r5,255
8111d4c8:	0009883a 	mov	r4,zero
8111d4cc:	110b2500 	call	8110b250 <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
8111d4d0:	01400834 	movhi	r5,32
8111d4d4:	297fffc4 	addi	r5,r5,-1
8111d4d8:	0009883a 	mov	r4,zero
8111d4dc:	110b2d00 	call	8110b2d0 <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
8111d4e0:	01400074 	movhi	r5,1
8111d4e4:	01000044 	movi	r4,1
8111d4e8:	110b2d00 	call	8110b2d0 <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
8111d4ec:	0009883a 	mov	r4,zero
8111d4f0:	110c8ac0 	call	8110c8ac <bSSDisplayConfig>
	bSSDisplayUpdate(0);
8111d4f4:	0009883a 	mov	r4,zero
8111d4f8:	110c97c0 	call	8110c97c <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111d4fc:	01008004 	movi	r4,512
8111d500:	110c40c0 	call	8110c40c <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111d504:	01008004 	movi	r4,512
8111d508:	110c3980 	call	8110c398 <vRstcReleaseDeviceReset>

}
8111d50c:	0001883a 	nop
8111d510:	e037883a 	mov	sp,fp
8111d514:	dfc00117 	ldw	ra,4(sp)
8111d518:	df000017 	ldw	fp,0(sp)
8111d51c:	dec00204 	addi	sp,sp,8
8111d520:	f800283a 	ret

8111d524 <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
8111d524:	defffd04 	addi	sp,sp,-12
8111d528:	de00012e 	bgeu	sp,et,8111d530 <bLogWriteSDCard+0xc>
8111d52c:	003b68fa 	trap	3
8111d530:	df000215 	stw	fp,8(sp)
8111d534:	df000204 	addi	fp,sp,8
8111d538:	e13ffe15 	stw	r4,-8(fp)
8111d53c:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
8111d540:	00800044 	movi	r2,1
}
8111d544:	e037883a 	mov	sp,fp
8111d548:	df000017 	ldw	fp,0(sp)
8111d54c:	dec00104 	addi	sp,sp,4
8111d550:	f800283a 	ret

8111d554 <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
8111d554:	deffe004 	addi	sp,sp,-128
8111d558:	de00012e 	bgeu	sp,et,8111d560 <vLogWriteNUC+0xc>
8111d55c:	003b68fa 	trap	3
8111d560:	dfc01f15 	stw	ra,124(sp)
8111d564:	df001e15 	stw	fp,120(sp)
8111d568:	df001e04 	addi	fp,sp,120
8111d56c:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
8111d570:	e03fe215 	stw	zero,-120(fp)
8111d574:	e0bfe304 	addi	r2,fp,-116
8111d578:	00c01b84 	movi	r3,110
8111d57c:	180d883a 	mov	r6,r3
8111d580:	000b883a 	mov	r5,zero
8111d584:	1009883a 	mov	r4,r2
8111d588:	11219b80 	call	811219b8 <memset>
	memset(cTemp,0,114);
8111d58c:	01801c84 	movi	r6,114
8111d590:	000b883a 	mov	r5,zero
8111d594:	e13fe204 	addi	r4,fp,-120
8111d598:	11219b80 	call	811219b8 <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
8111d59c:	e13fff17 	ldw	r4,-4(fp)
8111d5a0:	112235c0 	call	8112235c <strlen>
8111d5a4:	10801c68 	cmpgeui	r2,r2,113
8111d5a8:	1000031e 	bne	r2,zero,8111d5b8 <vLogWriteNUC+0x64>
8111d5ac:	e13fff17 	ldw	r4,-4(fp)
8111d5b0:	112235c0 	call	8112235c <strlen>
8111d5b4:	00000106 	br	8111d5bc <vLogWriteNUC+0x68>
8111d5b8:	00801c44 	movi	r2,113
8111d5bc:	100d883a 	mov	r6,r2
8111d5c0:	e17fff17 	ldw	r5,-4(fp)
8111d5c4:	e13fe204 	addi	r4,fp,-120
8111d5c8:	11218680 	call	81121868 <memcpy>
	vSendLog ( cDataIn );
8111d5cc:	e13fff17 	ldw	r4,-4(fp)
8111d5d0:	11188b80 	call	811188b8 <vSendLog>
}
8111d5d4:	0001883a 	nop
8111d5d8:	e037883a 	mov	sp,fp
8111d5dc:	dfc00117 	ldw	ra,4(sp)
8111d5e0:	df000017 	ldw	fp,0(sp)
8111d5e4:	dec00204 	addi	sp,sp,8
8111d5e8:	f800283a 	ret

8111d5ec <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
8111d5ec:	defffd04 	addi	sp,sp,-12
8111d5f0:	de00012e 	bgeu	sp,et,8111d5f8 <vSimucamStructureInit+0xc>
8111d5f4:	003b68fa 	trap	3
8111d5f8:	dfc00215 	stw	ra,8(sp)
8111d5fc:	df000115 	stw	fp,4(sp)
8111d600:	df000104 	addi	fp,sp,4
8111d604:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
8111d608:	e0bfff17 	ldw	r2,-4(fp)
8111d60c:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebInit;
8111d610:	e0bfff17 	ldw	r2,-4(fp)
8111d614:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
8111d618:	e13fff17 	ldw	r4,-4(fp)
8111d61c:	111d6d80 	call	8111d6d8 <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
8111d620:	e13fff17 	ldw	r4,-4(fp)
8111d624:	111d77c0 	call	8111d77c <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
8111d628:	e13fff17 	ldw	r4,-4(fp)
8111d62c:	111d8240 	call	8111d824 <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
8111d630:	e13fff17 	ldw	r4,-4(fp)
8111d634:	111d8c40 	call	8111d8c4 <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
8111d638:	e0bfff17 	ldw	r2,-4(fp)
8111d63c:	10000615 	stw	zero,24(r2)
    xMeb->fPixelTransferTime = 0;
8111d640:	e0bfff17 	ldw	r2,-4(fp)
8111d644:	10000715 	stw	zero,28(r2)
    xMeb->usiDelaySyncReset = 500; /* milliseconds */
8111d648:	e0bfff17 	ldw	r2,-4(fp)
8111d64c:	00c07d04 	movi	r3,500
8111d650:	10c0050d 	sth	r3,20(r2)

    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
8111d654:	e0bfff17 	ldw	r2,-4(fp)
8111d658:	10000205 	stb	zero,8(r2)
    xMeb->ucNextDDR = 1;
8111d65c:	e0bfff17 	ldw	r2,-4(fp)
8111d660:	00c00044 	movi	r3,1
8111d664:	10c00245 	stb	r3,9(r2)

    xMeb->xFeeControl.pActualMem = &xMeb->ucActualDDR;
8111d668:	e0bfff17 	ldw	r2,-4(fp)
8111d66c:	10c00204 	addi	r3,r2,8
8111d670:	e0bfff17 	ldw	r2,-4(fp)
8111d674:	10c0a815 	stw	r3,672(r2)
    xMeb->xDataControl.pNextMem = &xMeb->ucNextDDR;
8111d678:	e0bfff17 	ldw	r2,-4(fp)
8111d67c:	10c00244 	addi	r3,r2,9
8111d680:	e0bfff17 	ldw	r2,-4(fp)
8111d684:	10c01115 	stw	r3,68(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
8111d688:	e0bfff17 	ldw	r2,-4(fp)
8111d68c:	10800017 	ldw	r2,0(r2)
8111d690:	10000b1e 	bne	r2,zero,8111d6c0 <vSimucamStructureInit+0xd4>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
8111d694:	e0bfff17 	ldw	r2,-4(fp)
8111d698:	10801204 	addi	r2,r2,72
8111d69c:	1009883a 	mov	r4,r2
8111d6a0:	111d2840 	call	8111d284 <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
8111d6a4:	e0bfff17 	ldw	r2,-4(fp)
8111d6a8:	10c00a04 	addi	r3,r2,40
8111d6ac:	e0bfff17 	ldw	r2,-4(fp)
8111d6b0:	10801204 	addi	r2,r2,72
8111d6b4:	100b883a 	mov	r5,r2
8111d6b8:	1809883a 	mov	r4,r3
8111d6bc:	111a9cc0 	call	8111a9cc <vDataControllerInit>


    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */


}
8111d6c0:	0001883a 	nop
8111d6c4:	e037883a 	mov	sp,fp
8111d6c8:	dfc00117 	ldw	ra,4(sp)
8111d6cc:	df000017 	ldw	fp,0(sp)
8111d6d0:	dec00204 	addi	sp,sp,8
8111d6d4:	f800283a 	ret

8111d6d8 <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
8111d6d8:	defffe04 	addi	sp,sp,-8
8111d6dc:	de00012e 	bgeu	sp,et,8111d6e4 <vLoadDefaultEPValue+0xc>
8111d6e0:	003b68fa 	trap	3
8111d6e4:	df000115 	stw	fp,4(sp)
8111d6e8:	df000104 	addi	fp,sp,4
8111d6ec:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
8111d6f0:	e0bfff17 	ldw	r2,-4(fp)
8111d6f4:	00d07234 	movhi	r3,16840
8111d6f8:	10c00315 	stw	r3,12(r2)
}
8111d6fc:	0001883a 	nop
8111d700:	e037883a 	mov	sp,fp
8111d704:	df000017 	ldw	fp,0(sp)
8111d708:	dec00104 	addi	sp,sp,4
8111d70c:	f800283a 	ret

8111d710 <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111d710:	defffd04 	addi	sp,sp,-12
8111d714:	de00012e 	bgeu	sp,et,8111d71c <vChangeEPValue+0xc>
8111d718:	003b68fa 	trap	3
8111d71c:	df000215 	stw	fp,8(sp)
8111d720:	df000204 	addi	fp,sp,8
8111d724:	e13ffe15 	stw	r4,-8(fp)
8111d728:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
8111d72c:	e0bffe17 	ldw	r2,-8(fp)
8111d730:	e0ffff17 	ldw	r3,-4(fp)
8111d734:	10c00315 	stw	r3,12(r2)
}
8111d738:	0001883a 	nop
8111d73c:	e037883a 	mov	sp,fp
8111d740:	df000017 	ldw	fp,0(sp)
8111d744:	dec00104 	addi	sp,sp,4
8111d748:	f800283a 	ret

8111d74c <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111d74c:	defffd04 	addi	sp,sp,-12
8111d750:	de00012e 	bgeu	sp,et,8111d758 <vChangeDefaultEPValue+0xc>
8111d754:	003b68fa 	trap	3
8111d758:	df000215 	stw	fp,8(sp)
8111d75c:	df000204 	addi	fp,sp,8
8111d760:	e13ffe15 	stw	r4,-8(fp)
8111d764:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
8111d768:	0001883a 	nop
8111d76c:	e037883a 	mov	sp,fp
8111d770:	df000017 	ldw	fp,0(sp)
8111d774:	dec00104 	addi	sp,sp,4
8111d778:	f800283a 	ret

8111d77c <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
8111d77c:	defffe04 	addi	sp,sp,-8
8111d780:	de00012e 	bgeu	sp,et,8111d788 <vLoadDefaultRTValue+0xc>
8111d784:	003b68fa 	trap	3
8111d788:	df000115 	stw	fp,4(sp)
8111d78c:	df000104 	addi	fp,sp,4
8111d790:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
8111d794:	e0ffff17 	ldw	r3,-4(fp)
8111d798:	00901eb4 	movhi	r2,16506
8111d79c:	10a66684 	addi	r2,r2,-26214
8111d7a0:	18800415 	stw	r2,16(r3)
}
8111d7a4:	0001883a 	nop
8111d7a8:	e037883a 	mov	sp,fp
8111d7ac:	df000017 	ldw	fp,0(sp)
8111d7b0:	dec00104 	addi	sp,sp,4
8111d7b4:	f800283a 	ret

8111d7b8 <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111d7b8:	defffd04 	addi	sp,sp,-12
8111d7bc:	de00012e 	bgeu	sp,et,8111d7c4 <vChangeRTValue+0xc>
8111d7c0:	003b68fa 	trap	3
8111d7c4:	df000215 	stw	fp,8(sp)
8111d7c8:	df000204 	addi	fp,sp,8
8111d7cc:	e13ffe15 	stw	r4,-8(fp)
8111d7d0:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
8111d7d4:	e0bffe17 	ldw	r2,-8(fp)
8111d7d8:	e0ffff17 	ldw	r3,-4(fp)
8111d7dc:	10c00415 	stw	r3,16(r2)
}
8111d7e0:	0001883a 	nop
8111d7e4:	e037883a 	mov	sp,fp
8111d7e8:	df000017 	ldw	fp,0(sp)
8111d7ec:	dec00104 	addi	sp,sp,4
8111d7f0:	f800283a 	ret

8111d7f4 <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111d7f4:	defffd04 	addi	sp,sp,-12
8111d7f8:	de00012e 	bgeu	sp,et,8111d800 <vChangeDefaultRTValue+0xc>
8111d7fc:	003b68fa 	trap	3
8111d800:	df000215 	stw	fp,8(sp)
8111d804:	df000204 	addi	fp,sp,8
8111d808:	e13ffe15 	stw	r4,-8(fp)
8111d80c:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
8111d810:	0001883a 	nop
8111d814:	e037883a 	mov	sp,fp
8111d818:	df000017 	ldw	fp,0(sp)
8111d81c:	dec00104 	addi	sp,sp,4
8111d820:	f800283a 	ret

8111d824 <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
8111d824:	defffe04 	addi	sp,sp,-8
8111d828:	de00012e 	bgeu	sp,et,8111d830 <vLoadDefaultSyncSource+0xc>
8111d82c:	003b68fa 	trap	3
8111d830:	df000115 	stw	fp,4(sp)
8111d834:	df000104 	addi	fp,sp,4
8111d838:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
8111d83c:	e0bfff17 	ldw	r2,-4(fp)
8111d840:	10000815 	stw	zero,32(r2)
}
8111d844:	0001883a 	nop
8111d848:	e037883a 	mov	sp,fp
8111d84c:	df000017 	ldw	fp,0(sp)
8111d850:	dec00104 	addi	sp,sp,4
8111d854:	f800283a 	ret

8111d858 <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111d858:	defffd04 	addi	sp,sp,-12
8111d85c:	de00012e 	bgeu	sp,et,8111d864 <vChangeSyncSource+0xc>
8111d860:	003b68fa 	trap	3
8111d864:	df000215 	stw	fp,8(sp)
8111d868:	df000204 	addi	fp,sp,8
8111d86c:	e13ffe15 	stw	r4,-8(fp)
8111d870:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
8111d874:	e0bffe17 	ldw	r2,-8(fp)
8111d878:	e0ffff17 	ldw	r3,-4(fp)
8111d87c:	10c00815 	stw	r3,32(r2)
}
8111d880:	0001883a 	nop
8111d884:	e037883a 	mov	sp,fp
8111d888:	df000017 	ldw	fp,0(sp)
8111d88c:	dec00104 	addi	sp,sp,4
8111d890:	f800283a 	ret

8111d894 <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111d894:	defffd04 	addi	sp,sp,-12
8111d898:	de00012e 	bgeu	sp,et,8111d8a0 <vChangeDefaultSyncSource+0xc>
8111d89c:	003b68fa 	trap	3
8111d8a0:	df000215 	stw	fp,8(sp)
8111d8a4:	df000204 	addi	fp,sp,8
8111d8a8:	e13ffe15 	stw	r4,-8(fp)
8111d8ac:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
8111d8b0:	0001883a 	nop
8111d8b4:	e037883a 	mov	sp,fp
8111d8b8:	df000017 	ldw	fp,0(sp)
8111d8bc:	dec00104 	addi	sp,sp,4
8111d8c0:	f800283a 	ret

8111d8c4 <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
8111d8c4:	defffe04 	addi	sp,sp,-8
8111d8c8:	de00012e 	bgeu	sp,et,8111d8d0 <vLoadDefaultAutoResetSync+0xc>
8111d8cc:	003b68fa 	trap	3
8111d8d0:	df000115 	stw	fp,4(sp)
8111d8d4:	df000104 	addi	fp,sp,4
8111d8d8:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoResetSyncMode = TRUE;
8111d8dc:	e0bfff17 	ldw	r2,-4(fp)
8111d8e0:	00c00044 	movi	r3,1
8111d8e4:	10c00915 	stw	r3,36(r2)
}
8111d8e8:	0001883a 	nop
8111d8ec:	e037883a 	mov	sp,fp
8111d8f0:	df000017 	ldw	fp,0(sp)
8111d8f4:	dec00104 	addi	sp,sp,4
8111d8f8:	f800283a 	ret

8111d8fc <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111d8fc:	defffd04 	addi	sp,sp,-12
8111d900:	de00012e 	bgeu	sp,et,8111d908 <vChangeAutoResetSync+0xc>
8111d904:	003b68fa 	trap	3
8111d908:	df000215 	stw	fp,8(sp)
8111d90c:	df000204 	addi	fp,sp,8
8111d910:	e13ffe15 	stw	r4,-8(fp)
8111d914:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoResetSyncMode = bAutoReset;
8111d918:	e0bffe17 	ldw	r2,-8(fp)
8111d91c:	e0ffff17 	ldw	r3,-4(fp)
8111d920:	10c00915 	stw	r3,36(r2)
}
8111d924:	0001883a 	nop
8111d928:	e037883a 	mov	sp,fp
8111d92c:	df000017 	ldw	fp,0(sp)
8111d930:	dec00104 	addi	sp,sp,4
8111d934:	f800283a 	ret

8111d938 <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111d938:	defffd04 	addi	sp,sp,-12
8111d93c:	de00012e 	bgeu	sp,et,8111d944 <vChangeDefaultAutoResetSync+0xc>
8111d940:	003b68fa 	trap	3
8111d944:	df000215 	stw	fp,8(sp)
8111d948:	df000204 	addi	fp,sp,8
8111d94c:	e13ffe15 	stw	r4,-8(fp)
8111d950:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
8111d954:	0001883a 	nop
8111d958:	e037883a 	mov	sp,fp
8111d95c:	df000017 	ldw	fp,0(sp)
8111d960:	dec00104 	addi	sp,sp,4
8111d964:	f800283a 	ret

8111d968 <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
8111d968:	defffc04 	addi	sp,sp,-16
8111d96c:	de00012e 	bgeu	sp,et,8111d974 <vSyncReset+0xc>
8111d970:	003b68fa 	trap	3
8111d974:	dfc00315 	stw	ra,12(sp)
8111d978:	df000215 	stw	fp,8(sp)
8111d97c:	df000204 	addi	fp,sp,8
8111d980:	e13ffe15 	stw	r4,-8(fp)
8111d984:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
8111d988:	e0bffe17 	ldw	r2,-8(fp)
8111d98c:	10801204 	addi	r2,r2,72
8111d990:	1009883a 	mov	r4,r2
8111d994:	111d3d00 	call	8111d3d0 <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
8111d998:	0001883a 	nop
8111d99c:	e037883a 	mov	sp,fp
8111d9a0:	dfc00117 	ldw	ra,4(sp)
8111d9a4:	df000017 	ldw	fp,0(sp)
8111d9a8:	dec00204 	addi	sp,sp,8
8111d9ac:	f800283a 	ret

8111d9b0 <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
8111d9b0:	defff004 	addi	sp,sp,-64
8111d9b4:	de00012e 	bgeu	sp,et,8111d9bc <pattern_createPattern+0xc>
8111d9b8:	003b68fa 	trap	3
8111d9bc:	dfc00f15 	stw	ra,60(sp)
8111d9c0:	df000e15 	stw	fp,56(sp)
8111d9c4:	dcc00d15 	stw	r19,52(sp)
8111d9c8:	dc800c15 	stw	r18,48(sp)
8111d9cc:	dc400b15 	stw	r17,44(sp)
8111d9d0:	dc000a15 	stw	r16,40(sp)
8111d9d4:	df000e04 	addi	fp,sp,56
8111d9d8:	e17ff915 	stw	r5,-28(fp)
8111d9dc:	3007883a 	mov	r3,r6
8111d9e0:	3805883a 	mov	r2,r7
8111d9e4:	e13ff805 	stb	r4,-32(fp)
8111d9e8:	e0fffa05 	stb	r3,-24(fp)
8111d9ec:	e0bffb05 	stb	r2,-20(fp)
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
8111d9f0:	e0bff803 	ldbu	r2,-32(fp)
8111d9f4:	1009883a 	mov	r4,r2
8111d9f8:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
8111d9fc:	e0bff917 	ldw	r2,-28(fp)
8111da00:	e0bff215 	stw	r2,-56(fp)
	alt_u8 i = 0;
8111da04:	e03ff305 	stb	zero,-52(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
8111da08:	e0bff217 	ldw	r2,-56(fp)
8111da0c:	e0bff415 	stw	r2,-48(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111da10:	e03ff515 	stw	zero,-44(fp)
8111da14:	00003606 	br	8111daf0 <pattern_createPattern+0x140>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111da18:	e03ff615 	stw	zero,-40(fp)
8111da1c:	00002e06 	br	8111dad8 <pattern_createPattern+0x128>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
8111da20:	e0bff303 	ldbu	r2,-52(fp)
8111da24:	10801018 	cmpnei	r2,r2,64
8111da28:	10000b1e 	bne	r2,zero,8111da58 <pattern_createPattern+0xa8>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
8111da2c:	e0bff417 	ldw	r2,-48(fp)
8111da30:	00ffffc4 	movi	r3,-1
8111da34:	10c02015 	stw	r3,128(r2)
8111da38:	00ffffc4 	movi	r3,-1
8111da3c:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
8111da40:	e0bff217 	ldw	r2,-56(fp)
8111da44:	10802204 	addi	r2,r2,136
8111da48:	e0bff215 	stw	r2,-56(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
8111da4c:	e0bff217 	ldw	r2,-56(fp)
8111da50:	e0bff415 	stw	r2,-48(fp)
				i = 0;
8111da54:	e03ff305 	stb	zero,-52(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
8111da58:	e0bff303 	ldbu	r2,-52(fp)
8111da5c:	10c00044 	addi	r3,r2,1
8111da60:	e0fff305 	stb	r3,-52(fp)
8111da64:	10803fcc 	andi	r2,r2,255
8111da68:	e0fffa03 	ldbu	r3,-24(fp)
8111da6c:	18c000cc 	andi	r3,r3,3
8111da70:	180692fa 	slli	r3,r3,11
8111da74:	1809883a 	mov	r4,r3
8111da78:	00f80004 	movi	r3,-8192
8111da7c:	20c6b03a 	or	r3,r4,r3
8111da80:	1809883a 	mov	r4,r3
8111da84:	e0fffb03 	ldbu	r3,-20(fp)
8111da88:	18c0004c 	andi	r3,r3,1
8111da8c:	180692ba 	slli	r3,r3,10
8111da90:	20c6b03a 	or	r3,r4,r3
8111da94:	1809883a 	mov	r4,r3
8111da98:	e0fff517 	ldw	r3,-44(fp)
8111da9c:	18c007cc 	andi	r3,r3,31
8111daa0:	1806917a 	slli	r3,r3,5
8111daa4:	20c6b03a 	or	r3,r4,r3
8111daa8:	1809883a 	mov	r4,r3
8111daac:	e0fff617 	ldw	r3,-40(fp)
8111dab0:	18c007cc 	andi	r3,r3,31
8111dab4:	20c6b03a 	or	r3,r4,r3
8111dab8:	1809883a 	mov	r4,r3
8111dabc:	e0fff417 	ldw	r3,-48(fp)
8111dac0:	1085883a 	add	r2,r2,r2
8111dac4:	1885883a 	add	r2,r3,r2
8111dac8:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111dacc:	e0bff617 	ldw	r2,-40(fp)
8111dad0:	10800044 	addi	r2,r2,1
8111dad4:	e0bff615 	stw	r2,-40(fp)
8111dad8:	e0fff617 	ldw	r3,-40(fp)
8111dadc:	e0800217 	ldw	r2,8(fp)
8111dae0:	18bfcf36 	bltu	r3,r2,8111da20 <__reset+0xfb0fda20>
{
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111dae4:	e0bff517 	ldw	r2,-44(fp)
8111dae8:	10800044 	addi	r2,r2,1
8111daec:	e0bff515 	stw	r2,-44(fp)
8111daf0:	e0fff517 	ldw	r3,-44(fp)
8111daf4:	e0800317 	ldw	r2,12(fp)
8111daf8:	18bfc736 	bltu	r3,r2,8111da18 <__reset+0xfb0fda18>
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
8111dafc:	e0bff303 	ldbu	r2,-52(fp)
8111db00:	e0bff705 	stb	r2,-36(fp)
8111db04:	00000806 	br	8111db28 <pattern_createPattern+0x178>
	{
		pxPixelData->usiPixel[j] = 0;
8111db08:	e0bff703 	ldbu	r2,-36(fp)
8111db0c:	e0fff417 	ldw	r3,-48(fp)
8111db10:	1085883a 	add	r2,r2,r2
8111db14:	1885883a 	add	r2,r3,r2
8111db18:	1000000d 	sth	zero,0(r2)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
8111db1c:	e0bff703 	ldbu	r2,-36(fp)
8111db20:	10800044 	addi	r2,r2,1
8111db24:	e0bff705 	stb	r2,-36(fp)
8111db28:	e0bff703 	ldbu	r2,-36(fp)
8111db2c:	10801030 	cmpltui	r2,r2,64
8111db30:	103ff51e 	bne	r2,zero,8111db08 <__reset+0xfb0fdb08>
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
8111db34:	e0bff417 	ldw	r2,-48(fp)
8111db38:	10002015 	stw	zero,128(r2)
8111db3c:	10002115 	stw	zero,132(r2)
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111db40:	e03ff745 	stb	zero,-35(fp)
8111db44:	00001106 	br	8111db8c <pattern_createPattern+0x1dc>
	{
		pxPixelData->ulliMask |= 1 << j;
8111db48:	e13ff417 	ldw	r4,-48(fp)
8111db4c:	20802017 	ldw	r2,128(r4)
8111db50:	20c02117 	ldw	r3,132(r4)
8111db54:	e13ff743 	ldbu	r4,-35(fp)
8111db58:	01400044 	movi	r5,1
8111db5c:	2908983a 	sll	r4,r5,r4
8111db60:	2025883a 	mov	r18,r4
8111db64:	2009d7fa 	srai	r4,r4,31
8111db68:	2027883a 	mov	r19,r4
8111db6c:	14a0b03a 	or	r16,r2,r18
8111db70:	1ce2b03a 	or	r17,r3,r19
8111db74:	e0bff417 	ldw	r2,-48(fp)
8111db78:	14002015 	stw	r16,128(r2)
8111db7c:	14402115 	stw	r17,132(r2)
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111db80:	e0bff743 	ldbu	r2,-35(fp)
8111db84:	10800044 	addi	r2,r2,1
8111db88:	e0bff745 	stb	r2,-35(fp)
8111db8c:	e0fff743 	ldbu	r3,-35(fp)
8111db90:	e0bff303 	ldbu	r2,-52(fp)
8111db94:	18bfec36 	bltu	r3,r2,8111db48 <__reset+0xfb0fdb48>
	{
		pxPixelData->ulliMask |= 1 << j;
	}
	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
8111db98:	e0bff217 	ldw	r2,-56(fp)
8111db9c:	10802204 	addi	r2,r2,136
8111dba0:	e0bff215 	stw	r2,-56(fp)
	return offset;
8111dba4:	e0bff217 	ldw	r2,-56(fp)
}
8111dba8:	e6fffc04 	addi	sp,fp,-16
8111dbac:	dfc00517 	ldw	ra,20(sp)
8111dbb0:	df000417 	ldw	fp,16(sp)
8111dbb4:	dcc00317 	ldw	r19,12(sp)
8111dbb8:	dc800217 	ldw	r18,8(sp)
8111dbbc:	dc400117 	ldw	r17,4(sp)
8111dbc0:	dc000017 	ldw	r16,0(sp)
8111dbc4:	dec00604 	addi	sp,sp,24
8111dbc8:	f800283a 	ret

8111dbcc <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
8111dbcc:	defffe04 	addi	sp,sp,-8
8111dbd0:	de00012e 	bgeu	sp,et,8111dbd8 <bSDcardIsPresent+0xc>
8111dbd4:	003b68fa 	trap	3
8111dbd8:	dfc00115 	stw	ra,4(sp)
8111dbdc:	df000015 	stw	fp,0(sp)
8111dbe0:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
8111dbe4:	11441140 	call	81144114 <alt_up_sd_card_is_Present>
}
8111dbe8:	e037883a 	mov	sp,fp
8111dbec:	dfc00117 	ldw	ra,4(sp)
8111dbf0:	df000017 	ldw	fp,0(sp)
8111dbf4:	dec00204 	addi	sp,sp,8
8111dbf8:	f800283a 	ret

8111dbfc <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
8111dbfc:	defffe04 	addi	sp,sp,-8
8111dc00:	de00012e 	bgeu	sp,et,8111dc08 <bSDcardFAT16Check+0xc>
8111dc04:	003b68fa 	trap	3
8111dc08:	dfc00115 	stw	ra,4(sp)
8111dc0c:	df000015 	stw	fp,0(sp)
8111dc10:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
8111dc14:	11441e00 	call	811441e0 <alt_up_sd_card_is_FAT16>
}
8111dc18:	e037883a 	mov	sp,fp
8111dc1c:	dfc00117 	ldw	ra,4(sp)
8111dc20:	df000017 	ldw	fp,0(sp)
8111dc24:	dec00204 	addi	sp,sp,8
8111dc28:	f800283a 	ret

8111dc2c <bInitializeSDCard>:

bool bInitializeSDCard( void ){
8111dc2c:	defffd04 	addi	sp,sp,-12
8111dc30:	de00012e 	bgeu	sp,et,8111dc38 <bInitializeSDCard+0xc>
8111dc34:	003b68fa 	trap	3
8111dc38:	dfc00215 	stw	ra,8(sp)
8111dc3c:	df000115 	stw	fp,4(sp)
8111dc40:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
8111dc44:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
8111dc48:	d0207615 	stw	zero,-32296(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
8111dc4c:	01204574 	movhi	r4,33045
8111dc50:	213d5c04 	addi	r4,r4,-2704
8111dc54:	11440500 	call	81144050 <alt_up_sd_card_open_dev>
8111dc58:	d0a07615 	stw	r2,-32296(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
8111dc5c:	d0a07617 	ldw	r2,-32296(gp)
8111dc60:	10002226 	beq	r2,zero,8111dcec <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
8111dc64:	111dbcc0 	call	8111dbcc <bSDcardIsPresent>
8111dc68:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
8111dc6c:	e0bfff17 	ldw	r2,-4(fp)
8111dc70:	10001626 	beq	r2,zero,8111dccc <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
8111dc74:	111dbfc0 	call	8111dbfc <bSDcardFAT16Check>
8111dc78:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
8111dc7c:	e0bfff17 	ldw	r2,-4(fp)
8111dc80:	10000a26 	beq	r2,zero,8111dcac <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
8111dc84:	00800044 	movi	r2,1
8111dc88:	d0a07515 	stw	r2,-32300(gp)
				debug(fp, "SD is up.\r\n");
8111dc8c:	d0a06117 	ldw	r2,-32380(gp)
8111dc90:	100f883a 	mov	r7,r2
8111dc94:	018002c4 	movi	r6,11
8111dc98:	01400044 	movi	r5,1
8111dc9c:	01204574 	movhi	r4,33045
8111dca0:	213d6704 	addi	r4,r4,-2660
8111dca4:	1120e540 	call	81120e54 <fwrite>
8111dca8:	00001806 	br	8111dd0c <bInitializeSDCard+0xe0>
			} else {
				/* SD isn't in FAT16 format*/
				debug(fp, "SD Card should be formated in FAT16.\r\n");
8111dcac:	d0a06117 	ldw	r2,-32380(gp)
8111dcb0:	100f883a 	mov	r7,r2
8111dcb4:	01800984 	movi	r6,38
8111dcb8:	01400044 	movi	r5,1
8111dcbc:	01204574 	movhi	r4,33045
8111dcc0:	213d6a04 	addi	r4,r4,-2648
8111dcc4:	1120e540 	call	81120e54 <fwrite>
8111dcc8:	00001006 	br	8111dd0c <bInitializeSDCard+0xe0>
			}
		} else {
			/* There's no SDCard in the slot */
			debug(fp, "There is no SD in the slot.\r\n");
8111dccc:	d0a06117 	ldw	r2,-32380(gp)
8111dcd0:	100f883a 	mov	r7,r2
8111dcd4:	01800744 	movi	r6,29
8111dcd8:	01400044 	movi	r5,1
8111dcdc:	01204574 	movhi	r4,33045
8111dce0:	213d7404 	addi	r4,r4,-2608
8111dce4:	1120e540 	call	81120e54 <fwrite>
8111dce8:	00000806 	br	8111dd0c <bInitializeSDCard+0xe0>
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
8111dcec:	e03fff15 	stw	zero,-4(fp)
		debug(fp, "Unable to open the SDCard device.\r\n");
8111dcf0:	d0a06117 	ldw	r2,-32380(gp)
8111dcf4:	100f883a 	mov	r7,r2
8111dcf8:	018008c4 	movi	r6,35
8111dcfc:	01400044 	movi	r5,1
8111dd00:	01204574 	movhi	r4,33045
8111dd04:	213d7c04 	addi	r4,r4,-2576
8111dd08:	1120e540 	call	81120e54 <fwrite>
	}

	return bSucess;
8111dd0c:	e0bfff17 	ldw	r2,-4(fp)
}
8111dd10:	e037883a 	mov	sp,fp
8111dd14:	dfc00117 	ldw	ra,4(sp)
8111dd18:	df000017 	ldw	fp,0(sp)
8111dd1c:	dec00204 	addi	sp,sp,8
8111dd20:	f800283a 	ret

8111dd24 <siOpenFile>:
	}
	return (char)readCharacter;
}
*/

short int siOpenFile( char *filename ) {
8111dd24:	defffd04 	addi	sp,sp,-12
8111dd28:	de00012e 	bgeu	sp,et,8111dd30 <siOpenFile+0xc>
8111dd2c:	003b68fa 	trap	3
8111dd30:	dfc00215 	stw	ra,8(sp)
8111dd34:	df000115 	stw	fp,4(sp)
8111dd38:	df000104 	addi	fp,sp,4
8111dd3c:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
8111dd40:	000b883a 	mov	r5,zero
8111dd44:	e13fff17 	ldw	r4,-4(fp)
8111dd48:	11446ec0 	call	811446ec <alt_up_sd_card_fopen>
}
8111dd4c:	e037883a 	mov	sp,fp
8111dd50:	dfc00117 	ldw	ra,4(sp)
8111dd54:	df000017 	ldw	fp,0(sp)
8111dd58:	dec00204 	addi	sp,sp,8
8111dd5c:	f800283a 	ret

8111dd60 <siCloseFile>:

bool siCloseFile( short int file_handle ) {
8111dd60:	defffd04 	addi	sp,sp,-12
8111dd64:	de00012e 	bgeu	sp,et,8111dd6c <siCloseFile+0xc>
8111dd68:	003b68fa 	trap	3
8111dd6c:	dfc00215 	stw	ra,8(sp)
8111dd70:	df000115 	stw	fp,4(sp)
8111dd74:	df000104 	addi	fp,sp,4
8111dd78:	2005883a 	mov	r2,r4
8111dd7c:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
8111dd80:	e0bfff0f 	ldh	r2,-4(fp)
8111dd84:	1009883a 	mov	r4,r2
8111dd88:	11455380 	call	81145538 <alt_up_sd_card_fclose>
}
8111dd8c:	e037883a 	mov	sp,fp
8111dd90:	dfc00117 	ldw	ra,4(sp)
8111dd94:	df000017 	ldw	fp,0(sp)
8111dd98:	dec00204 	addi	sp,sp,8
8111dd9c:	f800283a 	ret

8111dda0 <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
8111dda0:	defffd04 	addi	sp,sp,-12
8111dda4:	de00012e 	bgeu	sp,et,8111ddac <cGetNextChar+0xc>
8111dda8:	003b68fa 	trap	3
8111ddac:	dfc00215 	stw	ra,8(sp)
8111ddb0:	df000115 	stw	fp,4(sp)
8111ddb4:	df000104 	addi	fp,sp,4
8111ddb8:	2005883a 	mov	r2,r4
8111ddbc:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
8111ddc0:	e0bfff0f 	ldh	r2,-4(fp)
8111ddc4:	1009883a 	mov	r4,r2
8111ddc8:	1144b900 	call	81144b90 <alt_up_sd_card_read>
}
8111ddcc:	e037883a 	mov	sp,fp
8111ddd0:	dfc00117 	ldw	ra,4(sp)
8111ddd4:	df000017 	ldw	fp,0(sp)
8111ddd8:	dec00204 	addi	sp,sp,8
8111dddc:	f800283a 	ret

8111dde0 <bInitSync>:

#include "sync_handler.h"

/* todo: Create a struct that will contain all config, and pass as parameter to the functions */

bool bInitSync( void ) {
8111dde0:	defffc04 	addi	sp,sp,-16
8111dde4:	de00012e 	bgeu	sp,et,8111ddec <bInitSync+0xc>
8111dde8:	003b68fa 	trap	3
8111ddec:	dfc00315 	stw	ra,12(sp)
8111ddf0:	df000215 	stw	fp,8(sp)
8111ddf4:	df000204 	addi	fp,sp,8
	bool	bSuccess;
	alt_u32	aux_32;

	vSyncInitIrq();
8111ddf8:	110cb1c0 	call	8110cb1c <vSyncInitIrq>

	#ifdef DEBUG_ON
		debug(fp, "Initializing Sync Module.\n");
8111ddfc:	d0a06117 	ldw	r2,-32380(gp)
8111de00:	100f883a 	mov	r7,r2
8111de04:	01800684 	movi	r6,26
8111de08:	01400044 	movi	r5,1
8111de0c:	01204574 	movhi	r4,33045
8111de10:	213d8504 	addi	r4,r4,-2540
8111de14:	1120e540 	call	81120e54 <fwrite>
	#endif

	// Configura um padro de sync interno
	// MBT => 400 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetMbt(MBT);
8111de18:	01004c74 	movhi	r4,305
8111de1c:	210b4004 	addi	r4,r4,11520
8111de20:	110cd240 	call	8110cd24 <bSyncSetMbt>
8111de24:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111de28:	e0bffe17 	ldw	r2,-8(fp)
8111de2c:	1000091e 	bne	r2,zero,8111de54 <bInitSync+0x74>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111de30:	d0a06117 	ldw	r2,-32380(gp)
8111de34:	100f883a 	mov	r7,r2
8111de38:	018005c4 	movi	r6,23
8111de3c:	01400044 	movi	r5,1
8111de40:	01204574 	movhi	r4,33045
8111de44:	213d8c04 	addi	r4,r4,-2512
8111de48:	1120e540 	call	81120e54 <fwrite>
		#endif
		return bSuccess;
8111de4c:	e0bffe17 	ldw	r2,-8(fp)
8111de50:	00007f06 	br	8111e050 <bInitSync+0x270>
	}

	// BT => 200 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetBt(BT);
8111de54:	01002674 	movhi	r4,153
8111de58:	2125a004 	addi	r4,r4,-27008
8111de5c:	110cd640 	call	8110cd64 <bSyncSetBt>
8111de60:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111de64:	e0bffe17 	ldw	r2,-8(fp)
8111de68:	1000091e 	bne	r2,zero,8111de90 <bInitSync+0xb0>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111de6c:	d0a06117 	ldw	r2,-32380(gp)
8111de70:	100f883a 	mov	r7,r2
8111de74:	018005c4 	movi	r6,23
8111de78:	01400044 	movi	r5,1
8111de7c:	01204574 	movhi	r4,33045
8111de80:	213d8c04 	addi	r4,r4,-2512
8111de84:	1120e540 	call	81120e54 <fwrite>
		#endif
		return bSuccess;
8111de88:	e0bffe17 	ldw	r2,-8(fp)
8111de8c:	00007006 	br	8111e050 <bInitSync+0x270>
	}

	// PER => 6,25s @ 20 ns (50 MHz)
	bSuccess = bSyncSetPer(  uliPerCalcPeriodMs( xDefaults.usiSyncPeriod ) );
8111de90:	00a045b4 	movhi	r2,33046
8111de94:	10975904 	addi	r2,r2,23908
8111de98:	1080068b 	ldhu	r2,26(r2)
8111de9c:	10bfffcc 	andi	r2,r2,65535
8111dea0:	1009883a 	mov	r4,r2
8111dea4:	110d9fc0 	call	8110d9fc <uliPerCalcPeriodMs>
8111dea8:	1009883a 	mov	r4,r2
8111deac:	110cda40 	call	8110cda4 <bSyncSetPer>
8111deb0:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111deb4:	e0bffe17 	ldw	r2,-8(fp)
8111deb8:	1000091e 	bne	r2,zero,8111dee0 <bInitSync+0x100>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111debc:	d0a06117 	ldw	r2,-32380(gp)
8111dec0:	100f883a 	mov	r7,r2
8111dec4:	018005c4 	movi	r6,23
8111dec8:	01400044 	movi	r5,1
8111decc:	01204574 	movhi	r4,33045
8111ded0:	213d8c04 	addi	r4,r4,-2512
8111ded4:	1120e540 	call	81120e54 <fwrite>
		#endif
		return bSuccess;
8111ded8:	e0bffe17 	ldw	r2,-8(fp)
8111dedc:	00005c06 	br	8111e050 <bInitSync+0x270>
	}

	// OST => 500 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetOst(OST);
8111dee0:	01005f74 	movhi	r4,381
8111dee4:	211e1004 	addi	r4,r4,30784
8111dee8:	110cde40 	call	8110cde4 <bSyncSetOst>
8111deec:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111def0:	e0bffe17 	ldw	r2,-8(fp)
8111def4:	1000091e 	bne	r2,zero,8111df1c <bInitSync+0x13c>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111def8:	d0a06117 	ldw	r2,-32380(gp)
8111defc:	100f883a 	mov	r7,r2
8111df00:	018005c4 	movi	r6,23
8111df04:	01400044 	movi	r5,1
8111df08:	01204574 	movhi	r4,33045
8111df0c:	213d8c04 	addi	r4,r4,-2512
8111df10:	1120e540 	call	81120e54 <fwrite>
		#endif
		return bSuccess;
8111df14:	e0bffe17 	ldw	r2,-8(fp)
8111df18:	00004d06 	br	8111e050 <bInitSync+0x270>
	}


	// Polaridade
	bSuccess = bSyncSetPolarity(POL);
8111df1c:	0009883a 	mov	r4,zero
8111df20:	110ce240 	call	8110ce24 <bSyncSetPolarity>
8111df24:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111df28:	e0bffe17 	ldw	r2,-8(fp)
8111df2c:	1000091e 	bne	r2,zero,8111df54 <bInitSync+0x174>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111df30:	d0a06117 	ldw	r2,-32380(gp)
8111df34:	100f883a 	mov	r7,r2
8111df38:	018005c4 	movi	r6,23
8111df3c:	01400044 	movi	r5,1
8111df40:	01204574 	movhi	r4,33045
8111df44:	213d8c04 	addi	r4,r4,-2512
8111df48:	1120e540 	call	81120e54 <fwrite>
		#endif
		return bSuccess;
8111df4c:	e0bffe17 	ldw	r2,-8(fp)
8111df50:	00003f06 	br	8111e050 <bInitSync+0x270>
	}

	// N. de ciclos
	bSuccess = bSyncSetNCycles(N_CICLOS);
8111df54:	01000104 	movi	r4,4
8111df58:	110ce980 	call	8110ce98 <bSyncSetNCycles>
8111df5c:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111df60:	e0bffe17 	ldw	r2,-8(fp)
8111df64:	1000091e 	bne	r2,zero,8111df8c <bInitSync+0x1ac>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111df68:	d0a06117 	ldw	r2,-32380(gp)
8111df6c:	100f883a 	mov	r7,r2
8111df70:	018005c4 	movi	r6,23
8111df74:	01400044 	movi	r5,1
8111df78:	01204574 	movhi	r4,33045
8111df7c:	213d8c04 	addi	r4,r4,-2512
8111df80:	1120e540 	call	81120e54 <fwrite>
		#endif
		return bSuccess;
8111df84:	e0bffe17 	ldw	r2,-8(fp)
8111df88:	00003106 	br	8111e050 <bInitSync+0x270>
	}

	// Altera mux para sync interno
	bSuccess = bSyncCtrExtnIrq(TRUE);
8111df8c:	01000044 	movi	r4,1
8111df90:	110d0740 	call	8110d074 <bSyncCtrExtnIrq>
8111df94:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111df98:	e0bffe17 	ldw	r2,-8(fp)
8111df9c:	1000091e 	bne	r2,zero,8111dfc4 <bInitSync+0x1e4>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111dfa0:	d0a06117 	ldw	r2,-32380(gp)
8111dfa4:	100f883a 	mov	r7,r2
8111dfa8:	018005c4 	movi	r6,23
8111dfac:	01400044 	movi	r5,1
8111dfb0:	01204574 	movhi	r4,33045
8111dfb4:	213d8c04 	addi	r4,r4,-2512
8111dfb8:	1120e540 	call	81120e54 <fwrite>
		#endif
		return bSuccess;
8111dfbc:	e0bffe17 	ldw	r2,-8(fp)
8111dfc0:	00002306 	br	8111e050 <bInitSync+0x270>
	}

	// Habilita sync_out enable (deve aparecer na sada o sync int.)
	bSuccess = bSyncCtrSyncOutEnable(TRUE);
8111dfc4:	01000044 	movi	r4,1
8111dfc8:	110d23c0 	call	8110d23c <bSyncCtrSyncOutEnable>
8111dfcc:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111dfd0:	e0bffe17 	ldw	r2,-8(fp)
8111dfd4:	1000091e 	bne	r2,zero,8111dffc <bInitSync+0x21c>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111dfd8:	d0a06117 	ldw	r2,-32380(gp)
8111dfdc:	100f883a 	mov	r7,r2
8111dfe0:	018005c4 	movi	r6,23
8111dfe4:	01400044 	movi	r5,1
8111dfe8:	01204574 	movhi	r4,33045
8111dfec:	213d8c04 	addi	r4,r4,-2512
8111dff0:	1120e540 	call	81120e54 <fwrite>
		#endif
		return bSuccess;
8111dff4:	e0bffe17 	ldw	r2,-8(fp)
8111dff8:	00001506 	br	8111e050 <bInitSync+0x270>
	}

	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh1OutEnable(TRUE);
8111dffc:	01000044 	movi	r4,1
8111e000:	110d2b00 	call	8110d2b0 <bSyncCtrCh1OutEnable>
8111e004:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111e008:	e0bffe17 	ldw	r2,-8(fp)
8111e00c:	1000091e 	bne	r2,zero,8111e034 <bInitSync+0x254>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111e010:	d0a06117 	ldw	r2,-32380(gp)
8111e014:	100f883a 	mov	r7,r2
8111e018:	018005c4 	movi	r6,23
8111e01c:	01400044 	movi	r5,1
8111e020:	01204574 	movhi	r4,33045
8111e024:	213d8c04 	addi	r4,r4,-2512
8111e028:	1120e540 	call	81120e54 <fwrite>
		#endif
		return bSuccess;
8111e02c:	e0bffe17 	ldw	r2,-8(fp)
8111e030:	00000706 	br	8111e050 <bInitSync+0x270>
	}

	bSuccess = bSyncCtrStart();
8111e034:	110d0ec0 	call	8110d0ec <bSyncCtrStart>
8111e038:	e0bffe15 	stw	r2,-8(fp)
	bSyncCtrReset();
8111e03c:	110d1400 	call	8110d140 <bSyncCtrReset>
	aux_32 = bSyncIrqEnableBlank(TRUE);
8111e040:	01000044 	movi	r4,1
8111e044:	110d6c40 	call	8110d6c4 <bSyncIrqEnableBlank>
8111e048:	e0bfff15 	stw	r2,-4(fp)


	return bSuccess;
8111e04c:	e0bffe17 	ldw	r2,-8(fp)
}
8111e050:	e037883a 	mov	sp,fp
8111e054:	dfc00117 	ldw	ra,4(sp)
8111e058:	df000017 	ldw	fp,0(sp)
8111e05c:	dec00204 	addi	sp,sp,8
8111e060:	f800283a 	ret

8111e064 <bStartSync>:


bool bStartSync(void) {
8111e064:	defffd04 	addi	sp,sp,-12
8111e068:	de00012e 	bgeu	sp,et,8111e070 <bStartSync+0xc>
8111e06c:	003b68fa 	trap	3
8111e070:	dfc00215 	stw	ra,8(sp)
8111e074:	df000115 	stw	fp,4(sp)
8111e078:	df000104 	addi	fp,sp,4

	bool bSuccess;
	bSyncCtrReset();
8111e07c:	110d1400 	call	8110d140 <bSyncCtrReset>
	bSuccess = bSyncCtrStart();
8111e080:	110d0ec0 	call	8110d0ec <bSyncCtrStart>
8111e084:	e0bfff15 	stw	r2,-4(fp)

	return bSuccess;
8111e088:	e0bfff17 	ldw	r2,-4(fp)
}
8111e08c:	e037883a 	mov	sp,fp
8111e090:	dfc00117 	ldw	ra,4(sp)
8111e094:	df000017 	ldw	fp,0(sp)
8111e098:	dec00204 	addi	sp,sp,8
8111e09c:	f800283a 	ret

8111e0a0 <bStopSync>:

bool bStopSync(void) {
8111e0a0:	defffe04 	addi	sp,sp,-8
8111e0a4:	de00012e 	bgeu	sp,et,8111e0ac <bStopSync+0xc>
8111e0a8:	003b68fa 	trap	3
8111e0ac:	dfc00115 	stw	ra,4(sp)
8111e0b0:	df000015 	stw	fp,0(sp)
8111e0b4:	d839883a 	mov	fp,sp
	return bSyncCtrReset();
8111e0b8:	110d1400 	call	8110d140 <bSyncCtrReset>
}
8111e0bc:	e037883a 	mov	sp,fp
8111e0c0:	dfc00117 	ldw	ra,4(sp)
8111e0c4:	df000017 	ldw	fp,0(sp)
8111e0c8:	dec00204 	addi	sp,sp,8
8111e0cc:	f800283a 	ret

8111e0d0 <bClearCounterSync>:

void bClearCounterSync(void) {
8111e0d0:	defffe04 	addi	sp,sp,-8
8111e0d4:	de00012e 	bgeu	sp,et,8111e0dc <bClearCounterSync+0xc>
8111e0d8:	003b68fa 	trap	3
8111e0dc:	dfc00115 	stw	ra,4(sp)
8111e0e0:	df000015 	stw	fp,0(sp)
8111e0e4:	d839883a 	mov	fp,sp

	vSyncClearCounter();
8111e0e8:	110caf00 	call	8110caf0 <vSyncClearCounter>
}
8111e0ec:	0001883a 	nop
8111e0f0:	e037883a 	mov	sp,fp
8111e0f4:	dfc00117 	ldw	ra,4(sp)
8111e0f8:	df000017 	ldw	fp,0(sp)
8111e0fc:	dec00204 	addi	sp,sp,8
8111e100:	f800283a 	ret

8111e104 <bTestSimucamCriticalHW>:
 */


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void ) {
8111e104:	defffd04 	addi	sp,sp,-12
8111e108:	de00012e 	bgeu	sp,et,8111e110 <bTestSimucamCriticalHW+0xc>
8111e10c:	003b68fa 	trap	3
8111e110:	dfc00215 	stw	ra,8(sp)
8111e114:	df000115 	stw	fp,4(sp)
8111e118:	df000104 	addi	fp,sp,4
	/*
	 * Verificar com Frana quais testes podemos realizar aqui
	 * SDcard para criar logs e pegar defaults
	 */

	bSuccess = bSdmaInitM1Dma();
8111e11c:	1103b300 	call	81103b30 <bSdmaInitM1Dma>
8111e120:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8111e124:	e0bfff17 	ldw	r2,-4(fp)
8111e128:	1000021e 	bne	r2,zero,8111e134 <bTestSimucamCriticalHW+0x30>
		return bSuccess;
8111e12c:	e0bfff17 	ldw	r2,-4(fp)
8111e130:	00001106 	br	8111e178 <bTestSimucamCriticalHW+0x74>
	}

	bSuccess = bSdmaInitM2Dma();
8111e134:	1103be00 	call	81103be0 <bSdmaInitM2Dma>
8111e138:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8111e13c:	e0bfff17 	ldw	r2,-4(fp)
8111e140:	1000021e 	bne	r2,zero,8111e14c <bTestSimucamCriticalHW+0x48>
		return bSuccess;
8111e144:	e0bfff17 	ldw	r2,-4(fp)
8111e148:	00000b06 	br	8111e178 <bTestSimucamCriticalHW+0x74>
	}

	xDma[0].pDmaTranfer = bSdmaDmaM1Transfer;
8111e14c:	00a045b4 	movhi	r2,33046
8111e150:	108a9d04 	addi	r2,r2,10868
8111e154:	00e04434 	movhi	r3,33040
8111e158:	18cf2404 	addi	r3,r3,15504
8111e15c:	10c00115 	stw	r3,4(r2)
	xDma[0].pDmaTranfer = bSdmaDmaM2Transfer;
8111e160:	00a045b4 	movhi	r2,33046
8111e164:	108a9d04 	addi	r2,r2,10868
8111e168:	00e04434 	movhi	r3,33040
8111e16c:	18d04604 	addi	r3,r3,16664
8111e170:	10c00115 	stw	r3,4(r2)


	return TRUE;
8111e174:	00800044 	movi	r2,1
}
8111e178:	e037883a 	mov	sp,fp
8111e17c:	dfc00117 	ldw	ra,4(sp)
8111e180:	df000017 	ldw	fp,0(sp)
8111e184:	dec00204 	addi	sp,sp,8
8111e188:	f800283a 	ret

8111e18c <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
8111e18c:	defffc04 	addi	sp,sp,-16
8111e190:	de00012e 	bgeu	sp,et,8111e198 <_reg_write+0xc>
8111e194:	003b68fa 	trap	3
8111e198:	df000315 	stw	fp,12(sp)
8111e19c:	df000304 	addi	fp,sp,12
8111e1a0:	e13ffd15 	stw	r4,-12(fp)
8111e1a4:	e17ffe15 	stw	r5,-8(fp)
8111e1a8:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
8111e1ac:	e0bffe17 	ldw	r2,-8(fp)
8111e1b0:	1085883a 	add	r2,r2,r2
8111e1b4:	1085883a 	add	r2,r2,r2
8111e1b8:	1007883a 	mov	r3,r2
8111e1bc:	e0bffd17 	ldw	r2,-12(fp)
8111e1c0:	1885883a 	add	r2,r3,r2
8111e1c4:	1007883a 	mov	r3,r2
8111e1c8:	e0bfff17 	ldw	r2,-4(fp)
8111e1cc:	18800035 	stwio	r2,0(r3)
	return 1;
8111e1d0:	00800044 	movi	r2,1

}
8111e1d4:	e037883a 	mov	sp,fp
8111e1d8:	df000017 	ldw	fp,0(sp)
8111e1dc:	dec00104 	addi	sp,sp,4
8111e1e0:	f800283a 	ret

8111e1e4 <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
8111e1e4:	defffc04 	addi	sp,sp,-16
8111e1e8:	de00012e 	bgeu	sp,et,8111e1f0 <_reg_read+0xc>
8111e1ec:	003b68fa 	trap	3
8111e1f0:	df000315 	stw	fp,12(sp)
8111e1f4:	df000304 	addi	fp,sp,12
8111e1f8:	e13ffd15 	stw	r4,-12(fp)
8111e1fc:	e17ffe15 	stw	r5,-8(fp)
8111e200:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
8111e204:	e0bffe17 	ldw	r2,-8(fp)
8111e208:	1085883a 	add	r2,r2,r2
8111e20c:	1085883a 	add	r2,r2,r2
8111e210:	1007883a 	mov	r3,r2
8111e214:	e0bffd17 	ldw	r2,-12(fp)
8111e218:	1885883a 	add	r2,r3,r2
8111e21c:	10c00037 	ldwio	r3,0(r2)
8111e220:	e0bfff17 	ldw	r2,-4(fp)
8111e224:	10c00015 	stw	r3,0(r2)
	return 1;
8111e228:	00800044 	movi	r2,1

}
8111e22c:	e037883a 	mov	sp,fp
8111e230:	df000017 	ldw	fp,0(sp)
8111e234:	dec00104 	addi	sp,sp,4
8111e238:	f800283a 	ret

8111e23c <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
8111e23c:	defffa04 	addi	sp,sp,-24
8111e240:	de00012e 	bgeu	sp,et,8111e248 <_print_codec_status+0xc>
8111e244:	003b68fa 	trap	3
8111e248:	dfc00515 	stw	ra,20(sp)
8111e24c:	df000415 	stw	fp,16(sp)
8111e250:	df000404 	addi	fp,sp,16
8111e254:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
8111e258:	e0bfff17 	ldw	r2,-4(fp)
8111e25c:	1005d1ba 	srai	r2,r2,6
8111e260:	1080004c 	andi	r2,r2,1
8111e264:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
8111e268:	e0bfff17 	ldw	r2,-4(fp)
8111e26c:	1005d17a 	srai	r2,r2,5
8111e270:	1080004c 	andi	r2,r2,1
8111e274:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
8111e278:	e0bfff17 	ldw	r2,-4(fp)
8111e27c:	1005d13a 	srai	r2,r2,4
8111e280:	1080004c 	andi	r2,r2,1
8111e284:	e0bffe15 	stw	r2,-8(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "-------- link status \n");
8111e288:	00e04574 	movhi	r3,33045
8111e28c:	18c97504 	addi	r3,r3,9684
8111e290:	00a04574 	movhi	r2,33045
8111e294:	10bd9204 	addi	r2,r2,-2488
8111e298:	1009883a 	mov	r4,r2
8111e29c:	008005c4 	movi	r2,23
8111e2a0:	100d883a 	mov	r6,r2
8111e2a4:	200b883a 	mov	r5,r4
8111e2a8:	1809883a 	mov	r4,r3
8111e2ac:	11218680 	call	81121868 <memcpy>
	debug(fp, cDebugBuffer);
8111e2b0:	d0a06117 	ldw	r2,-32380(gp)
8111e2b4:	01604574 	movhi	r5,33045
8111e2b8:	29497504 	addi	r5,r5,9684
8111e2bc:	1009883a 	mov	r4,r2
8111e2c0:	11207b80 	call	811207b8 <fprintf>
	sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
8111e2c4:	e0bffc17 	ldw	r2,-16(fp)
8111e2c8:	10800058 	cmpnei	r2,r2,1
8111e2cc:	1000031e 	bne	r2,zero,8111e2dc <_print_codec_status+0xa0>
8111e2d0:	00a04574 	movhi	r2,33045
8111e2d4:	10bd9804 	addi	r2,r2,-2464
8111e2d8:	00000206 	br	8111e2e4 <_print_codec_status+0xa8>
8111e2dc:	00a04574 	movhi	r2,33045
8111e2e0:	10bd9904 	addi	r2,r2,-2460
8111e2e4:	100d883a 	mov	r6,r2
8111e2e8:	01604574 	movhi	r5,33045
8111e2ec:	297d9a04 	addi	r5,r5,-2456
8111e2f0:	01204574 	movhi	r4,33045
8111e2f4:	21097504 	addi	r4,r4,9684
8111e2f8:	11221480 	call	81122148 <sprintf>
	debug(fp, cDebugBuffer);
8111e2fc:	d0a06117 	ldw	r2,-32380(gp)
8111e300:	01604574 	movhi	r5,33045
8111e304:	29497504 	addi	r5,r5,9684
8111e308:	1009883a 	mov	r4,r2
8111e30c:	11207b80 	call	811207b8 <fprintf>
	sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
8111e310:	e0bffd17 	ldw	r2,-12(fp)
8111e314:	10800058 	cmpnei	r2,r2,1
8111e318:	1000031e 	bne	r2,zero,8111e328 <_print_codec_status+0xec>
8111e31c:	00a04574 	movhi	r2,33045
8111e320:	10bd9804 	addi	r2,r2,-2464
8111e324:	00000206 	br	8111e330 <_print_codec_status+0xf4>
8111e328:	00a04574 	movhi	r2,33045
8111e32c:	10bd9904 	addi	r2,r2,-2460
8111e330:	100d883a 	mov	r6,r2
8111e334:	01604574 	movhi	r5,33045
8111e338:	297da004 	addi	r5,r5,-2432
8111e33c:	01204574 	movhi	r4,33045
8111e340:	21097504 	addi	r4,r4,9684
8111e344:	11221480 	call	81122148 <sprintf>
	debug(fp, cDebugBuffer);
8111e348:	d0a06117 	ldw	r2,-32380(gp)
8111e34c:	01604574 	movhi	r5,33045
8111e350:	29497504 	addi	r5,r5,9684
8111e354:	1009883a 	mov	r4,r2
8111e358:	11207b80 	call	811207b8 <fprintf>
	sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
8111e35c:	e0bffe17 	ldw	r2,-8(fp)
8111e360:	10800058 	cmpnei	r2,r2,1
8111e364:	1000031e 	bne	r2,zero,8111e374 <_print_codec_status+0x138>
8111e368:	00a04574 	movhi	r2,33045
8111e36c:	10bd9804 	addi	r2,r2,-2464
8111e370:	00000206 	br	8111e37c <_print_codec_status+0x140>
8111e374:	00a04574 	movhi	r2,33045
8111e378:	10bd9904 	addi	r2,r2,-2460
8111e37c:	100d883a 	mov	r6,r2
8111e380:	01604574 	movhi	r5,33045
8111e384:	297da604 	addi	r5,r5,-2408
8111e388:	01204574 	movhi	r4,33045
8111e38c:	21097504 	addi	r4,r4,9684
8111e390:	11221480 	call	81122148 <sprintf>
	debug(fp, cDebugBuffer);
8111e394:	d0a06117 	ldw	r2,-32380(gp)
8111e398:	01604574 	movhi	r5,33045
8111e39c:	29497504 	addi	r5,r5,9684
8111e3a0:	1009883a 	mov	r4,r2
8111e3a4:	11207b80 	call	811207b8 <fprintf>
	sprintf(cDebugBuffer, "--------  \n");
8111e3a8:	00a04574 	movhi	r2,33045
8111e3ac:	10897504 	addi	r2,r2,9684
8111e3b0:	00c00b44 	movi	r3,45
8111e3b4:	10c00005 	stb	r3,0(r2)
8111e3b8:	00c00b44 	movi	r3,45
8111e3bc:	10c00045 	stb	r3,1(r2)
8111e3c0:	00c00b44 	movi	r3,45
8111e3c4:	10c00085 	stb	r3,2(r2)
8111e3c8:	00c00b44 	movi	r3,45
8111e3cc:	10c000c5 	stb	r3,3(r2)
8111e3d0:	00c00b44 	movi	r3,45
8111e3d4:	10c00105 	stb	r3,4(r2)
8111e3d8:	00c00b44 	movi	r3,45
8111e3dc:	10c00145 	stb	r3,5(r2)
8111e3e0:	00c00b44 	movi	r3,45
8111e3e4:	10c00185 	stb	r3,6(r2)
8111e3e8:	00c00b44 	movi	r3,45
8111e3ec:	10c001c5 	stb	r3,7(r2)
8111e3f0:	00c00804 	movi	r3,32
8111e3f4:	10c00205 	stb	r3,8(r2)
8111e3f8:	00c00804 	movi	r3,32
8111e3fc:	10c00245 	stb	r3,9(r2)
8111e400:	00c00284 	movi	r3,10
8111e404:	10c00285 	stb	r3,10(r2)
8111e408:	100002c5 	stb	zero,11(r2)
	debug(fp, cDebugBuffer);
8111e40c:	d0a06117 	ldw	r2,-32380(gp)
8111e410:	01604574 	movhi	r5,33045
8111e414:	29497504 	addi	r5,r5,9684
8111e418:	1009883a 	mov	r4,r2
8111e41c:	11207b80 	call	811207b8 <fprintf>
#endif
}
8111e420:	0001883a 	nop
8111e424:	e037883a 	mov	sp,fp
8111e428:	dfc00117 	ldw	ra,4(sp)
8111e42c:	df000017 	ldw	fp,0(sp)
8111e430:	dec00204 	addi	sp,sp,8
8111e434:	f800283a 	ret

8111e438 <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
8111e438:	defffb04 	addi	sp,sp,-20
8111e43c:	de00012e 	bgeu	sp,et,8111e444 <_split_codec_status+0xc>
8111e440:	003b68fa 	trap	3
8111e444:	df000415 	stw	fp,16(sp)
8111e448:	df000404 	addi	fp,sp,16
8111e44c:	e13ffc15 	stw	r4,-16(fp)
8111e450:	e17ffd15 	stw	r5,-12(fp)
8111e454:	e1bffe15 	stw	r6,-8(fp)
8111e458:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
8111e45c:	e0bffc17 	ldw	r2,-16(fp)
8111e460:	1005d1ba 	srai	r2,r2,6
8111e464:	10c0004c 	andi	r3,r2,1
8111e468:	e0bffd17 	ldw	r2,-12(fp)
8111e46c:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
8111e470:	e0bffc17 	ldw	r2,-16(fp)
8111e474:	1005d17a 	srai	r2,r2,5
8111e478:	10c0004c 	andi	r3,r2,1
8111e47c:	e0bffe17 	ldw	r2,-8(fp)
8111e480:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
8111e484:	e0bffc17 	ldw	r2,-16(fp)
8111e488:	1005d13a 	srai	r2,r2,4
8111e48c:	10c0004c 	andi	r3,r2,1
8111e490:	e0bfff17 	ldw	r2,-4(fp)
8111e494:	10c00015 	stw	r3,0(r2)
}
8111e498:	0001883a 	nop
8111e49c:	e037883a 	mov	sp,fp
8111e4a0:	df000017 	ldw	fp,0(sp)
8111e4a4:	dec00104 	addi	sp,sp,4
8111e4a8:	f800283a 	ret

8111e4ac <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
8111e4ac:	defffc04 	addi	sp,sp,-16
8111e4b0:	de00012e 	bgeu	sp,et,8111e4b8 <aatoh+0xc>
8111e4b4:	003b68fa 	trap	3
8111e4b8:	df000315 	stw	fp,12(sp)
8111e4bc:	df000304 	addi	fp,sp,12
8111e4c0:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
8111e4c4:	e0bfff17 	ldw	r2,-4(fp)
8111e4c8:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111e4cc:	e0bffd17 	ldw	r2,-12(fp)
8111e4d0:	10c00003 	ldbu	r3,0(r2)
8111e4d4:	e0bffd17 	ldw	r2,-12(fp)
8111e4d8:	10800003 	ldbu	r2,0(r2)
8111e4dc:	10803fcc 	andi	r2,r2,255
8111e4e0:	10800eb0 	cmpltui	r2,r2,58
8111e4e4:	1000021e 	bne	r2,zero,8111e4f0 <aatoh+0x44>
8111e4e8:	00800dc4 	movi	r2,55
8111e4ec:	00000106 	br	8111e4f4 <aatoh+0x48>
8111e4f0:	00800c04 	movi	r2,48
8111e4f4:	1885c83a 	sub	r2,r3,r2
8111e4f8:	1004913a 	slli	r2,r2,4
8111e4fc:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
8111e500:	e0bffd17 	ldw	r2,-12(fp)
8111e504:	10800044 	addi	r2,r2,1
8111e508:	10c00003 	ldbu	r3,0(r2)
8111e50c:	e0bffd17 	ldw	r2,-12(fp)
8111e510:	10800044 	addi	r2,r2,1
8111e514:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111e518:	10803fcc 	andi	r2,r2,255
8111e51c:	10800eb0 	cmpltui	r2,r2,58
8111e520:	1000021e 	bne	r2,zero,8111e52c <aatoh+0x80>
8111e524:	00800dc4 	movi	r2,55
8111e528:	00000106 	br	8111e530 <aatoh+0x84>
8111e52c:	00800c04 	movi	r2,48
8111e530:	1885c83a 	sub	r2,r3,r2
8111e534:	2085883a 	add	r2,r4,r2
8111e538:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
8111e53c:	e0bffe03 	ldbu	r2,-8(fp)
}
8111e540:	e037883a 	mov	sp,fp
8111e544:	df000017 	ldw	fp,0(sp)
8111e548:	dec00104 	addi	sp,sp,4
8111e54c:	f800283a 	ret

8111e550 <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
8111e550:	defffd04 	addi	sp,sp,-12
8111e554:	de00012e 	bgeu	sp,et,8111e55c <Verif_Error+0xc>
8111e558:	003b68fa 	trap	3
8111e55c:	dfc00215 	stw	ra,8(sp)
8111e560:	df000115 	stw	fp,4(sp)
8111e564:	df000104 	addi	fp,sp,4
8111e568:	2005883a 	mov	r2,r4
8111e56c:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
8111e570:	e0bfff03 	ldbu	r2,-4(fp)
8111e574:	1000091e 	bne	r2,zero,8111e59c <Verif_Error+0x4c>
#ifdef DEBUG_ON
	debug(fp, "ERROR\n\r");
8111e578:	d0a06117 	ldw	r2,-32380(gp)
8111e57c:	100f883a 	mov	r7,r2
8111e580:	018001c4 	movi	r6,7
8111e584:	01400044 	movi	r5,1
8111e588:	01204574 	movhi	r4,33045
8111e58c:	213dac04 	addi	r4,r4,-2384
8111e590:	1120e540 	call	81120e54 <fwrite>
#endif
		return 0;
8111e594:	0005883a 	mov	r2,zero
8111e598:	00000106 	br	8111e5a0 <Verif_Error+0x50>
	} else
		return 1;
8111e59c:	00800044 	movi	r2,1
}
8111e5a0:	e037883a 	mov	sp,fp
8111e5a4:	dfc00117 	ldw	ra,4(sp)
8111e5a8:	df000017 	ldw	fp,0(sp)
8111e5ac:	dec00204 	addi	sp,sp,8
8111e5b0:	f800283a 	ret

8111e5b4 <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
8111e5b4:	defffe04 	addi	sp,sp,-8
8111e5b8:	de00012e 	bgeu	sp,et,8111e5c0 <toInt+0xc>
8111e5bc:	003b68fa 	trap	3
8111e5c0:	df000115 	stw	fp,4(sp)
8111e5c4:	df000104 	addi	fp,sp,4
8111e5c8:	2005883a 	mov	r2,r4
8111e5cc:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
8111e5d0:	e0bfff03 	ldbu	r2,-4(fp)
8111e5d4:	10bff404 	addi	r2,r2,-48
}
8111e5d8:	e037883a 	mov	sp,fp
8111e5dc:	df000017 	ldw	fp,0(sp)
8111e5e0:	dec00104 	addi	sp,sp,4
8111e5e4:	f800283a 	ret

8111e5e8 <__fixunsdfsi>:
8111e5e8:	defffd04 	addi	sp,sp,-12
8111e5ec:	000d883a 	mov	r6,zero
8111e5f0:	01d07834 	movhi	r7,16864
8111e5f4:	de00012e 	bgeu	sp,et,8111e5fc <__fixunsdfsi+0x14>
8111e5f8:	003b68fa 	trap	3
8111e5fc:	dc400115 	stw	r17,4(sp)
8111e600:	dc000015 	stw	r16,0(sp)
8111e604:	dfc00215 	stw	ra,8(sp)
8111e608:	2023883a 	mov	r17,r4
8111e60c:	2821883a 	mov	r16,r5
8111e610:	111f0d40 	call	8111f0d4 <__gedf2>
8111e614:	1000080e 	bge	r2,zero,8111e638 <__fixunsdfsi+0x50>
8111e618:	8809883a 	mov	r4,r17
8111e61c:	800b883a 	mov	r5,r16
8111e620:	11201d40 	call	811201d4 <__fixdfsi>
8111e624:	dfc00217 	ldw	ra,8(sp)
8111e628:	dc400117 	ldw	r17,4(sp)
8111e62c:	dc000017 	ldw	r16,0(sp)
8111e630:	dec00304 	addi	sp,sp,12
8111e634:	f800283a 	ret
8111e638:	000d883a 	mov	r6,zero
8111e63c:	01d07834 	movhi	r7,16864
8111e640:	8809883a 	mov	r4,r17
8111e644:	800b883a 	mov	r5,r16
8111e648:	111f8d00 	call	8111f8d0 <__subdf3>
8111e64c:	180b883a 	mov	r5,r3
8111e650:	1009883a 	mov	r4,r2
8111e654:	11201d40 	call	811201d4 <__fixdfsi>
8111e658:	00e00034 	movhi	r3,32768
8111e65c:	10c5883a 	add	r2,r2,r3
8111e660:	003ff006 	br	8111e624 <__reset+0xfb0fe624>

8111e664 <__divsf3>:
8111e664:	defff504 	addi	sp,sp,-44
8111e668:	200cd5fa 	srli	r6,r4,23
8111e66c:	de00012e 	bgeu	sp,et,8111e674 <__divsf3+0x10>
8111e670:	003b68fa 	trap	3
8111e674:	dcc00415 	stw	r19,16(sp)
8111e678:	2026d7fa 	srli	r19,r4,31
8111e67c:	00c02034 	movhi	r3,128
8111e680:	dd800715 	stw	r22,28(sp)
8111e684:	dd000515 	stw	r20,20(sp)
8111e688:	dc800315 	stw	r18,12(sp)
8111e68c:	18ffffc4 	addi	r3,r3,-1
8111e690:	dfc00a15 	stw	ra,40(sp)
8111e694:	df000915 	stw	fp,36(sp)
8111e698:	ddc00815 	stw	r23,32(sp)
8111e69c:	dd400615 	stw	r21,24(sp)
8111e6a0:	dc400215 	stw	r17,8(sp)
8111e6a4:	dc000115 	stw	r16,4(sp)
8111e6a8:	35003fcc 	andi	r20,r6,255
8111e6ac:	1924703a 	and	r18,r3,r4
8111e6b0:	9d803fcc 	andi	r22,r19,255
8111e6b4:	a0005226 	beq	r20,zero,8111e800 <__divsf3+0x19c>
8111e6b8:	00803fc4 	movi	r2,255
8111e6bc:	a0802e26 	beq	r20,r2,8111e778 <__divsf3+0x114>
8111e6c0:	91002034 	orhi	r4,r18,128
8111e6c4:	202490fa 	slli	r18,r4,3
8111e6c8:	a53fe044 	addi	r20,r20,-127
8111e6cc:	0021883a 	mov	r16,zero
8111e6d0:	002f883a 	mov	r23,zero
8111e6d4:	280cd5fa 	srli	r6,r5,23
8111e6d8:	282ad7fa 	srli	r21,r5,31
8111e6dc:	00c02034 	movhi	r3,128
8111e6e0:	18ffffc4 	addi	r3,r3,-1
8111e6e4:	31803fcc 	andi	r6,r6,255
8111e6e8:	1962703a 	and	r17,r3,r5
8111e6ec:	af003fcc 	andi	fp,r21,255
8111e6f0:	30004a26 	beq	r6,zero,8111e81c <__divsf3+0x1b8>
8111e6f4:	00803fc4 	movi	r2,255
8111e6f8:	30804526 	beq	r6,r2,8111e810 <__divsf3+0x1ac>
8111e6fc:	89402034 	orhi	r5,r17,128
8111e700:	282290fa 	slli	r17,r5,3
8111e704:	31bfe044 	addi	r6,r6,-127
8111e708:	000b883a 	mov	r5,zero
8111e70c:	2c20b03a 	or	r16,r5,r16
8111e710:	802090ba 	slli	r16,r16,2
8111e714:	00a044b4 	movhi	r2,33042
8111e718:	10b9ce04 	addi	r2,r2,-6344
8111e71c:	80a1883a 	add	r16,r16,r2
8111e720:	81000017 	ldw	r4,0(r16)
8111e724:	9d46f03a 	xor	r3,r19,r21
8111e728:	180f883a 	mov	r7,r3
8111e72c:	18803fcc 	andi	r2,r3,255
8111e730:	a18dc83a 	sub	r6,r20,r6
8111e734:	2000683a 	jmp	r4
8111e738:	8111e91c 	xori	r4,r16,18340
8111e73c:	8111e7a0 	cmpeqi	r4,r16,18334
8111e740:	8111e910 	cmplti	r4,r16,18340
8111e744:	8111e78c 	andi	r4,r16,18334
8111e748:	8111e910 	cmplti	r4,r16,18340
8111e74c:	8111e8e8 	cmpgeui	r4,r16,18339
8111e750:	8111e910 	cmplti	r4,r16,18340
8111e754:	8111e78c 	andi	r4,r16,18334
8111e758:	8111e7a0 	cmpeqi	r4,r16,18334
8111e75c:	8111e7a0 	cmpeqi	r4,r16,18334
8111e760:	8111e8e8 	cmpgeui	r4,r16,18339
8111e764:	8111e78c 	andi	r4,r16,18334
8111e768:	8111e9fc 	xorhi	r4,r16,18343
8111e76c:	8111e9fc 	xorhi	r4,r16,18343
8111e770:	8111e9fc 	xorhi	r4,r16,18343
8111e774:	8111e9b0 	cmpltui	r4,r16,18342
8111e778:	9000581e 	bne	r18,zero,8111e8dc <__divsf3+0x278>
8111e77c:	04000204 	movi	r16,8
8111e780:	05c00084 	movi	r23,2
8111e784:	003fd306 	br	8111e6d4 <__reset+0xfb0fe6d4>
8111e788:	0023883a 	mov	r17,zero
8111e78c:	e02d883a 	mov	r22,fp
8111e790:	282f883a 	mov	r23,r5
8111e794:	00800084 	movi	r2,2
8111e798:	b8808f1e 	bne	r23,r2,8111e9d8 <__divsf3+0x374>
8111e79c:	b005883a 	mov	r2,r22
8111e7a0:	11c0004c 	andi	r7,r2,1
8111e7a4:	013fffc4 	movi	r4,-1
8111e7a8:	000d883a 	mov	r6,zero
8111e7ac:	21003fcc 	andi	r4,r4,255
8111e7b0:	200895fa 	slli	r4,r4,23
8111e7b4:	38803fcc 	andi	r2,r7,255
8111e7b8:	00c02034 	movhi	r3,128
8111e7bc:	100497fa 	slli	r2,r2,31
8111e7c0:	18ffffc4 	addi	r3,r3,-1
8111e7c4:	30c6703a 	and	r3,r6,r3
8111e7c8:	1906b03a 	or	r3,r3,r4
8111e7cc:	1884b03a 	or	r2,r3,r2
8111e7d0:	dfc00a17 	ldw	ra,40(sp)
8111e7d4:	df000917 	ldw	fp,36(sp)
8111e7d8:	ddc00817 	ldw	r23,32(sp)
8111e7dc:	dd800717 	ldw	r22,28(sp)
8111e7e0:	dd400617 	ldw	r21,24(sp)
8111e7e4:	dd000517 	ldw	r20,20(sp)
8111e7e8:	dcc00417 	ldw	r19,16(sp)
8111e7ec:	dc800317 	ldw	r18,12(sp)
8111e7f0:	dc400217 	ldw	r17,8(sp)
8111e7f4:	dc000117 	ldw	r16,4(sp)
8111e7f8:	dec00b04 	addi	sp,sp,44
8111e7fc:	f800283a 	ret
8111e800:	90002b1e 	bne	r18,zero,8111e8b0 <__divsf3+0x24c>
8111e804:	04000104 	movi	r16,4
8111e808:	05c00044 	movi	r23,1
8111e80c:	003fb106 	br	8111e6d4 <__reset+0xfb0fe6d4>
8111e810:	8800251e 	bne	r17,zero,8111e8a8 <__divsf3+0x244>
8111e814:	01400084 	movi	r5,2
8111e818:	00000206 	br	8111e824 <__divsf3+0x1c0>
8111e81c:	88001a1e 	bne	r17,zero,8111e888 <__divsf3+0x224>
8111e820:	01400044 	movi	r5,1
8111e824:	8160b03a 	or	r16,r16,r5
8111e828:	802090ba 	slli	r16,r16,2
8111e82c:	00e044b4 	movhi	r3,33042
8111e830:	18fa1204 	addi	r3,r3,-6072
8111e834:	80e1883a 	add	r16,r16,r3
8111e838:	80c00017 	ldw	r3,0(r16)
8111e83c:	9d44f03a 	xor	r2,r19,r21
8111e840:	a18dc83a 	sub	r6,r20,r6
8111e844:	1800683a 	jmp	r3
8111e848:	8111e7a0 	cmpeqi	r4,r16,18334
8111e84c:	8111e7a0 	cmpeqi	r4,r16,18334
8111e850:	8111e9ec 	andhi	r4,r16,18343
8111e854:	8111e788 	cmpgei	r4,r16,18334
8111e858:	8111e9ec 	andhi	r4,r16,18343
8111e85c:	8111e8e8 	cmpgeui	r4,r16,18339
8111e860:	8111e9ec 	andhi	r4,r16,18343
8111e864:	8111e788 	cmpgei	r4,r16,18334
8111e868:	8111e7a0 	cmpeqi	r4,r16,18334
8111e86c:	8111e7a0 	cmpeqi	r4,r16,18334
8111e870:	8111e8e8 	cmpgeui	r4,r16,18339
8111e874:	8111e788 	cmpgei	r4,r16,18334
8111e878:	8111e9fc 	xorhi	r4,r16,18343
8111e87c:	8111e9fc 	xorhi	r4,r16,18343
8111e880:	8111e9fc 	xorhi	r4,r16,18343
8111e884:	8111ea14 	ori	r4,r16,18344
8111e888:	8809883a 	mov	r4,r17
8111e88c:	11205f80 	call	811205f8 <__clzsi2>
8111e890:	10fffec4 	addi	r3,r2,-5
8111e894:	10801d84 	addi	r2,r2,118
8111e898:	88e2983a 	sll	r17,r17,r3
8111e89c:	008dc83a 	sub	r6,zero,r2
8111e8a0:	000b883a 	mov	r5,zero
8111e8a4:	003f9906 	br	8111e70c <__reset+0xfb0fe70c>
8111e8a8:	014000c4 	movi	r5,3
8111e8ac:	003f9706 	br	8111e70c <__reset+0xfb0fe70c>
8111e8b0:	9009883a 	mov	r4,r18
8111e8b4:	d9400015 	stw	r5,0(sp)
8111e8b8:	11205f80 	call	811205f8 <__clzsi2>
8111e8bc:	10fffec4 	addi	r3,r2,-5
8111e8c0:	11801d84 	addi	r6,r2,118
8111e8c4:	90e4983a 	sll	r18,r18,r3
8111e8c8:	01a9c83a 	sub	r20,zero,r6
8111e8cc:	0021883a 	mov	r16,zero
8111e8d0:	002f883a 	mov	r23,zero
8111e8d4:	d9400017 	ldw	r5,0(sp)
8111e8d8:	003f7e06 	br	8111e6d4 <__reset+0xfb0fe6d4>
8111e8dc:	04000304 	movi	r16,12
8111e8e0:	05c000c4 	movi	r23,3
8111e8e4:	003f7b06 	br	8111e6d4 <__reset+0xfb0fe6d4>
8111e8e8:	01802034 	movhi	r6,128
8111e8ec:	000f883a 	mov	r7,zero
8111e8f0:	31bfffc4 	addi	r6,r6,-1
8111e8f4:	013fffc4 	movi	r4,-1
8111e8f8:	003fac06 	br	8111e7ac <__reset+0xfb0fe7ac>
8111e8fc:	01400044 	movi	r5,1
8111e900:	2909c83a 	sub	r4,r5,r4
8111e904:	00c006c4 	movi	r3,27
8111e908:	19004b0e 	bge	r3,r4,8111ea38 <__divsf3+0x3d4>
8111e90c:	114e703a 	and	r7,r2,r5
8111e910:	0009883a 	mov	r4,zero
8111e914:	000d883a 	mov	r6,zero
8111e918:	003fa406 	br	8111e7ac <__reset+0xfb0fe7ac>
8111e91c:	9006917a 	slli	r3,r18,5
8111e920:	8822917a 	slli	r17,r17,5
8111e924:	1c40372e 	bgeu	r3,r17,8111ea04 <__divsf3+0x3a0>
8111e928:	31bfffc4 	addi	r6,r6,-1
8111e92c:	010006c4 	movi	r4,27
8111e930:	000b883a 	mov	r5,zero
8111e934:	180f883a 	mov	r7,r3
8111e938:	294b883a 	add	r5,r5,r5
8111e93c:	18c7883a 	add	r3,r3,r3
8111e940:	38000116 	blt	r7,zero,8111e948 <__divsf3+0x2e4>
8111e944:	1c400236 	bltu	r3,r17,8111e950 <__divsf3+0x2ec>
8111e948:	1c47c83a 	sub	r3,r3,r17
8111e94c:	29400054 	ori	r5,r5,1
8111e950:	213fffc4 	addi	r4,r4,-1
8111e954:	203ff71e 	bne	r4,zero,8111e934 <__reset+0xfb0fe934>
8111e958:	1806c03a 	cmpne	r3,r3,zero
8111e95c:	1962b03a 	or	r17,r3,r5
8111e960:	31001fc4 	addi	r4,r6,127
8111e964:	013fe50e 	bge	zero,r4,8111e8fc <__reset+0xfb0fe8fc>
8111e968:	88c001cc 	andi	r3,r17,7
8111e96c:	18000426 	beq	r3,zero,8111e980 <__divsf3+0x31c>
8111e970:	88c003cc 	andi	r3,r17,15
8111e974:	01400104 	movi	r5,4
8111e978:	19400126 	beq	r3,r5,8111e980 <__divsf3+0x31c>
8111e97c:	8963883a 	add	r17,r17,r5
8111e980:	88c2002c 	andhi	r3,r17,2048
8111e984:	18000426 	beq	r3,zero,8111e998 <__divsf3+0x334>
8111e988:	00fe0034 	movhi	r3,63488
8111e98c:	18ffffc4 	addi	r3,r3,-1
8111e990:	31002004 	addi	r4,r6,128
8111e994:	88e2703a 	and	r17,r17,r3
8111e998:	00c03f84 	movi	r3,254
8111e99c:	193f8016 	blt	r3,r4,8111e7a0 <__reset+0xfb0fe7a0>
8111e9a0:	880c91ba 	slli	r6,r17,6
8111e9a4:	11c0004c 	andi	r7,r2,1
8111e9a8:	300cd27a 	srli	r6,r6,9
8111e9ac:	003f7f06 	br	8111e7ac <__reset+0xfb0fe7ac>
8111e9b0:	9080102c 	andhi	r2,r18,64
8111e9b4:	10000226 	beq	r2,zero,8111e9c0 <__divsf3+0x35c>
8111e9b8:	8880102c 	andhi	r2,r17,64
8111e9bc:	10001826 	beq	r2,zero,8111ea20 <__divsf3+0x3bc>
8111e9c0:	00802034 	movhi	r2,128
8111e9c4:	91801034 	orhi	r6,r18,64
8111e9c8:	10bfffc4 	addi	r2,r2,-1
8111e9cc:	980f883a 	mov	r7,r19
8111e9d0:	308c703a 	and	r6,r6,r2
8111e9d4:	003fc706 	br	8111e8f4 <__reset+0xfb0fe8f4>
8111e9d8:	008000c4 	movi	r2,3
8111e9dc:	b8802d26 	beq	r23,r2,8111ea94 <__divsf3+0x430>
8111e9e0:	00c00044 	movi	r3,1
8111e9e4:	b005883a 	mov	r2,r22
8111e9e8:	b8ffdd1e 	bne	r23,r3,8111e960 <__reset+0xfb0fe960>
8111e9ec:	11c0004c 	andi	r7,r2,1
8111e9f0:	0009883a 	mov	r4,zero
8111e9f4:	000d883a 	mov	r6,zero
8111e9f8:	003f6c06 	br	8111e7ac <__reset+0xfb0fe7ac>
8111e9fc:	9023883a 	mov	r17,r18
8111ea00:	003f6406 	br	8111e794 <__reset+0xfb0fe794>
8111ea04:	1c47c83a 	sub	r3,r3,r17
8111ea08:	01000684 	movi	r4,26
8111ea0c:	01400044 	movi	r5,1
8111ea10:	003fc806 	br	8111e934 <__reset+0xfb0fe934>
8111ea14:	9080102c 	andhi	r2,r18,64
8111ea18:	103fe926 	beq	r2,zero,8111e9c0 <__reset+0xfb0fe9c0>
8111ea1c:	0023883a 	mov	r17,zero
8111ea20:	00802034 	movhi	r2,128
8111ea24:	89801034 	orhi	r6,r17,64
8111ea28:	10bfffc4 	addi	r2,r2,-1
8111ea2c:	a80f883a 	mov	r7,r21
8111ea30:	308c703a 	and	r6,r6,r2
8111ea34:	003faf06 	br	8111e8f4 <__reset+0xfb0fe8f4>
8111ea38:	01c00804 	movi	r7,32
8111ea3c:	390fc83a 	sub	r7,r7,r4
8111ea40:	89ce983a 	sll	r7,r17,r7
8111ea44:	890ad83a 	srl	r5,r17,r4
8111ea48:	380ec03a 	cmpne	r7,r7,zero
8111ea4c:	29cab03a 	or	r5,r5,r7
8111ea50:	28c001cc 	andi	r3,r5,7
8111ea54:	18000426 	beq	r3,zero,8111ea68 <__divsf3+0x404>
8111ea58:	28c003cc 	andi	r3,r5,15
8111ea5c:	01000104 	movi	r4,4
8111ea60:	19000126 	beq	r3,r4,8111ea68 <__divsf3+0x404>
8111ea64:	290b883a 	add	r5,r5,r4
8111ea68:	28c1002c 	andhi	r3,r5,1024
8111ea6c:	18000426 	beq	r3,zero,8111ea80 <__divsf3+0x41c>
8111ea70:	11c0004c 	andi	r7,r2,1
8111ea74:	01000044 	movi	r4,1
8111ea78:	000d883a 	mov	r6,zero
8111ea7c:	003f4b06 	br	8111e7ac <__reset+0xfb0fe7ac>
8111ea80:	280a91ba 	slli	r5,r5,6
8111ea84:	11c0004c 	andi	r7,r2,1
8111ea88:	0009883a 	mov	r4,zero
8111ea8c:	280cd27a 	srli	r6,r5,9
8111ea90:	003f4606 	br	8111e7ac <__reset+0xfb0fe7ac>
8111ea94:	00802034 	movhi	r2,128
8111ea98:	89801034 	orhi	r6,r17,64
8111ea9c:	10bfffc4 	addi	r2,r2,-1
8111eaa0:	b00f883a 	mov	r7,r22
8111eaa4:	308c703a 	and	r6,r6,r2
8111eaa8:	003f9206 	br	8111e8f4 <__reset+0xfb0fe8f4>

8111eaac <__mulsf3>:
8111eaac:	defff504 	addi	sp,sp,-44
8111eab0:	de00012e 	bgeu	sp,et,8111eab8 <__mulsf3+0xc>
8111eab4:	003b68fa 	trap	3
8111eab8:	dc000115 	stw	r16,4(sp)
8111eabc:	2020d5fa 	srli	r16,r4,23
8111eac0:	dd400615 	stw	r21,24(sp)
8111eac4:	202ad7fa 	srli	r21,r4,31
8111eac8:	dc800315 	stw	r18,12(sp)
8111eacc:	04802034 	movhi	r18,128
8111ead0:	df000915 	stw	fp,36(sp)
8111ead4:	dd000515 	stw	r20,20(sp)
8111ead8:	94bfffc4 	addi	r18,r18,-1
8111eadc:	dfc00a15 	stw	ra,40(sp)
8111eae0:	ddc00815 	stw	r23,32(sp)
8111eae4:	dd800715 	stw	r22,28(sp)
8111eae8:	dcc00415 	stw	r19,16(sp)
8111eaec:	dc400215 	stw	r17,8(sp)
8111eaf0:	84003fcc 	andi	r16,r16,255
8111eaf4:	9124703a 	and	r18,r18,r4
8111eaf8:	a829883a 	mov	r20,r21
8111eafc:	af003fcc 	andi	fp,r21,255
8111eb00:	80005426 	beq	r16,zero,8111ec54 <__mulsf3+0x1a8>
8111eb04:	00803fc4 	movi	r2,255
8111eb08:	80802f26 	beq	r16,r2,8111ebc8 <__mulsf3+0x11c>
8111eb0c:	91002034 	orhi	r4,r18,128
8111eb10:	202490fa 	slli	r18,r4,3
8111eb14:	843fe044 	addi	r16,r16,-127
8111eb18:	0023883a 	mov	r17,zero
8111eb1c:	002f883a 	mov	r23,zero
8111eb20:	2804d5fa 	srli	r2,r5,23
8111eb24:	282cd7fa 	srli	r22,r5,31
8111eb28:	01002034 	movhi	r4,128
8111eb2c:	213fffc4 	addi	r4,r4,-1
8111eb30:	10803fcc 	andi	r2,r2,255
8111eb34:	2166703a 	and	r19,r4,r5
8111eb38:	b1803fcc 	andi	r6,r22,255
8111eb3c:	10004c26 	beq	r2,zero,8111ec70 <__mulsf3+0x1c4>
8111eb40:	00c03fc4 	movi	r3,255
8111eb44:	10c04726 	beq	r2,r3,8111ec64 <__mulsf3+0x1b8>
8111eb48:	99002034 	orhi	r4,r19,128
8111eb4c:	202690fa 	slli	r19,r4,3
8111eb50:	10bfe044 	addi	r2,r2,-127
8111eb54:	0007883a 	mov	r3,zero
8111eb58:	80a1883a 	add	r16,r16,r2
8111eb5c:	010003c4 	movi	r4,15
8111eb60:	1c44b03a 	or	r2,r3,r17
8111eb64:	b56af03a 	xor	r21,r22,r21
8111eb68:	81c00044 	addi	r7,r16,1
8111eb6c:	20806b36 	bltu	r4,r2,8111ed1c <__mulsf3+0x270>
8111eb70:	100490ba 	slli	r2,r2,2
8111eb74:	012044b4 	movhi	r4,33042
8111eb78:	213ae204 	addi	r4,r4,-5240
8111eb7c:	1105883a 	add	r2,r2,r4
8111eb80:	10800017 	ldw	r2,0(r2)
8111eb84:	1000683a 	jmp	r2
8111eb88:	8111ed1c 	xori	r4,r16,18356
8111eb8c:	8111ebdc 	xori	r4,r16,18351
8111eb90:	8111ebdc 	xori	r4,r16,18351
8111eb94:	8111ebd8 	cmpnei	r4,r16,18351
8111eb98:	8111ed00 	call	88111ed0 <__reset+0x20f1ed0>
8111eb9c:	8111ed00 	call	88111ed0 <__reset+0x20f1ed0>
8111eba0:	8111ecec 	andhi	r4,r16,18355
8111eba4:	8111ebd8 	cmpnei	r4,r16,18351
8111eba8:	8111ed00 	call	88111ed0 <__reset+0x20f1ed0>
8111ebac:	8111ecec 	andhi	r4,r16,18355
8111ebb0:	8111ed00 	call	88111ed0 <__reset+0x20f1ed0>
8111ebb4:	8111ebd8 	cmpnei	r4,r16,18351
8111ebb8:	8111ed0c 	andi	r4,r16,18356
8111ebbc:	8111ed0c 	andi	r4,r16,18356
8111ebc0:	8111ed0c 	andi	r4,r16,18356
8111ebc4:	8111ede8 	cmpgeui	r4,r16,18359
8111ebc8:	90003b1e 	bne	r18,zero,8111ecb8 <__mulsf3+0x20c>
8111ebcc:	04400204 	movi	r17,8
8111ebd0:	05c00084 	movi	r23,2
8111ebd4:	003fd206 	br	8111eb20 <__reset+0xfb0feb20>
8111ebd8:	302b883a 	mov	r21,r6
8111ebdc:	00800084 	movi	r2,2
8111ebe0:	18802626 	beq	r3,r2,8111ec7c <__mulsf3+0x1d0>
8111ebe4:	008000c4 	movi	r2,3
8111ebe8:	1880ab26 	beq	r3,r2,8111ee98 <__mulsf3+0x3ec>
8111ebec:	00800044 	movi	r2,1
8111ebf0:	1880a21e 	bne	r3,r2,8111ee7c <__mulsf3+0x3d0>
8111ebf4:	a829883a 	mov	r20,r21
8111ebf8:	0007883a 	mov	r3,zero
8111ebfc:	0009883a 	mov	r4,zero
8111ec00:	18803fcc 	andi	r2,r3,255
8111ec04:	100695fa 	slli	r3,r2,23
8111ec08:	a0803fcc 	andi	r2,r20,255
8111ec0c:	100a97fa 	slli	r5,r2,31
8111ec10:	00802034 	movhi	r2,128
8111ec14:	10bfffc4 	addi	r2,r2,-1
8111ec18:	2084703a 	and	r2,r4,r2
8111ec1c:	10c4b03a 	or	r2,r2,r3
8111ec20:	1144b03a 	or	r2,r2,r5
8111ec24:	dfc00a17 	ldw	ra,40(sp)
8111ec28:	df000917 	ldw	fp,36(sp)
8111ec2c:	ddc00817 	ldw	r23,32(sp)
8111ec30:	dd800717 	ldw	r22,28(sp)
8111ec34:	dd400617 	ldw	r21,24(sp)
8111ec38:	dd000517 	ldw	r20,20(sp)
8111ec3c:	dcc00417 	ldw	r19,16(sp)
8111ec40:	dc800317 	ldw	r18,12(sp)
8111ec44:	dc400217 	ldw	r17,8(sp)
8111ec48:	dc000117 	ldw	r16,4(sp)
8111ec4c:	dec00b04 	addi	sp,sp,44
8111ec50:	f800283a 	ret
8111ec54:	90000d1e 	bne	r18,zero,8111ec8c <__mulsf3+0x1e0>
8111ec58:	04400104 	movi	r17,4
8111ec5c:	05c00044 	movi	r23,1
8111ec60:	003faf06 	br	8111eb20 <__reset+0xfb0feb20>
8111ec64:	9806c03a 	cmpne	r3,r19,zero
8111ec68:	18c00084 	addi	r3,r3,2
8111ec6c:	003fba06 	br	8111eb58 <__reset+0xfb0feb58>
8111ec70:	9800141e 	bne	r19,zero,8111ecc4 <__mulsf3+0x218>
8111ec74:	00c00044 	movi	r3,1
8111ec78:	003fb706 	br	8111eb58 <__reset+0xfb0feb58>
8111ec7c:	a829883a 	mov	r20,r21
8111ec80:	00ffffc4 	movi	r3,-1
8111ec84:	0009883a 	mov	r4,zero
8111ec88:	003fdd06 	br	8111ec00 <__reset+0xfb0fec00>
8111ec8c:	9009883a 	mov	r4,r18
8111ec90:	d9400015 	stw	r5,0(sp)
8111ec94:	11205f80 	call	811205f8 <__clzsi2>
8111ec98:	10fffec4 	addi	r3,r2,-5
8111ec9c:	10801d84 	addi	r2,r2,118
8111eca0:	90e4983a 	sll	r18,r18,r3
8111eca4:	00a1c83a 	sub	r16,zero,r2
8111eca8:	0023883a 	mov	r17,zero
8111ecac:	002f883a 	mov	r23,zero
8111ecb0:	d9400017 	ldw	r5,0(sp)
8111ecb4:	003f9a06 	br	8111eb20 <__reset+0xfb0feb20>
8111ecb8:	04400304 	movi	r17,12
8111ecbc:	05c000c4 	movi	r23,3
8111ecc0:	003f9706 	br	8111eb20 <__reset+0xfb0feb20>
8111ecc4:	9809883a 	mov	r4,r19
8111ecc8:	d9800015 	stw	r6,0(sp)
8111eccc:	11205f80 	call	811205f8 <__clzsi2>
8111ecd0:	10fffec4 	addi	r3,r2,-5
8111ecd4:	10801d84 	addi	r2,r2,118
8111ecd8:	98e6983a 	sll	r19,r19,r3
8111ecdc:	0085c83a 	sub	r2,zero,r2
8111ece0:	0007883a 	mov	r3,zero
8111ece4:	d9800017 	ldw	r6,0(sp)
8111ece8:	003f9b06 	br	8111eb58 <__reset+0xfb0feb58>
8111ecec:	01002034 	movhi	r4,128
8111ecf0:	0029883a 	mov	r20,zero
8111ecf4:	213fffc4 	addi	r4,r4,-1
8111ecf8:	00ffffc4 	movi	r3,-1
8111ecfc:	003fc006 	br	8111ec00 <__reset+0xfb0fec00>
8111ed00:	9027883a 	mov	r19,r18
8111ed04:	b807883a 	mov	r3,r23
8111ed08:	003fb406 	br	8111ebdc <__reset+0xfb0febdc>
8111ed0c:	9027883a 	mov	r19,r18
8111ed10:	e02b883a 	mov	r21,fp
8111ed14:	b807883a 	mov	r3,r23
8111ed18:	003fb006 	br	8111ebdc <__reset+0xfb0febdc>
8111ed1c:	9004d43a 	srli	r2,r18,16
8111ed20:	9810d43a 	srli	r8,r19,16
8111ed24:	94bfffcc 	andi	r18,r18,65535
8111ed28:	993fffcc 	andi	r4,r19,65535
8111ed2c:	910d383a 	mul	r6,r18,r4
8111ed30:	20a7383a 	mul	r19,r4,r2
8111ed34:	9225383a 	mul	r18,r18,r8
8111ed38:	3006d43a 	srli	r3,r6,16
8111ed3c:	1211383a 	mul	r8,r2,r8
8111ed40:	94e5883a 	add	r18,r18,r19
8111ed44:	1c87883a 	add	r3,r3,r18
8111ed48:	1cc0022e 	bgeu	r3,r19,8111ed54 <__mulsf3+0x2a8>
8111ed4c:	00800074 	movhi	r2,1
8111ed50:	4091883a 	add	r8,r8,r2
8111ed54:	1804943a 	slli	r2,r3,16
8111ed58:	31bfffcc 	andi	r6,r6,65535
8111ed5c:	1806d43a 	srli	r3,r3,16
8111ed60:	1185883a 	add	r2,r2,r6
8111ed64:	102691ba 	slli	r19,r2,6
8111ed68:	1a07883a 	add	r3,r3,r8
8111ed6c:	1004d6ba 	srli	r2,r2,26
8111ed70:	180891ba 	slli	r4,r3,6
8111ed74:	9826c03a 	cmpne	r19,r19,zero
8111ed78:	9884b03a 	or	r2,r19,r2
8111ed7c:	1126b03a 	or	r19,r2,r4
8111ed80:	9882002c 	andhi	r2,r19,2048
8111ed84:	10000426 	beq	r2,zero,8111ed98 <__mulsf3+0x2ec>
8111ed88:	9804d07a 	srli	r2,r19,1
8111ed8c:	9900004c 	andi	r4,r19,1
8111ed90:	3821883a 	mov	r16,r7
8111ed94:	1126b03a 	or	r19,r2,r4
8111ed98:	80c01fc4 	addi	r3,r16,127
8111ed9c:	00c0210e 	bge	zero,r3,8111ee24 <__mulsf3+0x378>
8111eda0:	988001cc 	andi	r2,r19,7
8111eda4:	10000426 	beq	r2,zero,8111edb8 <__mulsf3+0x30c>
8111eda8:	988003cc 	andi	r2,r19,15
8111edac:	01000104 	movi	r4,4
8111edb0:	11000126 	beq	r2,r4,8111edb8 <__mulsf3+0x30c>
8111edb4:	9927883a 	add	r19,r19,r4
8111edb8:	9882002c 	andhi	r2,r19,2048
8111edbc:	10000426 	beq	r2,zero,8111edd0 <__mulsf3+0x324>
8111edc0:	00be0034 	movhi	r2,63488
8111edc4:	10bfffc4 	addi	r2,r2,-1
8111edc8:	80c02004 	addi	r3,r16,128
8111edcc:	98a6703a 	and	r19,r19,r2
8111edd0:	00803f84 	movi	r2,254
8111edd4:	10ffa916 	blt	r2,r3,8111ec7c <__reset+0xfb0fec7c>
8111edd8:	980891ba 	slli	r4,r19,6
8111eddc:	a829883a 	mov	r20,r21
8111ede0:	2008d27a 	srli	r4,r4,9
8111ede4:	003f8606 	br	8111ec00 <__reset+0xfb0fec00>
8111ede8:	9080102c 	andhi	r2,r18,64
8111edec:	10000826 	beq	r2,zero,8111ee10 <__mulsf3+0x364>
8111edf0:	9880102c 	andhi	r2,r19,64
8111edf4:	1000061e 	bne	r2,zero,8111ee10 <__mulsf3+0x364>
8111edf8:	00802034 	movhi	r2,128
8111edfc:	99001034 	orhi	r4,r19,64
8111ee00:	10bfffc4 	addi	r2,r2,-1
8111ee04:	b029883a 	mov	r20,r22
8111ee08:	2088703a 	and	r4,r4,r2
8111ee0c:	003fba06 	br	8111ecf8 <__reset+0xfb0fecf8>
8111ee10:	00802034 	movhi	r2,128
8111ee14:	91001034 	orhi	r4,r18,64
8111ee18:	10bfffc4 	addi	r2,r2,-1
8111ee1c:	2088703a 	and	r4,r4,r2
8111ee20:	003fb506 	br	8111ecf8 <__reset+0xfb0fecf8>
8111ee24:	00800044 	movi	r2,1
8111ee28:	10c7c83a 	sub	r3,r2,r3
8111ee2c:	008006c4 	movi	r2,27
8111ee30:	10ff7016 	blt	r2,r3,8111ebf4 <__reset+0xfb0febf4>
8111ee34:	00800804 	movi	r2,32
8111ee38:	10c5c83a 	sub	r2,r2,r3
8111ee3c:	9884983a 	sll	r2,r19,r2
8111ee40:	98c6d83a 	srl	r3,r19,r3
8111ee44:	1004c03a 	cmpne	r2,r2,zero
8111ee48:	1884b03a 	or	r2,r3,r2
8111ee4c:	10c001cc 	andi	r3,r2,7
8111ee50:	18000426 	beq	r3,zero,8111ee64 <__mulsf3+0x3b8>
8111ee54:	10c003cc 	andi	r3,r2,15
8111ee58:	01000104 	movi	r4,4
8111ee5c:	19000126 	beq	r3,r4,8111ee64 <__mulsf3+0x3b8>
8111ee60:	1105883a 	add	r2,r2,r4
8111ee64:	10c1002c 	andhi	r3,r2,1024
8111ee68:	18000626 	beq	r3,zero,8111ee84 <__mulsf3+0x3d8>
8111ee6c:	a829883a 	mov	r20,r21
8111ee70:	00c00044 	movi	r3,1
8111ee74:	0009883a 	mov	r4,zero
8111ee78:	003f6106 	br	8111ec00 <__reset+0xfb0fec00>
8111ee7c:	3821883a 	mov	r16,r7
8111ee80:	003fc506 	br	8111ed98 <__reset+0xfb0fed98>
8111ee84:	100491ba 	slli	r2,r2,6
8111ee88:	a829883a 	mov	r20,r21
8111ee8c:	0007883a 	mov	r3,zero
8111ee90:	1008d27a 	srli	r4,r2,9
8111ee94:	003f5a06 	br	8111ec00 <__reset+0xfb0fec00>
8111ee98:	00802034 	movhi	r2,128
8111ee9c:	99001034 	orhi	r4,r19,64
8111eea0:	10bfffc4 	addi	r2,r2,-1
8111eea4:	a829883a 	mov	r20,r21
8111eea8:	2088703a 	and	r4,r4,r2
8111eeac:	003f9206 	br	8111ecf8 <__reset+0xfb0fecf8>

8111eeb0 <__floatsisf>:
8111eeb0:	defffd04 	addi	sp,sp,-12
8111eeb4:	de00012e 	bgeu	sp,et,8111eebc <__floatsisf+0xc>
8111eeb8:	003b68fa 	trap	3
8111eebc:	dfc00215 	stw	ra,8(sp)
8111eec0:	dc400115 	stw	r17,4(sp)
8111eec4:	dc000015 	stw	r16,0(sp)
8111eec8:	20003526 	beq	r4,zero,8111efa0 <__floatsisf+0xf0>
8111eecc:	2021883a 	mov	r16,r4
8111eed0:	2022d7fa 	srli	r17,r4,31
8111eed4:	20003616 	blt	r4,zero,8111efb0 <__floatsisf+0x100>
8111eed8:	8009883a 	mov	r4,r16
8111eedc:	11205f80 	call	811205f8 <__clzsi2>
8111eee0:	00c02784 	movi	r3,158
8111eee4:	1887c83a 	sub	r3,r3,r2
8111eee8:	01002584 	movi	r4,150
8111eeec:	20c01416 	blt	r4,r3,8111ef40 <__floatsisf+0x90>
8111eef0:	20c9c83a 	sub	r4,r4,r3
8111eef4:	8120983a 	sll	r16,r16,r4
8111eef8:	00802034 	movhi	r2,128
8111eefc:	10bfffc4 	addi	r2,r2,-1
8111ef00:	8809883a 	mov	r4,r17
8111ef04:	80a0703a 	and	r16,r16,r2
8111ef08:	18803fcc 	andi	r2,r3,255
8111ef0c:	100695fa 	slli	r3,r2,23
8111ef10:	20803fcc 	andi	r2,r4,255
8111ef14:	100897fa 	slli	r4,r2,31
8111ef18:	00802034 	movhi	r2,128
8111ef1c:	10bfffc4 	addi	r2,r2,-1
8111ef20:	8084703a 	and	r2,r16,r2
8111ef24:	10c4b03a 	or	r2,r2,r3
8111ef28:	1104b03a 	or	r2,r2,r4
8111ef2c:	dfc00217 	ldw	ra,8(sp)
8111ef30:	dc400117 	ldw	r17,4(sp)
8111ef34:	dc000017 	ldw	r16,0(sp)
8111ef38:	dec00304 	addi	sp,sp,12
8111ef3c:	f800283a 	ret
8111ef40:	01002644 	movi	r4,153
8111ef44:	20c01c16 	blt	r4,r3,8111efb8 <__floatsisf+0x108>
8111ef48:	20c9c83a 	sub	r4,r4,r3
8111ef4c:	8120983a 	sll	r16,r16,r4
8111ef50:	013f0034 	movhi	r4,64512
8111ef54:	213fffc4 	addi	r4,r4,-1
8111ef58:	814001cc 	andi	r5,r16,7
8111ef5c:	8108703a 	and	r4,r16,r4
8111ef60:	28000426 	beq	r5,zero,8111ef74 <__floatsisf+0xc4>
8111ef64:	840003cc 	andi	r16,r16,15
8111ef68:	01400104 	movi	r5,4
8111ef6c:	81400126 	beq	r16,r5,8111ef74 <__floatsisf+0xc4>
8111ef70:	2149883a 	add	r4,r4,r5
8111ef74:	2141002c 	andhi	r5,r4,1024
8111ef78:	28000526 	beq	r5,zero,8111ef90 <__floatsisf+0xe0>
8111ef7c:	00c027c4 	movi	r3,159
8111ef80:	1887c83a 	sub	r3,r3,r2
8111ef84:	00bf0034 	movhi	r2,64512
8111ef88:	10bfffc4 	addi	r2,r2,-1
8111ef8c:	2088703a 	and	r4,r4,r2
8111ef90:	202091ba 	slli	r16,r4,6
8111ef94:	8809883a 	mov	r4,r17
8111ef98:	8020d27a 	srli	r16,r16,9
8111ef9c:	003fda06 	br	8111ef08 <__reset+0xfb0fef08>
8111efa0:	0009883a 	mov	r4,zero
8111efa4:	0007883a 	mov	r3,zero
8111efa8:	0021883a 	mov	r16,zero
8111efac:	003fd606 	br	8111ef08 <__reset+0xfb0fef08>
8111efb0:	0121c83a 	sub	r16,zero,r4
8111efb4:	003fc806 	br	8111eed8 <__reset+0xfb0feed8>
8111efb8:	01002e44 	movi	r4,185
8111efbc:	20c9c83a 	sub	r4,r4,r3
8111efc0:	01400144 	movi	r5,5
8111efc4:	8108983a 	sll	r4,r16,r4
8111efc8:	288bc83a 	sub	r5,r5,r2
8111efcc:	8160d83a 	srl	r16,r16,r5
8111efd0:	2008c03a 	cmpne	r4,r4,zero
8111efd4:	8120b03a 	or	r16,r16,r4
8111efd8:	003fdd06 	br	8111ef50 <__reset+0xfb0fef50>

8111efdc <__floatunsisf>:
8111efdc:	defffe04 	addi	sp,sp,-8
8111efe0:	de00012e 	bgeu	sp,et,8111efe8 <__floatunsisf+0xc>
8111efe4:	003b68fa 	trap	3
8111efe8:	dfc00115 	stw	ra,4(sp)
8111efec:	dc000015 	stw	r16,0(sp)
8111eff0:	20002c26 	beq	r4,zero,8111f0a4 <__floatunsisf+0xc8>
8111eff4:	2021883a 	mov	r16,r4
8111eff8:	11205f80 	call	811205f8 <__clzsi2>
8111effc:	00c02784 	movi	r3,158
8111f000:	1887c83a 	sub	r3,r3,r2
8111f004:	01002584 	movi	r4,150
8111f008:	20c00f16 	blt	r4,r3,8111f048 <__floatunsisf+0x6c>
8111f00c:	20c9c83a 	sub	r4,r4,r3
8111f010:	8108983a 	sll	r4,r16,r4
8111f014:	00802034 	movhi	r2,128
8111f018:	10bfffc4 	addi	r2,r2,-1
8111f01c:	2088703a 	and	r4,r4,r2
8111f020:	18803fcc 	andi	r2,r3,255
8111f024:	100695fa 	slli	r3,r2,23
8111f028:	00802034 	movhi	r2,128
8111f02c:	10bfffc4 	addi	r2,r2,-1
8111f030:	2084703a 	and	r2,r4,r2
8111f034:	10c4b03a 	or	r2,r2,r3
8111f038:	dfc00117 	ldw	ra,4(sp)
8111f03c:	dc000017 	ldw	r16,0(sp)
8111f040:	dec00204 	addi	sp,sp,8
8111f044:	f800283a 	ret
8111f048:	01002644 	movi	r4,153
8111f04c:	20c01816 	blt	r4,r3,8111f0b0 <__floatunsisf+0xd4>
8111f050:	20c9c83a 	sub	r4,r4,r3
8111f054:	8108983a 	sll	r4,r16,r4
8111f058:	017f0034 	movhi	r5,64512
8111f05c:	297fffc4 	addi	r5,r5,-1
8111f060:	218001cc 	andi	r6,r4,7
8111f064:	214a703a 	and	r5,r4,r5
8111f068:	30000426 	beq	r6,zero,8111f07c <__floatunsisf+0xa0>
8111f06c:	210003cc 	andi	r4,r4,15
8111f070:	01800104 	movi	r6,4
8111f074:	21800126 	beq	r4,r6,8111f07c <__floatunsisf+0xa0>
8111f078:	298b883a 	add	r5,r5,r6
8111f07c:	2901002c 	andhi	r4,r5,1024
8111f080:	20000526 	beq	r4,zero,8111f098 <__floatunsisf+0xbc>
8111f084:	00c027c4 	movi	r3,159
8111f088:	1887c83a 	sub	r3,r3,r2
8111f08c:	00bf0034 	movhi	r2,64512
8111f090:	10bfffc4 	addi	r2,r2,-1
8111f094:	288a703a 	and	r5,r5,r2
8111f098:	280891ba 	slli	r4,r5,6
8111f09c:	2008d27a 	srli	r4,r4,9
8111f0a0:	003fdf06 	br	8111f020 <__reset+0xfb0ff020>
8111f0a4:	0007883a 	mov	r3,zero
8111f0a8:	0009883a 	mov	r4,zero
8111f0ac:	003fdc06 	br	8111f020 <__reset+0xfb0ff020>
8111f0b0:	01402e44 	movi	r5,185
8111f0b4:	28cbc83a 	sub	r5,r5,r3
8111f0b8:	01000144 	movi	r4,5
8111f0bc:	2089c83a 	sub	r4,r4,r2
8111f0c0:	814a983a 	sll	r5,r16,r5
8111f0c4:	8108d83a 	srl	r4,r16,r4
8111f0c8:	2820c03a 	cmpne	r16,r5,zero
8111f0cc:	2408b03a 	or	r4,r4,r16
8111f0d0:	003fe106 	br	8111f058 <__reset+0xfb0ff058>

8111f0d4 <__gedf2>:
8111f0d4:	2804d53a 	srli	r2,r5,20
8111f0d8:	3806d53a 	srli	r3,r7,20
8111f0dc:	02000434 	movhi	r8,16
8111f0e0:	423fffc4 	addi	r8,r8,-1
8111f0e4:	1081ffcc 	andi	r2,r2,2047
8111f0e8:	0241ffc4 	movi	r9,2047
8111f0ec:	2a14703a 	and	r10,r5,r8
8111f0f0:	18c1ffcc 	andi	r3,r3,2047
8111f0f4:	3a10703a 	and	r8,r7,r8
8111f0f8:	280ad7fa 	srli	r5,r5,31
8111f0fc:	380ed7fa 	srli	r7,r7,31
8111f100:	12401d26 	beq	r2,r9,8111f178 <__gedf2+0xa4>
8111f104:	0241ffc4 	movi	r9,2047
8111f108:	1a401226 	beq	r3,r9,8111f154 <__gedf2+0x80>
8111f10c:	1000081e 	bne	r2,zero,8111f130 <__gedf2+0x5c>
8111f110:	2296b03a 	or	r11,r4,r10
8111f114:	5813003a 	cmpeq	r9,r11,zero
8111f118:	1800091e 	bne	r3,zero,8111f140 <__gedf2+0x6c>
8111f11c:	3218b03a 	or	r12,r6,r8
8111f120:	6000071e 	bne	r12,zero,8111f140 <__gedf2+0x6c>
8111f124:	0005883a 	mov	r2,zero
8111f128:	5800101e 	bne	r11,zero,8111f16c <__gedf2+0x98>
8111f12c:	f800283a 	ret
8111f130:	18000c1e 	bne	r3,zero,8111f164 <__gedf2+0x90>
8111f134:	3212b03a 	or	r9,r6,r8
8111f138:	48000c26 	beq	r9,zero,8111f16c <__gedf2+0x98>
8111f13c:	0013883a 	mov	r9,zero
8111f140:	39c03fcc 	andi	r7,r7,255
8111f144:	48000826 	beq	r9,zero,8111f168 <__gedf2+0x94>
8111f148:	38000926 	beq	r7,zero,8111f170 <__gedf2+0x9c>
8111f14c:	00800044 	movi	r2,1
8111f150:	f800283a 	ret
8111f154:	3212b03a 	or	r9,r6,r8
8111f158:	483fec26 	beq	r9,zero,8111f10c <__reset+0xfb0ff10c>
8111f15c:	00bfff84 	movi	r2,-2
8111f160:	f800283a 	ret
8111f164:	39c03fcc 	andi	r7,r7,255
8111f168:	29c00626 	beq	r5,r7,8111f184 <__gedf2+0xb0>
8111f16c:	283ff726 	beq	r5,zero,8111f14c <__reset+0xfb0ff14c>
8111f170:	00bfffc4 	movi	r2,-1
8111f174:	f800283a 	ret
8111f178:	2292b03a 	or	r9,r4,r10
8111f17c:	483fe126 	beq	r9,zero,8111f104 <__reset+0xfb0ff104>
8111f180:	003ff606 	br	8111f15c <__reset+0xfb0ff15c>
8111f184:	18bff916 	blt	r3,r2,8111f16c <__reset+0xfb0ff16c>
8111f188:	10c00316 	blt	r2,r3,8111f198 <__gedf2+0xc4>
8111f18c:	42bff736 	bltu	r8,r10,8111f16c <__reset+0xfb0ff16c>
8111f190:	52000326 	beq	r10,r8,8111f1a0 <__gedf2+0xcc>
8111f194:	5200042e 	bgeu	r10,r8,8111f1a8 <__gedf2+0xd4>
8111f198:	283fec1e 	bne	r5,zero,8111f14c <__reset+0xfb0ff14c>
8111f19c:	003ff406 	br	8111f170 <__reset+0xfb0ff170>
8111f1a0:	313ff236 	bltu	r6,r4,8111f16c <__reset+0xfb0ff16c>
8111f1a4:	21bffc36 	bltu	r4,r6,8111f198 <__reset+0xfb0ff198>
8111f1a8:	0005883a 	mov	r2,zero
8111f1ac:	f800283a 	ret

8111f1b0 <__muldf3>:
8111f1b0:	defff304 	addi	sp,sp,-52
8111f1b4:	2804d53a 	srli	r2,r5,20
8111f1b8:	de00012e 	bgeu	sp,et,8111f1c0 <__muldf3+0x10>
8111f1bc:	003b68fa 	trap	3
8111f1c0:	dd800915 	stw	r22,36(sp)
8111f1c4:	282cd7fa 	srli	r22,r5,31
8111f1c8:	dc000315 	stw	r16,12(sp)
8111f1cc:	04000434 	movhi	r16,16
8111f1d0:	dd400815 	stw	r21,32(sp)
8111f1d4:	dc800515 	stw	r18,20(sp)
8111f1d8:	843fffc4 	addi	r16,r16,-1
8111f1dc:	dfc00c15 	stw	ra,48(sp)
8111f1e0:	df000b15 	stw	fp,44(sp)
8111f1e4:	ddc00a15 	stw	r23,40(sp)
8111f1e8:	dd000715 	stw	r20,28(sp)
8111f1ec:	dcc00615 	stw	r19,24(sp)
8111f1f0:	dc400415 	stw	r17,16(sp)
8111f1f4:	1481ffcc 	andi	r18,r2,2047
8111f1f8:	2c20703a 	and	r16,r5,r16
8111f1fc:	b02b883a 	mov	r21,r22
8111f200:	b2403fcc 	andi	r9,r22,255
8111f204:	90006026 	beq	r18,zero,8111f388 <__muldf3+0x1d8>
8111f208:	0081ffc4 	movi	r2,2047
8111f20c:	2029883a 	mov	r20,r4
8111f210:	90803626 	beq	r18,r2,8111f2ec <__muldf3+0x13c>
8111f214:	80800434 	orhi	r2,r16,16
8111f218:	100490fa 	slli	r2,r2,3
8111f21c:	2020d77a 	srli	r16,r4,29
8111f220:	202890fa 	slli	r20,r4,3
8111f224:	94bf0044 	addi	r18,r18,-1023
8111f228:	80a0b03a 	or	r16,r16,r2
8111f22c:	0027883a 	mov	r19,zero
8111f230:	0039883a 	mov	fp,zero
8111f234:	3804d53a 	srli	r2,r7,20
8111f238:	382ed7fa 	srli	r23,r7,31
8111f23c:	04400434 	movhi	r17,16
8111f240:	8c7fffc4 	addi	r17,r17,-1
8111f244:	1081ffcc 	andi	r2,r2,2047
8111f248:	3011883a 	mov	r8,r6
8111f24c:	3c62703a 	and	r17,r7,r17
8111f250:	ba803fcc 	andi	r10,r23,255
8111f254:	10006d26 	beq	r2,zero,8111f40c <__muldf3+0x25c>
8111f258:	00c1ffc4 	movi	r3,2047
8111f25c:	10c06526 	beq	r2,r3,8111f3f4 <__muldf3+0x244>
8111f260:	88c00434 	orhi	r3,r17,16
8111f264:	180690fa 	slli	r3,r3,3
8111f268:	3022d77a 	srli	r17,r6,29
8111f26c:	301090fa 	slli	r8,r6,3
8111f270:	10bf0044 	addi	r2,r2,-1023
8111f274:	88e2b03a 	or	r17,r17,r3
8111f278:	000b883a 	mov	r5,zero
8111f27c:	9085883a 	add	r2,r18,r2
8111f280:	2cc8b03a 	or	r4,r5,r19
8111f284:	00c003c4 	movi	r3,15
8111f288:	bdacf03a 	xor	r22,r23,r22
8111f28c:	12c00044 	addi	r11,r2,1
8111f290:	19009936 	bltu	r3,r4,8111f4f8 <__muldf3+0x348>
8111f294:	200890ba 	slli	r4,r4,2
8111f298:	00e044b4 	movhi	r3,33042
8111f29c:	18fcab04 	addi	r3,r3,-3412
8111f2a0:	20c9883a 	add	r4,r4,r3
8111f2a4:	20c00017 	ldw	r3,0(r4)
8111f2a8:	1800683a 	jmp	r3
8111f2ac:	8111f4f8 	rdprs	r4,r16,18387
8111f2b0:	8111f30c 	andi	r4,r16,18380
8111f2b4:	8111f30c 	andi	r4,r16,18380
8111f2b8:	8111f308 	cmpgei	r4,r16,18380
8111f2bc:	8111f4d4 	ori	r4,r16,18387
8111f2c0:	8111f4d4 	ori	r4,r16,18387
8111f2c4:	8111f4bc 	xorhi	r4,r16,18386
8111f2c8:	8111f308 	cmpgei	r4,r16,18380
8111f2cc:	8111f4d4 	ori	r4,r16,18387
8111f2d0:	8111f4bc 	xorhi	r4,r16,18386
8111f2d4:	8111f4d4 	ori	r4,r16,18387
8111f2d8:	8111f308 	cmpgei	r4,r16,18380
8111f2dc:	8111f4e4 	muli	r4,r16,18387
8111f2e0:	8111f4e4 	muli	r4,r16,18387
8111f2e4:	8111f4e4 	muli	r4,r16,18387
8111f2e8:	8111f700 	call	88111f70 <__reset+0x20f1f70>
8111f2ec:	2404b03a 	or	r2,r4,r16
8111f2f0:	10006f1e 	bne	r2,zero,8111f4b0 <__muldf3+0x300>
8111f2f4:	04c00204 	movi	r19,8
8111f2f8:	0021883a 	mov	r16,zero
8111f2fc:	0029883a 	mov	r20,zero
8111f300:	07000084 	movi	fp,2
8111f304:	003fcb06 	br	8111f234 <__reset+0xfb0ff234>
8111f308:	502d883a 	mov	r22,r10
8111f30c:	00800084 	movi	r2,2
8111f310:	28805726 	beq	r5,r2,8111f470 <__muldf3+0x2c0>
8111f314:	008000c4 	movi	r2,3
8111f318:	28816626 	beq	r5,r2,8111f8b4 <__muldf3+0x704>
8111f31c:	00800044 	movi	r2,1
8111f320:	2881411e 	bne	r5,r2,8111f828 <__muldf3+0x678>
8111f324:	b02b883a 	mov	r21,r22
8111f328:	0005883a 	mov	r2,zero
8111f32c:	000b883a 	mov	r5,zero
8111f330:	0029883a 	mov	r20,zero
8111f334:	1004953a 	slli	r2,r2,20
8111f338:	a8c03fcc 	andi	r3,r21,255
8111f33c:	04400434 	movhi	r17,16
8111f340:	8c7fffc4 	addi	r17,r17,-1
8111f344:	180697fa 	slli	r3,r3,31
8111f348:	2c4a703a 	and	r5,r5,r17
8111f34c:	288ab03a 	or	r5,r5,r2
8111f350:	28c6b03a 	or	r3,r5,r3
8111f354:	a005883a 	mov	r2,r20
8111f358:	dfc00c17 	ldw	ra,48(sp)
8111f35c:	df000b17 	ldw	fp,44(sp)
8111f360:	ddc00a17 	ldw	r23,40(sp)
8111f364:	dd800917 	ldw	r22,36(sp)
8111f368:	dd400817 	ldw	r21,32(sp)
8111f36c:	dd000717 	ldw	r20,28(sp)
8111f370:	dcc00617 	ldw	r19,24(sp)
8111f374:	dc800517 	ldw	r18,20(sp)
8111f378:	dc400417 	ldw	r17,16(sp)
8111f37c:	dc000317 	ldw	r16,12(sp)
8111f380:	dec00d04 	addi	sp,sp,52
8111f384:	f800283a 	ret
8111f388:	2404b03a 	or	r2,r4,r16
8111f38c:	2027883a 	mov	r19,r4
8111f390:	10004226 	beq	r2,zero,8111f49c <__muldf3+0x2ec>
8111f394:	8000fc26 	beq	r16,zero,8111f788 <__muldf3+0x5d8>
8111f398:	8009883a 	mov	r4,r16
8111f39c:	d9800215 	stw	r6,8(sp)
8111f3a0:	d9c00015 	stw	r7,0(sp)
8111f3a4:	da400115 	stw	r9,4(sp)
8111f3a8:	11205f80 	call	811205f8 <__clzsi2>
8111f3ac:	d9800217 	ldw	r6,8(sp)
8111f3b0:	d9c00017 	ldw	r7,0(sp)
8111f3b4:	da400117 	ldw	r9,4(sp)
8111f3b8:	113ffd44 	addi	r4,r2,-11
8111f3bc:	00c00704 	movi	r3,28
8111f3c0:	1900ed16 	blt	r3,r4,8111f778 <__muldf3+0x5c8>
8111f3c4:	00c00744 	movi	r3,29
8111f3c8:	147ffe04 	addi	r17,r2,-8
8111f3cc:	1907c83a 	sub	r3,r3,r4
8111f3d0:	8460983a 	sll	r16,r16,r17
8111f3d4:	98c6d83a 	srl	r3,r19,r3
8111f3d8:	9c68983a 	sll	r20,r19,r17
8111f3dc:	1c20b03a 	or	r16,r3,r16
8111f3e0:	1080fcc4 	addi	r2,r2,1011
8111f3e4:	00a5c83a 	sub	r18,zero,r2
8111f3e8:	0027883a 	mov	r19,zero
8111f3ec:	0039883a 	mov	fp,zero
8111f3f0:	003f9006 	br	8111f234 <__reset+0xfb0ff234>
8111f3f4:	3446b03a 	or	r3,r6,r17
8111f3f8:	1800261e 	bne	r3,zero,8111f494 <__muldf3+0x2e4>
8111f3fc:	0023883a 	mov	r17,zero
8111f400:	0011883a 	mov	r8,zero
8111f404:	01400084 	movi	r5,2
8111f408:	003f9c06 	br	8111f27c <__reset+0xfb0ff27c>
8111f40c:	3446b03a 	or	r3,r6,r17
8111f410:	18001c26 	beq	r3,zero,8111f484 <__muldf3+0x2d4>
8111f414:	8800ce26 	beq	r17,zero,8111f750 <__muldf3+0x5a0>
8111f418:	8809883a 	mov	r4,r17
8111f41c:	d9800215 	stw	r6,8(sp)
8111f420:	da400115 	stw	r9,4(sp)
8111f424:	da800015 	stw	r10,0(sp)
8111f428:	11205f80 	call	811205f8 <__clzsi2>
8111f42c:	d9800217 	ldw	r6,8(sp)
8111f430:	da400117 	ldw	r9,4(sp)
8111f434:	da800017 	ldw	r10,0(sp)
8111f438:	113ffd44 	addi	r4,r2,-11
8111f43c:	00c00704 	movi	r3,28
8111f440:	1900bf16 	blt	r3,r4,8111f740 <__muldf3+0x590>
8111f444:	00c00744 	movi	r3,29
8111f448:	123ffe04 	addi	r8,r2,-8
8111f44c:	1907c83a 	sub	r3,r3,r4
8111f450:	8a22983a 	sll	r17,r17,r8
8111f454:	30c6d83a 	srl	r3,r6,r3
8111f458:	3210983a 	sll	r8,r6,r8
8111f45c:	1c62b03a 	or	r17,r3,r17
8111f460:	1080fcc4 	addi	r2,r2,1011
8111f464:	0085c83a 	sub	r2,zero,r2
8111f468:	000b883a 	mov	r5,zero
8111f46c:	003f8306 	br	8111f27c <__reset+0xfb0ff27c>
8111f470:	b02b883a 	mov	r21,r22
8111f474:	0081ffc4 	movi	r2,2047
8111f478:	000b883a 	mov	r5,zero
8111f47c:	0029883a 	mov	r20,zero
8111f480:	003fac06 	br	8111f334 <__reset+0xfb0ff334>
8111f484:	0023883a 	mov	r17,zero
8111f488:	0011883a 	mov	r8,zero
8111f48c:	01400044 	movi	r5,1
8111f490:	003f7a06 	br	8111f27c <__reset+0xfb0ff27c>
8111f494:	014000c4 	movi	r5,3
8111f498:	003f7806 	br	8111f27c <__reset+0xfb0ff27c>
8111f49c:	04c00104 	movi	r19,4
8111f4a0:	0021883a 	mov	r16,zero
8111f4a4:	0029883a 	mov	r20,zero
8111f4a8:	07000044 	movi	fp,1
8111f4ac:	003f6106 	br	8111f234 <__reset+0xfb0ff234>
8111f4b0:	04c00304 	movi	r19,12
8111f4b4:	070000c4 	movi	fp,3
8111f4b8:	003f5e06 	br	8111f234 <__reset+0xfb0ff234>
8111f4bc:	01400434 	movhi	r5,16
8111f4c0:	002b883a 	mov	r21,zero
8111f4c4:	297fffc4 	addi	r5,r5,-1
8111f4c8:	053fffc4 	movi	r20,-1
8111f4cc:	0081ffc4 	movi	r2,2047
8111f4d0:	003f9806 	br	8111f334 <__reset+0xfb0ff334>
8111f4d4:	8023883a 	mov	r17,r16
8111f4d8:	a011883a 	mov	r8,r20
8111f4dc:	e00b883a 	mov	r5,fp
8111f4e0:	003f8a06 	br	8111f30c <__reset+0xfb0ff30c>
8111f4e4:	8023883a 	mov	r17,r16
8111f4e8:	a011883a 	mov	r8,r20
8111f4ec:	482d883a 	mov	r22,r9
8111f4f0:	e00b883a 	mov	r5,fp
8111f4f4:	003f8506 	br	8111f30c <__reset+0xfb0ff30c>
8111f4f8:	a00ad43a 	srli	r5,r20,16
8111f4fc:	401ad43a 	srli	r13,r8,16
8111f500:	a53fffcc 	andi	r20,r20,65535
8111f504:	423fffcc 	andi	r8,r8,65535
8111f508:	4519383a 	mul	r12,r8,r20
8111f50c:	4147383a 	mul	r3,r8,r5
8111f510:	6d09383a 	mul	r4,r13,r20
8111f514:	600cd43a 	srli	r6,r12,16
8111f518:	2b5d383a 	mul	r14,r5,r13
8111f51c:	20c9883a 	add	r4,r4,r3
8111f520:	310d883a 	add	r6,r6,r4
8111f524:	30c0022e 	bgeu	r6,r3,8111f530 <__muldf3+0x380>
8111f528:	00c00074 	movhi	r3,1
8111f52c:	70dd883a 	add	r14,r14,r3
8111f530:	8826d43a 	srli	r19,r17,16
8111f534:	8bffffcc 	andi	r15,r17,65535
8111f538:	7d23383a 	mul	r17,r15,r20
8111f53c:	7949383a 	mul	r4,r15,r5
8111f540:	9d29383a 	mul	r20,r19,r20
8111f544:	8814d43a 	srli	r10,r17,16
8111f548:	3012943a 	slli	r9,r6,16
8111f54c:	a129883a 	add	r20,r20,r4
8111f550:	633fffcc 	andi	r12,r12,65535
8111f554:	5515883a 	add	r10,r10,r20
8111f558:	3006d43a 	srli	r3,r6,16
8111f55c:	4b13883a 	add	r9,r9,r12
8111f560:	2ccb383a 	mul	r5,r5,r19
8111f564:	5100022e 	bgeu	r10,r4,8111f570 <__muldf3+0x3c0>
8111f568:	01000074 	movhi	r4,1
8111f56c:	290b883a 	add	r5,r5,r4
8111f570:	802ad43a 	srli	r21,r16,16
8111f574:	843fffcc 	andi	r16,r16,65535
8111f578:	440d383a 	mul	r6,r8,r16
8111f57c:	4565383a 	mul	r18,r8,r21
8111f580:	8349383a 	mul	r4,r16,r13
8111f584:	500e943a 	slli	r7,r10,16
8111f588:	3010d43a 	srli	r8,r6,16
8111f58c:	5028d43a 	srli	r20,r10,16
8111f590:	2489883a 	add	r4,r4,r18
8111f594:	8abfffcc 	andi	r10,r17,65535
8111f598:	3a95883a 	add	r10,r7,r10
8111f59c:	4119883a 	add	r12,r8,r4
8111f5a0:	a169883a 	add	r20,r20,r5
8111f5a4:	1a87883a 	add	r3,r3,r10
8111f5a8:	6d5b383a 	mul	r13,r13,r21
8111f5ac:	6480022e 	bgeu	r12,r18,8111f5b8 <__muldf3+0x408>
8111f5b0:	01000074 	movhi	r4,1
8111f5b4:	691b883a 	add	r13,r13,r4
8111f5b8:	7c25383a 	mul	r18,r15,r16
8111f5bc:	7d4b383a 	mul	r5,r15,r21
8111f5c0:	84cf383a 	mul	r7,r16,r19
8111f5c4:	901ed43a 	srli	r15,r18,16
8111f5c8:	6008d43a 	srli	r4,r12,16
8111f5cc:	6010943a 	slli	r8,r12,16
8111f5d0:	394f883a 	add	r7,r7,r5
8111f5d4:	333fffcc 	andi	r12,r6,65535
8111f5d8:	79df883a 	add	r15,r15,r7
8111f5dc:	235b883a 	add	r13,r4,r13
8111f5e0:	9d63383a 	mul	r17,r19,r21
8111f5e4:	4309883a 	add	r4,r8,r12
8111f5e8:	7940022e 	bgeu	r15,r5,8111f5f4 <__muldf3+0x444>
8111f5ec:	01400074 	movhi	r5,1
8111f5f0:	8963883a 	add	r17,r17,r5
8111f5f4:	780a943a 	slli	r5,r15,16
8111f5f8:	91bfffcc 	andi	r6,r18,65535
8111f5fc:	70c7883a 	add	r3,r14,r3
8111f600:	298d883a 	add	r6,r5,r6
8111f604:	1a8f803a 	cmpltu	r7,r3,r10
8111f608:	350b883a 	add	r5,r6,r20
8111f60c:	20c7883a 	add	r3,r4,r3
8111f610:	3955883a 	add	r10,r7,r5
8111f614:	1909803a 	cmpltu	r4,r3,r4
8111f618:	6a91883a 	add	r8,r13,r10
8111f61c:	780cd43a 	srli	r6,r15,16
8111f620:	2219883a 	add	r12,r4,r8
8111f624:	2d0b803a 	cmpltu	r5,r5,r20
8111f628:	51cf803a 	cmpltu	r7,r10,r7
8111f62c:	29ceb03a 	or	r7,r5,r7
8111f630:	4351803a 	cmpltu	r8,r8,r13
8111f634:	610b803a 	cmpltu	r5,r12,r4
8111f638:	4148b03a 	or	r4,r8,r5
8111f63c:	398f883a 	add	r7,r7,r6
8111f640:	3909883a 	add	r4,r7,r4
8111f644:	1810927a 	slli	r8,r3,9
8111f648:	2449883a 	add	r4,r4,r17
8111f64c:	2008927a 	slli	r4,r4,9
8111f650:	6022d5fa 	srli	r17,r12,23
8111f654:	1806d5fa 	srli	r3,r3,23
8111f658:	4252b03a 	or	r9,r8,r9
8111f65c:	600a927a 	slli	r5,r12,9
8111f660:	4810c03a 	cmpne	r8,r9,zero
8111f664:	2462b03a 	or	r17,r4,r17
8111f668:	40c6b03a 	or	r3,r8,r3
8111f66c:	8900402c 	andhi	r4,r17,256
8111f670:	1950b03a 	or	r8,r3,r5
8111f674:	20000726 	beq	r4,zero,8111f694 <__muldf3+0x4e4>
8111f678:	4006d07a 	srli	r3,r8,1
8111f67c:	880497fa 	slli	r2,r17,31
8111f680:	4200004c 	andi	r8,r8,1
8111f684:	8822d07a 	srli	r17,r17,1
8111f688:	1a10b03a 	or	r8,r3,r8
8111f68c:	1210b03a 	or	r8,r2,r8
8111f690:	5805883a 	mov	r2,r11
8111f694:	1140ffc4 	addi	r5,r2,1023
8111f698:	0140440e 	bge	zero,r5,8111f7ac <__muldf3+0x5fc>
8111f69c:	40c001cc 	andi	r3,r8,7
8111f6a0:	18000726 	beq	r3,zero,8111f6c0 <__muldf3+0x510>
8111f6a4:	40c003cc 	andi	r3,r8,15
8111f6a8:	01000104 	movi	r4,4
8111f6ac:	19000426 	beq	r3,r4,8111f6c0 <__muldf3+0x510>
8111f6b0:	4107883a 	add	r3,r8,r4
8111f6b4:	1a11803a 	cmpltu	r8,r3,r8
8111f6b8:	8a23883a 	add	r17,r17,r8
8111f6bc:	1811883a 	mov	r8,r3
8111f6c0:	88c0402c 	andhi	r3,r17,256
8111f6c4:	18000426 	beq	r3,zero,8111f6d8 <__muldf3+0x528>
8111f6c8:	11410004 	addi	r5,r2,1024
8111f6cc:	00bfc034 	movhi	r2,65280
8111f6d0:	10bfffc4 	addi	r2,r2,-1
8111f6d4:	88a2703a 	and	r17,r17,r2
8111f6d8:	0081ff84 	movi	r2,2046
8111f6dc:	117f6416 	blt	r2,r5,8111f470 <__reset+0xfb0ff470>
8111f6e0:	8828977a 	slli	r20,r17,29
8111f6e4:	4010d0fa 	srli	r8,r8,3
8111f6e8:	8822927a 	slli	r17,r17,9
8111f6ec:	2881ffcc 	andi	r2,r5,2047
8111f6f0:	a228b03a 	or	r20,r20,r8
8111f6f4:	880ad33a 	srli	r5,r17,12
8111f6f8:	b02b883a 	mov	r21,r22
8111f6fc:	003f0d06 	br	8111f334 <__reset+0xfb0ff334>
8111f700:	8080022c 	andhi	r2,r16,8
8111f704:	10000926 	beq	r2,zero,8111f72c <__muldf3+0x57c>
8111f708:	8880022c 	andhi	r2,r17,8
8111f70c:	1000071e 	bne	r2,zero,8111f72c <__muldf3+0x57c>
8111f710:	00800434 	movhi	r2,16
8111f714:	89400234 	orhi	r5,r17,8
8111f718:	10bfffc4 	addi	r2,r2,-1
8111f71c:	b82b883a 	mov	r21,r23
8111f720:	288a703a 	and	r5,r5,r2
8111f724:	4029883a 	mov	r20,r8
8111f728:	003f6806 	br	8111f4cc <__reset+0xfb0ff4cc>
8111f72c:	00800434 	movhi	r2,16
8111f730:	81400234 	orhi	r5,r16,8
8111f734:	10bfffc4 	addi	r2,r2,-1
8111f738:	288a703a 	and	r5,r5,r2
8111f73c:	003f6306 	br	8111f4cc <__reset+0xfb0ff4cc>
8111f740:	147ff604 	addi	r17,r2,-40
8111f744:	3462983a 	sll	r17,r6,r17
8111f748:	0011883a 	mov	r8,zero
8111f74c:	003f4406 	br	8111f460 <__reset+0xfb0ff460>
8111f750:	3009883a 	mov	r4,r6
8111f754:	d9800215 	stw	r6,8(sp)
8111f758:	da400115 	stw	r9,4(sp)
8111f75c:	da800015 	stw	r10,0(sp)
8111f760:	11205f80 	call	811205f8 <__clzsi2>
8111f764:	10800804 	addi	r2,r2,32
8111f768:	da800017 	ldw	r10,0(sp)
8111f76c:	da400117 	ldw	r9,4(sp)
8111f770:	d9800217 	ldw	r6,8(sp)
8111f774:	003f3006 	br	8111f438 <__reset+0xfb0ff438>
8111f778:	143ff604 	addi	r16,r2,-40
8111f77c:	9c20983a 	sll	r16,r19,r16
8111f780:	0029883a 	mov	r20,zero
8111f784:	003f1606 	br	8111f3e0 <__reset+0xfb0ff3e0>
8111f788:	d9800215 	stw	r6,8(sp)
8111f78c:	d9c00015 	stw	r7,0(sp)
8111f790:	da400115 	stw	r9,4(sp)
8111f794:	11205f80 	call	811205f8 <__clzsi2>
8111f798:	10800804 	addi	r2,r2,32
8111f79c:	da400117 	ldw	r9,4(sp)
8111f7a0:	d9c00017 	ldw	r7,0(sp)
8111f7a4:	d9800217 	ldw	r6,8(sp)
8111f7a8:	003f0306 	br	8111f3b8 <__reset+0xfb0ff3b8>
8111f7ac:	00c00044 	movi	r3,1
8111f7b0:	1947c83a 	sub	r3,r3,r5
8111f7b4:	00800e04 	movi	r2,56
8111f7b8:	10feda16 	blt	r2,r3,8111f324 <__reset+0xfb0ff324>
8111f7bc:	008007c4 	movi	r2,31
8111f7c0:	10c01b16 	blt	r2,r3,8111f830 <__muldf3+0x680>
8111f7c4:	00800804 	movi	r2,32
8111f7c8:	10c5c83a 	sub	r2,r2,r3
8111f7cc:	888a983a 	sll	r5,r17,r2
8111f7d0:	40c8d83a 	srl	r4,r8,r3
8111f7d4:	4084983a 	sll	r2,r8,r2
8111f7d8:	88e2d83a 	srl	r17,r17,r3
8111f7dc:	2906b03a 	or	r3,r5,r4
8111f7e0:	1004c03a 	cmpne	r2,r2,zero
8111f7e4:	1886b03a 	or	r3,r3,r2
8111f7e8:	188001cc 	andi	r2,r3,7
8111f7ec:	10000726 	beq	r2,zero,8111f80c <__muldf3+0x65c>
8111f7f0:	188003cc 	andi	r2,r3,15
8111f7f4:	01000104 	movi	r4,4
8111f7f8:	11000426 	beq	r2,r4,8111f80c <__muldf3+0x65c>
8111f7fc:	1805883a 	mov	r2,r3
8111f800:	10c00104 	addi	r3,r2,4
8111f804:	1885803a 	cmpltu	r2,r3,r2
8111f808:	88a3883a 	add	r17,r17,r2
8111f80c:	8880202c 	andhi	r2,r17,128
8111f810:	10001c26 	beq	r2,zero,8111f884 <__muldf3+0x6d4>
8111f814:	b02b883a 	mov	r21,r22
8111f818:	00800044 	movi	r2,1
8111f81c:	000b883a 	mov	r5,zero
8111f820:	0029883a 	mov	r20,zero
8111f824:	003ec306 	br	8111f334 <__reset+0xfb0ff334>
8111f828:	5805883a 	mov	r2,r11
8111f82c:	003f9906 	br	8111f694 <__reset+0xfb0ff694>
8111f830:	00bff844 	movi	r2,-31
8111f834:	1145c83a 	sub	r2,r2,r5
8111f838:	8888d83a 	srl	r4,r17,r2
8111f83c:	00800804 	movi	r2,32
8111f840:	18801a26 	beq	r3,r2,8111f8ac <__muldf3+0x6fc>
8111f844:	00801004 	movi	r2,64
8111f848:	10c5c83a 	sub	r2,r2,r3
8111f84c:	8884983a 	sll	r2,r17,r2
8111f850:	1204b03a 	or	r2,r2,r8
8111f854:	1004c03a 	cmpne	r2,r2,zero
8111f858:	2084b03a 	or	r2,r4,r2
8111f85c:	144001cc 	andi	r17,r2,7
8111f860:	88000d1e 	bne	r17,zero,8111f898 <__muldf3+0x6e8>
8111f864:	000b883a 	mov	r5,zero
8111f868:	1028d0fa 	srli	r20,r2,3
8111f86c:	b02b883a 	mov	r21,r22
8111f870:	0005883a 	mov	r2,zero
8111f874:	a468b03a 	or	r20,r20,r17
8111f878:	003eae06 	br	8111f334 <__reset+0xfb0ff334>
8111f87c:	1007883a 	mov	r3,r2
8111f880:	0023883a 	mov	r17,zero
8111f884:	880a927a 	slli	r5,r17,9
8111f888:	1805883a 	mov	r2,r3
8111f88c:	8822977a 	slli	r17,r17,29
8111f890:	280ad33a 	srli	r5,r5,12
8111f894:	003ff406 	br	8111f868 <__reset+0xfb0ff868>
8111f898:	10c003cc 	andi	r3,r2,15
8111f89c:	01000104 	movi	r4,4
8111f8a0:	193ff626 	beq	r3,r4,8111f87c <__reset+0xfb0ff87c>
8111f8a4:	0023883a 	mov	r17,zero
8111f8a8:	003fd506 	br	8111f800 <__reset+0xfb0ff800>
8111f8ac:	0005883a 	mov	r2,zero
8111f8b0:	003fe706 	br	8111f850 <__reset+0xfb0ff850>
8111f8b4:	00800434 	movhi	r2,16
8111f8b8:	89400234 	orhi	r5,r17,8
8111f8bc:	10bfffc4 	addi	r2,r2,-1
8111f8c0:	b02b883a 	mov	r21,r22
8111f8c4:	288a703a 	and	r5,r5,r2
8111f8c8:	4029883a 	mov	r20,r8
8111f8cc:	003eff06 	br	8111f4cc <__reset+0xfb0ff4cc>

8111f8d0 <__subdf3>:
8111f8d0:	02000434 	movhi	r8,16
8111f8d4:	423fffc4 	addi	r8,r8,-1
8111f8d8:	defffb04 	addi	sp,sp,-20
8111f8dc:	2a14703a 	and	r10,r5,r8
8111f8e0:	3812d53a 	srli	r9,r7,20
8111f8e4:	3a10703a 	and	r8,r7,r8
8111f8e8:	de00012e 	bgeu	sp,et,8111f8f0 <__subdf3+0x20>
8111f8ec:	003b68fa 	trap	3
8111f8f0:	2006d77a 	srli	r3,r4,29
8111f8f4:	3004d77a 	srli	r2,r6,29
8111f8f8:	dc000015 	stw	r16,0(sp)
8111f8fc:	501490fa 	slli	r10,r10,3
8111f900:	2820d53a 	srli	r16,r5,20
8111f904:	401090fa 	slli	r8,r8,3
8111f908:	dc800215 	stw	r18,8(sp)
8111f90c:	dc400115 	stw	r17,4(sp)
8111f910:	dfc00415 	stw	ra,16(sp)
8111f914:	202290fa 	slli	r17,r4,3
8111f918:	dcc00315 	stw	r19,12(sp)
8111f91c:	4a41ffcc 	andi	r9,r9,2047
8111f920:	0101ffc4 	movi	r4,2047
8111f924:	2824d7fa 	srli	r18,r5,31
8111f928:	8401ffcc 	andi	r16,r16,2047
8111f92c:	50c6b03a 	or	r3,r10,r3
8111f930:	380ed7fa 	srli	r7,r7,31
8111f934:	408ab03a 	or	r5,r8,r2
8111f938:	300c90fa 	slli	r6,r6,3
8111f93c:	49009626 	beq	r9,r4,8111fb98 <__subdf3+0x2c8>
8111f940:	39c0005c 	xori	r7,r7,1
8111f944:	8245c83a 	sub	r2,r16,r9
8111f948:	3c807426 	beq	r7,r18,8111fb1c <__subdf3+0x24c>
8111f94c:	0080af0e 	bge	zero,r2,8111fc0c <__subdf3+0x33c>
8111f950:	48002a1e 	bne	r9,zero,8111f9fc <__subdf3+0x12c>
8111f954:	2988b03a 	or	r4,r5,r6
8111f958:	20009a1e 	bne	r4,zero,8111fbc4 <__subdf3+0x2f4>
8111f95c:	888001cc 	andi	r2,r17,7
8111f960:	10000726 	beq	r2,zero,8111f980 <__subdf3+0xb0>
8111f964:	888003cc 	andi	r2,r17,15
8111f968:	01000104 	movi	r4,4
8111f96c:	11000426 	beq	r2,r4,8111f980 <__subdf3+0xb0>
8111f970:	890b883a 	add	r5,r17,r4
8111f974:	2c63803a 	cmpltu	r17,r5,r17
8111f978:	1c47883a 	add	r3,r3,r17
8111f97c:	2823883a 	mov	r17,r5
8111f980:	1880202c 	andhi	r2,r3,128
8111f984:	10005926 	beq	r2,zero,8111faec <__subdf3+0x21c>
8111f988:	84000044 	addi	r16,r16,1
8111f98c:	0081ffc4 	movi	r2,2047
8111f990:	8080be26 	beq	r16,r2,8111fc8c <__subdf3+0x3bc>
8111f994:	017fe034 	movhi	r5,65408
8111f998:	297fffc4 	addi	r5,r5,-1
8111f99c:	1946703a 	and	r3,r3,r5
8111f9a0:	1804977a 	slli	r2,r3,29
8111f9a4:	1806927a 	slli	r3,r3,9
8111f9a8:	8822d0fa 	srli	r17,r17,3
8111f9ac:	8401ffcc 	andi	r16,r16,2047
8111f9b0:	180ad33a 	srli	r5,r3,12
8111f9b4:	9100004c 	andi	r4,r18,1
8111f9b8:	1444b03a 	or	r2,r2,r17
8111f9bc:	80c1ffcc 	andi	r3,r16,2047
8111f9c0:	1820953a 	slli	r16,r3,20
8111f9c4:	20c03fcc 	andi	r3,r4,255
8111f9c8:	180897fa 	slli	r4,r3,31
8111f9cc:	00c00434 	movhi	r3,16
8111f9d0:	18ffffc4 	addi	r3,r3,-1
8111f9d4:	28c6703a 	and	r3,r5,r3
8111f9d8:	1c06b03a 	or	r3,r3,r16
8111f9dc:	1906b03a 	or	r3,r3,r4
8111f9e0:	dfc00417 	ldw	ra,16(sp)
8111f9e4:	dcc00317 	ldw	r19,12(sp)
8111f9e8:	dc800217 	ldw	r18,8(sp)
8111f9ec:	dc400117 	ldw	r17,4(sp)
8111f9f0:	dc000017 	ldw	r16,0(sp)
8111f9f4:	dec00504 	addi	sp,sp,20
8111f9f8:	f800283a 	ret
8111f9fc:	0101ffc4 	movi	r4,2047
8111fa00:	813fd626 	beq	r16,r4,8111f95c <__reset+0xfb0ff95c>
8111fa04:	29402034 	orhi	r5,r5,128
8111fa08:	01000e04 	movi	r4,56
8111fa0c:	2080a316 	blt	r4,r2,8111fc9c <__subdf3+0x3cc>
8111fa10:	010007c4 	movi	r4,31
8111fa14:	2080c616 	blt	r4,r2,8111fd30 <__subdf3+0x460>
8111fa18:	01000804 	movi	r4,32
8111fa1c:	2089c83a 	sub	r4,r4,r2
8111fa20:	2910983a 	sll	r8,r5,r4
8111fa24:	308ed83a 	srl	r7,r6,r2
8111fa28:	3108983a 	sll	r4,r6,r4
8111fa2c:	2884d83a 	srl	r2,r5,r2
8111fa30:	41ccb03a 	or	r6,r8,r7
8111fa34:	2008c03a 	cmpne	r4,r4,zero
8111fa38:	310cb03a 	or	r6,r6,r4
8111fa3c:	898dc83a 	sub	r6,r17,r6
8111fa40:	89a3803a 	cmpltu	r17,r17,r6
8111fa44:	1887c83a 	sub	r3,r3,r2
8111fa48:	1c47c83a 	sub	r3,r3,r17
8111fa4c:	3023883a 	mov	r17,r6
8111fa50:	1880202c 	andhi	r2,r3,128
8111fa54:	10002326 	beq	r2,zero,8111fae4 <__subdf3+0x214>
8111fa58:	04c02034 	movhi	r19,128
8111fa5c:	9cffffc4 	addi	r19,r19,-1
8111fa60:	1ce6703a 	and	r19,r3,r19
8111fa64:	98007a26 	beq	r19,zero,8111fc50 <__subdf3+0x380>
8111fa68:	9809883a 	mov	r4,r19
8111fa6c:	11205f80 	call	811205f8 <__clzsi2>
8111fa70:	113ffe04 	addi	r4,r2,-8
8111fa74:	00c007c4 	movi	r3,31
8111fa78:	19007b16 	blt	r3,r4,8111fc68 <__subdf3+0x398>
8111fa7c:	00800804 	movi	r2,32
8111fa80:	1105c83a 	sub	r2,r2,r4
8111fa84:	8884d83a 	srl	r2,r17,r2
8111fa88:	9906983a 	sll	r3,r19,r4
8111fa8c:	8922983a 	sll	r17,r17,r4
8111fa90:	10c4b03a 	or	r2,r2,r3
8111fa94:	24007816 	blt	r4,r16,8111fc78 <__subdf3+0x3a8>
8111fa98:	2421c83a 	sub	r16,r4,r16
8111fa9c:	80c00044 	addi	r3,r16,1
8111faa0:	010007c4 	movi	r4,31
8111faa4:	20c09516 	blt	r4,r3,8111fcfc <__subdf3+0x42c>
8111faa8:	01400804 	movi	r5,32
8111faac:	28cbc83a 	sub	r5,r5,r3
8111fab0:	88c8d83a 	srl	r4,r17,r3
8111fab4:	8962983a 	sll	r17,r17,r5
8111fab8:	114a983a 	sll	r5,r2,r5
8111fabc:	10c6d83a 	srl	r3,r2,r3
8111fac0:	8804c03a 	cmpne	r2,r17,zero
8111fac4:	290ab03a 	or	r5,r5,r4
8111fac8:	28a2b03a 	or	r17,r5,r2
8111facc:	0021883a 	mov	r16,zero
8111fad0:	003fa206 	br	8111f95c <__reset+0xfb0ff95c>
8111fad4:	2090b03a 	or	r8,r4,r2
8111fad8:	40018e26 	beq	r8,zero,81120114 <__subdf3+0x844>
8111fadc:	1007883a 	mov	r3,r2
8111fae0:	2023883a 	mov	r17,r4
8111fae4:	888001cc 	andi	r2,r17,7
8111fae8:	103f9e1e 	bne	r2,zero,8111f964 <__reset+0xfb0ff964>
8111faec:	1804977a 	slli	r2,r3,29
8111faf0:	8822d0fa 	srli	r17,r17,3
8111faf4:	1810d0fa 	srli	r8,r3,3
8111faf8:	9100004c 	andi	r4,r18,1
8111fafc:	1444b03a 	or	r2,r2,r17
8111fb00:	00c1ffc4 	movi	r3,2047
8111fb04:	80c02826 	beq	r16,r3,8111fba8 <__subdf3+0x2d8>
8111fb08:	01400434 	movhi	r5,16
8111fb0c:	297fffc4 	addi	r5,r5,-1
8111fb10:	80e0703a 	and	r16,r16,r3
8111fb14:	414a703a 	and	r5,r8,r5
8111fb18:	003fa806 	br	8111f9bc <__reset+0xfb0ff9bc>
8111fb1c:	0080630e 	bge	zero,r2,8111fcac <__subdf3+0x3dc>
8111fb20:	48003026 	beq	r9,zero,8111fbe4 <__subdf3+0x314>
8111fb24:	0101ffc4 	movi	r4,2047
8111fb28:	813f8c26 	beq	r16,r4,8111f95c <__reset+0xfb0ff95c>
8111fb2c:	29402034 	orhi	r5,r5,128
8111fb30:	01000e04 	movi	r4,56
8111fb34:	2080a90e 	bge	r4,r2,8111fddc <__subdf3+0x50c>
8111fb38:	298cb03a 	or	r6,r5,r6
8111fb3c:	3012c03a 	cmpne	r9,r6,zero
8111fb40:	0005883a 	mov	r2,zero
8111fb44:	4c53883a 	add	r9,r9,r17
8111fb48:	4c63803a 	cmpltu	r17,r9,r17
8111fb4c:	10c7883a 	add	r3,r2,r3
8111fb50:	88c7883a 	add	r3,r17,r3
8111fb54:	4823883a 	mov	r17,r9
8111fb58:	1880202c 	andhi	r2,r3,128
8111fb5c:	1000d026 	beq	r2,zero,8111fea0 <__subdf3+0x5d0>
8111fb60:	84000044 	addi	r16,r16,1
8111fb64:	0081ffc4 	movi	r2,2047
8111fb68:	8080fe26 	beq	r16,r2,8111ff64 <__subdf3+0x694>
8111fb6c:	00bfe034 	movhi	r2,65408
8111fb70:	10bfffc4 	addi	r2,r2,-1
8111fb74:	1886703a 	and	r3,r3,r2
8111fb78:	880ad07a 	srli	r5,r17,1
8111fb7c:	180497fa 	slli	r2,r3,31
8111fb80:	8900004c 	andi	r4,r17,1
8111fb84:	2922b03a 	or	r17,r5,r4
8111fb88:	1806d07a 	srli	r3,r3,1
8111fb8c:	1462b03a 	or	r17,r2,r17
8111fb90:	3825883a 	mov	r18,r7
8111fb94:	003f7106 	br	8111f95c <__reset+0xfb0ff95c>
8111fb98:	2984b03a 	or	r2,r5,r6
8111fb9c:	103f6826 	beq	r2,zero,8111f940 <__reset+0xfb0ff940>
8111fba0:	39c03fcc 	andi	r7,r7,255
8111fba4:	003f6706 	br	8111f944 <__reset+0xfb0ff944>
8111fba8:	4086b03a 	or	r3,r8,r2
8111fbac:	18015226 	beq	r3,zero,811200f8 <__subdf3+0x828>
8111fbb0:	00c00434 	movhi	r3,16
8111fbb4:	41400234 	orhi	r5,r8,8
8111fbb8:	18ffffc4 	addi	r3,r3,-1
8111fbbc:	28ca703a 	and	r5,r5,r3
8111fbc0:	003f7e06 	br	8111f9bc <__reset+0xfb0ff9bc>
8111fbc4:	10bfffc4 	addi	r2,r2,-1
8111fbc8:	1000491e 	bne	r2,zero,8111fcf0 <__subdf3+0x420>
8111fbcc:	898fc83a 	sub	r7,r17,r6
8111fbd0:	89e3803a 	cmpltu	r17,r17,r7
8111fbd4:	1947c83a 	sub	r3,r3,r5
8111fbd8:	1c47c83a 	sub	r3,r3,r17
8111fbdc:	3823883a 	mov	r17,r7
8111fbe0:	003f9b06 	br	8111fa50 <__reset+0xfb0ffa50>
8111fbe4:	2988b03a 	or	r4,r5,r6
8111fbe8:	203f5c26 	beq	r4,zero,8111f95c <__reset+0xfb0ff95c>
8111fbec:	10bfffc4 	addi	r2,r2,-1
8111fbf0:	1000931e 	bne	r2,zero,8111fe40 <__subdf3+0x570>
8111fbf4:	898d883a 	add	r6,r17,r6
8111fbf8:	3463803a 	cmpltu	r17,r6,r17
8111fbfc:	1947883a 	add	r3,r3,r5
8111fc00:	88c7883a 	add	r3,r17,r3
8111fc04:	3023883a 	mov	r17,r6
8111fc08:	003fd306 	br	8111fb58 <__reset+0xfb0ffb58>
8111fc0c:	1000541e 	bne	r2,zero,8111fd60 <__subdf3+0x490>
8111fc10:	80800044 	addi	r2,r16,1
8111fc14:	1081ffcc 	andi	r2,r2,2047
8111fc18:	01000044 	movi	r4,1
8111fc1c:	2080a20e 	bge	r4,r2,8111fea8 <__subdf3+0x5d8>
8111fc20:	8989c83a 	sub	r4,r17,r6
8111fc24:	8905803a 	cmpltu	r2,r17,r4
8111fc28:	1967c83a 	sub	r19,r3,r5
8111fc2c:	98a7c83a 	sub	r19,r19,r2
8111fc30:	9880202c 	andhi	r2,r19,128
8111fc34:	10006326 	beq	r2,zero,8111fdc4 <__subdf3+0x4f4>
8111fc38:	3463c83a 	sub	r17,r6,r17
8111fc3c:	28c7c83a 	sub	r3,r5,r3
8111fc40:	344d803a 	cmpltu	r6,r6,r17
8111fc44:	19a7c83a 	sub	r19,r3,r6
8111fc48:	3825883a 	mov	r18,r7
8111fc4c:	983f861e 	bne	r19,zero,8111fa68 <__reset+0xfb0ffa68>
8111fc50:	8809883a 	mov	r4,r17
8111fc54:	11205f80 	call	811205f8 <__clzsi2>
8111fc58:	10800804 	addi	r2,r2,32
8111fc5c:	113ffe04 	addi	r4,r2,-8
8111fc60:	00c007c4 	movi	r3,31
8111fc64:	193f850e 	bge	r3,r4,8111fa7c <__reset+0xfb0ffa7c>
8111fc68:	10bff604 	addi	r2,r2,-40
8111fc6c:	8884983a 	sll	r2,r17,r2
8111fc70:	0023883a 	mov	r17,zero
8111fc74:	243f880e 	bge	r4,r16,8111fa98 <__reset+0xfb0ffa98>
8111fc78:	00ffe034 	movhi	r3,65408
8111fc7c:	18ffffc4 	addi	r3,r3,-1
8111fc80:	8121c83a 	sub	r16,r16,r4
8111fc84:	10c6703a 	and	r3,r2,r3
8111fc88:	003f3406 	br	8111f95c <__reset+0xfb0ff95c>
8111fc8c:	9100004c 	andi	r4,r18,1
8111fc90:	000b883a 	mov	r5,zero
8111fc94:	0005883a 	mov	r2,zero
8111fc98:	003f4806 	br	8111f9bc <__reset+0xfb0ff9bc>
8111fc9c:	298cb03a 	or	r6,r5,r6
8111fca0:	300cc03a 	cmpne	r6,r6,zero
8111fca4:	0005883a 	mov	r2,zero
8111fca8:	003f6406 	br	8111fa3c <__reset+0xfb0ffa3c>
8111fcac:	10009a1e 	bne	r2,zero,8111ff18 <__subdf3+0x648>
8111fcb0:	82400044 	addi	r9,r16,1
8111fcb4:	4881ffcc 	andi	r2,r9,2047
8111fcb8:	02800044 	movi	r10,1
8111fcbc:	5080670e 	bge	r10,r2,8111fe5c <__subdf3+0x58c>
8111fcc0:	0081ffc4 	movi	r2,2047
8111fcc4:	4880af26 	beq	r9,r2,8111ff84 <__subdf3+0x6b4>
8111fcc8:	898d883a 	add	r6,r17,r6
8111fccc:	1945883a 	add	r2,r3,r5
8111fcd0:	3447803a 	cmpltu	r3,r6,r17
8111fcd4:	1887883a 	add	r3,r3,r2
8111fcd8:	182297fa 	slli	r17,r3,31
8111fcdc:	300cd07a 	srli	r6,r6,1
8111fce0:	1806d07a 	srli	r3,r3,1
8111fce4:	4821883a 	mov	r16,r9
8111fce8:	89a2b03a 	or	r17,r17,r6
8111fcec:	003f1b06 	br	8111f95c <__reset+0xfb0ff95c>
8111fcf0:	0101ffc4 	movi	r4,2047
8111fcf4:	813f441e 	bne	r16,r4,8111fa08 <__reset+0xfb0ffa08>
8111fcf8:	003f1806 	br	8111f95c <__reset+0xfb0ff95c>
8111fcfc:	843ff844 	addi	r16,r16,-31
8111fd00:	01400804 	movi	r5,32
8111fd04:	1408d83a 	srl	r4,r2,r16
8111fd08:	19405026 	beq	r3,r5,8111fe4c <__subdf3+0x57c>
8111fd0c:	01401004 	movi	r5,64
8111fd10:	28c7c83a 	sub	r3,r5,r3
8111fd14:	10c4983a 	sll	r2,r2,r3
8111fd18:	88a2b03a 	or	r17,r17,r2
8111fd1c:	8822c03a 	cmpne	r17,r17,zero
8111fd20:	2462b03a 	or	r17,r4,r17
8111fd24:	0007883a 	mov	r3,zero
8111fd28:	0021883a 	mov	r16,zero
8111fd2c:	003f6d06 	br	8111fae4 <__reset+0xfb0ffae4>
8111fd30:	11fff804 	addi	r7,r2,-32
8111fd34:	01000804 	movi	r4,32
8111fd38:	29ced83a 	srl	r7,r5,r7
8111fd3c:	11004526 	beq	r2,r4,8111fe54 <__subdf3+0x584>
8111fd40:	01001004 	movi	r4,64
8111fd44:	2089c83a 	sub	r4,r4,r2
8111fd48:	2904983a 	sll	r2,r5,r4
8111fd4c:	118cb03a 	or	r6,r2,r6
8111fd50:	300cc03a 	cmpne	r6,r6,zero
8111fd54:	398cb03a 	or	r6,r7,r6
8111fd58:	0005883a 	mov	r2,zero
8111fd5c:	003f3706 	br	8111fa3c <__reset+0xfb0ffa3c>
8111fd60:	80002a26 	beq	r16,zero,8111fe0c <__subdf3+0x53c>
8111fd64:	0101ffc4 	movi	r4,2047
8111fd68:	49006626 	beq	r9,r4,8111ff04 <__subdf3+0x634>
8111fd6c:	0085c83a 	sub	r2,zero,r2
8111fd70:	18c02034 	orhi	r3,r3,128
8111fd74:	01000e04 	movi	r4,56
8111fd78:	20807e16 	blt	r4,r2,8111ff74 <__subdf3+0x6a4>
8111fd7c:	010007c4 	movi	r4,31
8111fd80:	2080e716 	blt	r4,r2,81120120 <__subdf3+0x850>
8111fd84:	01000804 	movi	r4,32
8111fd88:	2089c83a 	sub	r4,r4,r2
8111fd8c:	1914983a 	sll	r10,r3,r4
8111fd90:	8890d83a 	srl	r8,r17,r2
8111fd94:	8908983a 	sll	r4,r17,r4
8111fd98:	1884d83a 	srl	r2,r3,r2
8111fd9c:	5222b03a 	or	r17,r10,r8
8111fda0:	2006c03a 	cmpne	r3,r4,zero
8111fda4:	88e2b03a 	or	r17,r17,r3
8111fda8:	3463c83a 	sub	r17,r6,r17
8111fdac:	2885c83a 	sub	r2,r5,r2
8111fdb0:	344d803a 	cmpltu	r6,r6,r17
8111fdb4:	1187c83a 	sub	r3,r2,r6
8111fdb8:	4821883a 	mov	r16,r9
8111fdbc:	3825883a 	mov	r18,r7
8111fdc0:	003f2306 	br	8111fa50 <__reset+0xfb0ffa50>
8111fdc4:	24d0b03a 	or	r8,r4,r19
8111fdc8:	40001b1e 	bne	r8,zero,8111fe38 <__subdf3+0x568>
8111fdcc:	0005883a 	mov	r2,zero
8111fdd0:	0009883a 	mov	r4,zero
8111fdd4:	0021883a 	mov	r16,zero
8111fdd8:	003f4906 	br	8111fb00 <__reset+0xfb0ffb00>
8111fddc:	010007c4 	movi	r4,31
8111fde0:	20803a16 	blt	r4,r2,8111fecc <__subdf3+0x5fc>
8111fde4:	01000804 	movi	r4,32
8111fde8:	2089c83a 	sub	r4,r4,r2
8111fdec:	2912983a 	sll	r9,r5,r4
8111fdf0:	3090d83a 	srl	r8,r6,r2
8111fdf4:	3108983a 	sll	r4,r6,r4
8111fdf8:	2884d83a 	srl	r2,r5,r2
8111fdfc:	4a12b03a 	or	r9,r9,r8
8111fe00:	2008c03a 	cmpne	r4,r4,zero
8111fe04:	4912b03a 	or	r9,r9,r4
8111fe08:	003f4e06 	br	8111fb44 <__reset+0xfb0ffb44>
8111fe0c:	1c48b03a 	or	r4,r3,r17
8111fe10:	20003c26 	beq	r4,zero,8111ff04 <__subdf3+0x634>
8111fe14:	0084303a 	nor	r2,zero,r2
8111fe18:	1000381e 	bne	r2,zero,8111fefc <__subdf3+0x62c>
8111fe1c:	3463c83a 	sub	r17,r6,r17
8111fe20:	28c5c83a 	sub	r2,r5,r3
8111fe24:	344d803a 	cmpltu	r6,r6,r17
8111fe28:	1187c83a 	sub	r3,r2,r6
8111fe2c:	4821883a 	mov	r16,r9
8111fe30:	3825883a 	mov	r18,r7
8111fe34:	003f0606 	br	8111fa50 <__reset+0xfb0ffa50>
8111fe38:	2023883a 	mov	r17,r4
8111fe3c:	003f0906 	br	8111fa64 <__reset+0xfb0ffa64>
8111fe40:	0101ffc4 	movi	r4,2047
8111fe44:	813f3a1e 	bne	r16,r4,8111fb30 <__reset+0xfb0ffb30>
8111fe48:	003ec406 	br	8111f95c <__reset+0xfb0ff95c>
8111fe4c:	0005883a 	mov	r2,zero
8111fe50:	003fb106 	br	8111fd18 <__reset+0xfb0ffd18>
8111fe54:	0005883a 	mov	r2,zero
8111fe58:	003fbc06 	br	8111fd4c <__reset+0xfb0ffd4c>
8111fe5c:	1c44b03a 	or	r2,r3,r17
8111fe60:	80008e1e 	bne	r16,zero,8112009c <__subdf3+0x7cc>
8111fe64:	1000c826 	beq	r2,zero,81120188 <__subdf3+0x8b8>
8111fe68:	2984b03a 	or	r2,r5,r6
8111fe6c:	103ebb26 	beq	r2,zero,8111f95c <__reset+0xfb0ff95c>
8111fe70:	8989883a 	add	r4,r17,r6
8111fe74:	1945883a 	add	r2,r3,r5
8111fe78:	2447803a 	cmpltu	r3,r4,r17
8111fe7c:	1887883a 	add	r3,r3,r2
8111fe80:	1880202c 	andhi	r2,r3,128
8111fe84:	2023883a 	mov	r17,r4
8111fe88:	103f1626 	beq	r2,zero,8111fae4 <__reset+0xfb0ffae4>
8111fe8c:	00bfe034 	movhi	r2,65408
8111fe90:	10bfffc4 	addi	r2,r2,-1
8111fe94:	5021883a 	mov	r16,r10
8111fe98:	1886703a 	and	r3,r3,r2
8111fe9c:	003eaf06 	br	8111f95c <__reset+0xfb0ff95c>
8111fea0:	3825883a 	mov	r18,r7
8111fea4:	003f0f06 	br	8111fae4 <__reset+0xfb0ffae4>
8111fea8:	1c44b03a 	or	r2,r3,r17
8111feac:	8000251e 	bne	r16,zero,8111ff44 <__subdf3+0x674>
8111feb0:	1000661e 	bne	r2,zero,8112004c <__subdf3+0x77c>
8111feb4:	2990b03a 	or	r8,r5,r6
8111feb8:	40009626 	beq	r8,zero,81120114 <__subdf3+0x844>
8111febc:	2807883a 	mov	r3,r5
8111fec0:	3023883a 	mov	r17,r6
8111fec4:	3825883a 	mov	r18,r7
8111fec8:	003ea406 	br	8111f95c <__reset+0xfb0ff95c>
8111fecc:	127ff804 	addi	r9,r2,-32
8111fed0:	01000804 	movi	r4,32
8111fed4:	2a52d83a 	srl	r9,r5,r9
8111fed8:	11008c26 	beq	r2,r4,8112010c <__subdf3+0x83c>
8111fedc:	01001004 	movi	r4,64
8111fee0:	2085c83a 	sub	r2,r4,r2
8111fee4:	2884983a 	sll	r2,r5,r2
8111fee8:	118cb03a 	or	r6,r2,r6
8111feec:	300cc03a 	cmpne	r6,r6,zero
8111fef0:	4992b03a 	or	r9,r9,r6
8111fef4:	0005883a 	mov	r2,zero
8111fef8:	003f1206 	br	8111fb44 <__reset+0xfb0ffb44>
8111fefc:	0101ffc4 	movi	r4,2047
8111ff00:	493f9c1e 	bne	r9,r4,8111fd74 <__reset+0xfb0ffd74>
8111ff04:	2807883a 	mov	r3,r5
8111ff08:	3023883a 	mov	r17,r6
8111ff0c:	4821883a 	mov	r16,r9
8111ff10:	3825883a 	mov	r18,r7
8111ff14:	003e9106 	br	8111f95c <__reset+0xfb0ff95c>
8111ff18:	80001f1e 	bne	r16,zero,8111ff98 <__subdf3+0x6c8>
8111ff1c:	1c48b03a 	or	r4,r3,r17
8111ff20:	20005a26 	beq	r4,zero,8112008c <__subdf3+0x7bc>
8111ff24:	0084303a 	nor	r2,zero,r2
8111ff28:	1000561e 	bne	r2,zero,81120084 <__subdf3+0x7b4>
8111ff2c:	89a3883a 	add	r17,r17,r6
8111ff30:	1945883a 	add	r2,r3,r5
8111ff34:	898d803a 	cmpltu	r6,r17,r6
8111ff38:	3087883a 	add	r3,r6,r2
8111ff3c:	4821883a 	mov	r16,r9
8111ff40:	003f0506 	br	8111fb58 <__reset+0xfb0ffb58>
8111ff44:	10002b1e 	bne	r2,zero,8111fff4 <__subdf3+0x724>
8111ff48:	2984b03a 	or	r2,r5,r6
8111ff4c:	10008026 	beq	r2,zero,81120150 <__subdf3+0x880>
8111ff50:	2807883a 	mov	r3,r5
8111ff54:	3023883a 	mov	r17,r6
8111ff58:	3825883a 	mov	r18,r7
8111ff5c:	0401ffc4 	movi	r16,2047
8111ff60:	003e7e06 	br	8111f95c <__reset+0xfb0ff95c>
8111ff64:	3809883a 	mov	r4,r7
8111ff68:	0011883a 	mov	r8,zero
8111ff6c:	0005883a 	mov	r2,zero
8111ff70:	003ee306 	br	8111fb00 <__reset+0xfb0ffb00>
8111ff74:	1c62b03a 	or	r17,r3,r17
8111ff78:	8822c03a 	cmpne	r17,r17,zero
8111ff7c:	0005883a 	mov	r2,zero
8111ff80:	003f8906 	br	8111fda8 <__reset+0xfb0ffda8>
8111ff84:	3809883a 	mov	r4,r7
8111ff88:	4821883a 	mov	r16,r9
8111ff8c:	0011883a 	mov	r8,zero
8111ff90:	0005883a 	mov	r2,zero
8111ff94:	003eda06 	br	8111fb00 <__reset+0xfb0ffb00>
8111ff98:	0101ffc4 	movi	r4,2047
8111ff9c:	49003b26 	beq	r9,r4,8112008c <__subdf3+0x7bc>
8111ffa0:	0085c83a 	sub	r2,zero,r2
8111ffa4:	18c02034 	orhi	r3,r3,128
8111ffa8:	01000e04 	movi	r4,56
8111ffac:	20806e16 	blt	r4,r2,81120168 <__subdf3+0x898>
8111ffb0:	010007c4 	movi	r4,31
8111ffb4:	20807716 	blt	r4,r2,81120194 <__subdf3+0x8c4>
8111ffb8:	01000804 	movi	r4,32
8111ffbc:	2089c83a 	sub	r4,r4,r2
8111ffc0:	1914983a 	sll	r10,r3,r4
8111ffc4:	8890d83a 	srl	r8,r17,r2
8111ffc8:	8908983a 	sll	r4,r17,r4
8111ffcc:	1884d83a 	srl	r2,r3,r2
8111ffd0:	5222b03a 	or	r17,r10,r8
8111ffd4:	2006c03a 	cmpne	r3,r4,zero
8111ffd8:	88e2b03a 	or	r17,r17,r3
8111ffdc:	89a3883a 	add	r17,r17,r6
8111ffe0:	1145883a 	add	r2,r2,r5
8111ffe4:	898d803a 	cmpltu	r6,r17,r6
8111ffe8:	3087883a 	add	r3,r6,r2
8111ffec:	4821883a 	mov	r16,r9
8111fff0:	003ed906 	br	8111fb58 <__reset+0xfb0ffb58>
8111fff4:	2984b03a 	or	r2,r5,r6
8111fff8:	10004226 	beq	r2,zero,81120104 <__subdf3+0x834>
8111fffc:	1808d0fa 	srli	r4,r3,3
81120000:	8822d0fa 	srli	r17,r17,3
81120004:	1806977a 	slli	r3,r3,29
81120008:	2080022c 	andhi	r2,r4,8
8112000c:	1c62b03a 	or	r17,r3,r17
81120010:	10000826 	beq	r2,zero,81120034 <__subdf3+0x764>
81120014:	2812d0fa 	srli	r9,r5,3
81120018:	4880022c 	andhi	r2,r9,8
8112001c:	1000051e 	bne	r2,zero,81120034 <__subdf3+0x764>
81120020:	300cd0fa 	srli	r6,r6,3
81120024:	2804977a 	slli	r2,r5,29
81120028:	4809883a 	mov	r4,r9
8112002c:	3825883a 	mov	r18,r7
81120030:	11a2b03a 	or	r17,r2,r6
81120034:	8806d77a 	srli	r3,r17,29
81120038:	200890fa 	slli	r4,r4,3
8112003c:	882290fa 	slli	r17,r17,3
81120040:	0401ffc4 	movi	r16,2047
81120044:	1906b03a 	or	r3,r3,r4
81120048:	003e4406 	br	8111f95c <__reset+0xfb0ff95c>
8112004c:	2984b03a 	or	r2,r5,r6
81120050:	103e4226 	beq	r2,zero,8111f95c <__reset+0xfb0ff95c>
81120054:	8989c83a 	sub	r4,r17,r6
81120058:	8911803a 	cmpltu	r8,r17,r4
8112005c:	1945c83a 	sub	r2,r3,r5
81120060:	1205c83a 	sub	r2,r2,r8
81120064:	1200202c 	andhi	r8,r2,128
81120068:	403e9a26 	beq	r8,zero,8111fad4 <__reset+0xfb0ffad4>
8112006c:	3463c83a 	sub	r17,r6,r17
81120070:	28c5c83a 	sub	r2,r5,r3
81120074:	344d803a 	cmpltu	r6,r6,r17
81120078:	1187c83a 	sub	r3,r2,r6
8112007c:	3825883a 	mov	r18,r7
81120080:	003e3606 	br	8111f95c <__reset+0xfb0ff95c>
81120084:	0101ffc4 	movi	r4,2047
81120088:	493fc71e 	bne	r9,r4,8111ffa8 <__reset+0xfb0fffa8>
8112008c:	2807883a 	mov	r3,r5
81120090:	3023883a 	mov	r17,r6
81120094:	4821883a 	mov	r16,r9
81120098:	003e3006 	br	8111f95c <__reset+0xfb0ff95c>
8112009c:	10003626 	beq	r2,zero,81120178 <__subdf3+0x8a8>
811200a0:	2984b03a 	or	r2,r5,r6
811200a4:	10001726 	beq	r2,zero,81120104 <__subdf3+0x834>
811200a8:	1808d0fa 	srli	r4,r3,3
811200ac:	8822d0fa 	srli	r17,r17,3
811200b0:	1806977a 	slli	r3,r3,29
811200b4:	2080022c 	andhi	r2,r4,8
811200b8:	1c62b03a 	or	r17,r3,r17
811200bc:	10000726 	beq	r2,zero,811200dc <__subdf3+0x80c>
811200c0:	2812d0fa 	srli	r9,r5,3
811200c4:	4880022c 	andhi	r2,r9,8
811200c8:	1000041e 	bne	r2,zero,811200dc <__subdf3+0x80c>
811200cc:	300cd0fa 	srli	r6,r6,3
811200d0:	2804977a 	slli	r2,r5,29
811200d4:	4809883a 	mov	r4,r9
811200d8:	11a2b03a 	or	r17,r2,r6
811200dc:	8806d77a 	srli	r3,r17,29
811200e0:	200890fa 	slli	r4,r4,3
811200e4:	882290fa 	slli	r17,r17,3
811200e8:	3825883a 	mov	r18,r7
811200ec:	1906b03a 	or	r3,r3,r4
811200f0:	0401ffc4 	movi	r16,2047
811200f4:	003e1906 	br	8111f95c <__reset+0xfb0ff95c>
811200f8:	000b883a 	mov	r5,zero
811200fc:	0005883a 	mov	r2,zero
81120100:	003e2e06 	br	8111f9bc <__reset+0xfb0ff9bc>
81120104:	0401ffc4 	movi	r16,2047
81120108:	003e1406 	br	8111f95c <__reset+0xfb0ff95c>
8112010c:	0005883a 	mov	r2,zero
81120110:	003f7506 	br	8111fee8 <__reset+0xfb0ffee8>
81120114:	0005883a 	mov	r2,zero
81120118:	0009883a 	mov	r4,zero
8112011c:	003e7806 	br	8111fb00 <__reset+0xfb0ffb00>
81120120:	123ff804 	addi	r8,r2,-32
81120124:	01000804 	movi	r4,32
81120128:	1a10d83a 	srl	r8,r3,r8
8112012c:	11002526 	beq	r2,r4,811201c4 <__subdf3+0x8f4>
81120130:	01001004 	movi	r4,64
81120134:	2085c83a 	sub	r2,r4,r2
81120138:	1884983a 	sll	r2,r3,r2
8112013c:	1444b03a 	or	r2,r2,r17
81120140:	1004c03a 	cmpne	r2,r2,zero
81120144:	40a2b03a 	or	r17,r8,r2
81120148:	0005883a 	mov	r2,zero
8112014c:	003f1606 	br	8111fda8 <__reset+0xfb0ffda8>
81120150:	02000434 	movhi	r8,16
81120154:	0009883a 	mov	r4,zero
81120158:	423fffc4 	addi	r8,r8,-1
8112015c:	00bfffc4 	movi	r2,-1
81120160:	0401ffc4 	movi	r16,2047
81120164:	003e6606 	br	8111fb00 <__reset+0xfb0ffb00>
81120168:	1c62b03a 	or	r17,r3,r17
8112016c:	8822c03a 	cmpne	r17,r17,zero
81120170:	0005883a 	mov	r2,zero
81120174:	003f9906 	br	8111ffdc <__reset+0xfb0fffdc>
81120178:	2807883a 	mov	r3,r5
8112017c:	3023883a 	mov	r17,r6
81120180:	0401ffc4 	movi	r16,2047
81120184:	003df506 	br	8111f95c <__reset+0xfb0ff95c>
81120188:	2807883a 	mov	r3,r5
8112018c:	3023883a 	mov	r17,r6
81120190:	003df206 	br	8111f95c <__reset+0xfb0ff95c>
81120194:	123ff804 	addi	r8,r2,-32
81120198:	01000804 	movi	r4,32
8112019c:	1a10d83a 	srl	r8,r3,r8
811201a0:	11000a26 	beq	r2,r4,811201cc <__subdf3+0x8fc>
811201a4:	01001004 	movi	r4,64
811201a8:	2085c83a 	sub	r2,r4,r2
811201ac:	1884983a 	sll	r2,r3,r2
811201b0:	1444b03a 	or	r2,r2,r17
811201b4:	1004c03a 	cmpne	r2,r2,zero
811201b8:	40a2b03a 	or	r17,r8,r2
811201bc:	0005883a 	mov	r2,zero
811201c0:	003f8606 	br	8111ffdc <__reset+0xfb0fffdc>
811201c4:	0005883a 	mov	r2,zero
811201c8:	003fdc06 	br	8112013c <__reset+0xfb10013c>
811201cc:	0005883a 	mov	r2,zero
811201d0:	003ff706 	br	811201b0 <__reset+0xfb1001b0>

811201d4 <__fixdfsi>:
811201d4:	280cd53a 	srli	r6,r5,20
811201d8:	00c00434 	movhi	r3,16
811201dc:	18ffffc4 	addi	r3,r3,-1
811201e0:	3181ffcc 	andi	r6,r6,2047
811201e4:	01c0ff84 	movi	r7,1022
811201e8:	28c6703a 	and	r3,r5,r3
811201ec:	280ad7fa 	srli	r5,r5,31
811201f0:	3980120e 	bge	r7,r6,8112023c <__fixdfsi+0x68>
811201f4:	00810744 	movi	r2,1053
811201f8:	11800c16 	blt	r2,r6,8112022c <__fixdfsi+0x58>
811201fc:	00810cc4 	movi	r2,1075
81120200:	1185c83a 	sub	r2,r2,r6
81120204:	01c007c4 	movi	r7,31
81120208:	18c00434 	orhi	r3,r3,16
8112020c:	38800d16 	blt	r7,r2,81120244 <__fixdfsi+0x70>
81120210:	31befb44 	addi	r6,r6,-1043
81120214:	2084d83a 	srl	r2,r4,r2
81120218:	1986983a 	sll	r3,r3,r6
8112021c:	1884b03a 	or	r2,r3,r2
81120220:	28000726 	beq	r5,zero,81120240 <__fixdfsi+0x6c>
81120224:	0085c83a 	sub	r2,zero,r2
81120228:	f800283a 	ret
8112022c:	00a00034 	movhi	r2,32768
81120230:	10bfffc4 	addi	r2,r2,-1
81120234:	2885883a 	add	r2,r5,r2
81120238:	f800283a 	ret
8112023c:	0005883a 	mov	r2,zero
81120240:	f800283a 	ret
81120244:	008104c4 	movi	r2,1043
81120248:	1185c83a 	sub	r2,r2,r6
8112024c:	1884d83a 	srl	r2,r3,r2
81120250:	003ff306 	br	81120220 <__reset+0xfb100220>

81120254 <__floatsidf>:
81120254:	defffd04 	addi	sp,sp,-12
81120258:	de00012e 	bgeu	sp,et,81120260 <__floatsidf+0xc>
8112025c:	003b68fa 	trap	3
81120260:	dfc00215 	stw	ra,8(sp)
81120264:	dc400115 	stw	r17,4(sp)
81120268:	dc000015 	stw	r16,0(sp)
8112026c:	20002b26 	beq	r4,zero,8112031c <__floatsidf+0xc8>
81120270:	2023883a 	mov	r17,r4
81120274:	2020d7fa 	srli	r16,r4,31
81120278:	20002d16 	blt	r4,zero,81120330 <__floatsidf+0xdc>
8112027c:	8809883a 	mov	r4,r17
81120280:	11205f80 	call	811205f8 <__clzsi2>
81120284:	01410784 	movi	r5,1054
81120288:	288bc83a 	sub	r5,r5,r2
8112028c:	01010cc4 	movi	r4,1075
81120290:	2149c83a 	sub	r4,r4,r5
81120294:	00c007c4 	movi	r3,31
81120298:	1900160e 	bge	r3,r4,811202f4 <__floatsidf+0xa0>
8112029c:	00c104c4 	movi	r3,1043
811202a0:	1947c83a 	sub	r3,r3,r5
811202a4:	88c6983a 	sll	r3,r17,r3
811202a8:	00800434 	movhi	r2,16
811202ac:	10bfffc4 	addi	r2,r2,-1
811202b0:	1886703a 	and	r3,r3,r2
811202b4:	2941ffcc 	andi	r5,r5,2047
811202b8:	800d883a 	mov	r6,r16
811202bc:	0005883a 	mov	r2,zero
811202c0:	280a953a 	slli	r5,r5,20
811202c4:	31803fcc 	andi	r6,r6,255
811202c8:	01000434 	movhi	r4,16
811202cc:	300c97fa 	slli	r6,r6,31
811202d0:	213fffc4 	addi	r4,r4,-1
811202d4:	1906703a 	and	r3,r3,r4
811202d8:	1946b03a 	or	r3,r3,r5
811202dc:	1986b03a 	or	r3,r3,r6
811202e0:	dfc00217 	ldw	ra,8(sp)
811202e4:	dc400117 	ldw	r17,4(sp)
811202e8:	dc000017 	ldw	r16,0(sp)
811202ec:	dec00304 	addi	sp,sp,12
811202f0:	f800283a 	ret
811202f4:	00c002c4 	movi	r3,11
811202f8:	1887c83a 	sub	r3,r3,r2
811202fc:	88c6d83a 	srl	r3,r17,r3
81120300:	8904983a 	sll	r2,r17,r4
81120304:	01000434 	movhi	r4,16
81120308:	213fffc4 	addi	r4,r4,-1
8112030c:	2941ffcc 	andi	r5,r5,2047
81120310:	1906703a 	and	r3,r3,r4
81120314:	800d883a 	mov	r6,r16
81120318:	003fe906 	br	811202c0 <__reset+0xfb1002c0>
8112031c:	000d883a 	mov	r6,zero
81120320:	000b883a 	mov	r5,zero
81120324:	0007883a 	mov	r3,zero
81120328:	0005883a 	mov	r2,zero
8112032c:	003fe406 	br	811202c0 <__reset+0xfb1002c0>
81120330:	0123c83a 	sub	r17,zero,r4
81120334:	003fd106 	br	8112027c <__reset+0xfb10027c>

81120338 <__extendsfdf2>:
81120338:	200ad5fa 	srli	r5,r4,23
8112033c:	defffd04 	addi	sp,sp,-12
81120340:	de00012e 	bgeu	sp,et,81120348 <__extendsfdf2+0x10>
81120344:	003b68fa 	trap	3
81120348:	29403fcc 	andi	r5,r5,255
8112034c:	dc400115 	stw	r17,4(sp)
81120350:	29800044 	addi	r6,r5,1
81120354:	04402034 	movhi	r17,128
81120358:	dc000015 	stw	r16,0(sp)
8112035c:	8c7fffc4 	addi	r17,r17,-1
81120360:	dfc00215 	stw	ra,8(sp)
81120364:	31803fcc 	andi	r6,r6,255
81120368:	00800044 	movi	r2,1
8112036c:	8922703a 	and	r17,r17,r4
81120370:	2020d7fa 	srli	r16,r4,31
81120374:	1180110e 	bge	r2,r6,811203bc <__extendsfdf2+0x84>
81120378:	880cd0fa 	srli	r6,r17,3
8112037c:	8822977a 	slli	r17,r17,29
81120380:	2940e004 	addi	r5,r5,896
81120384:	2941ffcc 	andi	r5,r5,2047
81120388:	2804953a 	slli	r2,r5,20
8112038c:	01400434 	movhi	r5,16
81120390:	800697fa 	slli	r3,r16,31
81120394:	297fffc4 	addi	r5,r5,-1
81120398:	314a703a 	and	r5,r6,r5
8112039c:	288ab03a 	or	r5,r5,r2
811203a0:	28c6b03a 	or	r3,r5,r3
811203a4:	8805883a 	mov	r2,r17
811203a8:	dfc00217 	ldw	ra,8(sp)
811203ac:	dc400117 	ldw	r17,4(sp)
811203b0:	dc000017 	ldw	r16,0(sp)
811203b4:	dec00304 	addi	sp,sp,12
811203b8:	f800283a 	ret
811203bc:	2800111e 	bne	r5,zero,81120404 <__extendsfdf2+0xcc>
811203c0:	88001c26 	beq	r17,zero,81120434 <__extendsfdf2+0xfc>
811203c4:	8809883a 	mov	r4,r17
811203c8:	11205f80 	call	811205f8 <__clzsi2>
811203cc:	00c00284 	movi	r3,10
811203d0:	18801b16 	blt	r3,r2,81120440 <__extendsfdf2+0x108>
811203d4:	018002c4 	movi	r6,11
811203d8:	308dc83a 	sub	r6,r6,r2
811203dc:	11000544 	addi	r4,r2,21
811203e0:	8986d83a 	srl	r3,r17,r6
811203e4:	8922983a 	sll	r17,r17,r4
811203e8:	0180e244 	movi	r6,905
811203ec:	01400434 	movhi	r5,16
811203f0:	3085c83a 	sub	r2,r6,r2
811203f4:	297fffc4 	addi	r5,r5,-1
811203f8:	194c703a 	and	r6,r3,r5
811203fc:	1141ffcc 	andi	r5,r2,2047
81120400:	003fe006 	br	81120384 <__reset+0xfb100384>
81120404:	88000826 	beq	r17,zero,81120428 <__extendsfdf2+0xf0>
81120408:	880cd0fa 	srli	r6,r17,3
8112040c:	00800434 	movhi	r2,16
81120410:	10bfffc4 	addi	r2,r2,-1
81120414:	31800234 	orhi	r6,r6,8
81120418:	8822977a 	slli	r17,r17,29
8112041c:	308c703a 	and	r6,r6,r2
81120420:	0141ffc4 	movi	r5,2047
81120424:	003fd706 	br	81120384 <__reset+0xfb100384>
81120428:	0141ffc4 	movi	r5,2047
8112042c:	000d883a 	mov	r6,zero
81120430:	003fd406 	br	81120384 <__reset+0xfb100384>
81120434:	000b883a 	mov	r5,zero
81120438:	000d883a 	mov	r6,zero
8112043c:	003fd106 	br	81120384 <__reset+0xfb100384>
81120440:	11bffd44 	addi	r6,r2,-11
81120444:	8986983a 	sll	r3,r17,r6
81120448:	0023883a 	mov	r17,zero
8112044c:	003fe606 	br	811203e8 <__reset+0xfb1003e8>

81120450 <__truncdfsf2>:
81120450:	2810d53a 	srli	r8,r5,20
81120454:	01c00434 	movhi	r7,16
81120458:	39ffffc4 	addi	r7,r7,-1
8112045c:	29ce703a 	and	r7,r5,r7
81120460:	4201ffcc 	andi	r8,r8,2047
81120464:	380e90fa 	slli	r7,r7,3
81120468:	200cd77a 	srli	r6,r4,29
8112046c:	42400044 	addi	r9,r8,1
81120470:	4a41ffcc 	andi	r9,r9,2047
81120474:	00c00044 	movi	r3,1
81120478:	280ad7fa 	srli	r5,r5,31
8112047c:	31ceb03a 	or	r7,r6,r7
81120480:	200490fa 	slli	r2,r4,3
81120484:	1a40230e 	bge	r3,r9,81120514 <__truncdfsf2+0xc4>
81120488:	40ff2004 	addi	r3,r8,-896
8112048c:	01803f84 	movi	r6,254
81120490:	30c01516 	blt	r6,r3,811204e8 <__truncdfsf2+0x98>
81120494:	00c0380e 	bge	zero,r3,81120578 <__truncdfsf2+0x128>
81120498:	200c91ba 	slli	r6,r4,6
8112049c:	380e90fa 	slli	r7,r7,3
811204a0:	1004d77a 	srli	r2,r2,29
811204a4:	300cc03a 	cmpne	r6,r6,zero
811204a8:	31ccb03a 	or	r6,r6,r7
811204ac:	308cb03a 	or	r6,r6,r2
811204b0:	308001cc 	andi	r2,r6,7
811204b4:	10000426 	beq	r2,zero,811204c8 <__truncdfsf2+0x78>
811204b8:	308003cc 	andi	r2,r6,15
811204bc:	01000104 	movi	r4,4
811204c0:	11000126 	beq	r2,r4,811204c8 <__truncdfsf2+0x78>
811204c4:	31800104 	addi	r6,r6,4
811204c8:	3081002c 	andhi	r2,r6,1024
811204cc:	10001626 	beq	r2,zero,81120528 <__truncdfsf2+0xd8>
811204d0:	18c00044 	addi	r3,r3,1
811204d4:	00803fc4 	movi	r2,255
811204d8:	18800326 	beq	r3,r2,811204e8 <__truncdfsf2+0x98>
811204dc:	300c91ba 	slli	r6,r6,6
811204e0:	300cd27a 	srli	r6,r6,9
811204e4:	00000206 	br	811204f0 <__truncdfsf2+0xa0>
811204e8:	00ffffc4 	movi	r3,-1
811204ec:	000d883a 	mov	r6,zero
811204f0:	18c03fcc 	andi	r3,r3,255
811204f4:	180895fa 	slli	r4,r3,23
811204f8:	00c02034 	movhi	r3,128
811204fc:	280a97fa 	slli	r5,r5,31
81120500:	18ffffc4 	addi	r3,r3,-1
81120504:	30c6703a 	and	r3,r6,r3
81120508:	1906b03a 	or	r3,r3,r4
8112050c:	1944b03a 	or	r2,r3,r5
81120510:	f800283a 	ret
81120514:	40000b1e 	bne	r8,zero,81120544 <__truncdfsf2+0xf4>
81120518:	388cb03a 	or	r6,r7,r2
8112051c:	0007883a 	mov	r3,zero
81120520:	30000426 	beq	r6,zero,81120534 <__truncdfsf2+0xe4>
81120524:	01800144 	movi	r6,5
81120528:	00803fc4 	movi	r2,255
8112052c:	300cd0fa 	srli	r6,r6,3
81120530:	18800a26 	beq	r3,r2,8112055c <__truncdfsf2+0x10c>
81120534:	00802034 	movhi	r2,128
81120538:	10bfffc4 	addi	r2,r2,-1
8112053c:	308c703a 	and	r6,r6,r2
81120540:	003feb06 	br	811204f0 <__reset+0xfb1004f0>
81120544:	3888b03a 	or	r4,r7,r2
81120548:	203fe726 	beq	r4,zero,811204e8 <__reset+0xfb1004e8>
8112054c:	380c90fa 	slli	r6,r7,3
81120550:	00c03fc4 	movi	r3,255
81120554:	31808034 	orhi	r6,r6,512
81120558:	003fd506 	br	811204b0 <__reset+0xfb1004b0>
8112055c:	303fe226 	beq	r6,zero,811204e8 <__reset+0xfb1004e8>
81120560:	00802034 	movhi	r2,128
81120564:	31801034 	orhi	r6,r6,64
81120568:	10bfffc4 	addi	r2,r2,-1
8112056c:	00ffffc4 	movi	r3,-1
81120570:	308c703a 	and	r6,r6,r2
81120574:	003fde06 	br	811204f0 <__reset+0xfb1004f0>
81120578:	013ffa44 	movi	r4,-23
8112057c:	19000e16 	blt	r3,r4,811205b8 <__truncdfsf2+0x168>
81120580:	01000784 	movi	r4,30
81120584:	20c9c83a 	sub	r4,r4,r3
81120588:	018007c4 	movi	r6,31
8112058c:	39c02034 	orhi	r7,r7,128
81120590:	31000b16 	blt	r6,r4,811205c0 <__truncdfsf2+0x170>
81120594:	423f2084 	addi	r8,r8,-894
81120598:	120c983a 	sll	r6,r2,r8
8112059c:	3a0e983a 	sll	r7,r7,r8
811205a0:	1104d83a 	srl	r2,r2,r4
811205a4:	300cc03a 	cmpne	r6,r6,zero
811205a8:	31ceb03a 	or	r7,r6,r7
811205ac:	388cb03a 	or	r6,r7,r2
811205b0:	0007883a 	mov	r3,zero
811205b4:	003fbe06 	br	811204b0 <__reset+0xfb1004b0>
811205b8:	0007883a 	mov	r3,zero
811205bc:	003fd906 	br	81120524 <__reset+0xfb100524>
811205c0:	01bfff84 	movi	r6,-2
811205c4:	30cdc83a 	sub	r6,r6,r3
811205c8:	00c00804 	movi	r3,32
811205cc:	398cd83a 	srl	r6,r7,r6
811205d0:	20c00726 	beq	r4,r3,811205f0 <__truncdfsf2+0x1a0>
811205d4:	423f2884 	addi	r8,r8,-862
811205d8:	3a0e983a 	sll	r7,r7,r8
811205dc:	3884b03a 	or	r2,r7,r2
811205e0:	1004c03a 	cmpne	r2,r2,zero
811205e4:	118cb03a 	or	r6,r2,r6
811205e8:	0007883a 	mov	r3,zero
811205ec:	003fb006 	br	811204b0 <__reset+0xfb1004b0>
811205f0:	000f883a 	mov	r7,zero
811205f4:	003ff906 	br	811205dc <__reset+0xfb1005dc>

811205f8 <__clzsi2>:
811205f8:	00bfffd4 	movui	r2,65535
811205fc:	11000536 	bltu	r2,r4,81120614 <__clzsi2+0x1c>
81120600:	00803fc4 	movi	r2,255
81120604:	11000f36 	bltu	r2,r4,81120644 <__clzsi2+0x4c>
81120608:	00800804 	movi	r2,32
8112060c:	0007883a 	mov	r3,zero
81120610:	00000506 	br	81120628 <__clzsi2+0x30>
81120614:	00804034 	movhi	r2,256
81120618:	10bfffc4 	addi	r2,r2,-1
8112061c:	11000c2e 	bgeu	r2,r4,81120650 <__clzsi2+0x58>
81120620:	00800204 	movi	r2,8
81120624:	00c00604 	movi	r3,24
81120628:	20c8d83a 	srl	r4,r4,r3
8112062c:	00e04574 	movhi	r3,33045
81120630:	18fdae04 	addi	r3,r3,-2376
81120634:	1909883a 	add	r4,r3,r4
81120638:	20c00003 	ldbu	r3,0(r4)
8112063c:	10c5c83a 	sub	r2,r2,r3
81120640:	f800283a 	ret
81120644:	00800604 	movi	r2,24
81120648:	00c00204 	movi	r3,8
8112064c:	003ff606 	br	81120628 <__reset+0xfb100628>
81120650:	00800404 	movi	r2,16
81120654:	1007883a 	mov	r3,r2
81120658:	003ff306 	br	81120628 <__reset+0xfb100628>

8112065c <atoi>:
8112065c:	01800284 	movi	r6,10
81120660:	000b883a 	mov	r5,zero
81120664:	11226781 	jmpi	81122678 <strtol>

81120668 <_atoi_r>:
81120668:	01c00284 	movi	r7,10
8112066c:	000d883a 	mov	r6,zero
81120670:	11224381 	jmpi	81122438 <_strtol_r>

81120674 <_fopen_r>:
81120674:	defffa04 	addi	sp,sp,-24
81120678:	3005883a 	mov	r2,r6
8112067c:	de00012e 	bgeu	sp,et,81120684 <_fopen_r+0x10>
81120680:	003b68fa 	trap	3
81120684:	d80d883a 	mov	r6,sp
81120688:	dcc00415 	stw	r19,16(sp)
8112068c:	2827883a 	mov	r19,r5
81120690:	100b883a 	mov	r5,r2
81120694:	dc800315 	stw	r18,12(sp)
81120698:	dfc00515 	stw	ra,20(sp)
8112069c:	dc400215 	stw	r17,8(sp)
811206a0:	dc000115 	stw	r16,4(sp)
811206a4:	2025883a 	mov	r18,r4
811206a8:	112a6800 	call	8112a680 <__sflags>
811206ac:	10002726 	beq	r2,zero,8112074c <_fopen_r+0xd8>
811206b0:	9009883a 	mov	r4,r18
811206b4:	1023883a 	mov	r17,r2
811206b8:	112a4f80 	call	8112a4f8 <__sfp>
811206bc:	1021883a 	mov	r16,r2
811206c0:	10002226 	beq	r2,zero,8112074c <_fopen_r+0xd8>
811206c4:	d9800017 	ldw	r6,0(sp)
811206c8:	01c06d84 	movi	r7,438
811206cc:	980b883a 	mov	r5,r19
811206d0:	9009883a 	mov	r4,r18
811206d4:	1121ae00 	call	81121ae0 <_open_r>
811206d8:	10001916 	blt	r2,zero,81120740 <_fopen_r+0xcc>
811206dc:	8080038d 	sth	r2,14(r16)
811206e0:	00a044b4 	movhi	r2,33042
811206e4:	10886f04 	addi	r2,r2,8636
811206e8:	80800815 	stw	r2,32(r16)
811206ec:	00a044b4 	movhi	r2,33042
811206f0:	10888804 	addi	r2,r2,8736
811206f4:	80800915 	stw	r2,36(r16)
811206f8:	00a044b4 	movhi	r2,33042
811206fc:	1088a904 	addi	r2,r2,8868
81120700:	80800a15 	stw	r2,40(r16)
81120704:	00a044b4 	movhi	r2,33042
81120708:	1088c204 	addi	r2,r2,8968
8112070c:	8440030d 	sth	r17,12(r16)
81120710:	84000715 	stw	r16,28(r16)
81120714:	80800b15 	stw	r2,44(r16)
81120718:	8c40400c 	andi	r17,r17,256
8112071c:	88000d1e 	bne	r17,zero,81120754 <_fopen_r+0xe0>
81120720:	8005883a 	mov	r2,r16
81120724:	dfc00517 	ldw	ra,20(sp)
81120728:	dcc00417 	ldw	r19,16(sp)
8112072c:	dc800317 	ldw	r18,12(sp)
81120730:	dc400217 	ldw	r17,8(sp)
81120734:	dc000117 	ldw	r16,4(sp)
81120738:	dec00604 	addi	sp,sp,24
8112073c:	f800283a 	ret
81120740:	112a6400 	call	8112a640 <__sfp_lock_acquire>
81120744:	8000030d 	sth	zero,12(r16)
81120748:	112a6440 	call	8112a644 <__sfp_lock_release>
8112074c:	0005883a 	mov	r2,zero
81120750:	003ff406 	br	81120724 <__reset+0xfb100724>
81120754:	01c00084 	movi	r7,2
81120758:	000d883a 	mov	r6,zero
8112075c:	800b883a 	mov	r5,r16
81120760:	9009883a 	mov	r4,r18
81120764:	11208940 	call	81120894 <_fseek_r>
81120768:	8005883a 	mov	r2,r16
8112076c:	003fed06 	br	81120724 <__reset+0xfb100724>

81120770 <fopen>:
81120770:	00a04574 	movhi	r2,33045
81120774:	10886904 	addi	r2,r2,8612
81120778:	280d883a 	mov	r6,r5
8112077c:	200b883a 	mov	r5,r4
81120780:	11000017 	ldw	r4,0(r2)
81120784:	11206741 	jmpi	81120674 <_fopen_r>

81120788 <_fprintf_r>:
81120788:	defffe04 	addi	sp,sp,-8
8112078c:	2809883a 	mov	r4,r5
81120790:	300b883a 	mov	r5,r6
81120794:	de00012e 	bgeu	sp,et,8112079c <_fprintf_r+0x14>
81120798:	003b68fa 	trap	3
8112079c:	dfc00015 	stw	ra,0(sp)
811207a0:	d9c00115 	stw	r7,4(sp)
811207a4:	d9800104 	addi	r6,sp,4
811207a8:	1126a740 	call	81126a74 <__vfprintf_internal>
811207ac:	dfc00017 	ldw	ra,0(sp)
811207b0:	dec00204 	addi	sp,sp,8
811207b4:	f800283a 	ret

811207b8 <fprintf>:
811207b8:	defffd04 	addi	sp,sp,-12
811207bc:	de00012e 	bgeu	sp,et,811207c4 <fprintf+0xc>
811207c0:	003b68fa 	trap	3
811207c4:	dfc00015 	stw	ra,0(sp)
811207c8:	d9800115 	stw	r6,4(sp)
811207cc:	d9c00215 	stw	r7,8(sp)
811207d0:	d9800104 	addi	r6,sp,4
811207d4:	1126a740 	call	81126a74 <__vfprintf_internal>
811207d8:	dfc00017 	ldw	ra,0(sp)
811207dc:	dec00304 	addi	sp,sp,12
811207e0:	f800283a 	ret

811207e4 <_fputc_r>:
811207e4:	defffc04 	addi	sp,sp,-16
811207e8:	de00012e 	bgeu	sp,et,811207f0 <_fputc_r+0xc>
811207ec:	003b68fa 	trap	3
811207f0:	dc000215 	stw	r16,8(sp)
811207f4:	dfc00315 	stw	ra,12(sp)
811207f8:	2021883a 	mov	r16,r4
811207fc:	20000726 	beq	r4,zero,8112081c <_fputc_r+0x38>
81120800:	20800e17 	ldw	r2,56(r4)
81120804:	1000051e 	bne	r2,zero,8112081c <_fputc_r+0x38>
81120808:	d9400015 	stw	r5,0(sp)
8112080c:	d9800115 	stw	r6,4(sp)
81120810:	112a6300 	call	8112a630 <__sinit>
81120814:	d9800117 	ldw	r6,4(sp)
81120818:	d9400017 	ldw	r5,0(sp)
8112081c:	8009883a 	mov	r4,r16
81120820:	dfc00317 	ldw	ra,12(sp)
81120824:	dc000217 	ldw	r16,8(sp)
81120828:	dec00404 	addi	sp,sp,16
8112082c:	1121bc41 	jmpi	81121bc4 <_putc_r>

81120830 <fputc>:
81120830:	00a04574 	movhi	r2,33045
81120834:	defffc04 	addi	sp,sp,-16
81120838:	10886904 	addi	r2,r2,8612
8112083c:	de00012e 	bgeu	sp,et,81120844 <fputc+0x14>
81120840:	003b68fa 	trap	3
81120844:	dc000115 	stw	r16,4(sp)
81120848:	14000017 	ldw	r16,0(r2)
8112084c:	dc400215 	stw	r17,8(sp)
81120850:	dfc00315 	stw	ra,12(sp)
81120854:	2023883a 	mov	r17,r4
81120858:	80000626 	beq	r16,zero,81120874 <fputc+0x44>
8112085c:	80800e17 	ldw	r2,56(r16)
81120860:	1000041e 	bne	r2,zero,81120874 <fputc+0x44>
81120864:	8009883a 	mov	r4,r16
81120868:	d9400015 	stw	r5,0(sp)
8112086c:	112a6300 	call	8112a630 <__sinit>
81120870:	d9400017 	ldw	r5,0(sp)
81120874:	280d883a 	mov	r6,r5
81120878:	8009883a 	mov	r4,r16
8112087c:	880b883a 	mov	r5,r17
81120880:	dfc00317 	ldw	ra,12(sp)
81120884:	dc400217 	ldw	r17,8(sp)
81120888:	dc000117 	ldw	r16,4(sp)
8112088c:	dec00404 	addi	sp,sp,16
81120890:	1121bc41 	jmpi	81121bc4 <_putc_r>

81120894 <_fseek_r>:
81120894:	11208b41 	jmpi	811208b4 <_fseeko_r>

81120898 <fseek>:
81120898:	00a04574 	movhi	r2,33045
8112089c:	10886904 	addi	r2,r2,8612
811208a0:	300f883a 	mov	r7,r6
811208a4:	280d883a 	mov	r6,r5
811208a8:	200b883a 	mov	r5,r4
811208ac:	11000017 	ldw	r4,0(r2)
811208b0:	11208b41 	jmpi	811208b4 <_fseeko_r>

811208b4 <_fseeko_r>:
811208b4:	deffe804 	addi	sp,sp,-96
811208b8:	de00012e 	bgeu	sp,et,811208c0 <_fseeko_r+0xc>
811208bc:	003b68fa 	trap	3
811208c0:	dd401415 	stw	r21,80(sp)
811208c4:	dc801115 	stw	r18,68(sp)
811208c8:	dc401015 	stw	r17,64(sp)
811208cc:	dc000f15 	stw	r16,60(sp)
811208d0:	dfc01715 	stw	ra,92(sp)
811208d4:	ddc01615 	stw	r23,88(sp)
811208d8:	dd801515 	stw	r22,84(sp)
811208dc:	dd001315 	stw	r20,76(sp)
811208e0:	dcc01215 	stw	r19,72(sp)
811208e4:	2023883a 	mov	r17,r4
811208e8:	2821883a 	mov	r16,r5
811208ec:	302b883a 	mov	r21,r6
811208f0:	3825883a 	mov	r18,r7
811208f4:	20000226 	beq	r4,zero,81120900 <_fseeko_r+0x4c>
811208f8:	20800e17 	ldw	r2,56(r4)
811208fc:	10005a26 	beq	r2,zero,81120a68 <_fseeko_r+0x1b4>
81120900:	8080030b 	ldhu	r2,12(r16)
81120904:	00c04204 	movi	r3,264
81120908:	1080420c 	andi	r2,r2,264
8112090c:	10c05b26 	beq	r2,r3,81120a7c <_fseeko_r+0x1c8>
81120910:	85000a17 	ldw	r20,40(r16)
81120914:	a000f626 	beq	r20,zero,81120cf0 <_fseeko_r+0x43c>
81120918:	00800044 	movi	r2,1
8112091c:	90803e26 	beq	r18,r2,81120a18 <_fseeko_r+0x164>
81120920:	00800084 	movi	r2,2
81120924:	90801026 	beq	r18,r2,81120968 <_fseeko_r+0xb4>
81120928:	90000f26 	beq	r18,zero,81120968 <_fseeko_r+0xb4>
8112092c:	00800584 	movi	r2,22
81120930:	88800015 	stw	r2,0(r17)
81120934:	04ffffc4 	movi	r19,-1
81120938:	9805883a 	mov	r2,r19
8112093c:	dfc01717 	ldw	ra,92(sp)
81120940:	ddc01617 	ldw	r23,88(sp)
81120944:	dd801517 	ldw	r22,84(sp)
81120948:	dd401417 	ldw	r21,80(sp)
8112094c:	dd001317 	ldw	r20,76(sp)
81120950:	dcc01217 	ldw	r19,72(sp)
81120954:	dc801117 	ldw	r18,68(sp)
81120958:	dc401017 	ldw	r17,64(sp)
8112095c:	dc000f17 	ldw	r16,60(sp)
81120960:	dec01804 	addi	sp,sp,96
81120964:	f800283a 	ret
81120968:	80800417 	ldw	r2,16(r16)
8112096c:	002f883a 	mov	r23,zero
81120970:	0027883a 	mov	r19,zero
81120974:	1000cb26 	beq	r2,zero,81120ca4 <_fseeko_r+0x3f0>
81120978:	8080030b 	ldhu	r2,12(r16)
8112097c:	10c2068c 	andi	r3,r2,2074
81120980:	1800071e 	bne	r3,zero,811209a0 <_fseeko_r+0xec>
81120984:	10c1000c 	andi	r3,r2,1024
81120988:	1800451e 	bne	r3,zero,81120aa0 <_fseeko_r+0x1ec>
8112098c:	00e044b4 	movhi	r3,33042
81120990:	18c8a904 	addi	r3,r3,8868
81120994:	a0c0b726 	beq	r20,r3,81120c74 <_fseeko_r+0x3c0>
81120998:	10820014 	ori	r2,r2,2048
8112099c:	8080030d 	sth	r2,12(r16)
811209a0:	800b883a 	mov	r5,r16
811209a4:	8809883a 	mov	r4,r17
811209a8:	112a2340 	call	8112a234 <_fflush_r>
811209ac:	1027883a 	mov	r19,r2
811209b0:	103fe01e 	bne	r2,zero,81120934 <__reset+0xfb100934>
811209b4:	81400717 	ldw	r5,28(r16)
811209b8:	900f883a 	mov	r7,r18
811209bc:	a80d883a 	mov	r6,r21
811209c0:	8809883a 	mov	r4,r17
811209c4:	a03ee83a 	callr	r20
811209c8:	00ffffc4 	movi	r3,-1
811209cc:	10ffd926 	beq	r2,r3,81120934 <__reset+0xfb100934>
811209d0:	81400c17 	ldw	r5,48(r16)
811209d4:	28000526 	beq	r5,zero,811209ec <_fseeko_r+0x138>
811209d8:	80801004 	addi	r2,r16,64
811209dc:	28800226 	beq	r5,r2,811209e8 <_fseeko_r+0x134>
811209e0:	8809883a 	mov	r4,r17
811209e4:	112aac80 	call	8112aac8 <_free_r>
811209e8:	80000c15 	stw	zero,48(r16)
811209ec:	8080030b 	ldhu	r2,12(r16)
811209f0:	80c00417 	ldw	r3,16(r16)
811209f4:	80000115 	stw	zero,4(r16)
811209f8:	10bdf7cc 	andi	r2,r2,63455
811209fc:	80c00015 	stw	r3,0(r16)
81120a00:	8080030d 	sth	r2,12(r16)
81120a04:	01800204 	movi	r6,8
81120a08:	000b883a 	mov	r5,zero
81120a0c:	81001704 	addi	r4,r16,92
81120a10:	11219b80 	call	811219b8 <memset>
81120a14:	003fc806 	br	81120938 <__reset+0xfb100938>
81120a18:	800b883a 	mov	r5,r16
81120a1c:	8809883a 	mov	r4,r17
81120a20:	112a2340 	call	8112a234 <_fflush_r>
81120a24:	8080030b 	ldhu	r2,12(r16)
81120a28:	10c4000c 	andi	r3,r2,4096
81120a2c:	18008726 	beq	r3,zero,81120c4c <_fseeko_r+0x398>
81120a30:	84c01417 	ldw	r19,80(r16)
81120a34:	10c0010c 	andi	r3,r2,4
81120a38:	1800431e 	bne	r3,zero,81120b48 <_fseeko_r+0x294>
81120a3c:	1080020c 	andi	r2,r2,8
81120a40:	10008026 	beq	r2,zero,81120c44 <_fseeko_r+0x390>
81120a44:	80c00017 	ldw	r3,0(r16)
81120a48:	80800417 	ldw	r2,16(r16)
81120a4c:	18000226 	beq	r3,zero,81120a58 <_fseeko_r+0x1a4>
81120a50:	1887c83a 	sub	r3,r3,r2
81120a54:	98e7883a 	add	r19,r19,r3
81120a58:	aceb883a 	add	r21,r21,r19
81120a5c:	05c00044 	movi	r23,1
81120a60:	0025883a 	mov	r18,zero
81120a64:	003fc306 	br	81120974 <__reset+0xfb100974>
81120a68:	112a6300 	call	8112a630 <__sinit>
81120a6c:	8080030b 	ldhu	r2,12(r16)
81120a70:	00c04204 	movi	r3,264
81120a74:	1080420c 	andi	r2,r2,264
81120a78:	10ffa51e 	bne	r2,r3,81120910 <__reset+0xfb100910>
81120a7c:	800b883a 	mov	r5,r16
81120a80:	8809883a 	mov	r4,r17
81120a84:	112a2340 	call	8112a234 <_fflush_r>
81120a88:	003fa106 	br	81120910 <__reset+0xfb100910>
81120a8c:	8080030b 	ldhu	r2,12(r16)
81120a90:	00c10004 	movi	r3,1024
81120a94:	80c01315 	stw	r3,76(r16)
81120a98:	10c4b03a 	or	r2,r2,r3
81120a9c:	8080030d 	sth	r2,12(r16)
81120aa0:	9000311e 	bne	r18,zero,81120b68 <_fseeko_r+0x2b4>
81120aa4:	a82d883a 	mov	r22,r21
81120aa8:	b800371e 	bne	r23,zero,81120b88 <_fseeko_r+0x2d4>
81120aac:	8080030b 	ldhu	r2,12(r16)
81120ab0:	1084000c 	andi	r2,r2,4096
81120ab4:	10007f26 	beq	r2,zero,81120cb4 <_fseeko_r+0x400>
81120ab8:	80801417 	ldw	r2,80(r16)
81120abc:	81800117 	ldw	r6,4(r16)
81120ac0:	81400c17 	ldw	r5,48(r16)
81120ac4:	11a7c83a 	sub	r19,r2,r6
81120ac8:	28008226 	beq	r5,zero,81120cd4 <_fseeko_r+0x420>
81120acc:	81c00f17 	ldw	r7,60(r16)
81120ad0:	99e7c83a 	sub	r19,r19,r7
81120ad4:	81000e17 	ldw	r4,56(r16)
81120ad8:	80800417 	ldw	r2,16(r16)
81120adc:	99a7883a 	add	r19,r19,r6
81120ae0:	2087c83a 	sub	r3,r4,r2
81120ae4:	98e7c83a 	sub	r19,r19,r3
81120ae8:	38c7883a 	add	r3,r7,r3
81120aec:	b4c02b16 	blt	r22,r19,81120b9c <_fseeko_r+0x2e8>
81120af0:	98c9883a 	add	r4,r19,r3
81120af4:	b100292e 	bgeu	r22,r4,81120b9c <_fseeko_r+0x2e8>
81120af8:	b4e7c83a 	sub	r19,r22,r19
81120afc:	14c5883a 	add	r2,r2,r19
81120b00:	1ce7c83a 	sub	r19,r3,r19
81120b04:	80800015 	stw	r2,0(r16)
81120b08:	84c00115 	stw	r19,4(r16)
81120b0c:	28000526 	beq	r5,zero,81120b24 <_fseeko_r+0x270>
81120b10:	80801004 	addi	r2,r16,64
81120b14:	28800226 	beq	r5,r2,81120b20 <_fseeko_r+0x26c>
81120b18:	8809883a 	mov	r4,r17
81120b1c:	112aac80 	call	8112aac8 <_free_r>
81120b20:	80000c15 	stw	zero,48(r16)
81120b24:	8080030b 	ldhu	r2,12(r16)
81120b28:	01800204 	movi	r6,8
81120b2c:	000b883a 	mov	r5,zero
81120b30:	10bff7cc 	andi	r2,r2,65503
81120b34:	8080030d 	sth	r2,12(r16)
81120b38:	81001704 	addi	r4,r16,92
81120b3c:	11219b80 	call	811219b8 <memset>
81120b40:	0027883a 	mov	r19,zero
81120b44:	003f7c06 	br	81120938 <__reset+0xfb100938>
81120b48:	80c00117 	ldw	r3,4(r16)
81120b4c:	80800c17 	ldw	r2,48(r16)
81120b50:	98e7c83a 	sub	r19,r19,r3
81120b54:	10003b26 	beq	r2,zero,81120c44 <_fseeko_r+0x390>
81120b58:	80c00f17 	ldw	r3,60(r16)
81120b5c:	80800417 	ldw	r2,16(r16)
81120b60:	98e7c83a 	sub	r19,r19,r3
81120b64:	003fbc06 	br	81120a58 <__reset+0xfb100a58>
81120b68:	8140038f 	ldh	r5,14(r16)
81120b6c:	d80d883a 	mov	r6,sp
81120b70:	8809883a 	mov	r4,r17
81120b74:	1120d1c0 	call	81120d1c <_fstat_r>
81120b78:	103f891e 	bne	r2,zero,811209a0 <__reset+0xfb1009a0>
81120b7c:	dd800417 	ldw	r22,16(sp)
81120b80:	adad883a 	add	r22,r21,r22
81120b84:	b83fc926 	beq	r23,zero,81120aac <__reset+0xfb100aac>
81120b88:	81400c17 	ldw	r5,48(r16)
81120b8c:	81800117 	ldw	r6,4(r16)
81120b90:	28005026 	beq	r5,zero,81120cd4 <_fseeko_r+0x420>
81120b94:	81c00f17 	ldw	r7,60(r16)
81120b98:	003fce06 	br	81120ad4 <__reset+0xfb100ad4>
81120b9c:	84c01317 	ldw	r19,76(r16)
81120ba0:	81400717 	ldw	r5,28(r16)
81120ba4:	000f883a 	mov	r7,zero
81120ba8:	04e7c83a 	sub	r19,zero,r19
81120bac:	9da6703a 	and	r19,r19,r22
81120bb0:	980d883a 	mov	r6,r19
81120bb4:	8809883a 	mov	r4,r17
81120bb8:	a03ee83a 	callr	r20
81120bbc:	00ffffc4 	movi	r3,-1
81120bc0:	10ff7726 	beq	r2,r3,811209a0 <__reset+0xfb1009a0>
81120bc4:	80800417 	ldw	r2,16(r16)
81120bc8:	81400c17 	ldw	r5,48(r16)
81120bcc:	80000115 	stw	zero,4(r16)
81120bd0:	80800015 	stw	r2,0(r16)
81120bd4:	28000526 	beq	r5,zero,81120bec <_fseeko_r+0x338>
81120bd8:	80801004 	addi	r2,r16,64
81120bdc:	28800226 	beq	r5,r2,81120be8 <_fseeko_r+0x334>
81120be0:	8809883a 	mov	r4,r17
81120be4:	112aac80 	call	8112aac8 <_free_r>
81120be8:	80000c15 	stw	zero,48(r16)
81120bec:	8080030b 	ldhu	r2,12(r16)
81120bf0:	b4e7c83a 	sub	r19,r22,r19
81120bf4:	10bff7cc 	andi	r2,r2,65503
81120bf8:	8080030d 	sth	r2,12(r16)
81120bfc:	98000b26 	beq	r19,zero,81120c2c <_fseeko_r+0x378>
81120c00:	800b883a 	mov	r5,r16
81120c04:	8809883a 	mov	r4,r17
81120c08:	1121e340 	call	81121e34 <__srefill_r>
81120c0c:	103f641e 	bne	r2,zero,811209a0 <__reset+0xfb1009a0>
81120c10:	80800117 	ldw	r2,4(r16)
81120c14:	14ff6236 	bltu	r2,r19,811209a0 <__reset+0xfb1009a0>
81120c18:	80c00017 	ldw	r3,0(r16)
81120c1c:	14c5c83a 	sub	r2,r2,r19
81120c20:	80800115 	stw	r2,4(r16)
81120c24:	1ce7883a 	add	r19,r3,r19
81120c28:	84c00015 	stw	r19,0(r16)
81120c2c:	01800204 	movi	r6,8
81120c30:	000b883a 	mov	r5,zero
81120c34:	81001704 	addi	r4,r16,92
81120c38:	11219b80 	call	811219b8 <memset>
81120c3c:	0027883a 	mov	r19,zero
81120c40:	003f3d06 	br	81120938 <__reset+0xfb100938>
81120c44:	80800417 	ldw	r2,16(r16)
81120c48:	003f8306 	br	81120a58 <__reset+0xfb100a58>
81120c4c:	81400717 	ldw	r5,28(r16)
81120c50:	900f883a 	mov	r7,r18
81120c54:	000d883a 	mov	r6,zero
81120c58:	8809883a 	mov	r4,r17
81120c5c:	a03ee83a 	callr	r20
81120c60:	1027883a 	mov	r19,r2
81120c64:	00bfffc4 	movi	r2,-1
81120c68:	98bf3226 	beq	r19,r2,81120934 <__reset+0xfb100934>
81120c6c:	8080030b 	ldhu	r2,12(r16)
81120c70:	003f7006 	br	81120a34 <__reset+0xfb100a34>
81120c74:	8140038f 	ldh	r5,14(r16)
81120c78:	283f4716 	blt	r5,zero,81120998 <__reset+0xfb100998>
81120c7c:	d80d883a 	mov	r6,sp
81120c80:	8809883a 	mov	r4,r17
81120c84:	1120d1c0 	call	81120d1c <_fstat_r>
81120c88:	1000041e 	bne	r2,zero,81120c9c <_fseeko_r+0x3e8>
81120c8c:	d8800117 	ldw	r2,4(sp)
81120c90:	00e00014 	movui	r3,32768
81120c94:	10bc000c 	andi	r2,r2,61440
81120c98:	10ff7c26 	beq	r2,r3,81120a8c <__reset+0xfb100a8c>
81120c9c:	8080030b 	ldhu	r2,12(r16)
81120ca0:	003f3d06 	br	81120998 <__reset+0xfb100998>
81120ca4:	800b883a 	mov	r5,r16
81120ca8:	8809883a 	mov	r4,r17
81120cac:	1120e900 	call	81120e90 <__smakebuf_r>
81120cb0:	003f3106 	br	81120978 <__reset+0xfb100978>
81120cb4:	81400717 	ldw	r5,28(r16)
81120cb8:	01c00044 	movi	r7,1
81120cbc:	000d883a 	mov	r6,zero
81120cc0:	8809883a 	mov	r4,r17
81120cc4:	a03ee83a 	callr	r20
81120cc8:	00ffffc4 	movi	r3,-1
81120ccc:	10ff7b1e 	bne	r2,r3,81120abc <__reset+0xfb100abc>
81120cd0:	003f3306 	br	811209a0 <__reset+0xfb1009a0>
81120cd4:	80c00017 	ldw	r3,0(r16)
81120cd8:	80800417 	ldw	r2,16(r16)
81120cdc:	000b883a 	mov	r5,zero
81120ce0:	1887c83a 	sub	r3,r3,r2
81120ce4:	98e7c83a 	sub	r19,r19,r3
81120ce8:	30c7883a 	add	r3,r6,r3
81120cec:	003f7f06 	br	81120aec <__reset+0xfb100aec>
81120cf0:	00800744 	movi	r2,29
81120cf4:	88800015 	stw	r2,0(r17)
81120cf8:	04ffffc4 	movi	r19,-1
81120cfc:	003f0e06 	br	81120938 <__reset+0xfb100938>

81120d00 <fseeko>:
81120d00:	00a04574 	movhi	r2,33045
81120d04:	10886904 	addi	r2,r2,8612
81120d08:	300f883a 	mov	r7,r6
81120d0c:	280d883a 	mov	r6,r5
81120d10:	200b883a 	mov	r5,r4
81120d14:	11000017 	ldw	r4,0(r2)
81120d18:	11208b41 	jmpi	811208b4 <_fseeko_r>

81120d1c <_fstat_r>:
81120d1c:	defffd04 	addi	sp,sp,-12
81120d20:	de00012e 	bgeu	sp,et,81120d28 <_fstat_r+0xc>
81120d24:	003b68fa 	trap	3
81120d28:	2805883a 	mov	r2,r5
81120d2c:	dc000015 	stw	r16,0(sp)
81120d30:	04204574 	movhi	r16,33045
81120d34:	dc400115 	stw	r17,4(sp)
81120d38:	8408db04 	addi	r16,r16,9068
81120d3c:	2023883a 	mov	r17,r4
81120d40:	300b883a 	mov	r5,r6
81120d44:	1009883a 	mov	r4,r2
81120d48:	dfc00215 	stw	ra,8(sp)
81120d4c:	80000015 	stw	zero,0(r16)
81120d50:	11357480 	call	81135748 <fstat>
81120d54:	00ffffc4 	movi	r3,-1
81120d58:	10c00526 	beq	r2,r3,81120d70 <_fstat_r+0x54>
81120d5c:	dfc00217 	ldw	ra,8(sp)
81120d60:	dc400117 	ldw	r17,4(sp)
81120d64:	dc000017 	ldw	r16,0(sp)
81120d68:	dec00304 	addi	sp,sp,12
81120d6c:	f800283a 	ret
81120d70:	80c00017 	ldw	r3,0(r16)
81120d74:	183ff926 	beq	r3,zero,81120d5c <__reset+0xfb100d5c>
81120d78:	88c00015 	stw	r3,0(r17)
81120d7c:	003ff706 	br	81120d5c <__reset+0xfb100d5c>

81120d80 <_fwrite_r>:
81120d80:	defff504 	addi	sp,sp,-44
81120d84:	de00012e 	bgeu	sp,et,81120d8c <_fwrite_r+0xc>
81120d88:	003b68fa 	trap	3
81120d8c:	dc800815 	stw	r18,32(sp)
81120d90:	39a5383a 	mul	r18,r7,r6
81120d94:	d8800304 	addi	r2,sp,12
81120d98:	d8800015 	stw	r2,0(sp)
81120d9c:	00800044 	movi	r2,1
81120da0:	dcc00915 	stw	r19,36(sp)
81120da4:	dc400715 	stw	r17,28(sp)
81120da8:	dc000615 	stw	r16,24(sp)
81120dac:	d9400315 	stw	r5,12(sp)
81120db0:	dfc00a15 	stw	ra,40(sp)
81120db4:	dc800415 	stw	r18,16(sp)
81120db8:	dc800215 	stw	r18,8(sp)
81120dbc:	d8800115 	stw	r2,4(sp)
81120dc0:	3027883a 	mov	r19,r6
81120dc4:	3821883a 	mov	r16,r7
81120dc8:	2023883a 	mov	r17,r4
81120dcc:	d9400b17 	ldw	r5,44(sp)
81120dd0:	20000226 	beq	r4,zero,81120ddc <_fwrite_r+0x5c>
81120dd4:	20800e17 	ldw	r2,56(r4)
81120dd8:	10001a26 	beq	r2,zero,81120e44 <_fwrite_r+0xc4>
81120ddc:	2880030b 	ldhu	r2,12(r5)
81120de0:	10c8000c 	andi	r3,r2,8192
81120de4:	1800061e 	bne	r3,zero,81120e00 <_fwrite_r+0x80>
81120de8:	29001917 	ldw	r4,100(r5)
81120dec:	00f7ffc4 	movi	r3,-8193
81120df0:	10880014 	ori	r2,r2,8192
81120df4:	20c6703a 	and	r3,r4,r3
81120df8:	2880030d 	sth	r2,12(r5)
81120dfc:	28c01915 	stw	r3,100(r5)
81120e00:	d80d883a 	mov	r6,sp
81120e04:	8809883a 	mov	r4,r17
81120e08:	112ade00 	call	8112ade0 <__sfvwrite_r>
81120e0c:	10000b26 	beq	r2,zero,81120e3c <_fwrite_r+0xbc>
81120e10:	d9000217 	ldw	r4,8(sp)
81120e14:	980b883a 	mov	r5,r19
81120e18:	9109c83a 	sub	r4,r18,r4
81120e1c:	1133dd40 	call	81133dd4 <__udivsi3>
81120e20:	dfc00a17 	ldw	ra,40(sp)
81120e24:	dcc00917 	ldw	r19,36(sp)
81120e28:	dc800817 	ldw	r18,32(sp)
81120e2c:	dc400717 	ldw	r17,28(sp)
81120e30:	dc000617 	ldw	r16,24(sp)
81120e34:	dec00b04 	addi	sp,sp,44
81120e38:	f800283a 	ret
81120e3c:	8005883a 	mov	r2,r16
81120e40:	003ff706 	br	81120e20 <__reset+0xfb100e20>
81120e44:	d9400515 	stw	r5,20(sp)
81120e48:	112a6300 	call	8112a630 <__sinit>
81120e4c:	d9400517 	ldw	r5,20(sp)
81120e50:	003fe206 	br	81120ddc <__reset+0xfb100ddc>

81120e54 <fwrite>:
81120e54:	defffe04 	addi	sp,sp,-8
81120e58:	00a04574 	movhi	r2,33045
81120e5c:	de00012e 	bgeu	sp,et,81120e64 <fwrite+0x10>
81120e60:	003b68fa 	trap	3
81120e64:	10886904 	addi	r2,r2,8612
81120e68:	d9c00015 	stw	r7,0(sp)
81120e6c:	300f883a 	mov	r7,r6
81120e70:	280d883a 	mov	r6,r5
81120e74:	200b883a 	mov	r5,r4
81120e78:	11000017 	ldw	r4,0(r2)
81120e7c:	dfc00115 	stw	ra,4(sp)
81120e80:	1120d800 	call	81120d80 <_fwrite_r>
81120e84:	dfc00117 	ldw	ra,4(sp)
81120e88:	dec00204 	addi	sp,sp,8
81120e8c:	f800283a 	ret

81120e90 <__smakebuf_r>:
81120e90:	2880030b 	ldhu	r2,12(r5)
81120e94:	10c0008c 	andi	r3,r2,2
81120e98:	1800431e 	bne	r3,zero,81120fa8 <__smakebuf_r+0x118>
81120e9c:	deffec04 	addi	sp,sp,-80
81120ea0:	de00012e 	bgeu	sp,et,81120ea8 <__smakebuf_r+0x18>
81120ea4:	003b68fa 	trap	3
81120ea8:	dc000f15 	stw	r16,60(sp)
81120eac:	2821883a 	mov	r16,r5
81120eb0:	2940038f 	ldh	r5,14(r5)
81120eb4:	dc401015 	stw	r17,64(sp)
81120eb8:	dfc01315 	stw	ra,76(sp)
81120ebc:	dcc01215 	stw	r19,72(sp)
81120ec0:	dc801115 	stw	r18,68(sp)
81120ec4:	2023883a 	mov	r17,r4
81120ec8:	28001c16 	blt	r5,zero,81120f3c <__smakebuf_r+0xac>
81120ecc:	d80d883a 	mov	r6,sp
81120ed0:	1120d1c0 	call	81120d1c <_fstat_r>
81120ed4:	10001816 	blt	r2,zero,81120f38 <__smakebuf_r+0xa8>
81120ed8:	d8800117 	ldw	r2,4(sp)
81120edc:	00e00014 	movui	r3,32768
81120ee0:	10bc000c 	andi	r2,r2,61440
81120ee4:	14c80020 	cmpeqi	r19,r2,8192
81120ee8:	10c03726 	beq	r2,r3,81120fc8 <__smakebuf_r+0x138>
81120eec:	80c0030b 	ldhu	r3,12(r16)
81120ef0:	18c20014 	ori	r3,r3,2048
81120ef4:	80c0030d 	sth	r3,12(r16)
81120ef8:	00c80004 	movi	r3,8192
81120efc:	10c0521e 	bne	r2,r3,81121048 <__smakebuf_r+0x1b8>
81120f00:	8140038f 	ldh	r5,14(r16)
81120f04:	8809883a 	mov	r4,r17
81120f08:	112b43c0 	call	8112b43c <_isatty_r>
81120f0c:	10004c26 	beq	r2,zero,81121040 <__smakebuf_r+0x1b0>
81120f10:	8080030b 	ldhu	r2,12(r16)
81120f14:	80c010c4 	addi	r3,r16,67
81120f18:	80c00015 	stw	r3,0(r16)
81120f1c:	10800054 	ori	r2,r2,1
81120f20:	8080030d 	sth	r2,12(r16)
81120f24:	00800044 	movi	r2,1
81120f28:	80c00415 	stw	r3,16(r16)
81120f2c:	80800515 	stw	r2,20(r16)
81120f30:	04810004 	movi	r18,1024
81120f34:	00000706 	br	81120f54 <__smakebuf_r+0xc4>
81120f38:	8080030b 	ldhu	r2,12(r16)
81120f3c:	10c0200c 	andi	r3,r2,128
81120f40:	18001f1e 	bne	r3,zero,81120fc0 <__smakebuf_r+0x130>
81120f44:	04810004 	movi	r18,1024
81120f48:	10820014 	ori	r2,r2,2048
81120f4c:	8080030d 	sth	r2,12(r16)
81120f50:	0027883a 	mov	r19,zero
81120f54:	900b883a 	mov	r5,r18
81120f58:	8809883a 	mov	r4,r17
81120f5c:	11210540 	call	81121054 <_malloc_r>
81120f60:	10002c26 	beq	r2,zero,81121014 <__smakebuf_r+0x184>
81120f64:	80c0030b 	ldhu	r3,12(r16)
81120f68:	012044f4 	movhi	r4,33043
81120f6c:	2128b404 	addi	r4,r4,-23856
81120f70:	89000f15 	stw	r4,60(r17)
81120f74:	18c02014 	ori	r3,r3,128
81120f78:	80c0030d 	sth	r3,12(r16)
81120f7c:	80800015 	stw	r2,0(r16)
81120f80:	80800415 	stw	r2,16(r16)
81120f84:	84800515 	stw	r18,20(r16)
81120f88:	98001a1e 	bne	r19,zero,81120ff4 <__smakebuf_r+0x164>
81120f8c:	dfc01317 	ldw	ra,76(sp)
81120f90:	dcc01217 	ldw	r19,72(sp)
81120f94:	dc801117 	ldw	r18,68(sp)
81120f98:	dc401017 	ldw	r17,64(sp)
81120f9c:	dc000f17 	ldw	r16,60(sp)
81120fa0:	dec01404 	addi	sp,sp,80
81120fa4:	f800283a 	ret
81120fa8:	288010c4 	addi	r2,r5,67
81120fac:	28800015 	stw	r2,0(r5)
81120fb0:	28800415 	stw	r2,16(r5)
81120fb4:	00800044 	movi	r2,1
81120fb8:	28800515 	stw	r2,20(r5)
81120fbc:	f800283a 	ret
81120fc0:	04801004 	movi	r18,64
81120fc4:	003fe006 	br	81120f48 <__reset+0xfb100f48>
81120fc8:	81000a17 	ldw	r4,40(r16)
81120fcc:	00e044b4 	movhi	r3,33042
81120fd0:	18c8a904 	addi	r3,r3,8868
81120fd4:	20ffc51e 	bne	r4,r3,81120eec <__reset+0xfb100eec>
81120fd8:	8080030b 	ldhu	r2,12(r16)
81120fdc:	04810004 	movi	r18,1024
81120fe0:	84801315 	stw	r18,76(r16)
81120fe4:	1484b03a 	or	r2,r2,r18
81120fe8:	8080030d 	sth	r2,12(r16)
81120fec:	0027883a 	mov	r19,zero
81120ff0:	003fd806 	br	81120f54 <__reset+0xfb100f54>
81120ff4:	8140038f 	ldh	r5,14(r16)
81120ff8:	8809883a 	mov	r4,r17
81120ffc:	112b43c0 	call	8112b43c <_isatty_r>
81121000:	103fe226 	beq	r2,zero,81120f8c <__reset+0xfb100f8c>
81121004:	8080030b 	ldhu	r2,12(r16)
81121008:	10800054 	ori	r2,r2,1
8112100c:	8080030d 	sth	r2,12(r16)
81121010:	003fde06 	br	81120f8c <__reset+0xfb100f8c>
81121014:	8080030b 	ldhu	r2,12(r16)
81121018:	10c0800c 	andi	r3,r2,512
8112101c:	183fdb1e 	bne	r3,zero,81120f8c <__reset+0xfb100f8c>
81121020:	10800094 	ori	r2,r2,2
81121024:	80c010c4 	addi	r3,r16,67
81121028:	8080030d 	sth	r2,12(r16)
8112102c:	00800044 	movi	r2,1
81121030:	80c00015 	stw	r3,0(r16)
81121034:	80c00415 	stw	r3,16(r16)
81121038:	80800515 	stw	r2,20(r16)
8112103c:	003fd306 	br	81120f8c <__reset+0xfb100f8c>
81121040:	04810004 	movi	r18,1024
81121044:	003fc306 	br	81120f54 <__reset+0xfb100f54>
81121048:	0027883a 	mov	r19,zero
8112104c:	04810004 	movi	r18,1024
81121050:	003fc006 	br	81120f54 <__reset+0xfb100f54>

81121054 <_malloc_r>:
81121054:	defff504 	addi	sp,sp,-44
81121058:	de00012e 	bgeu	sp,et,81121060 <_malloc_r+0xc>
8112105c:	003b68fa 	trap	3
81121060:	288002c4 	addi	r2,r5,11
81121064:	dc800315 	stw	r18,12(sp)
81121068:	dfc00a15 	stw	ra,40(sp)
8112106c:	df000915 	stw	fp,36(sp)
81121070:	ddc00815 	stw	r23,32(sp)
81121074:	dd800715 	stw	r22,28(sp)
81121078:	dd400615 	stw	r21,24(sp)
8112107c:	dd000515 	stw	r20,20(sp)
81121080:	dcc00415 	stw	r19,16(sp)
81121084:	dc400215 	stw	r17,8(sp)
81121088:	dc000115 	stw	r16,4(sp)
8112108c:	00c00584 	movi	r3,22
81121090:	2025883a 	mov	r18,r4
81121094:	18807f2e 	bgeu	r3,r2,81121294 <_malloc_r+0x240>
81121098:	047ffe04 	movi	r17,-8
8112109c:	1462703a 	and	r17,r2,r17
811210a0:	8800a316 	blt	r17,zero,81121330 <_malloc_r+0x2dc>
811210a4:	8940a236 	bltu	r17,r5,81121330 <_malloc_r+0x2dc>
811210a8:	11372900 	call	81137290 <__malloc_lock>
811210ac:	00807dc4 	movi	r2,503
811210b0:	1441e92e 	bgeu	r2,r17,81121858 <_malloc_r+0x804>
811210b4:	8804d27a 	srli	r2,r17,9
811210b8:	1000a126 	beq	r2,zero,81121340 <_malloc_r+0x2ec>
811210bc:	00c00104 	movi	r3,4
811210c0:	18811e36 	bltu	r3,r2,8112153c <_malloc_r+0x4e8>
811210c4:	8804d1ba 	srli	r2,r17,6
811210c8:	12000e44 	addi	r8,r2,57
811210cc:	11c00e04 	addi	r7,r2,56
811210d0:	4209883a 	add	r4,r8,r8
811210d4:	04e04574 	movhi	r19,33045
811210d8:	2109883a 	add	r4,r4,r4
811210dc:	9cc22704 	addi	r19,r19,2204
811210e0:	2109883a 	add	r4,r4,r4
811210e4:	9909883a 	add	r4,r19,r4
811210e8:	24000117 	ldw	r16,4(r4)
811210ec:	213ffe04 	addi	r4,r4,-8
811210f0:	24009726 	beq	r4,r16,81121350 <_malloc_r+0x2fc>
811210f4:	80800117 	ldw	r2,4(r16)
811210f8:	01bfff04 	movi	r6,-4
811210fc:	014003c4 	movi	r5,15
81121100:	1184703a 	and	r2,r2,r6
81121104:	1447c83a 	sub	r3,r2,r17
81121108:	28c00716 	blt	r5,r3,81121128 <_malloc_r+0xd4>
8112110c:	1800920e 	bge	r3,zero,81121358 <_malloc_r+0x304>
81121110:	84000317 	ldw	r16,12(r16)
81121114:	24008e26 	beq	r4,r16,81121350 <_malloc_r+0x2fc>
81121118:	80800117 	ldw	r2,4(r16)
8112111c:	1184703a 	and	r2,r2,r6
81121120:	1447c83a 	sub	r3,r2,r17
81121124:	28fff90e 	bge	r5,r3,8112110c <__reset+0xfb10110c>
81121128:	3809883a 	mov	r4,r7
8112112c:	01a04574 	movhi	r6,33045
81121130:	9c000417 	ldw	r16,16(r19)
81121134:	31822704 	addi	r6,r6,2204
81121138:	32000204 	addi	r8,r6,8
8112113c:	82013426 	beq	r16,r8,81121610 <_malloc_r+0x5bc>
81121140:	80c00117 	ldw	r3,4(r16)
81121144:	00bfff04 	movi	r2,-4
81121148:	188e703a 	and	r7,r3,r2
8112114c:	3c45c83a 	sub	r2,r7,r17
81121150:	00c003c4 	movi	r3,15
81121154:	18811f16 	blt	r3,r2,811215d4 <_malloc_r+0x580>
81121158:	32000515 	stw	r8,20(r6)
8112115c:	32000415 	stw	r8,16(r6)
81121160:	10007f0e 	bge	r2,zero,81121360 <_malloc_r+0x30c>
81121164:	00807fc4 	movi	r2,511
81121168:	11c0fd36 	bltu	r2,r7,81121560 <_malloc_r+0x50c>
8112116c:	3806d0fa 	srli	r3,r7,3
81121170:	01c00044 	movi	r7,1
81121174:	30800117 	ldw	r2,4(r6)
81121178:	19400044 	addi	r5,r3,1
8112117c:	294b883a 	add	r5,r5,r5
81121180:	1807d0ba 	srai	r3,r3,2
81121184:	294b883a 	add	r5,r5,r5
81121188:	294b883a 	add	r5,r5,r5
8112118c:	298b883a 	add	r5,r5,r6
81121190:	38c6983a 	sll	r3,r7,r3
81121194:	29c00017 	ldw	r7,0(r5)
81121198:	2a7ffe04 	addi	r9,r5,-8
8112119c:	1886b03a 	or	r3,r3,r2
811211a0:	82400315 	stw	r9,12(r16)
811211a4:	81c00215 	stw	r7,8(r16)
811211a8:	30c00115 	stw	r3,4(r6)
811211ac:	2c000015 	stw	r16,0(r5)
811211b0:	3c000315 	stw	r16,12(r7)
811211b4:	2005d0ba 	srai	r2,r4,2
811211b8:	01400044 	movi	r5,1
811211bc:	288a983a 	sll	r5,r5,r2
811211c0:	19406f36 	bltu	r3,r5,81121380 <_malloc_r+0x32c>
811211c4:	28c4703a 	and	r2,r5,r3
811211c8:	10000a1e 	bne	r2,zero,811211f4 <_malloc_r+0x1a0>
811211cc:	00bfff04 	movi	r2,-4
811211d0:	294b883a 	add	r5,r5,r5
811211d4:	2088703a 	and	r4,r4,r2
811211d8:	28c4703a 	and	r2,r5,r3
811211dc:	21000104 	addi	r4,r4,4
811211e0:	1000041e 	bne	r2,zero,811211f4 <_malloc_r+0x1a0>
811211e4:	294b883a 	add	r5,r5,r5
811211e8:	28c4703a 	and	r2,r5,r3
811211ec:	21000104 	addi	r4,r4,4
811211f0:	103ffc26 	beq	r2,zero,811211e4 <__reset+0xfb1011e4>
811211f4:	02bfff04 	movi	r10,-4
811211f8:	024003c4 	movi	r9,15
811211fc:	21800044 	addi	r6,r4,1
81121200:	318d883a 	add	r6,r6,r6
81121204:	318d883a 	add	r6,r6,r6
81121208:	318d883a 	add	r6,r6,r6
8112120c:	998d883a 	add	r6,r19,r6
81121210:	333ffe04 	addi	r12,r6,-8
81121214:	2017883a 	mov	r11,r4
81121218:	31800104 	addi	r6,r6,4
8112121c:	34000017 	ldw	r16,0(r6)
81121220:	31fffd04 	addi	r7,r6,-12
81121224:	81c0041e 	bne	r16,r7,81121238 <_malloc_r+0x1e4>
81121228:	0000fb06 	br	81121618 <_malloc_r+0x5c4>
8112122c:	1801030e 	bge	r3,zero,8112163c <_malloc_r+0x5e8>
81121230:	84000317 	ldw	r16,12(r16)
81121234:	81c0f826 	beq	r16,r7,81121618 <_malloc_r+0x5c4>
81121238:	80800117 	ldw	r2,4(r16)
8112123c:	1284703a 	and	r2,r2,r10
81121240:	1447c83a 	sub	r3,r2,r17
81121244:	48fff90e 	bge	r9,r3,8112122c <__reset+0xfb10122c>
81121248:	80800317 	ldw	r2,12(r16)
8112124c:	81000217 	ldw	r4,8(r16)
81121250:	89400054 	ori	r5,r17,1
81121254:	81400115 	stw	r5,4(r16)
81121258:	20800315 	stw	r2,12(r4)
8112125c:	11000215 	stw	r4,8(r2)
81121260:	8463883a 	add	r17,r16,r17
81121264:	9c400515 	stw	r17,20(r19)
81121268:	9c400415 	stw	r17,16(r19)
8112126c:	18800054 	ori	r2,r3,1
81121270:	88800115 	stw	r2,4(r17)
81121274:	8a000315 	stw	r8,12(r17)
81121278:	8a000215 	stw	r8,8(r17)
8112127c:	88e3883a 	add	r17,r17,r3
81121280:	88c00015 	stw	r3,0(r17)
81121284:	9009883a 	mov	r4,r18
81121288:	11373b80 	call	811373b8 <__malloc_unlock>
8112128c:	80800204 	addi	r2,r16,8
81121290:	00001b06 	br	81121300 <_malloc_r+0x2ac>
81121294:	04400404 	movi	r17,16
81121298:	89402536 	bltu	r17,r5,81121330 <_malloc_r+0x2dc>
8112129c:	11372900 	call	81137290 <__malloc_lock>
811212a0:	00800184 	movi	r2,6
811212a4:	01000084 	movi	r4,2
811212a8:	04e04574 	movhi	r19,33045
811212ac:	1085883a 	add	r2,r2,r2
811212b0:	9cc22704 	addi	r19,r19,2204
811212b4:	1085883a 	add	r2,r2,r2
811212b8:	9885883a 	add	r2,r19,r2
811212bc:	14000117 	ldw	r16,4(r2)
811212c0:	10fffe04 	addi	r3,r2,-8
811212c4:	80c0d926 	beq	r16,r3,8112162c <_malloc_r+0x5d8>
811212c8:	80c00117 	ldw	r3,4(r16)
811212cc:	81000317 	ldw	r4,12(r16)
811212d0:	00bfff04 	movi	r2,-4
811212d4:	1884703a 	and	r2,r3,r2
811212d8:	81400217 	ldw	r5,8(r16)
811212dc:	8085883a 	add	r2,r16,r2
811212e0:	10c00117 	ldw	r3,4(r2)
811212e4:	29000315 	stw	r4,12(r5)
811212e8:	21400215 	stw	r5,8(r4)
811212ec:	18c00054 	ori	r3,r3,1
811212f0:	10c00115 	stw	r3,4(r2)
811212f4:	9009883a 	mov	r4,r18
811212f8:	11373b80 	call	811373b8 <__malloc_unlock>
811212fc:	80800204 	addi	r2,r16,8
81121300:	dfc00a17 	ldw	ra,40(sp)
81121304:	df000917 	ldw	fp,36(sp)
81121308:	ddc00817 	ldw	r23,32(sp)
8112130c:	dd800717 	ldw	r22,28(sp)
81121310:	dd400617 	ldw	r21,24(sp)
81121314:	dd000517 	ldw	r20,20(sp)
81121318:	dcc00417 	ldw	r19,16(sp)
8112131c:	dc800317 	ldw	r18,12(sp)
81121320:	dc400217 	ldw	r17,8(sp)
81121324:	dc000117 	ldw	r16,4(sp)
81121328:	dec00b04 	addi	sp,sp,44
8112132c:	f800283a 	ret
81121330:	00800304 	movi	r2,12
81121334:	90800015 	stw	r2,0(r18)
81121338:	0005883a 	mov	r2,zero
8112133c:	003ff006 	br	81121300 <__reset+0xfb101300>
81121340:	01002004 	movi	r4,128
81121344:	02001004 	movi	r8,64
81121348:	01c00fc4 	movi	r7,63
8112134c:	003f6106 	br	811210d4 <__reset+0xfb1010d4>
81121350:	4009883a 	mov	r4,r8
81121354:	003f7506 	br	8112112c <__reset+0xfb10112c>
81121358:	81000317 	ldw	r4,12(r16)
8112135c:	003fde06 	br	811212d8 <__reset+0xfb1012d8>
81121360:	81c5883a 	add	r2,r16,r7
81121364:	11400117 	ldw	r5,4(r2)
81121368:	9009883a 	mov	r4,r18
8112136c:	29400054 	ori	r5,r5,1
81121370:	11400115 	stw	r5,4(r2)
81121374:	11373b80 	call	811373b8 <__malloc_unlock>
81121378:	80800204 	addi	r2,r16,8
8112137c:	003fe006 	br	81121300 <__reset+0xfb101300>
81121380:	9c000217 	ldw	r16,8(r19)
81121384:	00bfff04 	movi	r2,-4
81121388:	85800117 	ldw	r22,4(r16)
8112138c:	b0ac703a 	and	r22,r22,r2
81121390:	b4400336 	bltu	r22,r17,811213a0 <_malloc_r+0x34c>
81121394:	b445c83a 	sub	r2,r22,r17
81121398:	00c003c4 	movi	r3,15
8112139c:	18805d16 	blt	r3,r2,81121514 <_malloc_r+0x4c0>
811213a0:	05e04574 	movhi	r23,33045
811213a4:	00a04574 	movhi	r2,33045
811213a8:	1088de04 	addi	r2,r2,9080
811213ac:	bdc86a04 	addi	r23,r23,8616
811213b0:	15400017 	ldw	r21,0(r2)
811213b4:	b8c00017 	ldw	r3,0(r23)
811213b8:	00bfffc4 	movi	r2,-1
811213bc:	858d883a 	add	r6,r16,r22
811213c0:	8d6b883a 	add	r21,r17,r21
811213c4:	1880ea26 	beq	r3,r2,81121770 <_malloc_r+0x71c>
811213c8:	ad4403c4 	addi	r21,r21,4111
811213cc:	00bc0004 	movi	r2,-4096
811213d0:	a8aa703a 	and	r21,r21,r2
811213d4:	a80b883a 	mov	r5,r21
811213d8:	9009883a 	mov	r4,r18
811213dc:	d9800015 	stw	r6,0(sp)
811213e0:	11220100 	call	81122010 <_sbrk_r>
811213e4:	1029883a 	mov	r20,r2
811213e8:	00bfffc4 	movi	r2,-1
811213ec:	d9800017 	ldw	r6,0(sp)
811213f0:	a080e826 	beq	r20,r2,81121794 <_malloc_r+0x740>
811213f4:	a180a636 	bltu	r20,r6,81121690 <_malloc_r+0x63c>
811213f8:	07204574 	movhi	fp,33045
811213fc:	e7096b04 	addi	fp,fp,9644
81121400:	e0800017 	ldw	r2,0(fp)
81121404:	a887883a 	add	r3,r21,r2
81121408:	e0c00015 	stw	r3,0(fp)
8112140c:	3500e626 	beq	r6,r20,811217a8 <_malloc_r+0x754>
81121410:	b9000017 	ldw	r4,0(r23)
81121414:	00bfffc4 	movi	r2,-1
81121418:	2080ee26 	beq	r4,r2,811217d4 <_malloc_r+0x780>
8112141c:	a185c83a 	sub	r2,r20,r6
81121420:	10c5883a 	add	r2,r2,r3
81121424:	e0800015 	stw	r2,0(fp)
81121428:	a0c001cc 	andi	r3,r20,7
8112142c:	1800bc26 	beq	r3,zero,81121720 <_malloc_r+0x6cc>
81121430:	a0e9c83a 	sub	r20,r20,r3
81121434:	00840204 	movi	r2,4104
81121438:	a5000204 	addi	r20,r20,8
8112143c:	10c7c83a 	sub	r3,r2,r3
81121440:	a545883a 	add	r2,r20,r21
81121444:	1083ffcc 	andi	r2,r2,4095
81121448:	18abc83a 	sub	r21,r3,r2
8112144c:	a80b883a 	mov	r5,r21
81121450:	9009883a 	mov	r4,r18
81121454:	11220100 	call	81122010 <_sbrk_r>
81121458:	00ffffc4 	movi	r3,-1
8112145c:	10c0e126 	beq	r2,r3,811217e4 <_malloc_r+0x790>
81121460:	1505c83a 	sub	r2,r2,r20
81121464:	1545883a 	add	r2,r2,r21
81121468:	10800054 	ori	r2,r2,1
8112146c:	e0c00017 	ldw	r3,0(fp)
81121470:	9d000215 	stw	r20,8(r19)
81121474:	a0800115 	stw	r2,4(r20)
81121478:	a8c7883a 	add	r3,r21,r3
8112147c:	e0c00015 	stw	r3,0(fp)
81121480:	84c00e26 	beq	r16,r19,811214bc <_malloc_r+0x468>
81121484:	018003c4 	movi	r6,15
81121488:	3580a72e 	bgeu	r6,r22,81121728 <_malloc_r+0x6d4>
8112148c:	81400117 	ldw	r5,4(r16)
81121490:	013ffe04 	movi	r4,-8
81121494:	b0bffd04 	addi	r2,r22,-12
81121498:	1104703a 	and	r2,r2,r4
8112149c:	2900004c 	andi	r4,r5,1
811214a0:	2088b03a 	or	r4,r4,r2
811214a4:	81000115 	stw	r4,4(r16)
811214a8:	01400144 	movi	r5,5
811214ac:	8089883a 	add	r4,r16,r2
811214b0:	21400115 	stw	r5,4(r4)
811214b4:	21400215 	stw	r5,8(r4)
811214b8:	3080cd36 	bltu	r6,r2,811217f0 <_malloc_r+0x79c>
811214bc:	00a04574 	movhi	r2,33045
811214c0:	1088dd04 	addi	r2,r2,9076
811214c4:	11000017 	ldw	r4,0(r2)
811214c8:	20c0012e 	bgeu	r4,r3,811214d0 <_malloc_r+0x47c>
811214cc:	10c00015 	stw	r3,0(r2)
811214d0:	00a04574 	movhi	r2,33045
811214d4:	1088dc04 	addi	r2,r2,9072
811214d8:	11000017 	ldw	r4,0(r2)
811214dc:	9c000217 	ldw	r16,8(r19)
811214e0:	20c0012e 	bgeu	r4,r3,811214e8 <_malloc_r+0x494>
811214e4:	10c00015 	stw	r3,0(r2)
811214e8:	80c00117 	ldw	r3,4(r16)
811214ec:	00bfff04 	movi	r2,-4
811214f0:	1886703a 	and	r3,r3,r2
811214f4:	1c45c83a 	sub	r2,r3,r17
811214f8:	1c400236 	bltu	r3,r17,81121504 <_malloc_r+0x4b0>
811214fc:	00c003c4 	movi	r3,15
81121500:	18800416 	blt	r3,r2,81121514 <_malloc_r+0x4c0>
81121504:	9009883a 	mov	r4,r18
81121508:	11373b80 	call	811373b8 <__malloc_unlock>
8112150c:	0005883a 	mov	r2,zero
81121510:	003f7b06 	br	81121300 <__reset+0xfb101300>
81121514:	88c00054 	ori	r3,r17,1
81121518:	80c00115 	stw	r3,4(r16)
8112151c:	8463883a 	add	r17,r16,r17
81121520:	10800054 	ori	r2,r2,1
81121524:	9c400215 	stw	r17,8(r19)
81121528:	88800115 	stw	r2,4(r17)
8112152c:	9009883a 	mov	r4,r18
81121530:	11373b80 	call	811373b8 <__malloc_unlock>
81121534:	80800204 	addi	r2,r16,8
81121538:	003f7106 	br	81121300 <__reset+0xfb101300>
8112153c:	00c00504 	movi	r3,20
81121540:	18804a2e 	bgeu	r3,r2,8112166c <_malloc_r+0x618>
81121544:	00c01504 	movi	r3,84
81121548:	18806e36 	bltu	r3,r2,81121704 <_malloc_r+0x6b0>
8112154c:	8804d33a 	srli	r2,r17,12
81121550:	12001bc4 	addi	r8,r2,111
81121554:	11c01b84 	addi	r7,r2,110
81121558:	4209883a 	add	r4,r8,r8
8112155c:	003edd06 	br	811210d4 <__reset+0xfb1010d4>
81121560:	3804d27a 	srli	r2,r7,9
81121564:	00c00104 	movi	r3,4
81121568:	1880442e 	bgeu	r3,r2,8112167c <_malloc_r+0x628>
8112156c:	00c00504 	movi	r3,20
81121570:	18808136 	bltu	r3,r2,81121778 <_malloc_r+0x724>
81121574:	11401704 	addi	r5,r2,92
81121578:	10c016c4 	addi	r3,r2,91
8112157c:	294b883a 	add	r5,r5,r5
81121580:	294b883a 	add	r5,r5,r5
81121584:	294b883a 	add	r5,r5,r5
81121588:	994b883a 	add	r5,r19,r5
8112158c:	28800017 	ldw	r2,0(r5)
81121590:	01a04574 	movhi	r6,33045
81121594:	297ffe04 	addi	r5,r5,-8
81121598:	31822704 	addi	r6,r6,2204
8112159c:	28806526 	beq	r5,r2,81121734 <_malloc_r+0x6e0>
811215a0:	01bfff04 	movi	r6,-4
811215a4:	10c00117 	ldw	r3,4(r2)
811215a8:	1986703a 	and	r3,r3,r6
811215ac:	38c0022e 	bgeu	r7,r3,811215b8 <_malloc_r+0x564>
811215b0:	10800217 	ldw	r2,8(r2)
811215b4:	28bffb1e 	bne	r5,r2,811215a4 <__reset+0xfb1015a4>
811215b8:	11400317 	ldw	r5,12(r2)
811215bc:	98c00117 	ldw	r3,4(r19)
811215c0:	81400315 	stw	r5,12(r16)
811215c4:	80800215 	stw	r2,8(r16)
811215c8:	2c000215 	stw	r16,8(r5)
811215cc:	14000315 	stw	r16,12(r2)
811215d0:	003ef806 	br	811211b4 <__reset+0xfb1011b4>
811215d4:	88c00054 	ori	r3,r17,1
811215d8:	80c00115 	stw	r3,4(r16)
811215dc:	8463883a 	add	r17,r16,r17
811215e0:	34400515 	stw	r17,20(r6)
811215e4:	34400415 	stw	r17,16(r6)
811215e8:	10c00054 	ori	r3,r2,1
811215ec:	8a000315 	stw	r8,12(r17)
811215f0:	8a000215 	stw	r8,8(r17)
811215f4:	88c00115 	stw	r3,4(r17)
811215f8:	88a3883a 	add	r17,r17,r2
811215fc:	88800015 	stw	r2,0(r17)
81121600:	9009883a 	mov	r4,r18
81121604:	11373b80 	call	811373b8 <__malloc_unlock>
81121608:	80800204 	addi	r2,r16,8
8112160c:	003f3c06 	br	81121300 <__reset+0xfb101300>
81121610:	30c00117 	ldw	r3,4(r6)
81121614:	003ee706 	br	811211b4 <__reset+0xfb1011b4>
81121618:	5ac00044 	addi	r11,r11,1
8112161c:	588000cc 	andi	r2,r11,3
81121620:	31800204 	addi	r6,r6,8
81121624:	103efd1e 	bne	r2,zero,8112121c <__reset+0xfb10121c>
81121628:	00002406 	br	811216bc <_malloc_r+0x668>
8112162c:	14000317 	ldw	r16,12(r2)
81121630:	143f251e 	bne	r2,r16,811212c8 <__reset+0xfb1012c8>
81121634:	21000084 	addi	r4,r4,2
81121638:	003ebc06 	br	8112112c <__reset+0xfb10112c>
8112163c:	8085883a 	add	r2,r16,r2
81121640:	10c00117 	ldw	r3,4(r2)
81121644:	81000317 	ldw	r4,12(r16)
81121648:	81400217 	ldw	r5,8(r16)
8112164c:	18c00054 	ori	r3,r3,1
81121650:	10c00115 	stw	r3,4(r2)
81121654:	29000315 	stw	r4,12(r5)
81121658:	21400215 	stw	r5,8(r4)
8112165c:	9009883a 	mov	r4,r18
81121660:	11373b80 	call	811373b8 <__malloc_unlock>
81121664:	80800204 	addi	r2,r16,8
81121668:	003f2506 	br	81121300 <__reset+0xfb101300>
8112166c:	12001704 	addi	r8,r2,92
81121670:	11c016c4 	addi	r7,r2,91
81121674:	4209883a 	add	r4,r8,r8
81121678:	003e9606 	br	811210d4 <__reset+0xfb1010d4>
8112167c:	3804d1ba 	srli	r2,r7,6
81121680:	11400e44 	addi	r5,r2,57
81121684:	10c00e04 	addi	r3,r2,56
81121688:	294b883a 	add	r5,r5,r5
8112168c:	003fbc06 	br	81121580 <__reset+0xfb101580>
81121690:	84ff5926 	beq	r16,r19,811213f8 <__reset+0xfb1013f8>
81121694:	00a04574 	movhi	r2,33045
81121698:	10822704 	addi	r2,r2,2204
8112169c:	14000217 	ldw	r16,8(r2)
811216a0:	00bfff04 	movi	r2,-4
811216a4:	80c00117 	ldw	r3,4(r16)
811216a8:	1886703a 	and	r3,r3,r2
811216ac:	003f9106 	br	811214f4 <__reset+0xfb1014f4>
811216b0:	60800217 	ldw	r2,8(r12)
811216b4:	213fffc4 	addi	r4,r4,-1
811216b8:	1300651e 	bne	r2,r12,81121850 <_malloc_r+0x7fc>
811216bc:	208000cc 	andi	r2,r4,3
811216c0:	633ffe04 	addi	r12,r12,-8
811216c4:	103ffa1e 	bne	r2,zero,811216b0 <__reset+0xfb1016b0>
811216c8:	98800117 	ldw	r2,4(r19)
811216cc:	0146303a 	nor	r3,zero,r5
811216d0:	1884703a 	and	r2,r3,r2
811216d4:	98800115 	stw	r2,4(r19)
811216d8:	294b883a 	add	r5,r5,r5
811216dc:	117f2836 	bltu	r2,r5,81121380 <__reset+0xfb101380>
811216e0:	283f2726 	beq	r5,zero,81121380 <__reset+0xfb101380>
811216e4:	2886703a 	and	r3,r5,r2
811216e8:	5809883a 	mov	r4,r11
811216ec:	183ec31e 	bne	r3,zero,811211fc <__reset+0xfb1011fc>
811216f0:	294b883a 	add	r5,r5,r5
811216f4:	2886703a 	and	r3,r5,r2
811216f8:	21000104 	addi	r4,r4,4
811216fc:	183ffc26 	beq	r3,zero,811216f0 <__reset+0xfb1016f0>
81121700:	003ebe06 	br	811211fc <__reset+0xfb1011fc>
81121704:	00c05504 	movi	r3,340
81121708:	18801236 	bltu	r3,r2,81121754 <_malloc_r+0x700>
8112170c:	8804d3fa 	srli	r2,r17,15
81121710:	12001e04 	addi	r8,r2,120
81121714:	11c01dc4 	addi	r7,r2,119
81121718:	4209883a 	add	r4,r8,r8
8112171c:	003e6d06 	br	811210d4 <__reset+0xfb1010d4>
81121720:	00c40004 	movi	r3,4096
81121724:	003f4606 	br	81121440 <__reset+0xfb101440>
81121728:	00800044 	movi	r2,1
8112172c:	a0800115 	stw	r2,4(r20)
81121730:	003f7406 	br	81121504 <__reset+0xfb101504>
81121734:	1805d0ba 	srai	r2,r3,2
81121738:	01c00044 	movi	r7,1
8112173c:	30c00117 	ldw	r3,4(r6)
81121740:	388e983a 	sll	r7,r7,r2
81121744:	2805883a 	mov	r2,r5
81121748:	38c6b03a 	or	r3,r7,r3
8112174c:	30c00115 	stw	r3,4(r6)
81121750:	003f9b06 	br	811215c0 <__reset+0xfb1015c0>
81121754:	00c15504 	movi	r3,1364
81121758:	18801a36 	bltu	r3,r2,811217c4 <_malloc_r+0x770>
8112175c:	8804d4ba 	srli	r2,r17,18
81121760:	12001f44 	addi	r8,r2,125
81121764:	11c01f04 	addi	r7,r2,124
81121768:	4209883a 	add	r4,r8,r8
8112176c:	003e5906 	br	811210d4 <__reset+0xfb1010d4>
81121770:	ad400404 	addi	r21,r21,16
81121774:	003f1706 	br	811213d4 <__reset+0xfb1013d4>
81121778:	00c01504 	movi	r3,84
8112177c:	18802336 	bltu	r3,r2,8112180c <_malloc_r+0x7b8>
81121780:	3804d33a 	srli	r2,r7,12
81121784:	11401bc4 	addi	r5,r2,111
81121788:	10c01b84 	addi	r3,r2,110
8112178c:	294b883a 	add	r5,r5,r5
81121790:	003f7b06 	br	81121580 <__reset+0xfb101580>
81121794:	9c000217 	ldw	r16,8(r19)
81121798:	00bfff04 	movi	r2,-4
8112179c:	80c00117 	ldw	r3,4(r16)
811217a0:	1886703a 	and	r3,r3,r2
811217a4:	003f5306 	br	811214f4 <__reset+0xfb1014f4>
811217a8:	3083ffcc 	andi	r2,r6,4095
811217ac:	103f181e 	bne	r2,zero,81121410 <__reset+0xfb101410>
811217b0:	99000217 	ldw	r4,8(r19)
811217b4:	b545883a 	add	r2,r22,r21
811217b8:	10800054 	ori	r2,r2,1
811217bc:	20800115 	stw	r2,4(r4)
811217c0:	003f3e06 	br	811214bc <__reset+0xfb1014bc>
811217c4:	01003f84 	movi	r4,254
811217c8:	02001fc4 	movi	r8,127
811217cc:	01c01f84 	movi	r7,126
811217d0:	003e4006 	br	811210d4 <__reset+0xfb1010d4>
811217d4:	00a04574 	movhi	r2,33045
811217d8:	10886a04 	addi	r2,r2,8616
811217dc:	15000015 	stw	r20,0(r2)
811217e0:	003f1106 	br	81121428 <__reset+0xfb101428>
811217e4:	00800044 	movi	r2,1
811217e8:	002b883a 	mov	r21,zero
811217ec:	003f1f06 	br	8112146c <__reset+0xfb10146c>
811217f0:	81400204 	addi	r5,r16,8
811217f4:	9009883a 	mov	r4,r18
811217f8:	112aac80 	call	8112aac8 <_free_r>
811217fc:	00a04574 	movhi	r2,33045
81121800:	10896b04 	addi	r2,r2,9644
81121804:	10c00017 	ldw	r3,0(r2)
81121808:	003f2c06 	br	811214bc <__reset+0xfb1014bc>
8112180c:	00c05504 	movi	r3,340
81121810:	18800536 	bltu	r3,r2,81121828 <_malloc_r+0x7d4>
81121814:	3804d3fa 	srli	r2,r7,15
81121818:	11401e04 	addi	r5,r2,120
8112181c:	10c01dc4 	addi	r3,r2,119
81121820:	294b883a 	add	r5,r5,r5
81121824:	003f5606 	br	81121580 <__reset+0xfb101580>
81121828:	00c15504 	movi	r3,1364
8112182c:	18800536 	bltu	r3,r2,81121844 <_malloc_r+0x7f0>
81121830:	3804d4ba 	srli	r2,r7,18
81121834:	11401f44 	addi	r5,r2,125
81121838:	10c01f04 	addi	r3,r2,124
8112183c:	294b883a 	add	r5,r5,r5
81121840:	003f4f06 	br	81121580 <__reset+0xfb101580>
81121844:	01403f84 	movi	r5,254
81121848:	00c01f84 	movi	r3,126
8112184c:	003f4c06 	br	81121580 <__reset+0xfb101580>
81121850:	98800117 	ldw	r2,4(r19)
81121854:	003fa006 	br	811216d8 <__reset+0xfb1016d8>
81121858:	8808d0fa 	srli	r4,r17,3
8112185c:	20800044 	addi	r2,r4,1
81121860:	1085883a 	add	r2,r2,r2
81121864:	003e9006 	br	811212a8 <__reset+0xfb1012a8>

81121868 <memcpy>:
81121868:	defffd04 	addi	sp,sp,-12
8112186c:	de00012e 	bgeu	sp,et,81121874 <memcpy+0xc>
81121870:	003b68fa 	trap	3
81121874:	00c003c4 	movi	r3,15
81121878:	dfc00215 	stw	ra,8(sp)
8112187c:	dc400115 	stw	r17,4(sp)
81121880:	dc000015 	stw	r16,0(sp)
81121884:	2005883a 	mov	r2,r4
81121888:	1980452e 	bgeu	r3,r6,811219a0 <memcpy+0x138>
8112188c:	2906b03a 	or	r3,r5,r4
81121890:	18c000cc 	andi	r3,r3,3
81121894:	1800441e 	bne	r3,zero,811219a8 <memcpy+0x140>
81121898:	347ffc04 	addi	r17,r6,-16
8112189c:	8822d13a 	srli	r17,r17,4
811218a0:	28c00104 	addi	r3,r5,4
811218a4:	23400104 	addi	r13,r4,4
811218a8:	8820913a 	slli	r16,r17,4
811218ac:	2b000204 	addi	r12,r5,8
811218b0:	22c00204 	addi	r11,r4,8
811218b4:	84000504 	addi	r16,r16,20
811218b8:	2a800304 	addi	r10,r5,12
811218bc:	22400304 	addi	r9,r4,12
811218c0:	2c21883a 	add	r16,r5,r16
811218c4:	2811883a 	mov	r8,r5
811218c8:	200f883a 	mov	r7,r4
811218cc:	41000017 	ldw	r4,0(r8)
811218d0:	1fc00017 	ldw	ra,0(r3)
811218d4:	63c00017 	ldw	r15,0(r12)
811218d8:	39000015 	stw	r4,0(r7)
811218dc:	53800017 	ldw	r14,0(r10)
811218e0:	6fc00015 	stw	ra,0(r13)
811218e4:	5bc00015 	stw	r15,0(r11)
811218e8:	4b800015 	stw	r14,0(r9)
811218ec:	18c00404 	addi	r3,r3,16
811218f0:	39c00404 	addi	r7,r7,16
811218f4:	42000404 	addi	r8,r8,16
811218f8:	6b400404 	addi	r13,r13,16
811218fc:	63000404 	addi	r12,r12,16
81121900:	5ac00404 	addi	r11,r11,16
81121904:	52800404 	addi	r10,r10,16
81121908:	4a400404 	addi	r9,r9,16
8112190c:	1c3fef1e 	bne	r3,r16,811218cc <__reset+0xfb1018cc>
81121910:	89c00044 	addi	r7,r17,1
81121914:	380e913a 	slli	r7,r7,4
81121918:	310003cc 	andi	r4,r6,15
8112191c:	02c000c4 	movi	r11,3
81121920:	11c7883a 	add	r3,r2,r7
81121924:	29cb883a 	add	r5,r5,r7
81121928:	5900212e 	bgeu	r11,r4,811219b0 <memcpy+0x148>
8112192c:	1813883a 	mov	r9,r3
81121930:	2811883a 	mov	r8,r5
81121934:	200f883a 	mov	r7,r4
81121938:	42800017 	ldw	r10,0(r8)
8112193c:	4a400104 	addi	r9,r9,4
81121940:	39ffff04 	addi	r7,r7,-4
81121944:	4abfff15 	stw	r10,-4(r9)
81121948:	42000104 	addi	r8,r8,4
8112194c:	59fffa36 	bltu	r11,r7,81121938 <__reset+0xfb101938>
81121950:	213fff04 	addi	r4,r4,-4
81121954:	2008d0ba 	srli	r4,r4,2
81121958:	318000cc 	andi	r6,r6,3
8112195c:	21000044 	addi	r4,r4,1
81121960:	2109883a 	add	r4,r4,r4
81121964:	2109883a 	add	r4,r4,r4
81121968:	1907883a 	add	r3,r3,r4
8112196c:	290b883a 	add	r5,r5,r4
81121970:	30000626 	beq	r6,zero,8112198c <memcpy+0x124>
81121974:	198d883a 	add	r6,r3,r6
81121978:	29c00003 	ldbu	r7,0(r5)
8112197c:	18c00044 	addi	r3,r3,1
81121980:	29400044 	addi	r5,r5,1
81121984:	19ffffc5 	stb	r7,-1(r3)
81121988:	19bffb1e 	bne	r3,r6,81121978 <__reset+0xfb101978>
8112198c:	dfc00217 	ldw	ra,8(sp)
81121990:	dc400117 	ldw	r17,4(sp)
81121994:	dc000017 	ldw	r16,0(sp)
81121998:	dec00304 	addi	sp,sp,12
8112199c:	f800283a 	ret
811219a0:	2007883a 	mov	r3,r4
811219a4:	003ff206 	br	81121970 <__reset+0xfb101970>
811219a8:	2007883a 	mov	r3,r4
811219ac:	003ff106 	br	81121974 <__reset+0xfb101974>
811219b0:	200d883a 	mov	r6,r4
811219b4:	003fee06 	br	81121970 <__reset+0xfb101970>

811219b8 <memset>:
811219b8:	20c000cc 	andi	r3,r4,3
811219bc:	2005883a 	mov	r2,r4
811219c0:	18004426 	beq	r3,zero,81121ad4 <memset+0x11c>
811219c4:	31ffffc4 	addi	r7,r6,-1
811219c8:	30004026 	beq	r6,zero,81121acc <memset+0x114>
811219cc:	2813883a 	mov	r9,r5
811219d0:	200d883a 	mov	r6,r4
811219d4:	2007883a 	mov	r3,r4
811219d8:	00000406 	br	811219ec <memset+0x34>
811219dc:	3a3fffc4 	addi	r8,r7,-1
811219e0:	31800044 	addi	r6,r6,1
811219e4:	38003926 	beq	r7,zero,81121acc <memset+0x114>
811219e8:	400f883a 	mov	r7,r8
811219ec:	18c00044 	addi	r3,r3,1
811219f0:	32400005 	stb	r9,0(r6)
811219f4:	1a0000cc 	andi	r8,r3,3
811219f8:	403ff81e 	bne	r8,zero,811219dc <__reset+0xfb1019dc>
811219fc:	010000c4 	movi	r4,3
81121a00:	21c02d2e 	bgeu	r4,r7,81121ab8 <memset+0x100>
81121a04:	29003fcc 	andi	r4,r5,255
81121a08:	200c923a 	slli	r6,r4,8
81121a0c:	3108b03a 	or	r4,r6,r4
81121a10:	200c943a 	slli	r6,r4,16
81121a14:	218cb03a 	or	r6,r4,r6
81121a18:	010003c4 	movi	r4,15
81121a1c:	21c0182e 	bgeu	r4,r7,81121a80 <memset+0xc8>
81121a20:	3b3ffc04 	addi	r12,r7,-16
81121a24:	6018d13a 	srli	r12,r12,4
81121a28:	1a000104 	addi	r8,r3,4
81121a2c:	1ac00204 	addi	r11,r3,8
81121a30:	6008913a 	slli	r4,r12,4
81121a34:	1a800304 	addi	r10,r3,12
81121a38:	1813883a 	mov	r9,r3
81121a3c:	21000504 	addi	r4,r4,20
81121a40:	1909883a 	add	r4,r3,r4
81121a44:	49800015 	stw	r6,0(r9)
81121a48:	41800015 	stw	r6,0(r8)
81121a4c:	59800015 	stw	r6,0(r11)
81121a50:	51800015 	stw	r6,0(r10)
81121a54:	42000404 	addi	r8,r8,16
81121a58:	4a400404 	addi	r9,r9,16
81121a5c:	5ac00404 	addi	r11,r11,16
81121a60:	52800404 	addi	r10,r10,16
81121a64:	413ff71e 	bne	r8,r4,81121a44 <__reset+0xfb101a44>
81121a68:	63000044 	addi	r12,r12,1
81121a6c:	6018913a 	slli	r12,r12,4
81121a70:	39c003cc 	andi	r7,r7,15
81121a74:	010000c4 	movi	r4,3
81121a78:	1b07883a 	add	r3,r3,r12
81121a7c:	21c00e2e 	bgeu	r4,r7,81121ab8 <memset+0x100>
81121a80:	1813883a 	mov	r9,r3
81121a84:	3811883a 	mov	r8,r7
81121a88:	010000c4 	movi	r4,3
81121a8c:	49800015 	stw	r6,0(r9)
81121a90:	423fff04 	addi	r8,r8,-4
81121a94:	4a400104 	addi	r9,r9,4
81121a98:	223ffc36 	bltu	r4,r8,81121a8c <__reset+0xfb101a8c>
81121a9c:	393fff04 	addi	r4,r7,-4
81121aa0:	2008d0ba 	srli	r4,r4,2
81121aa4:	39c000cc 	andi	r7,r7,3
81121aa8:	21000044 	addi	r4,r4,1
81121aac:	2109883a 	add	r4,r4,r4
81121ab0:	2109883a 	add	r4,r4,r4
81121ab4:	1907883a 	add	r3,r3,r4
81121ab8:	38000526 	beq	r7,zero,81121ad0 <memset+0x118>
81121abc:	19cf883a 	add	r7,r3,r7
81121ac0:	19400005 	stb	r5,0(r3)
81121ac4:	18c00044 	addi	r3,r3,1
81121ac8:	38fffd1e 	bne	r7,r3,81121ac0 <__reset+0xfb101ac0>
81121acc:	f800283a 	ret
81121ad0:	f800283a 	ret
81121ad4:	2007883a 	mov	r3,r4
81121ad8:	300f883a 	mov	r7,r6
81121adc:	003fc706 	br	811219fc <__reset+0xfb1019fc>

81121ae0 <_open_r>:
81121ae0:	defffd04 	addi	sp,sp,-12
81121ae4:	de00012e 	bgeu	sp,et,81121aec <_open_r+0xc>
81121ae8:	003b68fa 	trap	3
81121aec:	2805883a 	mov	r2,r5
81121af0:	dc000015 	stw	r16,0(sp)
81121af4:	04204574 	movhi	r16,33045
81121af8:	dc400115 	stw	r17,4(sp)
81121afc:	300b883a 	mov	r5,r6
81121b00:	8408db04 	addi	r16,r16,9068
81121b04:	2023883a 	mov	r17,r4
81121b08:	380d883a 	mov	r6,r7
81121b0c:	1009883a 	mov	r4,r2
81121b10:	dfc00215 	stw	ra,8(sp)
81121b14:	80000015 	stw	zero,0(r16)
81121b18:	11369100 	call	81136910 <open>
81121b1c:	00ffffc4 	movi	r3,-1
81121b20:	10c00526 	beq	r2,r3,81121b38 <_open_r+0x58>
81121b24:	dfc00217 	ldw	ra,8(sp)
81121b28:	dc400117 	ldw	r17,4(sp)
81121b2c:	dc000017 	ldw	r16,0(sp)
81121b30:	dec00304 	addi	sp,sp,12
81121b34:	f800283a 	ret
81121b38:	80c00017 	ldw	r3,0(r16)
81121b3c:	183ff926 	beq	r3,zero,81121b24 <__reset+0xfb101b24>
81121b40:	88c00015 	stw	r3,0(r17)
81121b44:	003ff706 	br	81121b24 <__reset+0xfb101b24>

81121b48 <_printf_r>:
81121b48:	defffd04 	addi	sp,sp,-12
81121b4c:	2805883a 	mov	r2,r5
81121b50:	de00012e 	bgeu	sp,et,81121b58 <_printf_r+0x10>
81121b54:	003b68fa 	trap	3
81121b58:	dfc00015 	stw	ra,0(sp)
81121b5c:	d9800115 	stw	r6,4(sp)
81121b60:	d9c00215 	stw	r7,8(sp)
81121b64:	21400217 	ldw	r5,8(r4)
81121b68:	d9c00104 	addi	r7,sp,4
81121b6c:	100d883a 	mov	r6,r2
81121b70:	11248740 	call	81124874 <___vfprintf_internal_r>
81121b74:	dfc00017 	ldw	ra,0(sp)
81121b78:	dec00304 	addi	sp,sp,12
81121b7c:	f800283a 	ret

81121b80 <printf>:
81121b80:	defffc04 	addi	sp,sp,-16
81121b84:	de00012e 	bgeu	sp,et,81121b8c <printf+0xc>
81121b88:	003b68fa 	trap	3
81121b8c:	dfc00015 	stw	ra,0(sp)
81121b90:	d9400115 	stw	r5,4(sp)
81121b94:	d9800215 	stw	r6,8(sp)
81121b98:	d9c00315 	stw	r7,12(sp)
81121b9c:	00a04574 	movhi	r2,33045
81121ba0:	10886904 	addi	r2,r2,8612
81121ba4:	10800017 	ldw	r2,0(r2)
81121ba8:	200b883a 	mov	r5,r4
81121bac:	d9800104 	addi	r6,sp,4
81121bb0:	11000217 	ldw	r4,8(r2)
81121bb4:	1126a740 	call	81126a74 <__vfprintf_internal>
81121bb8:	dfc00017 	ldw	ra,0(sp)
81121bbc:	dec00404 	addi	sp,sp,16
81121bc0:	f800283a 	ret

81121bc4 <_putc_r>:
81121bc4:	defffc04 	addi	sp,sp,-16
81121bc8:	de00012e 	bgeu	sp,et,81121bd0 <_putc_r+0xc>
81121bcc:	003b68fa 	trap	3
81121bd0:	dc000215 	stw	r16,8(sp)
81121bd4:	dfc00315 	stw	ra,12(sp)
81121bd8:	2021883a 	mov	r16,r4
81121bdc:	20000226 	beq	r4,zero,81121be8 <_putc_r+0x24>
81121be0:	20800e17 	ldw	r2,56(r4)
81121be4:	10001b26 	beq	r2,zero,81121c54 <_putc_r+0x90>
81121be8:	30800217 	ldw	r2,8(r6)
81121bec:	10bfffc4 	addi	r2,r2,-1
81121bf0:	30800215 	stw	r2,8(r6)
81121bf4:	10000a16 	blt	r2,zero,81121c20 <_putc_r+0x5c>
81121bf8:	30800017 	ldw	r2,0(r6)
81121bfc:	11400005 	stb	r5,0(r2)
81121c00:	30800017 	ldw	r2,0(r6)
81121c04:	10c00044 	addi	r3,r2,1
81121c08:	30c00015 	stw	r3,0(r6)
81121c0c:	10800003 	ldbu	r2,0(r2)
81121c10:	dfc00317 	ldw	ra,12(sp)
81121c14:	dc000217 	ldw	r16,8(sp)
81121c18:	dec00404 	addi	sp,sp,16
81121c1c:	f800283a 	ret
81121c20:	30c00617 	ldw	r3,24(r6)
81121c24:	10c00616 	blt	r2,r3,81121c40 <_putc_r+0x7c>
81121c28:	30800017 	ldw	r2,0(r6)
81121c2c:	00c00284 	movi	r3,10
81121c30:	11400005 	stb	r5,0(r2)
81121c34:	30800017 	ldw	r2,0(r6)
81121c38:	11400003 	ldbu	r5,0(r2)
81121c3c:	28fff11e 	bne	r5,r3,81121c04 <__reset+0xfb101c04>
81121c40:	8009883a 	mov	r4,r16
81121c44:	dfc00317 	ldw	ra,12(sp)
81121c48:	dc000217 	ldw	r16,8(sp)
81121c4c:	dec00404 	addi	sp,sp,16
81121c50:	11283f81 	jmpi	811283f8 <__swbuf_r>
81121c54:	d9400015 	stw	r5,0(sp)
81121c58:	d9800115 	stw	r6,4(sp)
81121c5c:	112a6300 	call	8112a630 <__sinit>
81121c60:	d9800117 	ldw	r6,4(sp)
81121c64:	d9400017 	ldw	r5,0(sp)
81121c68:	003fdf06 	br	81121be8 <__reset+0xfb101be8>

81121c6c <putc>:
81121c6c:	00a04574 	movhi	r2,33045
81121c70:	defffc04 	addi	sp,sp,-16
81121c74:	10886904 	addi	r2,r2,8612
81121c78:	de00012e 	bgeu	sp,et,81121c80 <putc+0x14>
81121c7c:	003b68fa 	trap	3
81121c80:	dc000115 	stw	r16,4(sp)
81121c84:	14000017 	ldw	r16,0(r2)
81121c88:	dc400215 	stw	r17,8(sp)
81121c8c:	dfc00315 	stw	ra,12(sp)
81121c90:	2023883a 	mov	r17,r4
81121c94:	80000226 	beq	r16,zero,81121ca0 <putc+0x34>
81121c98:	80800e17 	ldw	r2,56(r16)
81121c9c:	10001a26 	beq	r2,zero,81121d08 <putc+0x9c>
81121ca0:	28800217 	ldw	r2,8(r5)
81121ca4:	10bfffc4 	addi	r2,r2,-1
81121ca8:	28800215 	stw	r2,8(r5)
81121cac:	10000b16 	blt	r2,zero,81121cdc <putc+0x70>
81121cb0:	28800017 	ldw	r2,0(r5)
81121cb4:	14400005 	stb	r17,0(r2)
81121cb8:	28800017 	ldw	r2,0(r5)
81121cbc:	10c00044 	addi	r3,r2,1
81121cc0:	28c00015 	stw	r3,0(r5)
81121cc4:	10800003 	ldbu	r2,0(r2)
81121cc8:	dfc00317 	ldw	ra,12(sp)
81121ccc:	dc400217 	ldw	r17,8(sp)
81121cd0:	dc000117 	ldw	r16,4(sp)
81121cd4:	dec00404 	addi	sp,sp,16
81121cd8:	f800283a 	ret
81121cdc:	28c00617 	ldw	r3,24(r5)
81121ce0:	10c00e16 	blt	r2,r3,81121d1c <putc+0xb0>
81121ce4:	28800017 	ldw	r2,0(r5)
81121ce8:	01000284 	movi	r4,10
81121cec:	14400005 	stb	r17,0(r2)
81121cf0:	28800017 	ldw	r2,0(r5)
81121cf4:	10c00003 	ldbu	r3,0(r2)
81121cf8:	193ff01e 	bne	r3,r4,81121cbc <__reset+0xfb101cbc>
81121cfc:	280d883a 	mov	r6,r5
81121d00:	180b883a 	mov	r5,r3
81121d04:	00000706 	br	81121d24 <putc+0xb8>
81121d08:	8009883a 	mov	r4,r16
81121d0c:	d9400015 	stw	r5,0(sp)
81121d10:	112a6300 	call	8112a630 <__sinit>
81121d14:	d9400017 	ldw	r5,0(sp)
81121d18:	003fe106 	br	81121ca0 <__reset+0xfb101ca0>
81121d1c:	280d883a 	mov	r6,r5
81121d20:	880b883a 	mov	r5,r17
81121d24:	8009883a 	mov	r4,r16
81121d28:	dfc00317 	ldw	ra,12(sp)
81121d2c:	dc400217 	ldw	r17,8(sp)
81121d30:	dc000117 	ldw	r16,4(sp)
81121d34:	dec00404 	addi	sp,sp,16
81121d38:	11283f81 	jmpi	811283f8 <__swbuf_r>

81121d3c <_puts_r>:
81121d3c:	defff604 	addi	sp,sp,-40
81121d40:	de00012e 	bgeu	sp,et,81121d48 <_puts_r+0xc>
81121d44:	003b68fa 	trap	3
81121d48:	dc000715 	stw	r16,28(sp)
81121d4c:	2021883a 	mov	r16,r4
81121d50:	2809883a 	mov	r4,r5
81121d54:	dc400815 	stw	r17,32(sp)
81121d58:	dfc00915 	stw	ra,36(sp)
81121d5c:	2823883a 	mov	r17,r5
81121d60:	112235c0 	call	8112235c <strlen>
81121d64:	10c00044 	addi	r3,r2,1
81121d68:	d8800115 	stw	r2,4(sp)
81121d6c:	00a04574 	movhi	r2,33045
81121d70:	10be9004 	addi	r2,r2,-1472
81121d74:	d8800215 	stw	r2,8(sp)
81121d78:	00800044 	movi	r2,1
81121d7c:	d8800315 	stw	r2,12(sp)
81121d80:	00800084 	movi	r2,2
81121d84:	dc400015 	stw	r17,0(sp)
81121d88:	d8c00615 	stw	r3,24(sp)
81121d8c:	dec00415 	stw	sp,16(sp)
81121d90:	d8800515 	stw	r2,20(sp)
81121d94:	80000226 	beq	r16,zero,81121da0 <_puts_r+0x64>
81121d98:	80800e17 	ldw	r2,56(r16)
81121d9c:	10001426 	beq	r2,zero,81121df0 <_puts_r+0xb4>
81121da0:	81400217 	ldw	r5,8(r16)
81121da4:	2880030b 	ldhu	r2,12(r5)
81121da8:	10c8000c 	andi	r3,r2,8192
81121dac:	1800061e 	bne	r3,zero,81121dc8 <_puts_r+0x8c>
81121db0:	29001917 	ldw	r4,100(r5)
81121db4:	00f7ffc4 	movi	r3,-8193
81121db8:	10880014 	ori	r2,r2,8192
81121dbc:	20c6703a 	and	r3,r4,r3
81121dc0:	2880030d 	sth	r2,12(r5)
81121dc4:	28c01915 	stw	r3,100(r5)
81121dc8:	d9800404 	addi	r6,sp,16
81121dcc:	8009883a 	mov	r4,r16
81121dd0:	112ade00 	call	8112ade0 <__sfvwrite_r>
81121dd4:	1000091e 	bne	r2,zero,81121dfc <_puts_r+0xc0>
81121dd8:	00800284 	movi	r2,10
81121ddc:	dfc00917 	ldw	ra,36(sp)
81121de0:	dc400817 	ldw	r17,32(sp)
81121de4:	dc000717 	ldw	r16,28(sp)
81121de8:	dec00a04 	addi	sp,sp,40
81121dec:	f800283a 	ret
81121df0:	8009883a 	mov	r4,r16
81121df4:	112a6300 	call	8112a630 <__sinit>
81121df8:	003fe906 	br	81121da0 <__reset+0xfb101da0>
81121dfc:	00bfffc4 	movi	r2,-1
81121e00:	003ff606 	br	81121ddc <__reset+0xfb101ddc>

81121e04 <puts>:
81121e04:	00a04574 	movhi	r2,33045
81121e08:	10886904 	addi	r2,r2,8612
81121e0c:	200b883a 	mov	r5,r4
81121e10:	11000017 	ldw	r4,0(r2)
81121e14:	1121d3c1 	jmpi	81121d3c <_puts_r>

81121e18 <lflush>:
81121e18:	2080030b 	ldhu	r2,12(r4)
81121e1c:	00c00244 	movi	r3,9
81121e20:	1080024c 	andi	r2,r2,9
81121e24:	10c00226 	beq	r2,r3,81121e30 <lflush+0x18>
81121e28:	0005883a 	mov	r2,zero
81121e2c:	f800283a 	ret
81121e30:	112a2981 	jmpi	8112a298 <fflush>

81121e34 <__srefill_r>:
81121e34:	defffc04 	addi	sp,sp,-16
81121e38:	de00012e 	bgeu	sp,et,81121e40 <__srefill_r+0xc>
81121e3c:	003b68fa 	trap	3
81121e40:	dc400115 	stw	r17,4(sp)
81121e44:	dc000015 	stw	r16,0(sp)
81121e48:	dfc00315 	stw	ra,12(sp)
81121e4c:	dc800215 	stw	r18,8(sp)
81121e50:	2023883a 	mov	r17,r4
81121e54:	2821883a 	mov	r16,r5
81121e58:	20000226 	beq	r4,zero,81121e64 <__srefill_r+0x30>
81121e5c:	20800e17 	ldw	r2,56(r4)
81121e60:	10003c26 	beq	r2,zero,81121f54 <__srefill_r+0x120>
81121e64:	80c0030b 	ldhu	r3,12(r16)
81121e68:	1908000c 	andi	r4,r3,8192
81121e6c:	1805883a 	mov	r2,r3
81121e70:	2000071e 	bne	r4,zero,81121e90 <__srefill_r+0x5c>
81121e74:	81001917 	ldw	r4,100(r16)
81121e78:	18880014 	ori	r2,r3,8192
81121e7c:	00f7ffc4 	movi	r3,-8193
81121e80:	20c8703a 	and	r4,r4,r3
81121e84:	8080030d 	sth	r2,12(r16)
81121e88:	1007883a 	mov	r3,r2
81121e8c:	81001915 	stw	r4,100(r16)
81121e90:	80000115 	stw	zero,4(r16)
81121e94:	1100080c 	andi	r4,r2,32
81121e98:	2000571e 	bne	r4,zero,81121ff8 <__srefill_r+0x1c4>
81121e9c:	1100010c 	andi	r4,r2,4
81121ea0:	20001f26 	beq	r4,zero,81121f20 <__srefill_r+0xec>
81121ea4:	81400c17 	ldw	r5,48(r16)
81121ea8:	28000826 	beq	r5,zero,81121ecc <__srefill_r+0x98>
81121eac:	80801004 	addi	r2,r16,64
81121eb0:	28800226 	beq	r5,r2,81121ebc <__srefill_r+0x88>
81121eb4:	8809883a 	mov	r4,r17
81121eb8:	112aac80 	call	8112aac8 <_free_r>
81121ebc:	80800f17 	ldw	r2,60(r16)
81121ec0:	80000c15 	stw	zero,48(r16)
81121ec4:	80800115 	stw	r2,4(r16)
81121ec8:	1000391e 	bne	r2,zero,81121fb0 <__srefill_r+0x17c>
81121ecc:	80800417 	ldw	r2,16(r16)
81121ed0:	10004b26 	beq	r2,zero,81122000 <__srefill_r+0x1cc>
81121ed4:	8480030b 	ldhu	r18,12(r16)
81121ed8:	908000cc 	andi	r2,r18,3
81121edc:	10001f1e 	bne	r2,zero,81121f5c <__srefill_r+0x128>
81121ee0:	81800417 	ldw	r6,16(r16)
81121ee4:	80800817 	ldw	r2,32(r16)
81121ee8:	81c00517 	ldw	r7,20(r16)
81121eec:	81400717 	ldw	r5,28(r16)
81121ef0:	81800015 	stw	r6,0(r16)
81121ef4:	8809883a 	mov	r4,r17
81121ef8:	103ee83a 	callr	r2
81121efc:	80800115 	stw	r2,4(r16)
81121f00:	00800e0e 	bge	zero,r2,81121f3c <__srefill_r+0x108>
81121f04:	0005883a 	mov	r2,zero
81121f08:	dfc00317 	ldw	ra,12(sp)
81121f0c:	dc800217 	ldw	r18,8(sp)
81121f10:	dc400117 	ldw	r17,4(sp)
81121f14:	dc000017 	ldw	r16,0(sp)
81121f18:	dec00404 	addi	sp,sp,16
81121f1c:	f800283a 	ret
81121f20:	1100040c 	andi	r4,r2,16
81121f24:	20003026 	beq	r4,zero,81121fe8 <__srefill_r+0x1b4>
81121f28:	1080020c 	andi	r2,r2,8
81121f2c:	1000241e 	bne	r2,zero,81121fc0 <__srefill_r+0x18c>
81121f30:	18c00114 	ori	r3,r3,4
81121f34:	80c0030d 	sth	r3,12(r16)
81121f38:	003fe406 	br	81121ecc <__reset+0xfb101ecc>
81121f3c:	80c0030b 	ldhu	r3,12(r16)
81121f40:	1000161e 	bne	r2,zero,81121f9c <__srefill_r+0x168>
81121f44:	18c00814 	ori	r3,r3,32
81121f48:	00bfffc4 	movi	r2,-1
81121f4c:	80c0030d 	sth	r3,12(r16)
81121f50:	003fed06 	br	81121f08 <__reset+0xfb101f08>
81121f54:	112a6300 	call	8112a630 <__sinit>
81121f58:	003fc206 	br	81121e64 <__reset+0xfb101e64>
81121f5c:	00a04574 	movhi	r2,33045
81121f60:	10886804 	addi	r2,r2,8608
81121f64:	11000017 	ldw	r4,0(r2)
81121f68:	016044b4 	movhi	r5,33042
81121f6c:	00800044 	movi	r2,1
81121f70:	29478604 	addi	r5,r5,7704
81121f74:	8080030d 	sth	r2,12(r16)
81121f78:	112b2a40 	call	8112b2a4 <_fwalk>
81121f7c:	00800244 	movi	r2,9
81121f80:	8480030d 	sth	r18,12(r16)
81121f84:	9480024c 	andi	r18,r18,9
81121f88:	90bfd51e 	bne	r18,r2,81121ee0 <__reset+0xfb101ee0>
81121f8c:	800b883a 	mov	r5,r16
81121f90:	8809883a 	mov	r4,r17
81121f94:	112a0100 	call	8112a010 <__sflush_r>
81121f98:	003fd106 	br	81121ee0 <__reset+0xfb101ee0>
81121f9c:	18c01014 	ori	r3,r3,64
81121fa0:	80000115 	stw	zero,4(r16)
81121fa4:	00bfffc4 	movi	r2,-1
81121fa8:	80c0030d 	sth	r3,12(r16)
81121fac:	003fd606 	br	81121f08 <__reset+0xfb101f08>
81121fb0:	80c00e17 	ldw	r3,56(r16)
81121fb4:	0005883a 	mov	r2,zero
81121fb8:	80c00015 	stw	r3,0(r16)
81121fbc:	003fd206 	br	81121f08 <__reset+0xfb101f08>
81121fc0:	800b883a 	mov	r5,r16
81121fc4:	8809883a 	mov	r4,r17
81121fc8:	112a2340 	call	8112a234 <_fflush_r>
81121fcc:	10000a1e 	bne	r2,zero,81121ff8 <__srefill_r+0x1c4>
81121fd0:	8080030b 	ldhu	r2,12(r16)
81121fd4:	00fffdc4 	movi	r3,-9
81121fd8:	80000215 	stw	zero,8(r16)
81121fdc:	1886703a 	and	r3,r3,r2
81121fe0:	80000615 	stw	zero,24(r16)
81121fe4:	003fd206 	br	81121f30 <__reset+0xfb101f30>
81121fe8:	00800244 	movi	r2,9
81121fec:	88800015 	stw	r2,0(r17)
81121ff0:	18c01014 	ori	r3,r3,64
81121ff4:	80c0030d 	sth	r3,12(r16)
81121ff8:	00bfffc4 	movi	r2,-1
81121ffc:	003fc206 	br	81121f08 <__reset+0xfb101f08>
81122000:	800b883a 	mov	r5,r16
81122004:	8809883a 	mov	r4,r17
81122008:	1120e900 	call	81120e90 <__smakebuf_r>
8112200c:	003fb106 	br	81121ed4 <__reset+0xfb101ed4>

81122010 <_sbrk_r>:
81122010:	defffd04 	addi	sp,sp,-12
81122014:	de00012e 	bgeu	sp,et,8112201c <_sbrk_r+0xc>
81122018:	003b68fa 	trap	3
8112201c:	dc000015 	stw	r16,0(sp)
81122020:	04204574 	movhi	r16,33045
81122024:	dc400115 	stw	r17,4(sp)
81122028:	8408db04 	addi	r16,r16,9068
8112202c:	2023883a 	mov	r17,r4
81122030:	2809883a 	mov	r4,r5
81122034:	dfc00215 	stw	ra,8(sp)
81122038:	80000015 	stw	zero,0(r16)
8112203c:	1136c200 	call	81136c20 <sbrk>
81122040:	00ffffc4 	movi	r3,-1
81122044:	10c00526 	beq	r2,r3,8112205c <_sbrk_r+0x4c>
81122048:	dfc00217 	ldw	ra,8(sp)
8112204c:	dc400117 	ldw	r17,4(sp)
81122050:	dc000017 	ldw	r16,0(sp)
81122054:	dec00304 	addi	sp,sp,12
81122058:	f800283a 	ret
8112205c:	80c00017 	ldw	r3,0(r16)
81122060:	183ff926 	beq	r3,zero,81122048 <__reset+0xfb102048>
81122064:	88c00015 	stw	r3,0(r17)
81122068:	003ff706 	br	81122048 <__reset+0xfb102048>

8112206c <scanf>:
8112206c:	defffc04 	addi	sp,sp,-16
81122070:	de00012e 	bgeu	sp,et,81122078 <scanf+0xc>
81122074:	003b68fa 	trap	3
81122078:	dfc00015 	stw	ra,0(sp)
8112207c:	d9400115 	stw	r5,4(sp)
81122080:	d9800215 	stw	r6,8(sp)
81122084:	d9c00315 	stw	r7,12(sp)
81122088:	00a04574 	movhi	r2,33045
8112208c:	10886904 	addi	r2,r2,8612
81122090:	200d883a 	mov	r6,r4
81122094:	11000017 	ldw	r4,0(r2)
81122098:	d9c00104 	addi	r7,sp,4
8112209c:	21400117 	ldw	r5,4(r4)
811220a0:	11283a40 	call	811283a4 <_vfscanf_r>
811220a4:	dfc00017 	ldw	ra,0(sp)
811220a8:	dec00404 	addi	sp,sp,16
811220ac:	f800283a 	ret

811220b0 <_scanf_r>:
811220b0:	defffd04 	addi	sp,sp,-12
811220b4:	2805883a 	mov	r2,r5
811220b8:	de00012e 	bgeu	sp,et,811220c0 <_scanf_r+0x10>
811220bc:	003b68fa 	trap	3
811220c0:	dfc00015 	stw	ra,0(sp)
811220c4:	d9800115 	stw	r6,4(sp)
811220c8:	d9c00215 	stw	r7,8(sp)
811220cc:	21400117 	ldw	r5,4(r4)
811220d0:	d9c00104 	addi	r7,sp,4
811220d4:	100d883a 	mov	r6,r2
811220d8:	11283a40 	call	811283a4 <_vfscanf_r>
811220dc:	dfc00017 	ldw	ra,0(sp)
811220e0:	dec00304 	addi	sp,sp,12
811220e4:	f800283a 	ret

811220e8 <_sprintf_r>:
811220e8:	deffe404 	addi	sp,sp,-112
811220ec:	2807883a 	mov	r3,r5
811220f0:	de00012e 	bgeu	sp,et,811220f8 <_sprintf_r+0x10>
811220f4:	003b68fa 	trap	3
811220f8:	dfc01a15 	stw	ra,104(sp)
811220fc:	d9c01b15 	stw	r7,108(sp)
81122100:	00a00034 	movhi	r2,32768
81122104:	10bfffc4 	addi	r2,r2,-1
81122108:	02008204 	movi	r8,520
8112210c:	d8800215 	stw	r2,8(sp)
81122110:	d8800515 	stw	r2,20(sp)
81122114:	d9c01b04 	addi	r7,sp,108
81122118:	d80b883a 	mov	r5,sp
8112211c:	00bfffc4 	movi	r2,-1
81122120:	d8c00015 	stw	r3,0(sp)
81122124:	d8c00415 	stw	r3,16(sp)
81122128:	da00030d 	sth	r8,12(sp)
8112212c:	d880038d 	sth	r2,14(sp)
81122130:	11226940 	call	81122694 <___svfprintf_internal_r>
81122134:	d8c00017 	ldw	r3,0(sp)
81122138:	18000005 	stb	zero,0(r3)
8112213c:	dfc01a17 	ldw	ra,104(sp)
81122140:	dec01c04 	addi	sp,sp,112
81122144:	f800283a 	ret

81122148 <sprintf>:
81122148:	deffe304 	addi	sp,sp,-116
8112214c:	2007883a 	mov	r3,r4
81122150:	de00012e 	bgeu	sp,et,81122158 <sprintf+0x10>
81122154:	003b68fa 	trap	3
81122158:	dfc01a15 	stw	ra,104(sp)
8112215c:	d9801b15 	stw	r6,108(sp)
81122160:	d9c01c15 	stw	r7,112(sp)
81122164:	01204574 	movhi	r4,33045
81122168:	21086904 	addi	r4,r4,8612
8112216c:	21000017 	ldw	r4,0(r4)
81122170:	00a00034 	movhi	r2,32768
81122174:	10bfffc4 	addi	r2,r2,-1
81122178:	280d883a 	mov	r6,r5
8112217c:	02008204 	movi	r8,520
81122180:	d8800215 	stw	r2,8(sp)
81122184:	d8800515 	stw	r2,20(sp)
81122188:	d9c01b04 	addi	r7,sp,108
8112218c:	d80b883a 	mov	r5,sp
81122190:	00bfffc4 	movi	r2,-1
81122194:	d8c00015 	stw	r3,0(sp)
81122198:	d8c00415 	stw	r3,16(sp)
8112219c:	da00030d 	sth	r8,12(sp)
811221a0:	d880038d 	sth	r2,14(sp)
811221a4:	11226940 	call	81122694 <___svfprintf_internal_r>
811221a8:	d8c00017 	ldw	r3,0(sp)
811221ac:	18000005 	stb	zero,0(r3)
811221b0:	dfc01a17 	ldw	ra,104(sp)
811221b4:	dec01d04 	addi	sp,sp,116
811221b8:	f800283a 	ret

811221bc <__sread>:
811221bc:	defffe04 	addi	sp,sp,-8
811221c0:	de00012e 	bgeu	sp,et,811221c8 <__sread+0xc>
811221c4:	003b68fa 	trap	3
811221c8:	dc000015 	stw	r16,0(sp)
811221cc:	2821883a 	mov	r16,r5
811221d0:	2940038f 	ldh	r5,14(r5)
811221d4:	dfc00115 	stw	ra,4(sp)
811221d8:	112caf40 	call	8112caf4 <_read_r>
811221dc:	10000716 	blt	r2,zero,811221fc <__sread+0x40>
811221e0:	80c01417 	ldw	r3,80(r16)
811221e4:	1887883a 	add	r3,r3,r2
811221e8:	80c01415 	stw	r3,80(r16)
811221ec:	dfc00117 	ldw	ra,4(sp)
811221f0:	dc000017 	ldw	r16,0(sp)
811221f4:	dec00204 	addi	sp,sp,8
811221f8:	f800283a 	ret
811221fc:	80c0030b 	ldhu	r3,12(r16)
81122200:	18fbffcc 	andi	r3,r3,61439
81122204:	80c0030d 	sth	r3,12(r16)
81122208:	dfc00117 	ldw	ra,4(sp)
8112220c:	dc000017 	ldw	r16,0(sp)
81122210:	dec00204 	addi	sp,sp,8
81122214:	f800283a 	ret

81122218 <__seofread>:
81122218:	0005883a 	mov	r2,zero
8112221c:	f800283a 	ret

81122220 <__swrite>:
81122220:	defffb04 	addi	sp,sp,-20
81122224:	de00012e 	bgeu	sp,et,8112222c <__swrite+0xc>
81122228:	003b68fa 	trap	3
8112222c:	2880030b 	ldhu	r2,12(r5)
81122230:	dcc00315 	stw	r19,12(sp)
81122234:	dc800215 	stw	r18,8(sp)
81122238:	dc400115 	stw	r17,4(sp)
8112223c:	dc000015 	stw	r16,0(sp)
81122240:	dfc00415 	stw	ra,16(sp)
81122244:	10c0400c 	andi	r3,r2,256
81122248:	2821883a 	mov	r16,r5
8112224c:	2023883a 	mov	r17,r4
81122250:	3025883a 	mov	r18,r6
81122254:	3827883a 	mov	r19,r7
81122258:	18000526 	beq	r3,zero,81122270 <__swrite+0x50>
8112225c:	2940038f 	ldh	r5,14(r5)
81122260:	01c00084 	movi	r7,2
81122264:	000d883a 	mov	r6,zero
81122268:	112b5ac0 	call	8112b5ac <_lseek_r>
8112226c:	8080030b 	ldhu	r2,12(r16)
81122270:	8140038f 	ldh	r5,14(r16)
81122274:	10bbffcc 	andi	r2,r2,61439
81122278:	980f883a 	mov	r7,r19
8112227c:	900d883a 	mov	r6,r18
81122280:	8809883a 	mov	r4,r17
81122284:	8080030d 	sth	r2,12(r16)
81122288:	dfc00417 	ldw	ra,16(sp)
8112228c:	dcc00317 	ldw	r19,12(sp)
81122290:	dc800217 	ldw	r18,8(sp)
81122294:	dc400117 	ldw	r17,4(sp)
81122298:	dc000017 	ldw	r16,0(sp)
8112229c:	dec00504 	addi	sp,sp,20
811222a0:	11285581 	jmpi	81128558 <_write_r>

811222a4 <__sseek>:
811222a4:	defffe04 	addi	sp,sp,-8
811222a8:	de00012e 	bgeu	sp,et,811222b0 <__sseek+0xc>
811222ac:	003b68fa 	trap	3
811222b0:	dc000015 	stw	r16,0(sp)
811222b4:	2821883a 	mov	r16,r5
811222b8:	2940038f 	ldh	r5,14(r5)
811222bc:	dfc00115 	stw	ra,4(sp)
811222c0:	112b5ac0 	call	8112b5ac <_lseek_r>
811222c4:	00ffffc4 	movi	r3,-1
811222c8:	10c00826 	beq	r2,r3,811222ec <__sseek+0x48>
811222cc:	80c0030b 	ldhu	r3,12(r16)
811222d0:	80801415 	stw	r2,80(r16)
811222d4:	18c40014 	ori	r3,r3,4096
811222d8:	80c0030d 	sth	r3,12(r16)
811222dc:	dfc00117 	ldw	ra,4(sp)
811222e0:	dc000017 	ldw	r16,0(sp)
811222e4:	dec00204 	addi	sp,sp,8
811222e8:	f800283a 	ret
811222ec:	80c0030b 	ldhu	r3,12(r16)
811222f0:	18fbffcc 	andi	r3,r3,61439
811222f4:	80c0030d 	sth	r3,12(r16)
811222f8:	dfc00117 	ldw	ra,4(sp)
811222fc:	dc000017 	ldw	r16,0(sp)
81122300:	dec00204 	addi	sp,sp,8
81122304:	f800283a 	ret

81122308 <__sclose>:
81122308:	2940038f 	ldh	r5,14(r5)
8112230c:	112871c1 	jmpi	8112871c <_close_r>

81122310 <strcspn>:
81122310:	21c00007 	ldb	r7,0(r4)
81122314:	38000f26 	beq	r7,zero,81122354 <strcspn+0x44>
81122318:	2a000007 	ldb	r8,0(r5)
8112231c:	2005883a 	mov	r2,r4
81122320:	40000726 	beq	r8,zero,81122340 <strcspn+0x30>
81122324:	3a000926 	beq	r7,r8,8112234c <strcspn+0x3c>
81122328:	2807883a 	mov	r3,r5
8112232c:	00000106 	br	81122334 <strcspn+0x24>
81122330:	31c00626 	beq	r6,r7,8112234c <strcspn+0x3c>
81122334:	18c00044 	addi	r3,r3,1
81122338:	19800007 	ldb	r6,0(r3)
8112233c:	303ffc1e 	bne	r6,zero,81122330 <__reset+0xfb102330>
81122340:	10800044 	addi	r2,r2,1
81122344:	11c00007 	ldb	r7,0(r2)
81122348:	383ff51e 	bne	r7,zero,81122320 <__reset+0xfb102320>
8112234c:	1105c83a 	sub	r2,r2,r4
81122350:	f800283a 	ret
81122354:	0005883a 	mov	r2,zero
81122358:	f800283a 	ret

8112235c <strlen>:
8112235c:	208000cc 	andi	r2,r4,3
81122360:	10002026 	beq	r2,zero,811223e4 <strlen+0x88>
81122364:	20800007 	ldb	r2,0(r4)
81122368:	10002026 	beq	r2,zero,811223ec <strlen+0x90>
8112236c:	2005883a 	mov	r2,r4
81122370:	00000206 	br	8112237c <strlen+0x20>
81122374:	10c00007 	ldb	r3,0(r2)
81122378:	18001826 	beq	r3,zero,811223dc <strlen+0x80>
8112237c:	10800044 	addi	r2,r2,1
81122380:	10c000cc 	andi	r3,r2,3
81122384:	183ffb1e 	bne	r3,zero,81122374 <__reset+0xfb102374>
81122388:	10c00017 	ldw	r3,0(r2)
8112238c:	01ffbff4 	movhi	r7,65279
81122390:	39ffbfc4 	addi	r7,r7,-257
81122394:	00ca303a 	nor	r5,zero,r3
81122398:	01a02074 	movhi	r6,32897
8112239c:	19c7883a 	add	r3,r3,r7
811223a0:	31a02004 	addi	r6,r6,-32640
811223a4:	1946703a 	and	r3,r3,r5
811223a8:	1986703a 	and	r3,r3,r6
811223ac:	1800091e 	bne	r3,zero,811223d4 <strlen+0x78>
811223b0:	10800104 	addi	r2,r2,4
811223b4:	10c00017 	ldw	r3,0(r2)
811223b8:	19cb883a 	add	r5,r3,r7
811223bc:	00c6303a 	nor	r3,zero,r3
811223c0:	28c6703a 	and	r3,r5,r3
811223c4:	1986703a 	and	r3,r3,r6
811223c8:	183ff926 	beq	r3,zero,811223b0 <__reset+0xfb1023b0>
811223cc:	00000106 	br	811223d4 <strlen+0x78>
811223d0:	10800044 	addi	r2,r2,1
811223d4:	10c00007 	ldb	r3,0(r2)
811223d8:	183ffd1e 	bne	r3,zero,811223d0 <__reset+0xfb1023d0>
811223dc:	1105c83a 	sub	r2,r2,r4
811223e0:	f800283a 	ret
811223e4:	2005883a 	mov	r2,r4
811223e8:	003fe706 	br	81122388 <__reset+0xfb102388>
811223ec:	0005883a 	mov	r2,zero
811223f0:	f800283a 	ret

811223f4 <strnlen>:
811223f4:	28000e26 	beq	r5,zero,81122430 <strnlen+0x3c>
811223f8:	20800007 	ldb	r2,0(r4)
811223fc:	10000c26 	beq	r2,zero,81122430 <strnlen+0x3c>
81122400:	20c00044 	addi	r3,r4,1
81122404:	214b883a 	add	r5,r4,r5
81122408:	28c00526 	beq	r5,r3,81122420 <strnlen+0x2c>
8112240c:	19800007 	ldb	r6,0(r3)
81122410:	19c00044 	addi	r7,r3,1
81122414:	30000426 	beq	r6,zero,81122428 <strnlen+0x34>
81122418:	3807883a 	mov	r3,r7
8112241c:	28fffb1e 	bne	r5,r3,8112240c <__reset+0xfb10240c>
81122420:	2905c83a 	sub	r2,r5,r4
81122424:	f800283a 	ret
81122428:	1905c83a 	sub	r2,r3,r4
8112242c:	f800283a 	ret
81122430:	0005883a 	mov	r2,zero
81122434:	f800283a 	ret

81122438 <_strtol_r>:
81122438:	00a04574 	movhi	r2,33045
8112243c:	defff404 	addi	sp,sp,-48
81122440:	10886704 	addi	r2,r2,8604
81122444:	de00012e 	bgeu	sp,et,8112244c <_strtol_r+0x14>
81122448:	003b68fa 	trap	3
8112244c:	dd400715 	stw	r21,28(sp)
81122450:	15400017 	ldw	r21,0(r2)
81122454:	dd800815 	stw	r22,32(sp)
81122458:	dd000615 	stw	r20,24(sp)
8112245c:	dcc00515 	stw	r19,20(sp)
81122460:	d9000015 	stw	r4,0(sp)
81122464:	dfc00b15 	stw	ra,44(sp)
81122468:	df000a15 	stw	fp,40(sp)
8112246c:	ddc00915 	stw	r23,36(sp)
81122470:	dc800415 	stw	r18,16(sp)
81122474:	dc400315 	stw	r17,12(sp)
81122478:	dc000215 	stw	r16,8(sp)
8112247c:	2829883a 	mov	r20,r5
81122480:	3027883a 	mov	r19,r6
81122484:	382d883a 	mov	r22,r7
81122488:	2809883a 	mov	r4,r5
8112248c:	24000003 	ldbu	r16,0(r4)
81122490:	24400044 	addi	r17,r4,1
81122494:	2007883a 	mov	r3,r4
81122498:	ac05883a 	add	r2,r21,r16
8112249c:	10800043 	ldbu	r2,1(r2)
811224a0:	8809883a 	mov	r4,r17
811224a4:	1080020c 	andi	r2,r2,8
811224a8:	103ff81e 	bne	r2,zero,8112248c <__reset+0xfb10248c>
811224ac:	00800b44 	movi	r2,45
811224b0:	80805826 	beq	r16,r2,81122614 <_strtol_r+0x1dc>
811224b4:	00800ac4 	movi	r2,43
811224b8:	80805a26 	beq	r16,r2,81122624 <_strtol_r+0x1ec>
811224bc:	0039883a 	mov	fp,zero
811224c0:	b0004426 	beq	r22,zero,811225d4 <_strtol_r+0x19c>
811224c4:	00800404 	movi	r2,16
811224c8:	b0806026 	beq	r22,r2,8112264c <_strtol_r+0x214>
811224cc:	b02f883a 	mov	r23,r22
811224d0:	00a00034 	movhi	r2,32768
811224d4:	e025003a 	cmpeq	r18,fp,zero
811224d8:	14a5c83a 	sub	r18,r2,r18
811224dc:	b80b883a 	mov	r5,r23
811224e0:	9009883a 	mov	r4,r18
811224e4:	1133e380 	call	81133e38 <__umodsi3>
811224e8:	b80b883a 	mov	r5,r23
811224ec:	9009883a 	mov	r4,r18
811224f0:	d8800115 	stw	r2,4(sp)
811224f4:	1133dd40 	call	81133dd4 <__udivsi3>
811224f8:	ac07883a 	add	r3,r21,r16
811224fc:	18c00043 	ldbu	r3,1(r3)
81122500:	880b883a 	mov	r5,r17
81122504:	000d883a 	mov	r6,zero
81122508:	1a00010c 	andi	r8,r3,4
8112250c:	0009883a 	mov	r4,zero
81122510:	02800044 	movi	r10,1
81122514:	027fffc4 	movi	r9,-1
81122518:	d9c00117 	ldw	r7,4(sp)
8112251c:	40000e26 	beq	r8,zero,81122558 <_strtol_r+0x120>
81122520:	843ff404 	addi	r16,r16,-48
81122524:	8580120e 	bge	r16,r22,81122570 <_strtol_r+0x138>
81122528:	32400526 	beq	r6,r9,81122540 <_strtol_r+0x108>
8112252c:	11002536 	bltu	r2,r4,811225c4 <_strtol_r+0x18c>
81122530:	20802326 	beq	r4,r2,811225c0 <_strtol_r+0x188>
81122534:	25c9383a 	mul	r4,r4,r23
81122538:	01800044 	movi	r6,1
8112253c:	8109883a 	add	r4,r16,r4
81122540:	2c000003 	ldbu	r16,0(r5)
81122544:	29400044 	addi	r5,r5,1
81122548:	ac07883a 	add	r3,r21,r16
8112254c:	18c00043 	ldbu	r3,1(r3)
81122550:	1a00010c 	andi	r8,r3,4
81122554:	403ff21e 	bne	r8,zero,81122520 <__reset+0xfb102520>
81122558:	18c000cc 	andi	r3,r3,3
8112255c:	18000426 	beq	r3,zero,81122570 <_strtol_r+0x138>
81122560:	1a801a26 	beq	r3,r10,811225cc <_strtol_r+0x194>
81122564:	00c015c4 	movi	r3,87
81122568:	80e1c83a 	sub	r16,r16,r3
8112256c:	85bfee16 	blt	r16,r22,81122528 <__reset+0xfb102528>
81122570:	00bfffc4 	movi	r2,-1
81122574:	30801e26 	beq	r6,r2,811225f0 <_strtol_r+0x1b8>
81122578:	e0001b1e 	bne	fp,zero,811225e8 <_strtol_r+0x1b0>
8112257c:	2005883a 	mov	r2,r4
81122580:	98000326 	beq	r19,zero,81122590 <_strtol_r+0x158>
81122584:	3000211e 	bne	r6,zero,8112260c <_strtol_r+0x1d4>
81122588:	a00b883a 	mov	r5,r20
8112258c:	99400015 	stw	r5,0(r19)
81122590:	dfc00b17 	ldw	ra,44(sp)
81122594:	df000a17 	ldw	fp,40(sp)
81122598:	ddc00917 	ldw	r23,36(sp)
8112259c:	dd800817 	ldw	r22,32(sp)
811225a0:	dd400717 	ldw	r21,28(sp)
811225a4:	dd000617 	ldw	r20,24(sp)
811225a8:	dcc00517 	ldw	r19,20(sp)
811225ac:	dc800417 	ldw	r18,16(sp)
811225b0:	dc400317 	ldw	r17,12(sp)
811225b4:	dc000217 	ldw	r16,8(sp)
811225b8:	dec00c04 	addi	sp,sp,48
811225bc:	f800283a 	ret
811225c0:	3c3fdc0e 	bge	r7,r16,81122534 <__reset+0xfb102534>
811225c4:	01bfffc4 	movi	r6,-1
811225c8:	003fdd06 	br	81122540 <__reset+0xfb102540>
811225cc:	00c00dc4 	movi	r3,55
811225d0:	003fe506 	br	81122568 <__reset+0xfb102568>
811225d4:	00800c04 	movi	r2,48
811225d8:	80801626 	beq	r16,r2,81122634 <_strtol_r+0x1fc>
811225dc:	05800284 	movi	r22,10
811225e0:	b02f883a 	mov	r23,r22
811225e4:	003fba06 	br	811224d0 <__reset+0xfb1024d0>
811225e8:	0109c83a 	sub	r4,zero,r4
811225ec:	003fe306 	br	8112257c <__reset+0xfb10257c>
811225f0:	d9000017 	ldw	r4,0(sp)
811225f4:	00c00884 	movi	r3,34
811225f8:	e005003a 	cmpeq	r2,fp,zero
811225fc:	20c00015 	stw	r3,0(r4)
81122600:	00e00034 	movhi	r3,32768
81122604:	1885c83a 	sub	r2,r3,r2
81122608:	983fe126 	beq	r19,zero,81122590 <__reset+0xfb102590>
8112260c:	297fffc4 	addi	r5,r5,-1
81122610:	003fde06 	br	8112258c <__reset+0xfb10258c>
81122614:	1c400084 	addi	r17,r3,2
81122618:	1c000043 	ldbu	r16,1(r3)
8112261c:	07000044 	movi	fp,1
81122620:	003fa706 	br	811224c0 <__reset+0xfb1024c0>
81122624:	1c400084 	addi	r17,r3,2
81122628:	1c000043 	ldbu	r16,1(r3)
8112262c:	0039883a 	mov	fp,zero
81122630:	003fa306 	br	811224c0 <__reset+0xfb1024c0>
81122634:	88800003 	ldbu	r2,0(r17)
81122638:	00c01604 	movi	r3,88
8112263c:	108037cc 	andi	r2,r2,223
81122640:	10c00826 	beq	r2,r3,81122664 <_strtol_r+0x22c>
81122644:	05800204 	movi	r22,8
81122648:	003fa006 	br	811224cc <__reset+0xfb1024cc>
8112264c:	00800c04 	movi	r2,48
81122650:	80bf9e1e 	bne	r16,r2,811224cc <__reset+0xfb1024cc>
81122654:	88800003 	ldbu	r2,0(r17)
81122658:	00c01604 	movi	r3,88
8112265c:	108037cc 	andi	r2,r2,223
81122660:	10ff9a1e 	bne	r2,r3,811224cc <__reset+0xfb1024cc>
81122664:	05c00404 	movi	r23,16
81122668:	8c000043 	ldbu	r16,1(r17)
8112266c:	b82d883a 	mov	r22,r23
81122670:	8c400084 	addi	r17,r17,2
81122674:	003f9606 	br	811224d0 <__reset+0xfb1024d0>

81122678 <strtol>:
81122678:	00a04574 	movhi	r2,33045
8112267c:	10886904 	addi	r2,r2,8612
81122680:	300f883a 	mov	r7,r6
81122684:	280d883a 	mov	r6,r5
81122688:	200b883a 	mov	r5,r4
8112268c:	11000017 	ldw	r4,0(r2)
81122690:	11224381 	jmpi	81122438 <_strtol_r>

81122694 <___svfprintf_internal_r>:
81122694:	deffb704 	addi	sp,sp,-292
81122698:	de00012e 	bgeu	sp,et,811226a0 <___svfprintf_internal_r+0xc>
8112269c:	003b68fa 	trap	3
811226a0:	dfc04815 	stw	ra,288(sp)
811226a4:	ddc04615 	stw	r23,280(sp)
811226a8:	d9402c15 	stw	r5,176(sp)
811226ac:	d9003915 	stw	r4,228(sp)
811226b0:	302f883a 	mov	r23,r6
811226b4:	d9c02d15 	stw	r7,180(sp)
811226b8:	df004715 	stw	fp,284(sp)
811226bc:	dd804515 	stw	r22,276(sp)
811226c0:	dd404415 	stw	r21,272(sp)
811226c4:	dd004315 	stw	r20,268(sp)
811226c8:	dcc04215 	stw	r19,264(sp)
811226cc:	dc804115 	stw	r18,260(sp)
811226d0:	dc404015 	stw	r17,256(sp)
811226d4:	dc003f15 	stw	r16,252(sp)
811226d8:	112b57c0 	call	8112b57c <_localeconv_r>
811226dc:	10800017 	ldw	r2,0(r2)
811226e0:	1009883a 	mov	r4,r2
811226e4:	d8803415 	stw	r2,208(sp)
811226e8:	112235c0 	call	8112235c <strlen>
811226ec:	d8c02c17 	ldw	r3,176(sp)
811226f0:	d8803815 	stw	r2,224(sp)
811226f4:	1880030b 	ldhu	r2,12(r3)
811226f8:	1080200c 	andi	r2,r2,128
811226fc:	10000226 	beq	r2,zero,81122708 <___svfprintf_internal_r+0x74>
81122700:	18800417 	ldw	r2,16(r3)
81122704:	10067f26 	beq	r2,zero,81124104 <___svfprintf_internal_r+0x1a70>
81122708:	dcc03917 	ldw	r19,228(sp)
8112270c:	d8c00404 	addi	r3,sp,16
81122710:	05604574 	movhi	r21,33045
81122714:	d9001e04 	addi	r4,sp,120
81122718:	ad7ea184 	addi	r21,r21,-1402
8112271c:	d8c01e15 	stw	r3,120(sp)
81122720:	d8002015 	stw	zero,128(sp)
81122724:	d8001f15 	stw	zero,124(sp)
81122728:	d8003315 	stw	zero,204(sp)
8112272c:	d8003615 	stw	zero,216(sp)
81122730:	d8003715 	stw	zero,220(sp)
81122734:	1811883a 	mov	r8,r3
81122738:	d8003a15 	stw	zero,232(sp)
8112273c:	d8003b15 	stw	zero,236(sp)
81122740:	d8002f15 	stw	zero,188(sp)
81122744:	d9002815 	stw	r4,160(sp)
81122748:	b8800007 	ldb	r2,0(r23)
8112274c:	10026726 	beq	r2,zero,811230ec <___svfprintf_internal_r+0xa58>
81122750:	00c00944 	movi	r3,37
81122754:	b821883a 	mov	r16,r23
81122758:	10c0021e 	bne	r2,r3,81122764 <___svfprintf_internal_r+0xd0>
8112275c:	00001406 	br	811227b0 <___svfprintf_internal_r+0x11c>
81122760:	10c00326 	beq	r2,r3,81122770 <___svfprintf_internal_r+0xdc>
81122764:	84000044 	addi	r16,r16,1
81122768:	80800007 	ldb	r2,0(r16)
8112276c:	103ffc1e 	bne	r2,zero,81122760 <__reset+0xfb102760>
81122770:	85e3c83a 	sub	r17,r16,r23
81122774:	88000e26 	beq	r17,zero,811227b0 <___svfprintf_internal_r+0x11c>
81122778:	d8c02017 	ldw	r3,128(sp)
8112277c:	d8801f17 	ldw	r2,124(sp)
81122780:	45c00015 	stw	r23,0(r8)
81122784:	1c47883a 	add	r3,r3,r17
81122788:	10800044 	addi	r2,r2,1
8112278c:	d8c02015 	stw	r3,128(sp)
81122790:	44400115 	stw	r17,4(r8)
81122794:	d8801f15 	stw	r2,124(sp)
81122798:	00c001c4 	movi	r3,7
8112279c:	18809716 	blt	r3,r2,811229fc <___svfprintf_internal_r+0x368>
811227a0:	42000204 	addi	r8,r8,8
811227a4:	d9402f17 	ldw	r5,188(sp)
811227a8:	2c4b883a 	add	r5,r5,r17
811227ac:	d9402f15 	stw	r5,188(sp)
811227b0:	80800007 	ldb	r2,0(r16)
811227b4:	10009826 	beq	r2,zero,81122a18 <___svfprintf_internal_r+0x384>
811227b8:	84400047 	ldb	r17,1(r16)
811227bc:	00bfffc4 	movi	r2,-1
811227c0:	85c00044 	addi	r23,r16,1
811227c4:	d8002785 	stb	zero,158(sp)
811227c8:	0007883a 	mov	r3,zero
811227cc:	000f883a 	mov	r7,zero
811227d0:	d8802915 	stw	r2,164(sp)
811227d4:	d8003115 	stw	zero,196(sp)
811227d8:	0025883a 	mov	r18,zero
811227dc:	01401604 	movi	r5,88
811227e0:	01800244 	movi	r6,9
811227e4:	02800a84 	movi	r10,42
811227e8:	02401b04 	movi	r9,108
811227ec:	bdc00044 	addi	r23,r23,1
811227f0:	88bff804 	addi	r2,r17,-32
811227f4:	2882f036 	bltu	r5,r2,811233b8 <___svfprintf_internal_r+0xd24>
811227f8:	100490ba 	slli	r2,r2,2
811227fc:	012044b4 	movhi	r4,33042
81122800:	210a0404 	addi	r4,r4,10256
81122804:	1105883a 	add	r2,r2,r4
81122808:	10800017 	ldw	r2,0(r2)
8112280c:	1000683a 	jmp	r2
81122810:	81123320 	cmpeqi	r4,r16,18636
81122814:	811233b8 	rdprs	r4,r16,18638
81122818:	811233b8 	rdprs	r4,r16,18638
8112281c:	81123314 	ori	r4,r16,18636
81122820:	811233b8 	rdprs	r4,r16,18638
81122824:	811233b8 	rdprs	r4,r16,18638
81122828:	811233b8 	rdprs	r4,r16,18638
8112282c:	811233b8 	rdprs	r4,r16,18638
81122830:	811233b8 	rdprs	r4,r16,18638
81122834:	811233b8 	rdprs	r4,r16,18638
81122838:	81122a74 	orhi	r4,r16,18601
8112283c:	81123250 	cmplti	r4,r16,18633
81122840:	811233b8 	rdprs	r4,r16,18638
81122844:	81122984 	addi	r4,r16,18598
81122848:	81122a9c 	xori	r4,r16,18602
8112284c:	811233b8 	rdprs	r4,r16,18638
81122850:	81122b10 	cmplti	r4,r16,18604
81122854:	81122adc 	xori	r4,r16,18603
81122858:	81122adc 	xori	r4,r16,18603
8112285c:	81122adc 	xori	r4,r16,18603
81122860:	81122adc 	xori	r4,r16,18603
81122864:	81122adc 	xori	r4,r16,18603
81122868:	81122adc 	xori	r4,r16,18603
8112286c:	81122adc 	xori	r4,r16,18603
81122870:	81122adc 	xori	r4,r16,18603
81122874:	81122adc 	xori	r4,r16,18603
81122878:	811233b8 	rdprs	r4,r16,18638
8112287c:	811233b8 	rdprs	r4,r16,18638
81122880:	811233b8 	rdprs	r4,r16,18638
81122884:	811233b8 	rdprs	r4,r16,18638
81122888:	811233b8 	rdprs	r4,r16,18638
8112288c:	811233b8 	rdprs	r4,r16,18638
81122890:	811233b8 	rdprs	r4,r16,18638
81122894:	811233b8 	rdprs	r4,r16,18638
81122898:	811233b8 	rdprs	r4,r16,18638
8112289c:	811233b8 	rdprs	r4,r16,18638
811228a0:	81122bc8 	cmpgei	r4,r16,18607
811228a4:	81122b1c 	xori	r4,r16,18604
811228a8:	811233b8 	rdprs	r4,r16,18638
811228ac:	81122b1c 	xori	r4,r16,18604
811228b0:	811233b8 	rdprs	r4,r16,18638
811228b4:	811233b8 	rdprs	r4,r16,18638
811228b8:	811233b8 	rdprs	r4,r16,18638
811228bc:	811233b8 	rdprs	r4,r16,18638
811228c0:	81122bbc 	xorhi	r4,r16,18606
811228c4:	811233b8 	rdprs	r4,r16,18638
811228c8:	811233b8 	rdprs	r4,r16,18638
811228cc:	81122c84 	addi	r4,r16,18610
811228d0:	811233b8 	rdprs	r4,r16,18638
811228d4:	811233b8 	rdprs	r4,r16,18638
811228d8:	811233b8 	rdprs	r4,r16,18638
811228dc:	811233b8 	rdprs	r4,r16,18638
811228e0:	811233b8 	rdprs	r4,r16,18638
811228e4:	811230f4 	orhi	r4,r16,18627
811228e8:	811233b8 	rdprs	r4,r16,18638
811228ec:	811233b8 	rdprs	r4,r16,18638
811228f0:	81123154 	ori	r4,r16,18629
811228f4:	811233b8 	rdprs	r4,r16,18638
811228f8:	811233b8 	rdprs	r4,r16,18638
811228fc:	811233b8 	rdprs	r4,r16,18638
81122900:	811233b8 	rdprs	r4,r16,18638
81122904:	811233b8 	rdprs	r4,r16,18638
81122908:	811233b8 	rdprs	r4,r16,18638
8112290c:	811233b8 	rdprs	r4,r16,18638
81122910:	811233b8 	rdprs	r4,r16,18638
81122914:	811233b8 	rdprs	r4,r16,18638
81122918:	811233b8 	rdprs	r4,r16,18638
8112291c:	81123204 	addi	r4,r16,18632
81122920:	81123340 	call	88112334 <__reset+0x20f2334>
81122924:	81122b1c 	xori	r4,r16,18604
81122928:	81122b1c 	xori	r4,r16,18604
8112292c:	81122b1c 	xori	r4,r16,18604
81122930:	81123394 	ori	r4,r16,18638
81122934:	81123340 	call	88112334 <__reset+0x20f2334>
81122938:	811233b8 	rdprs	r4,r16,18638
8112293c:	811233b8 	rdprs	r4,r16,18638
81122940:	81123350 	cmplti	r4,r16,18637
81122944:	811233b8 	rdprs	r4,r16,18638
81122948:	81123360 	cmpeqi	r4,r16,18637
8112294c:	81123240 	call	88112324 <__reset+0x20f2324>
81122950:	81122990 	cmplti	r4,r16,18598
81122954:	81123260 	cmpeqi	r4,r16,18633
81122958:	811233b8 	rdprs	r4,r16,18638
8112295c:	8112326c 	andhi	r4,r16,18633
81122960:	811233b8 	rdprs	r4,r16,18638
81122964:	811232c8 	cmpgei	r4,r16,18635
81122968:	811233b8 	rdprs	r4,r16,18638
8112296c:	811233b8 	rdprs	r4,r16,18638
81122970:	811232d8 	cmpnei	r4,r16,18635
81122974:	d9003117 	ldw	r4,196(sp)
81122978:	d8802d15 	stw	r2,180(sp)
8112297c:	0109c83a 	sub	r4,zero,r4
81122980:	d9003115 	stw	r4,196(sp)
81122984:	94800114 	ori	r18,r18,4
81122988:	bc400007 	ldb	r17,0(r23)
8112298c:	003f9706 	br	811227ec <__reset+0xfb1027ec>
81122990:	00800c04 	movi	r2,48
81122994:	d9002d17 	ldw	r4,180(sp)
81122998:	d9402917 	ldw	r5,164(sp)
8112299c:	d8802705 	stb	r2,156(sp)
811229a0:	00801e04 	movi	r2,120
811229a4:	d8802745 	stb	r2,157(sp)
811229a8:	d8002785 	stb	zero,158(sp)
811229ac:	20c00104 	addi	r3,r4,4
811229b0:	25000017 	ldw	r20,0(r4)
811229b4:	002d883a 	mov	r22,zero
811229b8:	90800094 	ori	r2,r18,2
811229bc:	28028616 	blt	r5,zero,811233d8 <___svfprintf_internal_r+0xd44>
811229c0:	00bfdfc4 	movi	r2,-129
811229c4:	90a4703a 	and	r18,r18,r2
811229c8:	d8c02d15 	stw	r3,180(sp)
811229cc:	94800094 	ori	r18,r18,2
811229d0:	a002731e 	bne	r20,zero,811233a0 <___svfprintf_internal_r+0xd0c>
811229d4:	00a04574 	movhi	r2,33045
811229d8:	10be9a04 	addi	r2,r2,-1432
811229dc:	d8803a15 	stw	r2,232(sp)
811229e0:	04401e04 	movi	r17,120
811229e4:	d8c02917 	ldw	r3,164(sp)
811229e8:	0039883a 	mov	fp,zero
811229ec:	1801d526 	beq	r3,zero,81123144 <___svfprintf_internal_r+0xab0>
811229f0:	0029883a 	mov	r20,zero
811229f4:	002d883a 	mov	r22,zero
811229f8:	0001f106 	br	811231c0 <___svfprintf_internal_r+0xb2c>
811229fc:	d9402c17 	ldw	r5,176(sp)
81122a00:	d9801e04 	addi	r6,sp,120
81122a04:	9809883a 	mov	r4,r19
81122a08:	112f2b40 	call	8112f2b4 <__ssprint_r>
81122a0c:	1000081e 	bne	r2,zero,81122a30 <___svfprintf_internal_r+0x39c>
81122a10:	da000404 	addi	r8,sp,16
81122a14:	003f6306 	br	811227a4 <__reset+0xfb1027a4>
81122a18:	d8802017 	ldw	r2,128(sp)
81122a1c:	10000426 	beq	r2,zero,81122a30 <___svfprintf_internal_r+0x39c>
81122a20:	d9402c17 	ldw	r5,176(sp)
81122a24:	d9003917 	ldw	r4,228(sp)
81122a28:	d9801e04 	addi	r6,sp,120
81122a2c:	112f2b40 	call	8112f2b4 <__ssprint_r>
81122a30:	d8802c17 	ldw	r2,176(sp)
81122a34:	10c0030b 	ldhu	r3,12(r2)
81122a38:	d8802f17 	ldw	r2,188(sp)
81122a3c:	18c0100c 	andi	r3,r3,64
81122a40:	1805f51e 	bne	r3,zero,81124218 <___svfprintf_internal_r+0x1b84>
81122a44:	dfc04817 	ldw	ra,288(sp)
81122a48:	df004717 	ldw	fp,284(sp)
81122a4c:	ddc04617 	ldw	r23,280(sp)
81122a50:	dd804517 	ldw	r22,276(sp)
81122a54:	dd404417 	ldw	r21,272(sp)
81122a58:	dd004317 	ldw	r20,268(sp)
81122a5c:	dcc04217 	ldw	r19,264(sp)
81122a60:	dc804117 	ldw	r18,260(sp)
81122a64:	dc404017 	ldw	r17,256(sp)
81122a68:	dc003f17 	ldw	r16,252(sp)
81122a6c:	dec04904 	addi	sp,sp,292
81122a70:	f800283a 	ret
81122a74:	d8802d17 	ldw	r2,180(sp)
81122a78:	d9002d17 	ldw	r4,180(sp)
81122a7c:	10800017 	ldw	r2,0(r2)
81122a80:	d8803115 	stw	r2,196(sp)
81122a84:	20800104 	addi	r2,r4,4
81122a88:	d9003117 	ldw	r4,196(sp)
81122a8c:	203fb916 	blt	r4,zero,81122974 <__reset+0xfb102974>
81122a90:	d8802d15 	stw	r2,180(sp)
81122a94:	bc400007 	ldb	r17,0(r23)
81122a98:	003f5406 	br	811227ec <__reset+0xfb1027ec>
81122a9c:	bc400007 	ldb	r17,0(r23)
81122aa0:	bac00044 	addi	r11,r23,1
81122aa4:	8a873926 	beq	r17,r10,8112478c <___svfprintf_internal_r+0x20f8>
81122aa8:	88bff404 	addi	r2,r17,-48
81122aac:	0009883a 	mov	r4,zero
81122ab0:	30868836 	bltu	r6,r2,811244d4 <___svfprintf_internal_r+0x1e40>
81122ab4:	5c400007 	ldb	r17,0(r11)
81122ab8:	210002a4 	muli	r4,r4,10
81122abc:	5dc00044 	addi	r23,r11,1
81122ac0:	b817883a 	mov	r11,r23
81122ac4:	2089883a 	add	r4,r4,r2
81122ac8:	88bff404 	addi	r2,r17,-48
81122acc:	30bff92e 	bgeu	r6,r2,81122ab4 <__reset+0xfb102ab4>
81122ad0:	2005d716 	blt	r4,zero,81124230 <___svfprintf_internal_r+0x1b9c>
81122ad4:	d9002915 	stw	r4,164(sp)
81122ad8:	003f4506 	br	811227f0 <__reset+0xfb1027f0>
81122adc:	b809883a 	mov	r4,r23
81122ae0:	d8003115 	stw	zero,196(sp)
81122ae4:	88bff404 	addi	r2,r17,-48
81122ae8:	0017883a 	mov	r11,zero
81122aec:	24400007 	ldb	r17,0(r4)
81122af0:	5ac002a4 	muli	r11,r11,10
81122af4:	bdc00044 	addi	r23,r23,1
81122af8:	b809883a 	mov	r4,r23
81122afc:	12d7883a 	add	r11,r2,r11
81122b00:	88bff404 	addi	r2,r17,-48
81122b04:	30bff92e 	bgeu	r6,r2,81122aec <__reset+0xfb102aec>
81122b08:	dac03115 	stw	r11,196(sp)
81122b0c:	003f3806 	br	811227f0 <__reset+0xfb1027f0>
81122b10:	94802014 	ori	r18,r18,128
81122b14:	bc400007 	ldb	r17,0(r23)
81122b18:	003f3406 	br	811227ec <__reset+0xfb1027ec>
81122b1c:	18c03fcc 	andi	r3,r3,255
81122b20:	1807471e 	bne	r3,zero,81124840 <___svfprintf_internal_r+0x21ac>
81122b24:	9080020c 	andi	r2,r18,8
81122b28:	10047d26 	beq	r2,zero,81123d20 <___svfprintf_internal_r+0x168c>
81122b2c:	d8c02d17 	ldw	r3,180(sp)
81122b30:	d9002d17 	ldw	r4,180(sp)
81122b34:	d9402d17 	ldw	r5,180(sp)
81122b38:	18c00017 	ldw	r3,0(r3)
81122b3c:	21000117 	ldw	r4,4(r4)
81122b40:	29400204 	addi	r5,r5,8
81122b44:	d8c03615 	stw	r3,216(sp)
81122b48:	d9003715 	stw	r4,220(sp)
81122b4c:	d9402d15 	stw	r5,180(sp)
81122b50:	d9003617 	ldw	r4,216(sp)
81122b54:	d9403717 	ldw	r5,220(sp)
81122b58:	da003e15 	stw	r8,248(sp)
81122b5c:	04000044 	movi	r16,1
81122b60:	112d0c80 	call	8112d0c8 <__fpclassifyd>
81122b64:	da003e17 	ldw	r8,248(sp)
81122b68:	14044b1e 	bne	r2,r16,81123c98 <___svfprintf_internal_r+0x1604>
81122b6c:	d9003617 	ldw	r4,216(sp)
81122b70:	d9403717 	ldw	r5,220(sp)
81122b74:	000d883a 	mov	r6,zero
81122b78:	000f883a 	mov	r7,zero
81122b7c:	11352b80 	call	811352b8 <__ledf2>
81122b80:	da003e17 	ldw	r8,248(sp)
81122b84:	1005f316 	blt	r2,zero,81124354 <___svfprintf_internal_r+0x1cc0>
81122b88:	df002783 	ldbu	fp,158(sp)
81122b8c:	008011c4 	movi	r2,71
81122b90:	1445590e 	bge	r2,r17,811240f8 <___svfprintf_internal_r+0x1a64>
81122b94:	04204574 	movhi	r16,33045
81122b98:	843e9204 	addi	r16,r16,-1464
81122b9c:	00c000c4 	movi	r3,3
81122ba0:	00bfdfc4 	movi	r2,-129
81122ba4:	d8c02a15 	stw	r3,168(sp)
81122ba8:	90a4703a 	and	r18,r18,r2
81122bac:	d8c02e15 	stw	r3,184(sp)
81122bb0:	d8002915 	stw	zero,164(sp)
81122bb4:	d8003215 	stw	zero,200(sp)
81122bb8:	00006606 	br	81122d54 <___svfprintf_internal_r+0x6c0>
81122bbc:	94800214 	ori	r18,r18,8
81122bc0:	bc400007 	ldb	r17,0(r23)
81122bc4:	003f0906 	br	811227ec <__reset+0xfb1027ec>
81122bc8:	18c03fcc 	andi	r3,r3,255
81122bcc:	1807181e 	bne	r3,zero,81124830 <___svfprintf_internal_r+0x219c>
81122bd0:	94800414 	ori	r18,r18,16
81122bd4:	9080080c 	andi	r2,r18,32
81122bd8:	10039626 	beq	r2,zero,81123a34 <___svfprintf_internal_r+0x13a0>
81122bdc:	d9402d17 	ldw	r5,180(sp)
81122be0:	28800117 	ldw	r2,4(r5)
81122be4:	2d000017 	ldw	r20,0(r5)
81122be8:	29400204 	addi	r5,r5,8
81122bec:	d9402d15 	stw	r5,180(sp)
81122bf0:	102d883a 	mov	r22,r2
81122bf4:	10039816 	blt	r2,zero,81123a58 <___svfprintf_internal_r+0x13c4>
81122bf8:	d9402917 	ldw	r5,164(sp)
81122bfc:	df002783 	ldbu	fp,158(sp)
81122c00:	2803ab16 	blt	r5,zero,81123ab0 <___svfprintf_internal_r+0x141c>
81122c04:	00ffdfc4 	movi	r3,-129
81122c08:	a584b03a 	or	r2,r20,r22
81122c0c:	90e4703a 	and	r18,r18,r3
81122c10:	10014a26 	beq	r2,zero,8112313c <___svfprintf_internal_r+0xaa8>
81122c14:	b0034b26 	beq	r22,zero,81123944 <___svfprintf_internal_r+0x12b0>
81122c18:	dc402a15 	stw	r17,168(sp)
81122c1c:	dc001e04 	addi	r16,sp,120
81122c20:	b023883a 	mov	r17,r22
81122c24:	402d883a 	mov	r22,r8
81122c28:	a009883a 	mov	r4,r20
81122c2c:	880b883a 	mov	r5,r17
81122c30:	01800284 	movi	r6,10
81122c34:	000f883a 	mov	r7,zero
81122c38:	113379c0 	call	8113379c <__umoddi3>
81122c3c:	10800c04 	addi	r2,r2,48
81122c40:	843fffc4 	addi	r16,r16,-1
81122c44:	a009883a 	mov	r4,r20
81122c48:	880b883a 	mov	r5,r17
81122c4c:	80800005 	stb	r2,0(r16)
81122c50:	01800284 	movi	r6,10
81122c54:	000f883a 	mov	r7,zero
81122c58:	113321c0 	call	8113321c <__udivdi3>
81122c5c:	1029883a 	mov	r20,r2
81122c60:	10c4b03a 	or	r2,r2,r3
81122c64:	1823883a 	mov	r17,r3
81122c68:	103fef1e 	bne	r2,zero,81122c28 <__reset+0xfb102c28>
81122c6c:	d8c02817 	ldw	r3,160(sp)
81122c70:	dc402a17 	ldw	r17,168(sp)
81122c74:	b011883a 	mov	r8,r22
81122c78:	1c07c83a 	sub	r3,r3,r16
81122c7c:	d8c02e15 	stw	r3,184(sp)
81122c80:	00002e06 	br	81122d3c <___svfprintf_internal_r+0x6a8>
81122c84:	18c03fcc 	andi	r3,r3,255
81122c88:	1806e71e 	bne	r3,zero,81124828 <___svfprintf_internal_r+0x2194>
81122c8c:	94800414 	ori	r18,r18,16
81122c90:	9080080c 	andi	r2,r18,32
81122c94:	1002d426 	beq	r2,zero,811237e8 <___svfprintf_internal_r+0x1154>
81122c98:	d9402d17 	ldw	r5,180(sp)
81122c9c:	d8c02917 	ldw	r3,164(sp)
81122ca0:	d8002785 	stb	zero,158(sp)
81122ca4:	28800204 	addi	r2,r5,8
81122ca8:	2d000017 	ldw	r20,0(r5)
81122cac:	2d800117 	ldw	r22,4(r5)
81122cb0:	18041516 	blt	r3,zero,81123d08 <___svfprintf_internal_r+0x1674>
81122cb4:	013fdfc4 	movi	r4,-129
81122cb8:	a586b03a 	or	r3,r20,r22
81122cbc:	d8802d15 	stw	r2,180(sp)
81122cc0:	9124703a 	and	r18,r18,r4
81122cc4:	1802d51e 	bne	r3,zero,8112381c <___svfprintf_internal_r+0x1188>
81122cc8:	d9402917 	ldw	r5,164(sp)
81122ccc:	0039883a 	mov	fp,zero
81122cd0:	2806be26 	beq	r5,zero,811247cc <___svfprintf_internal_r+0x2138>
81122cd4:	0029883a 	mov	r20,zero
81122cd8:	002d883a 	mov	r22,zero
81122cdc:	dc001e04 	addi	r16,sp,120
81122ce0:	a006d0fa 	srli	r3,r20,3
81122ce4:	b008977a 	slli	r4,r22,29
81122ce8:	b02cd0fa 	srli	r22,r22,3
81122cec:	a50001cc 	andi	r20,r20,7
81122cf0:	a0800c04 	addi	r2,r20,48
81122cf4:	843fffc4 	addi	r16,r16,-1
81122cf8:	20e8b03a 	or	r20,r4,r3
81122cfc:	80800005 	stb	r2,0(r16)
81122d00:	a586b03a 	or	r3,r20,r22
81122d04:	183ff61e 	bne	r3,zero,81122ce0 <__reset+0xfb102ce0>
81122d08:	90c0004c 	andi	r3,r18,1
81122d0c:	18013926 	beq	r3,zero,811231f4 <___svfprintf_internal_r+0xb60>
81122d10:	10803fcc 	andi	r2,r2,255
81122d14:	1080201c 	xori	r2,r2,128
81122d18:	10bfe004 	addi	r2,r2,-128
81122d1c:	00c00c04 	movi	r3,48
81122d20:	10c13426 	beq	r2,r3,811231f4 <___svfprintf_internal_r+0xb60>
81122d24:	80ffffc5 	stb	r3,-1(r16)
81122d28:	d8c02817 	ldw	r3,160(sp)
81122d2c:	80bfffc4 	addi	r2,r16,-1
81122d30:	1021883a 	mov	r16,r2
81122d34:	1887c83a 	sub	r3,r3,r2
81122d38:	d8c02e15 	stw	r3,184(sp)
81122d3c:	d8802e17 	ldw	r2,184(sp)
81122d40:	d9002917 	ldw	r4,164(sp)
81122d44:	1100010e 	bge	r2,r4,81122d4c <___svfprintf_internal_r+0x6b8>
81122d48:	2005883a 	mov	r2,r4
81122d4c:	d8802a15 	stw	r2,168(sp)
81122d50:	d8003215 	stw	zero,200(sp)
81122d54:	e7003fcc 	andi	fp,fp,255
81122d58:	e700201c 	xori	fp,fp,128
81122d5c:	e73fe004 	addi	fp,fp,-128
81122d60:	e0000326 	beq	fp,zero,81122d70 <___svfprintf_internal_r+0x6dc>
81122d64:	d8c02a17 	ldw	r3,168(sp)
81122d68:	18c00044 	addi	r3,r3,1
81122d6c:	d8c02a15 	stw	r3,168(sp)
81122d70:	90c0008c 	andi	r3,r18,2
81122d74:	d8c02b15 	stw	r3,172(sp)
81122d78:	18000326 	beq	r3,zero,81122d88 <___svfprintf_internal_r+0x6f4>
81122d7c:	d8c02a17 	ldw	r3,168(sp)
81122d80:	18c00084 	addi	r3,r3,2
81122d84:	d8c02a15 	stw	r3,168(sp)
81122d88:	90c0210c 	andi	r3,r18,132
81122d8c:	d8c03015 	stw	r3,192(sp)
81122d90:	1801a11e 	bne	r3,zero,81123418 <___svfprintf_internal_r+0xd84>
81122d94:	d9003117 	ldw	r4,196(sp)
81122d98:	d8c02a17 	ldw	r3,168(sp)
81122d9c:	20e9c83a 	sub	r20,r4,r3
81122da0:	05019d0e 	bge	zero,r20,81123418 <___svfprintf_internal_r+0xd84>
81122da4:	02400404 	movi	r9,16
81122da8:	d8c02017 	ldw	r3,128(sp)
81122dac:	d8801f17 	ldw	r2,124(sp)
81122db0:	4d051b0e 	bge	r9,r20,81124220 <___svfprintf_internal_r+0x1b8c>
81122db4:	01604574 	movhi	r5,33045
81122db8:	297ea584 	addi	r5,r5,-1386
81122dbc:	dc403c15 	stw	r17,240(sp)
81122dc0:	d9403515 	stw	r5,212(sp)
81122dc4:	a023883a 	mov	r17,r20
81122dc8:	482d883a 	mov	r22,r9
81122dcc:	9029883a 	mov	r20,r18
81122dd0:	070001c4 	movi	fp,7
81122dd4:	8025883a 	mov	r18,r16
81122dd8:	dc002c17 	ldw	r16,176(sp)
81122ddc:	00000306 	br	81122dec <___svfprintf_internal_r+0x758>
81122de0:	8c7ffc04 	addi	r17,r17,-16
81122de4:	42000204 	addi	r8,r8,8
81122de8:	b440130e 	bge	r22,r17,81122e38 <___svfprintf_internal_r+0x7a4>
81122dec:	01204574 	movhi	r4,33045
81122df0:	18c00404 	addi	r3,r3,16
81122df4:	10800044 	addi	r2,r2,1
81122df8:	213ea584 	addi	r4,r4,-1386
81122dfc:	41000015 	stw	r4,0(r8)
81122e00:	45800115 	stw	r22,4(r8)
81122e04:	d8c02015 	stw	r3,128(sp)
81122e08:	d8801f15 	stw	r2,124(sp)
81122e0c:	e0bff40e 	bge	fp,r2,81122de0 <__reset+0xfb102de0>
81122e10:	d9801e04 	addi	r6,sp,120
81122e14:	800b883a 	mov	r5,r16
81122e18:	9809883a 	mov	r4,r19
81122e1c:	112f2b40 	call	8112f2b4 <__ssprint_r>
81122e20:	103f031e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
81122e24:	8c7ffc04 	addi	r17,r17,-16
81122e28:	d8c02017 	ldw	r3,128(sp)
81122e2c:	d8801f17 	ldw	r2,124(sp)
81122e30:	da000404 	addi	r8,sp,16
81122e34:	b47fed16 	blt	r22,r17,81122dec <__reset+0xfb102dec>
81122e38:	9021883a 	mov	r16,r18
81122e3c:	a025883a 	mov	r18,r20
81122e40:	8829883a 	mov	r20,r17
81122e44:	dc403c17 	ldw	r17,240(sp)
81122e48:	d9403517 	ldw	r5,212(sp)
81122e4c:	a0c7883a 	add	r3,r20,r3
81122e50:	10800044 	addi	r2,r2,1
81122e54:	41400015 	stw	r5,0(r8)
81122e58:	45000115 	stw	r20,4(r8)
81122e5c:	d8c02015 	stw	r3,128(sp)
81122e60:	d8801f15 	stw	r2,124(sp)
81122e64:	010001c4 	movi	r4,7
81122e68:	20829f16 	blt	r4,r2,811238e8 <___svfprintf_internal_r+0x1254>
81122e6c:	df002787 	ldb	fp,158(sp)
81122e70:	42000204 	addi	r8,r8,8
81122e74:	e0000c26 	beq	fp,zero,81122ea8 <___svfprintf_internal_r+0x814>
81122e78:	d8801f17 	ldw	r2,124(sp)
81122e7c:	d9002784 	addi	r4,sp,158
81122e80:	18c00044 	addi	r3,r3,1
81122e84:	10800044 	addi	r2,r2,1
81122e88:	41000015 	stw	r4,0(r8)
81122e8c:	01000044 	movi	r4,1
81122e90:	41000115 	stw	r4,4(r8)
81122e94:	d8c02015 	stw	r3,128(sp)
81122e98:	d8801f15 	stw	r2,124(sp)
81122e9c:	010001c4 	movi	r4,7
81122ea0:	20823816 	blt	r4,r2,81123784 <___svfprintf_internal_r+0x10f0>
81122ea4:	42000204 	addi	r8,r8,8
81122ea8:	d8802b17 	ldw	r2,172(sp)
81122eac:	10000c26 	beq	r2,zero,81122ee0 <___svfprintf_internal_r+0x84c>
81122eb0:	d8801f17 	ldw	r2,124(sp)
81122eb4:	d9002704 	addi	r4,sp,156
81122eb8:	18c00084 	addi	r3,r3,2
81122ebc:	10800044 	addi	r2,r2,1
81122ec0:	41000015 	stw	r4,0(r8)
81122ec4:	01000084 	movi	r4,2
81122ec8:	41000115 	stw	r4,4(r8)
81122ecc:	d8c02015 	stw	r3,128(sp)
81122ed0:	d8801f15 	stw	r2,124(sp)
81122ed4:	010001c4 	movi	r4,7
81122ed8:	20823216 	blt	r4,r2,811237a4 <___svfprintf_internal_r+0x1110>
81122edc:	42000204 	addi	r8,r8,8
81122ee0:	d9003017 	ldw	r4,192(sp)
81122ee4:	00802004 	movi	r2,128
81122ee8:	20819726 	beq	r4,r2,81123548 <___svfprintf_internal_r+0xeb4>
81122eec:	d9402917 	ldw	r5,164(sp)
81122ef0:	d8802e17 	ldw	r2,184(sp)
81122ef4:	28adc83a 	sub	r22,r5,r2
81122ef8:	05802f0e 	bge	zero,r22,81122fb8 <___svfprintf_internal_r+0x924>
81122efc:	07000404 	movi	fp,16
81122f00:	d8801f17 	ldw	r2,124(sp)
81122f04:	e583c00e 	bge	fp,r22,81123e08 <___svfprintf_internal_r+0x1774>
81122f08:	01604574 	movhi	r5,33045
81122f0c:	297ea184 	addi	r5,r5,-1402
81122f10:	dc402915 	stw	r17,164(sp)
81122f14:	d9402b15 	stw	r5,172(sp)
81122f18:	b023883a 	mov	r17,r22
81122f1c:	050001c4 	movi	r20,7
81122f20:	902d883a 	mov	r22,r18
81122f24:	8025883a 	mov	r18,r16
81122f28:	dc002c17 	ldw	r16,176(sp)
81122f2c:	00000306 	br	81122f3c <___svfprintf_internal_r+0x8a8>
81122f30:	8c7ffc04 	addi	r17,r17,-16
81122f34:	42000204 	addi	r8,r8,8
81122f38:	e440110e 	bge	fp,r17,81122f80 <___svfprintf_internal_r+0x8ec>
81122f3c:	18c00404 	addi	r3,r3,16
81122f40:	10800044 	addi	r2,r2,1
81122f44:	45400015 	stw	r21,0(r8)
81122f48:	47000115 	stw	fp,4(r8)
81122f4c:	d8c02015 	stw	r3,128(sp)
81122f50:	d8801f15 	stw	r2,124(sp)
81122f54:	a0bff60e 	bge	r20,r2,81122f30 <__reset+0xfb102f30>
81122f58:	d9801e04 	addi	r6,sp,120
81122f5c:	800b883a 	mov	r5,r16
81122f60:	9809883a 	mov	r4,r19
81122f64:	112f2b40 	call	8112f2b4 <__ssprint_r>
81122f68:	103eb11e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
81122f6c:	8c7ffc04 	addi	r17,r17,-16
81122f70:	d8c02017 	ldw	r3,128(sp)
81122f74:	d8801f17 	ldw	r2,124(sp)
81122f78:	da000404 	addi	r8,sp,16
81122f7c:	e47fef16 	blt	fp,r17,81122f3c <__reset+0xfb102f3c>
81122f80:	9021883a 	mov	r16,r18
81122f84:	b025883a 	mov	r18,r22
81122f88:	882d883a 	mov	r22,r17
81122f8c:	dc402917 	ldw	r17,164(sp)
81122f90:	d9002b17 	ldw	r4,172(sp)
81122f94:	1d87883a 	add	r3,r3,r22
81122f98:	10800044 	addi	r2,r2,1
81122f9c:	41000015 	stw	r4,0(r8)
81122fa0:	45800115 	stw	r22,4(r8)
81122fa4:	d8c02015 	stw	r3,128(sp)
81122fa8:	d8801f15 	stw	r2,124(sp)
81122fac:	010001c4 	movi	r4,7
81122fb0:	2081ec16 	blt	r4,r2,81123764 <___svfprintf_internal_r+0x10d0>
81122fb4:	42000204 	addi	r8,r8,8
81122fb8:	9080400c 	andi	r2,r18,256
81122fbc:	1001181e 	bne	r2,zero,81123420 <___svfprintf_internal_r+0xd8c>
81122fc0:	d9402e17 	ldw	r5,184(sp)
81122fc4:	d8801f17 	ldw	r2,124(sp)
81122fc8:	44000015 	stw	r16,0(r8)
81122fcc:	1947883a 	add	r3,r3,r5
81122fd0:	10800044 	addi	r2,r2,1
81122fd4:	41400115 	stw	r5,4(r8)
81122fd8:	d8c02015 	stw	r3,128(sp)
81122fdc:	d8801f15 	stw	r2,124(sp)
81122fe0:	010001c4 	movi	r4,7
81122fe4:	2081d116 	blt	r4,r2,8112372c <___svfprintf_internal_r+0x1098>
81122fe8:	42000204 	addi	r8,r8,8
81122fec:	9480010c 	andi	r18,r18,4
81122ff0:	90003226 	beq	r18,zero,811230bc <___svfprintf_internal_r+0xa28>
81122ff4:	d9403117 	ldw	r5,196(sp)
81122ff8:	d8802a17 	ldw	r2,168(sp)
81122ffc:	28a1c83a 	sub	r16,r5,r2
81123000:	04002e0e 	bge	zero,r16,811230bc <___svfprintf_internal_r+0xa28>
81123004:	04400404 	movi	r17,16
81123008:	d8801f17 	ldw	r2,124(sp)
8112300c:	8c04b90e 	bge	r17,r16,811242f4 <___svfprintf_internal_r+0x1c60>
81123010:	01604574 	movhi	r5,33045
81123014:	297ea584 	addi	r5,r5,-1386
81123018:	d9403515 	stw	r5,212(sp)
8112301c:	048001c4 	movi	r18,7
81123020:	dd002c17 	ldw	r20,176(sp)
81123024:	00000306 	br	81123034 <___svfprintf_internal_r+0x9a0>
81123028:	843ffc04 	addi	r16,r16,-16
8112302c:	42000204 	addi	r8,r8,8
81123030:	8c00130e 	bge	r17,r16,81123080 <___svfprintf_internal_r+0x9ec>
81123034:	01204574 	movhi	r4,33045
81123038:	18c00404 	addi	r3,r3,16
8112303c:	10800044 	addi	r2,r2,1
81123040:	213ea584 	addi	r4,r4,-1386
81123044:	41000015 	stw	r4,0(r8)
81123048:	44400115 	stw	r17,4(r8)
8112304c:	d8c02015 	stw	r3,128(sp)
81123050:	d8801f15 	stw	r2,124(sp)
81123054:	90bff40e 	bge	r18,r2,81123028 <__reset+0xfb103028>
81123058:	d9801e04 	addi	r6,sp,120
8112305c:	a00b883a 	mov	r5,r20
81123060:	9809883a 	mov	r4,r19
81123064:	112f2b40 	call	8112f2b4 <__ssprint_r>
81123068:	103e711e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
8112306c:	843ffc04 	addi	r16,r16,-16
81123070:	d8c02017 	ldw	r3,128(sp)
81123074:	d8801f17 	ldw	r2,124(sp)
81123078:	da000404 	addi	r8,sp,16
8112307c:	8c3fed16 	blt	r17,r16,81123034 <__reset+0xfb103034>
81123080:	d9403517 	ldw	r5,212(sp)
81123084:	1c07883a 	add	r3,r3,r16
81123088:	10800044 	addi	r2,r2,1
8112308c:	41400015 	stw	r5,0(r8)
81123090:	44000115 	stw	r16,4(r8)
81123094:	d8c02015 	stw	r3,128(sp)
81123098:	d8801f15 	stw	r2,124(sp)
8112309c:	010001c4 	movi	r4,7
811230a0:	2080060e 	bge	r4,r2,811230bc <___svfprintf_internal_r+0xa28>
811230a4:	d9402c17 	ldw	r5,176(sp)
811230a8:	d9801e04 	addi	r6,sp,120
811230ac:	9809883a 	mov	r4,r19
811230b0:	112f2b40 	call	8112f2b4 <__ssprint_r>
811230b4:	103e5e1e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
811230b8:	d8c02017 	ldw	r3,128(sp)
811230bc:	d8803117 	ldw	r2,196(sp)
811230c0:	d9002a17 	ldw	r4,168(sp)
811230c4:	1100010e 	bge	r2,r4,811230cc <___svfprintf_internal_r+0xa38>
811230c8:	2005883a 	mov	r2,r4
811230cc:	d9402f17 	ldw	r5,188(sp)
811230d0:	288b883a 	add	r5,r5,r2
811230d4:	d9402f15 	stw	r5,188(sp)
811230d8:	18019c1e 	bne	r3,zero,8112374c <___svfprintf_internal_r+0x10b8>
811230dc:	b8800007 	ldb	r2,0(r23)
811230e0:	d8001f15 	stw	zero,124(sp)
811230e4:	da000404 	addi	r8,sp,16
811230e8:	103d991e 	bne	r2,zero,81122750 <__reset+0xfb102750>
811230ec:	b821883a 	mov	r16,r23
811230f0:	003daf06 	br	811227b0 <__reset+0xfb1027b0>
811230f4:	18c03fcc 	andi	r3,r3,255
811230f8:	1805c71e 	bne	r3,zero,81124818 <___svfprintf_internal_r+0x2184>
811230fc:	94800414 	ori	r18,r18,16
81123100:	9080080c 	andi	r2,r18,32
81123104:	10020126 	beq	r2,zero,8112390c <___svfprintf_internal_r+0x1278>
81123108:	d8802d17 	ldw	r2,180(sp)
8112310c:	d9002917 	ldw	r4,164(sp)
81123110:	d8002785 	stb	zero,158(sp)
81123114:	10c00204 	addi	r3,r2,8
81123118:	15000017 	ldw	r20,0(r2)
8112311c:	15800117 	ldw	r22,4(r2)
81123120:	20038e16 	blt	r4,zero,81123f5c <___svfprintf_internal_r+0x18c8>
81123124:	013fdfc4 	movi	r4,-129
81123128:	a584b03a 	or	r2,r20,r22
8112312c:	d8c02d15 	stw	r3,180(sp)
81123130:	9124703a 	and	r18,r18,r4
81123134:	0039883a 	mov	fp,zero
81123138:	103eb61e 	bne	r2,zero,81122c14 <__reset+0xfb102c14>
8112313c:	d8802917 	ldw	r2,164(sp)
81123140:	1002c81e 	bne	r2,zero,81123c64 <___svfprintf_internal_r+0x15d0>
81123144:	d8002915 	stw	zero,164(sp)
81123148:	d8002e15 	stw	zero,184(sp)
8112314c:	dc001e04 	addi	r16,sp,120
81123150:	003efa06 	br	81122d3c <__reset+0xfb102d3c>
81123154:	18c03fcc 	andi	r3,r3,255
81123158:	1805ad1e 	bne	r3,zero,81124810 <___svfprintf_internal_r+0x217c>
8112315c:	01604574 	movhi	r5,33045
81123160:	297e9504 	addi	r5,r5,-1452
81123164:	d9403a15 	stw	r5,232(sp)
81123168:	9080080c 	andi	r2,r18,32
8112316c:	10006126 	beq	r2,zero,811232f4 <___svfprintf_internal_r+0xc60>
81123170:	d8802d17 	ldw	r2,180(sp)
81123174:	15000017 	ldw	r20,0(r2)
81123178:	15800117 	ldw	r22,4(r2)
8112317c:	10800204 	addi	r2,r2,8
81123180:	d8802d15 	stw	r2,180(sp)
81123184:	9080004c 	andi	r2,r18,1
81123188:	10018e26 	beq	r2,zero,811237c4 <___svfprintf_internal_r+0x1130>
8112318c:	a584b03a 	or	r2,r20,r22
81123190:	10030926 	beq	r2,zero,81123db8 <___svfprintf_internal_r+0x1724>
81123194:	d8c02917 	ldw	r3,164(sp)
81123198:	00800c04 	movi	r2,48
8112319c:	d8802705 	stb	r2,156(sp)
811231a0:	dc402745 	stb	r17,157(sp)
811231a4:	d8002785 	stb	zero,158(sp)
811231a8:	90800094 	ori	r2,r18,2
811231ac:	18048716 	blt	r3,zero,811243cc <___svfprintf_internal_r+0x1d38>
811231b0:	00bfdfc4 	movi	r2,-129
811231b4:	90a4703a 	and	r18,r18,r2
811231b8:	94800094 	ori	r18,r18,2
811231bc:	0039883a 	mov	fp,zero
811231c0:	d9003a17 	ldw	r4,232(sp)
811231c4:	dc001e04 	addi	r16,sp,120
811231c8:	a08003cc 	andi	r2,r20,15
811231cc:	b006973a 	slli	r3,r22,28
811231d0:	2085883a 	add	r2,r4,r2
811231d4:	a028d13a 	srli	r20,r20,4
811231d8:	10800003 	ldbu	r2,0(r2)
811231dc:	b02cd13a 	srli	r22,r22,4
811231e0:	843fffc4 	addi	r16,r16,-1
811231e4:	1d28b03a 	or	r20,r3,r20
811231e8:	80800005 	stb	r2,0(r16)
811231ec:	a584b03a 	or	r2,r20,r22
811231f0:	103ff51e 	bne	r2,zero,811231c8 <__reset+0xfb1031c8>
811231f4:	d8c02817 	ldw	r3,160(sp)
811231f8:	1c07c83a 	sub	r3,r3,r16
811231fc:	d8c02e15 	stw	r3,184(sp)
81123200:	003ece06 	br	81122d3c <__reset+0xfb102d3c>
81123204:	d8c02d17 	ldw	r3,180(sp)
81123208:	d9002d17 	ldw	r4,180(sp)
8112320c:	d8002785 	stb	zero,158(sp)
81123210:	18800017 	ldw	r2,0(r3)
81123214:	21000104 	addi	r4,r4,4
81123218:	00c00044 	movi	r3,1
8112321c:	d8c02a15 	stw	r3,168(sp)
81123220:	d8801405 	stb	r2,80(sp)
81123224:	d9002d15 	stw	r4,180(sp)
81123228:	d8c02e15 	stw	r3,184(sp)
8112322c:	d8002915 	stw	zero,164(sp)
81123230:	d8003215 	stw	zero,200(sp)
81123234:	dc001404 	addi	r16,sp,80
81123238:	0039883a 	mov	fp,zero
8112323c:	003ecc06 	br	81122d70 <__reset+0xfb102d70>
81123240:	18c03fcc 	andi	r3,r3,255
81123244:	183e9226 	beq	r3,zero,81122c90 <__reset+0xfb102c90>
81123248:	d9c02785 	stb	r7,158(sp)
8112324c:	003e9006 	br	81122c90 <__reset+0xfb102c90>
81123250:	00c00044 	movi	r3,1
81123254:	01c00ac4 	movi	r7,43
81123258:	bc400007 	ldb	r17,0(r23)
8112325c:	003d6306 	br	811227ec <__reset+0xfb1027ec>
81123260:	94800814 	ori	r18,r18,32
81123264:	bc400007 	ldb	r17,0(r23)
81123268:	003d6006 	br	811227ec <__reset+0xfb1027ec>
8112326c:	d8c02d17 	ldw	r3,180(sp)
81123270:	d8002785 	stb	zero,158(sp)
81123274:	1c000017 	ldw	r16,0(r3)
81123278:	1d000104 	addi	r20,r3,4
8112327c:	80040f26 	beq	r16,zero,811242bc <___svfprintf_internal_r+0x1c28>
81123280:	d9002917 	ldw	r4,164(sp)
81123284:	2003dc16 	blt	r4,zero,811241f8 <___svfprintf_internal_r+0x1b64>
81123288:	200d883a 	mov	r6,r4
8112328c:	000b883a 	mov	r5,zero
81123290:	8009883a 	mov	r4,r16
81123294:	da003e15 	stw	r8,248(sp)
81123298:	112b8580 	call	8112b858 <memchr>
8112329c:	da003e17 	ldw	r8,248(sp)
811232a0:	10045826 	beq	r2,zero,81124404 <___svfprintf_internal_r+0x1d70>
811232a4:	1405c83a 	sub	r2,r2,r16
811232a8:	d8802e15 	stw	r2,184(sp)
811232ac:	1003d816 	blt	r2,zero,81124210 <___svfprintf_internal_r+0x1b7c>
811232b0:	df002783 	ldbu	fp,158(sp)
811232b4:	d8802a15 	stw	r2,168(sp)
811232b8:	dd002d15 	stw	r20,180(sp)
811232bc:	d8002915 	stw	zero,164(sp)
811232c0:	d8003215 	stw	zero,200(sp)
811232c4:	003ea306 	br	81122d54 <__reset+0xfb102d54>
811232c8:	18c03fcc 	andi	r3,r3,255
811232cc:	183f8c26 	beq	r3,zero,81123100 <__reset+0xfb103100>
811232d0:	d9c02785 	stb	r7,158(sp)
811232d4:	003f8a06 	br	81123100 <__reset+0xfb103100>
811232d8:	18c03fcc 	andi	r3,r3,255
811232dc:	1805631e 	bne	r3,zero,8112486c <___svfprintf_internal_r+0x21d8>
811232e0:	01604574 	movhi	r5,33045
811232e4:	297e9a04 	addi	r5,r5,-1432
811232e8:	d9403a15 	stw	r5,232(sp)
811232ec:	9080080c 	andi	r2,r18,32
811232f0:	103f9f1e 	bne	r2,zero,81123170 <__reset+0xfb103170>
811232f4:	9080040c 	andi	r2,r18,16
811232f8:	10029c26 	beq	r2,zero,81123d6c <___svfprintf_internal_r+0x16d8>
811232fc:	d8c02d17 	ldw	r3,180(sp)
81123300:	002d883a 	mov	r22,zero
81123304:	1d000017 	ldw	r20,0(r3)
81123308:	18c00104 	addi	r3,r3,4
8112330c:	d8c02d15 	stw	r3,180(sp)
81123310:	003f9c06 	br	81123184 <__reset+0xfb103184>
81123314:	94800054 	ori	r18,r18,1
81123318:	bc400007 	ldb	r17,0(r23)
8112331c:	003d3306 	br	811227ec <__reset+0xfb1027ec>
81123320:	38803fcc 	andi	r2,r7,255
81123324:	1080201c 	xori	r2,r2,128
81123328:	10bfe004 	addi	r2,r2,-128
8112332c:	1002971e 	bne	r2,zero,81123d8c <___svfprintf_internal_r+0x16f8>
81123330:	00c00044 	movi	r3,1
81123334:	01c00804 	movi	r7,32
81123338:	bc400007 	ldb	r17,0(r23)
8112333c:	003d2b06 	br	811227ec <__reset+0xfb1027ec>
81123340:	18c03fcc 	andi	r3,r3,255
81123344:	183e2326 	beq	r3,zero,81122bd4 <__reset+0xfb102bd4>
81123348:	d9c02785 	stb	r7,158(sp)
8112334c:	003e2106 	br	81122bd4 <__reset+0xfb102bd4>
81123350:	bc400007 	ldb	r17,0(r23)
81123354:	8a430426 	beq	r17,r9,81123f68 <___svfprintf_internal_r+0x18d4>
81123358:	94800414 	ori	r18,r18,16
8112335c:	003d2306 	br	811227ec <__reset+0xfb1027ec>
81123360:	18c03fcc 	andi	r3,r3,255
81123364:	18053f1e 	bne	r3,zero,81124864 <___svfprintf_internal_r+0x21d0>
81123368:	9080080c 	andi	r2,r18,32
8112336c:	10028926 	beq	r2,zero,81123d94 <___svfprintf_internal_r+0x1700>
81123370:	d9402d17 	ldw	r5,180(sp)
81123374:	d9002f17 	ldw	r4,188(sp)
81123378:	28800017 	ldw	r2,0(r5)
8112337c:	2007d7fa 	srai	r3,r4,31
81123380:	29400104 	addi	r5,r5,4
81123384:	d9402d15 	stw	r5,180(sp)
81123388:	11000015 	stw	r4,0(r2)
8112338c:	10c00115 	stw	r3,4(r2)
81123390:	003ced06 	br	81122748 <__reset+0xfb102748>
81123394:	94801014 	ori	r18,r18,64
81123398:	bc400007 	ldb	r17,0(r23)
8112339c:	003d1306 	br	811227ec <__reset+0xfb1027ec>
811233a0:	01204574 	movhi	r4,33045
811233a4:	213e9a04 	addi	r4,r4,-1432
811233a8:	0039883a 	mov	fp,zero
811233ac:	d9003a15 	stw	r4,232(sp)
811233b0:	04401e04 	movi	r17,120
811233b4:	003f8206 	br	811231c0 <__reset+0xfb1031c0>
811233b8:	18c03fcc 	andi	r3,r3,255
811233bc:	1805221e 	bne	r3,zero,81124848 <___svfprintf_internal_r+0x21b4>
811233c0:	883d9526 	beq	r17,zero,81122a18 <__reset+0xfb102a18>
811233c4:	00c00044 	movi	r3,1
811233c8:	d8c02a15 	stw	r3,168(sp)
811233cc:	dc401405 	stb	r17,80(sp)
811233d0:	d8002785 	stb	zero,158(sp)
811233d4:	003f9406 	br	81123228 <__reset+0xfb103228>
811233d8:	01204574 	movhi	r4,33045
811233dc:	213e9a04 	addi	r4,r4,-1432
811233e0:	d9003a15 	stw	r4,232(sp)
811233e4:	d8c02d15 	stw	r3,180(sp)
811233e8:	1025883a 	mov	r18,r2
811233ec:	04401e04 	movi	r17,120
811233f0:	a584b03a 	or	r2,r20,r22
811233f4:	1000fa1e 	bne	r2,zero,811237e0 <___svfprintf_internal_r+0x114c>
811233f8:	0039883a 	mov	fp,zero
811233fc:	00800084 	movi	r2,2
81123400:	10803fcc 	andi	r2,r2,255
81123404:	00c00044 	movi	r3,1
81123408:	10c21626 	beq	r2,r3,81123c64 <___svfprintf_internal_r+0x15d0>
8112340c:	00c00084 	movi	r3,2
81123410:	10fe301e 	bne	r2,r3,81122cd4 <__reset+0xfb102cd4>
81123414:	003d7606 	br	811229f0 <__reset+0xfb1029f0>
81123418:	d8c02017 	ldw	r3,128(sp)
8112341c:	003e9506 	br	81122e74 <__reset+0xfb102e74>
81123420:	00801944 	movi	r2,101
81123424:	14407c0e 	bge	r2,r17,81123618 <___svfprintf_internal_r+0xf84>
81123428:	d9003617 	ldw	r4,216(sp)
8112342c:	d9403717 	ldw	r5,220(sp)
81123430:	000d883a 	mov	r6,zero
81123434:	000f883a 	mov	r7,zero
81123438:	d8c03d15 	stw	r3,244(sp)
8112343c:	da003e15 	stw	r8,248(sp)
81123440:	11352300 	call	81135230 <__eqdf2>
81123444:	d8c03d17 	ldw	r3,244(sp)
81123448:	da003e17 	ldw	r8,248(sp)
8112344c:	1000f51e 	bne	r2,zero,81123824 <___svfprintf_internal_r+0x1190>
81123450:	d8801f17 	ldw	r2,124(sp)
81123454:	01204574 	movhi	r4,33045
81123458:	213ea104 	addi	r4,r4,-1404
8112345c:	18c00044 	addi	r3,r3,1
81123460:	10800044 	addi	r2,r2,1
81123464:	41000015 	stw	r4,0(r8)
81123468:	01000044 	movi	r4,1
8112346c:	41000115 	stw	r4,4(r8)
81123470:	d8c02015 	stw	r3,128(sp)
81123474:	d8801f15 	stw	r2,124(sp)
81123478:	010001c4 	movi	r4,7
8112347c:	20826616 	blt	r4,r2,81123e18 <___svfprintf_internal_r+0x1784>
81123480:	42000204 	addi	r8,r8,8
81123484:	d8802617 	ldw	r2,152(sp)
81123488:	d9403317 	ldw	r5,204(sp)
8112348c:	11400216 	blt	r2,r5,81123498 <___svfprintf_internal_r+0xe04>
81123490:	9080004c 	andi	r2,r18,1
81123494:	103ed526 	beq	r2,zero,81122fec <__reset+0xfb102fec>
81123498:	d8803817 	ldw	r2,224(sp)
8112349c:	d9003417 	ldw	r4,208(sp)
811234a0:	d9403817 	ldw	r5,224(sp)
811234a4:	1887883a 	add	r3,r3,r2
811234a8:	d8801f17 	ldw	r2,124(sp)
811234ac:	41000015 	stw	r4,0(r8)
811234b0:	41400115 	stw	r5,4(r8)
811234b4:	10800044 	addi	r2,r2,1
811234b8:	d8c02015 	stw	r3,128(sp)
811234bc:	d8801f15 	stw	r2,124(sp)
811234c0:	010001c4 	movi	r4,7
811234c4:	2082af16 	blt	r4,r2,81123f84 <___svfprintf_internal_r+0x18f0>
811234c8:	42000204 	addi	r8,r8,8
811234cc:	d8803317 	ldw	r2,204(sp)
811234d0:	143fffc4 	addi	r16,r2,-1
811234d4:	043ec50e 	bge	zero,r16,81122fec <__reset+0xfb102fec>
811234d8:	04400404 	movi	r17,16
811234dc:	d8801f17 	ldw	r2,124(sp)
811234e0:	8c00860e 	bge	r17,r16,811236fc <___svfprintf_internal_r+0x1068>
811234e4:	01604574 	movhi	r5,33045
811234e8:	297ea184 	addi	r5,r5,-1402
811234ec:	d9402b15 	stw	r5,172(sp)
811234f0:	058001c4 	movi	r22,7
811234f4:	dd002c17 	ldw	r20,176(sp)
811234f8:	00000306 	br	81123508 <___svfprintf_internal_r+0xe74>
811234fc:	42000204 	addi	r8,r8,8
81123500:	843ffc04 	addi	r16,r16,-16
81123504:	8c00800e 	bge	r17,r16,81123708 <___svfprintf_internal_r+0x1074>
81123508:	18c00404 	addi	r3,r3,16
8112350c:	10800044 	addi	r2,r2,1
81123510:	45400015 	stw	r21,0(r8)
81123514:	44400115 	stw	r17,4(r8)
81123518:	d8c02015 	stw	r3,128(sp)
8112351c:	d8801f15 	stw	r2,124(sp)
81123520:	b0bff60e 	bge	r22,r2,811234fc <__reset+0xfb1034fc>
81123524:	d9801e04 	addi	r6,sp,120
81123528:	a00b883a 	mov	r5,r20
8112352c:	9809883a 	mov	r4,r19
81123530:	112f2b40 	call	8112f2b4 <__ssprint_r>
81123534:	103d3e1e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
81123538:	d8c02017 	ldw	r3,128(sp)
8112353c:	d8801f17 	ldw	r2,124(sp)
81123540:	da000404 	addi	r8,sp,16
81123544:	003fee06 	br	81123500 <__reset+0xfb103500>
81123548:	d9403117 	ldw	r5,196(sp)
8112354c:	d8802a17 	ldw	r2,168(sp)
81123550:	28adc83a 	sub	r22,r5,r2
81123554:	05be650e 	bge	zero,r22,81122eec <__reset+0xfb102eec>
81123558:	07000404 	movi	fp,16
8112355c:	d8801f17 	ldw	r2,124(sp)
81123560:	e583a20e 	bge	fp,r22,811243ec <___svfprintf_internal_r+0x1d58>
81123564:	01604574 	movhi	r5,33045
81123568:	297ea184 	addi	r5,r5,-1402
8112356c:	dc403015 	stw	r17,192(sp)
81123570:	d9402b15 	stw	r5,172(sp)
81123574:	b023883a 	mov	r17,r22
81123578:	050001c4 	movi	r20,7
8112357c:	902d883a 	mov	r22,r18
81123580:	8025883a 	mov	r18,r16
81123584:	dc002c17 	ldw	r16,176(sp)
81123588:	00000306 	br	81123598 <___svfprintf_internal_r+0xf04>
8112358c:	8c7ffc04 	addi	r17,r17,-16
81123590:	42000204 	addi	r8,r8,8
81123594:	e440110e 	bge	fp,r17,811235dc <___svfprintf_internal_r+0xf48>
81123598:	18c00404 	addi	r3,r3,16
8112359c:	10800044 	addi	r2,r2,1
811235a0:	45400015 	stw	r21,0(r8)
811235a4:	47000115 	stw	fp,4(r8)
811235a8:	d8c02015 	stw	r3,128(sp)
811235ac:	d8801f15 	stw	r2,124(sp)
811235b0:	a0bff60e 	bge	r20,r2,8112358c <__reset+0xfb10358c>
811235b4:	d9801e04 	addi	r6,sp,120
811235b8:	800b883a 	mov	r5,r16
811235bc:	9809883a 	mov	r4,r19
811235c0:	112f2b40 	call	8112f2b4 <__ssprint_r>
811235c4:	103d1a1e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
811235c8:	8c7ffc04 	addi	r17,r17,-16
811235cc:	d8c02017 	ldw	r3,128(sp)
811235d0:	d8801f17 	ldw	r2,124(sp)
811235d4:	da000404 	addi	r8,sp,16
811235d8:	e47fef16 	blt	fp,r17,81123598 <__reset+0xfb103598>
811235dc:	9021883a 	mov	r16,r18
811235e0:	b025883a 	mov	r18,r22
811235e4:	882d883a 	mov	r22,r17
811235e8:	dc403017 	ldw	r17,192(sp)
811235ec:	d9002b17 	ldw	r4,172(sp)
811235f0:	1d87883a 	add	r3,r3,r22
811235f4:	10800044 	addi	r2,r2,1
811235f8:	41000015 	stw	r4,0(r8)
811235fc:	45800115 	stw	r22,4(r8)
81123600:	d8c02015 	stw	r3,128(sp)
81123604:	d8801f15 	stw	r2,124(sp)
81123608:	010001c4 	movi	r4,7
8112360c:	20819a16 	blt	r4,r2,81123c78 <___svfprintf_internal_r+0x15e4>
81123610:	42000204 	addi	r8,r8,8
81123614:	003e3506 	br	81122eec <__reset+0xfb102eec>
81123618:	d9403317 	ldw	r5,204(sp)
8112361c:	00800044 	movi	r2,1
81123620:	18c00044 	addi	r3,r3,1
81123624:	1141710e 	bge	r2,r5,81123bec <___svfprintf_internal_r+0x1558>
81123628:	dc401f17 	ldw	r17,124(sp)
8112362c:	00800044 	movi	r2,1
81123630:	40800115 	stw	r2,4(r8)
81123634:	8c400044 	addi	r17,r17,1
81123638:	44000015 	stw	r16,0(r8)
8112363c:	d8c02015 	stw	r3,128(sp)
81123640:	dc401f15 	stw	r17,124(sp)
81123644:	008001c4 	movi	r2,7
81123648:	14417416 	blt	r2,r17,81123c1c <___svfprintf_internal_r+0x1588>
8112364c:	42000204 	addi	r8,r8,8
81123650:	d8803817 	ldw	r2,224(sp)
81123654:	d9003417 	ldw	r4,208(sp)
81123658:	8c400044 	addi	r17,r17,1
8112365c:	10c7883a 	add	r3,r2,r3
81123660:	40800115 	stw	r2,4(r8)
81123664:	41000015 	stw	r4,0(r8)
81123668:	d8c02015 	stw	r3,128(sp)
8112366c:	dc401f15 	stw	r17,124(sp)
81123670:	008001c4 	movi	r2,7
81123674:	14417216 	blt	r2,r17,81123c40 <___svfprintf_internal_r+0x15ac>
81123678:	45800204 	addi	r22,r8,8
8112367c:	d9003617 	ldw	r4,216(sp)
81123680:	d9403717 	ldw	r5,220(sp)
81123684:	000d883a 	mov	r6,zero
81123688:	000f883a 	mov	r7,zero
8112368c:	d8c03d15 	stw	r3,244(sp)
81123690:	11352300 	call	81135230 <__eqdf2>
81123694:	d8c03d17 	ldw	r3,244(sp)
81123698:	1000b326 	beq	r2,zero,81123968 <___svfprintf_internal_r+0x12d4>
8112369c:	d9403317 	ldw	r5,204(sp)
811236a0:	84000044 	addi	r16,r16,1
811236a4:	8c400044 	addi	r17,r17,1
811236a8:	28bfffc4 	addi	r2,r5,-1
811236ac:	1887883a 	add	r3,r3,r2
811236b0:	b0800115 	stw	r2,4(r22)
811236b4:	b4000015 	stw	r16,0(r22)
811236b8:	d8c02015 	stw	r3,128(sp)
811236bc:	dc401f15 	stw	r17,124(sp)
811236c0:	008001c4 	movi	r2,7
811236c4:	1440d216 	blt	r2,r17,81123a10 <___svfprintf_internal_r+0x137c>
811236c8:	b5800204 	addi	r22,r22,8
811236cc:	d9003b17 	ldw	r4,236(sp)
811236d0:	df0022c4 	addi	fp,sp,139
811236d4:	8c400044 	addi	r17,r17,1
811236d8:	20c7883a 	add	r3,r4,r3
811236dc:	b7000015 	stw	fp,0(r22)
811236e0:	b1000115 	stw	r4,4(r22)
811236e4:	d8c02015 	stw	r3,128(sp)
811236e8:	dc401f15 	stw	r17,124(sp)
811236ec:	008001c4 	movi	r2,7
811236f0:	14400e16 	blt	r2,r17,8112372c <___svfprintf_internal_r+0x1098>
811236f4:	b2000204 	addi	r8,r22,8
811236f8:	003e3c06 	br	81122fec <__reset+0xfb102fec>
811236fc:	01204574 	movhi	r4,33045
81123700:	213ea184 	addi	r4,r4,-1402
81123704:	d9002b15 	stw	r4,172(sp)
81123708:	d9002b17 	ldw	r4,172(sp)
8112370c:	1c07883a 	add	r3,r3,r16
81123710:	44000115 	stw	r16,4(r8)
81123714:	41000015 	stw	r4,0(r8)
81123718:	10800044 	addi	r2,r2,1
8112371c:	d8c02015 	stw	r3,128(sp)
81123720:	d8801f15 	stw	r2,124(sp)
81123724:	010001c4 	movi	r4,7
81123728:	20be2f0e 	bge	r4,r2,81122fe8 <__reset+0xfb102fe8>
8112372c:	d9402c17 	ldw	r5,176(sp)
81123730:	d9801e04 	addi	r6,sp,120
81123734:	9809883a 	mov	r4,r19
81123738:	112f2b40 	call	8112f2b4 <__ssprint_r>
8112373c:	103cbc1e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
81123740:	d8c02017 	ldw	r3,128(sp)
81123744:	da000404 	addi	r8,sp,16
81123748:	003e2806 	br	81122fec <__reset+0xfb102fec>
8112374c:	d9402c17 	ldw	r5,176(sp)
81123750:	d9801e04 	addi	r6,sp,120
81123754:	9809883a 	mov	r4,r19
81123758:	112f2b40 	call	8112f2b4 <__ssprint_r>
8112375c:	103e5f26 	beq	r2,zero,811230dc <__reset+0xfb1030dc>
81123760:	003cb306 	br	81122a30 <__reset+0xfb102a30>
81123764:	d9402c17 	ldw	r5,176(sp)
81123768:	d9801e04 	addi	r6,sp,120
8112376c:	9809883a 	mov	r4,r19
81123770:	112f2b40 	call	8112f2b4 <__ssprint_r>
81123774:	103cae1e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
81123778:	d8c02017 	ldw	r3,128(sp)
8112377c:	da000404 	addi	r8,sp,16
81123780:	003e0d06 	br	81122fb8 <__reset+0xfb102fb8>
81123784:	d9402c17 	ldw	r5,176(sp)
81123788:	d9801e04 	addi	r6,sp,120
8112378c:	9809883a 	mov	r4,r19
81123790:	112f2b40 	call	8112f2b4 <__ssprint_r>
81123794:	103ca61e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
81123798:	d8c02017 	ldw	r3,128(sp)
8112379c:	da000404 	addi	r8,sp,16
811237a0:	003dc106 	br	81122ea8 <__reset+0xfb102ea8>
811237a4:	d9402c17 	ldw	r5,176(sp)
811237a8:	d9801e04 	addi	r6,sp,120
811237ac:	9809883a 	mov	r4,r19
811237b0:	112f2b40 	call	8112f2b4 <__ssprint_r>
811237b4:	103c9e1e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
811237b8:	d8c02017 	ldw	r3,128(sp)
811237bc:	da000404 	addi	r8,sp,16
811237c0:	003dc706 	br	81122ee0 <__reset+0xfb102ee0>
811237c4:	d8802917 	ldw	r2,164(sp)
811237c8:	d8002785 	stb	zero,158(sp)
811237cc:	103f0816 	blt	r2,zero,811233f0 <__reset+0xfb1033f0>
811237d0:	00ffdfc4 	movi	r3,-129
811237d4:	a584b03a 	or	r2,r20,r22
811237d8:	90e4703a 	and	r18,r18,r3
811237dc:	103c8126 	beq	r2,zero,811229e4 <__reset+0xfb1029e4>
811237e0:	0039883a 	mov	fp,zero
811237e4:	003e7606 	br	811231c0 <__reset+0xfb1031c0>
811237e8:	9080040c 	andi	r2,r18,16
811237ec:	10013d26 	beq	r2,zero,81123ce4 <___svfprintf_internal_r+0x1650>
811237f0:	d9002d17 	ldw	r4,180(sp)
811237f4:	d9402917 	ldw	r5,164(sp)
811237f8:	d8002785 	stb	zero,158(sp)
811237fc:	20800104 	addi	r2,r4,4
81123800:	25000017 	ldw	r20,0(r4)
81123804:	002d883a 	mov	r22,zero
81123808:	28013f16 	blt	r5,zero,81123d08 <___svfprintf_internal_r+0x1674>
8112380c:	00ffdfc4 	movi	r3,-129
81123810:	d8802d15 	stw	r2,180(sp)
81123814:	90e4703a 	and	r18,r18,r3
81123818:	a03d2b26 	beq	r20,zero,81122cc8 <__reset+0xfb102cc8>
8112381c:	0039883a 	mov	fp,zero
81123820:	003d2e06 	br	81122cdc <__reset+0xfb102cdc>
81123824:	dc402617 	ldw	r17,152(sp)
81123828:	0441830e 	bge	zero,r17,81123e38 <___svfprintf_internal_r+0x17a4>
8112382c:	dc403217 	ldw	r17,200(sp)
81123830:	d8803317 	ldw	r2,204(sp)
81123834:	1440010e 	bge	r2,r17,8112383c <___svfprintf_internal_r+0x11a8>
81123838:	1023883a 	mov	r17,r2
8112383c:	04400a0e 	bge	zero,r17,81123868 <___svfprintf_internal_r+0x11d4>
81123840:	d8801f17 	ldw	r2,124(sp)
81123844:	1c47883a 	add	r3,r3,r17
81123848:	44000015 	stw	r16,0(r8)
8112384c:	10800044 	addi	r2,r2,1
81123850:	44400115 	stw	r17,4(r8)
81123854:	d8c02015 	stw	r3,128(sp)
81123858:	d8801f15 	stw	r2,124(sp)
8112385c:	010001c4 	movi	r4,7
81123860:	20827516 	blt	r4,r2,81124238 <___svfprintf_internal_r+0x1ba4>
81123864:	42000204 	addi	r8,r8,8
81123868:	88027b16 	blt	r17,zero,81124258 <___svfprintf_internal_r+0x1bc4>
8112386c:	d9003217 	ldw	r4,200(sp)
81123870:	2463c83a 	sub	r17,r4,r17
81123874:	0440990e 	bge	zero,r17,81123adc <___svfprintf_internal_r+0x1448>
81123878:	05800404 	movi	r22,16
8112387c:	d8801f17 	ldw	r2,124(sp)
81123880:	b441530e 	bge	r22,r17,81123dd0 <___svfprintf_internal_r+0x173c>
81123884:	01204574 	movhi	r4,33045
81123888:	213ea184 	addi	r4,r4,-1402
8112388c:	d9002b15 	stw	r4,172(sp)
81123890:	070001c4 	movi	fp,7
81123894:	dd002c17 	ldw	r20,176(sp)
81123898:	00000306 	br	811238a8 <___svfprintf_internal_r+0x1214>
8112389c:	42000204 	addi	r8,r8,8
811238a0:	8c7ffc04 	addi	r17,r17,-16
811238a4:	b4414d0e 	bge	r22,r17,81123ddc <___svfprintf_internal_r+0x1748>
811238a8:	18c00404 	addi	r3,r3,16
811238ac:	10800044 	addi	r2,r2,1
811238b0:	45400015 	stw	r21,0(r8)
811238b4:	45800115 	stw	r22,4(r8)
811238b8:	d8c02015 	stw	r3,128(sp)
811238bc:	d8801f15 	stw	r2,124(sp)
811238c0:	e0bff60e 	bge	fp,r2,8112389c <__reset+0xfb10389c>
811238c4:	d9801e04 	addi	r6,sp,120
811238c8:	a00b883a 	mov	r5,r20
811238cc:	9809883a 	mov	r4,r19
811238d0:	112f2b40 	call	8112f2b4 <__ssprint_r>
811238d4:	103c561e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
811238d8:	d8c02017 	ldw	r3,128(sp)
811238dc:	d8801f17 	ldw	r2,124(sp)
811238e0:	da000404 	addi	r8,sp,16
811238e4:	003fee06 	br	811238a0 <__reset+0xfb1038a0>
811238e8:	d9402c17 	ldw	r5,176(sp)
811238ec:	d9801e04 	addi	r6,sp,120
811238f0:	9809883a 	mov	r4,r19
811238f4:	112f2b40 	call	8112f2b4 <__ssprint_r>
811238f8:	103c4d1e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
811238fc:	d8c02017 	ldw	r3,128(sp)
81123900:	df002787 	ldb	fp,158(sp)
81123904:	da000404 	addi	r8,sp,16
81123908:	003d5a06 	br	81122e74 <__reset+0xfb102e74>
8112390c:	9080040c 	andi	r2,r18,16
81123910:	10005c26 	beq	r2,zero,81123a84 <___svfprintf_internal_r+0x13f0>
81123914:	d9402d17 	ldw	r5,180(sp)
81123918:	d8c02917 	ldw	r3,164(sp)
8112391c:	d8002785 	stb	zero,158(sp)
81123920:	28800104 	addi	r2,r5,4
81123924:	2d000017 	ldw	r20,0(r5)
81123928:	002d883a 	mov	r22,zero
8112392c:	18005e16 	blt	r3,zero,81123aa8 <___svfprintf_internal_r+0x1414>
81123930:	00ffdfc4 	movi	r3,-129
81123934:	d8802d15 	stw	r2,180(sp)
81123938:	90e4703a 	and	r18,r18,r3
8112393c:	0039883a 	mov	fp,zero
81123940:	a03dfe26 	beq	r20,zero,8112313c <__reset+0xfb10313c>
81123944:	00800244 	movi	r2,9
81123948:	153cb336 	bltu	r2,r20,81122c18 <__reset+0xfb102c18>
8112394c:	a5000c04 	addi	r20,r20,48
81123950:	dc001dc4 	addi	r16,sp,119
81123954:	dd001dc5 	stb	r20,119(sp)
81123958:	d8c02817 	ldw	r3,160(sp)
8112395c:	1c07c83a 	sub	r3,r3,r16
81123960:	d8c02e15 	stw	r3,184(sp)
81123964:	003cf506 	br	81122d3c <__reset+0xfb102d3c>
81123968:	d8803317 	ldw	r2,204(sp)
8112396c:	143fffc4 	addi	r16,r2,-1
81123970:	043f560e 	bge	zero,r16,811236cc <__reset+0xfb1036cc>
81123974:	07000404 	movi	fp,16
81123978:	e403530e 	bge	fp,r16,811246c8 <___svfprintf_internal_r+0x2034>
8112397c:	01604574 	movhi	r5,33045
81123980:	297ea184 	addi	r5,r5,-1402
81123984:	d9402b15 	stw	r5,172(sp)
81123988:	01c001c4 	movi	r7,7
8112398c:	dd002c17 	ldw	r20,176(sp)
81123990:	00000306 	br	811239a0 <___svfprintf_internal_r+0x130c>
81123994:	843ffc04 	addi	r16,r16,-16
81123998:	b5800204 	addi	r22,r22,8
8112399c:	e400130e 	bge	fp,r16,811239ec <___svfprintf_internal_r+0x1358>
811239a0:	18c00404 	addi	r3,r3,16
811239a4:	8c400044 	addi	r17,r17,1
811239a8:	b5400015 	stw	r21,0(r22)
811239ac:	b7000115 	stw	fp,4(r22)
811239b0:	d8c02015 	stw	r3,128(sp)
811239b4:	dc401f15 	stw	r17,124(sp)
811239b8:	3c7ff60e 	bge	r7,r17,81123994 <__reset+0xfb103994>
811239bc:	d9801e04 	addi	r6,sp,120
811239c0:	a00b883a 	mov	r5,r20
811239c4:	9809883a 	mov	r4,r19
811239c8:	d9c03d15 	stw	r7,244(sp)
811239cc:	112f2b40 	call	8112f2b4 <__ssprint_r>
811239d0:	d9c03d17 	ldw	r7,244(sp)
811239d4:	103c161e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
811239d8:	843ffc04 	addi	r16,r16,-16
811239dc:	d8c02017 	ldw	r3,128(sp)
811239e0:	dc401f17 	ldw	r17,124(sp)
811239e4:	dd800404 	addi	r22,sp,16
811239e8:	e43fed16 	blt	fp,r16,811239a0 <__reset+0xfb1039a0>
811239ec:	d8802b17 	ldw	r2,172(sp)
811239f0:	1c07883a 	add	r3,r3,r16
811239f4:	8c400044 	addi	r17,r17,1
811239f8:	b0800015 	stw	r2,0(r22)
811239fc:	b4000115 	stw	r16,4(r22)
81123a00:	d8c02015 	stw	r3,128(sp)
81123a04:	dc401f15 	stw	r17,124(sp)
81123a08:	008001c4 	movi	r2,7
81123a0c:	147f2e0e 	bge	r2,r17,811236c8 <__reset+0xfb1036c8>
81123a10:	d9402c17 	ldw	r5,176(sp)
81123a14:	d9801e04 	addi	r6,sp,120
81123a18:	9809883a 	mov	r4,r19
81123a1c:	112f2b40 	call	8112f2b4 <__ssprint_r>
81123a20:	103c031e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
81123a24:	d8c02017 	ldw	r3,128(sp)
81123a28:	dc401f17 	ldw	r17,124(sp)
81123a2c:	dd800404 	addi	r22,sp,16
81123a30:	003f2606 	br	811236cc <__reset+0xfb1036cc>
81123a34:	9080040c 	andi	r2,r18,16
81123a38:	1000c326 	beq	r2,zero,81123d48 <___svfprintf_internal_r+0x16b4>
81123a3c:	d8802d17 	ldw	r2,180(sp)
81123a40:	15000017 	ldw	r20,0(r2)
81123a44:	10800104 	addi	r2,r2,4
81123a48:	d8802d15 	stw	r2,180(sp)
81123a4c:	a02dd7fa 	srai	r22,r20,31
81123a50:	b005883a 	mov	r2,r22
81123a54:	103c680e 	bge	r2,zero,81122bf8 <__reset+0xfb102bf8>
81123a58:	0529c83a 	sub	r20,zero,r20
81123a5c:	a004c03a 	cmpne	r2,r20,zero
81123a60:	05adc83a 	sub	r22,zero,r22
81123a64:	b0adc83a 	sub	r22,r22,r2
81123a68:	d8802917 	ldw	r2,164(sp)
81123a6c:	07000b44 	movi	fp,45
81123a70:	df002785 	stb	fp,158(sp)
81123a74:	10022e16 	blt	r2,zero,81124330 <___svfprintf_internal_r+0x1c9c>
81123a78:	00bfdfc4 	movi	r2,-129
81123a7c:	90a4703a 	and	r18,r18,r2
81123a80:	003c6406 	br	81122c14 <__reset+0xfb102c14>
81123a84:	9080100c 	andi	r2,r18,64
81123a88:	d8002785 	stb	zero,158(sp)
81123a8c:	10012526 	beq	r2,zero,81123f24 <___svfprintf_internal_r+0x1890>
81123a90:	d9002d17 	ldw	r4,180(sp)
81123a94:	d9402917 	ldw	r5,164(sp)
81123a98:	002d883a 	mov	r22,zero
81123a9c:	20800104 	addi	r2,r4,4
81123aa0:	2500000b 	ldhu	r20,0(r4)
81123aa4:	283fa20e 	bge	r5,zero,81123930 <__reset+0xfb103930>
81123aa8:	d8802d15 	stw	r2,180(sp)
81123aac:	0039883a 	mov	fp,zero
81123ab0:	a584b03a 	or	r2,r20,r22
81123ab4:	103c571e 	bne	r2,zero,81122c14 <__reset+0xfb102c14>
81123ab8:	00800044 	movi	r2,1
81123abc:	003e5006 	br	81123400 <__reset+0xfb103400>
81123ac0:	d9402c17 	ldw	r5,176(sp)
81123ac4:	d9801e04 	addi	r6,sp,120
81123ac8:	9809883a 	mov	r4,r19
81123acc:	112f2b40 	call	8112f2b4 <__ssprint_r>
81123ad0:	103bd71e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
81123ad4:	d8c02017 	ldw	r3,128(sp)
81123ad8:	da000404 	addi	r8,sp,16
81123adc:	d9003217 	ldw	r4,200(sp)
81123ae0:	d8802617 	ldw	r2,152(sp)
81123ae4:	d9403317 	ldw	r5,204(sp)
81123ae8:	8123883a 	add	r17,r16,r4
81123aec:	11400216 	blt	r2,r5,81123af8 <___svfprintf_internal_r+0x1464>
81123af0:	9100004c 	andi	r4,r18,1
81123af4:	20000d26 	beq	r4,zero,81123b2c <___svfprintf_internal_r+0x1498>
81123af8:	d9003817 	ldw	r4,224(sp)
81123afc:	d9403417 	ldw	r5,208(sp)
81123b00:	1907883a 	add	r3,r3,r4
81123b04:	d9001f17 	ldw	r4,124(sp)
81123b08:	41400015 	stw	r5,0(r8)
81123b0c:	d9403817 	ldw	r5,224(sp)
81123b10:	21000044 	addi	r4,r4,1
81123b14:	d8c02015 	stw	r3,128(sp)
81123b18:	41400115 	stw	r5,4(r8)
81123b1c:	d9001f15 	stw	r4,124(sp)
81123b20:	014001c4 	movi	r5,7
81123b24:	2901dc16 	blt	r5,r4,81124298 <___svfprintf_internal_r+0x1c04>
81123b28:	42000204 	addi	r8,r8,8
81123b2c:	d9003317 	ldw	r4,204(sp)
81123b30:	8121883a 	add	r16,r16,r4
81123b34:	2085c83a 	sub	r2,r4,r2
81123b38:	8461c83a 	sub	r16,r16,r17
81123b3c:	1400010e 	bge	r2,r16,81123b44 <___svfprintf_internal_r+0x14b0>
81123b40:	1021883a 	mov	r16,r2
81123b44:	04000a0e 	bge	zero,r16,81123b70 <___svfprintf_internal_r+0x14dc>
81123b48:	d9001f17 	ldw	r4,124(sp)
81123b4c:	1c07883a 	add	r3,r3,r16
81123b50:	44400015 	stw	r17,0(r8)
81123b54:	21000044 	addi	r4,r4,1
81123b58:	44000115 	stw	r16,4(r8)
81123b5c:	d8c02015 	stw	r3,128(sp)
81123b60:	d9001f15 	stw	r4,124(sp)
81123b64:	014001c4 	movi	r5,7
81123b68:	2901e616 	blt	r5,r4,81124304 <___svfprintf_internal_r+0x1c70>
81123b6c:	42000204 	addi	r8,r8,8
81123b70:	8001f616 	blt	r16,zero,8112434c <___svfprintf_internal_r+0x1cb8>
81123b74:	1421c83a 	sub	r16,r2,r16
81123b78:	043d1c0e 	bge	zero,r16,81122fec <__reset+0xfb102fec>
81123b7c:	04400404 	movi	r17,16
81123b80:	d8801f17 	ldw	r2,124(sp)
81123b84:	8c3edd0e 	bge	r17,r16,811236fc <__reset+0xfb1036fc>
81123b88:	01604574 	movhi	r5,33045
81123b8c:	297ea184 	addi	r5,r5,-1402
81123b90:	d9402b15 	stw	r5,172(sp)
81123b94:	058001c4 	movi	r22,7
81123b98:	dd002c17 	ldw	r20,176(sp)
81123b9c:	00000306 	br	81123bac <___svfprintf_internal_r+0x1518>
81123ba0:	42000204 	addi	r8,r8,8
81123ba4:	843ffc04 	addi	r16,r16,-16
81123ba8:	8c3ed70e 	bge	r17,r16,81123708 <__reset+0xfb103708>
81123bac:	18c00404 	addi	r3,r3,16
81123bb0:	10800044 	addi	r2,r2,1
81123bb4:	45400015 	stw	r21,0(r8)
81123bb8:	44400115 	stw	r17,4(r8)
81123bbc:	d8c02015 	stw	r3,128(sp)
81123bc0:	d8801f15 	stw	r2,124(sp)
81123bc4:	b0bff60e 	bge	r22,r2,81123ba0 <__reset+0xfb103ba0>
81123bc8:	d9801e04 	addi	r6,sp,120
81123bcc:	a00b883a 	mov	r5,r20
81123bd0:	9809883a 	mov	r4,r19
81123bd4:	112f2b40 	call	8112f2b4 <__ssprint_r>
81123bd8:	103b951e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
81123bdc:	d8c02017 	ldw	r3,128(sp)
81123be0:	d8801f17 	ldw	r2,124(sp)
81123be4:	da000404 	addi	r8,sp,16
81123be8:	003fee06 	br	81123ba4 <__reset+0xfb103ba4>
81123bec:	9088703a 	and	r4,r18,r2
81123bf0:	203e8d1e 	bne	r4,zero,81123628 <__reset+0xfb103628>
81123bf4:	dc401f17 	ldw	r17,124(sp)
81123bf8:	40800115 	stw	r2,4(r8)
81123bfc:	44000015 	stw	r16,0(r8)
81123c00:	8c400044 	addi	r17,r17,1
81123c04:	d8c02015 	stw	r3,128(sp)
81123c08:	dc401f15 	stw	r17,124(sp)
81123c0c:	008001c4 	movi	r2,7
81123c10:	147f7f16 	blt	r2,r17,81123a10 <__reset+0xfb103a10>
81123c14:	45800204 	addi	r22,r8,8
81123c18:	003eac06 	br	811236cc <__reset+0xfb1036cc>
81123c1c:	d9402c17 	ldw	r5,176(sp)
81123c20:	d9801e04 	addi	r6,sp,120
81123c24:	9809883a 	mov	r4,r19
81123c28:	112f2b40 	call	8112f2b4 <__ssprint_r>
81123c2c:	103b801e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
81123c30:	d8c02017 	ldw	r3,128(sp)
81123c34:	dc401f17 	ldw	r17,124(sp)
81123c38:	da000404 	addi	r8,sp,16
81123c3c:	003e8406 	br	81123650 <__reset+0xfb103650>
81123c40:	d9402c17 	ldw	r5,176(sp)
81123c44:	d9801e04 	addi	r6,sp,120
81123c48:	9809883a 	mov	r4,r19
81123c4c:	112f2b40 	call	8112f2b4 <__ssprint_r>
81123c50:	103b771e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
81123c54:	d8c02017 	ldw	r3,128(sp)
81123c58:	dc401f17 	ldw	r17,124(sp)
81123c5c:	dd800404 	addi	r22,sp,16
81123c60:	003e8606 	br	8112367c <__reset+0xfb10367c>
81123c64:	0029883a 	mov	r20,zero
81123c68:	a5000c04 	addi	r20,r20,48
81123c6c:	dc001dc4 	addi	r16,sp,119
81123c70:	dd001dc5 	stb	r20,119(sp)
81123c74:	003f3806 	br	81123958 <__reset+0xfb103958>
81123c78:	d9402c17 	ldw	r5,176(sp)
81123c7c:	d9801e04 	addi	r6,sp,120
81123c80:	9809883a 	mov	r4,r19
81123c84:	112f2b40 	call	8112f2b4 <__ssprint_r>
81123c88:	103b691e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
81123c8c:	d8c02017 	ldw	r3,128(sp)
81123c90:	da000404 	addi	r8,sp,16
81123c94:	003c9506 	br	81122eec <__reset+0xfb102eec>
81123c98:	d9003617 	ldw	r4,216(sp)
81123c9c:	d9403717 	ldw	r5,220(sp)
81123ca0:	da003e15 	stw	r8,248(sp)
81123ca4:	112d0c80 	call	8112d0c8 <__fpclassifyd>
81123ca8:	da003e17 	ldw	r8,248(sp)
81123cac:	1000bd1e 	bne	r2,zero,81123fa4 <___svfprintf_internal_r+0x1910>
81123cb0:	008011c4 	movi	r2,71
81123cb4:	14411e0e 	bge	r2,r17,81124130 <___svfprintf_internal_r+0x1a9c>
81123cb8:	04204574 	movhi	r16,33045
81123cbc:	843e9404 	addi	r16,r16,-1456
81123cc0:	00c000c4 	movi	r3,3
81123cc4:	00bfdfc4 	movi	r2,-129
81123cc8:	d8c02a15 	stw	r3,168(sp)
81123ccc:	90a4703a 	and	r18,r18,r2
81123cd0:	df002783 	ldbu	fp,158(sp)
81123cd4:	d8c02e15 	stw	r3,184(sp)
81123cd8:	d8002915 	stw	zero,164(sp)
81123cdc:	d8003215 	stw	zero,200(sp)
81123ce0:	003c1c06 	br	81122d54 <__reset+0xfb102d54>
81123ce4:	9080100c 	andi	r2,r18,64
81123ce8:	d8002785 	stb	zero,158(sp)
81123cec:	10009426 	beq	r2,zero,81123f40 <___svfprintf_internal_r+0x18ac>
81123cf0:	d8c02d17 	ldw	r3,180(sp)
81123cf4:	d9002917 	ldw	r4,164(sp)
81123cf8:	002d883a 	mov	r22,zero
81123cfc:	18800104 	addi	r2,r3,4
81123d00:	1d00000b 	ldhu	r20,0(r3)
81123d04:	203ec10e 	bge	r4,zero,8112380c <__reset+0xfb10380c>
81123d08:	a586b03a 	or	r3,r20,r22
81123d0c:	d8802d15 	stw	r2,180(sp)
81123d10:	183ec21e 	bne	r3,zero,8112381c <__reset+0xfb10381c>
81123d14:	0039883a 	mov	fp,zero
81123d18:	0005883a 	mov	r2,zero
81123d1c:	003db806 	br	81123400 <__reset+0xfb103400>
81123d20:	d8802d17 	ldw	r2,180(sp)
81123d24:	d8c02d17 	ldw	r3,180(sp)
81123d28:	d9002d17 	ldw	r4,180(sp)
81123d2c:	10800017 	ldw	r2,0(r2)
81123d30:	18c00117 	ldw	r3,4(r3)
81123d34:	21000204 	addi	r4,r4,8
81123d38:	d8803615 	stw	r2,216(sp)
81123d3c:	d8c03715 	stw	r3,220(sp)
81123d40:	d9002d15 	stw	r4,180(sp)
81123d44:	003b8206 	br	81122b50 <__reset+0xfb102b50>
81123d48:	9080100c 	andi	r2,r18,64
81123d4c:	10010726 	beq	r2,zero,8112416c <___svfprintf_internal_r+0x1ad8>
81123d50:	d8c02d17 	ldw	r3,180(sp)
81123d54:	1d00000f 	ldh	r20,0(r3)
81123d58:	18c00104 	addi	r3,r3,4
81123d5c:	d8c02d15 	stw	r3,180(sp)
81123d60:	a02dd7fa 	srai	r22,r20,31
81123d64:	b005883a 	mov	r2,r22
81123d68:	003ba206 	br	81122bf4 <__reset+0xfb102bf4>
81123d6c:	9080100c 	andi	r2,r18,64
81123d70:	10010526 	beq	r2,zero,81124188 <___svfprintf_internal_r+0x1af4>
81123d74:	d9002d17 	ldw	r4,180(sp)
81123d78:	002d883a 	mov	r22,zero
81123d7c:	2500000b 	ldhu	r20,0(r4)
81123d80:	21000104 	addi	r4,r4,4
81123d84:	d9002d15 	stw	r4,180(sp)
81123d88:	003cfe06 	br	81123184 <__reset+0xfb103184>
81123d8c:	bc400007 	ldb	r17,0(r23)
81123d90:	003a9606 	br	811227ec <__reset+0xfb1027ec>
81123d94:	9080040c 	andi	r2,r18,16
81123d98:	10010126 	beq	r2,zero,811241a0 <___svfprintf_internal_r+0x1b0c>
81123d9c:	d9402d17 	ldw	r5,180(sp)
81123da0:	d8c02f17 	ldw	r3,188(sp)
81123da4:	28800017 	ldw	r2,0(r5)
81123da8:	29400104 	addi	r5,r5,4
81123dac:	d9402d15 	stw	r5,180(sp)
81123db0:	10c00015 	stw	r3,0(r2)
81123db4:	003a6406 	br	81122748 <__reset+0xfb102748>
81123db8:	d9002917 	ldw	r4,164(sp)
81123dbc:	d8002785 	stb	zero,158(sp)
81123dc0:	203d8d16 	blt	r4,zero,811233f8 <__reset+0xfb1033f8>
81123dc4:	00bfdfc4 	movi	r2,-129
81123dc8:	90a4703a 	and	r18,r18,r2
81123dcc:	003b0506 	br	811229e4 <__reset+0xfb1029e4>
81123dd0:	01604574 	movhi	r5,33045
81123dd4:	297ea184 	addi	r5,r5,-1402
81123dd8:	d9402b15 	stw	r5,172(sp)
81123ddc:	d9402b17 	ldw	r5,172(sp)
81123de0:	1c47883a 	add	r3,r3,r17
81123de4:	10800044 	addi	r2,r2,1
81123de8:	41400015 	stw	r5,0(r8)
81123dec:	44400115 	stw	r17,4(r8)
81123df0:	d8c02015 	stw	r3,128(sp)
81123df4:	d8801f15 	stw	r2,124(sp)
81123df8:	010001c4 	movi	r4,7
81123dfc:	20bf3016 	blt	r4,r2,81123ac0 <__reset+0xfb103ac0>
81123e00:	42000204 	addi	r8,r8,8
81123e04:	003f3506 	br	81123adc <__reset+0xfb103adc>
81123e08:	01204574 	movhi	r4,33045
81123e0c:	213ea184 	addi	r4,r4,-1402
81123e10:	d9002b15 	stw	r4,172(sp)
81123e14:	003c5e06 	br	81122f90 <__reset+0xfb102f90>
81123e18:	d9402c17 	ldw	r5,176(sp)
81123e1c:	d9801e04 	addi	r6,sp,120
81123e20:	9809883a 	mov	r4,r19
81123e24:	112f2b40 	call	8112f2b4 <__ssprint_r>
81123e28:	103b011e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
81123e2c:	d8c02017 	ldw	r3,128(sp)
81123e30:	da000404 	addi	r8,sp,16
81123e34:	003d9306 	br	81123484 <__reset+0xfb103484>
81123e38:	d8801f17 	ldw	r2,124(sp)
81123e3c:	01604574 	movhi	r5,33045
81123e40:	01000044 	movi	r4,1
81123e44:	18c00044 	addi	r3,r3,1
81123e48:	10800044 	addi	r2,r2,1
81123e4c:	297ea104 	addi	r5,r5,-1404
81123e50:	41000115 	stw	r4,4(r8)
81123e54:	41400015 	stw	r5,0(r8)
81123e58:	d8c02015 	stw	r3,128(sp)
81123e5c:	d8801f15 	stw	r2,124(sp)
81123e60:	010001c4 	movi	r4,7
81123e64:	2080b516 	blt	r4,r2,8112413c <___svfprintf_internal_r+0x1aa8>
81123e68:	42000204 	addi	r8,r8,8
81123e6c:	8800041e 	bne	r17,zero,81123e80 <___svfprintf_internal_r+0x17ec>
81123e70:	d8803317 	ldw	r2,204(sp)
81123e74:	1000021e 	bne	r2,zero,81123e80 <___svfprintf_internal_r+0x17ec>
81123e78:	9080004c 	andi	r2,r18,1
81123e7c:	103c5b26 	beq	r2,zero,81122fec <__reset+0xfb102fec>
81123e80:	d9003817 	ldw	r4,224(sp)
81123e84:	d8801f17 	ldw	r2,124(sp)
81123e88:	d9403417 	ldw	r5,208(sp)
81123e8c:	20c7883a 	add	r3,r4,r3
81123e90:	10800044 	addi	r2,r2,1
81123e94:	41000115 	stw	r4,4(r8)
81123e98:	41400015 	stw	r5,0(r8)
81123e9c:	d8c02015 	stw	r3,128(sp)
81123ea0:	d8801f15 	stw	r2,124(sp)
81123ea4:	010001c4 	movi	r4,7
81123ea8:	20818016 	blt	r4,r2,811244ac <___svfprintf_internal_r+0x1e18>
81123eac:	42000204 	addi	r8,r8,8
81123eb0:	0463c83a 	sub	r17,zero,r17
81123eb4:	0440cb0e 	bge	zero,r17,811241e4 <___svfprintf_internal_r+0x1b50>
81123eb8:	05800404 	movi	r22,16
81123ebc:	b440e80e 	bge	r22,r17,81124260 <___svfprintf_internal_r+0x1bcc>
81123ec0:	01604574 	movhi	r5,33045
81123ec4:	297ea184 	addi	r5,r5,-1402
81123ec8:	d9402b15 	stw	r5,172(sp)
81123ecc:	070001c4 	movi	fp,7
81123ed0:	dd002c17 	ldw	r20,176(sp)
81123ed4:	00000306 	br	81123ee4 <___svfprintf_internal_r+0x1850>
81123ed8:	42000204 	addi	r8,r8,8
81123edc:	8c7ffc04 	addi	r17,r17,-16
81123ee0:	b440e20e 	bge	r22,r17,8112426c <___svfprintf_internal_r+0x1bd8>
81123ee4:	18c00404 	addi	r3,r3,16
81123ee8:	10800044 	addi	r2,r2,1
81123eec:	45400015 	stw	r21,0(r8)
81123ef0:	45800115 	stw	r22,4(r8)
81123ef4:	d8c02015 	stw	r3,128(sp)
81123ef8:	d8801f15 	stw	r2,124(sp)
81123efc:	e0bff60e 	bge	fp,r2,81123ed8 <__reset+0xfb103ed8>
81123f00:	d9801e04 	addi	r6,sp,120
81123f04:	a00b883a 	mov	r5,r20
81123f08:	9809883a 	mov	r4,r19
81123f0c:	112f2b40 	call	8112f2b4 <__ssprint_r>
81123f10:	103ac71e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
81123f14:	d8c02017 	ldw	r3,128(sp)
81123f18:	d8801f17 	ldw	r2,124(sp)
81123f1c:	da000404 	addi	r8,sp,16
81123f20:	003fee06 	br	81123edc <__reset+0xfb103edc>
81123f24:	d8c02d17 	ldw	r3,180(sp)
81123f28:	d9002917 	ldw	r4,164(sp)
81123f2c:	002d883a 	mov	r22,zero
81123f30:	18800104 	addi	r2,r3,4
81123f34:	1d000017 	ldw	r20,0(r3)
81123f38:	203e7d0e 	bge	r4,zero,81123930 <__reset+0xfb103930>
81123f3c:	003eda06 	br	81123aa8 <__reset+0xfb103aa8>
81123f40:	d9402d17 	ldw	r5,180(sp)
81123f44:	d8c02917 	ldw	r3,164(sp)
81123f48:	002d883a 	mov	r22,zero
81123f4c:	28800104 	addi	r2,r5,4
81123f50:	2d000017 	ldw	r20,0(r5)
81123f54:	183e2d0e 	bge	r3,zero,8112380c <__reset+0xfb10380c>
81123f58:	003f6b06 	br	81123d08 <__reset+0xfb103d08>
81123f5c:	d8c02d15 	stw	r3,180(sp)
81123f60:	0039883a 	mov	fp,zero
81123f64:	003ed206 	br	81123ab0 <__reset+0xfb103ab0>
81123f68:	bc400043 	ldbu	r17,1(r23)
81123f6c:	94800814 	ori	r18,r18,32
81123f70:	bdc00044 	addi	r23,r23,1
81123f74:	8c403fcc 	andi	r17,r17,255
81123f78:	8c40201c 	xori	r17,r17,128
81123f7c:	8c7fe004 	addi	r17,r17,-128
81123f80:	003a1a06 	br	811227ec <__reset+0xfb1027ec>
81123f84:	d9402c17 	ldw	r5,176(sp)
81123f88:	d9801e04 	addi	r6,sp,120
81123f8c:	9809883a 	mov	r4,r19
81123f90:	112f2b40 	call	8112f2b4 <__ssprint_r>
81123f94:	103aa61e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
81123f98:	d8c02017 	ldw	r3,128(sp)
81123f9c:	da000404 	addi	r8,sp,16
81123fa0:	003d4a06 	br	811234cc <__reset+0xfb1034cc>
81123fa4:	d9002917 	ldw	r4,164(sp)
81123fa8:	05bff7c4 	movi	r22,-33
81123fac:	00bfffc4 	movi	r2,-1
81123fb0:	8dac703a 	and	r22,r17,r22
81123fb4:	20806a26 	beq	r4,r2,81124160 <___svfprintf_internal_r+0x1acc>
81123fb8:	008011c4 	movi	r2,71
81123fbc:	b0813726 	beq	r22,r2,8112449c <___svfprintf_internal_r+0x1e08>
81123fc0:	d9003717 	ldw	r4,220(sp)
81123fc4:	90c04014 	ori	r3,r18,256
81123fc8:	d8c02b15 	stw	r3,172(sp)
81123fcc:	20015d16 	blt	r4,zero,81124544 <___svfprintf_internal_r+0x1eb0>
81123fd0:	dd003717 	ldw	r20,220(sp)
81123fd4:	d8002a05 	stb	zero,168(sp)
81123fd8:	00801984 	movi	r2,102
81123fdc:	88814026 	beq	r17,r2,811244e0 <___svfprintf_internal_r+0x1e4c>
81123fe0:	00801184 	movi	r2,70
81123fe4:	88817126 	beq	r17,r2,811245ac <___svfprintf_internal_r+0x1f18>
81123fe8:	00801144 	movi	r2,69
81123fec:	b0816226 	beq	r22,r2,81124578 <___svfprintf_internal_r+0x1ee4>
81123ff0:	d8c02917 	ldw	r3,164(sp)
81123ff4:	d8802104 	addi	r2,sp,132
81123ff8:	d8800315 	stw	r2,12(sp)
81123ffc:	d9403617 	ldw	r5,216(sp)
81124000:	d8802504 	addi	r2,sp,148
81124004:	d8800215 	stw	r2,8(sp)
81124008:	d8802604 	addi	r2,sp,152
8112400c:	d8c00015 	stw	r3,0(sp)
81124010:	d8800115 	stw	r2,4(sp)
81124014:	01c00084 	movi	r7,2
81124018:	a00d883a 	mov	r6,r20
8112401c:	9809883a 	mov	r4,r19
81124020:	d8c03d15 	stw	r3,244(sp)
81124024:	da003e15 	stw	r8,248(sp)
81124028:	11289800 	call	81128980 <_dtoa_r>
8112402c:	1021883a 	mov	r16,r2
81124030:	008019c4 	movi	r2,103
81124034:	d8c03d17 	ldw	r3,244(sp)
81124038:	da003e17 	ldw	r8,248(sp)
8112403c:	8880e726 	beq	r17,r2,811243dc <___svfprintf_internal_r+0x1d48>
81124040:	008011c4 	movi	r2,71
81124044:	8880d426 	beq	r17,r2,81124398 <___svfprintf_internal_r+0x1d04>
81124048:	80f9883a 	add	fp,r16,r3
8112404c:	d9003617 	ldw	r4,216(sp)
81124050:	000d883a 	mov	r6,zero
81124054:	000f883a 	mov	r7,zero
81124058:	a00b883a 	mov	r5,r20
8112405c:	da003e15 	stw	r8,248(sp)
81124060:	11352300 	call	81135230 <__eqdf2>
81124064:	da003e17 	ldw	r8,248(sp)
81124068:	1000e426 	beq	r2,zero,811243fc <___svfprintf_internal_r+0x1d68>
8112406c:	d8802117 	ldw	r2,132(sp)
81124070:	1700062e 	bgeu	r2,fp,8112408c <___svfprintf_internal_r+0x19f8>
81124074:	01000c04 	movi	r4,48
81124078:	10c00044 	addi	r3,r2,1
8112407c:	d8c02115 	stw	r3,132(sp)
81124080:	11000005 	stb	r4,0(r2)
81124084:	d8802117 	ldw	r2,132(sp)
81124088:	173ffb36 	bltu	r2,fp,81124078 <__reset+0xfb104078>
8112408c:	1405c83a 	sub	r2,r2,r16
81124090:	d8803315 	stw	r2,204(sp)
81124094:	008011c4 	movi	r2,71
81124098:	b080c526 	beq	r22,r2,811243b0 <___svfprintf_internal_r+0x1d1c>
8112409c:	00801944 	movi	r2,101
811240a0:	1441d90e 	bge	r2,r17,81124808 <___svfprintf_internal_r+0x2174>
811240a4:	d8c02617 	ldw	r3,152(sp)
811240a8:	00801984 	movi	r2,102
811240ac:	d8c03215 	stw	r3,200(sp)
811240b0:	88813426 	beq	r17,r2,81124584 <___svfprintf_internal_r+0x1ef0>
811240b4:	d8c03217 	ldw	r3,200(sp)
811240b8:	d9003317 	ldw	r4,204(sp)
811240bc:	19012516 	blt	r3,r4,81124554 <___svfprintf_internal_r+0x1ec0>
811240c0:	9480004c 	andi	r18,r18,1
811240c4:	9001841e 	bne	r18,zero,811246d8 <___svfprintf_internal_r+0x2044>
811240c8:	1805883a 	mov	r2,r3
811240cc:	1801cc16 	blt	r3,zero,81124800 <___svfprintf_internal_r+0x216c>
811240d0:	d8c03217 	ldw	r3,200(sp)
811240d4:	044019c4 	movi	r17,103
811240d8:	d8c02e15 	stw	r3,184(sp)
811240dc:	df002a07 	ldb	fp,168(sp)
811240e0:	e000a61e 	bne	fp,zero,8112437c <___svfprintf_internal_r+0x1ce8>
811240e4:	df002783 	ldbu	fp,158(sp)
811240e8:	d8802a15 	stw	r2,168(sp)
811240ec:	dc802b17 	ldw	r18,172(sp)
811240f0:	d8002915 	stw	zero,164(sp)
811240f4:	003b1706 	br	81122d54 <__reset+0xfb102d54>
811240f8:	04204574 	movhi	r16,33045
811240fc:	843e9104 	addi	r16,r16,-1468
81124100:	003aa606 	br	81122b9c <__reset+0xfb102b9c>
81124104:	d9003917 	ldw	r4,228(sp)
81124108:	04001004 	movi	r16,64
8112410c:	800b883a 	mov	r5,r16
81124110:	11210540 	call	81121054 <_malloc_r>
81124114:	d9002c17 	ldw	r4,176(sp)
81124118:	20800015 	stw	r2,0(r4)
8112411c:	20800415 	stw	r2,16(r4)
81124120:	1001cb26 	beq	r2,zero,81124850 <___svfprintf_internal_r+0x21bc>
81124124:	d8802c17 	ldw	r2,176(sp)
81124128:	14000515 	stw	r16,20(r2)
8112412c:	00397606 	br	81122708 <__reset+0xfb102708>
81124130:	04204574 	movhi	r16,33045
81124134:	843e9304 	addi	r16,r16,-1460
81124138:	003ee106 	br	81123cc0 <__reset+0xfb103cc0>
8112413c:	d9402c17 	ldw	r5,176(sp)
81124140:	d9801e04 	addi	r6,sp,120
81124144:	9809883a 	mov	r4,r19
81124148:	112f2b40 	call	8112f2b4 <__ssprint_r>
8112414c:	103a381e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
81124150:	dc402617 	ldw	r17,152(sp)
81124154:	d8c02017 	ldw	r3,128(sp)
81124158:	da000404 	addi	r8,sp,16
8112415c:	003f4306 	br	81123e6c <__reset+0xfb103e6c>
81124160:	01400184 	movi	r5,6
81124164:	d9402915 	stw	r5,164(sp)
81124168:	003f9506 	br	81123fc0 <__reset+0xfb103fc0>
8112416c:	d9002d17 	ldw	r4,180(sp)
81124170:	25000017 	ldw	r20,0(r4)
81124174:	21000104 	addi	r4,r4,4
81124178:	d9002d15 	stw	r4,180(sp)
8112417c:	a02dd7fa 	srai	r22,r20,31
81124180:	b005883a 	mov	r2,r22
81124184:	003a9b06 	br	81122bf4 <__reset+0xfb102bf4>
81124188:	d9402d17 	ldw	r5,180(sp)
8112418c:	002d883a 	mov	r22,zero
81124190:	2d000017 	ldw	r20,0(r5)
81124194:	29400104 	addi	r5,r5,4
81124198:	d9402d15 	stw	r5,180(sp)
8112419c:	003bf906 	br	81123184 <__reset+0xfb103184>
811241a0:	9480100c 	andi	r18,r18,64
811241a4:	90006e26 	beq	r18,zero,81124360 <___svfprintf_internal_r+0x1ccc>
811241a8:	d9002d17 	ldw	r4,180(sp)
811241ac:	d9402f17 	ldw	r5,188(sp)
811241b0:	20800017 	ldw	r2,0(r4)
811241b4:	21000104 	addi	r4,r4,4
811241b8:	d9002d15 	stw	r4,180(sp)
811241bc:	1140000d 	sth	r5,0(r2)
811241c0:	00396106 	br	81122748 <__reset+0xfb102748>
811241c4:	d9402c17 	ldw	r5,176(sp)
811241c8:	d9801e04 	addi	r6,sp,120
811241cc:	9809883a 	mov	r4,r19
811241d0:	112f2b40 	call	8112f2b4 <__ssprint_r>
811241d4:	103a161e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
811241d8:	d8c02017 	ldw	r3,128(sp)
811241dc:	d8801f17 	ldw	r2,124(sp)
811241e0:	da000404 	addi	r8,sp,16
811241e4:	d9403317 	ldw	r5,204(sp)
811241e8:	10800044 	addi	r2,r2,1
811241ec:	44000015 	stw	r16,0(r8)
811241f0:	28c7883a 	add	r3,r5,r3
811241f4:	003b7706 	br	81122fd4 <__reset+0xfb102fd4>
811241f8:	8009883a 	mov	r4,r16
811241fc:	da003e15 	stw	r8,248(sp)
81124200:	112235c0 	call	8112235c <strlen>
81124204:	d8802e15 	stw	r2,184(sp)
81124208:	da003e17 	ldw	r8,248(sp)
8112420c:	103c280e 	bge	r2,zero,811232b0 <__reset+0xfb1032b0>
81124210:	0005883a 	mov	r2,zero
81124214:	003c2606 	br	811232b0 <__reset+0xfb1032b0>
81124218:	00bfffc4 	movi	r2,-1
8112421c:	003a0906 	br	81122a44 <__reset+0xfb102a44>
81124220:	01204574 	movhi	r4,33045
81124224:	213ea584 	addi	r4,r4,-1386
81124228:	d9003515 	stw	r4,212(sp)
8112422c:	003b0606 	br	81122e48 <__reset+0xfb102e48>
81124230:	013fffc4 	movi	r4,-1
81124234:	003a2706 	br	81122ad4 <__reset+0xfb102ad4>
81124238:	d9402c17 	ldw	r5,176(sp)
8112423c:	d9801e04 	addi	r6,sp,120
81124240:	9809883a 	mov	r4,r19
81124244:	112f2b40 	call	8112f2b4 <__ssprint_r>
81124248:	1039f91e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
8112424c:	d8c02017 	ldw	r3,128(sp)
81124250:	da000404 	addi	r8,sp,16
81124254:	003d8406 	br	81123868 <__reset+0xfb103868>
81124258:	0023883a 	mov	r17,zero
8112425c:	003d8306 	br	8112386c <__reset+0xfb10386c>
81124260:	01204574 	movhi	r4,33045
81124264:	213ea184 	addi	r4,r4,-1402
81124268:	d9002b15 	stw	r4,172(sp)
8112426c:	d9002b17 	ldw	r4,172(sp)
81124270:	1c47883a 	add	r3,r3,r17
81124274:	10800044 	addi	r2,r2,1
81124278:	41000015 	stw	r4,0(r8)
8112427c:	44400115 	stw	r17,4(r8)
81124280:	d8c02015 	stw	r3,128(sp)
81124284:	d8801f15 	stw	r2,124(sp)
81124288:	010001c4 	movi	r4,7
8112428c:	20bfcd16 	blt	r4,r2,811241c4 <__reset+0xfb1041c4>
81124290:	42000204 	addi	r8,r8,8
81124294:	003fd306 	br	811241e4 <__reset+0xfb1041e4>
81124298:	d9402c17 	ldw	r5,176(sp)
8112429c:	d9801e04 	addi	r6,sp,120
811242a0:	9809883a 	mov	r4,r19
811242a4:	112f2b40 	call	8112f2b4 <__ssprint_r>
811242a8:	1039e11e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
811242ac:	d8802617 	ldw	r2,152(sp)
811242b0:	d8c02017 	ldw	r3,128(sp)
811242b4:	da000404 	addi	r8,sp,16
811242b8:	003e1c06 	br	81123b2c <__reset+0xfb103b2c>
811242bc:	d8802917 	ldw	r2,164(sp)
811242c0:	00c00184 	movi	r3,6
811242c4:	1880012e 	bgeu	r3,r2,811242cc <___svfprintf_internal_r+0x1c38>
811242c8:	1805883a 	mov	r2,r3
811242cc:	d8802e15 	stw	r2,184(sp)
811242d0:	1000f316 	blt	r2,zero,811246a0 <___svfprintf_internal_r+0x200c>
811242d4:	04204574 	movhi	r16,33045
811242d8:	d8802a15 	stw	r2,168(sp)
811242dc:	dd002d15 	stw	r20,180(sp)
811242e0:	d8002915 	stw	zero,164(sp)
811242e4:	d8003215 	stw	zero,200(sp)
811242e8:	843e9f04 	addi	r16,r16,-1412
811242ec:	0039883a 	mov	fp,zero
811242f0:	003a9f06 	br	81122d70 <__reset+0xfb102d70>
811242f4:	01204574 	movhi	r4,33045
811242f8:	213ea584 	addi	r4,r4,-1386
811242fc:	d9003515 	stw	r4,212(sp)
81124300:	003b5f06 	br	81123080 <__reset+0xfb103080>
81124304:	d9402c17 	ldw	r5,176(sp)
81124308:	d9801e04 	addi	r6,sp,120
8112430c:	9809883a 	mov	r4,r19
81124310:	112f2b40 	call	8112f2b4 <__ssprint_r>
81124314:	1039c61e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
81124318:	d8802617 	ldw	r2,152(sp)
8112431c:	d9403317 	ldw	r5,204(sp)
81124320:	d8c02017 	ldw	r3,128(sp)
81124324:	da000404 	addi	r8,sp,16
81124328:	2885c83a 	sub	r2,r5,r2
8112432c:	003e1006 	br	81123b70 <__reset+0xfb103b70>
81124330:	00800044 	movi	r2,1
81124334:	10803fcc 	andi	r2,r2,255
81124338:	00c00044 	movi	r3,1
8112433c:	10fa3526 	beq	r2,r3,81122c14 <__reset+0xfb102c14>
81124340:	00c00084 	movi	r3,2
81124344:	10fb9e26 	beq	r2,r3,811231c0 <__reset+0xfb1031c0>
81124348:	003a6406 	br	81122cdc <__reset+0xfb102cdc>
8112434c:	0021883a 	mov	r16,zero
81124350:	003e0806 	br	81123b74 <__reset+0xfb103b74>
81124354:	07000b44 	movi	fp,45
81124358:	df002785 	stb	fp,158(sp)
8112435c:	003a0b06 	br	81122b8c <__reset+0xfb102b8c>
81124360:	d8c02d17 	ldw	r3,180(sp)
81124364:	d9002f17 	ldw	r4,188(sp)
81124368:	18800017 	ldw	r2,0(r3)
8112436c:	18c00104 	addi	r3,r3,4
81124370:	d8c02d15 	stw	r3,180(sp)
81124374:	11000015 	stw	r4,0(r2)
81124378:	0038f306 	br	81122748 <__reset+0xfb102748>
8112437c:	00c00b44 	movi	r3,45
81124380:	d8c02785 	stb	r3,158(sp)
81124384:	d8802a15 	stw	r2,168(sp)
81124388:	dc802b17 	ldw	r18,172(sp)
8112438c:	d8002915 	stw	zero,164(sp)
81124390:	07000b44 	movi	fp,45
81124394:	003a7306 	br	81122d64 <__reset+0xfb102d64>
81124398:	9080004c 	andi	r2,r18,1
8112439c:	1000941e 	bne	r2,zero,811245f0 <___svfprintf_internal_r+0x1f5c>
811243a0:	d8802117 	ldw	r2,132(sp)
811243a4:	1405c83a 	sub	r2,r2,r16
811243a8:	d8803315 	stw	r2,204(sp)
811243ac:	b441161e 	bne	r22,r17,81124808 <___svfprintf_internal_r+0x2174>
811243b0:	dd802617 	ldw	r22,152(sp)
811243b4:	00bfff44 	movi	r2,-3
811243b8:	b0801a16 	blt	r22,r2,81124424 <___svfprintf_internal_r+0x1d90>
811243bc:	d9402917 	ldw	r5,164(sp)
811243c0:	2d801816 	blt	r5,r22,81124424 <___svfprintf_internal_r+0x1d90>
811243c4:	dd803215 	stw	r22,200(sp)
811243c8:	003f3a06 	br	811240b4 <__reset+0xfb1040b4>
811243cc:	1025883a 	mov	r18,r2
811243d0:	0039883a 	mov	fp,zero
811243d4:	00800084 	movi	r2,2
811243d8:	003fd606 	br	81124334 <__reset+0xfb104334>
811243dc:	9080004c 	andi	r2,r18,1
811243e0:	103f191e 	bne	r2,zero,81124048 <__reset+0xfb104048>
811243e4:	d8802117 	ldw	r2,132(sp)
811243e8:	003f2806 	br	8112408c <__reset+0xfb10408c>
811243ec:	01204574 	movhi	r4,33045
811243f0:	213ea184 	addi	r4,r4,-1402
811243f4:	d9002b15 	stw	r4,172(sp)
811243f8:	003c7c06 	br	811235ec <__reset+0xfb1035ec>
811243fc:	e005883a 	mov	r2,fp
81124400:	003f2206 	br	8112408c <__reset+0xfb10408c>
81124404:	d9402917 	ldw	r5,164(sp)
81124408:	df002783 	ldbu	fp,158(sp)
8112440c:	dd002d15 	stw	r20,180(sp)
81124410:	d9402a15 	stw	r5,168(sp)
81124414:	d9402e15 	stw	r5,184(sp)
81124418:	d8002915 	stw	zero,164(sp)
8112441c:	d8003215 	stw	zero,200(sp)
81124420:	003a4c06 	br	81122d54 <__reset+0xfb102d54>
81124424:	8c7fff84 	addi	r17,r17,-2
81124428:	b5bfffc4 	addi	r22,r22,-1
8112442c:	dd802615 	stw	r22,152(sp)
81124430:	dc4022c5 	stb	r17,139(sp)
81124434:	b000c316 	blt	r22,zero,81124744 <___svfprintf_internal_r+0x20b0>
81124438:	00800ac4 	movi	r2,43
8112443c:	d8802305 	stb	r2,140(sp)
81124440:	00800244 	movi	r2,9
81124444:	15806e16 	blt	r2,r22,81124600 <___svfprintf_internal_r+0x1f6c>
81124448:	00800c04 	movi	r2,48
8112444c:	b5800c04 	addi	r22,r22,48
81124450:	d8802345 	stb	r2,141(sp)
81124454:	dd802385 	stb	r22,142(sp)
81124458:	d88023c4 	addi	r2,sp,143
8112445c:	df0022c4 	addi	fp,sp,139
81124460:	d8c03317 	ldw	r3,204(sp)
81124464:	1739c83a 	sub	fp,r2,fp
81124468:	d9003317 	ldw	r4,204(sp)
8112446c:	e0c7883a 	add	r3,fp,r3
81124470:	df003b15 	stw	fp,236(sp)
81124474:	d8c02e15 	stw	r3,184(sp)
81124478:	00800044 	movi	r2,1
8112447c:	1100b70e 	bge	r2,r4,8112475c <___svfprintf_internal_r+0x20c8>
81124480:	d8c02e17 	ldw	r3,184(sp)
81124484:	18c00044 	addi	r3,r3,1
81124488:	d8c02e15 	stw	r3,184(sp)
8112448c:	1805883a 	mov	r2,r3
81124490:	1800b016 	blt	r3,zero,81124754 <___svfprintf_internal_r+0x20c0>
81124494:	d8003215 	stw	zero,200(sp)
81124498:	003f1006 	br	811240dc <__reset+0xfb1040dc>
8112449c:	d8802917 	ldw	r2,164(sp)
811244a0:	103ec71e 	bne	r2,zero,81123fc0 <__reset+0xfb103fc0>
811244a4:	dc002915 	stw	r16,164(sp)
811244a8:	003ec506 	br	81123fc0 <__reset+0xfb103fc0>
811244ac:	d9402c17 	ldw	r5,176(sp)
811244b0:	d9801e04 	addi	r6,sp,120
811244b4:	9809883a 	mov	r4,r19
811244b8:	112f2b40 	call	8112f2b4 <__ssprint_r>
811244bc:	10395c1e 	bne	r2,zero,81122a30 <__reset+0xfb102a30>
811244c0:	dc402617 	ldw	r17,152(sp)
811244c4:	d8c02017 	ldw	r3,128(sp)
811244c8:	d8801f17 	ldw	r2,124(sp)
811244cc:	da000404 	addi	r8,sp,16
811244d0:	003e7706 	br	81123eb0 <__reset+0xfb103eb0>
811244d4:	582f883a 	mov	r23,r11
811244d8:	d8002915 	stw	zero,164(sp)
811244dc:	0038c406 	br	811227f0 <__reset+0xfb1027f0>
811244e0:	d8c02917 	ldw	r3,164(sp)
811244e4:	d8802104 	addi	r2,sp,132
811244e8:	d8800315 	stw	r2,12(sp)
811244ec:	d9403617 	ldw	r5,216(sp)
811244f0:	d8802504 	addi	r2,sp,148
811244f4:	d8800215 	stw	r2,8(sp)
811244f8:	d8802604 	addi	r2,sp,152
811244fc:	d8c00015 	stw	r3,0(sp)
81124500:	9809883a 	mov	r4,r19
81124504:	d8800115 	stw	r2,4(sp)
81124508:	01c000c4 	movi	r7,3
8112450c:	a00d883a 	mov	r6,r20
81124510:	da003e15 	stw	r8,248(sp)
81124514:	11289800 	call	81128980 <_dtoa_r>
81124518:	d9002917 	ldw	r4,164(sp)
8112451c:	da003e17 	ldw	r8,248(sp)
81124520:	1021883a 	mov	r16,r2
81124524:	1139883a 	add	fp,r2,r4
81124528:	2007883a 	mov	r3,r4
8112452c:	81000007 	ldb	r4,0(r16)
81124530:	00800c04 	movi	r2,48
81124534:	20806f26 	beq	r4,r2,811246f4 <___svfprintf_internal_r+0x2060>
81124538:	d8c02617 	ldw	r3,152(sp)
8112453c:	e0f9883a 	add	fp,fp,r3
81124540:	003ec206 	br	8112404c <__reset+0xfb10404c>
81124544:	00c00b44 	movi	r3,45
81124548:	2520003c 	xorhi	r20,r4,32768
8112454c:	d8c02a05 	stb	r3,168(sp)
81124550:	003ea106 	br	81123fd8 <__reset+0xfb103fd8>
81124554:	d8c03217 	ldw	r3,200(sp)
81124558:	00c0890e 	bge	zero,r3,81124780 <___svfprintf_internal_r+0x20ec>
8112455c:	00800044 	movi	r2,1
81124560:	d9003317 	ldw	r4,204(sp)
81124564:	1105883a 	add	r2,r2,r4
81124568:	d8802e15 	stw	r2,184(sp)
8112456c:	10005f16 	blt	r2,zero,811246ec <___svfprintf_internal_r+0x2058>
81124570:	044019c4 	movi	r17,103
81124574:	003ed906 	br	811240dc <__reset+0xfb1040dc>
81124578:	d9002917 	ldw	r4,164(sp)
8112457c:	20c00044 	addi	r3,r4,1
81124580:	003e9c06 	br	81123ff4 <__reset+0xfb103ff4>
81124584:	d9002917 	ldw	r4,164(sp)
81124588:	00c0680e 	bge	zero,r3,8112472c <___svfprintf_internal_r+0x2098>
8112458c:	2000461e 	bne	r4,zero,811246a8 <___svfprintf_internal_r+0x2014>
81124590:	9480004c 	andi	r18,r18,1
81124594:	9000441e 	bne	r18,zero,811246a8 <___svfprintf_internal_r+0x2014>
81124598:	1805883a 	mov	r2,r3
8112459c:	1800a016 	blt	r3,zero,81124820 <___svfprintf_internal_r+0x218c>
811245a0:	d8c03217 	ldw	r3,200(sp)
811245a4:	d8c02e15 	stw	r3,184(sp)
811245a8:	003ecc06 	br	811240dc <__reset+0xfb1040dc>
811245ac:	d9402917 	ldw	r5,164(sp)
811245b0:	d8802104 	addi	r2,sp,132
811245b4:	d8800315 	stw	r2,12(sp)
811245b8:	d9400015 	stw	r5,0(sp)
811245bc:	d8802504 	addi	r2,sp,148
811245c0:	d9403617 	ldw	r5,216(sp)
811245c4:	d8800215 	stw	r2,8(sp)
811245c8:	d8802604 	addi	r2,sp,152
811245cc:	d8800115 	stw	r2,4(sp)
811245d0:	01c000c4 	movi	r7,3
811245d4:	a00d883a 	mov	r6,r20
811245d8:	9809883a 	mov	r4,r19
811245dc:	da003e15 	stw	r8,248(sp)
811245e0:	11289800 	call	81128980 <_dtoa_r>
811245e4:	d8c02917 	ldw	r3,164(sp)
811245e8:	da003e17 	ldw	r8,248(sp)
811245ec:	1021883a 	mov	r16,r2
811245f0:	00801184 	movi	r2,70
811245f4:	80f9883a 	add	fp,r16,r3
811245f8:	88bfcc26 	beq	r17,r2,8112452c <__reset+0xfb10452c>
811245fc:	003e9306 	br	8112404c <__reset+0xfb10404c>
81124600:	df0022c4 	addi	fp,sp,139
81124604:	dc002915 	stw	r16,164(sp)
81124608:	9829883a 	mov	r20,r19
8112460c:	e021883a 	mov	r16,fp
81124610:	4027883a 	mov	r19,r8
81124614:	b009883a 	mov	r4,r22
81124618:	01400284 	movi	r5,10
8112461c:	1133d600 	call	81133d60 <__modsi3>
81124620:	10800c04 	addi	r2,r2,48
81124624:	843fffc4 	addi	r16,r16,-1
81124628:	b009883a 	mov	r4,r22
8112462c:	01400284 	movi	r5,10
81124630:	80800005 	stb	r2,0(r16)
81124634:	1133cdc0 	call	81133cdc <__divsi3>
81124638:	102d883a 	mov	r22,r2
8112463c:	00800244 	movi	r2,9
81124640:	15bff416 	blt	r2,r22,81124614 <__reset+0xfb104614>
81124644:	9811883a 	mov	r8,r19
81124648:	b0800c04 	addi	r2,r22,48
8112464c:	a027883a 	mov	r19,r20
81124650:	8029883a 	mov	r20,r16
81124654:	a17fffc4 	addi	r5,r20,-1
81124658:	a0bfffc5 	stb	r2,-1(r20)
8112465c:	dc002917 	ldw	r16,164(sp)
81124660:	2f00752e 	bgeu	r5,fp,81124838 <___svfprintf_internal_r+0x21a4>
81124664:	d9c02384 	addi	r7,sp,142
81124668:	3d0fc83a 	sub	r7,r7,r20
8112466c:	d9002344 	addi	r4,sp,141
81124670:	e1cf883a 	add	r7,fp,r7
81124674:	00000106 	br	8112467c <___svfprintf_internal_r+0x1fe8>
81124678:	28800003 	ldbu	r2,0(r5)
8112467c:	20800005 	stb	r2,0(r4)
81124680:	21000044 	addi	r4,r4,1
81124684:	29400044 	addi	r5,r5,1
81124688:	21fffb1e 	bne	r4,r7,81124678 <__reset+0xfb104678>
8112468c:	d8802304 	addi	r2,sp,140
81124690:	1505c83a 	sub	r2,r2,r20
81124694:	d8c02344 	addi	r3,sp,141
81124698:	1885883a 	add	r2,r3,r2
8112469c:	003f7006 	br	81124460 <__reset+0xfb104460>
811246a0:	0005883a 	mov	r2,zero
811246a4:	003f0b06 	br	811242d4 <__reset+0xfb1042d4>
811246a8:	d9002917 	ldw	r4,164(sp)
811246ac:	d8c03217 	ldw	r3,200(sp)
811246b0:	20800044 	addi	r2,r4,1
811246b4:	1885883a 	add	r2,r3,r2
811246b8:	d8802e15 	stw	r2,184(sp)
811246bc:	103e870e 	bge	r2,zero,811240dc <__reset+0xfb1040dc>
811246c0:	0005883a 	mov	r2,zero
811246c4:	003e8506 	br	811240dc <__reset+0xfb1040dc>
811246c8:	01204574 	movhi	r4,33045
811246cc:	213ea184 	addi	r4,r4,-1402
811246d0:	d9002b15 	stw	r4,172(sp)
811246d4:	003cc506 	br	811239ec <__reset+0xfb1039ec>
811246d8:	d8c03217 	ldw	r3,200(sp)
811246dc:	18c00044 	addi	r3,r3,1
811246e0:	d8c02e15 	stw	r3,184(sp)
811246e4:	1805883a 	mov	r2,r3
811246e8:	183fa10e 	bge	r3,zero,81124570 <__reset+0xfb104570>
811246ec:	0005883a 	mov	r2,zero
811246f0:	003f9f06 	br	81124570 <__reset+0xfb104570>
811246f4:	d9003617 	ldw	r4,216(sp)
811246f8:	000d883a 	mov	r6,zero
811246fc:	000f883a 	mov	r7,zero
81124700:	a00b883a 	mov	r5,r20
81124704:	d8c03d15 	stw	r3,244(sp)
81124708:	da003e15 	stw	r8,248(sp)
8112470c:	11352300 	call	81135230 <__eqdf2>
81124710:	d8c03d17 	ldw	r3,244(sp)
81124714:	da003e17 	ldw	r8,248(sp)
81124718:	103f8726 	beq	r2,zero,81124538 <__reset+0xfb104538>
8112471c:	00800044 	movi	r2,1
81124720:	10c7c83a 	sub	r3,r2,r3
81124724:	d8c02615 	stw	r3,152(sp)
81124728:	003f8406 	br	8112453c <__reset+0xfb10453c>
8112472c:	20000e1e 	bne	r4,zero,81124768 <___svfprintf_internal_r+0x20d4>
81124730:	9480004c 	andi	r18,r18,1
81124734:	90000c1e 	bne	r18,zero,81124768 <___svfprintf_internal_r+0x20d4>
81124738:	00800044 	movi	r2,1
8112473c:	d8802e15 	stw	r2,184(sp)
81124740:	003e6606 	br	811240dc <__reset+0xfb1040dc>
81124744:	00800b44 	movi	r2,45
81124748:	05adc83a 	sub	r22,zero,r22
8112474c:	d8802305 	stb	r2,140(sp)
81124750:	003f3b06 	br	81124440 <__reset+0xfb104440>
81124754:	0005883a 	mov	r2,zero
81124758:	003f4e06 	br	81124494 <__reset+0xfb104494>
8112475c:	90a4703a 	and	r18,r18,r2
81124760:	903f4a26 	beq	r18,zero,8112448c <__reset+0xfb10448c>
81124764:	003f4606 	br	81124480 <__reset+0xfb104480>
81124768:	d8c02917 	ldw	r3,164(sp)
8112476c:	18c00084 	addi	r3,r3,2
81124770:	d8c02e15 	stw	r3,184(sp)
81124774:	1805883a 	mov	r2,r3
81124778:	183e580e 	bge	r3,zero,811240dc <__reset+0xfb1040dc>
8112477c:	003fd006 	br	811246c0 <__reset+0xfb1046c0>
81124780:	00800084 	movi	r2,2
81124784:	10c5c83a 	sub	r2,r2,r3
81124788:	003f7506 	br	81124560 <__reset+0xfb104560>
8112478c:	d8802d17 	ldw	r2,180(sp)
81124790:	d9002d17 	ldw	r4,180(sp)
81124794:	bc400043 	ldbu	r17,1(r23)
81124798:	10800017 	ldw	r2,0(r2)
8112479c:	582f883a 	mov	r23,r11
811247a0:	d8802915 	stw	r2,164(sp)
811247a4:	20800104 	addi	r2,r4,4
811247a8:	d9002917 	ldw	r4,164(sp)
811247ac:	d8802d15 	stw	r2,180(sp)
811247b0:	203df00e 	bge	r4,zero,81123f74 <__reset+0xfb103f74>
811247b4:	8c403fcc 	andi	r17,r17,255
811247b8:	00bfffc4 	movi	r2,-1
811247bc:	8c40201c 	xori	r17,r17,128
811247c0:	d8802915 	stw	r2,164(sp)
811247c4:	8c7fe004 	addi	r17,r17,-128
811247c8:	00380806 	br	811227ec <__reset+0xfb1027ec>
811247cc:	9080004c 	andi	r2,r18,1
811247d0:	0039883a 	mov	fp,zero
811247d4:	10000726 	beq	r2,zero,811247f4 <___svfprintf_internal_r+0x2160>
811247d8:	d8c02817 	ldw	r3,160(sp)
811247dc:	dc001dc4 	addi	r16,sp,119
811247e0:	00800c04 	movi	r2,48
811247e4:	1c07c83a 	sub	r3,r3,r16
811247e8:	d8801dc5 	stb	r2,119(sp)
811247ec:	d8c02e15 	stw	r3,184(sp)
811247f0:	00395206 	br	81122d3c <__reset+0xfb102d3c>
811247f4:	d8002e15 	stw	zero,184(sp)
811247f8:	dc001e04 	addi	r16,sp,120
811247fc:	00394f06 	br	81122d3c <__reset+0xfb102d3c>
81124800:	0005883a 	mov	r2,zero
81124804:	003e3206 	br	811240d0 <__reset+0xfb1040d0>
81124808:	dd802617 	ldw	r22,152(sp)
8112480c:	003f0606 	br	81124428 <__reset+0xfb104428>
81124810:	d9c02785 	stb	r7,158(sp)
81124814:	003a5106 	br	8112315c <__reset+0xfb10315c>
81124818:	d9c02785 	stb	r7,158(sp)
8112481c:	003a3706 	br	811230fc <__reset+0xfb1030fc>
81124820:	0005883a 	mov	r2,zero
81124824:	003f5e06 	br	811245a0 <__reset+0xfb1045a0>
81124828:	d9c02785 	stb	r7,158(sp)
8112482c:	00391706 	br	81122c8c <__reset+0xfb102c8c>
81124830:	d9c02785 	stb	r7,158(sp)
81124834:	0038e606 	br	81122bd0 <__reset+0xfb102bd0>
81124838:	d8802344 	addi	r2,sp,141
8112483c:	003f0806 	br	81124460 <__reset+0xfb104460>
81124840:	d9c02785 	stb	r7,158(sp)
81124844:	0038b706 	br	81122b24 <__reset+0xfb102b24>
81124848:	d9c02785 	stb	r7,158(sp)
8112484c:	003adc06 	br	811233c0 <__reset+0xfb1033c0>
81124850:	d9403917 	ldw	r5,228(sp)
81124854:	00800304 	movi	r2,12
81124858:	28800015 	stw	r2,0(r5)
8112485c:	00bfffc4 	movi	r2,-1
81124860:	00387806 	br	81122a44 <__reset+0xfb102a44>
81124864:	d9c02785 	stb	r7,158(sp)
81124868:	003abf06 	br	81123368 <__reset+0xfb103368>
8112486c:	d9c02785 	stb	r7,158(sp)
81124870:	003a9b06 	br	811232e0 <__reset+0xfb1032e0>

81124874 <___vfprintf_internal_r>:
81124874:	deffb804 	addi	sp,sp,-288
81124878:	de00012e 	bgeu	sp,et,81124880 <___vfprintf_internal_r+0xc>
8112487c:	003b68fa 	trap	3
81124880:	dfc04715 	stw	ra,284(sp)
81124884:	ddc04515 	stw	r23,276(sp)
81124888:	dd404315 	stw	r21,268(sp)
8112488c:	d9002c15 	stw	r4,176(sp)
81124890:	282f883a 	mov	r23,r5
81124894:	302b883a 	mov	r21,r6
81124898:	d9c02d15 	stw	r7,180(sp)
8112489c:	df004615 	stw	fp,280(sp)
811248a0:	dd804415 	stw	r22,272(sp)
811248a4:	dd004215 	stw	r20,264(sp)
811248a8:	dcc04115 	stw	r19,260(sp)
811248ac:	dc804015 	stw	r18,256(sp)
811248b0:	dc403f15 	stw	r17,252(sp)
811248b4:	dc003e15 	stw	r16,248(sp)
811248b8:	112b57c0 	call	8112b57c <_localeconv_r>
811248bc:	10800017 	ldw	r2,0(r2)
811248c0:	1009883a 	mov	r4,r2
811248c4:	d8803415 	stw	r2,208(sp)
811248c8:	112235c0 	call	8112235c <strlen>
811248cc:	d8803715 	stw	r2,220(sp)
811248d0:	d8802c17 	ldw	r2,176(sp)
811248d4:	10000226 	beq	r2,zero,811248e0 <___vfprintf_internal_r+0x6c>
811248d8:	10800e17 	ldw	r2,56(r2)
811248dc:	1000f926 	beq	r2,zero,81124cc4 <___vfprintf_internal_r+0x450>
811248e0:	b880030b 	ldhu	r2,12(r23)
811248e4:	10c8000c 	andi	r3,r2,8192
811248e8:	1800061e 	bne	r3,zero,81124904 <___vfprintf_internal_r+0x90>
811248ec:	b9001917 	ldw	r4,100(r23)
811248f0:	00f7ffc4 	movi	r3,-8193
811248f4:	10880014 	ori	r2,r2,8192
811248f8:	20c6703a 	and	r3,r4,r3
811248fc:	b880030d 	sth	r2,12(r23)
81124900:	b8c01915 	stw	r3,100(r23)
81124904:	10c0020c 	andi	r3,r2,8
81124908:	1800c126 	beq	r3,zero,81124c10 <___vfprintf_internal_r+0x39c>
8112490c:	b8c00417 	ldw	r3,16(r23)
81124910:	1800bf26 	beq	r3,zero,81124c10 <___vfprintf_internal_r+0x39c>
81124914:	1080068c 	andi	r2,r2,26
81124918:	00c00284 	movi	r3,10
8112491c:	10c0c426 	beq	r2,r3,81124c30 <___vfprintf_internal_r+0x3bc>
81124920:	d8c00404 	addi	r3,sp,16
81124924:	05204574 	movhi	r20,33045
81124928:	d9001e04 	addi	r4,sp,120
8112492c:	a53ea984 	addi	r20,r20,-1370
81124930:	d8c01e15 	stw	r3,120(sp)
81124934:	d8002015 	stw	zero,128(sp)
81124938:	d8001f15 	stw	zero,124(sp)
8112493c:	d8003315 	stw	zero,204(sp)
81124940:	d8003615 	stw	zero,216(sp)
81124944:	d8003815 	stw	zero,224(sp)
81124948:	1811883a 	mov	r8,r3
8112494c:	d8003915 	stw	zero,228(sp)
81124950:	d8003a15 	stw	zero,232(sp)
81124954:	d8002f15 	stw	zero,188(sp)
81124958:	d9002815 	stw	r4,160(sp)
8112495c:	a8800007 	ldb	r2,0(r21)
81124960:	10027b26 	beq	r2,zero,81125350 <___vfprintf_internal_r+0xadc>
81124964:	00c00944 	movi	r3,37
81124968:	a821883a 	mov	r16,r21
8112496c:	10c0021e 	bne	r2,r3,81124978 <___vfprintf_internal_r+0x104>
81124970:	00001406 	br	811249c4 <___vfprintf_internal_r+0x150>
81124974:	10c00326 	beq	r2,r3,81124984 <___vfprintf_internal_r+0x110>
81124978:	84000044 	addi	r16,r16,1
8112497c:	80800007 	ldb	r2,0(r16)
81124980:	103ffc1e 	bne	r2,zero,81124974 <__reset+0xfb104974>
81124984:	8563c83a 	sub	r17,r16,r21
81124988:	88000e26 	beq	r17,zero,811249c4 <___vfprintf_internal_r+0x150>
8112498c:	d8c02017 	ldw	r3,128(sp)
81124990:	d8801f17 	ldw	r2,124(sp)
81124994:	45400015 	stw	r21,0(r8)
81124998:	1c47883a 	add	r3,r3,r17
8112499c:	10800044 	addi	r2,r2,1
811249a0:	d8c02015 	stw	r3,128(sp)
811249a4:	44400115 	stw	r17,4(r8)
811249a8:	d8801f15 	stw	r2,124(sp)
811249ac:	00c001c4 	movi	r3,7
811249b0:	1880a716 	blt	r3,r2,81124c50 <___vfprintf_internal_r+0x3dc>
811249b4:	42000204 	addi	r8,r8,8
811249b8:	d9402f17 	ldw	r5,188(sp)
811249bc:	2c4b883a 	add	r5,r5,r17
811249c0:	d9402f15 	stw	r5,188(sp)
811249c4:	80800007 	ldb	r2,0(r16)
811249c8:	1000a826 	beq	r2,zero,81124c6c <___vfprintf_internal_r+0x3f8>
811249cc:	84400047 	ldb	r17,1(r16)
811249d0:	00bfffc4 	movi	r2,-1
811249d4:	85400044 	addi	r21,r16,1
811249d8:	d8002785 	stb	zero,158(sp)
811249dc:	0007883a 	mov	r3,zero
811249e0:	000f883a 	mov	r7,zero
811249e4:	d8802915 	stw	r2,164(sp)
811249e8:	d8003115 	stw	zero,196(sp)
811249ec:	0025883a 	mov	r18,zero
811249f0:	01401604 	movi	r5,88
811249f4:	01800244 	movi	r6,9
811249f8:	02800a84 	movi	r10,42
811249fc:	02401b04 	movi	r9,108
81124a00:	ad400044 	addi	r21,r21,1
81124a04:	88bff804 	addi	r2,r17,-32
81124a08:	28830436 	bltu	r5,r2,8112561c <___vfprintf_internal_r+0xda8>
81124a0c:	100490ba 	slli	r2,r2,2
81124a10:	012044b4 	movhi	r4,33042
81124a14:	21128904 	addi	r4,r4,18980
81124a18:	1105883a 	add	r2,r2,r4
81124a1c:	10800017 	ldw	r2,0(r2)
81124a20:	1000683a 	jmp	r2
81124a24:	8112553c 	xorhi	r4,r16,18772
81124a28:	8112561c 	xori	r4,r16,18776
81124a2c:	8112561c 	xori	r4,r16,18776
81124a30:	8112555c 	xori	r4,r16,18773
81124a34:	8112561c 	xori	r4,r16,18776
81124a38:	8112561c 	xori	r4,r16,18776
81124a3c:	8112561c 	xori	r4,r16,18776
81124a40:	8112561c 	xori	r4,r16,18776
81124a44:	8112561c 	xori	r4,r16,18776
81124a48:	8112561c 	xori	r4,r16,18776
81124a4c:	81124cd0 	cmplti	r4,r16,18739
81124a50:	81125478 	rdprs	r4,r16,18769
81124a54:	8112561c 	xori	r4,r16,18776
81124a58:	81124b98 	cmpnei	r4,r16,18734
81124a5c:	81124cf8 	rdprs	r4,r16,18739
81124a60:	8112561c 	xori	r4,r16,18776
81124a64:	81124d38 	rdprs	r4,r16,18740
81124a68:	81124d44 	addi	r4,r16,18741
81124a6c:	81124d44 	addi	r4,r16,18741
81124a70:	81124d44 	addi	r4,r16,18741
81124a74:	81124d44 	addi	r4,r16,18741
81124a78:	81124d44 	addi	r4,r16,18741
81124a7c:	81124d44 	addi	r4,r16,18741
81124a80:	81124d44 	addi	r4,r16,18741
81124a84:	81124d44 	addi	r4,r16,18741
81124a88:	81124d44 	addi	r4,r16,18741
81124a8c:	8112561c 	xori	r4,r16,18776
81124a90:	8112561c 	xori	r4,r16,18776
81124a94:	8112561c 	xori	r4,r16,18776
81124a98:	8112561c 	xori	r4,r16,18776
81124a9c:	8112561c 	xori	r4,r16,18776
81124aa0:	8112561c 	xori	r4,r16,18776
81124aa4:	8112561c 	xori	r4,r16,18776
81124aa8:	8112561c 	xori	r4,r16,18776
81124aac:	8112561c 	xori	r4,r16,18776
81124ab0:	8112561c 	xori	r4,r16,18776
81124ab4:	81124d78 	rdprs	r4,r16,18741
81124ab8:	81124e34 	orhi	r4,r16,18744
81124abc:	8112561c 	xori	r4,r16,18776
81124ac0:	81124e34 	orhi	r4,r16,18744
81124ac4:	8112561c 	xori	r4,r16,18776
81124ac8:	8112561c 	xori	r4,r16,18776
81124acc:	8112561c 	xori	r4,r16,18776
81124ad0:	8112561c 	xori	r4,r16,18776
81124ad4:	81124ed4 	ori	r4,r16,18747
81124ad8:	8112561c 	xori	r4,r16,18776
81124adc:	8112561c 	xori	r4,r16,18776
81124ae0:	81124ee0 	cmpeqi	r4,r16,18747
81124ae4:	8112561c 	xori	r4,r16,18776
81124ae8:	8112561c 	xori	r4,r16,18776
81124aec:	8112561c 	xori	r4,r16,18776
81124af0:	8112561c 	xori	r4,r16,18776
81124af4:	8112561c 	xori	r4,r16,18776
81124af8:	81125358 	cmpnei	r4,r16,18765
81124afc:	8112561c 	xori	r4,r16,18776
81124b00:	8112561c 	xori	r4,r16,18776
81124b04:	811253b8 	rdprs	r4,r16,18766
81124b08:	8112561c 	xori	r4,r16,18776
81124b0c:	8112561c 	xori	r4,r16,18776
81124b10:	8112561c 	xori	r4,r16,18776
81124b14:	8112561c 	xori	r4,r16,18776
81124b18:	8112561c 	xori	r4,r16,18776
81124b1c:	8112561c 	xori	r4,r16,18776
81124b20:	8112561c 	xori	r4,r16,18776
81124b24:	8112561c 	xori	r4,r16,18776
81124b28:	8112561c 	xori	r4,r16,18776
81124b2c:	8112561c 	xori	r4,r16,18776
81124b30:	811255c8 	cmpgei	r4,r16,18775
81124b34:	81125568 	cmpgeui	r4,r16,18773
81124b38:	81124e34 	orhi	r4,r16,18744
81124b3c:	81124e34 	orhi	r4,r16,18744
81124b40:	81124e34 	orhi	r4,r16,18744
81124b44:	81125578 	rdprs	r4,r16,18773
81124b48:	81125568 	cmpgeui	r4,r16,18773
81124b4c:	8112561c 	xori	r4,r16,18776
81124b50:	8112561c 	xori	r4,r16,18776
81124b54:	81125584 	addi	r4,r16,18774
81124b58:	8112561c 	xori	r4,r16,18776
81124b5c:	81125594 	ori	r4,r16,18774
81124b60:	81125468 	cmpgeui	r4,r16,18769
81124b64:	81124ba4 	muli	r4,r16,18734
81124b68:	81125488 	cmpgei	r4,r16,18770
81124b6c:	8112561c 	xori	r4,r16,18776
81124b70:	81125494 	ori	r4,r16,18770
81124b74:	8112561c 	xori	r4,r16,18776
81124b78:	811254f0 	cmpltui	r4,r16,18771
81124b7c:	8112561c 	xori	r4,r16,18776
81124b80:	8112561c 	xori	r4,r16,18776
81124b84:	81125500 	call	88112550 <__reset+0x20f2550>
81124b88:	d9003117 	ldw	r4,196(sp)
81124b8c:	d8802d15 	stw	r2,180(sp)
81124b90:	0109c83a 	sub	r4,zero,r4
81124b94:	d9003115 	stw	r4,196(sp)
81124b98:	94800114 	ori	r18,r18,4
81124b9c:	ac400007 	ldb	r17,0(r21)
81124ba0:	003f9706 	br	81124a00 <__reset+0xfb104a00>
81124ba4:	00800c04 	movi	r2,48
81124ba8:	d9002d17 	ldw	r4,180(sp)
81124bac:	d9402917 	ldw	r5,164(sp)
81124bb0:	d8802705 	stb	r2,156(sp)
81124bb4:	00801e04 	movi	r2,120
81124bb8:	d8802745 	stb	r2,157(sp)
81124bbc:	d8002785 	stb	zero,158(sp)
81124bc0:	20c00104 	addi	r3,r4,4
81124bc4:	24c00017 	ldw	r19,0(r4)
81124bc8:	002d883a 	mov	r22,zero
81124bcc:	90800094 	ori	r2,r18,2
81124bd0:	28029a16 	blt	r5,zero,8112563c <___vfprintf_internal_r+0xdc8>
81124bd4:	00bfdfc4 	movi	r2,-129
81124bd8:	90a4703a 	and	r18,r18,r2
81124bdc:	d8c02d15 	stw	r3,180(sp)
81124be0:	94800094 	ori	r18,r18,2
81124be4:	9802871e 	bne	r19,zero,81125604 <___vfprintf_internal_r+0xd90>
81124be8:	00a04574 	movhi	r2,33045
81124bec:	10be9a04 	addi	r2,r2,-1432
81124bf0:	d8803915 	stw	r2,228(sp)
81124bf4:	04401e04 	movi	r17,120
81124bf8:	d8802917 	ldw	r2,164(sp)
81124bfc:	0039883a 	mov	fp,zero
81124c00:	1001e926 	beq	r2,zero,811253a8 <___vfprintf_internal_r+0xb34>
81124c04:	0027883a 	mov	r19,zero
81124c08:	002d883a 	mov	r22,zero
81124c0c:	00020506 	br	81125424 <___vfprintf_internal_r+0xbb0>
81124c10:	d9002c17 	ldw	r4,176(sp)
81124c14:	b80b883a 	mov	r5,r23
81124c18:	11285c00 	call	811285c0 <__swsetup_r>
81124c1c:	1005ac1e 	bne	r2,zero,811262d0 <___vfprintf_internal_r+0x1a5c>
81124c20:	b880030b 	ldhu	r2,12(r23)
81124c24:	00c00284 	movi	r3,10
81124c28:	1080068c 	andi	r2,r2,26
81124c2c:	10ff3c1e 	bne	r2,r3,81124920 <__reset+0xfb104920>
81124c30:	b880038f 	ldh	r2,14(r23)
81124c34:	103f3a16 	blt	r2,zero,81124920 <__reset+0xfb104920>
81124c38:	d9c02d17 	ldw	r7,180(sp)
81124c3c:	d9002c17 	ldw	r4,176(sp)
81124c40:	a80d883a 	mov	r6,r21
81124c44:	b80b883a 	mov	r5,r23
81124c48:	1126a900 	call	81126a90 <__sbprintf>
81124c4c:	00001106 	br	81124c94 <___vfprintf_internal_r+0x420>
81124c50:	d9002c17 	ldw	r4,176(sp)
81124c54:	d9801e04 	addi	r6,sp,120
81124c58:	b80b883a 	mov	r5,r23
81124c5c:	1130a640 	call	81130a64 <__sprint_r>
81124c60:	1000081e 	bne	r2,zero,81124c84 <___vfprintf_internal_r+0x410>
81124c64:	da000404 	addi	r8,sp,16
81124c68:	003f5306 	br	811249b8 <__reset+0xfb1049b8>
81124c6c:	d8802017 	ldw	r2,128(sp)
81124c70:	10000426 	beq	r2,zero,81124c84 <___vfprintf_internal_r+0x410>
81124c74:	d9002c17 	ldw	r4,176(sp)
81124c78:	d9801e04 	addi	r6,sp,120
81124c7c:	b80b883a 	mov	r5,r23
81124c80:	1130a640 	call	81130a64 <__sprint_r>
81124c84:	b880030b 	ldhu	r2,12(r23)
81124c88:	1080100c 	andi	r2,r2,64
81124c8c:	1005901e 	bne	r2,zero,811262d0 <___vfprintf_internal_r+0x1a5c>
81124c90:	d8802f17 	ldw	r2,188(sp)
81124c94:	dfc04717 	ldw	ra,284(sp)
81124c98:	df004617 	ldw	fp,280(sp)
81124c9c:	ddc04517 	ldw	r23,276(sp)
81124ca0:	dd804417 	ldw	r22,272(sp)
81124ca4:	dd404317 	ldw	r21,268(sp)
81124ca8:	dd004217 	ldw	r20,264(sp)
81124cac:	dcc04117 	ldw	r19,260(sp)
81124cb0:	dc804017 	ldw	r18,256(sp)
81124cb4:	dc403f17 	ldw	r17,252(sp)
81124cb8:	dc003e17 	ldw	r16,248(sp)
81124cbc:	dec04804 	addi	sp,sp,288
81124cc0:	f800283a 	ret
81124cc4:	d9002c17 	ldw	r4,176(sp)
81124cc8:	112a6300 	call	8112a630 <__sinit>
81124ccc:	003f0406 	br	811248e0 <__reset+0xfb1048e0>
81124cd0:	d8802d17 	ldw	r2,180(sp)
81124cd4:	d9002d17 	ldw	r4,180(sp)
81124cd8:	10800017 	ldw	r2,0(r2)
81124cdc:	d8803115 	stw	r2,196(sp)
81124ce0:	20800104 	addi	r2,r4,4
81124ce4:	d9003117 	ldw	r4,196(sp)
81124ce8:	203fa716 	blt	r4,zero,81124b88 <__reset+0xfb104b88>
81124cec:	d8802d15 	stw	r2,180(sp)
81124cf0:	ac400007 	ldb	r17,0(r21)
81124cf4:	003f4206 	br	81124a00 <__reset+0xfb104a00>
81124cf8:	ac400007 	ldb	r17,0(r21)
81124cfc:	aac00044 	addi	r11,r21,1
81124d00:	8a872826 	beq	r17,r10,811269a4 <___vfprintf_internal_r+0x2130>
81124d04:	88bff404 	addi	r2,r17,-48
81124d08:	0009883a 	mov	r4,zero
81124d0c:	30867d36 	bltu	r6,r2,81126704 <___vfprintf_internal_r+0x1e90>
81124d10:	5c400007 	ldb	r17,0(r11)
81124d14:	210002a4 	muli	r4,r4,10
81124d18:	5d400044 	addi	r21,r11,1
81124d1c:	a817883a 	mov	r11,r21
81124d20:	2089883a 	add	r4,r4,r2
81124d24:	88bff404 	addi	r2,r17,-48
81124d28:	30bff92e 	bgeu	r6,r2,81124d10 <__reset+0xfb104d10>
81124d2c:	2005c916 	blt	r4,zero,81126454 <___vfprintf_internal_r+0x1be0>
81124d30:	d9002915 	stw	r4,164(sp)
81124d34:	003f3306 	br	81124a04 <__reset+0xfb104a04>
81124d38:	94802014 	ori	r18,r18,128
81124d3c:	ac400007 	ldb	r17,0(r21)
81124d40:	003f2f06 	br	81124a00 <__reset+0xfb104a00>
81124d44:	a809883a 	mov	r4,r21
81124d48:	d8003115 	stw	zero,196(sp)
81124d4c:	88bff404 	addi	r2,r17,-48
81124d50:	0017883a 	mov	r11,zero
81124d54:	24400007 	ldb	r17,0(r4)
81124d58:	5ac002a4 	muli	r11,r11,10
81124d5c:	ad400044 	addi	r21,r21,1
81124d60:	a809883a 	mov	r4,r21
81124d64:	12d7883a 	add	r11,r2,r11
81124d68:	88bff404 	addi	r2,r17,-48
81124d6c:	30bff92e 	bgeu	r6,r2,81124d54 <__reset+0xfb104d54>
81124d70:	dac03115 	stw	r11,196(sp)
81124d74:	003f2306 	br	81124a04 <__reset+0xfb104a04>
81124d78:	18c03fcc 	andi	r3,r3,255
81124d7c:	18072b1e 	bne	r3,zero,81126a2c <___vfprintf_internal_r+0x21b8>
81124d80:	94800414 	ori	r18,r18,16
81124d84:	9080080c 	andi	r2,r18,32
81124d88:	10037b26 	beq	r2,zero,81125b78 <___vfprintf_internal_r+0x1304>
81124d8c:	d9402d17 	ldw	r5,180(sp)
81124d90:	28800117 	ldw	r2,4(r5)
81124d94:	2cc00017 	ldw	r19,0(r5)
81124d98:	29400204 	addi	r5,r5,8
81124d9c:	d9402d15 	stw	r5,180(sp)
81124da0:	102d883a 	mov	r22,r2
81124da4:	10044b16 	blt	r2,zero,81125ed4 <___vfprintf_internal_r+0x1660>
81124da8:	d9402917 	ldw	r5,164(sp)
81124dac:	df002783 	ldbu	fp,158(sp)
81124db0:	2803bc16 	blt	r5,zero,81125ca4 <___vfprintf_internal_r+0x1430>
81124db4:	00ffdfc4 	movi	r3,-129
81124db8:	9d84b03a 	or	r2,r19,r22
81124dbc:	90e4703a 	and	r18,r18,r3
81124dc0:	10017726 	beq	r2,zero,811253a0 <___vfprintf_internal_r+0xb2c>
81124dc4:	b0038326 	beq	r22,zero,81125bd4 <___vfprintf_internal_r+0x1360>
81124dc8:	dc402a15 	stw	r17,168(sp)
81124dcc:	dc001e04 	addi	r16,sp,120
81124dd0:	b023883a 	mov	r17,r22
81124dd4:	402d883a 	mov	r22,r8
81124dd8:	9809883a 	mov	r4,r19
81124ddc:	880b883a 	mov	r5,r17
81124de0:	01800284 	movi	r6,10
81124de4:	000f883a 	mov	r7,zero
81124de8:	113379c0 	call	8113379c <__umoddi3>
81124dec:	10800c04 	addi	r2,r2,48
81124df0:	843fffc4 	addi	r16,r16,-1
81124df4:	9809883a 	mov	r4,r19
81124df8:	880b883a 	mov	r5,r17
81124dfc:	80800005 	stb	r2,0(r16)
81124e00:	01800284 	movi	r6,10
81124e04:	000f883a 	mov	r7,zero
81124e08:	113321c0 	call	8113321c <__udivdi3>
81124e0c:	1027883a 	mov	r19,r2
81124e10:	10c4b03a 	or	r2,r2,r3
81124e14:	1823883a 	mov	r17,r3
81124e18:	103fef1e 	bne	r2,zero,81124dd8 <__reset+0xfb104dd8>
81124e1c:	d8c02817 	ldw	r3,160(sp)
81124e20:	dc402a17 	ldw	r17,168(sp)
81124e24:	b011883a 	mov	r8,r22
81124e28:	1c07c83a 	sub	r3,r3,r16
81124e2c:	d8c02e15 	stw	r3,184(sp)
81124e30:	00005906 	br	81124f98 <___vfprintf_internal_r+0x724>
81124e34:	18c03fcc 	andi	r3,r3,255
81124e38:	1806fa1e 	bne	r3,zero,81126a24 <___vfprintf_internal_r+0x21b0>
81124e3c:	9080020c 	andi	r2,r18,8
81124e40:	10048a26 	beq	r2,zero,8112606c <___vfprintf_internal_r+0x17f8>
81124e44:	d8c02d17 	ldw	r3,180(sp)
81124e48:	d9002d17 	ldw	r4,180(sp)
81124e4c:	d9402d17 	ldw	r5,180(sp)
81124e50:	18c00017 	ldw	r3,0(r3)
81124e54:	21000117 	ldw	r4,4(r4)
81124e58:	29400204 	addi	r5,r5,8
81124e5c:	d8c03615 	stw	r3,216(sp)
81124e60:	d9003815 	stw	r4,224(sp)
81124e64:	d9402d15 	stw	r5,180(sp)
81124e68:	d9003617 	ldw	r4,216(sp)
81124e6c:	d9403817 	ldw	r5,224(sp)
81124e70:	da003d15 	stw	r8,244(sp)
81124e74:	04000044 	movi	r16,1
81124e78:	112d0c80 	call	8112d0c8 <__fpclassifyd>
81124e7c:	da003d17 	ldw	r8,244(sp)
81124e80:	14041f1e 	bne	r2,r16,81125f00 <___vfprintf_internal_r+0x168c>
81124e84:	d9003617 	ldw	r4,216(sp)
81124e88:	d9403817 	ldw	r5,224(sp)
81124e8c:	000d883a 	mov	r6,zero
81124e90:	000f883a 	mov	r7,zero
81124e94:	11352b80 	call	811352b8 <__ledf2>
81124e98:	da003d17 	ldw	r8,244(sp)
81124e9c:	1005be16 	blt	r2,zero,81126598 <___vfprintf_internal_r+0x1d24>
81124ea0:	df002783 	ldbu	fp,158(sp)
81124ea4:	008011c4 	movi	r2,71
81124ea8:	1445330e 	bge	r2,r17,81126378 <___vfprintf_internal_r+0x1b04>
81124eac:	04204574 	movhi	r16,33045
81124eb0:	843e9204 	addi	r16,r16,-1464
81124eb4:	00c000c4 	movi	r3,3
81124eb8:	00bfdfc4 	movi	r2,-129
81124ebc:	d8c02a15 	stw	r3,168(sp)
81124ec0:	90a4703a 	and	r18,r18,r2
81124ec4:	d8c02e15 	stw	r3,184(sp)
81124ec8:	d8002915 	stw	zero,164(sp)
81124ecc:	d8003215 	stw	zero,200(sp)
81124ed0:	00003706 	br	81124fb0 <___vfprintf_internal_r+0x73c>
81124ed4:	94800214 	ori	r18,r18,8
81124ed8:	ac400007 	ldb	r17,0(r21)
81124edc:	003ec806 	br	81124a00 <__reset+0xfb104a00>
81124ee0:	18c03fcc 	andi	r3,r3,255
81124ee4:	1806db1e 	bne	r3,zero,81126a54 <___vfprintf_internal_r+0x21e0>
81124ee8:	94800414 	ori	r18,r18,16
81124eec:	9080080c 	andi	r2,r18,32
81124ef0:	1002d826 	beq	r2,zero,81125a54 <___vfprintf_internal_r+0x11e0>
81124ef4:	d9402d17 	ldw	r5,180(sp)
81124ef8:	d8c02917 	ldw	r3,164(sp)
81124efc:	d8002785 	stb	zero,158(sp)
81124f00:	28800204 	addi	r2,r5,8
81124f04:	2cc00017 	ldw	r19,0(r5)
81124f08:	2d800117 	ldw	r22,4(r5)
81124f0c:	18048f16 	blt	r3,zero,8112614c <___vfprintf_internal_r+0x18d8>
81124f10:	013fdfc4 	movi	r4,-129
81124f14:	9d86b03a 	or	r3,r19,r22
81124f18:	d8802d15 	stw	r2,180(sp)
81124f1c:	9124703a 	and	r18,r18,r4
81124f20:	1802d91e 	bne	r3,zero,81125a88 <___vfprintf_internal_r+0x1214>
81124f24:	d8c02917 	ldw	r3,164(sp)
81124f28:	0039883a 	mov	fp,zero
81124f2c:	1805c326 	beq	r3,zero,8112663c <___vfprintf_internal_r+0x1dc8>
81124f30:	0027883a 	mov	r19,zero
81124f34:	002d883a 	mov	r22,zero
81124f38:	dc001e04 	addi	r16,sp,120
81124f3c:	9806d0fa 	srli	r3,r19,3
81124f40:	b008977a 	slli	r4,r22,29
81124f44:	b02cd0fa 	srli	r22,r22,3
81124f48:	9cc001cc 	andi	r19,r19,7
81124f4c:	98800c04 	addi	r2,r19,48
81124f50:	843fffc4 	addi	r16,r16,-1
81124f54:	20e6b03a 	or	r19,r4,r3
81124f58:	80800005 	stb	r2,0(r16)
81124f5c:	9d86b03a 	or	r3,r19,r22
81124f60:	183ff61e 	bne	r3,zero,81124f3c <__reset+0xfb104f3c>
81124f64:	90c0004c 	andi	r3,r18,1
81124f68:	18013b26 	beq	r3,zero,81125458 <___vfprintf_internal_r+0xbe4>
81124f6c:	10803fcc 	andi	r2,r2,255
81124f70:	1080201c 	xori	r2,r2,128
81124f74:	10bfe004 	addi	r2,r2,-128
81124f78:	00c00c04 	movi	r3,48
81124f7c:	10c13626 	beq	r2,r3,81125458 <___vfprintf_internal_r+0xbe4>
81124f80:	80ffffc5 	stb	r3,-1(r16)
81124f84:	d8c02817 	ldw	r3,160(sp)
81124f88:	80bfffc4 	addi	r2,r16,-1
81124f8c:	1021883a 	mov	r16,r2
81124f90:	1887c83a 	sub	r3,r3,r2
81124f94:	d8c02e15 	stw	r3,184(sp)
81124f98:	d8802e17 	ldw	r2,184(sp)
81124f9c:	d9002917 	ldw	r4,164(sp)
81124fa0:	1100010e 	bge	r2,r4,81124fa8 <___vfprintf_internal_r+0x734>
81124fa4:	2005883a 	mov	r2,r4
81124fa8:	d8802a15 	stw	r2,168(sp)
81124fac:	d8003215 	stw	zero,200(sp)
81124fb0:	e7003fcc 	andi	fp,fp,255
81124fb4:	e700201c 	xori	fp,fp,128
81124fb8:	e73fe004 	addi	fp,fp,-128
81124fbc:	e0000326 	beq	fp,zero,81124fcc <___vfprintf_internal_r+0x758>
81124fc0:	d8c02a17 	ldw	r3,168(sp)
81124fc4:	18c00044 	addi	r3,r3,1
81124fc8:	d8c02a15 	stw	r3,168(sp)
81124fcc:	90c0008c 	andi	r3,r18,2
81124fd0:	d8c02b15 	stw	r3,172(sp)
81124fd4:	18000326 	beq	r3,zero,81124fe4 <___vfprintf_internal_r+0x770>
81124fd8:	d8c02a17 	ldw	r3,168(sp)
81124fdc:	18c00084 	addi	r3,r3,2
81124fe0:	d8c02a15 	stw	r3,168(sp)
81124fe4:	90c0210c 	andi	r3,r18,132
81124fe8:	d8c03015 	stw	r3,192(sp)
81124fec:	1801a31e 	bne	r3,zero,8112567c <___vfprintf_internal_r+0xe08>
81124ff0:	d9003117 	ldw	r4,196(sp)
81124ff4:	d8c02a17 	ldw	r3,168(sp)
81124ff8:	20e7c83a 	sub	r19,r4,r3
81124ffc:	04c19f0e 	bge	zero,r19,8112567c <___vfprintf_internal_r+0xe08>
81125000:	02400404 	movi	r9,16
81125004:	d8c02017 	ldw	r3,128(sp)
81125008:	d8801f17 	ldw	r2,124(sp)
8112500c:	4cc50d0e 	bge	r9,r19,81126444 <___vfprintf_internal_r+0x1bd0>
81125010:	01604574 	movhi	r5,33045
81125014:	297ead84 	addi	r5,r5,-1354
81125018:	dc403b15 	stw	r17,236(sp)
8112501c:	d9403515 	stw	r5,212(sp)
81125020:	9823883a 	mov	r17,r19
81125024:	482d883a 	mov	r22,r9
81125028:	9027883a 	mov	r19,r18
8112502c:	070001c4 	movi	fp,7
81125030:	8025883a 	mov	r18,r16
81125034:	dc002c17 	ldw	r16,176(sp)
81125038:	00000306 	br	81125048 <___vfprintf_internal_r+0x7d4>
8112503c:	8c7ffc04 	addi	r17,r17,-16
81125040:	42000204 	addi	r8,r8,8
81125044:	b440130e 	bge	r22,r17,81125094 <___vfprintf_internal_r+0x820>
81125048:	01204574 	movhi	r4,33045
8112504c:	18c00404 	addi	r3,r3,16
81125050:	10800044 	addi	r2,r2,1
81125054:	213ead84 	addi	r4,r4,-1354
81125058:	41000015 	stw	r4,0(r8)
8112505c:	45800115 	stw	r22,4(r8)
81125060:	d8c02015 	stw	r3,128(sp)
81125064:	d8801f15 	stw	r2,124(sp)
81125068:	e0bff40e 	bge	fp,r2,8112503c <__reset+0xfb10503c>
8112506c:	d9801e04 	addi	r6,sp,120
81125070:	b80b883a 	mov	r5,r23
81125074:	8009883a 	mov	r4,r16
81125078:	1130a640 	call	81130a64 <__sprint_r>
8112507c:	103f011e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
81125080:	8c7ffc04 	addi	r17,r17,-16
81125084:	d8c02017 	ldw	r3,128(sp)
81125088:	d8801f17 	ldw	r2,124(sp)
8112508c:	da000404 	addi	r8,sp,16
81125090:	b47fed16 	blt	r22,r17,81125048 <__reset+0xfb105048>
81125094:	9021883a 	mov	r16,r18
81125098:	9825883a 	mov	r18,r19
8112509c:	8827883a 	mov	r19,r17
811250a0:	dc403b17 	ldw	r17,236(sp)
811250a4:	d9403517 	ldw	r5,212(sp)
811250a8:	98c7883a 	add	r3,r19,r3
811250ac:	10800044 	addi	r2,r2,1
811250b0:	41400015 	stw	r5,0(r8)
811250b4:	44c00115 	stw	r19,4(r8)
811250b8:	d8c02015 	stw	r3,128(sp)
811250bc:	d8801f15 	stw	r2,124(sp)
811250c0:	010001c4 	movi	r4,7
811250c4:	2082a316 	blt	r4,r2,81125b54 <___vfprintf_internal_r+0x12e0>
811250c8:	df002787 	ldb	fp,158(sp)
811250cc:	42000204 	addi	r8,r8,8
811250d0:	e0000c26 	beq	fp,zero,81125104 <___vfprintf_internal_r+0x890>
811250d4:	d8801f17 	ldw	r2,124(sp)
811250d8:	d9002784 	addi	r4,sp,158
811250dc:	18c00044 	addi	r3,r3,1
811250e0:	10800044 	addi	r2,r2,1
811250e4:	41000015 	stw	r4,0(r8)
811250e8:	01000044 	movi	r4,1
811250ec:	41000115 	stw	r4,4(r8)
811250f0:	d8c02015 	stw	r3,128(sp)
811250f4:	d8801f15 	stw	r2,124(sp)
811250f8:	010001c4 	movi	r4,7
811250fc:	20823c16 	blt	r4,r2,811259f0 <___vfprintf_internal_r+0x117c>
81125100:	42000204 	addi	r8,r8,8
81125104:	d8802b17 	ldw	r2,172(sp)
81125108:	10000c26 	beq	r2,zero,8112513c <___vfprintf_internal_r+0x8c8>
8112510c:	d8801f17 	ldw	r2,124(sp)
81125110:	d9002704 	addi	r4,sp,156
81125114:	18c00084 	addi	r3,r3,2
81125118:	10800044 	addi	r2,r2,1
8112511c:	41000015 	stw	r4,0(r8)
81125120:	01000084 	movi	r4,2
81125124:	41000115 	stw	r4,4(r8)
81125128:	d8c02015 	stw	r3,128(sp)
8112512c:	d8801f15 	stw	r2,124(sp)
81125130:	010001c4 	movi	r4,7
81125134:	20823616 	blt	r4,r2,81125a10 <___vfprintf_internal_r+0x119c>
81125138:	42000204 	addi	r8,r8,8
8112513c:	d9003017 	ldw	r4,192(sp)
81125140:	00802004 	movi	r2,128
81125144:	20819926 	beq	r4,r2,811257ac <___vfprintf_internal_r+0xf38>
81125148:	d9402917 	ldw	r5,164(sp)
8112514c:	d8802e17 	ldw	r2,184(sp)
81125150:	28adc83a 	sub	r22,r5,r2
81125154:	0580310e 	bge	zero,r22,8112521c <___vfprintf_internal_r+0x9a8>
81125158:	07000404 	movi	fp,16
8112515c:	d8801f17 	ldw	r2,124(sp)
81125160:	e584140e 	bge	fp,r22,811261b4 <___vfprintf_internal_r+0x1940>
81125164:	01604574 	movhi	r5,33045
81125168:	297ea984 	addi	r5,r5,-1370
8112516c:	dc402915 	stw	r17,164(sp)
81125170:	d9402b15 	stw	r5,172(sp)
81125174:	b023883a 	mov	r17,r22
81125178:	04c001c4 	movi	r19,7
8112517c:	a82d883a 	mov	r22,r21
81125180:	902b883a 	mov	r21,r18
81125184:	8025883a 	mov	r18,r16
81125188:	dc002c17 	ldw	r16,176(sp)
8112518c:	00000306 	br	8112519c <___vfprintf_internal_r+0x928>
81125190:	8c7ffc04 	addi	r17,r17,-16
81125194:	42000204 	addi	r8,r8,8
81125198:	e440110e 	bge	fp,r17,811251e0 <___vfprintf_internal_r+0x96c>
8112519c:	18c00404 	addi	r3,r3,16
811251a0:	10800044 	addi	r2,r2,1
811251a4:	45000015 	stw	r20,0(r8)
811251a8:	47000115 	stw	fp,4(r8)
811251ac:	d8c02015 	stw	r3,128(sp)
811251b0:	d8801f15 	stw	r2,124(sp)
811251b4:	98bff60e 	bge	r19,r2,81125190 <__reset+0xfb105190>
811251b8:	d9801e04 	addi	r6,sp,120
811251bc:	b80b883a 	mov	r5,r23
811251c0:	8009883a 	mov	r4,r16
811251c4:	1130a640 	call	81130a64 <__sprint_r>
811251c8:	103eae1e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
811251cc:	8c7ffc04 	addi	r17,r17,-16
811251d0:	d8c02017 	ldw	r3,128(sp)
811251d4:	d8801f17 	ldw	r2,124(sp)
811251d8:	da000404 	addi	r8,sp,16
811251dc:	e47fef16 	blt	fp,r17,8112519c <__reset+0xfb10519c>
811251e0:	9021883a 	mov	r16,r18
811251e4:	a825883a 	mov	r18,r21
811251e8:	b02b883a 	mov	r21,r22
811251ec:	882d883a 	mov	r22,r17
811251f0:	dc402917 	ldw	r17,164(sp)
811251f4:	d9002b17 	ldw	r4,172(sp)
811251f8:	1d87883a 	add	r3,r3,r22
811251fc:	10800044 	addi	r2,r2,1
81125200:	41000015 	stw	r4,0(r8)
81125204:	45800115 	stw	r22,4(r8)
81125208:	d8c02015 	stw	r3,128(sp)
8112520c:	d8801f15 	stw	r2,124(sp)
81125210:	010001c4 	movi	r4,7
81125214:	2081ee16 	blt	r4,r2,811259d0 <___vfprintf_internal_r+0x115c>
81125218:	42000204 	addi	r8,r8,8
8112521c:	9080400c 	andi	r2,r18,256
81125220:	1001181e 	bne	r2,zero,81125684 <___vfprintf_internal_r+0xe10>
81125224:	d9402e17 	ldw	r5,184(sp)
81125228:	d8801f17 	ldw	r2,124(sp)
8112522c:	44000015 	stw	r16,0(r8)
81125230:	1947883a 	add	r3,r3,r5
81125234:	10800044 	addi	r2,r2,1
81125238:	41400115 	stw	r5,4(r8)
8112523c:	d8c02015 	stw	r3,128(sp)
81125240:	d8801f15 	stw	r2,124(sp)
81125244:	010001c4 	movi	r4,7
81125248:	2081d316 	blt	r4,r2,81125998 <___vfprintf_internal_r+0x1124>
8112524c:	42000204 	addi	r8,r8,8
81125250:	9480010c 	andi	r18,r18,4
81125254:	90003226 	beq	r18,zero,81125320 <___vfprintf_internal_r+0xaac>
81125258:	d9403117 	ldw	r5,196(sp)
8112525c:	d8802a17 	ldw	r2,168(sp)
81125260:	28a1c83a 	sub	r16,r5,r2
81125264:	04002e0e 	bge	zero,r16,81125320 <___vfprintf_internal_r+0xaac>
81125268:	04400404 	movi	r17,16
8112526c:	d8801f17 	ldw	r2,124(sp)
81125270:	8c04a20e 	bge	r17,r16,811264fc <___vfprintf_internal_r+0x1c88>
81125274:	01604574 	movhi	r5,33045
81125278:	297ead84 	addi	r5,r5,-1354
8112527c:	d9403515 	stw	r5,212(sp)
81125280:	048001c4 	movi	r18,7
81125284:	dcc02c17 	ldw	r19,176(sp)
81125288:	00000306 	br	81125298 <___vfprintf_internal_r+0xa24>
8112528c:	843ffc04 	addi	r16,r16,-16
81125290:	42000204 	addi	r8,r8,8
81125294:	8c00130e 	bge	r17,r16,811252e4 <___vfprintf_internal_r+0xa70>
81125298:	01204574 	movhi	r4,33045
8112529c:	18c00404 	addi	r3,r3,16
811252a0:	10800044 	addi	r2,r2,1
811252a4:	213ead84 	addi	r4,r4,-1354
811252a8:	41000015 	stw	r4,0(r8)
811252ac:	44400115 	stw	r17,4(r8)
811252b0:	d8c02015 	stw	r3,128(sp)
811252b4:	d8801f15 	stw	r2,124(sp)
811252b8:	90bff40e 	bge	r18,r2,8112528c <__reset+0xfb10528c>
811252bc:	d9801e04 	addi	r6,sp,120
811252c0:	b80b883a 	mov	r5,r23
811252c4:	9809883a 	mov	r4,r19
811252c8:	1130a640 	call	81130a64 <__sprint_r>
811252cc:	103e6d1e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
811252d0:	843ffc04 	addi	r16,r16,-16
811252d4:	d8c02017 	ldw	r3,128(sp)
811252d8:	d8801f17 	ldw	r2,124(sp)
811252dc:	da000404 	addi	r8,sp,16
811252e0:	8c3fed16 	blt	r17,r16,81125298 <__reset+0xfb105298>
811252e4:	d9403517 	ldw	r5,212(sp)
811252e8:	1c07883a 	add	r3,r3,r16
811252ec:	10800044 	addi	r2,r2,1
811252f0:	41400015 	stw	r5,0(r8)
811252f4:	44000115 	stw	r16,4(r8)
811252f8:	d8c02015 	stw	r3,128(sp)
811252fc:	d8801f15 	stw	r2,124(sp)
81125300:	010001c4 	movi	r4,7
81125304:	2080060e 	bge	r4,r2,81125320 <___vfprintf_internal_r+0xaac>
81125308:	d9002c17 	ldw	r4,176(sp)
8112530c:	d9801e04 	addi	r6,sp,120
81125310:	b80b883a 	mov	r5,r23
81125314:	1130a640 	call	81130a64 <__sprint_r>
81125318:	103e5a1e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
8112531c:	d8c02017 	ldw	r3,128(sp)
81125320:	d8803117 	ldw	r2,196(sp)
81125324:	d9002a17 	ldw	r4,168(sp)
81125328:	1100010e 	bge	r2,r4,81125330 <___vfprintf_internal_r+0xabc>
8112532c:	2005883a 	mov	r2,r4
81125330:	d9402f17 	ldw	r5,188(sp)
81125334:	288b883a 	add	r5,r5,r2
81125338:	d9402f15 	stw	r5,188(sp)
8112533c:	18019e1e 	bne	r3,zero,811259b8 <___vfprintf_internal_r+0x1144>
81125340:	a8800007 	ldb	r2,0(r21)
81125344:	d8001f15 	stw	zero,124(sp)
81125348:	da000404 	addi	r8,sp,16
8112534c:	103d851e 	bne	r2,zero,81124964 <__reset+0xfb104964>
81125350:	a821883a 	mov	r16,r21
81125354:	003d9b06 	br	811249c4 <__reset+0xfb1049c4>
81125358:	18c03fcc 	andi	r3,r3,255
8112535c:	1805c11e 	bne	r3,zero,81126a64 <___vfprintf_internal_r+0x21f0>
81125360:	94800414 	ori	r18,r18,16
81125364:	9080080c 	andi	r2,r18,32
81125368:	10020c26 	beq	r2,zero,81125b9c <___vfprintf_internal_r+0x1328>
8112536c:	d8802d17 	ldw	r2,180(sp)
81125370:	d9002917 	ldw	r4,164(sp)
81125374:	d8002785 	stb	zero,158(sp)
81125378:	10c00204 	addi	r3,r2,8
8112537c:	14c00017 	ldw	r19,0(r2)
81125380:	15800117 	ldw	r22,4(r2)
81125384:	20040f16 	blt	r4,zero,811263c4 <___vfprintf_internal_r+0x1b50>
81125388:	013fdfc4 	movi	r4,-129
8112538c:	9d84b03a 	or	r2,r19,r22
81125390:	d8c02d15 	stw	r3,180(sp)
81125394:	9124703a 	and	r18,r18,r4
81125398:	0039883a 	mov	fp,zero
8112539c:	103e891e 	bne	r2,zero,81124dc4 <__reset+0xfb104dc4>
811253a0:	d9002917 	ldw	r4,164(sp)
811253a4:	2002c11e 	bne	r4,zero,81125eac <___vfprintf_internal_r+0x1638>
811253a8:	d8002915 	stw	zero,164(sp)
811253ac:	d8002e15 	stw	zero,184(sp)
811253b0:	dc001e04 	addi	r16,sp,120
811253b4:	003ef806 	br	81124f98 <__reset+0xfb104f98>
811253b8:	18c03fcc 	andi	r3,r3,255
811253bc:	18059d1e 	bne	r3,zero,81126a34 <___vfprintf_internal_r+0x21c0>
811253c0:	01604574 	movhi	r5,33045
811253c4:	297e9504 	addi	r5,r5,-1452
811253c8:	d9403915 	stw	r5,228(sp)
811253cc:	9080080c 	andi	r2,r18,32
811253d0:	10005226 	beq	r2,zero,8112551c <___vfprintf_internal_r+0xca8>
811253d4:	d8802d17 	ldw	r2,180(sp)
811253d8:	14c00017 	ldw	r19,0(r2)
811253dc:	15800117 	ldw	r22,4(r2)
811253e0:	10800204 	addi	r2,r2,8
811253e4:	d8802d15 	stw	r2,180(sp)
811253e8:	9080004c 	andi	r2,r18,1
811253ec:	10019026 	beq	r2,zero,81125a30 <___vfprintf_internal_r+0x11bc>
811253f0:	9d84b03a 	or	r2,r19,r22
811253f4:	10036926 	beq	r2,zero,8112619c <___vfprintf_internal_r+0x1928>
811253f8:	d8c02917 	ldw	r3,164(sp)
811253fc:	00800c04 	movi	r2,48
81125400:	d8802705 	stb	r2,156(sp)
81125404:	dc402745 	stb	r17,157(sp)
81125408:	d8002785 	stb	zero,158(sp)
8112540c:	90800094 	ori	r2,r18,2
81125410:	18045d16 	blt	r3,zero,81126588 <___vfprintf_internal_r+0x1d14>
81125414:	00bfdfc4 	movi	r2,-129
81125418:	90a4703a 	and	r18,r18,r2
8112541c:	94800094 	ori	r18,r18,2
81125420:	0039883a 	mov	fp,zero
81125424:	d9003917 	ldw	r4,228(sp)
81125428:	dc001e04 	addi	r16,sp,120
8112542c:	988003cc 	andi	r2,r19,15
81125430:	b006973a 	slli	r3,r22,28
81125434:	2085883a 	add	r2,r4,r2
81125438:	9826d13a 	srli	r19,r19,4
8112543c:	10800003 	ldbu	r2,0(r2)
81125440:	b02cd13a 	srli	r22,r22,4
81125444:	843fffc4 	addi	r16,r16,-1
81125448:	1ce6b03a 	or	r19,r3,r19
8112544c:	80800005 	stb	r2,0(r16)
81125450:	9d84b03a 	or	r2,r19,r22
81125454:	103ff51e 	bne	r2,zero,8112542c <__reset+0xfb10542c>
81125458:	d8c02817 	ldw	r3,160(sp)
8112545c:	1c07c83a 	sub	r3,r3,r16
81125460:	d8c02e15 	stw	r3,184(sp)
81125464:	003ecc06 	br	81124f98 <__reset+0xfb104f98>
81125468:	18c03fcc 	andi	r3,r3,255
8112546c:	183e9f26 	beq	r3,zero,81124eec <__reset+0xfb104eec>
81125470:	d9c02785 	stb	r7,158(sp)
81125474:	003e9d06 	br	81124eec <__reset+0xfb104eec>
81125478:	00c00044 	movi	r3,1
8112547c:	01c00ac4 	movi	r7,43
81125480:	ac400007 	ldb	r17,0(r21)
81125484:	003d5e06 	br	81124a00 <__reset+0xfb104a00>
81125488:	94800814 	ori	r18,r18,32
8112548c:	ac400007 	ldb	r17,0(r21)
81125490:	003d5b06 	br	81124a00 <__reset+0xfb104a00>
81125494:	d8c02d17 	ldw	r3,180(sp)
81125498:	d8002785 	stb	zero,158(sp)
8112549c:	1c000017 	ldw	r16,0(r3)
811254a0:	1cc00104 	addi	r19,r3,4
811254a4:	80041926 	beq	r16,zero,8112650c <___vfprintf_internal_r+0x1c98>
811254a8:	d9002917 	ldw	r4,164(sp)
811254ac:	2003d016 	blt	r4,zero,811263f0 <___vfprintf_internal_r+0x1b7c>
811254b0:	200d883a 	mov	r6,r4
811254b4:	000b883a 	mov	r5,zero
811254b8:	8009883a 	mov	r4,r16
811254bc:	da003d15 	stw	r8,244(sp)
811254c0:	112b8580 	call	8112b858 <memchr>
811254c4:	da003d17 	ldw	r8,244(sp)
811254c8:	10045426 	beq	r2,zero,8112661c <___vfprintf_internal_r+0x1da8>
811254cc:	1405c83a 	sub	r2,r2,r16
811254d0:	d8802e15 	stw	r2,184(sp)
811254d4:	1003cc16 	blt	r2,zero,81126408 <___vfprintf_internal_r+0x1b94>
811254d8:	df002783 	ldbu	fp,158(sp)
811254dc:	d8802a15 	stw	r2,168(sp)
811254e0:	dcc02d15 	stw	r19,180(sp)
811254e4:	d8002915 	stw	zero,164(sp)
811254e8:	d8003215 	stw	zero,200(sp)
811254ec:	003eb006 	br	81124fb0 <__reset+0xfb104fb0>
811254f0:	18c03fcc 	andi	r3,r3,255
811254f4:	183f9b26 	beq	r3,zero,81125364 <__reset+0xfb105364>
811254f8:	d9c02785 	stb	r7,158(sp)
811254fc:	003f9906 	br	81125364 <__reset+0xfb105364>
81125500:	18c03fcc 	andi	r3,r3,255
81125504:	1805551e 	bne	r3,zero,81126a5c <___vfprintf_internal_r+0x21e8>
81125508:	01604574 	movhi	r5,33045
8112550c:	297e9a04 	addi	r5,r5,-1432
81125510:	d9403915 	stw	r5,228(sp)
81125514:	9080080c 	andi	r2,r18,32
81125518:	103fae1e 	bne	r2,zero,811253d4 <__reset+0xfb1053d4>
8112551c:	9080040c 	andi	r2,r18,16
81125520:	1002de26 	beq	r2,zero,8112609c <___vfprintf_internal_r+0x1828>
81125524:	d8c02d17 	ldw	r3,180(sp)
81125528:	002d883a 	mov	r22,zero
8112552c:	1cc00017 	ldw	r19,0(r3)
81125530:	18c00104 	addi	r3,r3,4
81125534:	d8c02d15 	stw	r3,180(sp)
81125538:	003fab06 	br	811253e8 <__reset+0xfb1053e8>
8112553c:	38803fcc 	andi	r2,r7,255
81125540:	1080201c 	xori	r2,r2,128
81125544:	10bfe004 	addi	r2,r2,-128
81125548:	1002d21e 	bne	r2,zero,81126094 <___vfprintf_internal_r+0x1820>
8112554c:	00c00044 	movi	r3,1
81125550:	01c00804 	movi	r7,32
81125554:	ac400007 	ldb	r17,0(r21)
81125558:	003d2906 	br	81124a00 <__reset+0xfb104a00>
8112555c:	94800054 	ori	r18,r18,1
81125560:	ac400007 	ldb	r17,0(r21)
81125564:	003d2606 	br	81124a00 <__reset+0xfb104a00>
81125568:	18c03fcc 	andi	r3,r3,255
8112556c:	183e0526 	beq	r3,zero,81124d84 <__reset+0xfb104d84>
81125570:	d9c02785 	stb	r7,158(sp)
81125574:	003e0306 	br	81124d84 <__reset+0xfb104d84>
81125578:	94801014 	ori	r18,r18,64
8112557c:	ac400007 	ldb	r17,0(r21)
81125580:	003d1f06 	br	81124a00 <__reset+0xfb104a00>
81125584:	ac400007 	ldb	r17,0(r21)
81125588:	8a438726 	beq	r17,r9,811263a8 <___vfprintf_internal_r+0x1b34>
8112558c:	94800414 	ori	r18,r18,16
81125590:	003d1b06 	br	81124a00 <__reset+0xfb104a00>
81125594:	18c03fcc 	andi	r3,r3,255
81125598:	1805341e 	bne	r3,zero,81126a6c <___vfprintf_internal_r+0x21f8>
8112559c:	9080080c 	andi	r2,r18,32
811255a0:	1002cd26 	beq	r2,zero,811260d8 <___vfprintf_internal_r+0x1864>
811255a4:	d9402d17 	ldw	r5,180(sp)
811255a8:	d9002f17 	ldw	r4,188(sp)
811255ac:	28800017 	ldw	r2,0(r5)
811255b0:	2007d7fa 	srai	r3,r4,31
811255b4:	29400104 	addi	r5,r5,4
811255b8:	d9402d15 	stw	r5,180(sp)
811255bc:	11000015 	stw	r4,0(r2)
811255c0:	10c00115 	stw	r3,4(r2)
811255c4:	003ce506 	br	8112495c <__reset+0xfb10495c>
811255c8:	d8c02d17 	ldw	r3,180(sp)
811255cc:	d9002d17 	ldw	r4,180(sp)
811255d0:	d8002785 	stb	zero,158(sp)
811255d4:	18800017 	ldw	r2,0(r3)
811255d8:	21000104 	addi	r4,r4,4
811255dc:	00c00044 	movi	r3,1
811255e0:	d8c02a15 	stw	r3,168(sp)
811255e4:	d8801405 	stb	r2,80(sp)
811255e8:	d9002d15 	stw	r4,180(sp)
811255ec:	d8c02e15 	stw	r3,184(sp)
811255f0:	d8002915 	stw	zero,164(sp)
811255f4:	d8003215 	stw	zero,200(sp)
811255f8:	dc001404 	addi	r16,sp,80
811255fc:	0039883a 	mov	fp,zero
81125600:	003e7206 	br	81124fcc <__reset+0xfb104fcc>
81125604:	01204574 	movhi	r4,33045
81125608:	213e9a04 	addi	r4,r4,-1432
8112560c:	0039883a 	mov	fp,zero
81125610:	d9003915 	stw	r4,228(sp)
81125614:	04401e04 	movi	r17,120
81125618:	003f8206 	br	81125424 <__reset+0xfb105424>
8112561c:	18c03fcc 	andi	r3,r3,255
81125620:	1805061e 	bne	r3,zero,81126a3c <___vfprintf_internal_r+0x21c8>
81125624:	883d9126 	beq	r17,zero,81124c6c <__reset+0xfb104c6c>
81125628:	00c00044 	movi	r3,1
8112562c:	d8c02a15 	stw	r3,168(sp)
81125630:	dc401405 	stb	r17,80(sp)
81125634:	d8002785 	stb	zero,158(sp)
81125638:	003fec06 	br	811255ec <__reset+0xfb1055ec>
8112563c:	01604574 	movhi	r5,33045
81125640:	297e9a04 	addi	r5,r5,-1432
81125644:	d9403915 	stw	r5,228(sp)
81125648:	d8c02d15 	stw	r3,180(sp)
8112564c:	1025883a 	mov	r18,r2
81125650:	04401e04 	movi	r17,120
81125654:	9d84b03a 	or	r2,r19,r22
81125658:	1000fc1e 	bne	r2,zero,81125a4c <___vfprintf_internal_r+0x11d8>
8112565c:	0039883a 	mov	fp,zero
81125660:	00800084 	movi	r2,2
81125664:	10803fcc 	andi	r2,r2,255
81125668:	00c00044 	movi	r3,1
8112566c:	10c20f26 	beq	r2,r3,81125eac <___vfprintf_internal_r+0x1638>
81125670:	00c00084 	movi	r3,2
81125674:	10fd6326 	beq	r2,r3,81124c04 <__reset+0xfb104c04>
81125678:	003e2d06 	br	81124f30 <__reset+0xfb104f30>
8112567c:	d8c02017 	ldw	r3,128(sp)
81125680:	003e9306 	br	811250d0 <__reset+0xfb1050d0>
81125684:	00801944 	movi	r2,101
81125688:	14407e0e 	bge	r2,r17,81125884 <___vfprintf_internal_r+0x1010>
8112568c:	d9003617 	ldw	r4,216(sp)
81125690:	d9403817 	ldw	r5,224(sp)
81125694:	000d883a 	mov	r6,zero
81125698:	000f883a 	mov	r7,zero
8112569c:	d8c03c15 	stw	r3,240(sp)
811256a0:	da003d15 	stw	r8,244(sp)
811256a4:	11352300 	call	81135230 <__eqdf2>
811256a8:	d8c03c17 	ldw	r3,240(sp)
811256ac:	da003d17 	ldw	r8,244(sp)
811256b0:	1000f71e 	bne	r2,zero,81125a90 <___vfprintf_internal_r+0x121c>
811256b4:	d8801f17 	ldw	r2,124(sp)
811256b8:	01204574 	movhi	r4,33045
811256bc:	213ea104 	addi	r4,r4,-1404
811256c0:	18c00044 	addi	r3,r3,1
811256c4:	10800044 	addi	r2,r2,1
811256c8:	41000015 	stw	r4,0(r8)
811256cc:	01000044 	movi	r4,1
811256d0:	41000115 	stw	r4,4(r8)
811256d4:	d8c02015 	stw	r3,128(sp)
811256d8:	d8801f15 	stw	r2,124(sp)
811256dc:	010001c4 	movi	r4,7
811256e0:	2082b816 	blt	r4,r2,811261c4 <___vfprintf_internal_r+0x1950>
811256e4:	42000204 	addi	r8,r8,8
811256e8:	d8802617 	ldw	r2,152(sp)
811256ec:	d9403317 	ldw	r5,204(sp)
811256f0:	11400216 	blt	r2,r5,811256fc <___vfprintf_internal_r+0xe88>
811256f4:	9080004c 	andi	r2,r18,1
811256f8:	103ed526 	beq	r2,zero,81125250 <__reset+0xfb105250>
811256fc:	d8803717 	ldw	r2,220(sp)
81125700:	d9003417 	ldw	r4,208(sp)
81125704:	d9403717 	ldw	r5,220(sp)
81125708:	1887883a 	add	r3,r3,r2
8112570c:	d8801f17 	ldw	r2,124(sp)
81125710:	41000015 	stw	r4,0(r8)
81125714:	41400115 	stw	r5,4(r8)
81125718:	10800044 	addi	r2,r2,1
8112571c:	d8c02015 	stw	r3,128(sp)
81125720:	d8801f15 	stw	r2,124(sp)
81125724:	010001c4 	movi	r4,7
81125728:	20832916 	blt	r4,r2,811263d0 <___vfprintf_internal_r+0x1b5c>
8112572c:	42000204 	addi	r8,r8,8
81125730:	d8803317 	ldw	r2,204(sp)
81125734:	143fffc4 	addi	r16,r2,-1
81125738:	043ec50e 	bge	zero,r16,81125250 <__reset+0xfb105250>
8112573c:	04400404 	movi	r17,16
81125740:	d8801f17 	ldw	r2,124(sp)
81125744:	8c00880e 	bge	r17,r16,81125968 <___vfprintf_internal_r+0x10f4>
81125748:	01604574 	movhi	r5,33045
8112574c:	297ea984 	addi	r5,r5,-1370
81125750:	d9402b15 	stw	r5,172(sp)
81125754:	058001c4 	movi	r22,7
81125758:	dcc02c17 	ldw	r19,176(sp)
8112575c:	00000306 	br	8112576c <___vfprintf_internal_r+0xef8>
81125760:	42000204 	addi	r8,r8,8
81125764:	843ffc04 	addi	r16,r16,-16
81125768:	8c00820e 	bge	r17,r16,81125974 <___vfprintf_internal_r+0x1100>
8112576c:	18c00404 	addi	r3,r3,16
81125770:	10800044 	addi	r2,r2,1
81125774:	45000015 	stw	r20,0(r8)
81125778:	44400115 	stw	r17,4(r8)
8112577c:	d8c02015 	stw	r3,128(sp)
81125780:	d8801f15 	stw	r2,124(sp)
81125784:	b0bff60e 	bge	r22,r2,81125760 <__reset+0xfb105760>
81125788:	d9801e04 	addi	r6,sp,120
8112578c:	b80b883a 	mov	r5,r23
81125790:	9809883a 	mov	r4,r19
81125794:	1130a640 	call	81130a64 <__sprint_r>
81125798:	103d3a1e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
8112579c:	d8c02017 	ldw	r3,128(sp)
811257a0:	d8801f17 	ldw	r2,124(sp)
811257a4:	da000404 	addi	r8,sp,16
811257a8:	003fee06 	br	81125764 <__reset+0xfb105764>
811257ac:	d9403117 	ldw	r5,196(sp)
811257b0:	d8802a17 	ldw	r2,168(sp)
811257b4:	28adc83a 	sub	r22,r5,r2
811257b8:	05be630e 	bge	zero,r22,81125148 <__reset+0xfb105148>
811257bc:	07000404 	movi	fp,16
811257c0:	d8801f17 	ldw	r2,124(sp)
811257c4:	e5838f0e 	bge	fp,r22,81126604 <___vfprintf_internal_r+0x1d90>
811257c8:	01604574 	movhi	r5,33045
811257cc:	297ea984 	addi	r5,r5,-1370
811257d0:	dc403015 	stw	r17,192(sp)
811257d4:	d9402b15 	stw	r5,172(sp)
811257d8:	b023883a 	mov	r17,r22
811257dc:	04c001c4 	movi	r19,7
811257e0:	a82d883a 	mov	r22,r21
811257e4:	902b883a 	mov	r21,r18
811257e8:	8025883a 	mov	r18,r16
811257ec:	dc002c17 	ldw	r16,176(sp)
811257f0:	00000306 	br	81125800 <___vfprintf_internal_r+0xf8c>
811257f4:	8c7ffc04 	addi	r17,r17,-16
811257f8:	42000204 	addi	r8,r8,8
811257fc:	e440110e 	bge	fp,r17,81125844 <___vfprintf_internal_r+0xfd0>
81125800:	18c00404 	addi	r3,r3,16
81125804:	10800044 	addi	r2,r2,1
81125808:	45000015 	stw	r20,0(r8)
8112580c:	47000115 	stw	fp,4(r8)
81125810:	d8c02015 	stw	r3,128(sp)
81125814:	d8801f15 	stw	r2,124(sp)
81125818:	98bff60e 	bge	r19,r2,811257f4 <__reset+0xfb1057f4>
8112581c:	d9801e04 	addi	r6,sp,120
81125820:	b80b883a 	mov	r5,r23
81125824:	8009883a 	mov	r4,r16
81125828:	1130a640 	call	81130a64 <__sprint_r>
8112582c:	103d151e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
81125830:	8c7ffc04 	addi	r17,r17,-16
81125834:	d8c02017 	ldw	r3,128(sp)
81125838:	d8801f17 	ldw	r2,124(sp)
8112583c:	da000404 	addi	r8,sp,16
81125840:	e47fef16 	blt	fp,r17,81125800 <__reset+0xfb105800>
81125844:	9021883a 	mov	r16,r18
81125848:	a825883a 	mov	r18,r21
8112584c:	b02b883a 	mov	r21,r22
81125850:	882d883a 	mov	r22,r17
81125854:	dc403017 	ldw	r17,192(sp)
81125858:	d9002b17 	ldw	r4,172(sp)
8112585c:	1d87883a 	add	r3,r3,r22
81125860:	10800044 	addi	r2,r2,1
81125864:	41000015 	stw	r4,0(r8)
81125868:	45800115 	stw	r22,4(r8)
8112586c:	d8c02015 	stw	r3,128(sp)
81125870:	d8801f15 	stw	r2,124(sp)
81125874:	010001c4 	movi	r4,7
81125878:	20818e16 	blt	r4,r2,81125eb4 <___vfprintf_internal_r+0x1640>
8112587c:	42000204 	addi	r8,r8,8
81125880:	003e3106 	br	81125148 <__reset+0xfb105148>
81125884:	d9403317 	ldw	r5,204(sp)
81125888:	00800044 	movi	r2,1
8112588c:	18c00044 	addi	r3,r3,1
81125890:	1141530e 	bge	r2,r5,81125de0 <___vfprintf_internal_r+0x156c>
81125894:	dc401f17 	ldw	r17,124(sp)
81125898:	00800044 	movi	r2,1
8112589c:	40800115 	stw	r2,4(r8)
811258a0:	8c400044 	addi	r17,r17,1
811258a4:	44000015 	stw	r16,0(r8)
811258a8:	d8c02015 	stw	r3,128(sp)
811258ac:	dc401f15 	stw	r17,124(sp)
811258b0:	008001c4 	movi	r2,7
811258b4:	14416b16 	blt	r2,r17,81125e64 <___vfprintf_internal_r+0x15f0>
811258b8:	42000204 	addi	r8,r8,8
811258bc:	d8803717 	ldw	r2,220(sp)
811258c0:	d9003417 	ldw	r4,208(sp)
811258c4:	8c400044 	addi	r17,r17,1
811258c8:	10c7883a 	add	r3,r2,r3
811258cc:	40800115 	stw	r2,4(r8)
811258d0:	41000015 	stw	r4,0(r8)
811258d4:	d8c02015 	stw	r3,128(sp)
811258d8:	dc401f15 	stw	r17,124(sp)
811258dc:	008001c4 	movi	r2,7
811258e0:	14416916 	blt	r2,r17,81125e88 <___vfprintf_internal_r+0x1614>
811258e4:	45800204 	addi	r22,r8,8
811258e8:	d9003617 	ldw	r4,216(sp)
811258ec:	d9403817 	ldw	r5,224(sp)
811258f0:	000d883a 	mov	r6,zero
811258f4:	000f883a 	mov	r7,zero
811258f8:	d8c03c15 	stw	r3,240(sp)
811258fc:	11352300 	call	81135230 <__eqdf2>
81125900:	d8c03c17 	ldw	r3,240(sp)
81125904:	1000bc26 	beq	r2,zero,81125bf8 <___vfprintf_internal_r+0x1384>
81125908:	d9403317 	ldw	r5,204(sp)
8112590c:	84000044 	addi	r16,r16,1
81125910:	8c400044 	addi	r17,r17,1
81125914:	28bfffc4 	addi	r2,r5,-1
81125918:	1887883a 	add	r3,r3,r2
8112591c:	b0800115 	stw	r2,4(r22)
81125920:	b4000015 	stw	r16,0(r22)
81125924:	d8c02015 	stw	r3,128(sp)
81125928:	dc401f15 	stw	r17,124(sp)
8112592c:	008001c4 	movi	r2,7
81125930:	14414316 	blt	r2,r17,81125e40 <___vfprintf_internal_r+0x15cc>
81125934:	b5800204 	addi	r22,r22,8
81125938:	d9003a17 	ldw	r4,232(sp)
8112593c:	df0022c4 	addi	fp,sp,139
81125940:	8c400044 	addi	r17,r17,1
81125944:	20c7883a 	add	r3,r4,r3
81125948:	b7000015 	stw	fp,0(r22)
8112594c:	b1000115 	stw	r4,4(r22)
81125950:	d8c02015 	stw	r3,128(sp)
81125954:	dc401f15 	stw	r17,124(sp)
81125958:	008001c4 	movi	r2,7
8112595c:	14400e16 	blt	r2,r17,81125998 <___vfprintf_internal_r+0x1124>
81125960:	b2000204 	addi	r8,r22,8
81125964:	003e3a06 	br	81125250 <__reset+0xfb105250>
81125968:	01204574 	movhi	r4,33045
8112596c:	213ea984 	addi	r4,r4,-1370
81125970:	d9002b15 	stw	r4,172(sp)
81125974:	d9002b17 	ldw	r4,172(sp)
81125978:	1c07883a 	add	r3,r3,r16
8112597c:	44000115 	stw	r16,4(r8)
81125980:	41000015 	stw	r4,0(r8)
81125984:	10800044 	addi	r2,r2,1
81125988:	d8c02015 	stw	r3,128(sp)
8112598c:	d8801f15 	stw	r2,124(sp)
81125990:	010001c4 	movi	r4,7
81125994:	20be2d0e 	bge	r4,r2,8112524c <__reset+0xfb10524c>
81125998:	d9002c17 	ldw	r4,176(sp)
8112599c:	d9801e04 	addi	r6,sp,120
811259a0:	b80b883a 	mov	r5,r23
811259a4:	1130a640 	call	81130a64 <__sprint_r>
811259a8:	103cb61e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
811259ac:	d8c02017 	ldw	r3,128(sp)
811259b0:	da000404 	addi	r8,sp,16
811259b4:	003e2606 	br	81125250 <__reset+0xfb105250>
811259b8:	d9002c17 	ldw	r4,176(sp)
811259bc:	d9801e04 	addi	r6,sp,120
811259c0:	b80b883a 	mov	r5,r23
811259c4:	1130a640 	call	81130a64 <__sprint_r>
811259c8:	103e5d26 	beq	r2,zero,81125340 <__reset+0xfb105340>
811259cc:	003cad06 	br	81124c84 <__reset+0xfb104c84>
811259d0:	d9002c17 	ldw	r4,176(sp)
811259d4:	d9801e04 	addi	r6,sp,120
811259d8:	b80b883a 	mov	r5,r23
811259dc:	1130a640 	call	81130a64 <__sprint_r>
811259e0:	103ca81e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
811259e4:	d8c02017 	ldw	r3,128(sp)
811259e8:	da000404 	addi	r8,sp,16
811259ec:	003e0b06 	br	8112521c <__reset+0xfb10521c>
811259f0:	d9002c17 	ldw	r4,176(sp)
811259f4:	d9801e04 	addi	r6,sp,120
811259f8:	b80b883a 	mov	r5,r23
811259fc:	1130a640 	call	81130a64 <__sprint_r>
81125a00:	103ca01e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
81125a04:	d8c02017 	ldw	r3,128(sp)
81125a08:	da000404 	addi	r8,sp,16
81125a0c:	003dbd06 	br	81125104 <__reset+0xfb105104>
81125a10:	d9002c17 	ldw	r4,176(sp)
81125a14:	d9801e04 	addi	r6,sp,120
81125a18:	b80b883a 	mov	r5,r23
81125a1c:	1130a640 	call	81130a64 <__sprint_r>
81125a20:	103c981e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
81125a24:	d8c02017 	ldw	r3,128(sp)
81125a28:	da000404 	addi	r8,sp,16
81125a2c:	003dc306 	br	8112513c <__reset+0xfb10513c>
81125a30:	d8802917 	ldw	r2,164(sp)
81125a34:	d8002785 	stb	zero,158(sp)
81125a38:	103f0616 	blt	r2,zero,81125654 <__reset+0xfb105654>
81125a3c:	00ffdfc4 	movi	r3,-129
81125a40:	9d84b03a 	or	r2,r19,r22
81125a44:	90e4703a 	and	r18,r18,r3
81125a48:	103c6b26 	beq	r2,zero,81124bf8 <__reset+0xfb104bf8>
81125a4c:	0039883a 	mov	fp,zero
81125a50:	003e7406 	br	81125424 <__reset+0xfb105424>
81125a54:	9080040c 	andi	r2,r18,16
81125a58:	1001b326 	beq	r2,zero,81126128 <___vfprintf_internal_r+0x18b4>
81125a5c:	d9002d17 	ldw	r4,180(sp)
81125a60:	d9402917 	ldw	r5,164(sp)
81125a64:	d8002785 	stb	zero,158(sp)
81125a68:	20800104 	addi	r2,r4,4
81125a6c:	24c00017 	ldw	r19,0(r4)
81125a70:	002d883a 	mov	r22,zero
81125a74:	2801b516 	blt	r5,zero,8112614c <___vfprintf_internal_r+0x18d8>
81125a78:	00ffdfc4 	movi	r3,-129
81125a7c:	d8802d15 	stw	r2,180(sp)
81125a80:	90e4703a 	and	r18,r18,r3
81125a84:	983d2726 	beq	r19,zero,81124f24 <__reset+0xfb104f24>
81125a88:	0039883a 	mov	fp,zero
81125a8c:	003d2a06 	br	81124f38 <__reset+0xfb104f38>
81125a90:	dc402617 	ldw	r17,152(sp)
81125a94:	0441d30e 	bge	zero,r17,811261e4 <___vfprintf_internal_r+0x1970>
81125a98:	dc403217 	ldw	r17,200(sp)
81125a9c:	d8803317 	ldw	r2,204(sp)
81125aa0:	1440010e 	bge	r2,r17,81125aa8 <___vfprintf_internal_r+0x1234>
81125aa4:	1023883a 	mov	r17,r2
81125aa8:	04400a0e 	bge	zero,r17,81125ad4 <___vfprintf_internal_r+0x1260>
81125aac:	d8801f17 	ldw	r2,124(sp)
81125ab0:	1c47883a 	add	r3,r3,r17
81125ab4:	44000015 	stw	r16,0(r8)
81125ab8:	10800044 	addi	r2,r2,1
81125abc:	44400115 	stw	r17,4(r8)
81125ac0:	d8c02015 	stw	r3,128(sp)
81125ac4:	d8801f15 	stw	r2,124(sp)
81125ac8:	010001c4 	movi	r4,7
81125acc:	20826516 	blt	r4,r2,81126464 <___vfprintf_internal_r+0x1bf0>
81125ad0:	42000204 	addi	r8,r8,8
81125ad4:	88026116 	blt	r17,zero,8112645c <___vfprintf_internal_r+0x1be8>
81125ad8:	d9003217 	ldw	r4,200(sp)
81125adc:	2463c83a 	sub	r17,r4,r17
81125ae0:	04407b0e 	bge	zero,r17,81125cd0 <___vfprintf_internal_r+0x145c>
81125ae4:	05800404 	movi	r22,16
81125ae8:	d8801f17 	ldw	r2,124(sp)
81125aec:	b4419d0e 	bge	r22,r17,81126164 <___vfprintf_internal_r+0x18f0>
81125af0:	01204574 	movhi	r4,33045
81125af4:	213ea984 	addi	r4,r4,-1370
81125af8:	d9002b15 	stw	r4,172(sp)
81125afc:	070001c4 	movi	fp,7
81125b00:	dcc02c17 	ldw	r19,176(sp)
81125b04:	00000306 	br	81125b14 <___vfprintf_internal_r+0x12a0>
81125b08:	42000204 	addi	r8,r8,8
81125b0c:	8c7ffc04 	addi	r17,r17,-16
81125b10:	b441970e 	bge	r22,r17,81126170 <___vfprintf_internal_r+0x18fc>
81125b14:	18c00404 	addi	r3,r3,16
81125b18:	10800044 	addi	r2,r2,1
81125b1c:	45000015 	stw	r20,0(r8)
81125b20:	45800115 	stw	r22,4(r8)
81125b24:	d8c02015 	stw	r3,128(sp)
81125b28:	d8801f15 	stw	r2,124(sp)
81125b2c:	e0bff60e 	bge	fp,r2,81125b08 <__reset+0xfb105b08>
81125b30:	d9801e04 	addi	r6,sp,120
81125b34:	b80b883a 	mov	r5,r23
81125b38:	9809883a 	mov	r4,r19
81125b3c:	1130a640 	call	81130a64 <__sprint_r>
81125b40:	103c501e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
81125b44:	d8c02017 	ldw	r3,128(sp)
81125b48:	d8801f17 	ldw	r2,124(sp)
81125b4c:	da000404 	addi	r8,sp,16
81125b50:	003fee06 	br	81125b0c <__reset+0xfb105b0c>
81125b54:	d9002c17 	ldw	r4,176(sp)
81125b58:	d9801e04 	addi	r6,sp,120
81125b5c:	b80b883a 	mov	r5,r23
81125b60:	1130a640 	call	81130a64 <__sprint_r>
81125b64:	103c471e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
81125b68:	d8c02017 	ldw	r3,128(sp)
81125b6c:	df002787 	ldb	fp,158(sp)
81125b70:	da000404 	addi	r8,sp,16
81125b74:	003d5606 	br	811250d0 <__reset+0xfb1050d0>
81125b78:	9080040c 	andi	r2,r18,16
81125b7c:	10016126 	beq	r2,zero,81126104 <___vfprintf_internal_r+0x1890>
81125b80:	d8802d17 	ldw	r2,180(sp)
81125b84:	14c00017 	ldw	r19,0(r2)
81125b88:	10800104 	addi	r2,r2,4
81125b8c:	d8802d15 	stw	r2,180(sp)
81125b90:	982dd7fa 	srai	r22,r19,31
81125b94:	b005883a 	mov	r2,r22
81125b98:	003c8206 	br	81124da4 <__reset+0xfb104da4>
81125b9c:	9080040c 	andi	r2,r18,16
81125ba0:	10003526 	beq	r2,zero,81125c78 <___vfprintf_internal_r+0x1404>
81125ba4:	d9402d17 	ldw	r5,180(sp)
81125ba8:	d8c02917 	ldw	r3,164(sp)
81125bac:	d8002785 	stb	zero,158(sp)
81125bb0:	28800104 	addi	r2,r5,4
81125bb4:	2cc00017 	ldw	r19,0(r5)
81125bb8:	002d883a 	mov	r22,zero
81125bbc:	18003716 	blt	r3,zero,81125c9c <___vfprintf_internal_r+0x1428>
81125bc0:	00ffdfc4 	movi	r3,-129
81125bc4:	d8802d15 	stw	r2,180(sp)
81125bc8:	90e4703a 	and	r18,r18,r3
81125bcc:	0039883a 	mov	fp,zero
81125bd0:	983df326 	beq	r19,zero,811253a0 <__reset+0xfb1053a0>
81125bd4:	00800244 	movi	r2,9
81125bd8:	14fc7b36 	bltu	r2,r19,81124dc8 <__reset+0xfb104dc8>
81125bdc:	d8c02817 	ldw	r3,160(sp)
81125be0:	dc001dc4 	addi	r16,sp,119
81125be4:	9cc00c04 	addi	r19,r19,48
81125be8:	1c07c83a 	sub	r3,r3,r16
81125bec:	dcc01dc5 	stb	r19,119(sp)
81125bf0:	d8c02e15 	stw	r3,184(sp)
81125bf4:	003ce806 	br	81124f98 <__reset+0xfb104f98>
81125bf8:	d8803317 	ldw	r2,204(sp)
81125bfc:	143fffc4 	addi	r16,r2,-1
81125c00:	043f4d0e 	bge	zero,r16,81125938 <__reset+0xfb105938>
81125c04:	07000404 	movi	fp,16
81125c08:	e400810e 	bge	fp,r16,81125e10 <___vfprintf_internal_r+0x159c>
81125c0c:	01604574 	movhi	r5,33045
81125c10:	297ea984 	addi	r5,r5,-1370
81125c14:	d9402b15 	stw	r5,172(sp)
81125c18:	01c001c4 	movi	r7,7
81125c1c:	dcc02c17 	ldw	r19,176(sp)
81125c20:	00000306 	br	81125c30 <___vfprintf_internal_r+0x13bc>
81125c24:	b5800204 	addi	r22,r22,8
81125c28:	843ffc04 	addi	r16,r16,-16
81125c2c:	e4007b0e 	bge	fp,r16,81125e1c <___vfprintf_internal_r+0x15a8>
81125c30:	18c00404 	addi	r3,r3,16
81125c34:	8c400044 	addi	r17,r17,1
81125c38:	b5000015 	stw	r20,0(r22)
81125c3c:	b7000115 	stw	fp,4(r22)
81125c40:	d8c02015 	stw	r3,128(sp)
81125c44:	dc401f15 	stw	r17,124(sp)
81125c48:	3c7ff60e 	bge	r7,r17,81125c24 <__reset+0xfb105c24>
81125c4c:	d9801e04 	addi	r6,sp,120
81125c50:	b80b883a 	mov	r5,r23
81125c54:	9809883a 	mov	r4,r19
81125c58:	d9c03c15 	stw	r7,240(sp)
81125c5c:	1130a640 	call	81130a64 <__sprint_r>
81125c60:	d9c03c17 	ldw	r7,240(sp)
81125c64:	103c071e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
81125c68:	d8c02017 	ldw	r3,128(sp)
81125c6c:	dc401f17 	ldw	r17,124(sp)
81125c70:	dd800404 	addi	r22,sp,16
81125c74:	003fec06 	br	81125c28 <__reset+0xfb105c28>
81125c78:	9080100c 	andi	r2,r18,64
81125c7c:	d8002785 	stb	zero,158(sp)
81125c80:	10010e26 	beq	r2,zero,811260bc <___vfprintf_internal_r+0x1848>
81125c84:	d9002d17 	ldw	r4,180(sp)
81125c88:	d9402917 	ldw	r5,164(sp)
81125c8c:	002d883a 	mov	r22,zero
81125c90:	20800104 	addi	r2,r4,4
81125c94:	24c0000b 	ldhu	r19,0(r4)
81125c98:	283fc90e 	bge	r5,zero,81125bc0 <__reset+0xfb105bc0>
81125c9c:	d8802d15 	stw	r2,180(sp)
81125ca0:	0039883a 	mov	fp,zero
81125ca4:	9d84b03a 	or	r2,r19,r22
81125ca8:	103c461e 	bne	r2,zero,81124dc4 <__reset+0xfb104dc4>
81125cac:	00800044 	movi	r2,1
81125cb0:	003e6c06 	br	81125664 <__reset+0xfb105664>
81125cb4:	d9002c17 	ldw	r4,176(sp)
81125cb8:	d9801e04 	addi	r6,sp,120
81125cbc:	b80b883a 	mov	r5,r23
81125cc0:	1130a640 	call	81130a64 <__sprint_r>
81125cc4:	103bef1e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
81125cc8:	d8c02017 	ldw	r3,128(sp)
81125ccc:	da000404 	addi	r8,sp,16
81125cd0:	d9003217 	ldw	r4,200(sp)
81125cd4:	d8802617 	ldw	r2,152(sp)
81125cd8:	d9403317 	ldw	r5,204(sp)
81125cdc:	8123883a 	add	r17,r16,r4
81125ce0:	11400216 	blt	r2,r5,81125cec <___vfprintf_internal_r+0x1478>
81125ce4:	9100004c 	andi	r4,r18,1
81125ce8:	20000d26 	beq	r4,zero,81125d20 <___vfprintf_internal_r+0x14ac>
81125cec:	d9003717 	ldw	r4,220(sp)
81125cf0:	d9403417 	ldw	r5,208(sp)
81125cf4:	1907883a 	add	r3,r3,r4
81125cf8:	d9001f17 	ldw	r4,124(sp)
81125cfc:	41400015 	stw	r5,0(r8)
81125d00:	d9403717 	ldw	r5,220(sp)
81125d04:	21000044 	addi	r4,r4,1
81125d08:	d8c02015 	stw	r3,128(sp)
81125d0c:	41400115 	stw	r5,4(r8)
81125d10:	d9001f15 	stw	r4,124(sp)
81125d14:	014001c4 	movi	r5,7
81125d18:	2901e816 	blt	r5,r4,811264bc <___vfprintf_internal_r+0x1c48>
81125d1c:	42000204 	addi	r8,r8,8
81125d20:	d9003317 	ldw	r4,204(sp)
81125d24:	8121883a 	add	r16,r16,r4
81125d28:	2085c83a 	sub	r2,r4,r2
81125d2c:	8461c83a 	sub	r16,r16,r17
81125d30:	1400010e 	bge	r2,r16,81125d38 <___vfprintf_internal_r+0x14c4>
81125d34:	1021883a 	mov	r16,r2
81125d38:	04000a0e 	bge	zero,r16,81125d64 <___vfprintf_internal_r+0x14f0>
81125d3c:	d9001f17 	ldw	r4,124(sp)
81125d40:	1c07883a 	add	r3,r3,r16
81125d44:	44400015 	stw	r17,0(r8)
81125d48:	21000044 	addi	r4,r4,1
81125d4c:	44000115 	stw	r16,4(r8)
81125d50:	d8c02015 	stw	r3,128(sp)
81125d54:	d9001f15 	stw	r4,124(sp)
81125d58:	014001c4 	movi	r5,7
81125d5c:	2901fb16 	blt	r5,r4,8112654c <___vfprintf_internal_r+0x1cd8>
81125d60:	42000204 	addi	r8,r8,8
81125d64:	8001f716 	blt	r16,zero,81126544 <___vfprintf_internal_r+0x1cd0>
81125d68:	1421c83a 	sub	r16,r2,r16
81125d6c:	043d380e 	bge	zero,r16,81125250 <__reset+0xfb105250>
81125d70:	04400404 	movi	r17,16
81125d74:	d8801f17 	ldw	r2,124(sp)
81125d78:	8c3efb0e 	bge	r17,r16,81125968 <__reset+0xfb105968>
81125d7c:	01604574 	movhi	r5,33045
81125d80:	297ea984 	addi	r5,r5,-1370
81125d84:	d9402b15 	stw	r5,172(sp)
81125d88:	058001c4 	movi	r22,7
81125d8c:	dcc02c17 	ldw	r19,176(sp)
81125d90:	00000306 	br	81125da0 <___vfprintf_internal_r+0x152c>
81125d94:	42000204 	addi	r8,r8,8
81125d98:	843ffc04 	addi	r16,r16,-16
81125d9c:	8c3ef50e 	bge	r17,r16,81125974 <__reset+0xfb105974>
81125da0:	18c00404 	addi	r3,r3,16
81125da4:	10800044 	addi	r2,r2,1
81125da8:	45000015 	stw	r20,0(r8)
81125dac:	44400115 	stw	r17,4(r8)
81125db0:	d8c02015 	stw	r3,128(sp)
81125db4:	d8801f15 	stw	r2,124(sp)
81125db8:	b0bff60e 	bge	r22,r2,81125d94 <__reset+0xfb105d94>
81125dbc:	d9801e04 	addi	r6,sp,120
81125dc0:	b80b883a 	mov	r5,r23
81125dc4:	9809883a 	mov	r4,r19
81125dc8:	1130a640 	call	81130a64 <__sprint_r>
81125dcc:	103bad1e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
81125dd0:	d8c02017 	ldw	r3,128(sp)
81125dd4:	d8801f17 	ldw	r2,124(sp)
81125dd8:	da000404 	addi	r8,sp,16
81125ddc:	003fee06 	br	81125d98 <__reset+0xfb105d98>
81125de0:	9088703a 	and	r4,r18,r2
81125de4:	203eab1e 	bne	r4,zero,81125894 <__reset+0xfb105894>
81125de8:	dc401f17 	ldw	r17,124(sp)
81125dec:	40800115 	stw	r2,4(r8)
81125df0:	44000015 	stw	r16,0(r8)
81125df4:	8c400044 	addi	r17,r17,1
81125df8:	d8c02015 	stw	r3,128(sp)
81125dfc:	dc401f15 	stw	r17,124(sp)
81125e00:	008001c4 	movi	r2,7
81125e04:	14400e16 	blt	r2,r17,81125e40 <___vfprintf_internal_r+0x15cc>
81125e08:	45800204 	addi	r22,r8,8
81125e0c:	003eca06 	br	81125938 <__reset+0xfb105938>
81125e10:	01204574 	movhi	r4,33045
81125e14:	213ea984 	addi	r4,r4,-1370
81125e18:	d9002b15 	stw	r4,172(sp)
81125e1c:	d8802b17 	ldw	r2,172(sp)
81125e20:	1c07883a 	add	r3,r3,r16
81125e24:	8c400044 	addi	r17,r17,1
81125e28:	b0800015 	stw	r2,0(r22)
81125e2c:	b4000115 	stw	r16,4(r22)
81125e30:	d8c02015 	stw	r3,128(sp)
81125e34:	dc401f15 	stw	r17,124(sp)
81125e38:	008001c4 	movi	r2,7
81125e3c:	147ebd0e 	bge	r2,r17,81125934 <__reset+0xfb105934>
81125e40:	d9002c17 	ldw	r4,176(sp)
81125e44:	d9801e04 	addi	r6,sp,120
81125e48:	b80b883a 	mov	r5,r23
81125e4c:	1130a640 	call	81130a64 <__sprint_r>
81125e50:	103b8c1e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
81125e54:	d8c02017 	ldw	r3,128(sp)
81125e58:	dc401f17 	ldw	r17,124(sp)
81125e5c:	dd800404 	addi	r22,sp,16
81125e60:	003eb506 	br	81125938 <__reset+0xfb105938>
81125e64:	d9002c17 	ldw	r4,176(sp)
81125e68:	d9801e04 	addi	r6,sp,120
81125e6c:	b80b883a 	mov	r5,r23
81125e70:	1130a640 	call	81130a64 <__sprint_r>
81125e74:	103b831e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
81125e78:	d8c02017 	ldw	r3,128(sp)
81125e7c:	dc401f17 	ldw	r17,124(sp)
81125e80:	da000404 	addi	r8,sp,16
81125e84:	003e8d06 	br	811258bc <__reset+0xfb1058bc>
81125e88:	d9002c17 	ldw	r4,176(sp)
81125e8c:	d9801e04 	addi	r6,sp,120
81125e90:	b80b883a 	mov	r5,r23
81125e94:	1130a640 	call	81130a64 <__sprint_r>
81125e98:	103b7a1e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
81125e9c:	d8c02017 	ldw	r3,128(sp)
81125ea0:	dc401f17 	ldw	r17,124(sp)
81125ea4:	dd800404 	addi	r22,sp,16
81125ea8:	003e8f06 	br	811258e8 <__reset+0xfb1058e8>
81125eac:	0027883a 	mov	r19,zero
81125eb0:	003f4a06 	br	81125bdc <__reset+0xfb105bdc>
81125eb4:	d9002c17 	ldw	r4,176(sp)
81125eb8:	d9801e04 	addi	r6,sp,120
81125ebc:	b80b883a 	mov	r5,r23
81125ec0:	1130a640 	call	81130a64 <__sprint_r>
81125ec4:	103b6f1e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
81125ec8:	d8c02017 	ldw	r3,128(sp)
81125ecc:	da000404 	addi	r8,sp,16
81125ed0:	003c9d06 	br	81125148 <__reset+0xfb105148>
81125ed4:	04e7c83a 	sub	r19,zero,r19
81125ed8:	9804c03a 	cmpne	r2,r19,zero
81125edc:	05adc83a 	sub	r22,zero,r22
81125ee0:	b0adc83a 	sub	r22,r22,r2
81125ee4:	d8802917 	ldw	r2,164(sp)
81125ee8:	07000b44 	movi	fp,45
81125eec:	df002785 	stb	fp,158(sp)
81125ef0:	10017b16 	blt	r2,zero,811264e0 <___vfprintf_internal_r+0x1c6c>
81125ef4:	00bfdfc4 	movi	r2,-129
81125ef8:	90a4703a 	and	r18,r18,r2
81125efc:	003bb106 	br	81124dc4 <__reset+0xfb104dc4>
81125f00:	d9003617 	ldw	r4,216(sp)
81125f04:	d9403817 	ldw	r5,224(sp)
81125f08:	da003d15 	stw	r8,244(sp)
81125f0c:	112d0c80 	call	8112d0c8 <__fpclassifyd>
81125f10:	da003d17 	ldw	r8,244(sp)
81125f14:	1000f026 	beq	r2,zero,811262d8 <___vfprintf_internal_r+0x1a64>
81125f18:	d9002917 	ldw	r4,164(sp)
81125f1c:	05bff7c4 	movi	r22,-33
81125f20:	00bfffc4 	movi	r2,-1
81125f24:	8dac703a 	and	r22,r17,r22
81125f28:	20820026 	beq	r4,r2,8112672c <___vfprintf_internal_r+0x1eb8>
81125f2c:	008011c4 	movi	r2,71
81125f30:	b081f726 	beq	r22,r2,81126710 <___vfprintf_internal_r+0x1e9c>
81125f34:	d9003817 	ldw	r4,224(sp)
81125f38:	90c04014 	ori	r3,r18,256
81125f3c:	d8c02b15 	stw	r3,172(sp)
81125f40:	20021516 	blt	r4,zero,81126798 <___vfprintf_internal_r+0x1f24>
81125f44:	dcc03817 	ldw	r19,224(sp)
81125f48:	d8002a05 	stb	zero,168(sp)
81125f4c:	00801984 	movi	r2,102
81125f50:	8881f926 	beq	r17,r2,81126738 <___vfprintf_internal_r+0x1ec4>
81125f54:	00801184 	movi	r2,70
81125f58:	88821c26 	beq	r17,r2,811267cc <___vfprintf_internal_r+0x1f58>
81125f5c:	00801144 	movi	r2,69
81125f60:	b081ef26 	beq	r22,r2,81126720 <___vfprintf_internal_r+0x1eac>
81125f64:	d8c02917 	ldw	r3,164(sp)
81125f68:	d8802104 	addi	r2,sp,132
81125f6c:	d8800315 	stw	r2,12(sp)
81125f70:	d9403617 	ldw	r5,216(sp)
81125f74:	d8802504 	addi	r2,sp,148
81125f78:	d9002c17 	ldw	r4,176(sp)
81125f7c:	d8800215 	stw	r2,8(sp)
81125f80:	d8802604 	addi	r2,sp,152
81125f84:	d8c00015 	stw	r3,0(sp)
81125f88:	d8800115 	stw	r2,4(sp)
81125f8c:	01c00084 	movi	r7,2
81125f90:	980d883a 	mov	r6,r19
81125f94:	d8c03c15 	stw	r3,240(sp)
81125f98:	da003d15 	stw	r8,244(sp)
81125f9c:	11289800 	call	81128980 <_dtoa_r>
81125fa0:	1021883a 	mov	r16,r2
81125fa4:	008019c4 	movi	r2,103
81125fa8:	d8c03c17 	ldw	r3,240(sp)
81125fac:	da003d17 	ldw	r8,244(sp)
81125fb0:	88817126 	beq	r17,r2,81126578 <___vfprintf_internal_r+0x1d04>
81125fb4:	008011c4 	movi	r2,71
81125fb8:	88829226 	beq	r17,r2,81126a04 <___vfprintf_internal_r+0x2190>
81125fbc:	80f9883a 	add	fp,r16,r3
81125fc0:	d9003617 	ldw	r4,216(sp)
81125fc4:	000d883a 	mov	r6,zero
81125fc8:	000f883a 	mov	r7,zero
81125fcc:	980b883a 	mov	r5,r19
81125fd0:	da003d15 	stw	r8,244(sp)
81125fd4:	11352300 	call	81135230 <__eqdf2>
81125fd8:	da003d17 	ldw	r8,244(sp)
81125fdc:	10018d26 	beq	r2,zero,81126614 <___vfprintf_internal_r+0x1da0>
81125fe0:	d8802117 	ldw	r2,132(sp)
81125fe4:	1700062e 	bgeu	r2,fp,81126000 <___vfprintf_internal_r+0x178c>
81125fe8:	01000c04 	movi	r4,48
81125fec:	10c00044 	addi	r3,r2,1
81125ff0:	d8c02115 	stw	r3,132(sp)
81125ff4:	11000005 	stb	r4,0(r2)
81125ff8:	d8802117 	ldw	r2,132(sp)
81125ffc:	173ffb36 	bltu	r2,fp,81125fec <__reset+0xfb105fec>
81126000:	1405c83a 	sub	r2,r2,r16
81126004:	d8803315 	stw	r2,204(sp)
81126008:	008011c4 	movi	r2,71
8112600c:	b0817626 	beq	r22,r2,811265e8 <___vfprintf_internal_r+0x1d74>
81126010:	00801944 	movi	r2,101
81126014:	1442810e 	bge	r2,r17,81126a1c <___vfprintf_internal_r+0x21a8>
81126018:	d8c02617 	ldw	r3,152(sp)
8112601c:	00801984 	movi	r2,102
81126020:	d8c03215 	stw	r3,200(sp)
81126024:	8881fe26 	beq	r17,r2,81126820 <___vfprintf_internal_r+0x1fac>
81126028:	d8c03217 	ldw	r3,200(sp)
8112602c:	d9003317 	ldw	r4,204(sp)
81126030:	1901dd16 	blt	r3,r4,811267a8 <___vfprintf_internal_r+0x1f34>
81126034:	9480004c 	andi	r18,r18,1
81126038:	90022b1e 	bne	r18,zero,811268e8 <___vfprintf_internal_r+0x2074>
8112603c:	1805883a 	mov	r2,r3
81126040:	18028016 	blt	r3,zero,81126a44 <___vfprintf_internal_r+0x21d0>
81126044:	d8c03217 	ldw	r3,200(sp)
81126048:	044019c4 	movi	r17,103
8112604c:	d8c02e15 	stw	r3,184(sp)
81126050:	df002a07 	ldb	fp,168(sp)
81126054:	e001531e 	bne	fp,zero,811265a4 <___vfprintf_internal_r+0x1d30>
81126058:	df002783 	ldbu	fp,158(sp)
8112605c:	d8802a15 	stw	r2,168(sp)
81126060:	dc802b17 	ldw	r18,172(sp)
81126064:	d8002915 	stw	zero,164(sp)
81126068:	003bd106 	br	81124fb0 <__reset+0xfb104fb0>
8112606c:	d8802d17 	ldw	r2,180(sp)
81126070:	d8c02d17 	ldw	r3,180(sp)
81126074:	d9002d17 	ldw	r4,180(sp)
81126078:	10800017 	ldw	r2,0(r2)
8112607c:	18c00117 	ldw	r3,4(r3)
81126080:	21000204 	addi	r4,r4,8
81126084:	d8803615 	stw	r2,216(sp)
81126088:	d8c03815 	stw	r3,224(sp)
8112608c:	d9002d15 	stw	r4,180(sp)
81126090:	003b7506 	br	81124e68 <__reset+0xfb104e68>
81126094:	ac400007 	ldb	r17,0(r21)
81126098:	003a5906 	br	81124a00 <__reset+0xfb104a00>
8112609c:	9080100c 	andi	r2,r18,64
811260a0:	1000a826 	beq	r2,zero,81126344 <___vfprintf_internal_r+0x1ad0>
811260a4:	d9002d17 	ldw	r4,180(sp)
811260a8:	002d883a 	mov	r22,zero
811260ac:	24c0000b 	ldhu	r19,0(r4)
811260b0:	21000104 	addi	r4,r4,4
811260b4:	d9002d15 	stw	r4,180(sp)
811260b8:	003ccb06 	br	811253e8 <__reset+0xfb1053e8>
811260bc:	d8c02d17 	ldw	r3,180(sp)
811260c0:	d9002917 	ldw	r4,164(sp)
811260c4:	002d883a 	mov	r22,zero
811260c8:	18800104 	addi	r2,r3,4
811260cc:	1cc00017 	ldw	r19,0(r3)
811260d0:	203ebb0e 	bge	r4,zero,81125bc0 <__reset+0xfb105bc0>
811260d4:	003ef106 	br	81125c9c <__reset+0xfb105c9c>
811260d8:	9080040c 	andi	r2,r18,16
811260dc:	1000921e 	bne	r2,zero,81126328 <___vfprintf_internal_r+0x1ab4>
811260e0:	9480100c 	andi	r18,r18,64
811260e4:	90013926 	beq	r18,zero,811265cc <___vfprintf_internal_r+0x1d58>
811260e8:	d9002d17 	ldw	r4,180(sp)
811260ec:	d9402f17 	ldw	r5,188(sp)
811260f0:	20800017 	ldw	r2,0(r4)
811260f4:	21000104 	addi	r4,r4,4
811260f8:	d9002d15 	stw	r4,180(sp)
811260fc:	1140000d 	sth	r5,0(r2)
81126100:	003a1606 	br	8112495c <__reset+0xfb10495c>
81126104:	9080100c 	andi	r2,r18,64
81126108:	10008026 	beq	r2,zero,8112630c <___vfprintf_internal_r+0x1a98>
8112610c:	d8c02d17 	ldw	r3,180(sp)
81126110:	1cc0000f 	ldh	r19,0(r3)
81126114:	18c00104 	addi	r3,r3,4
81126118:	d8c02d15 	stw	r3,180(sp)
8112611c:	982dd7fa 	srai	r22,r19,31
81126120:	b005883a 	mov	r2,r22
81126124:	003b1f06 	br	81124da4 <__reset+0xfb104da4>
81126128:	9080100c 	andi	r2,r18,64
8112612c:	d8002785 	stb	zero,158(sp)
81126130:	10008a1e 	bne	r2,zero,8112635c <___vfprintf_internal_r+0x1ae8>
81126134:	d9402d17 	ldw	r5,180(sp)
81126138:	d8c02917 	ldw	r3,164(sp)
8112613c:	002d883a 	mov	r22,zero
81126140:	28800104 	addi	r2,r5,4
81126144:	2cc00017 	ldw	r19,0(r5)
81126148:	183e4b0e 	bge	r3,zero,81125a78 <__reset+0xfb105a78>
8112614c:	9d86b03a 	or	r3,r19,r22
81126150:	d8802d15 	stw	r2,180(sp)
81126154:	183e4c1e 	bne	r3,zero,81125a88 <__reset+0xfb105a88>
81126158:	0039883a 	mov	fp,zero
8112615c:	0005883a 	mov	r2,zero
81126160:	003d4006 	br	81125664 <__reset+0xfb105664>
81126164:	01604574 	movhi	r5,33045
81126168:	297ea984 	addi	r5,r5,-1370
8112616c:	d9402b15 	stw	r5,172(sp)
81126170:	d9402b17 	ldw	r5,172(sp)
81126174:	1c47883a 	add	r3,r3,r17
81126178:	10800044 	addi	r2,r2,1
8112617c:	41400015 	stw	r5,0(r8)
81126180:	44400115 	stw	r17,4(r8)
81126184:	d8c02015 	stw	r3,128(sp)
81126188:	d8801f15 	stw	r2,124(sp)
8112618c:	010001c4 	movi	r4,7
81126190:	20bec816 	blt	r4,r2,81125cb4 <__reset+0xfb105cb4>
81126194:	42000204 	addi	r8,r8,8
81126198:	003ecd06 	br	81125cd0 <__reset+0xfb105cd0>
8112619c:	d9002917 	ldw	r4,164(sp)
811261a0:	d8002785 	stb	zero,158(sp)
811261a4:	203d2d16 	blt	r4,zero,8112565c <__reset+0xfb10565c>
811261a8:	00bfdfc4 	movi	r2,-129
811261ac:	90a4703a 	and	r18,r18,r2
811261b0:	003a9106 	br	81124bf8 <__reset+0xfb104bf8>
811261b4:	01204574 	movhi	r4,33045
811261b8:	213ea984 	addi	r4,r4,-1370
811261bc:	d9002b15 	stw	r4,172(sp)
811261c0:	003c0c06 	br	811251f4 <__reset+0xfb1051f4>
811261c4:	d9002c17 	ldw	r4,176(sp)
811261c8:	d9801e04 	addi	r6,sp,120
811261cc:	b80b883a 	mov	r5,r23
811261d0:	1130a640 	call	81130a64 <__sprint_r>
811261d4:	103aab1e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
811261d8:	d8c02017 	ldw	r3,128(sp)
811261dc:	da000404 	addi	r8,sp,16
811261e0:	003d4106 	br	811256e8 <__reset+0xfb1056e8>
811261e4:	d8801f17 	ldw	r2,124(sp)
811261e8:	01604574 	movhi	r5,33045
811261ec:	01000044 	movi	r4,1
811261f0:	18c00044 	addi	r3,r3,1
811261f4:	10800044 	addi	r2,r2,1
811261f8:	297ea104 	addi	r5,r5,-1404
811261fc:	41000115 	stw	r4,4(r8)
81126200:	41400015 	stw	r5,0(r8)
81126204:	d8c02015 	stw	r3,128(sp)
81126208:	d8801f15 	stw	r2,124(sp)
8112620c:	010001c4 	movi	r4,7
81126210:	20805c16 	blt	r4,r2,81126384 <___vfprintf_internal_r+0x1b10>
81126214:	42000204 	addi	r8,r8,8
81126218:	8800041e 	bne	r17,zero,8112622c <___vfprintf_internal_r+0x19b8>
8112621c:	d8803317 	ldw	r2,204(sp)
81126220:	1000021e 	bne	r2,zero,8112622c <___vfprintf_internal_r+0x19b8>
81126224:	9080004c 	andi	r2,r18,1
81126228:	103c0926 	beq	r2,zero,81125250 <__reset+0xfb105250>
8112622c:	d9003717 	ldw	r4,220(sp)
81126230:	d8801f17 	ldw	r2,124(sp)
81126234:	d9403417 	ldw	r5,208(sp)
81126238:	20c7883a 	add	r3,r4,r3
8112623c:	10800044 	addi	r2,r2,1
81126240:	41000115 	stw	r4,4(r8)
81126244:	41400015 	stw	r5,0(r8)
81126248:	d8c02015 	stw	r3,128(sp)
8112624c:	d8801f15 	stw	r2,124(sp)
81126250:	010001c4 	movi	r4,7
81126254:	20812116 	blt	r4,r2,811266dc <___vfprintf_internal_r+0x1e68>
81126258:	42000204 	addi	r8,r8,8
8112625c:	0463c83a 	sub	r17,zero,r17
81126260:	0440730e 	bge	zero,r17,81126430 <___vfprintf_internal_r+0x1bbc>
81126264:	05800404 	movi	r22,16
81126268:	b440860e 	bge	r22,r17,81126484 <___vfprintf_internal_r+0x1c10>
8112626c:	01604574 	movhi	r5,33045
81126270:	297ea984 	addi	r5,r5,-1370
81126274:	d9402b15 	stw	r5,172(sp)
81126278:	070001c4 	movi	fp,7
8112627c:	dcc02c17 	ldw	r19,176(sp)
81126280:	00000306 	br	81126290 <___vfprintf_internal_r+0x1a1c>
81126284:	42000204 	addi	r8,r8,8
81126288:	8c7ffc04 	addi	r17,r17,-16
8112628c:	b440800e 	bge	r22,r17,81126490 <___vfprintf_internal_r+0x1c1c>
81126290:	18c00404 	addi	r3,r3,16
81126294:	10800044 	addi	r2,r2,1
81126298:	45000015 	stw	r20,0(r8)
8112629c:	45800115 	stw	r22,4(r8)
811262a0:	d8c02015 	stw	r3,128(sp)
811262a4:	d8801f15 	stw	r2,124(sp)
811262a8:	e0bff60e 	bge	fp,r2,81126284 <__reset+0xfb106284>
811262ac:	d9801e04 	addi	r6,sp,120
811262b0:	b80b883a 	mov	r5,r23
811262b4:	9809883a 	mov	r4,r19
811262b8:	1130a640 	call	81130a64 <__sprint_r>
811262bc:	103a711e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
811262c0:	d8c02017 	ldw	r3,128(sp)
811262c4:	d8801f17 	ldw	r2,124(sp)
811262c8:	da000404 	addi	r8,sp,16
811262cc:	003fee06 	br	81126288 <__reset+0xfb106288>
811262d0:	00bfffc4 	movi	r2,-1
811262d4:	003a6f06 	br	81124c94 <__reset+0xfb104c94>
811262d8:	008011c4 	movi	r2,71
811262dc:	1440b816 	blt	r2,r17,811265c0 <___vfprintf_internal_r+0x1d4c>
811262e0:	04204574 	movhi	r16,33045
811262e4:	843e9304 	addi	r16,r16,-1460
811262e8:	00c000c4 	movi	r3,3
811262ec:	00bfdfc4 	movi	r2,-129
811262f0:	d8c02a15 	stw	r3,168(sp)
811262f4:	90a4703a 	and	r18,r18,r2
811262f8:	df002783 	ldbu	fp,158(sp)
811262fc:	d8c02e15 	stw	r3,184(sp)
81126300:	d8002915 	stw	zero,164(sp)
81126304:	d8003215 	stw	zero,200(sp)
81126308:	003b2906 	br	81124fb0 <__reset+0xfb104fb0>
8112630c:	d9002d17 	ldw	r4,180(sp)
81126310:	24c00017 	ldw	r19,0(r4)
81126314:	21000104 	addi	r4,r4,4
81126318:	d9002d15 	stw	r4,180(sp)
8112631c:	982dd7fa 	srai	r22,r19,31
81126320:	b005883a 	mov	r2,r22
81126324:	003a9f06 	br	81124da4 <__reset+0xfb104da4>
81126328:	d9402d17 	ldw	r5,180(sp)
8112632c:	d8c02f17 	ldw	r3,188(sp)
81126330:	28800017 	ldw	r2,0(r5)
81126334:	29400104 	addi	r5,r5,4
81126338:	d9402d15 	stw	r5,180(sp)
8112633c:	10c00015 	stw	r3,0(r2)
81126340:	00398606 	br	8112495c <__reset+0xfb10495c>
81126344:	d9402d17 	ldw	r5,180(sp)
81126348:	002d883a 	mov	r22,zero
8112634c:	2cc00017 	ldw	r19,0(r5)
81126350:	29400104 	addi	r5,r5,4
81126354:	d9402d15 	stw	r5,180(sp)
81126358:	003c2306 	br	811253e8 <__reset+0xfb1053e8>
8112635c:	d8c02d17 	ldw	r3,180(sp)
81126360:	d9002917 	ldw	r4,164(sp)
81126364:	002d883a 	mov	r22,zero
81126368:	18800104 	addi	r2,r3,4
8112636c:	1cc0000b 	ldhu	r19,0(r3)
81126370:	203dc10e 	bge	r4,zero,81125a78 <__reset+0xfb105a78>
81126374:	003f7506 	br	8112614c <__reset+0xfb10614c>
81126378:	04204574 	movhi	r16,33045
8112637c:	843e9104 	addi	r16,r16,-1468
81126380:	003acc06 	br	81124eb4 <__reset+0xfb104eb4>
81126384:	d9002c17 	ldw	r4,176(sp)
81126388:	d9801e04 	addi	r6,sp,120
8112638c:	b80b883a 	mov	r5,r23
81126390:	1130a640 	call	81130a64 <__sprint_r>
81126394:	103a3b1e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
81126398:	dc402617 	ldw	r17,152(sp)
8112639c:	d8c02017 	ldw	r3,128(sp)
811263a0:	da000404 	addi	r8,sp,16
811263a4:	003f9c06 	br	81126218 <__reset+0xfb106218>
811263a8:	ac400043 	ldbu	r17,1(r21)
811263ac:	94800814 	ori	r18,r18,32
811263b0:	ad400044 	addi	r21,r21,1
811263b4:	8c403fcc 	andi	r17,r17,255
811263b8:	8c40201c 	xori	r17,r17,128
811263bc:	8c7fe004 	addi	r17,r17,-128
811263c0:	00398f06 	br	81124a00 <__reset+0xfb104a00>
811263c4:	d8c02d15 	stw	r3,180(sp)
811263c8:	0039883a 	mov	fp,zero
811263cc:	003e3506 	br	81125ca4 <__reset+0xfb105ca4>
811263d0:	d9002c17 	ldw	r4,176(sp)
811263d4:	d9801e04 	addi	r6,sp,120
811263d8:	b80b883a 	mov	r5,r23
811263dc:	1130a640 	call	81130a64 <__sprint_r>
811263e0:	103a281e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
811263e4:	d8c02017 	ldw	r3,128(sp)
811263e8:	da000404 	addi	r8,sp,16
811263ec:	003cd006 	br	81125730 <__reset+0xfb105730>
811263f0:	8009883a 	mov	r4,r16
811263f4:	da003d15 	stw	r8,244(sp)
811263f8:	112235c0 	call	8112235c <strlen>
811263fc:	d8802e15 	stw	r2,184(sp)
81126400:	da003d17 	ldw	r8,244(sp)
81126404:	103c340e 	bge	r2,zero,811254d8 <__reset+0xfb1054d8>
81126408:	0005883a 	mov	r2,zero
8112640c:	003c3206 	br	811254d8 <__reset+0xfb1054d8>
81126410:	d9002c17 	ldw	r4,176(sp)
81126414:	d9801e04 	addi	r6,sp,120
81126418:	b80b883a 	mov	r5,r23
8112641c:	1130a640 	call	81130a64 <__sprint_r>
81126420:	103a181e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
81126424:	d8c02017 	ldw	r3,128(sp)
81126428:	d8801f17 	ldw	r2,124(sp)
8112642c:	da000404 	addi	r8,sp,16
81126430:	d9403317 	ldw	r5,204(sp)
81126434:	10800044 	addi	r2,r2,1
81126438:	44000015 	stw	r16,0(r8)
8112643c:	28c7883a 	add	r3,r5,r3
81126440:	003b7d06 	br	81125238 <__reset+0xfb105238>
81126444:	01204574 	movhi	r4,33045
81126448:	213ead84 	addi	r4,r4,-1354
8112644c:	d9003515 	stw	r4,212(sp)
81126450:	003b1406 	br	811250a4 <__reset+0xfb1050a4>
81126454:	013fffc4 	movi	r4,-1
81126458:	003a3506 	br	81124d30 <__reset+0xfb104d30>
8112645c:	0023883a 	mov	r17,zero
81126460:	003d9d06 	br	81125ad8 <__reset+0xfb105ad8>
81126464:	d9002c17 	ldw	r4,176(sp)
81126468:	d9801e04 	addi	r6,sp,120
8112646c:	b80b883a 	mov	r5,r23
81126470:	1130a640 	call	81130a64 <__sprint_r>
81126474:	103a031e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
81126478:	d8c02017 	ldw	r3,128(sp)
8112647c:	da000404 	addi	r8,sp,16
81126480:	003d9406 	br	81125ad4 <__reset+0xfb105ad4>
81126484:	01204574 	movhi	r4,33045
81126488:	213ea984 	addi	r4,r4,-1370
8112648c:	d9002b15 	stw	r4,172(sp)
81126490:	d9002b17 	ldw	r4,172(sp)
81126494:	1c47883a 	add	r3,r3,r17
81126498:	10800044 	addi	r2,r2,1
8112649c:	41000015 	stw	r4,0(r8)
811264a0:	44400115 	stw	r17,4(r8)
811264a4:	d8c02015 	stw	r3,128(sp)
811264a8:	d8801f15 	stw	r2,124(sp)
811264ac:	010001c4 	movi	r4,7
811264b0:	20bfd716 	blt	r4,r2,81126410 <__reset+0xfb106410>
811264b4:	42000204 	addi	r8,r8,8
811264b8:	003fdd06 	br	81126430 <__reset+0xfb106430>
811264bc:	d9002c17 	ldw	r4,176(sp)
811264c0:	d9801e04 	addi	r6,sp,120
811264c4:	b80b883a 	mov	r5,r23
811264c8:	1130a640 	call	81130a64 <__sprint_r>
811264cc:	1039ed1e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
811264d0:	d8802617 	ldw	r2,152(sp)
811264d4:	d8c02017 	ldw	r3,128(sp)
811264d8:	da000404 	addi	r8,sp,16
811264dc:	003e1006 	br	81125d20 <__reset+0xfb105d20>
811264e0:	00800044 	movi	r2,1
811264e4:	10803fcc 	andi	r2,r2,255
811264e8:	00c00044 	movi	r3,1
811264ec:	10fa3526 	beq	r2,r3,81124dc4 <__reset+0xfb104dc4>
811264f0:	00c00084 	movi	r3,2
811264f4:	10fbcb26 	beq	r2,r3,81125424 <__reset+0xfb105424>
811264f8:	003a8f06 	br	81124f38 <__reset+0xfb104f38>
811264fc:	01204574 	movhi	r4,33045
81126500:	213ead84 	addi	r4,r4,-1354
81126504:	d9003515 	stw	r4,212(sp)
81126508:	003b7606 	br	811252e4 <__reset+0xfb1052e4>
8112650c:	d8802917 	ldw	r2,164(sp)
81126510:	00c00184 	movi	r3,6
81126514:	1880012e 	bgeu	r3,r2,8112651c <___vfprintf_internal_r+0x1ca8>
81126518:	1805883a 	mov	r2,r3
8112651c:	d8802e15 	stw	r2,184(sp)
81126520:	1000ef16 	blt	r2,zero,811268e0 <___vfprintf_internal_r+0x206c>
81126524:	04204574 	movhi	r16,33045
81126528:	d8802a15 	stw	r2,168(sp)
8112652c:	dcc02d15 	stw	r19,180(sp)
81126530:	d8002915 	stw	zero,164(sp)
81126534:	d8003215 	stw	zero,200(sp)
81126538:	843e9f04 	addi	r16,r16,-1412
8112653c:	0039883a 	mov	fp,zero
81126540:	003aa206 	br	81124fcc <__reset+0xfb104fcc>
81126544:	0021883a 	mov	r16,zero
81126548:	003e0706 	br	81125d68 <__reset+0xfb105d68>
8112654c:	d9002c17 	ldw	r4,176(sp)
81126550:	d9801e04 	addi	r6,sp,120
81126554:	b80b883a 	mov	r5,r23
81126558:	1130a640 	call	81130a64 <__sprint_r>
8112655c:	1039c91e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
81126560:	d8802617 	ldw	r2,152(sp)
81126564:	d9403317 	ldw	r5,204(sp)
81126568:	d8c02017 	ldw	r3,128(sp)
8112656c:	da000404 	addi	r8,sp,16
81126570:	2885c83a 	sub	r2,r5,r2
81126574:	003dfb06 	br	81125d64 <__reset+0xfb105d64>
81126578:	9080004c 	andi	r2,r18,1
8112657c:	103e8f1e 	bne	r2,zero,81125fbc <__reset+0xfb105fbc>
81126580:	d8802117 	ldw	r2,132(sp)
81126584:	003e9e06 	br	81126000 <__reset+0xfb106000>
81126588:	1025883a 	mov	r18,r2
8112658c:	0039883a 	mov	fp,zero
81126590:	00800084 	movi	r2,2
81126594:	003fd306 	br	811264e4 <__reset+0xfb1064e4>
81126598:	07000b44 	movi	fp,45
8112659c:	df002785 	stb	fp,158(sp)
811265a0:	003a4006 	br	81124ea4 <__reset+0xfb104ea4>
811265a4:	00c00b44 	movi	r3,45
811265a8:	d8c02785 	stb	r3,158(sp)
811265ac:	d8802a15 	stw	r2,168(sp)
811265b0:	dc802b17 	ldw	r18,172(sp)
811265b4:	d8002915 	stw	zero,164(sp)
811265b8:	07000b44 	movi	fp,45
811265bc:	003a8006 	br	81124fc0 <__reset+0xfb104fc0>
811265c0:	04204574 	movhi	r16,33045
811265c4:	843e9404 	addi	r16,r16,-1456
811265c8:	003f4706 	br	811262e8 <__reset+0xfb1062e8>
811265cc:	d8c02d17 	ldw	r3,180(sp)
811265d0:	d9002f17 	ldw	r4,188(sp)
811265d4:	18800017 	ldw	r2,0(r3)
811265d8:	18c00104 	addi	r3,r3,4
811265dc:	d8c02d15 	stw	r3,180(sp)
811265e0:	11000015 	stw	r4,0(r2)
811265e4:	0038dd06 	br	8112495c <__reset+0xfb10495c>
811265e8:	dd802617 	ldw	r22,152(sp)
811265ec:	00bfff44 	movi	r2,-3
811265f0:	b0801c16 	blt	r22,r2,81126664 <___vfprintf_internal_r+0x1df0>
811265f4:	d9402917 	ldw	r5,164(sp)
811265f8:	2d801a16 	blt	r5,r22,81126664 <___vfprintf_internal_r+0x1df0>
811265fc:	dd803215 	stw	r22,200(sp)
81126600:	003e8906 	br	81126028 <__reset+0xfb106028>
81126604:	01204574 	movhi	r4,33045
81126608:	213ea984 	addi	r4,r4,-1370
8112660c:	d9002b15 	stw	r4,172(sp)
81126610:	003c9106 	br	81125858 <__reset+0xfb105858>
81126614:	e005883a 	mov	r2,fp
81126618:	003e7906 	br	81126000 <__reset+0xfb106000>
8112661c:	d9402917 	ldw	r5,164(sp)
81126620:	df002783 	ldbu	fp,158(sp)
81126624:	dcc02d15 	stw	r19,180(sp)
81126628:	d9402a15 	stw	r5,168(sp)
8112662c:	d9402e15 	stw	r5,184(sp)
81126630:	d8002915 	stw	zero,164(sp)
81126634:	d8003215 	stw	zero,200(sp)
81126638:	003a5d06 	br	81124fb0 <__reset+0xfb104fb0>
8112663c:	9080004c 	andi	r2,r18,1
81126640:	0039883a 	mov	fp,zero
81126644:	10000426 	beq	r2,zero,81126658 <___vfprintf_internal_r+0x1de4>
81126648:	00800c04 	movi	r2,48
8112664c:	dc001dc4 	addi	r16,sp,119
81126650:	d8801dc5 	stb	r2,119(sp)
81126654:	003b8006 	br	81125458 <__reset+0xfb105458>
81126658:	d8002e15 	stw	zero,184(sp)
8112665c:	dc001e04 	addi	r16,sp,120
81126660:	003a4d06 	br	81124f98 <__reset+0xfb104f98>
81126664:	8c7fff84 	addi	r17,r17,-2
81126668:	b5bfffc4 	addi	r22,r22,-1
8112666c:	dd802615 	stw	r22,152(sp)
81126670:	dc4022c5 	stb	r17,139(sp)
81126674:	b000bf16 	blt	r22,zero,81126974 <___vfprintf_internal_r+0x2100>
81126678:	00800ac4 	movi	r2,43
8112667c:	d8802305 	stb	r2,140(sp)
81126680:	00800244 	movi	r2,9
81126684:	15807016 	blt	r2,r22,81126848 <___vfprintf_internal_r+0x1fd4>
81126688:	00800c04 	movi	r2,48
8112668c:	b5800c04 	addi	r22,r22,48
81126690:	d8802345 	stb	r2,141(sp)
81126694:	dd802385 	stb	r22,142(sp)
81126698:	d88023c4 	addi	r2,sp,143
8112669c:	df0022c4 	addi	fp,sp,139
811266a0:	d8c03317 	ldw	r3,204(sp)
811266a4:	1739c83a 	sub	fp,r2,fp
811266a8:	d9003317 	ldw	r4,204(sp)
811266ac:	e0c7883a 	add	r3,fp,r3
811266b0:	df003a15 	stw	fp,232(sp)
811266b4:	d8c02e15 	stw	r3,184(sp)
811266b8:	00800044 	movi	r2,1
811266bc:	1100b30e 	bge	r2,r4,8112698c <___vfprintf_internal_r+0x2118>
811266c0:	d8c02e17 	ldw	r3,184(sp)
811266c4:	18c00044 	addi	r3,r3,1
811266c8:	d8c02e15 	stw	r3,184(sp)
811266cc:	1805883a 	mov	r2,r3
811266d0:	1800ac16 	blt	r3,zero,81126984 <___vfprintf_internal_r+0x2110>
811266d4:	d8003215 	stw	zero,200(sp)
811266d8:	003e5d06 	br	81126050 <__reset+0xfb106050>
811266dc:	d9002c17 	ldw	r4,176(sp)
811266e0:	d9801e04 	addi	r6,sp,120
811266e4:	b80b883a 	mov	r5,r23
811266e8:	1130a640 	call	81130a64 <__sprint_r>
811266ec:	1039651e 	bne	r2,zero,81124c84 <__reset+0xfb104c84>
811266f0:	dc402617 	ldw	r17,152(sp)
811266f4:	d8c02017 	ldw	r3,128(sp)
811266f8:	d8801f17 	ldw	r2,124(sp)
811266fc:	da000404 	addi	r8,sp,16
81126700:	003ed606 	br	8112625c <__reset+0xfb10625c>
81126704:	582b883a 	mov	r21,r11
81126708:	d8002915 	stw	zero,164(sp)
8112670c:	0038bd06 	br	81124a04 <__reset+0xfb104a04>
81126710:	d8802917 	ldw	r2,164(sp)
81126714:	103e071e 	bne	r2,zero,81125f34 <__reset+0xfb105f34>
81126718:	dc002915 	stw	r16,164(sp)
8112671c:	003e0506 	br	81125f34 <__reset+0xfb105f34>
81126720:	d9002917 	ldw	r4,164(sp)
81126724:	20c00044 	addi	r3,r4,1
81126728:	003e0f06 	br	81125f68 <__reset+0xfb105f68>
8112672c:	01400184 	movi	r5,6
81126730:	d9402915 	stw	r5,164(sp)
81126734:	003dff06 	br	81125f34 <__reset+0xfb105f34>
81126738:	d8802104 	addi	r2,sp,132
8112673c:	d8800315 	stw	r2,12(sp)
81126740:	d8802504 	addi	r2,sp,148
81126744:	d8800215 	stw	r2,8(sp)
81126748:	d8802604 	addi	r2,sp,152
8112674c:	d8800115 	stw	r2,4(sp)
81126750:	d8802917 	ldw	r2,164(sp)
81126754:	d9403617 	ldw	r5,216(sp)
81126758:	d9002c17 	ldw	r4,176(sp)
8112675c:	d8800015 	stw	r2,0(sp)
81126760:	01c000c4 	movi	r7,3
81126764:	980d883a 	mov	r6,r19
81126768:	da003d15 	stw	r8,244(sp)
8112676c:	11289800 	call	81128980 <_dtoa_r>
81126770:	d8c02917 	ldw	r3,164(sp)
81126774:	da003d17 	ldw	r8,244(sp)
81126778:	1021883a 	mov	r16,r2
8112677c:	10f9883a 	add	fp,r2,r3
81126780:	81000007 	ldb	r4,0(r16)
81126784:	00800c04 	movi	r2,48
81126788:	20805e26 	beq	r4,r2,81126904 <___vfprintf_internal_r+0x2090>
8112678c:	d8c02617 	ldw	r3,152(sp)
81126790:	e0f9883a 	add	fp,fp,r3
81126794:	003e0a06 	br	81125fc0 <__reset+0xfb105fc0>
81126798:	00c00b44 	movi	r3,45
8112679c:	24e0003c 	xorhi	r19,r4,32768
811267a0:	d8c02a05 	stb	r3,168(sp)
811267a4:	003de906 	br	81125f4c <__reset+0xfb105f4c>
811267a8:	d8c03217 	ldw	r3,200(sp)
811267ac:	00c07a0e 	bge	zero,r3,81126998 <___vfprintf_internal_r+0x2124>
811267b0:	00800044 	movi	r2,1
811267b4:	d9003317 	ldw	r4,204(sp)
811267b8:	1105883a 	add	r2,r2,r4
811267bc:	d8802e15 	stw	r2,184(sp)
811267c0:	10004e16 	blt	r2,zero,811268fc <___vfprintf_internal_r+0x2088>
811267c4:	044019c4 	movi	r17,103
811267c8:	003e2106 	br	81126050 <__reset+0xfb106050>
811267cc:	d9002917 	ldw	r4,164(sp)
811267d0:	d8802104 	addi	r2,sp,132
811267d4:	d8800315 	stw	r2,12(sp)
811267d8:	d9000015 	stw	r4,0(sp)
811267dc:	d8802504 	addi	r2,sp,148
811267e0:	d9403617 	ldw	r5,216(sp)
811267e4:	d9002c17 	ldw	r4,176(sp)
811267e8:	d8800215 	stw	r2,8(sp)
811267ec:	d8802604 	addi	r2,sp,152
811267f0:	d8800115 	stw	r2,4(sp)
811267f4:	01c000c4 	movi	r7,3
811267f8:	980d883a 	mov	r6,r19
811267fc:	da003d15 	stw	r8,244(sp)
81126800:	11289800 	call	81128980 <_dtoa_r>
81126804:	d8c02917 	ldw	r3,164(sp)
81126808:	da003d17 	ldw	r8,244(sp)
8112680c:	1021883a 	mov	r16,r2
81126810:	00801184 	movi	r2,70
81126814:	80f9883a 	add	fp,r16,r3
81126818:	88bfd926 	beq	r17,r2,81126780 <__reset+0xfb106780>
8112681c:	003de806 	br	81125fc0 <__reset+0xfb105fc0>
81126820:	d9002917 	ldw	r4,164(sp)
81126824:	00c04d0e 	bge	zero,r3,8112695c <___vfprintf_internal_r+0x20e8>
81126828:	2000441e 	bne	r4,zero,8112693c <___vfprintf_internal_r+0x20c8>
8112682c:	9480004c 	andi	r18,r18,1
81126830:	9000421e 	bne	r18,zero,8112693c <___vfprintf_internal_r+0x20c8>
81126834:	1805883a 	mov	r2,r3
81126838:	18007016 	blt	r3,zero,811269fc <___vfprintf_internal_r+0x2188>
8112683c:	d8c03217 	ldw	r3,200(sp)
81126840:	d8c02e15 	stw	r3,184(sp)
81126844:	003e0206 	br	81126050 <__reset+0xfb106050>
81126848:	df0022c4 	addi	fp,sp,139
8112684c:	dc002915 	stw	r16,164(sp)
81126850:	4027883a 	mov	r19,r8
81126854:	e021883a 	mov	r16,fp
81126858:	b009883a 	mov	r4,r22
8112685c:	01400284 	movi	r5,10
81126860:	1133d600 	call	81133d60 <__modsi3>
81126864:	10800c04 	addi	r2,r2,48
81126868:	843fffc4 	addi	r16,r16,-1
8112686c:	b009883a 	mov	r4,r22
81126870:	01400284 	movi	r5,10
81126874:	80800005 	stb	r2,0(r16)
81126878:	1133cdc0 	call	81133cdc <__divsi3>
8112687c:	102d883a 	mov	r22,r2
81126880:	00800244 	movi	r2,9
81126884:	15bff416 	blt	r2,r22,81126858 <__reset+0xfb106858>
81126888:	9811883a 	mov	r8,r19
8112688c:	b0800c04 	addi	r2,r22,48
81126890:	8027883a 	mov	r19,r16
81126894:	997fffc4 	addi	r5,r19,-1
81126898:	98bfffc5 	stb	r2,-1(r19)
8112689c:	dc002917 	ldw	r16,164(sp)
811268a0:	2f006a2e 	bgeu	r5,fp,81126a4c <___vfprintf_internal_r+0x21d8>
811268a4:	d9c02384 	addi	r7,sp,142
811268a8:	3ccfc83a 	sub	r7,r7,r19
811268ac:	d9002344 	addi	r4,sp,141
811268b0:	e1cf883a 	add	r7,fp,r7
811268b4:	00000106 	br	811268bc <___vfprintf_internal_r+0x2048>
811268b8:	28800003 	ldbu	r2,0(r5)
811268bc:	20800005 	stb	r2,0(r4)
811268c0:	21000044 	addi	r4,r4,1
811268c4:	29400044 	addi	r5,r5,1
811268c8:	393ffb1e 	bne	r7,r4,811268b8 <__reset+0xfb1068b8>
811268cc:	d8802304 	addi	r2,sp,140
811268d0:	14c5c83a 	sub	r2,r2,r19
811268d4:	d8c02344 	addi	r3,sp,141
811268d8:	1885883a 	add	r2,r3,r2
811268dc:	003f7006 	br	811266a0 <__reset+0xfb1066a0>
811268e0:	0005883a 	mov	r2,zero
811268e4:	003f0f06 	br	81126524 <__reset+0xfb106524>
811268e8:	d8c03217 	ldw	r3,200(sp)
811268ec:	18c00044 	addi	r3,r3,1
811268f0:	d8c02e15 	stw	r3,184(sp)
811268f4:	1805883a 	mov	r2,r3
811268f8:	183fb20e 	bge	r3,zero,811267c4 <__reset+0xfb1067c4>
811268fc:	0005883a 	mov	r2,zero
81126900:	003fb006 	br	811267c4 <__reset+0xfb1067c4>
81126904:	d9003617 	ldw	r4,216(sp)
81126908:	000d883a 	mov	r6,zero
8112690c:	000f883a 	mov	r7,zero
81126910:	980b883a 	mov	r5,r19
81126914:	d8c03c15 	stw	r3,240(sp)
81126918:	da003d15 	stw	r8,244(sp)
8112691c:	11352300 	call	81135230 <__eqdf2>
81126920:	d8c03c17 	ldw	r3,240(sp)
81126924:	da003d17 	ldw	r8,244(sp)
81126928:	103f9826 	beq	r2,zero,8112678c <__reset+0xfb10678c>
8112692c:	00800044 	movi	r2,1
81126930:	10c7c83a 	sub	r3,r2,r3
81126934:	d8c02615 	stw	r3,152(sp)
81126938:	003f9506 	br	81126790 <__reset+0xfb106790>
8112693c:	d9002917 	ldw	r4,164(sp)
81126940:	d8c03217 	ldw	r3,200(sp)
81126944:	20800044 	addi	r2,r4,1
81126948:	1885883a 	add	r2,r3,r2
8112694c:	d8802e15 	stw	r2,184(sp)
81126950:	103dbf0e 	bge	r2,zero,81126050 <__reset+0xfb106050>
81126954:	0005883a 	mov	r2,zero
81126958:	003dbd06 	br	81126050 <__reset+0xfb106050>
8112695c:	2000211e 	bne	r4,zero,811269e4 <___vfprintf_internal_r+0x2170>
81126960:	9480004c 	andi	r18,r18,1
81126964:	90001f1e 	bne	r18,zero,811269e4 <___vfprintf_internal_r+0x2170>
81126968:	00800044 	movi	r2,1
8112696c:	d8802e15 	stw	r2,184(sp)
81126970:	003db706 	br	81126050 <__reset+0xfb106050>
81126974:	00800b44 	movi	r2,45
81126978:	05adc83a 	sub	r22,zero,r22
8112697c:	d8802305 	stb	r2,140(sp)
81126980:	003f3f06 	br	81126680 <__reset+0xfb106680>
81126984:	0005883a 	mov	r2,zero
81126988:	003f5206 	br	811266d4 <__reset+0xfb1066d4>
8112698c:	90a4703a 	and	r18,r18,r2
81126990:	903f4e26 	beq	r18,zero,811266cc <__reset+0xfb1066cc>
81126994:	003f4a06 	br	811266c0 <__reset+0xfb1066c0>
81126998:	00800084 	movi	r2,2
8112699c:	10c5c83a 	sub	r2,r2,r3
811269a0:	003f8406 	br	811267b4 <__reset+0xfb1067b4>
811269a4:	d8802d17 	ldw	r2,180(sp)
811269a8:	d9002d17 	ldw	r4,180(sp)
811269ac:	ac400043 	ldbu	r17,1(r21)
811269b0:	10800017 	ldw	r2,0(r2)
811269b4:	582b883a 	mov	r21,r11
811269b8:	d8802915 	stw	r2,164(sp)
811269bc:	20800104 	addi	r2,r4,4
811269c0:	d9002917 	ldw	r4,164(sp)
811269c4:	d8802d15 	stw	r2,180(sp)
811269c8:	203e7a0e 	bge	r4,zero,811263b4 <__reset+0xfb1063b4>
811269cc:	8c403fcc 	andi	r17,r17,255
811269d0:	00bfffc4 	movi	r2,-1
811269d4:	8c40201c 	xori	r17,r17,128
811269d8:	d8802915 	stw	r2,164(sp)
811269dc:	8c7fe004 	addi	r17,r17,-128
811269e0:	00380706 	br	81124a00 <__reset+0xfb104a00>
811269e4:	d8c02917 	ldw	r3,164(sp)
811269e8:	18c00084 	addi	r3,r3,2
811269ec:	d8c02e15 	stw	r3,184(sp)
811269f0:	1805883a 	mov	r2,r3
811269f4:	183d960e 	bge	r3,zero,81126050 <__reset+0xfb106050>
811269f8:	003fd606 	br	81126954 <__reset+0xfb106954>
811269fc:	0005883a 	mov	r2,zero
81126a00:	003f8e06 	br	8112683c <__reset+0xfb10683c>
81126a04:	9080004c 	andi	r2,r18,1
81126a08:	103f811e 	bne	r2,zero,81126810 <__reset+0xfb106810>
81126a0c:	d8802117 	ldw	r2,132(sp)
81126a10:	1405c83a 	sub	r2,r2,r16
81126a14:	d8803315 	stw	r2,204(sp)
81126a18:	b47ef326 	beq	r22,r17,811265e8 <__reset+0xfb1065e8>
81126a1c:	dd802617 	ldw	r22,152(sp)
81126a20:	003f1106 	br	81126668 <__reset+0xfb106668>
81126a24:	d9c02785 	stb	r7,158(sp)
81126a28:	00390406 	br	81124e3c <__reset+0xfb104e3c>
81126a2c:	d9c02785 	stb	r7,158(sp)
81126a30:	0038d306 	br	81124d80 <__reset+0xfb104d80>
81126a34:	d9c02785 	stb	r7,158(sp)
81126a38:	003a6106 	br	811253c0 <__reset+0xfb1053c0>
81126a3c:	d9c02785 	stb	r7,158(sp)
81126a40:	003af806 	br	81125624 <__reset+0xfb105624>
81126a44:	0005883a 	mov	r2,zero
81126a48:	003d7e06 	br	81126044 <__reset+0xfb106044>
81126a4c:	d8802344 	addi	r2,sp,141
81126a50:	003f1306 	br	811266a0 <__reset+0xfb1066a0>
81126a54:	d9c02785 	stb	r7,158(sp)
81126a58:	00392306 	br	81124ee8 <__reset+0xfb104ee8>
81126a5c:	d9c02785 	stb	r7,158(sp)
81126a60:	003aa906 	br	81125508 <__reset+0xfb105508>
81126a64:	d9c02785 	stb	r7,158(sp)
81126a68:	003a3d06 	br	81125360 <__reset+0xfb105360>
81126a6c:	d9c02785 	stb	r7,158(sp)
81126a70:	003aca06 	br	8112559c <__reset+0xfb10559c>

81126a74 <__vfprintf_internal>:
81126a74:	00a04574 	movhi	r2,33045
81126a78:	10886904 	addi	r2,r2,8612
81126a7c:	300f883a 	mov	r7,r6
81126a80:	280d883a 	mov	r6,r5
81126a84:	200b883a 	mov	r5,r4
81126a88:	11000017 	ldw	r4,0(r2)
81126a8c:	11248741 	jmpi	81124874 <___vfprintf_internal_r>

81126a90 <__sbprintf>:
81126a90:	defee204 	addi	sp,sp,-1144
81126a94:	de00012e 	bgeu	sp,et,81126a9c <__sbprintf+0xc>
81126a98:	003b68fa 	trap	3
81126a9c:	2880030b 	ldhu	r2,12(r5)
81126aa0:	2ac01917 	ldw	r11,100(r5)
81126aa4:	2a80038b 	ldhu	r10,14(r5)
81126aa8:	2a400717 	ldw	r9,28(r5)
81126aac:	2a000917 	ldw	r8,36(r5)
81126ab0:	00c10004 	movi	r3,1024
81126ab4:	dc011a15 	stw	r16,1128(sp)
81126ab8:	10bfff4c 	andi	r2,r2,65533
81126abc:	2821883a 	mov	r16,r5
81126ac0:	d8cb883a 	add	r5,sp,r3
81126ac4:	dc811c15 	stw	r18,1136(sp)
81126ac8:	dc411b15 	stw	r17,1132(sp)
81126acc:	dfc11d15 	stw	ra,1140(sp)
81126ad0:	2025883a 	mov	r18,r4
81126ad4:	d881030d 	sth	r2,1036(sp)
81126ad8:	dac11915 	stw	r11,1124(sp)
81126adc:	da81038d 	sth	r10,1038(sp)
81126ae0:	da410715 	stw	r9,1052(sp)
81126ae4:	da010915 	stw	r8,1060(sp)
81126ae8:	dec10015 	stw	sp,1024(sp)
81126aec:	dec10415 	stw	sp,1040(sp)
81126af0:	d8c10215 	stw	r3,1032(sp)
81126af4:	d8c10515 	stw	r3,1044(sp)
81126af8:	d8010615 	stw	zero,1048(sp)
81126afc:	11248740 	call	81124874 <___vfprintf_internal_r>
81126b00:	1023883a 	mov	r17,r2
81126b04:	10000416 	blt	r2,zero,81126b18 <__sbprintf+0x88>
81126b08:	d9410004 	addi	r5,sp,1024
81126b0c:	9009883a 	mov	r4,r18
81126b10:	112a2340 	call	8112a234 <_fflush_r>
81126b14:	10000d1e 	bne	r2,zero,81126b4c <__sbprintf+0xbc>
81126b18:	d881030b 	ldhu	r2,1036(sp)
81126b1c:	1080100c 	andi	r2,r2,64
81126b20:	10000326 	beq	r2,zero,81126b30 <__sbprintf+0xa0>
81126b24:	8080030b 	ldhu	r2,12(r16)
81126b28:	10801014 	ori	r2,r2,64
81126b2c:	8080030d 	sth	r2,12(r16)
81126b30:	8805883a 	mov	r2,r17
81126b34:	dfc11d17 	ldw	ra,1140(sp)
81126b38:	dc811c17 	ldw	r18,1136(sp)
81126b3c:	dc411b17 	ldw	r17,1132(sp)
81126b40:	dc011a17 	ldw	r16,1128(sp)
81126b44:	dec11e04 	addi	sp,sp,1144
81126b48:	f800283a 	ret
81126b4c:	047fffc4 	movi	r17,-1
81126b50:	003ff106 	br	81126b18 <__reset+0xfb106b18>

81126b54 <__svfscanf_r>:
81126b54:	deff4b04 	addi	sp,sp,-724
81126b58:	de00012e 	bgeu	sp,et,81126b60 <__svfscanf_r+0xc>
81126b5c:	003b68fa 	trap	3
81126b60:	2880030b 	ldhu	r2,12(r5)
81126b64:	df00b315 	stw	fp,716(sp)
81126b68:	dd80b115 	stw	r22,708(sp)
81126b6c:	dfc0b415 	stw	ra,720(sp)
81126b70:	ddc0b215 	stw	r23,712(sp)
81126b74:	dd40b015 	stw	r21,704(sp)
81126b78:	dd00af15 	stw	r20,700(sp)
81126b7c:	dcc0ae15 	stw	r19,696(sp)
81126b80:	dc80ad15 	stw	r18,692(sp)
81126b84:	dc40ac15 	stw	r17,688(sp)
81126b88:	dc00ab15 	stw	r16,684(sp)
81126b8c:	10c8000c 	andi	r3,r2,8192
81126b90:	d9c09c15 	stw	r7,624(sp)
81126b94:	2839883a 	mov	fp,r5
81126b98:	202d883a 	mov	r22,r4
81126b9c:	1800061e 	bne	r3,zero,81126bb8 <__svfscanf_r+0x64>
81126ba0:	29001917 	ldw	r4,100(r5)
81126ba4:	00f7ffc4 	movi	r3,-8193
81126ba8:	10880014 	ori	r2,r2,8192
81126bac:	20c6703a 	and	r3,r4,r3
81126bb0:	2880030d 	sth	r2,12(r5)
81126bb4:	28c01915 	stw	r3,100(r5)
81126bb8:	30800003 	ldbu	r2,0(r6)
81126bbc:	0021883a 	mov	r16,zero
81126bc0:	05e04574 	movhi	r23,33045
81126bc4:	d800a115 	stw	zero,644(sp)
81126bc8:	d8009e15 	stw	zero,632(sp)
81126bcc:	d800a015 	stw	zero,640(sp)
81126bd0:	d8809b15 	stw	r2,620(sp)
81126bd4:	bdc86704 	addi	r23,r23,8604
81126bd8:	8025883a 	mov	r18,r16
81126bdc:	35000044 	addi	r20,r6,1
81126be0:	10001e26 	beq	r2,zero,81126c5c <__svfscanf_r+0x108>
81126be4:	b9c00017 	ldw	r7,0(r23)
81126be8:	3887883a 	add	r3,r7,r2
81126bec:	18c00043 	ldbu	r3,1(r3)
81126bf0:	18c0020c 	andi	r3,r3,8
81126bf4:	18001b26 	beq	r3,zero,81126c64 <__svfscanf_r+0x110>
81126bf8:	e0800117 	ldw	r2,4(fp)
81126bfc:	00800e0e 	bge	zero,r2,81126c38 <__svfscanf_r+0xe4>
81126c00:	e0c00017 	ldw	r3,0(fp)
81126c04:	b9000017 	ldw	r4,0(r23)
81126c08:	18800003 	ldbu	r2,0(r3)
81126c0c:	2085883a 	add	r2,r4,r2
81126c10:	10800043 	ldbu	r2,1(r2)
81126c14:	1080020c 	andi	r2,r2,8
81126c18:	10000b26 	beq	r2,zero,81126c48 <__svfscanf_r+0xf4>
81126c1c:	e0800117 	ldw	r2,4(fp)
81126c20:	18c00044 	addi	r3,r3,1
81126c24:	e0c00015 	stw	r3,0(fp)
81126c28:	10bfffc4 	addi	r2,r2,-1
81126c2c:	e0800115 	stw	r2,4(fp)
81126c30:	94800044 	addi	r18,r18,1
81126c34:	00bff216 	blt	zero,r2,81126c00 <__reset+0xfb106c00>
81126c38:	e00b883a 	mov	r5,fp
81126c3c:	b009883a 	mov	r4,r22
81126c40:	1121e340 	call	81121e34 <__srefill_r>
81126c44:	103fee26 	beq	r2,zero,81126c00 <__reset+0xfb106c00>
81126c48:	a00d883a 	mov	r6,r20
81126c4c:	30800003 	ldbu	r2,0(r6)
81126c50:	35000044 	addi	r20,r6,1
81126c54:	d8809b15 	stw	r2,620(sp)
81126c58:	103fe21e 	bne	r2,zero,81126be4 <__reset+0xfb106be4>
81126c5c:	d880a017 	ldw	r2,640(sp)
81126c60:	00009906 	br	81126ec8 <__svfscanf_r+0x374>
81126c64:	00c00944 	movi	r3,37
81126c68:	10c0881e 	bne	r2,r3,81126e8c <__svfscanf_r+0x338>
81126c6c:	30c00043 	ldbu	r3,1(r6)
81126c70:	0023883a 	mov	r17,zero
81126c74:	0027883a 	mov	r19,zero
81126c78:	01001e04 	movi	r4,120
81126c7c:	01401b04 	movi	r5,108
81126c80:	a1800044 	addi	r6,r20,1
81126c84:	20c0a236 	bltu	r4,r3,81126f10 <__svfscanf_r+0x3bc>
81126c88:	180490ba 	slli	r2,r3,2
81126c8c:	022044b4 	movhi	r8,33042
81126c90:	421b2804 	addi	r8,r8,27808
81126c94:	1205883a 	add	r2,r2,r8
81126c98:	10800017 	ldw	r2,0(r2)
81126c9c:	1000683a 	jmp	r2
81126ca0:	81126ec4 	addi	r4,r16,18875
81126ca4:	81126f10 	cmplti	r4,r16,18876
81126ca8:	81126f10 	cmplti	r4,r16,18876
81126cac:	81126f10 	cmplti	r4,r16,18876
81126cb0:	81126f10 	cmplti	r4,r16,18876
81126cb4:	81126f10 	cmplti	r4,r16,18876
81126cb8:	81126f10 	cmplti	r4,r16,18876
81126cbc:	81126f10 	cmplti	r4,r16,18876
81126cc0:	81126f10 	cmplti	r4,r16,18876
81126cc4:	81126f10 	cmplti	r4,r16,18876
81126cc8:	81126f10 	cmplti	r4,r16,18876
81126ccc:	81126f10 	cmplti	r4,r16,18876
81126cd0:	81126f10 	cmplti	r4,r16,18876
81126cd4:	81126f10 	cmplti	r4,r16,18876
81126cd8:	81126f10 	cmplti	r4,r16,18876
81126cdc:	81126f10 	cmplti	r4,r16,18876
81126ce0:	81126f10 	cmplti	r4,r16,18876
81126ce4:	81126f10 	cmplti	r4,r16,18876
81126ce8:	81126f10 	cmplti	r4,r16,18876
81126cec:	81126f10 	cmplti	r4,r16,18876
81126cf0:	81126f10 	cmplti	r4,r16,18876
81126cf4:	81126f10 	cmplti	r4,r16,18876
81126cf8:	81126f10 	cmplti	r4,r16,18876
81126cfc:	81126f10 	cmplti	r4,r16,18876
81126d00:	81126f10 	cmplti	r4,r16,18876
81126d04:	81126f10 	cmplti	r4,r16,18876
81126d08:	81126f10 	cmplti	r4,r16,18876
81126d0c:	81126f10 	cmplti	r4,r16,18876
81126d10:	81126f10 	cmplti	r4,r16,18876
81126d14:	81126f10 	cmplti	r4,r16,18876
81126d18:	81126f10 	cmplti	r4,r16,18876
81126d1c:	81126f10 	cmplti	r4,r16,18876
81126d20:	81126f10 	cmplti	r4,r16,18876
81126d24:	81126f10 	cmplti	r4,r16,18876
81126d28:	81126f10 	cmplti	r4,r16,18876
81126d2c:	81126f10 	cmplti	r4,r16,18876
81126d30:	81126f10 	cmplti	r4,r16,18876
81126d34:	81126e84 	addi	r4,r16,18874
81126d38:	81126f10 	cmplti	r4,r16,18876
81126d3c:	81126f10 	cmplti	r4,r16,18876
81126d40:	81126f10 	cmplti	r4,r16,18876
81126d44:	81126f10 	cmplti	r4,r16,18876
81126d48:	81126ef8 	rdprs	r4,r16,18875
81126d4c:	81126f10 	cmplti	r4,r16,18876
81126d50:	81126f10 	cmplti	r4,r16,18876
81126d54:	81126f10 	cmplti	r4,r16,18876
81126d58:	81126f10 	cmplti	r4,r16,18876
81126d5c:	81126f10 	cmplti	r4,r16,18876
81126d60:	8112702c 	andhi	r4,r16,18880
81126d64:	8112702c 	andhi	r4,r16,18880
81126d68:	8112702c 	andhi	r4,r16,18880
81126d6c:	8112702c 	andhi	r4,r16,18880
81126d70:	8112702c 	andhi	r4,r16,18880
81126d74:	8112702c 	andhi	r4,r16,18880
81126d78:	8112702c 	andhi	r4,r16,18880
81126d7c:	8112702c 	andhi	r4,r16,18880
81126d80:	8112702c 	andhi	r4,r16,18880
81126d84:	8112702c 	andhi	r4,r16,18880
81126d88:	81126f10 	cmplti	r4,r16,18876
81126d8c:	81126f10 	cmplti	r4,r16,18876
81126d90:	81126f10 	cmplti	r4,r16,18876
81126d94:	81126f10 	cmplti	r4,r16,18876
81126d98:	81126f10 	cmplti	r4,r16,18876
81126d9c:	81126f10 	cmplti	r4,r16,18876
81126da0:	81126f10 	cmplti	r4,r16,18876
81126da4:	81126f10 	cmplti	r4,r16,18876
81126da8:	81126f10 	cmplti	r4,r16,18876
81126dac:	81126f10 	cmplti	r4,r16,18876
81126db0:	81127000 	call	88112700 <__reset+0x20f2700>
81126db4:	811270b0 	cmpltui	r4,r16,18882
81126db8:	81126f10 	cmplti	r4,r16,18876
81126dbc:	811270b0 	cmpltui	r4,r16,18882
81126dc0:	81126f10 	cmplti	r4,r16,18876
81126dc4:	81126f10 	cmplti	r4,r16,18876
81126dc8:	81126f10 	cmplti	r4,r16,18876
81126dcc:	81126f10 	cmplti	r4,r16,18876
81126dd0:	8112709c 	xori	r4,r16,18882
81126dd4:	81126f10 	cmplti	r4,r16,18876
81126dd8:	81126f10 	cmplti	r4,r16,18876
81126ddc:	81127070 	cmpltui	r4,r16,18881
81126de0:	81126f10 	cmplti	r4,r16,18876
81126de4:	81126f10 	cmplti	r4,r16,18876
81126de8:	81126f10 	cmplti	r4,r16,18876
81126dec:	81126f10 	cmplti	r4,r16,18876
81126df0:	81126f10 	cmplti	r4,r16,18876
81126df4:	81126f10 	cmplti	r4,r16,18876
81126df8:	81126f10 	cmplti	r4,r16,18876
81126dfc:	81126f10 	cmplti	r4,r16,18876
81126e00:	81127048 	cmpgei	r4,r16,18881
81126e04:	81126f10 	cmplti	r4,r16,18876
81126e08:	81126f10 	cmplti	r4,r16,18876
81126e0c:	811271e4 	muli	r4,r16,18887
81126e10:	81126f10 	cmplti	r4,r16,18876
81126e14:	81126f10 	cmplti	r4,r16,18876
81126e18:	81126f10 	cmplti	r4,r16,18876
81126e1c:	81126f10 	cmplti	r4,r16,18876
81126e20:	81126f10 	cmplti	r4,r16,18876
81126e24:	81126f10 	cmplti	r4,r16,18876
81126e28:	81126f10 	cmplti	r4,r16,18876
81126e2c:	81127168 	cmpgeui	r4,r16,18885
81126e30:	81127140 	call	88112714 <__reset+0x20f2714>
81126e34:	811270b0 	cmpltui	r4,r16,18882
81126e38:	811270b0 	cmpltui	r4,r16,18882
81126e3c:	811270b0 	cmpltui	r4,r16,18882
81126e40:	8112712c 	andhi	r4,r16,18884
81126e44:	81127270 	cmpltui	r4,r16,18889
81126e48:	81126f10 	cmplti	r4,r16,18876
81126e4c:	81126f10 	cmplti	r4,r16,18876
81126e50:	81127118 	cmpnei	r4,r16,18884
81126e54:	81126f10 	cmplti	r4,r16,18876
81126e58:	811270e8 	cmpgeui	r4,r16,18883
81126e5c:	811270c4 	addi	r4,r16,18883
81126e60:	81126fd4 	ori	r4,r16,18879
81126e64:	81126f10 	cmplti	r4,r16,18876
81126e68:	81126f10 	cmplti	r4,r16,18876
81126e6c:	81126fc0 	call	881126fc <__reset+0x20f26fc>
81126e70:	81126f10 	cmplti	r4,r16,18876
81126e74:	81126f48 	cmpgei	r4,r16,18877
81126e78:	81126f10 	cmplti	r4,r16,18876
81126e7c:	81126f10 	cmplti	r4,r16,18876
81126e80:	81127048 	cmpgei	r4,r16,18881
81126e84:	d9809d15 	stw	r6,628(sp)
81126e88:	3029883a 	mov	r20,r6
81126e8c:	e0800117 	ldw	r2,4(fp)
81126e90:	0081aa0e 	bge	zero,r2,8112753c <__svfscanf_r+0x9e8>
81126e94:	e0800017 	ldw	r2,0(fp)
81126e98:	a0ffffc3 	ldbu	r3,-1(r20)
81126e9c:	11000003 	ldbu	r4,0(r2)
81126ea0:	20ff6e1e 	bne	r4,r3,81126c5c <__reset+0xfb106c5c>
81126ea4:	e0c00117 	ldw	r3,4(fp)
81126ea8:	10800044 	addi	r2,r2,1
81126eac:	e0800015 	stw	r2,0(fp)
81126eb0:	18bfffc4 	addi	r2,r3,-1
81126eb4:	e0800115 	stw	r2,4(fp)
81126eb8:	94800044 	addi	r18,r18,1
81126ebc:	a00d883a 	mov	r6,r20
81126ec0:	003f6206 	br	81126c4c <__reset+0xfb106c4c>
81126ec4:	00bfffc4 	movi	r2,-1
81126ec8:	dfc0b417 	ldw	ra,720(sp)
81126ecc:	df00b317 	ldw	fp,716(sp)
81126ed0:	ddc0b217 	ldw	r23,712(sp)
81126ed4:	dd80b117 	ldw	r22,708(sp)
81126ed8:	dd40b017 	ldw	r21,704(sp)
81126edc:	dd00af17 	ldw	r20,700(sp)
81126ee0:	dcc0ae17 	ldw	r19,696(sp)
81126ee4:	dc80ad17 	ldw	r18,692(sp)
81126ee8:	dc40ac17 	ldw	r17,688(sp)
81126eec:	dc00ab17 	ldw	r16,684(sp)
81126ef0:	dec0b504 	addi	sp,sp,724
81126ef4:	f800283a 	ret
81126ef8:	a0800043 	ldbu	r2,1(r20)
81126efc:	3029883a 	mov	r20,r6
81126f00:	8c400414 	ori	r17,r17,16
81126f04:	10c03fcc 	andi	r3,r2,255
81126f08:	a1800044 	addi	r6,r20,1
81126f0c:	20ff5e2e 	bgeu	r4,r3,81126c88 <__reset+0xfb106c88>
81126f10:	38c7883a 	add	r3,r7,r3
81126f14:	18800043 	ldbu	r2,1(r3)
81126f18:	d9809d15 	stw	r6,628(sp)
81126f1c:	00c00044 	movi	r3,1
81126f20:	108000cc 	andi	r2,r2,3
81126f24:	10c18f26 	beq	r2,r3,81127564 <__svfscanf_r+0xa10>
81126f28:	e0800117 	ldw	r2,4(fp)
81126f2c:	00808716 	blt	zero,r2,8112714c <__svfscanf_r+0x5f8>
81126f30:	e00b883a 	mov	r5,fp
81126f34:	b009883a 	mov	r4,r22
81126f38:	1121e340 	call	81121e34 <__srefill_r>
81126f3c:	1001431e 	bne	r2,zero,8112744c <__svfscanf_r+0x8f8>
81126f40:	b9c00017 	ldw	r7,0(r23)
81126f44:	00008106 	br	8112714c <__svfscanf_r+0x5f8>
81126f48:	e0800117 	ldw	r2,4(fp)
81126f4c:	d9809d15 	stw	r6,628(sp)
81126f50:	0081a30e 	bge	zero,r2,811275e0 <__svfscanf_r+0xa8c>
81126f54:	00a044f4 	movhi	r2,33043
81126f58:	10bb5904 	addi	r2,r2,-4764
81126f5c:	02000284 	movi	r8,10
81126f60:	d880a115 	stw	r2,644(sp)
81126f64:	da009e15 	stw	r8,632(sp)
81126f68:	050000c4 	movi	r20,3
81126f6c:	e0c00017 	ldw	r3,0(fp)
81126f70:	00000206 	br	81126f7c <__svfscanf_r+0x428>
81126f74:	18c00044 	addi	r3,r3,1
81126f78:	e0c00015 	stw	r3,0(fp)
81126f7c:	19000003 	ldbu	r4,0(r3)
81126f80:	20803fcc 	andi	r2,r4,255
81126f84:	3885883a 	add	r2,r7,r2
81126f88:	10800043 	ldbu	r2,1(r2)
81126f8c:	1140020c 	andi	r5,r2,8
81126f90:	2801ab26 	beq	r5,zero,81127640 <__svfscanf_r+0xaec>
81126f94:	e0800117 	ldw	r2,4(fp)
81126f98:	94800044 	addi	r18,r18,1
81126f9c:	10bfffc4 	addi	r2,r2,-1
81126fa0:	e0800115 	stw	r2,4(fp)
81126fa4:	00bff316 	blt	zero,r2,81126f74 <__reset+0xfb106f74>
81126fa8:	e00b883a 	mov	r5,fp
81126fac:	b009883a 	mov	r4,r22
81126fb0:	1121e340 	call	81121e34 <__srefill_r>
81126fb4:	1001251e 	bne	r2,zero,8112744c <__svfscanf_r+0x8f8>
81126fb8:	b9c00017 	ldw	r7,0(r23)
81126fbc:	003feb06 	br	81126f6c <__reset+0xfb106f6c>
81126fc0:	e0800117 	ldw	r2,4(fp)
81126fc4:	d9809d15 	stw	r6,628(sp)
81126fc8:	00818b0e 	bge	zero,r2,811275f8 <__svfscanf_r+0xaa4>
81126fcc:	05000084 	movi	r20,2
81126fd0:	003fe606 	br	81126f6c <__reset+0xfb106f6c>
81126fd4:	e0800117 	ldw	r2,4(fp)
81126fd8:	d9809d15 	stw	r6,628(sp)
81126fdc:	8c408814 	ori	r17,r17,544
81126fe0:	00801d0e 	bge	zero,r2,81127058 <__svfscanf_r+0x504>
81126fe4:	00a044f4 	movhi	r2,33043
81126fe8:	10bb5904 	addi	r2,r2,-4764
81126fec:	02000404 	movi	r8,16
81126ff0:	d880a115 	stw	r2,644(sp)
81126ff4:	da009e15 	stw	r8,632(sp)
81126ff8:	050000c4 	movi	r20,3
81126ffc:	003fdb06 	br	81126f6c <__reset+0xfb106f6c>
81127000:	e0800117 	ldw	r2,4(fp)
81127004:	d9809d15 	stw	r6,628(sp)
81127008:	8c400054 	ori	r17,r17,1
8112700c:	00bfc80e 	bge	zero,r2,81126f30 <__reset+0xfb106f30>
81127010:	00e044b4 	movhi	r3,33042
81127014:	18c90e04 	addi	r3,r3,9272
81127018:	02000284 	movi	r8,10
8112701c:	d8c0a115 	stw	r3,644(sp)
81127020:	da009e15 	stw	r8,632(sp)
81127024:	050000c4 	movi	r20,3
81127028:	003fd006 	br	81126f6c <__reset+0xfb106f6c>
8112702c:	9cc002a4 	muli	r19,r19,10
81127030:	a0800043 	ldbu	r2,1(r20)
81127034:	3029883a 	mov	r20,r6
81127038:	98e7883a 	add	r19,r19,r3
8112703c:	9cfff404 	addi	r19,r19,-48
81127040:	10c03fcc 	andi	r3,r2,255
81127044:	003f0e06 	br	81126c80 <__reset+0xfb106c80>
81127048:	e0800117 	ldw	r2,4(fp)
8112704c:	d9809d15 	stw	r6,628(sp)
81127050:	8c408014 	ori	r17,r17,512
81127054:	00bfe316 	blt	zero,r2,81126fe4 <__reset+0xfb106fe4>
81127058:	e00b883a 	mov	r5,fp
8112705c:	b009883a 	mov	r4,r22
81127060:	1121e340 	call	81121e34 <__srefill_r>
81127064:	1000f91e 	bne	r2,zero,8112744c <__svfscanf_r+0x8f8>
81127068:	b9c00017 	ldw	r7,0(r23)
8112706c:	003fdd06 	br	81126fe4 <__reset+0xfb106fe4>
81127070:	e0800117 	ldw	r2,4(fp)
81127074:	d9809d15 	stw	r6,628(sp)
81127078:	8c400054 	ori	r17,r17,1
8112707c:	0080140e 	bge	zero,r2,811270d0 <__svfscanf_r+0x57c>
81127080:	00a044f4 	movhi	r2,33043
81127084:	10bb5904 	addi	r2,r2,-4764
81127088:	02000204 	movi	r8,8
8112708c:	d880a115 	stw	r2,644(sp)
81127090:	da009e15 	stw	r8,632(sp)
81127094:	050000c4 	movi	r20,3
81127098:	003fb406 	br	81126f6c <__reset+0xfb106f6c>
8112709c:	a0800043 	ldbu	r2,1(r20)
811270a0:	8c400094 	ori	r17,r17,2
811270a4:	3029883a 	mov	r20,r6
811270a8:	10c03fcc 	andi	r3,r2,255
811270ac:	003ef406 	br	81126c80 <__reset+0xfb106c80>
811270b0:	e0800117 	ldw	r2,4(fp)
811270b4:	d9809d15 	stw	r6,628(sp)
811270b8:	0081420e 	bge	zero,r2,811275c4 <__svfscanf_r+0xa70>
811270bc:	05000104 	movi	r20,4
811270c0:	003faa06 	br	81126f6c <__reset+0xfb106f6c>
811270c4:	e0800117 	ldw	r2,4(fp)
811270c8:	d9809d15 	stw	r6,628(sp)
811270cc:	00bfec16 	blt	zero,r2,81127080 <__reset+0xfb107080>
811270d0:	e00b883a 	mov	r5,fp
811270d4:	b009883a 	mov	r4,r22
811270d8:	1121e340 	call	81121e34 <__srefill_r>
811270dc:	1000db1e 	bne	r2,zero,8112744c <__svfscanf_r+0x8f8>
811270e0:	b9c00017 	ldw	r7,0(r23)
811270e4:	003fe606 	br	81127080 <__reset+0xfb107080>
811270e8:	d9809d15 	stw	r6,628(sp)
811270ec:	8880040c 	andi	r2,r17,16
811270f0:	10009c1e 	bne	r2,zero,81127364 <__svfscanf_r+0x810>
811270f4:	8880010c 	andi	r2,r17,4
811270f8:	10011e26 	beq	r2,zero,81127574 <__svfscanf_r+0xa20>
811270fc:	da009c17 	ldw	r8,624(sp)
81127100:	3029883a 	mov	r20,r6
81127104:	40800017 	ldw	r2,0(r8)
81127108:	42000104 	addi	r8,r8,4
8112710c:	da009c15 	stw	r8,624(sp)
81127110:	1480000d 	sth	r18,0(r2)
81127114:	003ecc06 	br	81126c48 <__reset+0xfb106c48>
81127118:	a0c00043 	ldbu	r3,1(r20)
8112711c:	19410c26 	beq	r3,r5,81127550 <__svfscanf_r+0x9fc>
81127120:	8c400054 	ori	r17,r17,1
81127124:	3029883a 	mov	r20,r6
81127128:	003ed506 	br	81126c80 <__reset+0xfb106c80>
8112712c:	a0800043 	ldbu	r2,1(r20)
81127130:	8c400114 	ori	r17,r17,4
81127134:	3029883a 	mov	r20,r6
81127138:	10c03fcc 	andi	r3,r2,255
8112713c:	003ed006 	br	81126c80 <__reset+0xfb106c80>
81127140:	e0800117 	ldw	r2,4(fp)
81127144:	d9809d15 	stw	r6,628(sp)
81127148:	00bf790e 	bge	zero,r2,81126f30 <__reset+0xfb106f30>
8112714c:	00a044b4 	movhi	r2,33042
81127150:	10890e04 	addi	r2,r2,9272
81127154:	02000284 	movi	r8,10
81127158:	d880a115 	stw	r2,644(sp)
8112715c:	da009e15 	stw	r8,632(sp)
81127160:	050000c4 	movi	r20,3
81127164:	003f8106 	br	81126f6c <__reset+0xfb106f6c>
81127168:	e0800117 	ldw	r2,4(fp)
8112716c:	d9809d15 	stw	r6,628(sp)
81127170:	0080c40e 	bge	zero,r2,81127484 <__svfscanf_r+0x930>
81127174:	9800011e 	bne	r19,zero,8112717c <__svfscanf_r+0x628>
81127178:	04c00044 	movi	r19,1
8112717c:	8880004c 	andi	r2,r17,1
81127180:	1000441e 	bne	r2,zero,81127294 <__svfscanf_r+0x740>
81127184:	8c40040c 	andi	r17,r17,16
81127188:	8800da26 	beq	r17,zero,811274f4 <__svfscanf_r+0x9a0>
8112718c:	0021883a 	mov	r16,zero
81127190:	00000806 	br	811271b4 <__svfscanf_r+0x660>
81127194:	1887883a 	add	r3,r3,r2
81127198:	e00b883a 	mov	r5,fp
8112719c:	b009883a 	mov	r4,r22
811271a0:	e0c00015 	stw	r3,0(fp)
811271a4:	80a1883a 	add	r16,r16,r2
811271a8:	98a7c83a 	sub	r19,r19,r2
811271ac:	1121e340 	call	81121e34 <__srefill_r>
811271b0:	1000ca1e 	bne	r2,zero,811274dc <__svfscanf_r+0x988>
811271b4:	e0800117 	ldw	r2,4(fp)
811271b8:	e0c00017 	ldw	r3,0(fp)
811271bc:	14fff516 	blt	r2,r19,81127194 <__reset+0xfb107194>
811271c0:	14c5c83a 	sub	r2,r2,r19
811271c4:	1cd5883a 	add	r10,r3,r19
811271c8:	84e1883a 	add	r16,r16,r19
811271cc:	e0800115 	stw	r2,4(fp)
811271d0:	e2800015 	stw	r10,0(fp)
811271d4:	dd009d17 	ldw	r20,628(sp)
811271d8:	9425883a 	add	r18,r18,r16
811271dc:	a00d883a 	mov	r6,r20
811271e0:	003e9a06 	br	81126c4c <__reset+0xfb106c4c>
811271e4:	300b883a 	mov	r5,r6
811271e8:	d9005884 	addi	r4,sp,354
811271ec:	d9809d15 	stw	r6,628(sp)
811271f0:	112d13c0 	call	8112d13c <__sccl>
811271f4:	1029883a 	mov	r20,r2
811271f8:	e0800117 	ldw	r2,4(fp)
811271fc:	0081050e 	bge	zero,r2,81127614 <__svfscanf_r+0xac0>
81127200:	e1000017 	ldw	r4,0(fp)
81127204:	20800003 	ldbu	r2,0(r4)
81127208:	98005926 	beq	r19,zero,81127370 <__svfscanf_r+0x81c>
8112720c:	8c40040c 	andi	r17,r17,16
81127210:	88005a26 	beq	r17,zero,8112737c <__svfscanf_r+0x828>
81127214:	9823883a 	mov	r17,r19
81127218:	0021883a 	mov	r16,zero
8112721c:	00000106 	br	81127224 <__svfscanf_r+0x6d0>
81127220:	20800003 	ldbu	r2,0(r4)
81127224:	10803fcc 	andi	r2,r2,255
81127228:	d8c05884 	addi	r3,sp,354
8112722c:	1885883a 	add	r2,r3,r2
81127230:	10800007 	ldb	r2,0(r2)
81127234:	1000ad26 	beq	r2,zero,811274ec <__svfscanf_r+0x998>
81127238:	e0800117 	ldw	r2,4(fp)
8112723c:	21000044 	addi	r4,r4,1
81127240:	84000044 	addi	r16,r16,1
81127244:	10bfffc4 	addi	r2,r2,-1
81127248:	e0800115 	stw	r2,4(fp)
8112724c:	e1000015 	stw	r4,0(fp)
81127250:	84c0a026 	beq	r16,r19,811274d4 <__svfscanf_r+0x980>
81127254:	00bff216 	blt	zero,r2,81127220 <__reset+0xfb107220>
81127258:	e00b883a 	mov	r5,fp
8112725c:	b009883a 	mov	r4,r22
81127260:	1121e340 	call	81121e34 <__srefill_r>
81127264:	10009a1e 	bne	r2,zero,811274d0 <__svfscanf_r+0x97c>
81127268:	e1000017 	ldw	r4,0(fp)
8112726c:	003fec06 	br	81127220 <__reset+0xfb107220>
81127270:	e0800117 	ldw	r2,4(fp)
81127274:	d9809d15 	stw	r6,628(sp)
81127278:	0080eb0e 	bge	zero,r2,81127628 <__svfscanf_r+0xad4>
8112727c:	00a044b4 	movhi	r2,33042
81127280:	10890e04 	addi	r2,r2,9272
81127284:	d880a115 	stw	r2,644(sp)
81127288:	d8009e15 	stw	zero,632(sp)
8112728c:	050000c4 	movi	r20,3
81127290:	003f3606 	br	81126f6c <__reset+0xfb106f6c>
81127294:	dd409904 	addi	r21,sp,612
81127298:	8c40040c 	andi	r17,r17,16
8112729c:	01800204 	movi	r6,8
811272a0:	000b883a 	mov	r5,zero
811272a4:	a809883a 	mov	r4,r21
811272a8:	dc409f15 	stw	r17,636(sp)
811272ac:	11219b80 	call	811219b8 <memset>
811272b0:	dc409f17 	ldw	r17,636(sp)
811272b4:	88006e26 	beq	r17,zero,81127470 <__svfscanf_r+0x91c>
811272b8:	0029883a 	mov	r20,zero
811272bc:	0023883a 	mov	r17,zero
811272c0:	112b5580 	call	8112b558 <__locale_mb_cur_max>
811272c4:	14406126 	beq	r2,r17,8112744c <__svfscanf_r+0x8f8>
811272c8:	e0800017 	ldw	r2,0(fp)
811272cc:	e0c00117 	ldw	r3,4(fp)
811272d0:	d9000104 	addi	r4,sp,4
811272d4:	12000003 	ldbu	r8,0(r2)
811272d8:	18ffffc4 	addi	r3,r3,-1
811272dc:	10800044 	addi	r2,r2,1
811272e0:	e0c00115 	stw	r3,4(fp)
811272e4:	e0800015 	stw	r2,0(fp)
811272e8:	8c000044 	addi	r16,r17,1
811272ec:	dd400015 	stw	r21,0(sp)
811272f0:	2463883a 	add	r17,r4,r17
811272f4:	200d883a 	mov	r6,r4
811272f8:	a00b883a 	mov	r5,r20
811272fc:	800f883a 	mov	r7,r16
81127300:	b009883a 	mov	r4,r22
81127304:	8a000005 	stb	r8,0(r17)
81127308:	112b6140 	call	8112b614 <_mbrtowc_r>
8112730c:	017fffc4 	movi	r5,-1
81127310:	11404e26 	beq	r2,r5,8112744c <__svfscanf_r+0x8f8>
81127314:	1000601e 	bne	r2,zero,81127498 <__svfscanf_r+0x944>
81127318:	da009f17 	ldw	r8,636(sp)
8112731c:	4000641e 	bne	r8,zero,811274b0 <__svfscanf_r+0x95c>
81127320:	a0000015 	stw	zero,0(r20)
81127324:	9425883a 	add	r18,r18,r16
81127328:	9967883a 	add	r19,r19,r5
8112732c:	a5000104 	addi	r20,r20,4
81127330:	e0800117 	ldw	r2,4(fp)
81127334:	0023883a 	mov	r17,zero
81127338:	00804b16 	blt	zero,r2,81127468 <__svfscanf_r+0x914>
8112733c:	e00b883a 	mov	r5,fp
81127340:	b009883a 	mov	r4,r22
81127344:	1121e340 	call	81121e34 <__srefill_r>
81127348:	10004726 	beq	r2,zero,81127468 <__svfscanf_r+0x914>
8112734c:	88003f1e 	bne	r17,zero,8112744c <__svfscanf_r+0x8f8>
81127350:	d8c09f17 	ldw	r3,636(sp)
81127354:	1800031e 	bne	r3,zero,81127364 <__svfscanf_r+0x810>
81127358:	da00a017 	ldw	r8,640(sp)
8112735c:	42000044 	addi	r8,r8,1
81127360:	da00a015 	stw	r8,640(sp)
81127364:	dd009d17 	ldw	r20,628(sp)
81127368:	a00d883a 	mov	r6,r20
8112736c:	003e3706 	br	81126c4c <__reset+0xfb106c4c>
81127370:	8c40040c 	andi	r17,r17,16
81127374:	04ffffc4 	movi	r19,-1
81127378:	883fa61e 	bne	r17,zero,81127214 <__reset+0xfb107214>
8112737c:	da009c17 	ldw	r8,624(sp)
81127380:	9abfffc4 	addi	r10,r19,-1
81127384:	44000017 	ldw	r16,0(r8)
81127388:	44400104 	addi	r17,r8,4
8112738c:	8007883a 	mov	r3,r16
81127390:	82ab883a 	add	r21,r16,r10
81127394:	00000306 	br	811273a4 <__svfscanf_r+0x850>
81127398:	e1000017 	ldw	r4,0(fp)
8112739c:	9807883a 	mov	r3,r19
811273a0:	20800003 	ldbu	r2,0(r4)
811273a4:	10803fcc 	andi	r2,r2,255
811273a8:	d9405884 	addi	r5,sp,354
811273ac:	2885883a 	add	r2,r5,r2
811273b0:	10800007 	ldb	r2,0(r2)
811273b4:	10004b26 	beq	r2,zero,811274e4 <__svfscanf_r+0x990>
811273b8:	e0800117 	ldw	r2,4(fp)
811273bc:	21400044 	addi	r5,r4,1
811273c0:	e1400015 	stw	r5,0(fp)
811273c4:	10bfffc4 	addi	r2,r2,-1
811273c8:	e0800115 	stw	r2,4(fp)
811273cc:	20800003 	ldbu	r2,0(r4)
811273d0:	1cc00044 	addi	r19,r3,1
811273d4:	18800005 	stb	r2,0(r3)
811273d8:	1d400726 	beq	r3,r21,811273f8 <__svfscanf_r+0x8a4>
811273dc:	e0800117 	ldw	r2,4(fp)
811273e0:	00bfed16 	blt	zero,r2,81127398 <__reset+0xfb107398>
811273e4:	e00b883a 	mov	r5,fp
811273e8:	b009883a 	mov	r4,r22
811273ec:	1121e340 	call	81121e34 <__srefill_r>
811273f0:	103fe926 	beq	r2,zero,81127398 <__reset+0xfb107398>
811273f4:	84c01526 	beq	r16,r19,8112744c <__svfscanf_r+0x8f8>
811273f8:	9c21c83a 	sub	r16,r19,r16
811273fc:	803e1726 	beq	r16,zero,81126c5c <__reset+0xfb106c5c>
81127400:	da00a017 	ldw	r8,640(sp)
81127404:	98000005 	stb	zero,0(r19)
81127408:	dc409c15 	stw	r17,624(sp)
8112740c:	42000044 	addi	r8,r8,1
81127410:	da00a015 	stw	r8,640(sp)
81127414:	9425883a 	add	r18,r18,r16
81127418:	a00d883a 	mov	r6,r20
8112741c:	003e0b06 	br	81126c4c <__reset+0xfb106c4c>
81127420:	017fff84 	movi	r5,-2
81127424:	11439b1e 	bne	r2,r5,81128294 <__svfscanf_r+0x1740>
81127428:	8821883a 	mov	r16,r17
8112742c:	e0800117 	ldw	r2,4(fp)
81127430:	0082e516 	blt	zero,r2,81127fc8 <__svfscanf_r+0x1474>
81127434:	e00b883a 	mov	r5,fp
81127438:	b009883a 	mov	r4,r22
8112743c:	1121e340 	call	81121e34 <__srefill_r>
81127440:	1002e126 	beq	r2,zero,81127fc8 <__svfscanf_r+0x1474>
81127444:	dc409f17 	ldw	r17,636(sp)
81127448:	8002e826 	beq	r16,zero,81127fec <__svfscanf_r+0x1498>
8112744c:	da00a017 	ldw	r8,640(sp)
81127450:	403e9c26 	beq	r8,zero,81126ec4 <__reset+0xfb106ec4>
81127454:	e080030b 	ldhu	r2,12(fp)
81127458:	1080100c 	andi	r2,r2,64
8112745c:	103e991e 	bne	r2,zero,81126ec4 <__reset+0xfb106ec4>
81127460:	4005883a 	mov	r2,r8
81127464:	003e9806 	br	81126ec8 <__reset+0xfb106ec8>
81127468:	983f951e 	bne	r19,zero,811272c0 <__reset+0xfb1072c0>
8112746c:	003fb806 	br	81127350 <__reset+0xfb107350>
81127470:	da009c17 	ldw	r8,624(sp)
81127474:	45000017 	ldw	r20,0(r8)
81127478:	42000104 	addi	r8,r8,4
8112747c:	da009c15 	stw	r8,624(sp)
81127480:	003f8e06 	br	811272bc <__reset+0xfb1072bc>
81127484:	e00b883a 	mov	r5,fp
81127488:	b009883a 	mov	r4,r22
8112748c:	1121e340 	call	81121e34 <__srefill_r>
81127490:	103f3826 	beq	r2,zero,81127174 <__reset+0xfb107174>
81127494:	003fed06 	br	8112744c <__reset+0xfb10744c>
81127498:	00ffff84 	movi	r3,-2
8112749c:	10c0071e 	bne	r2,r3,811274bc <__svfscanf_r+0x968>
811274a0:	e0800117 	ldw	r2,4(fp)
811274a4:	8023883a 	mov	r17,r16
811274a8:	00bf8516 	blt	zero,r2,811272c0 <__reset+0xfb1072c0>
811274ac:	003fa306 	br	8112733c <__reset+0xfb10733c>
811274b0:	9425883a 	add	r18,r18,r16
811274b4:	9cffffc4 	addi	r19,r19,-1
811274b8:	003f9d06 	br	81127330 <__reset+0xfb107330>
811274bc:	da009f17 	ldw	r8,636(sp)
811274c0:	9425883a 	add	r18,r18,r16
811274c4:	9cffffc4 	addi	r19,r19,-1
811274c8:	403f9826 	beq	r8,zero,8112732c <__reset+0xfb10732c>
811274cc:	003f9806 	br	81127330 <__reset+0xfb107330>
811274d0:	8023883a 	mov	r17,r16
811274d4:	8821883a 	mov	r16,r17
811274d8:	003fce06 	br	81127414 <__reset+0xfb107414>
811274dc:	803f3d1e 	bne	r16,zero,811271d4 <__reset+0xfb1071d4>
811274e0:	003fda06 	br	8112744c <__reset+0xfb10744c>
811274e4:	1827883a 	mov	r19,r3
811274e8:	003fc306 	br	811273f8 <__reset+0xfb1073f8>
811274ec:	803fc91e 	bne	r16,zero,81127414 <__reset+0xfb107414>
811274f0:	003dda06 	br	81126c5c <__reset+0xfb106c5c>
811274f4:	da009c17 	ldw	r8,624(sp)
811274f8:	df000015 	stw	fp,0(sp)
811274fc:	980f883a 	mov	r7,r19
81127500:	41400017 	ldw	r5,0(r8)
81127504:	01800044 	movi	r6,1
81127508:	b009883a 	mov	r4,r22
8112750c:	112a72c0 	call	8112a72c <_fread_r>
81127510:	da009c17 	ldw	r8,624(sp)
81127514:	40c00104 	addi	r3,r8,4
81127518:	103fcc26 	beq	r2,zero,8112744c <__reset+0xfb10744c>
8112751c:	da00a017 	ldw	r8,640(sp)
81127520:	dd009d17 	ldw	r20,628(sp)
81127524:	90a5883a 	add	r18,r18,r2
81127528:	42000044 	addi	r8,r8,1
8112752c:	da00a015 	stw	r8,640(sp)
81127530:	d8c09c15 	stw	r3,624(sp)
81127534:	a00d883a 	mov	r6,r20
81127538:	003dc406 	br	81126c4c <__reset+0xfb106c4c>
8112753c:	e00b883a 	mov	r5,fp
81127540:	b009883a 	mov	r4,r22
81127544:	1121e340 	call	81121e34 <__srefill_r>
81127548:	103e5226 	beq	r2,zero,81126e94 <__reset+0xfb106e94>
8112754c:	003fbf06 	br	8112744c <__reset+0xfb10744c>
81127550:	a0800083 	ldbu	r2,2(r20)
81127554:	8c400094 	ori	r17,r17,2
81127558:	a5000084 	addi	r20,r20,2
8112755c:	10c03fcc 	andi	r3,r2,255
81127560:	003dc706 	br	81126c80 <__reset+0xfb106c80>
81127564:	e0800117 	ldw	r2,4(fp)
81127568:	88e2b03a 	or	r17,r17,r3
8112756c:	00bef716 	blt	zero,r2,8112714c <__reset+0xfb10714c>
81127570:	003e6f06 	br	81126f30 <__reset+0xfb106f30>
81127574:	8880004c 	andi	r2,r17,1
81127578:	10000b1e 	bne	r2,zero,811275a8 <__svfscanf_r+0xa54>
8112757c:	8c40008c 	andi	r17,r17,2
81127580:	88000926 	beq	r17,zero,811275a8 <__svfscanf_r+0xa54>
81127584:	da009c17 	ldw	r8,624(sp)
81127588:	9007d7fa 	srai	r3,r18,31
8112758c:	dd009d17 	ldw	r20,628(sp)
81127590:	40800017 	ldw	r2,0(r8)
81127594:	42000104 	addi	r8,r8,4
81127598:	da009c15 	stw	r8,624(sp)
8112759c:	14800015 	stw	r18,0(r2)
811275a0:	10c00115 	stw	r3,4(r2)
811275a4:	003da806 	br	81126c48 <__reset+0xfb106c48>
811275a8:	da009c17 	ldw	r8,624(sp)
811275ac:	dd009d17 	ldw	r20,628(sp)
811275b0:	40800017 	ldw	r2,0(r8)
811275b4:	42000104 	addi	r8,r8,4
811275b8:	da009c15 	stw	r8,624(sp)
811275bc:	14800015 	stw	r18,0(r2)
811275c0:	003da106 	br	81126c48 <__reset+0xfb106c48>
811275c4:	e00b883a 	mov	r5,fp
811275c8:	b009883a 	mov	r4,r22
811275cc:	1121e340 	call	81121e34 <__srefill_r>
811275d0:	103f9e1e 	bne	r2,zero,8112744c <__reset+0xfb10744c>
811275d4:	b9c00017 	ldw	r7,0(r23)
811275d8:	05000104 	movi	r20,4
811275dc:	003e6306 	br	81126f6c <__reset+0xfb106f6c>
811275e0:	e00b883a 	mov	r5,fp
811275e4:	b009883a 	mov	r4,r22
811275e8:	1121e340 	call	81121e34 <__srefill_r>
811275ec:	103f971e 	bne	r2,zero,8112744c <__reset+0xfb10744c>
811275f0:	b9c00017 	ldw	r7,0(r23)
811275f4:	003e5706 	br	81126f54 <__reset+0xfb106f54>
811275f8:	e00b883a 	mov	r5,fp
811275fc:	b009883a 	mov	r4,r22
81127600:	1121e340 	call	81121e34 <__srefill_r>
81127604:	103f911e 	bne	r2,zero,8112744c <__reset+0xfb10744c>
81127608:	b9c00017 	ldw	r7,0(r23)
8112760c:	05000084 	movi	r20,2
81127610:	003e5606 	br	81126f6c <__reset+0xfb106f6c>
81127614:	e00b883a 	mov	r5,fp
81127618:	b009883a 	mov	r4,r22
8112761c:	1121e340 	call	81121e34 <__srefill_r>
81127620:	103ef726 	beq	r2,zero,81127200 <__reset+0xfb107200>
81127624:	003f8906 	br	8112744c <__reset+0xfb10744c>
81127628:	e00b883a 	mov	r5,fp
8112762c:	b009883a 	mov	r4,r22
81127630:	1121e340 	call	81121e34 <__srefill_r>
81127634:	103f851e 	bne	r2,zero,8112744c <__reset+0xfb10744c>
81127638:	b9c00017 	ldw	r7,0(r23)
8112763c:	003f0f06 	br	8112727c <__reset+0xfb10727c>
81127640:	014000c4 	movi	r5,3
81127644:	a1414a26 	beq	r20,r5,81127b70 <__svfscanf_r+0x101c>
81127648:	01000104 	movi	r4,4
8112764c:	a101f11e 	bne	r20,r4,81127e14 <__svfscanf_r+0x12c0>
81127650:	b009883a 	mov	r4,r22
81127654:	112b57c0 	call	8112b57c <_localeconv_r>
81127658:	10800017 	ldw	r2,0(r2)
8112765c:	98ffffc4 	addi	r3,r19,-1
81127660:	d880a315 	stw	r2,652(sp)
81127664:	00805704 	movi	r2,348
81127668:	10c21e2e 	bgeu	r2,r3,81127ee4 <__svfscanf_r+0x1390>
8112766c:	9cffa8c4 	addi	r19,r19,-349
81127670:	dcc0a215 	stw	r19,648(sp)
81127674:	04c05744 	movi	r19,349
81127678:	8d01e014 	ori	r20,r17,1920
8112767c:	0023883a 	mov	r17,zero
81127680:	dc000104 	addi	r16,sp,4
81127684:	8805883a 	mov	r2,r17
81127688:	0019883a 	mov	r12,zero
8112768c:	8023883a 	mov	r17,r16
81127690:	b007883a 	mov	r3,r22
81127694:	9821883a 	mov	r16,r19
81127698:	002b883a 	mov	r21,zero
8112769c:	d800a515 	stw	zero,660(sp)
811276a0:	d800a415 	stw	zero,656(sp)
811276a4:	d8009f15 	stw	zero,636(sp)
811276a8:	01c01384 	movi	r7,78
811276ac:	602d883a 	mov	r22,r12
811276b0:	1027883a 	mov	r19,r2
811276b4:	e1000017 	ldw	r4,0(fp)
811276b8:	21400003 	ldbu	r5,0(r4)
811276bc:	28bff544 	addi	r2,r5,-43
811276c0:	10803fcc 	andi	r2,r2,255
811276c4:	38810e36 	bltu	r7,r2,81127b00 <__svfscanf_r+0xfac>
811276c8:	100490ba 	slli	r2,r2,2
811276cc:	01a044b4 	movhi	r6,33042
811276d0:	319db804 	addi	r6,r6,30432
811276d4:	1185883a 	add	r2,r2,r6
811276d8:	10800017 	ldw	r2,0(r2)
811276dc:	1000683a 	jmp	r2
811276e0:	811279d8 	cmpnei	r4,r16,18919
811276e4:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811276e8:	811279d8 	cmpnei	r4,r16,18919
811276ec:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811276f0:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811276f4:	811279ac 	andhi	r4,r16,18918
811276f8:	8112781c 	xori	r4,r16,18912
811276fc:	8112781c 	xori	r4,r16,18912
81127700:	8112781c 	xori	r4,r16,18912
81127704:	8112781c 	xori	r4,r16,18912
81127708:	8112781c 	xori	r4,r16,18912
8112770c:	8112781c 	xori	r4,r16,18912
81127710:	8112781c 	xori	r4,r16,18912
81127714:	8112781c 	xori	r4,r16,18912
81127718:	8112781c 	xori	r4,r16,18912
8112771c:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127720:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127724:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127728:	81127b00 	call	881127b0 <__reset+0x20f27b0>
8112772c:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127730:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127734:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127738:	81127af0 	cmpltui	r4,r16,18923
8112773c:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127740:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127744:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127748:	81127aac 	andhi	r4,r16,18922
8112774c:	81127a90 	cmplti	r4,r16,18922
81127750:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127754:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127758:	81127a5c 	xori	r4,r16,18921
8112775c:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127760:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127764:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127768:	81127b00 	call	881127b0 <__reset+0x20f27b0>
8112776c:	81127a24 	muli	r4,r16,18920
81127770:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127774:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127778:	81127b00 	call	881127b0 <__reset+0x20f27b0>
8112777c:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127780:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127784:	81127a08 	cmpgei	r4,r16,18920
81127788:	81127b00 	call	881127b0 <__reset+0x20f27b0>
8112778c:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127790:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127794:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127798:	811279ec 	andhi	r4,r16,18919
8112779c:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277a0:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277a4:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277a8:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277ac:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277b0:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277b4:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277b8:	81127af0 	cmpltui	r4,r16,18923
811277bc:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277c0:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277c4:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277c8:	81127aac 	andhi	r4,r16,18922
811277cc:	81127a90 	cmplti	r4,r16,18922
811277d0:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277d4:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277d8:	81127a5c 	xori	r4,r16,18921
811277dc:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277e0:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277e4:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277e8:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277ec:	81127a24 	muli	r4,r16,18920
811277f0:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277f4:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277f8:	81127b00 	call	881127b0 <__reset+0x20f27b0>
811277fc:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127800:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127804:	81127a08 	cmpgei	r4,r16,18920
81127808:	81127b00 	call	881127b0 <__reset+0x20f27b0>
8112780c:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127810:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127814:	81127b00 	call	881127b0 <__reset+0x20f27b0>
81127818:	811279ec 	andhi	r4,r16,18919
8112781c:	a8803fcc 	andi	r2,r21,255
81127820:	1080201c 	xori	r2,r2,128
81127824:	10bfe004 	addi	r2,r2,-128
81127828:	b085883a 	add	r2,r22,r2
8112782c:	10000d1e 	bne	r2,zero,81127864 <__svfscanf_r+0xd10>
81127830:	00bf9fc4 	movi	r2,-385
81127834:	a0a8703a 	and	r20,r20,r2
81127838:	89400005 	stb	r5,0(r17)
8112783c:	8c400044 	addi	r17,r17,1
81127840:	e0800117 	ldw	r2,4(fp)
81127844:	843fffc4 	addi	r16,r16,-1
81127848:	94800044 	addi	r18,r18,1
8112784c:	10bfffc4 	addi	r2,r2,-1
81127850:	e0800115 	stw	r2,4(fp)
81127854:	0080b40e 	bge	zero,r2,81127b28 <__svfscanf_r+0xfd4>
81127858:	21000044 	addi	r4,r4,1
8112785c:	e1000015 	stw	r4,0(fp)
81127860:	803f941e 	bne	r16,zero,811276b4 <__reset+0xfb1076b4>
81127864:	8821883a 	mov	r16,r17
81127868:	b019883a 	mov	r12,r22
8112786c:	9823883a 	mov	r17,r19
81127870:	182d883a 	mov	r22,r3
81127874:	9801961e 	bne	r19,zero,81127ed0 <__svfscanf_r+0x137c>
81127878:	633fffc4 	addi	r12,r12,-1
8112787c:	00800044 	movi	r2,1
81127880:	1302882e 	bgeu	r2,r12,811282a4 <__svfscanf_r+0x1750>
81127884:	a8803fcc 	andi	r2,r21,255
81127888:	1080201c 	xori	r2,r2,128
8112788c:	10bfe004 	addi	r2,r2,-128
81127890:	113fffc4 	addi	r4,r2,-1
81127894:	01400184 	movi	r5,6
81127898:	29001136 	bltu	r5,r4,811278e0 <__svfscanf_r+0xd8c>
8112789c:	01000084 	movi	r4,2
811278a0:	2082900e 	bge	r4,r2,811282e4 <__svfscanf_r+0x1790>
811278a4:	00c000c4 	movi	r3,3
811278a8:	10c00d26 	beq	r2,r3,811278e0 <__svfscanf_r+0xd8c>
811278ac:	9425c83a 	sub	r18,r18,r16
811278b0:	1827883a 	mov	r19,r3
811278b4:	843fffc4 	addi	r16,r16,-1
811278b8:	81400007 	ldb	r5,0(r16)
811278bc:	e00d883a 	mov	r6,fp
811278c0:	b009883a 	mov	r4,r22
811278c4:	11307ac0 	call	811307ac <_ungetc_r>
811278c8:	a8bfffc4 	addi	r2,r21,-1
811278cc:	10c03fcc 	andi	r3,r2,255
811278d0:	8493883a 	add	r9,r16,r18
811278d4:	102b883a 	mov	r21,r2
811278d8:	98fff636 	bltu	r19,r3,811278b4 <__reset+0xfb1078b4>
811278dc:	4825883a 	mov	r18,r9
811278e0:	a080400c 	andi	r2,r20,256
811278e4:	10001426 	beq	r2,zero,81127938 <__svfscanf_r+0xde4>
811278e8:	a081000c 	andi	r2,r20,1024
811278ec:	1002571e 	bne	r2,zero,8112824c <__svfscanf_r+0x16f8>
811278f0:	817fffc7 	ldb	r5,-1(r16)
811278f4:	00801944 	movi	r2,101
811278f8:	84ffffc4 	addi	r19,r16,-1
811278fc:	957fffc4 	addi	r21,r18,-1
81127900:	28800826 	beq	r5,r2,81127924 <__svfscanf_r+0xdd0>
81127904:	00801144 	movi	r2,69
81127908:	28800626 	beq	r5,r2,81127924 <__svfscanf_r+0xdd0>
8112790c:	e00d883a 	mov	r6,fp
81127910:	b009883a 	mov	r4,r22
81127914:	11307ac0 	call	811307ac <_ungetc_r>
81127918:	817fff87 	ldb	r5,-2(r16)
8112791c:	84ffff84 	addi	r19,r16,-2
81127920:	957fff84 	addi	r21,r18,-2
81127924:	e00d883a 	mov	r6,fp
81127928:	b009883a 	mov	r4,r22
8112792c:	11307ac0 	call	811307ac <_ungetc_r>
81127930:	a825883a 	mov	r18,r21
81127934:	9821883a 	mov	r16,r19
81127938:	a080040c 	andi	r2,r20,16
8112793c:	103e891e 	bne	r2,zero,81127364 <__reset+0xfb107364>
81127940:	80000005 	stb	zero,0(r16)
81127944:	a081800c 	andi	r2,r20,1536
81127948:	01010004 	movi	r4,1024
8112794c:	1101dd26 	beq	r2,r4,811280c4 <__svfscanf_r+0x1570>
81127950:	da00a417 	ldw	r8,656(sp)
81127954:	4001e71e 	bne	r8,zero,811280f4 <__svfscanf_r+0x15a0>
81127958:	000d883a 	mov	r6,zero
8112795c:	d9400104 	addi	r5,sp,4
81127960:	b009883a 	mov	r4,r22
81127964:	112d35c0 	call	8112d35c <_strtod_r>
81127968:	1021883a 	mov	r16,r2
8112796c:	a080004c 	andi	r2,r20,1
81127970:	1000021e 	bne	r2,zero,8112797c <__svfscanf_r+0xe28>
81127974:	a2c0008c 	andi	r11,r20,2
81127978:	5801e826 	beq	r11,zero,8112811c <__svfscanf_r+0x15c8>
8112797c:	da009c17 	ldw	r8,624(sp)
81127980:	40800017 	ldw	r2,0(r8)
81127984:	42000104 	addi	r8,r8,4
81127988:	da009c15 	stw	r8,624(sp)
8112798c:	14000015 	stw	r16,0(r2)
81127990:	10c00115 	stw	r3,4(r2)
81127994:	da00a017 	ldw	r8,640(sp)
81127998:	dd009d17 	ldw	r20,628(sp)
8112799c:	42000044 	addi	r8,r8,1
811279a0:	da00a015 	stw	r8,640(sp)
811279a4:	a00d883a 	mov	r6,r20
811279a8:	003ca806 	br	81126c4c <__reset+0xfb106c4c>
811279ac:	a080400c 	andi	r2,r20,256
811279b0:	103f9a26 	beq	r2,zero,8112781c <__reset+0xfb10781c>
811279b4:	da00a217 	ldw	r8,648(sp)
811279b8:	00bfdfc4 	movi	r2,-129
811279bc:	a0a8703a 	and	r20,r20,r2
811279c0:	9cc00044 	addi	r19,r19,1
811279c4:	403f9e26 	beq	r8,zero,81127840 <__reset+0xfb107840>
811279c8:	423fffc4 	addi	r8,r8,-1
811279cc:	da00a215 	stw	r8,648(sp)
811279d0:	84000044 	addi	r16,r16,1
811279d4:	003f9a06 	br	81127840 <__reset+0xfb107840>
811279d8:	a080200c 	andi	r2,r20,128
811279dc:	103fa126 	beq	r2,zero,81127864 <__reset+0xfb107864>
811279e0:	00bfdfc4 	movi	r2,-129
811279e4:	a0a8703a 	and	r20,r20,r2
811279e8:	003f9306 	br	81127838 <__reset+0xfb107838>
811279ec:	a8803fcc 	andi	r2,r21,255
811279f0:	1080201c 	xori	r2,r2,128
811279f4:	10bfe004 	addi	r2,r2,-128
811279f8:	020001c4 	movi	r8,7
811279fc:	123f991e 	bne	r2,r8,81127864 <__reset+0xfb107864>
81127a00:	05400204 	movi	r21,8
81127a04:	003f8c06 	br	81127838 <__reset+0xfb107838>
81127a08:	a8803fcc 	andi	r2,r21,255
81127a0c:	1080201c 	xori	r2,r2,128
81127a10:	10bfe004 	addi	r2,r2,-128
81127a14:	01800184 	movi	r6,6
81127a18:	11bf921e 	bne	r2,r6,81127864 <__reset+0xfb107864>
81127a1c:	054001c4 	movi	r21,7
81127a20:	003f8506 	br	81127838 <__reset+0xfb107838>
81127a24:	b000491e 	bne	r22,zero,81127b4c <__svfscanf_r+0xff8>
81127a28:	9800031e 	bne	r19,zero,81127a38 <__svfscanf_r+0xee4>
81127a2c:	a081c00c 	andi	r2,r20,1792
81127a30:	0181c004 	movi	r6,1792
81127a34:	11819f26 	beq	r2,r6,811280b4 <__svfscanf_r+0x1560>
81127a38:	a8803fcc 	andi	r2,r21,255
81127a3c:	1080201c 	xori	r2,r2,128
81127a40:	10bfe004 	addi	r2,r2,-128
81127a44:	01800044 	movi	r6,1
81127a48:	11800226 	beq	r2,r6,81127a54 <__svfscanf_r+0xf00>
81127a4c:	01800104 	movi	r6,4
81127a50:	11bf841e 	bne	r2,r6,81127864 <__reset+0xfb107864>
81127a54:	ad400044 	addi	r21,r21,1
81127a58:	003f7706 	br	81127838 <__reset+0xfb107838>
81127a5c:	a8803fcc 	andi	r2,r21,255
81127a60:	1080201c 	xori	r2,r2,128
81127a64:	10bfe004 	addi	r2,r2,-128
81127a68:	10003c1e 	bne	r2,zero,81127b5c <__svfscanf_r+0x1008>
81127a6c:	9801141e 	bne	r19,zero,81127ec0 <__svfscanf_r+0x136c>
81127a70:	a081c00c 	andi	r2,r20,1792
81127a74:	0181c004 	movi	r6,1792
81127a78:	11818226 	beq	r2,r6,81128084 <__svfscanf_r+0x1530>
81127a7c:	8821883a 	mov	r16,r17
81127a80:	b019883a 	mov	r12,r22
81127a84:	9823883a 	mov	r17,r19
81127a88:	182d883a 	mov	r22,r3
81127a8c:	003f7a06 	br	81127878 <__reset+0xfb107878>
81127a90:	a8803fcc 	andi	r2,r21,255
81127a94:	1080201c 	xori	r2,r2,128
81127a98:	10bfe004 	addi	r2,r2,-128
81127a9c:	01800084 	movi	r6,2
81127aa0:	11bf701e 	bne	r2,r6,81127864 <__reset+0xfb107864>
81127aa4:	054000c4 	movi	r21,3
81127aa8:	003f6306 	br	81127838 <__reset+0xfb107838>
81127aac:	a081400c 	andi	r2,r20,1280
81127ab0:	01810004 	movi	r6,1024
81127ab4:	11800326 	beq	r2,r6,81127ac4 <__svfscanf_r+0xf70>
81127ab8:	a184703a 	and	r2,r20,r6
81127abc:	103f6926 	beq	r2,zero,81127864 <__reset+0xfb107864>
81127ac0:	983fee26 	beq	r19,zero,81127a7c <__reset+0xfb107a7c>
81127ac4:	a080800c 	andi	r2,r20,512
81127ac8:	1000041e 	bne	r2,zero,81127adc <__svfscanf_r+0xf88>
81127acc:	da009f17 	ldw	r8,636(sp)
81127ad0:	dc40a515 	stw	r17,660(sp)
81127ad4:	9a27c83a 	sub	r19,r19,r8
81127ad8:	dcc0a415 	stw	r19,656(sp)
81127adc:	00be1fc4 	movi	r2,-1921
81127ae0:	a0a8703a 	and	r20,r20,r2
81127ae4:	a5006014 	ori	r20,r20,384
81127ae8:	0027883a 	mov	r19,zero
81127aec:	003f5206 	br	81127838 <__reset+0xfb107838>
81127af0:	00800044 	movi	r2,1
81127af4:	b0bf5b1e 	bne	r22,r2,81127864 <__reset+0xfb107864>
81127af8:	05800084 	movi	r22,2
81127afc:	003f4e06 	br	81127838 <__reset+0xfb107838>
81127b00:	d980a317 	ldw	r6,652(sp)
81127b04:	30800003 	ldbu	r2,0(r6)
81127b08:	29803fcc 	andi	r6,r5,255
81127b0c:	30bf551e 	bne	r6,r2,81127864 <__reset+0xfb107864>
81127b10:	a080800c 	andi	r2,r20,512
81127b14:	103f5326 	beq	r2,zero,81127864 <__reset+0xfb107864>
81127b18:	023f5fc4 	movi	r8,-641
81127b1c:	a228703a 	and	r20,r20,r8
81127b20:	dcc09f15 	stw	r19,636(sp)
81127b24:	003f4406 	br	81127838 <__reset+0xfb107838>
81127b28:	1809883a 	mov	r4,r3
81127b2c:	e00b883a 	mov	r5,fp
81127b30:	d8c0a615 	stw	r3,664(sp)
81127b34:	d9c0aa15 	stw	r7,680(sp)
81127b38:	1121e340 	call	81121e34 <__srefill_r>
81127b3c:	d8c0a617 	ldw	r3,664(sp)
81127b40:	d9c0aa17 	ldw	r7,680(sp)
81127b44:	103f4626 	beq	r2,zero,81127860 <__reset+0xfb107860>
81127b48:	003f4606 	br	81127864 <__reset+0xfb107864>
81127b4c:	00800084 	movi	r2,2
81127b50:	b0bfb91e 	bne	r22,r2,81127a38 <__reset+0xfb107a38>
81127b54:	058000c4 	movi	r22,3
81127b58:	003f3706 	br	81127838 <__reset+0xfb107838>
81127b5c:	018000c4 	movi	r6,3
81127b60:	11bfbc26 	beq	r2,r6,81127a54 <__reset+0xfb107a54>
81127b64:	01800144 	movi	r6,5
81127b68:	11bfba26 	beq	r2,r6,81127a54 <__reset+0xfb107a54>
81127b6c:	003f3d06 	br	81127864 <__reset+0xfb107864>
81127b70:	98bfffc4 	addi	r2,r19,-1
81127b74:	01405704 	movi	r5,348
81127b78:	2880d82e 	bgeu	r5,r2,81127edc <__svfscanf_r+0x1388>
81127b7c:	99ffa8c4 	addi	r7,r19,-349
81127b80:	04c05744 	movi	r19,349
81127b84:	8c436014 	ori	r17,r17,3456
81127b88:	9013883a 	mov	r9,r18
81127b8c:	8825883a 	mov	r18,r17
81127b90:	dc409e17 	ldw	r17,632(sp)
81127b94:	0029883a 	mov	r20,zero
81127b98:	dc000104 	addi	r16,sp,4
81127b9c:	05401344 	movi	r21,77
81127ba0:	02c08004 	movi	r11,512
81127ba4:	01bf7fc4 	movi	r6,-513
81127ba8:	023fdfc4 	movi	r8,-129
81127bac:	20bff544 	addi	r2,r4,-43
81127bb0:	10803fcc 	andi	r2,r2,255
81127bb4:	a8807236 	bltu	r21,r2,81127d80 <__svfscanf_r+0x122c>
81127bb8:	100490ba 	slli	r2,r2,2
81127bbc:	016044b4 	movhi	r5,33042
81127bc0:	295ef404 	addi	r5,r5,31696
81127bc4:	1145883a 	add	r2,r2,r5
81127bc8:	10800017 	ldw	r2,0(r2)
81127bcc:	1000683a 	jmp	r2
81127bd0:	81127e04 	addi	r4,r16,18936
81127bd4:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127bd8:	81127e04 	addi	r4,r16,18936
81127bdc:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127be0:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127be4:	81127ddc 	xori	r4,r16,18935
81127be8:	81127dbc 	xorhi	r4,r16,18934
81127bec:	81127dbc 	xorhi	r4,r16,18934
81127bf0:	81127dbc 	xorhi	r4,r16,18934
81127bf4:	81127dbc 	xorhi	r4,r16,18934
81127bf8:	81127dbc 	xorhi	r4,r16,18934
81127bfc:	81127dbc 	xorhi	r4,r16,18934
81127c00:	81127dbc 	xorhi	r4,r16,18934
81127c04:	81127d64 	muli	r4,r16,18933
81127c08:	81127d64 	muli	r4,r16,18933
81127c0c:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c10:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c14:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c18:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c1c:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c20:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c24:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c28:	81127d50 	cmplti	r4,r16,18933
81127c2c:	81127d50 	cmplti	r4,r16,18933
81127c30:	81127d50 	cmplti	r4,r16,18933
81127c34:	81127d50 	cmplti	r4,r16,18933
81127c38:	81127d50 	cmplti	r4,r16,18933
81127c3c:	81127d50 	cmplti	r4,r16,18933
81127c40:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c44:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c48:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c4c:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c50:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c54:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c58:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c5c:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c60:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c64:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c68:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c6c:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c70:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c74:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c78:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c7c:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c80:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c84:	81127d08 	cmpgei	r4,r16,18932
81127c88:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c8c:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c90:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c94:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c98:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127c9c:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127ca0:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127ca4:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127ca8:	81127d50 	cmplti	r4,r16,18933
81127cac:	81127d50 	cmplti	r4,r16,18933
81127cb0:	81127d50 	cmplti	r4,r16,18933
81127cb4:	81127d50 	cmplti	r4,r16,18933
81127cb8:	81127d50 	cmplti	r4,r16,18933
81127cbc:	81127d50 	cmplti	r4,r16,18933
81127cc0:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127cc4:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127cc8:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127ccc:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127cd0:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127cd4:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127cd8:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127cdc:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127ce0:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127ce4:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127ce8:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127cec:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127cf0:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127cf4:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127cf8:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127cfc:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127d00:	81127d80 	call	881127d8 <__reset+0x20f27d8>
81127d04:	81127d08 	cmpgei	r4,r16,18932
81127d08:	9081800c 	andi	r2,r18,1536
81127d0c:	12c01c1e 	bne	r2,r11,81127d80 <__svfscanf_r+0x122c>
81127d10:	91a4703a 	and	r18,r18,r6
81127d14:	94814014 	ori	r18,r18,1280
81127d18:	04400404 	movi	r17,16
81127d1c:	81000005 	stb	r4,0(r16)
81127d20:	84000044 	addi	r16,r16,1
81127d24:	e0800117 	ldw	r2,4(fp)
81127d28:	10bfffc4 	addi	r2,r2,-1
81127d2c:	e0800115 	stw	r2,4(fp)
81127d30:	0080540e 	bge	zero,r2,81127e84 <__svfscanf_r+0x1330>
81127d34:	18c00044 	addi	r3,r3,1
81127d38:	e0c00015 	stw	r3,0(fp)
81127d3c:	9cffffc4 	addi	r19,r19,-1
81127d40:	98000f26 	beq	r19,zero,81127d80 <__svfscanf_r+0x122c>
81127d44:	e0c00017 	ldw	r3,0(fp)
81127d48:	19000003 	ldbu	r4,0(r3)
81127d4c:	003f9706 	br	81127bac <__reset+0xfb107bac>
81127d50:	00800284 	movi	r2,10
81127d54:	14400a0e 	bge	r2,r17,81127d80 <__svfscanf_r+0x122c>
81127d58:	00bd1fc4 	movi	r2,-2945
81127d5c:	90a4703a 	and	r18,r18,r2
81127d60:	003fee06 	br	81127d1c <__reset+0xfb107d1c>
81127d64:	01604574 	movhi	r5,33045
81127d68:	8c63883a 	add	r17,r17,r17
81127d6c:	297eb384 	addi	r5,r5,-1330
81127d70:	2c45883a 	add	r2,r5,r17
81127d74:	1440000f 	ldh	r17,0(r2)
81127d78:	00800204 	movi	r2,8
81127d7c:	147ff616 	blt	r2,r17,81127d58 <__reset+0xfb107d58>
81127d80:	dc409e15 	stw	r17,632(sp)
81127d84:	9023883a 	mov	r17,r18
81127d88:	8880400c 	andi	r2,r17,256
81127d8c:	4825883a 	mov	r18,r9
81127d90:	10000426 	beq	r2,zero,81127da4 <__svfscanf_r+0x1250>
81127d94:	d9800104 	addi	r6,sp,4
81127d98:	3400be36 	bltu	r6,r16,81128094 <__svfscanf_r+0x1540>
81127d9c:	da000104 	addi	r8,sp,4
81127da0:	443bae26 	beq	r8,r16,81126c5c <__reset+0xfb106c5c>
81127da4:	8880040c 	andi	r2,r17,16
81127da8:	10009326 	beq	r2,zero,81127ff8 <__svfscanf_r+0x14a4>
81127dac:	d8800104 	addi	r2,sp,4
81127db0:	80a1c83a 	sub	r16,r16,r2
81127db4:	8521883a 	add	r16,r16,r20
81127db8:	003d0606 	br	811271d4 <__reset+0xfb1071d4>
81127dbc:	01604574 	movhi	r5,33045
81127dc0:	8c63883a 	add	r17,r17,r17
81127dc4:	297eb384 	addi	r5,r5,-1330
81127dc8:	2c45883a 	add	r2,r5,r17
81127dcc:	1440000f 	ldh	r17,0(r2)
81127dd0:	00bd1fc4 	movi	r2,-2945
81127dd4:	90a4703a 	and	r18,r18,r2
81127dd8:	003fd006 	br	81127d1c <__reset+0xfb107d1c>
81127ddc:	9082000c 	andi	r2,r18,2048
81127de0:	103fce26 	beq	r2,zero,81127d1c <__reset+0xfb107d1c>
81127de4:	8800021e 	bne	r17,zero,81127df0 <__svfscanf_r+0x129c>
81127de8:	94808014 	ori	r18,r18,512
81127dec:	04400204 	movi	r17,8
81127df0:	9081000c 	andi	r2,r18,1024
81127df4:	10009426 	beq	r2,zero,81128048 <__svfscanf_r+0x14f4>
81127df8:	00be9fc4 	movi	r2,-1409
81127dfc:	90a4703a 	and	r18,r18,r2
81127e00:	003fc606 	br	81127d1c <__reset+0xfb107d1c>
81127e04:	9080200c 	andi	r2,r18,128
81127e08:	103fdd26 	beq	r2,zero,81127d80 <__reset+0xfb107d80>
81127e0c:	9224703a 	and	r18,r18,r8
81127e10:	003fc206 	br	81127d1c <__reset+0xfb107d1c>
81127e14:	9800011e 	bne	r19,zero,81127e1c <__svfscanf_r+0x12c8>
81127e18:	04ffffc4 	movi	r19,-1
81127e1c:	8900004c 	andi	r4,r17,1
81127e20:	20005b1e 	bne	r4,zero,81127f90 <__svfscanf_r+0x143c>
81127e24:	8c40040c 	andi	r17,r17,16
81127e28:	88003026 	beq	r17,zero,81127eec <__svfscanf_r+0x1398>
81127e2c:	0021883a 	mov	r16,zero
81127e30:	00000306 	br	81127e40 <__svfscanf_r+0x12ec>
81127e34:	18800003 	ldbu	r2,0(r3)
81127e38:	3885883a 	add	r2,r7,r2
81127e3c:	10800043 	ldbu	r2,1(r2)
81127e40:	1080020c 	andi	r2,r2,8
81127e44:	103ce31e 	bne	r2,zero,811271d4 <__reset+0xfb1071d4>
81127e48:	e0800117 	ldw	r2,4(fp)
81127e4c:	18c00044 	addi	r3,r3,1
81127e50:	84000044 	addi	r16,r16,1
81127e54:	10bfffc4 	addi	r2,r2,-1
81127e58:	e0800115 	stw	r2,4(fp)
81127e5c:	e0c00015 	stw	r3,0(fp)
81127e60:	84fcdc26 	beq	r16,r19,811271d4 <__reset+0xfb1071d4>
81127e64:	00bff316 	blt	zero,r2,81127e34 <__reset+0xfb107e34>
81127e68:	e00b883a 	mov	r5,fp
81127e6c:	b009883a 	mov	r4,r22
81127e70:	1121e340 	call	81121e34 <__srefill_r>
81127e74:	103cd71e 	bne	r2,zero,811271d4 <__reset+0xfb1071d4>
81127e78:	b9c00017 	ldw	r7,0(r23)
81127e7c:	e0c00017 	ldw	r3,0(fp)
81127e80:	003fec06 	br	81127e34 <__reset+0xfb107e34>
81127e84:	e00b883a 	mov	r5,fp
81127e88:	b009883a 	mov	r4,r22
81127e8c:	d980a715 	stw	r6,668(sp)
81127e90:	d9c0aa15 	stw	r7,680(sp)
81127e94:	da00a815 	stw	r8,672(sp)
81127e98:	da40a915 	stw	r9,676(sp)
81127e9c:	dac0a615 	stw	r11,664(sp)
81127ea0:	1121e340 	call	81121e34 <__srefill_r>
81127ea4:	d980a717 	ldw	r6,668(sp)
81127ea8:	d9c0aa17 	ldw	r7,680(sp)
81127eac:	da00a817 	ldw	r8,672(sp)
81127eb0:	da40a917 	ldw	r9,676(sp)
81127eb4:	dac0a617 	ldw	r11,664(sp)
81127eb8:	103fa026 	beq	r2,zero,81127d3c <__reset+0xfb107d3c>
81127ebc:	003fb006 	br	81127d80 <__reset+0xfb107d80>
81127ec0:	8821883a 	mov	r16,r17
81127ec4:	b019883a 	mov	r12,r22
81127ec8:	9823883a 	mov	r17,r19
81127ecc:	182d883a 	mov	r22,r3
81127ed0:	00bfbfc4 	movi	r2,-257
81127ed4:	a0a8703a 	and	r20,r20,r2
81127ed8:	003e6706 	br	81127878 <__reset+0xfb107878>
81127edc:	000f883a 	mov	r7,zero
81127ee0:	003f2806 	br	81127b84 <__reset+0xfb107b84>
81127ee4:	d800a215 	stw	zero,648(sp)
81127ee8:	003de306 	br	81127678 <__reset+0xfb107678>
81127eec:	da009c17 	ldw	r8,624(sp)
81127ef0:	9abfffc4 	addi	r10,r19,-1
81127ef4:	44400017 	ldw	r17,0(r8)
81127ef8:	44000104 	addi	r16,r8,4
81127efc:	880b883a 	mov	r5,r17
81127f00:	8aa9883a 	add	r20,r17,r10
81127f04:	00000606 	br	81127f20 <__svfscanf_r+0x13cc>
81127f08:	e0c00017 	ldw	r3,0(fp)
81127f0c:	b9000017 	ldw	r4,0(r23)
81127f10:	a80b883a 	mov	r5,r21
81127f14:	18800003 	ldbu	r2,0(r3)
81127f18:	2085883a 	add	r2,r4,r2
81127f1c:	10800043 	ldbu	r2,1(r2)
81127f20:	1080020c 	andi	r2,r2,8
81127f24:	1000551e 	bne	r2,zero,8112807c <__svfscanf_r+0x1528>
81127f28:	e0800117 	ldw	r2,4(fp)
81127f2c:	19000044 	addi	r4,r3,1
81127f30:	e1000015 	stw	r4,0(fp)
81127f34:	10bfffc4 	addi	r2,r2,-1
81127f38:	e0800115 	stw	r2,4(fp)
81127f3c:	18800003 	ldbu	r2,0(r3)
81127f40:	2d400044 	addi	r21,r5,1
81127f44:	a827883a 	mov	r19,r21
81127f48:	28800005 	stb	r2,0(r5)
81127f4c:	2d000626 	beq	r5,r20,81127f68 <__svfscanf_r+0x1414>
81127f50:	e0800117 	ldw	r2,4(fp)
81127f54:	00bfec16 	blt	zero,r2,81127f08 <__reset+0xfb107f08>
81127f58:	e00b883a 	mov	r5,fp
81127f5c:	b009883a 	mov	r4,r22
81127f60:	1121e340 	call	81121e34 <__srefill_r>
81127f64:	103fe826 	beq	r2,zero,81127f08 <__reset+0xfb107f08>
81127f68:	da00a017 	ldw	r8,640(sp)
81127f6c:	dd009d17 	ldw	r20,628(sp)
81127f70:	9c63c83a 	sub	r17,r19,r17
81127f74:	42000044 	addi	r8,r8,1
81127f78:	98000005 	stb	zero,0(r19)
81127f7c:	9465883a 	add	r18,r18,r17
81127f80:	da00a015 	stw	r8,640(sp)
81127f84:	dc009c15 	stw	r16,624(sp)
81127f88:	a00d883a 	mov	r6,r20
81127f8c:	003b2f06 	br	81126c4c <__reset+0xfb106c4c>
81127f90:	dd409904 	addi	r21,sp,612
81127f94:	8c40040c 	andi	r17,r17,16
81127f98:	01800204 	movi	r6,8
81127f9c:	000b883a 	mov	r5,zero
81127fa0:	a809883a 	mov	r4,r21
81127fa4:	11219b80 	call	811219b8 <memset>
81127fa8:	8800401e 	bne	r17,zero,811280ac <__svfscanf_r+0x1558>
81127fac:	da009c17 	ldw	r8,624(sp)
81127fb0:	45000017 	ldw	r20,0(r8)
81127fb4:	42000104 	addi	r8,r8,4
81127fb8:	da009c15 	stw	r8,624(sp)
81127fbc:	000d883a 	mov	r6,zero
81127fc0:	3021883a 	mov	r16,r6
81127fc4:	dc409f15 	stw	r17,636(sp)
81127fc8:	e0800017 	ldw	r2,0(fp)
81127fcc:	b8c00017 	ldw	r3,0(r23)
81127fd0:	10800003 	ldbu	r2,0(r2)
81127fd4:	1885883a 	add	r2,r3,r2
81127fd8:	10800043 	ldbu	r2,1(r2)
81127fdc:	1080020c 	andi	r2,r2,8
81127fe0:	1000011e 	bne	r2,zero,81127fe8 <__svfscanf_r+0x1494>
81127fe4:	9800701e 	bne	r19,zero,811281a8 <__svfscanf_r+0x1654>
81127fe8:	dc409f17 	ldw	r17,636(sp)
81127fec:	883cdd1e 	bne	r17,zero,81127364 <__reset+0xfb107364>
81127ff0:	a0000015 	stw	zero,0(r20)
81127ff4:	003cd806 	br	81127358 <__reset+0xfb107358>
81127ff8:	d9c09e17 	ldw	r7,632(sp)
81127ffc:	da00a117 	ldw	r8,644(sp)
81128000:	000d883a 	mov	r6,zero
81128004:	d9400104 	addi	r5,sp,4
81128008:	b009883a 	mov	r4,r22
8112800c:	80000005 	stb	zero,0(r16)
81128010:	403ee83a 	callr	r8
81128014:	88c0080c 	andi	r3,r17,32
81128018:	1800121e 	bne	r3,zero,81128064 <__svfscanf_r+0x1510>
8112801c:	88c0010c 	andi	r3,r17,4
81128020:	18004d26 	beq	r3,zero,81128158 <__svfscanf_r+0x1604>
81128024:	da009c17 	ldw	r8,624(sp)
81128028:	40c00017 	ldw	r3,0(r8)
8112802c:	42000104 	addi	r8,r8,4
81128030:	da009c15 	stw	r8,624(sp)
81128034:	1880000d 	sth	r2,0(r3)
81128038:	da00a017 	ldw	r8,640(sp)
8112803c:	42000044 	addi	r8,r8,1
81128040:	da00a015 	stw	r8,640(sp)
81128044:	003f5906 	br	81127dac <__reset+0xfb107dac>
81128048:	00bf1fc4 	movi	r2,-897
8112804c:	90a4703a 	and	r18,r18,r2
81128050:	38000226 	beq	r7,zero,8112805c <__svfscanf_r+0x1508>
81128054:	39ffffc4 	addi	r7,r7,-1
81128058:	9cc00044 	addi	r19,r19,1
8112805c:	a5000044 	addi	r20,r20,1
81128060:	003f3006 	br	81127d24 <__reset+0xfb107d24>
81128064:	da009c17 	ldw	r8,624(sp)
81128068:	40c00017 	ldw	r3,0(r8)
8112806c:	42000104 	addi	r8,r8,4
81128070:	da009c15 	stw	r8,624(sp)
81128074:	18800015 	stw	r2,0(r3)
81128078:	003fef06 	br	81128038 <__reset+0xfb108038>
8112807c:	2827883a 	mov	r19,r5
81128080:	003fb906 	br	81127f68 <__reset+0xfb107f68>
81128084:	01be1fc4 	movi	r6,-1921
81128088:	a1a8703a 	and	r20,r20,r6
8112808c:	05400044 	movi	r21,1
81128090:	003de906 	br	81127838 <__reset+0xfb107838>
81128094:	817fffc7 	ldb	r5,-1(r16)
81128098:	e00d883a 	mov	r6,fp
8112809c:	b009883a 	mov	r4,r22
811280a0:	843fffc4 	addi	r16,r16,-1
811280a4:	11307ac0 	call	811307ac <_ungetc_r>
811280a8:	003f3c06 	br	81127d9c <__reset+0xfb107d9c>
811280ac:	dd009b04 	addi	r20,sp,620
811280b0:	003fc206 	br	81127fbc <__reset+0xfb107fbc>
811280b4:	00be1fc4 	movi	r2,-1921
811280b8:	a0a8703a 	and	r20,r20,r2
811280bc:	05800044 	movi	r22,1
811280c0:	003ddd06 	br	81127838 <__reset+0xfb107838>
811280c4:	d8c09f17 	ldw	r3,636(sp)
811280c8:	88e3c83a 	sub	r17,r17,r3
811280cc:	044dc83a 	sub	r6,zero,r17
811280d0:	883e2126 	beq	r17,zero,81127958 <__reset+0xfb107958>
811280d4:	d88055c4 	addi	r2,sp,343
811280d8:	80800136 	bltu	r16,r2,811280e0 <__svfscanf_r+0x158c>
811280dc:	dc005584 	addi	r16,sp,342
811280e0:	01604574 	movhi	r5,33045
811280e4:	297eb204 	addi	r5,r5,-1336
811280e8:	8009883a 	mov	r4,r16
811280ec:	11221480 	call	81122148 <sprintf>
811280f0:	003e1906 	br	81127958 <__reset+0xfb107958>
811280f4:	d8c0a517 	ldw	r3,660(sp)
811280f8:	000d883a 	mov	r6,zero
811280fc:	01c00284 	movi	r7,10
81128100:	19400044 	addi	r5,r3,1
81128104:	b009883a 	mov	r4,r22
81128108:	11224380 	call	81122438 <_strtol_r>
8112810c:	da00a417 	ldw	r8,656(sp)
81128110:	dc00a517 	ldw	r16,660(sp)
81128114:	120dc83a 	sub	r6,r2,r8
81128118:	003fee06 	br	811280d4 <__reset+0xfb1080d4>
8112811c:	da009c17 	ldw	r8,624(sp)
81128120:	180b883a 	mov	r5,r3
81128124:	8009883a 	mov	r4,r16
81128128:	45000017 	ldw	r20,0(r8)
8112812c:	44400104 	addi	r17,r8,4
81128130:	d8c0a615 	stw	r3,664(sp)
81128134:	112d0c80 	call	8112d0c8 <__fpclassifyd>
81128138:	d8c0a617 	ldw	r3,664(sp)
8112813c:	10006426 	beq	r2,zero,811282d0 <__svfscanf_r+0x177c>
81128140:	8009883a 	mov	r4,r16
81128144:	180b883a 	mov	r5,r3
81128148:	11204500 	call	81120450 <__truncdfsf2>
8112814c:	a0800015 	stw	r2,0(r20)
81128150:	dc409c15 	stw	r17,624(sp)
81128154:	003e0f06 	br	81127994 <__reset+0xfb107994>
81128158:	88c0004c 	andi	r3,r17,1
8112815c:	183fc11e 	bne	r3,zero,81128064 <__reset+0xfb108064>
81128160:	8c40008c 	andi	r17,r17,2
81128164:	883fbf26 	beq	r17,zero,81128064 <__reset+0xfb108064>
81128168:	da00a117 	ldw	r8,644(sp)
8112816c:	00a044f4 	movhi	r2,33043
81128170:	10bb5904 	addi	r2,r2,-4764
81128174:	d9c09e17 	ldw	r7,632(sp)
81128178:	000d883a 	mov	r6,zero
8112817c:	d9400104 	addi	r5,sp,4
81128180:	b009883a 	mov	r4,r22
81128184:	40806226 	beq	r8,r2,81128310 <__svfscanf_r+0x17bc>
81128188:	112ea7c0 	call	8112ea7c <_strtoll_r>
8112818c:	da009c17 	ldw	r8,624(sp)
81128190:	41000017 	ldw	r4,0(r8)
81128194:	42000104 	addi	r8,r8,4
81128198:	da009c15 	stw	r8,624(sp)
8112819c:	20800015 	stw	r2,0(r4)
811281a0:	20c00115 	stw	r3,4(r4)
811281a4:	003fa406 	br	81128038 <__reset+0xfb108038>
811281a8:	112b5580 	call	8112b558 <__locale_mb_cur_max>
811281ac:	80bca726 	beq	r16,r2,8112744c <__reset+0xfb10744c>
811281b0:	e0800017 	ldw	r2,0(fp)
811281b4:	e1000117 	ldw	r4,4(fp)
811281b8:	d8c00104 	addi	r3,sp,4
811281bc:	12000003 	ldbu	r8,0(r2)
811281c0:	213fffc4 	addi	r4,r4,-1
811281c4:	10800044 	addi	r2,r2,1
811281c8:	e1000115 	stw	r4,4(fp)
811281cc:	e0800015 	stw	r2,0(fp)
811281d0:	84400044 	addi	r17,r16,1
811281d4:	dd400015 	stw	r21,0(sp)
811281d8:	1c21883a 	add	r16,r3,r16
811281dc:	b009883a 	mov	r4,r22
811281e0:	880f883a 	mov	r7,r17
811281e4:	180d883a 	mov	r6,r3
811281e8:	a00b883a 	mov	r5,r20
811281ec:	82000005 	stb	r8,0(r16)
811281f0:	112b6140 	call	8112b614 <_mbrtowc_r>
811281f4:	013fffc4 	movi	r4,-1
811281f8:	113c9426 	beq	r2,r4,8112744c <__reset+0xfb10744c>
811281fc:	103c881e 	bne	r2,zero,81127420 <__reset+0xfb107420>
81128200:	a0000015 	stw	zero,0(r20)
81128204:	0009883a 	mov	r4,zero
81128208:	112b4980 	call	8112b498 <iswspace>
8112820c:	10001a26 	beq	r2,zero,81128278 <__svfscanf_r+0x1724>
81128210:	8821883a 	mov	r16,r17
81128214:	dc409f17 	ldw	r17,636(sp)
81128218:	803f7426 	beq	r16,zero,81127fec <__reset+0xfb107fec>
8112821c:	843fffc4 	addi	r16,r16,-1
81128220:	d9800104 	addi	r6,sp,4
81128224:	342b883a 	add	r21,r6,r16
81128228:	00000106 	br	81128230 <__svfscanf_r+0x16dc>
8112822c:	843fffc4 	addi	r16,r16,-1
81128230:	a9400003 	ldbu	r5,0(r21)
81128234:	e00d883a 	mov	r6,fp
81128238:	b009883a 	mov	r4,r22
8112823c:	11307ac0 	call	811307ac <_ungetc_r>
81128240:	ad7fffc4 	addi	r21,r21,-1
81128244:	803ff91e 	bne	r16,zero,8112822c <__reset+0xfb10822c>
81128248:	003f6806 	br	81127fec <__reset+0xfb107fec>
8112824c:	d9800104 	addi	r6,sp,4
81128250:	802b883a 	mov	r21,r16
81128254:	343a812e 	bgeu	r6,r16,81126c5c <__reset+0xfb106c5c>
81128258:	ad7fffc4 	addi	r21,r21,-1
8112825c:	a9400007 	ldb	r5,0(r21)
81128260:	e00d883a 	mov	r6,fp
81128264:	b009883a 	mov	r4,r22
81128268:	11307ac0 	call	811307ac <_ungetc_r>
8112826c:	da000104 	addi	r8,sp,4
81128270:	457ff91e 	bne	r8,r21,81128258 <__reset+0xfb108258>
81128274:	003a7906 	br	81126c5c <__reset+0xfb106c5c>
81128278:	da009f17 	ldw	r8,636(sp)
8112827c:	9465883a 	add	r18,r18,r17
81128280:	9cffffc4 	addi	r19,r19,-1
81128284:	4000051e 	bne	r8,zero,8112829c <__svfscanf_r+0x1748>
81128288:	a5000104 	addi	r20,r20,4
8112828c:	0021883a 	mov	r16,zero
81128290:	003c6606 	br	8112742c <__reset+0xfb10742c>
81128294:	a1000017 	ldw	r4,0(r20)
81128298:	003fdb06 	br	81128208 <__reset+0xfb108208>
8112829c:	0021883a 	mov	r16,zero
811282a0:	003c6206 	br	8112742c <__reset+0xfb10742c>
811282a4:	d8800104 	addi	r2,sp,4
811282a8:	802b883a 	mov	r21,r16
811282ac:	143a6b2e 	bgeu	r2,r16,81126c5c <__reset+0xfb106c5c>
811282b0:	ad7fffc4 	addi	r21,r21,-1
811282b4:	a9400007 	ldb	r5,0(r21)
811282b8:	e00d883a 	mov	r6,fp
811282bc:	b009883a 	mov	r4,r22
811282c0:	11307ac0 	call	811307ac <_ungetc_r>
811282c4:	d8c00104 	addi	r3,sp,4
811282c8:	1d7ff91e 	bne	r3,r21,811282b0 <__reset+0xfb1082b0>
811282cc:	003a6306 	br	81126c5c <__reset+0xfb106c5c>
811282d0:	0009883a 	mov	r4,zero
811282d4:	112d20c0 	call	8112d20c <nanf>
811282d8:	a0800015 	stw	r2,0(r20)
811282dc:	dc409c15 	stw	r17,624(sp)
811282e0:	003dac06 	br	81127994 <__reset+0xfb107994>
811282e4:	d9000104 	addi	r4,sp,4
811282e8:	802b883a 	mov	r21,r16
811282ec:	243a5b2e 	bgeu	r4,r16,81126c5c <__reset+0xfb106c5c>
811282f0:	ad7fffc4 	addi	r21,r21,-1
811282f4:	a9400007 	ldb	r5,0(r21)
811282f8:	e00d883a 	mov	r6,fp
811282fc:	b009883a 	mov	r4,r22
81128300:	11307ac0 	call	811307ac <_ungetc_r>
81128304:	d9400104 	addi	r5,sp,4
81128308:	2d7ff91e 	bne	r5,r21,811282f0 <__reset+0xfb1082f0>
8112830c:	003a5306 	br	81126c5c <__reset+0xfb106c5c>
81128310:	112efd40 	call	8112efd4 <_strtoull_r>
81128314:	003f9d06 	br	8112818c <__reset+0xfb10818c>

81128318 <vfscanf>:
81128318:	00a04574 	movhi	r2,33045
8112831c:	defffb04 	addi	sp,sp,-20
81128320:	10886904 	addi	r2,r2,8612
81128324:	de00012e 	bgeu	sp,et,8112832c <vfscanf+0x14>
81128328:	003b68fa 	trap	3
8112832c:	dc000215 	stw	r16,8(sp)
81128330:	14000017 	ldw	r16,0(r2)
81128334:	dc400315 	stw	r17,12(sp)
81128338:	dfc00415 	stw	ra,16(sp)
8112833c:	2023883a 	mov	r17,r4
81128340:	80000826 	beq	r16,zero,81128364 <vfscanf+0x4c>
81128344:	80800e17 	ldw	r2,56(r16)
81128348:	1000061e 	bne	r2,zero,81128364 <vfscanf+0x4c>
8112834c:	8009883a 	mov	r4,r16
81128350:	d9400015 	stw	r5,0(sp)
81128354:	d9800115 	stw	r6,4(sp)
81128358:	112a6300 	call	8112a630 <__sinit>
8112835c:	d9800117 	ldw	r6,4(sp)
81128360:	d9400017 	ldw	r5,0(sp)
81128364:	300f883a 	mov	r7,r6
81128368:	8009883a 	mov	r4,r16
8112836c:	280d883a 	mov	r6,r5
81128370:	880b883a 	mov	r5,r17
81128374:	dfc00417 	ldw	ra,16(sp)
81128378:	dc400317 	ldw	r17,12(sp)
8112837c:	dc000217 	ldw	r16,8(sp)
81128380:	dec00504 	addi	sp,sp,20
81128384:	1126b541 	jmpi	81126b54 <__svfscanf_r>

81128388 <__svfscanf>:
81128388:	00a04574 	movhi	r2,33045
8112838c:	10886904 	addi	r2,r2,8612
81128390:	300f883a 	mov	r7,r6
81128394:	280d883a 	mov	r6,r5
81128398:	200b883a 	mov	r5,r4
8112839c:	11000017 	ldw	r4,0(r2)
811283a0:	1126b541 	jmpi	81126b54 <__svfscanf_r>

811283a4 <_vfscanf_r>:
811283a4:	defffb04 	addi	sp,sp,-20
811283a8:	de00012e 	bgeu	sp,et,811283b0 <_vfscanf_r+0xc>
811283ac:	003b68fa 	trap	3
811283b0:	dc000315 	stw	r16,12(sp)
811283b4:	dfc00415 	stw	ra,16(sp)
811283b8:	2021883a 	mov	r16,r4
811283bc:	20000926 	beq	r4,zero,811283e4 <_vfscanf_r+0x40>
811283c0:	20800e17 	ldw	r2,56(r4)
811283c4:	1000071e 	bne	r2,zero,811283e4 <_vfscanf_r+0x40>
811283c8:	d9400015 	stw	r5,0(sp)
811283cc:	d9800115 	stw	r6,4(sp)
811283d0:	d9c00215 	stw	r7,8(sp)
811283d4:	112a6300 	call	8112a630 <__sinit>
811283d8:	d9c00217 	ldw	r7,8(sp)
811283dc:	d9800117 	ldw	r6,4(sp)
811283e0:	d9400017 	ldw	r5,0(sp)
811283e4:	8009883a 	mov	r4,r16
811283e8:	dfc00417 	ldw	ra,16(sp)
811283ec:	dc000317 	ldw	r16,12(sp)
811283f0:	dec00504 	addi	sp,sp,20
811283f4:	1126b541 	jmpi	81126b54 <__svfscanf_r>

811283f8 <__swbuf_r>:
811283f8:	defffb04 	addi	sp,sp,-20
811283fc:	de00012e 	bgeu	sp,et,81128404 <__swbuf_r+0xc>
81128400:	003b68fa 	trap	3
81128404:	dcc00315 	stw	r19,12(sp)
81128408:	dc800215 	stw	r18,8(sp)
8112840c:	dc000015 	stw	r16,0(sp)
81128410:	dfc00415 	stw	ra,16(sp)
81128414:	dc400115 	stw	r17,4(sp)
81128418:	2025883a 	mov	r18,r4
8112841c:	2827883a 	mov	r19,r5
81128420:	3021883a 	mov	r16,r6
81128424:	20000226 	beq	r4,zero,81128430 <__swbuf_r+0x38>
81128428:	20800e17 	ldw	r2,56(r4)
8112842c:	10004226 	beq	r2,zero,81128538 <__swbuf_r+0x140>
81128430:	80800617 	ldw	r2,24(r16)
81128434:	8100030b 	ldhu	r4,12(r16)
81128438:	80800215 	stw	r2,8(r16)
8112843c:	2080020c 	andi	r2,r4,8
81128440:	10003626 	beq	r2,zero,8112851c <__swbuf_r+0x124>
81128444:	80c00417 	ldw	r3,16(r16)
81128448:	18003426 	beq	r3,zero,8112851c <__swbuf_r+0x124>
8112844c:	2088000c 	andi	r2,r4,8192
81128450:	9c403fcc 	andi	r17,r19,255
81128454:	10001a26 	beq	r2,zero,811284c0 <__swbuf_r+0xc8>
81128458:	80800017 	ldw	r2,0(r16)
8112845c:	81000517 	ldw	r4,20(r16)
81128460:	10c7c83a 	sub	r3,r2,r3
81128464:	1900200e 	bge	r3,r4,811284e8 <__swbuf_r+0xf0>
81128468:	18c00044 	addi	r3,r3,1
8112846c:	81000217 	ldw	r4,8(r16)
81128470:	11400044 	addi	r5,r2,1
81128474:	81400015 	stw	r5,0(r16)
81128478:	213fffc4 	addi	r4,r4,-1
8112847c:	81000215 	stw	r4,8(r16)
81128480:	14c00005 	stb	r19,0(r2)
81128484:	80800517 	ldw	r2,20(r16)
81128488:	10c01e26 	beq	r2,r3,81128504 <__swbuf_r+0x10c>
8112848c:	8080030b 	ldhu	r2,12(r16)
81128490:	1080004c 	andi	r2,r2,1
81128494:	10000226 	beq	r2,zero,811284a0 <__swbuf_r+0xa8>
81128498:	00800284 	movi	r2,10
8112849c:	88801926 	beq	r17,r2,81128504 <__swbuf_r+0x10c>
811284a0:	8805883a 	mov	r2,r17
811284a4:	dfc00417 	ldw	ra,16(sp)
811284a8:	dcc00317 	ldw	r19,12(sp)
811284ac:	dc800217 	ldw	r18,8(sp)
811284b0:	dc400117 	ldw	r17,4(sp)
811284b4:	dc000017 	ldw	r16,0(sp)
811284b8:	dec00504 	addi	sp,sp,20
811284bc:	f800283a 	ret
811284c0:	81401917 	ldw	r5,100(r16)
811284c4:	00b7ffc4 	movi	r2,-8193
811284c8:	21080014 	ori	r4,r4,8192
811284cc:	2884703a 	and	r2,r5,r2
811284d0:	80801915 	stw	r2,100(r16)
811284d4:	80800017 	ldw	r2,0(r16)
811284d8:	8100030d 	sth	r4,12(r16)
811284dc:	81000517 	ldw	r4,20(r16)
811284e0:	10c7c83a 	sub	r3,r2,r3
811284e4:	193fe016 	blt	r3,r4,81128468 <__reset+0xfb108468>
811284e8:	800b883a 	mov	r5,r16
811284ec:	9009883a 	mov	r4,r18
811284f0:	112a2340 	call	8112a234 <_fflush_r>
811284f4:	1000071e 	bne	r2,zero,81128514 <__swbuf_r+0x11c>
811284f8:	80800017 	ldw	r2,0(r16)
811284fc:	00c00044 	movi	r3,1
81128500:	003fda06 	br	8112846c <__reset+0xfb10846c>
81128504:	800b883a 	mov	r5,r16
81128508:	9009883a 	mov	r4,r18
8112850c:	112a2340 	call	8112a234 <_fflush_r>
81128510:	103fe326 	beq	r2,zero,811284a0 <__reset+0xfb1084a0>
81128514:	00bfffc4 	movi	r2,-1
81128518:	003fe206 	br	811284a4 <__reset+0xfb1084a4>
8112851c:	800b883a 	mov	r5,r16
81128520:	9009883a 	mov	r4,r18
81128524:	11285c00 	call	811285c0 <__swsetup_r>
81128528:	103ffa1e 	bne	r2,zero,81128514 <__reset+0xfb108514>
8112852c:	8100030b 	ldhu	r4,12(r16)
81128530:	80c00417 	ldw	r3,16(r16)
81128534:	003fc506 	br	8112844c <__reset+0xfb10844c>
81128538:	112a6300 	call	8112a630 <__sinit>
8112853c:	003fbc06 	br	81128430 <__reset+0xfb108430>

81128540 <__swbuf>:
81128540:	00a04574 	movhi	r2,33045
81128544:	10886904 	addi	r2,r2,8612
81128548:	280d883a 	mov	r6,r5
8112854c:	200b883a 	mov	r5,r4
81128550:	11000017 	ldw	r4,0(r2)
81128554:	11283f81 	jmpi	811283f8 <__swbuf_r>

81128558 <_write_r>:
81128558:	defffd04 	addi	sp,sp,-12
8112855c:	de00012e 	bgeu	sp,et,81128564 <_write_r+0xc>
81128560:	003b68fa 	trap	3
81128564:	2805883a 	mov	r2,r5
81128568:	dc000015 	stw	r16,0(sp)
8112856c:	04204574 	movhi	r16,33045
81128570:	dc400115 	stw	r17,4(sp)
81128574:	300b883a 	mov	r5,r6
81128578:	8408db04 	addi	r16,r16,9068
8112857c:	2023883a 	mov	r17,r4
81128580:	380d883a 	mov	r6,r7
81128584:	1009883a 	mov	r4,r2
81128588:	dfc00215 	stw	ra,8(sp)
8112858c:	80000015 	stw	zero,0(r16)
81128590:	11370500 	call	81137050 <write>
81128594:	00ffffc4 	movi	r3,-1
81128598:	10c00526 	beq	r2,r3,811285b0 <_write_r+0x58>
8112859c:	dfc00217 	ldw	ra,8(sp)
811285a0:	dc400117 	ldw	r17,4(sp)
811285a4:	dc000017 	ldw	r16,0(sp)
811285a8:	dec00304 	addi	sp,sp,12
811285ac:	f800283a 	ret
811285b0:	80c00017 	ldw	r3,0(r16)
811285b4:	183ff926 	beq	r3,zero,8112859c <__reset+0xfb10859c>
811285b8:	88c00015 	stw	r3,0(r17)
811285bc:	003ff706 	br	8112859c <__reset+0xfb10859c>

811285c0 <__swsetup_r>:
811285c0:	00a04574 	movhi	r2,33045
811285c4:	defffd04 	addi	sp,sp,-12
811285c8:	10886904 	addi	r2,r2,8612
811285cc:	de00012e 	bgeu	sp,et,811285d4 <__swsetup_r+0x14>
811285d0:	003b68fa 	trap	3
811285d4:	dc400115 	stw	r17,4(sp)
811285d8:	2023883a 	mov	r17,r4
811285dc:	11000017 	ldw	r4,0(r2)
811285e0:	dc000015 	stw	r16,0(sp)
811285e4:	dfc00215 	stw	ra,8(sp)
811285e8:	2821883a 	mov	r16,r5
811285ec:	20000226 	beq	r4,zero,811285f8 <__swsetup_r+0x38>
811285f0:	20800e17 	ldw	r2,56(r4)
811285f4:	10003126 	beq	r2,zero,811286bc <__swsetup_r+0xfc>
811285f8:	8080030b 	ldhu	r2,12(r16)
811285fc:	10c0020c 	andi	r3,r2,8
81128600:	1009883a 	mov	r4,r2
81128604:	18000f26 	beq	r3,zero,81128644 <__swsetup_r+0x84>
81128608:	80c00417 	ldw	r3,16(r16)
8112860c:	18001526 	beq	r3,zero,81128664 <__swsetup_r+0xa4>
81128610:	1100004c 	andi	r4,r2,1
81128614:	20001c1e 	bne	r4,zero,81128688 <__swsetup_r+0xc8>
81128618:	1080008c 	andi	r2,r2,2
8112861c:	1000291e 	bne	r2,zero,811286c4 <__swsetup_r+0x104>
81128620:	80800517 	ldw	r2,20(r16)
81128624:	80800215 	stw	r2,8(r16)
81128628:	18001c26 	beq	r3,zero,8112869c <__swsetup_r+0xdc>
8112862c:	0005883a 	mov	r2,zero
81128630:	dfc00217 	ldw	ra,8(sp)
81128634:	dc400117 	ldw	r17,4(sp)
81128638:	dc000017 	ldw	r16,0(sp)
8112863c:	dec00304 	addi	sp,sp,12
81128640:	f800283a 	ret
81128644:	2080040c 	andi	r2,r4,16
81128648:	10002e26 	beq	r2,zero,81128704 <__swsetup_r+0x144>
8112864c:	2080010c 	andi	r2,r4,4
81128650:	10001e1e 	bne	r2,zero,811286cc <__swsetup_r+0x10c>
81128654:	80c00417 	ldw	r3,16(r16)
81128658:	20800214 	ori	r2,r4,8
8112865c:	8080030d 	sth	r2,12(r16)
81128660:	183feb1e 	bne	r3,zero,81128610 <__reset+0xfb108610>
81128664:	1100a00c 	andi	r4,r2,640
81128668:	01408004 	movi	r5,512
8112866c:	217fe826 	beq	r4,r5,81128610 <__reset+0xfb108610>
81128670:	800b883a 	mov	r5,r16
81128674:	8809883a 	mov	r4,r17
81128678:	1120e900 	call	81120e90 <__smakebuf_r>
8112867c:	8080030b 	ldhu	r2,12(r16)
81128680:	80c00417 	ldw	r3,16(r16)
81128684:	003fe206 	br	81128610 <__reset+0xfb108610>
81128688:	80800517 	ldw	r2,20(r16)
8112868c:	80000215 	stw	zero,8(r16)
81128690:	0085c83a 	sub	r2,zero,r2
81128694:	80800615 	stw	r2,24(r16)
81128698:	183fe41e 	bne	r3,zero,8112862c <__reset+0xfb10862c>
8112869c:	80c0030b 	ldhu	r3,12(r16)
811286a0:	0005883a 	mov	r2,zero
811286a4:	1900200c 	andi	r4,r3,128
811286a8:	203fe126 	beq	r4,zero,81128630 <__reset+0xfb108630>
811286ac:	18c01014 	ori	r3,r3,64
811286b0:	80c0030d 	sth	r3,12(r16)
811286b4:	00bfffc4 	movi	r2,-1
811286b8:	003fdd06 	br	81128630 <__reset+0xfb108630>
811286bc:	112a6300 	call	8112a630 <__sinit>
811286c0:	003fcd06 	br	811285f8 <__reset+0xfb1085f8>
811286c4:	0005883a 	mov	r2,zero
811286c8:	003fd606 	br	81128624 <__reset+0xfb108624>
811286cc:	81400c17 	ldw	r5,48(r16)
811286d0:	28000626 	beq	r5,zero,811286ec <__swsetup_r+0x12c>
811286d4:	80801004 	addi	r2,r16,64
811286d8:	28800326 	beq	r5,r2,811286e8 <__swsetup_r+0x128>
811286dc:	8809883a 	mov	r4,r17
811286e0:	112aac80 	call	8112aac8 <_free_r>
811286e4:	8100030b 	ldhu	r4,12(r16)
811286e8:	80000c15 	stw	zero,48(r16)
811286ec:	80c00417 	ldw	r3,16(r16)
811286f0:	00bff6c4 	movi	r2,-37
811286f4:	1108703a 	and	r4,r2,r4
811286f8:	80000115 	stw	zero,4(r16)
811286fc:	80c00015 	stw	r3,0(r16)
81128700:	003fd506 	br	81128658 <__reset+0xfb108658>
81128704:	00800244 	movi	r2,9
81128708:	88800015 	stw	r2,0(r17)
8112870c:	20801014 	ori	r2,r4,64
81128710:	8080030d 	sth	r2,12(r16)
81128714:	00bfffc4 	movi	r2,-1
81128718:	003fc506 	br	81128630 <__reset+0xfb108630>

8112871c <_close_r>:
8112871c:	defffd04 	addi	sp,sp,-12
81128720:	de00012e 	bgeu	sp,et,81128728 <_close_r+0xc>
81128724:	003b68fa 	trap	3
81128728:	dc000015 	stw	r16,0(sp)
8112872c:	04204574 	movhi	r16,33045
81128730:	dc400115 	stw	r17,4(sp)
81128734:	8408db04 	addi	r16,r16,9068
81128738:	2023883a 	mov	r17,r4
8112873c:	2809883a 	mov	r4,r5
81128740:	dfc00215 	stw	ra,8(sp)
81128744:	80000015 	stw	zero,0(r16)
81128748:	11355d00 	call	811355d0 <close>
8112874c:	00ffffc4 	movi	r3,-1
81128750:	10c00526 	beq	r2,r3,81128768 <_close_r+0x4c>
81128754:	dfc00217 	ldw	ra,8(sp)
81128758:	dc400117 	ldw	r17,4(sp)
8112875c:	dc000017 	ldw	r16,0(sp)
81128760:	dec00304 	addi	sp,sp,12
81128764:	f800283a 	ret
81128768:	80c00017 	ldw	r3,0(r16)
8112876c:	183ff926 	beq	r3,zero,81128754 <__reset+0xfb108754>
81128770:	88c00015 	stw	r3,0(r17)
81128774:	003ff706 	br	81128754 <__reset+0xfb108754>

81128778 <quorem>:
81128778:	defff704 	addi	sp,sp,-36
8112877c:	de00012e 	bgeu	sp,et,81128784 <quorem+0xc>
81128780:	003b68fa 	trap	3
81128784:	dc800215 	stw	r18,8(sp)
81128788:	20800417 	ldw	r2,16(r4)
8112878c:	2c800417 	ldw	r18,16(r5)
81128790:	dfc00815 	stw	ra,32(sp)
81128794:	ddc00715 	stw	r23,28(sp)
81128798:	dd800615 	stw	r22,24(sp)
8112879c:	dd400515 	stw	r21,20(sp)
811287a0:	dd000415 	stw	r20,16(sp)
811287a4:	dcc00315 	stw	r19,12(sp)
811287a8:	dc400115 	stw	r17,4(sp)
811287ac:	dc000015 	stw	r16,0(sp)
811287b0:	14807116 	blt	r2,r18,81128978 <quorem+0x200>
811287b4:	94bfffc4 	addi	r18,r18,-1
811287b8:	94ad883a 	add	r22,r18,r18
811287bc:	b5ad883a 	add	r22,r22,r22
811287c0:	2c400504 	addi	r17,r5,20
811287c4:	8da9883a 	add	r20,r17,r22
811287c8:	25400504 	addi	r21,r4,20
811287cc:	282f883a 	mov	r23,r5
811287d0:	adad883a 	add	r22,r21,r22
811287d4:	a1400017 	ldw	r5,0(r20)
811287d8:	2021883a 	mov	r16,r4
811287dc:	b1000017 	ldw	r4,0(r22)
811287e0:	29400044 	addi	r5,r5,1
811287e4:	1133dd40 	call	81133dd4 <__udivsi3>
811287e8:	1027883a 	mov	r19,r2
811287ec:	10002c26 	beq	r2,zero,811288a0 <quorem+0x128>
811287f0:	a813883a 	mov	r9,r21
811287f4:	880b883a 	mov	r5,r17
811287f8:	0009883a 	mov	r4,zero
811287fc:	000d883a 	mov	r6,zero
81128800:	2a000017 	ldw	r8,0(r5)
81128804:	49c00017 	ldw	r7,0(r9)
81128808:	29400104 	addi	r5,r5,4
8112880c:	40bfffcc 	andi	r2,r8,65535
81128810:	14c5383a 	mul	r2,r2,r19
81128814:	4010d43a 	srli	r8,r8,16
81128818:	38ffffcc 	andi	r3,r7,65535
8112881c:	1105883a 	add	r2,r2,r4
81128820:	1008d43a 	srli	r4,r2,16
81128824:	44d1383a 	mul	r8,r8,r19
81128828:	198d883a 	add	r6,r3,r6
8112882c:	10ffffcc 	andi	r3,r2,65535
81128830:	30c7c83a 	sub	r3,r6,r3
81128834:	380ed43a 	srli	r7,r7,16
81128838:	4105883a 	add	r2,r8,r4
8112883c:	180dd43a 	srai	r6,r3,16
81128840:	113fffcc 	andi	r4,r2,65535
81128844:	390fc83a 	sub	r7,r7,r4
81128848:	398d883a 	add	r6,r7,r6
8112884c:	300e943a 	slli	r7,r6,16
81128850:	18ffffcc 	andi	r3,r3,65535
81128854:	1008d43a 	srli	r4,r2,16
81128858:	38ceb03a 	or	r7,r7,r3
8112885c:	49c00015 	stw	r7,0(r9)
81128860:	300dd43a 	srai	r6,r6,16
81128864:	4a400104 	addi	r9,r9,4
81128868:	a17fe52e 	bgeu	r20,r5,81128800 <__reset+0xfb108800>
8112886c:	b0800017 	ldw	r2,0(r22)
81128870:	10000b1e 	bne	r2,zero,811288a0 <quorem+0x128>
81128874:	b0bfff04 	addi	r2,r22,-4
81128878:	a880082e 	bgeu	r21,r2,8112889c <quorem+0x124>
8112887c:	b0ffff17 	ldw	r3,-4(r22)
81128880:	18000326 	beq	r3,zero,81128890 <quorem+0x118>
81128884:	00000506 	br	8112889c <quorem+0x124>
81128888:	10c00017 	ldw	r3,0(r2)
8112888c:	1800031e 	bne	r3,zero,8112889c <quorem+0x124>
81128890:	10bfff04 	addi	r2,r2,-4
81128894:	94bfffc4 	addi	r18,r18,-1
81128898:	a8bffb36 	bltu	r21,r2,81128888 <__reset+0xfb108888>
8112889c:	84800415 	stw	r18,16(r16)
811288a0:	b80b883a 	mov	r5,r23
811288a4:	8009883a 	mov	r4,r16
811288a8:	112c3980 	call	8112c398 <__mcmp>
811288ac:	10002616 	blt	r2,zero,81128948 <quorem+0x1d0>
811288b0:	9cc00044 	addi	r19,r19,1
811288b4:	a805883a 	mov	r2,r21
811288b8:	000b883a 	mov	r5,zero
811288bc:	11000017 	ldw	r4,0(r2)
811288c0:	89800017 	ldw	r6,0(r17)
811288c4:	10800104 	addi	r2,r2,4
811288c8:	20ffffcc 	andi	r3,r4,65535
811288cc:	194b883a 	add	r5,r3,r5
811288d0:	30ffffcc 	andi	r3,r6,65535
811288d4:	28c7c83a 	sub	r3,r5,r3
811288d8:	300cd43a 	srli	r6,r6,16
811288dc:	2008d43a 	srli	r4,r4,16
811288e0:	180bd43a 	srai	r5,r3,16
811288e4:	18ffffcc 	andi	r3,r3,65535
811288e8:	2189c83a 	sub	r4,r4,r6
811288ec:	2149883a 	add	r4,r4,r5
811288f0:	200c943a 	slli	r6,r4,16
811288f4:	8c400104 	addi	r17,r17,4
811288f8:	200bd43a 	srai	r5,r4,16
811288fc:	30c6b03a 	or	r3,r6,r3
81128900:	10ffff15 	stw	r3,-4(r2)
81128904:	a47fed2e 	bgeu	r20,r17,811288bc <__reset+0xfb1088bc>
81128908:	9485883a 	add	r2,r18,r18
8112890c:	1085883a 	add	r2,r2,r2
81128910:	a887883a 	add	r3,r21,r2
81128914:	18800017 	ldw	r2,0(r3)
81128918:	10000b1e 	bne	r2,zero,81128948 <quorem+0x1d0>
8112891c:	18bfff04 	addi	r2,r3,-4
81128920:	a880082e 	bgeu	r21,r2,81128944 <quorem+0x1cc>
81128924:	18ffff17 	ldw	r3,-4(r3)
81128928:	18000326 	beq	r3,zero,81128938 <quorem+0x1c0>
8112892c:	00000506 	br	81128944 <quorem+0x1cc>
81128930:	10c00017 	ldw	r3,0(r2)
81128934:	1800031e 	bne	r3,zero,81128944 <quorem+0x1cc>
81128938:	10bfff04 	addi	r2,r2,-4
8112893c:	94bfffc4 	addi	r18,r18,-1
81128940:	a8bffb36 	bltu	r21,r2,81128930 <__reset+0xfb108930>
81128944:	84800415 	stw	r18,16(r16)
81128948:	9805883a 	mov	r2,r19
8112894c:	dfc00817 	ldw	ra,32(sp)
81128950:	ddc00717 	ldw	r23,28(sp)
81128954:	dd800617 	ldw	r22,24(sp)
81128958:	dd400517 	ldw	r21,20(sp)
8112895c:	dd000417 	ldw	r20,16(sp)
81128960:	dcc00317 	ldw	r19,12(sp)
81128964:	dc800217 	ldw	r18,8(sp)
81128968:	dc400117 	ldw	r17,4(sp)
8112896c:	dc000017 	ldw	r16,0(sp)
81128970:	dec00904 	addi	sp,sp,36
81128974:	f800283a 	ret
81128978:	0005883a 	mov	r2,zero
8112897c:	003ff306 	br	8112894c <__reset+0xfb10894c>

81128980 <_dtoa_r>:
81128980:	deffde04 	addi	sp,sp,-136
81128984:	de00012e 	bgeu	sp,et,8112898c <_dtoa_r+0xc>
81128988:	003b68fa 	trap	3
8112898c:	20801017 	ldw	r2,64(r4)
81128990:	df002015 	stw	fp,128(sp)
81128994:	dcc01b15 	stw	r19,108(sp)
81128998:	dc801a15 	stw	r18,104(sp)
8112899c:	dc401915 	stw	r17,100(sp)
811289a0:	dc001815 	stw	r16,96(sp)
811289a4:	dfc02115 	stw	ra,132(sp)
811289a8:	ddc01f15 	stw	r23,124(sp)
811289ac:	dd801e15 	stw	r22,120(sp)
811289b0:	dd401d15 	stw	r21,116(sp)
811289b4:	dd001c15 	stw	r20,112(sp)
811289b8:	d9c00315 	stw	r7,12(sp)
811289bc:	2039883a 	mov	fp,r4
811289c0:	3023883a 	mov	r17,r6
811289c4:	2825883a 	mov	r18,r5
811289c8:	dc002417 	ldw	r16,144(sp)
811289cc:	3027883a 	mov	r19,r6
811289d0:	10000826 	beq	r2,zero,811289f4 <_dtoa_r+0x74>
811289d4:	21801117 	ldw	r6,68(r4)
811289d8:	00c00044 	movi	r3,1
811289dc:	100b883a 	mov	r5,r2
811289e0:	1986983a 	sll	r3,r3,r6
811289e4:	11800115 	stw	r6,4(r2)
811289e8:	10c00215 	stw	r3,8(r2)
811289ec:	112bb480 	call	8112bb48 <_Bfree>
811289f0:	e0001015 	stw	zero,64(fp)
811289f4:	88002e16 	blt	r17,zero,81128ab0 <_dtoa_r+0x130>
811289f8:	80000015 	stw	zero,0(r16)
811289fc:	889ffc2c 	andhi	r2,r17,32752
81128a00:	00dffc34 	movhi	r3,32752
81128a04:	10c01c26 	beq	r2,r3,81128a78 <_dtoa_r+0xf8>
81128a08:	000d883a 	mov	r6,zero
81128a0c:	000f883a 	mov	r7,zero
81128a10:	9009883a 	mov	r4,r18
81128a14:	980b883a 	mov	r5,r19
81128a18:	11352300 	call	81135230 <__eqdf2>
81128a1c:	10002b1e 	bne	r2,zero,81128acc <_dtoa_r+0x14c>
81128a20:	d9c02317 	ldw	r7,140(sp)
81128a24:	00800044 	movi	r2,1
81128a28:	38800015 	stw	r2,0(r7)
81128a2c:	d8802517 	ldw	r2,148(sp)
81128a30:	10019e26 	beq	r2,zero,811290ac <_dtoa_r+0x72c>
81128a34:	d8c02517 	ldw	r3,148(sp)
81128a38:	00a04574 	movhi	r2,33045
81128a3c:	10bea144 	addi	r2,r2,-1403
81128a40:	18800015 	stw	r2,0(r3)
81128a44:	10bfffc4 	addi	r2,r2,-1
81128a48:	dfc02117 	ldw	ra,132(sp)
81128a4c:	df002017 	ldw	fp,128(sp)
81128a50:	ddc01f17 	ldw	r23,124(sp)
81128a54:	dd801e17 	ldw	r22,120(sp)
81128a58:	dd401d17 	ldw	r21,116(sp)
81128a5c:	dd001c17 	ldw	r20,112(sp)
81128a60:	dcc01b17 	ldw	r19,108(sp)
81128a64:	dc801a17 	ldw	r18,104(sp)
81128a68:	dc401917 	ldw	r17,100(sp)
81128a6c:	dc001817 	ldw	r16,96(sp)
81128a70:	dec02204 	addi	sp,sp,136
81128a74:	f800283a 	ret
81128a78:	d8c02317 	ldw	r3,140(sp)
81128a7c:	0089c3c4 	movi	r2,9999
81128a80:	18800015 	stw	r2,0(r3)
81128a84:	90017726 	beq	r18,zero,81129064 <_dtoa_r+0x6e4>
81128a88:	00a04574 	movhi	r2,33045
81128a8c:	10bebf04 	addi	r2,r2,-1284
81128a90:	d9002517 	ldw	r4,148(sp)
81128a94:	203fec26 	beq	r4,zero,81128a48 <__reset+0xfb108a48>
81128a98:	10c000c7 	ldb	r3,3(r2)
81128a9c:	1801781e 	bne	r3,zero,81129080 <_dtoa_r+0x700>
81128aa0:	10c000c4 	addi	r3,r2,3
81128aa4:	d9802517 	ldw	r6,148(sp)
81128aa8:	30c00015 	stw	r3,0(r6)
81128aac:	003fe606 	br	81128a48 <__reset+0xfb108a48>
81128ab0:	04e00034 	movhi	r19,32768
81128ab4:	9cffffc4 	addi	r19,r19,-1
81128ab8:	00800044 	movi	r2,1
81128abc:	8ce6703a 	and	r19,r17,r19
81128ac0:	80800015 	stw	r2,0(r16)
81128ac4:	9823883a 	mov	r17,r19
81128ac8:	003fcc06 	br	811289fc <__reset+0xfb1089fc>
81128acc:	d8800204 	addi	r2,sp,8
81128ad0:	d8800015 	stw	r2,0(sp)
81128ad4:	d9c00104 	addi	r7,sp,4
81128ad8:	900b883a 	mov	r5,r18
81128adc:	980d883a 	mov	r6,r19
81128ae0:	e009883a 	mov	r4,fp
81128ae4:	8820d53a 	srli	r16,r17,20
81128ae8:	112c7740 	call	8112c774 <__d2b>
81128aec:	d8800915 	stw	r2,36(sp)
81128af0:	8001651e 	bne	r16,zero,81129088 <_dtoa_r+0x708>
81128af4:	dd800217 	ldw	r22,8(sp)
81128af8:	dc000117 	ldw	r16,4(sp)
81128afc:	00800804 	movi	r2,32
81128b00:	b421883a 	add	r16,r22,r16
81128b04:	80c10c84 	addi	r3,r16,1074
81128b08:	10c2d10e 	bge	r2,r3,81129650 <_dtoa_r+0xcd0>
81128b0c:	00801004 	movi	r2,64
81128b10:	81010484 	addi	r4,r16,1042
81128b14:	10c7c83a 	sub	r3,r2,r3
81128b18:	9108d83a 	srl	r4,r18,r4
81128b1c:	88e2983a 	sll	r17,r17,r3
81128b20:	2448b03a 	or	r4,r4,r17
81128b24:	11353ac0 	call	811353ac <__floatunsidf>
81128b28:	017f8434 	movhi	r5,65040
81128b2c:	01800044 	movi	r6,1
81128b30:	1009883a 	mov	r4,r2
81128b34:	194b883a 	add	r5,r3,r5
81128b38:	843fffc4 	addi	r16,r16,-1
81128b3c:	d9801115 	stw	r6,68(sp)
81128b40:	000d883a 	mov	r6,zero
81128b44:	01cffe34 	movhi	r7,16376
81128b48:	111f8d00 	call	8111f8d0 <__subdf3>
81128b4c:	0198dbf4 	movhi	r6,25455
81128b50:	01cff4f4 	movhi	r7,16339
81128b54:	3190d844 	addi	r6,r6,17249
81128b58:	39e1e9c4 	addi	r7,r7,-30809
81128b5c:	1009883a 	mov	r4,r2
81128b60:	180b883a 	mov	r5,r3
81128b64:	111f1b00 	call	8111f1b0 <__muldf3>
81128b68:	01a2d874 	movhi	r6,35681
81128b6c:	01cff1f4 	movhi	r7,16327
81128b70:	31b22cc4 	addi	r6,r6,-14157
81128b74:	39e28a04 	addi	r7,r7,-30168
81128b78:	180b883a 	mov	r5,r3
81128b7c:	1009883a 	mov	r4,r2
81128b80:	113408c0 	call	8113408c <__adddf3>
81128b84:	8009883a 	mov	r4,r16
81128b88:	1029883a 	mov	r20,r2
81128b8c:	1823883a 	mov	r17,r3
81128b90:	11202540 	call	81120254 <__floatsidf>
81128b94:	019427f4 	movhi	r6,20639
81128b98:	01cff4f4 	movhi	r7,16339
81128b9c:	319e7ec4 	addi	r6,r6,31227
81128ba0:	39d104c4 	addi	r7,r7,17427
81128ba4:	1009883a 	mov	r4,r2
81128ba8:	180b883a 	mov	r5,r3
81128bac:	111f1b00 	call	8111f1b0 <__muldf3>
81128bb0:	100d883a 	mov	r6,r2
81128bb4:	180f883a 	mov	r7,r3
81128bb8:	a009883a 	mov	r4,r20
81128bbc:	880b883a 	mov	r5,r17
81128bc0:	113408c0 	call	8113408c <__adddf3>
81128bc4:	1009883a 	mov	r4,r2
81128bc8:	180b883a 	mov	r5,r3
81128bcc:	1029883a 	mov	r20,r2
81128bd0:	1823883a 	mov	r17,r3
81128bd4:	11201d40 	call	811201d4 <__fixdfsi>
81128bd8:	000d883a 	mov	r6,zero
81128bdc:	000f883a 	mov	r7,zero
81128be0:	a009883a 	mov	r4,r20
81128be4:	880b883a 	mov	r5,r17
81128be8:	d8800515 	stw	r2,20(sp)
81128bec:	11352b80 	call	811352b8 <__ledf2>
81128bf0:	10028716 	blt	r2,zero,81129610 <_dtoa_r+0xc90>
81128bf4:	d8c00517 	ldw	r3,20(sp)
81128bf8:	00800584 	movi	r2,22
81128bfc:	10c27536 	bltu	r2,r3,811295d4 <_dtoa_r+0xc54>
81128c00:	180490fa 	slli	r2,r3,3
81128c04:	00e04574 	movhi	r3,33045
81128c08:	18feda04 	addi	r3,r3,-1176
81128c0c:	1885883a 	add	r2,r3,r2
81128c10:	11000017 	ldw	r4,0(r2)
81128c14:	11400117 	ldw	r5,4(r2)
81128c18:	900d883a 	mov	r6,r18
81128c1c:	980f883a 	mov	r7,r19
81128c20:	111f0d40 	call	8111f0d4 <__gedf2>
81128c24:	00828d0e 	bge	zero,r2,8112965c <_dtoa_r+0xcdc>
81128c28:	d9000517 	ldw	r4,20(sp)
81128c2c:	d8000e15 	stw	zero,56(sp)
81128c30:	213fffc4 	addi	r4,r4,-1
81128c34:	d9000515 	stw	r4,20(sp)
81128c38:	b42dc83a 	sub	r22,r22,r16
81128c3c:	b5bfffc4 	addi	r22,r22,-1
81128c40:	b0026f16 	blt	r22,zero,81129600 <_dtoa_r+0xc80>
81128c44:	d8000815 	stw	zero,32(sp)
81128c48:	d9c00517 	ldw	r7,20(sp)
81128c4c:	38026416 	blt	r7,zero,811295e0 <_dtoa_r+0xc60>
81128c50:	b1ed883a 	add	r22,r22,r7
81128c54:	d9c00d15 	stw	r7,52(sp)
81128c58:	d8000a15 	stw	zero,40(sp)
81128c5c:	d9800317 	ldw	r6,12(sp)
81128c60:	00800244 	movi	r2,9
81128c64:	11811436 	bltu	r2,r6,811290b8 <_dtoa_r+0x738>
81128c68:	00800144 	movi	r2,5
81128c6c:	1184e10e 	bge	r2,r6,81129ff4 <_dtoa_r+0x1674>
81128c70:	31bfff04 	addi	r6,r6,-4
81128c74:	d9800315 	stw	r6,12(sp)
81128c78:	0023883a 	mov	r17,zero
81128c7c:	d9800317 	ldw	r6,12(sp)
81128c80:	008000c4 	movi	r2,3
81128c84:	30836726 	beq	r6,r2,81129a24 <_dtoa_r+0x10a4>
81128c88:	1183410e 	bge	r2,r6,81129990 <_dtoa_r+0x1010>
81128c8c:	d9c00317 	ldw	r7,12(sp)
81128c90:	00800104 	movi	r2,4
81128c94:	38827c26 	beq	r7,r2,81129688 <_dtoa_r+0xd08>
81128c98:	00800144 	movi	r2,5
81128c9c:	3884c41e 	bne	r7,r2,81129fb0 <_dtoa_r+0x1630>
81128ca0:	00800044 	movi	r2,1
81128ca4:	d8800b15 	stw	r2,44(sp)
81128ca8:	d8c00517 	ldw	r3,20(sp)
81128cac:	d9002217 	ldw	r4,136(sp)
81128cb0:	1907883a 	add	r3,r3,r4
81128cb4:	19800044 	addi	r6,r3,1
81128cb8:	d8c00c15 	stw	r3,48(sp)
81128cbc:	d9800615 	stw	r6,24(sp)
81128cc0:	0183a40e 	bge	zero,r6,81129b54 <_dtoa_r+0x11d4>
81128cc4:	d9800617 	ldw	r6,24(sp)
81128cc8:	3021883a 	mov	r16,r6
81128ccc:	e0001115 	stw	zero,68(fp)
81128cd0:	008005c4 	movi	r2,23
81128cd4:	1184c92e 	bgeu	r2,r6,81129ffc <_dtoa_r+0x167c>
81128cd8:	00c00044 	movi	r3,1
81128cdc:	00800104 	movi	r2,4
81128ce0:	1085883a 	add	r2,r2,r2
81128ce4:	11000504 	addi	r4,r2,20
81128ce8:	180b883a 	mov	r5,r3
81128cec:	18c00044 	addi	r3,r3,1
81128cf0:	313ffb2e 	bgeu	r6,r4,81128ce0 <__reset+0xfb108ce0>
81128cf4:	e1401115 	stw	r5,68(fp)
81128cf8:	e009883a 	mov	r4,fp
81128cfc:	112ba980 	call	8112ba98 <_Balloc>
81128d00:	d8800715 	stw	r2,28(sp)
81128d04:	e0801015 	stw	r2,64(fp)
81128d08:	00800384 	movi	r2,14
81128d0c:	1400f736 	bltu	r2,r16,811290ec <_dtoa_r+0x76c>
81128d10:	8800f626 	beq	r17,zero,811290ec <_dtoa_r+0x76c>
81128d14:	d9c00517 	ldw	r7,20(sp)
81128d18:	01c39a0e 	bge	zero,r7,81129b84 <_dtoa_r+0x1204>
81128d1c:	388003cc 	andi	r2,r7,15
81128d20:	100490fa 	slli	r2,r2,3
81128d24:	382bd13a 	srai	r21,r7,4
81128d28:	00e04574 	movhi	r3,33045
81128d2c:	18feda04 	addi	r3,r3,-1176
81128d30:	1885883a 	add	r2,r3,r2
81128d34:	a8c0040c 	andi	r3,r21,16
81128d38:	12400017 	ldw	r9,0(r2)
81128d3c:	12000117 	ldw	r8,4(r2)
81128d40:	18037926 	beq	r3,zero,81129b28 <_dtoa_r+0x11a8>
81128d44:	00a04574 	movhi	r2,33045
81128d48:	10bed004 	addi	r2,r2,-1216
81128d4c:	11800817 	ldw	r6,32(r2)
81128d50:	11c00917 	ldw	r7,36(r2)
81128d54:	9009883a 	mov	r4,r18
81128d58:	980b883a 	mov	r5,r19
81128d5c:	da001715 	stw	r8,92(sp)
81128d60:	da401615 	stw	r9,88(sp)
81128d64:	11349400 	call	81134940 <__divdf3>
81128d68:	da001717 	ldw	r8,92(sp)
81128d6c:	da401617 	ldw	r9,88(sp)
81128d70:	ad4003cc 	andi	r21,r21,15
81128d74:	040000c4 	movi	r16,3
81128d78:	1023883a 	mov	r17,r2
81128d7c:	1829883a 	mov	r20,r3
81128d80:	a8001126 	beq	r21,zero,81128dc8 <_dtoa_r+0x448>
81128d84:	05e04574 	movhi	r23,33045
81128d88:	bdfed004 	addi	r23,r23,-1216
81128d8c:	4805883a 	mov	r2,r9
81128d90:	4007883a 	mov	r3,r8
81128d94:	a980004c 	andi	r6,r21,1
81128d98:	1009883a 	mov	r4,r2
81128d9c:	a82bd07a 	srai	r21,r21,1
81128da0:	180b883a 	mov	r5,r3
81128da4:	30000426 	beq	r6,zero,81128db8 <_dtoa_r+0x438>
81128da8:	b9800017 	ldw	r6,0(r23)
81128dac:	b9c00117 	ldw	r7,4(r23)
81128db0:	84000044 	addi	r16,r16,1
81128db4:	111f1b00 	call	8111f1b0 <__muldf3>
81128db8:	bdc00204 	addi	r23,r23,8
81128dbc:	a83ff51e 	bne	r21,zero,81128d94 <__reset+0xfb108d94>
81128dc0:	1013883a 	mov	r9,r2
81128dc4:	1811883a 	mov	r8,r3
81128dc8:	480d883a 	mov	r6,r9
81128dcc:	400f883a 	mov	r7,r8
81128dd0:	8809883a 	mov	r4,r17
81128dd4:	a00b883a 	mov	r5,r20
81128dd8:	11349400 	call	81134940 <__divdf3>
81128ddc:	d8800f15 	stw	r2,60(sp)
81128de0:	d8c01015 	stw	r3,64(sp)
81128de4:	d8c00e17 	ldw	r3,56(sp)
81128de8:	18000626 	beq	r3,zero,81128e04 <_dtoa_r+0x484>
81128dec:	d9000f17 	ldw	r4,60(sp)
81128df0:	d9401017 	ldw	r5,64(sp)
81128df4:	000d883a 	mov	r6,zero
81128df8:	01cffc34 	movhi	r7,16368
81128dfc:	11352b80 	call	811352b8 <__ledf2>
81128e00:	10040b16 	blt	r2,zero,81129e30 <_dtoa_r+0x14b0>
81128e04:	8009883a 	mov	r4,r16
81128e08:	11202540 	call	81120254 <__floatsidf>
81128e0c:	d9800f17 	ldw	r6,60(sp)
81128e10:	d9c01017 	ldw	r7,64(sp)
81128e14:	1009883a 	mov	r4,r2
81128e18:	180b883a 	mov	r5,r3
81128e1c:	111f1b00 	call	8111f1b0 <__muldf3>
81128e20:	000d883a 	mov	r6,zero
81128e24:	01d00734 	movhi	r7,16412
81128e28:	1009883a 	mov	r4,r2
81128e2c:	180b883a 	mov	r5,r3
81128e30:	113408c0 	call	8113408c <__adddf3>
81128e34:	1021883a 	mov	r16,r2
81128e38:	d8800617 	ldw	r2,24(sp)
81128e3c:	047f3034 	movhi	r17,64704
81128e40:	1c63883a 	add	r17,r3,r17
81128e44:	10031826 	beq	r2,zero,81129aa8 <_dtoa_r+0x1128>
81128e48:	d8c00517 	ldw	r3,20(sp)
81128e4c:	db000617 	ldw	r12,24(sp)
81128e50:	d8c01315 	stw	r3,76(sp)
81128e54:	d9000b17 	ldw	r4,44(sp)
81128e58:	20038f26 	beq	r4,zero,81129c98 <_dtoa_r+0x1318>
81128e5c:	60bfffc4 	addi	r2,r12,-1
81128e60:	100490fa 	slli	r2,r2,3
81128e64:	00e04574 	movhi	r3,33045
81128e68:	18feda04 	addi	r3,r3,-1176
81128e6c:	1885883a 	add	r2,r3,r2
81128e70:	11800017 	ldw	r6,0(r2)
81128e74:	11c00117 	ldw	r7,4(r2)
81128e78:	d8800717 	ldw	r2,28(sp)
81128e7c:	0009883a 	mov	r4,zero
81128e80:	014ff834 	movhi	r5,16352
81128e84:	db001615 	stw	r12,88(sp)
81128e88:	15c00044 	addi	r23,r2,1
81128e8c:	11349400 	call	81134940 <__divdf3>
81128e90:	800d883a 	mov	r6,r16
81128e94:	880f883a 	mov	r7,r17
81128e98:	1009883a 	mov	r4,r2
81128e9c:	180b883a 	mov	r5,r3
81128ea0:	111f8d00 	call	8111f8d0 <__subdf3>
81128ea4:	d9401017 	ldw	r5,64(sp)
81128ea8:	d9000f17 	ldw	r4,60(sp)
81128eac:	102b883a 	mov	r21,r2
81128eb0:	d8c01215 	stw	r3,72(sp)
81128eb4:	11201d40 	call	811201d4 <__fixdfsi>
81128eb8:	1009883a 	mov	r4,r2
81128ebc:	1029883a 	mov	r20,r2
81128ec0:	11202540 	call	81120254 <__floatsidf>
81128ec4:	d9000f17 	ldw	r4,60(sp)
81128ec8:	d9401017 	ldw	r5,64(sp)
81128ecc:	100d883a 	mov	r6,r2
81128ed0:	180f883a 	mov	r7,r3
81128ed4:	111f8d00 	call	8111f8d0 <__subdf3>
81128ed8:	1823883a 	mov	r17,r3
81128edc:	d8c00717 	ldw	r3,28(sp)
81128ee0:	d9401217 	ldw	r5,72(sp)
81128ee4:	a2000c04 	addi	r8,r20,48
81128ee8:	1021883a 	mov	r16,r2
81128eec:	1a000005 	stb	r8,0(r3)
81128ef0:	800d883a 	mov	r6,r16
81128ef4:	880f883a 	mov	r7,r17
81128ef8:	a809883a 	mov	r4,r21
81128efc:	4029883a 	mov	r20,r8
81128f00:	111f0d40 	call	8111f0d4 <__gedf2>
81128f04:	00841d16 	blt	zero,r2,81129f7c <_dtoa_r+0x15fc>
81128f08:	800d883a 	mov	r6,r16
81128f0c:	880f883a 	mov	r7,r17
81128f10:	0009883a 	mov	r4,zero
81128f14:	014ffc34 	movhi	r5,16368
81128f18:	111f8d00 	call	8111f8d0 <__subdf3>
81128f1c:	d9401217 	ldw	r5,72(sp)
81128f20:	100d883a 	mov	r6,r2
81128f24:	180f883a 	mov	r7,r3
81128f28:	a809883a 	mov	r4,r21
81128f2c:	111f0d40 	call	8111f0d4 <__gedf2>
81128f30:	db001617 	ldw	r12,88(sp)
81128f34:	00840e16 	blt	zero,r2,81129f70 <_dtoa_r+0x15f0>
81128f38:	00800044 	movi	r2,1
81128f3c:	13006b0e 	bge	r2,r12,811290ec <_dtoa_r+0x76c>
81128f40:	d9000717 	ldw	r4,28(sp)
81128f44:	dd800f15 	stw	r22,60(sp)
81128f48:	dcc01015 	stw	r19,64(sp)
81128f4c:	2319883a 	add	r12,r4,r12
81128f50:	dcc01217 	ldw	r19,72(sp)
81128f54:	602d883a 	mov	r22,r12
81128f58:	dc801215 	stw	r18,72(sp)
81128f5c:	b825883a 	mov	r18,r23
81128f60:	00000906 	br	81128f88 <_dtoa_r+0x608>
81128f64:	111f8d00 	call	8111f8d0 <__subdf3>
81128f68:	a80d883a 	mov	r6,r21
81128f6c:	980f883a 	mov	r7,r19
81128f70:	1009883a 	mov	r4,r2
81128f74:	180b883a 	mov	r5,r3
81128f78:	11352b80 	call	811352b8 <__ledf2>
81128f7c:	1003e816 	blt	r2,zero,81129f20 <_dtoa_r+0x15a0>
81128f80:	b825883a 	mov	r18,r23
81128f84:	bd83e926 	beq	r23,r22,81129f2c <_dtoa_r+0x15ac>
81128f88:	a809883a 	mov	r4,r21
81128f8c:	980b883a 	mov	r5,r19
81128f90:	000d883a 	mov	r6,zero
81128f94:	01d00934 	movhi	r7,16420
81128f98:	111f1b00 	call	8111f1b0 <__muldf3>
81128f9c:	000d883a 	mov	r6,zero
81128fa0:	01d00934 	movhi	r7,16420
81128fa4:	8009883a 	mov	r4,r16
81128fa8:	880b883a 	mov	r5,r17
81128fac:	102b883a 	mov	r21,r2
81128fb0:	1827883a 	mov	r19,r3
81128fb4:	111f1b00 	call	8111f1b0 <__muldf3>
81128fb8:	180b883a 	mov	r5,r3
81128fbc:	1009883a 	mov	r4,r2
81128fc0:	1821883a 	mov	r16,r3
81128fc4:	1023883a 	mov	r17,r2
81128fc8:	11201d40 	call	811201d4 <__fixdfsi>
81128fcc:	1009883a 	mov	r4,r2
81128fd0:	1029883a 	mov	r20,r2
81128fd4:	11202540 	call	81120254 <__floatsidf>
81128fd8:	8809883a 	mov	r4,r17
81128fdc:	800b883a 	mov	r5,r16
81128fe0:	100d883a 	mov	r6,r2
81128fe4:	180f883a 	mov	r7,r3
81128fe8:	111f8d00 	call	8111f8d0 <__subdf3>
81128fec:	a5000c04 	addi	r20,r20,48
81128ff0:	a80d883a 	mov	r6,r21
81128ff4:	980f883a 	mov	r7,r19
81128ff8:	1009883a 	mov	r4,r2
81128ffc:	180b883a 	mov	r5,r3
81129000:	95000005 	stb	r20,0(r18)
81129004:	1021883a 	mov	r16,r2
81129008:	1823883a 	mov	r17,r3
8112900c:	11352b80 	call	811352b8 <__ledf2>
81129010:	bdc00044 	addi	r23,r23,1
81129014:	800d883a 	mov	r6,r16
81129018:	880f883a 	mov	r7,r17
8112901c:	0009883a 	mov	r4,zero
81129020:	014ffc34 	movhi	r5,16368
81129024:	103fcf0e 	bge	r2,zero,81128f64 <__reset+0xfb108f64>
81129028:	d8c01317 	ldw	r3,76(sp)
8112902c:	d8c00515 	stw	r3,20(sp)
81129030:	d9400917 	ldw	r5,36(sp)
81129034:	e009883a 	mov	r4,fp
81129038:	112bb480 	call	8112bb48 <_Bfree>
8112903c:	d9000517 	ldw	r4,20(sp)
81129040:	d9802317 	ldw	r6,140(sp)
81129044:	d9c02517 	ldw	r7,148(sp)
81129048:	b8000005 	stb	zero,0(r23)
8112904c:	20800044 	addi	r2,r4,1
81129050:	30800015 	stw	r2,0(r6)
81129054:	3802aa26 	beq	r7,zero,81129b00 <_dtoa_r+0x1180>
81129058:	3dc00015 	stw	r23,0(r7)
8112905c:	d8800717 	ldw	r2,28(sp)
81129060:	003e7906 	br	81128a48 <__reset+0xfb108a48>
81129064:	00800434 	movhi	r2,16
81129068:	10bfffc4 	addi	r2,r2,-1
8112906c:	88a2703a 	and	r17,r17,r2
81129070:	883e851e 	bne	r17,zero,81128a88 <__reset+0xfb108a88>
81129074:	00a04574 	movhi	r2,33045
81129078:	10bebc04 	addi	r2,r2,-1296
8112907c:	003e8406 	br	81128a90 <__reset+0xfb108a90>
81129080:	10c00204 	addi	r3,r2,8
81129084:	003e8706 	br	81128aa4 <__reset+0xfb108aa4>
81129088:	01400434 	movhi	r5,16
8112908c:	297fffc4 	addi	r5,r5,-1
81129090:	994a703a 	and	r5,r19,r5
81129094:	9009883a 	mov	r4,r18
81129098:	843f0044 	addi	r16,r16,-1023
8112909c:	294ffc34 	orhi	r5,r5,16368
811290a0:	dd800217 	ldw	r22,8(sp)
811290a4:	d8001115 	stw	zero,68(sp)
811290a8:	003ea506 	br	81128b40 <__reset+0xfb108b40>
811290ac:	00a04574 	movhi	r2,33045
811290b0:	10bea104 	addi	r2,r2,-1404
811290b4:	003e6406 	br	81128a48 <__reset+0xfb108a48>
811290b8:	e0001115 	stw	zero,68(fp)
811290bc:	000b883a 	mov	r5,zero
811290c0:	e009883a 	mov	r4,fp
811290c4:	112ba980 	call	8112ba98 <_Balloc>
811290c8:	01bfffc4 	movi	r6,-1
811290cc:	01c00044 	movi	r7,1
811290d0:	d8800715 	stw	r2,28(sp)
811290d4:	d9800c15 	stw	r6,48(sp)
811290d8:	e0801015 	stw	r2,64(fp)
811290dc:	d8000315 	stw	zero,12(sp)
811290e0:	d9c00b15 	stw	r7,44(sp)
811290e4:	d9800615 	stw	r6,24(sp)
811290e8:	d8002215 	stw	zero,136(sp)
811290ec:	d8800117 	ldw	r2,4(sp)
811290f0:	10008916 	blt	r2,zero,81129318 <_dtoa_r+0x998>
811290f4:	d9000517 	ldw	r4,20(sp)
811290f8:	00c00384 	movi	r3,14
811290fc:	19008616 	blt	r3,r4,81129318 <_dtoa_r+0x998>
81129100:	200490fa 	slli	r2,r4,3
81129104:	00e04574 	movhi	r3,33045
81129108:	d9802217 	ldw	r6,136(sp)
8112910c:	18feda04 	addi	r3,r3,-1176
81129110:	1885883a 	add	r2,r3,r2
81129114:	14000017 	ldw	r16,0(r2)
81129118:	14400117 	ldw	r17,4(r2)
8112911c:	30016316 	blt	r6,zero,811296ac <_dtoa_r+0xd2c>
81129120:	800d883a 	mov	r6,r16
81129124:	880f883a 	mov	r7,r17
81129128:	9009883a 	mov	r4,r18
8112912c:	980b883a 	mov	r5,r19
81129130:	11349400 	call	81134940 <__divdf3>
81129134:	180b883a 	mov	r5,r3
81129138:	1009883a 	mov	r4,r2
8112913c:	11201d40 	call	811201d4 <__fixdfsi>
81129140:	1009883a 	mov	r4,r2
81129144:	102b883a 	mov	r21,r2
81129148:	11202540 	call	81120254 <__floatsidf>
8112914c:	800d883a 	mov	r6,r16
81129150:	880f883a 	mov	r7,r17
81129154:	1009883a 	mov	r4,r2
81129158:	180b883a 	mov	r5,r3
8112915c:	111f1b00 	call	8111f1b0 <__muldf3>
81129160:	100d883a 	mov	r6,r2
81129164:	180f883a 	mov	r7,r3
81129168:	9009883a 	mov	r4,r18
8112916c:	980b883a 	mov	r5,r19
81129170:	111f8d00 	call	8111f8d0 <__subdf3>
81129174:	d9c00717 	ldw	r7,28(sp)
81129178:	1009883a 	mov	r4,r2
8112917c:	a8800c04 	addi	r2,r21,48
81129180:	38800005 	stb	r2,0(r7)
81129184:	3dc00044 	addi	r23,r7,1
81129188:	d9c00617 	ldw	r7,24(sp)
8112918c:	01800044 	movi	r6,1
81129190:	180b883a 	mov	r5,r3
81129194:	2005883a 	mov	r2,r4
81129198:	39803826 	beq	r7,r6,8112927c <_dtoa_r+0x8fc>
8112919c:	000d883a 	mov	r6,zero
811291a0:	01d00934 	movhi	r7,16420
811291a4:	111f1b00 	call	8111f1b0 <__muldf3>
811291a8:	000d883a 	mov	r6,zero
811291ac:	000f883a 	mov	r7,zero
811291b0:	1009883a 	mov	r4,r2
811291b4:	180b883a 	mov	r5,r3
811291b8:	1025883a 	mov	r18,r2
811291bc:	1827883a 	mov	r19,r3
811291c0:	11352300 	call	81135230 <__eqdf2>
811291c4:	103f9a26 	beq	r2,zero,81129030 <__reset+0xfb109030>
811291c8:	d9c00617 	ldw	r7,24(sp)
811291cc:	d8c00717 	ldw	r3,28(sp)
811291d0:	b829883a 	mov	r20,r23
811291d4:	38bfffc4 	addi	r2,r7,-1
811291d8:	18ad883a 	add	r22,r3,r2
811291dc:	00000a06 	br	81129208 <_dtoa_r+0x888>
811291e0:	111f1b00 	call	8111f1b0 <__muldf3>
811291e4:	000d883a 	mov	r6,zero
811291e8:	000f883a 	mov	r7,zero
811291ec:	1009883a 	mov	r4,r2
811291f0:	180b883a 	mov	r5,r3
811291f4:	1025883a 	mov	r18,r2
811291f8:	1827883a 	mov	r19,r3
811291fc:	b829883a 	mov	r20,r23
81129200:	11352300 	call	81135230 <__eqdf2>
81129204:	103f8a26 	beq	r2,zero,81129030 <__reset+0xfb109030>
81129208:	800d883a 	mov	r6,r16
8112920c:	880f883a 	mov	r7,r17
81129210:	9009883a 	mov	r4,r18
81129214:	980b883a 	mov	r5,r19
81129218:	11349400 	call	81134940 <__divdf3>
8112921c:	180b883a 	mov	r5,r3
81129220:	1009883a 	mov	r4,r2
81129224:	11201d40 	call	811201d4 <__fixdfsi>
81129228:	1009883a 	mov	r4,r2
8112922c:	102b883a 	mov	r21,r2
81129230:	11202540 	call	81120254 <__floatsidf>
81129234:	800d883a 	mov	r6,r16
81129238:	880f883a 	mov	r7,r17
8112923c:	1009883a 	mov	r4,r2
81129240:	180b883a 	mov	r5,r3
81129244:	111f1b00 	call	8111f1b0 <__muldf3>
81129248:	100d883a 	mov	r6,r2
8112924c:	180f883a 	mov	r7,r3
81129250:	9009883a 	mov	r4,r18
81129254:	980b883a 	mov	r5,r19
81129258:	111f8d00 	call	8111f8d0 <__subdf3>
8112925c:	aa000c04 	addi	r8,r21,48
81129260:	a2000005 	stb	r8,0(r20)
81129264:	000d883a 	mov	r6,zero
81129268:	01d00934 	movhi	r7,16420
8112926c:	1009883a 	mov	r4,r2
81129270:	180b883a 	mov	r5,r3
81129274:	a5c00044 	addi	r23,r20,1
81129278:	b53fd91e 	bne	r22,r20,811291e0 <__reset+0xfb1091e0>
8112927c:	100d883a 	mov	r6,r2
81129280:	180f883a 	mov	r7,r3
81129284:	1009883a 	mov	r4,r2
81129288:	180b883a 	mov	r5,r3
8112928c:	113408c0 	call	8113408c <__adddf3>
81129290:	100d883a 	mov	r6,r2
81129294:	180f883a 	mov	r7,r3
81129298:	8009883a 	mov	r4,r16
8112929c:	880b883a 	mov	r5,r17
811292a0:	1027883a 	mov	r19,r2
811292a4:	1825883a 	mov	r18,r3
811292a8:	11352b80 	call	811352b8 <__ledf2>
811292ac:	10000816 	blt	r2,zero,811292d0 <_dtoa_r+0x950>
811292b0:	980d883a 	mov	r6,r19
811292b4:	900f883a 	mov	r7,r18
811292b8:	8009883a 	mov	r4,r16
811292bc:	880b883a 	mov	r5,r17
811292c0:	11352300 	call	81135230 <__eqdf2>
811292c4:	103f5a1e 	bne	r2,zero,81129030 <__reset+0xfb109030>
811292c8:	ad40004c 	andi	r21,r21,1
811292cc:	a83f5826 	beq	r21,zero,81129030 <__reset+0xfb109030>
811292d0:	bd3fffc3 	ldbu	r20,-1(r23)
811292d4:	b8bfffc4 	addi	r2,r23,-1
811292d8:	1007883a 	mov	r3,r2
811292dc:	01400e44 	movi	r5,57
811292e0:	d9800717 	ldw	r6,28(sp)
811292e4:	00000506 	br	811292fc <_dtoa_r+0x97c>
811292e8:	18ffffc4 	addi	r3,r3,-1
811292ec:	11824726 	beq	r2,r6,81129c0c <_dtoa_r+0x128c>
811292f0:	1d000003 	ldbu	r20,0(r3)
811292f4:	102f883a 	mov	r23,r2
811292f8:	10bfffc4 	addi	r2,r2,-1
811292fc:	a1003fcc 	andi	r4,r20,255
81129300:	2100201c 	xori	r4,r4,128
81129304:	213fe004 	addi	r4,r4,-128
81129308:	217ff726 	beq	r4,r5,811292e8 <__reset+0xfb1092e8>
8112930c:	a2000044 	addi	r8,r20,1
81129310:	12000005 	stb	r8,0(r2)
81129314:	003f4606 	br	81129030 <__reset+0xfb109030>
81129318:	d9000b17 	ldw	r4,44(sp)
8112931c:	2000c826 	beq	r4,zero,81129640 <_dtoa_r+0xcc0>
81129320:	d9800317 	ldw	r6,12(sp)
81129324:	00c00044 	movi	r3,1
81129328:	1980f90e 	bge	r3,r6,81129710 <_dtoa_r+0xd90>
8112932c:	d8800617 	ldw	r2,24(sp)
81129330:	d8c00a17 	ldw	r3,40(sp)
81129334:	157fffc4 	addi	r21,r2,-1
81129338:	1d41f316 	blt	r3,r21,81129b08 <_dtoa_r+0x1188>
8112933c:	1d6bc83a 	sub	r21,r3,r21
81129340:	d9c00617 	ldw	r7,24(sp)
81129344:	3802aa16 	blt	r7,zero,81129df0 <_dtoa_r+0x1470>
81129348:	dd000817 	ldw	r20,32(sp)
8112934c:	d8800617 	ldw	r2,24(sp)
81129350:	d8c00817 	ldw	r3,32(sp)
81129354:	01400044 	movi	r5,1
81129358:	e009883a 	mov	r4,fp
8112935c:	1887883a 	add	r3,r3,r2
81129360:	d8c00815 	stw	r3,32(sp)
81129364:	b0ad883a 	add	r22,r22,r2
81129368:	112bebc0 	call	8112bebc <__i2b>
8112936c:	1023883a 	mov	r17,r2
81129370:	a0000826 	beq	r20,zero,81129394 <_dtoa_r+0xa14>
81129374:	0580070e 	bge	zero,r22,81129394 <_dtoa_r+0xa14>
81129378:	a005883a 	mov	r2,r20
8112937c:	b500b916 	blt	r22,r20,81129664 <_dtoa_r+0xce4>
81129380:	d9000817 	ldw	r4,32(sp)
81129384:	a0a9c83a 	sub	r20,r20,r2
81129388:	b0adc83a 	sub	r22,r22,r2
8112938c:	2089c83a 	sub	r4,r4,r2
81129390:	d9000815 	stw	r4,32(sp)
81129394:	d9800a17 	ldw	r6,40(sp)
81129398:	0181810e 	bge	zero,r6,811299a0 <_dtoa_r+0x1020>
8112939c:	d9c00b17 	ldw	r7,44(sp)
811293a0:	3800b326 	beq	r7,zero,81129670 <_dtoa_r+0xcf0>
811293a4:	a800b226 	beq	r21,zero,81129670 <_dtoa_r+0xcf0>
811293a8:	880b883a 	mov	r5,r17
811293ac:	a80d883a 	mov	r6,r21
811293b0:	e009883a 	mov	r4,fp
811293b4:	112c1000 	call	8112c100 <__pow5mult>
811293b8:	d9800917 	ldw	r6,36(sp)
811293bc:	100b883a 	mov	r5,r2
811293c0:	e009883a 	mov	r4,fp
811293c4:	1023883a 	mov	r17,r2
811293c8:	112bf000 	call	8112bf00 <__multiply>
811293cc:	1021883a 	mov	r16,r2
811293d0:	d8800a17 	ldw	r2,40(sp)
811293d4:	d9400917 	ldw	r5,36(sp)
811293d8:	e009883a 	mov	r4,fp
811293dc:	1545c83a 	sub	r2,r2,r21
811293e0:	d8800a15 	stw	r2,40(sp)
811293e4:	112bb480 	call	8112bb48 <_Bfree>
811293e8:	d8c00a17 	ldw	r3,40(sp)
811293ec:	18009f1e 	bne	r3,zero,8112966c <_dtoa_r+0xcec>
811293f0:	05c00044 	movi	r23,1
811293f4:	e009883a 	mov	r4,fp
811293f8:	b80b883a 	mov	r5,r23
811293fc:	112bebc0 	call	8112bebc <__i2b>
81129400:	d9000d17 	ldw	r4,52(sp)
81129404:	102b883a 	mov	r21,r2
81129408:	2000ce26 	beq	r4,zero,81129744 <_dtoa_r+0xdc4>
8112940c:	200d883a 	mov	r6,r4
81129410:	100b883a 	mov	r5,r2
81129414:	e009883a 	mov	r4,fp
81129418:	112c1000 	call	8112c100 <__pow5mult>
8112941c:	d9800317 	ldw	r6,12(sp)
81129420:	102b883a 	mov	r21,r2
81129424:	b981810e 	bge	r23,r6,81129a2c <_dtoa_r+0x10ac>
81129428:	0027883a 	mov	r19,zero
8112942c:	a8800417 	ldw	r2,16(r21)
81129430:	05c00804 	movi	r23,32
81129434:	10800104 	addi	r2,r2,4
81129438:	1085883a 	add	r2,r2,r2
8112943c:	1085883a 	add	r2,r2,r2
81129440:	a885883a 	add	r2,r21,r2
81129444:	11000017 	ldw	r4,0(r2)
81129448:	112bda40 	call	8112bda4 <__hi0bits>
8112944c:	b885c83a 	sub	r2,r23,r2
81129450:	1585883a 	add	r2,r2,r22
81129454:	108007cc 	andi	r2,r2,31
81129458:	1000b326 	beq	r2,zero,81129728 <_dtoa_r+0xda8>
8112945c:	00c00804 	movi	r3,32
81129460:	1887c83a 	sub	r3,r3,r2
81129464:	01000104 	movi	r4,4
81129468:	20c2cd0e 	bge	r4,r3,81129fa0 <_dtoa_r+0x1620>
8112946c:	00c00704 	movi	r3,28
81129470:	1885c83a 	sub	r2,r3,r2
81129474:	d8c00817 	ldw	r3,32(sp)
81129478:	a0a9883a 	add	r20,r20,r2
8112947c:	b0ad883a 	add	r22,r22,r2
81129480:	1887883a 	add	r3,r3,r2
81129484:	d8c00815 	stw	r3,32(sp)
81129488:	d9800817 	ldw	r6,32(sp)
8112948c:	0180040e 	bge	zero,r6,811294a0 <_dtoa_r+0xb20>
81129490:	800b883a 	mov	r5,r16
81129494:	e009883a 	mov	r4,fp
81129498:	112c2480 	call	8112c248 <__lshift>
8112949c:	1021883a 	mov	r16,r2
811294a0:	0580050e 	bge	zero,r22,811294b8 <_dtoa_r+0xb38>
811294a4:	a80b883a 	mov	r5,r21
811294a8:	b00d883a 	mov	r6,r22
811294ac:	e009883a 	mov	r4,fp
811294b0:	112c2480 	call	8112c248 <__lshift>
811294b4:	102b883a 	mov	r21,r2
811294b8:	d9c00e17 	ldw	r7,56(sp)
811294bc:	3801211e 	bne	r7,zero,81129944 <_dtoa_r+0xfc4>
811294c0:	d9800617 	ldw	r6,24(sp)
811294c4:	0181380e 	bge	zero,r6,811299a8 <_dtoa_r+0x1028>
811294c8:	d8c00b17 	ldw	r3,44(sp)
811294cc:	1800ab1e 	bne	r3,zero,8112977c <_dtoa_r+0xdfc>
811294d0:	dc800717 	ldw	r18,28(sp)
811294d4:	dcc00617 	ldw	r19,24(sp)
811294d8:	9029883a 	mov	r20,r18
811294dc:	00000206 	br	811294e8 <_dtoa_r+0xb68>
811294e0:	112bb700 	call	8112bb70 <__multadd>
811294e4:	1021883a 	mov	r16,r2
811294e8:	a80b883a 	mov	r5,r21
811294ec:	8009883a 	mov	r4,r16
811294f0:	11287780 	call	81128778 <quorem>
811294f4:	10800c04 	addi	r2,r2,48
811294f8:	90800005 	stb	r2,0(r18)
811294fc:	94800044 	addi	r18,r18,1
81129500:	9507c83a 	sub	r3,r18,r20
81129504:	000f883a 	mov	r7,zero
81129508:	01800284 	movi	r6,10
8112950c:	800b883a 	mov	r5,r16
81129510:	e009883a 	mov	r4,fp
81129514:	1cfff216 	blt	r3,r19,811294e0 <__reset+0xfb1094e0>
81129518:	1011883a 	mov	r8,r2
8112951c:	d8800617 	ldw	r2,24(sp)
81129520:	0082370e 	bge	zero,r2,81129e00 <_dtoa_r+0x1480>
81129524:	d9000717 	ldw	r4,28(sp)
81129528:	0025883a 	mov	r18,zero
8112952c:	20af883a 	add	r23,r4,r2
81129530:	01800044 	movi	r6,1
81129534:	800b883a 	mov	r5,r16
81129538:	e009883a 	mov	r4,fp
8112953c:	da001715 	stw	r8,92(sp)
81129540:	112c2480 	call	8112c248 <__lshift>
81129544:	a80b883a 	mov	r5,r21
81129548:	1009883a 	mov	r4,r2
8112954c:	d8800915 	stw	r2,36(sp)
81129550:	112c3980 	call	8112c398 <__mcmp>
81129554:	da001717 	ldw	r8,92(sp)
81129558:	0081800e 	bge	zero,r2,81129b5c <_dtoa_r+0x11dc>
8112955c:	b93fffc3 	ldbu	r4,-1(r23)
81129560:	b8bfffc4 	addi	r2,r23,-1
81129564:	1007883a 	mov	r3,r2
81129568:	01800e44 	movi	r6,57
8112956c:	d9c00717 	ldw	r7,28(sp)
81129570:	00000506 	br	81129588 <_dtoa_r+0xc08>
81129574:	18ffffc4 	addi	r3,r3,-1
81129578:	11c12326 	beq	r2,r7,81129a08 <_dtoa_r+0x1088>
8112957c:	19000003 	ldbu	r4,0(r3)
81129580:	102f883a 	mov	r23,r2
81129584:	10bfffc4 	addi	r2,r2,-1
81129588:	21403fcc 	andi	r5,r4,255
8112958c:	2940201c 	xori	r5,r5,128
81129590:	297fe004 	addi	r5,r5,-128
81129594:	29bff726 	beq	r5,r6,81129574 <__reset+0xfb109574>
81129598:	21000044 	addi	r4,r4,1
8112959c:	11000005 	stb	r4,0(r2)
811295a0:	a80b883a 	mov	r5,r21
811295a4:	e009883a 	mov	r4,fp
811295a8:	112bb480 	call	8112bb48 <_Bfree>
811295ac:	883ea026 	beq	r17,zero,81129030 <__reset+0xfb109030>
811295b0:	90000426 	beq	r18,zero,811295c4 <_dtoa_r+0xc44>
811295b4:	94400326 	beq	r18,r17,811295c4 <_dtoa_r+0xc44>
811295b8:	900b883a 	mov	r5,r18
811295bc:	e009883a 	mov	r4,fp
811295c0:	112bb480 	call	8112bb48 <_Bfree>
811295c4:	880b883a 	mov	r5,r17
811295c8:	e009883a 	mov	r4,fp
811295cc:	112bb480 	call	8112bb48 <_Bfree>
811295d0:	003e9706 	br	81129030 <__reset+0xfb109030>
811295d4:	01800044 	movi	r6,1
811295d8:	d9800e15 	stw	r6,56(sp)
811295dc:	003d9606 	br	81128c38 <__reset+0xfb108c38>
811295e0:	d8800817 	ldw	r2,32(sp)
811295e4:	d8c00517 	ldw	r3,20(sp)
811295e8:	d8000d15 	stw	zero,52(sp)
811295ec:	10c5c83a 	sub	r2,r2,r3
811295f0:	00c9c83a 	sub	r4,zero,r3
811295f4:	d8800815 	stw	r2,32(sp)
811295f8:	d9000a15 	stw	r4,40(sp)
811295fc:	003d9706 	br	81128c5c <__reset+0xfb108c5c>
81129600:	05adc83a 	sub	r22,zero,r22
81129604:	dd800815 	stw	r22,32(sp)
81129608:	002d883a 	mov	r22,zero
8112960c:	003d8e06 	br	81128c48 <__reset+0xfb108c48>
81129610:	d9000517 	ldw	r4,20(sp)
81129614:	11202540 	call	81120254 <__floatsidf>
81129618:	100d883a 	mov	r6,r2
8112961c:	180f883a 	mov	r7,r3
81129620:	a009883a 	mov	r4,r20
81129624:	880b883a 	mov	r5,r17
81129628:	11352300 	call	81135230 <__eqdf2>
8112962c:	103d7126 	beq	r2,zero,81128bf4 <__reset+0xfb108bf4>
81129630:	d9c00517 	ldw	r7,20(sp)
81129634:	39ffffc4 	addi	r7,r7,-1
81129638:	d9c00515 	stw	r7,20(sp)
8112963c:	003d6d06 	br	81128bf4 <__reset+0xfb108bf4>
81129640:	dd400a17 	ldw	r21,40(sp)
81129644:	dd000817 	ldw	r20,32(sp)
81129648:	0023883a 	mov	r17,zero
8112964c:	003f4806 	br	81129370 <__reset+0xfb109370>
81129650:	10e3c83a 	sub	r17,r2,r3
81129654:	9448983a 	sll	r4,r18,r17
81129658:	003d3206 	br	81128b24 <__reset+0xfb108b24>
8112965c:	d8000e15 	stw	zero,56(sp)
81129660:	003d7506 	br	81128c38 <__reset+0xfb108c38>
81129664:	b005883a 	mov	r2,r22
81129668:	003f4506 	br	81129380 <__reset+0xfb109380>
8112966c:	dc000915 	stw	r16,36(sp)
81129670:	d9800a17 	ldw	r6,40(sp)
81129674:	d9400917 	ldw	r5,36(sp)
81129678:	e009883a 	mov	r4,fp
8112967c:	112c1000 	call	8112c100 <__pow5mult>
81129680:	1021883a 	mov	r16,r2
81129684:	003f5a06 	br	811293f0 <__reset+0xfb1093f0>
81129688:	01c00044 	movi	r7,1
8112968c:	d9c00b15 	stw	r7,44(sp)
81129690:	d8802217 	ldw	r2,136(sp)
81129694:	0081280e 	bge	zero,r2,81129b38 <_dtoa_r+0x11b8>
81129698:	100d883a 	mov	r6,r2
8112969c:	1021883a 	mov	r16,r2
811296a0:	d8800c15 	stw	r2,48(sp)
811296a4:	d8800615 	stw	r2,24(sp)
811296a8:	003d8806 	br	81128ccc <__reset+0xfb108ccc>
811296ac:	d8800617 	ldw	r2,24(sp)
811296b0:	00be9b16 	blt	zero,r2,81129120 <__reset+0xfb109120>
811296b4:	10010f1e 	bne	r2,zero,81129af4 <_dtoa_r+0x1174>
811296b8:	880b883a 	mov	r5,r17
811296bc:	000d883a 	mov	r6,zero
811296c0:	01d00534 	movhi	r7,16404
811296c4:	8009883a 	mov	r4,r16
811296c8:	111f1b00 	call	8111f1b0 <__muldf3>
811296cc:	900d883a 	mov	r6,r18
811296d0:	980f883a 	mov	r7,r19
811296d4:	1009883a 	mov	r4,r2
811296d8:	180b883a 	mov	r5,r3
811296dc:	111f0d40 	call	8111f0d4 <__gedf2>
811296e0:	002b883a 	mov	r21,zero
811296e4:	0023883a 	mov	r17,zero
811296e8:	1000bf16 	blt	r2,zero,811299e8 <_dtoa_r+0x1068>
811296ec:	d9802217 	ldw	r6,136(sp)
811296f0:	ddc00717 	ldw	r23,28(sp)
811296f4:	018c303a 	nor	r6,zero,r6
811296f8:	d9800515 	stw	r6,20(sp)
811296fc:	a80b883a 	mov	r5,r21
81129700:	e009883a 	mov	r4,fp
81129704:	112bb480 	call	8112bb48 <_Bfree>
81129708:	883e4926 	beq	r17,zero,81129030 <__reset+0xfb109030>
8112970c:	003fad06 	br	811295c4 <__reset+0xfb1095c4>
81129710:	d9c01117 	ldw	r7,68(sp)
81129714:	3801bc26 	beq	r7,zero,81129e08 <_dtoa_r+0x1488>
81129718:	10810cc4 	addi	r2,r2,1075
8112971c:	dd400a17 	ldw	r21,40(sp)
81129720:	dd000817 	ldw	r20,32(sp)
81129724:	003f0a06 	br	81129350 <__reset+0xfb109350>
81129728:	00800704 	movi	r2,28
8112972c:	d9000817 	ldw	r4,32(sp)
81129730:	a0a9883a 	add	r20,r20,r2
81129734:	b0ad883a 	add	r22,r22,r2
81129738:	2089883a 	add	r4,r4,r2
8112973c:	d9000815 	stw	r4,32(sp)
81129740:	003f5106 	br	81129488 <__reset+0xfb109488>
81129744:	d8c00317 	ldw	r3,12(sp)
81129748:	b8c1fc0e 	bge	r23,r3,81129f3c <_dtoa_r+0x15bc>
8112974c:	0027883a 	mov	r19,zero
81129750:	b805883a 	mov	r2,r23
81129754:	003f3e06 	br	81129450 <__reset+0xfb109450>
81129758:	880b883a 	mov	r5,r17
8112975c:	e009883a 	mov	r4,fp
81129760:	000f883a 	mov	r7,zero
81129764:	01800284 	movi	r6,10
81129768:	112bb700 	call	8112bb70 <__multadd>
8112976c:	d9000c17 	ldw	r4,48(sp)
81129770:	1023883a 	mov	r17,r2
81129774:	0102040e 	bge	zero,r4,81129f88 <_dtoa_r+0x1608>
81129778:	d9000615 	stw	r4,24(sp)
8112977c:	0500050e 	bge	zero,r20,81129794 <_dtoa_r+0xe14>
81129780:	880b883a 	mov	r5,r17
81129784:	a00d883a 	mov	r6,r20
81129788:	e009883a 	mov	r4,fp
8112978c:	112c2480 	call	8112c248 <__lshift>
81129790:	1023883a 	mov	r17,r2
81129794:	9801241e 	bne	r19,zero,81129c28 <_dtoa_r+0x12a8>
81129798:	8829883a 	mov	r20,r17
8112979c:	d9000617 	ldw	r4,24(sp)
811297a0:	dcc00717 	ldw	r19,28(sp)
811297a4:	9480004c 	andi	r18,r18,1
811297a8:	20bfffc4 	addi	r2,r4,-1
811297ac:	9885883a 	add	r2,r19,r2
811297b0:	d8800415 	stw	r2,16(sp)
811297b4:	dc800615 	stw	r18,24(sp)
811297b8:	a80b883a 	mov	r5,r21
811297bc:	8009883a 	mov	r4,r16
811297c0:	11287780 	call	81128778 <quorem>
811297c4:	880b883a 	mov	r5,r17
811297c8:	8009883a 	mov	r4,r16
811297cc:	102f883a 	mov	r23,r2
811297d0:	112c3980 	call	8112c398 <__mcmp>
811297d4:	a80b883a 	mov	r5,r21
811297d8:	a00d883a 	mov	r6,r20
811297dc:	e009883a 	mov	r4,fp
811297e0:	102d883a 	mov	r22,r2
811297e4:	112c3f80 	call	8112c3f8 <__mdiff>
811297e8:	1007883a 	mov	r3,r2
811297ec:	10800317 	ldw	r2,12(r2)
811297f0:	bc800c04 	addi	r18,r23,48
811297f4:	180b883a 	mov	r5,r3
811297f8:	10004e1e 	bne	r2,zero,81129934 <_dtoa_r+0xfb4>
811297fc:	8009883a 	mov	r4,r16
81129800:	d8c01615 	stw	r3,88(sp)
81129804:	112c3980 	call	8112c398 <__mcmp>
81129808:	d8c01617 	ldw	r3,88(sp)
8112980c:	e009883a 	mov	r4,fp
81129810:	d8801615 	stw	r2,88(sp)
81129814:	180b883a 	mov	r5,r3
81129818:	112bb480 	call	8112bb48 <_Bfree>
8112981c:	d8801617 	ldw	r2,88(sp)
81129820:	1000041e 	bne	r2,zero,81129834 <_dtoa_r+0xeb4>
81129824:	d9800317 	ldw	r6,12(sp)
81129828:	3000021e 	bne	r6,zero,81129834 <_dtoa_r+0xeb4>
8112982c:	d8c00617 	ldw	r3,24(sp)
81129830:	18003726 	beq	r3,zero,81129910 <_dtoa_r+0xf90>
81129834:	b0002016 	blt	r22,zero,811298b8 <_dtoa_r+0xf38>
81129838:	b000041e 	bne	r22,zero,8112984c <_dtoa_r+0xecc>
8112983c:	d9000317 	ldw	r4,12(sp)
81129840:	2000021e 	bne	r4,zero,8112984c <_dtoa_r+0xecc>
81129844:	d8c00617 	ldw	r3,24(sp)
81129848:	18001b26 	beq	r3,zero,811298b8 <_dtoa_r+0xf38>
8112984c:	00810716 	blt	zero,r2,81129c6c <_dtoa_r+0x12ec>
81129850:	d8c00417 	ldw	r3,16(sp)
81129854:	9d800044 	addi	r22,r19,1
81129858:	9c800005 	stb	r18,0(r19)
8112985c:	b02f883a 	mov	r23,r22
81129860:	98c10626 	beq	r19,r3,81129c7c <_dtoa_r+0x12fc>
81129864:	800b883a 	mov	r5,r16
81129868:	000f883a 	mov	r7,zero
8112986c:	01800284 	movi	r6,10
81129870:	e009883a 	mov	r4,fp
81129874:	112bb700 	call	8112bb70 <__multadd>
81129878:	1021883a 	mov	r16,r2
8112987c:	000f883a 	mov	r7,zero
81129880:	01800284 	movi	r6,10
81129884:	880b883a 	mov	r5,r17
81129888:	e009883a 	mov	r4,fp
8112988c:	8d002526 	beq	r17,r20,81129924 <_dtoa_r+0xfa4>
81129890:	112bb700 	call	8112bb70 <__multadd>
81129894:	a00b883a 	mov	r5,r20
81129898:	000f883a 	mov	r7,zero
8112989c:	01800284 	movi	r6,10
811298a0:	e009883a 	mov	r4,fp
811298a4:	1023883a 	mov	r17,r2
811298a8:	112bb700 	call	8112bb70 <__multadd>
811298ac:	1029883a 	mov	r20,r2
811298b0:	b027883a 	mov	r19,r22
811298b4:	003fc006 	br	811297b8 <__reset+0xfb1097b8>
811298b8:	9011883a 	mov	r8,r18
811298bc:	00800e0e 	bge	zero,r2,811298f8 <_dtoa_r+0xf78>
811298c0:	800b883a 	mov	r5,r16
811298c4:	01800044 	movi	r6,1
811298c8:	e009883a 	mov	r4,fp
811298cc:	da001715 	stw	r8,92(sp)
811298d0:	112c2480 	call	8112c248 <__lshift>
811298d4:	a80b883a 	mov	r5,r21
811298d8:	1009883a 	mov	r4,r2
811298dc:	1021883a 	mov	r16,r2
811298e0:	112c3980 	call	8112c398 <__mcmp>
811298e4:	da001717 	ldw	r8,92(sp)
811298e8:	0081960e 	bge	zero,r2,81129f44 <_dtoa_r+0x15c4>
811298ec:	00800e44 	movi	r2,57
811298f0:	40817026 	beq	r8,r2,81129eb4 <_dtoa_r+0x1534>
811298f4:	ba000c44 	addi	r8,r23,49
811298f8:	8825883a 	mov	r18,r17
811298fc:	9dc00044 	addi	r23,r19,1
81129900:	9a000005 	stb	r8,0(r19)
81129904:	a023883a 	mov	r17,r20
81129908:	dc000915 	stw	r16,36(sp)
8112990c:	003f2406 	br	811295a0 <__reset+0xfb1095a0>
81129910:	00800e44 	movi	r2,57
81129914:	9011883a 	mov	r8,r18
81129918:	90816626 	beq	r18,r2,81129eb4 <_dtoa_r+0x1534>
8112991c:	05bff516 	blt	zero,r22,811298f4 <__reset+0xfb1098f4>
81129920:	003ff506 	br	811298f8 <__reset+0xfb1098f8>
81129924:	112bb700 	call	8112bb70 <__multadd>
81129928:	1023883a 	mov	r17,r2
8112992c:	1029883a 	mov	r20,r2
81129930:	003fdf06 	br	811298b0 <__reset+0xfb1098b0>
81129934:	e009883a 	mov	r4,fp
81129938:	112bb480 	call	8112bb48 <_Bfree>
8112993c:	00800044 	movi	r2,1
81129940:	003fbc06 	br	81129834 <__reset+0xfb109834>
81129944:	a80b883a 	mov	r5,r21
81129948:	8009883a 	mov	r4,r16
8112994c:	112c3980 	call	8112c398 <__mcmp>
81129950:	103edb0e 	bge	r2,zero,811294c0 <__reset+0xfb1094c0>
81129954:	800b883a 	mov	r5,r16
81129958:	000f883a 	mov	r7,zero
8112995c:	01800284 	movi	r6,10
81129960:	e009883a 	mov	r4,fp
81129964:	112bb700 	call	8112bb70 <__multadd>
81129968:	1021883a 	mov	r16,r2
8112996c:	d8800517 	ldw	r2,20(sp)
81129970:	d8c00b17 	ldw	r3,44(sp)
81129974:	10bfffc4 	addi	r2,r2,-1
81129978:	d8800515 	stw	r2,20(sp)
8112997c:	183f761e 	bne	r3,zero,81129758 <__reset+0xfb109758>
81129980:	d9000c17 	ldw	r4,48(sp)
81129984:	0101730e 	bge	zero,r4,81129f54 <_dtoa_r+0x15d4>
81129988:	d9000615 	stw	r4,24(sp)
8112998c:	003ed006 	br	811294d0 <__reset+0xfb1094d0>
81129990:	00800084 	movi	r2,2
81129994:	3081861e 	bne	r6,r2,81129fb0 <_dtoa_r+0x1630>
81129998:	d8000b15 	stw	zero,44(sp)
8112999c:	003f3c06 	br	81129690 <__reset+0xfb109690>
811299a0:	dc000917 	ldw	r16,36(sp)
811299a4:	003e9206 	br	811293f0 <__reset+0xfb1093f0>
811299a8:	d9c00317 	ldw	r7,12(sp)
811299ac:	00800084 	movi	r2,2
811299b0:	11fec50e 	bge	r2,r7,811294c8 <__reset+0xfb1094c8>
811299b4:	d9000617 	ldw	r4,24(sp)
811299b8:	20013c1e 	bne	r4,zero,81129eac <_dtoa_r+0x152c>
811299bc:	a80b883a 	mov	r5,r21
811299c0:	000f883a 	mov	r7,zero
811299c4:	01800144 	movi	r6,5
811299c8:	e009883a 	mov	r4,fp
811299cc:	112bb700 	call	8112bb70 <__multadd>
811299d0:	100b883a 	mov	r5,r2
811299d4:	8009883a 	mov	r4,r16
811299d8:	102b883a 	mov	r21,r2
811299dc:	112c3980 	call	8112c398 <__mcmp>
811299e0:	dc000915 	stw	r16,36(sp)
811299e4:	00bf410e 	bge	zero,r2,811296ec <__reset+0xfb1096ec>
811299e8:	d9c00717 	ldw	r7,28(sp)
811299ec:	00800c44 	movi	r2,49
811299f0:	38800005 	stb	r2,0(r7)
811299f4:	d8800517 	ldw	r2,20(sp)
811299f8:	3dc00044 	addi	r23,r7,1
811299fc:	10800044 	addi	r2,r2,1
81129a00:	d8800515 	stw	r2,20(sp)
81129a04:	003f3d06 	br	811296fc <__reset+0xfb1096fc>
81129a08:	d9800517 	ldw	r6,20(sp)
81129a0c:	d9c00717 	ldw	r7,28(sp)
81129a10:	00800c44 	movi	r2,49
81129a14:	31800044 	addi	r6,r6,1
81129a18:	d9800515 	stw	r6,20(sp)
81129a1c:	38800005 	stb	r2,0(r7)
81129a20:	003edf06 	br	811295a0 <__reset+0xfb1095a0>
81129a24:	d8000b15 	stw	zero,44(sp)
81129a28:	003c9f06 	br	81128ca8 <__reset+0xfb108ca8>
81129a2c:	903e7e1e 	bne	r18,zero,81129428 <__reset+0xfb109428>
81129a30:	00800434 	movhi	r2,16
81129a34:	10bfffc4 	addi	r2,r2,-1
81129a38:	9884703a 	and	r2,r19,r2
81129a3c:	1000ea1e 	bne	r2,zero,81129de8 <_dtoa_r+0x1468>
81129a40:	9cdffc2c 	andhi	r19,r19,32752
81129a44:	9800e826 	beq	r19,zero,81129de8 <_dtoa_r+0x1468>
81129a48:	d9c00817 	ldw	r7,32(sp)
81129a4c:	b5800044 	addi	r22,r22,1
81129a50:	04c00044 	movi	r19,1
81129a54:	39c00044 	addi	r7,r7,1
81129a58:	d9c00815 	stw	r7,32(sp)
81129a5c:	d8800d17 	ldw	r2,52(sp)
81129a60:	103e721e 	bne	r2,zero,8112942c <__reset+0xfb10942c>
81129a64:	00800044 	movi	r2,1
81129a68:	003e7906 	br	81129450 <__reset+0xfb109450>
81129a6c:	8009883a 	mov	r4,r16
81129a70:	11202540 	call	81120254 <__floatsidf>
81129a74:	d9800f17 	ldw	r6,60(sp)
81129a78:	d9c01017 	ldw	r7,64(sp)
81129a7c:	1009883a 	mov	r4,r2
81129a80:	180b883a 	mov	r5,r3
81129a84:	111f1b00 	call	8111f1b0 <__muldf3>
81129a88:	000d883a 	mov	r6,zero
81129a8c:	01d00734 	movhi	r7,16412
81129a90:	1009883a 	mov	r4,r2
81129a94:	180b883a 	mov	r5,r3
81129a98:	113408c0 	call	8113408c <__adddf3>
81129a9c:	047f3034 	movhi	r17,64704
81129aa0:	1021883a 	mov	r16,r2
81129aa4:	1c63883a 	add	r17,r3,r17
81129aa8:	d9000f17 	ldw	r4,60(sp)
81129aac:	d9401017 	ldw	r5,64(sp)
81129ab0:	000d883a 	mov	r6,zero
81129ab4:	01d00534 	movhi	r7,16404
81129ab8:	111f8d00 	call	8111f8d0 <__subdf3>
81129abc:	800d883a 	mov	r6,r16
81129ac0:	880f883a 	mov	r7,r17
81129ac4:	1009883a 	mov	r4,r2
81129ac8:	180b883a 	mov	r5,r3
81129acc:	102b883a 	mov	r21,r2
81129ad0:	1829883a 	mov	r20,r3
81129ad4:	111f0d40 	call	8111f0d4 <__gedf2>
81129ad8:	00806c16 	blt	zero,r2,81129c8c <_dtoa_r+0x130c>
81129adc:	89e0003c 	xorhi	r7,r17,32768
81129ae0:	800d883a 	mov	r6,r16
81129ae4:	a809883a 	mov	r4,r21
81129ae8:	a00b883a 	mov	r5,r20
81129aec:	11352b80 	call	811352b8 <__ledf2>
81129af0:	103d7e0e 	bge	r2,zero,811290ec <__reset+0xfb1090ec>
81129af4:	002b883a 	mov	r21,zero
81129af8:	0023883a 	mov	r17,zero
81129afc:	003efb06 	br	811296ec <__reset+0xfb1096ec>
81129b00:	d8800717 	ldw	r2,28(sp)
81129b04:	003bd006 	br	81128a48 <__reset+0xfb108a48>
81129b08:	d9000a17 	ldw	r4,40(sp)
81129b0c:	d9800d17 	ldw	r6,52(sp)
81129b10:	dd400a15 	stw	r21,40(sp)
81129b14:	a905c83a 	sub	r2,r21,r4
81129b18:	308d883a 	add	r6,r6,r2
81129b1c:	d9800d15 	stw	r6,52(sp)
81129b20:	002b883a 	mov	r21,zero
81129b24:	003e0606 	br	81129340 <__reset+0xfb109340>
81129b28:	9023883a 	mov	r17,r18
81129b2c:	9829883a 	mov	r20,r19
81129b30:	04000084 	movi	r16,2
81129b34:	003c9206 	br	81128d80 <__reset+0xfb108d80>
81129b38:	04000044 	movi	r16,1
81129b3c:	dc000c15 	stw	r16,48(sp)
81129b40:	dc000615 	stw	r16,24(sp)
81129b44:	dc002215 	stw	r16,136(sp)
81129b48:	e0001115 	stw	zero,68(fp)
81129b4c:	000b883a 	mov	r5,zero
81129b50:	003c6906 	br	81128cf8 <__reset+0xfb108cf8>
81129b54:	3021883a 	mov	r16,r6
81129b58:	003ffb06 	br	81129b48 <__reset+0xfb109b48>
81129b5c:	1000021e 	bne	r2,zero,81129b68 <_dtoa_r+0x11e8>
81129b60:	4200004c 	andi	r8,r8,1
81129b64:	403e7d1e 	bne	r8,zero,8112955c <__reset+0xfb10955c>
81129b68:	01000c04 	movi	r4,48
81129b6c:	00000106 	br	81129b74 <_dtoa_r+0x11f4>
81129b70:	102f883a 	mov	r23,r2
81129b74:	b8bfffc4 	addi	r2,r23,-1
81129b78:	10c00007 	ldb	r3,0(r2)
81129b7c:	193ffc26 	beq	r3,r4,81129b70 <__reset+0xfb109b70>
81129b80:	003e8706 	br	811295a0 <__reset+0xfb1095a0>
81129b84:	d8800517 	ldw	r2,20(sp)
81129b88:	00a3c83a 	sub	r17,zero,r2
81129b8c:	8800a426 	beq	r17,zero,81129e20 <_dtoa_r+0x14a0>
81129b90:	888003cc 	andi	r2,r17,15
81129b94:	100490fa 	slli	r2,r2,3
81129b98:	00e04574 	movhi	r3,33045
81129b9c:	18feda04 	addi	r3,r3,-1176
81129ba0:	1885883a 	add	r2,r3,r2
81129ba4:	11800017 	ldw	r6,0(r2)
81129ba8:	11c00117 	ldw	r7,4(r2)
81129bac:	9009883a 	mov	r4,r18
81129bb0:	980b883a 	mov	r5,r19
81129bb4:	8823d13a 	srai	r17,r17,4
81129bb8:	111f1b00 	call	8111f1b0 <__muldf3>
81129bbc:	d8800f15 	stw	r2,60(sp)
81129bc0:	d8c01015 	stw	r3,64(sp)
81129bc4:	8800e826 	beq	r17,zero,81129f68 <_dtoa_r+0x15e8>
81129bc8:	05204574 	movhi	r20,33045
81129bcc:	a53ed004 	addi	r20,r20,-1216
81129bd0:	04000084 	movi	r16,2
81129bd4:	8980004c 	andi	r6,r17,1
81129bd8:	1009883a 	mov	r4,r2
81129bdc:	8823d07a 	srai	r17,r17,1
81129be0:	180b883a 	mov	r5,r3
81129be4:	30000426 	beq	r6,zero,81129bf8 <_dtoa_r+0x1278>
81129be8:	a1800017 	ldw	r6,0(r20)
81129bec:	a1c00117 	ldw	r7,4(r20)
81129bf0:	84000044 	addi	r16,r16,1
81129bf4:	111f1b00 	call	8111f1b0 <__muldf3>
81129bf8:	a5000204 	addi	r20,r20,8
81129bfc:	883ff51e 	bne	r17,zero,81129bd4 <__reset+0xfb109bd4>
81129c00:	d8800f15 	stw	r2,60(sp)
81129c04:	d8c01015 	stw	r3,64(sp)
81129c08:	003c7606 	br	81128de4 <__reset+0xfb108de4>
81129c0c:	00c00c04 	movi	r3,48
81129c10:	10c00005 	stb	r3,0(r2)
81129c14:	d8c00517 	ldw	r3,20(sp)
81129c18:	bd3fffc3 	ldbu	r20,-1(r23)
81129c1c:	18c00044 	addi	r3,r3,1
81129c20:	d8c00515 	stw	r3,20(sp)
81129c24:	003db906 	br	8112930c <__reset+0xfb10930c>
81129c28:	89400117 	ldw	r5,4(r17)
81129c2c:	e009883a 	mov	r4,fp
81129c30:	112ba980 	call	8112ba98 <_Balloc>
81129c34:	89800417 	ldw	r6,16(r17)
81129c38:	89400304 	addi	r5,r17,12
81129c3c:	11000304 	addi	r4,r2,12
81129c40:	31800084 	addi	r6,r6,2
81129c44:	318d883a 	add	r6,r6,r6
81129c48:	318d883a 	add	r6,r6,r6
81129c4c:	1027883a 	mov	r19,r2
81129c50:	11218680 	call	81121868 <memcpy>
81129c54:	01800044 	movi	r6,1
81129c58:	980b883a 	mov	r5,r19
81129c5c:	e009883a 	mov	r4,fp
81129c60:	112c2480 	call	8112c248 <__lshift>
81129c64:	1029883a 	mov	r20,r2
81129c68:	003ecc06 	br	8112979c <__reset+0xfb10979c>
81129c6c:	00800e44 	movi	r2,57
81129c70:	90809026 	beq	r18,r2,81129eb4 <_dtoa_r+0x1534>
81129c74:	92000044 	addi	r8,r18,1
81129c78:	003f1f06 	br	811298f8 <__reset+0xfb1098f8>
81129c7c:	9011883a 	mov	r8,r18
81129c80:	8825883a 	mov	r18,r17
81129c84:	a023883a 	mov	r17,r20
81129c88:	003e2906 	br	81129530 <__reset+0xfb109530>
81129c8c:	002b883a 	mov	r21,zero
81129c90:	0023883a 	mov	r17,zero
81129c94:	003f5406 	br	811299e8 <__reset+0xfb1099e8>
81129c98:	61bfffc4 	addi	r6,r12,-1
81129c9c:	300490fa 	slli	r2,r6,3
81129ca0:	00e04574 	movhi	r3,33045
81129ca4:	18feda04 	addi	r3,r3,-1176
81129ca8:	1885883a 	add	r2,r3,r2
81129cac:	11000017 	ldw	r4,0(r2)
81129cb0:	11400117 	ldw	r5,4(r2)
81129cb4:	d8800717 	ldw	r2,28(sp)
81129cb8:	880f883a 	mov	r7,r17
81129cbc:	d9801215 	stw	r6,72(sp)
81129cc0:	800d883a 	mov	r6,r16
81129cc4:	db001615 	stw	r12,88(sp)
81129cc8:	15c00044 	addi	r23,r2,1
81129ccc:	111f1b00 	call	8111f1b0 <__muldf3>
81129cd0:	d9401017 	ldw	r5,64(sp)
81129cd4:	d9000f17 	ldw	r4,60(sp)
81129cd8:	d8c01515 	stw	r3,84(sp)
81129cdc:	d8801415 	stw	r2,80(sp)
81129ce0:	11201d40 	call	811201d4 <__fixdfsi>
81129ce4:	1009883a 	mov	r4,r2
81129ce8:	1021883a 	mov	r16,r2
81129cec:	11202540 	call	81120254 <__floatsidf>
81129cf0:	d9000f17 	ldw	r4,60(sp)
81129cf4:	d9401017 	ldw	r5,64(sp)
81129cf8:	100d883a 	mov	r6,r2
81129cfc:	180f883a 	mov	r7,r3
81129d00:	111f8d00 	call	8111f8d0 <__subdf3>
81129d04:	1829883a 	mov	r20,r3
81129d08:	d8c00717 	ldw	r3,28(sp)
81129d0c:	84000c04 	addi	r16,r16,48
81129d10:	1023883a 	mov	r17,r2
81129d14:	1c000005 	stb	r16,0(r3)
81129d18:	db001617 	ldw	r12,88(sp)
81129d1c:	00800044 	movi	r2,1
81129d20:	60802226 	beq	r12,r2,81129dac <_dtoa_r+0x142c>
81129d24:	d9c00717 	ldw	r7,28(sp)
81129d28:	8805883a 	mov	r2,r17
81129d2c:	b82b883a 	mov	r21,r23
81129d30:	3b19883a 	add	r12,r7,r12
81129d34:	6023883a 	mov	r17,r12
81129d38:	a007883a 	mov	r3,r20
81129d3c:	dc800f15 	stw	r18,60(sp)
81129d40:	000d883a 	mov	r6,zero
81129d44:	01d00934 	movhi	r7,16420
81129d48:	1009883a 	mov	r4,r2
81129d4c:	180b883a 	mov	r5,r3
81129d50:	111f1b00 	call	8111f1b0 <__muldf3>
81129d54:	180b883a 	mov	r5,r3
81129d58:	1009883a 	mov	r4,r2
81129d5c:	1829883a 	mov	r20,r3
81129d60:	1025883a 	mov	r18,r2
81129d64:	11201d40 	call	811201d4 <__fixdfsi>
81129d68:	1009883a 	mov	r4,r2
81129d6c:	1021883a 	mov	r16,r2
81129d70:	11202540 	call	81120254 <__floatsidf>
81129d74:	100d883a 	mov	r6,r2
81129d78:	180f883a 	mov	r7,r3
81129d7c:	9009883a 	mov	r4,r18
81129d80:	a00b883a 	mov	r5,r20
81129d84:	84000c04 	addi	r16,r16,48
81129d88:	111f8d00 	call	8111f8d0 <__subdf3>
81129d8c:	ad400044 	addi	r21,r21,1
81129d90:	ac3fffc5 	stb	r16,-1(r21)
81129d94:	ac7fea1e 	bne	r21,r17,81129d40 <__reset+0xfb109d40>
81129d98:	1023883a 	mov	r17,r2
81129d9c:	d8801217 	ldw	r2,72(sp)
81129da0:	dc800f17 	ldw	r18,60(sp)
81129da4:	1829883a 	mov	r20,r3
81129da8:	b8af883a 	add	r23,r23,r2
81129dac:	d9001417 	ldw	r4,80(sp)
81129db0:	d9401517 	ldw	r5,84(sp)
81129db4:	000d883a 	mov	r6,zero
81129db8:	01cff834 	movhi	r7,16352
81129dbc:	113408c0 	call	8113408c <__adddf3>
81129dc0:	880d883a 	mov	r6,r17
81129dc4:	a00f883a 	mov	r7,r20
81129dc8:	1009883a 	mov	r4,r2
81129dcc:	180b883a 	mov	r5,r3
81129dd0:	11352b80 	call	811352b8 <__ledf2>
81129dd4:	10003e0e 	bge	r2,zero,81129ed0 <_dtoa_r+0x1550>
81129dd8:	d9001317 	ldw	r4,76(sp)
81129ddc:	bd3fffc3 	ldbu	r20,-1(r23)
81129de0:	d9000515 	stw	r4,20(sp)
81129de4:	003d3b06 	br	811292d4 <__reset+0xfb1092d4>
81129de8:	0027883a 	mov	r19,zero
81129dec:	003f1b06 	br	81129a5c <__reset+0xfb109a5c>
81129df0:	d8800817 	ldw	r2,32(sp)
81129df4:	11e9c83a 	sub	r20,r2,r7
81129df8:	0005883a 	mov	r2,zero
81129dfc:	003d5406 	br	81129350 <__reset+0xfb109350>
81129e00:	00800044 	movi	r2,1
81129e04:	003dc706 	br	81129524 <__reset+0xfb109524>
81129e08:	d8c00217 	ldw	r3,8(sp)
81129e0c:	00800d84 	movi	r2,54
81129e10:	dd400a17 	ldw	r21,40(sp)
81129e14:	10c5c83a 	sub	r2,r2,r3
81129e18:	dd000817 	ldw	r20,32(sp)
81129e1c:	003d4c06 	br	81129350 <__reset+0xfb109350>
81129e20:	dc800f15 	stw	r18,60(sp)
81129e24:	dcc01015 	stw	r19,64(sp)
81129e28:	04000084 	movi	r16,2
81129e2c:	003bed06 	br	81128de4 <__reset+0xfb108de4>
81129e30:	d9000617 	ldw	r4,24(sp)
81129e34:	203f0d26 	beq	r4,zero,81129a6c <__reset+0xfb109a6c>
81129e38:	d9800c17 	ldw	r6,48(sp)
81129e3c:	01bcab0e 	bge	zero,r6,811290ec <__reset+0xfb1090ec>
81129e40:	d9401017 	ldw	r5,64(sp)
81129e44:	d9000f17 	ldw	r4,60(sp)
81129e48:	000d883a 	mov	r6,zero
81129e4c:	01d00934 	movhi	r7,16420
81129e50:	111f1b00 	call	8111f1b0 <__muldf3>
81129e54:	81000044 	addi	r4,r16,1
81129e58:	d8800f15 	stw	r2,60(sp)
81129e5c:	d8c01015 	stw	r3,64(sp)
81129e60:	11202540 	call	81120254 <__floatsidf>
81129e64:	d9800f17 	ldw	r6,60(sp)
81129e68:	d9c01017 	ldw	r7,64(sp)
81129e6c:	1009883a 	mov	r4,r2
81129e70:	180b883a 	mov	r5,r3
81129e74:	111f1b00 	call	8111f1b0 <__muldf3>
81129e78:	01d00734 	movhi	r7,16412
81129e7c:	000d883a 	mov	r6,zero
81129e80:	1009883a 	mov	r4,r2
81129e84:	180b883a 	mov	r5,r3
81129e88:	113408c0 	call	8113408c <__adddf3>
81129e8c:	d9c00517 	ldw	r7,20(sp)
81129e90:	047f3034 	movhi	r17,64704
81129e94:	1021883a 	mov	r16,r2
81129e98:	39ffffc4 	addi	r7,r7,-1
81129e9c:	d9c01315 	stw	r7,76(sp)
81129ea0:	1c63883a 	add	r17,r3,r17
81129ea4:	db000c17 	ldw	r12,48(sp)
81129ea8:	003bea06 	br	81128e54 <__reset+0xfb108e54>
81129eac:	dc000915 	stw	r16,36(sp)
81129eb0:	003e0e06 	br	811296ec <__reset+0xfb1096ec>
81129eb4:	01000e44 	movi	r4,57
81129eb8:	8825883a 	mov	r18,r17
81129ebc:	9dc00044 	addi	r23,r19,1
81129ec0:	99000005 	stb	r4,0(r19)
81129ec4:	a023883a 	mov	r17,r20
81129ec8:	dc000915 	stw	r16,36(sp)
81129ecc:	003da406 	br	81129560 <__reset+0xfb109560>
81129ed0:	d9801417 	ldw	r6,80(sp)
81129ed4:	d9c01517 	ldw	r7,84(sp)
81129ed8:	0009883a 	mov	r4,zero
81129edc:	014ff834 	movhi	r5,16352
81129ee0:	111f8d00 	call	8111f8d0 <__subdf3>
81129ee4:	880d883a 	mov	r6,r17
81129ee8:	a00f883a 	mov	r7,r20
81129eec:	1009883a 	mov	r4,r2
81129ef0:	180b883a 	mov	r5,r3
81129ef4:	111f0d40 	call	8111f0d4 <__gedf2>
81129ef8:	00bc7c0e 	bge	zero,r2,811290ec <__reset+0xfb1090ec>
81129efc:	01000c04 	movi	r4,48
81129f00:	00000106 	br	81129f08 <_dtoa_r+0x1588>
81129f04:	102f883a 	mov	r23,r2
81129f08:	b8bfffc4 	addi	r2,r23,-1
81129f0c:	10c00007 	ldb	r3,0(r2)
81129f10:	193ffc26 	beq	r3,r4,81129f04 <__reset+0xfb109f04>
81129f14:	d9801317 	ldw	r6,76(sp)
81129f18:	d9800515 	stw	r6,20(sp)
81129f1c:	003c4406 	br	81129030 <__reset+0xfb109030>
81129f20:	d9801317 	ldw	r6,76(sp)
81129f24:	d9800515 	stw	r6,20(sp)
81129f28:	003cea06 	br	811292d4 <__reset+0xfb1092d4>
81129f2c:	dd800f17 	ldw	r22,60(sp)
81129f30:	dcc01017 	ldw	r19,64(sp)
81129f34:	dc801217 	ldw	r18,72(sp)
81129f38:	003c6c06 	br	811290ec <__reset+0xfb1090ec>
81129f3c:	903e031e 	bne	r18,zero,8112974c <__reset+0xfb10974c>
81129f40:	003ebb06 	br	81129a30 <__reset+0xfb109a30>
81129f44:	103e6c1e 	bne	r2,zero,811298f8 <__reset+0xfb1098f8>
81129f48:	4080004c 	andi	r2,r8,1
81129f4c:	103e6a26 	beq	r2,zero,811298f8 <__reset+0xfb1098f8>
81129f50:	003e6606 	br	811298ec <__reset+0xfb1098ec>
81129f54:	d8c00317 	ldw	r3,12(sp)
81129f58:	00800084 	movi	r2,2
81129f5c:	10c02916 	blt	r2,r3,8112a004 <_dtoa_r+0x1684>
81129f60:	d9000c17 	ldw	r4,48(sp)
81129f64:	003e8806 	br	81129988 <__reset+0xfb109988>
81129f68:	04000084 	movi	r16,2
81129f6c:	003b9d06 	br	81128de4 <__reset+0xfb108de4>
81129f70:	d9001317 	ldw	r4,76(sp)
81129f74:	d9000515 	stw	r4,20(sp)
81129f78:	003cd606 	br	811292d4 <__reset+0xfb1092d4>
81129f7c:	d8801317 	ldw	r2,76(sp)
81129f80:	d8800515 	stw	r2,20(sp)
81129f84:	003c2a06 	br	81129030 <__reset+0xfb109030>
81129f88:	d9800317 	ldw	r6,12(sp)
81129f8c:	00800084 	movi	r2,2
81129f90:	11801516 	blt	r2,r6,81129fe8 <_dtoa_r+0x1668>
81129f94:	d9c00c17 	ldw	r7,48(sp)
81129f98:	d9c00615 	stw	r7,24(sp)
81129f9c:	003df706 	br	8112977c <__reset+0xfb10977c>
81129fa0:	193d3926 	beq	r3,r4,81129488 <__reset+0xfb109488>
81129fa4:	00c00f04 	movi	r3,60
81129fa8:	1885c83a 	sub	r2,r3,r2
81129fac:	003ddf06 	br	8112972c <__reset+0xfb10972c>
81129fb0:	e009883a 	mov	r4,fp
81129fb4:	e0001115 	stw	zero,68(fp)
81129fb8:	000b883a 	mov	r5,zero
81129fbc:	112ba980 	call	8112ba98 <_Balloc>
81129fc0:	d8800715 	stw	r2,28(sp)
81129fc4:	d8c00717 	ldw	r3,28(sp)
81129fc8:	00bfffc4 	movi	r2,-1
81129fcc:	01000044 	movi	r4,1
81129fd0:	d8800c15 	stw	r2,48(sp)
81129fd4:	e0c01015 	stw	r3,64(fp)
81129fd8:	d9000b15 	stw	r4,44(sp)
81129fdc:	d8800615 	stw	r2,24(sp)
81129fe0:	d8002215 	stw	zero,136(sp)
81129fe4:	003c4106 	br	811290ec <__reset+0xfb1090ec>
81129fe8:	d8c00c17 	ldw	r3,48(sp)
81129fec:	d8c00615 	stw	r3,24(sp)
81129ff0:	003e7006 	br	811299b4 <__reset+0xfb1099b4>
81129ff4:	04400044 	movi	r17,1
81129ff8:	003b2006 	br	81128c7c <__reset+0xfb108c7c>
81129ffc:	000b883a 	mov	r5,zero
8112a000:	003b3d06 	br	81128cf8 <__reset+0xfb108cf8>
8112a004:	d8800c17 	ldw	r2,48(sp)
8112a008:	d8800615 	stw	r2,24(sp)
8112a00c:	003e6906 	br	811299b4 <__reset+0xfb1099b4>

8112a010 <__sflush_r>:
8112a010:	defffb04 	addi	sp,sp,-20
8112a014:	de00012e 	bgeu	sp,et,8112a01c <__sflush_r+0xc>
8112a018:	003b68fa 	trap	3
8112a01c:	2880030b 	ldhu	r2,12(r5)
8112a020:	dcc00315 	stw	r19,12(sp)
8112a024:	dc400115 	stw	r17,4(sp)
8112a028:	dfc00415 	stw	ra,16(sp)
8112a02c:	dc800215 	stw	r18,8(sp)
8112a030:	dc000015 	stw	r16,0(sp)
8112a034:	10c0020c 	andi	r3,r2,8
8112a038:	2823883a 	mov	r17,r5
8112a03c:	2027883a 	mov	r19,r4
8112a040:	1800311e 	bne	r3,zero,8112a108 <__sflush_r+0xf8>
8112a044:	28c00117 	ldw	r3,4(r5)
8112a048:	10820014 	ori	r2,r2,2048
8112a04c:	2880030d 	sth	r2,12(r5)
8112a050:	00c04b0e 	bge	zero,r3,8112a180 <__sflush_r+0x170>
8112a054:	8a000a17 	ldw	r8,40(r17)
8112a058:	40002326 	beq	r8,zero,8112a0e8 <__sflush_r+0xd8>
8112a05c:	9c000017 	ldw	r16,0(r19)
8112a060:	10c4000c 	andi	r3,r2,4096
8112a064:	98000015 	stw	zero,0(r19)
8112a068:	18004826 	beq	r3,zero,8112a18c <__sflush_r+0x17c>
8112a06c:	89801417 	ldw	r6,80(r17)
8112a070:	10c0010c 	andi	r3,r2,4
8112a074:	18000626 	beq	r3,zero,8112a090 <__sflush_r+0x80>
8112a078:	88c00117 	ldw	r3,4(r17)
8112a07c:	88800c17 	ldw	r2,48(r17)
8112a080:	30cdc83a 	sub	r6,r6,r3
8112a084:	10000226 	beq	r2,zero,8112a090 <__sflush_r+0x80>
8112a088:	88800f17 	ldw	r2,60(r17)
8112a08c:	308dc83a 	sub	r6,r6,r2
8112a090:	89400717 	ldw	r5,28(r17)
8112a094:	000f883a 	mov	r7,zero
8112a098:	9809883a 	mov	r4,r19
8112a09c:	403ee83a 	callr	r8
8112a0a0:	00ffffc4 	movi	r3,-1
8112a0a4:	10c04426 	beq	r2,r3,8112a1b8 <__sflush_r+0x1a8>
8112a0a8:	88c0030b 	ldhu	r3,12(r17)
8112a0ac:	89000417 	ldw	r4,16(r17)
8112a0b0:	88000115 	stw	zero,4(r17)
8112a0b4:	197dffcc 	andi	r5,r3,63487
8112a0b8:	8940030d 	sth	r5,12(r17)
8112a0bc:	89000015 	stw	r4,0(r17)
8112a0c0:	18c4000c 	andi	r3,r3,4096
8112a0c4:	18002c1e 	bne	r3,zero,8112a178 <__sflush_r+0x168>
8112a0c8:	89400c17 	ldw	r5,48(r17)
8112a0cc:	9c000015 	stw	r16,0(r19)
8112a0d0:	28000526 	beq	r5,zero,8112a0e8 <__sflush_r+0xd8>
8112a0d4:	88801004 	addi	r2,r17,64
8112a0d8:	28800226 	beq	r5,r2,8112a0e4 <__sflush_r+0xd4>
8112a0dc:	9809883a 	mov	r4,r19
8112a0e0:	112aac80 	call	8112aac8 <_free_r>
8112a0e4:	88000c15 	stw	zero,48(r17)
8112a0e8:	0005883a 	mov	r2,zero
8112a0ec:	dfc00417 	ldw	ra,16(sp)
8112a0f0:	dcc00317 	ldw	r19,12(sp)
8112a0f4:	dc800217 	ldw	r18,8(sp)
8112a0f8:	dc400117 	ldw	r17,4(sp)
8112a0fc:	dc000017 	ldw	r16,0(sp)
8112a100:	dec00504 	addi	sp,sp,20
8112a104:	f800283a 	ret
8112a108:	2c800417 	ldw	r18,16(r5)
8112a10c:	903ff626 	beq	r18,zero,8112a0e8 <__reset+0xfb10a0e8>
8112a110:	2c000017 	ldw	r16,0(r5)
8112a114:	108000cc 	andi	r2,r2,3
8112a118:	2c800015 	stw	r18,0(r5)
8112a11c:	84a1c83a 	sub	r16,r16,r18
8112a120:	1000131e 	bne	r2,zero,8112a170 <__sflush_r+0x160>
8112a124:	28800517 	ldw	r2,20(r5)
8112a128:	88800215 	stw	r2,8(r17)
8112a12c:	04000316 	blt	zero,r16,8112a13c <__sflush_r+0x12c>
8112a130:	003fed06 	br	8112a0e8 <__reset+0xfb10a0e8>
8112a134:	90a5883a 	add	r18,r18,r2
8112a138:	043feb0e 	bge	zero,r16,8112a0e8 <__reset+0xfb10a0e8>
8112a13c:	88800917 	ldw	r2,36(r17)
8112a140:	89400717 	ldw	r5,28(r17)
8112a144:	800f883a 	mov	r7,r16
8112a148:	900d883a 	mov	r6,r18
8112a14c:	9809883a 	mov	r4,r19
8112a150:	103ee83a 	callr	r2
8112a154:	80a1c83a 	sub	r16,r16,r2
8112a158:	00bff616 	blt	zero,r2,8112a134 <__reset+0xfb10a134>
8112a15c:	88c0030b 	ldhu	r3,12(r17)
8112a160:	00bfffc4 	movi	r2,-1
8112a164:	18c01014 	ori	r3,r3,64
8112a168:	88c0030d 	sth	r3,12(r17)
8112a16c:	003fdf06 	br	8112a0ec <__reset+0xfb10a0ec>
8112a170:	0005883a 	mov	r2,zero
8112a174:	003fec06 	br	8112a128 <__reset+0xfb10a128>
8112a178:	88801415 	stw	r2,80(r17)
8112a17c:	003fd206 	br	8112a0c8 <__reset+0xfb10a0c8>
8112a180:	28c00f17 	ldw	r3,60(r5)
8112a184:	00ffb316 	blt	zero,r3,8112a054 <__reset+0xfb10a054>
8112a188:	003fd706 	br	8112a0e8 <__reset+0xfb10a0e8>
8112a18c:	89400717 	ldw	r5,28(r17)
8112a190:	000d883a 	mov	r6,zero
8112a194:	01c00044 	movi	r7,1
8112a198:	9809883a 	mov	r4,r19
8112a19c:	403ee83a 	callr	r8
8112a1a0:	100d883a 	mov	r6,r2
8112a1a4:	00bfffc4 	movi	r2,-1
8112a1a8:	30801426 	beq	r6,r2,8112a1fc <__sflush_r+0x1ec>
8112a1ac:	8880030b 	ldhu	r2,12(r17)
8112a1b0:	8a000a17 	ldw	r8,40(r17)
8112a1b4:	003fae06 	br	8112a070 <__reset+0xfb10a070>
8112a1b8:	98c00017 	ldw	r3,0(r19)
8112a1bc:	183fba26 	beq	r3,zero,8112a0a8 <__reset+0xfb10a0a8>
8112a1c0:	01000744 	movi	r4,29
8112a1c4:	19000626 	beq	r3,r4,8112a1e0 <__sflush_r+0x1d0>
8112a1c8:	01000584 	movi	r4,22
8112a1cc:	19000426 	beq	r3,r4,8112a1e0 <__sflush_r+0x1d0>
8112a1d0:	88c0030b 	ldhu	r3,12(r17)
8112a1d4:	18c01014 	ori	r3,r3,64
8112a1d8:	88c0030d 	sth	r3,12(r17)
8112a1dc:	003fc306 	br	8112a0ec <__reset+0xfb10a0ec>
8112a1e0:	8880030b 	ldhu	r2,12(r17)
8112a1e4:	88c00417 	ldw	r3,16(r17)
8112a1e8:	88000115 	stw	zero,4(r17)
8112a1ec:	10bdffcc 	andi	r2,r2,63487
8112a1f0:	8880030d 	sth	r2,12(r17)
8112a1f4:	88c00015 	stw	r3,0(r17)
8112a1f8:	003fb306 	br	8112a0c8 <__reset+0xfb10a0c8>
8112a1fc:	98800017 	ldw	r2,0(r19)
8112a200:	103fea26 	beq	r2,zero,8112a1ac <__reset+0xfb10a1ac>
8112a204:	00c00744 	movi	r3,29
8112a208:	10c00226 	beq	r2,r3,8112a214 <__sflush_r+0x204>
8112a20c:	00c00584 	movi	r3,22
8112a210:	10c0031e 	bne	r2,r3,8112a220 <__sflush_r+0x210>
8112a214:	9c000015 	stw	r16,0(r19)
8112a218:	0005883a 	mov	r2,zero
8112a21c:	003fb306 	br	8112a0ec <__reset+0xfb10a0ec>
8112a220:	88c0030b 	ldhu	r3,12(r17)
8112a224:	3005883a 	mov	r2,r6
8112a228:	18c01014 	ori	r3,r3,64
8112a22c:	88c0030d 	sth	r3,12(r17)
8112a230:	003fae06 	br	8112a0ec <__reset+0xfb10a0ec>

8112a234 <_fflush_r>:
8112a234:	defffd04 	addi	sp,sp,-12
8112a238:	de00012e 	bgeu	sp,et,8112a240 <_fflush_r+0xc>
8112a23c:	003b68fa 	trap	3
8112a240:	dc000115 	stw	r16,4(sp)
8112a244:	dfc00215 	stw	ra,8(sp)
8112a248:	2021883a 	mov	r16,r4
8112a24c:	20000226 	beq	r4,zero,8112a258 <_fflush_r+0x24>
8112a250:	20800e17 	ldw	r2,56(r4)
8112a254:	10000c26 	beq	r2,zero,8112a288 <_fflush_r+0x54>
8112a258:	2880030f 	ldh	r2,12(r5)
8112a25c:	1000051e 	bne	r2,zero,8112a274 <_fflush_r+0x40>
8112a260:	0005883a 	mov	r2,zero
8112a264:	dfc00217 	ldw	ra,8(sp)
8112a268:	dc000117 	ldw	r16,4(sp)
8112a26c:	dec00304 	addi	sp,sp,12
8112a270:	f800283a 	ret
8112a274:	8009883a 	mov	r4,r16
8112a278:	dfc00217 	ldw	ra,8(sp)
8112a27c:	dc000117 	ldw	r16,4(sp)
8112a280:	dec00304 	addi	sp,sp,12
8112a284:	112a0101 	jmpi	8112a010 <__sflush_r>
8112a288:	d9400015 	stw	r5,0(sp)
8112a28c:	112a6300 	call	8112a630 <__sinit>
8112a290:	d9400017 	ldw	r5,0(sp)
8112a294:	003ff006 	br	8112a258 <__reset+0xfb10a258>

8112a298 <fflush>:
8112a298:	20000526 	beq	r4,zero,8112a2b0 <fflush+0x18>
8112a29c:	00a04574 	movhi	r2,33045
8112a2a0:	10886904 	addi	r2,r2,8612
8112a2a4:	200b883a 	mov	r5,r4
8112a2a8:	11000017 	ldw	r4,0(r2)
8112a2ac:	112a2341 	jmpi	8112a234 <_fflush_r>
8112a2b0:	00a04574 	movhi	r2,33045
8112a2b4:	10886804 	addi	r2,r2,8608
8112a2b8:	11000017 	ldw	r4,0(r2)
8112a2bc:	016044f4 	movhi	r5,33043
8112a2c0:	29688d04 	addi	r5,r5,-24012
8112a2c4:	112b3701 	jmpi	8112b370 <_fwalk_reent>

8112a2c8 <__fp_unlock>:
8112a2c8:	0005883a 	mov	r2,zero
8112a2cc:	f800283a 	ret

8112a2d0 <_cleanup_r>:
8112a2d0:	016044f4 	movhi	r5,33043
8112a2d4:	29482304 	addi	r5,r5,8332
8112a2d8:	112b3701 	jmpi	8112b370 <_fwalk_reent>

8112a2dc <__sinit.part.1>:
8112a2dc:	defff704 	addi	sp,sp,-36
8112a2e0:	00e044f4 	movhi	r3,33043
8112a2e4:	de00012e 	bgeu	sp,et,8112a2ec <__sinit.part.1+0x10>
8112a2e8:	003b68fa 	trap	3
8112a2ec:	18e8b404 	addi	r3,r3,-23856
8112a2f0:	dfc00815 	stw	ra,32(sp)
8112a2f4:	ddc00715 	stw	r23,28(sp)
8112a2f8:	dd800615 	stw	r22,24(sp)
8112a2fc:	dd400515 	stw	r21,20(sp)
8112a300:	dd000415 	stw	r20,16(sp)
8112a304:	dcc00315 	stw	r19,12(sp)
8112a308:	dc800215 	stw	r18,8(sp)
8112a30c:	dc400115 	stw	r17,4(sp)
8112a310:	dc000015 	stw	r16,0(sp)
8112a314:	24000117 	ldw	r16,4(r4)
8112a318:	20c00f15 	stw	r3,60(r4)
8112a31c:	2080bb04 	addi	r2,r4,748
8112a320:	00c000c4 	movi	r3,3
8112a324:	20c0b915 	stw	r3,740(r4)
8112a328:	2080ba15 	stw	r2,744(r4)
8112a32c:	2000b815 	stw	zero,736(r4)
8112a330:	05c00204 	movi	r23,8
8112a334:	00800104 	movi	r2,4
8112a338:	2025883a 	mov	r18,r4
8112a33c:	b80d883a 	mov	r6,r23
8112a340:	81001704 	addi	r4,r16,92
8112a344:	000b883a 	mov	r5,zero
8112a348:	80000015 	stw	zero,0(r16)
8112a34c:	80000115 	stw	zero,4(r16)
8112a350:	80000215 	stw	zero,8(r16)
8112a354:	8080030d 	sth	r2,12(r16)
8112a358:	80001915 	stw	zero,100(r16)
8112a35c:	8000038d 	sth	zero,14(r16)
8112a360:	80000415 	stw	zero,16(r16)
8112a364:	80000515 	stw	zero,20(r16)
8112a368:	80000615 	stw	zero,24(r16)
8112a36c:	11219b80 	call	811219b8 <memset>
8112a370:	05a044b4 	movhi	r22,33042
8112a374:	94400217 	ldw	r17,8(r18)
8112a378:	056044b4 	movhi	r21,33042
8112a37c:	052044b4 	movhi	r20,33042
8112a380:	04e044b4 	movhi	r19,33042
8112a384:	b5886f04 	addi	r22,r22,8636
8112a388:	ad488804 	addi	r21,r21,8736
8112a38c:	a508a904 	addi	r20,r20,8868
8112a390:	9cc8c204 	addi	r19,r19,8968
8112a394:	85800815 	stw	r22,32(r16)
8112a398:	85400915 	stw	r21,36(r16)
8112a39c:	85000a15 	stw	r20,40(r16)
8112a3a0:	84c00b15 	stw	r19,44(r16)
8112a3a4:	84000715 	stw	r16,28(r16)
8112a3a8:	00800284 	movi	r2,10
8112a3ac:	8880030d 	sth	r2,12(r17)
8112a3b0:	00800044 	movi	r2,1
8112a3b4:	b80d883a 	mov	r6,r23
8112a3b8:	89001704 	addi	r4,r17,92
8112a3bc:	000b883a 	mov	r5,zero
8112a3c0:	88000015 	stw	zero,0(r17)
8112a3c4:	88000115 	stw	zero,4(r17)
8112a3c8:	88000215 	stw	zero,8(r17)
8112a3cc:	88001915 	stw	zero,100(r17)
8112a3d0:	8880038d 	sth	r2,14(r17)
8112a3d4:	88000415 	stw	zero,16(r17)
8112a3d8:	88000515 	stw	zero,20(r17)
8112a3dc:	88000615 	stw	zero,24(r17)
8112a3e0:	11219b80 	call	811219b8 <memset>
8112a3e4:	94000317 	ldw	r16,12(r18)
8112a3e8:	00800484 	movi	r2,18
8112a3ec:	8c400715 	stw	r17,28(r17)
8112a3f0:	8d800815 	stw	r22,32(r17)
8112a3f4:	8d400915 	stw	r21,36(r17)
8112a3f8:	8d000a15 	stw	r20,40(r17)
8112a3fc:	8cc00b15 	stw	r19,44(r17)
8112a400:	8080030d 	sth	r2,12(r16)
8112a404:	00800084 	movi	r2,2
8112a408:	80000015 	stw	zero,0(r16)
8112a40c:	80000115 	stw	zero,4(r16)
8112a410:	80000215 	stw	zero,8(r16)
8112a414:	80001915 	stw	zero,100(r16)
8112a418:	8080038d 	sth	r2,14(r16)
8112a41c:	80000415 	stw	zero,16(r16)
8112a420:	80000515 	stw	zero,20(r16)
8112a424:	80000615 	stw	zero,24(r16)
8112a428:	b80d883a 	mov	r6,r23
8112a42c:	000b883a 	mov	r5,zero
8112a430:	81001704 	addi	r4,r16,92
8112a434:	11219b80 	call	811219b8 <memset>
8112a438:	00800044 	movi	r2,1
8112a43c:	84000715 	stw	r16,28(r16)
8112a440:	85800815 	stw	r22,32(r16)
8112a444:	85400915 	stw	r21,36(r16)
8112a448:	85000a15 	stw	r20,40(r16)
8112a44c:	84c00b15 	stw	r19,44(r16)
8112a450:	90800e15 	stw	r2,56(r18)
8112a454:	dfc00817 	ldw	ra,32(sp)
8112a458:	ddc00717 	ldw	r23,28(sp)
8112a45c:	dd800617 	ldw	r22,24(sp)
8112a460:	dd400517 	ldw	r21,20(sp)
8112a464:	dd000417 	ldw	r20,16(sp)
8112a468:	dcc00317 	ldw	r19,12(sp)
8112a46c:	dc800217 	ldw	r18,8(sp)
8112a470:	dc400117 	ldw	r17,4(sp)
8112a474:	dc000017 	ldw	r16,0(sp)
8112a478:	dec00904 	addi	sp,sp,36
8112a47c:	f800283a 	ret

8112a480 <__fp_lock>:
8112a480:	0005883a 	mov	r2,zero
8112a484:	f800283a 	ret

8112a488 <__sfmoreglue>:
8112a488:	defffc04 	addi	sp,sp,-16
8112a48c:	de00012e 	bgeu	sp,et,8112a494 <__sfmoreglue+0xc>
8112a490:	003b68fa 	trap	3
8112a494:	dc400115 	stw	r17,4(sp)
8112a498:	2c7fffc4 	addi	r17,r5,-1
8112a49c:	8c401a24 	muli	r17,r17,104
8112a4a0:	dc800215 	stw	r18,8(sp)
8112a4a4:	2825883a 	mov	r18,r5
8112a4a8:	89401d04 	addi	r5,r17,116
8112a4ac:	dc000015 	stw	r16,0(sp)
8112a4b0:	dfc00315 	stw	ra,12(sp)
8112a4b4:	11210540 	call	81121054 <_malloc_r>
8112a4b8:	1021883a 	mov	r16,r2
8112a4bc:	10000726 	beq	r2,zero,8112a4dc <__sfmoreglue+0x54>
8112a4c0:	11000304 	addi	r4,r2,12
8112a4c4:	10000015 	stw	zero,0(r2)
8112a4c8:	14800115 	stw	r18,4(r2)
8112a4cc:	11000215 	stw	r4,8(r2)
8112a4d0:	89801a04 	addi	r6,r17,104
8112a4d4:	000b883a 	mov	r5,zero
8112a4d8:	11219b80 	call	811219b8 <memset>
8112a4dc:	8005883a 	mov	r2,r16
8112a4e0:	dfc00317 	ldw	ra,12(sp)
8112a4e4:	dc800217 	ldw	r18,8(sp)
8112a4e8:	dc400117 	ldw	r17,4(sp)
8112a4ec:	dc000017 	ldw	r16,0(sp)
8112a4f0:	dec00404 	addi	sp,sp,16
8112a4f4:	f800283a 	ret

8112a4f8 <__sfp>:
8112a4f8:	defffb04 	addi	sp,sp,-20
8112a4fc:	de00012e 	bgeu	sp,et,8112a504 <__sfp+0xc>
8112a500:	003b68fa 	trap	3
8112a504:	dc000015 	stw	r16,0(sp)
8112a508:	04204574 	movhi	r16,33045
8112a50c:	84086804 	addi	r16,r16,8608
8112a510:	dcc00315 	stw	r19,12(sp)
8112a514:	2027883a 	mov	r19,r4
8112a518:	81000017 	ldw	r4,0(r16)
8112a51c:	dfc00415 	stw	ra,16(sp)
8112a520:	dc800215 	stw	r18,8(sp)
8112a524:	20800e17 	ldw	r2,56(r4)
8112a528:	dc400115 	stw	r17,4(sp)
8112a52c:	1000021e 	bne	r2,zero,8112a538 <__sfp+0x40>
8112a530:	112a2dc0 	call	8112a2dc <__sinit.part.1>
8112a534:	81000017 	ldw	r4,0(r16)
8112a538:	2480b804 	addi	r18,r4,736
8112a53c:	047fffc4 	movi	r17,-1
8112a540:	91000117 	ldw	r4,4(r18)
8112a544:	94000217 	ldw	r16,8(r18)
8112a548:	213fffc4 	addi	r4,r4,-1
8112a54c:	20000a16 	blt	r4,zero,8112a578 <__sfp+0x80>
8112a550:	8080030f 	ldh	r2,12(r16)
8112a554:	10000c26 	beq	r2,zero,8112a588 <__sfp+0x90>
8112a558:	80c01d04 	addi	r3,r16,116
8112a55c:	00000206 	br	8112a568 <__sfp+0x70>
8112a560:	18bfe60f 	ldh	r2,-104(r3)
8112a564:	10000826 	beq	r2,zero,8112a588 <__sfp+0x90>
8112a568:	213fffc4 	addi	r4,r4,-1
8112a56c:	1c3ffd04 	addi	r16,r3,-12
8112a570:	18c01a04 	addi	r3,r3,104
8112a574:	247ffa1e 	bne	r4,r17,8112a560 <__reset+0xfb10a560>
8112a578:	90800017 	ldw	r2,0(r18)
8112a57c:	10001d26 	beq	r2,zero,8112a5f4 <__sfp+0xfc>
8112a580:	1025883a 	mov	r18,r2
8112a584:	003fee06 	br	8112a540 <__reset+0xfb10a540>
8112a588:	00bfffc4 	movi	r2,-1
8112a58c:	8080038d 	sth	r2,14(r16)
8112a590:	00800044 	movi	r2,1
8112a594:	8080030d 	sth	r2,12(r16)
8112a598:	80001915 	stw	zero,100(r16)
8112a59c:	80000015 	stw	zero,0(r16)
8112a5a0:	80000215 	stw	zero,8(r16)
8112a5a4:	80000115 	stw	zero,4(r16)
8112a5a8:	80000415 	stw	zero,16(r16)
8112a5ac:	80000515 	stw	zero,20(r16)
8112a5b0:	80000615 	stw	zero,24(r16)
8112a5b4:	01800204 	movi	r6,8
8112a5b8:	000b883a 	mov	r5,zero
8112a5bc:	81001704 	addi	r4,r16,92
8112a5c0:	11219b80 	call	811219b8 <memset>
8112a5c4:	8005883a 	mov	r2,r16
8112a5c8:	80000c15 	stw	zero,48(r16)
8112a5cc:	80000d15 	stw	zero,52(r16)
8112a5d0:	80001115 	stw	zero,68(r16)
8112a5d4:	80001215 	stw	zero,72(r16)
8112a5d8:	dfc00417 	ldw	ra,16(sp)
8112a5dc:	dcc00317 	ldw	r19,12(sp)
8112a5e0:	dc800217 	ldw	r18,8(sp)
8112a5e4:	dc400117 	ldw	r17,4(sp)
8112a5e8:	dc000017 	ldw	r16,0(sp)
8112a5ec:	dec00504 	addi	sp,sp,20
8112a5f0:	f800283a 	ret
8112a5f4:	01400104 	movi	r5,4
8112a5f8:	9809883a 	mov	r4,r19
8112a5fc:	112a4880 	call	8112a488 <__sfmoreglue>
8112a600:	90800015 	stw	r2,0(r18)
8112a604:	103fde1e 	bne	r2,zero,8112a580 <__reset+0xfb10a580>
8112a608:	00800304 	movi	r2,12
8112a60c:	98800015 	stw	r2,0(r19)
8112a610:	0005883a 	mov	r2,zero
8112a614:	003ff006 	br	8112a5d8 <__reset+0xfb10a5d8>

8112a618 <_cleanup>:
8112a618:	00a04574 	movhi	r2,33045
8112a61c:	10886804 	addi	r2,r2,8608
8112a620:	11000017 	ldw	r4,0(r2)
8112a624:	016044f4 	movhi	r5,33043
8112a628:	29482304 	addi	r5,r5,8332
8112a62c:	112b3701 	jmpi	8112b370 <_fwalk_reent>

8112a630 <__sinit>:
8112a630:	20800e17 	ldw	r2,56(r4)
8112a634:	10000126 	beq	r2,zero,8112a63c <__sinit+0xc>
8112a638:	f800283a 	ret
8112a63c:	112a2dc1 	jmpi	8112a2dc <__sinit.part.1>

8112a640 <__sfp_lock_acquire>:
8112a640:	f800283a 	ret

8112a644 <__sfp_lock_release>:
8112a644:	f800283a 	ret

8112a648 <__sinit_lock_acquire>:
8112a648:	f800283a 	ret

8112a64c <__sinit_lock_release>:
8112a64c:	f800283a 	ret

8112a650 <__fp_lock_all>:
8112a650:	00a04574 	movhi	r2,33045
8112a654:	10886904 	addi	r2,r2,8612
8112a658:	11000017 	ldw	r4,0(r2)
8112a65c:	016044f4 	movhi	r5,33043
8112a660:	29692004 	addi	r5,r5,-23424
8112a664:	112b2a41 	jmpi	8112b2a4 <_fwalk>

8112a668 <__fp_unlock_all>:
8112a668:	00a04574 	movhi	r2,33045
8112a66c:	10886904 	addi	r2,r2,8612
8112a670:	11000017 	ldw	r4,0(r2)
8112a674:	016044f4 	movhi	r5,33043
8112a678:	2968b204 	addi	r5,r5,-23864
8112a67c:	112b2a41 	jmpi	8112b2a4 <_fwalk>

8112a680 <__sflags>:
8112a680:	28800007 	ldb	r2,0(r5)
8112a684:	00c01c84 	movi	r3,114
8112a688:	10c02426 	beq	r2,r3,8112a71c <__sflags+0x9c>
8112a68c:	00c01dc4 	movi	r3,119
8112a690:	10c01e26 	beq	r2,r3,8112a70c <__sflags+0x8c>
8112a694:	00c01844 	movi	r3,97
8112a698:	10c00426 	beq	r2,r3,8112a6ac <__sflags+0x2c>
8112a69c:	00800584 	movi	r2,22
8112a6a0:	20800015 	stw	r2,0(r4)
8112a6a4:	0005883a 	mov	r2,zero
8112a6a8:	f800283a 	ret
8112a6ac:	02c08204 	movi	r11,520
8112a6b0:	01000044 	movi	r4,1
8112a6b4:	00804204 	movi	r2,264
8112a6b8:	01c00ac4 	movi	r7,43
8112a6bc:	02bff8c4 	movi	r10,-29
8112a6c0:	027fff04 	movi	r9,-4
8112a6c4:	02001e04 	movi	r8,120
8112a6c8:	29400044 	addi	r5,r5,1
8112a6cc:	28c00007 	ldb	r3,0(r5)
8112a6d0:	18000626 	beq	r3,zero,8112a6ec <__sflags+0x6c>
8112a6d4:	19c00826 	beq	r3,r7,8112a6f8 <__sflags+0x78>
8112a6d8:	1a3ffb1e 	bne	r3,r8,8112a6c8 <__reset+0xfb10a6c8>
8112a6dc:	29400044 	addi	r5,r5,1
8112a6e0:	28c00007 	ldb	r3,0(r5)
8112a6e4:	21020014 	ori	r4,r4,2048
8112a6e8:	183ffa1e 	bne	r3,zero,8112a6d4 <__reset+0xfb10a6d4>
8112a6ec:	22c8b03a 	or	r4,r4,r11
8112a6f0:	31000015 	stw	r4,0(r6)
8112a6f4:	f800283a 	ret
8112a6f8:	1284703a 	and	r2,r2,r10
8112a6fc:	2248703a 	and	r4,r4,r9
8112a700:	10800414 	ori	r2,r2,16
8112a704:	21000094 	ori	r4,r4,2
8112a708:	003fef06 	br	8112a6c8 <__reset+0xfb10a6c8>
8112a70c:	02c18004 	movi	r11,1536
8112a710:	01000044 	movi	r4,1
8112a714:	00800204 	movi	r2,8
8112a718:	003fe706 	br	8112a6b8 <__reset+0xfb10a6b8>
8112a71c:	0017883a 	mov	r11,zero
8112a720:	0009883a 	mov	r4,zero
8112a724:	00800104 	movi	r2,4
8112a728:	003fe306 	br	8112a6b8 <__reset+0xfb10a6b8>

8112a72c <_fread_r>:
8112a72c:	defff404 	addi	sp,sp,-48
8112a730:	de00012e 	bgeu	sp,et,8112a738 <_fread_r+0xc>
8112a734:	003b68fa 	trap	3
8112a738:	dd800815 	stw	r22,32(sp)
8112a73c:	39ad383a 	mul	r22,r7,r6
8112a740:	dc000215 	stw	r16,8(sp)
8112a744:	dfc00b15 	stw	ra,44(sp)
8112a748:	df000a15 	stw	fp,40(sp)
8112a74c:	ddc00915 	stw	r23,36(sp)
8112a750:	dd400715 	stw	r21,28(sp)
8112a754:	dd000615 	stw	r20,24(sp)
8112a758:	dcc00515 	stw	r19,20(sp)
8112a75c:	dc800415 	stw	r18,16(sp)
8112a760:	dc400315 	stw	r17,12(sp)
8112a764:	dc000c17 	ldw	r16,48(sp)
8112a768:	b0003b26 	beq	r22,zero,8112a858 <_fread_r+0x12c>
8112a76c:	302f883a 	mov	r23,r6
8112a770:	382b883a 	mov	r21,r7
8112a774:	2029883a 	mov	r20,r4
8112a778:	2827883a 	mov	r19,r5
8112a77c:	20000226 	beq	r4,zero,8112a788 <_fread_r+0x5c>
8112a780:	20800e17 	ldw	r2,56(r4)
8112a784:	10006e26 	beq	r2,zero,8112a940 <_fread_r+0x214>
8112a788:	8080030b 	ldhu	r2,12(r16)
8112a78c:	10c8000c 	andi	r3,r2,8192
8112a790:	1800061e 	bne	r3,zero,8112a7ac <_fread_r+0x80>
8112a794:	81001917 	ldw	r4,100(r16)
8112a798:	00f7ffc4 	movi	r3,-8193
8112a79c:	10880014 	ori	r2,r2,8192
8112a7a0:	20c6703a 	and	r3,r4,r3
8112a7a4:	8080030d 	sth	r2,12(r16)
8112a7a8:	80c01915 	stw	r3,100(r16)
8112a7ac:	84400117 	ldw	r17,4(r16)
8112a7b0:	88005f16 	blt	r17,zero,8112a930 <_fread_r+0x204>
8112a7b4:	8809883a 	mov	r4,r17
8112a7b8:	1080008c 	andi	r2,r2,2
8112a7bc:	1000281e 	bne	r2,zero,8112a860 <_fread_r+0x134>
8112a7c0:	b025883a 	mov	r18,r22
8112a7c4:	00000b06 	br	8112a7f4 <_fread_r+0xc8>
8112a7c8:	11218680 	call	81121868 <memcpy>
8112a7cc:	80800017 	ldw	r2,0(r16)
8112a7d0:	9c67883a 	add	r19,r19,r17
8112a7d4:	9465c83a 	sub	r18,r18,r17
8112a7d8:	1463883a 	add	r17,r2,r17
8112a7dc:	800b883a 	mov	r5,r16
8112a7e0:	a009883a 	mov	r4,r20
8112a7e4:	84400015 	stw	r17,0(r16)
8112a7e8:	1121e340 	call	81121e34 <__srefill_r>
8112a7ec:	10004c1e 	bne	r2,zero,8112a920 <_fread_r+0x1f4>
8112a7f0:	84400117 	ldw	r17,4(r16)
8112a7f4:	880d883a 	mov	r6,r17
8112a7f8:	9809883a 	mov	r4,r19
8112a7fc:	81400017 	ldw	r5,0(r16)
8112a800:	8cbff136 	bltu	r17,r18,8112a7c8 <__reset+0xfb10a7c8>
8112a804:	900d883a 	mov	r6,r18
8112a808:	11218680 	call	81121868 <memcpy>
8112a80c:	80c00117 	ldw	r3,4(r16)
8112a810:	81000017 	ldw	r4,0(r16)
8112a814:	a805883a 	mov	r2,r21
8112a818:	1c87c83a 	sub	r3,r3,r18
8112a81c:	24a5883a 	add	r18,r4,r18
8112a820:	80c00115 	stw	r3,4(r16)
8112a824:	84800015 	stw	r18,0(r16)
8112a828:	dfc00b17 	ldw	ra,44(sp)
8112a82c:	df000a17 	ldw	fp,40(sp)
8112a830:	ddc00917 	ldw	r23,36(sp)
8112a834:	dd800817 	ldw	r22,32(sp)
8112a838:	dd400717 	ldw	r21,28(sp)
8112a83c:	dd000617 	ldw	r20,24(sp)
8112a840:	dcc00517 	ldw	r19,20(sp)
8112a844:	dc800417 	ldw	r18,16(sp)
8112a848:	dc400317 	ldw	r17,12(sp)
8112a84c:	dc000217 	ldw	r16,8(sp)
8112a850:	dec00c04 	addi	sp,sp,48
8112a854:	f800283a 	ret
8112a858:	0005883a 	mov	r2,zero
8112a85c:	003ff206 	br	8112a828 <__reset+0xfb10a828>
8112a860:	b007883a 	mov	r3,r22
8112a864:	2580012e 	bgeu	r4,r22,8112a86c <_fread_r+0x140>
8112a868:	2007883a 	mov	r3,r4
8112a86c:	81400017 	ldw	r5,0(r16)
8112a870:	180d883a 	mov	r6,r3
8112a874:	9809883a 	mov	r4,r19
8112a878:	d8c00115 	stw	r3,4(sp)
8112a87c:	11218680 	call	81121868 <memcpy>
8112a880:	d8c00117 	ldw	r3,4(sp)
8112a884:	84400017 	ldw	r17,0(r16)
8112a888:	80800117 	ldw	r2,4(r16)
8112a88c:	81400c17 	ldw	r5,48(r16)
8112a890:	88e3883a 	add	r17,r17,r3
8112a894:	10c5c83a 	sub	r2,r2,r3
8112a898:	84400015 	stw	r17,0(r16)
8112a89c:	80800115 	stw	r2,4(r16)
8112a8a0:	b0e5c83a 	sub	r18,r22,r3
8112a8a4:	28002b26 	beq	r5,zero,8112a954 <_fread_r+0x228>
8112a8a8:	90002b26 	beq	r18,zero,8112a958 <_fread_r+0x22c>
8112a8ac:	80801004 	addi	r2,r16,64
8112a8b0:	28800526 	beq	r5,r2,8112a8c8 <_fread_r+0x19c>
8112a8b4:	a009883a 	mov	r4,r20
8112a8b8:	d8c00115 	stw	r3,4(sp)
8112a8bc:	112aac80 	call	8112aac8 <_free_r>
8112a8c0:	d8c00117 	ldw	r3,4(sp)
8112a8c4:	84400017 	ldw	r17,0(r16)
8112a8c8:	80000c15 	stw	zero,48(r16)
8112a8cc:	80800517 	ldw	r2,20(r16)
8112a8d0:	87000417 	ldw	fp,16(r16)
8112a8d4:	98e7883a 	add	r19,r19,r3
8112a8d8:	d8800015 	stw	r2,0(sp)
8112a8dc:	00000106 	br	8112a8e4 <_fread_r+0x1b8>
8112a8e0:	90001d26 	beq	r18,zero,8112a958 <_fread_r+0x22c>
8112a8e4:	84c00415 	stw	r19,16(r16)
8112a8e8:	84800515 	stw	r18,20(r16)
8112a8ec:	84c00015 	stw	r19,0(r16)
8112a8f0:	a009883a 	mov	r4,r20
8112a8f4:	800b883a 	mov	r5,r16
8112a8f8:	1121e340 	call	81121e34 <__srefill_r>
8112a8fc:	d9000017 	ldw	r4,0(sp)
8112a900:	80c00117 	ldw	r3,4(r16)
8112a904:	87000415 	stw	fp,16(r16)
8112a908:	81000515 	stw	r4,20(r16)
8112a90c:	84400015 	stw	r17,0(r16)
8112a910:	80000115 	stw	zero,4(r16)
8112a914:	90e5c83a 	sub	r18,r18,r3
8112a918:	98e7883a 	add	r19,r19,r3
8112a91c:	103ff026 	beq	r2,zero,8112a8e0 <__reset+0xfb10a8e0>
8112a920:	b80b883a 	mov	r5,r23
8112a924:	b489c83a 	sub	r4,r22,r18
8112a928:	1133dd40 	call	81133dd4 <__udivsi3>
8112a92c:	003fbe06 	br	8112a828 <__reset+0xfb10a828>
8112a930:	80000115 	stw	zero,4(r16)
8112a934:	0009883a 	mov	r4,zero
8112a938:	0023883a 	mov	r17,zero
8112a93c:	003f9e06 	br	8112a7b8 <__reset+0xfb10a7b8>
8112a940:	112a6300 	call	8112a630 <__sinit>
8112a944:	8080030b 	ldhu	r2,12(r16)
8112a948:	10c8000c 	andi	r3,r2,8192
8112a94c:	183f971e 	bne	r3,zero,8112a7ac <__reset+0xfb10a7ac>
8112a950:	003f9006 	br	8112a794 <__reset+0xfb10a794>
8112a954:	903fdd1e 	bne	r18,zero,8112a8cc <__reset+0xfb10a8cc>
8112a958:	a805883a 	mov	r2,r21
8112a95c:	003fb206 	br	8112a828 <__reset+0xfb10a828>

8112a960 <fread>:
8112a960:	defffe04 	addi	sp,sp,-8
8112a964:	00a04574 	movhi	r2,33045
8112a968:	de00012e 	bgeu	sp,et,8112a970 <fread+0x10>
8112a96c:	003b68fa 	trap	3
8112a970:	10886904 	addi	r2,r2,8612
8112a974:	d9c00015 	stw	r7,0(sp)
8112a978:	300f883a 	mov	r7,r6
8112a97c:	280d883a 	mov	r6,r5
8112a980:	200b883a 	mov	r5,r4
8112a984:	11000017 	ldw	r4,0(r2)
8112a988:	dfc00115 	stw	ra,4(sp)
8112a98c:	112a72c0 	call	8112a72c <_fread_r>
8112a990:	dfc00117 	ldw	ra,4(sp)
8112a994:	dec00204 	addi	sp,sp,8
8112a998:	f800283a 	ret

8112a99c <_malloc_trim_r>:
8112a99c:	defffb04 	addi	sp,sp,-20
8112a9a0:	de00012e 	bgeu	sp,et,8112a9a8 <_malloc_trim_r+0xc>
8112a9a4:	003b68fa 	trap	3
8112a9a8:	dcc00315 	stw	r19,12(sp)
8112a9ac:	04e04574 	movhi	r19,33045
8112a9b0:	dc800215 	stw	r18,8(sp)
8112a9b4:	dc400115 	stw	r17,4(sp)
8112a9b8:	dc000015 	stw	r16,0(sp)
8112a9bc:	dfc00415 	stw	ra,16(sp)
8112a9c0:	2821883a 	mov	r16,r5
8112a9c4:	9cc22704 	addi	r19,r19,2204
8112a9c8:	2025883a 	mov	r18,r4
8112a9cc:	11372900 	call	81137290 <__malloc_lock>
8112a9d0:	98800217 	ldw	r2,8(r19)
8112a9d4:	14400117 	ldw	r17,4(r2)
8112a9d8:	00bfff04 	movi	r2,-4
8112a9dc:	88a2703a 	and	r17,r17,r2
8112a9e0:	8c21c83a 	sub	r16,r17,r16
8112a9e4:	8403fbc4 	addi	r16,r16,4079
8112a9e8:	8020d33a 	srli	r16,r16,12
8112a9ec:	0083ffc4 	movi	r2,4095
8112a9f0:	843fffc4 	addi	r16,r16,-1
8112a9f4:	8020933a 	slli	r16,r16,12
8112a9f8:	1400060e 	bge	r2,r16,8112aa14 <_malloc_trim_r+0x78>
8112a9fc:	000b883a 	mov	r5,zero
8112aa00:	9009883a 	mov	r4,r18
8112aa04:	11220100 	call	81122010 <_sbrk_r>
8112aa08:	98c00217 	ldw	r3,8(r19)
8112aa0c:	1c47883a 	add	r3,r3,r17
8112aa10:	10c00a26 	beq	r2,r3,8112aa3c <_malloc_trim_r+0xa0>
8112aa14:	9009883a 	mov	r4,r18
8112aa18:	11373b80 	call	811373b8 <__malloc_unlock>
8112aa1c:	0005883a 	mov	r2,zero
8112aa20:	dfc00417 	ldw	ra,16(sp)
8112aa24:	dcc00317 	ldw	r19,12(sp)
8112aa28:	dc800217 	ldw	r18,8(sp)
8112aa2c:	dc400117 	ldw	r17,4(sp)
8112aa30:	dc000017 	ldw	r16,0(sp)
8112aa34:	dec00504 	addi	sp,sp,20
8112aa38:	f800283a 	ret
8112aa3c:	040bc83a 	sub	r5,zero,r16
8112aa40:	9009883a 	mov	r4,r18
8112aa44:	11220100 	call	81122010 <_sbrk_r>
8112aa48:	00ffffc4 	movi	r3,-1
8112aa4c:	10c00d26 	beq	r2,r3,8112aa84 <_malloc_trim_r+0xe8>
8112aa50:	00e04574 	movhi	r3,33045
8112aa54:	18c96b04 	addi	r3,r3,9644
8112aa58:	18800017 	ldw	r2,0(r3)
8112aa5c:	99000217 	ldw	r4,8(r19)
8112aa60:	8c23c83a 	sub	r17,r17,r16
8112aa64:	8c400054 	ori	r17,r17,1
8112aa68:	1421c83a 	sub	r16,r2,r16
8112aa6c:	24400115 	stw	r17,4(r4)
8112aa70:	9009883a 	mov	r4,r18
8112aa74:	1c000015 	stw	r16,0(r3)
8112aa78:	11373b80 	call	811373b8 <__malloc_unlock>
8112aa7c:	00800044 	movi	r2,1
8112aa80:	003fe706 	br	8112aa20 <__reset+0xfb10aa20>
8112aa84:	000b883a 	mov	r5,zero
8112aa88:	9009883a 	mov	r4,r18
8112aa8c:	11220100 	call	81122010 <_sbrk_r>
8112aa90:	99000217 	ldw	r4,8(r19)
8112aa94:	014003c4 	movi	r5,15
8112aa98:	1107c83a 	sub	r3,r2,r4
8112aa9c:	28ffdd0e 	bge	r5,r3,8112aa14 <__reset+0xfb10aa14>
8112aaa0:	01604574 	movhi	r5,33045
8112aaa4:	29486a04 	addi	r5,r5,8616
8112aaa8:	29400017 	ldw	r5,0(r5)
8112aaac:	18c00054 	ori	r3,r3,1
8112aab0:	20c00115 	stw	r3,4(r4)
8112aab4:	00e04574 	movhi	r3,33045
8112aab8:	1145c83a 	sub	r2,r2,r5
8112aabc:	18c96b04 	addi	r3,r3,9644
8112aac0:	18800015 	stw	r2,0(r3)
8112aac4:	003fd306 	br	8112aa14 <__reset+0xfb10aa14>

8112aac8 <_free_r>:
8112aac8:	28004326 	beq	r5,zero,8112abd8 <_free_r+0x110>
8112aacc:	defffd04 	addi	sp,sp,-12
8112aad0:	de00012e 	bgeu	sp,et,8112aad8 <_free_r+0x10>
8112aad4:	003b68fa 	trap	3
8112aad8:	dc400115 	stw	r17,4(sp)
8112aadc:	dc000015 	stw	r16,0(sp)
8112aae0:	2023883a 	mov	r17,r4
8112aae4:	2821883a 	mov	r16,r5
8112aae8:	dfc00215 	stw	ra,8(sp)
8112aaec:	11372900 	call	81137290 <__malloc_lock>
8112aaf0:	81ffff17 	ldw	r7,-4(r16)
8112aaf4:	00bfff84 	movi	r2,-2
8112aaf8:	01204574 	movhi	r4,33045
8112aafc:	81bffe04 	addi	r6,r16,-8
8112ab00:	3884703a 	and	r2,r7,r2
8112ab04:	21022704 	addi	r4,r4,2204
8112ab08:	308b883a 	add	r5,r6,r2
8112ab0c:	2a400117 	ldw	r9,4(r5)
8112ab10:	22000217 	ldw	r8,8(r4)
8112ab14:	00ffff04 	movi	r3,-4
8112ab18:	48c6703a 	and	r3,r9,r3
8112ab1c:	2a005726 	beq	r5,r8,8112ac7c <_free_r+0x1b4>
8112ab20:	28c00115 	stw	r3,4(r5)
8112ab24:	39c0004c 	andi	r7,r7,1
8112ab28:	3800091e 	bne	r7,zero,8112ab50 <_free_r+0x88>
8112ab2c:	823ffe17 	ldw	r8,-8(r16)
8112ab30:	22400204 	addi	r9,r4,8
8112ab34:	320dc83a 	sub	r6,r6,r8
8112ab38:	31c00217 	ldw	r7,8(r6)
8112ab3c:	1205883a 	add	r2,r2,r8
8112ab40:	3a406526 	beq	r7,r9,8112acd8 <_free_r+0x210>
8112ab44:	32000317 	ldw	r8,12(r6)
8112ab48:	3a000315 	stw	r8,12(r7)
8112ab4c:	41c00215 	stw	r7,8(r8)
8112ab50:	28cf883a 	add	r7,r5,r3
8112ab54:	39c00117 	ldw	r7,4(r7)
8112ab58:	39c0004c 	andi	r7,r7,1
8112ab5c:	38003a26 	beq	r7,zero,8112ac48 <_free_r+0x180>
8112ab60:	10c00054 	ori	r3,r2,1
8112ab64:	30c00115 	stw	r3,4(r6)
8112ab68:	3087883a 	add	r3,r6,r2
8112ab6c:	18800015 	stw	r2,0(r3)
8112ab70:	00c07fc4 	movi	r3,511
8112ab74:	18801936 	bltu	r3,r2,8112abdc <_free_r+0x114>
8112ab78:	1004d0fa 	srli	r2,r2,3
8112ab7c:	01c00044 	movi	r7,1
8112ab80:	21400117 	ldw	r5,4(r4)
8112ab84:	10c00044 	addi	r3,r2,1
8112ab88:	18c7883a 	add	r3,r3,r3
8112ab8c:	1005d0ba 	srai	r2,r2,2
8112ab90:	18c7883a 	add	r3,r3,r3
8112ab94:	18c7883a 	add	r3,r3,r3
8112ab98:	1907883a 	add	r3,r3,r4
8112ab9c:	3884983a 	sll	r2,r7,r2
8112aba0:	19c00017 	ldw	r7,0(r3)
8112aba4:	1a3ffe04 	addi	r8,r3,-8
8112aba8:	1144b03a 	or	r2,r2,r5
8112abac:	32000315 	stw	r8,12(r6)
8112abb0:	31c00215 	stw	r7,8(r6)
8112abb4:	20800115 	stw	r2,4(r4)
8112abb8:	19800015 	stw	r6,0(r3)
8112abbc:	39800315 	stw	r6,12(r7)
8112abc0:	8809883a 	mov	r4,r17
8112abc4:	dfc00217 	ldw	ra,8(sp)
8112abc8:	dc400117 	ldw	r17,4(sp)
8112abcc:	dc000017 	ldw	r16,0(sp)
8112abd0:	dec00304 	addi	sp,sp,12
8112abd4:	11373b81 	jmpi	811373b8 <__malloc_unlock>
8112abd8:	f800283a 	ret
8112abdc:	100ad27a 	srli	r5,r2,9
8112abe0:	00c00104 	movi	r3,4
8112abe4:	19404a36 	bltu	r3,r5,8112ad10 <_free_r+0x248>
8112abe8:	100ad1ba 	srli	r5,r2,6
8112abec:	28c00e44 	addi	r3,r5,57
8112abf0:	18c7883a 	add	r3,r3,r3
8112abf4:	29400e04 	addi	r5,r5,56
8112abf8:	18c7883a 	add	r3,r3,r3
8112abfc:	18c7883a 	add	r3,r3,r3
8112ac00:	1909883a 	add	r4,r3,r4
8112ac04:	20c00017 	ldw	r3,0(r4)
8112ac08:	01e04574 	movhi	r7,33045
8112ac0c:	213ffe04 	addi	r4,r4,-8
8112ac10:	39c22704 	addi	r7,r7,2204
8112ac14:	20c04426 	beq	r4,r3,8112ad28 <_free_r+0x260>
8112ac18:	01ffff04 	movi	r7,-4
8112ac1c:	19400117 	ldw	r5,4(r3)
8112ac20:	29ca703a 	and	r5,r5,r7
8112ac24:	1140022e 	bgeu	r2,r5,8112ac30 <_free_r+0x168>
8112ac28:	18c00217 	ldw	r3,8(r3)
8112ac2c:	20fffb1e 	bne	r4,r3,8112ac1c <__reset+0xfb10ac1c>
8112ac30:	19000317 	ldw	r4,12(r3)
8112ac34:	31000315 	stw	r4,12(r6)
8112ac38:	30c00215 	stw	r3,8(r6)
8112ac3c:	21800215 	stw	r6,8(r4)
8112ac40:	19800315 	stw	r6,12(r3)
8112ac44:	003fde06 	br	8112abc0 <__reset+0xfb10abc0>
8112ac48:	29c00217 	ldw	r7,8(r5)
8112ac4c:	10c5883a 	add	r2,r2,r3
8112ac50:	00e04574 	movhi	r3,33045
8112ac54:	18c22904 	addi	r3,r3,2212
8112ac58:	38c03b26 	beq	r7,r3,8112ad48 <_free_r+0x280>
8112ac5c:	2a000317 	ldw	r8,12(r5)
8112ac60:	11400054 	ori	r5,r2,1
8112ac64:	3087883a 	add	r3,r6,r2
8112ac68:	3a000315 	stw	r8,12(r7)
8112ac6c:	41c00215 	stw	r7,8(r8)
8112ac70:	31400115 	stw	r5,4(r6)
8112ac74:	18800015 	stw	r2,0(r3)
8112ac78:	003fbd06 	br	8112ab70 <__reset+0xfb10ab70>
8112ac7c:	39c0004c 	andi	r7,r7,1
8112ac80:	10c5883a 	add	r2,r2,r3
8112ac84:	3800071e 	bne	r7,zero,8112aca4 <_free_r+0x1dc>
8112ac88:	81fffe17 	ldw	r7,-8(r16)
8112ac8c:	31cdc83a 	sub	r6,r6,r7
8112ac90:	30c00317 	ldw	r3,12(r6)
8112ac94:	31400217 	ldw	r5,8(r6)
8112ac98:	11c5883a 	add	r2,r2,r7
8112ac9c:	28c00315 	stw	r3,12(r5)
8112aca0:	19400215 	stw	r5,8(r3)
8112aca4:	10c00054 	ori	r3,r2,1
8112aca8:	30c00115 	stw	r3,4(r6)
8112acac:	00e04574 	movhi	r3,33045
8112acb0:	18c86b04 	addi	r3,r3,8620
8112acb4:	18c00017 	ldw	r3,0(r3)
8112acb8:	21800215 	stw	r6,8(r4)
8112acbc:	10ffc036 	bltu	r2,r3,8112abc0 <__reset+0xfb10abc0>
8112acc0:	00a04574 	movhi	r2,33045
8112acc4:	1088de04 	addi	r2,r2,9080
8112acc8:	11400017 	ldw	r5,0(r2)
8112accc:	8809883a 	mov	r4,r17
8112acd0:	112a99c0 	call	8112a99c <_malloc_trim_r>
8112acd4:	003fba06 	br	8112abc0 <__reset+0xfb10abc0>
8112acd8:	28c9883a 	add	r4,r5,r3
8112acdc:	21000117 	ldw	r4,4(r4)
8112ace0:	2100004c 	andi	r4,r4,1
8112ace4:	2000391e 	bne	r4,zero,8112adcc <_free_r+0x304>
8112ace8:	29c00217 	ldw	r7,8(r5)
8112acec:	29000317 	ldw	r4,12(r5)
8112acf0:	1885883a 	add	r2,r3,r2
8112acf4:	10c00054 	ori	r3,r2,1
8112acf8:	39000315 	stw	r4,12(r7)
8112acfc:	21c00215 	stw	r7,8(r4)
8112ad00:	30c00115 	stw	r3,4(r6)
8112ad04:	308d883a 	add	r6,r6,r2
8112ad08:	30800015 	stw	r2,0(r6)
8112ad0c:	003fac06 	br	8112abc0 <__reset+0xfb10abc0>
8112ad10:	00c00504 	movi	r3,20
8112ad14:	19401536 	bltu	r3,r5,8112ad6c <_free_r+0x2a4>
8112ad18:	28c01704 	addi	r3,r5,92
8112ad1c:	18c7883a 	add	r3,r3,r3
8112ad20:	294016c4 	addi	r5,r5,91
8112ad24:	003fb406 	br	8112abf8 <__reset+0xfb10abf8>
8112ad28:	280bd0ba 	srai	r5,r5,2
8112ad2c:	00c00044 	movi	r3,1
8112ad30:	38800117 	ldw	r2,4(r7)
8112ad34:	194a983a 	sll	r5,r3,r5
8112ad38:	2007883a 	mov	r3,r4
8112ad3c:	2884b03a 	or	r2,r5,r2
8112ad40:	38800115 	stw	r2,4(r7)
8112ad44:	003fbb06 	br	8112ac34 <__reset+0xfb10ac34>
8112ad48:	21800515 	stw	r6,20(r4)
8112ad4c:	21800415 	stw	r6,16(r4)
8112ad50:	10c00054 	ori	r3,r2,1
8112ad54:	31c00315 	stw	r7,12(r6)
8112ad58:	31c00215 	stw	r7,8(r6)
8112ad5c:	30c00115 	stw	r3,4(r6)
8112ad60:	308d883a 	add	r6,r6,r2
8112ad64:	30800015 	stw	r2,0(r6)
8112ad68:	003f9506 	br	8112abc0 <__reset+0xfb10abc0>
8112ad6c:	00c01504 	movi	r3,84
8112ad70:	19400536 	bltu	r3,r5,8112ad88 <_free_r+0x2c0>
8112ad74:	100ad33a 	srli	r5,r2,12
8112ad78:	28c01bc4 	addi	r3,r5,111
8112ad7c:	18c7883a 	add	r3,r3,r3
8112ad80:	29401b84 	addi	r5,r5,110
8112ad84:	003f9c06 	br	8112abf8 <__reset+0xfb10abf8>
8112ad88:	00c05504 	movi	r3,340
8112ad8c:	19400536 	bltu	r3,r5,8112ada4 <_free_r+0x2dc>
8112ad90:	100ad3fa 	srli	r5,r2,15
8112ad94:	28c01e04 	addi	r3,r5,120
8112ad98:	18c7883a 	add	r3,r3,r3
8112ad9c:	29401dc4 	addi	r5,r5,119
8112ada0:	003f9506 	br	8112abf8 <__reset+0xfb10abf8>
8112ada4:	00c15504 	movi	r3,1364
8112ada8:	19400536 	bltu	r3,r5,8112adc0 <_free_r+0x2f8>
8112adac:	100ad4ba 	srli	r5,r2,18
8112adb0:	28c01f44 	addi	r3,r5,125
8112adb4:	18c7883a 	add	r3,r3,r3
8112adb8:	29401f04 	addi	r5,r5,124
8112adbc:	003f8e06 	br	8112abf8 <__reset+0xfb10abf8>
8112adc0:	00c03f84 	movi	r3,254
8112adc4:	01401f84 	movi	r5,126
8112adc8:	003f8b06 	br	8112abf8 <__reset+0xfb10abf8>
8112adcc:	10c00054 	ori	r3,r2,1
8112add0:	30c00115 	stw	r3,4(r6)
8112add4:	308d883a 	add	r6,r6,r2
8112add8:	30800015 	stw	r2,0(r6)
8112addc:	003f7806 	br	8112abc0 <__reset+0xfb10abc0>

8112ade0 <__sfvwrite_r>:
8112ade0:	30800217 	ldw	r2,8(r6)
8112ade4:	10006926 	beq	r2,zero,8112af8c <__sfvwrite_r+0x1ac>
8112ade8:	defff404 	addi	sp,sp,-48
8112adec:	de00012e 	bgeu	sp,et,8112adf4 <__sfvwrite_r+0x14>
8112adf0:	003b68fa 	trap	3
8112adf4:	28c0030b 	ldhu	r3,12(r5)
8112adf8:	dd400715 	stw	r21,28(sp)
8112adfc:	dd000615 	stw	r20,24(sp)
8112ae00:	dc000215 	stw	r16,8(sp)
8112ae04:	dfc00b15 	stw	ra,44(sp)
8112ae08:	df000a15 	stw	fp,40(sp)
8112ae0c:	ddc00915 	stw	r23,36(sp)
8112ae10:	dd800815 	stw	r22,32(sp)
8112ae14:	dcc00515 	stw	r19,20(sp)
8112ae18:	dc800415 	stw	r18,16(sp)
8112ae1c:	dc400315 	stw	r17,12(sp)
8112ae20:	1880020c 	andi	r2,r3,8
8112ae24:	2821883a 	mov	r16,r5
8112ae28:	202b883a 	mov	r21,r4
8112ae2c:	3029883a 	mov	r20,r6
8112ae30:	10002726 	beq	r2,zero,8112aed0 <__sfvwrite_r+0xf0>
8112ae34:	28800417 	ldw	r2,16(r5)
8112ae38:	10002526 	beq	r2,zero,8112aed0 <__sfvwrite_r+0xf0>
8112ae3c:	1880008c 	andi	r2,r3,2
8112ae40:	a4400017 	ldw	r17,0(r20)
8112ae44:	10002a26 	beq	r2,zero,8112aef0 <__sfvwrite_r+0x110>
8112ae48:	05a00034 	movhi	r22,32768
8112ae4c:	0027883a 	mov	r19,zero
8112ae50:	0025883a 	mov	r18,zero
8112ae54:	b5bf0004 	addi	r22,r22,-1024
8112ae58:	980d883a 	mov	r6,r19
8112ae5c:	a809883a 	mov	r4,r21
8112ae60:	90004626 	beq	r18,zero,8112af7c <__sfvwrite_r+0x19c>
8112ae64:	900f883a 	mov	r7,r18
8112ae68:	b480022e 	bgeu	r22,r18,8112ae74 <__sfvwrite_r+0x94>
8112ae6c:	01e00034 	movhi	r7,32768
8112ae70:	39ff0004 	addi	r7,r7,-1024
8112ae74:	80800917 	ldw	r2,36(r16)
8112ae78:	81400717 	ldw	r5,28(r16)
8112ae7c:	103ee83a 	callr	r2
8112ae80:	0080570e 	bge	zero,r2,8112afe0 <__sfvwrite_r+0x200>
8112ae84:	a0c00217 	ldw	r3,8(r20)
8112ae88:	98a7883a 	add	r19,r19,r2
8112ae8c:	90a5c83a 	sub	r18,r18,r2
8112ae90:	1885c83a 	sub	r2,r3,r2
8112ae94:	a0800215 	stw	r2,8(r20)
8112ae98:	103fef1e 	bne	r2,zero,8112ae58 <__reset+0xfb10ae58>
8112ae9c:	0005883a 	mov	r2,zero
8112aea0:	dfc00b17 	ldw	ra,44(sp)
8112aea4:	df000a17 	ldw	fp,40(sp)
8112aea8:	ddc00917 	ldw	r23,36(sp)
8112aeac:	dd800817 	ldw	r22,32(sp)
8112aeb0:	dd400717 	ldw	r21,28(sp)
8112aeb4:	dd000617 	ldw	r20,24(sp)
8112aeb8:	dcc00517 	ldw	r19,20(sp)
8112aebc:	dc800417 	ldw	r18,16(sp)
8112aec0:	dc400317 	ldw	r17,12(sp)
8112aec4:	dc000217 	ldw	r16,8(sp)
8112aec8:	dec00c04 	addi	sp,sp,48
8112aecc:	f800283a 	ret
8112aed0:	800b883a 	mov	r5,r16
8112aed4:	a809883a 	mov	r4,r21
8112aed8:	11285c00 	call	811285c0 <__swsetup_r>
8112aedc:	1000eb1e 	bne	r2,zero,8112b28c <__sfvwrite_r+0x4ac>
8112aee0:	80c0030b 	ldhu	r3,12(r16)
8112aee4:	a4400017 	ldw	r17,0(r20)
8112aee8:	1880008c 	andi	r2,r3,2
8112aeec:	103fd61e 	bne	r2,zero,8112ae48 <__reset+0xfb10ae48>
8112aef0:	1880004c 	andi	r2,r3,1
8112aef4:	10003f1e 	bne	r2,zero,8112aff4 <__sfvwrite_r+0x214>
8112aef8:	0039883a 	mov	fp,zero
8112aefc:	0025883a 	mov	r18,zero
8112af00:	90001a26 	beq	r18,zero,8112af6c <__sfvwrite_r+0x18c>
8112af04:	1880800c 	andi	r2,r3,512
8112af08:	84c00217 	ldw	r19,8(r16)
8112af0c:	10002126 	beq	r2,zero,8112af94 <__sfvwrite_r+0x1b4>
8112af10:	982f883a 	mov	r23,r19
8112af14:	94c09336 	bltu	r18,r19,8112b164 <__sfvwrite_r+0x384>
8112af18:	1881200c 	andi	r2,r3,1152
8112af1c:	10009e1e 	bne	r2,zero,8112b198 <__sfvwrite_r+0x3b8>
8112af20:	81000017 	ldw	r4,0(r16)
8112af24:	b80d883a 	mov	r6,r23
8112af28:	e00b883a 	mov	r5,fp
8112af2c:	112b93c0 	call	8112b93c <memmove>
8112af30:	80c00217 	ldw	r3,8(r16)
8112af34:	81000017 	ldw	r4,0(r16)
8112af38:	9005883a 	mov	r2,r18
8112af3c:	1ce7c83a 	sub	r19,r3,r19
8112af40:	25cf883a 	add	r7,r4,r23
8112af44:	84c00215 	stw	r19,8(r16)
8112af48:	81c00015 	stw	r7,0(r16)
8112af4c:	a0c00217 	ldw	r3,8(r20)
8112af50:	e0b9883a 	add	fp,fp,r2
8112af54:	90a5c83a 	sub	r18,r18,r2
8112af58:	18a7c83a 	sub	r19,r3,r2
8112af5c:	a4c00215 	stw	r19,8(r20)
8112af60:	983fce26 	beq	r19,zero,8112ae9c <__reset+0xfb10ae9c>
8112af64:	80c0030b 	ldhu	r3,12(r16)
8112af68:	903fe61e 	bne	r18,zero,8112af04 <__reset+0xfb10af04>
8112af6c:	8f000017 	ldw	fp,0(r17)
8112af70:	8c800117 	ldw	r18,4(r17)
8112af74:	8c400204 	addi	r17,r17,8
8112af78:	003fe106 	br	8112af00 <__reset+0xfb10af00>
8112af7c:	8cc00017 	ldw	r19,0(r17)
8112af80:	8c800117 	ldw	r18,4(r17)
8112af84:	8c400204 	addi	r17,r17,8
8112af88:	003fb306 	br	8112ae58 <__reset+0xfb10ae58>
8112af8c:	0005883a 	mov	r2,zero
8112af90:	f800283a 	ret
8112af94:	81000017 	ldw	r4,0(r16)
8112af98:	80800417 	ldw	r2,16(r16)
8112af9c:	11005736 	bltu	r2,r4,8112b0fc <__sfvwrite_r+0x31c>
8112afa0:	85c00517 	ldw	r23,20(r16)
8112afa4:	95c05536 	bltu	r18,r23,8112b0fc <__sfvwrite_r+0x31c>
8112afa8:	00a00034 	movhi	r2,32768
8112afac:	10bfffc4 	addi	r2,r2,-1
8112afb0:	9009883a 	mov	r4,r18
8112afb4:	1480012e 	bgeu	r2,r18,8112afbc <__sfvwrite_r+0x1dc>
8112afb8:	1009883a 	mov	r4,r2
8112afbc:	b80b883a 	mov	r5,r23
8112afc0:	1133cdc0 	call	81133cdc <__divsi3>
8112afc4:	15cf383a 	mul	r7,r2,r23
8112afc8:	81400717 	ldw	r5,28(r16)
8112afcc:	80800917 	ldw	r2,36(r16)
8112afd0:	e00d883a 	mov	r6,fp
8112afd4:	a809883a 	mov	r4,r21
8112afd8:	103ee83a 	callr	r2
8112afdc:	00bfdb16 	blt	zero,r2,8112af4c <__reset+0xfb10af4c>
8112afe0:	8080030b 	ldhu	r2,12(r16)
8112afe4:	10801014 	ori	r2,r2,64
8112afe8:	8080030d 	sth	r2,12(r16)
8112afec:	00bfffc4 	movi	r2,-1
8112aff0:	003fab06 	br	8112aea0 <__reset+0xfb10aea0>
8112aff4:	0027883a 	mov	r19,zero
8112aff8:	0011883a 	mov	r8,zero
8112affc:	0039883a 	mov	fp,zero
8112b000:	0025883a 	mov	r18,zero
8112b004:	90001f26 	beq	r18,zero,8112b084 <__sfvwrite_r+0x2a4>
8112b008:	40005a26 	beq	r8,zero,8112b174 <__sfvwrite_r+0x394>
8112b00c:	982d883a 	mov	r22,r19
8112b010:	94c0012e 	bgeu	r18,r19,8112b018 <__sfvwrite_r+0x238>
8112b014:	902d883a 	mov	r22,r18
8112b018:	81000017 	ldw	r4,0(r16)
8112b01c:	80800417 	ldw	r2,16(r16)
8112b020:	b02f883a 	mov	r23,r22
8112b024:	81c00517 	ldw	r7,20(r16)
8112b028:	1100032e 	bgeu	r2,r4,8112b038 <__sfvwrite_r+0x258>
8112b02c:	80c00217 	ldw	r3,8(r16)
8112b030:	38c7883a 	add	r3,r7,r3
8112b034:	1d801816 	blt	r3,r22,8112b098 <__sfvwrite_r+0x2b8>
8112b038:	b1c03e16 	blt	r22,r7,8112b134 <__sfvwrite_r+0x354>
8112b03c:	80800917 	ldw	r2,36(r16)
8112b040:	81400717 	ldw	r5,28(r16)
8112b044:	e00d883a 	mov	r6,fp
8112b048:	da000115 	stw	r8,4(sp)
8112b04c:	a809883a 	mov	r4,r21
8112b050:	103ee83a 	callr	r2
8112b054:	102f883a 	mov	r23,r2
8112b058:	da000117 	ldw	r8,4(sp)
8112b05c:	00bfe00e 	bge	zero,r2,8112afe0 <__reset+0xfb10afe0>
8112b060:	9de7c83a 	sub	r19,r19,r23
8112b064:	98001f26 	beq	r19,zero,8112b0e4 <__sfvwrite_r+0x304>
8112b068:	a0800217 	ldw	r2,8(r20)
8112b06c:	e5f9883a 	add	fp,fp,r23
8112b070:	95e5c83a 	sub	r18,r18,r23
8112b074:	15efc83a 	sub	r23,r2,r23
8112b078:	a5c00215 	stw	r23,8(r20)
8112b07c:	b83f8726 	beq	r23,zero,8112ae9c <__reset+0xfb10ae9c>
8112b080:	903fe11e 	bne	r18,zero,8112b008 <__reset+0xfb10b008>
8112b084:	8f000017 	ldw	fp,0(r17)
8112b088:	8c800117 	ldw	r18,4(r17)
8112b08c:	0011883a 	mov	r8,zero
8112b090:	8c400204 	addi	r17,r17,8
8112b094:	003fdb06 	br	8112b004 <__reset+0xfb10b004>
8112b098:	180d883a 	mov	r6,r3
8112b09c:	e00b883a 	mov	r5,fp
8112b0a0:	da000115 	stw	r8,4(sp)
8112b0a4:	d8c00015 	stw	r3,0(sp)
8112b0a8:	112b93c0 	call	8112b93c <memmove>
8112b0ac:	d8c00017 	ldw	r3,0(sp)
8112b0b0:	80800017 	ldw	r2,0(r16)
8112b0b4:	800b883a 	mov	r5,r16
8112b0b8:	a809883a 	mov	r4,r21
8112b0bc:	10c5883a 	add	r2,r2,r3
8112b0c0:	80800015 	stw	r2,0(r16)
8112b0c4:	d8c00015 	stw	r3,0(sp)
8112b0c8:	112a2340 	call	8112a234 <_fflush_r>
8112b0cc:	d8c00017 	ldw	r3,0(sp)
8112b0d0:	da000117 	ldw	r8,4(sp)
8112b0d4:	103fc21e 	bne	r2,zero,8112afe0 <__reset+0xfb10afe0>
8112b0d8:	182f883a 	mov	r23,r3
8112b0dc:	9de7c83a 	sub	r19,r19,r23
8112b0e0:	983fe11e 	bne	r19,zero,8112b068 <__reset+0xfb10b068>
8112b0e4:	800b883a 	mov	r5,r16
8112b0e8:	a809883a 	mov	r4,r21
8112b0ec:	112a2340 	call	8112a234 <_fflush_r>
8112b0f0:	103fbb1e 	bne	r2,zero,8112afe0 <__reset+0xfb10afe0>
8112b0f4:	0011883a 	mov	r8,zero
8112b0f8:	003fdb06 	br	8112b068 <__reset+0xfb10b068>
8112b0fc:	94c0012e 	bgeu	r18,r19,8112b104 <__sfvwrite_r+0x324>
8112b100:	9027883a 	mov	r19,r18
8112b104:	980d883a 	mov	r6,r19
8112b108:	e00b883a 	mov	r5,fp
8112b10c:	112b93c0 	call	8112b93c <memmove>
8112b110:	80800217 	ldw	r2,8(r16)
8112b114:	80c00017 	ldw	r3,0(r16)
8112b118:	14c5c83a 	sub	r2,r2,r19
8112b11c:	1cc7883a 	add	r3,r3,r19
8112b120:	80800215 	stw	r2,8(r16)
8112b124:	80c00015 	stw	r3,0(r16)
8112b128:	10004326 	beq	r2,zero,8112b238 <__sfvwrite_r+0x458>
8112b12c:	9805883a 	mov	r2,r19
8112b130:	003f8606 	br	8112af4c <__reset+0xfb10af4c>
8112b134:	b00d883a 	mov	r6,r22
8112b138:	e00b883a 	mov	r5,fp
8112b13c:	da000115 	stw	r8,4(sp)
8112b140:	112b93c0 	call	8112b93c <memmove>
8112b144:	80800217 	ldw	r2,8(r16)
8112b148:	80c00017 	ldw	r3,0(r16)
8112b14c:	da000117 	ldw	r8,4(sp)
8112b150:	1585c83a 	sub	r2,r2,r22
8112b154:	1dad883a 	add	r22,r3,r22
8112b158:	80800215 	stw	r2,8(r16)
8112b15c:	85800015 	stw	r22,0(r16)
8112b160:	003fbf06 	br	8112b060 <__reset+0xfb10b060>
8112b164:	81000017 	ldw	r4,0(r16)
8112b168:	9027883a 	mov	r19,r18
8112b16c:	902f883a 	mov	r23,r18
8112b170:	003f6c06 	br	8112af24 <__reset+0xfb10af24>
8112b174:	900d883a 	mov	r6,r18
8112b178:	01400284 	movi	r5,10
8112b17c:	e009883a 	mov	r4,fp
8112b180:	112b8580 	call	8112b858 <memchr>
8112b184:	10003e26 	beq	r2,zero,8112b280 <__sfvwrite_r+0x4a0>
8112b188:	10800044 	addi	r2,r2,1
8112b18c:	1727c83a 	sub	r19,r2,fp
8112b190:	02000044 	movi	r8,1
8112b194:	003f9d06 	br	8112b00c <__reset+0xfb10b00c>
8112b198:	80800517 	ldw	r2,20(r16)
8112b19c:	81400417 	ldw	r5,16(r16)
8112b1a0:	81c00017 	ldw	r7,0(r16)
8112b1a4:	10a7883a 	add	r19,r2,r2
8112b1a8:	9885883a 	add	r2,r19,r2
8112b1ac:	1026d7fa 	srli	r19,r2,31
8112b1b0:	396dc83a 	sub	r22,r7,r5
8112b1b4:	b1000044 	addi	r4,r22,1
8112b1b8:	9885883a 	add	r2,r19,r2
8112b1bc:	1027d07a 	srai	r19,r2,1
8112b1c0:	2485883a 	add	r2,r4,r18
8112b1c4:	980d883a 	mov	r6,r19
8112b1c8:	9880022e 	bgeu	r19,r2,8112b1d4 <__sfvwrite_r+0x3f4>
8112b1cc:	1027883a 	mov	r19,r2
8112b1d0:	100d883a 	mov	r6,r2
8112b1d4:	18c1000c 	andi	r3,r3,1024
8112b1d8:	18001c26 	beq	r3,zero,8112b24c <__sfvwrite_r+0x46c>
8112b1dc:	300b883a 	mov	r5,r6
8112b1e0:	a809883a 	mov	r4,r21
8112b1e4:	11210540 	call	81121054 <_malloc_r>
8112b1e8:	102f883a 	mov	r23,r2
8112b1ec:	10002926 	beq	r2,zero,8112b294 <__sfvwrite_r+0x4b4>
8112b1f0:	81400417 	ldw	r5,16(r16)
8112b1f4:	b00d883a 	mov	r6,r22
8112b1f8:	1009883a 	mov	r4,r2
8112b1fc:	11218680 	call	81121868 <memcpy>
8112b200:	8080030b 	ldhu	r2,12(r16)
8112b204:	00fedfc4 	movi	r3,-1153
8112b208:	10c4703a 	and	r2,r2,r3
8112b20c:	10802014 	ori	r2,r2,128
8112b210:	8080030d 	sth	r2,12(r16)
8112b214:	bd89883a 	add	r4,r23,r22
8112b218:	9d8fc83a 	sub	r7,r19,r22
8112b21c:	85c00415 	stw	r23,16(r16)
8112b220:	84c00515 	stw	r19,20(r16)
8112b224:	81000015 	stw	r4,0(r16)
8112b228:	9027883a 	mov	r19,r18
8112b22c:	81c00215 	stw	r7,8(r16)
8112b230:	902f883a 	mov	r23,r18
8112b234:	003f3b06 	br	8112af24 <__reset+0xfb10af24>
8112b238:	800b883a 	mov	r5,r16
8112b23c:	a809883a 	mov	r4,r21
8112b240:	112a2340 	call	8112a234 <_fflush_r>
8112b244:	103fb926 	beq	r2,zero,8112b12c <__reset+0xfb10b12c>
8112b248:	003f6506 	br	8112afe0 <__reset+0xfb10afe0>
8112b24c:	a809883a 	mov	r4,r21
8112b250:	112cb5c0 	call	8112cb5c <_realloc_r>
8112b254:	102f883a 	mov	r23,r2
8112b258:	103fee1e 	bne	r2,zero,8112b214 <__reset+0xfb10b214>
8112b25c:	81400417 	ldw	r5,16(r16)
8112b260:	a809883a 	mov	r4,r21
8112b264:	112aac80 	call	8112aac8 <_free_r>
8112b268:	8080030b 	ldhu	r2,12(r16)
8112b26c:	00ffdfc4 	movi	r3,-129
8112b270:	1884703a 	and	r2,r3,r2
8112b274:	00c00304 	movi	r3,12
8112b278:	a8c00015 	stw	r3,0(r21)
8112b27c:	003f5906 	br	8112afe4 <__reset+0xfb10afe4>
8112b280:	94c00044 	addi	r19,r18,1
8112b284:	02000044 	movi	r8,1
8112b288:	003f6006 	br	8112b00c <__reset+0xfb10b00c>
8112b28c:	00bfffc4 	movi	r2,-1
8112b290:	003f0306 	br	8112aea0 <__reset+0xfb10aea0>
8112b294:	00800304 	movi	r2,12
8112b298:	a8800015 	stw	r2,0(r21)
8112b29c:	8080030b 	ldhu	r2,12(r16)
8112b2a0:	003f5006 	br	8112afe4 <__reset+0xfb10afe4>

8112b2a4 <_fwalk>:
8112b2a4:	defff704 	addi	sp,sp,-36
8112b2a8:	de00012e 	bgeu	sp,et,8112b2b0 <_fwalk+0xc>
8112b2ac:	003b68fa 	trap	3
8112b2b0:	dd000415 	stw	r20,16(sp)
8112b2b4:	dfc00815 	stw	ra,32(sp)
8112b2b8:	ddc00715 	stw	r23,28(sp)
8112b2bc:	dd800615 	stw	r22,24(sp)
8112b2c0:	dd400515 	stw	r21,20(sp)
8112b2c4:	dcc00315 	stw	r19,12(sp)
8112b2c8:	dc800215 	stw	r18,8(sp)
8112b2cc:	dc400115 	stw	r17,4(sp)
8112b2d0:	dc000015 	stw	r16,0(sp)
8112b2d4:	2500b804 	addi	r20,r4,736
8112b2d8:	a0002326 	beq	r20,zero,8112b368 <_fwalk+0xc4>
8112b2dc:	282b883a 	mov	r21,r5
8112b2e0:	002f883a 	mov	r23,zero
8112b2e4:	05800044 	movi	r22,1
8112b2e8:	04ffffc4 	movi	r19,-1
8112b2ec:	a4400117 	ldw	r17,4(r20)
8112b2f0:	a4800217 	ldw	r18,8(r20)
8112b2f4:	8c7fffc4 	addi	r17,r17,-1
8112b2f8:	88000d16 	blt	r17,zero,8112b330 <_fwalk+0x8c>
8112b2fc:	94000304 	addi	r16,r18,12
8112b300:	94800384 	addi	r18,r18,14
8112b304:	8080000b 	ldhu	r2,0(r16)
8112b308:	8c7fffc4 	addi	r17,r17,-1
8112b30c:	813ffd04 	addi	r4,r16,-12
8112b310:	b080042e 	bgeu	r22,r2,8112b324 <_fwalk+0x80>
8112b314:	9080000f 	ldh	r2,0(r18)
8112b318:	14c00226 	beq	r2,r19,8112b324 <_fwalk+0x80>
8112b31c:	a83ee83a 	callr	r21
8112b320:	b8aeb03a 	or	r23,r23,r2
8112b324:	84001a04 	addi	r16,r16,104
8112b328:	94801a04 	addi	r18,r18,104
8112b32c:	8cfff51e 	bne	r17,r19,8112b304 <__reset+0xfb10b304>
8112b330:	a5000017 	ldw	r20,0(r20)
8112b334:	a03fed1e 	bne	r20,zero,8112b2ec <__reset+0xfb10b2ec>
8112b338:	b805883a 	mov	r2,r23
8112b33c:	dfc00817 	ldw	ra,32(sp)
8112b340:	ddc00717 	ldw	r23,28(sp)
8112b344:	dd800617 	ldw	r22,24(sp)
8112b348:	dd400517 	ldw	r21,20(sp)
8112b34c:	dd000417 	ldw	r20,16(sp)
8112b350:	dcc00317 	ldw	r19,12(sp)
8112b354:	dc800217 	ldw	r18,8(sp)
8112b358:	dc400117 	ldw	r17,4(sp)
8112b35c:	dc000017 	ldw	r16,0(sp)
8112b360:	dec00904 	addi	sp,sp,36
8112b364:	f800283a 	ret
8112b368:	002f883a 	mov	r23,zero
8112b36c:	003ff206 	br	8112b338 <__reset+0xfb10b338>

8112b370 <_fwalk_reent>:
8112b370:	defff704 	addi	sp,sp,-36
8112b374:	de00012e 	bgeu	sp,et,8112b37c <_fwalk_reent+0xc>
8112b378:	003b68fa 	trap	3
8112b37c:	dd000415 	stw	r20,16(sp)
8112b380:	dfc00815 	stw	ra,32(sp)
8112b384:	ddc00715 	stw	r23,28(sp)
8112b388:	dd800615 	stw	r22,24(sp)
8112b38c:	dd400515 	stw	r21,20(sp)
8112b390:	dcc00315 	stw	r19,12(sp)
8112b394:	dc800215 	stw	r18,8(sp)
8112b398:	dc400115 	stw	r17,4(sp)
8112b39c:	dc000015 	stw	r16,0(sp)
8112b3a0:	2500b804 	addi	r20,r4,736
8112b3a4:	a0002326 	beq	r20,zero,8112b434 <_fwalk_reent+0xc4>
8112b3a8:	282b883a 	mov	r21,r5
8112b3ac:	2027883a 	mov	r19,r4
8112b3b0:	002f883a 	mov	r23,zero
8112b3b4:	05800044 	movi	r22,1
8112b3b8:	04bfffc4 	movi	r18,-1
8112b3bc:	a4400117 	ldw	r17,4(r20)
8112b3c0:	a4000217 	ldw	r16,8(r20)
8112b3c4:	8c7fffc4 	addi	r17,r17,-1
8112b3c8:	88000c16 	blt	r17,zero,8112b3fc <_fwalk_reent+0x8c>
8112b3cc:	84000304 	addi	r16,r16,12
8112b3d0:	8080000b 	ldhu	r2,0(r16)
8112b3d4:	8c7fffc4 	addi	r17,r17,-1
8112b3d8:	817ffd04 	addi	r5,r16,-12
8112b3dc:	b080052e 	bgeu	r22,r2,8112b3f4 <_fwalk_reent+0x84>
8112b3e0:	8080008f 	ldh	r2,2(r16)
8112b3e4:	9809883a 	mov	r4,r19
8112b3e8:	14800226 	beq	r2,r18,8112b3f4 <_fwalk_reent+0x84>
8112b3ec:	a83ee83a 	callr	r21
8112b3f0:	b8aeb03a 	or	r23,r23,r2
8112b3f4:	84001a04 	addi	r16,r16,104
8112b3f8:	8cbff51e 	bne	r17,r18,8112b3d0 <__reset+0xfb10b3d0>
8112b3fc:	a5000017 	ldw	r20,0(r20)
8112b400:	a03fee1e 	bne	r20,zero,8112b3bc <__reset+0xfb10b3bc>
8112b404:	b805883a 	mov	r2,r23
8112b408:	dfc00817 	ldw	ra,32(sp)
8112b40c:	ddc00717 	ldw	r23,28(sp)
8112b410:	dd800617 	ldw	r22,24(sp)
8112b414:	dd400517 	ldw	r21,20(sp)
8112b418:	dd000417 	ldw	r20,16(sp)
8112b41c:	dcc00317 	ldw	r19,12(sp)
8112b420:	dc800217 	ldw	r18,8(sp)
8112b424:	dc400117 	ldw	r17,4(sp)
8112b428:	dc000017 	ldw	r16,0(sp)
8112b42c:	dec00904 	addi	sp,sp,36
8112b430:	f800283a 	ret
8112b434:	002f883a 	mov	r23,zero
8112b438:	003ff206 	br	8112b404 <__reset+0xfb10b404>

8112b43c <_isatty_r>:
8112b43c:	defffd04 	addi	sp,sp,-12
8112b440:	de00012e 	bgeu	sp,et,8112b448 <_isatty_r+0xc>
8112b444:	003b68fa 	trap	3
8112b448:	dc000015 	stw	r16,0(sp)
8112b44c:	04204574 	movhi	r16,33045
8112b450:	dc400115 	stw	r17,4(sp)
8112b454:	8408db04 	addi	r16,r16,9068
8112b458:	2023883a 	mov	r17,r4
8112b45c:	2809883a 	mov	r4,r5
8112b460:	dfc00215 	stw	ra,8(sp)
8112b464:	80000015 	stw	zero,0(r16)
8112b468:	11359cc0 	call	811359cc <isatty>
8112b46c:	00ffffc4 	movi	r3,-1
8112b470:	10c00526 	beq	r2,r3,8112b488 <_isatty_r+0x4c>
8112b474:	dfc00217 	ldw	ra,8(sp)
8112b478:	dc400117 	ldw	r17,4(sp)
8112b47c:	dc000017 	ldw	r16,0(sp)
8112b480:	dec00304 	addi	sp,sp,12
8112b484:	f800283a 	ret
8112b488:	80c00017 	ldw	r3,0(r16)
8112b48c:	183ff926 	beq	r3,zero,8112b474 <__reset+0xfb10b474>
8112b490:	88c00015 	stw	r3,0(r17)
8112b494:	003ff706 	br	8112b474 <__reset+0xfb10b474>

8112b498 <iswspace>:
8112b498:	00803fc4 	movi	r2,255
8112b49c:	11000836 	bltu	r2,r4,8112b4c0 <iswspace+0x28>
8112b4a0:	00a04574 	movhi	r2,33045
8112b4a4:	10886704 	addi	r2,r2,8604
8112b4a8:	10800017 	ldw	r2,0(r2)
8112b4ac:	1109883a 	add	r4,r2,r4
8112b4b0:	20800043 	ldbu	r2,1(r4)
8112b4b4:	1080020c 	andi	r2,r2,8
8112b4b8:	10803fcc 	andi	r2,r2,255
8112b4bc:	f800283a 	ret
8112b4c0:	0005883a 	mov	r2,zero
8112b4c4:	f800283a 	ret

8112b4c8 <_setlocale_r>:
8112b4c8:	30001d26 	beq	r6,zero,8112b540 <_setlocale_r+0x78>
8112b4cc:	01604574 	movhi	r5,33045
8112b4d0:	defffe04 	addi	sp,sp,-8
8112b4d4:	297ec004 	addi	r5,r5,-1280
8112b4d8:	3009883a 	mov	r4,r6
8112b4dc:	de00012e 	bgeu	sp,et,8112b4e4 <_setlocale_r+0x1c>
8112b4e0:	003b68fa 	trap	3
8112b4e4:	dc000015 	stw	r16,0(sp)
8112b4e8:	dfc00115 	stw	ra,4(sp)
8112b4ec:	3021883a 	mov	r16,r6
8112b4f0:	112d2140 	call	8112d214 <strcmp>
8112b4f4:	1000061e 	bne	r2,zero,8112b510 <_setlocale_r+0x48>
8112b4f8:	00a04574 	movhi	r2,33045
8112b4fc:	10be8f04 	addi	r2,r2,-1476
8112b500:	dfc00117 	ldw	ra,4(sp)
8112b504:	dc000017 	ldw	r16,0(sp)
8112b508:	dec00204 	addi	sp,sp,8
8112b50c:	f800283a 	ret
8112b510:	01604574 	movhi	r5,33045
8112b514:	297e8f04 	addi	r5,r5,-1476
8112b518:	8009883a 	mov	r4,r16
8112b51c:	112d2140 	call	8112d214 <strcmp>
8112b520:	103ff526 	beq	r2,zero,8112b4f8 <__reset+0xfb10b4f8>
8112b524:	01604574 	movhi	r5,33045
8112b528:	297e9904 	addi	r5,r5,-1436
8112b52c:	8009883a 	mov	r4,r16
8112b530:	112d2140 	call	8112d214 <strcmp>
8112b534:	103ff026 	beq	r2,zero,8112b4f8 <__reset+0xfb10b4f8>
8112b538:	0005883a 	mov	r2,zero
8112b53c:	003ff006 	br	8112b500 <__reset+0xfb10b500>
8112b540:	00a04574 	movhi	r2,33045
8112b544:	10be8f04 	addi	r2,r2,-1476
8112b548:	f800283a 	ret

8112b54c <__locale_charset>:
8112b54c:	00a04574 	movhi	r2,33045
8112b550:	10833104 	addi	r2,r2,3268
8112b554:	f800283a 	ret

8112b558 <__locale_mb_cur_max>:
8112b558:	00a04574 	movhi	r2,33045
8112b55c:	10886c04 	addi	r2,r2,8624
8112b560:	10800017 	ldw	r2,0(r2)
8112b564:	f800283a 	ret

8112b568 <__locale_msgcharset>:
8112b568:	00a04574 	movhi	r2,33045
8112b56c:	10832904 	addi	r2,r2,3236
8112b570:	f800283a 	ret

8112b574 <__locale_cjk_lang>:
8112b574:	0005883a 	mov	r2,zero
8112b578:	f800283a 	ret

8112b57c <_localeconv_r>:
8112b57c:	00a04574 	movhi	r2,33045
8112b580:	10833904 	addi	r2,r2,3300
8112b584:	f800283a 	ret

8112b588 <setlocale>:
8112b588:	00a04574 	movhi	r2,33045
8112b58c:	10886904 	addi	r2,r2,8612
8112b590:	280d883a 	mov	r6,r5
8112b594:	200b883a 	mov	r5,r4
8112b598:	11000017 	ldw	r4,0(r2)
8112b59c:	112b4c81 	jmpi	8112b4c8 <_setlocale_r>

8112b5a0 <localeconv>:
8112b5a0:	00a04574 	movhi	r2,33045
8112b5a4:	10833904 	addi	r2,r2,3300
8112b5a8:	f800283a 	ret

8112b5ac <_lseek_r>:
8112b5ac:	defffd04 	addi	sp,sp,-12
8112b5b0:	de00012e 	bgeu	sp,et,8112b5b8 <_lseek_r+0xc>
8112b5b4:	003b68fa 	trap	3
8112b5b8:	2805883a 	mov	r2,r5
8112b5bc:	dc000015 	stw	r16,0(sp)
8112b5c0:	04204574 	movhi	r16,33045
8112b5c4:	dc400115 	stw	r17,4(sp)
8112b5c8:	300b883a 	mov	r5,r6
8112b5cc:	8408db04 	addi	r16,r16,9068
8112b5d0:	2023883a 	mov	r17,r4
8112b5d4:	380d883a 	mov	r6,r7
8112b5d8:	1009883a 	mov	r4,r2
8112b5dc:	dfc00215 	stw	ra,8(sp)
8112b5e0:	80000015 	stw	zero,0(r16)
8112b5e4:	11365c80 	call	811365c8 <lseek>
8112b5e8:	00ffffc4 	movi	r3,-1
8112b5ec:	10c00526 	beq	r2,r3,8112b604 <_lseek_r+0x58>
8112b5f0:	dfc00217 	ldw	ra,8(sp)
8112b5f4:	dc400117 	ldw	r17,4(sp)
8112b5f8:	dc000017 	ldw	r16,0(sp)
8112b5fc:	dec00304 	addi	sp,sp,12
8112b600:	f800283a 	ret
8112b604:	80c00017 	ldw	r3,0(r16)
8112b608:	183ff926 	beq	r3,zero,8112b5f0 <__reset+0xfb10b5f0>
8112b60c:	88c00015 	stw	r3,0(r17)
8112b610:	003ff706 	br	8112b5f0 <__reset+0xfb10b5f0>

8112b614 <_mbrtowc_r>:
8112b614:	defff704 	addi	sp,sp,-36
8112b618:	00a04574 	movhi	r2,33045
8112b61c:	de00012e 	bgeu	sp,et,8112b624 <_mbrtowc_r+0x10>
8112b620:	003b68fa 	trap	3
8112b624:	10886d04 	addi	r2,r2,8628
8112b628:	dc800715 	stw	r18,28(sp)
8112b62c:	dc400615 	stw	r17,24(sp)
8112b630:	dc000515 	stw	r16,20(sp)
8112b634:	dfc00815 	stw	ra,32(sp)
8112b638:	2021883a 	mov	r16,r4
8112b63c:	dc400917 	ldw	r17,36(sp)
8112b640:	14800017 	ldw	r18,0(r2)
8112b644:	30001626 	beq	r6,zero,8112b6a0 <_mbrtowc_r+0x8c>
8112b648:	d9400215 	stw	r5,8(sp)
8112b64c:	d9800315 	stw	r6,12(sp)
8112b650:	d9c00415 	stw	r7,16(sp)
8112b654:	112b54c0 	call	8112b54c <__locale_charset>
8112b658:	d9c00417 	ldw	r7,16(sp)
8112b65c:	d9800317 	ldw	r6,12(sp)
8112b660:	d9400217 	ldw	r5,8(sp)
8112b664:	d8800015 	stw	r2,0(sp)
8112b668:	dc400115 	stw	r17,4(sp)
8112b66c:	8009883a 	mov	r4,r16
8112b670:	903ee83a 	callr	r18
8112b674:	00ffffc4 	movi	r3,-1
8112b678:	10c0031e 	bne	r2,r3,8112b688 <_mbrtowc_r+0x74>
8112b67c:	88000015 	stw	zero,0(r17)
8112b680:	00c02284 	movi	r3,138
8112b684:	80c00015 	stw	r3,0(r16)
8112b688:	dfc00817 	ldw	ra,32(sp)
8112b68c:	dc800717 	ldw	r18,28(sp)
8112b690:	dc400617 	ldw	r17,24(sp)
8112b694:	dc000517 	ldw	r16,20(sp)
8112b698:	dec00904 	addi	sp,sp,36
8112b69c:	f800283a 	ret
8112b6a0:	112b54c0 	call	8112b54c <__locale_charset>
8112b6a4:	01a04574 	movhi	r6,33045
8112b6a8:	31be9904 	addi	r6,r6,-1436
8112b6ac:	dc400115 	stw	r17,4(sp)
8112b6b0:	d8800015 	stw	r2,0(sp)
8112b6b4:	01c00044 	movi	r7,1
8112b6b8:	000b883a 	mov	r5,zero
8112b6bc:	8009883a 	mov	r4,r16
8112b6c0:	903ee83a 	callr	r18
8112b6c4:	003feb06 	br	8112b674 <__reset+0xfb10b674>

8112b6c8 <mbrtowc>:
8112b6c8:	defff704 	addi	sp,sp,-36
8112b6cc:	00a04574 	movhi	r2,33045
8112b6d0:	de00012e 	bgeu	sp,et,8112b6d8 <mbrtowc+0x10>
8112b6d4:	003b68fa 	trap	3
8112b6d8:	10886904 	addi	r2,r2,8612
8112b6dc:	dc800415 	stw	r18,16(sp)
8112b6e0:	dc400315 	stw	r17,12(sp)
8112b6e4:	dfc00815 	stw	ra,32(sp)
8112b6e8:	dd400715 	stw	r21,28(sp)
8112b6ec:	dd000615 	stw	r20,24(sp)
8112b6f0:	dcc00515 	stw	r19,20(sp)
8112b6f4:	dc000215 	stw	r16,8(sp)
8112b6f8:	3825883a 	mov	r18,r7
8112b6fc:	14400017 	ldw	r17,0(r2)
8112b700:	28001c26 	beq	r5,zero,8112b774 <mbrtowc+0xac>
8112b704:	00a04574 	movhi	r2,33045
8112b708:	10886d04 	addi	r2,r2,8628
8112b70c:	15400017 	ldw	r21,0(r2)
8112b710:	2821883a 	mov	r16,r5
8112b714:	2027883a 	mov	r19,r4
8112b718:	3029883a 	mov	r20,r6
8112b71c:	112b54c0 	call	8112b54c <__locale_charset>
8112b720:	d8800015 	stw	r2,0(sp)
8112b724:	dc800115 	stw	r18,4(sp)
8112b728:	a00f883a 	mov	r7,r20
8112b72c:	800d883a 	mov	r6,r16
8112b730:	980b883a 	mov	r5,r19
8112b734:	8809883a 	mov	r4,r17
8112b738:	a83ee83a 	callr	r21
8112b73c:	00ffffc4 	movi	r3,-1
8112b740:	10c0031e 	bne	r2,r3,8112b750 <mbrtowc+0x88>
8112b744:	90000015 	stw	zero,0(r18)
8112b748:	00c02284 	movi	r3,138
8112b74c:	88c00015 	stw	r3,0(r17)
8112b750:	dfc00817 	ldw	ra,32(sp)
8112b754:	dd400717 	ldw	r21,28(sp)
8112b758:	dd000617 	ldw	r20,24(sp)
8112b75c:	dcc00517 	ldw	r19,20(sp)
8112b760:	dc800417 	ldw	r18,16(sp)
8112b764:	dc400317 	ldw	r17,12(sp)
8112b768:	dc000217 	ldw	r16,8(sp)
8112b76c:	dec00904 	addi	sp,sp,36
8112b770:	f800283a 	ret
8112b774:	00a04574 	movhi	r2,33045
8112b778:	10886d04 	addi	r2,r2,8628
8112b77c:	14000017 	ldw	r16,0(r2)
8112b780:	112b54c0 	call	8112b54c <__locale_charset>
8112b784:	01a04574 	movhi	r6,33045
8112b788:	31be9904 	addi	r6,r6,-1436
8112b78c:	dc800115 	stw	r18,4(sp)
8112b790:	d8800015 	stw	r2,0(sp)
8112b794:	01c00044 	movi	r7,1
8112b798:	000b883a 	mov	r5,zero
8112b79c:	8809883a 	mov	r4,r17
8112b7a0:	803ee83a 	callr	r16
8112b7a4:	003fe506 	br	8112b73c <__reset+0xfb10b73c>

8112b7a8 <__ascii_mbtowc>:
8112b7a8:	deffff04 	addi	sp,sp,-4
8112b7ac:	de00012e 	bgeu	sp,et,8112b7b4 <__ascii_mbtowc+0xc>
8112b7b0:	003b68fa 	trap	3
8112b7b4:	28000826 	beq	r5,zero,8112b7d8 <__ascii_mbtowc+0x30>
8112b7b8:	30000926 	beq	r6,zero,8112b7e0 <__ascii_mbtowc+0x38>
8112b7bc:	38000b26 	beq	r7,zero,8112b7ec <__ascii_mbtowc+0x44>
8112b7c0:	30800003 	ldbu	r2,0(r6)
8112b7c4:	28800015 	stw	r2,0(r5)
8112b7c8:	30800003 	ldbu	r2,0(r6)
8112b7cc:	1004c03a 	cmpne	r2,r2,zero
8112b7d0:	dec00104 	addi	sp,sp,4
8112b7d4:	f800283a 	ret
8112b7d8:	d80b883a 	mov	r5,sp
8112b7dc:	303ff71e 	bne	r6,zero,8112b7bc <__reset+0xfb10b7bc>
8112b7e0:	0005883a 	mov	r2,zero
8112b7e4:	dec00104 	addi	sp,sp,4
8112b7e8:	f800283a 	ret
8112b7ec:	00bfff84 	movi	r2,-2
8112b7f0:	003ff706 	br	8112b7d0 <__reset+0xfb10b7d0>

8112b7f4 <_mbtowc_r>:
8112b7f4:	00a04574 	movhi	r2,33045
8112b7f8:	defff804 	addi	sp,sp,-32
8112b7fc:	10886d04 	addi	r2,r2,8628
8112b800:	de00012e 	bgeu	sp,et,8112b808 <_mbtowc_r+0x14>
8112b804:	003b68fa 	trap	3
8112b808:	dfc00715 	stw	ra,28(sp)
8112b80c:	dc000615 	stw	r16,24(sp)
8112b810:	14000017 	ldw	r16,0(r2)
8112b814:	d9000215 	stw	r4,8(sp)
8112b818:	d9400315 	stw	r5,12(sp)
8112b81c:	d9800415 	stw	r6,16(sp)
8112b820:	d9c00515 	stw	r7,20(sp)
8112b824:	112b54c0 	call	8112b54c <__locale_charset>
8112b828:	d8800015 	stw	r2,0(sp)
8112b82c:	d8800817 	ldw	r2,32(sp)
8112b830:	d9c00517 	ldw	r7,20(sp)
8112b834:	d9800417 	ldw	r6,16(sp)
8112b838:	d9400317 	ldw	r5,12(sp)
8112b83c:	d9000217 	ldw	r4,8(sp)
8112b840:	d8800115 	stw	r2,4(sp)
8112b844:	803ee83a 	callr	r16
8112b848:	dfc00717 	ldw	ra,28(sp)
8112b84c:	dc000617 	ldw	r16,24(sp)
8112b850:	dec00804 	addi	sp,sp,32
8112b854:	f800283a 	ret

8112b858 <memchr>:
8112b858:	208000cc 	andi	r2,r4,3
8112b85c:	280f883a 	mov	r7,r5
8112b860:	10003426 	beq	r2,zero,8112b934 <memchr+0xdc>
8112b864:	30bfffc4 	addi	r2,r6,-1
8112b868:	30001a26 	beq	r6,zero,8112b8d4 <memchr+0x7c>
8112b86c:	20c00003 	ldbu	r3,0(r4)
8112b870:	29803fcc 	andi	r6,r5,255
8112b874:	30c0051e 	bne	r6,r3,8112b88c <memchr+0x34>
8112b878:	00001806 	br	8112b8dc <memchr+0x84>
8112b87c:	10001526 	beq	r2,zero,8112b8d4 <memchr+0x7c>
8112b880:	20c00003 	ldbu	r3,0(r4)
8112b884:	10bfffc4 	addi	r2,r2,-1
8112b888:	30c01426 	beq	r6,r3,8112b8dc <memchr+0x84>
8112b88c:	21000044 	addi	r4,r4,1
8112b890:	20c000cc 	andi	r3,r4,3
8112b894:	183ff91e 	bne	r3,zero,8112b87c <__reset+0xfb10b87c>
8112b898:	020000c4 	movi	r8,3
8112b89c:	40801136 	bltu	r8,r2,8112b8e4 <memchr+0x8c>
8112b8a0:	10000c26 	beq	r2,zero,8112b8d4 <memchr+0x7c>
8112b8a4:	20c00003 	ldbu	r3,0(r4)
8112b8a8:	29403fcc 	andi	r5,r5,255
8112b8ac:	28c00b26 	beq	r5,r3,8112b8dc <memchr+0x84>
8112b8b0:	20c00044 	addi	r3,r4,1
8112b8b4:	39803fcc 	andi	r6,r7,255
8112b8b8:	2089883a 	add	r4,r4,r2
8112b8bc:	00000306 	br	8112b8cc <memchr+0x74>
8112b8c0:	18c00044 	addi	r3,r3,1
8112b8c4:	197fffc3 	ldbu	r5,-1(r3)
8112b8c8:	31400526 	beq	r6,r5,8112b8e0 <memchr+0x88>
8112b8cc:	1805883a 	mov	r2,r3
8112b8d0:	20fffb1e 	bne	r4,r3,8112b8c0 <__reset+0xfb10b8c0>
8112b8d4:	0005883a 	mov	r2,zero
8112b8d8:	f800283a 	ret
8112b8dc:	2005883a 	mov	r2,r4
8112b8e0:	f800283a 	ret
8112b8e4:	28c03fcc 	andi	r3,r5,255
8112b8e8:	1812923a 	slli	r9,r3,8
8112b8ec:	02ffbff4 	movhi	r11,65279
8112b8f0:	02a02074 	movhi	r10,32897
8112b8f4:	48d2b03a 	or	r9,r9,r3
8112b8f8:	4806943a 	slli	r3,r9,16
8112b8fc:	5affbfc4 	addi	r11,r11,-257
8112b900:	52a02004 	addi	r10,r10,-32640
8112b904:	48d2b03a 	or	r9,r9,r3
8112b908:	20c00017 	ldw	r3,0(r4)
8112b90c:	48c6f03a 	xor	r3,r9,r3
8112b910:	1acd883a 	add	r6,r3,r11
8112b914:	00c6303a 	nor	r3,zero,r3
8112b918:	30c6703a 	and	r3,r6,r3
8112b91c:	1a86703a 	and	r3,r3,r10
8112b920:	183fe01e 	bne	r3,zero,8112b8a4 <__reset+0xfb10b8a4>
8112b924:	10bfff04 	addi	r2,r2,-4
8112b928:	21000104 	addi	r4,r4,4
8112b92c:	40bff636 	bltu	r8,r2,8112b908 <__reset+0xfb10b908>
8112b930:	003fdb06 	br	8112b8a0 <__reset+0xfb10b8a0>
8112b934:	3005883a 	mov	r2,r6
8112b938:	003fd706 	br	8112b898 <__reset+0xfb10b898>

8112b93c <memmove>:
8112b93c:	2005883a 	mov	r2,r4
8112b940:	29000b2e 	bgeu	r5,r4,8112b970 <memmove+0x34>
8112b944:	298f883a 	add	r7,r5,r6
8112b948:	21c0092e 	bgeu	r4,r7,8112b970 <memmove+0x34>
8112b94c:	2187883a 	add	r3,r4,r6
8112b950:	198bc83a 	sub	r5,r3,r6
8112b954:	30004826 	beq	r6,zero,8112ba78 <memmove+0x13c>
8112b958:	39ffffc4 	addi	r7,r7,-1
8112b95c:	39000003 	ldbu	r4,0(r7)
8112b960:	18ffffc4 	addi	r3,r3,-1
8112b964:	19000005 	stb	r4,0(r3)
8112b968:	28fffb1e 	bne	r5,r3,8112b958 <__reset+0xfb10b958>
8112b96c:	f800283a 	ret
8112b970:	00c003c4 	movi	r3,15
8112b974:	1980412e 	bgeu	r3,r6,8112ba7c <memmove+0x140>
8112b978:	2886b03a 	or	r3,r5,r2
8112b97c:	18c000cc 	andi	r3,r3,3
8112b980:	1800401e 	bne	r3,zero,8112ba84 <memmove+0x148>
8112b984:	33fffc04 	addi	r15,r6,-16
8112b988:	781ed13a 	srli	r15,r15,4
8112b98c:	28c00104 	addi	r3,r5,4
8112b990:	13400104 	addi	r13,r2,4
8112b994:	781c913a 	slli	r14,r15,4
8112b998:	2b000204 	addi	r12,r5,8
8112b99c:	12c00204 	addi	r11,r2,8
8112b9a0:	73800504 	addi	r14,r14,20
8112b9a4:	2a800304 	addi	r10,r5,12
8112b9a8:	12400304 	addi	r9,r2,12
8112b9ac:	2b9d883a 	add	r14,r5,r14
8112b9b0:	2811883a 	mov	r8,r5
8112b9b4:	100f883a 	mov	r7,r2
8112b9b8:	41000017 	ldw	r4,0(r8)
8112b9bc:	39c00404 	addi	r7,r7,16
8112b9c0:	18c00404 	addi	r3,r3,16
8112b9c4:	393ffc15 	stw	r4,-16(r7)
8112b9c8:	193ffc17 	ldw	r4,-16(r3)
8112b9cc:	6b400404 	addi	r13,r13,16
8112b9d0:	5ac00404 	addi	r11,r11,16
8112b9d4:	693ffc15 	stw	r4,-16(r13)
8112b9d8:	61000017 	ldw	r4,0(r12)
8112b9dc:	4a400404 	addi	r9,r9,16
8112b9e0:	42000404 	addi	r8,r8,16
8112b9e4:	593ffc15 	stw	r4,-16(r11)
8112b9e8:	51000017 	ldw	r4,0(r10)
8112b9ec:	63000404 	addi	r12,r12,16
8112b9f0:	52800404 	addi	r10,r10,16
8112b9f4:	493ffc15 	stw	r4,-16(r9)
8112b9f8:	1bbfef1e 	bne	r3,r14,8112b9b8 <__reset+0xfb10b9b8>
8112b9fc:	79000044 	addi	r4,r15,1
8112ba00:	2008913a 	slli	r4,r4,4
8112ba04:	328003cc 	andi	r10,r6,15
8112ba08:	02c000c4 	movi	r11,3
8112ba0c:	1107883a 	add	r3,r2,r4
8112ba10:	290b883a 	add	r5,r5,r4
8112ba14:	5a801e2e 	bgeu	r11,r10,8112ba90 <memmove+0x154>
8112ba18:	1813883a 	mov	r9,r3
8112ba1c:	2811883a 	mov	r8,r5
8112ba20:	500f883a 	mov	r7,r10
8112ba24:	41000017 	ldw	r4,0(r8)
8112ba28:	4a400104 	addi	r9,r9,4
8112ba2c:	39ffff04 	addi	r7,r7,-4
8112ba30:	493fff15 	stw	r4,-4(r9)
8112ba34:	42000104 	addi	r8,r8,4
8112ba38:	59fffa36 	bltu	r11,r7,8112ba24 <__reset+0xfb10ba24>
8112ba3c:	513fff04 	addi	r4,r10,-4
8112ba40:	2008d0ba 	srli	r4,r4,2
8112ba44:	318000cc 	andi	r6,r6,3
8112ba48:	21000044 	addi	r4,r4,1
8112ba4c:	2109883a 	add	r4,r4,r4
8112ba50:	2109883a 	add	r4,r4,r4
8112ba54:	1907883a 	add	r3,r3,r4
8112ba58:	290b883a 	add	r5,r5,r4
8112ba5c:	30000b26 	beq	r6,zero,8112ba8c <memmove+0x150>
8112ba60:	198d883a 	add	r6,r3,r6
8112ba64:	29c00003 	ldbu	r7,0(r5)
8112ba68:	18c00044 	addi	r3,r3,1
8112ba6c:	29400044 	addi	r5,r5,1
8112ba70:	19ffffc5 	stb	r7,-1(r3)
8112ba74:	19bffb1e 	bne	r3,r6,8112ba64 <__reset+0xfb10ba64>
8112ba78:	f800283a 	ret
8112ba7c:	1007883a 	mov	r3,r2
8112ba80:	003ff606 	br	8112ba5c <__reset+0xfb10ba5c>
8112ba84:	1007883a 	mov	r3,r2
8112ba88:	003ff506 	br	8112ba60 <__reset+0xfb10ba60>
8112ba8c:	f800283a 	ret
8112ba90:	500d883a 	mov	r6,r10
8112ba94:	003ff106 	br	8112ba5c <__reset+0xfb10ba5c>

8112ba98 <_Balloc>:
8112ba98:	defffc04 	addi	sp,sp,-16
8112ba9c:	de00012e 	bgeu	sp,et,8112baa4 <_Balloc+0xc>
8112baa0:	003b68fa 	trap	3
8112baa4:	20801317 	ldw	r2,76(r4)
8112baa8:	dc400115 	stw	r17,4(sp)
8112baac:	dc000015 	stw	r16,0(sp)
8112bab0:	dfc00315 	stw	ra,12(sp)
8112bab4:	dc800215 	stw	r18,8(sp)
8112bab8:	2023883a 	mov	r17,r4
8112babc:	2821883a 	mov	r16,r5
8112bac0:	10000f26 	beq	r2,zero,8112bb00 <_Balloc+0x68>
8112bac4:	8407883a 	add	r3,r16,r16
8112bac8:	18c7883a 	add	r3,r3,r3
8112bacc:	10c7883a 	add	r3,r2,r3
8112bad0:	18800017 	ldw	r2,0(r3)
8112bad4:	10001126 	beq	r2,zero,8112bb1c <_Balloc+0x84>
8112bad8:	11000017 	ldw	r4,0(r2)
8112badc:	19000015 	stw	r4,0(r3)
8112bae0:	10000415 	stw	zero,16(r2)
8112bae4:	10000315 	stw	zero,12(r2)
8112bae8:	dfc00317 	ldw	ra,12(sp)
8112baec:	dc800217 	ldw	r18,8(sp)
8112baf0:	dc400117 	ldw	r17,4(sp)
8112baf4:	dc000017 	ldw	r16,0(sp)
8112baf8:	dec00404 	addi	sp,sp,16
8112bafc:	f800283a 	ret
8112bb00:	01800844 	movi	r6,33
8112bb04:	01400104 	movi	r5,4
8112bb08:	1131fc00 	call	81131fc0 <_calloc_r>
8112bb0c:	88801315 	stw	r2,76(r17)
8112bb10:	103fec1e 	bne	r2,zero,8112bac4 <__reset+0xfb10bac4>
8112bb14:	0005883a 	mov	r2,zero
8112bb18:	003ff306 	br	8112bae8 <__reset+0xfb10bae8>
8112bb1c:	01400044 	movi	r5,1
8112bb20:	2c24983a 	sll	r18,r5,r16
8112bb24:	8809883a 	mov	r4,r17
8112bb28:	91800144 	addi	r6,r18,5
8112bb2c:	318d883a 	add	r6,r6,r6
8112bb30:	318d883a 	add	r6,r6,r6
8112bb34:	1131fc00 	call	81131fc0 <_calloc_r>
8112bb38:	103ff626 	beq	r2,zero,8112bb14 <__reset+0xfb10bb14>
8112bb3c:	14000115 	stw	r16,4(r2)
8112bb40:	14800215 	stw	r18,8(r2)
8112bb44:	003fe606 	br	8112bae0 <__reset+0xfb10bae0>

8112bb48 <_Bfree>:
8112bb48:	28000826 	beq	r5,zero,8112bb6c <_Bfree+0x24>
8112bb4c:	28c00117 	ldw	r3,4(r5)
8112bb50:	20801317 	ldw	r2,76(r4)
8112bb54:	18c7883a 	add	r3,r3,r3
8112bb58:	18c7883a 	add	r3,r3,r3
8112bb5c:	10c5883a 	add	r2,r2,r3
8112bb60:	10c00017 	ldw	r3,0(r2)
8112bb64:	28c00015 	stw	r3,0(r5)
8112bb68:	11400015 	stw	r5,0(r2)
8112bb6c:	f800283a 	ret

8112bb70 <__multadd>:
8112bb70:	defffa04 	addi	sp,sp,-24
8112bb74:	de00012e 	bgeu	sp,et,8112bb7c <__multadd+0xc>
8112bb78:	003b68fa 	trap	3
8112bb7c:	0011883a 	mov	r8,zero
8112bb80:	dc800315 	stw	r18,12(sp)
8112bb84:	dc400215 	stw	r17,8(sp)
8112bb88:	dc000115 	stw	r16,4(sp)
8112bb8c:	2823883a 	mov	r17,r5
8112bb90:	2c000417 	ldw	r16,16(r5)
8112bb94:	dfc00515 	stw	ra,20(sp)
8112bb98:	dcc00415 	stw	r19,16(sp)
8112bb9c:	2025883a 	mov	r18,r4
8112bba0:	29400504 	addi	r5,r5,20
8112bba4:	28c00017 	ldw	r3,0(r5)
8112bba8:	29400104 	addi	r5,r5,4
8112bbac:	42000044 	addi	r8,r8,1
8112bbb0:	18bfffcc 	andi	r2,r3,65535
8112bbb4:	1185383a 	mul	r2,r2,r6
8112bbb8:	1806d43a 	srli	r3,r3,16
8112bbbc:	11cf883a 	add	r7,r2,r7
8112bbc0:	3808d43a 	srli	r4,r7,16
8112bbc4:	1987383a 	mul	r3,r3,r6
8112bbc8:	38bfffcc 	andi	r2,r7,65535
8112bbcc:	1907883a 	add	r3,r3,r4
8112bbd0:	1808943a 	slli	r4,r3,16
8112bbd4:	180ed43a 	srli	r7,r3,16
8112bbd8:	2085883a 	add	r2,r4,r2
8112bbdc:	28bfff15 	stw	r2,-4(r5)
8112bbe0:	443ff016 	blt	r8,r16,8112bba4 <__reset+0xfb10bba4>
8112bbe4:	38000926 	beq	r7,zero,8112bc0c <__multadd+0x9c>
8112bbe8:	88800217 	ldw	r2,8(r17)
8112bbec:	80800f0e 	bge	r16,r2,8112bc2c <__multadd+0xbc>
8112bbf0:	80800144 	addi	r2,r16,5
8112bbf4:	1085883a 	add	r2,r2,r2
8112bbf8:	1085883a 	add	r2,r2,r2
8112bbfc:	8885883a 	add	r2,r17,r2
8112bc00:	11c00015 	stw	r7,0(r2)
8112bc04:	84000044 	addi	r16,r16,1
8112bc08:	8c000415 	stw	r16,16(r17)
8112bc0c:	8805883a 	mov	r2,r17
8112bc10:	dfc00517 	ldw	ra,20(sp)
8112bc14:	dcc00417 	ldw	r19,16(sp)
8112bc18:	dc800317 	ldw	r18,12(sp)
8112bc1c:	dc400217 	ldw	r17,8(sp)
8112bc20:	dc000117 	ldw	r16,4(sp)
8112bc24:	dec00604 	addi	sp,sp,24
8112bc28:	f800283a 	ret
8112bc2c:	89400117 	ldw	r5,4(r17)
8112bc30:	9009883a 	mov	r4,r18
8112bc34:	d9c00015 	stw	r7,0(sp)
8112bc38:	29400044 	addi	r5,r5,1
8112bc3c:	112ba980 	call	8112ba98 <_Balloc>
8112bc40:	89800417 	ldw	r6,16(r17)
8112bc44:	89400304 	addi	r5,r17,12
8112bc48:	11000304 	addi	r4,r2,12
8112bc4c:	31800084 	addi	r6,r6,2
8112bc50:	318d883a 	add	r6,r6,r6
8112bc54:	318d883a 	add	r6,r6,r6
8112bc58:	1027883a 	mov	r19,r2
8112bc5c:	11218680 	call	81121868 <memcpy>
8112bc60:	d9c00017 	ldw	r7,0(sp)
8112bc64:	88000a26 	beq	r17,zero,8112bc90 <__multadd+0x120>
8112bc68:	88c00117 	ldw	r3,4(r17)
8112bc6c:	90801317 	ldw	r2,76(r18)
8112bc70:	18c7883a 	add	r3,r3,r3
8112bc74:	18c7883a 	add	r3,r3,r3
8112bc78:	10c5883a 	add	r2,r2,r3
8112bc7c:	10c00017 	ldw	r3,0(r2)
8112bc80:	88c00015 	stw	r3,0(r17)
8112bc84:	14400015 	stw	r17,0(r2)
8112bc88:	9823883a 	mov	r17,r19
8112bc8c:	003fd806 	br	8112bbf0 <__reset+0xfb10bbf0>
8112bc90:	9823883a 	mov	r17,r19
8112bc94:	003fd606 	br	8112bbf0 <__reset+0xfb10bbf0>

8112bc98 <__s2b>:
8112bc98:	defff904 	addi	sp,sp,-28
8112bc9c:	de00012e 	bgeu	sp,et,8112bca4 <__s2b+0xc>
8112bca0:	003b68fa 	trap	3
8112bca4:	dc400115 	stw	r17,4(sp)
8112bca8:	dc000015 	stw	r16,0(sp)
8112bcac:	2023883a 	mov	r17,r4
8112bcb0:	2821883a 	mov	r16,r5
8112bcb4:	39000204 	addi	r4,r7,8
8112bcb8:	01400244 	movi	r5,9
8112bcbc:	dcc00315 	stw	r19,12(sp)
8112bcc0:	dc800215 	stw	r18,8(sp)
8112bcc4:	dfc00615 	stw	ra,24(sp)
8112bcc8:	dd400515 	stw	r21,20(sp)
8112bccc:	dd000415 	stw	r20,16(sp)
8112bcd0:	3825883a 	mov	r18,r7
8112bcd4:	3027883a 	mov	r19,r6
8112bcd8:	1133cdc0 	call	81133cdc <__divsi3>
8112bcdc:	00c00044 	movi	r3,1
8112bce0:	000b883a 	mov	r5,zero
8112bce4:	1880030e 	bge	r3,r2,8112bcf4 <__s2b+0x5c>
8112bce8:	18c7883a 	add	r3,r3,r3
8112bcec:	29400044 	addi	r5,r5,1
8112bcf0:	18bffd16 	blt	r3,r2,8112bce8 <__reset+0xfb10bce8>
8112bcf4:	8809883a 	mov	r4,r17
8112bcf8:	112ba980 	call	8112ba98 <_Balloc>
8112bcfc:	d8c00717 	ldw	r3,28(sp)
8112bd00:	10c00515 	stw	r3,20(r2)
8112bd04:	00c00044 	movi	r3,1
8112bd08:	10c00415 	stw	r3,16(r2)
8112bd0c:	00c00244 	movi	r3,9
8112bd10:	1cc0210e 	bge	r3,r19,8112bd98 <__s2b+0x100>
8112bd14:	80eb883a 	add	r21,r16,r3
8112bd18:	a829883a 	mov	r20,r21
8112bd1c:	84e1883a 	add	r16,r16,r19
8112bd20:	a1c00007 	ldb	r7,0(r20)
8112bd24:	01800284 	movi	r6,10
8112bd28:	a5000044 	addi	r20,r20,1
8112bd2c:	100b883a 	mov	r5,r2
8112bd30:	39fff404 	addi	r7,r7,-48
8112bd34:	8809883a 	mov	r4,r17
8112bd38:	112bb700 	call	8112bb70 <__multadd>
8112bd3c:	a43ff81e 	bne	r20,r16,8112bd20 <__reset+0xfb10bd20>
8112bd40:	ace1883a 	add	r16,r21,r19
8112bd44:	843ffe04 	addi	r16,r16,-8
8112bd48:	9c800a0e 	bge	r19,r18,8112bd74 <__s2b+0xdc>
8112bd4c:	94e5c83a 	sub	r18,r18,r19
8112bd50:	84a5883a 	add	r18,r16,r18
8112bd54:	81c00007 	ldb	r7,0(r16)
8112bd58:	01800284 	movi	r6,10
8112bd5c:	84000044 	addi	r16,r16,1
8112bd60:	100b883a 	mov	r5,r2
8112bd64:	39fff404 	addi	r7,r7,-48
8112bd68:	8809883a 	mov	r4,r17
8112bd6c:	112bb700 	call	8112bb70 <__multadd>
8112bd70:	84bff81e 	bne	r16,r18,8112bd54 <__reset+0xfb10bd54>
8112bd74:	dfc00617 	ldw	ra,24(sp)
8112bd78:	dd400517 	ldw	r21,20(sp)
8112bd7c:	dd000417 	ldw	r20,16(sp)
8112bd80:	dcc00317 	ldw	r19,12(sp)
8112bd84:	dc800217 	ldw	r18,8(sp)
8112bd88:	dc400117 	ldw	r17,4(sp)
8112bd8c:	dc000017 	ldw	r16,0(sp)
8112bd90:	dec00704 	addi	sp,sp,28
8112bd94:	f800283a 	ret
8112bd98:	84000284 	addi	r16,r16,10
8112bd9c:	1827883a 	mov	r19,r3
8112bda0:	003fe906 	br	8112bd48 <__reset+0xfb10bd48>

8112bda4 <__hi0bits>:
8112bda4:	20bfffec 	andhi	r2,r4,65535
8112bda8:	1000141e 	bne	r2,zero,8112bdfc <__hi0bits+0x58>
8112bdac:	2008943a 	slli	r4,r4,16
8112bdb0:	00800404 	movi	r2,16
8112bdb4:	20ffc02c 	andhi	r3,r4,65280
8112bdb8:	1800021e 	bne	r3,zero,8112bdc4 <__hi0bits+0x20>
8112bdbc:	2008923a 	slli	r4,r4,8
8112bdc0:	10800204 	addi	r2,r2,8
8112bdc4:	20fc002c 	andhi	r3,r4,61440
8112bdc8:	1800021e 	bne	r3,zero,8112bdd4 <__hi0bits+0x30>
8112bdcc:	2008913a 	slli	r4,r4,4
8112bdd0:	10800104 	addi	r2,r2,4
8112bdd4:	20f0002c 	andhi	r3,r4,49152
8112bdd8:	1800031e 	bne	r3,zero,8112bde8 <__hi0bits+0x44>
8112bddc:	2109883a 	add	r4,r4,r4
8112bde0:	10800084 	addi	r2,r2,2
8112bde4:	2109883a 	add	r4,r4,r4
8112bde8:	20000316 	blt	r4,zero,8112bdf8 <__hi0bits+0x54>
8112bdec:	2110002c 	andhi	r4,r4,16384
8112bdf0:	2000041e 	bne	r4,zero,8112be04 <__hi0bits+0x60>
8112bdf4:	00800804 	movi	r2,32
8112bdf8:	f800283a 	ret
8112bdfc:	0005883a 	mov	r2,zero
8112be00:	003fec06 	br	8112bdb4 <__reset+0xfb10bdb4>
8112be04:	10800044 	addi	r2,r2,1
8112be08:	f800283a 	ret

8112be0c <__lo0bits>:
8112be0c:	20c00017 	ldw	r3,0(r4)
8112be10:	188001cc 	andi	r2,r3,7
8112be14:	10000826 	beq	r2,zero,8112be38 <__lo0bits+0x2c>
8112be18:	1880004c 	andi	r2,r3,1
8112be1c:	1000211e 	bne	r2,zero,8112bea4 <__lo0bits+0x98>
8112be20:	1880008c 	andi	r2,r3,2
8112be24:	1000211e 	bne	r2,zero,8112beac <__lo0bits+0xa0>
8112be28:	1806d0ba 	srli	r3,r3,2
8112be2c:	00800084 	movi	r2,2
8112be30:	20c00015 	stw	r3,0(r4)
8112be34:	f800283a 	ret
8112be38:	18bfffcc 	andi	r2,r3,65535
8112be3c:	10001326 	beq	r2,zero,8112be8c <__lo0bits+0x80>
8112be40:	0005883a 	mov	r2,zero
8112be44:	19403fcc 	andi	r5,r3,255
8112be48:	2800021e 	bne	r5,zero,8112be54 <__lo0bits+0x48>
8112be4c:	1806d23a 	srli	r3,r3,8
8112be50:	10800204 	addi	r2,r2,8
8112be54:	194003cc 	andi	r5,r3,15
8112be58:	2800021e 	bne	r5,zero,8112be64 <__lo0bits+0x58>
8112be5c:	1806d13a 	srli	r3,r3,4
8112be60:	10800104 	addi	r2,r2,4
8112be64:	194000cc 	andi	r5,r3,3
8112be68:	2800021e 	bne	r5,zero,8112be74 <__lo0bits+0x68>
8112be6c:	1806d0ba 	srli	r3,r3,2
8112be70:	10800084 	addi	r2,r2,2
8112be74:	1940004c 	andi	r5,r3,1
8112be78:	2800081e 	bne	r5,zero,8112be9c <__lo0bits+0x90>
8112be7c:	1806d07a 	srli	r3,r3,1
8112be80:	1800051e 	bne	r3,zero,8112be98 <__lo0bits+0x8c>
8112be84:	00800804 	movi	r2,32
8112be88:	f800283a 	ret
8112be8c:	1806d43a 	srli	r3,r3,16
8112be90:	00800404 	movi	r2,16
8112be94:	003feb06 	br	8112be44 <__reset+0xfb10be44>
8112be98:	10800044 	addi	r2,r2,1
8112be9c:	20c00015 	stw	r3,0(r4)
8112bea0:	f800283a 	ret
8112bea4:	0005883a 	mov	r2,zero
8112bea8:	f800283a 	ret
8112beac:	1806d07a 	srli	r3,r3,1
8112beb0:	00800044 	movi	r2,1
8112beb4:	20c00015 	stw	r3,0(r4)
8112beb8:	f800283a 	ret

8112bebc <__i2b>:
8112bebc:	defffd04 	addi	sp,sp,-12
8112bec0:	de00012e 	bgeu	sp,et,8112bec8 <__i2b+0xc>
8112bec4:	003b68fa 	trap	3
8112bec8:	dc000015 	stw	r16,0(sp)
8112becc:	04000044 	movi	r16,1
8112bed0:	dc400115 	stw	r17,4(sp)
8112bed4:	2823883a 	mov	r17,r5
8112bed8:	800b883a 	mov	r5,r16
8112bedc:	dfc00215 	stw	ra,8(sp)
8112bee0:	112ba980 	call	8112ba98 <_Balloc>
8112bee4:	14400515 	stw	r17,20(r2)
8112bee8:	14000415 	stw	r16,16(r2)
8112beec:	dfc00217 	ldw	ra,8(sp)
8112bef0:	dc400117 	ldw	r17,4(sp)
8112bef4:	dc000017 	ldw	r16,0(sp)
8112bef8:	dec00304 	addi	sp,sp,12
8112befc:	f800283a 	ret

8112bf00 <__multiply>:
8112bf00:	defffa04 	addi	sp,sp,-24
8112bf04:	de00012e 	bgeu	sp,et,8112bf0c <__multiply+0xc>
8112bf08:	003b68fa 	trap	3
8112bf0c:	dcc00315 	stw	r19,12(sp)
8112bf10:	dc800215 	stw	r18,8(sp)
8112bf14:	34c00417 	ldw	r19,16(r6)
8112bf18:	2c800417 	ldw	r18,16(r5)
8112bf1c:	dd000415 	stw	r20,16(sp)
8112bf20:	dc400115 	stw	r17,4(sp)
8112bf24:	dfc00515 	stw	ra,20(sp)
8112bf28:	dc000015 	stw	r16,0(sp)
8112bf2c:	2829883a 	mov	r20,r5
8112bf30:	3023883a 	mov	r17,r6
8112bf34:	94c0050e 	bge	r18,r19,8112bf4c <__multiply+0x4c>
8112bf38:	9007883a 	mov	r3,r18
8112bf3c:	3029883a 	mov	r20,r6
8112bf40:	9825883a 	mov	r18,r19
8112bf44:	2823883a 	mov	r17,r5
8112bf48:	1827883a 	mov	r19,r3
8112bf4c:	a0800217 	ldw	r2,8(r20)
8112bf50:	94e1883a 	add	r16,r18,r19
8112bf54:	a1400117 	ldw	r5,4(r20)
8112bf58:	1400010e 	bge	r2,r16,8112bf60 <__multiply+0x60>
8112bf5c:	29400044 	addi	r5,r5,1
8112bf60:	112ba980 	call	8112ba98 <_Balloc>
8112bf64:	8415883a 	add	r10,r16,r16
8112bf68:	12c00504 	addi	r11,r2,20
8112bf6c:	5295883a 	add	r10,r10,r10
8112bf70:	5a95883a 	add	r10,r11,r10
8112bf74:	5807883a 	mov	r3,r11
8112bf78:	5a80032e 	bgeu	r11,r10,8112bf88 <__multiply+0x88>
8112bf7c:	18000015 	stw	zero,0(r3)
8112bf80:	18c00104 	addi	r3,r3,4
8112bf84:	1abffd36 	bltu	r3,r10,8112bf7c <__reset+0xfb10bf7c>
8112bf88:	9ce7883a 	add	r19,r19,r19
8112bf8c:	94a5883a 	add	r18,r18,r18
8112bf90:	89800504 	addi	r6,r17,20
8112bf94:	9ce7883a 	add	r19,r19,r19
8112bf98:	a3400504 	addi	r13,r20,20
8112bf9c:	94a5883a 	add	r18,r18,r18
8112bfa0:	34d9883a 	add	r12,r6,r19
8112bfa4:	6c93883a 	add	r9,r13,r18
8112bfa8:	3300422e 	bgeu	r6,r12,8112c0b4 <__multiply+0x1b4>
8112bfac:	37c00017 	ldw	ra,0(r6)
8112bfb0:	fbffffcc 	andi	r15,ra,65535
8112bfb4:	78001b26 	beq	r15,zero,8112c024 <__multiply+0x124>
8112bfb8:	5811883a 	mov	r8,r11
8112bfbc:	681d883a 	mov	r14,r13
8112bfc0:	000f883a 	mov	r7,zero
8112bfc4:	71000017 	ldw	r4,0(r14)
8112bfc8:	40c00017 	ldw	r3,0(r8)
8112bfcc:	73800104 	addi	r14,r14,4
8112bfd0:	217fffcc 	andi	r5,r4,65535
8112bfd4:	2bcb383a 	mul	r5,r5,r15
8112bfd8:	2008d43a 	srli	r4,r4,16
8112bfdc:	1c7fffcc 	andi	r17,r3,65535
8112bfe0:	2c4b883a 	add	r5,r5,r17
8112bfe4:	29cb883a 	add	r5,r5,r7
8112bfe8:	23c9383a 	mul	r4,r4,r15
8112bfec:	1806d43a 	srli	r3,r3,16
8112bff0:	280ed43a 	srli	r7,r5,16
8112bff4:	297fffcc 	andi	r5,r5,65535
8112bff8:	20c7883a 	add	r3,r4,r3
8112bffc:	19c7883a 	add	r3,r3,r7
8112c000:	1808943a 	slli	r4,r3,16
8112c004:	4023883a 	mov	r17,r8
8112c008:	180ed43a 	srli	r7,r3,16
8112c00c:	214ab03a 	or	r5,r4,r5
8112c010:	41400015 	stw	r5,0(r8)
8112c014:	42000104 	addi	r8,r8,4
8112c018:	727fea36 	bltu	r14,r9,8112bfc4 <__reset+0xfb10bfc4>
8112c01c:	89c00115 	stw	r7,4(r17)
8112c020:	37c00017 	ldw	ra,0(r6)
8112c024:	f83ed43a 	srli	ra,ra,16
8112c028:	f8001f26 	beq	ra,zero,8112c0a8 <__multiply+0x1a8>
8112c02c:	58c00017 	ldw	r3,0(r11)
8112c030:	681d883a 	mov	r14,r13
8112c034:	581f883a 	mov	r15,r11
8112c038:	1811883a 	mov	r8,r3
8112c03c:	5825883a 	mov	r18,r11
8112c040:	000f883a 	mov	r7,zero
8112c044:	00000106 	br	8112c04c <__multiply+0x14c>
8112c048:	8825883a 	mov	r18,r17
8112c04c:	7140000b 	ldhu	r5,0(r14)
8112c050:	4010d43a 	srli	r8,r8,16
8112c054:	193fffcc 	andi	r4,r3,65535
8112c058:	2fcb383a 	mul	r5,r5,ra
8112c05c:	7bc00104 	addi	r15,r15,4
8112c060:	73800104 	addi	r14,r14,4
8112c064:	2a0b883a 	add	r5,r5,r8
8112c068:	29cb883a 	add	r5,r5,r7
8112c06c:	2806943a 	slli	r3,r5,16
8112c070:	94400104 	addi	r17,r18,4
8112c074:	280ad43a 	srli	r5,r5,16
8112c078:	1908b03a 	or	r4,r3,r4
8112c07c:	793fff15 	stw	r4,-4(r15)
8112c080:	70ffff17 	ldw	r3,-4(r14)
8112c084:	8a000017 	ldw	r8,0(r17)
8112c088:	1806d43a 	srli	r3,r3,16
8112c08c:	413fffcc 	andi	r4,r8,65535
8112c090:	1fc7383a 	mul	r3,r3,ra
8112c094:	1907883a 	add	r3,r3,r4
8112c098:	1947883a 	add	r3,r3,r5
8112c09c:	180ed43a 	srli	r7,r3,16
8112c0a0:	727fe936 	bltu	r14,r9,8112c048 <__reset+0xfb10c048>
8112c0a4:	90c00115 	stw	r3,4(r18)
8112c0a8:	31800104 	addi	r6,r6,4
8112c0ac:	5ac00104 	addi	r11,r11,4
8112c0b0:	333fbe36 	bltu	r6,r12,8112bfac <__reset+0xfb10bfac>
8112c0b4:	0400090e 	bge	zero,r16,8112c0dc <__multiply+0x1dc>
8112c0b8:	50ffff17 	ldw	r3,-4(r10)
8112c0bc:	52bfff04 	addi	r10,r10,-4
8112c0c0:	18000326 	beq	r3,zero,8112c0d0 <__multiply+0x1d0>
8112c0c4:	00000506 	br	8112c0dc <__multiply+0x1dc>
8112c0c8:	50c00017 	ldw	r3,0(r10)
8112c0cc:	1800031e 	bne	r3,zero,8112c0dc <__multiply+0x1dc>
8112c0d0:	843fffc4 	addi	r16,r16,-1
8112c0d4:	52bfff04 	addi	r10,r10,-4
8112c0d8:	803ffb1e 	bne	r16,zero,8112c0c8 <__reset+0xfb10c0c8>
8112c0dc:	14000415 	stw	r16,16(r2)
8112c0e0:	dfc00517 	ldw	ra,20(sp)
8112c0e4:	dd000417 	ldw	r20,16(sp)
8112c0e8:	dcc00317 	ldw	r19,12(sp)
8112c0ec:	dc800217 	ldw	r18,8(sp)
8112c0f0:	dc400117 	ldw	r17,4(sp)
8112c0f4:	dc000017 	ldw	r16,0(sp)
8112c0f8:	dec00604 	addi	sp,sp,24
8112c0fc:	f800283a 	ret

8112c100 <__pow5mult>:
8112c100:	defffa04 	addi	sp,sp,-24
8112c104:	de00012e 	bgeu	sp,et,8112c10c <__pow5mult+0xc>
8112c108:	003b68fa 	trap	3
8112c10c:	308000cc 	andi	r2,r6,3
8112c110:	dcc00315 	stw	r19,12(sp)
8112c114:	dc000015 	stw	r16,0(sp)
8112c118:	dfc00515 	stw	ra,20(sp)
8112c11c:	dd000415 	stw	r20,16(sp)
8112c120:	dc800215 	stw	r18,8(sp)
8112c124:	dc400115 	stw	r17,4(sp)
8112c128:	3021883a 	mov	r16,r6
8112c12c:	2027883a 	mov	r19,r4
8112c130:	10002f1e 	bne	r2,zero,8112c1f0 <__pow5mult+0xf0>
8112c134:	2825883a 	mov	r18,r5
8112c138:	8021d0ba 	srai	r16,r16,2
8112c13c:	80001a26 	beq	r16,zero,8112c1a8 <__pow5mult+0xa8>
8112c140:	9c401217 	ldw	r17,72(r19)
8112c144:	8800061e 	bne	r17,zero,8112c160 <__pow5mult+0x60>
8112c148:	00003406 	br	8112c21c <__pow5mult+0x11c>
8112c14c:	8021d07a 	srai	r16,r16,1
8112c150:	80001526 	beq	r16,zero,8112c1a8 <__pow5mult+0xa8>
8112c154:	88800017 	ldw	r2,0(r17)
8112c158:	10001c26 	beq	r2,zero,8112c1cc <__pow5mult+0xcc>
8112c15c:	1023883a 	mov	r17,r2
8112c160:	8080004c 	andi	r2,r16,1
8112c164:	103ff926 	beq	r2,zero,8112c14c <__reset+0xfb10c14c>
8112c168:	880d883a 	mov	r6,r17
8112c16c:	900b883a 	mov	r5,r18
8112c170:	9809883a 	mov	r4,r19
8112c174:	112bf000 	call	8112bf00 <__multiply>
8112c178:	90001b26 	beq	r18,zero,8112c1e8 <__pow5mult+0xe8>
8112c17c:	91000117 	ldw	r4,4(r18)
8112c180:	98c01317 	ldw	r3,76(r19)
8112c184:	8021d07a 	srai	r16,r16,1
8112c188:	2109883a 	add	r4,r4,r4
8112c18c:	2109883a 	add	r4,r4,r4
8112c190:	1907883a 	add	r3,r3,r4
8112c194:	19000017 	ldw	r4,0(r3)
8112c198:	91000015 	stw	r4,0(r18)
8112c19c:	1c800015 	stw	r18,0(r3)
8112c1a0:	1025883a 	mov	r18,r2
8112c1a4:	803feb1e 	bne	r16,zero,8112c154 <__reset+0xfb10c154>
8112c1a8:	9005883a 	mov	r2,r18
8112c1ac:	dfc00517 	ldw	ra,20(sp)
8112c1b0:	dd000417 	ldw	r20,16(sp)
8112c1b4:	dcc00317 	ldw	r19,12(sp)
8112c1b8:	dc800217 	ldw	r18,8(sp)
8112c1bc:	dc400117 	ldw	r17,4(sp)
8112c1c0:	dc000017 	ldw	r16,0(sp)
8112c1c4:	dec00604 	addi	sp,sp,24
8112c1c8:	f800283a 	ret
8112c1cc:	880d883a 	mov	r6,r17
8112c1d0:	880b883a 	mov	r5,r17
8112c1d4:	9809883a 	mov	r4,r19
8112c1d8:	112bf000 	call	8112bf00 <__multiply>
8112c1dc:	88800015 	stw	r2,0(r17)
8112c1e0:	10000015 	stw	zero,0(r2)
8112c1e4:	003fdd06 	br	8112c15c <__reset+0xfb10c15c>
8112c1e8:	1025883a 	mov	r18,r2
8112c1ec:	003fd706 	br	8112c14c <__reset+0xfb10c14c>
8112c1f0:	10bfffc4 	addi	r2,r2,-1
8112c1f4:	1085883a 	add	r2,r2,r2
8112c1f8:	00e04574 	movhi	r3,33045
8112c1fc:	18fec304 	addi	r3,r3,-1268
8112c200:	1085883a 	add	r2,r2,r2
8112c204:	1885883a 	add	r2,r3,r2
8112c208:	11800017 	ldw	r6,0(r2)
8112c20c:	000f883a 	mov	r7,zero
8112c210:	112bb700 	call	8112bb70 <__multadd>
8112c214:	1025883a 	mov	r18,r2
8112c218:	003fc706 	br	8112c138 <__reset+0xfb10c138>
8112c21c:	05000044 	movi	r20,1
8112c220:	a00b883a 	mov	r5,r20
8112c224:	9809883a 	mov	r4,r19
8112c228:	112ba980 	call	8112ba98 <_Balloc>
8112c22c:	1023883a 	mov	r17,r2
8112c230:	00809c44 	movi	r2,625
8112c234:	88800515 	stw	r2,20(r17)
8112c238:	8d000415 	stw	r20,16(r17)
8112c23c:	9c401215 	stw	r17,72(r19)
8112c240:	88000015 	stw	zero,0(r17)
8112c244:	003fc606 	br	8112c160 <__reset+0xfb10c160>

8112c248 <__lshift>:
8112c248:	defff904 	addi	sp,sp,-28
8112c24c:	de00012e 	bgeu	sp,et,8112c254 <__lshift+0xc>
8112c250:	003b68fa 	trap	3
8112c254:	dd400515 	stw	r21,20(sp)
8112c258:	dcc00315 	stw	r19,12(sp)
8112c25c:	302bd17a 	srai	r21,r6,5
8112c260:	2cc00417 	ldw	r19,16(r5)
8112c264:	28800217 	ldw	r2,8(r5)
8112c268:	dd000415 	stw	r20,16(sp)
8112c26c:	ace7883a 	add	r19,r21,r19
8112c270:	dc800215 	stw	r18,8(sp)
8112c274:	dc400115 	stw	r17,4(sp)
8112c278:	dc000015 	stw	r16,0(sp)
8112c27c:	dfc00615 	stw	ra,24(sp)
8112c280:	9c000044 	addi	r16,r19,1
8112c284:	2823883a 	mov	r17,r5
8112c288:	3029883a 	mov	r20,r6
8112c28c:	2025883a 	mov	r18,r4
8112c290:	29400117 	ldw	r5,4(r5)
8112c294:	1400030e 	bge	r2,r16,8112c2a4 <__lshift+0x5c>
8112c298:	1085883a 	add	r2,r2,r2
8112c29c:	29400044 	addi	r5,r5,1
8112c2a0:	143ffd16 	blt	r2,r16,8112c298 <__reset+0xfb10c298>
8112c2a4:	9009883a 	mov	r4,r18
8112c2a8:	112ba980 	call	8112ba98 <_Balloc>
8112c2ac:	10c00504 	addi	r3,r2,20
8112c2b0:	0540070e 	bge	zero,r21,8112c2d0 <__lshift+0x88>
8112c2b4:	ad6b883a 	add	r21,r21,r21
8112c2b8:	ad6b883a 	add	r21,r21,r21
8112c2bc:	1809883a 	mov	r4,r3
8112c2c0:	1d47883a 	add	r3,r3,r21
8112c2c4:	20000015 	stw	zero,0(r4)
8112c2c8:	21000104 	addi	r4,r4,4
8112c2cc:	193ffd1e 	bne	r3,r4,8112c2c4 <__reset+0xfb10c2c4>
8112c2d0:	8a000417 	ldw	r8,16(r17)
8112c2d4:	89000504 	addi	r4,r17,20
8112c2d8:	a18007cc 	andi	r6,r20,31
8112c2dc:	4211883a 	add	r8,r8,r8
8112c2e0:	4211883a 	add	r8,r8,r8
8112c2e4:	2211883a 	add	r8,r4,r8
8112c2e8:	30002326 	beq	r6,zero,8112c378 <__lshift+0x130>
8112c2ec:	02400804 	movi	r9,32
8112c2f0:	4993c83a 	sub	r9,r9,r6
8112c2f4:	000b883a 	mov	r5,zero
8112c2f8:	21c00017 	ldw	r7,0(r4)
8112c2fc:	1815883a 	mov	r10,r3
8112c300:	18c00104 	addi	r3,r3,4
8112c304:	398e983a 	sll	r7,r7,r6
8112c308:	21000104 	addi	r4,r4,4
8112c30c:	394ab03a 	or	r5,r7,r5
8112c310:	197fff15 	stw	r5,-4(r3)
8112c314:	217fff17 	ldw	r5,-4(r4)
8112c318:	2a4ad83a 	srl	r5,r5,r9
8112c31c:	223ff636 	bltu	r4,r8,8112c2f8 <__reset+0xfb10c2f8>
8112c320:	51400115 	stw	r5,4(r10)
8112c324:	28001a1e 	bne	r5,zero,8112c390 <__lshift+0x148>
8112c328:	843fffc4 	addi	r16,r16,-1
8112c32c:	14000415 	stw	r16,16(r2)
8112c330:	88000826 	beq	r17,zero,8112c354 <__lshift+0x10c>
8112c334:	89000117 	ldw	r4,4(r17)
8112c338:	90c01317 	ldw	r3,76(r18)
8112c33c:	2109883a 	add	r4,r4,r4
8112c340:	2109883a 	add	r4,r4,r4
8112c344:	1907883a 	add	r3,r3,r4
8112c348:	19000017 	ldw	r4,0(r3)
8112c34c:	89000015 	stw	r4,0(r17)
8112c350:	1c400015 	stw	r17,0(r3)
8112c354:	dfc00617 	ldw	ra,24(sp)
8112c358:	dd400517 	ldw	r21,20(sp)
8112c35c:	dd000417 	ldw	r20,16(sp)
8112c360:	dcc00317 	ldw	r19,12(sp)
8112c364:	dc800217 	ldw	r18,8(sp)
8112c368:	dc400117 	ldw	r17,4(sp)
8112c36c:	dc000017 	ldw	r16,0(sp)
8112c370:	dec00704 	addi	sp,sp,28
8112c374:	f800283a 	ret
8112c378:	21400017 	ldw	r5,0(r4)
8112c37c:	18c00104 	addi	r3,r3,4
8112c380:	21000104 	addi	r4,r4,4
8112c384:	197fff15 	stw	r5,-4(r3)
8112c388:	223ffb36 	bltu	r4,r8,8112c378 <__reset+0xfb10c378>
8112c38c:	003fe606 	br	8112c328 <__reset+0xfb10c328>
8112c390:	9c000084 	addi	r16,r19,2
8112c394:	003fe406 	br	8112c328 <__reset+0xfb10c328>

8112c398 <__mcmp>:
8112c398:	20800417 	ldw	r2,16(r4)
8112c39c:	28c00417 	ldw	r3,16(r5)
8112c3a0:	10c5c83a 	sub	r2,r2,r3
8112c3a4:	1000111e 	bne	r2,zero,8112c3ec <__mcmp+0x54>
8112c3a8:	18c7883a 	add	r3,r3,r3
8112c3ac:	18c7883a 	add	r3,r3,r3
8112c3b0:	21000504 	addi	r4,r4,20
8112c3b4:	29400504 	addi	r5,r5,20
8112c3b8:	20c5883a 	add	r2,r4,r3
8112c3bc:	28cb883a 	add	r5,r5,r3
8112c3c0:	00000106 	br	8112c3c8 <__mcmp+0x30>
8112c3c4:	20800a2e 	bgeu	r4,r2,8112c3f0 <__mcmp+0x58>
8112c3c8:	10bfff04 	addi	r2,r2,-4
8112c3cc:	297fff04 	addi	r5,r5,-4
8112c3d0:	11800017 	ldw	r6,0(r2)
8112c3d4:	28c00017 	ldw	r3,0(r5)
8112c3d8:	30fffa26 	beq	r6,r3,8112c3c4 <__reset+0xfb10c3c4>
8112c3dc:	30c00236 	bltu	r6,r3,8112c3e8 <__mcmp+0x50>
8112c3e0:	00800044 	movi	r2,1
8112c3e4:	f800283a 	ret
8112c3e8:	00bfffc4 	movi	r2,-1
8112c3ec:	f800283a 	ret
8112c3f0:	0005883a 	mov	r2,zero
8112c3f4:	f800283a 	ret

8112c3f8 <__mdiff>:
8112c3f8:	defffa04 	addi	sp,sp,-24
8112c3fc:	de00012e 	bgeu	sp,et,8112c404 <__mdiff+0xc>
8112c400:	003b68fa 	trap	3
8112c404:	28c00417 	ldw	r3,16(r5)
8112c408:	30800417 	ldw	r2,16(r6)
8112c40c:	dcc00315 	stw	r19,12(sp)
8112c410:	dc800215 	stw	r18,8(sp)
8112c414:	dfc00515 	stw	ra,20(sp)
8112c418:	dd000415 	stw	r20,16(sp)
8112c41c:	dc400115 	stw	r17,4(sp)
8112c420:	dc000015 	stw	r16,0(sp)
8112c424:	1887c83a 	sub	r3,r3,r2
8112c428:	2825883a 	mov	r18,r5
8112c42c:	3027883a 	mov	r19,r6
8112c430:	1800141e 	bne	r3,zero,8112c484 <__mdiff+0x8c>
8112c434:	1085883a 	add	r2,r2,r2
8112c438:	1085883a 	add	r2,r2,r2
8112c43c:	2a000504 	addi	r8,r5,20
8112c440:	34000504 	addi	r16,r6,20
8112c444:	4087883a 	add	r3,r8,r2
8112c448:	8085883a 	add	r2,r16,r2
8112c44c:	00000106 	br	8112c454 <__mdiff+0x5c>
8112c450:	40c0592e 	bgeu	r8,r3,8112c5b8 <__mdiff+0x1c0>
8112c454:	18ffff04 	addi	r3,r3,-4
8112c458:	10bfff04 	addi	r2,r2,-4
8112c45c:	19c00017 	ldw	r7,0(r3)
8112c460:	11400017 	ldw	r5,0(r2)
8112c464:	397ffa26 	beq	r7,r5,8112c450 <__reset+0xfb10c450>
8112c468:	3940592e 	bgeu	r7,r5,8112c5d0 <__mdiff+0x1d8>
8112c46c:	9005883a 	mov	r2,r18
8112c470:	4023883a 	mov	r17,r8
8112c474:	9825883a 	mov	r18,r19
8112c478:	05000044 	movi	r20,1
8112c47c:	1027883a 	mov	r19,r2
8112c480:	00000406 	br	8112c494 <__mdiff+0x9c>
8112c484:	18005616 	blt	r3,zero,8112c5e0 <__mdiff+0x1e8>
8112c488:	34400504 	addi	r17,r6,20
8112c48c:	2c000504 	addi	r16,r5,20
8112c490:	0029883a 	mov	r20,zero
8112c494:	91400117 	ldw	r5,4(r18)
8112c498:	112ba980 	call	8112ba98 <_Balloc>
8112c49c:	92400417 	ldw	r9,16(r18)
8112c4a0:	9b000417 	ldw	r12,16(r19)
8112c4a4:	12c00504 	addi	r11,r2,20
8112c4a8:	4a51883a 	add	r8,r9,r9
8112c4ac:	6319883a 	add	r12,r12,r12
8112c4b0:	4211883a 	add	r8,r8,r8
8112c4b4:	6319883a 	add	r12,r12,r12
8112c4b8:	15000315 	stw	r20,12(r2)
8112c4bc:	8211883a 	add	r8,r16,r8
8112c4c0:	8b19883a 	add	r12,r17,r12
8112c4c4:	0007883a 	mov	r3,zero
8112c4c8:	81400017 	ldw	r5,0(r16)
8112c4cc:	89c00017 	ldw	r7,0(r17)
8112c4d0:	59800104 	addi	r6,r11,4
8112c4d4:	293fffcc 	andi	r4,r5,65535
8112c4d8:	20c7883a 	add	r3,r4,r3
8112c4dc:	393fffcc 	andi	r4,r7,65535
8112c4e0:	1909c83a 	sub	r4,r3,r4
8112c4e4:	280ad43a 	srli	r5,r5,16
8112c4e8:	380ed43a 	srli	r7,r7,16
8112c4ec:	2007d43a 	srai	r3,r4,16
8112c4f0:	213fffcc 	andi	r4,r4,65535
8112c4f4:	29cbc83a 	sub	r5,r5,r7
8112c4f8:	28c7883a 	add	r3,r5,r3
8112c4fc:	180a943a 	slli	r5,r3,16
8112c500:	8c400104 	addi	r17,r17,4
8112c504:	84000104 	addi	r16,r16,4
8112c508:	2908b03a 	or	r4,r5,r4
8112c50c:	59000015 	stw	r4,0(r11)
8112c510:	1807d43a 	srai	r3,r3,16
8112c514:	3015883a 	mov	r10,r6
8112c518:	3017883a 	mov	r11,r6
8112c51c:	8b3fea36 	bltu	r17,r12,8112c4c8 <__reset+0xfb10c4c8>
8112c520:	8200162e 	bgeu	r16,r8,8112c57c <__mdiff+0x184>
8112c524:	8017883a 	mov	r11,r16
8112c528:	59400017 	ldw	r5,0(r11)
8112c52c:	31800104 	addi	r6,r6,4
8112c530:	5ac00104 	addi	r11,r11,4
8112c534:	293fffcc 	andi	r4,r5,65535
8112c538:	20c7883a 	add	r3,r4,r3
8112c53c:	280ed43a 	srli	r7,r5,16
8112c540:	180bd43a 	srai	r5,r3,16
8112c544:	193fffcc 	andi	r4,r3,65535
8112c548:	3947883a 	add	r3,r7,r5
8112c54c:	180a943a 	slli	r5,r3,16
8112c550:	1807d43a 	srai	r3,r3,16
8112c554:	2908b03a 	or	r4,r5,r4
8112c558:	313fff15 	stw	r4,-4(r6)
8112c55c:	5a3ff236 	bltu	r11,r8,8112c528 <__reset+0xfb10c528>
8112c560:	0406303a 	nor	r3,zero,r16
8112c564:	1a07883a 	add	r3,r3,r8
8112c568:	1806d0ba 	srli	r3,r3,2
8112c56c:	18c00044 	addi	r3,r3,1
8112c570:	18c7883a 	add	r3,r3,r3
8112c574:	18c7883a 	add	r3,r3,r3
8112c578:	50d5883a 	add	r10,r10,r3
8112c57c:	50ffff04 	addi	r3,r10,-4
8112c580:	2000041e 	bne	r4,zero,8112c594 <__mdiff+0x19c>
8112c584:	18ffff04 	addi	r3,r3,-4
8112c588:	19000017 	ldw	r4,0(r3)
8112c58c:	4a7fffc4 	addi	r9,r9,-1
8112c590:	203ffc26 	beq	r4,zero,8112c584 <__reset+0xfb10c584>
8112c594:	12400415 	stw	r9,16(r2)
8112c598:	dfc00517 	ldw	ra,20(sp)
8112c59c:	dd000417 	ldw	r20,16(sp)
8112c5a0:	dcc00317 	ldw	r19,12(sp)
8112c5a4:	dc800217 	ldw	r18,8(sp)
8112c5a8:	dc400117 	ldw	r17,4(sp)
8112c5ac:	dc000017 	ldw	r16,0(sp)
8112c5b0:	dec00604 	addi	sp,sp,24
8112c5b4:	f800283a 	ret
8112c5b8:	000b883a 	mov	r5,zero
8112c5bc:	112ba980 	call	8112ba98 <_Balloc>
8112c5c0:	00c00044 	movi	r3,1
8112c5c4:	10c00415 	stw	r3,16(r2)
8112c5c8:	10000515 	stw	zero,20(r2)
8112c5cc:	003ff206 	br	8112c598 <__reset+0xfb10c598>
8112c5d0:	8023883a 	mov	r17,r16
8112c5d4:	0029883a 	mov	r20,zero
8112c5d8:	4021883a 	mov	r16,r8
8112c5dc:	003fad06 	br	8112c494 <__reset+0xfb10c494>
8112c5e0:	9005883a 	mov	r2,r18
8112c5e4:	94400504 	addi	r17,r18,20
8112c5e8:	9c000504 	addi	r16,r19,20
8112c5ec:	9825883a 	mov	r18,r19
8112c5f0:	05000044 	movi	r20,1
8112c5f4:	1027883a 	mov	r19,r2
8112c5f8:	003fa606 	br	8112c494 <__reset+0xfb10c494>

8112c5fc <__ulp>:
8112c5fc:	295ffc2c 	andhi	r5,r5,32752
8112c600:	00bf3034 	movhi	r2,64704
8112c604:	2887883a 	add	r3,r5,r2
8112c608:	00c0020e 	bge	zero,r3,8112c614 <__ulp+0x18>
8112c60c:	0005883a 	mov	r2,zero
8112c610:	f800283a 	ret
8112c614:	00c7c83a 	sub	r3,zero,r3
8112c618:	1807d53a 	srai	r3,r3,20
8112c61c:	008004c4 	movi	r2,19
8112c620:	10c00b0e 	bge	r2,r3,8112c650 <__ulp+0x54>
8112c624:	18bffb04 	addi	r2,r3,-20
8112c628:	01000784 	movi	r4,30
8112c62c:	0007883a 	mov	r3,zero
8112c630:	20800516 	blt	r4,r2,8112c648 <__ulp+0x4c>
8112c634:	010007c4 	movi	r4,31
8112c638:	2089c83a 	sub	r4,r4,r2
8112c63c:	00800044 	movi	r2,1
8112c640:	1104983a 	sll	r2,r2,r4
8112c644:	f800283a 	ret
8112c648:	00800044 	movi	r2,1
8112c64c:	f800283a 	ret
8112c650:	01400234 	movhi	r5,8
8112c654:	28c7d83a 	sra	r3,r5,r3
8112c658:	0005883a 	mov	r2,zero
8112c65c:	f800283a 	ret

8112c660 <__b2d>:
8112c660:	defffa04 	addi	sp,sp,-24
8112c664:	de00012e 	bgeu	sp,et,8112c66c <__b2d+0xc>
8112c668:	003b68fa 	trap	3
8112c66c:	dc000015 	stw	r16,0(sp)
8112c670:	24000417 	ldw	r16,16(r4)
8112c674:	dc400115 	stw	r17,4(sp)
8112c678:	24400504 	addi	r17,r4,20
8112c67c:	8421883a 	add	r16,r16,r16
8112c680:	8421883a 	add	r16,r16,r16
8112c684:	8c21883a 	add	r16,r17,r16
8112c688:	dc800215 	stw	r18,8(sp)
8112c68c:	84bfff17 	ldw	r18,-4(r16)
8112c690:	dd000415 	stw	r20,16(sp)
8112c694:	dcc00315 	stw	r19,12(sp)
8112c698:	9009883a 	mov	r4,r18
8112c69c:	2829883a 	mov	r20,r5
8112c6a0:	dfc00515 	stw	ra,20(sp)
8112c6a4:	112bda40 	call	8112bda4 <__hi0bits>
8112c6a8:	00c00804 	movi	r3,32
8112c6ac:	1889c83a 	sub	r4,r3,r2
8112c6b0:	a1000015 	stw	r4,0(r20)
8112c6b4:	01000284 	movi	r4,10
8112c6b8:	84ffff04 	addi	r19,r16,-4
8112c6bc:	20801216 	blt	r4,r2,8112c708 <__b2d+0xa8>
8112c6c0:	018002c4 	movi	r6,11
8112c6c4:	308dc83a 	sub	r6,r6,r2
8112c6c8:	9186d83a 	srl	r3,r18,r6
8112c6cc:	18cffc34 	orhi	r3,r3,16368
8112c6d0:	8cc0212e 	bgeu	r17,r19,8112c758 <__b2d+0xf8>
8112c6d4:	813ffe17 	ldw	r4,-8(r16)
8112c6d8:	218cd83a 	srl	r6,r4,r6
8112c6dc:	10800544 	addi	r2,r2,21
8112c6e0:	9084983a 	sll	r2,r18,r2
8112c6e4:	1184b03a 	or	r2,r2,r6
8112c6e8:	dfc00517 	ldw	ra,20(sp)
8112c6ec:	dd000417 	ldw	r20,16(sp)
8112c6f0:	dcc00317 	ldw	r19,12(sp)
8112c6f4:	dc800217 	ldw	r18,8(sp)
8112c6f8:	dc400117 	ldw	r17,4(sp)
8112c6fc:	dc000017 	ldw	r16,0(sp)
8112c700:	dec00604 	addi	sp,sp,24
8112c704:	f800283a 	ret
8112c708:	8cc00f2e 	bgeu	r17,r19,8112c748 <__b2d+0xe8>
8112c70c:	117ffd44 	addi	r5,r2,-11
8112c710:	80bffe17 	ldw	r2,-8(r16)
8112c714:	28000e26 	beq	r5,zero,8112c750 <__b2d+0xf0>
8112c718:	1949c83a 	sub	r4,r3,r5
8112c71c:	9164983a 	sll	r18,r18,r5
8112c720:	1106d83a 	srl	r3,r2,r4
8112c724:	81bffe04 	addi	r6,r16,-8
8112c728:	948ffc34 	orhi	r18,r18,16368
8112c72c:	90c6b03a 	or	r3,r18,r3
8112c730:	89800e2e 	bgeu	r17,r6,8112c76c <__b2d+0x10c>
8112c734:	81bffd17 	ldw	r6,-12(r16)
8112c738:	1144983a 	sll	r2,r2,r5
8112c73c:	310ad83a 	srl	r5,r6,r4
8112c740:	2884b03a 	or	r2,r5,r2
8112c744:	003fe806 	br	8112c6e8 <__reset+0xfb10c6e8>
8112c748:	10bffd44 	addi	r2,r2,-11
8112c74c:	1000041e 	bne	r2,zero,8112c760 <__b2d+0x100>
8112c750:	90cffc34 	orhi	r3,r18,16368
8112c754:	003fe406 	br	8112c6e8 <__reset+0xfb10c6e8>
8112c758:	000d883a 	mov	r6,zero
8112c75c:	003fdf06 	br	8112c6dc <__reset+0xfb10c6dc>
8112c760:	90a4983a 	sll	r18,r18,r2
8112c764:	0005883a 	mov	r2,zero
8112c768:	003ff906 	br	8112c750 <__reset+0xfb10c750>
8112c76c:	1144983a 	sll	r2,r2,r5
8112c770:	003fdd06 	br	8112c6e8 <__reset+0xfb10c6e8>

8112c774 <__d2b>:
8112c774:	defff804 	addi	sp,sp,-32
8112c778:	de00012e 	bgeu	sp,et,8112c780 <__d2b+0xc>
8112c77c:	003b68fa 	trap	3
8112c780:	dc000215 	stw	r16,8(sp)
8112c784:	3021883a 	mov	r16,r6
8112c788:	dc400315 	stw	r17,12(sp)
8112c78c:	8022907a 	slli	r17,r16,1
8112c790:	dd000615 	stw	r20,24(sp)
8112c794:	2829883a 	mov	r20,r5
8112c798:	01400044 	movi	r5,1
8112c79c:	dcc00515 	stw	r19,20(sp)
8112c7a0:	dc800415 	stw	r18,16(sp)
8112c7a4:	dfc00715 	stw	ra,28(sp)
8112c7a8:	3825883a 	mov	r18,r7
8112c7ac:	8822d57a 	srli	r17,r17,21
8112c7b0:	112ba980 	call	8112ba98 <_Balloc>
8112c7b4:	1027883a 	mov	r19,r2
8112c7b8:	00800434 	movhi	r2,16
8112c7bc:	10bfffc4 	addi	r2,r2,-1
8112c7c0:	808c703a 	and	r6,r16,r2
8112c7c4:	88000126 	beq	r17,zero,8112c7cc <__d2b+0x58>
8112c7c8:	31800434 	orhi	r6,r6,16
8112c7cc:	d9800015 	stw	r6,0(sp)
8112c7d0:	a0002426 	beq	r20,zero,8112c864 <__d2b+0xf0>
8112c7d4:	d9000104 	addi	r4,sp,4
8112c7d8:	dd000115 	stw	r20,4(sp)
8112c7dc:	112be0c0 	call	8112be0c <__lo0bits>
8112c7e0:	d8c00017 	ldw	r3,0(sp)
8112c7e4:	10002f1e 	bne	r2,zero,8112c8a4 <__d2b+0x130>
8112c7e8:	d9000117 	ldw	r4,4(sp)
8112c7ec:	99000515 	stw	r4,20(r19)
8112c7f0:	1821003a 	cmpeq	r16,r3,zero
8112c7f4:	01000084 	movi	r4,2
8112c7f8:	2421c83a 	sub	r16,r4,r16
8112c7fc:	98c00615 	stw	r3,24(r19)
8112c800:	9c000415 	stw	r16,16(r19)
8112c804:	88001f1e 	bne	r17,zero,8112c884 <__d2b+0x110>
8112c808:	10bef384 	addi	r2,r2,-1074
8112c80c:	90800015 	stw	r2,0(r18)
8112c810:	00900034 	movhi	r2,16384
8112c814:	10bfffc4 	addi	r2,r2,-1
8112c818:	8085883a 	add	r2,r16,r2
8112c81c:	1085883a 	add	r2,r2,r2
8112c820:	1085883a 	add	r2,r2,r2
8112c824:	9885883a 	add	r2,r19,r2
8112c828:	11000517 	ldw	r4,20(r2)
8112c82c:	8020917a 	slli	r16,r16,5
8112c830:	112bda40 	call	8112bda4 <__hi0bits>
8112c834:	d8c00817 	ldw	r3,32(sp)
8112c838:	8085c83a 	sub	r2,r16,r2
8112c83c:	18800015 	stw	r2,0(r3)
8112c840:	9805883a 	mov	r2,r19
8112c844:	dfc00717 	ldw	ra,28(sp)
8112c848:	dd000617 	ldw	r20,24(sp)
8112c84c:	dcc00517 	ldw	r19,20(sp)
8112c850:	dc800417 	ldw	r18,16(sp)
8112c854:	dc400317 	ldw	r17,12(sp)
8112c858:	dc000217 	ldw	r16,8(sp)
8112c85c:	dec00804 	addi	sp,sp,32
8112c860:	f800283a 	ret
8112c864:	d809883a 	mov	r4,sp
8112c868:	112be0c0 	call	8112be0c <__lo0bits>
8112c86c:	d8c00017 	ldw	r3,0(sp)
8112c870:	04000044 	movi	r16,1
8112c874:	9c000415 	stw	r16,16(r19)
8112c878:	98c00515 	stw	r3,20(r19)
8112c87c:	10800804 	addi	r2,r2,32
8112c880:	883fe126 	beq	r17,zero,8112c808 <__reset+0xfb10c808>
8112c884:	00c00d44 	movi	r3,53
8112c888:	8c7ef344 	addi	r17,r17,-1075
8112c88c:	88a3883a 	add	r17,r17,r2
8112c890:	1885c83a 	sub	r2,r3,r2
8112c894:	d8c00817 	ldw	r3,32(sp)
8112c898:	94400015 	stw	r17,0(r18)
8112c89c:	18800015 	stw	r2,0(r3)
8112c8a0:	003fe706 	br	8112c840 <__reset+0xfb10c840>
8112c8a4:	01000804 	movi	r4,32
8112c8a8:	2089c83a 	sub	r4,r4,r2
8112c8ac:	1908983a 	sll	r4,r3,r4
8112c8b0:	d9400117 	ldw	r5,4(sp)
8112c8b4:	1886d83a 	srl	r3,r3,r2
8112c8b8:	2148b03a 	or	r4,r4,r5
8112c8bc:	99000515 	stw	r4,20(r19)
8112c8c0:	d8c00015 	stw	r3,0(sp)
8112c8c4:	003fca06 	br	8112c7f0 <__reset+0xfb10c7f0>

8112c8c8 <__ratio>:
8112c8c8:	defff904 	addi	sp,sp,-28
8112c8cc:	de00012e 	bgeu	sp,et,8112c8d4 <__ratio+0xc>
8112c8d0:	003b68fa 	trap	3
8112c8d4:	dc400315 	stw	r17,12(sp)
8112c8d8:	2823883a 	mov	r17,r5
8112c8dc:	d9400104 	addi	r5,sp,4
8112c8e0:	dfc00615 	stw	ra,24(sp)
8112c8e4:	dcc00515 	stw	r19,20(sp)
8112c8e8:	dc800415 	stw	r18,16(sp)
8112c8ec:	2027883a 	mov	r19,r4
8112c8f0:	dc000215 	stw	r16,8(sp)
8112c8f4:	112c6600 	call	8112c660 <__b2d>
8112c8f8:	d80b883a 	mov	r5,sp
8112c8fc:	8809883a 	mov	r4,r17
8112c900:	1025883a 	mov	r18,r2
8112c904:	1821883a 	mov	r16,r3
8112c908:	112c6600 	call	8112c660 <__b2d>
8112c90c:	8a000417 	ldw	r8,16(r17)
8112c910:	99000417 	ldw	r4,16(r19)
8112c914:	d9400117 	ldw	r5,4(sp)
8112c918:	2209c83a 	sub	r4,r4,r8
8112c91c:	2010917a 	slli	r8,r4,5
8112c920:	d9000017 	ldw	r4,0(sp)
8112c924:	2909c83a 	sub	r4,r5,r4
8112c928:	4109883a 	add	r4,r8,r4
8112c92c:	01000e0e 	bge	zero,r4,8112c968 <__ratio+0xa0>
8112c930:	2008953a 	slli	r4,r4,20
8112c934:	2421883a 	add	r16,r4,r16
8112c938:	100d883a 	mov	r6,r2
8112c93c:	180f883a 	mov	r7,r3
8112c940:	9009883a 	mov	r4,r18
8112c944:	800b883a 	mov	r5,r16
8112c948:	11349400 	call	81134940 <__divdf3>
8112c94c:	dfc00617 	ldw	ra,24(sp)
8112c950:	dcc00517 	ldw	r19,20(sp)
8112c954:	dc800417 	ldw	r18,16(sp)
8112c958:	dc400317 	ldw	r17,12(sp)
8112c95c:	dc000217 	ldw	r16,8(sp)
8112c960:	dec00704 	addi	sp,sp,28
8112c964:	f800283a 	ret
8112c968:	2008953a 	slli	r4,r4,20
8112c96c:	1907c83a 	sub	r3,r3,r4
8112c970:	003ff106 	br	8112c938 <__reset+0xfb10c938>

8112c974 <_mprec_log10>:
8112c974:	defffe04 	addi	sp,sp,-8
8112c978:	de00012e 	bgeu	sp,et,8112c980 <_mprec_log10+0xc>
8112c97c:	003b68fa 	trap	3
8112c980:	008005c4 	movi	r2,23
8112c984:	dc000015 	stw	r16,0(sp)
8112c988:	dfc00115 	stw	ra,4(sp)
8112c98c:	2021883a 	mov	r16,r4
8112c990:	11000d0e 	bge	r2,r4,8112c9c8 <_mprec_log10+0x54>
8112c994:	0005883a 	mov	r2,zero
8112c998:	00cffc34 	movhi	r3,16368
8112c99c:	843fffc4 	addi	r16,r16,-1
8112c9a0:	000d883a 	mov	r6,zero
8112c9a4:	01d00934 	movhi	r7,16420
8112c9a8:	1009883a 	mov	r4,r2
8112c9ac:	180b883a 	mov	r5,r3
8112c9b0:	111f1b00 	call	8111f1b0 <__muldf3>
8112c9b4:	803ff91e 	bne	r16,zero,8112c99c <__reset+0xfb10c99c>
8112c9b8:	dfc00117 	ldw	ra,4(sp)
8112c9bc:	dc000017 	ldw	r16,0(sp)
8112c9c0:	dec00204 	addi	sp,sp,8
8112c9c4:	f800283a 	ret
8112c9c8:	202090fa 	slli	r16,r4,3
8112c9cc:	00a04574 	movhi	r2,33045
8112c9d0:	10beda04 	addi	r2,r2,-1176
8112c9d4:	1421883a 	add	r16,r2,r16
8112c9d8:	80800017 	ldw	r2,0(r16)
8112c9dc:	80c00117 	ldw	r3,4(r16)
8112c9e0:	dfc00117 	ldw	ra,4(sp)
8112c9e4:	dc000017 	ldw	r16,0(sp)
8112c9e8:	dec00204 	addi	sp,sp,8
8112c9ec:	f800283a 	ret

8112c9f0 <__copybits>:
8112c9f0:	297fffc4 	addi	r5,r5,-1
8112c9f4:	280fd17a 	srai	r7,r5,5
8112c9f8:	30c00417 	ldw	r3,16(r6)
8112c9fc:	30800504 	addi	r2,r6,20
8112ca00:	39c00044 	addi	r7,r7,1
8112ca04:	18c7883a 	add	r3,r3,r3
8112ca08:	39cf883a 	add	r7,r7,r7
8112ca0c:	18c7883a 	add	r3,r3,r3
8112ca10:	39cf883a 	add	r7,r7,r7
8112ca14:	10c7883a 	add	r3,r2,r3
8112ca18:	21cf883a 	add	r7,r4,r7
8112ca1c:	10c00d2e 	bgeu	r2,r3,8112ca54 <__copybits+0x64>
8112ca20:	200b883a 	mov	r5,r4
8112ca24:	12000017 	ldw	r8,0(r2)
8112ca28:	29400104 	addi	r5,r5,4
8112ca2c:	10800104 	addi	r2,r2,4
8112ca30:	2a3fff15 	stw	r8,-4(r5)
8112ca34:	10fffb36 	bltu	r2,r3,8112ca24 <__reset+0xfb10ca24>
8112ca38:	1985c83a 	sub	r2,r3,r6
8112ca3c:	10bffac4 	addi	r2,r2,-21
8112ca40:	1004d0ba 	srli	r2,r2,2
8112ca44:	10800044 	addi	r2,r2,1
8112ca48:	1085883a 	add	r2,r2,r2
8112ca4c:	1085883a 	add	r2,r2,r2
8112ca50:	2089883a 	add	r4,r4,r2
8112ca54:	21c0032e 	bgeu	r4,r7,8112ca64 <__copybits+0x74>
8112ca58:	20000015 	stw	zero,0(r4)
8112ca5c:	21000104 	addi	r4,r4,4
8112ca60:	21fffd36 	bltu	r4,r7,8112ca58 <__reset+0xfb10ca58>
8112ca64:	f800283a 	ret

8112ca68 <__any_on>:
8112ca68:	20c00417 	ldw	r3,16(r4)
8112ca6c:	2805d17a 	srai	r2,r5,5
8112ca70:	21000504 	addi	r4,r4,20
8112ca74:	18800d0e 	bge	r3,r2,8112caac <__any_on+0x44>
8112ca78:	18c7883a 	add	r3,r3,r3
8112ca7c:	18c7883a 	add	r3,r3,r3
8112ca80:	20c7883a 	add	r3,r4,r3
8112ca84:	20c0192e 	bgeu	r4,r3,8112caec <__any_on+0x84>
8112ca88:	18bfff17 	ldw	r2,-4(r3)
8112ca8c:	18ffff04 	addi	r3,r3,-4
8112ca90:	1000041e 	bne	r2,zero,8112caa4 <__any_on+0x3c>
8112ca94:	20c0142e 	bgeu	r4,r3,8112cae8 <__any_on+0x80>
8112ca98:	18ffff04 	addi	r3,r3,-4
8112ca9c:	19400017 	ldw	r5,0(r3)
8112caa0:	283ffc26 	beq	r5,zero,8112ca94 <__reset+0xfb10ca94>
8112caa4:	00800044 	movi	r2,1
8112caa8:	f800283a 	ret
8112caac:	10c00a0e 	bge	r2,r3,8112cad8 <__any_on+0x70>
8112cab0:	1085883a 	add	r2,r2,r2
8112cab4:	1085883a 	add	r2,r2,r2
8112cab8:	294007cc 	andi	r5,r5,31
8112cabc:	2087883a 	add	r3,r4,r2
8112cac0:	283ff026 	beq	r5,zero,8112ca84 <__reset+0xfb10ca84>
8112cac4:	19800017 	ldw	r6,0(r3)
8112cac8:	3144d83a 	srl	r2,r6,r5
8112cacc:	114a983a 	sll	r5,r2,r5
8112cad0:	317ff41e 	bne	r6,r5,8112caa4 <__reset+0xfb10caa4>
8112cad4:	003feb06 	br	8112ca84 <__reset+0xfb10ca84>
8112cad8:	1085883a 	add	r2,r2,r2
8112cadc:	1085883a 	add	r2,r2,r2
8112cae0:	2087883a 	add	r3,r4,r2
8112cae4:	003fe706 	br	8112ca84 <__reset+0xfb10ca84>
8112cae8:	f800283a 	ret
8112caec:	0005883a 	mov	r2,zero
8112caf0:	f800283a 	ret

8112caf4 <_read_r>:
8112caf4:	defffd04 	addi	sp,sp,-12
8112caf8:	de00012e 	bgeu	sp,et,8112cb00 <_read_r+0xc>
8112cafc:	003b68fa 	trap	3
8112cb00:	2805883a 	mov	r2,r5
8112cb04:	dc000015 	stw	r16,0(sp)
8112cb08:	04204574 	movhi	r16,33045
8112cb0c:	dc400115 	stw	r17,4(sp)
8112cb10:	300b883a 	mov	r5,r6
8112cb14:	8408db04 	addi	r16,r16,9068
8112cb18:	2023883a 	mov	r17,r4
8112cb1c:	380d883a 	mov	r6,r7
8112cb20:	1009883a 	mov	r4,r2
8112cb24:	dfc00215 	stw	ra,8(sp)
8112cb28:	80000015 	stw	zero,0(r16)
8112cb2c:	1136ab00 	call	81136ab0 <read>
8112cb30:	00ffffc4 	movi	r3,-1
8112cb34:	10c00526 	beq	r2,r3,8112cb4c <_read_r+0x58>
8112cb38:	dfc00217 	ldw	ra,8(sp)
8112cb3c:	dc400117 	ldw	r17,4(sp)
8112cb40:	dc000017 	ldw	r16,0(sp)
8112cb44:	dec00304 	addi	sp,sp,12
8112cb48:	f800283a 	ret
8112cb4c:	80c00017 	ldw	r3,0(r16)
8112cb50:	183ff926 	beq	r3,zero,8112cb38 <__reset+0xfb10cb38>
8112cb54:	88c00015 	stw	r3,0(r17)
8112cb58:	003ff706 	br	8112cb38 <__reset+0xfb10cb38>

8112cb5c <_realloc_r>:
8112cb5c:	defff604 	addi	sp,sp,-40
8112cb60:	de00012e 	bgeu	sp,et,8112cb68 <_realloc_r+0xc>
8112cb64:	003b68fa 	trap	3
8112cb68:	dc800215 	stw	r18,8(sp)
8112cb6c:	dfc00915 	stw	ra,36(sp)
8112cb70:	df000815 	stw	fp,32(sp)
8112cb74:	ddc00715 	stw	r23,28(sp)
8112cb78:	dd800615 	stw	r22,24(sp)
8112cb7c:	dd400515 	stw	r21,20(sp)
8112cb80:	dd000415 	stw	r20,16(sp)
8112cb84:	dcc00315 	stw	r19,12(sp)
8112cb88:	dc400115 	stw	r17,4(sp)
8112cb8c:	dc000015 	stw	r16,0(sp)
8112cb90:	3025883a 	mov	r18,r6
8112cb94:	2800b726 	beq	r5,zero,8112ce74 <_realloc_r+0x318>
8112cb98:	282b883a 	mov	r21,r5
8112cb9c:	2029883a 	mov	r20,r4
8112cba0:	11372900 	call	81137290 <__malloc_lock>
8112cba4:	a8bfff17 	ldw	r2,-4(r21)
8112cba8:	043fff04 	movi	r16,-4
8112cbac:	90c002c4 	addi	r3,r18,11
8112cbb0:	01000584 	movi	r4,22
8112cbb4:	acfffe04 	addi	r19,r21,-8
8112cbb8:	1420703a 	and	r16,r2,r16
8112cbbc:	20c0332e 	bgeu	r4,r3,8112cc8c <_realloc_r+0x130>
8112cbc0:	047ffe04 	movi	r17,-8
8112cbc4:	1c62703a 	and	r17,r3,r17
8112cbc8:	8807883a 	mov	r3,r17
8112cbcc:	88005816 	blt	r17,zero,8112cd30 <_realloc_r+0x1d4>
8112cbd0:	8c805736 	bltu	r17,r18,8112cd30 <_realloc_r+0x1d4>
8112cbd4:	80c0300e 	bge	r16,r3,8112cc98 <_realloc_r+0x13c>
8112cbd8:	07204574 	movhi	fp,33045
8112cbdc:	e7022704 	addi	fp,fp,2204
8112cbe0:	e1c00217 	ldw	r7,8(fp)
8112cbe4:	9c09883a 	add	r4,r19,r16
8112cbe8:	22000117 	ldw	r8,4(r4)
8112cbec:	21c06326 	beq	r4,r7,8112cd7c <_realloc_r+0x220>
8112cbf0:	017fff84 	movi	r5,-2
8112cbf4:	414a703a 	and	r5,r8,r5
8112cbf8:	214b883a 	add	r5,r4,r5
8112cbfc:	29800117 	ldw	r6,4(r5)
8112cc00:	3180004c 	andi	r6,r6,1
8112cc04:	30003f26 	beq	r6,zero,8112cd04 <_realloc_r+0x1a8>
8112cc08:	1080004c 	andi	r2,r2,1
8112cc0c:	10008326 	beq	r2,zero,8112ce1c <_realloc_r+0x2c0>
8112cc10:	900b883a 	mov	r5,r18
8112cc14:	a009883a 	mov	r4,r20
8112cc18:	11210540 	call	81121054 <_malloc_r>
8112cc1c:	1025883a 	mov	r18,r2
8112cc20:	10011e26 	beq	r2,zero,8112d09c <_realloc_r+0x540>
8112cc24:	a93fff17 	ldw	r4,-4(r21)
8112cc28:	10fffe04 	addi	r3,r2,-8
8112cc2c:	00bfff84 	movi	r2,-2
8112cc30:	2084703a 	and	r2,r4,r2
8112cc34:	9885883a 	add	r2,r19,r2
8112cc38:	1880ee26 	beq	r3,r2,8112cff4 <_realloc_r+0x498>
8112cc3c:	81bfff04 	addi	r6,r16,-4
8112cc40:	00800904 	movi	r2,36
8112cc44:	1180b836 	bltu	r2,r6,8112cf28 <_realloc_r+0x3cc>
8112cc48:	00c004c4 	movi	r3,19
8112cc4c:	19809636 	bltu	r3,r6,8112cea8 <_realloc_r+0x34c>
8112cc50:	9005883a 	mov	r2,r18
8112cc54:	a807883a 	mov	r3,r21
8112cc58:	19000017 	ldw	r4,0(r3)
8112cc5c:	11000015 	stw	r4,0(r2)
8112cc60:	19000117 	ldw	r4,4(r3)
8112cc64:	11000115 	stw	r4,4(r2)
8112cc68:	18c00217 	ldw	r3,8(r3)
8112cc6c:	10c00215 	stw	r3,8(r2)
8112cc70:	a80b883a 	mov	r5,r21
8112cc74:	a009883a 	mov	r4,r20
8112cc78:	112aac80 	call	8112aac8 <_free_r>
8112cc7c:	a009883a 	mov	r4,r20
8112cc80:	11373b80 	call	811373b8 <__malloc_unlock>
8112cc84:	9005883a 	mov	r2,r18
8112cc88:	00001206 	br	8112ccd4 <_realloc_r+0x178>
8112cc8c:	00c00404 	movi	r3,16
8112cc90:	1823883a 	mov	r17,r3
8112cc94:	003fce06 	br	8112cbd0 <__reset+0xfb10cbd0>
8112cc98:	a825883a 	mov	r18,r21
8112cc9c:	8445c83a 	sub	r2,r16,r17
8112cca0:	00c003c4 	movi	r3,15
8112cca4:	18802636 	bltu	r3,r2,8112cd40 <_realloc_r+0x1e4>
8112cca8:	99800117 	ldw	r6,4(r19)
8112ccac:	9c07883a 	add	r3,r19,r16
8112ccb0:	3180004c 	andi	r6,r6,1
8112ccb4:	3420b03a 	or	r16,r6,r16
8112ccb8:	9c000115 	stw	r16,4(r19)
8112ccbc:	18800117 	ldw	r2,4(r3)
8112ccc0:	10800054 	ori	r2,r2,1
8112ccc4:	18800115 	stw	r2,4(r3)
8112ccc8:	a009883a 	mov	r4,r20
8112cccc:	11373b80 	call	811373b8 <__malloc_unlock>
8112ccd0:	9005883a 	mov	r2,r18
8112ccd4:	dfc00917 	ldw	ra,36(sp)
8112ccd8:	df000817 	ldw	fp,32(sp)
8112ccdc:	ddc00717 	ldw	r23,28(sp)
8112cce0:	dd800617 	ldw	r22,24(sp)
8112cce4:	dd400517 	ldw	r21,20(sp)
8112cce8:	dd000417 	ldw	r20,16(sp)
8112ccec:	dcc00317 	ldw	r19,12(sp)
8112ccf0:	dc800217 	ldw	r18,8(sp)
8112ccf4:	dc400117 	ldw	r17,4(sp)
8112ccf8:	dc000017 	ldw	r16,0(sp)
8112ccfc:	dec00a04 	addi	sp,sp,40
8112cd00:	f800283a 	ret
8112cd04:	017fff04 	movi	r5,-4
8112cd08:	414a703a 	and	r5,r8,r5
8112cd0c:	814d883a 	add	r6,r16,r5
8112cd10:	30c01f16 	blt	r6,r3,8112cd90 <_realloc_r+0x234>
8112cd14:	20800317 	ldw	r2,12(r4)
8112cd18:	20c00217 	ldw	r3,8(r4)
8112cd1c:	a825883a 	mov	r18,r21
8112cd20:	3021883a 	mov	r16,r6
8112cd24:	18800315 	stw	r2,12(r3)
8112cd28:	10c00215 	stw	r3,8(r2)
8112cd2c:	003fdb06 	br	8112cc9c <__reset+0xfb10cc9c>
8112cd30:	00800304 	movi	r2,12
8112cd34:	a0800015 	stw	r2,0(r20)
8112cd38:	0005883a 	mov	r2,zero
8112cd3c:	003fe506 	br	8112ccd4 <__reset+0xfb10ccd4>
8112cd40:	98c00117 	ldw	r3,4(r19)
8112cd44:	9c4b883a 	add	r5,r19,r17
8112cd48:	11000054 	ori	r4,r2,1
8112cd4c:	18c0004c 	andi	r3,r3,1
8112cd50:	1c62b03a 	or	r17,r3,r17
8112cd54:	9c400115 	stw	r17,4(r19)
8112cd58:	29000115 	stw	r4,4(r5)
8112cd5c:	2885883a 	add	r2,r5,r2
8112cd60:	10c00117 	ldw	r3,4(r2)
8112cd64:	29400204 	addi	r5,r5,8
8112cd68:	a009883a 	mov	r4,r20
8112cd6c:	18c00054 	ori	r3,r3,1
8112cd70:	10c00115 	stw	r3,4(r2)
8112cd74:	112aac80 	call	8112aac8 <_free_r>
8112cd78:	003fd306 	br	8112ccc8 <__reset+0xfb10ccc8>
8112cd7c:	017fff04 	movi	r5,-4
8112cd80:	414a703a 	and	r5,r8,r5
8112cd84:	89800404 	addi	r6,r17,16
8112cd88:	8151883a 	add	r8,r16,r5
8112cd8c:	4180590e 	bge	r8,r6,8112cef4 <_realloc_r+0x398>
8112cd90:	1080004c 	andi	r2,r2,1
8112cd94:	103f9e1e 	bne	r2,zero,8112cc10 <__reset+0xfb10cc10>
8112cd98:	adbffe17 	ldw	r22,-8(r21)
8112cd9c:	00bfff04 	movi	r2,-4
8112cda0:	9dadc83a 	sub	r22,r19,r22
8112cda4:	b1800117 	ldw	r6,4(r22)
8112cda8:	3084703a 	and	r2,r6,r2
8112cdac:	20002026 	beq	r4,zero,8112ce30 <_realloc_r+0x2d4>
8112cdb0:	80af883a 	add	r23,r16,r2
8112cdb4:	b96f883a 	add	r23,r23,r5
8112cdb8:	21c05f26 	beq	r4,r7,8112cf38 <_realloc_r+0x3dc>
8112cdbc:	b8c01c16 	blt	r23,r3,8112ce30 <_realloc_r+0x2d4>
8112cdc0:	20800317 	ldw	r2,12(r4)
8112cdc4:	20c00217 	ldw	r3,8(r4)
8112cdc8:	81bfff04 	addi	r6,r16,-4
8112cdcc:	01000904 	movi	r4,36
8112cdd0:	18800315 	stw	r2,12(r3)
8112cdd4:	10c00215 	stw	r3,8(r2)
8112cdd8:	b0c00217 	ldw	r3,8(r22)
8112cddc:	b0800317 	ldw	r2,12(r22)
8112cde0:	b4800204 	addi	r18,r22,8
8112cde4:	18800315 	stw	r2,12(r3)
8112cde8:	10c00215 	stw	r3,8(r2)
8112cdec:	21801b36 	bltu	r4,r6,8112ce5c <_realloc_r+0x300>
8112cdf0:	008004c4 	movi	r2,19
8112cdf4:	1180352e 	bgeu	r2,r6,8112cecc <_realloc_r+0x370>
8112cdf8:	a8800017 	ldw	r2,0(r21)
8112cdfc:	b0800215 	stw	r2,8(r22)
8112ce00:	a8800117 	ldw	r2,4(r21)
8112ce04:	b0800315 	stw	r2,12(r22)
8112ce08:	008006c4 	movi	r2,27
8112ce0c:	11807f36 	bltu	r2,r6,8112d00c <_realloc_r+0x4b0>
8112ce10:	b0800404 	addi	r2,r22,16
8112ce14:	ad400204 	addi	r21,r21,8
8112ce18:	00002d06 	br	8112ced0 <_realloc_r+0x374>
8112ce1c:	adbffe17 	ldw	r22,-8(r21)
8112ce20:	00bfff04 	movi	r2,-4
8112ce24:	9dadc83a 	sub	r22,r19,r22
8112ce28:	b1000117 	ldw	r4,4(r22)
8112ce2c:	2084703a 	and	r2,r4,r2
8112ce30:	b03f7726 	beq	r22,zero,8112cc10 <__reset+0xfb10cc10>
8112ce34:	80af883a 	add	r23,r16,r2
8112ce38:	b8ff7516 	blt	r23,r3,8112cc10 <__reset+0xfb10cc10>
8112ce3c:	b0800317 	ldw	r2,12(r22)
8112ce40:	b0c00217 	ldw	r3,8(r22)
8112ce44:	81bfff04 	addi	r6,r16,-4
8112ce48:	01000904 	movi	r4,36
8112ce4c:	18800315 	stw	r2,12(r3)
8112ce50:	10c00215 	stw	r3,8(r2)
8112ce54:	b4800204 	addi	r18,r22,8
8112ce58:	21bfe52e 	bgeu	r4,r6,8112cdf0 <__reset+0xfb10cdf0>
8112ce5c:	a80b883a 	mov	r5,r21
8112ce60:	9009883a 	mov	r4,r18
8112ce64:	112b93c0 	call	8112b93c <memmove>
8112ce68:	b821883a 	mov	r16,r23
8112ce6c:	b027883a 	mov	r19,r22
8112ce70:	003f8a06 	br	8112cc9c <__reset+0xfb10cc9c>
8112ce74:	300b883a 	mov	r5,r6
8112ce78:	dfc00917 	ldw	ra,36(sp)
8112ce7c:	df000817 	ldw	fp,32(sp)
8112ce80:	ddc00717 	ldw	r23,28(sp)
8112ce84:	dd800617 	ldw	r22,24(sp)
8112ce88:	dd400517 	ldw	r21,20(sp)
8112ce8c:	dd000417 	ldw	r20,16(sp)
8112ce90:	dcc00317 	ldw	r19,12(sp)
8112ce94:	dc800217 	ldw	r18,8(sp)
8112ce98:	dc400117 	ldw	r17,4(sp)
8112ce9c:	dc000017 	ldw	r16,0(sp)
8112cea0:	dec00a04 	addi	sp,sp,40
8112cea4:	11210541 	jmpi	81121054 <_malloc_r>
8112cea8:	a8c00017 	ldw	r3,0(r21)
8112ceac:	90c00015 	stw	r3,0(r18)
8112ceb0:	a8c00117 	ldw	r3,4(r21)
8112ceb4:	90c00115 	stw	r3,4(r18)
8112ceb8:	00c006c4 	movi	r3,27
8112cebc:	19804536 	bltu	r3,r6,8112cfd4 <_realloc_r+0x478>
8112cec0:	90800204 	addi	r2,r18,8
8112cec4:	a8c00204 	addi	r3,r21,8
8112cec8:	003f6306 	br	8112cc58 <__reset+0xfb10cc58>
8112cecc:	9005883a 	mov	r2,r18
8112ced0:	a8c00017 	ldw	r3,0(r21)
8112ced4:	b821883a 	mov	r16,r23
8112ced8:	b027883a 	mov	r19,r22
8112cedc:	10c00015 	stw	r3,0(r2)
8112cee0:	a8c00117 	ldw	r3,4(r21)
8112cee4:	10c00115 	stw	r3,4(r2)
8112cee8:	a8c00217 	ldw	r3,8(r21)
8112ceec:	10c00215 	stw	r3,8(r2)
8112cef0:	003f6a06 	br	8112cc9c <__reset+0xfb10cc9c>
8112cef4:	9c67883a 	add	r19,r19,r17
8112cef8:	4445c83a 	sub	r2,r8,r17
8112cefc:	e4c00215 	stw	r19,8(fp)
8112cf00:	10800054 	ori	r2,r2,1
8112cf04:	98800115 	stw	r2,4(r19)
8112cf08:	a8bfff17 	ldw	r2,-4(r21)
8112cf0c:	a009883a 	mov	r4,r20
8112cf10:	1080004c 	andi	r2,r2,1
8112cf14:	1462b03a 	or	r17,r2,r17
8112cf18:	ac7fff15 	stw	r17,-4(r21)
8112cf1c:	11373b80 	call	811373b8 <__malloc_unlock>
8112cf20:	a805883a 	mov	r2,r21
8112cf24:	003f6b06 	br	8112ccd4 <__reset+0xfb10ccd4>
8112cf28:	a80b883a 	mov	r5,r21
8112cf2c:	9009883a 	mov	r4,r18
8112cf30:	112b93c0 	call	8112b93c <memmove>
8112cf34:	003f4e06 	br	8112cc70 <__reset+0xfb10cc70>
8112cf38:	89000404 	addi	r4,r17,16
8112cf3c:	b93fbc16 	blt	r23,r4,8112ce30 <__reset+0xfb10ce30>
8112cf40:	b0800317 	ldw	r2,12(r22)
8112cf44:	b0c00217 	ldw	r3,8(r22)
8112cf48:	81bfff04 	addi	r6,r16,-4
8112cf4c:	01000904 	movi	r4,36
8112cf50:	18800315 	stw	r2,12(r3)
8112cf54:	10c00215 	stw	r3,8(r2)
8112cf58:	b4800204 	addi	r18,r22,8
8112cf5c:	21804336 	bltu	r4,r6,8112d06c <_realloc_r+0x510>
8112cf60:	008004c4 	movi	r2,19
8112cf64:	11803f2e 	bgeu	r2,r6,8112d064 <_realloc_r+0x508>
8112cf68:	a8800017 	ldw	r2,0(r21)
8112cf6c:	b0800215 	stw	r2,8(r22)
8112cf70:	a8800117 	ldw	r2,4(r21)
8112cf74:	b0800315 	stw	r2,12(r22)
8112cf78:	008006c4 	movi	r2,27
8112cf7c:	11803f36 	bltu	r2,r6,8112d07c <_realloc_r+0x520>
8112cf80:	b0800404 	addi	r2,r22,16
8112cf84:	ad400204 	addi	r21,r21,8
8112cf88:	a8c00017 	ldw	r3,0(r21)
8112cf8c:	10c00015 	stw	r3,0(r2)
8112cf90:	a8c00117 	ldw	r3,4(r21)
8112cf94:	10c00115 	stw	r3,4(r2)
8112cf98:	a8c00217 	ldw	r3,8(r21)
8112cf9c:	10c00215 	stw	r3,8(r2)
8112cfa0:	b447883a 	add	r3,r22,r17
8112cfa4:	bc45c83a 	sub	r2,r23,r17
8112cfa8:	e0c00215 	stw	r3,8(fp)
8112cfac:	10800054 	ori	r2,r2,1
8112cfb0:	18800115 	stw	r2,4(r3)
8112cfb4:	b0800117 	ldw	r2,4(r22)
8112cfb8:	a009883a 	mov	r4,r20
8112cfbc:	1080004c 	andi	r2,r2,1
8112cfc0:	1462b03a 	or	r17,r2,r17
8112cfc4:	b4400115 	stw	r17,4(r22)
8112cfc8:	11373b80 	call	811373b8 <__malloc_unlock>
8112cfcc:	9005883a 	mov	r2,r18
8112cfd0:	003f4006 	br	8112ccd4 <__reset+0xfb10ccd4>
8112cfd4:	a8c00217 	ldw	r3,8(r21)
8112cfd8:	90c00215 	stw	r3,8(r18)
8112cfdc:	a8c00317 	ldw	r3,12(r21)
8112cfe0:	90c00315 	stw	r3,12(r18)
8112cfe4:	30801126 	beq	r6,r2,8112d02c <_realloc_r+0x4d0>
8112cfe8:	90800404 	addi	r2,r18,16
8112cfec:	a8c00404 	addi	r3,r21,16
8112cff0:	003f1906 	br	8112cc58 <__reset+0xfb10cc58>
8112cff4:	90ffff17 	ldw	r3,-4(r18)
8112cff8:	00bfff04 	movi	r2,-4
8112cffc:	a825883a 	mov	r18,r21
8112d000:	1884703a 	and	r2,r3,r2
8112d004:	80a1883a 	add	r16,r16,r2
8112d008:	003f2406 	br	8112cc9c <__reset+0xfb10cc9c>
8112d00c:	a8800217 	ldw	r2,8(r21)
8112d010:	b0800415 	stw	r2,16(r22)
8112d014:	a8800317 	ldw	r2,12(r21)
8112d018:	b0800515 	stw	r2,20(r22)
8112d01c:	31000a26 	beq	r6,r4,8112d048 <_realloc_r+0x4ec>
8112d020:	b0800604 	addi	r2,r22,24
8112d024:	ad400404 	addi	r21,r21,16
8112d028:	003fa906 	br	8112ced0 <__reset+0xfb10ced0>
8112d02c:	a9000417 	ldw	r4,16(r21)
8112d030:	90800604 	addi	r2,r18,24
8112d034:	a8c00604 	addi	r3,r21,24
8112d038:	91000415 	stw	r4,16(r18)
8112d03c:	a9000517 	ldw	r4,20(r21)
8112d040:	91000515 	stw	r4,20(r18)
8112d044:	003f0406 	br	8112cc58 <__reset+0xfb10cc58>
8112d048:	a8c00417 	ldw	r3,16(r21)
8112d04c:	ad400604 	addi	r21,r21,24
8112d050:	b0800804 	addi	r2,r22,32
8112d054:	b0c00615 	stw	r3,24(r22)
8112d058:	a8ffff17 	ldw	r3,-4(r21)
8112d05c:	b0c00715 	stw	r3,28(r22)
8112d060:	003f9b06 	br	8112ced0 <__reset+0xfb10ced0>
8112d064:	9005883a 	mov	r2,r18
8112d068:	003fc706 	br	8112cf88 <__reset+0xfb10cf88>
8112d06c:	a80b883a 	mov	r5,r21
8112d070:	9009883a 	mov	r4,r18
8112d074:	112b93c0 	call	8112b93c <memmove>
8112d078:	003fc906 	br	8112cfa0 <__reset+0xfb10cfa0>
8112d07c:	a8800217 	ldw	r2,8(r21)
8112d080:	b0800415 	stw	r2,16(r22)
8112d084:	a8800317 	ldw	r2,12(r21)
8112d088:	b0800515 	stw	r2,20(r22)
8112d08c:	31000726 	beq	r6,r4,8112d0ac <_realloc_r+0x550>
8112d090:	b0800604 	addi	r2,r22,24
8112d094:	ad400404 	addi	r21,r21,16
8112d098:	003fbb06 	br	8112cf88 <__reset+0xfb10cf88>
8112d09c:	a009883a 	mov	r4,r20
8112d0a0:	11373b80 	call	811373b8 <__malloc_unlock>
8112d0a4:	0005883a 	mov	r2,zero
8112d0a8:	003f0a06 	br	8112ccd4 <__reset+0xfb10ccd4>
8112d0ac:	a8c00417 	ldw	r3,16(r21)
8112d0b0:	ad400604 	addi	r21,r21,24
8112d0b4:	b0800804 	addi	r2,r22,32
8112d0b8:	b0c00615 	stw	r3,24(r22)
8112d0bc:	a8ffff17 	ldw	r3,-4(r21)
8112d0c0:	b0c00715 	stw	r3,28(r22)
8112d0c4:	003fb006 	br	8112cf88 <__reset+0xfb10cf88>

8112d0c8 <__fpclassifyd>:
8112d0c8:	00a00034 	movhi	r2,32768
8112d0cc:	10bfffc4 	addi	r2,r2,-1
8112d0d0:	2884703a 	and	r2,r5,r2
8112d0d4:	10000726 	beq	r2,zero,8112d0f4 <__fpclassifyd+0x2c>
8112d0d8:	00fffc34 	movhi	r3,65520
8112d0dc:	019ff834 	movhi	r6,32736
8112d0e0:	28c7883a 	add	r3,r5,r3
8112d0e4:	31bfffc4 	addi	r6,r6,-1
8112d0e8:	30c00536 	bltu	r6,r3,8112d100 <__fpclassifyd+0x38>
8112d0ec:	00800104 	movi	r2,4
8112d0f0:	f800283a 	ret
8112d0f4:	2000021e 	bne	r4,zero,8112d100 <__fpclassifyd+0x38>
8112d0f8:	00800084 	movi	r2,2
8112d0fc:	f800283a 	ret
8112d100:	00dffc34 	movhi	r3,32752
8112d104:	019ff834 	movhi	r6,32736
8112d108:	28cb883a 	add	r5,r5,r3
8112d10c:	31bfffc4 	addi	r6,r6,-1
8112d110:	317ff62e 	bgeu	r6,r5,8112d0ec <__reset+0xfb10d0ec>
8112d114:	01400434 	movhi	r5,16
8112d118:	297fffc4 	addi	r5,r5,-1
8112d11c:	28800236 	bltu	r5,r2,8112d128 <__fpclassifyd+0x60>
8112d120:	008000c4 	movi	r2,3
8112d124:	f800283a 	ret
8112d128:	10c00226 	beq	r2,r3,8112d134 <__fpclassifyd+0x6c>
8112d12c:	0005883a 	mov	r2,zero
8112d130:	f800283a 	ret
8112d134:	2005003a 	cmpeq	r2,r4,zero
8112d138:	f800283a 	ret

8112d13c <__sccl>:
8112d13c:	2a000003 	ldbu	r8,0(r5)
8112d140:	00801784 	movi	r2,94
8112d144:	40802a26 	beq	r8,r2,8112d1f0 <__sccl+0xb4>
8112d148:	29400044 	addi	r5,r5,1
8112d14c:	000f883a 	mov	r7,zero
8112d150:	0013883a 	mov	r9,zero
8112d154:	2007883a 	mov	r3,r4
8112d158:	21804004 	addi	r6,r4,256
8112d15c:	19c00005 	stb	r7,0(r3)
8112d160:	18c00044 	addi	r3,r3,1
8112d164:	19bffd1e 	bne	r3,r6,8112d15c <__reset+0xfb10d15c>
8112d168:	40001126 	beq	r8,zero,8112d1b0 <__sccl+0x74>
8112d16c:	00800044 	movi	r2,1
8112d170:	124fc83a 	sub	r7,r2,r9
8112d174:	02800b44 	movi	r10,45
8112d178:	02c01744 	movi	r11,93
8112d17c:	2205883a 	add	r2,r4,r8
8112d180:	11c00005 	stb	r7,0(r2)
8112d184:	28800044 	addi	r2,r5,1
8112d188:	28c00003 	ldbu	r3,0(r5)
8112d18c:	1a800a26 	beq	r3,r10,8112d1b8 <__sccl+0x7c>
8112d190:	1ac00426 	beq	r3,r11,8112d1a4 <__sccl+0x68>
8112d194:	18000426 	beq	r3,zero,8112d1a8 <__sccl+0x6c>
8112d198:	1811883a 	mov	r8,r3
8112d19c:	100b883a 	mov	r5,r2
8112d1a0:	003ff606 	br	8112d17c <__reset+0xfb10d17c>
8112d1a4:	f800283a 	ret
8112d1a8:	2805883a 	mov	r2,r5
8112d1ac:	f800283a 	ret
8112d1b0:	28bfffc4 	addi	r2,r5,-1
8112d1b4:	f800283a 	ret
8112d1b8:	12400003 	ldbu	r9,0(r2)
8112d1bc:	4ac01126 	beq	r9,r11,8112d204 <__sccl+0xc8>
8112d1c0:	4a001016 	blt	r9,r8,8112d204 <__sccl+0xc8>
8112d1c4:	41800044 	addi	r6,r8,1
8112d1c8:	29400084 	addi	r5,r5,2
8112d1cc:	2187883a 	add	r3,r4,r6
8112d1d0:	00000106 	br	8112d1d8 <__sccl+0x9c>
8112d1d4:	31800044 	addi	r6,r6,1
8112d1d8:	19c00005 	stb	r7,0(r3)
8112d1dc:	3011883a 	mov	r8,r6
8112d1e0:	18c00044 	addi	r3,r3,1
8112d1e4:	327ffb16 	blt	r6,r9,8112d1d4 <__reset+0xfb10d1d4>
8112d1e8:	10800084 	addi	r2,r2,2
8112d1ec:	003fe606 	br	8112d188 <__reset+0xfb10d188>
8112d1f0:	2a000043 	ldbu	r8,1(r5)
8112d1f4:	01c00044 	movi	r7,1
8112d1f8:	29400084 	addi	r5,r5,2
8112d1fc:	02400044 	movi	r9,1
8112d200:	003fd406 	br	8112d154 <__reset+0xfb10d154>
8112d204:	5011883a 	mov	r8,r10
8112d208:	003fe406 	br	8112d19c <__reset+0xfb10d19c>

8112d20c <nanf>:
8112d20c:	009ff034 	movhi	r2,32704
8112d210:	f800283a 	ret

8112d214 <strcmp>:
8112d214:	2144b03a 	or	r2,r4,r5
8112d218:	108000cc 	andi	r2,r2,3
8112d21c:	1000171e 	bne	r2,zero,8112d27c <strcmp+0x68>
8112d220:	20800017 	ldw	r2,0(r4)
8112d224:	28c00017 	ldw	r3,0(r5)
8112d228:	10c0141e 	bne	r2,r3,8112d27c <strcmp+0x68>
8112d22c:	027fbff4 	movhi	r9,65279
8112d230:	4a7fbfc4 	addi	r9,r9,-257
8112d234:	0086303a 	nor	r3,zero,r2
8112d238:	02202074 	movhi	r8,32897
8112d23c:	1245883a 	add	r2,r2,r9
8112d240:	42202004 	addi	r8,r8,-32640
8112d244:	10c4703a 	and	r2,r2,r3
8112d248:	1204703a 	and	r2,r2,r8
8112d24c:	10000226 	beq	r2,zero,8112d258 <strcmp+0x44>
8112d250:	00002306 	br	8112d2e0 <strcmp+0xcc>
8112d254:	1000221e 	bne	r2,zero,8112d2e0 <strcmp+0xcc>
8112d258:	21000104 	addi	r4,r4,4
8112d25c:	20c00017 	ldw	r3,0(r4)
8112d260:	29400104 	addi	r5,r5,4
8112d264:	29800017 	ldw	r6,0(r5)
8112d268:	1a4f883a 	add	r7,r3,r9
8112d26c:	00c4303a 	nor	r2,zero,r3
8112d270:	3884703a 	and	r2,r7,r2
8112d274:	1204703a 	and	r2,r2,r8
8112d278:	19bff626 	beq	r3,r6,8112d254 <__reset+0xfb10d254>
8112d27c:	20800003 	ldbu	r2,0(r4)
8112d280:	10c03fcc 	andi	r3,r2,255
8112d284:	18c0201c 	xori	r3,r3,128
8112d288:	18ffe004 	addi	r3,r3,-128
8112d28c:	18000c26 	beq	r3,zero,8112d2c0 <strcmp+0xac>
8112d290:	29800007 	ldb	r6,0(r5)
8112d294:	19800326 	beq	r3,r6,8112d2a4 <strcmp+0x90>
8112d298:	00001306 	br	8112d2e8 <strcmp+0xd4>
8112d29c:	29800007 	ldb	r6,0(r5)
8112d2a0:	11800b1e 	bne	r2,r6,8112d2d0 <strcmp+0xbc>
8112d2a4:	21000044 	addi	r4,r4,1
8112d2a8:	20c00003 	ldbu	r3,0(r4)
8112d2ac:	29400044 	addi	r5,r5,1
8112d2b0:	18803fcc 	andi	r2,r3,255
8112d2b4:	1080201c 	xori	r2,r2,128
8112d2b8:	10bfe004 	addi	r2,r2,-128
8112d2bc:	103ff71e 	bne	r2,zero,8112d29c <__reset+0xfb10d29c>
8112d2c0:	0007883a 	mov	r3,zero
8112d2c4:	28800003 	ldbu	r2,0(r5)
8112d2c8:	1885c83a 	sub	r2,r3,r2
8112d2cc:	f800283a 	ret
8112d2d0:	28800003 	ldbu	r2,0(r5)
8112d2d4:	18c03fcc 	andi	r3,r3,255
8112d2d8:	1885c83a 	sub	r2,r3,r2
8112d2dc:	f800283a 	ret
8112d2e0:	0005883a 	mov	r2,zero
8112d2e4:	f800283a 	ret
8112d2e8:	10c03fcc 	andi	r3,r2,255
8112d2ec:	003ff506 	br	8112d2c4 <__reset+0xfb10d2c4>

8112d2f0 <sulp>:
8112d2f0:	defffd04 	addi	sp,sp,-12
8112d2f4:	de00012e 	bgeu	sp,et,8112d2fc <sulp+0xc>
8112d2f8:	003b68fa 	trap	3
8112d2fc:	dc400115 	stw	r17,4(sp)
8112d300:	3023883a 	mov	r17,r6
8112d304:	dc000015 	stw	r16,0(sp)
8112d308:	dfc00215 	stw	ra,8(sp)
8112d30c:	2821883a 	mov	r16,r5
8112d310:	112c5fc0 	call	8112c5fc <__ulp>
8112d314:	88000c26 	beq	r17,zero,8112d348 <sulp+0x58>
8112d318:	841ffc2c 	andhi	r16,r16,32752
8112d31c:	8020d53a 	srli	r16,r16,20
8112d320:	01c01ac4 	movi	r7,107
8112d324:	3c21c83a 	sub	r16,r7,r16
8112d328:	0400070e 	bge	zero,r16,8112d348 <sulp+0x58>
8112d32c:	8020953a 	slli	r16,r16,20
8112d330:	01cffc34 	movhi	r7,16368
8112d334:	000d883a 	mov	r6,zero
8112d338:	81cf883a 	add	r7,r16,r7
8112d33c:	1009883a 	mov	r4,r2
8112d340:	180b883a 	mov	r5,r3
8112d344:	111f1b00 	call	8111f1b0 <__muldf3>
8112d348:	dfc00217 	ldw	ra,8(sp)
8112d34c:	dc400117 	ldw	r17,4(sp)
8112d350:	dc000017 	ldw	r16,0(sp)
8112d354:	dec00304 	addi	sp,sp,12
8112d358:	f800283a 	ret

8112d35c <_strtod_r>:
8112d35c:	deffe204 	addi	sp,sp,-120
8112d360:	de00012e 	bgeu	sp,et,8112d368 <_strtod_r+0xc>
8112d364:	003b68fa 	trap	3
8112d368:	ddc01b15 	stw	r23,108(sp)
8112d36c:	dd001815 	stw	r20,96(sp)
8112d370:	dc801615 	stw	r18,88(sp)
8112d374:	dc401515 	stw	r17,84(sp)
8112d378:	dc001415 	stw	r16,80(sp)
8112d37c:	d9400615 	stw	r5,24(sp)
8112d380:	dfc01d15 	stw	ra,116(sp)
8112d384:	df001c15 	stw	fp,112(sp)
8112d388:	dd801a15 	stw	r22,104(sp)
8112d38c:	dd401915 	stw	r21,100(sp)
8112d390:	dcc01715 	stw	r19,92(sp)
8112d394:	2021883a 	mov	r16,r4
8112d398:	d8000515 	stw	zero,20(sp)
8112d39c:	2809883a 	mov	r4,r5
8112d3a0:	20800003 	ldbu	r2,0(r4)
8112d3a4:	01e044f4 	movhi	r7,33043
8112d3a8:	282f883a 	mov	r23,r5
8112d3ac:	10c03fcc 	andi	r3,r2,255
8112d3b0:	01400b44 	movi	r5,45
8112d3b4:	39f4f604 	addi	r7,r7,-11304
8112d3b8:	3029883a 	mov	r20,r6
8112d3bc:	0025883a 	mov	r18,zero
8112d3c0:	0023883a 	mov	r17,zero
8112d3c4:	28c0ba36 	bltu	r5,r3,8112d6b0 <_strtod_r+0x354>
8112d3c8:	180690ba 	slli	r3,r3,2
8112d3cc:	19c7883a 	add	r3,r3,r7
8112d3d0:	18c00017 	ldw	r3,0(r3)
8112d3d4:	1800683a 	jmp	r3
8112d3d8:	8112d498 	cmpnei	r4,r16,19282
8112d3dc:	8112d6b0 	cmpltui	r4,r16,19290
8112d3e0:	8112d6b0 	cmpltui	r4,r16,19290
8112d3e4:	8112d6b0 	cmpltui	r4,r16,19290
8112d3e8:	8112d6b0 	cmpltui	r4,r16,19290
8112d3ec:	8112d6b0 	cmpltui	r4,r16,19290
8112d3f0:	8112d6b0 	cmpltui	r4,r16,19290
8112d3f4:	8112d6b0 	cmpltui	r4,r16,19290
8112d3f8:	8112d6b0 	cmpltui	r4,r16,19290
8112d3fc:	8112d69c 	xori	r4,r16,19290
8112d400:	8112d69c 	xori	r4,r16,19290
8112d404:	8112d69c 	xori	r4,r16,19290
8112d408:	8112d69c 	xori	r4,r16,19290
8112d40c:	8112d69c 	xori	r4,r16,19290
8112d410:	8112d6b0 	cmpltui	r4,r16,19290
8112d414:	8112d6b0 	cmpltui	r4,r16,19290
8112d418:	8112d6b0 	cmpltui	r4,r16,19290
8112d41c:	8112d6b0 	cmpltui	r4,r16,19290
8112d420:	8112d6b0 	cmpltui	r4,r16,19290
8112d424:	8112d6b0 	cmpltui	r4,r16,19290
8112d428:	8112d6b0 	cmpltui	r4,r16,19290
8112d42c:	8112d6b0 	cmpltui	r4,r16,19290
8112d430:	8112d6b0 	cmpltui	r4,r16,19290
8112d434:	8112d6b0 	cmpltui	r4,r16,19290
8112d438:	8112d6b0 	cmpltui	r4,r16,19290
8112d43c:	8112d6b0 	cmpltui	r4,r16,19290
8112d440:	8112d6b0 	cmpltui	r4,r16,19290
8112d444:	8112d6b0 	cmpltui	r4,r16,19290
8112d448:	8112d6b0 	cmpltui	r4,r16,19290
8112d44c:	8112d6b0 	cmpltui	r4,r16,19290
8112d450:	8112d6b0 	cmpltui	r4,r16,19290
8112d454:	8112d6b0 	cmpltui	r4,r16,19290
8112d458:	8112d69c 	xori	r4,r16,19290
8112d45c:	8112d6b0 	cmpltui	r4,r16,19290
8112d460:	8112d6b0 	cmpltui	r4,r16,19290
8112d464:	8112d6b0 	cmpltui	r4,r16,19290
8112d468:	8112d6b0 	cmpltui	r4,r16,19290
8112d46c:	8112d6b0 	cmpltui	r4,r16,19290
8112d470:	8112d6b0 	cmpltui	r4,r16,19290
8112d474:	8112d6b0 	cmpltui	r4,r16,19290
8112d478:	8112d6b0 	cmpltui	r4,r16,19290
8112d47c:	8112d6b0 	cmpltui	r4,r16,19290
8112d480:	8112d6b0 	cmpltui	r4,r16,19290
8112d484:	8112d4f0 	cmpltui	r4,r16,19283
8112d488:	8112d6b0 	cmpltui	r4,r16,19290
8112d48c:	8112d690 	cmplti	r4,r16,19290
8112d490:	00801244 	movi	r2,73
8112d494:	88843526 	beq	r17,r2,8112e56c <_strtod_r+0x1210>
8112d498:	002b883a 	mov	r21,zero
8112d49c:	002d883a 	mov	r22,zero
8112d4a0:	a0000526 	beq	r20,zero,8112d4b8 <_strtod_r+0x15c>
8112d4a4:	d8000715 	stw	zero,28(sp)
8112d4a8:	a5c00015 	stw	r23,0(r20)
8112d4ac:	d9000717 	ldw	r4,28(sp)
8112d4b0:	20000126 	beq	r4,zero,8112d4b8 <_strtod_r+0x15c>
8112d4b4:	b5a0003c 	xorhi	r22,r22,32768
8112d4b8:	a805883a 	mov	r2,r21
8112d4bc:	b007883a 	mov	r3,r22
8112d4c0:	dfc01d17 	ldw	ra,116(sp)
8112d4c4:	df001c17 	ldw	fp,112(sp)
8112d4c8:	ddc01b17 	ldw	r23,108(sp)
8112d4cc:	dd801a17 	ldw	r22,104(sp)
8112d4d0:	dd401917 	ldw	r21,100(sp)
8112d4d4:	dd001817 	ldw	r20,96(sp)
8112d4d8:	dcc01717 	ldw	r19,92(sp)
8112d4dc:	dc801617 	ldw	r18,88(sp)
8112d4e0:	dc401517 	ldw	r17,84(sp)
8112d4e4:	dc001417 	ldw	r16,80(sp)
8112d4e8:	dec01e04 	addi	sp,sp,120
8112d4ec:	f800283a 	ret
8112d4f0:	d8000715 	stw	zero,28(sp)
8112d4f4:	24c00044 	addi	r19,r4,1
8112d4f8:	dcc00615 	stw	r19,24(sp)
8112d4fc:	20800043 	ldbu	r2,1(r4)
8112d500:	10c03fcc 	andi	r3,r2,255
8112d504:	18c0201c 	xori	r3,r3,128
8112d508:	18ffe004 	addi	r3,r3,-128
8112d50c:	183fe226 	beq	r3,zero,8112d498 <__reset+0xfb10d498>
8112d510:	11403fcc 	andi	r5,r2,255
8112d514:	2940201c 	xori	r5,r5,128
8112d518:	297fe004 	addi	r5,r5,-128
8112d51c:	00c00c04 	movi	r3,48
8112d520:	28c0e526 	beq	r5,r3,8112d8b8 <_strtod_r+0x55c>
8112d524:	dcc00815 	stw	r19,32(sp)
8112d528:	0025883a 	mov	r18,zero
8112d52c:	10fff404 	addi	r3,r2,-48
8112d530:	18c03fcc 	andi	r3,r3,255
8112d534:	01000244 	movi	r4,9
8112d538:	20c37536 	bltu	r4,r3,8112e310 <_strtod_r+0xfb4>
8112d53c:	dd400817 	ldw	r21,32(sp)
8112d540:	0027883a 	mov	r19,zero
8112d544:	0039883a 	mov	fp,zero
8112d548:	002d883a 	mov	r22,zero
8112d54c:	01400204 	movi	r5,8
8112d550:	2d805a16 	blt	r5,r22,8112d6bc <_strtod_r+0x360>
8112d554:	e70002a4 	muli	fp,fp,10
8112d558:	10c03fcc 	andi	r3,r2,255
8112d55c:	18c0201c 	xori	r3,r3,128
8112d560:	18ffe004 	addi	r3,r3,-128
8112d564:	e0f9883a 	add	fp,fp,r3
8112d568:	e73ff404 	addi	fp,fp,-48
8112d56c:	ad400044 	addi	r21,r21,1
8112d570:	dd400615 	stw	r21,24(sp)
8112d574:	a8800003 	ldbu	r2,0(r21)
8112d578:	b5800044 	addi	r22,r22,1
8112d57c:	10fff404 	addi	r3,r2,-48
8112d580:	18c03fcc 	andi	r3,r3,255
8112d584:	20fff22e 	bgeu	r4,r3,8112d550 <__reset+0xfb10d550>
8112d588:	14403fcc 	andi	r17,r2,255
8112d58c:	8c40201c 	xori	r17,r17,128
8112d590:	8c7fe004 	addi	r17,r17,-128
8112d594:	8009883a 	mov	r4,r16
8112d598:	112b57c0 	call	8112b57c <_localeconv_r>
8112d59c:	11400017 	ldw	r5,0(r2)
8112d5a0:	8009883a 	mov	r4,r16
8112d5a4:	d9401315 	stw	r5,76(sp)
8112d5a8:	112b57c0 	call	8112b57c <_localeconv_r>
8112d5ac:	11000017 	ldw	r4,0(r2)
8112d5b0:	112235c0 	call	8112235c <strlen>
8112d5b4:	d9401317 	ldw	r5,76(sp)
8112d5b8:	100d883a 	mov	r6,r2
8112d5bc:	a809883a 	mov	r4,r21
8112d5c0:	1132f4c0 	call	81132f4c <strncmp>
8112d5c4:	1000ce26 	beq	r2,zero,8112d900 <_strtod_r+0x5a4>
8112d5c8:	b013883a 	mov	r9,r22
8112d5cc:	000b883a 	mov	r5,zero
8112d5d0:	0015883a 	mov	r10,zero
8112d5d4:	0017883a 	mov	r11,zero
8112d5d8:	00801944 	movi	r2,101
8112d5dc:	88807826 	beq	r17,r2,8112d7c0 <_strtod_r+0x464>
8112d5e0:	00801144 	movi	r2,69
8112d5e4:	88807626 	beq	r17,r2,8112d7c0 <_strtod_r+0x464>
8112d5e8:	002b883a 	mov	r21,zero
8112d5ec:	48003d1e 	bne	r9,zero,8112d6e4 <_strtod_r+0x388>
8112d5f0:	2800391e 	bne	r5,zero,8112d6d8 <_strtod_r+0x37c>
8112d5f4:	9000381e 	bne	r18,zero,8112d6d8 <_strtod_r+0x37c>
8112d5f8:	583fa71e 	bne	r11,zero,8112d498 <__reset+0xfb10d498>
8112d5fc:	00801384 	movi	r2,78
8112d600:	88800526 	beq	r17,r2,8112d618 <_strtod_r+0x2bc>
8112d604:	147fa20e 	bge	r2,r17,8112d490 <__reset+0xfb10d490>
8112d608:	00801a44 	movi	r2,105
8112d60c:	8883d726 	beq	r17,r2,8112e56c <_strtod_r+0x1210>
8112d610:	00801b84 	movi	r2,110
8112d614:	88bfa01e 	bne	r17,r2,8112d498 <__reset+0xfb10d498>
8112d618:	01604574 	movhi	r5,33045
8112d61c:	d9000617 	ldw	r4,24(sp)
8112d620:	297f0f04 	addi	r5,r5,-964
8112d624:	01c00644 	movi	r7,25
8112d628:	00000b06 	br	8112d658 <_strtod_r+0x2fc>
8112d62c:	21000044 	addi	r4,r4,1
8112d630:	20800003 	ldbu	r2,0(r4)
8112d634:	10ffefc4 	addi	r3,r2,-65
8112d638:	10803fcc 	andi	r2,r2,255
8112d63c:	1080201c 	xori	r2,r2,128
8112d640:	18c03fcc 	andi	r3,r3,255
8112d644:	10bfe004 	addi	r2,r2,-128
8112d648:	38c00136 	bltu	r7,r3,8112d650 <_strtod_r+0x2f4>
8112d64c:	10800804 	addi	r2,r2,32
8112d650:	29400044 	addi	r5,r5,1
8112d654:	11bf901e 	bne	r2,r6,8112d498 <__reset+0xfb10d498>
8112d658:	29800007 	ldb	r6,0(r5)
8112d65c:	303ff31e 	bne	r6,zero,8112d62c <__reset+0xfb10d62c>
8112d660:	20800044 	addi	r2,r4,1
8112d664:	d8800615 	stw	r2,24(sp)
8112d668:	20c00047 	ldb	r3,1(r4)
8112d66c:	00800a04 	movi	r2,40
8112d670:	18849d26 	beq	r3,r2,8112e8e8 <_strtod_r+0x158c>
8112d674:	047ffe34 	movhi	r17,65528
8112d678:	0025883a 	mov	r18,zero
8112d67c:	902b883a 	mov	r21,r18
8112d680:	882d883a 	mov	r22,r17
8112d684:	a03f8926 	beq	r20,zero,8112d4ac <__reset+0xfb10d4ac>
8112d688:	ddc00617 	ldw	r23,24(sp)
8112d68c:	003f8606 	br	8112d4a8 <__reset+0xfb10d4a8>
8112d690:	00800044 	movi	r2,1
8112d694:	d8800715 	stw	r2,28(sp)
8112d698:	003f9606 	br	8112d4f4 <__reset+0xfb10d4f4>
8112d69c:	21000044 	addi	r4,r4,1
8112d6a0:	d9000615 	stw	r4,24(sp)
8112d6a4:	20800003 	ldbu	r2,0(r4)
8112d6a8:	10c03fcc 	andi	r3,r2,255
8112d6ac:	28ff462e 	bgeu	r5,r3,8112d3c8 <__reset+0xfb10d3c8>
8112d6b0:	2027883a 	mov	r19,r4
8112d6b4:	d8000715 	stw	zero,28(sp)
8112d6b8:	003f9506 	br	8112d510 <__reset+0xfb10d510>
8112d6bc:	9cc002a4 	muli	r19,r19,10
8112d6c0:	10803fcc 	andi	r2,r2,255
8112d6c4:	1080201c 	xori	r2,r2,128
8112d6c8:	10bfe004 	addi	r2,r2,-128
8112d6cc:	9885883a 	add	r2,r19,r2
8112d6d0:	14fff404 	addi	r19,r2,-48
8112d6d4:	003fa506 	br	8112d56c <__reset+0xfb10d56c>
8112d6d8:	002b883a 	mov	r21,zero
8112d6dc:	002d883a 	mov	r22,zero
8112d6e0:	003fe806 	br	8112d684 <__reset+0xfb10d684>
8112d6e4:	aaabc83a 	sub	r21,r21,r10
8112d6e8:	b000011e 	bne	r22,zero,8112d6f0 <_strtod_r+0x394>
8112d6ec:	482d883a 	mov	r22,r9
8112d6f0:	00800404 	movi	r2,16
8112d6f4:	482f883a 	mov	r23,r9
8112d6f8:	1240010e 	bge	r2,r9,8112d700 <_strtod_r+0x3a4>
8112d6fc:	102f883a 	mov	r23,r2
8112d700:	e009883a 	mov	r4,fp
8112d704:	da401315 	stw	r9,76(sp)
8112d708:	11353ac0 	call	811353ac <__floatunsidf>
8112d70c:	1025883a 	mov	r18,r2
8112d710:	00800244 	movi	r2,9
8112d714:	1823883a 	mov	r17,r3
8112d718:	da401317 	ldw	r9,76(sp)
8112d71c:	15c0160e 	bge	r2,r23,8112d778 <_strtod_r+0x41c>
8112d720:	b8bffdc4 	addi	r2,r23,-9
8112d724:	100490fa 	slli	r2,r2,3
8112d728:	180b883a 	mov	r5,r3
8112d72c:	00e04574 	movhi	r3,33045
8112d730:	18feda04 	addi	r3,r3,-1176
8112d734:	1885883a 	add	r2,r3,r2
8112d738:	11800017 	ldw	r6,0(r2)
8112d73c:	11c00117 	ldw	r7,4(r2)
8112d740:	9009883a 	mov	r4,r18
8112d744:	111f1b00 	call	8111f1b0 <__muldf3>
8112d748:	9809883a 	mov	r4,r19
8112d74c:	1025883a 	mov	r18,r2
8112d750:	1823883a 	mov	r17,r3
8112d754:	11353ac0 	call	811353ac <__floatunsidf>
8112d758:	9009883a 	mov	r4,r18
8112d75c:	880b883a 	mov	r5,r17
8112d760:	100d883a 	mov	r6,r2
8112d764:	180f883a 	mov	r7,r3
8112d768:	113408c0 	call	8113408c <__adddf3>
8112d76c:	da401317 	ldw	r9,76(sp)
8112d770:	1025883a 	mov	r18,r2
8112d774:	1823883a 	mov	r17,r3
8112d778:	008003c4 	movi	r2,15
8112d77c:	12407b16 	blt	r2,r9,8112d96c <_strtod_r+0x610>
8112d780:	a83fbe26 	beq	r21,zero,8112d67c <__reset+0xfb10d67c>
8112d784:	0543670e 	bge	zero,r21,8112e524 <_strtod_r+0x11c8>
8112d788:	00c00584 	movi	r3,22
8112d78c:	1d42e816 	blt	r3,r21,8112e330 <_strtod_r+0xfd4>
8112d790:	a82a90fa 	slli	r21,r21,3
8112d794:	00a04574 	movhi	r2,33045
8112d798:	10beda04 	addi	r2,r2,-1176
8112d79c:	1545883a 	add	r2,r2,r21
8112d7a0:	11000017 	ldw	r4,0(r2)
8112d7a4:	11400117 	ldw	r5,4(r2)
8112d7a8:	900d883a 	mov	r6,r18
8112d7ac:	880f883a 	mov	r7,r17
8112d7b0:	111f1b00 	call	8111f1b0 <__muldf3>
8112d7b4:	102b883a 	mov	r21,r2
8112d7b8:	182d883a 	mov	r22,r3
8112d7bc:	003fb106 	br	8112d684 <__reset+0xfb10d684>
8112d7c0:	4801b526 	beq	r9,zero,8112de98 <_strtod_r+0xb3c>
8112d7c4:	ddc00617 	ldw	r23,24(sp)
8112d7c8:	00c00ac4 	movi	r3,43
8112d7cc:	b8800044 	addi	r2,r23,1
8112d7d0:	d8800615 	stw	r2,24(sp)
8112d7d4:	b8800047 	ldb	r2,1(r23)
8112d7d8:	10c1e926 	beq	r2,r3,8112df80 <_strtod_r+0xc24>
8112d7dc:	00c00b44 	movi	r3,45
8112d7e0:	10c1ec26 	beq	r2,r3,8112df94 <_strtod_r+0xc38>
8112d7e4:	1023883a 	mov	r17,r2
8112d7e8:	0019883a 	mov	r12,zero
8112d7ec:	88bff404 	addi	r2,r17,-48
8112d7f0:	00c00244 	movi	r3,9
8112d7f4:	1881b736 	bltu	r3,r2,8112ded4 <_strtod_r+0xb78>
8112d7f8:	00800c04 	movi	r2,48
8112d7fc:	8880071e 	bne	r17,r2,8112d81c <_strtod_r+0x4c0>
8112d800:	d8800617 	ldw	r2,24(sp)
8112d804:	8807883a 	mov	r3,r17
8112d808:	10800044 	addi	r2,r2,1
8112d80c:	d8800615 	stw	r2,24(sp)
8112d810:	14400007 	ldb	r17,0(r2)
8112d814:	10800044 	addi	r2,r2,1
8112d818:	88fffc26 	beq	r17,r3,8112d80c <__reset+0xfb10d80c>
8112d81c:	88bff3c4 	addi	r2,r17,-49
8112d820:	00c00204 	movi	r3,8
8112d824:	18bf7036 	bltu	r3,r2,8112d5e8 <__reset+0xfb10d5e8>
8112d828:	db800617 	ldw	r14,24(sp)
8112d82c:	88bff404 	addi	r2,r17,-48
8112d830:	03400244 	movi	r13,9
8112d834:	71c00044 	addi	r7,r14,1
8112d838:	d9c00615 	stw	r7,24(sp)
8112d83c:	74400043 	ldbu	r17,1(r14)
8112d840:	88fff404 	addi	r3,r17,-48
8112d844:	8c403fcc 	andi	r17,r17,255
8112d848:	8c40201c 	xori	r17,r17,128
8112d84c:	18c03fcc 	andi	r3,r3,255
8112d850:	8c7fe004 	addi	r17,r17,-128
8112d854:	68c00e36 	bltu	r13,r3,8112d890 <_strtod_r+0x534>
8112d858:	71000084 	addi	r4,r14,2
8112d85c:	d9000615 	stw	r4,24(sp)
8112d860:	108002a4 	muli	r2,r2,10
8112d864:	21800003 	ldbu	r6,0(r4)
8112d868:	200f883a 	mov	r7,r4
8112d86c:	1463883a 	add	r17,r2,r17
8112d870:	30fff404 	addi	r3,r6,-48
8112d874:	88bff404 	addi	r2,r17,-48
8112d878:	34403fcc 	andi	r17,r6,255
8112d87c:	8c40201c 	xori	r17,r17,128
8112d880:	18c03fcc 	andi	r3,r3,255
8112d884:	8c7fe004 	addi	r17,r17,-128
8112d888:	21000044 	addi	r4,r4,1
8112d88c:	68fff32e 	bgeu	r13,r3,8112d85c <__reset+0xfb10d85c>
8112d890:	3b8fc83a 	sub	r7,r7,r14
8112d894:	00c00204 	movi	r3,8
8112d898:	19c29716 	blt	r3,r7,8112e2f8 <_strtod_r+0xf9c>
8112d89c:	102b883a 	mov	r21,r2
8112d8a0:	009387c4 	movi	r2,19999
8112d8a4:	1540010e 	bge	r2,r21,8112d8ac <_strtod_r+0x550>
8112d8a8:	102b883a 	mov	r21,r2
8112d8ac:	603f4f26 	beq	r12,zero,8112d5ec <__reset+0xfb10d5ec>
8112d8b0:	056bc83a 	sub	r21,zero,r21
8112d8b4:	003f4d06 	br	8112d5ec <__reset+0xfb10d5ec>
8112d8b8:	98800047 	ldb	r2,1(r19)
8112d8bc:	00c01604 	movi	r3,88
8112d8c0:	10c1de26 	beq	r2,r3,8112e03c <_strtod_r+0xce0>
8112d8c4:	00c01e04 	movi	r3,120
8112d8c8:	10c1dc26 	beq	r2,r3,8112e03c <_strtod_r+0xce0>
8112d8cc:	98c00044 	addi	r3,r19,1
8112d8d0:	1827883a 	mov	r19,r3
8112d8d4:	d8c00615 	stw	r3,24(sp)
8112d8d8:	18c00044 	addi	r3,r3,1
8112d8dc:	18bfffc3 	ldbu	r2,-1(r3)
8112d8e0:	11003fcc 	andi	r4,r2,255
8112d8e4:	2100201c 	xori	r4,r4,128
8112d8e8:	213fe004 	addi	r4,r4,-128
8112d8ec:	217ff826 	beq	r4,r5,8112d8d0 <__reset+0xfb10d8d0>
8112d8f0:	203f7926 	beq	r4,zero,8112d6d8 <__reset+0xfb10d6d8>
8112d8f4:	dcc00815 	stw	r19,32(sp)
8112d8f8:	04800044 	movi	r18,1
8112d8fc:	003f0b06 	br	8112d52c <__reset+0xfb10d52c>
8112d900:	8009883a 	mov	r4,r16
8112d904:	112b57c0 	call	8112b57c <_localeconv_r>
8112d908:	11000017 	ldw	r4,0(r2)
8112d90c:	112235c0 	call	8112235c <strlen>
8112d910:	d8c00617 	ldw	r3,24(sp)
8112d914:	1885883a 	add	r2,r3,r2
8112d918:	d8800615 	stw	r2,24(sp)
8112d91c:	14400007 	ldb	r17,0(r2)
8112d920:	b001881e 	bne	r22,zero,8112df44 <_strtod_r+0xbe8>
8112d924:	00c00c04 	movi	r3,48
8112d928:	88c3391e 	bne	r17,r3,8112e610 <_strtod_r+0x12b4>
8112d92c:	10c00044 	addi	r3,r2,1
8112d930:	8809883a 	mov	r4,r17
8112d934:	d8c00615 	stw	r3,24(sp)
8112d938:	1c400007 	ldb	r17,0(r3)
8112d93c:	188bc83a 	sub	r5,r3,r2
8112d940:	18c00044 	addi	r3,r3,1
8112d944:	893ffb26 	beq	r17,r4,8112d934 <__reset+0xfb10d934>
8112d948:	88bff3c4 	addi	r2,r17,-49
8112d94c:	00c00204 	movi	r3,8
8112d950:	1882e72e 	bgeu	r3,r2,8112e4f0 <_strtod_r+0x1194>
8112d954:	00801944 	movi	r2,101
8112d958:	88814d26 	beq	r17,r2,8112de90 <_strtod_r+0xb34>
8112d95c:	0013883a 	mov	r9,zero
8112d960:	0015883a 	mov	r10,zero
8112d964:	02c00044 	movi	r11,1
8112d968:	003f1d06 	br	8112d5e0 <__reset+0xfb10d5e0>
8112d96c:	4defc83a 	sub	r23,r9,r23
8112d970:	bd6f883a 	add	r23,r23,r21
8112d974:	05c21e0e 	bge	zero,r23,8112e1f0 <_strtod_r+0xe94>
8112d978:	b88003cc 	andi	r2,r23,15
8112d97c:	10000d26 	beq	r2,zero,8112d9b4 <_strtod_r+0x658>
8112d980:	100490fa 	slli	r2,r2,3
8112d984:	00e04574 	movhi	r3,33045
8112d988:	18feda04 	addi	r3,r3,-1176
8112d98c:	1885883a 	add	r2,r3,r2
8112d990:	11000017 	ldw	r4,0(r2)
8112d994:	11400117 	ldw	r5,4(r2)
8112d998:	900d883a 	mov	r6,r18
8112d99c:	880f883a 	mov	r7,r17
8112d9a0:	da401315 	stw	r9,76(sp)
8112d9a4:	111f1b00 	call	8111f1b0 <__muldf3>
8112d9a8:	da401317 	ldw	r9,76(sp)
8112d9ac:	1025883a 	mov	r18,r2
8112d9b0:	1823883a 	mov	r17,r3
8112d9b4:	023ffc04 	movi	r8,-16
8112d9b8:	ba10703a 	and	r8,r23,r8
8112d9bc:	40003c26 	beq	r8,zero,8112dab0 <_strtod_r+0x754>
8112d9c0:	00804d04 	movi	r2,308
8112d9c4:	1201cd16 	blt	r2,r8,8112e0fc <_strtod_r+0xda0>
8112d9c8:	4011d13a 	srai	r8,r8,4
8112d9cc:	03000044 	movi	r12,1
8112d9d0:	62037c0e 	bge	r12,r8,8112e7c4 <_strtod_r+0x1468>
8112d9d4:	01204574 	movhi	r4,33045
8112d9d8:	213ed004 	addi	r4,r4,-1216
8112d9dc:	2015883a 	mov	r10,r4
8112d9e0:	0027883a 	mov	r19,zero
8112d9e4:	d9000915 	stw	r4,36(sp)
8112d9e8:	9005883a 	mov	r2,r18
8112d9ec:	8807883a 	mov	r3,r17
8112d9f0:	dc000c15 	stw	r16,48(sp)
8112d9f4:	dc800e15 	stw	r18,56(sp)
8112d9f8:	9821883a 	mov	r16,r19
8112d9fc:	0009883a 	mov	r4,zero
8112da00:	8827883a 	mov	r19,r17
8112da04:	602f883a 	mov	r23,r12
8112da08:	da400a15 	stw	r9,40(sp)
8112da0c:	5025883a 	mov	r18,r10
8112da10:	4023883a 	mov	r17,r8
8112da14:	8980004c 	andi	r6,r17,1
8112da18:	30000626 	beq	r6,zero,8112da34 <_strtod_r+0x6d8>
8112da1c:	91800017 	ldw	r6,0(r18)
8112da20:	91c00117 	ldw	r7,4(r18)
8112da24:	1009883a 	mov	r4,r2
8112da28:	180b883a 	mov	r5,r3
8112da2c:	111f1b00 	call	8111f1b0 <__muldf3>
8112da30:	01000044 	movi	r4,1
8112da34:	8823d07a 	srai	r17,r17,1
8112da38:	84000044 	addi	r16,r16,1
8112da3c:	94800204 	addi	r18,r18,8
8112da40:	8dfff41e 	bne	r17,r23,8112da14 <__reset+0xfb10da14>
8112da44:	21003fcc 	andi	r4,r4,255
8112da48:	9823883a 	mov	r17,r19
8112da4c:	da400a17 	ldw	r9,40(sp)
8112da50:	8027883a 	mov	r19,r16
8112da54:	dc800e17 	ldw	r18,56(sp)
8112da58:	dc000c17 	ldw	r16,48(sp)
8112da5c:	2003b11e 	bne	r4,zero,8112e924 <_strtod_r+0x15c8>
8112da60:	981690fa 	slli	r11,r19,3
8112da64:	d8800917 	ldw	r2,36(sp)
8112da68:	01ff2c34 	movhi	r7,64688
8112da6c:	900d883a 	mov	r6,r18
8112da70:	12ef883a 	add	r23,r2,r11
8112da74:	b9000017 	ldw	r4,0(r23)
8112da78:	b9400117 	ldw	r5,4(r23)
8112da7c:	89cf883a 	add	r7,r17,r7
8112da80:	da401315 	stw	r9,76(sp)
8112da84:	111f1b00 	call	8111f1b0 <__muldf3>
8112da88:	1025883a 	mov	r18,r2
8112da8c:	011f2834 	movhi	r4,31904
8112da90:	189ffc2c 	andhi	r2,r3,32752
8112da94:	da401317 	ldw	r9,76(sp)
8112da98:	20819836 	bltu	r4,r2,8112e0fc <_strtod_r+0xda0>
8112da9c:	011f2434 	movhi	r4,31888
8112daa0:	2083382e 	bgeu	r4,r2,8112e784 <_strtod_r+0x1428>
8112daa4:	045ffc34 	movhi	r17,32752
8112daa8:	8c7fffc4 	addi	r17,r17,-1
8112daac:	04bfffc4 	movi	r18,-1
8112dab0:	d8000915 	stw	zero,36(sp)
8112dab4:	d9400817 	ldw	r5,32(sp)
8112dab8:	df000015 	stw	fp,0(sp)
8112dabc:	480f883a 	mov	r7,r9
8112dac0:	b00d883a 	mov	r6,r22
8112dac4:	8009883a 	mov	r4,r16
8112dac8:	112bc980 	call	8112bc98 <__s2b>
8112dacc:	d8800815 	stw	r2,32(sp)
8112dad0:	10018a26 	beq	r2,zero,8112e0fc <_strtod_r+0xda0>
8112dad4:	a807d7fa 	srai	r3,r21,31
8112dad8:	0545c83a 	sub	r2,zero,r21
8112dadc:	dd400a15 	stw	r21,40(sp)
8112dae0:	1886703a 	and	r3,r3,r2
8112dae4:	d8c00c15 	stw	r3,48(sp)
8112dae8:	a8013516 	blt	r21,zero,8112dfc0 <_strtod_r+0xc64>
8112daec:	d9400817 	ldw	r5,32(sp)
8112daf0:	0011883a 	mov	r8,zero
8112daf4:	0027883a 	mov	r19,zero
8112daf8:	29400304 	addi	r5,r5,12
8112dafc:	d9400f15 	stw	r5,60(sp)
8112db00:	402b883a 	mov	r21,r8
8112db04:	dd001215 	stw	r20,72(sp)
8112db08:	d8800817 	ldw	r2,32(sp)
8112db0c:	8009883a 	mov	r4,r16
8112db10:	11400117 	ldw	r5,4(r2)
8112db14:	112ba980 	call	8112ba98 <_Balloc>
8112db18:	1029883a 	mov	r20,r2
8112db1c:	10012d26 	beq	r2,zero,8112dfd4 <_strtod_r+0xc78>
8112db20:	d8c00817 	ldw	r3,32(sp)
8112db24:	d9400f17 	ldw	r5,60(sp)
8112db28:	11000304 	addi	r4,r2,12
8112db2c:	19800417 	ldw	r6,16(r3)
8112db30:	31800084 	addi	r6,r6,2
8112db34:	318d883a 	add	r6,r6,r6
8112db38:	318d883a 	add	r6,r6,r6
8112db3c:	11218680 	call	81121868 <memcpy>
8112db40:	d9000204 	addi	r4,sp,8
8112db44:	d9000015 	stw	r4,0(sp)
8112db48:	d9c00404 	addi	r7,sp,16
8112db4c:	900b883a 	mov	r5,r18
8112db50:	880d883a 	mov	r6,r17
8112db54:	8009883a 	mov	r4,r16
8112db58:	112c7740 	call	8112c774 <__d2b>
8112db5c:	d8800515 	stw	r2,20(sp)
8112db60:	dc801115 	stw	r18,68(sp)
8112db64:	dc401015 	stw	r17,64(sp)
8112db68:	10027c26 	beq	r2,zero,8112e55c <_strtod_r+0x1200>
8112db6c:	01400044 	movi	r5,1
8112db70:	8009883a 	mov	r4,r16
8112db74:	112bebc0 	call	8112bebc <__i2b>
8112db78:	1027883a 	mov	r19,r2
8112db7c:	10011526 	beq	r2,zero,8112dfd4 <_strtod_r+0xc78>
8112db80:	d8800417 	ldw	r2,16(sp)
8112db84:	1000c816 	blt	r2,zero,8112dea8 <_strtod_r+0xb4c>
8112db88:	d9400c17 	ldw	r5,48(sp)
8112db8c:	d9000a17 	ldw	r4,40(sp)
8112db90:	28ad883a 	add	r22,r5,r2
8112db94:	d9400917 	ldw	r5,36(sp)
8112db98:	df000217 	ldw	fp,8(sp)
8112db9c:	05ff0084 	movi	r23,-1022
8112dba0:	1147c83a 	sub	r3,r2,r5
8112dba4:	1f07883a 	add	r3,r3,fp
8112dba8:	00800d84 	movi	r2,54
8112dbac:	18ffffc4 	addi	r3,r3,-1
8112dbb0:	1739c83a 	sub	fp,r2,fp
8112dbb4:	1dc0a50e 	bge	r3,r23,8112de4c <_strtod_r+0xaf0>
8112dbb8:	b8efc83a 	sub	r23,r23,r3
8112dbbc:	008007c4 	movi	r2,31
8112dbc0:	e5f9c83a 	sub	fp,fp,r23
8112dbc4:	15c0bc16 	blt	r2,r23,8112deb8 <_strtod_r+0xb5c>
8112dbc8:	00800044 	movi	r2,1
8112dbcc:	15c4983a 	sll	r2,r2,r23
8112dbd0:	d8000b15 	stw	zero,44(sp)
8112dbd4:	d8800d15 	stw	r2,52(sp)
8112dbd8:	2707883a 	add	r3,r4,fp
8112dbdc:	d9000917 	ldw	r4,36(sp)
8112dbe0:	b739883a 	add	fp,r22,fp
8112dbe4:	20ef883a 	add	r23,r4,r3
8112dbe8:	b009883a 	mov	r4,r22
8112dbec:	e580010e 	bge	fp,r22,8112dbf4 <_strtod_r+0x898>
8112dbf0:	e009883a 	mov	r4,fp
8112dbf4:	b805883a 	mov	r2,r23
8112dbf8:	25c0010e 	bge	r4,r23,8112dc00 <_strtod_r+0x8a4>
8112dbfc:	2005883a 	mov	r2,r4
8112dc00:	0080030e 	bge	zero,r2,8112dc10 <_strtod_r+0x8b4>
8112dc04:	e0b9c83a 	sub	fp,fp,r2
8112dc08:	b8afc83a 	sub	r23,r23,r2
8112dc0c:	b0adc83a 	sub	r22,r22,r2
8112dc10:	d9400c17 	ldw	r5,48(sp)
8112dc14:	28001126 	beq	r5,zero,8112dc5c <_strtod_r+0x900>
8112dc18:	280d883a 	mov	r6,r5
8112dc1c:	8009883a 	mov	r4,r16
8112dc20:	980b883a 	mov	r5,r19
8112dc24:	112c1000 	call	8112c100 <__pow5mult>
8112dc28:	1027883a 	mov	r19,r2
8112dc2c:	1000e926 	beq	r2,zero,8112dfd4 <_strtod_r+0xc78>
8112dc30:	d9800517 	ldw	r6,20(sp)
8112dc34:	100b883a 	mov	r5,r2
8112dc38:	8009883a 	mov	r4,r16
8112dc3c:	112bf000 	call	8112bf00 <__multiply>
8112dc40:	1000e426 	beq	r2,zero,8112dfd4 <_strtod_r+0xc78>
8112dc44:	d9400517 	ldw	r5,20(sp)
8112dc48:	8009883a 	mov	r4,r16
8112dc4c:	d8801315 	stw	r2,76(sp)
8112dc50:	112bb480 	call	8112bb48 <_Bfree>
8112dc54:	d8801317 	ldw	r2,76(sp)
8112dc58:	d8800515 	stw	r2,20(sp)
8112dc5c:	0700060e 	bge	zero,fp,8112dc78 <_strtod_r+0x91c>
8112dc60:	d9400517 	ldw	r5,20(sp)
8112dc64:	e00d883a 	mov	r6,fp
8112dc68:	8009883a 	mov	r4,r16
8112dc6c:	112c2480 	call	8112c248 <__lshift>
8112dc70:	d8800515 	stw	r2,20(sp)
8112dc74:	10023926 	beq	r2,zero,8112e55c <_strtod_r+0x1200>
8112dc78:	d8800a17 	ldw	r2,40(sp)
8112dc7c:	10000626 	beq	r2,zero,8112dc98 <_strtod_r+0x93c>
8112dc80:	d9800a17 	ldw	r6,40(sp)
8112dc84:	a00b883a 	mov	r5,r20
8112dc88:	8009883a 	mov	r4,r16
8112dc8c:	112c1000 	call	8112c100 <__pow5mult>
8112dc90:	1029883a 	mov	r20,r2
8112dc94:	1000cf26 	beq	r2,zero,8112dfd4 <_strtod_r+0xc78>
8112dc98:	05c0060e 	bge	zero,r23,8112dcb4 <_strtod_r+0x958>
8112dc9c:	a00b883a 	mov	r5,r20
8112dca0:	b80d883a 	mov	r6,r23
8112dca4:	8009883a 	mov	r4,r16
8112dca8:	112c2480 	call	8112c248 <__lshift>
8112dcac:	1029883a 	mov	r20,r2
8112dcb0:	1000c826 	beq	r2,zero,8112dfd4 <_strtod_r+0xc78>
8112dcb4:	0580060e 	bge	zero,r22,8112dcd0 <_strtod_r+0x974>
8112dcb8:	980b883a 	mov	r5,r19
8112dcbc:	b00d883a 	mov	r6,r22
8112dcc0:	8009883a 	mov	r4,r16
8112dcc4:	112c2480 	call	8112c248 <__lshift>
8112dcc8:	1027883a 	mov	r19,r2
8112dccc:	1000c126 	beq	r2,zero,8112dfd4 <_strtod_r+0xc78>
8112dcd0:	d9400517 	ldw	r5,20(sp)
8112dcd4:	a00d883a 	mov	r6,r20
8112dcd8:	8009883a 	mov	r4,r16
8112dcdc:	112c3f80 	call	8112c3f8 <__mdiff>
8112dce0:	102b883a 	mov	r21,r2
8112dce4:	1000bb26 	beq	r2,zero,8112dfd4 <_strtod_r+0xc78>
8112dce8:	10c00317 	ldw	r3,12(r2)
8112dcec:	980b883a 	mov	r5,r19
8112dcf0:	10000315 	stw	zero,12(r2)
8112dcf4:	1009883a 	mov	r4,r2
8112dcf8:	d8c00e15 	stw	r3,56(sp)
8112dcfc:	112c3980 	call	8112c398 <__mcmp>
8112dd00:	10027616 	blt	r2,zero,8112e6dc <_strtod_r+0x1380>
8112dd04:	10024426 	beq	r2,zero,8112e618 <_strtod_r+0x12bc>
8112dd08:	980b883a 	mov	r5,r19
8112dd0c:	a809883a 	mov	r4,r21
8112dd10:	112c8c80 	call	8112c8c8 <__ratio>
8112dd14:	000d883a 	mov	r6,zero
8112dd18:	01d00034 	movhi	r7,16384
8112dd1c:	1009883a 	mov	r4,r2
8112dd20:	180b883a 	mov	r5,r3
8112dd24:	102f883a 	mov	r23,r2
8112dd28:	182d883a 	mov	r22,r3
8112dd2c:	11352b80 	call	811352b8 <__ledf2>
8112dd30:	00804a16 	blt	zero,r2,8112de5c <_strtod_r+0xb00>
8112dd34:	d9400e17 	ldw	r5,56(sp)
8112dd38:	28006b26 	beq	r5,zero,8112dee8 <_strtod_r+0xb8c>
8112dd3c:	058ffc34 	movhi	r22,16368
8112dd40:	d8000b15 	stw	zero,44(sp)
8112dd44:	d8000d15 	stw	zero,52(sp)
8112dd48:	b02f883a 	mov	r23,r22
8112dd4c:	8f1ffc2c 	andhi	fp,r17,32752
8112dd50:	009ff834 	movhi	r2,32736
8112dd54:	e080cd26 	beq	fp,r2,8112e08c <_strtod_r+0xd30>
8112dd58:	d9400917 	ldw	r5,36(sp)
8112dd5c:	28001a26 	beq	r5,zero,8112ddc8 <_strtod_r+0xa6c>
8112dd60:	0081a834 	movhi	r2,1696
8112dd64:	17001836 	bltu	r2,fp,8112ddc8 <_strtod_r+0xa6c>
8112dd68:	d9000d17 	ldw	r4,52(sp)
8112dd6c:	01d07834 	movhi	r7,16864
8112dd70:	39ffffc4 	addi	r7,r7,-1
8112dd74:	01bff034 	movhi	r6,65472
8112dd78:	b80b883a 	mov	r5,r23
8112dd7c:	11352b80 	call	811352b8 <__ledf2>
8112dd80:	00800e16 	blt	zero,r2,8112ddbc <_strtod_r+0xa60>
8112dd84:	d9000d17 	ldw	r4,52(sp)
8112dd88:	b80b883a 	mov	r5,r23
8112dd8c:	111e5e80 	call	8111e5e8 <__fixunsdfsi>
8112dd90:	10018126 	beq	r2,zero,8112e398 <_strtod_r+0x103c>
8112dd94:	1009883a 	mov	r4,r2
8112dd98:	11353ac0 	call	811353ac <__floatunsidf>
8112dd9c:	d8800d15 	stw	r2,52(sp)
8112dda0:	182f883a 	mov	r23,r3
8112dda4:	d8800e17 	ldw	r2,56(sp)
8112dda8:	1001791e 	bne	r2,zero,8112e390 <_strtod_r+0x1034>
8112ddac:	ba20003c 	xorhi	r8,r23,32768
8112ddb0:	d8c00d17 	ldw	r3,52(sp)
8112ddb4:	402d883a 	mov	r22,r8
8112ddb8:	d8c00b15 	stw	r3,44(sp)
8112ddbc:	0081ac34 	movhi	r2,1712
8112ddc0:	b091883a 	add	r8,r22,r2
8112ddc4:	472dc83a 	sub	r22,r8,fp
8112ddc8:	9009883a 	mov	r4,r18
8112ddcc:	880b883a 	mov	r5,r17
8112ddd0:	112c5fc0 	call	8112c5fc <__ulp>
8112ddd4:	d9000b17 	ldw	r4,44(sp)
8112ddd8:	b00b883a 	mov	r5,r22
8112dddc:	100d883a 	mov	r6,r2
8112dde0:	180f883a 	mov	r7,r3
8112dde4:	111f1b00 	call	8111f1b0 <__muldf3>
8112dde8:	900d883a 	mov	r6,r18
8112ddec:	880f883a 	mov	r7,r17
8112ddf0:	1009883a 	mov	r4,r2
8112ddf4:	180b883a 	mov	r5,r3
8112ddf8:	113408c0 	call	8113408c <__adddf3>
8112ddfc:	1025883a 	mov	r18,r2
8112de00:	1823883a 	mov	r17,r3
8112de04:	182d883a 	mov	r22,r3
8112de08:	d9000917 	ldw	r4,36(sp)
8112de0c:	2000021e 	bne	r4,zero,8112de18 <_strtod_r+0xabc>
8112de10:	b09ffc2c 	andhi	r2,r22,32752
8112de14:	e080be26 	beq	fp,r2,8112e110 <_strtod_r+0xdb4>
8112de18:	d9400517 	ldw	r5,20(sp)
8112de1c:	8009883a 	mov	r4,r16
8112de20:	112bb480 	call	8112bb48 <_Bfree>
8112de24:	a00b883a 	mov	r5,r20
8112de28:	8009883a 	mov	r4,r16
8112de2c:	112bb480 	call	8112bb48 <_Bfree>
8112de30:	980b883a 	mov	r5,r19
8112de34:	8009883a 	mov	r4,r16
8112de38:	112bb480 	call	8112bb48 <_Bfree>
8112de3c:	a80b883a 	mov	r5,r21
8112de40:	8009883a 	mov	r4,r16
8112de44:	112bb480 	call	8112bb48 <_Bfree>
8112de48:	003f2f06 	br	8112db08 <__reset+0xfb10db08>
8112de4c:	00c00044 	movi	r3,1
8112de50:	d8000b15 	stw	zero,44(sp)
8112de54:	d8c00d15 	stw	r3,52(sp)
8112de58:	003f5f06 	br	8112dbd8 <__reset+0xfb10dbd8>
8112de5c:	b809883a 	mov	r4,r23
8112de60:	000d883a 	mov	r6,zero
8112de64:	01cff834 	movhi	r7,16352
8112de68:	b00b883a 	mov	r5,r22
8112de6c:	111f1b00 	call	8111f1b0 <__muldf3>
8112de70:	d9000e17 	ldw	r4,56(sp)
8112de74:	d8800d15 	stw	r2,52(sp)
8112de78:	182f883a 	mov	r23,r3
8112de7c:	2000181e 	bne	r4,zero,8112dee0 <_strtod_r+0xb84>
8112de80:	1a20003c 	xorhi	r8,r3,32768
8112de84:	d8800b15 	stw	r2,44(sp)
8112de88:	402d883a 	mov	r22,r8
8112de8c:	003faf06 	br	8112dd4c <__reset+0xfb10dd4c>
8112de90:	0015883a 	mov	r10,zero
8112de94:	02c00044 	movi	r11,1
8112de98:	2800011e 	bne	r5,zero,8112dea0 <_strtod_r+0xb44>
8112de9c:	903d7e26 	beq	r18,zero,8112d498 <__reset+0xfb10d498>
8112dea0:	0013883a 	mov	r9,zero
8112dea4:	003e4706 	br	8112d7c4 <__reset+0xfb10d7c4>
8112dea8:	d8c00a17 	ldw	r3,40(sp)
8112deac:	dd800c17 	ldw	r22,48(sp)
8112deb0:	1889c83a 	sub	r4,r3,r2
8112deb4:	003f3706 	br	8112db94 <__reset+0xfb10db94>
8112deb8:	00bef884 	movi	r2,-1054
8112debc:	05c00044 	movi	r23,1
8112dec0:	10c5c83a 	sub	r2,r2,r3
8112dec4:	b884983a 	sll	r2,r23,r2
8112dec8:	ddc00d15 	stw	r23,52(sp)
8112decc:	d8800b15 	stw	r2,44(sp)
8112ded0:	003f4106 	br	8112dbd8 <__reset+0xfb10dbd8>
8112ded4:	ddc00615 	stw	r23,24(sp)
8112ded8:	002b883a 	mov	r21,zero
8112dedc:	003dc306 	br	8112d5ec <__reset+0xfb10d5ec>
8112dee0:	1811883a 	mov	r8,r3
8112dee4:	003fe706 	br	8112de84 <__reset+0xfb10de84>
8112dee8:	90002e1e 	bne	r18,zero,8112dfa4 <_strtod_r+0xc48>
8112deec:	00c00434 	movhi	r3,16
8112def0:	18ffffc4 	addi	r3,r3,-1
8112def4:	88c4703a 	and	r2,r17,r3
8112def8:	10002c1e 	bne	r2,zero,8112dfac <_strtod_r+0xc50>
8112defc:	000d883a 	mov	r6,zero
8112df00:	01cffc34 	movhi	r7,16368
8112df04:	b809883a 	mov	r4,r23
8112df08:	b00b883a 	mov	r5,r22
8112df0c:	11352b80 	call	811352b8 <__ledf2>
8112df10:	10021716 	blt	r2,zero,8112e770 <_strtod_r+0x1414>
8112df14:	b809883a 	mov	r4,r23
8112df18:	b00b883a 	mov	r5,r22
8112df1c:	000d883a 	mov	r6,zero
8112df20:	01cff834 	movhi	r7,16352
8112df24:	111f1b00 	call	8111f1b0 <__muldf3>
8112df28:	d8800d15 	stw	r2,52(sp)
8112df2c:	182f883a 	mov	r23,r3
8112df30:	102d883a 	mov	r22,r2
8112df34:	1a20003c 	xorhi	r8,r3,32768
8112df38:	dd800b15 	stw	r22,44(sp)
8112df3c:	402d883a 	mov	r22,r8
8112df40:	003f8206 	br	8112dd4c <__reset+0xfb10dd4c>
8112df44:	b013883a 	mov	r9,r22
8112df48:	000b883a 	mov	r5,zero
8112df4c:	0015883a 	mov	r10,zero
8112df50:	893ff404 	addi	r4,r17,-48
8112df54:	00800244 	movi	r2,9
8112df58:	11001036 	bltu	r2,r4,8112df9c <_strtod_r+0xc40>
8112df5c:	28c00044 	addi	r3,r5,1
8112df60:	2023883a 	mov	r17,r4
8112df64:	20014d1e 	bne	r4,zero,8112e49c <_strtod_r+0x1140>
8112df68:	d9800617 	ldw	r6,24(sp)
8112df6c:	180b883a 	mov	r5,r3
8112df70:	30800044 	addi	r2,r6,1
8112df74:	d8800615 	stw	r2,24(sp)
8112df78:	34400047 	ldb	r17,1(r6)
8112df7c:	003ff406 	br	8112df50 <__reset+0xfb10df50>
8112df80:	0019883a 	mov	r12,zero
8112df84:	b8800084 	addi	r2,r23,2
8112df88:	d8800615 	stw	r2,24(sp)
8112df8c:	bc400087 	ldb	r17,2(r23)
8112df90:	003e1606 	br	8112d7ec <__reset+0xfb10d7ec>
8112df94:	03000044 	movi	r12,1
8112df98:	003ffa06 	br	8112df84 <__reset+0xfb10df84>
8112df9c:	02c00044 	movi	r11,1
8112dfa0:	003d8d06 	br	8112d5d8 <__reset+0xfb10d5d8>
8112dfa4:	00800044 	movi	r2,1
8112dfa8:	9080fe26 	beq	r18,r2,8112e3a4 <_strtod_r+0x1048>
8112dfac:	d8000b15 	stw	zero,44(sp)
8112dfb0:	05affc34 	movhi	r22,49136
8112dfb4:	d8000d15 	stw	zero,52(sp)
8112dfb8:	05cffc34 	movhi	r23,16368
8112dfbc:	003f6306 	br	8112dd4c <__reset+0xfb10dd4c>
8112dfc0:	d8000a15 	stw	zero,40(sp)
8112dfc4:	003ec906 	br	8112daec <__reset+0xfb10daec>
8112dfc8:	d9001117 	ldw	r4,68(sp)
8112dfcc:	00bfffc4 	movi	r2,-1
8112dfd0:	2080461e 	bne	r4,r2,8112e0ec <_strtod_r+0xd90>
8112dfd4:	dd000a15 	stw	r20,40(sp)
8112dfd8:	dd001217 	ldw	r20,72(sp)
8112dfdc:	a811883a 	mov	r8,r21
8112dfe0:	d8800517 	ldw	r2,20(sp)
8112dfe4:	00c00884 	movi	r3,34
8112dfe8:	80c00015 	stw	r3,0(r16)
8112dfec:	002b883a 	mov	r21,zero
8112dff0:	059ffc34 	movhi	r22,32752
8112dff4:	100b883a 	mov	r5,r2
8112dff8:	8009883a 	mov	r4,r16
8112dffc:	da001315 	stw	r8,76(sp)
8112e000:	112bb480 	call	8112bb48 <_Bfree>
8112e004:	d9400a17 	ldw	r5,40(sp)
8112e008:	8009883a 	mov	r4,r16
8112e00c:	112bb480 	call	8112bb48 <_Bfree>
8112e010:	980b883a 	mov	r5,r19
8112e014:	8009883a 	mov	r4,r16
8112e018:	112bb480 	call	8112bb48 <_Bfree>
8112e01c:	d9400817 	ldw	r5,32(sp)
8112e020:	8009883a 	mov	r4,r16
8112e024:	112bb480 	call	8112bb48 <_Bfree>
8112e028:	da001317 	ldw	r8,76(sp)
8112e02c:	8009883a 	mov	r4,r16
8112e030:	400b883a 	mov	r5,r8
8112e034:	112bb480 	call	8112bb48 <_Bfree>
8112e038:	003d9206 	br	8112d684 <__reset+0xfb10d684>
8112e03c:	d8c00717 	ldw	r3,28(sp)
8112e040:	d8800504 	addi	r2,sp,20
8112e044:	01a04574 	movhi	r6,33045
8112e048:	31bf1504 	addi	r6,r6,-940
8112e04c:	d8c00115 	stw	r3,4(sp)
8112e050:	d8800015 	stw	r2,0(sp)
8112e054:	d9c00404 	addi	r7,sp,16
8112e058:	d9400604 	addi	r5,sp,24
8112e05c:	8009883a 	mov	r4,r16
8112e060:	11324b00 	call	811324b0 <__gethex>
8112e064:	154001cc 	andi	r21,r2,7
8112e068:	a83d9b26 	beq	r21,zero,8112d6d8 <__reset+0xfb10d6d8>
8112e06c:	00c00184 	movi	r3,6
8112e070:	a8c0d61e 	bne	r21,r3,8112e3cc <_strtod_r+0x1070>
8112e074:	9cc00044 	addi	r19,r19,1
8112e078:	dcc00615 	stw	r19,24(sp)
8112e07c:	002b883a 	mov	r21,zero
8112e080:	002d883a 	mov	r22,zero
8112e084:	d8000715 	stw	zero,28(sp)
8112e088:	003d7e06 	br	8112d684 <__reset+0xfb10d684>
8112e08c:	00bf2c34 	movhi	r2,64688
8112e090:	88a3883a 	add	r17,r17,r2
8112e094:	9009883a 	mov	r4,r18
8112e098:	880b883a 	mov	r5,r17
8112e09c:	112c5fc0 	call	8112c5fc <__ulp>
8112e0a0:	d9000b17 	ldw	r4,44(sp)
8112e0a4:	100d883a 	mov	r6,r2
8112e0a8:	180f883a 	mov	r7,r3
8112e0ac:	b00b883a 	mov	r5,r22
8112e0b0:	111f1b00 	call	8111f1b0 <__muldf3>
8112e0b4:	900d883a 	mov	r6,r18
8112e0b8:	180b883a 	mov	r5,r3
8112e0bc:	880f883a 	mov	r7,r17
8112e0c0:	1009883a 	mov	r4,r2
8112e0c4:	113408c0 	call	8113408c <__adddf3>
8112e0c8:	015f2834 	movhi	r5,31904
8112e0cc:	1025883a 	mov	r18,r2
8112e0d0:	297fffc4 	addi	r5,r5,-1
8112e0d4:	189ffc2c 	andhi	r2,r3,32752
8112e0d8:	2880892e 	bgeu	r5,r2,8112e300 <_strtod_r+0xfa4>
8112e0dc:	d8801017 	ldw	r2,64(sp)
8112e0e0:	00dffc34 	movhi	r3,32752
8112e0e4:	18ffffc4 	addi	r3,r3,-1
8112e0e8:	10ffb726 	beq	r2,r3,8112dfc8 <__reset+0xfb10dfc8>
8112e0ec:	045ffc34 	movhi	r17,32752
8112e0f0:	8c7fffc4 	addi	r17,r17,-1
8112e0f4:	04bfffc4 	movi	r18,-1
8112e0f8:	003f4706 	br	8112de18 <__reset+0xfb10de18>
8112e0fc:	00800884 	movi	r2,34
8112e100:	80800015 	stw	r2,0(r16)
8112e104:	002b883a 	mov	r21,zero
8112e108:	059ffc34 	movhi	r22,32752
8112e10c:	003d5d06 	br	8112d684 <__reset+0xfb10d684>
8112e110:	d9000d17 	ldw	r4,52(sp)
8112e114:	b80b883a 	mov	r5,r23
8112e118:	11201d40 	call	811201d4 <__fixdfsi>
8112e11c:	1009883a 	mov	r4,r2
8112e120:	11202540 	call	81120254 <__floatsidf>
8112e124:	d9000d17 	ldw	r4,52(sp)
8112e128:	b80b883a 	mov	r5,r23
8112e12c:	100d883a 	mov	r6,r2
8112e130:	180f883a 	mov	r7,r3
8112e134:	111f8d00 	call	8111f8d0 <__subdf3>
8112e138:	d9400e17 	ldw	r5,56(sp)
8112e13c:	1039883a 	mov	fp,r2
8112e140:	182f883a 	mov	r23,r3
8112e144:	2800141e 	bne	r5,zero,8112e198 <_strtod_r+0xe3c>
8112e148:	9000131e 	bne	r18,zero,8112e198 <_strtod_r+0xe3c>
8112e14c:	00800434 	movhi	r2,16
8112e150:	10bfffc4 	addi	r2,r2,-1
8112e154:	b0ac703a 	and	r22,r22,r2
8112e158:	b0000f1e 	bne	r22,zero,8112e198 <_strtod_r+0xe3c>
8112e15c:	01a52834 	movhi	r6,38048
8112e160:	01cff434 	movhi	r7,16336
8112e164:	318d6544 	addi	r6,r6,13717
8112e168:	39ffffc4 	addi	r7,r7,-1
8112e16c:	e009883a 	mov	r4,fp
8112e170:	180b883a 	mov	r5,r3
8112e174:	11352b80 	call	811352b8 <__ledf2>
8112e178:	103f270e 	bge	r2,zero,8112de18 <__reset+0xfb10de18>
8112e17c:	dd000a15 	stw	r20,40(sp)
8112e180:	a811883a 	mov	r8,r21
8112e184:	dd001217 	ldw	r20,72(sp)
8112e188:	d8800517 	ldw	r2,20(sp)
8112e18c:	002b883a 	mov	r21,zero
8112e190:	882d883a 	mov	r22,r17
8112e194:	003f9706 	br	8112dff4 <__reset+0xfb10dff4>
8112e198:	01a52834 	movhi	r6,38048
8112e19c:	01cff834 	movhi	r7,16352
8112e1a0:	318d6544 	addi	r6,r6,13717
8112e1a4:	39ffffc4 	addi	r7,r7,-1
8112e1a8:	e009883a 	mov	r4,fp
8112e1ac:	b80b883a 	mov	r5,r23
8112e1b0:	11352b80 	call	811352b8 <__ledf2>
8112e1b4:	10000716 	blt	r2,zero,8112e1d4 <_strtod_r+0xe78>
8112e1b8:	018d6c34 	movhi	r6,13744
8112e1bc:	31b94d44 	addi	r6,r6,-6859
8112e1c0:	01cff834 	movhi	r7,16352
8112e1c4:	e009883a 	mov	r4,fp
8112e1c8:	b80b883a 	mov	r5,r23
8112e1cc:	111f0d40 	call	8111f0d4 <__gedf2>
8112e1d0:	00bf110e 	bge	zero,r2,8112de18 <__reset+0xfb10de18>
8112e1d4:	dd000a15 	stw	r20,40(sp)
8112e1d8:	a811883a 	mov	r8,r21
8112e1dc:	dd001217 	ldw	r20,72(sp)
8112e1e0:	d8800517 	ldw	r2,20(sp)
8112e1e4:	902b883a 	mov	r21,r18
8112e1e8:	882d883a 	mov	r22,r17
8112e1ec:	003f8106 	br	8112dff4 <__reset+0xfb10dff4>
8112e1f0:	b83e2f26 	beq	r23,zero,8112dab0 <__reset+0xfb10dab0>
8112e1f4:	05efc83a 	sub	r23,zero,r23
8112e1f8:	b88003cc 	andi	r2,r23,15
8112e1fc:	10000d26 	beq	r2,zero,8112e234 <_strtod_r+0xed8>
8112e200:	100490fa 	slli	r2,r2,3
8112e204:	00e04574 	movhi	r3,33045
8112e208:	18feda04 	addi	r3,r3,-1176
8112e20c:	1885883a 	add	r2,r3,r2
8112e210:	11800017 	ldw	r6,0(r2)
8112e214:	11c00117 	ldw	r7,4(r2)
8112e218:	9009883a 	mov	r4,r18
8112e21c:	880b883a 	mov	r5,r17
8112e220:	da401315 	stw	r9,76(sp)
8112e224:	11349400 	call	81134940 <__divdf3>
8112e228:	da401317 	ldw	r9,76(sp)
8112e22c:	1025883a 	mov	r18,r2
8112e230:	1823883a 	mov	r17,r3
8112e234:	b82fd13a 	srai	r23,r23,4
8112e238:	b83e1d26 	beq	r23,zero,8112dab0 <__reset+0xfb10dab0>
8112e23c:	008007c4 	movi	r2,31
8112e240:	15c02816 	blt	r2,r23,8112e2e4 <_strtod_r+0xf88>
8112e244:	b880040c 	andi	r2,r23,16
8112e248:	10019726 	beq	r2,zero,8112e8a8 <_strtod_r+0x154c>
8112e24c:	05c1880e 	bge	zero,r23,8112e870 <_strtod_r+0x1514>
8112e250:	00c01a84 	movi	r3,106
8112e254:	d8c00915 	stw	r3,36(sp)
8112e258:	04e04574 	movhi	r19,33045
8112e25c:	9cff1a04 	addi	r19,r19,-920
8112e260:	8807883a 	mov	r3,r17
8112e264:	9005883a 	mov	r2,r18
8112e268:	8023883a 	mov	r17,r16
8112e26c:	0009883a 	mov	r4,zero
8112e270:	9821883a 	mov	r16,r19
8112e274:	da400a15 	stw	r9,40(sp)
8112e278:	1827883a 	mov	r19,r3
8112e27c:	b980004c 	andi	r6,r23,1
8112e280:	30000626 	beq	r6,zero,8112e29c <_strtod_r+0xf40>
8112e284:	81800017 	ldw	r6,0(r16)
8112e288:	81c00117 	ldw	r7,4(r16)
8112e28c:	1009883a 	mov	r4,r2
8112e290:	180b883a 	mov	r5,r3
8112e294:	111f1b00 	call	8111f1b0 <__muldf3>
8112e298:	01000044 	movi	r4,1
8112e29c:	b82fd07a 	srai	r23,r23,1
8112e2a0:	84000204 	addi	r16,r16,8
8112e2a4:	b83ff51e 	bne	r23,zero,8112e27c <__reset+0xfb10e27c>
8112e2a8:	21003fcc 	andi	r4,r4,255
8112e2ac:	8821883a 	mov	r16,r17
8112e2b0:	da400a17 	ldw	r9,40(sp)
8112e2b4:	9823883a 	mov	r17,r19
8112e2b8:	2001a51e 	bne	r4,zero,8112e950 <_strtod_r+0x15f4>
8112e2bc:	d9000917 	ldw	r4,36(sp)
8112e2c0:	20016d1e 	bne	r4,zero,8112e878 <_strtod_r+0x151c>
8112e2c4:	000d883a 	mov	r6,zero
8112e2c8:	000f883a 	mov	r7,zero
8112e2cc:	9009883a 	mov	r4,r18
8112e2d0:	880b883a 	mov	r5,r17
8112e2d4:	da401315 	stw	r9,76(sp)
8112e2d8:	11352300 	call	81135230 <__eqdf2>
8112e2dc:	da401317 	ldw	r9,76(sp)
8112e2e0:	103df41e 	bne	r2,zero,8112dab4 <__reset+0xfb10dab4>
8112e2e4:	00800884 	movi	r2,34
8112e2e8:	80800015 	stw	r2,0(r16)
8112e2ec:	002b883a 	mov	r21,zero
8112e2f0:	002d883a 	mov	r22,zero
8112e2f4:	003ce306 	br	8112d684 <__reset+0xfb10d684>
8112e2f8:	055387c4 	movi	r21,19999
8112e2fc:	003d6b06 	br	8112d8ac <__reset+0xfb10d8ac>
8112e300:	0440d434 	movhi	r17,848
8112e304:	1c63883a 	add	r17,r3,r17
8112e308:	882d883a 	mov	r22,r17
8112e30c:	003ebe06 	br	8112de08 <__reset+0xfb10de08>
8112e310:	14403fcc 	andi	r17,r2,255
8112e314:	8c40201c 	xori	r17,r17,128
8112e318:	8c7fe004 	addi	r17,r17,-128
8112e31c:	dd400817 	ldw	r21,32(sp)
8112e320:	0027883a 	mov	r19,zero
8112e324:	0039883a 	mov	fp,zero
8112e328:	002d883a 	mov	r22,zero
8112e32c:	003c9906 	br	8112d594 <__reset+0xfb10d594>
8112e330:	00c00944 	movi	r3,37
8112e334:	1a47c83a 	sub	r3,r3,r9
8112e338:	1d7d8c16 	blt	r3,r21,8112d96c <__reset+0xfb10d96c>
8112e33c:	1261c83a 	sub	r16,r2,r9
8112e340:	800490fa 	slli	r2,r16,3
8112e344:	04e04574 	movhi	r19,33045
8112e348:	9cfeda04 	addi	r19,r19,-1176
8112e34c:	9885883a 	add	r2,r19,r2
8112e350:	11000017 	ldw	r4,0(r2)
8112e354:	11400117 	ldw	r5,4(r2)
8112e358:	900d883a 	mov	r6,r18
8112e35c:	880f883a 	mov	r7,r17
8112e360:	111f1b00 	call	8111f1b0 <__muldf3>
8112e364:	ac0dc83a 	sub	r6,r21,r16
8112e368:	300c90fa 	slli	r6,r6,3
8112e36c:	1009883a 	mov	r4,r2
8112e370:	180b883a 	mov	r5,r3
8112e374:	9985883a 	add	r2,r19,r6
8112e378:	11800017 	ldw	r6,0(r2)
8112e37c:	11c00117 	ldw	r7,4(r2)
8112e380:	111f1b00 	call	8111f1b0 <__muldf3>
8112e384:	102b883a 	mov	r21,r2
8112e388:	182d883a 	mov	r22,r3
8112e38c:	003cbd06 	br	8112d684 <__reset+0xfb10d684>
8112e390:	b811883a 	mov	r8,r23
8112e394:	003e8606 	br	8112ddb0 <__reset+0xfb10ddb0>
8112e398:	d8000d15 	stw	zero,52(sp)
8112e39c:	05cffc34 	movhi	r23,16368
8112e3a0:	003e8006 	br	8112dda4 <__reset+0xfb10dda4>
8112e3a4:	883f011e 	bne	r17,zero,8112dfac <__reset+0xfb10dfac>
8112e3a8:	dd000a15 	stw	r20,40(sp)
8112e3ac:	dd001217 	ldw	r20,72(sp)
8112e3b0:	a811883a 	mov	r8,r21
8112e3b4:	00800884 	movi	r2,34
8112e3b8:	80800015 	stw	r2,0(r16)
8112e3bc:	002b883a 	mov	r21,zero
8112e3c0:	d8800517 	ldw	r2,20(sp)
8112e3c4:	002d883a 	mov	r22,zero
8112e3c8:	003f0a06 	br	8112dff4 <__reset+0xfb10dff4>
8112e3cc:	d9800517 	ldw	r6,20(sp)
8112e3d0:	30000826 	beq	r6,zero,8112e3f4 <_strtod_r+0x1098>
8112e3d4:	01400d44 	movi	r5,53
8112e3d8:	d9000204 	addi	r4,sp,8
8112e3dc:	d8801315 	stw	r2,76(sp)
8112e3e0:	112c9f00 	call	8112c9f0 <__copybits>
8112e3e4:	d9400517 	ldw	r5,20(sp)
8112e3e8:	8009883a 	mov	r4,r16
8112e3ec:	112bb480 	call	8112bb48 <_Bfree>
8112e3f0:	d8801317 	ldw	r2,76(sp)
8112e3f4:	00c00184 	movi	r3,6
8112e3f8:	1d400f36 	bltu	r3,r21,8112e438 <_strtod_r+0x10dc>
8112e3fc:	a82a90ba 	slli	r21,r21,2
8112e400:	00e044f4 	movhi	r3,33043
8112e404:	18f90504 	addi	r3,r3,-7148
8112e408:	a8eb883a 	add	r21,r21,r3
8112e40c:	a8c00017 	ldw	r3,0(r21)
8112e410:	1800683a 	jmp	r3
8112e414:	8112e490 	cmplti	r4,r16,19346
8112e418:	8112e468 	cmpgeui	r4,r16,19345
8112e41c:	8112e44c 	andi	r4,r16,19345
8112e420:	8112e430 	cmpltui	r4,r16,19344
8112e424:	8112e458 	cmpnei	r4,r16,19345
8112e428:	8112e468 	cmpgeui	r4,r16,19345
8112e42c:	8112e490 	cmplti	r4,r16,19346
8112e430:	045ffc34 	movhi	r17,32752
8112e434:	0025883a 	mov	r18,zero
8112e438:	1080020c 	andi	r2,r2,8
8112e43c:	902b883a 	mov	r21,r18
8112e440:	103c8f26 	beq	r2,zero,8112d680 <__reset+0xfb10d680>
8112e444:	8da00034 	orhi	r22,r17,32768
8112e448:	003c8e06 	br	8112d684 <__reset+0xfb10d684>
8112e44c:	dc800217 	ldw	r18,8(sp)
8112e450:	dc400317 	ldw	r17,12(sp)
8112e454:	003ff806 	br	8112e438 <__reset+0xfb10e438>
8112e458:	04600034 	movhi	r17,32768
8112e45c:	8c7fffc4 	addi	r17,r17,-1
8112e460:	04bfffc4 	movi	r18,-1
8112e464:	003ff406 	br	8112e438 <__reset+0xfb10e438>
8112e468:	d8c00417 	ldw	r3,16(sp)
8112e46c:	dc400317 	ldw	r17,12(sp)
8112e470:	013ffc34 	movhi	r4,65520
8112e474:	18c10cc4 	addi	r3,r3,1075
8112e478:	1806953a 	slli	r3,r3,20
8112e47c:	213fffc4 	addi	r4,r4,-1
8112e480:	8922703a 	and	r17,r17,r4
8112e484:	dc800217 	ldw	r18,8(sp)
8112e488:	88e2b03a 	or	r17,r17,r3
8112e48c:	003fea06 	br	8112e438 <__reset+0xfb10e438>
8112e490:	0023883a 	mov	r17,zero
8112e494:	0025883a 	mov	r18,zero
8112e498:	003fe706 	br	8112e438 <__reset+0xfb10e438>
8112e49c:	01800044 	movi	r6,1
8112e4a0:	50d5883a 	add	r10,r10,r3
8112e4a4:	2a4b883a 	add	r5,r5,r9
8112e4a8:	19811a26 	beq	r3,r6,8112e914 <_strtod_r+0x15b8>
8112e4ac:	01800204 	movi	r6,8
8112e4b0:	01c00404 	movi	r7,16
8112e4b4:	4a400044 	addi	r9,r9,1
8112e4b8:	48bfffc4 	addi	r2,r9,-1
8112e4bc:	30801616 	blt	r6,r2,8112e518 <_strtod_r+0x11bc>
8112e4c0:	e70002a4 	muli	fp,fp,10
8112e4c4:	497ffb1e 	bne	r9,r5,8112e4b4 <__reset+0xfb10e4b4>
8112e4c8:	d9800617 	ldw	r6,24(sp)
8112e4cc:	4a400044 	addi	r9,r9,1
8112e4d0:	00c00204 	movi	r3,8
8112e4d4:	19400c0e 	bge	r3,r5,8112e508 <_strtod_r+0x11ac>
8112e4d8:	00800404 	movi	r2,16
8112e4dc:	000b883a 	mov	r5,zero
8112e4e0:	127ea316 	blt	r2,r9,8112df70 <__reset+0xfb10df70>
8112e4e4:	988002a4 	muli	r2,r19,10
8112e4e8:	20a7883a 	add	r19,r4,r2
8112e4ec:	003ea006 	br	8112df70 <__reset+0xfb10df70>
8112e4f0:	d8800617 	ldw	r2,24(sp)
8112e4f4:	8c7ff404 	addi	r17,r17,-48
8112e4f8:	2a800044 	addi	r10,r5,1
8112e4fc:	d8800815 	stw	r2,32(sp)
8112e500:	100d883a 	mov	r6,r2
8112e504:	02400044 	movi	r9,1
8112e508:	e08002a4 	muli	r2,fp,10
8112e50c:	000b883a 	mov	r5,zero
8112e510:	88b9883a 	add	fp,r17,r2
8112e514:	003e9606 	br	8112df70 <__reset+0xfb10df70>
8112e518:	3a7fea16 	blt	r7,r9,8112e4c4 <__reset+0xfb10e4c4>
8112e51c:	9cc002a4 	muli	r19,r19,10
8112e520:	003fe806 	br	8112e4c4 <__reset+0xfb10e4c4>
8112e524:	00bffa84 	movi	r2,-22
8112e528:	a8bd1016 	blt	r21,r2,8112d96c <__reset+0xfb10d96c>
8112e52c:	a82a90fa 	slli	r21,r21,3
8112e530:	00a04574 	movhi	r2,33045
8112e534:	10beda04 	addi	r2,r2,-1176
8112e538:	1545c83a 	sub	r2,r2,r21
8112e53c:	11800017 	ldw	r6,0(r2)
8112e540:	11c00117 	ldw	r7,4(r2)
8112e544:	9009883a 	mov	r4,r18
8112e548:	880b883a 	mov	r5,r17
8112e54c:	11349400 	call	81134940 <__divdf3>
8112e550:	102b883a 	mov	r21,r2
8112e554:	182d883a 	mov	r22,r3
8112e558:	003c4a06 	br	8112d684 <__reset+0xfb10d684>
8112e55c:	dd000a15 	stw	r20,40(sp)
8112e560:	a811883a 	mov	r8,r21
8112e564:	dd001217 	ldw	r20,72(sp)
8112e568:	003e9e06 	br	8112dfe4 <__reset+0xfb10dfe4>
8112e56c:	01604574 	movhi	r5,33045
8112e570:	d9000617 	ldw	r4,24(sp)
8112e574:	297f0c04 	addi	r5,r5,-976
8112e578:	01c00644 	movi	r7,25
8112e57c:	00000b06 	br	8112e5ac <_strtod_r+0x1250>
8112e580:	21000044 	addi	r4,r4,1
8112e584:	20800003 	ldbu	r2,0(r4)
8112e588:	10ffefc4 	addi	r3,r2,-65
8112e58c:	10803fcc 	andi	r2,r2,255
8112e590:	1080201c 	xori	r2,r2,128
8112e594:	18c03fcc 	andi	r3,r3,255
8112e598:	10bfe004 	addi	r2,r2,-128
8112e59c:	38c00136 	bltu	r7,r3,8112e5a4 <_strtod_r+0x1248>
8112e5a0:	10800804 	addi	r2,r2,32
8112e5a4:	29400044 	addi	r5,r5,1
8112e5a8:	11bbbb1e 	bne	r2,r6,8112d498 <__reset+0xfb10d498>
8112e5ac:	29800007 	ldb	r6,0(r5)
8112e5b0:	303ff31e 	bne	r6,zero,8112e580 <__reset+0xfb10e580>
8112e5b4:	01a04574 	movhi	r6,33045
8112e5b8:	d9000615 	stw	r4,24(sp)
8112e5bc:	31bf0d04 	addi	r6,r6,-972
8112e5c0:	200b883a 	mov	r5,r4
8112e5c4:	02000644 	movi	r8,25
8112e5c8:	00000a06 	br	8112e5f4 <_strtod_r+0x1298>
8112e5cc:	28800003 	ldbu	r2,0(r5)
8112e5d0:	10ffefc4 	addi	r3,r2,-65
8112e5d4:	10803fcc 	andi	r2,r2,255
8112e5d8:	1080201c 	xori	r2,r2,128
8112e5dc:	18c03fcc 	andi	r3,r3,255
8112e5e0:	10bfe004 	addi	r2,r2,-128
8112e5e4:	40c00136 	bltu	r8,r3,8112e5ec <_strtod_r+0x1290>
8112e5e8:	10800804 	addi	r2,r2,32
8112e5ec:	31800044 	addi	r6,r6,1
8112e5f0:	11c0711e 	bne	r2,r7,8112e7b8 <_strtod_r+0x145c>
8112e5f4:	31c00007 	ldb	r7,0(r6)
8112e5f8:	29400044 	addi	r5,r5,1
8112e5fc:	383ff31e 	bne	r7,zero,8112e5cc <__reset+0xfb10e5cc>
8112e600:	d9400615 	stw	r5,24(sp)
8112e604:	045ffc34 	movhi	r17,32752
8112e608:	0025883a 	mov	r18,zero
8112e60c:	003c1b06 	br	8112d67c <__reset+0xfb10d67c>
8112e610:	000b883a 	mov	r5,zero
8112e614:	003ccc06 	br	8112d948 <__reset+0xfb10d948>
8112e618:	d9400e17 	ldw	r5,56(sp)
8112e61c:	dd000a15 	stw	r20,40(sp)
8112e620:	00800434 	movhi	r2,16
8112e624:	a811883a 	mov	r8,r21
8112e628:	dd001217 	ldw	r20,72(sp)
8112e62c:	dd401117 	ldw	r21,68(sp)
8112e630:	dd801017 	ldw	r22,64(sp)
8112e634:	10bfffc4 	addi	r2,r2,-1
8112e638:	28005626 	beq	r5,zero,8112e794 <_strtod_r+0x1438>
8112e63c:	8886703a 	and	r3,r17,r2
8112e640:	18807826 	beq	r3,r2,8112e824 <_strtod_r+0x14c8>
8112e644:	d8c00b17 	ldw	r3,44(sp)
8112e648:	18005726 	beq	r3,zero,8112e7a8 <_strtod_r+0x144c>
8112e64c:	1c44703a 	and	r2,r3,r17
8112e650:	10000f26 	beq	r2,zero,8112e690 <_strtod_r+0x1334>
8112e654:	d9000e17 	ldw	r4,56(sp)
8112e658:	d9800917 	ldw	r6,36(sp)
8112e65c:	20005e26 	beq	r4,zero,8112e7d8 <_strtod_r+0x147c>
8112e660:	9009883a 	mov	r4,r18
8112e664:	880b883a 	mov	r5,r17
8112e668:	da001315 	stw	r8,76(sp)
8112e66c:	112d2f00 	call	8112d2f0 <sulp>
8112e670:	100d883a 	mov	r6,r2
8112e674:	180f883a 	mov	r7,r3
8112e678:	9009883a 	mov	r4,r18
8112e67c:	880b883a 	mov	r5,r17
8112e680:	113408c0 	call	8113408c <__adddf3>
8112e684:	da001317 	ldw	r8,76(sp)
8112e688:	102b883a 	mov	r21,r2
8112e68c:	182d883a 	mov	r22,r3
8112e690:	d8c00917 	ldw	r3,36(sp)
8112e694:	18000f26 	beq	r3,zero,8112e6d4 <_strtod_r+0x1378>
8112e698:	a809883a 	mov	r4,r21
8112e69c:	b00b883a 	mov	r5,r22
8112e6a0:	000d883a 	mov	r6,zero
8112e6a4:	01ce5434 	movhi	r7,14672
8112e6a8:	da001315 	stw	r8,76(sp)
8112e6ac:	111f1b00 	call	8111f1b0 <__muldf3>
8112e6b0:	102b883a 	mov	r21,r2
8112e6b4:	182d883a 	mov	r22,r3
8112e6b8:	da001317 	ldw	r8,76(sp)
8112e6bc:	1800051e 	bne	r3,zero,8112e6d4 <_strtod_r+0x1378>
8112e6c0:	d8800517 	ldw	r2,20(sp)
8112e6c4:	a83e4b1e 	bne	r21,zero,8112dff4 <__reset+0xfb10dff4>
8112e6c8:	00c00884 	movi	r3,34
8112e6cc:	80c00015 	stw	r3,0(r16)
8112e6d0:	003e4806 	br	8112dff4 <__reset+0xfb10dff4>
8112e6d4:	d8800517 	ldw	r2,20(sp)
8112e6d8:	003e4606 	br	8112dff4 <__reset+0xfb10dff4>
8112e6dc:	d9000e17 	ldw	r4,56(sp)
8112e6e0:	dd000a15 	stw	r20,40(sp)
8112e6e4:	a811883a 	mov	r8,r21
8112e6e8:	dd001217 	ldw	r20,72(sp)
8112e6ec:	dd401117 	ldw	r21,68(sp)
8112e6f0:	dd801017 	ldw	r22,64(sp)
8112e6f4:	203fe61e 	bne	r4,zero,8112e690 <__reset+0xfb10e690>
8112e6f8:	903fe51e 	bne	r18,zero,8112e690 <__reset+0xfb10e690>
8112e6fc:	00800434 	movhi	r2,16
8112e700:	10bfffc4 	addi	r2,r2,-1
8112e704:	8884703a 	and	r2,r17,r2
8112e708:	103fe11e 	bne	r2,zero,8112e690 <__reset+0xfb10e690>
8112e70c:	8ddffc2c 	andhi	r23,r17,32752
8112e710:	0081ac34 	movhi	r2,1712
8112e714:	15ffde2e 	bgeu	r2,r23,8112e690 <__reset+0xfb10e690>
8112e718:	40800517 	ldw	r2,20(r8)
8112e71c:	1000031e 	bne	r2,zero,8112e72c <_strtod_r+0x13d0>
8112e720:	40800417 	ldw	r2,16(r8)
8112e724:	00c00044 	movi	r3,1
8112e728:	18bfd90e 	bge	r3,r2,8112e690 <__reset+0xfb10e690>
8112e72c:	400b883a 	mov	r5,r8
8112e730:	01800044 	movi	r6,1
8112e734:	8009883a 	mov	r4,r16
8112e738:	112c2480 	call	8112c248 <__lshift>
8112e73c:	980b883a 	mov	r5,r19
8112e740:	1009883a 	mov	r4,r2
8112e744:	d8801315 	stw	r2,76(sp)
8112e748:	112c3980 	call	8112c398 <__mcmp>
8112e74c:	da001317 	ldw	r8,76(sp)
8112e750:	00bfcf0e 	bge	zero,r2,8112e690 <__reset+0xfb10e690>
8112e754:	d8c00917 	ldw	r3,36(sp)
8112e758:	18005c26 	beq	r3,zero,8112e8cc <_strtod_r+0x1570>
8112e75c:	0081ac34 	movhi	r2,1712
8112e760:	15c05a16 	blt	r2,r23,8112e8cc <_strtod_r+0x1570>
8112e764:	0080dc34 	movhi	r2,880
8112e768:	15ffcb16 	blt	r2,r23,8112e698 <__reset+0xfb10e698>
8112e76c:	003f1106 	br	8112e3b4 <__reset+0xfb10e3b4>
8112e770:	002d883a 	mov	r22,zero
8112e774:	022ff834 	movhi	r8,49120
8112e778:	d8000d15 	stw	zero,52(sp)
8112e77c:	05cff834 	movhi	r23,16352
8112e780:	003ded06 	br	8112df38 <__reset+0xfb10df38>
8112e784:	0440d434 	movhi	r17,848
8112e788:	1c63883a 	add	r17,r3,r17
8112e78c:	d8000915 	stw	zero,36(sp)
8112e790:	003cc806 	br	8112dab4 <__reset+0xfb10dab4>
8112e794:	8884703a 	and	r2,r17,r2
8112e798:	103faa1e 	bne	r2,zero,8112e644 <__reset+0xfb10e644>
8112e79c:	903fa91e 	bne	r18,zero,8112e644 <__reset+0xfb10e644>
8112e7a0:	8ddffc2c 	andhi	r23,r17,32752
8112e7a4:	003feb06 	br	8112e754 <__reset+0xfb10e754>
8112e7a8:	d8c00d17 	ldw	r3,52(sp)
8112e7ac:	1cae703a 	and	r23,r3,r18
8112e7b0:	b83fb726 	beq	r23,zero,8112e690 <__reset+0xfb10e690>
8112e7b4:	003fa706 	br	8112e654 <__reset+0xfb10e654>
8112e7b8:	21000044 	addi	r4,r4,1
8112e7bc:	d9000615 	stw	r4,24(sp)
8112e7c0:	003f9006 	br	8112e604 <__reset+0xfb10e604>
8112e7c4:	01604574 	movhi	r5,33045
8112e7c8:	297ed004 	addi	r5,r5,-1216
8112e7cc:	d9400915 	stw	r5,36(sp)
8112e7d0:	0027883a 	mov	r19,zero
8112e7d4:	003ca206 	br	8112da60 <__reset+0xfb10da60>
8112e7d8:	9009883a 	mov	r4,r18
8112e7dc:	880b883a 	mov	r5,r17
8112e7e0:	da001315 	stw	r8,76(sp)
8112e7e4:	112d2f00 	call	8112d2f0 <sulp>
8112e7e8:	100d883a 	mov	r6,r2
8112e7ec:	180f883a 	mov	r7,r3
8112e7f0:	9009883a 	mov	r4,r18
8112e7f4:	880b883a 	mov	r5,r17
8112e7f8:	111f8d00 	call	8111f8d0 <__subdf3>
8112e7fc:	000d883a 	mov	r6,zero
8112e800:	000f883a 	mov	r7,zero
8112e804:	1009883a 	mov	r4,r2
8112e808:	180b883a 	mov	r5,r3
8112e80c:	102b883a 	mov	r21,r2
8112e810:	182d883a 	mov	r22,r3
8112e814:	11352300 	call	81135230 <__eqdf2>
8112e818:	da001317 	ldw	r8,76(sp)
8112e81c:	103ee526 	beq	r2,zero,8112e3b4 <__reset+0xfb10e3b4>
8112e820:	003f9b06 	br	8112e690 <__reset+0xfb10e690>
8112e824:	d8800917 	ldw	r2,36(sp)
8112e828:	10002226 	beq	r2,zero,8112e8b4 <_strtod_r+0x1558>
8112e82c:	889ffc2c 	andhi	r2,r17,32752
8112e830:	00c1a834 	movhi	r3,1696
8112e834:	18801f36 	bltu	r3,r2,8112e8b4 <_strtod_r+0x1558>
8112e838:	1004d53a 	srli	r2,r2,20
8112e83c:	00c01ac4 	movi	r3,107
8112e840:	1887c83a 	sub	r3,r3,r2
8112e844:	00bfffc4 	movi	r2,-1
8112e848:	10c4983a 	sll	r2,r2,r3
8112e84c:	14bf7d1e 	bne	r2,r18,8112e644 <__reset+0xfb10e644>
8112e850:	00dffc34 	movhi	r3,32752
8112e854:	18ffffc4 	addi	r3,r3,-1
8112e858:	88c03526 	beq	r17,r3,8112e930 <_strtod_r+0x15d4>
8112e85c:	8c5ffc2c 	andhi	r17,r17,32752
8112e860:	00800434 	movhi	r2,16
8112e864:	002b883a 	mov	r21,zero
8112e868:	88ad883a 	add	r22,r17,r2
8112e86c:	003f8806 	br	8112e690 <__reset+0xfb10e690>
8112e870:	01401a84 	movi	r5,106
8112e874:	d9400915 	stw	r5,36(sp)
8112e878:	8ddffc2c 	andhi	r23,r17,32752
8112e87c:	b82ed53a 	srli	r23,r23,20
8112e880:	00801ac4 	movi	r2,107
8112e884:	15c5c83a 	sub	r2,r2,r23
8112e888:	00be8e0e 	bge	zero,r2,8112e2c4 <__reset+0xfb10e2c4>
8112e88c:	00c007c4 	movi	r3,31
8112e890:	18800a0e 	bge	r3,r2,8112e8bc <_strtod_r+0x1560>
8112e894:	00c00d04 	movi	r3,52
8112e898:	0025883a 	mov	r18,zero
8112e89c:	1880270e 	bge	r3,r2,8112e93c <_strtod_r+0x15e0>
8112e8a0:	0440dc34 	movhi	r17,880
8112e8a4:	003e8706 	br	8112e2c4 <__reset+0xfb10e2c4>
8112e8a8:	d8000915 	stw	zero,36(sp)
8112e8ac:	05fe6a16 	blt	zero,r23,8112e258 <__reset+0xfb10e258>
8112e8b0:	003e8406 	br	8112e2c4 <__reset+0xfb10e2c4>
8112e8b4:	00bfffc4 	movi	r2,-1
8112e8b8:	003fe406 	br	8112e84c <__reset+0xfb10e84c>
8112e8bc:	00ffffc4 	movi	r3,-1
8112e8c0:	1884983a 	sll	r2,r3,r2
8112e8c4:	14a4703a 	and	r18,r2,r18
8112e8c8:	003e7e06 	br	8112e2c4 <__reset+0xfb10e2c4>
8112e8cc:	00bffc34 	movhi	r2,65520
8112e8d0:	b8af883a 	add	r23,r23,r2
8112e8d4:	057fffc4 	movi	r21,-1
8112e8d8:	00800434 	movhi	r2,16
8112e8dc:	1545883a 	add	r2,r2,r21
8112e8e0:	b8acb03a 	or	r22,r23,r2
8112e8e4:	003f6a06 	br	8112e690 <__reset+0xfb10e690>
8112e8e8:	01604574 	movhi	r5,33045
8112e8ec:	297f1004 	addi	r5,r5,-960
8112e8f0:	d9800204 	addi	r6,sp,8
8112e8f4:	d9000604 	addi	r4,sp,24
8112e8f8:	1132ce80 	call	81132ce8 <__hexnan>
8112e8fc:	00c00144 	movi	r3,5
8112e900:	10fb5c1e 	bne	r2,r3,8112d674 <__reset+0xfb10d674>
8112e904:	dc400317 	ldw	r17,12(sp)
8112e908:	dc800217 	ldw	r18,8(sp)
8112e90c:	8c5ffc34 	orhi	r17,r17,32752
8112e910:	003b5a06 	br	8112d67c <__reset+0xfb10d67c>
8112e914:	480b883a 	mov	r5,r9
8112e918:	d9800617 	ldw	r6,24(sp)
8112e91c:	4a400044 	addi	r9,r9,1
8112e920:	003eeb06 	br	8112e4d0 <__reset+0xfb10e4d0>
8112e924:	1025883a 	mov	r18,r2
8112e928:	1823883a 	mov	r17,r3
8112e92c:	003c4c06 	br	8112da60 <__reset+0xfb10da60>
8112e930:	00ffffc4 	movi	r3,-1
8112e934:	10ffc91e 	bne	r2,r3,8112e85c <__reset+0xfb10e85c>
8112e938:	003da906 	br	8112dfe0 <__reset+0xfb10dfe0>
8112e93c:	10bff804 	addi	r2,r2,-32
8112e940:	00ffffc4 	movi	r3,-1
8112e944:	1884983a 	sll	r2,r3,r2
8112e948:	1462703a 	and	r17,r2,r17
8112e94c:	003e5d06 	br	8112e2c4 <__reset+0xfb10e2c4>
8112e950:	1025883a 	mov	r18,r2
8112e954:	1823883a 	mov	r17,r3
8112e958:	003e5806 	br	8112e2bc <__reset+0xfb10e2bc>

8112e95c <strtod>:
8112e95c:	00a04574 	movhi	r2,33045
8112e960:	10886904 	addi	r2,r2,8612
8112e964:	280d883a 	mov	r6,r5
8112e968:	200b883a 	mov	r5,r4
8112e96c:	11000017 	ldw	r4,0(r2)
8112e970:	112d35c1 	jmpi	8112d35c <_strtod_r>

8112e974 <strtof>:
8112e974:	defffb04 	addi	sp,sp,-20
8112e978:	de00012e 	bgeu	sp,et,8112e980 <strtof+0xc>
8112e97c:	003b68fa 	trap	3
8112e980:	dcc00315 	stw	r19,12(sp)
8112e984:	04e04574 	movhi	r19,33045
8112e988:	9cc86904 	addi	r19,r19,8612
8112e98c:	280d883a 	mov	r6,r5
8112e990:	200b883a 	mov	r5,r4
8112e994:	99000017 	ldw	r4,0(r19)
8112e998:	dfc00415 	stw	ra,16(sp)
8112e99c:	dc800215 	stw	r18,8(sp)
8112e9a0:	dc400115 	stw	r17,4(sp)
8112e9a4:	dc000015 	stw	r16,0(sp)
8112e9a8:	112d35c0 	call	8112d35c <_strtod_r>
8112e9ac:	1009883a 	mov	r4,r2
8112e9b0:	180b883a 	mov	r5,r3
8112e9b4:	1025883a 	mov	r18,r2
8112e9b8:	1823883a 	mov	r17,r3
8112e9bc:	11204500 	call	81120450 <__truncdfsf2>
8112e9c0:	000b883a 	mov	r5,zero
8112e9c4:	1009883a 	mov	r4,r2
8112e9c8:	1021883a 	mov	r16,r2
8112e9cc:	1133e900 	call	81133e90 <__eqsf2>
8112e9d0:	1000111e 	bne	r2,zero,8112ea18 <strtof+0xa4>
8112e9d4:	000d883a 	mov	r6,zero
8112e9d8:	000f883a 	mov	r7,zero
8112e9dc:	9009883a 	mov	r4,r18
8112e9e0:	880b883a 	mov	r5,r17
8112e9e4:	11352300 	call	81135230 <__eqdf2>
8112e9e8:	10000b26 	beq	r2,zero,8112ea18 <strtof+0xa4>
8112e9ec:	98800017 	ldw	r2,0(r19)
8112e9f0:	00c00884 	movi	r3,34
8112e9f4:	10c00015 	stw	r3,0(r2)
8112e9f8:	8005883a 	mov	r2,r16
8112e9fc:	dfc00417 	ldw	ra,16(sp)
8112ea00:	dcc00317 	ldw	r19,12(sp)
8112ea04:	dc800217 	ldw	r18,8(sp)
8112ea08:	dc400117 	ldw	r17,4(sp)
8112ea0c:	dc000017 	ldw	r16,0(sp)
8112ea10:	dec00504 	addi	sp,sp,20
8112ea14:	f800283a 	ret
8112ea18:	015fe034 	movhi	r5,32640
8112ea1c:	297fffc4 	addi	r5,r5,-1
8112ea20:	8009883a 	mov	r4,r16
8112ea24:	1133f080 	call	81133f08 <__gesf2>
8112ea28:	0080070e 	bge	zero,r2,8112ea48 <strtof+0xd4>
8112ea2c:	01dffc34 	movhi	r7,32752
8112ea30:	39ffffc4 	addi	r7,r7,-1
8112ea34:	01bfffc4 	movi	r6,-1
8112ea38:	9009883a 	mov	r4,r18
8112ea3c:	880b883a 	mov	r5,r17
8112ea40:	111f0d40 	call	8111f0d4 <__gedf2>
8112ea44:	00bfe90e 	bge	zero,r2,8112e9ec <__reset+0xfb10e9ec>
8112ea48:	017fe034 	movhi	r5,65408
8112ea4c:	297fffc4 	addi	r5,r5,-1
8112ea50:	8009883a 	mov	r4,r16
8112ea54:	1133fc40 	call	81133fc4 <__lesf2>
8112ea58:	103fe70e 	bge	r2,zero,8112e9f8 <__reset+0xfb10e9f8>
8112ea5c:	01fffc34 	movhi	r7,65520
8112ea60:	39ffffc4 	addi	r7,r7,-1
8112ea64:	01bfffc4 	movi	r6,-1
8112ea68:	9009883a 	mov	r4,r18
8112ea6c:	880b883a 	mov	r5,r17
8112ea70:	11352b80 	call	811352b8 <__ledf2>
8112ea74:	103fdd0e 	bge	r2,zero,8112e9ec <__reset+0xfb10e9ec>
8112ea78:	003fdf06 	br	8112e9f8 <__reset+0xfb10e9f8>

8112ea7c <_strtoll_r>:
8112ea7c:	00a04574 	movhi	r2,33045
8112ea80:	defff304 	addi	sp,sp,-52
8112ea84:	10886704 	addi	r2,r2,8604
8112ea88:	de00012e 	bgeu	sp,et,8112ea90 <_strtoll_r+0x14>
8112ea8c:	003b68fa 	trap	3
8112ea90:	dc800515 	stw	r18,20(sp)
8112ea94:	14800017 	ldw	r18,0(r2)
8112ea98:	dd800915 	stw	r22,36(sp)
8112ea9c:	dd400815 	stw	r21,32(sp)
8112eaa0:	dcc00615 	stw	r19,24(sp)
8112eaa4:	d9000015 	stw	r4,0(sp)
8112eaa8:	dfc00c15 	stw	ra,48(sp)
8112eaac:	df000b15 	stw	fp,44(sp)
8112eab0:	ddc00a15 	stw	r23,40(sp)
8112eab4:	dd000715 	stw	r20,28(sp)
8112eab8:	dc400415 	stw	r17,16(sp)
8112eabc:	dc000315 	stw	r16,12(sp)
8112eac0:	282d883a 	mov	r22,r5
8112eac4:	302b883a 	mov	r21,r6
8112eac8:	3827883a 	mov	r19,r7
8112eacc:	2809883a 	mov	r4,r5
8112ead0:	24000003 	ldbu	r16,0(r4)
8112ead4:	24400044 	addi	r17,r4,1
8112ead8:	2007883a 	mov	r3,r4
8112eadc:	9405883a 	add	r2,r18,r16
8112eae0:	10800043 	ldbu	r2,1(r2)
8112eae4:	8809883a 	mov	r4,r17
8112eae8:	1080020c 	andi	r2,r2,8
8112eaec:	103ff81e 	bne	r2,zero,8112ead0 <__reset+0xfb10ead0>
8112eaf0:	00800b44 	movi	r2,45
8112eaf4:	80807826 	beq	r16,r2,8112ecd8 <_strtoll_r+0x25c>
8112eaf8:	00800ac4 	movi	r2,43
8112eafc:	80807a26 	beq	r16,r2,8112ece8 <_strtoll_r+0x26c>
8112eb00:	0039883a 	mov	fp,zero
8112eb04:	98004e26 	beq	r19,zero,8112ec40 <_strtoll_r+0x1c4>
8112eb08:	00800404 	movi	r2,16
8112eb0c:	98808226 	beq	r19,r2,8112ed18 <_strtoll_r+0x29c>
8112eb10:	982fd7fa 	srai	r23,r19,31
8112eb14:	9829883a 	mov	r20,r19
8112eb18:	e0004f26 	beq	fp,zero,8112ec58 <_strtoll_r+0x1dc>
8112eb1c:	0017883a 	mov	r11,zero
8112eb20:	02a00034 	movhi	r10,32768
8112eb24:	5809883a 	mov	r4,r11
8112eb28:	500b883a 	mov	r5,r10
8112eb2c:	a00d883a 	mov	r6,r20
8112eb30:	b80f883a 	mov	r7,r23
8112eb34:	da800215 	stw	r10,8(sp)
8112eb38:	dac00115 	stw	r11,4(sp)
8112eb3c:	113379c0 	call	8113379c <__umoddi3>
8112eb40:	dac00117 	ldw	r11,4(sp)
8112eb44:	da800217 	ldw	r10,8(sp)
8112eb48:	a00d883a 	mov	r6,r20
8112eb4c:	5809883a 	mov	r4,r11
8112eb50:	500b883a 	mov	r5,r10
8112eb54:	b80f883a 	mov	r7,r23
8112eb58:	d8800115 	stw	r2,4(sp)
8112eb5c:	113321c0 	call	8113321c <__udivdi3>
8112eb60:	9409883a 	add	r4,r18,r16
8112eb64:	21000043 	ldbu	r4,1(r4)
8112eb68:	1019883a 	mov	r12,r2
8112eb6c:	880b883a 	mov	r5,r17
8112eb70:	2240010c 	andi	r9,r4,4
8112eb74:	0015883a 	mov	r10,zero
8112eb78:	000d883a 	mov	r6,zero
8112eb7c:	000f883a 	mov	r7,zero
8112eb80:	03400044 	movi	r13,1
8112eb84:	02ffffc4 	movi	r11,-1
8112eb88:	da000117 	ldw	r8,4(sp)
8112eb8c:	48000d26 	beq	r9,zero,8112ebc4 <_strtoll_r+0x148>
8112eb90:	843ff404 	addi	r16,r16,-48
8112eb94:	84c0110e 	bge	r16,r19,8112ebdc <_strtoll_r+0x160>
8112eb98:	52c00426 	beq	r10,r11,8112ebac <_strtoll_r+0x130>
8112eb9c:	19c00236 	bltu	r3,r7,8112eba8 <_strtoll_r+0x12c>
8112eba0:	38c0311e 	bne	r7,r3,8112ec68 <_strtoll_r+0x1ec>
8112eba4:	6180302e 	bgeu	r12,r6,8112ec68 <_strtoll_r+0x1ec>
8112eba8:	02bfffc4 	movi	r10,-1
8112ebac:	2c000003 	ldbu	r16,0(r5)
8112ebb0:	29400044 	addi	r5,r5,1
8112ebb4:	9409883a 	add	r4,r18,r16
8112ebb8:	21000043 	ldbu	r4,1(r4)
8112ebbc:	2240010c 	andi	r9,r4,4
8112ebc0:	483ff31e 	bne	r9,zero,8112eb90 <__reset+0xfb10eb90>
8112ebc4:	210000cc 	andi	r4,r4,3
8112ebc8:	20000426 	beq	r4,zero,8112ebdc <_strtoll_r+0x160>
8112ebcc:	23403426 	beq	r4,r13,8112eca0 <_strtoll_r+0x224>
8112ebd0:	008015c4 	movi	r2,87
8112ebd4:	80a1c83a 	sub	r16,r16,r2
8112ebd8:	84ffef16 	blt	r16,r19,8112eb98 <__reset+0xfb10eb98>
8112ebdc:	00bfffc4 	movi	r2,-1
8112ebe0:	50803426 	beq	r10,r2,8112ecb4 <_strtoll_r+0x238>
8112ebe4:	e0000426 	beq	fp,zero,8112ebf8 <_strtoll_r+0x17c>
8112ebe8:	018dc83a 	sub	r6,zero,r6
8112ebec:	3004c03a 	cmpne	r2,r6,zero
8112ebf0:	01e1c83a 	sub	r16,zero,r7
8112ebf4:	808fc83a 	sub	r7,r16,r2
8112ebf8:	3005883a 	mov	r2,r6
8112ebfc:	3807883a 	mov	r3,r7
8112ec00:	a8000326 	beq	r21,zero,8112ec10 <_strtoll_r+0x194>
8112ec04:	5000321e 	bne	r10,zero,8112ecd0 <_strtoll_r+0x254>
8112ec08:	b00b883a 	mov	r5,r22
8112ec0c:	a9400015 	stw	r5,0(r21)
8112ec10:	dfc00c17 	ldw	ra,48(sp)
8112ec14:	df000b17 	ldw	fp,44(sp)
8112ec18:	ddc00a17 	ldw	r23,40(sp)
8112ec1c:	dd800917 	ldw	r22,36(sp)
8112ec20:	dd400817 	ldw	r21,32(sp)
8112ec24:	dd000717 	ldw	r20,28(sp)
8112ec28:	dcc00617 	ldw	r19,24(sp)
8112ec2c:	dc800517 	ldw	r18,20(sp)
8112ec30:	dc400417 	ldw	r17,16(sp)
8112ec34:	dc000317 	ldw	r16,12(sp)
8112ec38:	dec00d04 	addi	sp,sp,52
8112ec3c:	f800283a 	ret
8112ec40:	00800c04 	movi	r2,48
8112ec44:	80802c26 	beq	r16,r2,8112ecf8 <_strtoll_r+0x27c>
8112ec48:	05000284 	movi	r20,10
8112ec4c:	002f883a 	mov	r23,zero
8112ec50:	a027883a 	mov	r19,r20
8112ec54:	e03fb11e 	bne	fp,zero,8112eb1c <__reset+0xfb10eb1c>
8112ec58:	02a00034 	movhi	r10,32768
8112ec5c:	52bfffc4 	addi	r10,r10,-1
8112ec60:	02ffffc4 	movi	r11,-1
8112ec64:	003faf06 	br	8112eb24 <__reset+0xfb10eb24>
8112ec68:	33000f26 	beq	r6,r12,8112eca8 <_strtoll_r+0x22c>
8112ec6c:	b985383a 	mul	r2,r23,r6
8112ec70:	3d0f383a 	mul	r7,r7,r20
8112ec74:	3508383a 	mulxuu	r4,r6,r20
8112ec78:	350d383a 	mul	r6,r6,r20
8112ec7c:	8013d7fa 	srai	r9,r16,31
8112ec80:	388f883a 	add	r7,r7,r2
8112ec84:	818d883a 	add	r6,r16,r6
8112ec88:	390f883a 	add	r7,r7,r4
8112ec8c:	3421803a 	cmpltu	r16,r6,r16
8112ec90:	49cf883a 	add	r7,r9,r7
8112ec94:	81cf883a 	add	r7,r16,r7
8112ec98:	02800044 	movi	r10,1
8112ec9c:	003fc306 	br	8112ebac <__reset+0xfb10ebac>
8112eca0:	00800dc4 	movi	r2,55
8112eca4:	003fcb06 	br	8112ebd4 <__reset+0xfb10ebd4>
8112eca8:	38fff01e 	bne	r7,r3,8112ec6c <__reset+0xfb10ec6c>
8112ecac:	443fbe16 	blt	r8,r16,8112eba8 <__reset+0xfb10eba8>
8112ecb0:	003fee06 	br	8112ec6c <__reset+0xfb10ec6c>
8112ecb4:	e0002426 	beq	fp,zero,8112ed48 <_strtoll_r+0x2cc>
8112ecb8:	0005883a 	mov	r2,zero
8112ecbc:	00e00034 	movhi	r3,32768
8112ecc0:	d9800017 	ldw	r6,0(sp)
8112ecc4:	01000884 	movi	r4,34
8112ecc8:	31000015 	stw	r4,0(r6)
8112eccc:	a83fd026 	beq	r21,zero,8112ec10 <__reset+0xfb10ec10>
8112ecd0:	297fffc4 	addi	r5,r5,-1
8112ecd4:	003fcd06 	br	8112ec0c <__reset+0xfb10ec0c>
8112ecd8:	1c400084 	addi	r17,r3,2
8112ecdc:	1c000043 	ldbu	r16,1(r3)
8112ece0:	07000044 	movi	fp,1
8112ece4:	003f8706 	br	8112eb04 <__reset+0xfb10eb04>
8112ece8:	1c400084 	addi	r17,r3,2
8112ecec:	1c000043 	ldbu	r16,1(r3)
8112ecf0:	0039883a 	mov	fp,zero
8112ecf4:	003f8306 	br	8112eb04 <__reset+0xfb10eb04>
8112ecf8:	88800003 	ldbu	r2,0(r17)
8112ecfc:	00c01604 	movi	r3,88
8112ed00:	108037cc 	andi	r2,r2,223
8112ed04:	10c00a26 	beq	r2,r3,8112ed30 <_strtoll_r+0x2b4>
8112ed08:	05000204 	movi	r20,8
8112ed0c:	002f883a 	mov	r23,zero
8112ed10:	a027883a 	mov	r19,r20
8112ed14:	003f8006 	br	8112eb18 <__reset+0xfb10eb18>
8112ed18:	00800c04 	movi	r2,48
8112ed1c:	80800e1e 	bne	r16,r2,8112ed58 <_strtoll_r+0x2dc>
8112ed20:	88800003 	ldbu	r2,0(r17)
8112ed24:	00c01604 	movi	r3,88
8112ed28:	108037cc 	andi	r2,r2,223
8112ed2c:	10c00a1e 	bne	r2,r3,8112ed58 <_strtoll_r+0x2dc>
8112ed30:	05000404 	movi	r20,16
8112ed34:	8c000043 	ldbu	r16,1(r17)
8112ed38:	002f883a 	mov	r23,zero
8112ed3c:	8c400084 	addi	r17,r17,2
8112ed40:	a027883a 	mov	r19,r20
8112ed44:	003f7406 	br	8112eb18 <__reset+0xfb10eb18>
8112ed48:	00e00034 	movhi	r3,32768
8112ed4c:	18ffffc4 	addi	r3,r3,-1
8112ed50:	5005883a 	mov	r2,r10
8112ed54:	003fda06 	br	8112ecc0 <__reset+0xfb10ecc0>
8112ed58:	9829883a 	mov	r20,r19
8112ed5c:	002f883a 	mov	r23,zero
8112ed60:	003f6d06 	br	8112eb18 <__reset+0xfb10eb18>

8112ed64 <_strtoul_r>:
8112ed64:	00a04574 	movhi	r2,33045
8112ed68:	defff604 	addi	sp,sp,-40
8112ed6c:	10886704 	addi	r2,r2,8604
8112ed70:	de00012e 	bgeu	sp,et,8112ed78 <_strtoul_r+0x14>
8112ed74:	003b68fa 	trap	3
8112ed78:	dc800315 	stw	r18,12(sp)
8112ed7c:	14800017 	ldw	r18,0(r2)
8112ed80:	dd400615 	stw	r21,24(sp)
8112ed84:	dd000515 	stw	r20,20(sp)
8112ed88:	dcc00415 	stw	r19,16(sp)
8112ed8c:	2029883a 	mov	r20,r4
8112ed90:	dfc00915 	stw	ra,36(sp)
8112ed94:	ddc00815 	stw	r23,32(sp)
8112ed98:	dd800715 	stw	r22,28(sp)
8112ed9c:	dc400215 	stw	r17,8(sp)
8112eda0:	dc000115 	stw	r16,4(sp)
8112eda4:	2827883a 	mov	r19,r5
8112eda8:	382b883a 	mov	r21,r7
8112edac:	2809883a 	mov	r4,r5
8112edb0:	24000003 	ldbu	r16,0(r4)
8112edb4:	24400044 	addi	r17,r4,1
8112edb8:	2007883a 	mov	r3,r4
8112edbc:	9405883a 	add	r2,r18,r16
8112edc0:	10800043 	ldbu	r2,1(r2)
8112edc4:	8809883a 	mov	r4,r17
8112edc8:	1080020c 	andi	r2,r2,8
8112edcc:	103ff81e 	bne	r2,zero,8112edb0 <__reset+0xfb10edb0>
8112edd0:	00800b44 	movi	r2,45
8112edd4:	80805326 	beq	r16,r2,8112ef24 <_strtoul_r+0x1c0>
8112edd8:	00800ac4 	movi	r2,43
8112eddc:	80805526 	beq	r16,r2,8112ef34 <_strtoul_r+0x1d0>
8112ede0:	002f883a 	mov	r23,zero
8112ede4:	a8000f26 	beq	r21,zero,8112ee24 <_strtoul_r+0xc0>
8112ede8:	00800404 	movi	r2,16
8112edec:	a8805f26 	beq	r21,r2,8112ef6c <_strtoul_r+0x208>
8112edf0:	013fffc4 	movi	r4,-1
8112edf4:	a80b883a 	mov	r5,r21
8112edf8:	d9800015 	stw	r6,0(sp)
8112edfc:	1133dd40 	call	81133dd4 <__udivsi3>
8112ee00:	a80b883a 	mov	r5,r21
8112ee04:	013fffc4 	movi	r4,-1
8112ee08:	102d883a 	mov	r22,r2
8112ee0c:	1133e380 	call	81133e38 <__umodsi3>
8112ee10:	d9800017 	ldw	r6,0(sp)
8112ee14:	1019883a 	mov	r12,r2
8112ee18:	a817883a 	mov	r11,r21
8112ee1c:	b00f883a 	mov	r7,r22
8112ee20:	00000706 	br	8112ee40 <_strtoul_r+0xdc>
8112ee24:	00800c04 	movi	r2,48
8112ee28:	80804626 	beq	r16,r2,8112ef44 <_strtoul_r+0x1e0>
8112ee2c:	05400284 	movi	r21,10
8112ee30:	01c666b4 	movhi	r7,6554
8112ee34:	03000144 	movi	r12,5
8112ee38:	39e66644 	addi	r7,r7,-26215
8112ee3c:	a817883a 	mov	r11,r21
8112ee40:	9407883a 	add	r3,r18,r16
8112ee44:	18c00043 	ldbu	r3,1(r3)
8112ee48:	8809883a 	mov	r4,r17
8112ee4c:	0011883a 	mov	r8,zero
8112ee50:	1940010c 	andi	r5,r3,4
8112ee54:	0005883a 	mov	r2,zero
8112ee58:	02800044 	movi	r10,1
8112ee5c:	027fffc4 	movi	r9,-1
8112ee60:	28000e26 	beq	r5,zero,8112ee9c <_strtoul_r+0x138>
8112ee64:	843ff404 	addi	r16,r16,-48
8112ee68:	8540120e 	bge	r16,r21,8112eeb4 <_strtoul_r+0x150>
8112ee6c:	42400526 	beq	r8,r9,8112ee84 <_strtoul_r+0x120>
8112ee70:	38802236 	bltu	r7,r2,8112eefc <_strtoul_r+0x198>
8112ee74:	11c02026 	beq	r2,r7,8112eef8 <_strtoul_r+0x194>
8112ee78:	12c5383a 	mul	r2,r2,r11
8112ee7c:	02000044 	movi	r8,1
8112ee80:	8085883a 	add	r2,r16,r2
8112ee84:	24000003 	ldbu	r16,0(r4)
8112ee88:	21000044 	addi	r4,r4,1
8112ee8c:	9407883a 	add	r3,r18,r16
8112ee90:	18c00043 	ldbu	r3,1(r3)
8112ee94:	1940010c 	andi	r5,r3,4
8112ee98:	283ff21e 	bne	r5,zero,8112ee64 <__reset+0xfb10ee64>
8112ee9c:	18c000cc 	andi	r3,r3,3
8112eea0:	18000426 	beq	r3,zero,8112eeb4 <_strtoul_r+0x150>
8112eea4:	1a801726 	beq	r3,r10,8112ef04 <_strtoul_r+0x1a0>
8112eea8:	00c015c4 	movi	r3,87
8112eeac:	80e1c83a 	sub	r16,r16,r3
8112eeb0:	857fee16 	blt	r16,r21,8112ee6c <__reset+0xfb10ee6c>
8112eeb4:	40001516 	blt	r8,zero,8112ef0c <_strtoul_r+0x1a8>
8112eeb8:	b8000126 	beq	r23,zero,8112eec0 <_strtoul_r+0x15c>
8112eebc:	0085c83a 	sub	r2,zero,r2
8112eec0:	30000226 	beq	r6,zero,8112eecc <_strtoul_r+0x168>
8112eec4:	4000151e 	bne	r8,zero,8112ef1c <_strtoul_r+0x1b8>
8112eec8:	34c00015 	stw	r19,0(r6)
8112eecc:	dfc00917 	ldw	ra,36(sp)
8112eed0:	ddc00817 	ldw	r23,32(sp)
8112eed4:	dd800717 	ldw	r22,28(sp)
8112eed8:	dd400617 	ldw	r21,24(sp)
8112eedc:	dd000517 	ldw	r20,20(sp)
8112eee0:	dcc00417 	ldw	r19,16(sp)
8112eee4:	dc800317 	ldw	r18,12(sp)
8112eee8:	dc400217 	ldw	r17,8(sp)
8112eeec:	dc000117 	ldw	r16,4(sp)
8112eef0:	dec00a04 	addi	sp,sp,40
8112eef4:	f800283a 	ret
8112eef8:	643fdf0e 	bge	r12,r16,8112ee78 <__reset+0xfb10ee78>
8112eefc:	023fffc4 	movi	r8,-1
8112ef00:	003fe006 	br	8112ee84 <__reset+0xfb10ee84>
8112ef04:	00c00dc4 	movi	r3,55
8112ef08:	003fe806 	br	8112eeac <__reset+0xfb10eeac>
8112ef0c:	00800884 	movi	r2,34
8112ef10:	a0800015 	stw	r2,0(r20)
8112ef14:	00bfffc4 	movi	r2,-1
8112ef18:	303fec26 	beq	r6,zero,8112eecc <__reset+0xfb10eecc>
8112ef1c:	24ffffc4 	addi	r19,r4,-1
8112ef20:	003fe906 	br	8112eec8 <__reset+0xfb10eec8>
8112ef24:	1c400084 	addi	r17,r3,2
8112ef28:	1c000043 	ldbu	r16,1(r3)
8112ef2c:	05c00044 	movi	r23,1
8112ef30:	003fac06 	br	8112ede4 <__reset+0xfb10ede4>
8112ef34:	1c400084 	addi	r17,r3,2
8112ef38:	1c000043 	ldbu	r16,1(r3)
8112ef3c:	002f883a 	mov	r23,zero
8112ef40:	003fa806 	br	8112ede4 <__reset+0xfb10ede4>
8112ef44:	88800003 	ldbu	r2,0(r17)
8112ef48:	00c01604 	movi	r3,88
8112ef4c:	108037cc 	andi	r2,r2,223
8112ef50:	10c00c26 	beq	r2,r3,8112ef84 <_strtoul_r+0x220>
8112ef54:	05400204 	movi	r21,8
8112ef58:	01c80034 	movhi	r7,8192
8112ef5c:	030001c4 	movi	r12,7
8112ef60:	39ffffc4 	addi	r7,r7,-1
8112ef64:	a817883a 	mov	r11,r21
8112ef68:	003fb506 	br	8112ee40 <__reset+0xfb10ee40>
8112ef6c:	00800c04 	movi	r2,48
8112ef70:	80800c1e 	bne	r16,r2,8112efa4 <_strtoul_r+0x240>
8112ef74:	88800003 	ldbu	r2,0(r17)
8112ef78:	00c01604 	movi	r3,88
8112ef7c:	108037cc 	andi	r2,r2,223
8112ef80:	10c0081e 	bne	r2,r3,8112efa4 <_strtoul_r+0x240>
8112ef84:	02c00404 	movi	r11,16
8112ef88:	05840034 	movhi	r22,4096
8112ef8c:	8c000043 	ldbu	r16,1(r17)
8112ef90:	030003c4 	movi	r12,15
8112ef94:	8c400084 	addi	r17,r17,2
8112ef98:	b5bfffc4 	addi	r22,r22,-1
8112ef9c:	582b883a 	mov	r21,r11
8112efa0:	003f9e06 	br	8112ee1c <__reset+0xfb10ee1c>
8112efa4:	01c40034 	movhi	r7,4096
8112efa8:	030003c4 	movi	r12,15
8112efac:	39ffffc4 	addi	r7,r7,-1
8112efb0:	a817883a 	mov	r11,r21
8112efb4:	003fa206 	br	8112ee40 <__reset+0xfb10ee40>

8112efb8 <strtoul>:
8112efb8:	00a04574 	movhi	r2,33045
8112efbc:	10886904 	addi	r2,r2,8612
8112efc0:	300f883a 	mov	r7,r6
8112efc4:	280d883a 	mov	r6,r5
8112efc8:	200b883a 	mov	r5,r4
8112efcc:	11000017 	ldw	r4,0(r2)
8112efd0:	112ed641 	jmpi	8112ed64 <_strtoul_r>

8112efd4 <_strtoull_r>:
8112efd4:	00a04574 	movhi	r2,33045
8112efd8:	defff404 	addi	sp,sp,-48
8112efdc:	10886704 	addi	r2,r2,8604
8112efe0:	de00012e 	bgeu	sp,et,8112efe8 <_strtoull_r+0x14>
8112efe4:	003b68fa 	trap	3
8112efe8:	dc400315 	stw	r17,12(sp)
8112efec:	14400017 	ldw	r17,0(r2)
8112eff0:	dd400715 	stw	r21,28(sp)
8112eff4:	dd000615 	stw	r20,24(sp)
8112eff8:	dcc00515 	stw	r19,20(sp)
8112effc:	dc800415 	stw	r18,16(sp)
8112f000:	dfc00b15 	stw	ra,44(sp)
8112f004:	df000a15 	stw	fp,40(sp)
8112f008:	ddc00915 	stw	r23,36(sp)
8112f00c:	dd800815 	stw	r22,32(sp)
8112f010:	dc000215 	stw	r16,8(sp)
8112f014:	2827883a 	mov	r19,r5
8112f018:	202b883a 	mov	r21,r4
8112f01c:	3029883a 	mov	r20,r6
8112f020:	3825883a 	mov	r18,r7
8112f024:	2807883a 	mov	r3,r5
8112f028:	1c000003 	ldbu	r16,0(r3)
8112f02c:	1f000044 	addi	fp,r3,1
8112f030:	1809883a 	mov	r4,r3
8112f034:	8c05883a 	add	r2,r17,r16
8112f038:	10800043 	ldbu	r2,1(r2)
8112f03c:	e007883a 	mov	r3,fp
8112f040:	1080020c 	andi	r2,r2,8
8112f044:	103ff81e 	bne	r2,zero,8112f028 <__reset+0xfb10f028>
8112f048:	00800b44 	movi	r2,45
8112f04c:	80806e26 	beq	r16,r2,8112f208 <_strtoull_r+0x234>
8112f050:	00800ac4 	movi	r2,43
8112f054:	80807026 	beq	r16,r2,8112f218 <_strtoull_r+0x244>
8112f058:	002f883a 	mov	r23,zero
8112f05c:	90001426 	beq	r18,zero,8112f0b0 <_strtoull_r+0xdc>
8112f060:	00800404 	movi	r2,16
8112f064:	90807c26 	beq	r18,r2,8112f258 <_strtoull_r+0x284>
8112f068:	902dd7fa 	srai	r22,r18,31
8112f06c:	013fffc4 	movi	r4,-1
8112f070:	200b883a 	mov	r5,r4
8112f074:	900d883a 	mov	r6,r18
8112f078:	b00f883a 	mov	r7,r22
8112f07c:	113321c0 	call	8113321c <__udivdi3>
8112f080:	013fffc4 	movi	r4,-1
8112f084:	900d883a 	mov	r6,r18
8112f088:	b00f883a 	mov	r7,r22
8112f08c:	200b883a 	mov	r5,r4
8112f090:	d8c00115 	stw	r3,4(sp)
8112f094:	d8800015 	stw	r2,0(sp)
8112f098:	113379c0 	call	8113379c <__umoddi3>
8112f09c:	101b883a 	mov	r13,r2
8112f0a0:	9015883a 	mov	r10,r18
8112f0a4:	dac00017 	ldw	r11,0(sp)
8112f0a8:	da000117 	ldw	r8,4(sp)
8112f0ac:	00000a06 	br	8112f0d8 <_strtoull_r+0x104>
8112f0b0:	00800c04 	movi	r2,48
8112f0b4:	80805c26 	beq	r16,r2,8112f228 <_strtoull_r+0x254>
8112f0b8:	02800284 	movi	r10,10
8112f0bc:	02e666b4 	movhi	r11,39322
8112f0c0:	020666b4 	movhi	r8,6554
8112f0c4:	03400144 	movi	r13,5
8112f0c8:	5ae66644 	addi	r11,r11,-26215
8112f0cc:	42266644 	addi	r8,r8,-26215
8112f0d0:	002d883a 	mov	r22,zero
8112f0d4:	5025883a 	mov	r18,r10
8112f0d8:	8c0b883a 	add	r5,r17,r16
8112f0dc:	29400043 	ldbu	r5,1(r5)
8112f0e0:	e009883a 	mov	r4,fp
8112f0e4:	000f883a 	mov	r7,zero
8112f0e8:	2980010c 	andi	r6,r5,4
8112f0ec:	0005883a 	mov	r2,zero
8112f0f0:	0007883a 	mov	r3,zero
8112f0f4:	03000044 	movi	r12,1
8112f0f8:	027fffc4 	movi	r9,-1
8112f0fc:	30000d26 	beq	r6,zero,8112f134 <_strtoull_r+0x160>
8112f100:	843ff404 	addi	r16,r16,-48
8112f104:	8480110e 	bge	r16,r18,8112f14c <_strtoull_r+0x178>
8112f108:	3a400426 	beq	r7,r9,8112f11c <_strtoull_r+0x148>
8112f10c:	40c00236 	bltu	r8,r3,8112f118 <_strtoull_r+0x144>
8112f110:	1a00231e 	bne	r3,r8,8112f1a0 <_strtoull_r+0x1cc>
8112f114:	5880222e 	bgeu	r11,r2,8112f1a0 <_strtoull_r+0x1cc>
8112f118:	01ffffc4 	movi	r7,-1
8112f11c:	24000003 	ldbu	r16,0(r4)
8112f120:	21000044 	addi	r4,r4,1
8112f124:	8c0b883a 	add	r5,r17,r16
8112f128:	29400043 	ldbu	r5,1(r5)
8112f12c:	2980010c 	andi	r6,r5,4
8112f130:	303ff31e 	bne	r6,zero,8112f100 <__reset+0xfb10f100>
8112f134:	294000cc 	andi	r5,r5,3
8112f138:	28000426 	beq	r5,zero,8112f14c <_strtoull_r+0x178>
8112f13c:	2b002626 	beq	r5,r12,8112f1d8 <_strtoull_r+0x204>
8112f140:	014015c4 	movi	r5,87
8112f144:	8161c83a 	sub	r16,r16,r5
8112f148:	84bfef16 	blt	r16,r18,8112f108 <__reset+0xfb10f108>
8112f14c:	38002716 	blt	r7,zero,8112f1ec <_strtoull_r+0x218>
8112f150:	b8000426 	beq	r23,zero,8112f164 <_strtoull_r+0x190>
8112f154:	0085c83a 	sub	r2,zero,r2
8112f158:	100ac03a 	cmpne	r5,r2,zero
8112f15c:	00e1c83a 	sub	r16,zero,r3
8112f160:	8147c83a 	sub	r3,r16,r5
8112f164:	a0000226 	beq	r20,zero,8112f170 <_strtoull_r+0x19c>
8112f168:	3800251e 	bne	r7,zero,8112f200 <_strtoull_r+0x22c>
8112f16c:	a4c00015 	stw	r19,0(r20)
8112f170:	dfc00b17 	ldw	ra,44(sp)
8112f174:	df000a17 	ldw	fp,40(sp)
8112f178:	ddc00917 	ldw	r23,36(sp)
8112f17c:	dd800817 	ldw	r22,32(sp)
8112f180:	dd400717 	ldw	r21,28(sp)
8112f184:	dd000617 	ldw	r20,24(sp)
8112f188:	dcc00517 	ldw	r19,20(sp)
8112f18c:	dc800417 	ldw	r18,16(sp)
8112f190:	dc400317 	ldw	r17,12(sp)
8112f194:	dc000217 	ldw	r16,8(sp)
8112f198:	dec00c04 	addi	sp,sp,48
8112f19c:	f800283a 	ret
8112f1a0:	12c00f26 	beq	r2,r11,8112f1e0 <_strtoull_r+0x20c>
8112f1a4:	b08d383a 	mul	r6,r22,r2
8112f1a8:	1a87383a 	mul	r3,r3,r10
8112f1ac:	128a383a 	mulxuu	r5,r2,r10
8112f1b0:	1285383a 	mul	r2,r2,r10
8112f1b4:	800fd7fa 	srai	r7,r16,31
8112f1b8:	1987883a 	add	r3,r3,r6
8112f1bc:	8085883a 	add	r2,r16,r2
8112f1c0:	1947883a 	add	r3,r3,r5
8112f1c4:	38c7883a 	add	r3,r7,r3
8112f1c8:	1421803a 	cmpltu	r16,r2,r16
8112f1cc:	80c7883a 	add	r3,r16,r3
8112f1d0:	01c00044 	movi	r7,1
8112f1d4:	003fd106 	br	8112f11c <__reset+0xfb10f11c>
8112f1d8:	01400dc4 	movi	r5,55
8112f1dc:	003fd906 	br	8112f144 <__reset+0xfb10f144>
8112f1e0:	1a3ff01e 	bne	r3,r8,8112f1a4 <__reset+0xfb10f1a4>
8112f1e4:	6c3fcc16 	blt	r13,r16,8112f118 <__reset+0xfb10f118>
8112f1e8:	003fee06 	br	8112f1a4 <__reset+0xfb10f1a4>
8112f1ec:	00800884 	movi	r2,34
8112f1f0:	a8800015 	stw	r2,0(r21)
8112f1f4:	00bfffc4 	movi	r2,-1
8112f1f8:	1007883a 	mov	r3,r2
8112f1fc:	a03fdc26 	beq	r20,zero,8112f170 <__reset+0xfb10f170>
8112f200:	24ffffc4 	addi	r19,r4,-1
8112f204:	003fd906 	br	8112f16c <__reset+0xfb10f16c>
8112f208:	27000084 	addi	fp,r4,2
8112f20c:	24000043 	ldbu	r16,1(r4)
8112f210:	05c00044 	movi	r23,1
8112f214:	003f9106 	br	8112f05c <__reset+0xfb10f05c>
8112f218:	27000084 	addi	fp,r4,2
8112f21c:	24000043 	ldbu	r16,1(r4)
8112f220:	002f883a 	mov	r23,zero
8112f224:	003f8d06 	br	8112f05c <__reset+0xfb10f05c>
8112f228:	e0800003 	ldbu	r2,0(fp)
8112f22c:	00c01604 	movi	r3,88
8112f230:	108037cc 	andi	r2,r2,223
8112f234:	10c00e26 	beq	r2,r3,8112f270 <_strtoull_r+0x29c>
8112f238:	02800204 	movi	r10,8
8112f23c:	02ffffc4 	movi	r11,-1
8112f240:	02080034 	movhi	r8,8192
8112f244:	034001c4 	movi	r13,7
8112f248:	42d1883a 	add	r8,r8,r11
8112f24c:	002d883a 	mov	r22,zero
8112f250:	5025883a 	mov	r18,r10
8112f254:	003fa006 	br	8112f0d8 <__reset+0xfb10f0d8>
8112f258:	00800c04 	movi	r2,48
8112f25c:	80800e1e 	bne	r16,r2,8112f298 <_strtoull_r+0x2c4>
8112f260:	e0800003 	ldbu	r2,0(fp)
8112f264:	00c01604 	movi	r3,88
8112f268:	108037cc 	andi	r2,r2,223
8112f26c:	10c00a1e 	bne	r2,r3,8112f298 <_strtoull_r+0x2c4>
8112f270:	02800404 	movi	r10,16
8112f274:	02ffffc4 	movi	r11,-1
8112f278:	02040034 	movhi	r8,4096
8112f27c:	e4000043 	ldbu	r16,1(fp)
8112f280:	034003c4 	movi	r13,15
8112f284:	e7000084 	addi	fp,fp,2
8112f288:	42d1883a 	add	r8,r8,r11
8112f28c:	002d883a 	mov	r22,zero
8112f290:	5025883a 	mov	r18,r10
8112f294:	003f9006 	br	8112f0d8 <__reset+0xfb10f0d8>
8112f298:	02ffffc4 	movi	r11,-1
8112f29c:	02040034 	movhi	r8,4096
8112f2a0:	034003c4 	movi	r13,15
8112f2a4:	42d1883a 	add	r8,r8,r11
8112f2a8:	9015883a 	mov	r10,r18
8112f2ac:	002d883a 	mov	r22,zero
8112f2b0:	003f8906 	br	8112f0d8 <__reset+0xfb10f0d8>

8112f2b4 <__ssprint_r>:
8112f2b4:	defff604 	addi	sp,sp,-40
8112f2b8:	de00012e 	bgeu	sp,et,8112f2c0 <__ssprint_r+0xc>
8112f2bc:	003b68fa 	trap	3
8112f2c0:	30800217 	ldw	r2,8(r6)
8112f2c4:	dc800215 	stw	r18,8(sp)
8112f2c8:	dfc00915 	stw	ra,36(sp)
8112f2cc:	df000815 	stw	fp,32(sp)
8112f2d0:	ddc00715 	stw	r23,28(sp)
8112f2d4:	dd800615 	stw	r22,24(sp)
8112f2d8:	dd400515 	stw	r21,20(sp)
8112f2dc:	dd000415 	stw	r20,16(sp)
8112f2e0:	dcc00315 	stw	r19,12(sp)
8112f2e4:	dc400115 	stw	r17,4(sp)
8112f2e8:	dc000015 	stw	r16,0(sp)
8112f2ec:	3025883a 	mov	r18,r6
8112f2f0:	10005826 	beq	r2,zero,8112f454 <__ssprint_r+0x1a0>
8112f2f4:	2027883a 	mov	r19,r4
8112f2f8:	35c00017 	ldw	r23,0(r6)
8112f2fc:	29000017 	ldw	r4,0(r5)
8112f300:	28800217 	ldw	r2,8(r5)
8112f304:	2823883a 	mov	r17,r5
8112f308:	0039883a 	mov	fp,zero
8112f30c:	0021883a 	mov	r16,zero
8112f310:	80003926 	beq	r16,zero,8112f3f8 <__ssprint_r+0x144>
8112f314:	102b883a 	mov	r21,r2
8112f318:	102d883a 	mov	r22,r2
8112f31c:	80803a36 	bltu	r16,r2,8112f408 <__ssprint_r+0x154>
8112f320:	88c0030b 	ldhu	r3,12(r17)
8112f324:	1881200c 	andi	r2,r3,1152
8112f328:	10002626 	beq	r2,zero,8112f3c4 <__ssprint_r+0x110>
8112f32c:	88800517 	ldw	r2,20(r17)
8112f330:	89400417 	ldw	r5,16(r17)
8112f334:	81800044 	addi	r6,r16,1
8112f338:	108f883a 	add	r7,r2,r2
8112f33c:	3885883a 	add	r2,r7,r2
8112f340:	100ed7fa 	srli	r7,r2,31
8112f344:	216dc83a 	sub	r22,r4,r5
8112f348:	3589883a 	add	r4,r6,r22
8112f34c:	3885883a 	add	r2,r7,r2
8112f350:	102bd07a 	srai	r21,r2,1
8112f354:	a80d883a 	mov	r6,r21
8112f358:	a900022e 	bgeu	r21,r4,8112f364 <__ssprint_r+0xb0>
8112f35c:	202b883a 	mov	r21,r4
8112f360:	200d883a 	mov	r6,r4
8112f364:	18c1000c 	andi	r3,r3,1024
8112f368:	18002a26 	beq	r3,zero,8112f414 <__ssprint_r+0x160>
8112f36c:	300b883a 	mov	r5,r6
8112f370:	9809883a 	mov	r4,r19
8112f374:	11210540 	call	81121054 <_malloc_r>
8112f378:	1029883a 	mov	r20,r2
8112f37c:	10002c26 	beq	r2,zero,8112f430 <__ssprint_r+0x17c>
8112f380:	89400417 	ldw	r5,16(r17)
8112f384:	b00d883a 	mov	r6,r22
8112f388:	1009883a 	mov	r4,r2
8112f38c:	11218680 	call	81121868 <memcpy>
8112f390:	8880030b 	ldhu	r2,12(r17)
8112f394:	00fedfc4 	movi	r3,-1153
8112f398:	10c4703a 	and	r2,r2,r3
8112f39c:	10802014 	ori	r2,r2,128
8112f3a0:	8880030d 	sth	r2,12(r17)
8112f3a4:	a589883a 	add	r4,r20,r22
8112f3a8:	adadc83a 	sub	r22,r21,r22
8112f3ac:	8d400515 	stw	r21,20(r17)
8112f3b0:	8d800215 	stw	r22,8(r17)
8112f3b4:	8d000415 	stw	r20,16(r17)
8112f3b8:	89000015 	stw	r4,0(r17)
8112f3bc:	802b883a 	mov	r21,r16
8112f3c0:	802d883a 	mov	r22,r16
8112f3c4:	b00d883a 	mov	r6,r22
8112f3c8:	e00b883a 	mov	r5,fp
8112f3cc:	112b93c0 	call	8112b93c <memmove>
8112f3d0:	88800217 	ldw	r2,8(r17)
8112f3d4:	89000017 	ldw	r4,0(r17)
8112f3d8:	90c00217 	ldw	r3,8(r18)
8112f3dc:	1545c83a 	sub	r2,r2,r21
8112f3e0:	2589883a 	add	r4,r4,r22
8112f3e4:	88800215 	stw	r2,8(r17)
8112f3e8:	89000015 	stw	r4,0(r17)
8112f3ec:	1c21c83a 	sub	r16,r3,r16
8112f3f0:	94000215 	stw	r16,8(r18)
8112f3f4:	80001726 	beq	r16,zero,8112f454 <__ssprint_r+0x1a0>
8112f3f8:	bf000017 	ldw	fp,0(r23)
8112f3fc:	bc000117 	ldw	r16,4(r23)
8112f400:	bdc00204 	addi	r23,r23,8
8112f404:	003fc206 	br	8112f310 <__reset+0xfb10f310>
8112f408:	802b883a 	mov	r21,r16
8112f40c:	802d883a 	mov	r22,r16
8112f410:	003fec06 	br	8112f3c4 <__reset+0xfb10f3c4>
8112f414:	9809883a 	mov	r4,r19
8112f418:	112cb5c0 	call	8112cb5c <_realloc_r>
8112f41c:	1029883a 	mov	r20,r2
8112f420:	103fe01e 	bne	r2,zero,8112f3a4 <__reset+0xfb10f3a4>
8112f424:	89400417 	ldw	r5,16(r17)
8112f428:	9809883a 	mov	r4,r19
8112f42c:	112aac80 	call	8112aac8 <_free_r>
8112f430:	88c0030b 	ldhu	r3,12(r17)
8112f434:	00800304 	movi	r2,12
8112f438:	98800015 	stw	r2,0(r19)
8112f43c:	18c01014 	ori	r3,r3,64
8112f440:	88c0030d 	sth	r3,12(r17)
8112f444:	00bfffc4 	movi	r2,-1
8112f448:	90000215 	stw	zero,8(r18)
8112f44c:	90000115 	stw	zero,4(r18)
8112f450:	00000206 	br	8112f45c <__ssprint_r+0x1a8>
8112f454:	90000115 	stw	zero,4(r18)
8112f458:	0005883a 	mov	r2,zero
8112f45c:	dfc00917 	ldw	ra,36(sp)
8112f460:	df000817 	ldw	fp,32(sp)
8112f464:	ddc00717 	ldw	r23,28(sp)
8112f468:	dd800617 	ldw	r22,24(sp)
8112f46c:	dd400517 	ldw	r21,20(sp)
8112f470:	dd000417 	ldw	r20,16(sp)
8112f474:	dcc00317 	ldw	r19,12(sp)
8112f478:	dc800217 	ldw	r18,8(sp)
8112f47c:	dc400117 	ldw	r17,4(sp)
8112f480:	dc000017 	ldw	r16,0(sp)
8112f484:	dec00a04 	addi	sp,sp,40
8112f488:	f800283a 	ret

8112f48c <___svfiprintf_internal_r>:
8112f48c:	deffc804 	addi	sp,sp,-224
8112f490:	de00012e 	bgeu	sp,et,8112f498 <___svfiprintf_internal_r+0xc>
8112f494:	003b68fa 	trap	3
8112f498:	2880030b 	ldhu	r2,12(r5)
8112f49c:	dcc03115 	stw	r19,196(sp)
8112f4a0:	dfc03715 	stw	ra,220(sp)
8112f4a4:	df003615 	stw	fp,216(sp)
8112f4a8:	ddc03515 	stw	r23,212(sp)
8112f4ac:	dd803415 	stw	r22,208(sp)
8112f4b0:	dd403315 	stw	r21,204(sp)
8112f4b4:	dd003215 	stw	r20,200(sp)
8112f4b8:	dc803015 	stw	r18,192(sp)
8112f4bc:	dc402f15 	stw	r17,188(sp)
8112f4c0:	dc002e15 	stw	r16,184(sp)
8112f4c4:	d9402715 	stw	r5,156(sp)
8112f4c8:	d9002a15 	stw	r4,168(sp)
8112f4cc:	1080200c 	andi	r2,r2,128
8112f4d0:	d9c02315 	stw	r7,140(sp)
8112f4d4:	3027883a 	mov	r19,r6
8112f4d8:	10000226 	beq	r2,zero,8112f4e4 <___svfiprintf_internal_r+0x58>
8112f4dc:	28800417 	ldw	r2,16(r5)
8112f4e0:	10041d26 	beq	r2,zero,81130558 <___svfiprintf_internal_r+0x10cc>
8112f4e4:	dac01a04 	addi	r11,sp,104
8112f4e8:	dac01e15 	stw	r11,120(sp)
8112f4ec:	d8801e17 	ldw	r2,120(sp)
8112f4f0:	dac019c4 	addi	r11,sp,103
8112f4f4:	dd402a17 	ldw	r21,168(sp)
8112f4f8:	ddc02717 	ldw	r23,156(sp)
8112f4fc:	05a04574 	movhi	r22,33045
8112f500:	05204574 	movhi	r20,33045
8112f504:	dac01f15 	stw	r11,124(sp)
8112f508:	12d7c83a 	sub	r11,r2,r11
8112f50c:	b5bf2804 	addi	r22,r22,-864
8112f510:	a53f2404 	addi	r20,r20,-880
8112f514:	dec01a15 	stw	sp,104(sp)
8112f518:	d8001c15 	stw	zero,112(sp)
8112f51c:	d8001b15 	stw	zero,108(sp)
8112f520:	d811883a 	mov	r8,sp
8112f524:	d8002915 	stw	zero,164(sp)
8112f528:	d8002515 	stw	zero,148(sp)
8112f52c:	dac02b15 	stw	r11,172(sp)
8112f530:	98800007 	ldb	r2,0(r19)
8112f534:	1002dd26 	beq	r2,zero,811300ac <___svfiprintf_internal_r+0xc20>
8112f538:	00c00944 	movi	r3,37
8112f53c:	9823883a 	mov	r17,r19
8112f540:	10c0021e 	bne	r2,r3,8112f54c <___svfiprintf_internal_r+0xc0>
8112f544:	00001406 	br	8112f598 <___svfiprintf_internal_r+0x10c>
8112f548:	10c00326 	beq	r2,r3,8112f558 <___svfiprintf_internal_r+0xcc>
8112f54c:	8c400044 	addi	r17,r17,1
8112f550:	88800007 	ldb	r2,0(r17)
8112f554:	103ffc1e 	bne	r2,zero,8112f548 <__reset+0xfb10f548>
8112f558:	8ce1c83a 	sub	r16,r17,r19
8112f55c:	80000e26 	beq	r16,zero,8112f598 <___svfiprintf_internal_r+0x10c>
8112f560:	d8c01c17 	ldw	r3,112(sp)
8112f564:	d8801b17 	ldw	r2,108(sp)
8112f568:	44c00015 	stw	r19,0(r8)
8112f56c:	1c07883a 	add	r3,r3,r16
8112f570:	10800044 	addi	r2,r2,1
8112f574:	d8c01c15 	stw	r3,112(sp)
8112f578:	44000115 	stw	r16,4(r8)
8112f57c:	d8801b15 	stw	r2,108(sp)
8112f580:	00c001c4 	movi	r3,7
8112f584:	18831e16 	blt	r3,r2,81130200 <___svfiprintf_internal_r+0xd74>
8112f588:	42000204 	addi	r8,r8,8
8112f58c:	dac02517 	ldw	r11,148(sp)
8112f590:	5c17883a 	add	r11,r11,r16
8112f594:	dac02515 	stw	r11,148(sp)
8112f598:	88800007 	ldb	r2,0(r17)
8112f59c:	1002c526 	beq	r2,zero,811300b4 <___svfiprintf_internal_r+0xc28>
8112f5a0:	88c00047 	ldb	r3,1(r17)
8112f5a4:	8cc00044 	addi	r19,r17,1
8112f5a8:	d8001d85 	stb	zero,118(sp)
8112f5ac:	0009883a 	mov	r4,zero
8112f5b0:	000f883a 	mov	r7,zero
8112f5b4:	043fffc4 	movi	r16,-1
8112f5b8:	d8002415 	stw	zero,144(sp)
8112f5bc:	0025883a 	mov	r18,zero
8112f5c0:	01401604 	movi	r5,88
8112f5c4:	01800244 	movi	r6,9
8112f5c8:	02800a84 	movi	r10,42
8112f5cc:	02401b04 	movi	r9,108
8112f5d0:	9cc00044 	addi	r19,r19,1
8112f5d4:	18bff804 	addi	r2,r3,-32
8112f5d8:	2881dd36 	bltu	r5,r2,8112fd50 <___svfiprintf_internal_r+0x8c4>
8112f5dc:	100490ba 	slli	r2,r2,2
8112f5e0:	02e044f4 	movhi	r11,33043
8112f5e4:	5afd7d04 	addi	r11,r11,-2572
8112f5e8:	12c5883a 	add	r2,r2,r11
8112f5ec:	10800017 	ldw	r2,0(r2)
8112f5f0:	1000683a 	jmp	r2
8112f5f4:	8112f7f0 	cmpltui	r4,r16,19423
8112f5f8:	8112fd50 	cmplti	r4,r16,19445
8112f5fc:	8112fd50 	cmplti	r4,r16,19445
8112f600:	8112f7e4 	muli	r4,r16,19423
8112f604:	8112fd50 	cmplti	r4,r16,19445
8112f608:	8112fd50 	cmplti	r4,r16,19445
8112f60c:	8112fd50 	cmplti	r4,r16,19445
8112f610:	8112fd50 	cmplti	r4,r16,19445
8112f614:	8112fd50 	cmplti	r4,r16,19445
8112f618:	8112fd50 	cmplti	r4,r16,19445
8112f61c:	8112f758 	cmpnei	r4,r16,19421
8112f620:	8112f934 	orhi	r4,r16,19428
8112f624:	8112fd50 	cmplti	r4,r16,19445
8112f628:	8112f784 	addi	r4,r16,19422
8112f62c:	8112fd84 	addi	r4,r16,19446
8112f630:	8112fd50 	cmplti	r4,r16,19445
8112f634:	8112fd78 	rdprs	r4,r16,19445
8112f638:	8112fd18 	cmpnei	r4,r16,19444
8112f63c:	8112fd18 	cmpnei	r4,r16,19444
8112f640:	8112fd18 	cmpnei	r4,r16,19444
8112f644:	8112fd18 	cmpnei	r4,r16,19444
8112f648:	8112fd18 	cmpnei	r4,r16,19444
8112f64c:	8112fd18 	cmpnei	r4,r16,19444
8112f650:	8112fd18 	cmpnei	r4,r16,19444
8112f654:	8112fd18 	cmpnei	r4,r16,19444
8112f658:	8112fd18 	cmpnei	r4,r16,19444
8112f65c:	8112fd50 	cmplti	r4,r16,19445
8112f660:	8112fd50 	cmplti	r4,r16,19445
8112f664:	8112fd50 	cmplti	r4,r16,19445
8112f668:	8112fd50 	cmplti	r4,r16,19445
8112f66c:	8112fd50 	cmplti	r4,r16,19445
8112f670:	8112fd50 	cmplti	r4,r16,19445
8112f674:	8112fd50 	cmplti	r4,r16,19445
8112f678:	8112fd50 	cmplti	r4,r16,19445
8112f67c:	8112fd50 	cmplti	r4,r16,19445
8112f680:	8112fd50 	cmplti	r4,r16,19445
8112f684:	8112fcb4 	orhi	r4,r16,19442
8112f688:	8112fd50 	cmplti	r4,r16,19445
8112f68c:	8112fd50 	cmplti	r4,r16,19445
8112f690:	8112fd50 	cmplti	r4,r16,19445
8112f694:	8112fd50 	cmplti	r4,r16,19445
8112f698:	8112fd50 	cmplti	r4,r16,19445
8112f69c:	8112fd50 	cmplti	r4,r16,19445
8112f6a0:	8112fd50 	cmplti	r4,r16,19445
8112f6a4:	8112fd50 	cmplti	r4,r16,19445
8112f6a8:	8112fd50 	cmplti	r4,r16,19445
8112f6ac:	8112fd50 	cmplti	r4,r16,19445
8112f6b0:	8112fe2c 	andhi	r4,r16,19448
8112f6b4:	8112fd50 	cmplti	r4,r16,19445
8112f6b8:	8112fd50 	cmplti	r4,r16,19445
8112f6bc:	8112fd50 	cmplti	r4,r16,19445
8112f6c0:	8112fd50 	cmplti	r4,r16,19445
8112f6c4:	8112fd50 	cmplti	r4,r16,19445
8112f6c8:	8112fdc4 	addi	r4,r16,19447
8112f6cc:	8112fd50 	cmplti	r4,r16,19445
8112f6d0:	8112fd50 	cmplti	r4,r16,19445
8112f6d4:	8112faf8 	rdprs	r4,r16,19435
8112f6d8:	8112fd50 	cmplti	r4,r16,19445
8112f6dc:	8112fd50 	cmplti	r4,r16,19445
8112f6e0:	8112fd50 	cmplti	r4,r16,19445
8112f6e4:	8112fd50 	cmplti	r4,r16,19445
8112f6e8:	8112fd50 	cmplti	r4,r16,19445
8112f6ec:	8112fd50 	cmplti	r4,r16,19445
8112f6f0:	8112fd50 	cmplti	r4,r16,19445
8112f6f4:	8112fd50 	cmplti	r4,r16,19445
8112f6f8:	8112fd50 	cmplti	r4,r16,19445
8112f6fc:	8112fd50 	cmplti	r4,r16,19445
8112f700:	8112f9e8 	cmpgeui	r4,r16,19431
8112f704:	8112fb94 	ori	r4,r16,19438
8112f708:	8112fd50 	cmplti	r4,r16,19445
8112f70c:	8112fd50 	cmplti	r4,r16,19445
8112f710:	8112fd50 	cmplti	r4,r16,19445
8112f714:	8112fb88 	cmpgei	r4,r16,19438
8112f718:	8112fb94 	ori	r4,r16,19438
8112f71c:	8112fd50 	cmplti	r4,r16,19445
8112f720:	8112fd50 	cmplti	r4,r16,19445
8112f724:	8112fb78 	rdprs	r4,r16,19437
8112f728:	8112fd50 	cmplti	r4,r16,19445
8112f72c:	8112fb3c 	xorhi	r4,r16,19436
8112f730:	8112f944 	addi	r4,r16,19429
8112f734:	8112f790 	cmplti	r4,r16,19422
8112f738:	8112fca8 	cmpgeui	r4,r16,19442
8112f73c:	8112fd50 	cmplti	r4,r16,19445
8112f740:	8112fc5c 	xori	r4,r16,19441
8112f744:	8112fd50 	cmplti	r4,r16,19445
8112f748:	8112f8b4 	orhi	r4,r16,19426
8112f74c:	8112fd50 	cmplti	r4,r16,19445
8112f750:	8112fd50 	cmplti	r4,r16,19445
8112f754:	8112f810 	cmplti	r4,r16,19424
8112f758:	dac02317 	ldw	r11,140(sp)
8112f75c:	5ac00017 	ldw	r11,0(r11)
8112f760:	dac02415 	stw	r11,144(sp)
8112f764:	dac02317 	ldw	r11,140(sp)
8112f768:	58800104 	addi	r2,r11,4
8112f76c:	dac02417 	ldw	r11,144(sp)
8112f770:	5802e90e 	bge	r11,zero,81130318 <___svfiprintf_internal_r+0xe8c>
8112f774:	dac02417 	ldw	r11,144(sp)
8112f778:	d8802315 	stw	r2,140(sp)
8112f77c:	02d7c83a 	sub	r11,zero,r11
8112f780:	dac02415 	stw	r11,144(sp)
8112f784:	94800114 	ori	r18,r18,4
8112f788:	98c00007 	ldb	r3,0(r19)
8112f78c:	003f9006 	br	8112f5d0 <__reset+0xfb10f5d0>
8112f790:	00800c04 	movi	r2,48
8112f794:	dac02317 	ldw	r11,140(sp)
8112f798:	d8801d05 	stb	r2,116(sp)
8112f79c:	00801e04 	movi	r2,120
8112f7a0:	d8801d45 	stb	r2,117(sp)
8112f7a4:	d8001d85 	stb	zero,118(sp)
8112f7a8:	58c00104 	addi	r3,r11,4
8112f7ac:	5f000017 	ldw	fp,0(r11)
8112f7b0:	0013883a 	mov	r9,zero
8112f7b4:	90800094 	ori	r2,r18,2
8112f7b8:	80032b16 	blt	r16,zero,81130468 <___svfiprintf_internal_r+0xfdc>
8112f7bc:	00bfdfc4 	movi	r2,-129
8112f7c0:	90a4703a 	and	r18,r18,r2
8112f7c4:	d8c02315 	stw	r3,140(sp)
8112f7c8:	94800094 	ori	r18,r18,2
8112f7cc:	e002dc26 	beq	fp,zero,81130340 <___svfiprintf_internal_r+0xeb4>
8112f7d0:	01204574 	movhi	r4,33045
8112f7d4:	213e9a04 	addi	r4,r4,-1432
8112f7d8:	0015883a 	mov	r10,zero
8112f7dc:	d9002915 	stw	r4,164(sp)
8112f7e0:	00002306 	br	8112f870 <___svfiprintf_internal_r+0x3e4>
8112f7e4:	94800054 	ori	r18,r18,1
8112f7e8:	98c00007 	ldb	r3,0(r19)
8112f7ec:	003f7806 	br	8112f5d0 <__reset+0xfb10f5d0>
8112f7f0:	38803fcc 	andi	r2,r7,255
8112f7f4:	1080201c 	xori	r2,r2,128
8112f7f8:	10bfe004 	addi	r2,r2,-128
8112f7fc:	1002f31e 	bne	r2,zero,811303cc <___svfiprintf_internal_r+0xf40>
8112f800:	01000044 	movi	r4,1
8112f804:	01c00804 	movi	r7,32
8112f808:	98c00007 	ldb	r3,0(r19)
8112f80c:	003f7006 	br	8112f5d0 <__reset+0xfb10f5d0>
8112f810:	21003fcc 	andi	r4,r4,255
8112f814:	2003aa1e 	bne	r4,zero,811306c0 <___svfiprintf_internal_r+0x1234>
8112f818:	00a04574 	movhi	r2,33045
8112f81c:	10be9a04 	addi	r2,r2,-1432
8112f820:	d8802915 	stw	r2,164(sp)
8112f824:	9080080c 	andi	r2,r18,32
8112f828:	1000ba26 	beq	r2,zero,8112fb14 <___svfiprintf_internal_r+0x688>
8112f82c:	dac02317 	ldw	r11,140(sp)
8112f830:	5f000017 	ldw	fp,0(r11)
8112f834:	5a400117 	ldw	r9,4(r11)
8112f838:	5ac00204 	addi	r11,r11,8
8112f83c:	dac02315 	stw	r11,140(sp)
8112f840:	9080004c 	andi	r2,r18,1
8112f844:	10029026 	beq	r2,zero,81130288 <___svfiprintf_internal_r+0xdfc>
8112f848:	e244b03a 	or	r2,fp,r9
8112f84c:	1002d41e 	bne	r2,zero,811303a0 <___svfiprintf_internal_r+0xf14>
8112f850:	d8001d85 	stb	zero,118(sp)
8112f854:	80030b16 	blt	r16,zero,81130484 <___svfiprintf_internal_r+0xff8>
8112f858:	00bfdfc4 	movi	r2,-129
8112f85c:	90a4703a 	and	r18,r18,r2
8112f860:	0015883a 	mov	r10,zero
8112f864:	80002426 	beq	r16,zero,8112f8f8 <___svfiprintf_internal_r+0x46c>
8112f868:	0039883a 	mov	fp,zero
8112f86c:	0013883a 	mov	r9,zero
8112f870:	d9002917 	ldw	r4,164(sp)
8112f874:	dc401a04 	addi	r17,sp,104
8112f878:	e08003cc 	andi	r2,fp,15
8112f87c:	4806973a 	slli	r3,r9,28
8112f880:	2085883a 	add	r2,r4,r2
8112f884:	e038d13a 	srli	fp,fp,4
8112f888:	10800003 	ldbu	r2,0(r2)
8112f88c:	4812d13a 	srli	r9,r9,4
8112f890:	8c7fffc4 	addi	r17,r17,-1
8112f894:	1f38b03a 	or	fp,r3,fp
8112f898:	88800005 	stb	r2,0(r17)
8112f89c:	e244b03a 	or	r2,fp,r9
8112f8a0:	103ff51e 	bne	r2,zero,8112f878 <__reset+0xfb10f878>
8112f8a4:	dac01e17 	ldw	r11,120(sp)
8112f8a8:	5c57c83a 	sub	r11,r11,r17
8112f8ac:	dac02115 	stw	r11,132(sp)
8112f8b0:	00001406 	br	8112f904 <___svfiprintf_internal_r+0x478>
8112f8b4:	21003fcc 	andi	r4,r4,255
8112f8b8:	2003741e 	bne	r4,zero,8113068c <___svfiprintf_internal_r+0x1200>
8112f8bc:	9080080c 	andi	r2,r18,32
8112f8c0:	10014526 	beq	r2,zero,8112fdd8 <___svfiprintf_internal_r+0x94c>
8112f8c4:	dac02317 	ldw	r11,140(sp)
8112f8c8:	d8001d85 	stb	zero,118(sp)
8112f8cc:	58c00204 	addi	r3,r11,8
8112f8d0:	5f000017 	ldw	fp,0(r11)
8112f8d4:	5a400117 	ldw	r9,4(r11)
8112f8d8:	8002d916 	blt	r16,zero,81130440 <___svfiprintf_internal_r+0xfb4>
8112f8dc:	013fdfc4 	movi	r4,-129
8112f8e0:	e244b03a 	or	r2,fp,r9
8112f8e4:	d8c02315 	stw	r3,140(sp)
8112f8e8:	9124703a 	and	r18,r18,r4
8112f8ec:	0015883a 	mov	r10,zero
8112f8f0:	1000b91e 	bne	r2,zero,8112fbd8 <___svfiprintf_internal_r+0x74c>
8112f8f4:	8002e61e 	bne	r16,zero,81130490 <___svfiprintf_internal_r+0x1004>
8112f8f8:	0021883a 	mov	r16,zero
8112f8fc:	d8002115 	stw	zero,132(sp)
8112f900:	dc401a04 	addi	r17,sp,104
8112f904:	d8c02117 	ldw	r3,132(sp)
8112f908:	dc002015 	stw	r16,128(sp)
8112f90c:	80c0010e 	bge	r16,r3,8112f914 <___svfiprintf_internal_r+0x488>
8112f910:	d8c02015 	stw	r3,128(sp)
8112f914:	52803fcc 	andi	r10,r10,255
8112f918:	5280201c 	xori	r10,r10,128
8112f91c:	52bfe004 	addi	r10,r10,-128
8112f920:	50003c26 	beq	r10,zero,8112fa14 <___svfiprintf_internal_r+0x588>
8112f924:	dac02017 	ldw	r11,128(sp)
8112f928:	5ac00044 	addi	r11,r11,1
8112f92c:	dac02015 	stw	r11,128(sp)
8112f930:	00003806 	br	8112fa14 <___svfiprintf_internal_r+0x588>
8112f934:	01000044 	movi	r4,1
8112f938:	01c00ac4 	movi	r7,43
8112f93c:	98c00007 	ldb	r3,0(r19)
8112f940:	003f2306 	br	8112f5d0 <__reset+0xfb10f5d0>
8112f944:	21003fcc 	andi	r4,r4,255
8112f948:	2003481e 	bne	r4,zero,8113066c <___svfiprintf_internal_r+0x11e0>
8112f94c:	9080080c 	andi	r2,r18,32
8112f950:	10013b26 	beq	r2,zero,8112fe40 <___svfiprintf_internal_r+0x9b4>
8112f954:	dac02317 	ldw	r11,140(sp)
8112f958:	d8001d85 	stb	zero,118(sp)
8112f95c:	58800204 	addi	r2,r11,8
8112f960:	5f000017 	ldw	fp,0(r11)
8112f964:	5a400117 	ldw	r9,4(r11)
8112f968:	8002a816 	blt	r16,zero,8113040c <___svfiprintf_internal_r+0xf80>
8112f96c:	013fdfc4 	movi	r4,-129
8112f970:	e246b03a 	or	r3,fp,r9
8112f974:	d8802315 	stw	r2,140(sp)
8112f978:	9124703a 	and	r18,r18,r4
8112f97c:	18013c26 	beq	r3,zero,8112fe70 <___svfiprintf_internal_r+0x9e4>
8112f980:	0015883a 	mov	r10,zero
8112f984:	dc401a04 	addi	r17,sp,104
8112f988:	e006d0fa 	srli	r3,fp,3
8112f98c:	4808977a 	slli	r4,r9,29
8112f990:	4812d0fa 	srli	r9,r9,3
8112f994:	e70001cc 	andi	fp,fp,7
8112f998:	e0800c04 	addi	r2,fp,48
8112f99c:	8c7fffc4 	addi	r17,r17,-1
8112f9a0:	20f8b03a 	or	fp,r4,r3
8112f9a4:	88800005 	stb	r2,0(r17)
8112f9a8:	e246b03a 	or	r3,fp,r9
8112f9ac:	183ff61e 	bne	r3,zero,8112f988 <__reset+0xfb10f988>
8112f9b0:	90c0004c 	andi	r3,r18,1
8112f9b4:	1800a526 	beq	r3,zero,8112fc4c <___svfiprintf_internal_r+0x7c0>
8112f9b8:	10803fcc 	andi	r2,r2,255
8112f9bc:	1080201c 	xori	r2,r2,128
8112f9c0:	10bfe004 	addi	r2,r2,-128
8112f9c4:	00c00c04 	movi	r3,48
8112f9c8:	10ffb626 	beq	r2,r3,8112f8a4 <__reset+0xfb10f8a4>
8112f9cc:	88ffffc5 	stb	r3,-1(r17)
8112f9d0:	d8c01e17 	ldw	r3,120(sp)
8112f9d4:	88bfffc4 	addi	r2,r17,-1
8112f9d8:	1023883a 	mov	r17,r2
8112f9dc:	1887c83a 	sub	r3,r3,r2
8112f9e0:	d8c02115 	stw	r3,132(sp)
8112f9e4:	003fc706 	br	8112f904 <__reset+0xfb10f904>
8112f9e8:	dac02317 	ldw	r11,140(sp)
8112f9ec:	00c00044 	movi	r3,1
8112f9f0:	d8c02015 	stw	r3,128(sp)
8112f9f4:	58800017 	ldw	r2,0(r11)
8112f9f8:	5ac00104 	addi	r11,r11,4
8112f9fc:	d8001d85 	stb	zero,118(sp)
8112fa00:	d8801005 	stb	r2,64(sp)
8112fa04:	dac02315 	stw	r11,140(sp)
8112fa08:	d8c02115 	stw	r3,132(sp)
8112fa0c:	dc401004 	addi	r17,sp,64
8112fa10:	0021883a 	mov	r16,zero
8112fa14:	90c0008c 	andi	r3,r18,2
8112fa18:	d8c02215 	stw	r3,136(sp)
8112fa1c:	18000326 	beq	r3,zero,8112fa2c <___svfiprintf_internal_r+0x5a0>
8112fa20:	dac02017 	ldw	r11,128(sp)
8112fa24:	5ac00084 	addi	r11,r11,2
8112fa28:	dac02015 	stw	r11,128(sp)
8112fa2c:	90c0210c 	andi	r3,r18,132
8112fa30:	d8c02615 	stw	r3,152(sp)
8112fa34:	1801131e 	bne	r3,zero,8112fe84 <___svfiprintf_internal_r+0x9f8>
8112fa38:	dac02417 	ldw	r11,144(sp)
8112fa3c:	d8c02017 	ldw	r3,128(sp)
8112fa40:	58f9c83a 	sub	fp,r11,r3
8112fa44:	07010f0e 	bge	zero,fp,8112fe84 <___svfiprintf_internal_r+0x9f8>
8112fa48:	02400404 	movi	r9,16
8112fa4c:	d8c01c17 	ldw	r3,112(sp)
8112fa50:	d8801b17 	ldw	r2,108(sp)
8112fa54:	4f02d60e 	bge	r9,fp,811305b0 <___svfiprintf_internal_r+0x1124>
8112fa58:	01604574 	movhi	r5,33045
8112fa5c:	297f2804 	addi	r5,r5,-864
8112fa60:	d9402815 	stw	r5,160(sp)
8112fa64:	028001c4 	movi	r10,7
8112fa68:	00000306 	br	8112fa78 <___svfiprintf_internal_r+0x5ec>
8112fa6c:	e73ffc04 	addi	fp,fp,-16
8112fa70:	42000204 	addi	r8,r8,8
8112fa74:	4f00150e 	bge	r9,fp,8112facc <___svfiprintf_internal_r+0x640>
8112fa78:	18c00404 	addi	r3,r3,16
8112fa7c:	10800044 	addi	r2,r2,1
8112fa80:	45800015 	stw	r22,0(r8)
8112fa84:	42400115 	stw	r9,4(r8)
8112fa88:	d8c01c15 	stw	r3,112(sp)
8112fa8c:	d8801b15 	stw	r2,108(sp)
8112fa90:	50bff60e 	bge	r10,r2,8112fa6c <__reset+0xfb10fa6c>
8112fa94:	d9801a04 	addi	r6,sp,104
8112fa98:	b80b883a 	mov	r5,r23
8112fa9c:	a809883a 	mov	r4,r21
8112faa0:	da402c15 	stw	r9,176(sp)
8112faa4:	da802d15 	stw	r10,180(sp)
8112faa8:	112f2b40 	call	8112f2b4 <__ssprint_r>
8112faac:	da402c17 	ldw	r9,176(sp)
8112fab0:	da802d17 	ldw	r10,180(sp)
8112fab4:	1001851e 	bne	r2,zero,811300cc <___svfiprintf_internal_r+0xc40>
8112fab8:	e73ffc04 	addi	fp,fp,-16
8112fabc:	d8c01c17 	ldw	r3,112(sp)
8112fac0:	d8801b17 	ldw	r2,108(sp)
8112fac4:	d811883a 	mov	r8,sp
8112fac8:	4f3feb16 	blt	r9,fp,8112fa78 <__reset+0xfb10fa78>
8112facc:	dac02817 	ldw	r11,160(sp)
8112fad0:	e0c7883a 	add	r3,fp,r3
8112fad4:	10800044 	addi	r2,r2,1
8112fad8:	42c00015 	stw	r11,0(r8)
8112fadc:	47000115 	stw	fp,4(r8)
8112fae0:	d8c01c15 	stw	r3,112(sp)
8112fae4:	d8801b15 	stw	r2,108(sp)
8112fae8:	010001c4 	movi	r4,7
8112faec:	2081ee16 	blt	r4,r2,811302a8 <___svfiprintf_internal_r+0xe1c>
8112faf0:	42000204 	addi	r8,r8,8
8112faf4:	0000e506 	br	8112fe8c <___svfiprintf_internal_r+0xa00>
8112faf8:	21003fcc 	andi	r4,r4,255
8112fafc:	2002dd1e 	bne	r4,zero,81130674 <___svfiprintf_internal_r+0x11e8>
8112fb00:	00a04574 	movhi	r2,33045
8112fb04:	10be9504 	addi	r2,r2,-1452
8112fb08:	d8802915 	stw	r2,164(sp)
8112fb0c:	9080080c 	andi	r2,r18,32
8112fb10:	103f461e 	bne	r2,zero,8112f82c <__reset+0xfb10f82c>
8112fb14:	9080040c 	andi	r2,r18,16
8112fb18:	10022e1e 	bne	r2,zero,811303d4 <___svfiprintf_internal_r+0xf48>
8112fb1c:	9080100c 	andi	r2,r18,64
8112fb20:	dac02317 	ldw	r11,140(sp)
8112fb24:	10027326 	beq	r2,zero,811304f4 <___svfiprintf_internal_r+0x1068>
8112fb28:	5f00000b 	ldhu	fp,0(r11)
8112fb2c:	5ac00104 	addi	r11,r11,4
8112fb30:	0013883a 	mov	r9,zero
8112fb34:	dac02315 	stw	r11,140(sp)
8112fb38:	003f4106 	br	8112f840 <__reset+0xfb10f840>
8112fb3c:	21003fcc 	andi	r4,r4,255
8112fb40:	2002e11e 	bne	r4,zero,811306c8 <___svfiprintf_internal_r+0x123c>
8112fb44:	9080080c 	andi	r2,r18,32
8112fb48:	1002011e 	bne	r2,zero,81130350 <___svfiprintf_internal_r+0xec4>
8112fb4c:	9080040c 	andi	r2,r18,16
8112fb50:	10023e1e 	bne	r2,zero,8113044c <___svfiprintf_internal_r+0xfc0>
8112fb54:	9480100c 	andi	r18,r18,64
8112fb58:	90023c26 	beq	r18,zero,8113044c <___svfiprintf_internal_r+0xfc0>
8112fb5c:	dac02317 	ldw	r11,140(sp)
8112fb60:	58800017 	ldw	r2,0(r11)
8112fb64:	5ac00104 	addi	r11,r11,4
8112fb68:	dac02315 	stw	r11,140(sp)
8112fb6c:	dac02517 	ldw	r11,148(sp)
8112fb70:	12c0000d 	sth	r11,0(r2)
8112fb74:	003e6e06 	br	8112f530 <__reset+0xfb10f530>
8112fb78:	98c00007 	ldb	r3,0(r19)
8112fb7c:	1a422926 	beq	r3,r9,81130424 <___svfiprintf_internal_r+0xf98>
8112fb80:	94800414 	ori	r18,r18,16
8112fb84:	003e9206 	br	8112f5d0 <__reset+0xfb10f5d0>
8112fb88:	94801014 	ori	r18,r18,64
8112fb8c:	98c00007 	ldb	r3,0(r19)
8112fb90:	003e8f06 	br	8112f5d0 <__reset+0xfb10f5d0>
8112fb94:	21003fcc 	andi	r4,r4,255
8112fb98:	2002c71e 	bne	r4,zero,811306b8 <___svfiprintf_internal_r+0x122c>
8112fb9c:	9080080c 	andi	r2,r18,32
8112fba0:	10004926 	beq	r2,zero,8112fcc8 <___svfiprintf_internal_r+0x83c>
8112fba4:	dac02317 	ldw	r11,140(sp)
8112fba8:	58800117 	ldw	r2,4(r11)
8112fbac:	5f000017 	ldw	fp,0(r11)
8112fbb0:	5ac00204 	addi	r11,r11,8
8112fbb4:	dac02315 	stw	r11,140(sp)
8112fbb8:	1013883a 	mov	r9,r2
8112fbbc:	10004b16 	blt	r2,zero,8112fcec <___svfiprintf_internal_r+0x860>
8112fbc0:	da801d83 	ldbu	r10,118(sp)
8112fbc4:	8001cb16 	blt	r16,zero,811302f4 <___svfiprintf_internal_r+0xe68>
8112fbc8:	00ffdfc4 	movi	r3,-129
8112fbcc:	e244b03a 	or	r2,fp,r9
8112fbd0:	90e4703a 	and	r18,r18,r3
8112fbd4:	103f4726 	beq	r2,zero,8112f8f4 <__reset+0xfb10f8f4>
8112fbd8:	48008c26 	beq	r9,zero,8112fe0c <___svfiprintf_internal_r+0x980>
8112fbdc:	dc802015 	stw	r18,128(sp)
8112fbe0:	dc002115 	stw	r16,132(sp)
8112fbe4:	dc401a04 	addi	r17,sp,104
8112fbe8:	e021883a 	mov	r16,fp
8112fbec:	da002215 	stw	r8,136(sp)
8112fbf0:	5039883a 	mov	fp,r10
8112fbf4:	4825883a 	mov	r18,r9
8112fbf8:	8009883a 	mov	r4,r16
8112fbfc:	900b883a 	mov	r5,r18
8112fc00:	01800284 	movi	r6,10
8112fc04:	000f883a 	mov	r7,zero
8112fc08:	113379c0 	call	8113379c <__umoddi3>
8112fc0c:	10800c04 	addi	r2,r2,48
8112fc10:	8c7fffc4 	addi	r17,r17,-1
8112fc14:	8009883a 	mov	r4,r16
8112fc18:	900b883a 	mov	r5,r18
8112fc1c:	88800005 	stb	r2,0(r17)
8112fc20:	01800284 	movi	r6,10
8112fc24:	000f883a 	mov	r7,zero
8112fc28:	113321c0 	call	8113321c <__udivdi3>
8112fc2c:	1021883a 	mov	r16,r2
8112fc30:	10c4b03a 	or	r2,r2,r3
8112fc34:	1825883a 	mov	r18,r3
8112fc38:	103fef1e 	bne	r2,zero,8112fbf8 <__reset+0xfb10fbf8>
8112fc3c:	dc802017 	ldw	r18,128(sp)
8112fc40:	dc002117 	ldw	r16,132(sp)
8112fc44:	da002217 	ldw	r8,136(sp)
8112fc48:	e015883a 	mov	r10,fp
8112fc4c:	d8c01e17 	ldw	r3,120(sp)
8112fc50:	1c47c83a 	sub	r3,r3,r17
8112fc54:	d8c02115 	stw	r3,132(sp)
8112fc58:	003f2a06 	br	8112f904 <__reset+0xfb10f904>
8112fc5c:	dac02317 	ldw	r11,140(sp)
8112fc60:	d8001d85 	stb	zero,118(sp)
8112fc64:	5c400017 	ldw	r17,0(r11)
8112fc68:	5f000104 	addi	fp,r11,4
8112fc6c:	88022f26 	beq	r17,zero,8113052c <___svfiprintf_internal_r+0x10a0>
8112fc70:	80022516 	blt	r16,zero,81130508 <___svfiprintf_internal_r+0x107c>
8112fc74:	800d883a 	mov	r6,r16
8112fc78:	000b883a 	mov	r5,zero
8112fc7c:	8809883a 	mov	r4,r17
8112fc80:	da002c15 	stw	r8,176(sp)
8112fc84:	112b8580 	call	8112b858 <memchr>
8112fc88:	da002c17 	ldw	r8,176(sp)
8112fc8c:	10026426 	beq	r2,zero,81130620 <___svfiprintf_internal_r+0x1194>
8112fc90:	1445c83a 	sub	r2,r2,r17
8112fc94:	d8802115 	stw	r2,132(sp)
8112fc98:	da801d83 	ldbu	r10,118(sp)
8112fc9c:	df002315 	stw	fp,140(sp)
8112fca0:	0021883a 	mov	r16,zero
8112fca4:	003f1706 	br	8112f904 <__reset+0xfb10f904>
8112fca8:	94800814 	ori	r18,r18,32
8112fcac:	98c00007 	ldb	r3,0(r19)
8112fcb0:	003e4706 	br	8112f5d0 <__reset+0xfb10f5d0>
8112fcb4:	21003fcc 	andi	r4,r4,255
8112fcb8:	2002701e 	bne	r4,zero,8113067c <___svfiprintf_internal_r+0x11f0>
8112fcbc:	94800414 	ori	r18,r18,16
8112fcc0:	9080080c 	andi	r2,r18,32
8112fcc4:	103fb71e 	bne	r2,zero,8112fba4 <__reset+0xfb10fba4>
8112fcc8:	9080040c 	andi	r2,r18,16
8112fccc:	1001ab26 	beq	r2,zero,8113037c <___svfiprintf_internal_r+0xef0>
8112fcd0:	dac02317 	ldw	r11,140(sp)
8112fcd4:	5f000017 	ldw	fp,0(r11)
8112fcd8:	5ac00104 	addi	r11,r11,4
8112fcdc:	dac02315 	stw	r11,140(sp)
8112fce0:	e013d7fa 	srai	r9,fp,31
8112fce4:	4805883a 	mov	r2,r9
8112fce8:	103fb50e 	bge	r2,zero,8112fbc0 <__reset+0xfb10fbc0>
8112fcec:	0739c83a 	sub	fp,zero,fp
8112fcf0:	02800b44 	movi	r10,45
8112fcf4:	e004c03a 	cmpne	r2,fp,zero
8112fcf8:	0253c83a 	sub	r9,zero,r9
8112fcfc:	da801d85 	stb	r10,118(sp)
8112fd00:	4893c83a 	sub	r9,r9,r2
8112fd04:	80023016 	blt	r16,zero,811305c8 <___svfiprintf_internal_r+0x113c>
8112fd08:	00bfdfc4 	movi	r2,-129
8112fd0c:	90a4703a 	and	r18,r18,r2
8112fd10:	483fb21e 	bne	r9,zero,8112fbdc <__reset+0xfb10fbdc>
8112fd14:	00003d06 	br	8112fe0c <___svfiprintf_internal_r+0x980>
8112fd18:	9817883a 	mov	r11,r19
8112fd1c:	d8002415 	stw	zero,144(sp)
8112fd20:	18bff404 	addi	r2,r3,-48
8112fd24:	0019883a 	mov	r12,zero
8112fd28:	58c00007 	ldb	r3,0(r11)
8112fd2c:	630002a4 	muli	r12,r12,10
8112fd30:	9cc00044 	addi	r19,r19,1
8112fd34:	9817883a 	mov	r11,r19
8112fd38:	1319883a 	add	r12,r2,r12
8112fd3c:	18bff404 	addi	r2,r3,-48
8112fd40:	30bff92e 	bgeu	r6,r2,8112fd28 <__reset+0xfb10fd28>
8112fd44:	db002415 	stw	r12,144(sp)
8112fd48:	18bff804 	addi	r2,r3,-32
8112fd4c:	28be232e 	bgeu	r5,r2,8112f5dc <__reset+0xfb10f5dc>
8112fd50:	21003fcc 	andi	r4,r4,255
8112fd54:	20024b1e 	bne	r4,zero,81130684 <___svfiprintf_internal_r+0x11f8>
8112fd58:	1800d626 	beq	r3,zero,811300b4 <___svfiprintf_internal_r+0xc28>
8112fd5c:	02c00044 	movi	r11,1
8112fd60:	dac02015 	stw	r11,128(sp)
8112fd64:	d8c01005 	stb	r3,64(sp)
8112fd68:	d8001d85 	stb	zero,118(sp)
8112fd6c:	dac02115 	stw	r11,132(sp)
8112fd70:	dc401004 	addi	r17,sp,64
8112fd74:	003f2606 	br	8112fa10 <__reset+0xfb10fa10>
8112fd78:	94802014 	ori	r18,r18,128
8112fd7c:	98c00007 	ldb	r3,0(r19)
8112fd80:	003e1306 	br	8112f5d0 <__reset+0xfb10f5d0>
8112fd84:	98c00007 	ldb	r3,0(r19)
8112fd88:	9ac00044 	addi	r11,r19,1
8112fd8c:	1a822b26 	beq	r3,r10,8113063c <___svfiprintf_internal_r+0x11b0>
8112fd90:	18bff404 	addi	r2,r3,-48
8112fd94:	0021883a 	mov	r16,zero
8112fd98:	30821e36 	bltu	r6,r2,81130614 <___svfiprintf_internal_r+0x1188>
8112fd9c:	58c00007 	ldb	r3,0(r11)
8112fda0:	840002a4 	muli	r16,r16,10
8112fda4:	5cc00044 	addi	r19,r11,1
8112fda8:	9817883a 	mov	r11,r19
8112fdac:	80a1883a 	add	r16,r16,r2
8112fdb0:	18bff404 	addi	r2,r3,-48
8112fdb4:	30bff92e 	bgeu	r6,r2,8112fd9c <__reset+0xfb10fd9c>
8112fdb8:	803e060e 	bge	r16,zero,8112f5d4 <__reset+0xfb10f5d4>
8112fdbc:	043fffc4 	movi	r16,-1
8112fdc0:	003e0406 	br	8112f5d4 <__reset+0xfb10f5d4>
8112fdc4:	21003fcc 	andi	r4,r4,255
8112fdc8:	2002371e 	bne	r4,zero,811306a8 <___svfiprintf_internal_r+0x121c>
8112fdcc:	94800414 	ori	r18,r18,16
8112fdd0:	9080080c 	andi	r2,r18,32
8112fdd4:	103ebb1e 	bne	r2,zero,8112f8c4 <__reset+0xfb10f8c4>
8112fdd8:	9080040c 	andi	r2,r18,16
8112fddc:	10013b26 	beq	r2,zero,811302cc <___svfiprintf_internal_r+0xe40>
8112fde0:	dac02317 	ldw	r11,140(sp)
8112fde4:	d8001d85 	stb	zero,118(sp)
8112fde8:	0013883a 	mov	r9,zero
8112fdec:	58800104 	addi	r2,r11,4
8112fdf0:	5f000017 	ldw	fp,0(r11)
8112fdf4:	80013d16 	blt	r16,zero,811302ec <___svfiprintf_internal_r+0xe60>
8112fdf8:	00ffdfc4 	movi	r3,-129
8112fdfc:	d8802315 	stw	r2,140(sp)
8112fe00:	90e4703a 	and	r18,r18,r3
8112fe04:	0015883a 	mov	r10,zero
8112fe08:	e03eba26 	beq	fp,zero,8112f8f4 <__reset+0xfb10f8f4>
8112fe0c:	00800244 	movi	r2,9
8112fe10:	173f7236 	bltu	r2,fp,8112fbdc <__reset+0xfb10fbdc>
8112fe14:	dac02b17 	ldw	r11,172(sp)
8112fe18:	e7000c04 	addi	fp,fp,48
8112fe1c:	df0019c5 	stb	fp,103(sp)
8112fe20:	dac02115 	stw	r11,132(sp)
8112fe24:	dc4019c4 	addi	r17,sp,103
8112fe28:	003eb606 	br	8112f904 <__reset+0xfb10f904>
8112fe2c:	21003fcc 	andi	r4,r4,255
8112fe30:	20021f1e 	bne	r4,zero,811306b0 <___svfiprintf_internal_r+0x1224>
8112fe34:	94800414 	ori	r18,r18,16
8112fe38:	9080080c 	andi	r2,r18,32
8112fe3c:	103ec51e 	bne	r2,zero,8112f954 <__reset+0xfb10f954>
8112fe40:	9080040c 	andi	r2,r18,16
8112fe44:	10016926 	beq	r2,zero,811303ec <___svfiprintf_internal_r+0xf60>
8112fe48:	dac02317 	ldw	r11,140(sp)
8112fe4c:	d8001d85 	stb	zero,118(sp)
8112fe50:	0013883a 	mov	r9,zero
8112fe54:	58800104 	addi	r2,r11,4
8112fe58:	5f000017 	ldw	fp,0(r11)
8112fe5c:	80016b16 	blt	r16,zero,8113040c <___svfiprintf_internal_r+0xf80>
8112fe60:	00ffdfc4 	movi	r3,-129
8112fe64:	d8802315 	stw	r2,140(sp)
8112fe68:	90e4703a 	and	r18,r18,r3
8112fe6c:	e03ec41e 	bne	fp,zero,8112f980 <__reset+0xfb10f980>
8112fe70:	0015883a 	mov	r10,zero
8112fe74:	8001c226 	beq	r16,zero,81130580 <___svfiprintf_internal_r+0x10f4>
8112fe78:	0039883a 	mov	fp,zero
8112fe7c:	0013883a 	mov	r9,zero
8112fe80:	003ec006 	br	8112f984 <__reset+0xfb10f984>
8112fe84:	d8c01c17 	ldw	r3,112(sp)
8112fe88:	d8801b17 	ldw	r2,108(sp)
8112fe8c:	d9001d87 	ldb	r4,118(sp)
8112fe90:	20000b26 	beq	r4,zero,8112fec0 <___svfiprintf_internal_r+0xa34>
8112fe94:	d9001d84 	addi	r4,sp,118
8112fe98:	18c00044 	addi	r3,r3,1
8112fe9c:	10800044 	addi	r2,r2,1
8112fea0:	41000015 	stw	r4,0(r8)
8112fea4:	01000044 	movi	r4,1
8112fea8:	41000115 	stw	r4,4(r8)
8112feac:	d8c01c15 	stw	r3,112(sp)
8112feb0:	d8801b15 	stw	r2,108(sp)
8112feb4:	010001c4 	movi	r4,7
8112feb8:	2080e116 	blt	r4,r2,81130240 <___svfiprintf_internal_r+0xdb4>
8112febc:	42000204 	addi	r8,r8,8
8112fec0:	dac02217 	ldw	r11,136(sp)
8112fec4:	58000b26 	beq	r11,zero,8112fef4 <___svfiprintf_internal_r+0xa68>
8112fec8:	d9001d04 	addi	r4,sp,116
8112fecc:	18c00084 	addi	r3,r3,2
8112fed0:	10800044 	addi	r2,r2,1
8112fed4:	41000015 	stw	r4,0(r8)
8112fed8:	01000084 	movi	r4,2
8112fedc:	41000115 	stw	r4,4(r8)
8112fee0:	d8c01c15 	stw	r3,112(sp)
8112fee4:	d8801b15 	stw	r2,108(sp)
8112fee8:	010001c4 	movi	r4,7
8112feec:	2080dd16 	blt	r4,r2,81130264 <___svfiprintf_internal_r+0xdd8>
8112fef0:	42000204 	addi	r8,r8,8
8112fef4:	dac02617 	ldw	r11,152(sp)
8112fef8:	01002004 	movi	r4,128
8112fefc:	59008426 	beq	r11,r4,81130110 <___svfiprintf_internal_r+0xc84>
8112ff00:	dac02117 	ldw	r11,132(sp)
8112ff04:	82e1c83a 	sub	r16,r16,r11
8112ff08:	0400270e 	bge	zero,r16,8112ffa8 <___svfiprintf_internal_r+0xb1c>
8112ff0c:	01c00404 	movi	r7,16
8112ff10:	3c016a0e 	bge	r7,r16,811304bc <___svfiprintf_internal_r+0x1030>
8112ff14:	01604574 	movhi	r5,33045
8112ff18:	297f2404 	addi	r5,r5,-880
8112ff1c:	d9402215 	stw	r5,136(sp)
8112ff20:	070001c4 	movi	fp,7
8112ff24:	00000306 	br	8112ff34 <___svfiprintf_internal_r+0xaa8>
8112ff28:	843ffc04 	addi	r16,r16,-16
8112ff2c:	42000204 	addi	r8,r8,8
8112ff30:	3c00130e 	bge	r7,r16,8112ff80 <___svfiprintf_internal_r+0xaf4>
8112ff34:	18c00404 	addi	r3,r3,16
8112ff38:	10800044 	addi	r2,r2,1
8112ff3c:	45000015 	stw	r20,0(r8)
8112ff40:	41c00115 	stw	r7,4(r8)
8112ff44:	d8c01c15 	stw	r3,112(sp)
8112ff48:	d8801b15 	stw	r2,108(sp)
8112ff4c:	e0bff60e 	bge	fp,r2,8112ff28 <__reset+0xfb10ff28>
8112ff50:	d9801a04 	addi	r6,sp,104
8112ff54:	b80b883a 	mov	r5,r23
8112ff58:	a809883a 	mov	r4,r21
8112ff5c:	d9c02c15 	stw	r7,176(sp)
8112ff60:	112f2b40 	call	8112f2b4 <__ssprint_r>
8112ff64:	d9c02c17 	ldw	r7,176(sp)
8112ff68:	1000581e 	bne	r2,zero,811300cc <___svfiprintf_internal_r+0xc40>
8112ff6c:	843ffc04 	addi	r16,r16,-16
8112ff70:	d8c01c17 	ldw	r3,112(sp)
8112ff74:	d8801b17 	ldw	r2,108(sp)
8112ff78:	d811883a 	mov	r8,sp
8112ff7c:	3c3fed16 	blt	r7,r16,8112ff34 <__reset+0xfb10ff34>
8112ff80:	dac02217 	ldw	r11,136(sp)
8112ff84:	1c07883a 	add	r3,r3,r16
8112ff88:	10800044 	addi	r2,r2,1
8112ff8c:	42c00015 	stw	r11,0(r8)
8112ff90:	44000115 	stw	r16,4(r8)
8112ff94:	d8c01c15 	stw	r3,112(sp)
8112ff98:	d8801b15 	stw	r2,108(sp)
8112ff9c:	010001c4 	movi	r4,7
8112ffa0:	20809e16 	blt	r4,r2,8113021c <___svfiprintf_internal_r+0xd90>
8112ffa4:	42000204 	addi	r8,r8,8
8112ffa8:	dac02117 	ldw	r11,132(sp)
8112ffac:	10800044 	addi	r2,r2,1
8112ffb0:	44400015 	stw	r17,0(r8)
8112ffb4:	58c7883a 	add	r3,r11,r3
8112ffb8:	42c00115 	stw	r11,4(r8)
8112ffbc:	d8c01c15 	stw	r3,112(sp)
8112ffc0:	d8801b15 	stw	r2,108(sp)
8112ffc4:	010001c4 	movi	r4,7
8112ffc8:	20807f16 	blt	r4,r2,811301c8 <___svfiprintf_internal_r+0xd3c>
8112ffcc:	42000204 	addi	r8,r8,8
8112ffd0:	9480010c 	andi	r18,r18,4
8112ffd4:	90002926 	beq	r18,zero,8113007c <___svfiprintf_internal_r+0xbf0>
8112ffd8:	dac02417 	ldw	r11,144(sp)
8112ffdc:	d8802017 	ldw	r2,128(sp)
8112ffe0:	58a1c83a 	sub	r16,r11,r2
8112ffe4:	0400250e 	bge	zero,r16,8113007c <___svfiprintf_internal_r+0xbf0>
8112ffe8:	04400404 	movi	r17,16
8112ffec:	d8801b17 	ldw	r2,108(sp)
8112fff0:	8c017c0e 	bge	r17,r16,811305e4 <___svfiprintf_internal_r+0x1158>
8112fff4:	01604574 	movhi	r5,33045
8112fff8:	297f2804 	addi	r5,r5,-864
8112fffc:	d9402815 	stw	r5,160(sp)
81130000:	048001c4 	movi	r18,7
81130004:	00000306 	br	81130014 <___svfiprintf_internal_r+0xb88>
81130008:	843ffc04 	addi	r16,r16,-16
8113000c:	42000204 	addi	r8,r8,8
81130010:	8c00110e 	bge	r17,r16,81130058 <___svfiprintf_internal_r+0xbcc>
81130014:	18c00404 	addi	r3,r3,16
81130018:	10800044 	addi	r2,r2,1
8113001c:	45800015 	stw	r22,0(r8)
81130020:	44400115 	stw	r17,4(r8)
81130024:	d8c01c15 	stw	r3,112(sp)
81130028:	d8801b15 	stw	r2,108(sp)
8113002c:	90bff60e 	bge	r18,r2,81130008 <__reset+0xfb110008>
81130030:	d9801a04 	addi	r6,sp,104
81130034:	b80b883a 	mov	r5,r23
81130038:	a809883a 	mov	r4,r21
8113003c:	112f2b40 	call	8112f2b4 <__ssprint_r>
81130040:	1000221e 	bne	r2,zero,811300cc <___svfiprintf_internal_r+0xc40>
81130044:	843ffc04 	addi	r16,r16,-16
81130048:	d8c01c17 	ldw	r3,112(sp)
8113004c:	d8801b17 	ldw	r2,108(sp)
81130050:	d811883a 	mov	r8,sp
81130054:	8c3fef16 	blt	r17,r16,81130014 <__reset+0xfb110014>
81130058:	dac02817 	ldw	r11,160(sp)
8113005c:	1c07883a 	add	r3,r3,r16
81130060:	10800044 	addi	r2,r2,1
81130064:	42c00015 	stw	r11,0(r8)
81130068:	44000115 	stw	r16,4(r8)
8113006c:	d8c01c15 	stw	r3,112(sp)
81130070:	d8801b15 	stw	r2,108(sp)
81130074:	010001c4 	movi	r4,7
81130078:	2080aa16 	blt	r4,r2,81130324 <___svfiprintf_internal_r+0xe98>
8113007c:	d8802417 	ldw	r2,144(sp)
81130080:	dac02017 	ldw	r11,128(sp)
81130084:	12c0010e 	bge	r2,r11,8113008c <___svfiprintf_internal_r+0xc00>
81130088:	5805883a 	mov	r2,r11
8113008c:	dac02517 	ldw	r11,148(sp)
81130090:	5897883a 	add	r11,r11,r2
81130094:	dac02515 	stw	r11,148(sp)
81130098:	1800531e 	bne	r3,zero,811301e8 <___svfiprintf_internal_r+0xd5c>
8113009c:	98800007 	ldb	r2,0(r19)
811300a0:	d8001b15 	stw	zero,108(sp)
811300a4:	d811883a 	mov	r8,sp
811300a8:	103d231e 	bne	r2,zero,8112f538 <__reset+0xfb10f538>
811300ac:	9823883a 	mov	r17,r19
811300b0:	003d3906 	br	8112f598 <__reset+0xfb10f598>
811300b4:	d8801c17 	ldw	r2,112(sp)
811300b8:	10000426 	beq	r2,zero,811300cc <___svfiprintf_internal_r+0xc40>
811300bc:	d9402717 	ldw	r5,156(sp)
811300c0:	d9002a17 	ldw	r4,168(sp)
811300c4:	d9801a04 	addi	r6,sp,104
811300c8:	112f2b40 	call	8112f2b4 <__ssprint_r>
811300cc:	dac02717 	ldw	r11,156(sp)
811300d0:	d8802517 	ldw	r2,148(sp)
811300d4:	58c0030b 	ldhu	r3,12(r11)
811300d8:	18c0100c 	andi	r3,r3,64
811300dc:	1801381e 	bne	r3,zero,811305c0 <___svfiprintf_internal_r+0x1134>
811300e0:	dfc03717 	ldw	ra,220(sp)
811300e4:	df003617 	ldw	fp,216(sp)
811300e8:	ddc03517 	ldw	r23,212(sp)
811300ec:	dd803417 	ldw	r22,208(sp)
811300f0:	dd403317 	ldw	r21,204(sp)
811300f4:	dd003217 	ldw	r20,200(sp)
811300f8:	dcc03117 	ldw	r19,196(sp)
811300fc:	dc803017 	ldw	r18,192(sp)
81130100:	dc402f17 	ldw	r17,188(sp)
81130104:	dc002e17 	ldw	r16,184(sp)
81130108:	dec03804 	addi	sp,sp,224
8113010c:	f800283a 	ret
81130110:	dac02417 	ldw	r11,144(sp)
81130114:	d9002017 	ldw	r4,128(sp)
81130118:	5939c83a 	sub	fp,r11,r4
8113011c:	073f780e 	bge	zero,fp,8112ff00 <__reset+0xfb10ff00>
81130120:	02400404 	movi	r9,16
81130124:	4f01370e 	bge	r9,fp,81130604 <___svfiprintf_internal_r+0x1178>
81130128:	02e04574 	movhi	r11,33045
8113012c:	5aff2404 	addi	r11,r11,-880
81130130:	dac02215 	stw	r11,136(sp)
81130134:	028001c4 	movi	r10,7
81130138:	00000306 	br	81130148 <___svfiprintf_internal_r+0xcbc>
8113013c:	e73ffc04 	addi	fp,fp,-16
81130140:	42000204 	addi	r8,r8,8
81130144:	4f00150e 	bge	r9,fp,8113019c <___svfiprintf_internal_r+0xd10>
81130148:	18c00404 	addi	r3,r3,16
8113014c:	10800044 	addi	r2,r2,1
81130150:	45000015 	stw	r20,0(r8)
81130154:	42400115 	stw	r9,4(r8)
81130158:	d8c01c15 	stw	r3,112(sp)
8113015c:	d8801b15 	stw	r2,108(sp)
81130160:	50bff60e 	bge	r10,r2,8113013c <__reset+0xfb11013c>
81130164:	d9801a04 	addi	r6,sp,104
81130168:	b80b883a 	mov	r5,r23
8113016c:	a809883a 	mov	r4,r21
81130170:	da402c15 	stw	r9,176(sp)
81130174:	da802d15 	stw	r10,180(sp)
81130178:	112f2b40 	call	8112f2b4 <__ssprint_r>
8113017c:	da402c17 	ldw	r9,176(sp)
81130180:	da802d17 	ldw	r10,180(sp)
81130184:	103fd11e 	bne	r2,zero,811300cc <__reset+0xfb1100cc>
81130188:	e73ffc04 	addi	fp,fp,-16
8113018c:	d8c01c17 	ldw	r3,112(sp)
81130190:	d8801b17 	ldw	r2,108(sp)
81130194:	d811883a 	mov	r8,sp
81130198:	4f3feb16 	blt	r9,fp,81130148 <__reset+0xfb110148>
8113019c:	dac02217 	ldw	r11,136(sp)
811301a0:	1f07883a 	add	r3,r3,fp
811301a4:	10800044 	addi	r2,r2,1
811301a8:	42c00015 	stw	r11,0(r8)
811301ac:	47000115 	stw	fp,4(r8)
811301b0:	d8c01c15 	stw	r3,112(sp)
811301b4:	d8801b15 	stw	r2,108(sp)
811301b8:	010001c4 	movi	r4,7
811301bc:	2080b616 	blt	r4,r2,81130498 <___svfiprintf_internal_r+0x100c>
811301c0:	42000204 	addi	r8,r8,8
811301c4:	003f4e06 	br	8112ff00 <__reset+0xfb10ff00>
811301c8:	d9801a04 	addi	r6,sp,104
811301cc:	b80b883a 	mov	r5,r23
811301d0:	a809883a 	mov	r4,r21
811301d4:	112f2b40 	call	8112f2b4 <__ssprint_r>
811301d8:	103fbc1e 	bne	r2,zero,811300cc <__reset+0xfb1100cc>
811301dc:	d8c01c17 	ldw	r3,112(sp)
811301e0:	d811883a 	mov	r8,sp
811301e4:	003f7a06 	br	8112ffd0 <__reset+0xfb10ffd0>
811301e8:	d9801a04 	addi	r6,sp,104
811301ec:	b80b883a 	mov	r5,r23
811301f0:	a809883a 	mov	r4,r21
811301f4:	112f2b40 	call	8112f2b4 <__ssprint_r>
811301f8:	103fa826 	beq	r2,zero,8113009c <__reset+0xfb11009c>
811301fc:	003fb306 	br	811300cc <__reset+0xfb1100cc>
81130200:	d9801a04 	addi	r6,sp,104
81130204:	b80b883a 	mov	r5,r23
81130208:	a809883a 	mov	r4,r21
8113020c:	112f2b40 	call	8112f2b4 <__ssprint_r>
81130210:	103fae1e 	bne	r2,zero,811300cc <__reset+0xfb1100cc>
81130214:	d811883a 	mov	r8,sp
81130218:	003cdc06 	br	8112f58c <__reset+0xfb10f58c>
8113021c:	d9801a04 	addi	r6,sp,104
81130220:	b80b883a 	mov	r5,r23
81130224:	a809883a 	mov	r4,r21
81130228:	112f2b40 	call	8112f2b4 <__ssprint_r>
8113022c:	103fa71e 	bne	r2,zero,811300cc <__reset+0xfb1100cc>
81130230:	d8c01c17 	ldw	r3,112(sp)
81130234:	d8801b17 	ldw	r2,108(sp)
81130238:	d811883a 	mov	r8,sp
8113023c:	003f5a06 	br	8112ffa8 <__reset+0xfb10ffa8>
81130240:	d9801a04 	addi	r6,sp,104
81130244:	b80b883a 	mov	r5,r23
81130248:	a809883a 	mov	r4,r21
8113024c:	112f2b40 	call	8112f2b4 <__ssprint_r>
81130250:	103f9e1e 	bne	r2,zero,811300cc <__reset+0xfb1100cc>
81130254:	d8c01c17 	ldw	r3,112(sp)
81130258:	d8801b17 	ldw	r2,108(sp)
8113025c:	d811883a 	mov	r8,sp
81130260:	003f1706 	br	8112fec0 <__reset+0xfb10fec0>
81130264:	d9801a04 	addi	r6,sp,104
81130268:	b80b883a 	mov	r5,r23
8113026c:	a809883a 	mov	r4,r21
81130270:	112f2b40 	call	8112f2b4 <__ssprint_r>
81130274:	103f951e 	bne	r2,zero,811300cc <__reset+0xfb1100cc>
81130278:	d8c01c17 	ldw	r3,112(sp)
8113027c:	d8801b17 	ldw	r2,108(sp)
81130280:	d811883a 	mov	r8,sp
81130284:	003f1b06 	br	8112fef4 <__reset+0xfb10fef4>
81130288:	d8001d85 	stb	zero,118(sp)
8113028c:	80007b16 	blt	r16,zero,8113047c <___svfiprintf_internal_r+0xff0>
81130290:	00ffdfc4 	movi	r3,-129
81130294:	e244b03a 	or	r2,fp,r9
81130298:	90e4703a 	and	r18,r18,r3
8113029c:	103d7026 	beq	r2,zero,8112f860 <__reset+0xfb10f860>
811302a0:	0015883a 	mov	r10,zero
811302a4:	003d7206 	br	8112f870 <__reset+0xfb10f870>
811302a8:	d9801a04 	addi	r6,sp,104
811302ac:	b80b883a 	mov	r5,r23
811302b0:	a809883a 	mov	r4,r21
811302b4:	112f2b40 	call	8112f2b4 <__ssprint_r>
811302b8:	103f841e 	bne	r2,zero,811300cc <__reset+0xfb1100cc>
811302bc:	d8c01c17 	ldw	r3,112(sp)
811302c0:	d8801b17 	ldw	r2,108(sp)
811302c4:	d811883a 	mov	r8,sp
811302c8:	003ef006 	br	8112fe8c <__reset+0xfb10fe8c>
811302cc:	9080100c 	andi	r2,r18,64
811302d0:	d8001d85 	stb	zero,118(sp)
811302d4:	dac02317 	ldw	r11,140(sp)
811302d8:	10008126 	beq	r2,zero,811304e0 <___svfiprintf_internal_r+0x1054>
811302dc:	58800104 	addi	r2,r11,4
811302e0:	5f00000b 	ldhu	fp,0(r11)
811302e4:	0013883a 	mov	r9,zero
811302e8:	803ec30e 	bge	r16,zero,8112fdf8 <__reset+0xfb10fdf8>
811302ec:	d8802315 	stw	r2,140(sp)
811302f0:	0015883a 	mov	r10,zero
811302f4:	e244b03a 	or	r2,fp,r9
811302f8:	103e371e 	bne	r2,zero,8112fbd8 <__reset+0xfb10fbd8>
811302fc:	00800044 	movi	r2,1
81130300:	10803fcc 	andi	r2,r2,255
81130304:	00c00044 	movi	r3,1
81130308:	10c06126 	beq	r2,r3,81130490 <___svfiprintf_internal_r+0x1004>
8113030c:	00c00084 	movi	r3,2
81130310:	10fd5526 	beq	r2,r3,8112f868 <__reset+0xfb10f868>
81130314:	003ed806 	br	8112fe78 <__reset+0xfb10fe78>
81130318:	d8802315 	stw	r2,140(sp)
8113031c:	98c00007 	ldb	r3,0(r19)
81130320:	003cab06 	br	8112f5d0 <__reset+0xfb10f5d0>
81130324:	d9801a04 	addi	r6,sp,104
81130328:	b80b883a 	mov	r5,r23
8113032c:	a809883a 	mov	r4,r21
81130330:	112f2b40 	call	8112f2b4 <__ssprint_r>
81130334:	103f651e 	bne	r2,zero,811300cc <__reset+0xfb1100cc>
81130338:	d8c01c17 	ldw	r3,112(sp)
8113033c:	003f4f06 	br	8113007c <__reset+0xfb11007c>
81130340:	00a04574 	movhi	r2,33045
81130344:	10be9a04 	addi	r2,r2,-1432
81130348:	d8802915 	stw	r2,164(sp)
8113034c:	003d4406 	br	8112f860 <__reset+0xfb10f860>
81130350:	dac02317 	ldw	r11,140(sp)
81130354:	58800017 	ldw	r2,0(r11)
81130358:	dac02517 	ldw	r11,148(sp)
8113035c:	5807d7fa 	srai	r3,r11,31
81130360:	dac02317 	ldw	r11,140(sp)
81130364:	10c00115 	stw	r3,4(r2)
81130368:	5ac00104 	addi	r11,r11,4
8113036c:	dac02315 	stw	r11,140(sp)
81130370:	dac02517 	ldw	r11,148(sp)
81130374:	12c00015 	stw	r11,0(r2)
81130378:	003c6d06 	br	8112f530 <__reset+0xfb10f530>
8113037c:	9080100c 	andi	r2,r18,64
81130380:	dac02317 	ldw	r11,140(sp)
81130384:	103e5326 	beq	r2,zero,8112fcd4 <__reset+0xfb10fcd4>
81130388:	5f00000f 	ldh	fp,0(r11)
8113038c:	5ac00104 	addi	r11,r11,4
81130390:	dac02315 	stw	r11,140(sp)
81130394:	e013d7fa 	srai	r9,fp,31
81130398:	4805883a 	mov	r2,r9
8113039c:	003e0706 	br	8112fbbc <__reset+0xfb10fbbc>
811303a0:	00800c04 	movi	r2,48
811303a4:	d8801d05 	stb	r2,116(sp)
811303a8:	d8c01d45 	stb	r3,117(sp)
811303ac:	d8001d85 	stb	zero,118(sp)
811303b0:	90800094 	ori	r2,r18,2
811303b4:	80008f16 	blt	r16,zero,811305f4 <___svfiprintf_internal_r+0x1168>
811303b8:	00bfdfc4 	movi	r2,-129
811303bc:	90a4703a 	and	r18,r18,r2
811303c0:	94800094 	ori	r18,r18,2
811303c4:	0015883a 	mov	r10,zero
811303c8:	003d2906 	br	8112f870 <__reset+0xfb10f870>
811303cc:	98c00007 	ldb	r3,0(r19)
811303d0:	003c7f06 	br	8112f5d0 <__reset+0xfb10f5d0>
811303d4:	dac02317 	ldw	r11,140(sp)
811303d8:	0013883a 	mov	r9,zero
811303dc:	5f000017 	ldw	fp,0(r11)
811303e0:	5ac00104 	addi	r11,r11,4
811303e4:	dac02315 	stw	r11,140(sp)
811303e8:	003d1506 	br	8112f840 <__reset+0xfb10f840>
811303ec:	9080100c 	andi	r2,r18,64
811303f0:	d8001d85 	stb	zero,118(sp)
811303f4:	dac02317 	ldw	r11,140(sp)
811303f8:	10003426 	beq	r2,zero,811304cc <___svfiprintf_internal_r+0x1040>
811303fc:	58800104 	addi	r2,r11,4
81130400:	5f00000b 	ldhu	fp,0(r11)
81130404:	0013883a 	mov	r9,zero
81130408:	803e950e 	bge	r16,zero,8112fe60 <__reset+0xfb10fe60>
8113040c:	e246b03a 	or	r3,fp,r9
81130410:	d8802315 	stw	r2,140(sp)
81130414:	183d5a1e 	bne	r3,zero,8112f980 <__reset+0xfb10f980>
81130418:	0015883a 	mov	r10,zero
8113041c:	0005883a 	mov	r2,zero
81130420:	003fb706 	br	81130300 <__reset+0xfb110300>
81130424:	98c00043 	ldbu	r3,1(r19)
81130428:	94800814 	ori	r18,r18,32
8113042c:	9cc00044 	addi	r19,r19,1
81130430:	18c03fcc 	andi	r3,r3,255
81130434:	18c0201c 	xori	r3,r3,128
81130438:	18ffe004 	addi	r3,r3,-128
8113043c:	003c6406 	br	8112f5d0 <__reset+0xfb10f5d0>
81130440:	d8c02315 	stw	r3,140(sp)
81130444:	0015883a 	mov	r10,zero
81130448:	003faa06 	br	811302f4 <__reset+0xfb1102f4>
8113044c:	dac02317 	ldw	r11,140(sp)
81130450:	58800017 	ldw	r2,0(r11)
81130454:	5ac00104 	addi	r11,r11,4
81130458:	dac02315 	stw	r11,140(sp)
8113045c:	dac02517 	ldw	r11,148(sp)
81130460:	12c00015 	stw	r11,0(r2)
81130464:	003c3206 	br	8112f530 <__reset+0xfb10f530>
81130468:	01204574 	movhi	r4,33045
8113046c:	213e9a04 	addi	r4,r4,-1432
81130470:	d9002915 	stw	r4,164(sp)
81130474:	d8c02315 	stw	r3,140(sp)
81130478:	1025883a 	mov	r18,r2
8113047c:	e244b03a 	or	r2,fp,r9
81130480:	103f871e 	bne	r2,zero,811302a0 <__reset+0xfb1102a0>
81130484:	0015883a 	mov	r10,zero
81130488:	00800084 	movi	r2,2
8113048c:	003f9c06 	br	81130300 <__reset+0xfb110300>
81130490:	0039883a 	mov	fp,zero
81130494:	003e5f06 	br	8112fe14 <__reset+0xfb10fe14>
81130498:	d9801a04 	addi	r6,sp,104
8113049c:	b80b883a 	mov	r5,r23
811304a0:	a809883a 	mov	r4,r21
811304a4:	112f2b40 	call	8112f2b4 <__ssprint_r>
811304a8:	103f081e 	bne	r2,zero,811300cc <__reset+0xfb1100cc>
811304ac:	d8c01c17 	ldw	r3,112(sp)
811304b0:	d8801b17 	ldw	r2,108(sp)
811304b4:	d811883a 	mov	r8,sp
811304b8:	003e9106 	br	8112ff00 <__reset+0xfb10ff00>
811304bc:	01204574 	movhi	r4,33045
811304c0:	213f2404 	addi	r4,r4,-880
811304c4:	d9002215 	stw	r4,136(sp)
811304c8:	003ead06 	br	8112ff80 <__reset+0xfb10ff80>
811304cc:	58800104 	addi	r2,r11,4
811304d0:	5f000017 	ldw	fp,0(r11)
811304d4:	0013883a 	mov	r9,zero
811304d8:	803e610e 	bge	r16,zero,8112fe60 <__reset+0xfb10fe60>
811304dc:	003fcb06 	br	8113040c <__reset+0xfb11040c>
811304e0:	58800104 	addi	r2,r11,4
811304e4:	5f000017 	ldw	fp,0(r11)
811304e8:	0013883a 	mov	r9,zero
811304ec:	803e420e 	bge	r16,zero,8112fdf8 <__reset+0xfb10fdf8>
811304f0:	003f7e06 	br	811302ec <__reset+0xfb1102ec>
811304f4:	5f000017 	ldw	fp,0(r11)
811304f8:	5ac00104 	addi	r11,r11,4
811304fc:	0013883a 	mov	r9,zero
81130500:	dac02315 	stw	r11,140(sp)
81130504:	003cce06 	br	8112f840 <__reset+0xfb10f840>
81130508:	8809883a 	mov	r4,r17
8113050c:	da002c15 	stw	r8,176(sp)
81130510:	112235c0 	call	8112235c <strlen>
81130514:	d8802115 	stw	r2,132(sp)
81130518:	da801d83 	ldbu	r10,118(sp)
8113051c:	df002315 	stw	fp,140(sp)
81130520:	0021883a 	mov	r16,zero
81130524:	da002c17 	ldw	r8,176(sp)
81130528:	003cf606 	br	8112f904 <__reset+0xfb10f904>
8113052c:	00800184 	movi	r2,6
81130530:	1400012e 	bgeu	r2,r16,81130538 <___svfiprintf_internal_r+0x10ac>
81130534:	1021883a 	mov	r16,r2
81130538:	dc002115 	stw	r16,132(sp)
8113053c:	8005883a 	mov	r2,r16
81130540:	80003c16 	blt	r16,zero,81130634 <___svfiprintf_internal_r+0x11a8>
81130544:	04604574 	movhi	r17,33045
81130548:	d8802015 	stw	r2,128(sp)
8113054c:	df002315 	stw	fp,140(sp)
81130550:	8c7e9f04 	addi	r17,r17,-1412
81130554:	003d2e06 	br	8112fa10 <__reset+0xfb10fa10>
81130558:	04001004 	movi	r16,64
8113055c:	800b883a 	mov	r5,r16
81130560:	11210540 	call	81121054 <_malloc_r>
81130564:	dac02717 	ldw	r11,156(sp)
81130568:	58800015 	stw	r2,0(r11)
8113056c:	58800415 	stw	r2,16(r11)
81130570:	10004826 	beq	r2,zero,81130694 <___svfiprintf_internal_r+0x1208>
81130574:	dac02717 	ldw	r11,156(sp)
81130578:	5c000515 	stw	r16,20(r11)
8113057c:	003bd906 	br	8112f4e4 <__reset+0xfb10f4e4>
81130580:	9080004c 	andi	r2,r18,1
81130584:	0015883a 	mov	r10,zero
81130588:	10000626 	beq	r2,zero,811305a4 <___svfiprintf_internal_r+0x1118>
8113058c:	dac02b17 	ldw	r11,172(sp)
81130590:	00800c04 	movi	r2,48
81130594:	d88019c5 	stb	r2,103(sp)
81130598:	dac02115 	stw	r11,132(sp)
8113059c:	dc4019c4 	addi	r17,sp,103
811305a0:	003cd806 	br	8112f904 <__reset+0xfb10f904>
811305a4:	d8002115 	stw	zero,132(sp)
811305a8:	dc401a04 	addi	r17,sp,104
811305ac:	003cd506 	br	8112f904 <__reset+0xfb10f904>
811305b0:	01204574 	movhi	r4,33045
811305b4:	213f2804 	addi	r4,r4,-864
811305b8:	d9002815 	stw	r4,160(sp)
811305bc:	003d4306 	br	8112facc <__reset+0xfb10facc>
811305c0:	00bfffc4 	movi	r2,-1
811305c4:	003ec606 	br	811300e0 <__reset+0xfb1100e0>
811305c8:	00800044 	movi	r2,1
811305cc:	10803fcc 	andi	r2,r2,255
811305d0:	00c00044 	movi	r3,1
811305d4:	10fd8026 	beq	r2,r3,8112fbd8 <__reset+0xfb10fbd8>
811305d8:	00c00084 	movi	r3,2
811305dc:	10fca426 	beq	r2,r3,8112f870 <__reset+0xfb10f870>
811305e0:	003ce806 	br	8112f984 <__reset+0xfb10f984>
811305e4:	01204574 	movhi	r4,33045
811305e8:	213f2804 	addi	r4,r4,-864
811305ec:	d9002815 	stw	r4,160(sp)
811305f0:	003e9906 	br	81130058 <__reset+0xfb110058>
811305f4:	1025883a 	mov	r18,r2
811305f8:	0015883a 	mov	r10,zero
811305fc:	00800084 	movi	r2,2
81130600:	003ff206 	br	811305cc <__reset+0xfb1105cc>
81130604:	01604574 	movhi	r5,33045
81130608:	297f2404 	addi	r5,r5,-880
8113060c:	d9402215 	stw	r5,136(sp)
81130610:	003ee206 	br	8113019c <__reset+0xfb11019c>
81130614:	5827883a 	mov	r19,r11
81130618:	0021883a 	mov	r16,zero
8113061c:	003bed06 	br	8112f5d4 <__reset+0xfb10f5d4>
81130620:	dc002115 	stw	r16,132(sp)
81130624:	da801d83 	ldbu	r10,118(sp)
81130628:	df002315 	stw	fp,140(sp)
8113062c:	0021883a 	mov	r16,zero
81130630:	003cb406 	br	8112f904 <__reset+0xfb10f904>
81130634:	0005883a 	mov	r2,zero
81130638:	003fc206 	br	81130544 <__reset+0xfb110544>
8113063c:	d8802317 	ldw	r2,140(sp)
81130640:	98c00043 	ldbu	r3,1(r19)
81130644:	5827883a 	mov	r19,r11
81130648:	14000017 	ldw	r16,0(r2)
8113064c:	10800104 	addi	r2,r2,4
81130650:	d8802315 	stw	r2,140(sp)
81130654:	803f760e 	bge	r16,zero,81130430 <__reset+0xfb110430>
81130658:	18c03fcc 	andi	r3,r3,255
8113065c:	18c0201c 	xori	r3,r3,128
81130660:	043fffc4 	movi	r16,-1
81130664:	18ffe004 	addi	r3,r3,-128
81130668:	003bd906 	br	8112f5d0 <__reset+0xfb10f5d0>
8113066c:	d9c01d85 	stb	r7,118(sp)
81130670:	003cb606 	br	8112f94c <__reset+0xfb10f94c>
81130674:	d9c01d85 	stb	r7,118(sp)
81130678:	003d2106 	br	8112fb00 <__reset+0xfb10fb00>
8113067c:	d9c01d85 	stb	r7,118(sp)
81130680:	003d8e06 	br	8112fcbc <__reset+0xfb10fcbc>
81130684:	d9c01d85 	stb	r7,118(sp)
81130688:	003db306 	br	8112fd58 <__reset+0xfb10fd58>
8113068c:	d9c01d85 	stb	r7,118(sp)
81130690:	003c8a06 	br	8112f8bc <__reset+0xfb10f8bc>
81130694:	dac02a17 	ldw	r11,168(sp)
81130698:	00800304 	movi	r2,12
8113069c:	58800015 	stw	r2,0(r11)
811306a0:	00bfffc4 	movi	r2,-1
811306a4:	003e8e06 	br	811300e0 <__reset+0xfb1100e0>
811306a8:	d9c01d85 	stb	r7,118(sp)
811306ac:	003dc706 	br	8112fdcc <__reset+0xfb10fdcc>
811306b0:	d9c01d85 	stb	r7,118(sp)
811306b4:	003ddf06 	br	8112fe34 <__reset+0xfb10fe34>
811306b8:	d9c01d85 	stb	r7,118(sp)
811306bc:	003d3706 	br	8112fb9c <__reset+0xfb10fb9c>
811306c0:	d9c01d85 	stb	r7,118(sp)
811306c4:	003c5406 	br	8112f818 <__reset+0xfb10f818>
811306c8:	d9c01d85 	stb	r7,118(sp)
811306cc:	003d1d06 	br	8112fb44 <__reset+0xfb10fb44>

811306d0 <__submore>:
811306d0:	defffa04 	addi	sp,sp,-24
811306d4:	de00012e 	bgeu	sp,et,811306dc <__submore+0xc>
811306d8:	003b68fa 	trap	3
811306dc:	dc000015 	stw	r16,0(sp)
811306e0:	2821883a 	mov	r16,r5
811306e4:	29400c17 	ldw	r5,48(r5)
811306e8:	dfc00515 	stw	ra,20(sp)
811306ec:	dd000415 	stw	r20,16(sp)
811306f0:	dcc00315 	stw	r19,12(sp)
811306f4:	dc800215 	stw	r18,8(sp)
811306f8:	dc400115 	stw	r17,4(sp)
811306fc:	80801004 	addi	r2,r16,64
81130700:	28801726 	beq	r5,r2,81130760 <__submore+0x90>
81130704:	84400d17 	ldw	r17,52(r16)
81130708:	8c67883a 	add	r19,r17,r17
8113070c:	980d883a 	mov	r6,r19
81130710:	112cb5c0 	call	8112cb5c <_realloc_r>
81130714:	1025883a 	mov	r18,r2
81130718:	10002226 	beq	r2,zero,811307a4 <__submore+0xd4>
8113071c:	1469883a 	add	r20,r2,r17
81130720:	880d883a 	mov	r6,r17
81130724:	100b883a 	mov	r5,r2
81130728:	a009883a 	mov	r4,r20
8113072c:	11218680 	call	81121868 <memcpy>
81130730:	0005883a 	mov	r2,zero
81130734:	85000015 	stw	r20,0(r16)
81130738:	84800c15 	stw	r18,48(r16)
8113073c:	84c00d15 	stw	r19,52(r16)
81130740:	dfc00517 	ldw	ra,20(sp)
81130744:	dd000417 	ldw	r20,16(sp)
81130748:	dcc00317 	ldw	r19,12(sp)
8113074c:	dc800217 	ldw	r18,8(sp)
81130750:	dc400117 	ldw	r17,4(sp)
81130754:	dc000017 	ldw	r16,0(sp)
81130758:	dec00604 	addi	sp,sp,24
8113075c:	f800283a 	ret
81130760:	04410004 	movi	r17,1024
81130764:	880b883a 	mov	r5,r17
81130768:	11210540 	call	81121054 <_malloc_r>
8113076c:	1007883a 	mov	r3,r2
81130770:	10000c26 	beq	r2,zero,811307a4 <__submore+0xd4>
81130774:	80801083 	ldbu	r2,66(r16)
81130778:	80c00c15 	stw	r3,48(r16)
8113077c:	84400d15 	stw	r17,52(r16)
81130780:	1880ffc5 	stb	r2,1023(r3)
81130784:	81401043 	ldbu	r5,65(r16)
81130788:	1900ff44 	addi	r4,r3,1021
8113078c:	0005883a 	mov	r2,zero
81130790:	1940ff85 	stb	r5,1022(r3)
81130794:	81401003 	ldbu	r5,64(r16)
81130798:	1940ff45 	stb	r5,1021(r3)
8113079c:	81000015 	stw	r4,0(r16)
811307a0:	003fe706 	br	81130740 <__reset+0xfb110740>
811307a4:	00bfffc4 	movi	r2,-1
811307a8:	003fe506 	br	81130740 <__reset+0xfb110740>

811307ac <_ungetc_r>:
811307ac:	00bfffc4 	movi	r2,-1
811307b0:	28806326 	beq	r5,r2,81130940 <_ungetc_r+0x194>
811307b4:	defffb04 	addi	sp,sp,-20
811307b8:	de00012e 	bgeu	sp,et,811307c0 <_ungetc_r+0x14>
811307bc:	003b68fa 	trap	3
811307c0:	dcc00315 	stw	r19,12(sp)
811307c4:	dc400115 	stw	r17,4(sp)
811307c8:	dc000015 	stw	r16,0(sp)
811307cc:	dfc00415 	stw	ra,16(sp)
811307d0:	dc800215 	stw	r18,8(sp)
811307d4:	2023883a 	mov	r17,r4
811307d8:	3021883a 	mov	r16,r6
811307dc:	2827883a 	mov	r19,r5
811307e0:	20000226 	beq	r4,zero,811307ec <_ungetc_r+0x40>
811307e4:	20800e17 	ldw	r2,56(r4)
811307e8:	10002e26 	beq	r2,zero,811308a4 <_ungetc_r+0xf8>
811307ec:	80c0030b 	ldhu	r3,12(r16)
811307f0:	1888000c 	andi	r2,r3,8192
811307f4:	1000051e 	bne	r2,zero,8113080c <_ungetc_r+0x60>
811307f8:	81001917 	ldw	r4,100(r16)
811307fc:	00b7ffc4 	movi	r2,-8193
81130800:	18c80014 	ori	r3,r3,8192
81130804:	2084703a 	and	r2,r4,r2
81130808:	80801915 	stw	r2,100(r16)
8113080c:	00bff7c4 	movi	r2,-33
81130810:	1884703a 	and	r2,r3,r2
81130814:	8080030d 	sth	r2,12(r16)
81130818:	1900010c 	andi	r4,r3,4
8113081c:	2000061e 	bne	r4,zero,81130838 <_ungetc_r+0x8c>
81130820:	1900040c 	andi	r4,r3,16
81130824:	20001d26 	beq	r4,zero,8113089c <_ungetc_r+0xf0>
81130828:	18c0020c 	andi	r3,r3,8
8113082c:	1800331e 	bne	r3,zero,811308fc <_ungetc_r+0x150>
81130830:	10800114 	ori	r2,r2,4
81130834:	8080030d 	sth	r2,12(r16)
81130838:	80800c17 	ldw	r2,48(r16)
8113083c:	9c803fcc 	andi	r18,r19,255
81130840:	10001a26 	beq	r2,zero,811308ac <_ungetc_r+0x100>
81130844:	80c00117 	ldw	r3,4(r16)
81130848:	80800d17 	ldw	r2,52(r16)
8113084c:	18800f0e 	bge	r3,r2,8113088c <_ungetc_r+0xe0>
81130850:	80c00017 	ldw	r3,0(r16)
81130854:	9005883a 	mov	r2,r18
81130858:	193fffc4 	addi	r4,r3,-1
8113085c:	81000015 	stw	r4,0(r16)
81130860:	1cffffc5 	stb	r19,-1(r3)
81130864:	80c00117 	ldw	r3,4(r16)
81130868:	18c00044 	addi	r3,r3,1
8113086c:	80c00115 	stw	r3,4(r16)
81130870:	dfc00417 	ldw	ra,16(sp)
81130874:	dcc00317 	ldw	r19,12(sp)
81130878:	dc800217 	ldw	r18,8(sp)
8113087c:	dc400117 	ldw	r17,4(sp)
81130880:	dc000017 	ldw	r16,0(sp)
81130884:	dec00504 	addi	sp,sp,20
81130888:	f800283a 	ret
8113088c:	800b883a 	mov	r5,r16
81130890:	8809883a 	mov	r4,r17
81130894:	11306d00 	call	811306d0 <__submore>
81130898:	103fed26 	beq	r2,zero,81130850 <__reset+0xfb110850>
8113089c:	00bfffc4 	movi	r2,-1
811308a0:	003ff306 	br	81130870 <__reset+0xfb110870>
811308a4:	112a6300 	call	8112a630 <__sinit>
811308a8:	003fd006 	br	811307ec <__reset+0xfb1107ec>
811308ac:	80c00417 	ldw	r3,16(r16)
811308b0:	80800017 	ldw	r2,0(r16)
811308b4:	18000326 	beq	r3,zero,811308c4 <_ungetc_r+0x118>
811308b8:	1880022e 	bgeu	r3,r2,811308c4 <_ungetc_r+0x118>
811308bc:	10ffffc3 	ldbu	r3,-1(r2)
811308c0:	90c01826 	beq	r18,r3,81130924 <_ungetc_r+0x178>
811308c4:	81400117 	ldw	r5,4(r16)
811308c8:	80800e15 	stw	r2,56(r16)
811308cc:	008000c4 	movi	r2,3
811308d0:	81001004 	addi	r4,r16,64
811308d4:	80c01084 	addi	r3,r16,66
811308d8:	80800d15 	stw	r2,52(r16)
811308dc:	00800044 	movi	r2,1
811308e0:	80800115 	stw	r2,4(r16)
811308e4:	81400f15 	stw	r5,60(r16)
811308e8:	81000c15 	stw	r4,48(r16)
811308ec:	84c01085 	stb	r19,66(r16)
811308f0:	80c00015 	stw	r3,0(r16)
811308f4:	9005883a 	mov	r2,r18
811308f8:	003fdd06 	br	81130870 <__reset+0xfb110870>
811308fc:	800b883a 	mov	r5,r16
81130900:	8809883a 	mov	r4,r17
81130904:	112a2340 	call	8112a234 <_fflush_r>
81130908:	103fe41e 	bne	r2,zero,8113089c <__reset+0xfb11089c>
8113090c:	8080030b 	ldhu	r2,12(r16)
81130910:	00fffdc4 	movi	r3,-9
81130914:	80000215 	stw	zero,8(r16)
81130918:	1884703a 	and	r2,r3,r2
8113091c:	80000615 	stw	zero,24(r16)
81130920:	003fc306 	br	81130830 <__reset+0xfb110830>
81130924:	80c00117 	ldw	r3,4(r16)
81130928:	10bfffc4 	addi	r2,r2,-1
8113092c:	80800015 	stw	r2,0(r16)
81130930:	18800044 	addi	r2,r3,1
81130934:	80800115 	stw	r2,4(r16)
81130938:	9005883a 	mov	r2,r18
8113093c:	003fcc06 	br	81130870 <__reset+0xfb110870>
81130940:	00bfffc4 	movi	r2,-1
81130944:	f800283a 	ret

81130948 <ungetc>:
81130948:	00a04574 	movhi	r2,33045
8113094c:	10886904 	addi	r2,r2,8612
81130950:	280d883a 	mov	r6,r5
81130954:	200b883a 	mov	r5,r4
81130958:	11000017 	ldw	r4,0(r2)
8113095c:	11307ac1 	jmpi	811307ac <_ungetc_r>

81130960 <__sprint_r.part.0>:
81130960:	defff604 	addi	sp,sp,-40
81130964:	de00012e 	bgeu	sp,et,8113096c <__sprint_r.part.0+0xc>
81130968:	003b68fa 	trap	3
8113096c:	28801917 	ldw	r2,100(r5)
81130970:	dd400515 	stw	r21,20(sp)
81130974:	dfc00915 	stw	ra,36(sp)
81130978:	df000815 	stw	fp,32(sp)
8113097c:	ddc00715 	stw	r23,28(sp)
81130980:	dd800615 	stw	r22,24(sp)
81130984:	dd000415 	stw	r20,16(sp)
81130988:	dcc00315 	stw	r19,12(sp)
8113098c:	dc800215 	stw	r18,8(sp)
81130990:	dc400115 	stw	r17,4(sp)
81130994:	dc000015 	stw	r16,0(sp)
81130998:	1088000c 	andi	r2,r2,8192
8113099c:	302b883a 	mov	r21,r6
811309a0:	10002e26 	beq	r2,zero,81130a5c <__sprint_r.part.0+0xfc>
811309a4:	30800217 	ldw	r2,8(r6)
811309a8:	35800017 	ldw	r22,0(r6)
811309ac:	10002926 	beq	r2,zero,81130a54 <__sprint_r.part.0+0xf4>
811309b0:	2827883a 	mov	r19,r5
811309b4:	2029883a 	mov	r20,r4
811309b8:	b5c00104 	addi	r23,r22,4
811309bc:	04bfffc4 	movi	r18,-1
811309c0:	bc400017 	ldw	r17,0(r23)
811309c4:	b4000017 	ldw	r16,0(r22)
811309c8:	0039883a 	mov	fp,zero
811309cc:	8822d0ba 	srli	r17,r17,2
811309d0:	8800031e 	bne	r17,zero,811309e0 <__sprint_r.part.0+0x80>
811309d4:	00001806 	br	81130a38 <__sprint_r.part.0+0xd8>
811309d8:	84000104 	addi	r16,r16,4
811309dc:	8f001526 	beq	r17,fp,81130a34 <__sprint_r.part.0+0xd4>
811309e0:	81400017 	ldw	r5,0(r16)
811309e4:	980d883a 	mov	r6,r19
811309e8:	a009883a 	mov	r4,r20
811309ec:	11323040 	call	81132304 <_fputwc_r>
811309f0:	e7000044 	addi	fp,fp,1
811309f4:	14bff81e 	bne	r2,r18,811309d8 <__reset+0xfb1109d8>
811309f8:	9005883a 	mov	r2,r18
811309fc:	a8000215 	stw	zero,8(r21)
81130a00:	a8000115 	stw	zero,4(r21)
81130a04:	dfc00917 	ldw	ra,36(sp)
81130a08:	df000817 	ldw	fp,32(sp)
81130a0c:	ddc00717 	ldw	r23,28(sp)
81130a10:	dd800617 	ldw	r22,24(sp)
81130a14:	dd400517 	ldw	r21,20(sp)
81130a18:	dd000417 	ldw	r20,16(sp)
81130a1c:	dcc00317 	ldw	r19,12(sp)
81130a20:	dc800217 	ldw	r18,8(sp)
81130a24:	dc400117 	ldw	r17,4(sp)
81130a28:	dc000017 	ldw	r16,0(sp)
81130a2c:	dec00a04 	addi	sp,sp,40
81130a30:	f800283a 	ret
81130a34:	a8800217 	ldw	r2,8(r21)
81130a38:	8c63883a 	add	r17,r17,r17
81130a3c:	8c63883a 	add	r17,r17,r17
81130a40:	1445c83a 	sub	r2,r2,r17
81130a44:	a8800215 	stw	r2,8(r21)
81130a48:	b5800204 	addi	r22,r22,8
81130a4c:	bdc00204 	addi	r23,r23,8
81130a50:	103fdb1e 	bne	r2,zero,811309c0 <__reset+0xfb1109c0>
81130a54:	0005883a 	mov	r2,zero
81130a58:	003fe806 	br	811309fc <__reset+0xfb1109fc>
81130a5c:	112ade00 	call	8112ade0 <__sfvwrite_r>
81130a60:	003fe606 	br	811309fc <__reset+0xfb1109fc>

81130a64 <__sprint_r>:
81130a64:	30c00217 	ldw	r3,8(r6)
81130a68:	18000126 	beq	r3,zero,81130a70 <__sprint_r+0xc>
81130a6c:	11309601 	jmpi	81130960 <__sprint_r.part.0>
81130a70:	30000115 	stw	zero,4(r6)
81130a74:	0005883a 	mov	r2,zero
81130a78:	f800283a 	ret

81130a7c <___vfiprintf_internal_r>:
81130a7c:	deffc904 	addi	sp,sp,-220
81130a80:	de00012e 	bgeu	sp,et,81130a88 <___vfiprintf_internal_r+0xc>
81130a84:	003b68fa 	trap	3
81130a88:	df003515 	stw	fp,212(sp)
81130a8c:	dd003115 	stw	r20,196(sp)
81130a90:	dfc03615 	stw	ra,216(sp)
81130a94:	ddc03415 	stw	r23,208(sp)
81130a98:	dd803315 	stw	r22,204(sp)
81130a9c:	dd403215 	stw	r21,200(sp)
81130aa0:	dcc03015 	stw	r19,192(sp)
81130aa4:	dc802f15 	stw	r18,188(sp)
81130aa8:	dc402e15 	stw	r17,184(sp)
81130aac:	dc002d15 	stw	r16,180(sp)
81130ab0:	d9002015 	stw	r4,128(sp)
81130ab4:	d9c02215 	stw	r7,136(sp)
81130ab8:	2829883a 	mov	r20,r5
81130abc:	3039883a 	mov	fp,r6
81130ac0:	20000226 	beq	r4,zero,81130acc <___vfiprintf_internal_r+0x50>
81130ac4:	20800e17 	ldw	r2,56(r4)
81130ac8:	1000cf26 	beq	r2,zero,81130e08 <___vfiprintf_internal_r+0x38c>
81130acc:	a080030b 	ldhu	r2,12(r20)
81130ad0:	10c8000c 	andi	r3,r2,8192
81130ad4:	1800061e 	bne	r3,zero,81130af0 <___vfiprintf_internal_r+0x74>
81130ad8:	a1001917 	ldw	r4,100(r20)
81130adc:	00f7ffc4 	movi	r3,-8193
81130ae0:	10880014 	ori	r2,r2,8192
81130ae4:	20c6703a 	and	r3,r4,r3
81130ae8:	a080030d 	sth	r2,12(r20)
81130aec:	a0c01915 	stw	r3,100(r20)
81130af0:	10c0020c 	andi	r3,r2,8
81130af4:	1800a926 	beq	r3,zero,81130d9c <___vfiprintf_internal_r+0x320>
81130af8:	a0c00417 	ldw	r3,16(r20)
81130afc:	1800a726 	beq	r3,zero,81130d9c <___vfiprintf_internal_r+0x320>
81130b00:	1080068c 	andi	r2,r2,26
81130b04:	00c00284 	movi	r3,10
81130b08:	10c0ac26 	beq	r2,r3,81130dbc <___vfiprintf_internal_r+0x340>
81130b0c:	da801a04 	addi	r10,sp,104
81130b10:	da801e15 	stw	r10,120(sp)
81130b14:	d8801e17 	ldw	r2,120(sp)
81130b18:	da8019c4 	addi	r10,sp,103
81130b1c:	05a04574 	movhi	r22,33045
81130b20:	05e04574 	movhi	r23,33045
81130b24:	da801f15 	stw	r10,124(sp)
81130b28:	1295c83a 	sub	r10,r2,r10
81130b2c:	b5bf3004 	addi	r22,r22,-832
81130b30:	bdff2c04 	addi	r23,r23,-848
81130b34:	dec01a15 	stw	sp,104(sp)
81130b38:	d8001c15 	stw	zero,112(sp)
81130b3c:	d8001b15 	stw	zero,108(sp)
81130b40:	d8002615 	stw	zero,152(sp)
81130b44:	d8002315 	stw	zero,140(sp)
81130b48:	da802715 	stw	r10,156(sp)
81130b4c:	d811883a 	mov	r8,sp
81130b50:	dd002115 	stw	r20,132(sp)
81130b54:	e021883a 	mov	r16,fp
81130b58:	80800007 	ldb	r2,0(r16)
81130b5c:	1003ea26 	beq	r2,zero,81131b08 <___vfiprintf_internal_r+0x108c>
81130b60:	00c00944 	movi	r3,37
81130b64:	8025883a 	mov	r18,r16
81130b68:	10c0021e 	bne	r2,r3,81130b74 <___vfiprintf_internal_r+0xf8>
81130b6c:	00001606 	br	81130bc8 <___vfiprintf_internal_r+0x14c>
81130b70:	10c00326 	beq	r2,r3,81130b80 <___vfiprintf_internal_r+0x104>
81130b74:	94800044 	addi	r18,r18,1
81130b78:	90800007 	ldb	r2,0(r18)
81130b7c:	103ffc1e 	bne	r2,zero,81130b70 <__reset+0xfb110b70>
81130b80:	9423c83a 	sub	r17,r18,r16
81130b84:	88001026 	beq	r17,zero,81130bc8 <___vfiprintf_internal_r+0x14c>
81130b88:	d8c01c17 	ldw	r3,112(sp)
81130b8c:	d8801b17 	ldw	r2,108(sp)
81130b90:	44000015 	stw	r16,0(r8)
81130b94:	88c7883a 	add	r3,r17,r3
81130b98:	10800044 	addi	r2,r2,1
81130b9c:	44400115 	stw	r17,4(r8)
81130ba0:	d8c01c15 	stw	r3,112(sp)
81130ba4:	d8801b15 	stw	r2,108(sp)
81130ba8:	010001c4 	movi	r4,7
81130bac:	2080760e 	bge	r4,r2,81130d88 <___vfiprintf_internal_r+0x30c>
81130bb0:	1803821e 	bne	r3,zero,811319bc <___vfiprintf_internal_r+0xf40>
81130bb4:	da802317 	ldw	r10,140(sp)
81130bb8:	d8001b15 	stw	zero,108(sp)
81130bbc:	d811883a 	mov	r8,sp
81130bc0:	5455883a 	add	r10,r10,r17
81130bc4:	da802315 	stw	r10,140(sp)
81130bc8:	90800007 	ldb	r2,0(r18)
81130bcc:	10044626 	beq	r2,zero,81131ce8 <___vfiprintf_internal_r+0x126c>
81130bd0:	90c00047 	ldb	r3,1(r18)
81130bd4:	94000044 	addi	r16,r18,1
81130bd8:	d8001d85 	stb	zero,118(sp)
81130bdc:	0009883a 	mov	r4,zero
81130be0:	000f883a 	mov	r7,zero
81130be4:	027fffc4 	movi	r9,-1
81130be8:	0023883a 	mov	r17,zero
81130bec:	0029883a 	mov	r20,zero
81130bf0:	01401604 	movi	r5,88
81130bf4:	01800244 	movi	r6,9
81130bf8:	03400a84 	movi	r13,42
81130bfc:	03001b04 	movi	r12,108
81130c00:	84000044 	addi	r16,r16,1
81130c04:	18bff804 	addi	r2,r3,-32
81130c08:	28827336 	bltu	r5,r2,811315d8 <___vfiprintf_internal_r+0xb5c>
81130c0c:	100490ba 	slli	r2,r2,2
81130c10:	02a044f4 	movhi	r10,33043
81130c14:	52830904 	addi	r10,r10,3108
81130c18:	1285883a 	add	r2,r2,r10
81130c1c:	10800017 	ldw	r2,0(r2)
81130c20:	1000683a 	jmp	r2
81130c24:	8113130c 	andi	r4,r16,19532
81130c28:	811315d8 	cmpnei	r4,r16,19543
81130c2c:	811315d8 	cmpnei	r4,r16,19543
81130c30:	8113132c 	andhi	r4,r16,19532
81130c34:	811315d8 	cmpnei	r4,r16,19543
81130c38:	811315d8 	cmpnei	r4,r16,19543
81130c3c:	811315d8 	cmpnei	r4,r16,19543
81130c40:	811315d8 	cmpnei	r4,r16,19543
81130c44:	811315d8 	cmpnei	r4,r16,19543
81130c48:	811315d8 	cmpnei	r4,r16,19543
81130c4c:	81131514 	ori	r4,r16,19540
81130c50:	81131530 	cmpltui	r4,r16,19540
81130c54:	811315d8 	cmpnei	r4,r16,19543
81130c58:	81130e18 	cmpnei	r4,r16,19512
81130c5c:	81131540 	call	88113154 <__reset+0x20f3154>
81130c60:	811315d8 	cmpnei	r4,r16,19543
81130c64:	81131338 	rdprs	r4,r16,19532
81130c68:	81131344 	addi	r4,r16,19533
81130c6c:	81131344 	addi	r4,r16,19533
81130c70:	81131344 	addi	r4,r16,19533
81130c74:	81131344 	addi	r4,r16,19533
81130c78:	81131344 	addi	r4,r16,19533
81130c7c:	81131344 	addi	r4,r16,19533
81130c80:	81131344 	addi	r4,r16,19533
81130c84:	81131344 	addi	r4,r16,19533
81130c88:	81131344 	addi	r4,r16,19533
81130c8c:	811315d8 	cmpnei	r4,r16,19543
81130c90:	811315d8 	cmpnei	r4,r16,19543
81130c94:	811315d8 	cmpnei	r4,r16,19543
81130c98:	811315d8 	cmpnei	r4,r16,19543
81130c9c:	811315d8 	cmpnei	r4,r16,19543
81130ca0:	811315d8 	cmpnei	r4,r16,19543
81130ca4:	811315d8 	cmpnei	r4,r16,19543
81130ca8:	811315d8 	cmpnei	r4,r16,19543
81130cac:	811315d8 	cmpnei	r4,r16,19543
81130cb0:	811315d8 	cmpnei	r4,r16,19543
81130cb4:	81131370 	cmpltui	r4,r16,19533
81130cb8:	811315d8 	cmpnei	r4,r16,19543
81130cbc:	811315d8 	cmpnei	r4,r16,19543
81130cc0:	811315d8 	cmpnei	r4,r16,19543
81130cc4:	811315d8 	cmpnei	r4,r16,19543
81130cc8:	811315d8 	cmpnei	r4,r16,19543
81130ccc:	811315d8 	cmpnei	r4,r16,19543
81130cd0:	811315d8 	cmpnei	r4,r16,19543
81130cd4:	811315d8 	cmpnei	r4,r16,19543
81130cd8:	811315d8 	cmpnei	r4,r16,19543
81130cdc:	811315d8 	cmpnei	r4,r16,19543
81130ce0:	811313a8 	cmpgeui	r4,r16,19534
81130ce4:	811315d8 	cmpnei	r4,r16,19543
81130ce8:	811315d8 	cmpnei	r4,r16,19543
81130cec:	811315d8 	cmpnei	r4,r16,19543
81130cf0:	811315d8 	cmpnei	r4,r16,19543
81130cf4:	811315d8 	cmpnei	r4,r16,19543
81130cf8:	81131400 	call	88113140 <__reset+0x20f3140>
81130cfc:	811315d8 	cmpnei	r4,r16,19543
81130d00:	811315d8 	cmpnei	r4,r16,19543
81130d04:	81131470 	cmpltui	r4,r16,19537
81130d08:	811315d8 	cmpnei	r4,r16,19543
81130d0c:	811315d8 	cmpnei	r4,r16,19543
81130d10:	811315d8 	cmpnei	r4,r16,19543
81130d14:	811315d8 	cmpnei	r4,r16,19543
81130d18:	811315d8 	cmpnei	r4,r16,19543
81130d1c:	811315d8 	cmpnei	r4,r16,19543
81130d20:	811315d8 	cmpnei	r4,r16,19543
81130d24:	811315d8 	cmpnei	r4,r16,19543
81130d28:	811315d8 	cmpnei	r4,r16,19543
81130d2c:	811315d8 	cmpnei	r4,r16,19543
81130d30:	8113121c 	xori	r4,r16,19528
81130d34:	81131248 	cmpgei	r4,r16,19529
81130d38:	811315d8 	cmpnei	r4,r16,19543
81130d3c:	811315d8 	cmpnei	r4,r16,19543
81130d40:	811315d8 	cmpnei	r4,r16,19543
81130d44:	81131580 	call	88113158 <__reset+0x20f3158>
81130d48:	81131248 	cmpgei	r4,r16,19529
81130d4c:	811315d8 	cmpnei	r4,r16,19543
81130d50:	811315d8 	cmpnei	r4,r16,19543
81130d54:	811310dc 	xori	r4,r16,19523
81130d58:	811315d8 	cmpnei	r4,r16,19543
81130d5c:	811310ec 	andhi	r4,r16,19523
81130d60:	81131128 	cmpgeui	r4,r16,19524
81130d64:	81130e24 	muli	r4,r16,19512
81130d68:	811310d0 	cmplti	r4,r16,19523
81130d6c:	811315d8 	cmpnei	r4,r16,19543
81130d70:	811314ac 	andhi	r4,r16,19538
81130d74:	811315d8 	cmpnei	r4,r16,19543
81130d78:	81131504 	addi	r4,r16,19540
81130d7c:	811315d8 	cmpnei	r4,r16,19543
81130d80:	811315d8 	cmpnei	r4,r16,19543
81130d84:	811311c8 	cmpgei	r4,r16,19527
81130d88:	42000204 	addi	r8,r8,8
81130d8c:	da802317 	ldw	r10,140(sp)
81130d90:	5455883a 	add	r10,r10,r17
81130d94:	da802315 	stw	r10,140(sp)
81130d98:	003f8b06 	br	81130bc8 <__reset+0xfb110bc8>
81130d9c:	d9002017 	ldw	r4,128(sp)
81130da0:	a00b883a 	mov	r5,r20
81130da4:	11285c00 	call	811285c0 <__swsetup_r>
81130da8:	1003b11e 	bne	r2,zero,81131c70 <___vfiprintf_internal_r+0x11f4>
81130dac:	a080030b 	ldhu	r2,12(r20)
81130db0:	00c00284 	movi	r3,10
81130db4:	1080068c 	andi	r2,r2,26
81130db8:	10ff541e 	bne	r2,r3,81130b0c <__reset+0xfb110b0c>
81130dbc:	a080038f 	ldh	r2,14(r20)
81130dc0:	103f5216 	blt	r2,zero,81130b0c <__reset+0xfb110b0c>
81130dc4:	d9c02217 	ldw	r7,136(sp)
81130dc8:	d9002017 	ldw	r4,128(sp)
81130dcc:	e00d883a 	mov	r6,fp
81130dd0:	a00b883a 	mov	r5,r20
81130dd4:	1131efc0 	call	81131efc <__sbprintf>
81130dd8:	dfc03617 	ldw	ra,216(sp)
81130ddc:	df003517 	ldw	fp,212(sp)
81130de0:	ddc03417 	ldw	r23,208(sp)
81130de4:	dd803317 	ldw	r22,204(sp)
81130de8:	dd403217 	ldw	r21,200(sp)
81130dec:	dd003117 	ldw	r20,196(sp)
81130df0:	dcc03017 	ldw	r19,192(sp)
81130df4:	dc802f17 	ldw	r18,188(sp)
81130df8:	dc402e17 	ldw	r17,184(sp)
81130dfc:	dc002d17 	ldw	r16,180(sp)
81130e00:	dec03704 	addi	sp,sp,220
81130e04:	f800283a 	ret
81130e08:	112a6300 	call	8112a630 <__sinit>
81130e0c:	003f2f06 	br	81130acc <__reset+0xfb110acc>
81130e10:	0463c83a 	sub	r17,zero,r17
81130e14:	d8802215 	stw	r2,136(sp)
81130e18:	a5000114 	ori	r20,r20,4
81130e1c:	80c00007 	ldb	r3,0(r16)
81130e20:	003f7706 	br	81130c00 <__reset+0xfb110c00>
81130e24:	00800c04 	movi	r2,48
81130e28:	da802217 	ldw	r10,136(sp)
81130e2c:	d8801d05 	stb	r2,116(sp)
81130e30:	00801e04 	movi	r2,120
81130e34:	d8801d45 	stb	r2,117(sp)
81130e38:	d8001d85 	stb	zero,118(sp)
81130e3c:	50c00104 	addi	r3,r10,4
81130e40:	54800017 	ldw	r18,0(r10)
81130e44:	0027883a 	mov	r19,zero
81130e48:	a0800094 	ori	r2,r20,2
81130e4c:	48030b16 	blt	r9,zero,81131a7c <___vfiprintf_internal_r+0x1000>
81130e50:	00bfdfc4 	movi	r2,-129
81130e54:	a096703a 	and	r11,r20,r2
81130e58:	d8c02215 	stw	r3,136(sp)
81130e5c:	5d000094 	ori	r20,r11,2
81130e60:	90032b1e 	bne	r18,zero,81131b10 <___vfiprintf_internal_r+0x1094>
81130e64:	00a04574 	movhi	r2,33045
81130e68:	10be9a04 	addi	r2,r2,-1432
81130e6c:	d8802615 	stw	r2,152(sp)
81130e70:	0039883a 	mov	fp,zero
81130e74:	48017b1e 	bne	r9,zero,81131464 <___vfiprintf_internal_r+0x9e8>
81130e78:	0013883a 	mov	r9,zero
81130e7c:	0027883a 	mov	r19,zero
81130e80:	dd401a04 	addi	r21,sp,104
81130e84:	4825883a 	mov	r18,r9
81130e88:	4cc0010e 	bge	r9,r19,81130e90 <___vfiprintf_internal_r+0x414>
81130e8c:	9825883a 	mov	r18,r19
81130e90:	e7003fcc 	andi	fp,fp,255
81130e94:	e700201c 	xori	fp,fp,128
81130e98:	e73fe004 	addi	fp,fp,-128
81130e9c:	e0000126 	beq	fp,zero,81130ea4 <___vfiprintf_internal_r+0x428>
81130ea0:	94800044 	addi	r18,r18,1
81130ea4:	a380008c 	andi	r14,r20,2
81130ea8:	70000126 	beq	r14,zero,81130eb0 <___vfiprintf_internal_r+0x434>
81130eac:	94800084 	addi	r18,r18,2
81130eb0:	a700210c 	andi	fp,r20,132
81130eb4:	e001df1e 	bne	fp,zero,81131634 <___vfiprintf_internal_r+0xbb8>
81130eb8:	8c87c83a 	sub	r3,r17,r18
81130ebc:	00c1dd0e 	bge	zero,r3,81131634 <___vfiprintf_internal_r+0xbb8>
81130ec0:	01c00404 	movi	r7,16
81130ec4:	d8801c17 	ldw	r2,112(sp)
81130ec8:	38c3ad0e 	bge	r7,r3,81131d80 <___vfiprintf_internal_r+0x1304>
81130ecc:	02a04574 	movhi	r10,33045
81130ed0:	52bf3004 	addi	r10,r10,-832
81130ed4:	dc002915 	stw	r16,164(sp)
81130ed8:	d9801b17 	ldw	r6,108(sp)
81130edc:	da802415 	stw	r10,144(sp)
81130ee0:	03c001c4 	movi	r15,7
81130ee4:	da402515 	stw	r9,148(sp)
81130ee8:	db802815 	stw	r14,160(sp)
81130eec:	1821883a 	mov	r16,r3
81130ef0:	00000506 	br	81130f08 <___vfiprintf_internal_r+0x48c>
81130ef4:	31400084 	addi	r5,r6,2
81130ef8:	42000204 	addi	r8,r8,8
81130efc:	200d883a 	mov	r6,r4
81130f00:	843ffc04 	addi	r16,r16,-16
81130f04:	3c000d0e 	bge	r7,r16,81130f3c <___vfiprintf_internal_r+0x4c0>
81130f08:	10800404 	addi	r2,r2,16
81130f0c:	31000044 	addi	r4,r6,1
81130f10:	45800015 	stw	r22,0(r8)
81130f14:	41c00115 	stw	r7,4(r8)
81130f18:	d8801c15 	stw	r2,112(sp)
81130f1c:	d9001b15 	stw	r4,108(sp)
81130f20:	793ff40e 	bge	r15,r4,81130ef4 <__reset+0xfb110ef4>
81130f24:	1001b51e 	bne	r2,zero,811315fc <___vfiprintf_internal_r+0xb80>
81130f28:	843ffc04 	addi	r16,r16,-16
81130f2c:	000d883a 	mov	r6,zero
81130f30:	01400044 	movi	r5,1
81130f34:	d811883a 	mov	r8,sp
81130f38:	3c3ff316 	blt	r7,r16,81130f08 <__reset+0xfb110f08>
81130f3c:	8007883a 	mov	r3,r16
81130f40:	da402517 	ldw	r9,148(sp)
81130f44:	db802817 	ldw	r14,160(sp)
81130f48:	dc002917 	ldw	r16,164(sp)
81130f4c:	da802417 	ldw	r10,144(sp)
81130f50:	1885883a 	add	r2,r3,r2
81130f54:	40c00115 	stw	r3,4(r8)
81130f58:	42800015 	stw	r10,0(r8)
81130f5c:	d8801c15 	stw	r2,112(sp)
81130f60:	d9401b15 	stw	r5,108(sp)
81130f64:	00c001c4 	movi	r3,7
81130f68:	19426016 	blt	r3,r5,811318ec <___vfiprintf_internal_r+0xe70>
81130f6c:	d8c01d87 	ldb	r3,118(sp)
81130f70:	42000204 	addi	r8,r8,8
81130f74:	29000044 	addi	r4,r5,1
81130f78:	1801b31e 	bne	r3,zero,81131648 <___vfiprintf_internal_r+0xbcc>
81130f7c:	7001c026 	beq	r14,zero,81131680 <___vfiprintf_internal_r+0xc04>
81130f80:	d8c01d04 	addi	r3,sp,116
81130f84:	10800084 	addi	r2,r2,2
81130f88:	40c00015 	stw	r3,0(r8)
81130f8c:	00c00084 	movi	r3,2
81130f90:	40c00115 	stw	r3,4(r8)
81130f94:	d8801c15 	stw	r2,112(sp)
81130f98:	d9001b15 	stw	r4,108(sp)
81130f9c:	00c001c4 	movi	r3,7
81130fa0:	1902650e 	bge	r3,r4,81131938 <___vfiprintf_internal_r+0xebc>
81130fa4:	10029a1e 	bne	r2,zero,81131a10 <___vfiprintf_internal_r+0xf94>
81130fa8:	00c02004 	movi	r3,128
81130fac:	01000044 	movi	r4,1
81130fb0:	000b883a 	mov	r5,zero
81130fb4:	d811883a 	mov	r8,sp
81130fb8:	e0c1b31e 	bne	fp,r3,81131688 <___vfiprintf_internal_r+0xc0c>
81130fbc:	8cb9c83a 	sub	fp,r17,r18
81130fc0:	0701b10e 	bge	zero,fp,81131688 <___vfiprintf_internal_r+0xc0c>
81130fc4:	01c00404 	movi	r7,16
81130fc8:	3f03890e 	bge	r7,fp,81131df0 <___vfiprintf_internal_r+0x1374>
81130fcc:	00e04574 	movhi	r3,33045
81130fd0:	18ff2c04 	addi	r3,r3,-848
81130fd4:	d8c02415 	stw	r3,144(sp)
81130fd8:	8007883a 	mov	r3,r16
81130fdc:	034001c4 	movi	r13,7
81130fe0:	e021883a 	mov	r16,fp
81130fe4:	da402515 	stw	r9,148(sp)
81130fe8:	1839883a 	mov	fp,r3
81130fec:	00000506 	br	81131004 <___vfiprintf_internal_r+0x588>
81130ff0:	29800084 	addi	r6,r5,2
81130ff4:	42000204 	addi	r8,r8,8
81130ff8:	180b883a 	mov	r5,r3
81130ffc:	843ffc04 	addi	r16,r16,-16
81131000:	3c000d0e 	bge	r7,r16,81131038 <___vfiprintf_internal_r+0x5bc>
81131004:	10800404 	addi	r2,r2,16
81131008:	28c00044 	addi	r3,r5,1
8113100c:	45c00015 	stw	r23,0(r8)
81131010:	41c00115 	stw	r7,4(r8)
81131014:	d8801c15 	stw	r2,112(sp)
81131018:	d8c01b15 	stw	r3,108(sp)
8113101c:	68fff40e 	bge	r13,r3,81130ff0 <__reset+0xfb110ff0>
81131020:	1002241e 	bne	r2,zero,811318b4 <___vfiprintf_internal_r+0xe38>
81131024:	843ffc04 	addi	r16,r16,-16
81131028:	01800044 	movi	r6,1
8113102c:	000b883a 	mov	r5,zero
81131030:	d811883a 	mov	r8,sp
81131034:	3c3ff316 	blt	r7,r16,81131004 <__reset+0xfb111004>
81131038:	da402517 	ldw	r9,148(sp)
8113103c:	e007883a 	mov	r3,fp
81131040:	8039883a 	mov	fp,r16
81131044:	1821883a 	mov	r16,r3
81131048:	d8c02417 	ldw	r3,144(sp)
8113104c:	1705883a 	add	r2,r2,fp
81131050:	47000115 	stw	fp,4(r8)
81131054:	40c00015 	stw	r3,0(r8)
81131058:	d8801c15 	stw	r2,112(sp)
8113105c:	d9801b15 	stw	r6,108(sp)
81131060:	00c001c4 	movi	r3,7
81131064:	19827616 	blt	r3,r6,81131a40 <___vfiprintf_internal_r+0xfc4>
81131068:	4cf9c83a 	sub	fp,r9,r19
8113106c:	42000204 	addi	r8,r8,8
81131070:	31000044 	addi	r4,r6,1
81131074:	300b883a 	mov	r5,r6
81131078:	07018516 	blt	zero,fp,81131690 <___vfiprintf_internal_r+0xc14>
8113107c:	9885883a 	add	r2,r19,r2
81131080:	45400015 	stw	r21,0(r8)
81131084:	44c00115 	stw	r19,4(r8)
81131088:	d8801c15 	stw	r2,112(sp)
8113108c:	d9001b15 	stw	r4,108(sp)
81131090:	00c001c4 	movi	r3,7
81131094:	1901dd0e 	bge	r3,r4,8113180c <___vfiprintf_internal_r+0xd90>
81131098:	1002401e 	bne	r2,zero,8113199c <___vfiprintf_internal_r+0xf20>
8113109c:	d8001b15 	stw	zero,108(sp)
811310a0:	a2c0010c 	andi	r11,r20,4
811310a4:	58000226 	beq	r11,zero,811310b0 <___vfiprintf_internal_r+0x634>
811310a8:	8ca7c83a 	sub	r19,r17,r18
811310ac:	04c2f216 	blt	zero,r19,81131c78 <___vfiprintf_internal_r+0x11fc>
811310b0:	8c80010e 	bge	r17,r18,811310b8 <___vfiprintf_internal_r+0x63c>
811310b4:	9023883a 	mov	r17,r18
811310b8:	da802317 	ldw	r10,140(sp)
811310bc:	5455883a 	add	r10,r10,r17
811310c0:	da802315 	stw	r10,140(sp)
811310c4:	d8001b15 	stw	zero,108(sp)
811310c8:	d811883a 	mov	r8,sp
811310cc:	003ea206 	br	81130b58 <__reset+0xfb110b58>
811310d0:	a5000814 	ori	r20,r20,32
811310d4:	80c00007 	ldb	r3,0(r16)
811310d8:	003ec906 	br	81130c00 <__reset+0xfb110c00>
811310dc:	80c00007 	ldb	r3,0(r16)
811310e0:	1b030926 	beq	r3,r12,81131d08 <___vfiprintf_internal_r+0x128c>
811310e4:	a5000414 	ori	r20,r20,16
811310e8:	003ec506 	br	81130c00 <__reset+0xfb110c00>
811310ec:	21003fcc 	andi	r4,r4,255
811310f0:	20035e1e 	bne	r4,zero,81131e6c <___vfiprintf_internal_r+0x13f0>
811310f4:	a080080c 	andi	r2,r20,32
811310f8:	1002a526 	beq	r2,zero,81131b90 <___vfiprintf_internal_r+0x1114>
811310fc:	da802217 	ldw	r10,136(sp)
81131100:	50800017 	ldw	r2,0(r10)
81131104:	da802317 	ldw	r10,140(sp)
81131108:	5007d7fa 	srai	r3,r10,31
8113110c:	da802217 	ldw	r10,136(sp)
81131110:	10c00115 	stw	r3,4(r2)
81131114:	52800104 	addi	r10,r10,4
81131118:	da802215 	stw	r10,136(sp)
8113111c:	da802317 	ldw	r10,140(sp)
81131120:	12800015 	stw	r10,0(r2)
81131124:	003e8c06 	br	81130b58 <__reset+0xfb110b58>
81131128:	21003fcc 	andi	r4,r4,255
8113112c:	2003511e 	bne	r4,zero,81131e74 <___vfiprintf_internal_r+0x13f8>
81131130:	a080080c 	andi	r2,r20,32
81131134:	1000a126 	beq	r2,zero,811313bc <___vfiprintf_internal_r+0x940>
81131138:	da802217 	ldw	r10,136(sp)
8113113c:	d8001d85 	stb	zero,118(sp)
81131140:	50800204 	addi	r2,r10,8
81131144:	54800017 	ldw	r18,0(r10)
81131148:	54c00117 	ldw	r19,4(r10)
8113114c:	4802b416 	blt	r9,zero,81131c20 <___vfiprintf_internal_r+0x11a4>
81131150:	013fdfc4 	movi	r4,-129
81131154:	94c6b03a 	or	r3,r18,r19
81131158:	d8802215 	stw	r2,136(sp)
8113115c:	a128703a 	and	r20,r20,r4
81131160:	1800a226 	beq	r3,zero,811313ec <___vfiprintf_internal_r+0x970>
81131164:	0039883a 	mov	fp,zero
81131168:	dd401a04 	addi	r21,sp,104
8113116c:	9006d0fa 	srli	r3,r18,3
81131170:	9808977a 	slli	r4,r19,29
81131174:	9826d0fa 	srli	r19,r19,3
81131178:	948001cc 	andi	r18,r18,7
8113117c:	90800c04 	addi	r2,r18,48
81131180:	ad7fffc4 	addi	r21,r21,-1
81131184:	20e4b03a 	or	r18,r4,r3
81131188:	a8800005 	stb	r2,0(r21)
8113118c:	94c6b03a 	or	r3,r18,r19
81131190:	183ff61e 	bne	r3,zero,8113116c <__reset+0xfb11116c>
81131194:	a0c0004c 	andi	r3,r20,1
81131198:	18005926 	beq	r3,zero,81131300 <___vfiprintf_internal_r+0x884>
8113119c:	10803fcc 	andi	r2,r2,255
811311a0:	1080201c 	xori	r2,r2,128
811311a4:	10bfe004 	addi	r2,r2,-128
811311a8:	00c00c04 	movi	r3,48
811311ac:	10c05426 	beq	r2,r3,81131300 <___vfiprintf_internal_r+0x884>
811311b0:	da801e17 	ldw	r10,120(sp)
811311b4:	a8bfffc4 	addi	r2,r21,-1
811311b8:	a8ffffc5 	stb	r3,-1(r21)
811311bc:	50a7c83a 	sub	r19,r10,r2
811311c0:	102b883a 	mov	r21,r2
811311c4:	003f2f06 	br	81130e84 <__reset+0xfb110e84>
811311c8:	21003fcc 	andi	r4,r4,255
811311cc:	2003421e 	bne	r4,zero,81131ed8 <___vfiprintf_internal_r+0x145c>
811311d0:	00a04574 	movhi	r2,33045
811311d4:	10be9a04 	addi	r2,r2,-1432
811311d8:	d8802615 	stw	r2,152(sp)
811311dc:	a080080c 	andi	r2,r20,32
811311e0:	1000aa26 	beq	r2,zero,8113148c <___vfiprintf_internal_r+0xa10>
811311e4:	da802217 	ldw	r10,136(sp)
811311e8:	54800017 	ldw	r18,0(r10)
811311ec:	54c00117 	ldw	r19,4(r10)
811311f0:	52800204 	addi	r10,r10,8
811311f4:	da802215 	stw	r10,136(sp)
811311f8:	a080004c 	andi	r2,r20,1
811311fc:	1001d226 	beq	r2,zero,81131948 <___vfiprintf_internal_r+0xecc>
81131200:	94c4b03a 	or	r2,r18,r19
81131204:	1002351e 	bne	r2,zero,81131adc <___vfiprintf_internal_r+0x1060>
81131208:	d8001d85 	stb	zero,118(sp)
8113120c:	48022216 	blt	r9,zero,81131a98 <___vfiprintf_internal_r+0x101c>
81131210:	00bfdfc4 	movi	r2,-129
81131214:	a0a8703a 	and	r20,r20,r2
81131218:	003f1506 	br	81130e70 <__reset+0xfb110e70>
8113121c:	da802217 	ldw	r10,136(sp)
81131220:	04800044 	movi	r18,1
81131224:	d8001d85 	stb	zero,118(sp)
81131228:	50800017 	ldw	r2,0(r10)
8113122c:	52800104 	addi	r10,r10,4
81131230:	da802215 	stw	r10,136(sp)
81131234:	d8801005 	stb	r2,64(sp)
81131238:	9027883a 	mov	r19,r18
8113123c:	dd401004 	addi	r21,sp,64
81131240:	0013883a 	mov	r9,zero
81131244:	003f1706 	br	81130ea4 <__reset+0xfb110ea4>
81131248:	21003fcc 	andi	r4,r4,255
8113124c:	2003201e 	bne	r4,zero,81131ed0 <___vfiprintf_internal_r+0x1454>
81131250:	a080080c 	andi	r2,r20,32
81131254:	10004b26 	beq	r2,zero,81131384 <___vfiprintf_internal_r+0x908>
81131258:	da802217 	ldw	r10,136(sp)
8113125c:	50800117 	ldw	r2,4(r10)
81131260:	54800017 	ldw	r18,0(r10)
81131264:	52800204 	addi	r10,r10,8
81131268:	da802215 	stw	r10,136(sp)
8113126c:	1027883a 	mov	r19,r2
81131270:	10022c16 	blt	r2,zero,81131b24 <___vfiprintf_internal_r+0x10a8>
81131274:	df001d83 	ldbu	fp,118(sp)
81131278:	48007216 	blt	r9,zero,81131444 <___vfiprintf_internal_r+0x9c8>
8113127c:	00ffdfc4 	movi	r3,-129
81131280:	94c4b03a 	or	r2,r18,r19
81131284:	a0e8703a 	and	r20,r20,r3
81131288:	1000cc26 	beq	r2,zero,811315bc <___vfiprintf_internal_r+0xb40>
8113128c:	98021026 	beq	r19,zero,81131ad0 <___vfiprintf_internal_r+0x1054>
81131290:	dc402415 	stw	r17,144(sp)
81131294:	dc002515 	stw	r16,148(sp)
81131298:	9823883a 	mov	r17,r19
8113129c:	9021883a 	mov	r16,r18
811312a0:	dd401a04 	addi	r21,sp,104
811312a4:	4825883a 	mov	r18,r9
811312a8:	4027883a 	mov	r19,r8
811312ac:	8009883a 	mov	r4,r16
811312b0:	880b883a 	mov	r5,r17
811312b4:	01800284 	movi	r6,10
811312b8:	000f883a 	mov	r7,zero
811312bc:	113379c0 	call	8113379c <__umoddi3>
811312c0:	10800c04 	addi	r2,r2,48
811312c4:	ad7fffc4 	addi	r21,r21,-1
811312c8:	8009883a 	mov	r4,r16
811312cc:	880b883a 	mov	r5,r17
811312d0:	a8800005 	stb	r2,0(r21)
811312d4:	01800284 	movi	r6,10
811312d8:	000f883a 	mov	r7,zero
811312dc:	113321c0 	call	8113321c <__udivdi3>
811312e0:	1021883a 	mov	r16,r2
811312e4:	10c4b03a 	or	r2,r2,r3
811312e8:	1823883a 	mov	r17,r3
811312ec:	103fef1e 	bne	r2,zero,811312ac <__reset+0xfb1112ac>
811312f0:	dc402417 	ldw	r17,144(sp)
811312f4:	dc002517 	ldw	r16,148(sp)
811312f8:	9013883a 	mov	r9,r18
811312fc:	9811883a 	mov	r8,r19
81131300:	da801e17 	ldw	r10,120(sp)
81131304:	5567c83a 	sub	r19,r10,r21
81131308:	003ede06 	br	81130e84 <__reset+0xfb110e84>
8113130c:	38803fcc 	andi	r2,r7,255
81131310:	1080201c 	xori	r2,r2,128
81131314:	10bfe004 	addi	r2,r2,-128
81131318:	1002371e 	bne	r2,zero,81131bf8 <___vfiprintf_internal_r+0x117c>
8113131c:	01000044 	movi	r4,1
81131320:	01c00804 	movi	r7,32
81131324:	80c00007 	ldb	r3,0(r16)
81131328:	003e3506 	br	81130c00 <__reset+0xfb110c00>
8113132c:	a5000054 	ori	r20,r20,1
81131330:	80c00007 	ldb	r3,0(r16)
81131334:	003e3206 	br	81130c00 <__reset+0xfb110c00>
81131338:	a5002014 	ori	r20,r20,128
8113133c:	80c00007 	ldb	r3,0(r16)
81131340:	003e2f06 	br	81130c00 <__reset+0xfb110c00>
81131344:	8015883a 	mov	r10,r16
81131348:	0023883a 	mov	r17,zero
8113134c:	18bff404 	addi	r2,r3,-48
81131350:	50c00007 	ldb	r3,0(r10)
81131354:	8c4002a4 	muli	r17,r17,10
81131358:	84000044 	addi	r16,r16,1
8113135c:	8015883a 	mov	r10,r16
81131360:	1463883a 	add	r17,r2,r17
81131364:	18bff404 	addi	r2,r3,-48
81131368:	30bff92e 	bgeu	r6,r2,81131350 <__reset+0xfb111350>
8113136c:	003e2506 	br	81130c04 <__reset+0xfb110c04>
81131370:	21003fcc 	andi	r4,r4,255
81131374:	2002d41e 	bne	r4,zero,81131ec8 <___vfiprintf_internal_r+0x144c>
81131378:	a5000414 	ori	r20,r20,16
8113137c:	a080080c 	andi	r2,r20,32
81131380:	103fb51e 	bne	r2,zero,81131258 <__reset+0xfb111258>
81131384:	a080040c 	andi	r2,r20,16
81131388:	1001f826 	beq	r2,zero,81131b6c <___vfiprintf_internal_r+0x10f0>
8113138c:	da802217 	ldw	r10,136(sp)
81131390:	54800017 	ldw	r18,0(r10)
81131394:	52800104 	addi	r10,r10,4
81131398:	da802215 	stw	r10,136(sp)
8113139c:	9027d7fa 	srai	r19,r18,31
811313a0:	9805883a 	mov	r2,r19
811313a4:	003fb206 	br	81131270 <__reset+0xfb111270>
811313a8:	21003fcc 	andi	r4,r4,255
811313ac:	2002c41e 	bne	r4,zero,81131ec0 <___vfiprintf_internal_r+0x1444>
811313b0:	a5000414 	ori	r20,r20,16
811313b4:	a080080c 	andi	r2,r20,32
811313b8:	103f5f1e 	bne	r2,zero,81131138 <__reset+0xfb111138>
811313bc:	a080040c 	andi	r2,r20,16
811313c0:	10020f26 	beq	r2,zero,81131c00 <___vfiprintf_internal_r+0x1184>
811313c4:	da802217 	ldw	r10,136(sp)
811313c8:	d8001d85 	stb	zero,118(sp)
811313cc:	0027883a 	mov	r19,zero
811313d0:	50800104 	addi	r2,r10,4
811313d4:	54800017 	ldw	r18,0(r10)
811313d8:	48021116 	blt	r9,zero,81131c20 <___vfiprintf_internal_r+0x11a4>
811313dc:	00ffdfc4 	movi	r3,-129
811313e0:	d8802215 	stw	r2,136(sp)
811313e4:	a0e8703a 	and	r20,r20,r3
811313e8:	903f5e1e 	bne	r18,zero,81131164 <__reset+0xfb111164>
811313ec:	0039883a 	mov	fp,zero
811313f0:	4802a626 	beq	r9,zero,81131e8c <___vfiprintf_internal_r+0x1410>
811313f4:	0025883a 	mov	r18,zero
811313f8:	0027883a 	mov	r19,zero
811313fc:	003f5a06 	br	81131168 <__reset+0xfb111168>
81131400:	21003fcc 	andi	r4,r4,255
81131404:	20029f1e 	bne	r4,zero,81131e84 <___vfiprintf_internal_r+0x1408>
81131408:	a5000414 	ori	r20,r20,16
8113140c:	a080080c 	andi	r2,r20,32
81131410:	10005e1e 	bne	r2,zero,8113158c <___vfiprintf_internal_r+0xb10>
81131414:	a080040c 	andi	r2,r20,16
81131418:	1001a21e 	bne	r2,zero,81131aa4 <___vfiprintf_internal_r+0x1028>
8113141c:	a080100c 	andi	r2,r20,64
81131420:	d8001d85 	stb	zero,118(sp)
81131424:	da802217 	ldw	r10,136(sp)
81131428:	1002231e 	bne	r2,zero,81131cb8 <___vfiprintf_internal_r+0x123c>
8113142c:	50800104 	addi	r2,r10,4
81131430:	54800017 	ldw	r18,0(r10)
81131434:	0027883a 	mov	r19,zero
81131438:	4801a00e 	bge	r9,zero,81131abc <___vfiprintf_internal_r+0x1040>
8113143c:	d8802215 	stw	r2,136(sp)
81131440:	0039883a 	mov	fp,zero
81131444:	94c4b03a 	or	r2,r18,r19
81131448:	103f901e 	bne	r2,zero,8113128c <__reset+0xfb11128c>
8113144c:	00800044 	movi	r2,1
81131450:	10803fcc 	andi	r2,r2,255
81131454:	00c00044 	movi	r3,1
81131458:	10c05926 	beq	r2,r3,811315c0 <___vfiprintf_internal_r+0xb44>
8113145c:	00c00084 	movi	r3,2
81131460:	10ffe41e 	bne	r2,r3,811313f4 <__reset+0xfb1113f4>
81131464:	0025883a 	mov	r18,zero
81131468:	0027883a 	mov	r19,zero
8113146c:	00013d06 	br	81131964 <___vfiprintf_internal_r+0xee8>
81131470:	21003fcc 	andi	r4,r4,255
81131474:	2002811e 	bne	r4,zero,81131e7c <___vfiprintf_internal_r+0x1400>
81131478:	00a04574 	movhi	r2,33045
8113147c:	10be9504 	addi	r2,r2,-1452
81131480:	d8802615 	stw	r2,152(sp)
81131484:	a080080c 	andi	r2,r20,32
81131488:	103f561e 	bne	r2,zero,811311e4 <__reset+0xfb1111e4>
8113148c:	a080040c 	andi	r2,r20,16
81131490:	1001d126 	beq	r2,zero,81131bd8 <___vfiprintf_internal_r+0x115c>
81131494:	da802217 	ldw	r10,136(sp)
81131498:	0027883a 	mov	r19,zero
8113149c:	54800017 	ldw	r18,0(r10)
811314a0:	52800104 	addi	r10,r10,4
811314a4:	da802215 	stw	r10,136(sp)
811314a8:	003f5306 	br	811311f8 <__reset+0xfb1111f8>
811314ac:	da802217 	ldw	r10,136(sp)
811314b0:	d8001d85 	stb	zero,118(sp)
811314b4:	55400017 	ldw	r21,0(r10)
811314b8:	50c00104 	addi	r3,r10,4
811314bc:	a8024226 	beq	r21,zero,81131dc8 <___vfiprintf_internal_r+0x134c>
811314c0:	48021816 	blt	r9,zero,81131d24 <___vfiprintf_internal_r+0x12a8>
811314c4:	480d883a 	mov	r6,r9
811314c8:	000b883a 	mov	r5,zero
811314cc:	a809883a 	mov	r4,r21
811314d0:	d8c02a15 	stw	r3,168(sp)
811314d4:	da002b15 	stw	r8,172(sp)
811314d8:	da402c15 	stw	r9,176(sp)
811314dc:	112b8580 	call	8112b858 <memchr>
811314e0:	d8c02a17 	ldw	r3,168(sp)
811314e4:	da002b17 	ldw	r8,172(sp)
811314e8:	da402c17 	ldw	r9,176(sp)
811314ec:	10024826 	beq	r2,zero,81131e10 <___vfiprintf_internal_r+0x1394>
811314f0:	1567c83a 	sub	r19,r2,r21
811314f4:	df001d83 	ldbu	fp,118(sp)
811314f8:	d8c02215 	stw	r3,136(sp)
811314fc:	0013883a 	mov	r9,zero
81131500:	003e6006 	br	81130e84 <__reset+0xfb110e84>
81131504:	21003fcc 	andi	r4,r4,255
81131508:	203fc026 	beq	r4,zero,8113140c <__reset+0xfb11140c>
8113150c:	d9c01d85 	stb	r7,118(sp)
81131510:	003fbe06 	br	8113140c <__reset+0xfb11140c>
81131514:	da802217 	ldw	r10,136(sp)
81131518:	54400017 	ldw	r17,0(r10)
8113151c:	50800104 	addi	r2,r10,4
81131520:	883e3b16 	blt	r17,zero,81130e10 <__reset+0xfb110e10>
81131524:	d8802215 	stw	r2,136(sp)
81131528:	80c00007 	ldb	r3,0(r16)
8113152c:	003db406 	br	81130c00 <__reset+0xfb110c00>
81131530:	01000044 	movi	r4,1
81131534:	01c00ac4 	movi	r7,43
81131538:	80c00007 	ldb	r3,0(r16)
8113153c:	003db006 	br	81130c00 <__reset+0xfb110c00>
81131540:	80c00007 	ldb	r3,0(r16)
81131544:	82800044 	addi	r10,r16,1
81131548:	1b423c26 	beq	r3,r13,81131e3c <___vfiprintf_internal_r+0x13c0>
8113154c:	18bff404 	addi	r2,r3,-48
81131550:	0013883a 	mov	r9,zero
81131554:	30822b36 	bltu	r6,r2,81131e04 <___vfiprintf_internal_r+0x1388>
81131558:	50c00007 	ldb	r3,0(r10)
8113155c:	4a4002a4 	muli	r9,r9,10
81131560:	54000044 	addi	r16,r10,1
81131564:	8015883a 	mov	r10,r16
81131568:	4893883a 	add	r9,r9,r2
8113156c:	18bff404 	addi	r2,r3,-48
81131570:	30bff92e 	bgeu	r6,r2,81131558 <__reset+0xfb111558>
81131574:	483da30e 	bge	r9,zero,81130c04 <__reset+0xfb110c04>
81131578:	027fffc4 	movi	r9,-1
8113157c:	003da106 	br	81130c04 <__reset+0xfb110c04>
81131580:	a5001014 	ori	r20,r20,64
81131584:	80c00007 	ldb	r3,0(r16)
81131588:	003d9d06 	br	81130c00 <__reset+0xfb110c00>
8113158c:	da802217 	ldw	r10,136(sp)
81131590:	d8001d85 	stb	zero,118(sp)
81131594:	50c00204 	addi	r3,r10,8
81131598:	54800017 	ldw	r18,0(r10)
8113159c:	54c00117 	ldw	r19,4(r10)
811315a0:	4801ca16 	blt	r9,zero,81131ccc <___vfiprintf_internal_r+0x1250>
811315a4:	013fdfc4 	movi	r4,-129
811315a8:	94c4b03a 	or	r2,r18,r19
811315ac:	d8c02215 	stw	r3,136(sp)
811315b0:	a128703a 	and	r20,r20,r4
811315b4:	0039883a 	mov	fp,zero
811315b8:	103f341e 	bne	r2,zero,8113128c <__reset+0xfb11128c>
811315bc:	483e2e26 	beq	r9,zero,81130e78 <__reset+0xfb110e78>
811315c0:	0025883a 	mov	r18,zero
811315c4:	94800c04 	addi	r18,r18,48
811315c8:	dc8019c5 	stb	r18,103(sp)
811315cc:	dcc02717 	ldw	r19,156(sp)
811315d0:	dd4019c4 	addi	r21,sp,103
811315d4:	003e2b06 	br	81130e84 <__reset+0xfb110e84>
811315d8:	21003fcc 	andi	r4,r4,255
811315dc:	2002361e 	bne	r4,zero,81131eb8 <___vfiprintf_internal_r+0x143c>
811315e0:	1801c126 	beq	r3,zero,81131ce8 <___vfiprintf_internal_r+0x126c>
811315e4:	04800044 	movi	r18,1
811315e8:	d8c01005 	stb	r3,64(sp)
811315ec:	d8001d85 	stb	zero,118(sp)
811315f0:	9027883a 	mov	r19,r18
811315f4:	dd401004 	addi	r21,sp,64
811315f8:	003f1106 	br	81131240 <__reset+0xfb111240>
811315fc:	d9402117 	ldw	r5,132(sp)
81131600:	d9002017 	ldw	r4,128(sp)
81131604:	d9801a04 	addi	r6,sp,104
81131608:	d9c02b15 	stw	r7,172(sp)
8113160c:	dbc02a15 	stw	r15,168(sp)
81131610:	11309600 	call	81130960 <__sprint_r.part.0>
81131614:	d9c02b17 	ldw	r7,172(sp)
81131618:	dbc02a17 	ldw	r15,168(sp)
8113161c:	10006d1e 	bne	r2,zero,811317d4 <___vfiprintf_internal_r+0xd58>
81131620:	d9801b17 	ldw	r6,108(sp)
81131624:	d8801c17 	ldw	r2,112(sp)
81131628:	d811883a 	mov	r8,sp
8113162c:	31400044 	addi	r5,r6,1
81131630:	003e3306 	br	81130f00 <__reset+0xfb110f00>
81131634:	d9401b17 	ldw	r5,108(sp)
81131638:	d8801c17 	ldw	r2,112(sp)
8113163c:	29000044 	addi	r4,r5,1
81131640:	d8c01d87 	ldb	r3,118(sp)
81131644:	183e4d26 	beq	r3,zero,81130f7c <__reset+0xfb110f7c>
81131648:	00c00044 	movi	r3,1
8113164c:	d9401d84 	addi	r5,sp,118
81131650:	10c5883a 	add	r2,r2,r3
81131654:	41400015 	stw	r5,0(r8)
81131658:	40c00115 	stw	r3,4(r8)
8113165c:	d8801c15 	stw	r2,112(sp)
81131660:	d9001b15 	stw	r4,108(sp)
81131664:	014001c4 	movi	r5,7
81131668:	2900a90e 	bge	r5,r4,81131910 <___vfiprintf_internal_r+0xe94>
8113166c:	1000da1e 	bne	r2,zero,811319d8 <___vfiprintf_internal_r+0xf5c>
81131670:	7000ab1e 	bne	r14,zero,81131920 <___vfiprintf_internal_r+0xea4>
81131674:	000b883a 	mov	r5,zero
81131678:	1809883a 	mov	r4,r3
8113167c:	d811883a 	mov	r8,sp
81131680:	00c02004 	movi	r3,128
81131684:	e0fe4d26 	beq	fp,r3,81130fbc <__reset+0xfb110fbc>
81131688:	4cf9c83a 	sub	fp,r9,r19
8113168c:	073e7b0e 	bge	zero,fp,8113107c <__reset+0xfb11107c>
81131690:	01c00404 	movi	r7,16
81131694:	3f01900e 	bge	r7,fp,81131cd8 <___vfiprintf_internal_r+0x125c>
81131698:	00e04574 	movhi	r3,33045
8113169c:	18ff2c04 	addi	r3,r3,-848
811316a0:	d8c02415 	stw	r3,144(sp)
811316a4:	034001c4 	movi	r13,7
811316a8:	00000506 	br	811316c0 <___vfiprintf_internal_r+0xc44>
811316ac:	29000084 	addi	r4,r5,2
811316b0:	42000204 	addi	r8,r8,8
811316b4:	180b883a 	mov	r5,r3
811316b8:	e73ffc04 	addi	fp,fp,-16
811316bc:	3f000d0e 	bge	r7,fp,811316f4 <___vfiprintf_internal_r+0xc78>
811316c0:	10800404 	addi	r2,r2,16
811316c4:	28c00044 	addi	r3,r5,1
811316c8:	45c00015 	stw	r23,0(r8)
811316cc:	41c00115 	stw	r7,4(r8)
811316d0:	d8801c15 	stw	r2,112(sp)
811316d4:	d8c01b15 	stw	r3,108(sp)
811316d8:	68fff40e 	bge	r13,r3,811316ac <__reset+0xfb1116ac>
811316dc:	1000101e 	bne	r2,zero,81131720 <___vfiprintf_internal_r+0xca4>
811316e0:	e73ffc04 	addi	fp,fp,-16
811316e4:	01000044 	movi	r4,1
811316e8:	000b883a 	mov	r5,zero
811316ec:	d811883a 	mov	r8,sp
811316f0:	3f3ff316 	blt	r7,fp,811316c0 <__reset+0xfb1116c0>
811316f4:	da802417 	ldw	r10,144(sp)
811316f8:	1705883a 	add	r2,r2,fp
811316fc:	47000115 	stw	fp,4(r8)
81131700:	42800015 	stw	r10,0(r8)
81131704:	d8801c15 	stw	r2,112(sp)
81131708:	d9001b15 	stw	r4,108(sp)
8113170c:	00c001c4 	movi	r3,7
81131710:	19003616 	blt	r3,r4,811317ec <___vfiprintf_internal_r+0xd70>
81131714:	42000204 	addi	r8,r8,8
81131718:	21000044 	addi	r4,r4,1
8113171c:	003e5706 	br	8113107c <__reset+0xfb11107c>
81131720:	d9402117 	ldw	r5,132(sp)
81131724:	d9002017 	ldw	r4,128(sp)
81131728:	d9801a04 	addi	r6,sp,104
8113172c:	d9c02b15 	stw	r7,172(sp)
81131730:	db402a15 	stw	r13,168(sp)
81131734:	11309600 	call	81130960 <__sprint_r.part.0>
81131738:	d9c02b17 	ldw	r7,172(sp)
8113173c:	db402a17 	ldw	r13,168(sp)
81131740:	1000241e 	bne	r2,zero,811317d4 <___vfiprintf_internal_r+0xd58>
81131744:	d9401b17 	ldw	r5,108(sp)
81131748:	d8801c17 	ldw	r2,112(sp)
8113174c:	d811883a 	mov	r8,sp
81131750:	29000044 	addi	r4,r5,1
81131754:	003fd806 	br	811316b8 <__reset+0xfb1116b8>
81131758:	d9401b17 	ldw	r5,108(sp)
8113175c:	00e04574 	movhi	r3,33045
81131760:	18ff3004 	addi	r3,r3,-832
81131764:	d8c02415 	stw	r3,144(sp)
81131768:	29400044 	addi	r5,r5,1
8113176c:	d8c02417 	ldw	r3,144(sp)
81131770:	14c5883a 	add	r2,r2,r19
81131774:	44c00115 	stw	r19,4(r8)
81131778:	40c00015 	stw	r3,0(r8)
8113177c:	d8801c15 	stw	r2,112(sp)
81131780:	d9401b15 	stw	r5,108(sp)
81131784:	00c001c4 	movi	r3,7
81131788:	1940070e 	bge	r3,r5,811317a8 <___vfiprintf_internal_r+0xd2c>
8113178c:	103e4826 	beq	r2,zero,811310b0 <__reset+0xfb1110b0>
81131790:	d9402117 	ldw	r5,132(sp)
81131794:	d9002017 	ldw	r4,128(sp)
81131798:	d9801a04 	addi	r6,sp,104
8113179c:	11309600 	call	81130960 <__sprint_r.part.0>
811317a0:	10000c1e 	bne	r2,zero,811317d4 <___vfiprintf_internal_r+0xd58>
811317a4:	d8801c17 	ldw	r2,112(sp)
811317a8:	8c80010e 	bge	r17,r18,811317b0 <___vfiprintf_internal_r+0xd34>
811317ac:	9023883a 	mov	r17,r18
811317b0:	da802317 	ldw	r10,140(sp)
811317b4:	5455883a 	add	r10,r10,r17
811317b8:	da802315 	stw	r10,140(sp)
811317bc:	103e4126 	beq	r2,zero,811310c4 <__reset+0xfb1110c4>
811317c0:	d9402117 	ldw	r5,132(sp)
811317c4:	d9002017 	ldw	r4,128(sp)
811317c8:	d9801a04 	addi	r6,sp,104
811317cc:	11309600 	call	81130960 <__sprint_r.part.0>
811317d0:	103e3c26 	beq	r2,zero,811310c4 <__reset+0xfb1110c4>
811317d4:	dd002117 	ldw	r20,132(sp)
811317d8:	a080030b 	ldhu	r2,12(r20)
811317dc:	1080100c 	andi	r2,r2,64
811317e0:	1001231e 	bne	r2,zero,81131c70 <___vfiprintf_internal_r+0x11f4>
811317e4:	d8802317 	ldw	r2,140(sp)
811317e8:	003d7b06 	br	81130dd8 <__reset+0xfb110dd8>
811317ec:	1000991e 	bne	r2,zero,81131a54 <___vfiprintf_internal_r+0xfd8>
811317f0:	00c00044 	movi	r3,1
811317f4:	9805883a 	mov	r2,r19
811317f8:	dd400015 	stw	r21,0(sp)
811317fc:	dcc00115 	stw	r19,4(sp)
81131800:	dcc01c15 	stw	r19,112(sp)
81131804:	d8c01b15 	stw	r3,108(sp)
81131808:	d811883a 	mov	r8,sp
8113180c:	42000204 	addi	r8,r8,8
81131810:	a2c0010c 	andi	r11,r20,4
81131814:	583fe426 	beq	r11,zero,811317a8 <__reset+0xfb1117a8>
81131818:	8ca7c83a 	sub	r19,r17,r18
8113181c:	04ffe20e 	bge	zero,r19,811317a8 <__reset+0xfb1117a8>
81131820:	01c00404 	movi	r7,16
81131824:	3cffcc0e 	bge	r7,r19,81131758 <__reset+0xfb111758>
81131828:	02a04574 	movhi	r10,33045
8113182c:	52bf3004 	addi	r10,r10,-832
81131830:	d9001b17 	ldw	r4,108(sp)
81131834:	da802415 	stw	r10,144(sp)
81131838:	382b883a 	mov	r21,r7
8113183c:	050001c4 	movi	r20,7
81131840:	df002017 	ldw	fp,128(sp)
81131844:	00000506 	br	8113185c <___vfiprintf_internal_r+0xde0>
81131848:	21400084 	addi	r5,r4,2
8113184c:	42000204 	addi	r8,r8,8
81131850:	1809883a 	mov	r4,r3
81131854:	9cfffc04 	addi	r19,r19,-16
81131858:	acffc40e 	bge	r21,r19,8113176c <__reset+0xfb11176c>
8113185c:	10800404 	addi	r2,r2,16
81131860:	20c00044 	addi	r3,r4,1
81131864:	45800015 	stw	r22,0(r8)
81131868:	45400115 	stw	r21,4(r8)
8113186c:	d8801c15 	stw	r2,112(sp)
81131870:	d8c01b15 	stw	r3,108(sp)
81131874:	a0fff40e 	bge	r20,r3,81131848 <__reset+0xfb111848>
81131878:	1000041e 	bne	r2,zero,8113188c <___vfiprintf_internal_r+0xe10>
8113187c:	01400044 	movi	r5,1
81131880:	0009883a 	mov	r4,zero
81131884:	d811883a 	mov	r8,sp
81131888:	003ff206 	br	81131854 <__reset+0xfb111854>
8113188c:	d9402117 	ldw	r5,132(sp)
81131890:	d9801a04 	addi	r6,sp,104
81131894:	e009883a 	mov	r4,fp
81131898:	11309600 	call	81130960 <__sprint_r.part.0>
8113189c:	103fcd1e 	bne	r2,zero,811317d4 <__reset+0xfb1117d4>
811318a0:	d9001b17 	ldw	r4,108(sp)
811318a4:	d8801c17 	ldw	r2,112(sp)
811318a8:	d811883a 	mov	r8,sp
811318ac:	21400044 	addi	r5,r4,1
811318b0:	003fe806 	br	81131854 <__reset+0xfb111854>
811318b4:	d9402117 	ldw	r5,132(sp)
811318b8:	d9002017 	ldw	r4,128(sp)
811318bc:	d9801a04 	addi	r6,sp,104
811318c0:	d9c02b15 	stw	r7,172(sp)
811318c4:	db402a15 	stw	r13,168(sp)
811318c8:	11309600 	call	81130960 <__sprint_r.part.0>
811318cc:	d9c02b17 	ldw	r7,172(sp)
811318d0:	db402a17 	ldw	r13,168(sp)
811318d4:	103fbf1e 	bne	r2,zero,811317d4 <__reset+0xfb1117d4>
811318d8:	d9401b17 	ldw	r5,108(sp)
811318dc:	d8801c17 	ldw	r2,112(sp)
811318e0:	d811883a 	mov	r8,sp
811318e4:	29800044 	addi	r6,r5,1
811318e8:	003dc406 	br	81130ffc <__reset+0xfb110ffc>
811318ec:	1000d21e 	bne	r2,zero,81131c38 <___vfiprintf_internal_r+0x11bc>
811318f0:	d8c01d87 	ldb	r3,118(sp)
811318f4:	18009526 	beq	r3,zero,81131b4c <___vfiprintf_internal_r+0x10d0>
811318f8:	00800044 	movi	r2,1
811318fc:	d8c01d84 	addi	r3,sp,118
81131900:	1009883a 	mov	r4,r2
81131904:	d8c00015 	stw	r3,0(sp)
81131908:	d8800115 	stw	r2,4(sp)
8113190c:	d811883a 	mov	r8,sp
81131910:	200b883a 	mov	r5,r4
81131914:	42000204 	addi	r8,r8,8
81131918:	21000044 	addi	r4,r4,1
8113191c:	003d9706 	br	81130f7c <__reset+0xfb110f7c>
81131920:	d9001d04 	addi	r4,sp,116
81131924:	00800084 	movi	r2,2
81131928:	d9000015 	stw	r4,0(sp)
8113192c:	d8800115 	stw	r2,4(sp)
81131930:	1809883a 	mov	r4,r3
81131934:	d811883a 	mov	r8,sp
81131938:	200b883a 	mov	r5,r4
8113193c:	42000204 	addi	r8,r8,8
81131940:	21000044 	addi	r4,r4,1
81131944:	003f4e06 	br	81131680 <__reset+0xfb111680>
81131948:	d8001d85 	stb	zero,118(sp)
8113194c:	48005016 	blt	r9,zero,81131a90 <___vfiprintf_internal_r+0x1014>
81131950:	00ffdfc4 	movi	r3,-129
81131954:	94c4b03a 	or	r2,r18,r19
81131958:	a0e8703a 	and	r20,r20,r3
8113195c:	103d4426 	beq	r2,zero,81130e70 <__reset+0xfb110e70>
81131960:	0039883a 	mov	fp,zero
81131964:	d9002617 	ldw	r4,152(sp)
81131968:	dd401a04 	addi	r21,sp,104
8113196c:	908003cc 	andi	r2,r18,15
81131970:	9806973a 	slli	r3,r19,28
81131974:	2085883a 	add	r2,r4,r2
81131978:	9024d13a 	srli	r18,r18,4
8113197c:	10800003 	ldbu	r2,0(r2)
81131980:	9826d13a 	srli	r19,r19,4
81131984:	ad7fffc4 	addi	r21,r21,-1
81131988:	1ca4b03a 	or	r18,r3,r18
8113198c:	a8800005 	stb	r2,0(r21)
81131990:	94c4b03a 	or	r2,r18,r19
81131994:	103ff51e 	bne	r2,zero,8113196c <__reset+0xfb11196c>
81131998:	003e5906 	br	81131300 <__reset+0xfb111300>
8113199c:	d9402117 	ldw	r5,132(sp)
811319a0:	d9002017 	ldw	r4,128(sp)
811319a4:	d9801a04 	addi	r6,sp,104
811319a8:	11309600 	call	81130960 <__sprint_r.part.0>
811319ac:	103f891e 	bne	r2,zero,811317d4 <__reset+0xfb1117d4>
811319b0:	d8801c17 	ldw	r2,112(sp)
811319b4:	d811883a 	mov	r8,sp
811319b8:	003f9506 	br	81131810 <__reset+0xfb111810>
811319bc:	d9402117 	ldw	r5,132(sp)
811319c0:	d9002017 	ldw	r4,128(sp)
811319c4:	d9801a04 	addi	r6,sp,104
811319c8:	11309600 	call	81130960 <__sprint_r.part.0>
811319cc:	103f811e 	bne	r2,zero,811317d4 <__reset+0xfb1117d4>
811319d0:	d811883a 	mov	r8,sp
811319d4:	003ced06 	br	81130d8c <__reset+0xfb110d8c>
811319d8:	d9402117 	ldw	r5,132(sp)
811319dc:	d9002017 	ldw	r4,128(sp)
811319e0:	d9801a04 	addi	r6,sp,104
811319e4:	da402c15 	stw	r9,176(sp)
811319e8:	db802a15 	stw	r14,168(sp)
811319ec:	11309600 	call	81130960 <__sprint_r.part.0>
811319f0:	da402c17 	ldw	r9,176(sp)
811319f4:	db802a17 	ldw	r14,168(sp)
811319f8:	103f761e 	bne	r2,zero,811317d4 <__reset+0xfb1117d4>
811319fc:	d9401b17 	ldw	r5,108(sp)
81131a00:	d8801c17 	ldw	r2,112(sp)
81131a04:	d811883a 	mov	r8,sp
81131a08:	29000044 	addi	r4,r5,1
81131a0c:	003d5b06 	br	81130f7c <__reset+0xfb110f7c>
81131a10:	d9402117 	ldw	r5,132(sp)
81131a14:	d9002017 	ldw	r4,128(sp)
81131a18:	d9801a04 	addi	r6,sp,104
81131a1c:	da402c15 	stw	r9,176(sp)
81131a20:	11309600 	call	81130960 <__sprint_r.part.0>
81131a24:	da402c17 	ldw	r9,176(sp)
81131a28:	103f6a1e 	bne	r2,zero,811317d4 <__reset+0xfb1117d4>
81131a2c:	d9401b17 	ldw	r5,108(sp)
81131a30:	d8801c17 	ldw	r2,112(sp)
81131a34:	d811883a 	mov	r8,sp
81131a38:	29000044 	addi	r4,r5,1
81131a3c:	003f1006 	br	81131680 <__reset+0xfb111680>
81131a40:	1000c31e 	bne	r2,zero,81131d50 <___vfiprintf_internal_r+0x12d4>
81131a44:	01000044 	movi	r4,1
81131a48:	000b883a 	mov	r5,zero
81131a4c:	d811883a 	mov	r8,sp
81131a50:	003f0d06 	br	81131688 <__reset+0xfb111688>
81131a54:	d9402117 	ldw	r5,132(sp)
81131a58:	d9002017 	ldw	r4,128(sp)
81131a5c:	d9801a04 	addi	r6,sp,104
81131a60:	11309600 	call	81130960 <__sprint_r.part.0>
81131a64:	103f5b1e 	bne	r2,zero,811317d4 <__reset+0xfb1117d4>
81131a68:	d9001b17 	ldw	r4,108(sp)
81131a6c:	d8801c17 	ldw	r2,112(sp)
81131a70:	d811883a 	mov	r8,sp
81131a74:	21000044 	addi	r4,r4,1
81131a78:	003d8006 	br	8113107c <__reset+0xfb11107c>
81131a7c:	01204574 	movhi	r4,33045
81131a80:	213e9a04 	addi	r4,r4,-1432
81131a84:	d9002615 	stw	r4,152(sp)
81131a88:	d8c02215 	stw	r3,136(sp)
81131a8c:	1029883a 	mov	r20,r2
81131a90:	94c4b03a 	or	r2,r18,r19
81131a94:	103fb21e 	bne	r2,zero,81131960 <__reset+0xfb111960>
81131a98:	0039883a 	mov	fp,zero
81131a9c:	00800084 	movi	r2,2
81131aa0:	003e6b06 	br	81131450 <__reset+0xfb111450>
81131aa4:	da802217 	ldw	r10,136(sp)
81131aa8:	d8001d85 	stb	zero,118(sp)
81131aac:	0027883a 	mov	r19,zero
81131ab0:	50800104 	addi	r2,r10,4
81131ab4:	54800017 	ldw	r18,0(r10)
81131ab8:	483e6016 	blt	r9,zero,8113143c <__reset+0xfb11143c>
81131abc:	00ffdfc4 	movi	r3,-129
81131ac0:	d8802215 	stw	r2,136(sp)
81131ac4:	a0e8703a 	and	r20,r20,r3
81131ac8:	0039883a 	mov	fp,zero
81131acc:	903ebb26 	beq	r18,zero,811315bc <__reset+0xfb1115bc>
81131ad0:	00800244 	movi	r2,9
81131ad4:	14bdee36 	bltu	r2,r18,81131290 <__reset+0xfb111290>
81131ad8:	003eba06 	br	811315c4 <__reset+0xfb1115c4>
81131adc:	00800c04 	movi	r2,48
81131ae0:	d8c01d45 	stb	r3,117(sp)
81131ae4:	d8801d05 	stb	r2,116(sp)
81131ae8:	d8001d85 	stb	zero,118(sp)
81131aec:	a0c00094 	ori	r3,r20,2
81131af0:	4800a916 	blt	r9,zero,81131d98 <___vfiprintf_internal_r+0x131c>
81131af4:	00bfdfc4 	movi	r2,-129
81131af8:	a096703a 	and	r11,r20,r2
81131afc:	5d000094 	ori	r20,r11,2
81131b00:	0039883a 	mov	fp,zero
81131b04:	003f9706 	br	81131964 <__reset+0xfb111964>
81131b08:	8025883a 	mov	r18,r16
81131b0c:	003c2e06 	br	81130bc8 <__reset+0xfb110bc8>
81131b10:	00a04574 	movhi	r2,33045
81131b14:	10be9a04 	addi	r2,r2,-1432
81131b18:	0039883a 	mov	fp,zero
81131b1c:	d8802615 	stw	r2,152(sp)
81131b20:	003f9006 	br	81131964 <__reset+0xfb111964>
81131b24:	04a5c83a 	sub	r18,zero,r18
81131b28:	07000b44 	movi	fp,45
81131b2c:	9004c03a 	cmpne	r2,r18,zero
81131b30:	04e7c83a 	sub	r19,zero,r19
81131b34:	df001d85 	stb	fp,118(sp)
81131b38:	98a7c83a 	sub	r19,r19,r2
81131b3c:	48009f16 	blt	r9,zero,81131dbc <___vfiprintf_internal_r+0x1340>
81131b40:	00bfdfc4 	movi	r2,-129
81131b44:	a0a8703a 	and	r20,r20,r2
81131b48:	003dd006 	br	8113128c <__reset+0xfb11128c>
81131b4c:	70004c26 	beq	r14,zero,81131c80 <___vfiprintf_internal_r+0x1204>
81131b50:	00800084 	movi	r2,2
81131b54:	d8c01d04 	addi	r3,sp,116
81131b58:	d8c00015 	stw	r3,0(sp)
81131b5c:	d8800115 	stw	r2,4(sp)
81131b60:	01000044 	movi	r4,1
81131b64:	d811883a 	mov	r8,sp
81131b68:	003f7306 	br	81131938 <__reset+0xfb111938>
81131b6c:	a080100c 	andi	r2,r20,64
81131b70:	da802217 	ldw	r10,136(sp)
81131b74:	103e0626 	beq	r2,zero,81131390 <__reset+0xfb111390>
81131b78:	5480000f 	ldh	r18,0(r10)
81131b7c:	52800104 	addi	r10,r10,4
81131b80:	da802215 	stw	r10,136(sp)
81131b84:	9027d7fa 	srai	r19,r18,31
81131b88:	9805883a 	mov	r2,r19
81131b8c:	003db806 	br	81131270 <__reset+0xfb111270>
81131b90:	a080040c 	andi	r2,r20,16
81131b94:	1000091e 	bne	r2,zero,81131bbc <___vfiprintf_internal_r+0x1140>
81131b98:	a2c0100c 	andi	r11,r20,64
81131b9c:	58000726 	beq	r11,zero,81131bbc <___vfiprintf_internal_r+0x1140>
81131ba0:	da802217 	ldw	r10,136(sp)
81131ba4:	50800017 	ldw	r2,0(r10)
81131ba8:	52800104 	addi	r10,r10,4
81131bac:	da802215 	stw	r10,136(sp)
81131bb0:	da802317 	ldw	r10,140(sp)
81131bb4:	1280000d 	sth	r10,0(r2)
81131bb8:	003be706 	br	81130b58 <__reset+0xfb110b58>
81131bbc:	da802217 	ldw	r10,136(sp)
81131bc0:	50800017 	ldw	r2,0(r10)
81131bc4:	52800104 	addi	r10,r10,4
81131bc8:	da802215 	stw	r10,136(sp)
81131bcc:	da802317 	ldw	r10,140(sp)
81131bd0:	12800015 	stw	r10,0(r2)
81131bd4:	003be006 	br	81130b58 <__reset+0xfb110b58>
81131bd8:	a080100c 	andi	r2,r20,64
81131bdc:	da802217 	ldw	r10,136(sp)
81131be0:	10003026 	beq	r2,zero,81131ca4 <___vfiprintf_internal_r+0x1228>
81131be4:	5480000b 	ldhu	r18,0(r10)
81131be8:	52800104 	addi	r10,r10,4
81131bec:	0027883a 	mov	r19,zero
81131bf0:	da802215 	stw	r10,136(sp)
81131bf4:	003d8006 	br	811311f8 <__reset+0xfb1111f8>
81131bf8:	80c00007 	ldb	r3,0(r16)
81131bfc:	003c0006 	br	81130c00 <__reset+0xfb110c00>
81131c00:	a080100c 	andi	r2,r20,64
81131c04:	d8001d85 	stb	zero,118(sp)
81131c08:	da802217 	ldw	r10,136(sp)
81131c0c:	1000201e 	bne	r2,zero,81131c90 <___vfiprintf_internal_r+0x1214>
81131c10:	50800104 	addi	r2,r10,4
81131c14:	54800017 	ldw	r18,0(r10)
81131c18:	0027883a 	mov	r19,zero
81131c1c:	483def0e 	bge	r9,zero,811313dc <__reset+0xfb1113dc>
81131c20:	94c6b03a 	or	r3,r18,r19
81131c24:	d8802215 	stw	r2,136(sp)
81131c28:	183d4e1e 	bne	r3,zero,81131164 <__reset+0xfb111164>
81131c2c:	0039883a 	mov	fp,zero
81131c30:	0005883a 	mov	r2,zero
81131c34:	003e0606 	br	81131450 <__reset+0xfb111450>
81131c38:	d9402117 	ldw	r5,132(sp)
81131c3c:	d9002017 	ldw	r4,128(sp)
81131c40:	d9801a04 	addi	r6,sp,104
81131c44:	da402c15 	stw	r9,176(sp)
81131c48:	db802a15 	stw	r14,168(sp)
81131c4c:	11309600 	call	81130960 <__sprint_r.part.0>
81131c50:	da402c17 	ldw	r9,176(sp)
81131c54:	db802a17 	ldw	r14,168(sp)
81131c58:	103ede1e 	bne	r2,zero,811317d4 <__reset+0xfb1117d4>
81131c5c:	d9401b17 	ldw	r5,108(sp)
81131c60:	d8801c17 	ldw	r2,112(sp)
81131c64:	d811883a 	mov	r8,sp
81131c68:	29000044 	addi	r4,r5,1
81131c6c:	003e7406 	br	81131640 <__reset+0xfb111640>
81131c70:	00bfffc4 	movi	r2,-1
81131c74:	003c5806 	br	81130dd8 <__reset+0xfb110dd8>
81131c78:	d811883a 	mov	r8,sp
81131c7c:	003ee806 	br	81131820 <__reset+0xfb111820>
81131c80:	000b883a 	mov	r5,zero
81131c84:	01000044 	movi	r4,1
81131c88:	d811883a 	mov	r8,sp
81131c8c:	003e7c06 	br	81131680 <__reset+0xfb111680>
81131c90:	50800104 	addi	r2,r10,4
81131c94:	5480000b 	ldhu	r18,0(r10)
81131c98:	0027883a 	mov	r19,zero
81131c9c:	483dcf0e 	bge	r9,zero,811313dc <__reset+0xfb1113dc>
81131ca0:	003fdf06 	br	81131c20 <__reset+0xfb111c20>
81131ca4:	54800017 	ldw	r18,0(r10)
81131ca8:	52800104 	addi	r10,r10,4
81131cac:	0027883a 	mov	r19,zero
81131cb0:	da802215 	stw	r10,136(sp)
81131cb4:	003d5006 	br	811311f8 <__reset+0xfb1111f8>
81131cb8:	50800104 	addi	r2,r10,4
81131cbc:	5480000b 	ldhu	r18,0(r10)
81131cc0:	0027883a 	mov	r19,zero
81131cc4:	483f7d0e 	bge	r9,zero,81131abc <__reset+0xfb111abc>
81131cc8:	003ddc06 	br	8113143c <__reset+0xfb11143c>
81131ccc:	d8c02215 	stw	r3,136(sp)
81131cd0:	0039883a 	mov	fp,zero
81131cd4:	003ddb06 	br	81131444 <__reset+0xfb111444>
81131cd8:	02a04574 	movhi	r10,33045
81131cdc:	52bf2c04 	addi	r10,r10,-848
81131ce0:	da802415 	stw	r10,144(sp)
81131ce4:	003e8306 	br	811316f4 <__reset+0xfb1116f4>
81131ce8:	d8801c17 	ldw	r2,112(sp)
81131cec:	dd002117 	ldw	r20,132(sp)
81131cf0:	103eb926 	beq	r2,zero,811317d8 <__reset+0xfb1117d8>
81131cf4:	d9002017 	ldw	r4,128(sp)
81131cf8:	d9801a04 	addi	r6,sp,104
81131cfc:	a00b883a 	mov	r5,r20
81131d00:	11309600 	call	81130960 <__sprint_r.part.0>
81131d04:	003eb406 	br	811317d8 <__reset+0xfb1117d8>
81131d08:	80c00043 	ldbu	r3,1(r16)
81131d0c:	a5000814 	ori	r20,r20,32
81131d10:	84000044 	addi	r16,r16,1
81131d14:	18c03fcc 	andi	r3,r3,255
81131d18:	18c0201c 	xori	r3,r3,128
81131d1c:	18ffe004 	addi	r3,r3,-128
81131d20:	003bb706 	br	81130c00 <__reset+0xfb110c00>
81131d24:	a809883a 	mov	r4,r21
81131d28:	d8c02a15 	stw	r3,168(sp)
81131d2c:	da002b15 	stw	r8,172(sp)
81131d30:	112235c0 	call	8112235c <strlen>
81131d34:	d8c02a17 	ldw	r3,168(sp)
81131d38:	1027883a 	mov	r19,r2
81131d3c:	df001d83 	ldbu	fp,118(sp)
81131d40:	d8c02215 	stw	r3,136(sp)
81131d44:	0013883a 	mov	r9,zero
81131d48:	da002b17 	ldw	r8,172(sp)
81131d4c:	003c4d06 	br	81130e84 <__reset+0xfb110e84>
81131d50:	d9402117 	ldw	r5,132(sp)
81131d54:	d9002017 	ldw	r4,128(sp)
81131d58:	d9801a04 	addi	r6,sp,104
81131d5c:	da402c15 	stw	r9,176(sp)
81131d60:	11309600 	call	81130960 <__sprint_r.part.0>
81131d64:	da402c17 	ldw	r9,176(sp)
81131d68:	103e9a1e 	bne	r2,zero,811317d4 <__reset+0xfb1117d4>
81131d6c:	d9401b17 	ldw	r5,108(sp)
81131d70:	d8801c17 	ldw	r2,112(sp)
81131d74:	d811883a 	mov	r8,sp
81131d78:	29000044 	addi	r4,r5,1
81131d7c:	003e4206 	br	81131688 <__reset+0xfb111688>
81131d80:	d9401b17 	ldw	r5,108(sp)
81131d84:	01204574 	movhi	r4,33045
81131d88:	213f3004 	addi	r4,r4,-832
81131d8c:	d9002415 	stw	r4,144(sp)
81131d90:	29400044 	addi	r5,r5,1
81131d94:	003c6d06 	br	81130f4c <__reset+0xfb110f4c>
81131d98:	0039883a 	mov	fp,zero
81131d9c:	00800084 	movi	r2,2
81131da0:	10803fcc 	andi	r2,r2,255
81131da4:	01000044 	movi	r4,1
81131da8:	11001e26 	beq	r2,r4,81131e24 <___vfiprintf_internal_r+0x13a8>
81131dac:	01000084 	movi	r4,2
81131db0:	11001e1e 	bne	r2,r4,81131e2c <___vfiprintf_internal_r+0x13b0>
81131db4:	1829883a 	mov	r20,r3
81131db8:	003eea06 	br	81131964 <__reset+0xfb111964>
81131dbc:	a007883a 	mov	r3,r20
81131dc0:	00800044 	movi	r2,1
81131dc4:	003ff606 	br	81131da0 <__reset+0xfb111da0>
81131dc8:	00800184 	movi	r2,6
81131dcc:	1240012e 	bgeu	r2,r9,81131dd4 <___vfiprintf_internal_r+0x1358>
81131dd0:	1013883a 	mov	r9,r2
81131dd4:	4827883a 	mov	r19,r9
81131dd8:	4825883a 	mov	r18,r9
81131ddc:	48001516 	blt	r9,zero,81131e34 <___vfiprintf_internal_r+0x13b8>
81131de0:	05604574 	movhi	r21,33045
81131de4:	d8c02215 	stw	r3,136(sp)
81131de8:	ad7e9f04 	addi	r21,r21,-1412
81131dec:	003d1406 	br	81131240 <__reset+0xfb111240>
81131df0:	02a04574 	movhi	r10,33045
81131df4:	52bf2c04 	addi	r10,r10,-848
81131df8:	da802415 	stw	r10,144(sp)
81131dfc:	200d883a 	mov	r6,r4
81131e00:	003c9106 	br	81131048 <__reset+0xfb111048>
81131e04:	5021883a 	mov	r16,r10
81131e08:	0013883a 	mov	r9,zero
81131e0c:	003b7d06 	br	81130c04 <__reset+0xfb110c04>
81131e10:	4827883a 	mov	r19,r9
81131e14:	df001d83 	ldbu	fp,118(sp)
81131e18:	d8c02215 	stw	r3,136(sp)
81131e1c:	0013883a 	mov	r9,zero
81131e20:	003c1806 	br	81130e84 <__reset+0xfb110e84>
81131e24:	1829883a 	mov	r20,r3
81131e28:	003d1806 	br	8113128c <__reset+0xfb11128c>
81131e2c:	1829883a 	mov	r20,r3
81131e30:	003ccd06 	br	81131168 <__reset+0xfb111168>
81131e34:	0025883a 	mov	r18,zero
81131e38:	003fe906 	br	81131de0 <__reset+0xfb111de0>
81131e3c:	d8802217 	ldw	r2,136(sp)
81131e40:	80c00043 	ldbu	r3,1(r16)
81131e44:	5021883a 	mov	r16,r10
81131e48:	12400017 	ldw	r9,0(r2)
81131e4c:	10800104 	addi	r2,r2,4
81131e50:	d8802215 	stw	r2,136(sp)
81131e54:	483faf0e 	bge	r9,zero,81131d14 <__reset+0xfb111d14>
81131e58:	18c03fcc 	andi	r3,r3,255
81131e5c:	18c0201c 	xori	r3,r3,128
81131e60:	027fffc4 	movi	r9,-1
81131e64:	18ffe004 	addi	r3,r3,-128
81131e68:	003b6506 	br	81130c00 <__reset+0xfb110c00>
81131e6c:	d9c01d85 	stb	r7,118(sp)
81131e70:	003ca006 	br	811310f4 <__reset+0xfb1110f4>
81131e74:	d9c01d85 	stb	r7,118(sp)
81131e78:	003cad06 	br	81131130 <__reset+0xfb111130>
81131e7c:	d9c01d85 	stb	r7,118(sp)
81131e80:	003d7d06 	br	81131478 <__reset+0xfb111478>
81131e84:	d9c01d85 	stb	r7,118(sp)
81131e88:	003d5f06 	br	81131408 <__reset+0xfb111408>
81131e8c:	a080004c 	andi	r2,r20,1
81131e90:	0039883a 	mov	fp,zero
81131e94:	10000526 	beq	r2,zero,81131eac <___vfiprintf_internal_r+0x1430>
81131e98:	00800c04 	movi	r2,48
81131e9c:	d88019c5 	stb	r2,103(sp)
81131ea0:	dcc02717 	ldw	r19,156(sp)
81131ea4:	dd4019c4 	addi	r21,sp,103
81131ea8:	003bf606 	br	81130e84 <__reset+0xfb110e84>
81131eac:	0027883a 	mov	r19,zero
81131eb0:	dd401a04 	addi	r21,sp,104
81131eb4:	003bf306 	br	81130e84 <__reset+0xfb110e84>
81131eb8:	d9c01d85 	stb	r7,118(sp)
81131ebc:	003dc806 	br	811315e0 <__reset+0xfb1115e0>
81131ec0:	d9c01d85 	stb	r7,118(sp)
81131ec4:	003d3a06 	br	811313b0 <__reset+0xfb1113b0>
81131ec8:	d9c01d85 	stb	r7,118(sp)
81131ecc:	003d2a06 	br	81131378 <__reset+0xfb111378>
81131ed0:	d9c01d85 	stb	r7,118(sp)
81131ed4:	003cde06 	br	81131250 <__reset+0xfb111250>
81131ed8:	d9c01d85 	stb	r7,118(sp)
81131edc:	003cbc06 	br	811311d0 <__reset+0xfb1111d0>

81131ee0 <__vfiprintf_internal>:
81131ee0:	00a04574 	movhi	r2,33045
81131ee4:	10886904 	addi	r2,r2,8612
81131ee8:	300f883a 	mov	r7,r6
81131eec:	280d883a 	mov	r6,r5
81131ef0:	200b883a 	mov	r5,r4
81131ef4:	11000017 	ldw	r4,0(r2)
81131ef8:	1130a7c1 	jmpi	81130a7c <___vfiprintf_internal_r>

81131efc <__sbprintf>:
81131efc:	defee204 	addi	sp,sp,-1144
81131f00:	de00012e 	bgeu	sp,et,81131f08 <__sbprintf+0xc>
81131f04:	003b68fa 	trap	3
81131f08:	2880030b 	ldhu	r2,12(r5)
81131f0c:	2ac01917 	ldw	r11,100(r5)
81131f10:	2a80038b 	ldhu	r10,14(r5)
81131f14:	2a400717 	ldw	r9,28(r5)
81131f18:	2a000917 	ldw	r8,36(r5)
81131f1c:	00c10004 	movi	r3,1024
81131f20:	dc011a15 	stw	r16,1128(sp)
81131f24:	10bfff4c 	andi	r2,r2,65533
81131f28:	2821883a 	mov	r16,r5
81131f2c:	d8cb883a 	add	r5,sp,r3
81131f30:	dc811c15 	stw	r18,1136(sp)
81131f34:	dc411b15 	stw	r17,1132(sp)
81131f38:	dfc11d15 	stw	ra,1140(sp)
81131f3c:	2025883a 	mov	r18,r4
81131f40:	d881030d 	sth	r2,1036(sp)
81131f44:	dac11915 	stw	r11,1124(sp)
81131f48:	da81038d 	sth	r10,1038(sp)
81131f4c:	da410715 	stw	r9,1052(sp)
81131f50:	da010915 	stw	r8,1060(sp)
81131f54:	dec10015 	stw	sp,1024(sp)
81131f58:	dec10415 	stw	sp,1040(sp)
81131f5c:	d8c10215 	stw	r3,1032(sp)
81131f60:	d8c10515 	stw	r3,1044(sp)
81131f64:	d8010615 	stw	zero,1048(sp)
81131f68:	1130a7c0 	call	81130a7c <___vfiprintf_internal_r>
81131f6c:	1023883a 	mov	r17,r2
81131f70:	10000416 	blt	r2,zero,81131f84 <__sbprintf+0x88>
81131f74:	d9410004 	addi	r5,sp,1024
81131f78:	9009883a 	mov	r4,r18
81131f7c:	112a2340 	call	8112a234 <_fflush_r>
81131f80:	10000d1e 	bne	r2,zero,81131fb8 <__sbprintf+0xbc>
81131f84:	d881030b 	ldhu	r2,1036(sp)
81131f88:	1080100c 	andi	r2,r2,64
81131f8c:	10000326 	beq	r2,zero,81131f9c <__sbprintf+0xa0>
81131f90:	8080030b 	ldhu	r2,12(r16)
81131f94:	10801014 	ori	r2,r2,64
81131f98:	8080030d 	sth	r2,12(r16)
81131f9c:	8805883a 	mov	r2,r17
81131fa0:	dfc11d17 	ldw	ra,1140(sp)
81131fa4:	dc811c17 	ldw	r18,1136(sp)
81131fa8:	dc411b17 	ldw	r17,1132(sp)
81131fac:	dc011a17 	ldw	r16,1128(sp)
81131fb0:	dec11e04 	addi	sp,sp,1144
81131fb4:	f800283a 	ret
81131fb8:	047fffc4 	movi	r17,-1
81131fbc:	003ff106 	br	81131f84 <__reset+0xfb111f84>

81131fc0 <_calloc_r>:
81131fc0:	298b383a 	mul	r5,r5,r6
81131fc4:	defffe04 	addi	sp,sp,-8
81131fc8:	de00012e 	bgeu	sp,et,81131fd0 <_calloc_r+0x10>
81131fcc:	003b68fa 	trap	3
81131fd0:	dfc00115 	stw	ra,4(sp)
81131fd4:	dc000015 	stw	r16,0(sp)
81131fd8:	11210540 	call	81121054 <_malloc_r>
81131fdc:	10002926 	beq	r2,zero,81132084 <_calloc_r+0xc4>
81131fe0:	11bfff17 	ldw	r6,-4(r2)
81131fe4:	1021883a 	mov	r16,r2
81131fe8:	00bfff04 	movi	r2,-4
81131fec:	308c703a 	and	r6,r6,r2
81131ff0:	00c00904 	movi	r3,36
81131ff4:	308d883a 	add	r6,r6,r2
81131ff8:	19801636 	bltu	r3,r6,81132054 <_calloc_r+0x94>
81131ffc:	008004c4 	movi	r2,19
81132000:	11800b2e 	bgeu	r2,r6,81132030 <_calloc_r+0x70>
81132004:	80000015 	stw	zero,0(r16)
81132008:	80000115 	stw	zero,4(r16)
8113200c:	008006c4 	movi	r2,27
81132010:	11801a2e 	bgeu	r2,r6,8113207c <_calloc_r+0xbc>
81132014:	80000215 	stw	zero,8(r16)
81132018:	80000315 	stw	zero,12(r16)
8113201c:	30c0151e 	bne	r6,r3,81132074 <_calloc_r+0xb4>
81132020:	80000415 	stw	zero,16(r16)
81132024:	80800604 	addi	r2,r16,24
81132028:	80000515 	stw	zero,20(r16)
8113202c:	00000106 	br	81132034 <_calloc_r+0x74>
81132030:	8005883a 	mov	r2,r16
81132034:	10000015 	stw	zero,0(r2)
81132038:	10000115 	stw	zero,4(r2)
8113203c:	10000215 	stw	zero,8(r2)
81132040:	8005883a 	mov	r2,r16
81132044:	dfc00117 	ldw	ra,4(sp)
81132048:	dc000017 	ldw	r16,0(sp)
8113204c:	dec00204 	addi	sp,sp,8
81132050:	f800283a 	ret
81132054:	000b883a 	mov	r5,zero
81132058:	8009883a 	mov	r4,r16
8113205c:	11219b80 	call	811219b8 <memset>
81132060:	8005883a 	mov	r2,r16
81132064:	dfc00117 	ldw	ra,4(sp)
81132068:	dc000017 	ldw	r16,0(sp)
8113206c:	dec00204 	addi	sp,sp,8
81132070:	f800283a 	ret
81132074:	80800404 	addi	r2,r16,16
81132078:	003fee06 	br	81132034 <__reset+0xfb112034>
8113207c:	80800204 	addi	r2,r16,8
81132080:	003fec06 	br	81132034 <__reset+0xfb112034>
81132084:	0005883a 	mov	r2,zero
81132088:	003fee06 	br	81132044 <__reset+0xfb112044>

8113208c <_fclose_r>:
8113208c:	28003b26 	beq	r5,zero,8113217c <_fclose_r+0xf0>
81132090:	defffc04 	addi	sp,sp,-16
81132094:	de00012e 	bgeu	sp,et,8113209c <_fclose_r+0x10>
81132098:	003b68fa 	trap	3
8113209c:	dc400115 	stw	r17,4(sp)
811320a0:	dc000015 	stw	r16,0(sp)
811320a4:	dfc00315 	stw	ra,12(sp)
811320a8:	dc800215 	stw	r18,8(sp)
811320ac:	2023883a 	mov	r17,r4
811320b0:	2821883a 	mov	r16,r5
811320b4:	20000226 	beq	r4,zero,811320c0 <_fclose_r+0x34>
811320b8:	20800e17 	ldw	r2,56(r4)
811320bc:	10002726 	beq	r2,zero,8113215c <_fclose_r+0xd0>
811320c0:	8080030f 	ldh	r2,12(r16)
811320c4:	1000071e 	bne	r2,zero,811320e4 <_fclose_r+0x58>
811320c8:	0005883a 	mov	r2,zero
811320cc:	dfc00317 	ldw	ra,12(sp)
811320d0:	dc800217 	ldw	r18,8(sp)
811320d4:	dc400117 	ldw	r17,4(sp)
811320d8:	dc000017 	ldw	r16,0(sp)
811320dc:	dec00404 	addi	sp,sp,16
811320e0:	f800283a 	ret
811320e4:	800b883a 	mov	r5,r16
811320e8:	8809883a 	mov	r4,r17
811320ec:	112a0100 	call	8112a010 <__sflush_r>
811320f0:	1025883a 	mov	r18,r2
811320f4:	80800b17 	ldw	r2,44(r16)
811320f8:	10000426 	beq	r2,zero,8113210c <_fclose_r+0x80>
811320fc:	81400717 	ldw	r5,28(r16)
81132100:	8809883a 	mov	r4,r17
81132104:	103ee83a 	callr	r2
81132108:	10001616 	blt	r2,zero,81132164 <_fclose_r+0xd8>
8113210c:	8080030b 	ldhu	r2,12(r16)
81132110:	1080200c 	andi	r2,r2,128
81132114:	1000151e 	bne	r2,zero,8113216c <_fclose_r+0xe0>
81132118:	81400c17 	ldw	r5,48(r16)
8113211c:	28000526 	beq	r5,zero,81132134 <_fclose_r+0xa8>
81132120:	80801004 	addi	r2,r16,64
81132124:	28800226 	beq	r5,r2,81132130 <_fclose_r+0xa4>
81132128:	8809883a 	mov	r4,r17
8113212c:	112aac80 	call	8112aac8 <_free_r>
81132130:	80000c15 	stw	zero,48(r16)
81132134:	81401117 	ldw	r5,68(r16)
81132138:	28000326 	beq	r5,zero,81132148 <_fclose_r+0xbc>
8113213c:	8809883a 	mov	r4,r17
81132140:	112aac80 	call	8112aac8 <_free_r>
81132144:	80001115 	stw	zero,68(r16)
81132148:	112a6400 	call	8112a640 <__sfp_lock_acquire>
8113214c:	8000030d 	sth	zero,12(r16)
81132150:	112a6440 	call	8112a644 <__sfp_lock_release>
81132154:	9005883a 	mov	r2,r18
81132158:	003fdc06 	br	811320cc <__reset+0xfb1120cc>
8113215c:	112a6300 	call	8112a630 <__sinit>
81132160:	003fd706 	br	811320c0 <__reset+0xfb1120c0>
81132164:	04bfffc4 	movi	r18,-1
81132168:	003fe806 	br	8113210c <__reset+0xfb11210c>
8113216c:	81400417 	ldw	r5,16(r16)
81132170:	8809883a 	mov	r4,r17
81132174:	112aac80 	call	8112aac8 <_free_r>
81132178:	003fe706 	br	81132118 <__reset+0xfb112118>
8113217c:	0005883a 	mov	r2,zero
81132180:	f800283a 	ret

81132184 <fclose>:
81132184:	00a04574 	movhi	r2,33045
81132188:	10886904 	addi	r2,r2,8612
8113218c:	200b883a 	mov	r5,r4
81132190:	11000017 	ldw	r4,0(r2)
81132194:	113208c1 	jmpi	8113208c <_fclose_r>

81132198 <__fputwc>:
81132198:	defff804 	addi	sp,sp,-32
8113219c:	de00012e 	bgeu	sp,et,811321a4 <__fputwc+0xc>
811321a0:	003b68fa 	trap	3
811321a4:	dcc00415 	stw	r19,16(sp)
811321a8:	dc800315 	stw	r18,12(sp)
811321ac:	dc000115 	stw	r16,4(sp)
811321b0:	dfc00715 	stw	ra,28(sp)
811321b4:	dd400615 	stw	r21,24(sp)
811321b8:	dd000515 	stw	r20,20(sp)
811321bc:	dc400215 	stw	r17,8(sp)
811321c0:	2027883a 	mov	r19,r4
811321c4:	2825883a 	mov	r18,r5
811321c8:	3021883a 	mov	r16,r6
811321cc:	112b5580 	call	8112b558 <__locale_mb_cur_max>
811321d0:	00c00044 	movi	r3,1
811321d4:	10c03e26 	beq	r2,r3,811322d0 <__fputwc+0x138>
811321d8:	81c01704 	addi	r7,r16,92
811321dc:	900d883a 	mov	r6,r18
811321e0:	d80b883a 	mov	r5,sp
811321e4:	9809883a 	mov	r4,r19
811321e8:	113301c0 	call	8113301c <_wcrtomb_r>
811321ec:	1029883a 	mov	r20,r2
811321f0:	00bfffc4 	movi	r2,-1
811321f4:	a0802026 	beq	r20,r2,81132278 <__fputwc+0xe0>
811321f8:	d9400003 	ldbu	r5,0(sp)
811321fc:	a0001c26 	beq	r20,zero,81132270 <__fputwc+0xd8>
81132200:	0023883a 	mov	r17,zero
81132204:	05400284 	movi	r21,10
81132208:	00000906 	br	81132230 <__fputwc+0x98>
8113220c:	80800017 	ldw	r2,0(r16)
81132210:	11400005 	stb	r5,0(r2)
81132214:	80c00017 	ldw	r3,0(r16)
81132218:	18c00044 	addi	r3,r3,1
8113221c:	80c00015 	stw	r3,0(r16)
81132220:	8c400044 	addi	r17,r17,1
81132224:	dc45883a 	add	r2,sp,r17
81132228:	8d00112e 	bgeu	r17,r20,81132270 <__fputwc+0xd8>
8113222c:	11400003 	ldbu	r5,0(r2)
81132230:	80c00217 	ldw	r3,8(r16)
81132234:	18ffffc4 	addi	r3,r3,-1
81132238:	80c00215 	stw	r3,8(r16)
8113223c:	183ff30e 	bge	r3,zero,8113220c <__reset+0xfb11220c>
81132240:	80800617 	ldw	r2,24(r16)
81132244:	18801916 	blt	r3,r2,811322ac <__fputwc+0x114>
81132248:	80800017 	ldw	r2,0(r16)
8113224c:	11400005 	stb	r5,0(r2)
81132250:	80800017 	ldw	r2,0(r16)
81132254:	10c00003 	ldbu	r3,0(r2)
81132258:	10800044 	addi	r2,r2,1
8113225c:	1d402326 	beq	r3,r21,811322ec <__fputwc+0x154>
81132260:	80800015 	stw	r2,0(r16)
81132264:	8c400044 	addi	r17,r17,1
81132268:	dc45883a 	add	r2,sp,r17
8113226c:	8d3fef36 	bltu	r17,r20,8113222c <__reset+0xfb11222c>
81132270:	9005883a 	mov	r2,r18
81132274:	00000406 	br	81132288 <__fputwc+0xf0>
81132278:	80c0030b 	ldhu	r3,12(r16)
8113227c:	a005883a 	mov	r2,r20
81132280:	18c01014 	ori	r3,r3,64
81132284:	80c0030d 	sth	r3,12(r16)
81132288:	dfc00717 	ldw	ra,28(sp)
8113228c:	dd400617 	ldw	r21,24(sp)
81132290:	dd000517 	ldw	r20,20(sp)
81132294:	dcc00417 	ldw	r19,16(sp)
81132298:	dc800317 	ldw	r18,12(sp)
8113229c:	dc400217 	ldw	r17,8(sp)
811322a0:	dc000117 	ldw	r16,4(sp)
811322a4:	dec00804 	addi	sp,sp,32
811322a8:	f800283a 	ret
811322ac:	800d883a 	mov	r6,r16
811322b0:	29403fcc 	andi	r5,r5,255
811322b4:	9809883a 	mov	r4,r19
811322b8:	11283f80 	call	811283f8 <__swbuf_r>
811322bc:	10bfffe0 	cmpeqi	r2,r2,-1
811322c0:	10803fcc 	andi	r2,r2,255
811322c4:	103fd626 	beq	r2,zero,81132220 <__reset+0xfb112220>
811322c8:	00bfffc4 	movi	r2,-1
811322cc:	003fee06 	br	81132288 <__reset+0xfb112288>
811322d0:	90ffffc4 	addi	r3,r18,-1
811322d4:	01003f84 	movi	r4,254
811322d8:	20ffbf36 	bltu	r4,r3,811321d8 <__reset+0xfb1121d8>
811322dc:	900b883a 	mov	r5,r18
811322e0:	dc800005 	stb	r18,0(sp)
811322e4:	1029883a 	mov	r20,r2
811322e8:	003fc506 	br	81132200 <__reset+0xfb112200>
811322ec:	800d883a 	mov	r6,r16
811322f0:	a80b883a 	mov	r5,r21
811322f4:	9809883a 	mov	r4,r19
811322f8:	11283f80 	call	811283f8 <__swbuf_r>
811322fc:	10bfffe0 	cmpeqi	r2,r2,-1
81132300:	003fef06 	br	811322c0 <__reset+0xfb1122c0>

81132304 <_fputwc_r>:
81132304:	3080030b 	ldhu	r2,12(r6)
81132308:	10c8000c 	andi	r3,r2,8192
8113230c:	1800051e 	bne	r3,zero,81132324 <_fputwc_r+0x20>
81132310:	30c01917 	ldw	r3,100(r6)
81132314:	10880014 	ori	r2,r2,8192
81132318:	3080030d 	sth	r2,12(r6)
8113231c:	18880014 	ori	r2,r3,8192
81132320:	30801915 	stw	r2,100(r6)
81132324:	11321981 	jmpi	81132198 <__fputwc>

81132328 <fputwc>:
81132328:	00a04574 	movhi	r2,33045
8113232c:	defffc04 	addi	sp,sp,-16
81132330:	10886904 	addi	r2,r2,8612
81132334:	de00012e 	bgeu	sp,et,8113233c <fputwc+0x14>
81132338:	003b68fa 	trap	3
8113233c:	dc000115 	stw	r16,4(sp)
81132340:	14000017 	ldw	r16,0(r2)
81132344:	dc400215 	stw	r17,8(sp)
81132348:	dfc00315 	stw	ra,12(sp)
8113234c:	2023883a 	mov	r17,r4
81132350:	80000226 	beq	r16,zero,8113235c <fputwc+0x34>
81132354:	80800e17 	ldw	r2,56(r16)
81132358:	10001026 	beq	r2,zero,8113239c <fputwc+0x74>
8113235c:	2880030b 	ldhu	r2,12(r5)
81132360:	10c8000c 	andi	r3,r2,8192
81132364:	1800051e 	bne	r3,zero,8113237c <fputwc+0x54>
81132368:	28c01917 	ldw	r3,100(r5)
8113236c:	10880014 	ori	r2,r2,8192
81132370:	2880030d 	sth	r2,12(r5)
81132374:	18880014 	ori	r2,r3,8192
81132378:	28801915 	stw	r2,100(r5)
8113237c:	280d883a 	mov	r6,r5
81132380:	8009883a 	mov	r4,r16
81132384:	880b883a 	mov	r5,r17
81132388:	dfc00317 	ldw	ra,12(sp)
8113238c:	dc400217 	ldw	r17,8(sp)
81132390:	dc000117 	ldw	r16,4(sp)
81132394:	dec00404 	addi	sp,sp,16
81132398:	11321981 	jmpi	81132198 <__fputwc>
8113239c:	8009883a 	mov	r4,r16
811323a0:	d9400015 	stw	r5,0(sp)
811323a4:	112a6300 	call	8112a630 <__sinit>
811323a8:	d9400017 	ldw	r5,0(sp)
811323ac:	003feb06 	br	8113235c <__reset+0xfb11235c>

811323b0 <rshift>:
811323b0:	2807d17a 	srai	r3,r5,5
811323b4:	20800417 	ldw	r2,16(r4)
811323b8:	22000504 	addi	r8,r4,20
811323bc:	1880250e 	bge	r3,r2,81132454 <rshift+0xa4>
811323c0:	1085883a 	add	r2,r2,r2
811323c4:	18c7883a 	add	r3,r3,r3
811323c8:	1085883a 	add	r2,r2,r2
811323cc:	18c7883a 	add	r3,r3,r3
811323d0:	294007cc 	andi	r5,r5,31
811323d4:	4085883a 	add	r2,r8,r2
811323d8:	40c7883a 	add	r3,r8,r3
811323dc:	28002026 	beq	r5,zero,81132460 <rshift+0xb0>
811323e0:	19800017 	ldw	r6,0(r3)
811323e4:	02c00804 	movi	r11,32
811323e8:	19c00104 	addi	r7,r3,4
811323ec:	5957c83a 	sub	r11,r11,r5
811323f0:	314cd83a 	srl	r6,r6,r5
811323f4:	38802c2e 	bgeu	r7,r2,811324a8 <rshift+0xf8>
811323f8:	4015883a 	mov	r10,r8
811323fc:	3a400017 	ldw	r9,0(r7)
81132400:	52800104 	addi	r10,r10,4
81132404:	39c00104 	addi	r7,r7,4
81132408:	4ad2983a 	sll	r9,r9,r11
8113240c:	498cb03a 	or	r6,r9,r6
81132410:	51bfff15 	stw	r6,-4(r10)
81132414:	39bfff17 	ldw	r6,-4(r7)
81132418:	314cd83a 	srl	r6,r6,r5
8113241c:	38bff736 	bltu	r7,r2,811323fc <__reset+0xfb1123fc>
81132420:	10c7c83a 	sub	r3,r2,r3
81132424:	18fffec4 	addi	r3,r3,-5
81132428:	1806d0ba 	srli	r3,r3,2
8113242c:	18c00044 	addi	r3,r3,1
81132430:	18c7883a 	add	r3,r3,r3
81132434:	18c7883a 	add	r3,r3,r3
81132438:	40c7883a 	add	r3,r8,r3
8113243c:	19800015 	stw	r6,0(r3)
81132440:	30000126 	beq	r6,zero,81132448 <rshift+0x98>
81132444:	18c00104 	addi	r3,r3,4
81132448:	1a05c83a 	sub	r2,r3,r8
8113244c:	1005d0ba 	srai	r2,r2,2
81132450:	00001206 	br	8113249c <rshift+0xec>
81132454:	20000415 	stw	zero,16(r4)
81132458:	20000515 	stw	zero,20(r4)
8113245c:	f800283a 	ret
81132460:	18bffc2e 	bgeu	r3,r2,81132454 <__reset+0xfb112454>
81132464:	180d883a 	mov	r6,r3
81132468:	400b883a 	mov	r5,r8
8113246c:	31c00017 	ldw	r7,0(r6)
81132470:	29400104 	addi	r5,r5,4
81132474:	31800104 	addi	r6,r6,4
81132478:	29ffff15 	stw	r7,-4(r5)
8113247c:	30bffb36 	bltu	r6,r2,8113246c <__reset+0xfb11246c>
81132480:	00c6303a 	nor	r3,zero,r3
81132484:	1885883a 	add	r2,r3,r2
81132488:	1004d0ba 	srli	r2,r2,2
8113248c:	10800044 	addi	r2,r2,1
81132490:	1085883a 	add	r2,r2,r2
81132494:	1085883a 	add	r2,r2,r2
81132498:	1005d0ba 	srai	r2,r2,2
8113249c:	20800415 	stw	r2,16(r4)
811324a0:	103fed26 	beq	r2,zero,81132458 <__reset+0xfb112458>
811324a4:	f800283a 	ret
811324a8:	4007883a 	mov	r3,r8
811324ac:	003fe306 	br	8113243c <__reset+0xfb11243c>

811324b0 <__gethex>:
811324b0:	deffeb04 	addi	sp,sp,-84
811324b4:	de00012e 	bgeu	sp,et,811324bc <__gethex+0xc>
811324b8:	003b68fa 	trap	3
811324bc:	dfc01415 	stw	ra,80(sp)
811324c0:	dd801115 	stw	r22,68(sp)
811324c4:	dcc00e15 	stw	r19,56(sp)
811324c8:	dc800d15 	stw	r18,52(sp)
811324cc:	2827883a 	mov	r19,r5
811324d0:	d9000115 	stw	r4,4(sp)
811324d4:	d9800015 	stw	r6,0(sp)
811324d8:	d9c00415 	stw	r7,16(sp)
811324dc:	df001315 	stw	fp,76(sp)
811324e0:	ddc01215 	stw	r23,72(sp)
811324e4:	dd401015 	stw	r21,64(sp)
811324e8:	dd000f15 	stw	r20,60(sp)
811324ec:	dc400c15 	stw	r17,48(sp)
811324f0:	dc000b15 	stw	r16,44(sp)
811324f4:	112b57c0 	call	8112b57c <_localeconv_r>
811324f8:	14800017 	ldw	r18,0(r2)
811324fc:	9009883a 	mov	r4,r18
81132500:	112235c0 	call	8112235c <strlen>
81132504:	98c00017 	ldw	r3,0(r19)
81132508:	102d883a 	mov	r22,r2
8113250c:	9085883a 	add	r2,r18,r2
81132510:	10bfffc3 	ldbu	r2,-1(r2)
81132514:	19000083 	ldbu	r4,2(r3)
81132518:	d8800305 	stb	r2,12(sp)
8113251c:	00800c04 	movi	r2,48
81132520:	2081521e 	bne	r4,r2,81132a6c <__gethex+0x5bc>
81132524:	017fff84 	movi	r5,-2
81132528:	188000c4 	addi	r2,r3,3
8113252c:	28cbc83a 	sub	r5,r5,r3
81132530:	200d883a 	mov	r6,r4
81132534:	28a3883a 	add	r17,r5,r2
81132538:	102b883a 	mov	r21,r2
8113253c:	10800044 	addi	r2,r2,1
81132540:	113fffc3 	ldbu	r4,-1(r2)
81132544:	21bffb26 	beq	r4,r6,81132534 <__reset+0xfb112534>
81132548:	05204574 	movhi	r20,33045
8113254c:	a53f3404 	addi	r20,r20,-816
81132550:	a109883a 	add	r4,r20,r4
81132554:	20800003 	ldbu	r2,0(r4)
81132558:	10008826 	beq	r2,zero,8113277c <__gethex+0x2cc>
8113255c:	a8800003 	ldbu	r2,0(r21)
81132560:	0015883a 	mov	r10,zero
81132564:	002f883a 	mov	r23,zero
81132568:	a085883a 	add	r2,r20,r2
8113256c:	10800003 	ldbu	r2,0(r2)
81132570:	a821883a 	mov	r16,r21
81132574:	10000526 	beq	r2,zero,8113258c <__gethex+0xdc>
81132578:	84000044 	addi	r16,r16,1
8113257c:	80800003 	ldbu	r2,0(r16)
81132580:	a085883a 	add	r2,r20,r2
81132584:	10800003 	ldbu	r2,0(r2)
81132588:	103ffb1e 	bne	r2,zero,81132578 <__reset+0xfb112578>
8113258c:	b00d883a 	mov	r6,r22
81132590:	900b883a 	mov	r5,r18
81132594:	8009883a 	mov	r4,r16
81132598:	da800a15 	stw	r10,40(sp)
8113259c:	1132f4c0 	call	81132f4c <strncmp>
811325a0:	da800a17 	ldw	r10,40(sp)
811325a4:	1000031e 	bne	r2,zero,811325b4 <__gethex+0x104>
811325a8:	b8015226 	beq	r23,zero,81132af4 <__gethex+0x644>
811325ac:	80800003 	ldbu	r2,0(r16)
811325b0:	00000206 	br	811325bc <__gethex+0x10c>
811325b4:	80800003 	ldbu	r2,0(r16)
811325b8:	b8011f26 	beq	r23,zero,81132a38 <__gethex+0x588>
811325bc:	85efc83a 	sub	r23,r16,r23
811325c0:	bdef883a 	add	r23,r23,r23
811325c4:	bdef883a 	add	r23,r23,r23
811325c8:	05efc83a 	sub	r23,zero,r23
811325cc:	10803fcc 	andi	r2,r2,255
811325d0:	01001404 	movi	r4,80
811325d4:	11008626 	beq	r2,r4,811327f0 <__gethex+0x340>
811325d8:	01001c04 	movi	r4,112
811325dc:	11008426 	beq	r2,r4,811327f0 <__gethex+0x340>
811325e0:	8039883a 	mov	fp,r16
811325e4:	9c000015 	stw	r16,0(r19)
811325e8:	5000711e 	bne	r10,zero,811327b0 <__gethex+0x300>
811325ec:	e545c83a 	sub	r2,fp,r21
811325f0:	10bfffc4 	addi	r2,r2,-1
811325f4:	010001c4 	movi	r4,7
811325f8:	000b883a 	mov	r5,zero
811325fc:	2080030e 	bge	r4,r2,8113260c <__gethex+0x15c>
81132600:	1005d07a 	srai	r2,r2,1
81132604:	29400044 	addi	r5,r5,1
81132608:	20bffd16 	blt	r4,r2,81132600 <__reset+0xfb112600>
8113260c:	d9000117 	ldw	r4,4(sp)
81132610:	112ba980 	call	8112ba98 <_Balloc>
81132614:	10c00504 	addi	r3,r2,20
81132618:	d8c00215 	stw	r3,8(sp)
8113261c:	1021883a 	mov	r16,r2
81132620:	af01732e 	bgeu	r21,fp,81132bf0 <__gethex+0x740>
81132624:	dc400303 	ldbu	r17,12(sp)
81132628:	03400044 	movi	r13,1
8113262c:	1815883a 	mov	r10,r3
81132630:	0013883a 	mov	r9,zero
81132634:	0027883a 	mov	r19,zero
81132638:	6d9bc83a 	sub	r13,r13,r22
8113263c:	02c00804 	movi	r11,32
81132640:	e0bfffc3 	ldbu	r2,-1(fp)
81132644:	e3bfffc4 	addi	r14,fp,-1
81132648:	88803026 	beq	r17,r2,8113270c <__gethex+0x25c>
8113264c:	9ac04526 	beq	r19,r11,81132764 <__gethex+0x2b4>
81132650:	980b883a 	mov	r5,r19
81132654:	9cc00104 	addi	r19,r19,4
81132658:	e13fffc3 	ldbu	r4,-1(fp)
8113265c:	7039883a 	mov	fp,r14
81132660:	a109883a 	add	r4,r20,r4
81132664:	20800003 	ldbu	r2,0(r4)
81132668:	108003cc 	andi	r2,r2,15
8113266c:	1144983a 	sll	r2,r2,r5
81132670:	4892b03a 	or	r9,r9,r2
81132674:	af3ff236 	bltu	r21,fp,81132640 <__reset+0xfb112640>
81132678:	d8c00217 	ldw	r3,8(sp)
8113267c:	50800104 	addi	r2,r10,4
81132680:	52400015 	stw	r9,0(r10)
81132684:	10c5c83a 	sub	r2,r2,r3
81132688:	1005d0ba 	srai	r2,r2,2
8113268c:	4809883a 	mov	r4,r9
81132690:	80800415 	stw	r2,16(r16)
81132694:	1022917a 	slli	r17,r2,5
81132698:	112bda40 	call	8112bda4 <__hi0bits>
8113269c:	d8c00017 	ldw	r3,0(sp)
811326a0:	8885c83a 	sub	r2,r17,r2
811326a4:	1c800017 	ldw	r18,0(r3)
811326a8:	9080c716 	blt	r18,r2,811329c8 <__gethex+0x518>
811326ac:	1480e416 	blt	r2,r18,81132a40 <__gethex+0x590>
811326b0:	0027883a 	mov	r19,zero
811326b4:	d8c00017 	ldw	r3,0(sp)
811326b8:	18800217 	ldw	r2,8(r3)
811326bc:	15c08d16 	blt	r2,r23,811328f4 <__gethex+0x444>
811326c0:	d8c00017 	ldw	r3,0(sp)
811326c4:	18800117 	ldw	r2,4(r3)
811326c8:	b880aa0e 	bge	r23,r2,81132974 <__gethex+0x4c4>
811326cc:	15efc83a 	sub	r23,r2,r23
811326d0:	bc80ed16 	blt	r23,r18,81132a88 <__gethex+0x5d8>
811326d4:	18c00317 	ldw	r3,12(r3)
811326d8:	01000084 	movi	r4,2
811326dc:	19014926 	beq	r3,r4,81132c04 <__gethex+0x754>
811326e0:	010000c4 	movi	r4,3
811326e4:	19012e26 	beq	r3,r4,81132ba0 <__gethex+0x6f0>
811326e8:	01000044 	movi	r4,1
811326ec:	19014826 	beq	r3,r4,81132c10 <__gethex+0x760>
811326f0:	d9000117 	ldw	r4,4(sp)
811326f4:	800b883a 	mov	r5,r16
811326f8:	112bb480 	call	8112bb48 <_Bfree>
811326fc:	d8801517 	ldw	r2,84(sp)
81132700:	10000015 	stw	zero,0(r2)
81132704:	00801404 	movi	r2,80
81132708:	00002b06 	br	811327b8 <__gethex+0x308>
8113270c:	735f883a 	add	r15,r14,r13
81132710:	7d7fce36 	bltu	r15,r21,8113264c <__reset+0xfb11264c>
81132714:	7809883a 	mov	r4,r15
81132718:	b00d883a 	mov	r6,r22
8113271c:	900b883a 	mov	r5,r18
81132720:	da400515 	stw	r9,20(sp)
81132724:	da800a15 	stw	r10,40(sp)
81132728:	dac00915 	stw	r11,36(sp)
8113272c:	db400815 	stw	r13,32(sp)
81132730:	db800615 	stw	r14,24(sp)
81132734:	dbc00715 	stw	r15,28(sp)
81132738:	1132f4c0 	call	81132f4c <strncmp>
8113273c:	da400517 	ldw	r9,20(sp)
81132740:	da800a17 	ldw	r10,40(sp)
81132744:	dac00917 	ldw	r11,36(sp)
81132748:	db400817 	ldw	r13,32(sp)
8113274c:	db800617 	ldw	r14,24(sp)
81132750:	dbc00717 	ldw	r15,28(sp)
81132754:	103fbd1e 	bne	r2,zero,8113264c <__reset+0xfb11264c>
81132758:	7839883a 	mov	fp,r15
8113275c:	af3fb836 	bltu	r21,fp,81132640 <__reset+0xfb112640>
81132760:	003fc506 	br	81132678 <__reset+0xfb112678>
81132764:	04c00104 	movi	r19,4
81132768:	52400015 	stw	r9,0(r10)
8113276c:	000b883a 	mov	r5,zero
81132770:	54d5883a 	add	r10,r10,r19
81132774:	0013883a 	mov	r9,zero
81132778:	003fb706 	br	81132658 <__reset+0xfb112658>
8113277c:	b00d883a 	mov	r6,r22
81132780:	900b883a 	mov	r5,r18
81132784:	a809883a 	mov	r4,r21
81132788:	1132f4c0 	call	81132f4c <strncmp>
8113278c:	10006426 	beq	r2,zero,81132920 <__gethex+0x470>
81132790:	a8800003 	ldbu	r2,0(r21)
81132794:	a821883a 	mov	r16,r21
81132798:	10803fcc 	andi	r2,r2,255
8113279c:	01001404 	movi	r4,80
811327a0:	11001126 	beq	r2,r4,811327e8 <__gethex+0x338>
811327a4:	01001c04 	movi	r4,112
811327a8:	11000f26 	beq	r2,r4,811327e8 <__gethex+0x338>
811327ac:	9c000015 	stw	r16,0(r19)
811327b0:	8800831e 	bne	r17,zero,811329c0 <__gethex+0x510>
811327b4:	00800184 	movi	r2,6
811327b8:	dfc01417 	ldw	ra,80(sp)
811327bc:	df001317 	ldw	fp,76(sp)
811327c0:	ddc01217 	ldw	r23,72(sp)
811327c4:	dd801117 	ldw	r22,68(sp)
811327c8:	dd401017 	ldw	r21,64(sp)
811327cc:	dd000f17 	ldw	r20,60(sp)
811327d0:	dcc00e17 	ldw	r19,56(sp)
811327d4:	dc800d17 	ldw	r18,52(sp)
811327d8:	dc400c17 	ldw	r17,48(sp)
811327dc:	dc000b17 	ldw	r16,44(sp)
811327e0:	dec01504 	addi	sp,sp,84
811327e4:	f800283a 	ret
811327e8:	002f883a 	mov	r23,zero
811327ec:	02800044 	movi	r10,1
811327f0:	80800043 	ldbu	r2,1(r16)
811327f4:	01400ac4 	movi	r5,43
811327f8:	11003fcc 	andi	r4,r2,255
811327fc:	21406e26 	beq	r4,r5,811329b8 <__gethex+0x508>
81132800:	01400b44 	movi	r5,45
81132804:	21404226 	beq	r4,r5,81132910 <__gethex+0x460>
81132808:	81400044 	addi	r5,r16,1
8113280c:	000d883a 	mov	r6,zero
81132810:	10803fcc 	andi	r2,r2,255
81132814:	a085883a 	add	r2,r20,r2
81132818:	11000003 	ldbu	r4,0(r2)
8113281c:	03000604 	movi	r12,24
81132820:	20bfffc4 	addi	r2,r4,-1
81132824:	10803fcc 	andi	r2,r2,255
81132828:	60bf6d36 	bltu	r12,r2,811325e0 <__reset+0xfb1125e0>
8113282c:	2ac00043 	ldbu	r11,1(r5)
81132830:	20803fcc 	andi	r2,r4,255
81132834:	01204574 	movhi	r4,33045
81132838:	213f3404 	addi	r4,r4,-816
8113283c:	22c9883a 	add	r4,r4,r11
81132840:	23400003 	ldbu	r13,0(r4)
81132844:	10bffc04 	addi	r2,r2,-16
81132848:	29400044 	addi	r5,r5,1
8113284c:	693fffc4 	addi	r4,r13,-1
81132850:	21003fcc 	andi	r4,r4,255
81132854:	6b403fcc 	andi	r13,r13,255
81132858:	61000b36 	bltu	r12,r4,81132888 <__gethex+0x3d8>
8113285c:	29400044 	addi	r5,r5,1
81132860:	29000003 	ldbu	r4,0(r5)
81132864:	108002a4 	muli	r2,r2,10
81132868:	a109883a 	add	r4,r20,r4
8113286c:	22c00003 	ldbu	r11,0(r4)
81132870:	1345883a 	add	r2,r2,r13
81132874:	10bffc04 	addi	r2,r2,-16
81132878:	593fffc4 	addi	r4,r11,-1
8113287c:	21003fcc 	andi	r4,r4,255
81132880:	5b403fcc 	andi	r13,r11,255
81132884:	613ff52e 	bgeu	r12,r4,8113285c <__reset+0xfb11285c>
81132888:	30000126 	beq	r6,zero,81132890 <__gethex+0x3e0>
8113288c:	0085c83a 	sub	r2,zero,r2
81132890:	8039883a 	mov	fp,r16
81132894:	b8af883a 	add	r23,r23,r2
81132898:	2821883a 	mov	r16,r5
8113289c:	003f5106 	br	811325e4 <__reset+0xfb1125e4>
811328a0:	80800217 	ldw	r2,8(r16)
811328a4:	e080f00e 	bge	fp,r2,81132c68 <__gethex+0x7b8>
811328a8:	e007883a 	mov	r3,fp
811328ac:	18800144 	addi	r2,r3,5
811328b0:	1085883a 	add	r2,r2,r2
811328b4:	18c00044 	addi	r3,r3,1
811328b8:	1085883a 	add	r2,r2,r2
811328bc:	8085883a 	add	r2,r16,r2
811328c0:	80c00415 	stw	r3,16(r16)
811328c4:	01000044 	movi	r4,1
811328c8:	11000015 	stw	r4,0(r2)
811328cc:	00800084 	movi	r2,2
811328d0:	8880d826 	beq	r17,r2,81132c34 <__gethex+0x784>
811328d4:	e0c0ac0e 	bge	fp,r3,81132b88 <__gethex+0x6d8>
811328d8:	01400044 	movi	r5,1
811328dc:	8009883a 	mov	r4,r16
811328e0:	11323b00 	call	811323b0 <rshift>
811328e4:	d8c00017 	ldw	r3,0(sp)
811328e8:	bdc00044 	addi	r23,r23,1
811328ec:	18800217 	ldw	r2,8(r3)
811328f0:	15c0a70e 	bge	r2,r23,81132b90 <__gethex+0x6e0>
811328f4:	d9000117 	ldw	r4,4(sp)
811328f8:	800b883a 	mov	r5,r16
811328fc:	112bb480 	call	8112bb48 <_Bfree>
81132900:	d9001517 	ldw	r4,84(sp)
81132904:	008028c4 	movi	r2,163
81132908:	20000015 	stw	zero,0(r4)
8113290c:	003faa06 	br	811327b8 <__reset+0xfb1127b8>
81132910:	01800044 	movi	r6,1
81132914:	80800083 	ldbu	r2,2(r16)
81132918:	81400084 	addi	r5,r16,2
8113291c:	003fbc06 	br	81132810 <__reset+0xfb112810>
81132920:	ada1883a 	add	r16,r21,r22
81132924:	81000003 	ldbu	r4,0(r16)
81132928:	21403fcc 	andi	r5,r4,255
8113292c:	a145883a 	add	r2,r20,r5
81132930:	10800003 	ldbu	r2,0(r2)
81132934:	11803fcc 	andi	r6,r2,255
81132938:	30004f26 	beq	r6,zero,81132a78 <__gethex+0x5c8>
8113293c:	00c00c04 	movi	r3,48
81132940:	802b883a 	mov	r21,r16
81132944:	28c0061e 	bne	r5,r3,81132960 <__gethex+0x4b0>
81132948:	2809883a 	mov	r4,r5
8113294c:	ad400044 	addi	r21,r21,1
81132950:	a8800003 	ldbu	r2,0(r21)
81132954:	113ffd26 	beq	r2,r4,8113294c <__reset+0xfb11294c>
81132958:	a085883a 	add	r2,r20,r2
8113295c:	10800003 	ldbu	r2,0(r2)
81132960:	10803fcc 	andi	r2,r2,255
81132964:	1015003a 	cmpeq	r10,r2,zero
81132968:	802f883a 	mov	r23,r16
8113296c:	04400044 	movi	r17,1
81132970:	003eff06 	br	81132570 <__reset+0xfb112570>
81132974:	04400044 	movi	r17,1
81132978:	98000926 	beq	r19,zero,811329a0 <__gethex+0x4f0>
8113297c:	d8c00017 	ldw	r3,0(sp)
81132980:	18800317 	ldw	r2,12(r3)
81132984:	00c00084 	movi	r3,2
81132988:	10c06826 	beq	r2,r3,81132b2c <__gethex+0x67c>
8113298c:	00c000c4 	movi	r3,3
81132990:	10c06a26 	beq	r2,r3,81132b3c <__gethex+0x68c>
81132994:	00c00044 	movi	r3,1
81132998:	10c08d26 	beq	r2,r3,81132bd0 <__gethex+0x720>
8113299c:	8c400414 	ori	r17,r17,16
811329a0:	d9001517 	ldw	r4,84(sp)
811329a4:	d8c00417 	ldw	r3,16(sp)
811329a8:	8805883a 	mov	r2,r17
811329ac:	24000015 	stw	r16,0(r4)
811329b0:	1dc00015 	stw	r23,0(r3)
811329b4:	003f8006 	br	811327b8 <__reset+0xfb1127b8>
811329b8:	000d883a 	mov	r6,zero
811329bc:	003fd506 	br	81132914 <__reset+0xfb112914>
811329c0:	0005883a 	mov	r2,zero
811329c4:	003f7c06 	br	811327b8 <__reset+0xfb1127b8>
811329c8:	14a3c83a 	sub	r17,r2,r18
811329cc:	880b883a 	mov	r5,r17
811329d0:	8009883a 	mov	r4,r16
811329d4:	112ca680 	call	8112ca68 <__any_on>
811329d8:	10002926 	beq	r2,zero,81132a80 <__gethex+0x5d0>
811329dc:	897fffc4 	addi	r5,r17,-1
811329e0:	2807d17a 	srai	r3,r5,5
811329e4:	d8800217 	ldw	r2,8(sp)
811329e8:	290007cc 	andi	r4,r5,31
811329ec:	18c7883a 	add	r3,r3,r3
811329f0:	18c7883a 	add	r3,r3,r3
811329f4:	04c00044 	movi	r19,1
811329f8:	10c7883a 	add	r3,r2,r3
811329fc:	9908983a 	sll	r4,r19,r4
81132a00:	18c00017 	ldw	r3,0(r3)
81132a04:	20c6703a 	and	r3,r4,r3
81132a08:	18000626 	beq	r3,zero,81132a24 <__gethex+0x574>
81132a0c:	99407b0e 	bge	r19,r5,81132bfc <__gethex+0x74c>
81132a10:	897fff84 	addi	r5,r17,-2
81132a14:	8009883a 	mov	r4,r16
81132a18:	112ca680 	call	8112ca68 <__any_on>
81132a1c:	10007726 	beq	r2,zero,81132bfc <__gethex+0x74c>
81132a20:	04c000c4 	movi	r19,3
81132a24:	880b883a 	mov	r5,r17
81132a28:	8009883a 	mov	r4,r16
81132a2c:	11323b00 	call	811323b0 <rshift>
81132a30:	bc6f883a 	add	r23,r23,r17
81132a34:	003f1f06 	br	811326b4 <__reset+0xfb1126b4>
81132a38:	002f883a 	mov	r23,zero
81132a3c:	003ee306 	br	811325cc <__reset+0xfb1125cc>
81132a40:	d9000117 	ldw	r4,4(sp)
81132a44:	90a3c83a 	sub	r17,r18,r2
81132a48:	800b883a 	mov	r5,r16
81132a4c:	880d883a 	mov	r6,r17
81132a50:	112c2480 	call	8112c248 <__lshift>
81132a54:	10c00504 	addi	r3,r2,20
81132a58:	1021883a 	mov	r16,r2
81132a5c:	bc6fc83a 	sub	r23,r23,r17
81132a60:	d8c00215 	stw	r3,8(sp)
81132a64:	0027883a 	mov	r19,zero
81132a68:	003f1206 	br	811326b4 <__reset+0xfb1126b4>
81132a6c:	1d400084 	addi	r21,r3,2
81132a70:	0023883a 	mov	r17,zero
81132a74:	003eb406 	br	81132548 <__reset+0xfb112548>
81132a78:	2005883a 	mov	r2,r4
81132a7c:	003f4606 	br	81132798 <__reset+0xfb112798>
81132a80:	0027883a 	mov	r19,zero
81132a84:	003fe706 	br	81132a24 <__reset+0xfb112a24>
81132a88:	bc7fffc4 	addi	r17,r23,-1
81132a8c:	9800421e 	bne	r19,zero,81132b98 <__gethex+0x6e8>
81132a90:	88000426 	beq	r17,zero,81132aa4 <__gethex+0x5f4>
81132a94:	880b883a 	mov	r5,r17
81132a98:	8009883a 	mov	r4,r16
81132a9c:	112ca680 	call	8112ca68 <__any_on>
81132aa0:	1027883a 	mov	r19,r2
81132aa4:	8805d17a 	srai	r2,r17,5
81132aa8:	d8c00217 	ldw	r3,8(sp)
81132aac:	8c4007cc 	andi	r17,r17,31
81132ab0:	1085883a 	add	r2,r2,r2
81132ab4:	1085883a 	add	r2,r2,r2
81132ab8:	1885883a 	add	r2,r3,r2
81132abc:	00c00044 	movi	r3,1
81132ac0:	1c62983a 	sll	r17,r3,r17
81132ac4:	10800017 	ldw	r2,0(r2)
81132ac8:	8884703a 	and	r2,r17,r2
81132acc:	10000126 	beq	r2,zero,81132ad4 <__gethex+0x624>
81132ad0:	9cc00094 	ori	r19,r19,2
81132ad4:	b80b883a 	mov	r5,r23
81132ad8:	8009883a 	mov	r4,r16
81132adc:	11323b00 	call	811323b0 <rshift>
81132ae0:	d8c00017 	ldw	r3,0(sp)
81132ae4:	95e5c83a 	sub	r18,r18,r23
81132ae8:	04400084 	movi	r17,2
81132aec:	1dc00117 	ldw	r23,4(r3)
81132af0:	003fa106 	br	81132978 <__reset+0xfb112978>
81132af4:	85af883a 	add	r23,r16,r22
81132af8:	b8800003 	ldbu	r2,0(r23)
81132afc:	b821883a 	mov	r16,r23
81132b00:	11003fcc 	andi	r4,r2,255
81132b04:	a109883a 	add	r4,r20,r4
81132b08:	21000003 	ldbu	r4,0(r4)
81132b0c:	203eaa26 	beq	r4,zero,811325b8 <__reset+0xfb1125b8>
81132b10:	84000044 	addi	r16,r16,1
81132b14:	80800003 	ldbu	r2,0(r16)
81132b18:	11003fcc 	andi	r4,r2,255
81132b1c:	a109883a 	add	r4,r20,r4
81132b20:	21000003 	ldbu	r4,0(r4)
81132b24:	203ffa1e 	bne	r4,zero,81132b10 <__reset+0xfb112b10>
81132b28:	003ea306 	br	811325b8 <__reset+0xfb1125b8>
81132b2c:	d9001617 	ldw	r4,88(sp)
81132b30:	00800044 	movi	r2,1
81132b34:	1109c83a 	sub	r4,r2,r4
81132b38:	d9001615 	stw	r4,88(sp)
81132b3c:	d8801617 	ldw	r2,88(sp)
81132b40:	103f9626 	beq	r2,zero,8113299c <__reset+0xfb11299c>
81132b44:	87000417 	ldw	fp,16(r16)
81132b48:	d9800217 	ldw	r6,8(sp)
81132b4c:	013fffc4 	movi	r4,-1
81132b50:	e727883a 	add	r19,fp,fp
81132b54:	9ce7883a 	add	r19,r19,r19
81132b58:	3005883a 	mov	r2,r6
81132b5c:	34cb883a 	add	r5,r6,r19
81132b60:	00000306 	br	81132b70 <__gethex+0x6c0>
81132b64:	10000015 	stw	zero,0(r2)
81132b68:	10800104 	addi	r2,r2,4
81132b6c:	117f4c2e 	bgeu	r2,r5,811328a0 <__reset+0xfb1128a0>
81132b70:	10c00017 	ldw	r3,0(r2)
81132b74:	193ffb26 	beq	r3,r4,81132b64 <__reset+0xfb112b64>
81132b78:	18c00044 	addi	r3,r3,1
81132b7c:	10c00015 	stw	r3,0(r2)
81132b80:	00800084 	movi	r2,2
81132b84:	88802b26 	beq	r17,r2,81132c34 <__gethex+0x784>
81132b88:	948007cc 	andi	r18,r18,31
81132b8c:	90002f1e 	bne	r18,zero,81132c4c <__gethex+0x79c>
81132b90:	04400844 	movi	r17,33
81132b94:	003f8206 	br	811329a0 <__reset+0xfb1129a0>
81132b98:	04c00044 	movi	r19,1
81132b9c:	003fc106 	br	81132aa4 <__reset+0xfb112aa4>
81132ba0:	d8c01617 	ldw	r3,88(sp)
81132ba4:	183ed226 	beq	r3,zero,811326f0 <__reset+0xfb1126f0>
81132ba8:	d8c00417 	ldw	r3,16(sp)
81132bac:	d9001517 	ldw	r4,84(sp)
81132bb0:	18800015 	stw	r2,0(r3)
81132bb4:	d8c00217 	ldw	r3,8(sp)
81132bb8:	00800044 	movi	r2,1
81132bbc:	80800415 	stw	r2,16(r16)
81132bc0:	18800015 	stw	r2,0(r3)
81132bc4:	24000015 	stw	r16,0(r4)
81132bc8:	00801884 	movi	r2,98
81132bcc:	003efa06 	br	811327b8 <__reset+0xfb1127b8>
81132bd0:	9880008c 	andi	r2,r19,2
81132bd4:	103f7126 	beq	r2,zero,8113299c <__reset+0xfb11299c>
81132bd8:	d8c00217 	ldw	r3,8(sp)
81132bdc:	18800017 	ldw	r2,0(r3)
81132be0:	9884b03a 	or	r2,r19,r2
81132be4:	1080004c 	andi	r2,r2,1
81132be8:	103fd61e 	bne	r2,zero,81132b44 <__reset+0xfb112b44>
81132bec:	003f6b06 	br	8113299c <__reset+0xfb11299c>
81132bf0:	da800217 	ldw	r10,8(sp)
81132bf4:	0013883a 	mov	r9,zero
81132bf8:	003e9f06 	br	81132678 <__reset+0xfb112678>
81132bfc:	04c00084 	movi	r19,2
81132c00:	003f8806 	br	81132a24 <__reset+0xfb112a24>
81132c04:	d9001617 	ldw	r4,88(sp)
81132c08:	203fe726 	beq	r4,zero,81132ba8 <__reset+0xfb112ba8>
81132c0c:	003eb806 	br	811326f0 <__reset+0xfb1126f0>
81132c10:	95feb71e 	bne	r18,r23,811326f0 <__reset+0xfb1126f0>
81132c14:	1cbfe40e 	bge	r3,r18,81132ba8 <__reset+0xfb112ba8>
81132c18:	917fffc4 	addi	r5,r18,-1
81132c1c:	8009883a 	mov	r4,r16
81132c20:	112ca680 	call	8112ca68 <__any_on>
81132c24:	103eb226 	beq	r2,zero,811326f0 <__reset+0xfb1126f0>
81132c28:	d8c00017 	ldw	r3,0(sp)
81132c2c:	18800117 	ldw	r2,4(r3)
81132c30:	003fdd06 	br	81132ba8 <__reset+0xfb112ba8>
81132c34:	d8c00017 	ldw	r3,0(sp)
81132c38:	18800017 	ldw	r2,0(r3)
81132c3c:	10bfffc4 	addi	r2,r2,-1
81132c40:	90801c26 	beq	r18,r2,81132cb4 <__gethex+0x804>
81132c44:	04400884 	movi	r17,34
81132c48:	003f5506 	br	811329a0 <__reset+0xfb1129a0>
81132c4c:	34c5883a 	add	r2,r6,r19
81132c50:	113fff17 	ldw	r4,-4(r2)
81132c54:	112bda40 	call	8112bda4 <__hi0bits>
81132c58:	00c00804 	movi	r3,32
81132c5c:	1ca5c83a 	sub	r18,r3,r18
81132c60:	14bfcb0e 	bge	r2,r18,81132b90 <__reset+0xfb112b90>
81132c64:	003f1c06 	br	811328d8 <__reset+0xfb1128d8>
81132c68:	81400117 	ldw	r5,4(r16)
81132c6c:	d9000117 	ldw	r4,4(sp)
81132c70:	29400044 	addi	r5,r5,1
81132c74:	112ba980 	call	8112ba98 <_Balloc>
81132c78:	81800417 	ldw	r6,16(r16)
81132c7c:	81400304 	addi	r5,r16,12
81132c80:	11000304 	addi	r4,r2,12
81132c84:	31800084 	addi	r6,r6,2
81132c88:	318d883a 	add	r6,r6,r6
81132c8c:	318d883a 	add	r6,r6,r6
81132c90:	1029883a 	mov	r20,r2
81132c94:	11218680 	call	81121868 <memcpy>
81132c98:	d9000117 	ldw	r4,4(sp)
81132c9c:	800b883a 	mov	r5,r16
81132ca0:	a021883a 	mov	r16,r20
81132ca4:	112bb480 	call	8112bb48 <_Bfree>
81132ca8:	a0c00417 	ldw	r3,16(r20)
81132cac:	a1800504 	addi	r6,r20,20
81132cb0:	003efe06 	br	811328ac <__reset+0xfb1128ac>
81132cb4:	9005d17a 	srai	r2,r18,5
81132cb8:	944007cc 	andi	r17,r18,31
81132cbc:	1085883a 	add	r2,r2,r2
81132cc0:	1085883a 	add	r2,r2,r2
81132cc4:	3087883a 	add	r3,r6,r2
81132cc8:	00800044 	movi	r2,1
81132ccc:	1462983a 	sll	r17,r2,r17
81132cd0:	18800017 	ldw	r2,0(r3)
81132cd4:	8884703a 	and	r2,r17,r2
81132cd8:	1022c03a 	cmpne	r17,r2,zero
81132cdc:	00800884 	movi	r2,34
81132ce0:	1463c83a 	sub	r17,r2,r17
81132ce4:	003f2e06 	br	811329a0 <__reset+0xfb1129a0>

81132ce8 <__hexnan>:
81132ce8:	defff904 	addi	sp,sp,-28
81132cec:	de00012e 	bgeu	sp,et,81132cf4 <__hexnan+0xc>
81132cf0:	003b68fa 	trap	3
81132cf4:	dc800215 	stw	r18,8(sp)
81132cf8:	2c800017 	ldw	r18,0(r5)
81132cfc:	dfc00615 	stw	ra,24(sp)
81132d00:	dd400515 	stw	r21,20(sp)
81132d04:	901fd17a 	srai	r15,r18,5
81132d08:	dd000415 	stw	r20,16(sp)
81132d0c:	dcc00315 	stw	r19,12(sp)
81132d10:	7bdf883a 	add	r15,r15,r15
81132d14:	7bdf883a 	add	r15,r15,r15
81132d18:	dc400115 	stw	r17,4(sp)
81132d1c:	dc000015 	stw	r16,0(sp)
81132d20:	948007cc 	andi	r18,r18,31
81132d24:	33df883a 	add	r15,r6,r15
81132d28:	90000126 	beq	r18,zero,81132d30 <__hexnan+0x48>
81132d2c:	7bc00104 	addi	r15,r15,4
81132d30:	22000017 	ldw	r8,0(r4)
81132d34:	7affff04 	addi	r11,r15,-4
81132d38:	03a04574 	movhi	r14,33045
81132d3c:	783fff15 	stw	zero,-4(r15)
81132d40:	581b883a 	mov	r13,r11
81132d44:	580b883a 	mov	r5,r11
81132d48:	000f883a 	mov	r7,zero
81132d4c:	003f883a 	mov	ra,zero
81132d50:	0019883a 	mov	r12,zero
81132d54:	73bf3404 	addi	r14,r14,-816
81132d58:	04400204 	movi	r17,8
81132d5c:	04000804 	movi	r16,32
81132d60:	04c001c4 	movi	r19,7
81132d64:	42000044 	addi	r8,r8,1
81132d68:	40c00003 	ldbu	r3,0(r8)
81132d6c:	18001d26 	beq	r3,zero,81132de4 <__hexnan+0xfc>
81132d70:	70c5883a 	add	r2,r14,r3
81132d74:	10800003 	ldbu	r2,0(r2)
81132d78:	12403fcc 	andi	r9,r2,255
81132d7c:	4800301e 	bne	r9,zero,81132e40 <__hexnan+0x158>
81132d80:	80c04236 	bltu	r16,r3,81132e8c <__hexnan+0x1a4>
81132d84:	fb3ff70e 	bge	ra,r12,81132d64 <__reset+0xfb112d64>
81132d88:	2b40112e 	bgeu	r5,r13,81132dd0 <__hexnan+0xe8>
81132d8c:	99c01016 	blt	r19,r7,81132dd0 <__hexnan+0xe8>
81132d90:	89e9c83a 	sub	r20,r17,r7
81132d94:	a529883a 	add	r20,r20,r20
81132d98:	2a800017 	ldw	r10,0(r5)
81132d9c:	a529883a 	add	r20,r20,r20
81132da0:	852bc83a 	sub	r21,r16,r20
81132da4:	28c00104 	addi	r3,r5,4
81132da8:	2805883a 	mov	r2,r5
81132dac:	19c00017 	ldw	r7,0(r3)
81132db0:	10800104 	addi	r2,r2,4
81132db4:	18c00104 	addi	r3,r3,4
81132db8:	3d52983a 	sll	r9,r7,r21
81132dbc:	4a92b03a 	or	r9,r9,r10
81132dc0:	3d14d83a 	srl	r10,r7,r20
81132dc4:	127fff15 	stw	r9,-4(r2)
81132dc8:	1abfff15 	stw	r10,-4(r3)
81132dcc:	137ff736 	bltu	r2,r13,81132dac <__reset+0xfb112dac>
81132dd0:	31402836 	bltu	r6,r5,81132e74 <__hexnan+0x18c>
81132dd4:	42000044 	addi	r8,r8,1
81132dd8:	40c00003 	ldbu	r3,0(r8)
81132ddc:	01c00204 	movi	r7,8
81132de0:	183fe31e 	bne	r3,zero,81132d70 <__reset+0xfb112d70>
81132de4:	60002b26 	beq	r12,zero,81132e94 <__hexnan+0x1ac>
81132de8:	2b40022e 	bgeu	r5,r13,81132df4 <__hexnan+0x10c>
81132dec:	008001c4 	movi	r2,7
81132df0:	11c0430e 	bge	r2,r7,81132f00 <__hexnan+0x218>
81132df4:	3140312e 	bgeu	r6,r5,81132ebc <__hexnan+0x1d4>
81132df8:	3007883a 	mov	r3,r6
81132dfc:	29000017 	ldw	r4,0(r5)
81132e00:	18800104 	addi	r2,r3,4
81132e04:	29400104 	addi	r5,r5,4
81132e08:	19000015 	stw	r4,0(r3)
81132e0c:	1007883a 	mov	r3,r2
81132e10:	597ffa2e 	bgeu	r11,r5,81132dfc <__reset+0xfb112dfc>
81132e14:	10000015 	stw	zero,0(r2)
81132e18:	10800104 	addi	r2,r2,4
81132e1c:	58bffd2e 	bgeu	r11,r2,81132e14 <__reset+0xfb112e14>
81132e20:	78bfff17 	ldw	r2,-4(r15)
81132e24:	1000041e 	bne	r2,zero,81132e38 <__hexnan+0x150>
81132e28:	32c02d26 	beq	r6,r11,81132ee0 <__hexnan+0x1f8>
81132e2c:	5affff04 	addi	r11,r11,-4
81132e30:	58800017 	ldw	r2,0(r11)
81132e34:	103ffc26 	beq	r2,zero,81132e28 <__reset+0xfb112e28>
81132e38:	00800144 	movi	r2,5
81132e3c:	00001606 	br	81132e98 <__hexnan+0x1b0>
81132e40:	39c00044 	addi	r7,r7,1
81132e44:	63000044 	addi	r12,r12,1
81132e48:	89c0040e 	bge	r17,r7,81132e5c <__hexnan+0x174>
81132e4c:	317fc52e 	bgeu	r6,r5,81132d64 <__reset+0xfb112d64>
81132e50:	283fff15 	stw	zero,-4(r5)
81132e54:	01c00044 	movi	r7,1
81132e58:	297fff04 	addi	r5,r5,-4
81132e5c:	28c00017 	ldw	r3,0(r5)
81132e60:	108003cc 	andi	r2,r2,15
81132e64:	1806913a 	slli	r3,r3,4
81132e68:	1884b03a 	or	r2,r3,r2
81132e6c:	28800015 	stw	r2,0(r5)
81132e70:	003fbc06 	br	81132d64 <__reset+0xfb112d64>
81132e74:	2b7fff04 	addi	r13,r5,-4
81132e78:	283fff15 	stw	zero,-4(r5)
81132e7c:	603f883a 	mov	ra,r12
81132e80:	680b883a 	mov	r5,r13
81132e84:	000f883a 	mov	r7,zero
81132e88:	003fb606 	br	81132d64 <__reset+0xfb112d64>
81132e8c:	00800a44 	movi	r2,41
81132e90:	18801726 	beq	r3,r2,81132ef0 <__hexnan+0x208>
81132e94:	00800104 	movi	r2,4
81132e98:	dfc00617 	ldw	ra,24(sp)
81132e9c:	dd400517 	ldw	r21,20(sp)
81132ea0:	dd000417 	ldw	r20,16(sp)
81132ea4:	dcc00317 	ldw	r19,12(sp)
81132ea8:	dc800217 	ldw	r18,8(sp)
81132eac:	dc400117 	ldw	r17,4(sp)
81132eb0:	dc000017 	ldw	r16,0(sp)
81132eb4:	dec00704 	addi	sp,sp,28
81132eb8:	f800283a 	ret
81132ebc:	903fd826 	beq	r18,zero,81132e20 <__reset+0xfb112e20>
81132ec0:	00c00804 	movi	r3,32
81132ec4:	1ca5c83a 	sub	r18,r3,r18
81132ec8:	00ffffc4 	movi	r3,-1
81132ecc:	78bfff17 	ldw	r2,-4(r15)
81132ed0:	1c86d83a 	srl	r3,r3,r18
81132ed4:	1884703a 	and	r2,r3,r2
81132ed8:	78bfff15 	stw	r2,-4(r15)
81132edc:	003fd106 	br	81132e24 <__reset+0xfb112e24>
81132ee0:	00800044 	movi	r2,1
81132ee4:	58800015 	stw	r2,0(r11)
81132ee8:	00800144 	movi	r2,5
81132eec:	003fea06 	br	81132e98 <__reset+0xfb112e98>
81132ef0:	42000044 	addi	r8,r8,1
81132ef4:	22000015 	stw	r8,0(r4)
81132ef8:	603fbb1e 	bne	r12,zero,81132de8 <__reset+0xfb112de8>
81132efc:	003fe506 	br	81132e94 <__reset+0xfb112e94>
81132f00:	02400204 	movi	r9,8
81132f04:	49d3c83a 	sub	r9,r9,r7
81132f08:	4a53883a 	add	r9,r9,r9
81132f0c:	2a000017 	ldw	r8,0(r5)
81132f10:	4a53883a 	add	r9,r9,r9
81132f14:	02800804 	movi	r10,32
81132f18:	5255c83a 	sub	r10,r10,r9
81132f1c:	28c00104 	addi	r3,r5,4
81132f20:	2805883a 	mov	r2,r5
81132f24:	19c00017 	ldw	r7,0(r3)
81132f28:	10800104 	addi	r2,r2,4
81132f2c:	18c00104 	addi	r3,r3,4
81132f30:	3a88983a 	sll	r4,r7,r10
81132f34:	2208b03a 	or	r4,r4,r8
81132f38:	3a50d83a 	srl	r8,r7,r9
81132f3c:	113fff15 	stw	r4,-4(r2)
81132f40:	1a3fff15 	stw	r8,-4(r3)
81132f44:	137ff736 	bltu	r2,r13,81132f24 <__reset+0xfb112f24>
81132f48:	003faa06 	br	81132df4 <__reset+0xfb112df4>

81132f4c <strncmp>:
81132f4c:	30003126 	beq	r6,zero,81133014 <strncmp+0xc8>
81132f50:	2144b03a 	or	r2,r4,r5
81132f54:	108000cc 	andi	r2,r2,3
81132f58:	10001e1e 	bne	r2,zero,81132fd4 <strncmp+0x88>
81132f5c:	024000c4 	movi	r9,3
81132f60:	49801c2e 	bgeu	r9,r6,81132fd4 <strncmp+0x88>
81132f64:	20800017 	ldw	r2,0(r4)
81132f68:	28c00017 	ldw	r3,0(r5)
81132f6c:	10c0191e 	bne	r2,r3,81132fd4 <strncmp+0x88>
81132f70:	31bfff04 	addi	r6,r6,-4
81132f74:	30002726 	beq	r6,zero,81133014 <strncmp+0xc8>
81132f78:	02ffbff4 	movhi	r11,65279
81132f7c:	5affbfc4 	addi	r11,r11,-257
81132f80:	0086303a 	nor	r3,zero,r2
81132f84:	02a02074 	movhi	r10,32897
81132f88:	12c5883a 	add	r2,r2,r11
81132f8c:	52a02004 	addi	r10,r10,-32640
81132f90:	10c4703a 	and	r2,r2,r3
81132f94:	1284703a 	and	r2,r2,r10
81132f98:	10000b26 	beq	r2,zero,81132fc8 <strncmp+0x7c>
81132f9c:	00001d06 	br	81133014 <strncmp+0xc8>
81132fa0:	20c00017 	ldw	r3,0(r4)
81132fa4:	29c00017 	ldw	r7,0(r5)
81132fa8:	1ad1883a 	add	r8,r3,r11
81132fac:	00c4303a 	nor	r2,zero,r3
81132fb0:	4084703a 	and	r2,r8,r2
81132fb4:	1284703a 	and	r2,r2,r10
81132fb8:	19c0061e 	bne	r3,r7,81132fd4 <strncmp+0x88>
81132fbc:	31bfff04 	addi	r6,r6,-4
81132fc0:	30001426 	beq	r6,zero,81133014 <strncmp+0xc8>
81132fc4:	1000131e 	bne	r2,zero,81133014 <strncmp+0xc8>
81132fc8:	21000104 	addi	r4,r4,4
81132fcc:	29400104 	addi	r5,r5,4
81132fd0:	49bff336 	bltu	r9,r6,81132fa0 <__reset+0xfb112fa0>
81132fd4:	28800007 	ldb	r2,0(r5)
81132fd8:	20c00007 	ldb	r3,0(r4)
81132fdc:	31bfffc4 	addi	r6,r6,-1
81132fe0:	10c0081e 	bne	r2,r3,81133004 <strncmp+0xb8>
81132fe4:	30000b26 	beq	r6,zero,81133014 <strncmp+0xc8>
81132fe8:	10000a26 	beq	r2,zero,81133014 <strncmp+0xc8>
81132fec:	21000044 	addi	r4,r4,1
81132ff0:	29400044 	addi	r5,r5,1
81132ff4:	20800007 	ldb	r2,0(r4)
81132ff8:	28c00007 	ldb	r3,0(r5)
81132ffc:	31bfffc4 	addi	r6,r6,-1
81133000:	10fff826 	beq	r2,r3,81132fe4 <__reset+0xfb112fe4>
81133004:	20800003 	ldbu	r2,0(r4)
81133008:	28c00003 	ldbu	r3,0(r5)
8113300c:	10c5c83a 	sub	r2,r2,r3
81133010:	f800283a 	ret
81133014:	0005883a 	mov	r2,zero
81133018:	f800283a 	ret

8113301c <_wcrtomb_r>:
8113301c:	defff604 	addi	sp,sp,-40
81133020:	00a04574 	movhi	r2,33045
81133024:	de00012e 	bgeu	sp,et,8113302c <_wcrtomb_r+0x10>
81133028:	003b68fa 	trap	3
8113302c:	10886e04 	addi	r2,r2,8632
81133030:	dc800815 	stw	r18,32(sp)
81133034:	dc400715 	stw	r17,28(sp)
81133038:	dc000615 	stw	r16,24(sp)
8113303c:	dfc00915 	stw	ra,36(sp)
81133040:	2021883a 	mov	r16,r4
81133044:	3823883a 	mov	r17,r7
81133048:	14800017 	ldw	r18,0(r2)
8113304c:	28001426 	beq	r5,zero,811330a0 <_wcrtomb_r+0x84>
81133050:	d9400415 	stw	r5,16(sp)
81133054:	d9800515 	stw	r6,20(sp)
81133058:	112b54c0 	call	8112b54c <__locale_charset>
8113305c:	d9800517 	ldw	r6,20(sp)
81133060:	d9400417 	ldw	r5,16(sp)
81133064:	100f883a 	mov	r7,r2
81133068:	dc400015 	stw	r17,0(sp)
8113306c:	8009883a 	mov	r4,r16
81133070:	903ee83a 	callr	r18
81133074:	00ffffc4 	movi	r3,-1
81133078:	10c0031e 	bne	r2,r3,81133088 <_wcrtomb_r+0x6c>
8113307c:	88000015 	stw	zero,0(r17)
81133080:	00c02284 	movi	r3,138
81133084:	80c00015 	stw	r3,0(r16)
81133088:	dfc00917 	ldw	ra,36(sp)
8113308c:	dc800817 	ldw	r18,32(sp)
81133090:	dc400717 	ldw	r17,28(sp)
81133094:	dc000617 	ldw	r16,24(sp)
81133098:	dec00a04 	addi	sp,sp,40
8113309c:	f800283a 	ret
811330a0:	112b54c0 	call	8112b54c <__locale_charset>
811330a4:	100f883a 	mov	r7,r2
811330a8:	dc400015 	stw	r17,0(sp)
811330ac:	000d883a 	mov	r6,zero
811330b0:	d9400104 	addi	r5,sp,4
811330b4:	8009883a 	mov	r4,r16
811330b8:	903ee83a 	callr	r18
811330bc:	003fed06 	br	81133074 <__reset+0xfb113074>

811330c0 <wcrtomb>:
811330c0:	defff604 	addi	sp,sp,-40
811330c4:	00a04574 	movhi	r2,33045
811330c8:	de00012e 	bgeu	sp,et,811330d0 <wcrtomb+0x10>
811330cc:	003b68fa 	trap	3
811330d0:	10886904 	addi	r2,r2,8612
811330d4:	dc800615 	stw	r18,24(sp)
811330d8:	dc400515 	stw	r17,20(sp)
811330dc:	dfc00915 	stw	ra,36(sp)
811330e0:	dd000815 	stw	r20,32(sp)
811330e4:	dcc00715 	stw	r19,28(sp)
811330e8:	dc000415 	stw	r16,16(sp)
811330ec:	3025883a 	mov	r18,r6
811330f0:	14400017 	ldw	r17,0(r2)
811330f4:	20001926 	beq	r4,zero,8113315c <wcrtomb+0x9c>
811330f8:	00a04574 	movhi	r2,33045
811330fc:	10886e04 	addi	r2,r2,8632
81133100:	15000017 	ldw	r20,0(r2)
81133104:	2021883a 	mov	r16,r4
81133108:	2827883a 	mov	r19,r5
8113310c:	112b54c0 	call	8112b54c <__locale_charset>
81133110:	100f883a 	mov	r7,r2
81133114:	dc800015 	stw	r18,0(sp)
81133118:	980d883a 	mov	r6,r19
8113311c:	800b883a 	mov	r5,r16
81133120:	8809883a 	mov	r4,r17
81133124:	a03ee83a 	callr	r20
81133128:	00ffffc4 	movi	r3,-1
8113312c:	10c0031e 	bne	r2,r3,8113313c <wcrtomb+0x7c>
81133130:	90000015 	stw	zero,0(r18)
81133134:	00c02284 	movi	r3,138
81133138:	88c00015 	stw	r3,0(r17)
8113313c:	dfc00917 	ldw	ra,36(sp)
81133140:	dd000817 	ldw	r20,32(sp)
81133144:	dcc00717 	ldw	r19,28(sp)
81133148:	dc800617 	ldw	r18,24(sp)
8113314c:	dc400517 	ldw	r17,20(sp)
81133150:	dc000417 	ldw	r16,16(sp)
81133154:	dec00a04 	addi	sp,sp,40
81133158:	f800283a 	ret
8113315c:	00a04574 	movhi	r2,33045
81133160:	10886e04 	addi	r2,r2,8632
81133164:	14000017 	ldw	r16,0(r2)
81133168:	112b54c0 	call	8112b54c <__locale_charset>
8113316c:	100f883a 	mov	r7,r2
81133170:	dc800015 	stw	r18,0(sp)
81133174:	000d883a 	mov	r6,zero
81133178:	d9400104 	addi	r5,sp,4
8113317c:	8809883a 	mov	r4,r17
81133180:	803ee83a 	callr	r16
81133184:	003fe806 	br	81133128 <__reset+0xfb113128>

81133188 <__ascii_wctomb>:
81133188:	28000526 	beq	r5,zero,811331a0 <__ascii_wctomb+0x18>
8113318c:	00803fc4 	movi	r2,255
81133190:	11800536 	bltu	r2,r6,811331a8 <__ascii_wctomb+0x20>
81133194:	29800005 	stb	r6,0(r5)
81133198:	00800044 	movi	r2,1
8113319c:	f800283a 	ret
811331a0:	0005883a 	mov	r2,zero
811331a4:	f800283a 	ret
811331a8:	00802284 	movi	r2,138
811331ac:	20800015 	stw	r2,0(r4)
811331b0:	00bfffc4 	movi	r2,-1
811331b4:	f800283a 	ret

811331b8 <_wctomb_r>:
811331b8:	00a04574 	movhi	r2,33045
811331bc:	defff904 	addi	sp,sp,-28
811331c0:	10886e04 	addi	r2,r2,8632
811331c4:	de00012e 	bgeu	sp,et,811331cc <_wctomb_r+0x14>
811331c8:	003b68fa 	trap	3
811331cc:	dfc00615 	stw	ra,24(sp)
811331d0:	dc400515 	stw	r17,20(sp)
811331d4:	dc000415 	stw	r16,16(sp)
811331d8:	3823883a 	mov	r17,r7
811331dc:	14000017 	ldw	r16,0(r2)
811331e0:	d9000115 	stw	r4,4(sp)
811331e4:	d9400215 	stw	r5,8(sp)
811331e8:	d9800315 	stw	r6,12(sp)
811331ec:	112b54c0 	call	8112b54c <__locale_charset>
811331f0:	d9800317 	ldw	r6,12(sp)
811331f4:	d9400217 	ldw	r5,8(sp)
811331f8:	d9000117 	ldw	r4,4(sp)
811331fc:	100f883a 	mov	r7,r2
81133200:	dc400015 	stw	r17,0(sp)
81133204:	803ee83a 	callr	r16
81133208:	dfc00617 	ldw	ra,24(sp)
8113320c:	dc400517 	ldw	r17,20(sp)
81133210:	dc000417 	ldw	r16,16(sp)
81133214:	dec00704 	addi	sp,sp,28
81133218:	f800283a 	ret

8113321c <__udivdi3>:
8113321c:	defff504 	addi	sp,sp,-44
81133220:	de00012e 	bgeu	sp,et,81133228 <__udivdi3+0xc>
81133224:	003b68fa 	trap	3
81133228:	dcc00415 	stw	r19,16(sp)
8113322c:	dc000115 	stw	r16,4(sp)
81133230:	dfc00a15 	stw	ra,40(sp)
81133234:	df000915 	stw	fp,36(sp)
81133238:	ddc00815 	stw	r23,32(sp)
8113323c:	dd800715 	stw	r22,28(sp)
81133240:	dd400615 	stw	r21,24(sp)
81133244:	dd000515 	stw	r20,20(sp)
81133248:	dc800315 	stw	r18,12(sp)
8113324c:	dc400215 	stw	r17,8(sp)
81133250:	2027883a 	mov	r19,r4
81133254:	2821883a 	mov	r16,r5
81133258:	3800411e 	bne	r7,zero,81133360 <__udivdi3+0x144>
8113325c:	3023883a 	mov	r17,r6
81133260:	2025883a 	mov	r18,r4
81133264:	2980522e 	bgeu	r5,r6,811333b0 <__udivdi3+0x194>
81133268:	00bfffd4 	movui	r2,65535
8113326c:	282d883a 	mov	r22,r5
81133270:	1180a836 	bltu	r2,r6,81133514 <__udivdi3+0x2f8>
81133274:	00803fc4 	movi	r2,255
81133278:	1185803a 	cmpltu	r2,r2,r6
8113327c:	100490fa 	slli	r2,r2,3
81133280:	3086d83a 	srl	r3,r6,r2
81133284:	01204574 	movhi	r4,33045
81133288:	213dae04 	addi	r4,r4,-2376
8113328c:	20c7883a 	add	r3,r4,r3
81133290:	18c00003 	ldbu	r3,0(r3)
81133294:	1885883a 	add	r2,r3,r2
81133298:	00c00804 	movi	r3,32
8113329c:	1887c83a 	sub	r3,r3,r2
811332a0:	18000526 	beq	r3,zero,811332b8 <__udivdi3+0x9c>
811332a4:	80e0983a 	sll	r16,r16,r3
811332a8:	9884d83a 	srl	r2,r19,r2
811332ac:	30e2983a 	sll	r17,r6,r3
811332b0:	98e4983a 	sll	r18,r19,r3
811332b4:	142cb03a 	or	r22,r2,r16
811332b8:	882ad43a 	srli	r21,r17,16
811332bc:	b009883a 	mov	r4,r22
811332c0:	8d3fffcc 	andi	r20,r17,65535
811332c4:	a80b883a 	mov	r5,r21
811332c8:	1133e380 	call	81133e38 <__umodsi3>
811332cc:	b009883a 	mov	r4,r22
811332d0:	a80b883a 	mov	r5,r21
811332d4:	1027883a 	mov	r19,r2
811332d8:	1133dd40 	call	81133dd4 <__udivsi3>
811332dc:	102d883a 	mov	r22,r2
811332e0:	9826943a 	slli	r19,r19,16
811332e4:	9004d43a 	srli	r2,r18,16
811332e8:	a5a1383a 	mul	r16,r20,r22
811332ec:	14c4b03a 	or	r2,r2,r19
811332f0:	1400052e 	bgeu	r2,r16,81133308 <__udivdi3+0xec>
811332f4:	1445883a 	add	r2,r2,r17
811332f8:	b0ffffc4 	addi	r3,r22,-1
811332fc:	14400136 	bltu	r2,r17,81133304 <__udivdi3+0xe8>
81133300:	14012336 	bltu	r2,r16,81133790 <__udivdi3+0x574>
81133304:	182d883a 	mov	r22,r3
81133308:	1421c83a 	sub	r16,r2,r16
8113330c:	a80b883a 	mov	r5,r21
81133310:	8009883a 	mov	r4,r16
81133314:	1133e380 	call	81133e38 <__umodsi3>
81133318:	1027883a 	mov	r19,r2
8113331c:	a80b883a 	mov	r5,r21
81133320:	8009883a 	mov	r4,r16
81133324:	1133dd40 	call	81133dd4 <__udivsi3>
81133328:	9826943a 	slli	r19,r19,16
8113332c:	a0a9383a 	mul	r20,r20,r2
81133330:	94bfffcc 	andi	r18,r18,65535
81133334:	94e4b03a 	or	r18,r18,r19
81133338:	9500052e 	bgeu	r18,r20,81133350 <__udivdi3+0x134>
8113333c:	8ca5883a 	add	r18,r17,r18
81133340:	10ffffc4 	addi	r3,r2,-1
81133344:	9440f136 	bltu	r18,r17,8113370c <__udivdi3+0x4f0>
81133348:	9500f02e 	bgeu	r18,r20,8113370c <__udivdi3+0x4f0>
8113334c:	10bfff84 	addi	r2,r2,-2
81133350:	b00c943a 	slli	r6,r22,16
81133354:	0007883a 	mov	r3,zero
81133358:	3084b03a 	or	r2,r6,r2
8113335c:	00005906 	br	811334c4 <__udivdi3+0x2a8>
81133360:	29c05636 	bltu	r5,r7,811334bc <__udivdi3+0x2a0>
81133364:	00bfffd4 	movui	r2,65535
81133368:	11c0622e 	bgeu	r2,r7,811334f4 <__udivdi3+0x2d8>
8113336c:	00804034 	movhi	r2,256
81133370:	10bfffc4 	addi	r2,r2,-1
81133374:	11c0ee36 	bltu	r2,r7,81133730 <__udivdi3+0x514>
81133378:	00800404 	movi	r2,16
8113337c:	3886d83a 	srl	r3,r7,r2
81133380:	01204574 	movhi	r4,33045
81133384:	213dae04 	addi	r4,r4,-2376
81133388:	20c7883a 	add	r3,r4,r3
8113338c:	18c00003 	ldbu	r3,0(r3)
81133390:	05400804 	movi	r21,32
81133394:	1885883a 	add	r2,r3,r2
81133398:	a8abc83a 	sub	r21,r21,r2
8113339c:	a800621e 	bne	r21,zero,81133528 <__udivdi3+0x30c>
811333a0:	3c00e936 	bltu	r7,r16,81133748 <__udivdi3+0x52c>
811333a4:	9985403a 	cmpgeu	r2,r19,r6
811333a8:	0007883a 	mov	r3,zero
811333ac:	00004506 	br	811334c4 <__udivdi3+0x2a8>
811333b0:	3000041e 	bne	r6,zero,811333c4 <__udivdi3+0x1a8>
811333b4:	000b883a 	mov	r5,zero
811333b8:	01000044 	movi	r4,1
811333bc:	1133dd40 	call	81133dd4 <__udivsi3>
811333c0:	1023883a 	mov	r17,r2
811333c4:	00bfffd4 	movui	r2,65535
811333c8:	14404e2e 	bgeu	r2,r17,81133504 <__udivdi3+0x2e8>
811333cc:	00804034 	movhi	r2,256
811333d0:	10bfffc4 	addi	r2,r2,-1
811333d4:	1440d836 	bltu	r2,r17,81133738 <__udivdi3+0x51c>
811333d8:	00800404 	movi	r2,16
811333dc:	8886d83a 	srl	r3,r17,r2
811333e0:	01204574 	movhi	r4,33045
811333e4:	213dae04 	addi	r4,r4,-2376
811333e8:	20c7883a 	add	r3,r4,r3
811333ec:	18c00003 	ldbu	r3,0(r3)
811333f0:	1885883a 	add	r2,r3,r2
811333f4:	00c00804 	movi	r3,32
811333f8:	1887c83a 	sub	r3,r3,r2
811333fc:	18008f1e 	bne	r3,zero,8113363c <__udivdi3+0x420>
81133400:	882ad43a 	srli	r21,r17,16
81133404:	8461c83a 	sub	r16,r16,r17
81133408:	8d3fffcc 	andi	r20,r17,65535
8113340c:	00c00044 	movi	r3,1
81133410:	8009883a 	mov	r4,r16
81133414:	a80b883a 	mov	r5,r21
81133418:	d8c00015 	stw	r3,0(sp)
8113341c:	1133e380 	call	81133e38 <__umodsi3>
81133420:	8009883a 	mov	r4,r16
81133424:	a80b883a 	mov	r5,r21
81133428:	1027883a 	mov	r19,r2
8113342c:	1133dd40 	call	81133dd4 <__udivsi3>
81133430:	9826943a 	slli	r19,r19,16
81133434:	9008d43a 	srli	r4,r18,16
81133438:	1521383a 	mul	r16,r2,r20
8113343c:	102d883a 	mov	r22,r2
81133440:	24c8b03a 	or	r4,r4,r19
81133444:	d8c00017 	ldw	r3,0(sp)
81133448:	2400052e 	bgeu	r4,r16,81133460 <__udivdi3+0x244>
8113344c:	2449883a 	add	r4,r4,r17
81133450:	b0bfffc4 	addi	r2,r22,-1
81133454:	24400136 	bltu	r4,r17,8113345c <__udivdi3+0x240>
81133458:	2400ca36 	bltu	r4,r16,81133784 <__udivdi3+0x568>
8113345c:	102d883a 	mov	r22,r2
81133460:	2421c83a 	sub	r16,r4,r16
81133464:	a80b883a 	mov	r5,r21
81133468:	8009883a 	mov	r4,r16
8113346c:	d8c00015 	stw	r3,0(sp)
81133470:	1133e380 	call	81133e38 <__umodsi3>
81133474:	1027883a 	mov	r19,r2
81133478:	a80b883a 	mov	r5,r21
8113347c:	8009883a 	mov	r4,r16
81133480:	1133dd40 	call	81133dd4 <__udivsi3>
81133484:	9826943a 	slli	r19,r19,16
81133488:	1529383a 	mul	r20,r2,r20
8113348c:	94bfffcc 	andi	r18,r18,65535
81133490:	94e4b03a 	or	r18,r18,r19
81133494:	d8c00017 	ldw	r3,0(sp)
81133498:	9500052e 	bgeu	r18,r20,811334b0 <__udivdi3+0x294>
8113349c:	8ca5883a 	add	r18,r17,r18
811334a0:	113fffc4 	addi	r4,r2,-1
811334a4:	94409736 	bltu	r18,r17,81133704 <__udivdi3+0x4e8>
811334a8:	9500962e 	bgeu	r18,r20,81133704 <__udivdi3+0x4e8>
811334ac:	10bfff84 	addi	r2,r2,-2
811334b0:	b00c943a 	slli	r6,r22,16
811334b4:	3084b03a 	or	r2,r6,r2
811334b8:	00000206 	br	811334c4 <__udivdi3+0x2a8>
811334bc:	0007883a 	mov	r3,zero
811334c0:	0005883a 	mov	r2,zero
811334c4:	dfc00a17 	ldw	ra,40(sp)
811334c8:	df000917 	ldw	fp,36(sp)
811334cc:	ddc00817 	ldw	r23,32(sp)
811334d0:	dd800717 	ldw	r22,28(sp)
811334d4:	dd400617 	ldw	r21,24(sp)
811334d8:	dd000517 	ldw	r20,20(sp)
811334dc:	dcc00417 	ldw	r19,16(sp)
811334e0:	dc800317 	ldw	r18,12(sp)
811334e4:	dc400217 	ldw	r17,8(sp)
811334e8:	dc000117 	ldw	r16,4(sp)
811334ec:	dec00b04 	addi	sp,sp,44
811334f0:	f800283a 	ret
811334f4:	00803fc4 	movi	r2,255
811334f8:	11c5803a 	cmpltu	r2,r2,r7
811334fc:	100490fa 	slli	r2,r2,3
81133500:	003f9e06 	br	8113337c <__reset+0xfb11337c>
81133504:	00803fc4 	movi	r2,255
81133508:	1445803a 	cmpltu	r2,r2,r17
8113350c:	100490fa 	slli	r2,r2,3
81133510:	003fb206 	br	811333dc <__reset+0xfb1133dc>
81133514:	00804034 	movhi	r2,256
81133518:	10bfffc4 	addi	r2,r2,-1
8113351c:	11808836 	bltu	r2,r6,81133740 <__udivdi3+0x524>
81133520:	00800404 	movi	r2,16
81133524:	003f5606 	br	81133280 <__reset+0xfb113280>
81133528:	30aed83a 	srl	r23,r6,r2
8113352c:	3d4e983a 	sll	r7,r7,r21
81133530:	80acd83a 	srl	r22,r16,r2
81133534:	9884d83a 	srl	r2,r19,r2
81133538:	3deeb03a 	or	r23,r7,r23
8113353c:	b824d43a 	srli	r18,r23,16
81133540:	8560983a 	sll	r16,r16,r21
81133544:	b009883a 	mov	r4,r22
81133548:	900b883a 	mov	r5,r18
8113354c:	3568983a 	sll	r20,r6,r21
81133550:	1420b03a 	or	r16,r2,r16
81133554:	1133e380 	call	81133e38 <__umodsi3>
81133558:	b009883a 	mov	r4,r22
8113355c:	900b883a 	mov	r5,r18
81133560:	1023883a 	mov	r17,r2
81133564:	1133dd40 	call	81133dd4 <__udivsi3>
81133568:	8808943a 	slli	r4,r17,16
8113356c:	bf3fffcc 	andi	fp,r23,65535
81133570:	8006d43a 	srli	r3,r16,16
81133574:	e0a3383a 	mul	r17,fp,r2
81133578:	100d883a 	mov	r6,r2
8113357c:	1906b03a 	or	r3,r3,r4
81133580:	1c40042e 	bgeu	r3,r17,81133594 <__udivdi3+0x378>
81133584:	1dc7883a 	add	r3,r3,r23
81133588:	10bfffc4 	addi	r2,r2,-1
8113358c:	1dc0752e 	bgeu	r3,r23,81133764 <__udivdi3+0x548>
81133590:	100d883a 	mov	r6,r2
81133594:	1c63c83a 	sub	r17,r3,r17
81133598:	900b883a 	mov	r5,r18
8113359c:	8809883a 	mov	r4,r17
811335a0:	d9800015 	stw	r6,0(sp)
811335a4:	1133e380 	call	81133e38 <__umodsi3>
811335a8:	102d883a 	mov	r22,r2
811335ac:	8809883a 	mov	r4,r17
811335b0:	900b883a 	mov	r5,r18
811335b4:	1133dd40 	call	81133dd4 <__udivsi3>
811335b8:	b02c943a 	slli	r22,r22,16
811335bc:	e089383a 	mul	r4,fp,r2
811335c0:	843fffcc 	andi	r16,r16,65535
811335c4:	85a0b03a 	or	r16,r16,r22
811335c8:	d9800017 	ldw	r6,0(sp)
811335cc:	8100042e 	bgeu	r16,r4,811335e0 <__udivdi3+0x3c4>
811335d0:	85e1883a 	add	r16,r16,r23
811335d4:	10ffffc4 	addi	r3,r2,-1
811335d8:	85c05e2e 	bgeu	r16,r23,81133754 <__udivdi3+0x538>
811335dc:	1805883a 	mov	r2,r3
811335e0:	300c943a 	slli	r6,r6,16
811335e4:	a17fffcc 	andi	r5,r20,65535
811335e8:	a028d43a 	srli	r20,r20,16
811335ec:	3084b03a 	or	r2,r6,r2
811335f0:	10ffffcc 	andi	r3,r2,65535
811335f4:	100cd43a 	srli	r6,r2,16
811335f8:	194f383a 	mul	r7,r3,r5
811335fc:	1d07383a 	mul	r3,r3,r20
81133600:	314b383a 	mul	r5,r6,r5
81133604:	3810d43a 	srli	r8,r7,16
81133608:	8121c83a 	sub	r16,r16,r4
8113360c:	1947883a 	add	r3,r3,r5
81133610:	40c7883a 	add	r3,r8,r3
81133614:	350d383a 	mul	r6,r6,r20
81133618:	1940022e 	bgeu	r3,r5,81133624 <__udivdi3+0x408>
8113361c:	01000074 	movhi	r4,1
81133620:	310d883a 	add	r6,r6,r4
81133624:	1828d43a 	srli	r20,r3,16
81133628:	a18d883a 	add	r6,r20,r6
8113362c:	81803e36 	bltu	r16,r6,81133728 <__udivdi3+0x50c>
81133630:	81803826 	beq	r16,r6,81133714 <__udivdi3+0x4f8>
81133634:	0007883a 	mov	r3,zero
81133638:	003fa206 	br	811334c4 <__reset+0xfb1134c4>
8113363c:	88e2983a 	sll	r17,r17,r3
81133640:	80a8d83a 	srl	r20,r16,r2
81133644:	80e0983a 	sll	r16,r16,r3
81133648:	882ad43a 	srli	r21,r17,16
8113364c:	9884d83a 	srl	r2,r19,r2
81133650:	a009883a 	mov	r4,r20
81133654:	a80b883a 	mov	r5,r21
81133658:	142eb03a 	or	r23,r2,r16
8113365c:	98e4983a 	sll	r18,r19,r3
81133660:	1133e380 	call	81133e38 <__umodsi3>
81133664:	a009883a 	mov	r4,r20
81133668:	a80b883a 	mov	r5,r21
8113366c:	1021883a 	mov	r16,r2
81133670:	1133dd40 	call	81133dd4 <__udivsi3>
81133674:	1039883a 	mov	fp,r2
81133678:	8d3fffcc 	andi	r20,r17,65535
8113367c:	8020943a 	slli	r16,r16,16
81133680:	b804d43a 	srli	r2,r23,16
81133684:	a72d383a 	mul	r22,r20,fp
81133688:	1404b03a 	or	r2,r2,r16
8113368c:	1580062e 	bgeu	r2,r22,811336a8 <__udivdi3+0x48c>
81133690:	1445883a 	add	r2,r2,r17
81133694:	e0ffffc4 	addi	r3,fp,-1
81133698:	14403836 	bltu	r2,r17,8113377c <__udivdi3+0x560>
8113369c:	1580372e 	bgeu	r2,r22,8113377c <__udivdi3+0x560>
811336a0:	e73fff84 	addi	fp,fp,-2
811336a4:	1445883a 	add	r2,r2,r17
811336a8:	15adc83a 	sub	r22,r2,r22
811336ac:	a80b883a 	mov	r5,r21
811336b0:	b009883a 	mov	r4,r22
811336b4:	1133e380 	call	81133e38 <__umodsi3>
811336b8:	1027883a 	mov	r19,r2
811336bc:	b009883a 	mov	r4,r22
811336c0:	a80b883a 	mov	r5,r21
811336c4:	1133dd40 	call	81133dd4 <__udivsi3>
811336c8:	9826943a 	slli	r19,r19,16
811336cc:	a0a1383a 	mul	r16,r20,r2
811336d0:	b93fffcc 	andi	r4,r23,65535
811336d4:	24c8b03a 	or	r4,r4,r19
811336d8:	2400062e 	bgeu	r4,r16,811336f4 <__udivdi3+0x4d8>
811336dc:	2449883a 	add	r4,r4,r17
811336e0:	10ffffc4 	addi	r3,r2,-1
811336e4:	24402336 	bltu	r4,r17,81133774 <__udivdi3+0x558>
811336e8:	2400222e 	bgeu	r4,r16,81133774 <__udivdi3+0x558>
811336ec:	10bfff84 	addi	r2,r2,-2
811336f0:	2449883a 	add	r4,r4,r17
811336f4:	e038943a 	slli	fp,fp,16
811336f8:	2421c83a 	sub	r16,r4,r16
811336fc:	e086b03a 	or	r3,fp,r2
81133700:	003f4306 	br	81133410 <__reset+0xfb113410>
81133704:	2005883a 	mov	r2,r4
81133708:	003f6906 	br	811334b0 <__reset+0xfb1134b0>
8113370c:	1805883a 	mov	r2,r3
81133710:	003f0f06 	br	81133350 <__reset+0xfb113350>
81133714:	1806943a 	slli	r3,r3,16
81133718:	9d66983a 	sll	r19,r19,r21
8113371c:	39ffffcc 	andi	r7,r7,65535
81133720:	19c7883a 	add	r3,r3,r7
81133724:	98ffc32e 	bgeu	r19,r3,81133634 <__reset+0xfb113634>
81133728:	10bfffc4 	addi	r2,r2,-1
8113372c:	003fc106 	br	81133634 <__reset+0xfb113634>
81133730:	00800604 	movi	r2,24
81133734:	003f1106 	br	8113337c <__reset+0xfb11337c>
81133738:	00800604 	movi	r2,24
8113373c:	003f2706 	br	811333dc <__reset+0xfb1133dc>
81133740:	00800604 	movi	r2,24
81133744:	003ece06 	br	81133280 <__reset+0xfb113280>
81133748:	0007883a 	mov	r3,zero
8113374c:	00800044 	movi	r2,1
81133750:	003f5c06 	br	811334c4 <__reset+0xfb1134c4>
81133754:	813fa12e 	bgeu	r16,r4,811335dc <__reset+0xfb1135dc>
81133758:	10bfff84 	addi	r2,r2,-2
8113375c:	85e1883a 	add	r16,r16,r23
81133760:	003f9f06 	br	811335e0 <__reset+0xfb1135e0>
81133764:	1c7f8a2e 	bgeu	r3,r17,81133590 <__reset+0xfb113590>
81133768:	31bfff84 	addi	r6,r6,-2
8113376c:	1dc7883a 	add	r3,r3,r23
81133770:	003f8806 	br	81133594 <__reset+0xfb113594>
81133774:	1805883a 	mov	r2,r3
81133778:	003fde06 	br	811336f4 <__reset+0xfb1136f4>
8113377c:	1839883a 	mov	fp,r3
81133780:	003fc906 	br	811336a8 <__reset+0xfb1136a8>
81133784:	b5bfff84 	addi	r22,r22,-2
81133788:	2449883a 	add	r4,r4,r17
8113378c:	003f3406 	br	81133460 <__reset+0xfb113460>
81133790:	b5bfff84 	addi	r22,r22,-2
81133794:	1445883a 	add	r2,r2,r17
81133798:	003edb06 	br	81133308 <__reset+0xfb113308>

8113379c <__umoddi3>:
8113379c:	defff404 	addi	sp,sp,-48
811337a0:	de00012e 	bgeu	sp,et,811337a8 <__umoddi3+0xc>
811337a4:	003b68fa 	trap	3
811337a8:	df000a15 	stw	fp,40(sp)
811337ac:	dc400315 	stw	r17,12(sp)
811337b0:	dc000215 	stw	r16,8(sp)
811337b4:	dfc00b15 	stw	ra,44(sp)
811337b8:	ddc00915 	stw	r23,36(sp)
811337bc:	dd800815 	stw	r22,32(sp)
811337c0:	dd400715 	stw	r21,28(sp)
811337c4:	dd000615 	stw	r20,24(sp)
811337c8:	dcc00515 	stw	r19,20(sp)
811337cc:	dc800415 	stw	r18,16(sp)
811337d0:	2021883a 	mov	r16,r4
811337d4:	2823883a 	mov	r17,r5
811337d8:	2839883a 	mov	fp,r5
811337dc:	38003c1e 	bne	r7,zero,811338d0 <__umoddi3+0x134>
811337e0:	3027883a 	mov	r19,r6
811337e4:	2029883a 	mov	r20,r4
811337e8:	2980512e 	bgeu	r5,r6,81133930 <__umoddi3+0x194>
811337ec:	00bfffd4 	movui	r2,65535
811337f0:	11809a36 	bltu	r2,r6,81133a5c <__umoddi3+0x2c0>
811337f4:	01003fc4 	movi	r4,255
811337f8:	2189803a 	cmpltu	r4,r4,r6
811337fc:	200890fa 	slli	r4,r4,3
81133800:	3104d83a 	srl	r2,r6,r4
81133804:	00e04574 	movhi	r3,33045
81133808:	18fdae04 	addi	r3,r3,-2376
8113380c:	1885883a 	add	r2,r3,r2
81133810:	10c00003 	ldbu	r3,0(r2)
81133814:	00800804 	movi	r2,32
81133818:	1909883a 	add	r4,r3,r4
8113381c:	1125c83a 	sub	r18,r2,r4
81133820:	90000526 	beq	r18,zero,81133838 <__umoddi3+0x9c>
81133824:	8ca2983a 	sll	r17,r17,r18
81133828:	8108d83a 	srl	r4,r16,r4
8113382c:	34a6983a 	sll	r19,r6,r18
81133830:	84a8983a 	sll	r20,r16,r18
81133834:	2478b03a 	or	fp,r4,r17
81133838:	982ed43a 	srli	r23,r19,16
8113383c:	e009883a 	mov	r4,fp
81133840:	9dbfffcc 	andi	r22,r19,65535
81133844:	b80b883a 	mov	r5,r23
81133848:	1133e380 	call	81133e38 <__umodsi3>
8113384c:	e009883a 	mov	r4,fp
81133850:	b80b883a 	mov	r5,r23
81133854:	102b883a 	mov	r21,r2
81133858:	1133dd40 	call	81133dd4 <__udivsi3>
8113385c:	a806943a 	slli	r3,r21,16
81133860:	a008d43a 	srli	r4,r20,16
81133864:	b085383a 	mul	r2,r22,r2
81133868:	20c8b03a 	or	r4,r4,r3
8113386c:	2080032e 	bgeu	r4,r2,8113387c <__umoddi3+0xe0>
81133870:	24c9883a 	add	r4,r4,r19
81133874:	24c00136 	bltu	r4,r19,8113387c <__umoddi3+0xe0>
81133878:	20811036 	bltu	r4,r2,81133cbc <__umoddi3+0x520>
8113387c:	20abc83a 	sub	r21,r4,r2
81133880:	b80b883a 	mov	r5,r23
81133884:	a809883a 	mov	r4,r21
81133888:	1133e380 	call	81133e38 <__umodsi3>
8113388c:	1023883a 	mov	r17,r2
81133890:	b80b883a 	mov	r5,r23
81133894:	a809883a 	mov	r4,r21
81133898:	1133dd40 	call	81133dd4 <__udivsi3>
8113389c:	8822943a 	slli	r17,r17,16
811338a0:	b085383a 	mul	r2,r22,r2
811338a4:	a0ffffcc 	andi	r3,r20,65535
811338a8:	1c46b03a 	or	r3,r3,r17
811338ac:	1880042e 	bgeu	r3,r2,811338c0 <__umoddi3+0x124>
811338b0:	1cc7883a 	add	r3,r3,r19
811338b4:	1cc00236 	bltu	r3,r19,811338c0 <__umoddi3+0x124>
811338b8:	1880012e 	bgeu	r3,r2,811338c0 <__umoddi3+0x124>
811338bc:	1cc7883a 	add	r3,r3,r19
811338c0:	1885c83a 	sub	r2,r3,r2
811338c4:	1484d83a 	srl	r2,r2,r18
811338c8:	0007883a 	mov	r3,zero
811338cc:	00004f06 	br	81133a0c <__umoddi3+0x270>
811338d0:	29c04c36 	bltu	r5,r7,81133a04 <__umoddi3+0x268>
811338d4:	00bfffd4 	movui	r2,65535
811338d8:	11c0582e 	bgeu	r2,r7,81133a3c <__umoddi3+0x2a0>
811338dc:	00804034 	movhi	r2,256
811338e0:	10bfffc4 	addi	r2,r2,-1
811338e4:	11c0e736 	bltu	r2,r7,81133c84 <__umoddi3+0x4e8>
811338e8:	01000404 	movi	r4,16
811338ec:	3904d83a 	srl	r2,r7,r4
811338f0:	00e04574 	movhi	r3,33045
811338f4:	18fdae04 	addi	r3,r3,-2376
811338f8:	1885883a 	add	r2,r3,r2
811338fc:	14c00003 	ldbu	r19,0(r2)
81133900:	00c00804 	movi	r3,32
81133904:	9927883a 	add	r19,r19,r4
81133908:	1ce9c83a 	sub	r20,r3,r19
8113390c:	a000581e 	bne	r20,zero,81133a70 <__umoddi3+0x2d4>
81133910:	3c400136 	bltu	r7,r17,81133918 <__umoddi3+0x17c>
81133914:	8180eb36 	bltu	r16,r6,81133cc4 <__umoddi3+0x528>
81133918:	8185c83a 	sub	r2,r16,r6
8113391c:	89e3c83a 	sub	r17,r17,r7
81133920:	8089803a 	cmpltu	r4,r16,r2
81133924:	8939c83a 	sub	fp,r17,r4
81133928:	e007883a 	mov	r3,fp
8113392c:	00003706 	br	81133a0c <__umoddi3+0x270>
81133930:	3000041e 	bne	r6,zero,81133944 <__umoddi3+0x1a8>
81133934:	000b883a 	mov	r5,zero
81133938:	01000044 	movi	r4,1
8113393c:	1133dd40 	call	81133dd4 <__udivsi3>
81133940:	1027883a 	mov	r19,r2
81133944:	00bfffd4 	movui	r2,65535
81133948:	14c0402e 	bgeu	r2,r19,81133a4c <__umoddi3+0x2b0>
8113394c:	00804034 	movhi	r2,256
81133950:	10bfffc4 	addi	r2,r2,-1
81133954:	14c0cd36 	bltu	r2,r19,81133c8c <__umoddi3+0x4f0>
81133958:	00800404 	movi	r2,16
8113395c:	9886d83a 	srl	r3,r19,r2
81133960:	01204574 	movhi	r4,33045
81133964:	213dae04 	addi	r4,r4,-2376
81133968:	20c7883a 	add	r3,r4,r3
8113396c:	18c00003 	ldbu	r3,0(r3)
81133970:	1887883a 	add	r3,r3,r2
81133974:	00800804 	movi	r2,32
81133978:	10e5c83a 	sub	r18,r2,r3
8113397c:	9000901e 	bne	r18,zero,81133bc0 <__umoddi3+0x424>
81133980:	982cd43a 	srli	r22,r19,16
81133984:	8ce3c83a 	sub	r17,r17,r19
81133988:	9d7fffcc 	andi	r21,r19,65535
8113398c:	b00b883a 	mov	r5,r22
81133990:	8809883a 	mov	r4,r17
81133994:	1133e380 	call	81133e38 <__umodsi3>
81133998:	8809883a 	mov	r4,r17
8113399c:	b00b883a 	mov	r5,r22
811339a0:	1021883a 	mov	r16,r2
811339a4:	1133dd40 	call	81133dd4 <__udivsi3>
811339a8:	8006943a 	slli	r3,r16,16
811339ac:	a008d43a 	srli	r4,r20,16
811339b0:	1545383a 	mul	r2,r2,r21
811339b4:	20c8b03a 	or	r4,r4,r3
811339b8:	2080042e 	bgeu	r4,r2,811339cc <__umoddi3+0x230>
811339bc:	24c9883a 	add	r4,r4,r19
811339c0:	24c00236 	bltu	r4,r19,811339cc <__umoddi3+0x230>
811339c4:	2080012e 	bgeu	r4,r2,811339cc <__umoddi3+0x230>
811339c8:	24c9883a 	add	r4,r4,r19
811339cc:	20a1c83a 	sub	r16,r4,r2
811339d0:	b00b883a 	mov	r5,r22
811339d4:	8009883a 	mov	r4,r16
811339d8:	1133e380 	call	81133e38 <__umodsi3>
811339dc:	1023883a 	mov	r17,r2
811339e0:	b00b883a 	mov	r5,r22
811339e4:	8009883a 	mov	r4,r16
811339e8:	1133dd40 	call	81133dd4 <__udivsi3>
811339ec:	8822943a 	slli	r17,r17,16
811339f0:	1545383a 	mul	r2,r2,r21
811339f4:	a53fffcc 	andi	r20,r20,65535
811339f8:	a446b03a 	or	r3,r20,r17
811339fc:	18bfb02e 	bgeu	r3,r2,811338c0 <__reset+0xfb1138c0>
81133a00:	003fab06 	br	811338b0 <__reset+0xfb1138b0>
81133a04:	2005883a 	mov	r2,r4
81133a08:	2807883a 	mov	r3,r5
81133a0c:	dfc00b17 	ldw	ra,44(sp)
81133a10:	df000a17 	ldw	fp,40(sp)
81133a14:	ddc00917 	ldw	r23,36(sp)
81133a18:	dd800817 	ldw	r22,32(sp)
81133a1c:	dd400717 	ldw	r21,28(sp)
81133a20:	dd000617 	ldw	r20,24(sp)
81133a24:	dcc00517 	ldw	r19,20(sp)
81133a28:	dc800417 	ldw	r18,16(sp)
81133a2c:	dc400317 	ldw	r17,12(sp)
81133a30:	dc000217 	ldw	r16,8(sp)
81133a34:	dec00c04 	addi	sp,sp,48
81133a38:	f800283a 	ret
81133a3c:	04c03fc4 	movi	r19,255
81133a40:	99c9803a 	cmpltu	r4,r19,r7
81133a44:	200890fa 	slli	r4,r4,3
81133a48:	003fa806 	br	811338ec <__reset+0xfb1138ec>
81133a4c:	00803fc4 	movi	r2,255
81133a50:	14c5803a 	cmpltu	r2,r2,r19
81133a54:	100490fa 	slli	r2,r2,3
81133a58:	003fc006 	br	8113395c <__reset+0xfb11395c>
81133a5c:	00804034 	movhi	r2,256
81133a60:	10bfffc4 	addi	r2,r2,-1
81133a64:	11808b36 	bltu	r2,r6,81133c94 <__umoddi3+0x4f8>
81133a68:	01000404 	movi	r4,16
81133a6c:	003f6406 	br	81133800 <__reset+0xfb113800>
81133a70:	34c4d83a 	srl	r2,r6,r19
81133a74:	3d0e983a 	sll	r7,r7,r20
81133a78:	8cf8d83a 	srl	fp,r17,r19
81133a7c:	8d10983a 	sll	r8,r17,r20
81133a80:	38aab03a 	or	r21,r7,r2
81133a84:	a82cd43a 	srli	r22,r21,16
81133a88:	84e2d83a 	srl	r17,r16,r19
81133a8c:	e009883a 	mov	r4,fp
81133a90:	b00b883a 	mov	r5,r22
81133a94:	8a22b03a 	or	r17,r17,r8
81133a98:	3524983a 	sll	r18,r6,r20
81133a9c:	1133e380 	call	81133e38 <__umodsi3>
81133aa0:	e009883a 	mov	r4,fp
81133aa4:	b00b883a 	mov	r5,r22
81133aa8:	102f883a 	mov	r23,r2
81133aac:	1133dd40 	call	81133dd4 <__udivsi3>
81133ab0:	100d883a 	mov	r6,r2
81133ab4:	b808943a 	slli	r4,r23,16
81133ab8:	aa3fffcc 	andi	r8,r21,65535
81133abc:	8804d43a 	srli	r2,r17,16
81133ac0:	41af383a 	mul	r23,r8,r6
81133ac4:	8520983a 	sll	r16,r16,r20
81133ac8:	1104b03a 	or	r2,r2,r4
81133acc:	15c0042e 	bgeu	r2,r23,81133ae0 <__umoddi3+0x344>
81133ad0:	1545883a 	add	r2,r2,r21
81133ad4:	30ffffc4 	addi	r3,r6,-1
81133ad8:	1540742e 	bgeu	r2,r21,81133cac <__umoddi3+0x510>
81133adc:	180d883a 	mov	r6,r3
81133ae0:	15efc83a 	sub	r23,r2,r23
81133ae4:	b00b883a 	mov	r5,r22
81133ae8:	b809883a 	mov	r4,r23
81133aec:	d9800115 	stw	r6,4(sp)
81133af0:	da000015 	stw	r8,0(sp)
81133af4:	1133e380 	call	81133e38 <__umodsi3>
81133af8:	b00b883a 	mov	r5,r22
81133afc:	b809883a 	mov	r4,r23
81133b00:	1039883a 	mov	fp,r2
81133b04:	1133dd40 	call	81133dd4 <__udivsi3>
81133b08:	da000017 	ldw	r8,0(sp)
81133b0c:	e038943a 	slli	fp,fp,16
81133b10:	100b883a 	mov	r5,r2
81133b14:	4089383a 	mul	r4,r8,r2
81133b18:	8a3fffcc 	andi	r8,r17,65535
81133b1c:	4710b03a 	or	r8,r8,fp
81133b20:	d9800117 	ldw	r6,4(sp)
81133b24:	4100042e 	bgeu	r8,r4,81133b38 <__umoddi3+0x39c>
81133b28:	4551883a 	add	r8,r8,r21
81133b2c:	10bfffc4 	addi	r2,r2,-1
81133b30:	45405a2e 	bgeu	r8,r21,81133c9c <__umoddi3+0x500>
81133b34:	100b883a 	mov	r5,r2
81133b38:	300c943a 	slli	r6,r6,16
81133b3c:	91ffffcc 	andi	r7,r18,65535
81133b40:	9004d43a 	srli	r2,r18,16
81133b44:	314cb03a 	or	r6,r6,r5
81133b48:	317fffcc 	andi	r5,r6,65535
81133b4c:	300cd43a 	srli	r6,r6,16
81133b50:	29d3383a 	mul	r9,r5,r7
81133b54:	288b383a 	mul	r5,r5,r2
81133b58:	31cf383a 	mul	r7,r6,r7
81133b5c:	4806d43a 	srli	r3,r9,16
81133b60:	4111c83a 	sub	r8,r8,r4
81133b64:	29cb883a 	add	r5,r5,r7
81133b68:	194b883a 	add	r5,r3,r5
81133b6c:	3085383a 	mul	r2,r6,r2
81133b70:	29c0022e 	bgeu	r5,r7,81133b7c <__umoddi3+0x3e0>
81133b74:	00c00074 	movhi	r3,1
81133b78:	10c5883a 	add	r2,r2,r3
81133b7c:	2808d43a 	srli	r4,r5,16
81133b80:	280a943a 	slli	r5,r5,16
81133b84:	4a7fffcc 	andi	r9,r9,65535
81133b88:	2085883a 	add	r2,r4,r2
81133b8c:	2a4b883a 	add	r5,r5,r9
81133b90:	40803636 	bltu	r8,r2,81133c6c <__umoddi3+0x4d0>
81133b94:	40804d26 	beq	r8,r2,81133ccc <__umoddi3+0x530>
81133b98:	4089c83a 	sub	r4,r8,r2
81133b9c:	280f883a 	mov	r7,r5
81133ba0:	81cfc83a 	sub	r7,r16,r7
81133ba4:	81c7803a 	cmpltu	r3,r16,r7
81133ba8:	20c7c83a 	sub	r3,r4,r3
81133bac:	1cc4983a 	sll	r2,r3,r19
81133bb0:	3d0ed83a 	srl	r7,r7,r20
81133bb4:	1d06d83a 	srl	r3,r3,r20
81133bb8:	11c4b03a 	or	r2,r2,r7
81133bbc:	003f9306 	br	81133a0c <__reset+0xfb113a0c>
81133bc0:	9ca6983a 	sll	r19,r19,r18
81133bc4:	88e8d83a 	srl	r20,r17,r3
81133bc8:	80c4d83a 	srl	r2,r16,r3
81133bcc:	982cd43a 	srli	r22,r19,16
81133bd0:	8ca2983a 	sll	r17,r17,r18
81133bd4:	a009883a 	mov	r4,r20
81133bd8:	b00b883a 	mov	r5,r22
81133bdc:	1478b03a 	or	fp,r2,r17
81133be0:	1133e380 	call	81133e38 <__umodsi3>
81133be4:	a009883a 	mov	r4,r20
81133be8:	b00b883a 	mov	r5,r22
81133bec:	1023883a 	mov	r17,r2
81133bf0:	1133dd40 	call	81133dd4 <__udivsi3>
81133bf4:	9d7fffcc 	andi	r21,r19,65535
81133bf8:	880a943a 	slli	r5,r17,16
81133bfc:	e008d43a 	srli	r4,fp,16
81133c00:	a885383a 	mul	r2,r21,r2
81133c04:	84a8983a 	sll	r20,r16,r18
81133c08:	2148b03a 	or	r4,r4,r5
81133c0c:	2080042e 	bgeu	r4,r2,81133c20 <__umoddi3+0x484>
81133c10:	24c9883a 	add	r4,r4,r19
81133c14:	24c00236 	bltu	r4,r19,81133c20 <__umoddi3+0x484>
81133c18:	2080012e 	bgeu	r4,r2,81133c20 <__umoddi3+0x484>
81133c1c:	24c9883a 	add	r4,r4,r19
81133c20:	20a3c83a 	sub	r17,r4,r2
81133c24:	b00b883a 	mov	r5,r22
81133c28:	8809883a 	mov	r4,r17
81133c2c:	1133e380 	call	81133e38 <__umodsi3>
81133c30:	102f883a 	mov	r23,r2
81133c34:	8809883a 	mov	r4,r17
81133c38:	b00b883a 	mov	r5,r22
81133c3c:	1133dd40 	call	81133dd4 <__udivsi3>
81133c40:	b82e943a 	slli	r23,r23,16
81133c44:	a885383a 	mul	r2,r21,r2
81133c48:	e13fffcc 	andi	r4,fp,65535
81133c4c:	25c8b03a 	or	r4,r4,r23
81133c50:	2080042e 	bgeu	r4,r2,81133c64 <__umoddi3+0x4c8>
81133c54:	24c9883a 	add	r4,r4,r19
81133c58:	24c00236 	bltu	r4,r19,81133c64 <__umoddi3+0x4c8>
81133c5c:	2080012e 	bgeu	r4,r2,81133c64 <__umoddi3+0x4c8>
81133c60:	24c9883a 	add	r4,r4,r19
81133c64:	20a3c83a 	sub	r17,r4,r2
81133c68:	003f4806 	br	8113398c <__reset+0xfb11398c>
81133c6c:	2c8fc83a 	sub	r7,r5,r18
81133c70:	1545c83a 	sub	r2,r2,r21
81133c74:	29cb803a 	cmpltu	r5,r5,r7
81133c78:	1145c83a 	sub	r2,r2,r5
81133c7c:	4089c83a 	sub	r4,r8,r2
81133c80:	003fc706 	br	81133ba0 <__reset+0xfb113ba0>
81133c84:	01000604 	movi	r4,24
81133c88:	003f1806 	br	811338ec <__reset+0xfb1138ec>
81133c8c:	00800604 	movi	r2,24
81133c90:	003f3206 	br	8113395c <__reset+0xfb11395c>
81133c94:	01000604 	movi	r4,24
81133c98:	003ed906 	br	81133800 <__reset+0xfb113800>
81133c9c:	413fa52e 	bgeu	r8,r4,81133b34 <__reset+0xfb113b34>
81133ca0:	297fff84 	addi	r5,r5,-2
81133ca4:	4551883a 	add	r8,r8,r21
81133ca8:	003fa306 	br	81133b38 <__reset+0xfb113b38>
81133cac:	15ff8b2e 	bgeu	r2,r23,81133adc <__reset+0xfb113adc>
81133cb0:	31bfff84 	addi	r6,r6,-2
81133cb4:	1545883a 	add	r2,r2,r21
81133cb8:	003f8906 	br	81133ae0 <__reset+0xfb113ae0>
81133cbc:	24c9883a 	add	r4,r4,r19
81133cc0:	003eee06 	br	8113387c <__reset+0xfb11387c>
81133cc4:	8005883a 	mov	r2,r16
81133cc8:	003f1706 	br	81133928 <__reset+0xfb113928>
81133ccc:	817fe736 	bltu	r16,r5,81133c6c <__reset+0xfb113c6c>
81133cd0:	280f883a 	mov	r7,r5
81133cd4:	0009883a 	mov	r4,zero
81133cd8:	003fb106 	br	81133ba0 <__reset+0xfb113ba0>

81133cdc <__divsi3>:
81133cdc:	20001b16 	blt	r4,zero,81133d4c <__divsi3+0x70>
81133ce0:	000f883a 	mov	r7,zero
81133ce4:	28001616 	blt	r5,zero,81133d40 <__divsi3+0x64>
81133ce8:	200d883a 	mov	r6,r4
81133cec:	29001a2e 	bgeu	r5,r4,81133d58 <__divsi3+0x7c>
81133cf0:	00800804 	movi	r2,32
81133cf4:	00c00044 	movi	r3,1
81133cf8:	00000106 	br	81133d00 <__divsi3+0x24>
81133cfc:	10000d26 	beq	r2,zero,81133d34 <__divsi3+0x58>
81133d00:	294b883a 	add	r5,r5,r5
81133d04:	10bfffc4 	addi	r2,r2,-1
81133d08:	18c7883a 	add	r3,r3,r3
81133d0c:	293ffb36 	bltu	r5,r4,81133cfc <__reset+0xfb113cfc>
81133d10:	0005883a 	mov	r2,zero
81133d14:	18000726 	beq	r3,zero,81133d34 <__divsi3+0x58>
81133d18:	0005883a 	mov	r2,zero
81133d1c:	31400236 	bltu	r6,r5,81133d28 <__divsi3+0x4c>
81133d20:	314dc83a 	sub	r6,r6,r5
81133d24:	10c4b03a 	or	r2,r2,r3
81133d28:	1806d07a 	srli	r3,r3,1
81133d2c:	280ad07a 	srli	r5,r5,1
81133d30:	183ffa1e 	bne	r3,zero,81133d1c <__reset+0xfb113d1c>
81133d34:	38000126 	beq	r7,zero,81133d3c <__divsi3+0x60>
81133d38:	0085c83a 	sub	r2,zero,r2
81133d3c:	f800283a 	ret
81133d40:	014bc83a 	sub	r5,zero,r5
81133d44:	39c0005c 	xori	r7,r7,1
81133d48:	003fe706 	br	81133ce8 <__reset+0xfb113ce8>
81133d4c:	0109c83a 	sub	r4,zero,r4
81133d50:	01c00044 	movi	r7,1
81133d54:	003fe306 	br	81133ce4 <__reset+0xfb113ce4>
81133d58:	00c00044 	movi	r3,1
81133d5c:	003fee06 	br	81133d18 <__reset+0xfb113d18>

81133d60 <__modsi3>:
81133d60:	20001716 	blt	r4,zero,81133dc0 <__modsi3+0x60>
81133d64:	000f883a 	mov	r7,zero
81133d68:	2005883a 	mov	r2,r4
81133d6c:	28001216 	blt	r5,zero,81133db8 <__modsi3+0x58>
81133d70:	2900162e 	bgeu	r5,r4,81133dcc <__modsi3+0x6c>
81133d74:	01800804 	movi	r6,32
81133d78:	00c00044 	movi	r3,1
81133d7c:	00000106 	br	81133d84 <__modsi3+0x24>
81133d80:	30000a26 	beq	r6,zero,81133dac <__modsi3+0x4c>
81133d84:	294b883a 	add	r5,r5,r5
81133d88:	31bfffc4 	addi	r6,r6,-1
81133d8c:	18c7883a 	add	r3,r3,r3
81133d90:	293ffb36 	bltu	r5,r4,81133d80 <__reset+0xfb113d80>
81133d94:	18000526 	beq	r3,zero,81133dac <__modsi3+0x4c>
81133d98:	1806d07a 	srli	r3,r3,1
81133d9c:	11400136 	bltu	r2,r5,81133da4 <__modsi3+0x44>
81133da0:	1145c83a 	sub	r2,r2,r5
81133da4:	280ad07a 	srli	r5,r5,1
81133da8:	183ffb1e 	bne	r3,zero,81133d98 <__reset+0xfb113d98>
81133dac:	38000126 	beq	r7,zero,81133db4 <__modsi3+0x54>
81133db0:	0085c83a 	sub	r2,zero,r2
81133db4:	f800283a 	ret
81133db8:	014bc83a 	sub	r5,zero,r5
81133dbc:	003fec06 	br	81133d70 <__reset+0xfb113d70>
81133dc0:	0109c83a 	sub	r4,zero,r4
81133dc4:	01c00044 	movi	r7,1
81133dc8:	003fe706 	br	81133d68 <__reset+0xfb113d68>
81133dcc:	00c00044 	movi	r3,1
81133dd0:	003ff106 	br	81133d98 <__reset+0xfb113d98>

81133dd4 <__udivsi3>:
81133dd4:	200d883a 	mov	r6,r4
81133dd8:	2900152e 	bgeu	r5,r4,81133e30 <__udivsi3+0x5c>
81133ddc:	28001416 	blt	r5,zero,81133e30 <__udivsi3+0x5c>
81133de0:	00800804 	movi	r2,32
81133de4:	00c00044 	movi	r3,1
81133de8:	00000206 	br	81133df4 <__udivsi3+0x20>
81133dec:	10000e26 	beq	r2,zero,81133e28 <__udivsi3+0x54>
81133df0:	28000516 	blt	r5,zero,81133e08 <__udivsi3+0x34>
81133df4:	294b883a 	add	r5,r5,r5
81133df8:	10bfffc4 	addi	r2,r2,-1
81133dfc:	18c7883a 	add	r3,r3,r3
81133e00:	293ffa36 	bltu	r5,r4,81133dec <__reset+0xfb113dec>
81133e04:	18000826 	beq	r3,zero,81133e28 <__udivsi3+0x54>
81133e08:	0005883a 	mov	r2,zero
81133e0c:	31400236 	bltu	r6,r5,81133e18 <__udivsi3+0x44>
81133e10:	314dc83a 	sub	r6,r6,r5
81133e14:	10c4b03a 	or	r2,r2,r3
81133e18:	1806d07a 	srli	r3,r3,1
81133e1c:	280ad07a 	srli	r5,r5,1
81133e20:	183ffa1e 	bne	r3,zero,81133e0c <__reset+0xfb113e0c>
81133e24:	f800283a 	ret
81133e28:	0005883a 	mov	r2,zero
81133e2c:	f800283a 	ret
81133e30:	00c00044 	movi	r3,1
81133e34:	003ff406 	br	81133e08 <__reset+0xfb113e08>

81133e38 <__umodsi3>:
81133e38:	2005883a 	mov	r2,r4
81133e3c:	2900122e 	bgeu	r5,r4,81133e88 <__umodsi3+0x50>
81133e40:	28001116 	blt	r5,zero,81133e88 <__umodsi3+0x50>
81133e44:	01800804 	movi	r6,32
81133e48:	00c00044 	movi	r3,1
81133e4c:	00000206 	br	81133e58 <__umodsi3+0x20>
81133e50:	30000c26 	beq	r6,zero,81133e84 <__umodsi3+0x4c>
81133e54:	28000516 	blt	r5,zero,81133e6c <__umodsi3+0x34>
81133e58:	294b883a 	add	r5,r5,r5
81133e5c:	31bfffc4 	addi	r6,r6,-1
81133e60:	18c7883a 	add	r3,r3,r3
81133e64:	293ffa36 	bltu	r5,r4,81133e50 <__reset+0xfb113e50>
81133e68:	18000626 	beq	r3,zero,81133e84 <__umodsi3+0x4c>
81133e6c:	1806d07a 	srli	r3,r3,1
81133e70:	11400136 	bltu	r2,r5,81133e78 <__umodsi3+0x40>
81133e74:	1145c83a 	sub	r2,r2,r5
81133e78:	280ad07a 	srli	r5,r5,1
81133e7c:	183ffb1e 	bne	r3,zero,81133e6c <__reset+0xfb113e6c>
81133e80:	f800283a 	ret
81133e84:	f800283a 	ret
81133e88:	00c00044 	movi	r3,1
81133e8c:	003ff706 	br	81133e6c <__reset+0xfb113e6c>

81133e90 <__eqsf2>:
81133e90:	2006d5fa 	srli	r3,r4,23
81133e94:	280cd5fa 	srli	r6,r5,23
81133e98:	01c02034 	movhi	r7,128
81133e9c:	39ffffc4 	addi	r7,r7,-1
81133ea0:	18c03fcc 	andi	r3,r3,255
81133ea4:	02003fc4 	movi	r8,255
81133ea8:	3904703a 	and	r2,r7,r4
81133eac:	31803fcc 	andi	r6,r6,255
81133eb0:	394e703a 	and	r7,r7,r5
81133eb4:	2008d7fa 	srli	r4,r4,31
81133eb8:	280ad7fa 	srli	r5,r5,31
81133ebc:	1a000d26 	beq	r3,r8,81133ef4 <__eqsf2+0x64>
81133ec0:	02003fc4 	movi	r8,255
81133ec4:	32000826 	beq	r6,r8,81133ee8 <__eqsf2+0x58>
81133ec8:	19800226 	beq	r3,r6,81133ed4 <__eqsf2+0x44>
81133ecc:	00800044 	movi	r2,1
81133ed0:	f800283a 	ret
81133ed4:	11fffd1e 	bne	r2,r7,81133ecc <__reset+0xfb113ecc>
81133ed8:	21400926 	beq	r4,r5,81133f00 <__eqsf2+0x70>
81133edc:	183ffb1e 	bne	r3,zero,81133ecc <__reset+0xfb113ecc>
81133ee0:	1004c03a 	cmpne	r2,r2,zero
81133ee4:	f800283a 	ret
81133ee8:	383ff726 	beq	r7,zero,81133ec8 <__reset+0xfb113ec8>
81133eec:	00800044 	movi	r2,1
81133ef0:	f800283a 	ret
81133ef4:	103ff226 	beq	r2,zero,81133ec0 <__reset+0xfb113ec0>
81133ef8:	00800044 	movi	r2,1
81133efc:	f800283a 	ret
81133f00:	0005883a 	mov	r2,zero
81133f04:	f800283a 	ret

81133f08 <__gesf2>:
81133f08:	2004d5fa 	srli	r2,r4,23
81133f0c:	2806d5fa 	srli	r3,r5,23
81133f10:	01802034 	movhi	r6,128
81133f14:	31bfffc4 	addi	r6,r6,-1
81133f18:	10803fcc 	andi	r2,r2,255
81133f1c:	01c03fc4 	movi	r7,255
81133f20:	3110703a 	and	r8,r6,r4
81133f24:	18c03fcc 	andi	r3,r3,255
81133f28:	314c703a 	and	r6,r6,r5
81133f2c:	2008d7fa 	srli	r4,r4,31
81133f30:	280ad7fa 	srli	r5,r5,31
81133f34:	11c01926 	beq	r2,r7,81133f9c <__gesf2+0x94>
81133f38:	01c03fc4 	movi	r7,255
81133f3c:	19c00f26 	beq	r3,r7,81133f7c <__gesf2+0x74>
81133f40:	1000061e 	bne	r2,zero,81133f5c <__gesf2+0x54>
81133f44:	400f003a 	cmpeq	r7,r8,zero
81133f48:	1800071e 	bne	r3,zero,81133f68 <__gesf2+0x60>
81133f4c:	3000061e 	bne	r6,zero,81133f68 <__gesf2+0x60>
81133f50:	0005883a 	mov	r2,zero
81133f54:	40000e1e 	bne	r8,zero,81133f90 <__gesf2+0x88>
81133f58:	f800283a 	ret
81133f5c:	18000a1e 	bne	r3,zero,81133f88 <__gesf2+0x80>
81133f60:	30000b26 	beq	r6,zero,81133f90 <__gesf2+0x88>
81133f64:	000f883a 	mov	r7,zero
81133f68:	29403fcc 	andi	r5,r5,255
81133f6c:	38000726 	beq	r7,zero,81133f8c <__gesf2+0x84>
81133f70:	28000826 	beq	r5,zero,81133f94 <__gesf2+0x8c>
81133f74:	00800044 	movi	r2,1
81133f78:	f800283a 	ret
81133f7c:	303ff026 	beq	r6,zero,81133f40 <__reset+0xfb113f40>
81133f80:	00bfff84 	movi	r2,-2
81133f84:	f800283a 	ret
81133f88:	29403fcc 	andi	r5,r5,255
81133f8c:	21400526 	beq	r4,r5,81133fa4 <__gesf2+0x9c>
81133f90:	203ff826 	beq	r4,zero,81133f74 <__reset+0xfb113f74>
81133f94:	00bfffc4 	movi	r2,-1
81133f98:	f800283a 	ret
81133f9c:	403fe626 	beq	r8,zero,81133f38 <__reset+0xfb113f38>
81133fa0:	003ff706 	br	81133f80 <__reset+0xfb113f80>
81133fa4:	18bffa16 	blt	r3,r2,81133f90 <__reset+0xfb113f90>
81133fa8:	10c00216 	blt	r2,r3,81133fb4 <__gesf2+0xac>
81133fac:	323ff836 	bltu	r6,r8,81133f90 <__reset+0xfb113f90>
81133fb0:	4180022e 	bgeu	r8,r6,81133fbc <__gesf2+0xb4>
81133fb4:	203fef1e 	bne	r4,zero,81133f74 <__reset+0xfb113f74>
81133fb8:	003ff606 	br	81133f94 <__reset+0xfb113f94>
81133fbc:	0005883a 	mov	r2,zero
81133fc0:	f800283a 	ret

81133fc4 <__lesf2>:
81133fc4:	2004d5fa 	srli	r2,r4,23
81133fc8:	280cd5fa 	srli	r6,r5,23
81133fcc:	00c02034 	movhi	r3,128
81133fd0:	18ffffc4 	addi	r3,r3,-1
81133fd4:	10803fcc 	andi	r2,r2,255
81133fd8:	01c03fc4 	movi	r7,255
81133fdc:	1910703a 	and	r8,r3,r4
81133fe0:	31803fcc 	andi	r6,r6,255
81133fe4:	1946703a 	and	r3,r3,r5
81133fe8:	2008d7fa 	srli	r4,r4,31
81133fec:	280ad7fa 	srli	r5,r5,31
81133ff0:	11c01b26 	beq	r2,r7,81134060 <__lesf2+0x9c>
81133ff4:	01c03fc4 	movi	r7,255
81133ff8:	31c01126 	beq	r6,r7,81134040 <__lesf2+0x7c>
81133ffc:	1000071e 	bne	r2,zero,8113401c <__lesf2+0x58>
81134000:	400f003a 	cmpeq	r7,r8,zero
81134004:	21003fcc 	andi	r4,r4,255
81134008:	3000081e 	bne	r6,zero,8113402c <__lesf2+0x68>
8113400c:	1800071e 	bne	r3,zero,8113402c <__lesf2+0x68>
81134010:	0005883a 	mov	r2,zero
81134014:	40000f1e 	bne	r8,zero,81134054 <__lesf2+0x90>
81134018:	f800283a 	ret
8113401c:	21003fcc 	andi	r4,r4,255
81134020:	30000a1e 	bne	r6,zero,8113404c <__lesf2+0x88>
81134024:	18000b26 	beq	r3,zero,81134054 <__lesf2+0x90>
81134028:	000f883a 	mov	r7,zero
8113402c:	29403fcc 	andi	r5,r5,255
81134030:	38000726 	beq	r7,zero,81134050 <__lesf2+0x8c>
81134034:	28000826 	beq	r5,zero,81134058 <__lesf2+0x94>
81134038:	00800044 	movi	r2,1
8113403c:	f800283a 	ret
81134040:	183fee26 	beq	r3,zero,81133ffc <__reset+0xfb113ffc>
81134044:	00800084 	movi	r2,2
81134048:	f800283a 	ret
8113404c:	29403fcc 	andi	r5,r5,255
81134050:	21400626 	beq	r4,r5,8113406c <__lesf2+0xa8>
81134054:	203ff826 	beq	r4,zero,81134038 <__reset+0xfb114038>
81134058:	00bfffc4 	movi	r2,-1
8113405c:	f800283a 	ret
81134060:	403fe426 	beq	r8,zero,81133ff4 <__reset+0xfb113ff4>
81134064:	00800084 	movi	r2,2
81134068:	f800283a 	ret
8113406c:	30bff916 	blt	r6,r2,81134054 <__reset+0xfb114054>
81134070:	11800216 	blt	r2,r6,8113407c <__lesf2+0xb8>
81134074:	1a3ff736 	bltu	r3,r8,81134054 <__reset+0xfb114054>
81134078:	40c0022e 	bgeu	r8,r3,81134084 <__lesf2+0xc0>
8113407c:	203fee1e 	bne	r4,zero,81134038 <__reset+0xfb114038>
81134080:	003ff506 	br	81134058 <__reset+0xfb114058>
81134084:	0005883a 	mov	r2,zero
81134088:	f800283a 	ret

8113408c <__adddf3>:
8113408c:	02c00434 	movhi	r11,16
81134090:	5affffc4 	addi	r11,r11,-1
81134094:	2806d7fa 	srli	r3,r5,31
81134098:	2ad4703a 	and	r10,r5,r11
8113409c:	3ad2703a 	and	r9,r7,r11
811340a0:	3804d53a 	srli	r2,r7,20
811340a4:	3018d77a 	srli	r12,r6,29
811340a8:	280ad53a 	srli	r5,r5,20
811340ac:	501490fa 	slli	r10,r10,3
811340b0:	2010d77a 	srli	r8,r4,29
811340b4:	481290fa 	slli	r9,r9,3
811340b8:	380ed7fa 	srli	r7,r7,31
811340bc:	defffb04 	addi	sp,sp,-20
811340c0:	de00012e 	bgeu	sp,et,811340c8 <__adddf3+0x3c>
811340c4:	003b68fa 	trap	3
811340c8:	dc800215 	stw	r18,8(sp)
811340cc:	dc400115 	stw	r17,4(sp)
811340d0:	dc000015 	stw	r16,0(sp)
811340d4:	dfc00415 	stw	ra,16(sp)
811340d8:	dcc00315 	stw	r19,12(sp)
811340dc:	1c803fcc 	andi	r18,r3,255
811340e0:	2c01ffcc 	andi	r16,r5,2047
811340e4:	5210b03a 	or	r8,r10,r8
811340e8:	202290fa 	slli	r17,r4,3
811340ec:	1081ffcc 	andi	r2,r2,2047
811340f0:	4b12b03a 	or	r9,r9,r12
811340f4:	300c90fa 	slli	r6,r6,3
811340f8:	91c07526 	beq	r18,r7,811342d0 <__adddf3+0x244>
811340fc:	8087c83a 	sub	r3,r16,r2
81134100:	00c0ab0e 	bge	zero,r3,811343b0 <__adddf3+0x324>
81134104:	10002a1e 	bne	r2,zero,811341b0 <__adddf3+0x124>
81134108:	4984b03a 	or	r2,r9,r6
8113410c:	1000961e 	bne	r2,zero,81134368 <__adddf3+0x2dc>
81134110:	888001cc 	andi	r2,r17,7
81134114:	10000726 	beq	r2,zero,81134134 <__adddf3+0xa8>
81134118:	888003cc 	andi	r2,r17,15
8113411c:	00c00104 	movi	r3,4
81134120:	10c00426 	beq	r2,r3,81134134 <__adddf3+0xa8>
81134124:	88c7883a 	add	r3,r17,r3
81134128:	1c63803a 	cmpltu	r17,r3,r17
8113412c:	4451883a 	add	r8,r8,r17
81134130:	1823883a 	mov	r17,r3
81134134:	4080202c 	andhi	r2,r8,128
81134138:	10005926 	beq	r2,zero,811342a0 <__adddf3+0x214>
8113413c:	84000044 	addi	r16,r16,1
81134140:	0081ffc4 	movi	r2,2047
81134144:	8080ba26 	beq	r16,r2,81134430 <__adddf3+0x3a4>
81134148:	00bfe034 	movhi	r2,65408
8113414c:	10bfffc4 	addi	r2,r2,-1
81134150:	4090703a 	and	r8,r8,r2
81134154:	4004977a 	slli	r2,r8,29
81134158:	4010927a 	slli	r8,r8,9
8113415c:	8822d0fa 	srli	r17,r17,3
81134160:	8401ffcc 	andi	r16,r16,2047
81134164:	4010d33a 	srli	r8,r8,12
81134168:	9007883a 	mov	r3,r18
8113416c:	1444b03a 	or	r2,r2,r17
81134170:	8401ffcc 	andi	r16,r16,2047
81134174:	8020953a 	slli	r16,r16,20
81134178:	18c03fcc 	andi	r3,r3,255
8113417c:	01000434 	movhi	r4,16
81134180:	213fffc4 	addi	r4,r4,-1
81134184:	180697fa 	slli	r3,r3,31
81134188:	4110703a 	and	r8,r8,r4
8113418c:	4410b03a 	or	r8,r8,r16
81134190:	40c6b03a 	or	r3,r8,r3
81134194:	dfc00417 	ldw	ra,16(sp)
81134198:	dcc00317 	ldw	r19,12(sp)
8113419c:	dc800217 	ldw	r18,8(sp)
811341a0:	dc400117 	ldw	r17,4(sp)
811341a4:	dc000017 	ldw	r16,0(sp)
811341a8:	dec00504 	addi	sp,sp,20
811341ac:	f800283a 	ret
811341b0:	0081ffc4 	movi	r2,2047
811341b4:	80bfd626 	beq	r16,r2,81134110 <__reset+0xfb114110>
811341b8:	4a402034 	orhi	r9,r9,128
811341bc:	00800e04 	movi	r2,56
811341c0:	10c09f16 	blt	r2,r3,81134440 <__adddf3+0x3b4>
811341c4:	008007c4 	movi	r2,31
811341c8:	10c0c216 	blt	r2,r3,811344d4 <__adddf3+0x448>
811341cc:	00800804 	movi	r2,32
811341d0:	10c5c83a 	sub	r2,r2,r3
811341d4:	488a983a 	sll	r5,r9,r2
811341d8:	30c8d83a 	srl	r4,r6,r3
811341dc:	3084983a 	sll	r2,r6,r2
811341e0:	48c6d83a 	srl	r3,r9,r3
811341e4:	290cb03a 	or	r6,r5,r4
811341e8:	1004c03a 	cmpne	r2,r2,zero
811341ec:	308cb03a 	or	r6,r6,r2
811341f0:	898dc83a 	sub	r6,r17,r6
811341f4:	89a3803a 	cmpltu	r17,r17,r6
811341f8:	40d1c83a 	sub	r8,r8,r3
811341fc:	4451c83a 	sub	r8,r8,r17
81134200:	3023883a 	mov	r17,r6
81134204:	4080202c 	andhi	r2,r8,128
81134208:	10002326 	beq	r2,zero,81134298 <__adddf3+0x20c>
8113420c:	04c02034 	movhi	r19,128
81134210:	9cffffc4 	addi	r19,r19,-1
81134214:	44e6703a 	and	r19,r8,r19
81134218:	98007626 	beq	r19,zero,811343f4 <__adddf3+0x368>
8113421c:	9809883a 	mov	r4,r19
81134220:	11205f80 	call	811205f8 <__clzsi2>
81134224:	10fffe04 	addi	r3,r2,-8
81134228:	010007c4 	movi	r4,31
8113422c:	20c07716 	blt	r4,r3,8113440c <__adddf3+0x380>
81134230:	00800804 	movi	r2,32
81134234:	10c5c83a 	sub	r2,r2,r3
81134238:	8884d83a 	srl	r2,r17,r2
8113423c:	98d0983a 	sll	r8,r19,r3
81134240:	88e2983a 	sll	r17,r17,r3
81134244:	1204b03a 	or	r2,r2,r8
81134248:	1c007416 	blt	r3,r16,8113441c <__adddf3+0x390>
8113424c:	1c21c83a 	sub	r16,r3,r16
81134250:	82000044 	addi	r8,r16,1
81134254:	00c007c4 	movi	r3,31
81134258:	1a009116 	blt	r3,r8,811344a0 <__adddf3+0x414>
8113425c:	00c00804 	movi	r3,32
81134260:	1a07c83a 	sub	r3,r3,r8
81134264:	8a08d83a 	srl	r4,r17,r8
81134268:	88e2983a 	sll	r17,r17,r3
8113426c:	10c6983a 	sll	r3,r2,r3
81134270:	1210d83a 	srl	r8,r2,r8
81134274:	8804c03a 	cmpne	r2,r17,zero
81134278:	1906b03a 	or	r3,r3,r4
8113427c:	18a2b03a 	or	r17,r3,r2
81134280:	0021883a 	mov	r16,zero
81134284:	003fa206 	br	81134110 <__reset+0xfb114110>
81134288:	1890b03a 	or	r8,r3,r2
8113428c:	40017d26 	beq	r8,zero,81134884 <__adddf3+0x7f8>
81134290:	1011883a 	mov	r8,r2
81134294:	1823883a 	mov	r17,r3
81134298:	888001cc 	andi	r2,r17,7
8113429c:	103f9e1e 	bne	r2,zero,81134118 <__reset+0xfb114118>
811342a0:	4004977a 	slli	r2,r8,29
811342a4:	8822d0fa 	srli	r17,r17,3
811342a8:	4010d0fa 	srli	r8,r8,3
811342ac:	9007883a 	mov	r3,r18
811342b0:	1444b03a 	or	r2,r2,r17
811342b4:	0101ffc4 	movi	r4,2047
811342b8:	81002426 	beq	r16,r4,8113434c <__adddf3+0x2c0>
811342bc:	8120703a 	and	r16,r16,r4
811342c0:	01000434 	movhi	r4,16
811342c4:	213fffc4 	addi	r4,r4,-1
811342c8:	4110703a 	and	r8,r8,r4
811342cc:	003fa806 	br	81134170 <__reset+0xfb114170>
811342d0:	8089c83a 	sub	r4,r16,r2
811342d4:	01005e0e 	bge	zero,r4,81134450 <__adddf3+0x3c4>
811342d8:	10002b26 	beq	r2,zero,81134388 <__adddf3+0x2fc>
811342dc:	0081ffc4 	movi	r2,2047
811342e0:	80bf8b26 	beq	r16,r2,81134110 <__reset+0xfb114110>
811342e4:	4a402034 	orhi	r9,r9,128
811342e8:	00800e04 	movi	r2,56
811342ec:	1100a40e 	bge	r2,r4,81134580 <__adddf3+0x4f4>
811342f0:	498cb03a 	or	r6,r9,r6
811342f4:	300ac03a 	cmpne	r5,r6,zero
811342f8:	0013883a 	mov	r9,zero
811342fc:	2c4b883a 	add	r5,r5,r17
81134300:	2c63803a 	cmpltu	r17,r5,r17
81134304:	4a11883a 	add	r8,r9,r8
81134308:	8a11883a 	add	r8,r17,r8
8113430c:	2823883a 	mov	r17,r5
81134310:	4080202c 	andhi	r2,r8,128
81134314:	103fe026 	beq	r2,zero,81134298 <__reset+0xfb114298>
81134318:	84000044 	addi	r16,r16,1
8113431c:	0081ffc4 	movi	r2,2047
81134320:	8080d226 	beq	r16,r2,8113466c <__adddf3+0x5e0>
81134324:	00bfe034 	movhi	r2,65408
81134328:	10bfffc4 	addi	r2,r2,-1
8113432c:	4090703a 	and	r8,r8,r2
81134330:	880ad07a 	srli	r5,r17,1
81134334:	400897fa 	slli	r4,r8,31
81134338:	88c0004c 	andi	r3,r17,1
8113433c:	28e2b03a 	or	r17,r5,r3
81134340:	4010d07a 	srli	r8,r8,1
81134344:	2462b03a 	or	r17,r4,r17
81134348:	003f7106 	br	81134110 <__reset+0xfb114110>
8113434c:	4088b03a 	or	r4,r8,r2
81134350:	20014526 	beq	r4,zero,81134868 <__adddf3+0x7dc>
81134354:	01000434 	movhi	r4,16
81134358:	42000234 	orhi	r8,r8,8
8113435c:	213fffc4 	addi	r4,r4,-1
81134360:	4110703a 	and	r8,r8,r4
81134364:	003f8206 	br	81134170 <__reset+0xfb114170>
81134368:	18ffffc4 	addi	r3,r3,-1
8113436c:	1800491e 	bne	r3,zero,81134494 <__adddf3+0x408>
81134370:	898bc83a 	sub	r5,r17,r6
81134374:	8963803a 	cmpltu	r17,r17,r5
81134378:	4251c83a 	sub	r8,r8,r9
8113437c:	4451c83a 	sub	r8,r8,r17
81134380:	2823883a 	mov	r17,r5
81134384:	003f9f06 	br	81134204 <__reset+0xfb114204>
81134388:	4984b03a 	or	r2,r9,r6
8113438c:	103f6026 	beq	r2,zero,81134110 <__reset+0xfb114110>
81134390:	213fffc4 	addi	r4,r4,-1
81134394:	2000931e 	bne	r4,zero,811345e4 <__adddf3+0x558>
81134398:	898d883a 	add	r6,r17,r6
8113439c:	3463803a 	cmpltu	r17,r6,r17
811343a0:	4251883a 	add	r8,r8,r9
811343a4:	8a11883a 	add	r8,r17,r8
811343a8:	3023883a 	mov	r17,r6
811343ac:	003fd806 	br	81134310 <__reset+0xfb114310>
811343b0:	1800541e 	bne	r3,zero,81134504 <__adddf3+0x478>
811343b4:	80800044 	addi	r2,r16,1
811343b8:	1081ffcc 	andi	r2,r2,2047
811343bc:	00c00044 	movi	r3,1
811343c0:	1880a00e 	bge	r3,r2,81134644 <__adddf3+0x5b8>
811343c4:	8989c83a 	sub	r4,r17,r6
811343c8:	8905803a 	cmpltu	r2,r17,r4
811343cc:	4267c83a 	sub	r19,r8,r9
811343d0:	98a7c83a 	sub	r19,r19,r2
811343d4:	9880202c 	andhi	r2,r19,128
811343d8:	10006326 	beq	r2,zero,81134568 <__adddf3+0x4dc>
811343dc:	3463c83a 	sub	r17,r6,r17
811343e0:	4a07c83a 	sub	r3,r9,r8
811343e4:	344d803a 	cmpltu	r6,r6,r17
811343e8:	19a7c83a 	sub	r19,r3,r6
811343ec:	3825883a 	mov	r18,r7
811343f0:	983f8a1e 	bne	r19,zero,8113421c <__reset+0xfb11421c>
811343f4:	8809883a 	mov	r4,r17
811343f8:	11205f80 	call	811205f8 <__clzsi2>
811343fc:	10800804 	addi	r2,r2,32
81134400:	10fffe04 	addi	r3,r2,-8
81134404:	010007c4 	movi	r4,31
81134408:	20ff890e 	bge	r4,r3,81134230 <__reset+0xfb114230>
8113440c:	10bff604 	addi	r2,r2,-40
81134410:	8884983a 	sll	r2,r17,r2
81134414:	0023883a 	mov	r17,zero
81134418:	1c3f8c0e 	bge	r3,r16,8113424c <__reset+0xfb11424c>
8113441c:	023fe034 	movhi	r8,65408
81134420:	423fffc4 	addi	r8,r8,-1
81134424:	80e1c83a 	sub	r16,r16,r3
81134428:	1210703a 	and	r8,r2,r8
8113442c:	003f3806 	br	81134110 <__reset+0xfb114110>
81134430:	9007883a 	mov	r3,r18
81134434:	0011883a 	mov	r8,zero
81134438:	0005883a 	mov	r2,zero
8113443c:	003f4c06 	br	81134170 <__reset+0xfb114170>
81134440:	498cb03a 	or	r6,r9,r6
81134444:	300cc03a 	cmpne	r6,r6,zero
81134448:	0007883a 	mov	r3,zero
8113444c:	003f6806 	br	811341f0 <__reset+0xfb1141f0>
81134450:	20009c1e 	bne	r4,zero,811346c4 <__adddf3+0x638>
81134454:	80800044 	addi	r2,r16,1
81134458:	1141ffcc 	andi	r5,r2,2047
8113445c:	01000044 	movi	r4,1
81134460:	2140670e 	bge	r4,r5,81134600 <__adddf3+0x574>
81134464:	0101ffc4 	movi	r4,2047
81134468:	11007f26 	beq	r2,r4,81134668 <__adddf3+0x5dc>
8113446c:	898d883a 	add	r6,r17,r6
81134470:	4247883a 	add	r3,r8,r9
81134474:	3451803a 	cmpltu	r8,r6,r17
81134478:	40d1883a 	add	r8,r8,r3
8113447c:	402297fa 	slli	r17,r8,31
81134480:	300cd07a 	srli	r6,r6,1
81134484:	4010d07a 	srli	r8,r8,1
81134488:	1021883a 	mov	r16,r2
8113448c:	89a2b03a 	or	r17,r17,r6
81134490:	003f1f06 	br	81134110 <__reset+0xfb114110>
81134494:	0081ffc4 	movi	r2,2047
81134498:	80bf481e 	bne	r16,r2,811341bc <__reset+0xfb1141bc>
8113449c:	003f1c06 	br	81134110 <__reset+0xfb114110>
811344a0:	843ff844 	addi	r16,r16,-31
811344a4:	01000804 	movi	r4,32
811344a8:	1406d83a 	srl	r3,r2,r16
811344ac:	41005026 	beq	r8,r4,811345f0 <__adddf3+0x564>
811344b0:	01001004 	movi	r4,64
811344b4:	2211c83a 	sub	r8,r4,r8
811344b8:	1204983a 	sll	r2,r2,r8
811344bc:	88a2b03a 	or	r17,r17,r2
811344c0:	8822c03a 	cmpne	r17,r17,zero
811344c4:	1c62b03a 	or	r17,r3,r17
811344c8:	0011883a 	mov	r8,zero
811344cc:	0021883a 	mov	r16,zero
811344d0:	003f7106 	br	81134298 <__reset+0xfb114298>
811344d4:	193ff804 	addi	r4,r3,-32
811344d8:	00800804 	movi	r2,32
811344dc:	4908d83a 	srl	r4,r9,r4
811344e0:	18804526 	beq	r3,r2,811345f8 <__adddf3+0x56c>
811344e4:	00801004 	movi	r2,64
811344e8:	10c5c83a 	sub	r2,r2,r3
811344ec:	4886983a 	sll	r3,r9,r2
811344f0:	198cb03a 	or	r6,r3,r6
811344f4:	300cc03a 	cmpne	r6,r6,zero
811344f8:	218cb03a 	or	r6,r4,r6
811344fc:	0007883a 	mov	r3,zero
81134500:	003f3b06 	br	811341f0 <__reset+0xfb1141f0>
81134504:	80002a26 	beq	r16,zero,811345b0 <__adddf3+0x524>
81134508:	0101ffc4 	movi	r4,2047
8113450c:	11006826 	beq	r2,r4,811346b0 <__adddf3+0x624>
81134510:	00c7c83a 	sub	r3,zero,r3
81134514:	42002034 	orhi	r8,r8,128
81134518:	01000e04 	movi	r4,56
8113451c:	20c07c16 	blt	r4,r3,81134710 <__adddf3+0x684>
81134520:	010007c4 	movi	r4,31
81134524:	20c0da16 	blt	r4,r3,81134890 <__adddf3+0x804>
81134528:	01000804 	movi	r4,32
8113452c:	20c9c83a 	sub	r4,r4,r3
81134530:	4114983a 	sll	r10,r8,r4
81134534:	88cad83a 	srl	r5,r17,r3
81134538:	8908983a 	sll	r4,r17,r4
8113453c:	40c6d83a 	srl	r3,r8,r3
81134540:	5162b03a 	or	r17,r10,r5
81134544:	2008c03a 	cmpne	r4,r4,zero
81134548:	8922b03a 	or	r17,r17,r4
8113454c:	3463c83a 	sub	r17,r6,r17
81134550:	48c7c83a 	sub	r3,r9,r3
81134554:	344d803a 	cmpltu	r6,r6,r17
81134558:	1991c83a 	sub	r8,r3,r6
8113455c:	1021883a 	mov	r16,r2
81134560:	3825883a 	mov	r18,r7
81134564:	003f2706 	br	81134204 <__reset+0xfb114204>
81134568:	24d0b03a 	or	r8,r4,r19
8113456c:	40001b1e 	bne	r8,zero,811345dc <__adddf3+0x550>
81134570:	0005883a 	mov	r2,zero
81134574:	0007883a 	mov	r3,zero
81134578:	0021883a 	mov	r16,zero
8113457c:	003f4d06 	br	811342b4 <__reset+0xfb1142b4>
81134580:	008007c4 	movi	r2,31
81134584:	11003c16 	blt	r2,r4,81134678 <__adddf3+0x5ec>
81134588:	00800804 	movi	r2,32
8113458c:	1105c83a 	sub	r2,r2,r4
81134590:	488e983a 	sll	r7,r9,r2
81134594:	310ad83a 	srl	r5,r6,r4
81134598:	3084983a 	sll	r2,r6,r2
8113459c:	4912d83a 	srl	r9,r9,r4
811345a0:	394ab03a 	or	r5,r7,r5
811345a4:	1004c03a 	cmpne	r2,r2,zero
811345a8:	288ab03a 	or	r5,r5,r2
811345ac:	003f5306 	br	811342fc <__reset+0xfb1142fc>
811345b0:	4448b03a 	or	r4,r8,r17
811345b4:	20003e26 	beq	r4,zero,811346b0 <__adddf3+0x624>
811345b8:	00c6303a 	nor	r3,zero,r3
811345bc:	18003a1e 	bne	r3,zero,811346a8 <__adddf3+0x61c>
811345c0:	3463c83a 	sub	r17,r6,r17
811345c4:	4a07c83a 	sub	r3,r9,r8
811345c8:	344d803a 	cmpltu	r6,r6,r17
811345cc:	1991c83a 	sub	r8,r3,r6
811345d0:	1021883a 	mov	r16,r2
811345d4:	3825883a 	mov	r18,r7
811345d8:	003f0a06 	br	81134204 <__reset+0xfb114204>
811345dc:	2023883a 	mov	r17,r4
811345e0:	003f0d06 	br	81134218 <__reset+0xfb114218>
811345e4:	0081ffc4 	movi	r2,2047
811345e8:	80bf3f1e 	bne	r16,r2,811342e8 <__reset+0xfb1142e8>
811345ec:	003ec806 	br	81134110 <__reset+0xfb114110>
811345f0:	0005883a 	mov	r2,zero
811345f4:	003fb106 	br	811344bc <__reset+0xfb1144bc>
811345f8:	0007883a 	mov	r3,zero
811345fc:	003fbc06 	br	811344f0 <__reset+0xfb1144f0>
81134600:	4444b03a 	or	r2,r8,r17
81134604:	8000871e 	bne	r16,zero,81134824 <__adddf3+0x798>
81134608:	1000ba26 	beq	r2,zero,811348f4 <__adddf3+0x868>
8113460c:	4984b03a 	or	r2,r9,r6
81134610:	103ebf26 	beq	r2,zero,81134110 <__reset+0xfb114110>
81134614:	8985883a 	add	r2,r17,r6
81134618:	4247883a 	add	r3,r8,r9
8113461c:	1451803a 	cmpltu	r8,r2,r17
81134620:	40d1883a 	add	r8,r8,r3
81134624:	40c0202c 	andhi	r3,r8,128
81134628:	1023883a 	mov	r17,r2
8113462c:	183f1a26 	beq	r3,zero,81134298 <__reset+0xfb114298>
81134630:	00bfe034 	movhi	r2,65408
81134634:	10bfffc4 	addi	r2,r2,-1
81134638:	2021883a 	mov	r16,r4
8113463c:	4090703a 	and	r8,r8,r2
81134640:	003eb306 	br	81134110 <__reset+0xfb114110>
81134644:	4444b03a 	or	r2,r8,r17
81134648:	8000291e 	bne	r16,zero,811346f0 <__adddf3+0x664>
8113464c:	10004b1e 	bne	r2,zero,8113477c <__adddf3+0x6f0>
81134650:	4990b03a 	or	r8,r9,r6
81134654:	40008b26 	beq	r8,zero,81134884 <__adddf3+0x7f8>
81134658:	4811883a 	mov	r8,r9
8113465c:	3023883a 	mov	r17,r6
81134660:	3825883a 	mov	r18,r7
81134664:	003eaa06 	br	81134110 <__reset+0xfb114110>
81134668:	1021883a 	mov	r16,r2
8113466c:	0011883a 	mov	r8,zero
81134670:	0005883a 	mov	r2,zero
81134674:	003f0f06 	br	811342b4 <__reset+0xfb1142b4>
81134678:	217ff804 	addi	r5,r4,-32
8113467c:	00800804 	movi	r2,32
81134680:	494ad83a 	srl	r5,r9,r5
81134684:	20807d26 	beq	r4,r2,8113487c <__adddf3+0x7f0>
81134688:	00801004 	movi	r2,64
8113468c:	1109c83a 	sub	r4,r2,r4
81134690:	4912983a 	sll	r9,r9,r4
81134694:	498cb03a 	or	r6,r9,r6
81134698:	300cc03a 	cmpne	r6,r6,zero
8113469c:	298ab03a 	or	r5,r5,r6
811346a0:	0013883a 	mov	r9,zero
811346a4:	003f1506 	br	811342fc <__reset+0xfb1142fc>
811346a8:	0101ffc4 	movi	r4,2047
811346ac:	113f9a1e 	bne	r2,r4,81134518 <__reset+0xfb114518>
811346b0:	4811883a 	mov	r8,r9
811346b4:	3023883a 	mov	r17,r6
811346b8:	1021883a 	mov	r16,r2
811346bc:	3825883a 	mov	r18,r7
811346c0:	003e9306 	br	81134110 <__reset+0xfb114110>
811346c4:	8000161e 	bne	r16,zero,81134720 <__adddf3+0x694>
811346c8:	444ab03a 	or	r5,r8,r17
811346cc:	28005126 	beq	r5,zero,81134814 <__adddf3+0x788>
811346d0:	0108303a 	nor	r4,zero,r4
811346d4:	20004d1e 	bne	r4,zero,8113480c <__adddf3+0x780>
811346d8:	89a3883a 	add	r17,r17,r6
811346dc:	4253883a 	add	r9,r8,r9
811346e0:	898d803a 	cmpltu	r6,r17,r6
811346e4:	3251883a 	add	r8,r6,r9
811346e8:	1021883a 	mov	r16,r2
811346ec:	003f0806 	br	81134310 <__reset+0xfb114310>
811346f0:	1000301e 	bne	r2,zero,811347b4 <__adddf3+0x728>
811346f4:	4984b03a 	or	r2,r9,r6
811346f8:	10007126 	beq	r2,zero,811348c0 <__adddf3+0x834>
811346fc:	4811883a 	mov	r8,r9
81134700:	3023883a 	mov	r17,r6
81134704:	3825883a 	mov	r18,r7
81134708:	0401ffc4 	movi	r16,2047
8113470c:	003e8006 	br	81134110 <__reset+0xfb114110>
81134710:	4462b03a 	or	r17,r8,r17
81134714:	8822c03a 	cmpne	r17,r17,zero
81134718:	0007883a 	mov	r3,zero
8113471c:	003f8b06 	br	8113454c <__reset+0xfb11454c>
81134720:	0141ffc4 	movi	r5,2047
81134724:	11403b26 	beq	r2,r5,81134814 <__adddf3+0x788>
81134728:	0109c83a 	sub	r4,zero,r4
8113472c:	42002034 	orhi	r8,r8,128
81134730:	01400e04 	movi	r5,56
81134734:	29006716 	blt	r5,r4,811348d4 <__adddf3+0x848>
81134738:	014007c4 	movi	r5,31
8113473c:	29007016 	blt	r5,r4,81134900 <__adddf3+0x874>
81134740:	01400804 	movi	r5,32
81134744:	290bc83a 	sub	r5,r5,r4
81134748:	4154983a 	sll	r10,r8,r5
8113474c:	890ed83a 	srl	r7,r17,r4
81134750:	894a983a 	sll	r5,r17,r5
81134754:	4108d83a 	srl	r4,r8,r4
81134758:	51e2b03a 	or	r17,r10,r7
8113475c:	280ac03a 	cmpne	r5,r5,zero
81134760:	8962b03a 	or	r17,r17,r5
81134764:	89a3883a 	add	r17,r17,r6
81134768:	2253883a 	add	r9,r4,r9
8113476c:	898d803a 	cmpltu	r6,r17,r6
81134770:	3251883a 	add	r8,r6,r9
81134774:	1021883a 	mov	r16,r2
81134778:	003ee506 	br	81134310 <__reset+0xfb114310>
8113477c:	4984b03a 	or	r2,r9,r6
81134780:	103e6326 	beq	r2,zero,81134110 <__reset+0xfb114110>
81134784:	8987c83a 	sub	r3,r17,r6
81134788:	88c9803a 	cmpltu	r4,r17,r3
8113478c:	4245c83a 	sub	r2,r8,r9
81134790:	1105c83a 	sub	r2,r2,r4
81134794:	1100202c 	andhi	r4,r2,128
81134798:	203ebb26 	beq	r4,zero,81134288 <__reset+0xfb114288>
8113479c:	3463c83a 	sub	r17,r6,r17
811347a0:	4a07c83a 	sub	r3,r9,r8
811347a4:	344d803a 	cmpltu	r6,r6,r17
811347a8:	1991c83a 	sub	r8,r3,r6
811347ac:	3825883a 	mov	r18,r7
811347b0:	003e5706 	br	81134110 <__reset+0xfb114110>
811347b4:	4984b03a 	or	r2,r9,r6
811347b8:	10002e26 	beq	r2,zero,81134874 <__adddf3+0x7e8>
811347bc:	4004d0fa 	srli	r2,r8,3
811347c0:	8822d0fa 	srli	r17,r17,3
811347c4:	4010977a 	slli	r8,r8,29
811347c8:	10c0022c 	andhi	r3,r2,8
811347cc:	4462b03a 	or	r17,r8,r17
811347d0:	18000826 	beq	r3,zero,811347f4 <__adddf3+0x768>
811347d4:	4808d0fa 	srli	r4,r9,3
811347d8:	20c0022c 	andhi	r3,r4,8
811347dc:	1800051e 	bne	r3,zero,811347f4 <__adddf3+0x768>
811347e0:	300cd0fa 	srli	r6,r6,3
811347e4:	4806977a 	slli	r3,r9,29
811347e8:	2005883a 	mov	r2,r4
811347ec:	3825883a 	mov	r18,r7
811347f0:	19a2b03a 	or	r17,r3,r6
811347f4:	8810d77a 	srli	r8,r17,29
811347f8:	100490fa 	slli	r2,r2,3
811347fc:	882290fa 	slli	r17,r17,3
81134800:	0401ffc4 	movi	r16,2047
81134804:	4090b03a 	or	r8,r8,r2
81134808:	003e4106 	br	81134110 <__reset+0xfb114110>
8113480c:	0141ffc4 	movi	r5,2047
81134810:	117fc71e 	bne	r2,r5,81134730 <__reset+0xfb114730>
81134814:	4811883a 	mov	r8,r9
81134818:	3023883a 	mov	r17,r6
8113481c:	1021883a 	mov	r16,r2
81134820:	003e3b06 	br	81134110 <__reset+0xfb114110>
81134824:	10002f26 	beq	r2,zero,811348e4 <__adddf3+0x858>
81134828:	4984b03a 	or	r2,r9,r6
8113482c:	10001126 	beq	r2,zero,81134874 <__adddf3+0x7e8>
81134830:	4004d0fa 	srli	r2,r8,3
81134834:	8822d0fa 	srli	r17,r17,3
81134838:	4010977a 	slli	r8,r8,29
8113483c:	10c0022c 	andhi	r3,r2,8
81134840:	4462b03a 	or	r17,r8,r17
81134844:	183feb26 	beq	r3,zero,811347f4 <__reset+0xfb1147f4>
81134848:	4808d0fa 	srli	r4,r9,3
8113484c:	20c0022c 	andhi	r3,r4,8
81134850:	183fe81e 	bne	r3,zero,811347f4 <__reset+0xfb1147f4>
81134854:	300cd0fa 	srli	r6,r6,3
81134858:	4806977a 	slli	r3,r9,29
8113485c:	2005883a 	mov	r2,r4
81134860:	19a2b03a 	or	r17,r3,r6
81134864:	003fe306 	br	811347f4 <__reset+0xfb1147f4>
81134868:	0011883a 	mov	r8,zero
8113486c:	0005883a 	mov	r2,zero
81134870:	003e3f06 	br	81134170 <__reset+0xfb114170>
81134874:	0401ffc4 	movi	r16,2047
81134878:	003e2506 	br	81134110 <__reset+0xfb114110>
8113487c:	0013883a 	mov	r9,zero
81134880:	003f8406 	br	81134694 <__reset+0xfb114694>
81134884:	0005883a 	mov	r2,zero
81134888:	0007883a 	mov	r3,zero
8113488c:	003e8906 	br	811342b4 <__reset+0xfb1142b4>
81134890:	197ff804 	addi	r5,r3,-32
81134894:	01000804 	movi	r4,32
81134898:	414ad83a 	srl	r5,r8,r5
8113489c:	19002426 	beq	r3,r4,81134930 <__adddf3+0x8a4>
811348a0:	01001004 	movi	r4,64
811348a4:	20c7c83a 	sub	r3,r4,r3
811348a8:	40c6983a 	sll	r3,r8,r3
811348ac:	1c46b03a 	or	r3,r3,r17
811348b0:	1806c03a 	cmpne	r3,r3,zero
811348b4:	28e2b03a 	or	r17,r5,r3
811348b8:	0007883a 	mov	r3,zero
811348bc:	003f2306 	br	8113454c <__reset+0xfb11454c>
811348c0:	0007883a 	mov	r3,zero
811348c4:	5811883a 	mov	r8,r11
811348c8:	00bfffc4 	movi	r2,-1
811348cc:	0401ffc4 	movi	r16,2047
811348d0:	003e7806 	br	811342b4 <__reset+0xfb1142b4>
811348d4:	4462b03a 	or	r17,r8,r17
811348d8:	8822c03a 	cmpne	r17,r17,zero
811348dc:	0009883a 	mov	r4,zero
811348e0:	003fa006 	br	81134764 <__reset+0xfb114764>
811348e4:	4811883a 	mov	r8,r9
811348e8:	3023883a 	mov	r17,r6
811348ec:	0401ffc4 	movi	r16,2047
811348f0:	003e0706 	br	81134110 <__reset+0xfb114110>
811348f4:	4811883a 	mov	r8,r9
811348f8:	3023883a 	mov	r17,r6
811348fc:	003e0406 	br	81134110 <__reset+0xfb114110>
81134900:	21fff804 	addi	r7,r4,-32
81134904:	01400804 	movi	r5,32
81134908:	41ced83a 	srl	r7,r8,r7
8113490c:	21400a26 	beq	r4,r5,81134938 <__adddf3+0x8ac>
81134910:	01401004 	movi	r5,64
81134914:	2909c83a 	sub	r4,r5,r4
81134918:	4108983a 	sll	r4,r8,r4
8113491c:	2448b03a 	or	r4,r4,r17
81134920:	2008c03a 	cmpne	r4,r4,zero
81134924:	3922b03a 	or	r17,r7,r4
81134928:	0009883a 	mov	r4,zero
8113492c:	003f8d06 	br	81134764 <__reset+0xfb114764>
81134930:	0007883a 	mov	r3,zero
81134934:	003fdd06 	br	811348ac <__reset+0xfb1148ac>
81134938:	0009883a 	mov	r4,zero
8113493c:	003ff706 	br	8113491c <__reset+0xfb11491c>

81134940 <__divdf3>:
81134940:	defff204 	addi	sp,sp,-56
81134944:	de00012e 	bgeu	sp,et,8113494c <__divdf3+0xc>
81134948:	003b68fa 	trap	3
8113494c:	dd400915 	stw	r21,36(sp)
81134950:	282ad53a 	srli	r21,r5,20
81134954:	dd000815 	stw	r20,32(sp)
81134958:	2828d7fa 	srli	r20,r5,31
8113495c:	dc000415 	stw	r16,16(sp)
81134960:	04000434 	movhi	r16,16
81134964:	df000c15 	stw	fp,48(sp)
81134968:	843fffc4 	addi	r16,r16,-1
8113496c:	dfc00d15 	stw	ra,52(sp)
81134970:	ddc00b15 	stw	r23,44(sp)
81134974:	dd800a15 	stw	r22,40(sp)
81134978:	dcc00715 	stw	r19,28(sp)
8113497c:	dc800615 	stw	r18,24(sp)
81134980:	dc400515 	stw	r17,20(sp)
81134984:	ad41ffcc 	andi	r21,r21,2047
81134988:	2c20703a 	and	r16,r5,r16
8113498c:	a7003fcc 	andi	fp,r20,255
81134990:	a8006126 	beq	r21,zero,81134b18 <__divdf3+0x1d8>
81134994:	0081ffc4 	movi	r2,2047
81134998:	2025883a 	mov	r18,r4
8113499c:	a8803726 	beq	r21,r2,81134a7c <__divdf3+0x13c>
811349a0:	80800434 	orhi	r2,r16,16
811349a4:	100490fa 	slli	r2,r2,3
811349a8:	2020d77a 	srli	r16,r4,29
811349ac:	202490fa 	slli	r18,r4,3
811349b0:	ad7f0044 	addi	r21,r21,-1023
811349b4:	80a0b03a 	or	r16,r16,r2
811349b8:	0027883a 	mov	r19,zero
811349bc:	0013883a 	mov	r9,zero
811349c0:	3804d53a 	srli	r2,r7,20
811349c4:	382cd7fa 	srli	r22,r7,31
811349c8:	04400434 	movhi	r17,16
811349cc:	8c7fffc4 	addi	r17,r17,-1
811349d0:	1081ffcc 	andi	r2,r2,2047
811349d4:	3011883a 	mov	r8,r6
811349d8:	3c62703a 	and	r17,r7,r17
811349dc:	b5c03fcc 	andi	r23,r22,255
811349e0:	10006c26 	beq	r2,zero,81134b94 <__divdf3+0x254>
811349e4:	00c1ffc4 	movi	r3,2047
811349e8:	10c06426 	beq	r2,r3,81134b7c <__divdf3+0x23c>
811349ec:	88c00434 	orhi	r3,r17,16
811349f0:	180690fa 	slli	r3,r3,3
811349f4:	3022d77a 	srli	r17,r6,29
811349f8:	301090fa 	slli	r8,r6,3
811349fc:	10bf0044 	addi	r2,r2,-1023
81134a00:	88e2b03a 	or	r17,r17,r3
81134a04:	000f883a 	mov	r7,zero
81134a08:	a58cf03a 	xor	r6,r20,r22
81134a0c:	3cc8b03a 	or	r4,r7,r19
81134a10:	a8abc83a 	sub	r21,r21,r2
81134a14:	008003c4 	movi	r2,15
81134a18:	3007883a 	mov	r3,r6
81134a1c:	34c03fcc 	andi	r19,r6,255
81134a20:	11009036 	bltu	r2,r4,81134c64 <__divdf3+0x324>
81134a24:	200890ba 	slli	r4,r4,2
81134a28:	00a044f4 	movhi	r2,33043
81134a2c:	10928f04 	addi	r2,r2,19004
81134a30:	2089883a 	add	r4,r4,r2
81134a34:	20800017 	ldw	r2,0(r4)
81134a38:	1000683a 	jmp	r2
81134a3c:	81134c64 	muli	r4,r16,19761
81134a40:	81134ab4 	orhi	r4,r16,19754
81134a44:	81134c54 	ori	r4,r16,19761
81134a48:	81134aa8 	cmpgeui	r4,r16,19754
81134a4c:	81134c54 	ori	r4,r16,19761
81134a50:	81134c28 	cmpgeui	r4,r16,19760
81134a54:	81134c54 	ori	r4,r16,19761
81134a58:	81134aa8 	cmpgeui	r4,r16,19754
81134a5c:	81134ab4 	orhi	r4,r16,19754
81134a60:	81134ab4 	orhi	r4,r16,19754
81134a64:	81134c28 	cmpgeui	r4,r16,19760
81134a68:	81134aa8 	cmpgeui	r4,r16,19754
81134a6c:	81134a98 	cmpnei	r4,r16,19754
81134a70:	81134a98 	cmpnei	r4,r16,19754
81134a74:	81134a98 	cmpnei	r4,r16,19754
81134a78:	81134f48 	cmpgei	r4,r16,19773
81134a7c:	2404b03a 	or	r2,r4,r16
81134a80:	1000661e 	bne	r2,zero,81134c1c <__divdf3+0x2dc>
81134a84:	04c00204 	movi	r19,8
81134a88:	0021883a 	mov	r16,zero
81134a8c:	0025883a 	mov	r18,zero
81134a90:	02400084 	movi	r9,2
81134a94:	003fca06 	br	811349c0 <__reset+0xfb1149c0>
81134a98:	8023883a 	mov	r17,r16
81134a9c:	9011883a 	mov	r8,r18
81134aa0:	e02f883a 	mov	r23,fp
81134aa4:	480f883a 	mov	r7,r9
81134aa8:	00800084 	movi	r2,2
81134aac:	3881311e 	bne	r7,r2,81134f74 <__divdf3+0x634>
81134ab0:	b827883a 	mov	r19,r23
81134ab4:	98c0004c 	andi	r3,r19,1
81134ab8:	0081ffc4 	movi	r2,2047
81134abc:	000b883a 	mov	r5,zero
81134ac0:	0025883a 	mov	r18,zero
81134ac4:	1004953a 	slli	r2,r2,20
81134ac8:	18c03fcc 	andi	r3,r3,255
81134acc:	04400434 	movhi	r17,16
81134ad0:	8c7fffc4 	addi	r17,r17,-1
81134ad4:	180697fa 	slli	r3,r3,31
81134ad8:	2c4a703a 	and	r5,r5,r17
81134adc:	288ab03a 	or	r5,r5,r2
81134ae0:	28c6b03a 	or	r3,r5,r3
81134ae4:	9005883a 	mov	r2,r18
81134ae8:	dfc00d17 	ldw	ra,52(sp)
81134aec:	df000c17 	ldw	fp,48(sp)
81134af0:	ddc00b17 	ldw	r23,44(sp)
81134af4:	dd800a17 	ldw	r22,40(sp)
81134af8:	dd400917 	ldw	r21,36(sp)
81134afc:	dd000817 	ldw	r20,32(sp)
81134b00:	dcc00717 	ldw	r19,28(sp)
81134b04:	dc800617 	ldw	r18,24(sp)
81134b08:	dc400517 	ldw	r17,20(sp)
81134b0c:	dc000417 	ldw	r16,16(sp)
81134b10:	dec00e04 	addi	sp,sp,56
81134b14:	f800283a 	ret
81134b18:	2404b03a 	or	r2,r4,r16
81134b1c:	2027883a 	mov	r19,r4
81134b20:	10003926 	beq	r2,zero,81134c08 <__divdf3+0x2c8>
81134b24:	80012e26 	beq	r16,zero,81134fe0 <__divdf3+0x6a0>
81134b28:	8009883a 	mov	r4,r16
81134b2c:	d9800315 	stw	r6,12(sp)
81134b30:	d9c00215 	stw	r7,8(sp)
81134b34:	11205f80 	call	811205f8 <__clzsi2>
81134b38:	d9800317 	ldw	r6,12(sp)
81134b3c:	d9c00217 	ldw	r7,8(sp)
81134b40:	113ffd44 	addi	r4,r2,-11
81134b44:	00c00704 	movi	r3,28
81134b48:	19012116 	blt	r3,r4,81134fd0 <__divdf3+0x690>
81134b4c:	00c00744 	movi	r3,29
81134b50:	147ffe04 	addi	r17,r2,-8
81134b54:	1907c83a 	sub	r3,r3,r4
81134b58:	8460983a 	sll	r16,r16,r17
81134b5c:	98c6d83a 	srl	r3,r19,r3
81134b60:	9c64983a 	sll	r18,r19,r17
81134b64:	1c20b03a 	or	r16,r3,r16
81134b68:	1080fcc4 	addi	r2,r2,1011
81134b6c:	00abc83a 	sub	r21,zero,r2
81134b70:	0027883a 	mov	r19,zero
81134b74:	0013883a 	mov	r9,zero
81134b78:	003f9106 	br	811349c0 <__reset+0xfb1149c0>
81134b7c:	3446b03a 	or	r3,r6,r17
81134b80:	18001f1e 	bne	r3,zero,81134c00 <__divdf3+0x2c0>
81134b84:	0023883a 	mov	r17,zero
81134b88:	0011883a 	mov	r8,zero
81134b8c:	01c00084 	movi	r7,2
81134b90:	003f9d06 	br	81134a08 <__reset+0xfb114a08>
81134b94:	3446b03a 	or	r3,r6,r17
81134b98:	18001526 	beq	r3,zero,81134bf0 <__divdf3+0x2b0>
81134b9c:	88011b26 	beq	r17,zero,8113500c <__divdf3+0x6cc>
81134ba0:	8809883a 	mov	r4,r17
81134ba4:	d9800315 	stw	r6,12(sp)
81134ba8:	da400115 	stw	r9,4(sp)
81134bac:	11205f80 	call	811205f8 <__clzsi2>
81134bb0:	d9800317 	ldw	r6,12(sp)
81134bb4:	da400117 	ldw	r9,4(sp)
81134bb8:	113ffd44 	addi	r4,r2,-11
81134bbc:	00c00704 	movi	r3,28
81134bc0:	19010e16 	blt	r3,r4,81134ffc <__divdf3+0x6bc>
81134bc4:	00c00744 	movi	r3,29
81134bc8:	123ffe04 	addi	r8,r2,-8
81134bcc:	1907c83a 	sub	r3,r3,r4
81134bd0:	8a22983a 	sll	r17,r17,r8
81134bd4:	30c6d83a 	srl	r3,r6,r3
81134bd8:	3210983a 	sll	r8,r6,r8
81134bdc:	1c62b03a 	or	r17,r3,r17
81134be0:	1080fcc4 	addi	r2,r2,1011
81134be4:	0085c83a 	sub	r2,zero,r2
81134be8:	000f883a 	mov	r7,zero
81134bec:	003f8606 	br	81134a08 <__reset+0xfb114a08>
81134bf0:	0023883a 	mov	r17,zero
81134bf4:	0011883a 	mov	r8,zero
81134bf8:	01c00044 	movi	r7,1
81134bfc:	003f8206 	br	81134a08 <__reset+0xfb114a08>
81134c00:	01c000c4 	movi	r7,3
81134c04:	003f8006 	br	81134a08 <__reset+0xfb114a08>
81134c08:	04c00104 	movi	r19,4
81134c0c:	0021883a 	mov	r16,zero
81134c10:	0025883a 	mov	r18,zero
81134c14:	02400044 	movi	r9,1
81134c18:	003f6906 	br	811349c0 <__reset+0xfb1149c0>
81134c1c:	04c00304 	movi	r19,12
81134c20:	024000c4 	movi	r9,3
81134c24:	003f6606 	br	811349c0 <__reset+0xfb1149c0>
81134c28:	01400434 	movhi	r5,16
81134c2c:	0007883a 	mov	r3,zero
81134c30:	297fffc4 	addi	r5,r5,-1
81134c34:	04bfffc4 	movi	r18,-1
81134c38:	0081ffc4 	movi	r2,2047
81134c3c:	003fa106 	br	81134ac4 <__reset+0xfb114ac4>
81134c40:	00c00044 	movi	r3,1
81134c44:	1887c83a 	sub	r3,r3,r2
81134c48:	01000e04 	movi	r4,56
81134c4c:	20c1210e 	bge	r4,r3,811350d4 <__divdf3+0x794>
81134c50:	98c0004c 	andi	r3,r19,1
81134c54:	0005883a 	mov	r2,zero
81134c58:	000b883a 	mov	r5,zero
81134c5c:	0025883a 	mov	r18,zero
81134c60:	003f9806 	br	81134ac4 <__reset+0xfb114ac4>
81134c64:	8c00fd36 	bltu	r17,r16,8113505c <__divdf3+0x71c>
81134c68:	8440fb26 	beq	r16,r17,81135058 <__divdf3+0x718>
81134c6c:	8007883a 	mov	r3,r16
81134c70:	ad7fffc4 	addi	r21,r21,-1
81134c74:	0021883a 	mov	r16,zero
81134c78:	4004d63a 	srli	r2,r8,24
81134c7c:	8822923a 	slli	r17,r17,8
81134c80:	1809883a 	mov	r4,r3
81134c84:	402c923a 	slli	r22,r8,8
81134c88:	88b8b03a 	or	fp,r17,r2
81134c8c:	e028d43a 	srli	r20,fp,16
81134c90:	d8c00015 	stw	r3,0(sp)
81134c94:	e5ffffcc 	andi	r23,fp,65535
81134c98:	a00b883a 	mov	r5,r20
81134c9c:	1133dd40 	call	81133dd4 <__udivsi3>
81134ca0:	d8c00017 	ldw	r3,0(sp)
81134ca4:	a00b883a 	mov	r5,r20
81134ca8:	d8800315 	stw	r2,12(sp)
81134cac:	1809883a 	mov	r4,r3
81134cb0:	1133e380 	call	81133e38 <__umodsi3>
81134cb4:	d9800317 	ldw	r6,12(sp)
81134cb8:	1006943a 	slli	r3,r2,16
81134cbc:	9004d43a 	srli	r2,r18,16
81134cc0:	b9a3383a 	mul	r17,r23,r6
81134cc4:	10c4b03a 	or	r2,r2,r3
81134cc8:	1440062e 	bgeu	r2,r17,81134ce4 <__divdf3+0x3a4>
81134ccc:	1705883a 	add	r2,r2,fp
81134cd0:	30ffffc4 	addi	r3,r6,-1
81134cd4:	1700ee36 	bltu	r2,fp,81135090 <__divdf3+0x750>
81134cd8:	1440ed2e 	bgeu	r2,r17,81135090 <__divdf3+0x750>
81134cdc:	31bfff84 	addi	r6,r6,-2
81134ce0:	1705883a 	add	r2,r2,fp
81134ce4:	1463c83a 	sub	r17,r2,r17
81134ce8:	a00b883a 	mov	r5,r20
81134cec:	8809883a 	mov	r4,r17
81134cf0:	d9800315 	stw	r6,12(sp)
81134cf4:	1133dd40 	call	81133dd4 <__udivsi3>
81134cf8:	a00b883a 	mov	r5,r20
81134cfc:	8809883a 	mov	r4,r17
81134d00:	d8800215 	stw	r2,8(sp)
81134d04:	1133e380 	call	81133e38 <__umodsi3>
81134d08:	d9c00217 	ldw	r7,8(sp)
81134d0c:	1004943a 	slli	r2,r2,16
81134d10:	94bfffcc 	andi	r18,r18,65535
81134d14:	b9d1383a 	mul	r8,r23,r7
81134d18:	90a4b03a 	or	r18,r18,r2
81134d1c:	d9800317 	ldw	r6,12(sp)
81134d20:	9200062e 	bgeu	r18,r8,81134d3c <__divdf3+0x3fc>
81134d24:	9725883a 	add	r18,r18,fp
81134d28:	38bfffc4 	addi	r2,r7,-1
81134d2c:	9700d636 	bltu	r18,fp,81135088 <__divdf3+0x748>
81134d30:	9200d52e 	bgeu	r18,r8,81135088 <__divdf3+0x748>
81134d34:	39ffff84 	addi	r7,r7,-2
81134d38:	9725883a 	add	r18,r18,fp
81134d3c:	3004943a 	slli	r2,r6,16
81134d40:	b012d43a 	srli	r9,r22,16
81134d44:	b1bfffcc 	andi	r6,r22,65535
81134d48:	11e2b03a 	or	r17,r2,r7
81134d4c:	8806d43a 	srli	r3,r17,16
81134d50:	893fffcc 	andi	r4,r17,65535
81134d54:	218b383a 	mul	r5,r4,r6
81134d58:	30c5383a 	mul	r2,r6,r3
81134d5c:	2249383a 	mul	r4,r4,r9
81134d60:	280ed43a 	srli	r7,r5,16
81134d64:	9225c83a 	sub	r18,r18,r8
81134d68:	2089883a 	add	r4,r4,r2
81134d6c:	3909883a 	add	r4,r7,r4
81134d70:	1a47383a 	mul	r3,r3,r9
81134d74:	2080022e 	bgeu	r4,r2,81134d80 <__divdf3+0x440>
81134d78:	00800074 	movhi	r2,1
81134d7c:	1887883a 	add	r3,r3,r2
81134d80:	2004d43a 	srli	r2,r4,16
81134d84:	2008943a 	slli	r4,r4,16
81134d88:	297fffcc 	andi	r5,r5,65535
81134d8c:	10c7883a 	add	r3,r2,r3
81134d90:	2149883a 	add	r4,r4,r5
81134d94:	90c0a536 	bltu	r18,r3,8113502c <__divdf3+0x6ec>
81134d98:	90c0bf26 	beq	r18,r3,81135098 <__divdf3+0x758>
81134d9c:	90c7c83a 	sub	r3,r18,r3
81134da0:	810fc83a 	sub	r7,r16,r4
81134da4:	81e5803a 	cmpltu	r18,r16,r7
81134da8:	1ca5c83a 	sub	r18,r3,r18
81134dac:	e480c126 	beq	fp,r18,811350b4 <__divdf3+0x774>
81134db0:	a00b883a 	mov	r5,r20
81134db4:	9009883a 	mov	r4,r18
81134db8:	d9800315 	stw	r6,12(sp)
81134dbc:	d9c00215 	stw	r7,8(sp)
81134dc0:	da400115 	stw	r9,4(sp)
81134dc4:	1133dd40 	call	81133dd4 <__udivsi3>
81134dc8:	a00b883a 	mov	r5,r20
81134dcc:	9009883a 	mov	r4,r18
81134dd0:	d8800015 	stw	r2,0(sp)
81134dd4:	1133e380 	call	81133e38 <__umodsi3>
81134dd8:	d9c00217 	ldw	r7,8(sp)
81134ddc:	da000017 	ldw	r8,0(sp)
81134de0:	1006943a 	slli	r3,r2,16
81134de4:	3804d43a 	srli	r2,r7,16
81134de8:	ba21383a 	mul	r16,r23,r8
81134dec:	d9800317 	ldw	r6,12(sp)
81134df0:	10c4b03a 	or	r2,r2,r3
81134df4:	da400117 	ldw	r9,4(sp)
81134df8:	1400062e 	bgeu	r2,r16,81134e14 <__divdf3+0x4d4>
81134dfc:	1705883a 	add	r2,r2,fp
81134e00:	40ffffc4 	addi	r3,r8,-1
81134e04:	1700ad36 	bltu	r2,fp,811350bc <__divdf3+0x77c>
81134e08:	1400ac2e 	bgeu	r2,r16,811350bc <__divdf3+0x77c>
81134e0c:	423fff84 	addi	r8,r8,-2
81134e10:	1705883a 	add	r2,r2,fp
81134e14:	1421c83a 	sub	r16,r2,r16
81134e18:	a00b883a 	mov	r5,r20
81134e1c:	8009883a 	mov	r4,r16
81134e20:	d9800315 	stw	r6,12(sp)
81134e24:	d9c00215 	stw	r7,8(sp)
81134e28:	da000015 	stw	r8,0(sp)
81134e2c:	da400115 	stw	r9,4(sp)
81134e30:	1133dd40 	call	81133dd4 <__udivsi3>
81134e34:	8009883a 	mov	r4,r16
81134e38:	a00b883a 	mov	r5,r20
81134e3c:	1025883a 	mov	r18,r2
81134e40:	1133e380 	call	81133e38 <__umodsi3>
81134e44:	d9c00217 	ldw	r7,8(sp)
81134e48:	1004943a 	slli	r2,r2,16
81134e4c:	bcaf383a 	mul	r23,r23,r18
81134e50:	393fffcc 	andi	r4,r7,65535
81134e54:	2088b03a 	or	r4,r4,r2
81134e58:	d9800317 	ldw	r6,12(sp)
81134e5c:	da000017 	ldw	r8,0(sp)
81134e60:	da400117 	ldw	r9,4(sp)
81134e64:	25c0062e 	bgeu	r4,r23,81134e80 <__divdf3+0x540>
81134e68:	2709883a 	add	r4,r4,fp
81134e6c:	90bfffc4 	addi	r2,r18,-1
81134e70:	27009436 	bltu	r4,fp,811350c4 <__divdf3+0x784>
81134e74:	25c0932e 	bgeu	r4,r23,811350c4 <__divdf3+0x784>
81134e78:	94bfff84 	addi	r18,r18,-2
81134e7c:	2709883a 	add	r4,r4,fp
81134e80:	4004943a 	slli	r2,r8,16
81134e84:	25efc83a 	sub	r23,r4,r23
81134e88:	1490b03a 	or	r8,r2,r18
81134e8c:	4008d43a 	srli	r4,r8,16
81134e90:	40ffffcc 	andi	r3,r8,65535
81134e94:	30c5383a 	mul	r2,r6,r3
81134e98:	1a47383a 	mul	r3,r3,r9
81134e9c:	310d383a 	mul	r6,r6,r4
81134ea0:	100ad43a 	srli	r5,r2,16
81134ea4:	4913383a 	mul	r9,r9,r4
81134ea8:	1987883a 	add	r3,r3,r6
81134eac:	28c7883a 	add	r3,r5,r3
81134eb0:	1980022e 	bgeu	r3,r6,81134ebc <__divdf3+0x57c>
81134eb4:	01000074 	movhi	r4,1
81134eb8:	4913883a 	add	r9,r9,r4
81134ebc:	1808d43a 	srli	r4,r3,16
81134ec0:	1806943a 	slli	r3,r3,16
81134ec4:	10bfffcc 	andi	r2,r2,65535
81134ec8:	2253883a 	add	r9,r4,r9
81134ecc:	1887883a 	add	r3,r3,r2
81134ed0:	ba403836 	bltu	r23,r9,81134fb4 <__divdf3+0x674>
81134ed4:	ba403626 	beq	r23,r9,81134fb0 <__divdf3+0x670>
81134ed8:	42000054 	ori	r8,r8,1
81134edc:	a880ffc4 	addi	r2,r21,1023
81134ee0:	00bf570e 	bge	zero,r2,81134c40 <__reset+0xfb114c40>
81134ee4:	40c001cc 	andi	r3,r8,7
81134ee8:	18000726 	beq	r3,zero,81134f08 <__divdf3+0x5c8>
81134eec:	40c003cc 	andi	r3,r8,15
81134ef0:	01000104 	movi	r4,4
81134ef4:	19000426 	beq	r3,r4,81134f08 <__divdf3+0x5c8>
81134ef8:	4107883a 	add	r3,r8,r4
81134efc:	1a11803a 	cmpltu	r8,r3,r8
81134f00:	8a23883a 	add	r17,r17,r8
81134f04:	1811883a 	mov	r8,r3
81134f08:	88c0402c 	andhi	r3,r17,256
81134f0c:	18000426 	beq	r3,zero,81134f20 <__divdf3+0x5e0>
81134f10:	00ffc034 	movhi	r3,65280
81134f14:	18ffffc4 	addi	r3,r3,-1
81134f18:	a8810004 	addi	r2,r21,1024
81134f1c:	88e2703a 	and	r17,r17,r3
81134f20:	00c1ff84 	movi	r3,2046
81134f24:	18bee316 	blt	r3,r2,81134ab4 <__reset+0xfb114ab4>
81134f28:	8824977a 	slli	r18,r17,29
81134f2c:	4010d0fa 	srli	r8,r8,3
81134f30:	8822927a 	slli	r17,r17,9
81134f34:	1081ffcc 	andi	r2,r2,2047
81134f38:	9224b03a 	or	r18,r18,r8
81134f3c:	880ad33a 	srli	r5,r17,12
81134f40:	98c0004c 	andi	r3,r19,1
81134f44:	003edf06 	br	81134ac4 <__reset+0xfb114ac4>
81134f48:	8080022c 	andhi	r2,r16,8
81134f4c:	10001226 	beq	r2,zero,81134f98 <__divdf3+0x658>
81134f50:	8880022c 	andhi	r2,r17,8
81134f54:	1000101e 	bne	r2,zero,81134f98 <__divdf3+0x658>
81134f58:	00800434 	movhi	r2,16
81134f5c:	89400234 	orhi	r5,r17,8
81134f60:	10bfffc4 	addi	r2,r2,-1
81134f64:	b007883a 	mov	r3,r22
81134f68:	288a703a 	and	r5,r5,r2
81134f6c:	4025883a 	mov	r18,r8
81134f70:	003f3106 	br	81134c38 <__reset+0xfb114c38>
81134f74:	008000c4 	movi	r2,3
81134f78:	3880a626 	beq	r7,r2,81135214 <__divdf3+0x8d4>
81134f7c:	00800044 	movi	r2,1
81134f80:	3880521e 	bne	r7,r2,811350cc <__divdf3+0x78c>
81134f84:	b807883a 	mov	r3,r23
81134f88:	0005883a 	mov	r2,zero
81134f8c:	000b883a 	mov	r5,zero
81134f90:	0025883a 	mov	r18,zero
81134f94:	003ecb06 	br	81134ac4 <__reset+0xfb114ac4>
81134f98:	00800434 	movhi	r2,16
81134f9c:	81400234 	orhi	r5,r16,8
81134fa0:	10bfffc4 	addi	r2,r2,-1
81134fa4:	a007883a 	mov	r3,r20
81134fa8:	288a703a 	and	r5,r5,r2
81134fac:	003f2206 	br	81134c38 <__reset+0xfb114c38>
81134fb0:	183fca26 	beq	r3,zero,81134edc <__reset+0xfb114edc>
81134fb4:	e5ef883a 	add	r23,fp,r23
81134fb8:	40bfffc4 	addi	r2,r8,-1
81134fbc:	bf00392e 	bgeu	r23,fp,811350a4 <__divdf3+0x764>
81134fc0:	1011883a 	mov	r8,r2
81134fc4:	ba7fc41e 	bne	r23,r9,81134ed8 <__reset+0xfb114ed8>
81134fc8:	b0ffc31e 	bne	r22,r3,81134ed8 <__reset+0xfb114ed8>
81134fcc:	003fc306 	br	81134edc <__reset+0xfb114edc>
81134fd0:	143ff604 	addi	r16,r2,-40
81134fd4:	9c20983a 	sll	r16,r19,r16
81134fd8:	0025883a 	mov	r18,zero
81134fdc:	003ee206 	br	81134b68 <__reset+0xfb114b68>
81134fe0:	d9800315 	stw	r6,12(sp)
81134fe4:	d9c00215 	stw	r7,8(sp)
81134fe8:	11205f80 	call	811205f8 <__clzsi2>
81134fec:	10800804 	addi	r2,r2,32
81134ff0:	d9c00217 	ldw	r7,8(sp)
81134ff4:	d9800317 	ldw	r6,12(sp)
81134ff8:	003ed106 	br	81134b40 <__reset+0xfb114b40>
81134ffc:	147ff604 	addi	r17,r2,-40
81135000:	3462983a 	sll	r17,r6,r17
81135004:	0011883a 	mov	r8,zero
81135008:	003ef506 	br	81134be0 <__reset+0xfb114be0>
8113500c:	3009883a 	mov	r4,r6
81135010:	d9800315 	stw	r6,12(sp)
81135014:	da400115 	stw	r9,4(sp)
81135018:	11205f80 	call	811205f8 <__clzsi2>
8113501c:	10800804 	addi	r2,r2,32
81135020:	da400117 	ldw	r9,4(sp)
81135024:	d9800317 	ldw	r6,12(sp)
81135028:	003ee306 	br	81134bb8 <__reset+0xfb114bb8>
8113502c:	85a1883a 	add	r16,r16,r22
81135030:	8585803a 	cmpltu	r2,r16,r22
81135034:	1705883a 	add	r2,r2,fp
81135038:	14a5883a 	add	r18,r2,r18
8113503c:	88bfffc4 	addi	r2,r17,-1
81135040:	e4800c2e 	bgeu	fp,r18,81135074 <__divdf3+0x734>
81135044:	90c03e36 	bltu	r18,r3,81135140 <__divdf3+0x800>
81135048:	1c806926 	beq	r3,r18,811351f0 <__divdf3+0x8b0>
8113504c:	90c7c83a 	sub	r3,r18,r3
81135050:	1023883a 	mov	r17,r2
81135054:	003f5206 	br	81134da0 <__reset+0xfb114da0>
81135058:	923f0436 	bltu	r18,r8,81134c6c <__reset+0xfb114c6c>
8113505c:	800897fa 	slli	r4,r16,31
81135060:	9004d07a 	srli	r2,r18,1
81135064:	8006d07a 	srli	r3,r16,1
81135068:	902097fa 	slli	r16,r18,31
8113506c:	20a4b03a 	or	r18,r4,r2
81135070:	003f0106 	br	81134c78 <__reset+0xfb114c78>
81135074:	e4bff51e 	bne	fp,r18,8113504c <__reset+0xfb11504c>
81135078:	85bff22e 	bgeu	r16,r22,81135044 <__reset+0xfb115044>
8113507c:	e0c7c83a 	sub	r3,fp,r3
81135080:	1023883a 	mov	r17,r2
81135084:	003f4606 	br	81134da0 <__reset+0xfb114da0>
81135088:	100f883a 	mov	r7,r2
8113508c:	003f2b06 	br	81134d3c <__reset+0xfb114d3c>
81135090:	180d883a 	mov	r6,r3
81135094:	003f1306 	br	81134ce4 <__reset+0xfb114ce4>
81135098:	813fe436 	bltu	r16,r4,8113502c <__reset+0xfb11502c>
8113509c:	0007883a 	mov	r3,zero
811350a0:	003f3f06 	br	81134da0 <__reset+0xfb114da0>
811350a4:	ba402c36 	bltu	r23,r9,81135158 <__divdf3+0x818>
811350a8:	4dc05426 	beq	r9,r23,811351fc <__divdf3+0x8bc>
811350ac:	1011883a 	mov	r8,r2
811350b0:	003f8906 	br	81134ed8 <__reset+0xfb114ed8>
811350b4:	023fffc4 	movi	r8,-1
811350b8:	003f8806 	br	81134edc <__reset+0xfb114edc>
811350bc:	1811883a 	mov	r8,r3
811350c0:	003f5406 	br	81134e14 <__reset+0xfb114e14>
811350c4:	1025883a 	mov	r18,r2
811350c8:	003f6d06 	br	81134e80 <__reset+0xfb114e80>
811350cc:	b827883a 	mov	r19,r23
811350d0:	003f8206 	br	81134edc <__reset+0xfb114edc>
811350d4:	010007c4 	movi	r4,31
811350d8:	20c02616 	blt	r4,r3,81135174 <__divdf3+0x834>
811350dc:	00800804 	movi	r2,32
811350e0:	10c5c83a 	sub	r2,r2,r3
811350e4:	888a983a 	sll	r5,r17,r2
811350e8:	40c8d83a 	srl	r4,r8,r3
811350ec:	4084983a 	sll	r2,r8,r2
811350f0:	88e2d83a 	srl	r17,r17,r3
811350f4:	2906b03a 	or	r3,r5,r4
811350f8:	1004c03a 	cmpne	r2,r2,zero
811350fc:	1886b03a 	or	r3,r3,r2
81135100:	188001cc 	andi	r2,r3,7
81135104:	10000726 	beq	r2,zero,81135124 <__divdf3+0x7e4>
81135108:	188003cc 	andi	r2,r3,15
8113510c:	01000104 	movi	r4,4
81135110:	11000426 	beq	r2,r4,81135124 <__divdf3+0x7e4>
81135114:	1805883a 	mov	r2,r3
81135118:	10c00104 	addi	r3,r2,4
8113511c:	1885803a 	cmpltu	r2,r3,r2
81135120:	88a3883a 	add	r17,r17,r2
81135124:	8880202c 	andhi	r2,r17,128
81135128:	10002726 	beq	r2,zero,811351c8 <__divdf3+0x888>
8113512c:	98c0004c 	andi	r3,r19,1
81135130:	00800044 	movi	r2,1
81135134:	000b883a 	mov	r5,zero
81135138:	0025883a 	mov	r18,zero
8113513c:	003e6106 	br	81134ac4 <__reset+0xfb114ac4>
81135140:	85a1883a 	add	r16,r16,r22
81135144:	8585803a 	cmpltu	r2,r16,r22
81135148:	1705883a 	add	r2,r2,fp
8113514c:	14a5883a 	add	r18,r2,r18
81135150:	8c7fff84 	addi	r17,r17,-2
81135154:	003f1106 	br	81134d9c <__reset+0xfb114d9c>
81135158:	b589883a 	add	r4,r22,r22
8113515c:	25ad803a 	cmpltu	r22,r4,r22
81135160:	b739883a 	add	fp,r22,fp
81135164:	40bfff84 	addi	r2,r8,-2
81135168:	bf2f883a 	add	r23,r23,fp
8113516c:	202d883a 	mov	r22,r4
81135170:	003f9306 	br	81134fc0 <__reset+0xfb114fc0>
81135174:	013ff844 	movi	r4,-31
81135178:	2085c83a 	sub	r2,r4,r2
8113517c:	8888d83a 	srl	r4,r17,r2
81135180:	00800804 	movi	r2,32
81135184:	18802126 	beq	r3,r2,8113520c <__divdf3+0x8cc>
81135188:	00801004 	movi	r2,64
8113518c:	10c5c83a 	sub	r2,r2,r3
81135190:	8884983a 	sll	r2,r17,r2
81135194:	1204b03a 	or	r2,r2,r8
81135198:	1004c03a 	cmpne	r2,r2,zero
8113519c:	2084b03a 	or	r2,r4,r2
811351a0:	144001cc 	andi	r17,r2,7
811351a4:	88000d1e 	bne	r17,zero,811351dc <__divdf3+0x89c>
811351a8:	000b883a 	mov	r5,zero
811351ac:	1024d0fa 	srli	r18,r2,3
811351b0:	98c0004c 	andi	r3,r19,1
811351b4:	0005883a 	mov	r2,zero
811351b8:	9464b03a 	or	r18,r18,r17
811351bc:	003e4106 	br	81134ac4 <__reset+0xfb114ac4>
811351c0:	1007883a 	mov	r3,r2
811351c4:	0023883a 	mov	r17,zero
811351c8:	880a927a 	slli	r5,r17,9
811351cc:	1805883a 	mov	r2,r3
811351d0:	8822977a 	slli	r17,r17,29
811351d4:	280ad33a 	srli	r5,r5,12
811351d8:	003ff406 	br	811351ac <__reset+0xfb1151ac>
811351dc:	10c003cc 	andi	r3,r2,15
811351e0:	01000104 	movi	r4,4
811351e4:	193ff626 	beq	r3,r4,811351c0 <__reset+0xfb1151c0>
811351e8:	0023883a 	mov	r17,zero
811351ec:	003fca06 	br	81135118 <__reset+0xfb115118>
811351f0:	813fd336 	bltu	r16,r4,81135140 <__reset+0xfb115140>
811351f4:	1023883a 	mov	r17,r2
811351f8:	003fa806 	br	8113509c <__reset+0xfb11509c>
811351fc:	b0ffd636 	bltu	r22,r3,81135158 <__reset+0xfb115158>
81135200:	1011883a 	mov	r8,r2
81135204:	b0ff341e 	bne	r22,r3,81134ed8 <__reset+0xfb114ed8>
81135208:	003f3406 	br	81134edc <__reset+0xfb114edc>
8113520c:	0005883a 	mov	r2,zero
81135210:	003fe006 	br	81135194 <__reset+0xfb115194>
81135214:	00800434 	movhi	r2,16
81135218:	89400234 	orhi	r5,r17,8
8113521c:	10bfffc4 	addi	r2,r2,-1
81135220:	b807883a 	mov	r3,r23
81135224:	288a703a 	and	r5,r5,r2
81135228:	4025883a 	mov	r18,r8
8113522c:	003e8206 	br	81134c38 <__reset+0xfb114c38>

81135230 <__eqdf2>:
81135230:	2804d53a 	srli	r2,r5,20
81135234:	3806d53a 	srli	r3,r7,20
81135238:	02000434 	movhi	r8,16
8113523c:	423fffc4 	addi	r8,r8,-1
81135240:	1081ffcc 	andi	r2,r2,2047
81135244:	0281ffc4 	movi	r10,2047
81135248:	2a12703a 	and	r9,r5,r8
8113524c:	18c1ffcc 	andi	r3,r3,2047
81135250:	3a10703a 	and	r8,r7,r8
81135254:	280ad7fa 	srli	r5,r5,31
81135258:	380ed7fa 	srli	r7,r7,31
8113525c:	12801026 	beq	r2,r10,811352a0 <__eqdf2+0x70>
81135260:	0281ffc4 	movi	r10,2047
81135264:	1a800a26 	beq	r3,r10,81135290 <__eqdf2+0x60>
81135268:	10c00226 	beq	r2,r3,81135274 <__eqdf2+0x44>
8113526c:	00800044 	movi	r2,1
81135270:	f800283a 	ret
81135274:	4a3ffd1e 	bne	r9,r8,8113526c <__reset+0xfb11526c>
81135278:	21bffc1e 	bne	r4,r6,8113526c <__reset+0xfb11526c>
8113527c:	29c00c26 	beq	r5,r7,811352b0 <__eqdf2+0x80>
81135280:	103ffa1e 	bne	r2,zero,8113526c <__reset+0xfb11526c>
81135284:	2244b03a 	or	r2,r4,r9
81135288:	1004c03a 	cmpne	r2,r2,zero
8113528c:	f800283a 	ret
81135290:	3214b03a 	or	r10,r6,r8
81135294:	503ff426 	beq	r10,zero,81135268 <__reset+0xfb115268>
81135298:	00800044 	movi	r2,1
8113529c:	f800283a 	ret
811352a0:	2254b03a 	or	r10,r4,r9
811352a4:	503fee26 	beq	r10,zero,81135260 <__reset+0xfb115260>
811352a8:	00800044 	movi	r2,1
811352ac:	f800283a 	ret
811352b0:	0005883a 	mov	r2,zero
811352b4:	f800283a 	ret

811352b8 <__ledf2>:
811352b8:	2804d53a 	srli	r2,r5,20
811352bc:	3810d53a 	srli	r8,r7,20
811352c0:	00c00434 	movhi	r3,16
811352c4:	18ffffc4 	addi	r3,r3,-1
811352c8:	1081ffcc 	andi	r2,r2,2047
811352cc:	0241ffc4 	movi	r9,2047
811352d0:	28d4703a 	and	r10,r5,r3
811352d4:	4201ffcc 	andi	r8,r8,2047
811352d8:	38c6703a 	and	r3,r7,r3
811352dc:	280ad7fa 	srli	r5,r5,31
811352e0:	380ed7fa 	srli	r7,r7,31
811352e4:	12401f26 	beq	r2,r9,81135364 <__ledf2+0xac>
811352e8:	0241ffc4 	movi	r9,2047
811352ec:	42401426 	beq	r8,r9,81135340 <__ledf2+0x88>
811352f0:	1000091e 	bne	r2,zero,81135318 <__ledf2+0x60>
811352f4:	2296b03a 	or	r11,r4,r10
811352f8:	5813003a 	cmpeq	r9,r11,zero
811352fc:	29403fcc 	andi	r5,r5,255
81135300:	40000a1e 	bne	r8,zero,8113532c <__ledf2+0x74>
81135304:	30d8b03a 	or	r12,r6,r3
81135308:	6000081e 	bne	r12,zero,8113532c <__ledf2+0x74>
8113530c:	0005883a 	mov	r2,zero
81135310:	5800111e 	bne	r11,zero,81135358 <__ledf2+0xa0>
81135314:	f800283a 	ret
81135318:	29403fcc 	andi	r5,r5,255
8113531c:	40000c1e 	bne	r8,zero,81135350 <__ledf2+0x98>
81135320:	30d2b03a 	or	r9,r6,r3
81135324:	48000c26 	beq	r9,zero,81135358 <__ledf2+0xa0>
81135328:	0013883a 	mov	r9,zero
8113532c:	39c03fcc 	andi	r7,r7,255
81135330:	48000826 	beq	r9,zero,81135354 <__ledf2+0x9c>
81135334:	38001126 	beq	r7,zero,8113537c <__ledf2+0xc4>
81135338:	00800044 	movi	r2,1
8113533c:	f800283a 	ret
81135340:	30d2b03a 	or	r9,r6,r3
81135344:	483fea26 	beq	r9,zero,811352f0 <__reset+0xfb1152f0>
81135348:	00800084 	movi	r2,2
8113534c:	f800283a 	ret
81135350:	39c03fcc 	andi	r7,r7,255
81135354:	39400726 	beq	r7,r5,81135374 <__ledf2+0xbc>
81135358:	2800081e 	bne	r5,zero,8113537c <__ledf2+0xc4>
8113535c:	00800044 	movi	r2,1
81135360:	f800283a 	ret
81135364:	2292b03a 	or	r9,r4,r10
81135368:	483fdf26 	beq	r9,zero,811352e8 <__reset+0xfb1152e8>
8113536c:	00800084 	movi	r2,2
81135370:	f800283a 	ret
81135374:	4080030e 	bge	r8,r2,81135384 <__ledf2+0xcc>
81135378:	383fef26 	beq	r7,zero,81135338 <__reset+0xfb115338>
8113537c:	00bfffc4 	movi	r2,-1
81135380:	f800283a 	ret
81135384:	123feb16 	blt	r2,r8,81135334 <__reset+0xfb115334>
81135388:	1abff336 	bltu	r3,r10,81135358 <__reset+0xfb115358>
8113538c:	50c00326 	beq	r10,r3,8113539c <__ledf2+0xe4>
81135390:	50c0042e 	bgeu	r10,r3,811353a4 <__ledf2+0xec>
81135394:	283fe81e 	bne	r5,zero,81135338 <__reset+0xfb115338>
81135398:	003ff806 	br	8113537c <__reset+0xfb11537c>
8113539c:	313fee36 	bltu	r6,r4,81135358 <__reset+0xfb115358>
811353a0:	21bffc36 	bltu	r4,r6,81135394 <__reset+0xfb115394>
811353a4:	0005883a 	mov	r2,zero
811353a8:	f800283a 	ret

811353ac <__floatunsidf>:
811353ac:	defffe04 	addi	sp,sp,-8
811353b0:	de00012e 	bgeu	sp,et,811353b8 <__floatunsidf+0xc>
811353b4:	003b68fa 	trap	3
811353b8:	dc000015 	stw	r16,0(sp)
811353bc:	dfc00115 	stw	ra,4(sp)
811353c0:	2021883a 	mov	r16,r4
811353c4:	20002226 	beq	r4,zero,81135450 <__floatunsidf+0xa4>
811353c8:	11205f80 	call	811205f8 <__clzsi2>
811353cc:	01010784 	movi	r4,1054
811353d0:	2089c83a 	sub	r4,r4,r2
811353d4:	01810cc4 	movi	r6,1075
811353d8:	310dc83a 	sub	r6,r6,r4
811353dc:	00c007c4 	movi	r3,31
811353e0:	1980120e 	bge	r3,r6,8113542c <__floatunsidf+0x80>
811353e4:	00c104c4 	movi	r3,1043
811353e8:	1907c83a 	sub	r3,r3,r4
811353ec:	80ca983a 	sll	r5,r16,r3
811353f0:	00800434 	movhi	r2,16
811353f4:	10bfffc4 	addi	r2,r2,-1
811353f8:	2101ffcc 	andi	r4,r4,2047
811353fc:	0021883a 	mov	r16,zero
81135400:	288a703a 	and	r5,r5,r2
81135404:	2008953a 	slli	r4,r4,20
81135408:	00c00434 	movhi	r3,16
8113540c:	18ffffc4 	addi	r3,r3,-1
81135410:	28c6703a 	and	r3,r5,r3
81135414:	8005883a 	mov	r2,r16
81135418:	1906b03a 	or	r3,r3,r4
8113541c:	dfc00117 	ldw	ra,4(sp)
81135420:	dc000017 	ldw	r16,0(sp)
81135424:	dec00204 	addi	sp,sp,8
81135428:	f800283a 	ret
8113542c:	00c002c4 	movi	r3,11
81135430:	188bc83a 	sub	r5,r3,r2
81135434:	814ad83a 	srl	r5,r16,r5
81135438:	00c00434 	movhi	r3,16
8113543c:	18ffffc4 	addi	r3,r3,-1
81135440:	81a0983a 	sll	r16,r16,r6
81135444:	2101ffcc 	andi	r4,r4,2047
81135448:	28ca703a 	and	r5,r5,r3
8113544c:	003fed06 	br	81135404 <__reset+0xfb115404>
81135450:	0009883a 	mov	r4,zero
81135454:	000b883a 	mov	r5,zero
81135458:	003fea06 	br	81135404 <__reset+0xfb115404>

8113545c <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
8113545c:	defffb04 	addi	sp,sp,-20
81135460:	de00012e 	bgeu	sp,et,81135468 <alt_busy_sleep+0xc>
81135464:	003b68fa 	trap	3
81135468:	df000415 	stw	fp,16(sp)
8113546c:	df000404 	addi	fp,sp,16
81135470:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
81135474:	008000c4 	movi	r2,3
81135478:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
8113547c:	e0fffd17 	ldw	r3,-12(fp)
81135480:	008003f4 	movhi	r2,15
81135484:	10909004 	addi	r2,r2,16960
81135488:	1887383a 	mul	r3,r3,r2
8113548c:	00817db4 	movhi	r2,1526
81135490:	10b84004 	addi	r2,r2,-7936
81135494:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
81135498:	00a00034 	movhi	r2,32768
8113549c:	10bfffc4 	addi	r2,r2,-1
811354a0:	10c5203a 	divu	r2,r2,r3
811354a4:	e0ffff17 	ldw	r3,-4(fp)
811354a8:	1885203a 	divu	r2,r3,r2
811354ac:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
811354b0:	e0bffe17 	ldw	r2,-8(fp)
811354b4:	10002526 	beq	r2,zero,8113554c <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
811354b8:	e03ffc15 	stw	zero,-16(fp)
811354bc:	00001406 	br	81135510 <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
811354c0:	00a00034 	movhi	r2,32768
811354c4:	10bfffc4 	addi	r2,r2,-1
811354c8:	10bfffc4 	addi	r2,r2,-1
811354cc:	103ffe1e 	bne	r2,zero,811354c8 <__reset+0xfb1154c8>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
811354d0:	e0fffd17 	ldw	r3,-12(fp)
811354d4:	008003f4 	movhi	r2,15
811354d8:	10909004 	addi	r2,r2,16960
811354dc:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
811354e0:	00817db4 	movhi	r2,1526
811354e4:	10b84004 	addi	r2,r2,-7936
811354e8:	10c7203a 	divu	r3,r2,r3
811354ec:	00a00034 	movhi	r2,32768
811354f0:	10bfffc4 	addi	r2,r2,-1
811354f4:	10c5203a 	divu	r2,r2,r3
811354f8:	e0ffff17 	ldw	r3,-4(fp)
811354fc:	1885c83a 	sub	r2,r3,r2
81135500:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
81135504:	e0bffc17 	ldw	r2,-16(fp)
81135508:	10800044 	addi	r2,r2,1
8113550c:	e0bffc15 	stw	r2,-16(fp)
81135510:	e0fffc17 	ldw	r3,-16(fp)
81135514:	e0bffe17 	ldw	r2,-8(fp)
81135518:	18bfe916 	blt	r3,r2,811354c0 <__reset+0xfb1154c0>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
8113551c:	e0fffd17 	ldw	r3,-12(fp)
81135520:	008003f4 	movhi	r2,15
81135524:	10909004 	addi	r2,r2,16960
81135528:	1887383a 	mul	r3,r3,r2
8113552c:	00817db4 	movhi	r2,1526
81135530:	10b84004 	addi	r2,r2,-7936
81135534:	10c7203a 	divu	r3,r2,r3
81135538:	e0bfff17 	ldw	r2,-4(fp)
8113553c:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81135540:	10bfffc4 	addi	r2,r2,-1
81135544:	103ffe1e 	bne	r2,zero,81135540 <__reset+0xfb115540>
81135548:	00000b06 	br	81135578 <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
8113554c:	e0fffd17 	ldw	r3,-12(fp)
81135550:	008003f4 	movhi	r2,15
81135554:	10909004 	addi	r2,r2,16960
81135558:	1887383a 	mul	r3,r3,r2
8113555c:	00817db4 	movhi	r2,1526
81135560:	10b84004 	addi	r2,r2,-7936
81135564:	10c7203a 	divu	r3,r2,r3
81135568:	e0bfff17 	ldw	r2,-4(fp)
8113556c:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81135570:	10bfffc4 	addi	r2,r2,-1
81135574:	00bffe16 	blt	zero,r2,81135570 <__reset+0xfb115570>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
81135578:	0005883a 	mov	r2,zero
}
8113557c:	e037883a 	mov	sp,fp
81135580:	df000017 	ldw	fp,0(sp)
81135584:	dec00104 	addi	sp,sp,4
81135588:	f800283a 	ret

8113558c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113558c:	defffe04 	addi	sp,sp,-8
81135590:	de00012e 	bgeu	sp,et,81135598 <alt_get_errno+0xc>
81135594:	003b68fa 	trap	3
81135598:	dfc00115 	stw	ra,4(sp)
8113559c:	df000015 	stw	fp,0(sp)
811355a0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811355a4:	d0a01017 	ldw	r2,-32704(gp)
811355a8:	10000326 	beq	r2,zero,811355b8 <alt_get_errno+0x2c>
811355ac:	d0a01017 	ldw	r2,-32704(gp)
811355b0:	103ee83a 	callr	r2
811355b4:	00000106 	br	811355bc <alt_get_errno+0x30>
811355b8:	d0a07704 	addi	r2,gp,-32292
}
811355bc:	e037883a 	mov	sp,fp
811355c0:	dfc00117 	ldw	ra,4(sp)
811355c4:	df000017 	ldw	fp,0(sp)
811355c8:	dec00204 	addi	sp,sp,8
811355cc:	f800283a 	ret

811355d0 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
811355d0:	defffb04 	addi	sp,sp,-20
811355d4:	de00012e 	bgeu	sp,et,811355dc <close+0xc>
811355d8:	003b68fa 	trap	3
811355dc:	dfc00415 	stw	ra,16(sp)
811355e0:	df000315 	stw	fp,12(sp)
811355e4:	df000304 	addi	fp,sp,12
811355e8:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
811355ec:	e0bfff17 	ldw	r2,-4(fp)
811355f0:	10000616 	blt	r2,zero,8113560c <close+0x3c>
811355f4:	e0bfff17 	ldw	r2,-4(fp)
811355f8:	10c00324 	muli	r3,r2,12
811355fc:	00a04574 	movhi	r2,33045
81135600:	10835104 	addi	r2,r2,3396
81135604:	1885883a 	add	r2,r3,r2
81135608:	00000106 	br	81135610 <close+0x40>
8113560c:	0005883a 	mov	r2,zero
81135610:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
81135614:	e0bffd17 	ldw	r2,-12(fp)
81135618:	10001926 	beq	r2,zero,81135680 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
8113561c:	e0bffd17 	ldw	r2,-12(fp)
81135620:	10800017 	ldw	r2,0(r2)
81135624:	10800417 	ldw	r2,16(r2)
81135628:	10000626 	beq	r2,zero,81135644 <close+0x74>
8113562c:	e0bffd17 	ldw	r2,-12(fp)
81135630:	10800017 	ldw	r2,0(r2)
81135634:	10800417 	ldw	r2,16(r2)
81135638:	e13ffd17 	ldw	r4,-12(fp)
8113563c:	103ee83a 	callr	r2
81135640:	00000106 	br	81135648 <close+0x78>
81135644:	0005883a 	mov	r2,zero
81135648:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
8113564c:	e13fff17 	ldw	r4,-4(fp)
81135650:	1136bb40 	call	81136bb4 <alt_release_fd>
    if (rval < 0)
81135654:	e0bffe17 	ldw	r2,-8(fp)
81135658:	1000070e 	bge	r2,zero,81135678 <close+0xa8>
    {
      ALT_ERRNO = -rval;
8113565c:	113558c0 	call	8113558c <alt_get_errno>
81135660:	1007883a 	mov	r3,r2
81135664:	e0bffe17 	ldw	r2,-8(fp)
81135668:	0085c83a 	sub	r2,zero,r2
8113566c:	18800015 	stw	r2,0(r3)
      return -1;
81135670:	00bfffc4 	movi	r2,-1
81135674:	00000706 	br	81135694 <close+0xc4>
    }
    return 0;
81135678:	0005883a 	mov	r2,zero
8113567c:	00000506 	br	81135694 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
81135680:	113558c0 	call	8113558c <alt_get_errno>
81135684:	1007883a 	mov	r3,r2
81135688:	00801444 	movi	r2,81
8113568c:	18800015 	stw	r2,0(r3)
    return -1;
81135690:	00bfffc4 	movi	r2,-1
  }
}
81135694:	e037883a 	mov	sp,fp
81135698:	dfc00117 	ldw	ra,4(sp)
8113569c:	df000017 	ldw	fp,0(sp)
811356a0:	dec00204 	addi	sp,sp,8
811356a4:	f800283a 	ret

811356a8 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
811356a8:	deffff04 	addi	sp,sp,-4
811356ac:	de00012e 	bgeu	sp,et,811356b4 <alt_dcache_flush_all+0xc>
811356b0:	003b68fa 	trap	3
811356b4:	df000015 	stw	fp,0(sp)
811356b8:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
811356bc:	0001883a 	nop
811356c0:	e037883a 	mov	sp,fp
811356c4:	df000017 	ldw	fp,0(sp)
811356c8:	dec00104 	addi	sp,sp,4
811356cc:	f800283a 	ret

811356d0 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
811356d0:	defffc04 	addi	sp,sp,-16
811356d4:	de00012e 	bgeu	sp,et,811356dc <alt_dev_null_write+0xc>
811356d8:	003b68fa 	trap	3
811356dc:	df000315 	stw	fp,12(sp)
811356e0:	df000304 	addi	fp,sp,12
811356e4:	e13ffd15 	stw	r4,-12(fp)
811356e8:	e17ffe15 	stw	r5,-8(fp)
811356ec:	e1bfff15 	stw	r6,-4(fp)
  return len;
811356f0:	e0bfff17 	ldw	r2,-4(fp)
}
811356f4:	e037883a 	mov	sp,fp
811356f8:	df000017 	ldw	fp,0(sp)
811356fc:	dec00104 	addi	sp,sp,4
81135700:	f800283a 	ret

81135704 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81135704:	defffe04 	addi	sp,sp,-8
81135708:	de00012e 	bgeu	sp,et,81135710 <alt_get_errno+0xc>
8113570c:	003b68fa 	trap	3
81135710:	dfc00115 	stw	ra,4(sp)
81135714:	df000015 	stw	fp,0(sp)
81135718:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113571c:	d0a01017 	ldw	r2,-32704(gp)
81135720:	10000326 	beq	r2,zero,81135730 <alt_get_errno+0x2c>
81135724:	d0a01017 	ldw	r2,-32704(gp)
81135728:	103ee83a 	callr	r2
8113572c:	00000106 	br	81135734 <alt_get_errno+0x30>
81135730:	d0a07704 	addi	r2,gp,-32292
}
81135734:	e037883a 	mov	sp,fp
81135738:	dfc00117 	ldw	ra,4(sp)
8113573c:	df000017 	ldw	fp,0(sp)
81135740:	dec00204 	addi	sp,sp,8
81135744:	f800283a 	ret

81135748 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
81135748:	defffb04 	addi	sp,sp,-20
8113574c:	de00012e 	bgeu	sp,et,81135754 <fstat+0xc>
81135750:	003b68fa 	trap	3
81135754:	dfc00415 	stw	ra,16(sp)
81135758:	df000315 	stw	fp,12(sp)
8113575c:	df000304 	addi	fp,sp,12
81135760:	e13ffe15 	stw	r4,-8(fp)
81135764:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81135768:	e0bffe17 	ldw	r2,-8(fp)
8113576c:	10000616 	blt	r2,zero,81135788 <fstat+0x40>
81135770:	e0bffe17 	ldw	r2,-8(fp)
81135774:	10c00324 	muli	r3,r2,12
81135778:	00a04574 	movhi	r2,33045
8113577c:	10835104 	addi	r2,r2,3396
81135780:	1885883a 	add	r2,r3,r2
81135784:	00000106 	br	8113578c <fstat+0x44>
81135788:	0005883a 	mov	r2,zero
8113578c:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
81135790:	e0bffd17 	ldw	r2,-12(fp)
81135794:	10001026 	beq	r2,zero,811357d8 <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
81135798:	e0bffd17 	ldw	r2,-12(fp)
8113579c:	10800017 	ldw	r2,0(r2)
811357a0:	10800817 	ldw	r2,32(r2)
811357a4:	10000726 	beq	r2,zero,811357c4 <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
811357a8:	e0bffd17 	ldw	r2,-12(fp)
811357ac:	10800017 	ldw	r2,0(r2)
811357b0:	10800817 	ldw	r2,32(r2)
811357b4:	e17fff17 	ldw	r5,-4(fp)
811357b8:	e13ffd17 	ldw	r4,-12(fp)
811357bc:	103ee83a 	callr	r2
811357c0:	00000a06 	br	811357ec <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
811357c4:	e0bfff17 	ldw	r2,-4(fp)
811357c8:	00c80004 	movi	r3,8192
811357cc:	10c00115 	stw	r3,4(r2)
      return 0;
811357d0:	0005883a 	mov	r2,zero
811357d4:	00000506 	br	811357ec <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
811357d8:	11357040 	call	81135704 <alt_get_errno>
811357dc:	1007883a 	mov	r3,r2
811357e0:	00801444 	movi	r2,81
811357e4:	18800015 	stw	r2,0(r3)
    return -1;
811357e8:	00bfffc4 	movi	r2,-1
  }
}
811357ec:	e037883a 	mov	sp,fp
811357f0:	dfc00117 	ldw	ra,4(sp)
811357f4:	df000017 	ldw	fp,0(sp)
811357f8:	dec00204 	addi	sp,sp,8
811357fc:	f800283a 	ret

81135800 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
81135800:	defff004 	addi	sp,sp,-64
81135804:	de00012e 	bgeu	sp,et,8113580c <alt_irq_register+0xc>
81135808:	003b68fa 	trap	3
8113580c:	df000f15 	stw	fp,60(sp)
81135810:	df000f04 	addi	fp,sp,60
81135814:	e13ffd15 	stw	r4,-12(fp)
81135818:	e17ffe15 	stw	r5,-8(fp)
8113581c:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
81135820:	00bffa84 	movi	r2,-22
81135824:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
81135828:	e0bffd17 	ldw	r2,-12(fp)
8113582c:	10800828 	cmpgeui	r2,r2,32
81135830:	1000501e 	bne	r2,zero,81135974 <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135834:	0005303a 	rdctl	r2,status
81135838:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113583c:	e0fff617 	ldw	r3,-40(fp)
81135840:	00bfff84 	movi	r2,-2
81135844:	1884703a 	and	r2,r3,r2
81135848:	1001703a 	wrctl	status,r2
  
  return context;
8113584c:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
81135850:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
81135854:	00a045f4 	movhi	r2,33047
81135858:	10b0f304 	addi	r2,r2,-15412
8113585c:	e0fffd17 	ldw	r3,-12(fp)
81135860:	180690fa 	slli	r3,r3,3
81135864:	10c5883a 	add	r2,r2,r3
81135868:	e0ffff17 	ldw	r3,-4(fp)
8113586c:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
81135870:	00a045f4 	movhi	r2,33047
81135874:	10b0f304 	addi	r2,r2,-15412
81135878:	e0fffd17 	ldw	r3,-12(fp)
8113587c:	180690fa 	slli	r3,r3,3
81135880:	10c5883a 	add	r2,r2,r3
81135884:	10800104 	addi	r2,r2,4
81135888:	e0fffe17 	ldw	r3,-8(fp)
8113588c:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
81135890:	e0bfff17 	ldw	r2,-4(fp)
81135894:	10001926 	beq	r2,zero,811358fc <alt_irq_register+0xfc>
81135898:	e0bffd17 	ldw	r2,-12(fp)
8113589c:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811358a0:	0005303a 	rdctl	r2,status
811358a4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811358a8:	e0fff717 	ldw	r3,-36(fp)
811358ac:	00bfff84 	movi	r2,-2
811358b0:	1884703a 	and	r2,r3,r2
811358b4:	1001703a 	wrctl	status,r2
  
  return context;
811358b8:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
811358bc:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
811358c0:	00c00044 	movi	r3,1
811358c4:	e0bff217 	ldw	r2,-56(fp)
811358c8:	1884983a 	sll	r2,r3,r2
811358cc:	1007883a 	mov	r3,r2
811358d0:	d0a07f17 	ldw	r2,-32260(gp)
811358d4:	1884b03a 	or	r2,r3,r2
811358d8:	d0a07f15 	stw	r2,-32260(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
811358dc:	d0a07f17 	ldw	r2,-32260(gp)
811358e0:	100170fa 	wrctl	ienable,r2
811358e4:	e0bff817 	ldw	r2,-32(fp)
811358e8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811358ec:	e0bff917 	ldw	r2,-28(fp)
811358f0:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
811358f4:	0005883a 	mov	r2,zero
811358f8:	00001906 	br	81135960 <alt_irq_register+0x160>
811358fc:	e0bffd17 	ldw	r2,-12(fp)
81135900:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135904:	0005303a 	rdctl	r2,status
81135908:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113590c:	e0fffa17 	ldw	r3,-24(fp)
81135910:	00bfff84 	movi	r2,-2
81135914:	1884703a 	and	r2,r3,r2
81135918:	1001703a 	wrctl	status,r2
  
  return context;
8113591c:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81135920:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
81135924:	00c00044 	movi	r3,1
81135928:	e0bff417 	ldw	r2,-48(fp)
8113592c:	1884983a 	sll	r2,r3,r2
81135930:	0084303a 	nor	r2,zero,r2
81135934:	1007883a 	mov	r3,r2
81135938:	d0a07f17 	ldw	r2,-32260(gp)
8113593c:	1884703a 	and	r2,r3,r2
81135940:	d0a07f15 	stw	r2,-32260(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81135944:	d0a07f17 	ldw	r2,-32260(gp)
81135948:	100170fa 	wrctl	ienable,r2
8113594c:	e0bffb17 	ldw	r2,-20(fp)
81135950:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135954:	e0bffc17 	ldw	r2,-16(fp)
81135958:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8113595c:	0005883a 	mov	r2,zero
81135960:	e0bff115 	stw	r2,-60(fp)
81135964:	e0bff317 	ldw	r2,-52(fp)
81135968:	e0bff515 	stw	r2,-44(fp)
8113596c:	e0bff517 	ldw	r2,-44(fp)
81135970:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
81135974:	e0bff117 	ldw	r2,-60(fp)
}
81135978:	e037883a 	mov	sp,fp
8113597c:	df000017 	ldw	fp,0(sp)
81135980:	dec00104 	addi	sp,sp,4
81135984:	f800283a 	ret

81135988 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81135988:	defffe04 	addi	sp,sp,-8
8113598c:	de00012e 	bgeu	sp,et,81135994 <alt_get_errno+0xc>
81135990:	003b68fa 	trap	3
81135994:	dfc00115 	stw	ra,4(sp)
81135998:	df000015 	stw	fp,0(sp)
8113599c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811359a0:	d0a01017 	ldw	r2,-32704(gp)
811359a4:	10000326 	beq	r2,zero,811359b4 <alt_get_errno+0x2c>
811359a8:	d0a01017 	ldw	r2,-32704(gp)
811359ac:	103ee83a 	callr	r2
811359b0:	00000106 	br	811359b8 <alt_get_errno+0x30>
811359b4:	d0a07704 	addi	r2,gp,-32292
}
811359b8:	e037883a 	mov	sp,fp
811359bc:	dfc00117 	ldw	ra,4(sp)
811359c0:	df000017 	ldw	fp,0(sp)
811359c4:	dec00204 	addi	sp,sp,8
811359c8:	f800283a 	ret

811359cc <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
811359cc:	deffed04 	addi	sp,sp,-76
811359d0:	de00012e 	bgeu	sp,et,811359d8 <isatty+0xc>
811359d4:	003b68fa 	trap	3
811359d8:	dfc01215 	stw	ra,72(sp)
811359dc:	df001115 	stw	fp,68(sp)
811359e0:	df001104 	addi	fp,sp,68
811359e4:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
811359e8:	e0bfff17 	ldw	r2,-4(fp)
811359ec:	10000616 	blt	r2,zero,81135a08 <isatty+0x3c>
811359f0:	e0bfff17 	ldw	r2,-4(fp)
811359f4:	10c00324 	muli	r3,r2,12
811359f8:	00a04574 	movhi	r2,33045
811359fc:	10835104 	addi	r2,r2,3396
81135a00:	1885883a 	add	r2,r3,r2
81135a04:	00000106 	br	81135a0c <isatty+0x40>
81135a08:	0005883a 	mov	r2,zero
81135a0c:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
81135a10:	e0bfef17 	ldw	r2,-68(fp)
81135a14:	10000e26 	beq	r2,zero,81135a50 <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
81135a18:	e0bfef17 	ldw	r2,-68(fp)
81135a1c:	10800017 	ldw	r2,0(r2)
81135a20:	10800817 	ldw	r2,32(r2)
81135a24:	1000021e 	bne	r2,zero,81135a30 <isatty+0x64>
    {
      return 1;
81135a28:	00800044 	movi	r2,1
81135a2c:	00000d06 	br	81135a64 <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
81135a30:	e0bff004 	addi	r2,fp,-64
81135a34:	100b883a 	mov	r5,r2
81135a38:	e13fff17 	ldw	r4,-4(fp)
81135a3c:	11357480 	call	81135748 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
81135a40:	e0bff117 	ldw	r2,-60(fp)
81135a44:	10880020 	cmpeqi	r2,r2,8192
81135a48:	10803fcc 	andi	r2,r2,255
81135a4c:	00000506 	br	81135a64 <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81135a50:	11359880 	call	81135988 <alt_get_errno>
81135a54:	1007883a 	mov	r3,r2
81135a58:	00801444 	movi	r2,81
81135a5c:	18800015 	stw	r2,0(r3)
    return 0;
81135a60:	0005883a 	mov	r2,zero
  }
}
81135a64:	e037883a 	mov	sp,fp
81135a68:	dfc00117 	ldw	ra,4(sp)
81135a6c:	df000017 	ldw	fp,0(sp)
81135a70:	dec00204 	addi	sp,sp,8
81135a74:	f800283a 	ret

81135a78 <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
81135a78:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
81135a7c:	318c2404 	addi	r6,r6,12432

81135a80 <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
81135a80:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
81135a84:	01c00826 	beq	zero,r7,81135aa8 <end_tx>

81135a88 <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
81135a88:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
81135a8c:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
81135a90:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
81135a94:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
81135a98:	283ffb26 	beq	r5,zero,81135a88 <__reset+0xfb115a88>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
81135a9c:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
81135aa0:	21000044 	addi	r4,r4,1
	br tx_next_char
81135aa4:	003ff606 	br	81135a80 <__reset+0xfb115a80>

81135aa8 <end_tx>:
end_tx:	
        ret
81135aa8:	f800283a 	ret

81135aac <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
81135aac:	defffd04 	addi	sp,sp,-12
81135ab0:	de00012e 	bgeu	sp,et,81135ab8 <alt_log_txchar+0xc>
81135ab4:	003b68fa 	trap	3
81135ab8:	df000215 	stw	fp,8(sp)
81135abc:	df000204 	addi	fp,sp,8
81135ac0:	e13ffe15 	stw	r4,-8(fp)
81135ac4:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
81135ac8:	0001883a 	nop
81135acc:	e0bfff17 	ldw	r2,-4(fp)
81135ad0:	10800104 	addi	r2,r2,4
81135ad4:	10800037 	ldwio	r2,0(r2)
81135ad8:	10bfffec 	andhi	r2,r2,65535
81135adc:	103ffb26 	beq	r2,zero,81135acc <__reset+0xfb115acc>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
81135ae0:	e0bfff17 	ldw	r2,-4(fp)
81135ae4:	e0fffe17 	ldw	r3,-8(fp)
81135ae8:	10c00035 	stwio	r3,0(r2)
}
81135aec:	0001883a 	nop
81135af0:	e037883a 	mov	sp,fp
81135af4:	df000017 	ldw	fp,0(sp)
81135af8:	dec00104 	addi	sp,sp,4
81135afc:	f800283a 	ret

81135b00 <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
81135b00:	defffb04 	addi	sp,sp,-20
81135b04:	de00012e 	bgeu	sp,et,81135b0c <alt_log_repchar+0xc>
81135b08:	003b68fa 	trap	3
81135b0c:	dfc00415 	stw	ra,16(sp)
81135b10:	df000315 	stw	fp,12(sp)
81135b14:	df000304 	addi	fp,sp,12
81135b18:	2005883a 	mov	r2,r4
81135b1c:	e17ffe15 	stw	r5,-8(fp)
81135b20:	e1bfff15 	stw	r6,-4(fp)
81135b24:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
81135b28:	00000506 	br	81135b40 <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
81135b2c:	e0bffd07 	ldb	r2,-12(fp)
81135b30:	e0ffff17 	ldw	r3,-4(fp)
81135b34:	180b883a 	mov	r5,r3
81135b38:	1009883a 	mov	r4,r2
81135b3c:	1135aac0 	call	81135aac <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
81135b40:	e0bffe17 	ldw	r2,-8(fp)
81135b44:	10ffffc4 	addi	r3,r2,-1
81135b48:	e0fffe15 	stw	r3,-8(fp)
81135b4c:	00bff716 	blt	zero,r2,81135b2c <__reset+0xfb115b2c>
    alt_log_txchar(c,(char*) base);
}
81135b50:	0001883a 	nop
81135b54:	e037883a 	mov	sp,fp
81135b58:	dfc00117 	ldw	ra,4(sp)
81135b5c:	df000017 	ldw	fp,0(sp)
81135b60:	dec00204 	addi	sp,sp,8
81135b64:	f800283a 	ret

81135b68 <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
81135b68:	deffe904 	addi	sp,sp,-92
81135b6c:	de00012e 	bgeu	sp,et,81135b74 <alt_log_private_printf+0xc>
81135b70:	003b68fa 	trap	3
81135b74:	dfc01615 	stw	ra,88(sp)
81135b78:	df001515 	stw	fp,84(sp)
81135b7c:	dc001415 	stw	r16,80(sp)
81135b80:	df001504 	addi	fp,sp,84
81135b84:	e13ffc15 	stw	r4,-16(fp)
81135b88:	e17ffd15 	stw	r5,-12(fp)
81135b8c:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
81135b90:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
81135b94:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
81135b98:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
81135b9c:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
81135ba0:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
81135ba4:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
81135ba8:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
81135bac:	e0bffc17 	ldw	r2,-16(fp)
81135bb0:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
81135bb4:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
81135bb8:	00014b06 	br	811360e8 <alt_log_private_printf+0x580>
    {
    switch(state)
81135bbc:	e0bfec17 	ldw	r2,-80(fp)
81135bc0:	10c00060 	cmpeqi	r3,r2,1
81135bc4:	18001b1e 	bne	r3,zero,81135c34 <alt_log_private_printf+0xcc>
81135bc8:	10c000a0 	cmpeqi	r3,r2,2
81135bcc:	18002d1e 	bne	r3,zero,81135c84 <alt_log_private_printf+0x11c>
81135bd0:	10000126 	beq	r2,zero,81135bd8 <alt_log_private_printf+0x70>
81135bd4:	00014406 	br	811360e8 <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
81135bd8:	e0bffb07 	ldb	r2,-20(fp)
81135bdc:	10800958 	cmpnei	r2,r2,37
81135be0:	10000e1e 	bne	r2,zero,81135c1c <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
81135be4:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
81135be8:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
81135bec:	00800284 	movi	r2,10
81135bf0:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
81135bf4:	00800044 	movi	r2,1
81135bf8:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
81135bfc:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
81135c00:	00bfffc4 	movi	r2,-1
81135c04:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
81135c08:	00bfffc4 	movi	r2,-1
81135c0c:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
81135c10:	00800044 	movi	r2,1
81135c14:	e0bfec15 	stw	r2,-80(fp)
81135c18:	00013306 	br	811360e8 <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
81135c1c:	e0bffb07 	ldb	r2,-20(fp)
81135c20:	e0fffd17 	ldw	r3,-12(fp)
81135c24:	180b883a 	mov	r5,r3
81135c28:	1009883a 	mov	r4,r2
81135c2c:	1135aac0 	call	81135aac <alt_log_txchar>
        }
        break;
81135c30:	00012d06 	br	811360e8 <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
81135c34:	e0bffb07 	ldb	r2,-20(fp)
81135c38:	10800c18 	cmpnei	r2,r2,48
81135c3c:	1000051e 	bne	r2,zero,81135c54 <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
81135c40:	00800044 	movi	r2,1
81135c44:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
81135c48:	00800084 	movi	r2,2
81135c4c:	e0bfec15 	stw	r2,-80(fp)
81135c50:	00012506 	br	811360e8 <alt_log_private_printf+0x580>
        }
        else if(c == '%')
81135c54:	e0bffb07 	ldb	r2,-20(fp)
81135c58:	10800958 	cmpnei	r2,r2,37
81135c5c:	1000071e 	bne	r2,zero,81135c7c <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
81135c60:	e0bffb07 	ldb	r2,-20(fp)
81135c64:	e0fffd17 	ldw	r3,-12(fp)
81135c68:	180b883a 	mov	r5,r3
81135c6c:	1009883a 	mov	r4,r2
81135c70:	1135aac0 	call	81135aac <alt_log_txchar>
          state = pfState_chars;
81135c74:	e03fec15 	stw	zero,-80(fp)
81135c78:	00011b06 	br	811360e8 <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
81135c7c:	00800084 	movi	r2,2
81135c80:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
81135c84:	e0bffb07 	ldb	r2,-20(fp)
81135c88:	10800b98 	cmpnei	r2,r2,46
81135c8c:	1000021e 	bne	r2,zero,81135c98 <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
81135c90:	e03ff015 	stw	zero,-64(fp)
81135c94:	00011306 	br	811360e4 <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
81135c98:	e0bffb07 	ldb	r2,-20(fp)
81135c9c:	10800c10 	cmplti	r2,r2,48
81135ca0:	10001a1e 	bne	r2,zero,81135d0c <alt_log_private_printf+0x1a4>
81135ca4:	e0bffb07 	ldb	r2,-20(fp)
81135ca8:	10800e88 	cmpgei	r2,r2,58
81135cac:	1000171e 	bne	r2,zero,81135d0c <alt_log_private_printf+0x1a4>
        {
          c -= '0';
81135cb0:	e0bffb03 	ldbu	r2,-20(fp)
81135cb4:	10bff404 	addi	r2,r2,-48
81135cb8:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
81135cbc:	e0bff017 	ldw	r2,-64(fp)
81135cc0:	10000c0e 	bge	r2,zero,81135cf4 <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
81135cc4:	e0bfef17 	ldw	r2,-68(fp)
81135cc8:	1000020e 	bge	r2,zero,81135cd4 <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
81135ccc:	e03fef15 	stw	zero,-68(fp)
81135cd0:	00000306 	br	81135ce0 <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
81135cd4:	e0bfef17 	ldw	r2,-68(fp)
81135cd8:	108002a4 	muli	r2,r2,10
81135cdc:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
81135ce0:	e0bffb07 	ldb	r2,-20(fp)
81135ce4:	e0ffef17 	ldw	r3,-68(fp)
81135ce8:	1885883a 	add	r2,r3,r2
81135cec:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81135cf0:	0000fc06 	br	811360e4 <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
81135cf4:	e0bff017 	ldw	r2,-64(fp)
81135cf8:	10c002a4 	muli	r3,r2,10
81135cfc:	e0bffb07 	ldb	r2,-20(fp)
81135d00:	1885883a 	add	r2,r3,r2
81135d04:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81135d08:	0000f606 	br	811360e4 <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
81135d0c:	e0bffb07 	ldb	r2,-20(fp)
81135d10:	10801b18 	cmpnei	r2,r2,108
81135d14:	1000031e 	bne	r2,zero,81135d24 <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
81135d18:	00800044 	movi	r2,1
81135d1c:	e0bfee15 	stw	r2,-72(fp)
81135d20:	0000f006 	br	811360e4 <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
81135d24:	e0bffb07 	ldb	r2,-20(fp)
81135d28:	10bfea04 	addi	r2,r2,-88
81135d2c:	10c00868 	cmpgeui	r3,r2,33
81135d30:	1800eb1e 	bne	r3,zero,811360e0 <alt_log_private_printf+0x578>
81135d34:	100690ba 	slli	r3,r2,2
81135d38:	00a044f4 	movhi	r2,33043
81135d3c:	10975304 	addi	r2,r2,23884
81135d40:	1885883a 	add	r2,r3,r2
81135d44:	10800017 	ldw	r2,0(r2)
81135d48:	1000683a 	jmp	r2
81135d4c:	8113600c 	andi	r4,r16,19840
81135d50:	811360e0 	cmpeqi	r4,r16,19843
81135d54:	811360e0 	cmpeqi	r4,r16,19843
81135d58:	811360e0 	cmpeqi	r4,r16,19843
81135d5c:	811360e0 	cmpeqi	r4,r16,19843
81135d60:	811360e0 	cmpeqi	r4,r16,19843
81135d64:	811360e0 	cmpeqi	r4,r16,19843
81135d68:	811360e0 	cmpeqi	r4,r16,19843
81135d6c:	811360e0 	cmpeqi	r4,r16,19843
81135d70:	811360e0 	cmpeqi	r4,r16,19843
81135d74:	811360e0 	cmpeqi	r4,r16,19843
81135d78:	81136024 	muli	r4,r16,19840
81135d7c:	81135dd0 	cmplti	r4,r16,19831
81135d80:	811360e0 	cmpeqi	r4,r16,19843
81135d84:	811360e0 	cmpeqi	r4,r16,19843
81135d88:	811360e0 	cmpeqi	r4,r16,19843
81135d8c:	811360e0 	cmpeqi	r4,r16,19843
81135d90:	81135dd0 	cmplti	r4,r16,19831
81135d94:	811360e0 	cmpeqi	r4,r16,19843
81135d98:	811360e0 	cmpeqi	r4,r16,19843
81135d9c:	811360e0 	cmpeqi	r4,r16,19843
81135da0:	811360e0 	cmpeqi	r4,r16,19843
81135da4:	811360e0 	cmpeqi	r4,r16,19843
81135da8:	81135fec 	andhi	r4,r16,19839
81135dac:	811360e0 	cmpeqi	r4,r16,19843
81135db0:	811360e0 	cmpeqi	r4,r16,19843
81135db4:	811360e0 	cmpeqi	r4,r16,19843
81135db8:	81136060 	cmpeqi	r4,r16,19841
81135dbc:	811360e0 	cmpeqi	r4,r16,19843
81135dc0:	81135fe4 	muli	r4,r16,19839
81135dc4:	811360e0 	cmpeqi	r4,r16,19843
81135dc8:	811360e0 	cmpeqi	r4,r16,19843
81135dcc:	81135ffc 	xorhi	r4,r16,19839
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
81135dd0:	e0bfee17 	ldw	r2,-72(fp)
81135dd4:	10000e26 	beq	r2,zero,81135e10 <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
81135dd8:	e0bff217 	ldw	r2,-56(fp)
81135ddc:	10000626 	beq	r2,zero,81135df8 <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
81135de0:	e0bffe17 	ldw	r2,-8(fp)
81135de4:	10c00104 	addi	r3,r2,4
81135de8:	e0fffe15 	stw	r3,-8(fp)
81135dec:	10800017 	ldw	r2,0(r2)
81135df0:	e0bff415 	stw	r2,-48(fp)
81135df4:	00001306 	br	81135e44 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
81135df8:	e0bffe17 	ldw	r2,-8(fp)
81135dfc:	10c00104 	addi	r3,r2,4
81135e00:	e0fffe15 	stw	r3,-8(fp)
81135e04:	10800017 	ldw	r2,0(r2)
81135e08:	e0bff415 	stw	r2,-48(fp)
81135e0c:	00000d06 	br	81135e44 <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
81135e10:	e0bff217 	ldw	r2,-56(fp)
81135e14:	10000626 	beq	r2,zero,81135e30 <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
81135e18:	e0bffe17 	ldw	r2,-8(fp)
81135e1c:	10c00104 	addi	r3,r2,4
81135e20:	e0fffe15 	stw	r3,-8(fp)
81135e24:	10800017 	ldw	r2,0(r2)
81135e28:	e0bff415 	stw	r2,-48(fp)
81135e2c:	00000506 	br	81135e44 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
81135e30:	e0bffe17 	ldw	r2,-8(fp)
81135e34:	10c00104 	addi	r3,r2,4
81135e38:	e0fffe15 	stw	r3,-8(fp)
81135e3c:	10800017 	ldw	r2,0(r2)
81135e40:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
81135e44:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
81135e48:	e0bff217 	ldw	r2,-56(fp)
81135e4c:	10000726 	beq	r2,zero,81135e6c <alt_log_private_printf+0x304>
81135e50:	e0bff417 	ldw	r2,-48(fp)
81135e54:	1000050e 	bge	r2,zero,81135e6c <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
81135e58:	e0bff417 	ldw	r2,-48(fp)
81135e5c:	0085c83a 	sub	r2,zero,r2
81135e60:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
81135e64:	00800044 	movi	r2,1
81135e68:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
81135e6c:	e0bff417 	ldw	r2,-48(fp)
81135e70:	e0bff615 	stw	r2,-40(fp)
                p = 1;
81135e74:	00800044 	movi	r2,1
81135e78:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
81135e7c:	00800044 	movi	r2,1
81135e80:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
81135e84:	00000706 	br	81135ea4 <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
81135e88:	e0bff817 	ldw	r2,-32(fp)
81135e8c:	10800044 	addi	r2,r2,1
81135e90:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
81135e94:	e0bff117 	ldw	r2,-60(fp)
81135e98:	e0fff517 	ldw	r3,-44(fp)
81135e9c:	1885383a 	mul	r2,r3,r2
81135ea0:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
81135ea4:	e0bff117 	ldw	r2,-60(fp)
81135ea8:	e0fff617 	ldw	r3,-40(fp)
81135eac:	1885203a 	divu	r2,r3,r2
81135eb0:	e0bff615 	stw	r2,-40(fp)
81135eb4:	e0bff617 	ldw	r2,-40(fp)
81135eb8:	103ff31e 	bne	r2,zero,81135e88 <__reset+0xfb115e88>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
81135ebc:	e0ffef17 	ldw	r3,-68(fp)
81135ec0:	e0bff817 	ldw	r2,-32(fp)
81135ec4:	1885c83a 	sub	r2,r3,r2
81135ec8:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
81135ecc:	e0bfed17 	ldw	r2,-76(fp)
81135ed0:	10000e26 	beq	r2,zero,81135f0c <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
81135ed4:	e0bff717 	ldw	r2,-36(fp)
81135ed8:	10000726 	beq	r2,zero,81135ef8 <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
81135edc:	e0bffd17 	ldw	r2,-12(fp)
81135ee0:	100b883a 	mov	r5,r2
81135ee4:	01000b44 	movi	r4,45
81135ee8:	1135aac0 	call	81135aac <alt_log_txchar>
                    fmtBeforeDecimal--;
81135eec:	e0bfef17 	ldw	r2,-68(fp)
81135ef0:	10bfffc4 	addi	r2,r2,-1
81135ef4:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
81135ef8:	e1bffd17 	ldw	r6,-12(fp)
81135efc:	e17fef17 	ldw	r5,-68(fp)
81135f00:	01000c04 	movi	r4,48
81135f04:	1135b000 	call	81135b00 <alt_log_repchar>
81135f08:	00003206 	br	81135fd4 <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
81135f0c:	e0bff717 	ldw	r2,-36(fp)
81135f10:	10000326 	beq	r2,zero,81135f20 <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
81135f14:	e0bfef17 	ldw	r2,-68(fp)
81135f18:	10bfffc4 	addi	r2,r2,-1
81135f1c:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
81135f20:	e1bffd17 	ldw	r6,-12(fp)
81135f24:	e17fef17 	ldw	r5,-68(fp)
81135f28:	01000804 	movi	r4,32
81135f2c:	1135b000 	call	81135b00 <alt_log_repchar>
                    if(sign)
81135f30:	e0bff717 	ldw	r2,-36(fp)
81135f34:	10002726 	beq	r2,zero,81135fd4 <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
81135f38:	e0bffd17 	ldw	r2,-12(fp)
81135f3c:	100b883a 	mov	r5,r2
81135f40:	01000b44 	movi	r4,45
81135f44:	1135aac0 	call	81135aac <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
81135f48:	00002206 	br	81135fd4 <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
81135f4c:	e0fff417 	ldw	r3,-48(fp)
81135f50:	e0bff517 	ldw	r2,-44(fp)
81135f54:	1885203a 	divu	r2,r3,r2
81135f58:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
81135f5c:	e0bff903 	ldbu	r2,-28(fp)
81135f60:	10800c04 	addi	r2,r2,48
81135f64:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
81135f68:	e0bff903 	ldbu	r2,-28(fp)
81135f6c:	10800eb0 	cmpltui	r2,r2,58
81135f70:	1000081e 	bne	r2,zero,81135f94 <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
81135f74:	e0bff317 	ldw	r2,-52(fp)
81135f78:	10000226 	beq	r2,zero,81135f84 <alt_log_private_printf+0x41c>
81135f7c:	008001c4 	movi	r2,7
81135f80:	00000106 	br	81135f88 <alt_log_private_printf+0x420>
81135f84:	008009c4 	movi	r2,39
81135f88:	e0fff903 	ldbu	r3,-28(fp)
81135f8c:	10c5883a 	add	r2,r2,r3
81135f90:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
81135f94:	e0bff903 	ldbu	r2,-28(fp)
81135f98:	e0fffd17 	ldw	r3,-12(fp)
81135f9c:	180b883a 	mov	r5,r3
81135fa0:	1009883a 	mov	r4,r2
81135fa4:	1135aac0 	call	81135aac <alt_log_txchar>

                  v = v % p;
81135fa8:	e0bff417 	ldw	r2,-48(fp)
81135fac:	e0fff517 	ldw	r3,-44(fp)
81135fb0:	10c9203a 	divu	r4,r2,r3
81135fb4:	e0fff517 	ldw	r3,-44(fp)
81135fb8:	20c7383a 	mul	r3,r4,r3
81135fbc:	10c5c83a 	sub	r2,r2,r3
81135fc0:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
81135fc4:	e0bff117 	ldw	r2,-60(fp)
81135fc8:	e0fff517 	ldw	r3,-44(fp)
81135fcc:	1885203a 	divu	r2,r3,r2
81135fd0:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
81135fd4:	e0bff517 	ldw	r2,-44(fp)
81135fd8:	103fdc1e 	bne	r2,zero,81135f4c <__reset+0xfb115f4c>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
81135fdc:	e03fec15 	stw	zero,-80(fp)
              break;
81135fe0:	00003f06 	br	811360e0 <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
81135fe4:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
81135fe8:	003f7906 	br	81135dd0 <__reset+0xfb115dd0>
            case 'o':
              fmtSigned = 0;
81135fec:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
81135ff0:	00800204 	movi	r2,8
81135ff4:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81135ff8:	003f7506 	br	81135dd0 <__reset+0xfb115dd0>
            case 'x':
              fmtSigned = 0;
81135ffc:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81136000:	00800404 	movi	r2,16
81136004:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81136008:	003f7106 	br	81135dd0 <__reset+0xfb115dd0>
            case 'X':
              fmtSigned = 0;
8113600c:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81136010:	00800404 	movi	r2,16
81136014:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
81136018:	00800044 	movi	r2,1
8113601c:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
81136020:	003f6b06 	br	81135dd0 <__reset+0xfb115dd0>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
81136024:	e0bfef17 	ldw	r2,-68(fp)
81136028:	10bfffc4 	addi	r2,r2,-1
8113602c:	e1bffd17 	ldw	r6,-12(fp)
81136030:	100b883a 	mov	r5,r2
81136034:	01000804 	movi	r4,32
81136038:	1135b000 	call	81135b00 <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
8113603c:	e0bffe17 	ldw	r2,-8(fp)
81136040:	10c00104 	addi	r3,r2,4
81136044:	e0fffe15 	stw	r3,-8(fp)
81136048:	10800017 	ldw	r2,0(r2)
8113604c:	e0fffd17 	ldw	r3,-12(fp)
81136050:	180b883a 	mov	r5,r3
81136054:	1009883a 	mov	r4,r2
81136058:	1135aac0 	call	81135aac <alt_log_txchar>
              break;
8113605c:	00002006 	br	811360e0 <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
81136060:	e0bffe17 	ldw	r2,-8(fp)
81136064:	10c00104 	addi	r3,r2,4
81136068:	e0fffe15 	stw	r3,-8(fp)
8113606c:	10800017 	ldw	r2,0(r2)
81136070:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
81136074:	e43fef17 	ldw	r16,-68(fp)
81136078:	e13ffa17 	ldw	r4,-24(fp)
8113607c:	112235c0 	call	8112235c <strlen>
81136080:	8085c83a 	sub	r2,r16,r2
81136084:	e1bffd17 	ldw	r6,-12(fp)
81136088:	100b883a 	mov	r5,r2
8113608c:	01000804 	movi	r4,32
81136090:	1135b000 	call	81135b00 <alt_log_repchar>

                while(*s)
81136094:	00000b06 	br	811360c4 <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
81136098:	e0bffa17 	ldw	r2,-24(fp)
8113609c:	10c00044 	addi	r3,r2,1
811360a0:	e0fffa15 	stw	r3,-24(fp)
811360a4:	10800003 	ldbu	r2,0(r2)
811360a8:	10803fcc 	andi	r2,r2,255
811360ac:	1080201c 	xori	r2,r2,128
811360b0:	10bfe004 	addi	r2,r2,-128
811360b4:	e0fffd17 	ldw	r3,-12(fp)
811360b8:	180b883a 	mov	r5,r3
811360bc:	1009883a 	mov	r4,r2
811360c0:	1135aac0 	call	81135aac <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
811360c4:	e0bffa17 	ldw	r2,-24(fp)
811360c8:	10800003 	ldbu	r2,0(r2)
811360cc:	10803fcc 	andi	r2,r2,255
811360d0:	1080201c 	xori	r2,r2,128
811360d4:	10bfe004 	addi	r2,r2,-128
811360d8:	103fef1e 	bne	r2,zero,81136098 <__reset+0xfb116098>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
811360dc:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
811360e0:	e03fec15 	stw	zero,-80(fp)
          }
        break;
811360e4:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
811360e8:	e0bfeb17 	ldw	r2,-84(fp)
811360ec:	10c00044 	addi	r3,r2,1
811360f0:	e0ffeb15 	stw	r3,-84(fp)
811360f4:	10800003 	ldbu	r2,0(r2)
811360f8:	e0bffb05 	stb	r2,-20(fp)
811360fc:	e0bffb07 	ldb	r2,-20(fp)
81136100:	103eae1e 	bne	r2,zero,81135bbc <__reset+0xfb115bbc>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
81136104:	0001883a 	nop
81136108:	e6ffff04 	addi	sp,fp,-4
8113610c:	dfc00217 	ldw	ra,8(sp)
81136110:	df000117 	ldw	fp,4(sp)
81136114:	dc000017 	ldw	r16,0(sp)
81136118:	dec00304 	addi	sp,sp,12
8113611c:	f800283a 	ret

81136120 <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
81136120:	defff904 	addi	sp,sp,-28
81136124:	de00012e 	bgeu	sp,et,8113612c <alt_log_printf_proc+0xc>
81136128:	003b68fa 	trap	3
8113612c:	dfc00315 	stw	ra,12(sp)
81136130:	df000215 	stw	fp,8(sp)
81136134:	df000204 	addi	fp,sp,8
81136138:	e13fff15 	stw	r4,-4(fp)
8113613c:	e1400215 	stw	r5,8(fp)
81136140:	e1800315 	stw	r6,12(fp)
81136144:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
81136148:	e0800204 	addi	r2,fp,8
8113614c:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
81136150:	e0bffe17 	ldw	r2,-8(fp)
81136154:	100d883a 	mov	r6,r2
81136158:	01604834 	movhi	r5,33056
8113615c:	294c2404 	addi	r5,r5,12432
81136160:	e13fff17 	ldw	r4,-4(fp)
81136164:	1135b680 	call	81135b68 <alt_log_private_printf>
    return (0);
81136168:	0005883a 	mov	r2,zero
}
8113616c:	e037883a 	mov	sp,fp
81136170:	dfc00117 	ldw	ra,4(sp)
81136174:	df000017 	ldw	fp,0(sp)
81136178:	dec00504 	addi	sp,sp,20
8113617c:	f800283a 	ret

81136180 <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
81136180:	defff904 	addi	sp,sp,-28
81136184:	de00012e 	bgeu	sp,et,8113618c <altera_avalon_jtag_uart_report_log+0xc>
81136188:	003b68fa 	trap	3
8113618c:	dfc00615 	stw	ra,24(sp)
81136190:	df000515 	stw	fp,20(sp)
81136194:	dc400415 	stw	r17,16(sp)
81136198:	dc000315 	stw	r16,12(sp)
8113619c:	df000504 	addi	fp,sp,20
811361a0:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
811361a4:	d0a08083 	ldbu	r2,-32254(gp)
811361a8:	10803fcc 	andi	r2,r2,255
811361ac:	10001426 	beq	r2,zero,81136200 <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
811361b0:	e0bffd17 	ldw	r2,-12(fp)
811361b4:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
811361b8:	00a04574 	movhi	r2,33045
811361bc:	10bf7704 	addi	r2,r2,-548
811361c0:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
811361c4:	e0bffb17 	ldw	r2,-20(fp)
811361c8:	10800017 	ldw	r2,0(r2)
811361cc:	e1bffc17 	ldw	r6,-16(fp)
811361d0:	100b883a 	mov	r5,r2
811361d4:	e13ffb17 	ldw	r4,-20(fp)
811361d8:	11362200 	call	81136220 <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811361dc:	d0e08717 	ldw	r3,-32228(gp)
        return ALT_LOG_JTAG_UART_TICKS;
811361e0:	00b33374 	movhi	r2,52429
811361e4:	10b33344 	addi	r2,r2,-13107
811361e8:	1888383a 	mulxuu	r4,r3,r2
811361ec:	1885383a 	mul	r2,r3,r2
811361f0:	1021883a 	mov	r16,r2
811361f4:	2023883a 	mov	r17,r4
811361f8:	8804d0fa 	srli	r2,r17,3
811361fc:	00000106 	br	81136204 <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
81136200:	0005883a 	mov	r2,zero
    }
}
81136204:	e6fffe04 	addi	sp,fp,-8
81136208:	dfc00317 	ldw	ra,12(sp)
8113620c:	df000217 	ldw	fp,8(sp)
81136210:	dc400117 	ldw	r17,4(sp)
81136214:	dc000017 	ldw	r16,0(sp)
81136218:	dec00404 	addi	sp,sp,16
8113621c:	f800283a 	ret

81136220 <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
81136220:	deffef04 	addi	sp,sp,-68
81136224:	de00012e 	bgeu	sp,et,8113622c <alt_log_jtag_uart_print_control_reg+0xc>
81136228:	003b68fa 	trap	3
8113622c:	dfc01015 	stw	ra,64(sp)
81136230:	df000f15 	stw	fp,60(sp)
81136234:	df000f04 	addi	fp,sp,60
81136238:	e13ffd15 	stw	r4,-12(fp)
8113623c:	e17ffe15 	stw	r5,-8(fp)
81136240:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81136244:	e0bffe17 	ldw	r2,-8(fp)
81136248:	10800104 	addi	r2,r2,4
8113624c:	10800037 	ldwio	r2,0(r2)
81136250:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
81136254:	e0bff617 	ldw	r2,-40(fp)
81136258:	1004d43a 	srli	r2,r2,16
8113625c:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
81136260:	e0bff617 	ldw	r2,-40(fp)
81136264:	1080008c 	andi	r2,r2,2
81136268:	1004d07a 	srli	r2,r2,1
8113626c:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
81136270:	e0bff617 	ldw	r2,-40(fp)
81136274:	1080004c 	andi	r2,r2,1
81136278:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
8113627c:	e0bff617 	ldw	r2,-40(fp)
81136280:	1080400c 	andi	r2,r2,256
81136284:	1004d23a 	srli	r2,r2,8
81136288:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
8113628c:	e0bff617 	ldw	r2,-40(fp)
81136290:	1080800c 	andi	r2,r2,512
81136294:	1004d27a 	srli	r2,r2,9
81136298:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
8113629c:	e0bff617 	ldw	r2,-40(fp)
811362a0:	1081000c 	andi	r2,r2,1024
811362a4:	1004d2ba 	srli	r2,r2,10
811362a8:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
811362ac:	e0bffd17 	ldw	r2,-12(fp)
811362b0:	10c01017 	ldw	r3,64(r2)
811362b4:	e0bffd17 	ldw	r2,-12(fp)
811362b8:	10800f17 	ldw	r2,60(r2)
811362bc:	1887c83a 	sub	r3,r3,r2
811362c0:	e0bff917 	ldw	r2,-28(fp)
811362c4:	d8800415 	stw	r2,16(sp)
811362c8:	e0bff817 	ldw	r2,-32(fp)
811362cc:	d8800315 	stw	r2,12(sp)
811362d0:	e0bffa17 	ldw	r2,-24(fp)
811362d4:	d8800215 	stw	r2,8(sp)
811362d8:	e0bffb17 	ldw	r2,-20(fp)
811362dc:	d8800115 	stw	r2,4(sp)
811362e0:	e0bffc17 	ldw	r2,-16(fp)
811362e4:	d8800015 	stw	r2,0(sp)
811362e8:	e1fff717 	ldw	r7,-36(fp)
811362ec:	180d883a 	mov	r6,r3
811362f0:	e17fff17 	ldw	r5,-4(fp)
811362f4:	01204574 	movhi	r4,33045
811362f8:	213f7a04 	addi	r4,r4,-536
811362fc:	11361200 	call	81136120 <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
81136300:	0001883a 	nop

}
81136304:	e037883a 	mov	sp,fp
81136308:	dfc00117 	ldw	ra,4(sp)
8113630c:	df000017 	ldw	fp,0(sp)
81136310:	dec00204 	addi	sp,sp,8
81136314:	f800283a 	ret

81136318 <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
81136318:	defffb04 	addi	sp,sp,-20
8113631c:	de00012e 	bgeu	sp,et,81136324 <alt_log_jtag_uart_startup_info+0xc>
81136320:	003b68fa 	trap	3
81136324:	dfc00415 	stw	ra,16(sp)
81136328:	df000315 	stw	fp,12(sp)
8113632c:	df000304 	addi	fp,sp,12
81136330:	e13ffe15 	stw	r4,-8(fp)
81136334:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
81136338:	00a04574 	movhi	r2,33045
8113633c:	10bf8c04 	addi	r2,r2,-464
81136340:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
81136344:	e1bffd17 	ldw	r6,-12(fp)
81136348:	e17fff17 	ldw	r5,-4(fp)
8113634c:	e13ffe17 	ldw	r4,-8(fp)
81136350:	11362200 	call	81136220 <alt_log_jtag_uart_print_control_reg>
     return;
81136354:	0001883a 	nop
}
81136358:	e037883a 	mov	sp,fp
8113635c:	dfc00117 	ldw	ra,4(sp)
81136360:	df000017 	ldw	fp,0(sp)
81136364:	dec00204 	addi	sp,sp,8
81136368:	f800283a 	ret

8113636c <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
8113636c:	defffb04 	addi	sp,sp,-20
81136370:	de00012e 	bgeu	sp,et,81136378 <alt_log_jtag_uart_isr_proc+0xc>
81136374:	003b68fa 	trap	3
81136378:	dfc00415 	stw	ra,16(sp)
8113637c:	df000315 	stw	fp,12(sp)
81136380:	df000304 	addi	fp,sp,12
81136384:	e13ffe15 	stw	r4,-8(fp)
81136388:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
8113638c:	d0a080c3 	ldbu	r2,-32253(gp)
81136390:	10803fcc 	andi	r2,r2,255
81136394:	10000826 	beq	r2,zero,811363b8 <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
81136398:	00a04574 	movhi	r2,33045
8113639c:	10bf9104 	addi	r2,r2,-444
811363a0:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
811363a4:	e1bffd17 	ldw	r6,-12(fp)
811363a8:	e17ffe17 	ldw	r5,-8(fp)
811363ac:	e13fff17 	ldw	r4,-4(fp)
811363b0:	11362200 	call	81136220 <alt_log_jtag_uart_print_control_reg>
    }
    return;
811363b4:	0001883a 	nop
811363b8:	0001883a 	nop
}
811363bc:	e037883a 	mov	sp,fp
811363c0:	dfc00117 	ldw	ra,4(sp)
811363c4:	df000017 	ldw	fp,0(sp)
811363c8:	dec00204 	addi	sp,sp,8
811363cc:	f800283a 	ret

811363d0 <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
811363d0:	defffa04 	addi	sp,sp,-24
811363d4:	de00012e 	bgeu	sp,et,811363dc <alt_log_write+0xc>
811363d8:	003b68fa 	trap	3
811363dc:	dfc00515 	stw	ra,20(sp)
811363e0:	df000415 	stw	fp,16(sp)
811363e4:	df000404 	addi	fp,sp,16
811363e8:	e13ffe15 	stw	r4,-8(fp)
811363ec:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
811363f0:	d0a08003 	ldbu	r2,-32256(gp)
811363f4:	10803fcc 	andi	r2,r2,255
811363f8:	10004026 	beq	r2,zero,811364fc <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
811363fc:	e0bfff17 	ldw	r2,-4(fp)
81136400:	10c00430 	cmpltui	r3,r2,16
81136404:	1800011e 	bne	r3,zero,8113640c <alt_log_write+0x3c>
81136408:	008003c4 	movi	r2,15
8113640c:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
81136410:	e0bffd17 	ldw	r2,-12(fp)
81136414:	10800088 	cmpgei	r2,r2,2
81136418:	10003726 	beq	r2,zero,811364f8 <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
8113641c:	e0bffd17 	ldw	r2,-12(fp)
81136420:	100d883a 	mov	r6,r2
81136424:	e17ffe17 	ldw	r5,-8(fp)
81136428:	012045b4 	movhi	r4,33046
8113642c:	21176d04 	addi	r4,r4,23988
81136430:	114a39c0 	call	8114a39c <strncpy>
    alt_log_write_buf[length-1]='\n';
81136434:	e0bffd17 	ldw	r2,-12(fp)
81136438:	10ffffc4 	addi	r3,r2,-1
8113643c:	00a045b4 	movhi	r2,33046
81136440:	10976d04 	addi	r2,r2,23988
81136444:	10c5883a 	add	r2,r2,r3
81136448:	00c00284 	movi	r3,10
8113644c:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
81136450:	00a045b4 	movhi	r2,33046
81136454:	10976d04 	addi	r2,r2,23988
81136458:	e0fffd17 	ldw	r3,-12(fp)
8113645c:	10c5883a 	add	r2,r2,r3
81136460:	00c00344 	movi	r3,13
81136464:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
81136468:	e0bffd17 	ldw	r2,-12(fp)
8113646c:	10c00044 	addi	r3,r2,1
81136470:	00a045b4 	movhi	r2,33046
81136474:	10976d04 	addi	r2,r2,23988
81136478:	10c5883a 	add	r2,r2,r3
8113647c:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
81136480:	e03ffc15 	stw	zero,-16(fp)
81136484:	00001306 	br	811364d4 <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
81136488:	00a045b4 	movhi	r2,33046
8113648c:	10976d04 	addi	r2,r2,23988
81136490:	e0fffc17 	ldw	r3,-16(fp)
81136494:	10c5883a 	add	r2,r2,r3
81136498:	10800003 	ldbu	r2,0(r2)
8113649c:	10803fcc 	andi	r2,r2,255
811364a0:	1080201c 	xori	r2,r2,128
811364a4:	10bfe004 	addi	r2,r2,-128
811364a8:	10800118 	cmpnei	r2,r2,4
811364ac:	1000061e 	bne	r2,zero,811364c8 <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
811364b0:	00a045b4 	movhi	r2,33046
811364b4:	10976d04 	addi	r2,r2,23988
811364b8:	e0fffc17 	ldw	r3,-16(fp)
811364bc:	10c5883a 	add	r2,r2,r3
811364c0:	00c01104 	movi	r3,68
811364c4:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
811364c8:	e0bffc17 	ldw	r2,-16(fp)
811364cc:	10800044 	addi	r2,r2,1
811364d0:	e0bffc15 	stw	r2,-16(fp)
811364d4:	e0fffc17 	ldw	r3,-16(fp)
811364d8:	e0bffd17 	ldw	r2,-12(fp)
811364dc:	18bfea16 	blt	r3,r2,81136488 <__reset+0xfb116488>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
811364e0:	016045b4 	movhi	r5,33046
811364e4:	29576d04 	addi	r5,r5,23988
811364e8:	01204574 	movhi	r4,33045
811364ec:	213f9404 	addi	r4,r4,-432
811364f0:	11361200 	call	81136120 <alt_log_printf_proc>
811364f4:	00000106 	br	811364fc <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
811364f8:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
811364fc:	e037883a 	mov	sp,fp
81136500:	dfc00117 	ldw	ra,4(sp)
81136504:	df000017 	ldw	fp,0(sp)
81136508:	dec00204 	addi	sp,sp,8
8113650c:	f800283a 	ret

81136510 <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
81136510:	defffe04 	addi	sp,sp,-8
81136514:	de00012e 	bgeu	sp,et,8113651c <alt_log_system_clock+0xc>
81136518:	003b68fa 	trap	3
8113651c:	dfc00115 	stw	ra,4(sp)
81136520:	df000015 	stw	fp,0(sp)
81136524:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
81136528:	d0a08043 	ldbu	r2,-32255(gp)
8113652c:	10803fcc 	andi	r2,r2,255
81136530:	10000e26 	beq	r2,zero,8113656c <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
81136534:	d0a08317 	ldw	r2,-32244(gp)
81136538:	10800044 	addi	r2,r2,1
8113653c:	d0a08315 	stw	r2,-32244(gp)
81136540:	d0a08717 	ldw	r2,-32228(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
81136544:	d0e08317 	ldw	r3,-32244(gp)
81136548:	10c0082e 	bgeu	r2,r3,8113656c <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
8113654c:	d0208315 	stw	zero,-32244(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
81136550:	d0a08217 	ldw	r2,-32248(gp)
81136554:	10c00044 	addi	r3,r2,1
81136558:	d0e08215 	stw	r3,-32248(gp)
8113655c:	100b883a 	mov	r5,r2
81136560:	01204574 	movhi	r4,33045
81136564:	213f9804 	addi	r4,r4,-416
81136568:	11361200 	call	81136120 <alt_log_printf_proc>
        }
    }
}
8113656c:	0001883a 	nop
81136570:	e037883a 	mov	sp,fp
81136574:	dfc00117 	ldw	ra,4(sp)
81136578:	df000017 	ldw	fp,0(sp)
8113657c:	dec00204 	addi	sp,sp,8
81136580:	f800283a 	ret

81136584 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81136584:	defffe04 	addi	sp,sp,-8
81136588:	de00012e 	bgeu	sp,et,81136590 <alt_get_errno+0xc>
8113658c:	003b68fa 	trap	3
81136590:	dfc00115 	stw	ra,4(sp)
81136594:	df000015 	stw	fp,0(sp)
81136598:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113659c:	d0a01017 	ldw	r2,-32704(gp)
811365a0:	10000326 	beq	r2,zero,811365b0 <alt_get_errno+0x2c>
811365a4:	d0a01017 	ldw	r2,-32704(gp)
811365a8:	103ee83a 	callr	r2
811365ac:	00000106 	br	811365b4 <alt_get_errno+0x30>
811365b0:	d0a07704 	addi	r2,gp,-32292
}
811365b4:	e037883a 	mov	sp,fp
811365b8:	dfc00117 	ldw	ra,4(sp)
811365bc:	df000017 	ldw	fp,0(sp)
811365c0:	dec00204 	addi	sp,sp,8
811365c4:	f800283a 	ret

811365c8 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
811365c8:	defff904 	addi	sp,sp,-28
811365cc:	de00012e 	bgeu	sp,et,811365d4 <lseek+0xc>
811365d0:	003b68fa 	trap	3
811365d4:	dfc00615 	stw	ra,24(sp)
811365d8:	df000515 	stw	fp,20(sp)
811365dc:	df000504 	addi	fp,sp,20
811365e0:	e13ffd15 	stw	r4,-12(fp)
811365e4:	e17ffe15 	stw	r5,-8(fp)
811365e8:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
811365ec:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
811365f0:	e0bffd17 	ldw	r2,-12(fp)
811365f4:	10000616 	blt	r2,zero,81136610 <lseek+0x48>
811365f8:	e0bffd17 	ldw	r2,-12(fp)
811365fc:	10c00324 	muli	r3,r2,12
81136600:	00a04574 	movhi	r2,33045
81136604:	10835104 	addi	r2,r2,3396
81136608:	1885883a 	add	r2,r3,r2
8113660c:	00000106 	br	81136614 <lseek+0x4c>
81136610:	0005883a 	mov	r2,zero
81136614:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
81136618:	e0bffc17 	ldw	r2,-16(fp)
8113661c:	10001026 	beq	r2,zero,81136660 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
81136620:	e0bffc17 	ldw	r2,-16(fp)
81136624:	10800017 	ldw	r2,0(r2)
81136628:	10800717 	ldw	r2,28(r2)
8113662c:	10000926 	beq	r2,zero,81136654 <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
81136630:	e0bffc17 	ldw	r2,-16(fp)
81136634:	10800017 	ldw	r2,0(r2)
81136638:	10800717 	ldw	r2,28(r2)
8113663c:	e1bfff17 	ldw	r6,-4(fp)
81136640:	e17ffe17 	ldw	r5,-8(fp)
81136644:	e13ffc17 	ldw	r4,-16(fp)
81136648:	103ee83a 	callr	r2
8113664c:	e0bffb15 	stw	r2,-20(fp)
81136650:	00000506 	br	81136668 <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
81136654:	00bfde84 	movi	r2,-134
81136658:	e0bffb15 	stw	r2,-20(fp)
8113665c:	00000206 	br	81136668 <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
81136660:	00bfebc4 	movi	r2,-81
81136664:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
81136668:	e0bffb17 	ldw	r2,-20(fp)
8113666c:	1000070e 	bge	r2,zero,8113668c <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
81136670:	11365840 	call	81136584 <alt_get_errno>
81136674:	1007883a 	mov	r3,r2
81136678:	e0bffb17 	ldw	r2,-20(fp)
8113667c:	0085c83a 	sub	r2,zero,r2
81136680:	18800015 	stw	r2,0(r3)
    rc = -1;
81136684:	00bfffc4 	movi	r2,-1
81136688:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
8113668c:	e0bffb17 	ldw	r2,-20(fp)
}
81136690:	e037883a 	mov	sp,fp
81136694:	dfc00117 	ldw	ra,4(sp)
81136698:	df000017 	ldw	fp,0(sp)
8113669c:	dec00204 	addi	sp,sp,8
811366a0:	f800283a 	ret

811366a4 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
811366a4:	defff904 	addi	sp,sp,-28
811366a8:	de00012e 	bgeu	sp,et,811366b0 <alt_main+0xc>
811366ac:	003b68fa 	trap	3
811366b0:	dfc00615 	stw	ra,24(sp)
811366b4:	df000515 	stw	fp,20(sp)
811366b8:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
811366bc:	d0a01217 	ldw	r2,-32696(gp)
811366c0:	10800058 	cmpnei	r2,r2,1
811366c4:	1000031e 	bne	r2,zero,811366d4 <alt_main+0x30>
811366c8:	01204574 	movhi	r4,33045
811366cc:	213f9e04 	addi	r4,r4,-392
811366d0:	11361200 	call	81136120 <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
811366d4:	0009883a 	mov	r4,zero
811366d8:	11411fc0 	call	811411fc <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
811366dc:	d0a01217 	ldw	r2,-32696(gp)
811366e0:	10800058 	cmpnei	r2,r2,1
811366e4:	1000031e 	bne	r2,zero,811366f4 <alt_main+0x50>
811366e8:	01204574 	movhi	r4,33045
811366ec:	213fac04 	addi	r4,r4,-336
811366f0:	11361200 	call	81136120 <alt_log_printf_proc>
  ALT_OS_INIT();
811366f4:	1137c900 	call	81137c90 <OSInit>
811366f8:	01000044 	movi	r4,1
811366fc:	113d9ac0 	call	8113d9ac <OSSemCreate>
81136700:	d0a08a15 	stw	r2,-32216(gp)
81136704:	01000044 	movi	r4,1
81136708:	113d9ac0 	call	8113d9ac <OSSemCreate>
8113670c:	d0a08c15 	stw	r2,-32208(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
81136710:	d0a01217 	ldw	r2,-32696(gp)
81136714:	10800058 	cmpnei	r2,r2,1
81136718:	1000031e 	bne	r2,zero,81136728 <alt_main+0x84>
8113671c:	01204574 	movhi	r4,33045
81136720:	213fba04 	addi	r4,r4,-280
81136724:	11361200 	call	81136120 <alt_log_printf_proc>
81136728:	d0a07e04 	addi	r2,gp,-32264
8113672c:	e0bffc15 	stw	r2,-16(fp)
81136730:	00800044 	movi	r2,1
81136734:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81136738:	e0bffd0b 	ldhu	r2,-12(fp)
8113673c:	1009883a 	mov	r4,r2
81136740:	113d9ac0 	call	8113d9ac <OSSemCreate>
81136744:	1007883a 	mov	r3,r2
81136748:	e0bffc17 	ldw	r2,-16(fp)
8113674c:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
81136750:	d0a01217 	ldw	r2,-32696(gp)
81136754:	10800058 	cmpnei	r2,r2,1
81136758:	1000031e 	bne	r2,zero,81136768 <alt_main+0xc4>
8113675c:	01204574 	movhi	r4,33045
81136760:	213fc804 	addi	r4,r4,-224
81136764:	11361200 	call	81136120 <alt_log_printf_proc>
  alt_sys_init();
81136768:	114123c0 	call	8114123c <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
8113676c:	d0a01217 	ldw	r2,-32696(gp)
81136770:	10800058 	cmpnei	r2,r2,1
81136774:	1000031e 	bne	r2,zero,81136784 <alt_main+0xe0>
81136778:	01204574 	movhi	r4,33045
8113677c:	213fd204 	addi	r4,r4,-184
81136780:	11361200 	call	81136120 <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
81136784:	d0a01217 	ldw	r2,-32696(gp)
81136788:	10800058 	cmpnei	r2,r2,1
8113678c:	1000031e 	bne	r2,zero,8113679c <alt_main+0xf8>
81136790:	01204574 	movhi	r4,33045
81136794:	213fdb04 	addi	r4,r4,-148
81136798:	11361200 	call	81136120 <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
8113679c:	01a04574 	movhi	r6,33045
811367a0:	31bfe304 	addi	r6,r6,-116
811367a4:	01604574 	movhi	r5,33045
811367a8:	297fe804 	addi	r5,r5,-96
811367ac:	01204574 	movhi	r4,33045
811367b0:	213fe804 	addi	r4,r4,-96
811367b4:	1149b2c0 	call	81149b2c <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
811367b8:	d0a01217 	ldw	r2,-32696(gp)
811367bc:	10800058 	cmpnei	r2,r2,1
811367c0:	1000031e 	bne	r2,zero,811367d0 <alt_main+0x12c>
811367c4:	01204574 	movhi	r4,33045
811367c8:	213fec04 	addi	r4,r4,-80
811367cc:	11361200 	call	81136120 <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
811367d0:	d0a08417 	ldw	r2,-32240(gp)
811367d4:	d0e08517 	ldw	r3,-32236(gp)
811367d8:	d1208617 	ldw	r4,-32232(gp)
811367dc:	200d883a 	mov	r6,r4
811367e0:	180b883a 	mov	r5,r3
811367e4:	1009883a 	mov	r4,r2
811367e8:	11173840 	call	81117384 <main>
811367ec:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
811367f0:	01000044 	movi	r4,1
811367f4:	11355d00 	call	811355d0 <close>
  exit (result);
811367f8:	e13ffb17 	ldw	r4,-20(fp)
811367fc:	114a2e00 	call	8114a2e0 <exit>

81136800 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81136800:	defffe04 	addi	sp,sp,-8
81136804:	de00012e 	bgeu	sp,et,8113680c <alt_get_errno+0xc>
81136808:	003b68fa 	trap	3
8113680c:	dfc00115 	stw	ra,4(sp)
81136810:	df000015 	stw	fp,0(sp)
81136814:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81136818:	d0a01017 	ldw	r2,-32704(gp)
8113681c:	10000326 	beq	r2,zero,8113682c <alt_get_errno+0x2c>
81136820:	d0a01017 	ldw	r2,-32704(gp)
81136824:	103ee83a 	callr	r2
81136828:	00000106 	br	81136830 <alt_get_errno+0x30>
8113682c:	d0a07704 	addi	r2,gp,-32292
}
81136830:	e037883a 	mov	sp,fp
81136834:	dfc00117 	ldw	ra,4(sp)
81136838:	df000017 	ldw	fp,0(sp)
8113683c:	dec00204 	addi	sp,sp,8
81136840:	f800283a 	ret

81136844 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
81136844:	defffd04 	addi	sp,sp,-12
81136848:	de00012e 	bgeu	sp,et,81136850 <alt_file_locked+0xc>
8113684c:	003b68fa 	trap	3
81136850:	df000215 	stw	fp,8(sp)
81136854:	df000204 	addi	fp,sp,8
81136858:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
8113685c:	e0bfff17 	ldw	r2,-4(fp)
81136860:	10800217 	ldw	r2,8(r2)
81136864:	10d00034 	orhi	r3,r2,16384
81136868:	e0bfff17 	ldw	r2,-4(fp)
8113686c:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81136870:	e03ffe15 	stw	zero,-8(fp)
81136874:	00001d06 	br	811368ec <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
81136878:	00a04574 	movhi	r2,33045
8113687c:	10835104 	addi	r2,r2,3396
81136880:	e0fffe17 	ldw	r3,-8(fp)
81136884:	18c00324 	muli	r3,r3,12
81136888:	10c5883a 	add	r2,r2,r3
8113688c:	10c00017 	ldw	r3,0(r2)
81136890:	e0bfff17 	ldw	r2,-4(fp)
81136894:	10800017 	ldw	r2,0(r2)
81136898:	1880111e 	bne	r3,r2,811368e0 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
8113689c:	00a04574 	movhi	r2,33045
811368a0:	10835104 	addi	r2,r2,3396
811368a4:	e0fffe17 	ldw	r3,-8(fp)
811368a8:	18c00324 	muli	r3,r3,12
811368ac:	10c5883a 	add	r2,r2,r3
811368b0:	10800204 	addi	r2,r2,8
811368b4:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
811368b8:	1000090e 	bge	r2,zero,811368e0 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
811368bc:	e0bffe17 	ldw	r2,-8(fp)
811368c0:	10c00324 	muli	r3,r2,12
811368c4:	00a04574 	movhi	r2,33045
811368c8:	10835104 	addi	r2,r2,3396
811368cc:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
811368d0:	e0bfff17 	ldw	r2,-4(fp)
811368d4:	18800226 	beq	r3,r2,811368e0 <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
811368d8:	00bffcc4 	movi	r2,-13
811368dc:	00000806 	br	81136900 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
811368e0:	e0bffe17 	ldw	r2,-8(fp)
811368e4:	10800044 	addi	r2,r2,1
811368e8:	e0bffe15 	stw	r2,-8(fp)
811368ec:	d0a00f17 	ldw	r2,-32708(gp)
811368f0:	1007883a 	mov	r3,r2
811368f4:	e0bffe17 	ldw	r2,-8(fp)
811368f8:	18bfdf2e 	bgeu	r3,r2,81136878 <__reset+0xfb116878>
    }
  }
  
  /* The device is not locked */
 
  return 0;
811368fc:	0005883a 	mov	r2,zero
}
81136900:	e037883a 	mov	sp,fp
81136904:	df000017 	ldw	fp,0(sp)
81136908:	dec00104 	addi	sp,sp,4
8113690c:	f800283a 	ret

81136910 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
81136910:	defff604 	addi	sp,sp,-40
81136914:	de00012e 	bgeu	sp,et,8113691c <open+0xc>
81136918:	003b68fa 	trap	3
8113691c:	dfc00915 	stw	ra,36(sp)
81136920:	df000815 	stw	fp,32(sp)
81136924:	df000804 	addi	fp,sp,32
81136928:	e13ffd15 	stw	r4,-12(fp)
8113692c:	e17ffe15 	stw	r5,-8(fp)
81136930:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
81136934:	00bfffc4 	movi	r2,-1
81136938:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
8113693c:	00bffb44 	movi	r2,-19
81136940:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
81136944:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
81136948:	d1600d04 	addi	r5,gp,-32716
8113694c:	e13ffd17 	ldw	r4,-12(fp)
81136950:	114950c0 	call	8114950c <alt_find_dev>
81136954:	e0bff815 	stw	r2,-32(fp)
81136958:	e0bff817 	ldw	r2,-32(fp)
8113695c:	1000051e 	bne	r2,zero,81136974 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
81136960:	e13ffd17 	ldw	r4,-12(fp)
81136964:	11495a40 	call	811495a4 <alt_find_file>
81136968:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
8113696c:	00800044 	movi	r2,1
81136970:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
81136974:	e0bff817 	ldw	r2,-32(fp)
81136978:	10002926 	beq	r2,zero,81136a20 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
8113697c:	e13ff817 	ldw	r4,-32(fp)
81136980:	11496b40 	call	811496b4 <alt_get_fd>
81136984:	e0bff915 	stw	r2,-28(fp)
81136988:	e0bff917 	ldw	r2,-28(fp)
8113698c:	1000030e 	bge	r2,zero,8113699c <open+0x8c>
    {
      status = index;
81136990:	e0bff917 	ldw	r2,-28(fp)
81136994:	e0bffa15 	stw	r2,-24(fp)
81136998:	00002306 	br	81136a28 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
8113699c:	e0bff917 	ldw	r2,-28(fp)
811369a0:	10c00324 	muli	r3,r2,12
811369a4:	00a04574 	movhi	r2,33045
811369a8:	10835104 	addi	r2,r2,3396
811369ac:	1885883a 	add	r2,r3,r2
811369b0:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
811369b4:	e0fffe17 	ldw	r3,-8(fp)
811369b8:	00900034 	movhi	r2,16384
811369bc:	10bfffc4 	addi	r2,r2,-1
811369c0:	1886703a 	and	r3,r3,r2
811369c4:	e0bffc17 	ldw	r2,-16(fp)
811369c8:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
811369cc:	e0bffb17 	ldw	r2,-20(fp)
811369d0:	1000051e 	bne	r2,zero,811369e8 <open+0xd8>
811369d4:	e13ffc17 	ldw	r4,-16(fp)
811369d8:	11368440 	call	81136844 <alt_file_locked>
811369dc:	e0bffa15 	stw	r2,-24(fp)
811369e0:	e0bffa17 	ldw	r2,-24(fp)
811369e4:	10001016 	blt	r2,zero,81136a28 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
811369e8:	e0bff817 	ldw	r2,-32(fp)
811369ec:	10800317 	ldw	r2,12(r2)
811369f0:	10000826 	beq	r2,zero,81136a14 <open+0x104>
811369f4:	e0bff817 	ldw	r2,-32(fp)
811369f8:	10800317 	ldw	r2,12(r2)
811369fc:	e1ffff17 	ldw	r7,-4(fp)
81136a00:	e1bffe17 	ldw	r6,-8(fp)
81136a04:	e17ffd17 	ldw	r5,-12(fp)
81136a08:	e13ffc17 	ldw	r4,-16(fp)
81136a0c:	103ee83a 	callr	r2
81136a10:	00000106 	br	81136a18 <open+0x108>
81136a14:	0005883a 	mov	r2,zero
81136a18:	e0bffa15 	stw	r2,-24(fp)
81136a1c:	00000206 	br	81136a28 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
81136a20:	00bffb44 	movi	r2,-19
81136a24:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
81136a28:	e0bffa17 	ldw	r2,-24(fp)
81136a2c:	1000090e 	bge	r2,zero,81136a54 <open+0x144>
  {
    alt_release_fd (index);  
81136a30:	e13ff917 	ldw	r4,-28(fp)
81136a34:	1136bb40 	call	81136bb4 <alt_release_fd>
    ALT_ERRNO = -status;
81136a38:	11368000 	call	81136800 <alt_get_errno>
81136a3c:	1007883a 	mov	r3,r2
81136a40:	e0bffa17 	ldw	r2,-24(fp)
81136a44:	0085c83a 	sub	r2,zero,r2
81136a48:	18800015 	stw	r2,0(r3)
    return -1;
81136a4c:	00bfffc4 	movi	r2,-1
81136a50:	00000106 	br	81136a58 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
81136a54:	e0bff917 	ldw	r2,-28(fp)
}
81136a58:	e037883a 	mov	sp,fp
81136a5c:	dfc00117 	ldw	ra,4(sp)
81136a60:	df000017 	ldw	fp,0(sp)
81136a64:	dec00204 	addi	sp,sp,8
81136a68:	f800283a 	ret

81136a6c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81136a6c:	defffe04 	addi	sp,sp,-8
81136a70:	de00012e 	bgeu	sp,et,81136a78 <alt_get_errno+0xc>
81136a74:	003b68fa 	trap	3
81136a78:	dfc00115 	stw	ra,4(sp)
81136a7c:	df000015 	stw	fp,0(sp)
81136a80:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81136a84:	d0a01017 	ldw	r2,-32704(gp)
81136a88:	10000326 	beq	r2,zero,81136a98 <alt_get_errno+0x2c>
81136a8c:	d0a01017 	ldw	r2,-32704(gp)
81136a90:	103ee83a 	callr	r2
81136a94:	00000106 	br	81136a9c <alt_get_errno+0x30>
81136a98:	d0a07704 	addi	r2,gp,-32292
}
81136a9c:	e037883a 	mov	sp,fp
81136aa0:	dfc00117 	ldw	ra,4(sp)
81136aa4:	df000017 	ldw	fp,0(sp)
81136aa8:	dec00204 	addi	sp,sp,8
81136aac:	f800283a 	ret

81136ab0 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
81136ab0:	defff904 	addi	sp,sp,-28
81136ab4:	de00012e 	bgeu	sp,et,81136abc <read+0xc>
81136ab8:	003b68fa 	trap	3
81136abc:	dfc00615 	stw	ra,24(sp)
81136ac0:	df000515 	stw	fp,20(sp)
81136ac4:	df000504 	addi	fp,sp,20
81136ac8:	e13ffd15 	stw	r4,-12(fp)
81136acc:	e17ffe15 	stw	r5,-8(fp)
81136ad0:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81136ad4:	e0bffd17 	ldw	r2,-12(fp)
81136ad8:	10000616 	blt	r2,zero,81136af4 <read+0x44>
81136adc:	e0bffd17 	ldw	r2,-12(fp)
81136ae0:	10c00324 	muli	r3,r2,12
81136ae4:	00a04574 	movhi	r2,33045
81136ae8:	10835104 	addi	r2,r2,3396
81136aec:	1885883a 	add	r2,r3,r2
81136af0:	00000106 	br	81136af8 <read+0x48>
81136af4:	0005883a 	mov	r2,zero
81136af8:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81136afc:	e0bffb17 	ldw	r2,-20(fp)
81136b00:	10002226 	beq	r2,zero,81136b8c <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81136b04:	e0bffb17 	ldw	r2,-20(fp)
81136b08:	10800217 	ldw	r2,8(r2)
81136b0c:	108000cc 	andi	r2,r2,3
81136b10:	10800060 	cmpeqi	r2,r2,1
81136b14:	1000181e 	bne	r2,zero,81136b78 <read+0xc8>
        (fd->dev->read))
81136b18:	e0bffb17 	ldw	r2,-20(fp)
81136b1c:	10800017 	ldw	r2,0(r2)
81136b20:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81136b24:	10001426 	beq	r2,zero,81136b78 <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
81136b28:	e0bffb17 	ldw	r2,-20(fp)
81136b2c:	10800017 	ldw	r2,0(r2)
81136b30:	10800517 	ldw	r2,20(r2)
81136b34:	e0ffff17 	ldw	r3,-4(fp)
81136b38:	180d883a 	mov	r6,r3
81136b3c:	e17ffe17 	ldw	r5,-8(fp)
81136b40:	e13ffb17 	ldw	r4,-20(fp)
81136b44:	103ee83a 	callr	r2
81136b48:	e0bffc15 	stw	r2,-16(fp)
81136b4c:	e0bffc17 	ldw	r2,-16(fp)
81136b50:	1000070e 	bge	r2,zero,81136b70 <read+0xc0>
        {
          ALT_ERRNO = -rval;
81136b54:	1136a6c0 	call	81136a6c <alt_get_errno>
81136b58:	1007883a 	mov	r3,r2
81136b5c:	e0bffc17 	ldw	r2,-16(fp)
81136b60:	0085c83a 	sub	r2,zero,r2
81136b64:	18800015 	stw	r2,0(r3)
          return -1;
81136b68:	00bfffc4 	movi	r2,-1
81136b6c:	00000c06 	br	81136ba0 <read+0xf0>
        }
        return rval;
81136b70:	e0bffc17 	ldw	r2,-16(fp)
81136b74:	00000a06 	br	81136ba0 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
81136b78:	1136a6c0 	call	81136a6c <alt_get_errno>
81136b7c:	1007883a 	mov	r3,r2
81136b80:	00800344 	movi	r2,13
81136b84:	18800015 	stw	r2,0(r3)
81136b88:	00000406 	br	81136b9c <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
81136b8c:	1136a6c0 	call	81136a6c <alt_get_errno>
81136b90:	1007883a 	mov	r3,r2
81136b94:	00801444 	movi	r2,81
81136b98:	18800015 	stw	r2,0(r3)
  }
  return -1;
81136b9c:	00bfffc4 	movi	r2,-1
}
81136ba0:	e037883a 	mov	sp,fp
81136ba4:	dfc00117 	ldw	ra,4(sp)
81136ba8:	df000017 	ldw	fp,0(sp)
81136bac:	dec00204 	addi	sp,sp,8
81136bb0:	f800283a 	ret

81136bb4 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
81136bb4:	defffe04 	addi	sp,sp,-8
81136bb8:	de00012e 	bgeu	sp,et,81136bc0 <alt_release_fd+0xc>
81136bbc:	003b68fa 	trap	3
81136bc0:	df000115 	stw	fp,4(sp)
81136bc4:	df000104 	addi	fp,sp,4
81136bc8:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
81136bcc:	e0bfff17 	ldw	r2,-4(fp)
81136bd0:	108000d0 	cmplti	r2,r2,3
81136bd4:	10000d1e 	bne	r2,zero,81136c0c <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
81136bd8:	00a04574 	movhi	r2,33045
81136bdc:	10835104 	addi	r2,r2,3396
81136be0:	e0ffff17 	ldw	r3,-4(fp)
81136be4:	18c00324 	muli	r3,r3,12
81136be8:	10c5883a 	add	r2,r2,r3
81136bec:	10800204 	addi	r2,r2,8
81136bf0:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
81136bf4:	00a04574 	movhi	r2,33045
81136bf8:	10835104 	addi	r2,r2,3396
81136bfc:	e0ffff17 	ldw	r3,-4(fp)
81136c00:	18c00324 	muli	r3,r3,12
81136c04:	10c5883a 	add	r2,r2,r3
81136c08:	10000015 	stw	zero,0(r2)
  }
}
81136c0c:	0001883a 	nop
81136c10:	e037883a 	mov	sp,fp
81136c14:	df000017 	ldw	fp,0(sp)
81136c18:	dec00104 	addi	sp,sp,4
81136c1c:	f800283a 	ret

81136c20 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
81136c20:	defff604 	addi	sp,sp,-40
81136c24:	de00012e 	bgeu	sp,et,81136c2c <sbrk+0xc>
81136c28:	003b68fa 	trap	3
81136c2c:	df000915 	stw	fp,36(sp)
81136c30:	df000904 	addi	fp,sp,36
81136c34:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136c38:	0005303a 	rdctl	r2,status
81136c3c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136c40:	e0fffe17 	ldw	r3,-8(fp)
81136c44:	00bfff84 	movi	r2,-2
81136c48:	1884703a 	and	r2,r3,r2
81136c4c:	1001703a 	wrctl	status,r2
  
  return context;
81136c50:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
81136c54:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
81136c58:	d0a01317 	ldw	r2,-32692(gp)
81136c5c:	10c000c4 	addi	r3,r2,3
81136c60:	00bfff04 	movi	r2,-4
81136c64:	1884703a 	and	r2,r3,r2
81136c68:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
81136c6c:	d0e01317 	ldw	r3,-32692(gp)
81136c70:	e0bfff17 	ldw	r2,-4(fp)
81136c74:	1887883a 	add	r3,r3,r2
81136c78:	00a04834 	movhi	r2,33056
81136c7c:	10a80004 	addi	r2,r2,-24576
81136c80:	10c0062e 	bgeu	r2,r3,81136c9c <sbrk+0x7c>
81136c84:	e0bff817 	ldw	r2,-32(fp)
81136c88:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136c8c:	e0bff717 	ldw	r2,-36(fp)
81136c90:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
81136c94:	00bfffc4 	movi	r2,-1
81136c98:	00001c06 	br	81136d0c <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
81136c9c:	d0a01317 	ldw	r2,-32692(gp)
81136ca0:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
81136ca4:	d0e01317 	ldw	r3,-32692(gp)
81136ca8:	e0bfff17 	ldw	r2,-4(fp)
81136cac:	1885883a 	add	r2,r3,r2
81136cb0:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
81136cb4:	c005883a 	mov	r2,et
81136cb8:	e0bff915 	stw	r2,-28(fp)

  return limit; 
81136cbc:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
81136cc0:	e0bffa17 	ldw	r2,-24(fp)
81136cc4:	18800c1e 	bne	r3,r2,81136cf8 <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
81136cc8:	d805883a 	mov	r2,sp
81136ccc:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
81136cd0:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
81136cd4:	d0e01317 	ldw	r3,-32692(gp)
81136cd8:	18800136 	bltu	r3,r2,81136ce0 <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
81136cdc:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
81136ce0:	d0a01317 	ldw	r2,-32692(gp)
81136ce4:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
81136ce8:	e0bffc17 	ldw	r2,-16(fp)
81136cec:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
81136cf0:	e0bffc17 	ldw	r2,-16(fp)
81136cf4:	1031883a 	mov	et,r2
81136cf8:	e0bff817 	ldw	r2,-32(fp)
81136cfc:	e0bffd15 	stw	r2,-12(fp)
81136d00:	e0bffd17 	ldw	r2,-12(fp)
81136d04:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
81136d08:	e0bffa17 	ldw	r2,-24(fp)
} 
81136d0c:	e037883a 	mov	sp,fp
81136d10:	df000017 	ldw	fp,0(sp)
81136d14:	dec00104 	addi	sp,sp,4
81136d18:	f800283a 	ret

81136d1c <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
81136d1c:	defffa04 	addi	sp,sp,-24
81136d20:	de00012e 	bgeu	sp,et,81136d28 <alt_alarm_stop+0xc>
81136d24:	003b68fa 	trap	3
81136d28:	df000515 	stw	fp,20(sp)
81136d2c:	df000504 	addi	fp,sp,20
81136d30:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136d34:	0005303a 	rdctl	r2,status
81136d38:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136d3c:	e0fffc17 	ldw	r3,-16(fp)
81136d40:	00bfff84 	movi	r2,-2
81136d44:	1884703a 	and	r2,r3,r2
81136d48:	1001703a 	wrctl	status,r2
  
  return context;
81136d4c:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
81136d50:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
81136d54:	e0bfff17 	ldw	r2,-4(fp)
81136d58:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
81136d5c:	e0bffd17 	ldw	r2,-12(fp)
81136d60:	10800017 	ldw	r2,0(r2)
81136d64:	e0fffd17 	ldw	r3,-12(fp)
81136d68:	18c00117 	ldw	r3,4(r3)
81136d6c:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
81136d70:	e0bffd17 	ldw	r2,-12(fp)
81136d74:	10800117 	ldw	r2,4(r2)
81136d78:	e0fffd17 	ldw	r3,-12(fp)
81136d7c:	18c00017 	ldw	r3,0(r3)
81136d80:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
81136d84:	e0bffd17 	ldw	r2,-12(fp)
81136d88:	e0fffd17 	ldw	r3,-12(fp)
81136d8c:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
81136d90:	e0bffd17 	ldw	r2,-12(fp)
81136d94:	e0fffd17 	ldw	r3,-12(fp)
81136d98:	10c00015 	stw	r3,0(r2)
81136d9c:	e0bffb17 	ldw	r2,-20(fp)
81136da0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136da4:	e0bffe17 	ldw	r2,-8(fp)
81136da8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
81136dac:	0001883a 	nop
81136db0:	e037883a 	mov	sp,fp
81136db4:	df000017 	ldw	fp,0(sp)
81136db8:	dec00104 	addi	sp,sp,4
81136dbc:	f800283a 	ret

81136dc0 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
81136dc0:	defffb04 	addi	sp,sp,-20
81136dc4:	de00012e 	bgeu	sp,et,81136dcc <alt_tick+0xc>
81136dc8:	003b68fa 	trap	3
81136dcc:	dfc00415 	stw	ra,16(sp)
81136dd0:	df000315 	stw	fp,12(sp)
81136dd4:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
81136dd8:	d0a01417 	ldw	r2,-32688(gp)
81136ddc:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
81136de0:	d0a08817 	ldw	r2,-32224(gp)
81136de4:	10800044 	addi	r2,r2,1
81136de8:	d0a08815 	stw	r2,-32224(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81136dec:	00002e06 	br	81136ea8 <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
81136df0:	e0bffd17 	ldw	r2,-12(fp)
81136df4:	10800017 	ldw	r2,0(r2)
81136df8:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
81136dfc:	e0bffd17 	ldw	r2,-12(fp)
81136e00:	10800403 	ldbu	r2,16(r2)
81136e04:	10803fcc 	andi	r2,r2,255
81136e08:	10000426 	beq	r2,zero,81136e1c <alt_tick+0x5c>
81136e0c:	d0a08817 	ldw	r2,-32224(gp)
81136e10:	1000021e 	bne	r2,zero,81136e1c <alt_tick+0x5c>
    {
      alarm->rollover = 0;
81136e14:	e0bffd17 	ldw	r2,-12(fp)
81136e18:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
81136e1c:	e0bffd17 	ldw	r2,-12(fp)
81136e20:	10800217 	ldw	r2,8(r2)
81136e24:	d0e08817 	ldw	r3,-32224(gp)
81136e28:	18801d36 	bltu	r3,r2,81136ea0 <alt_tick+0xe0>
81136e2c:	e0bffd17 	ldw	r2,-12(fp)
81136e30:	10800403 	ldbu	r2,16(r2)
81136e34:	10803fcc 	andi	r2,r2,255
81136e38:	1000191e 	bne	r2,zero,81136ea0 <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
81136e3c:	e0bffd17 	ldw	r2,-12(fp)
81136e40:	10800317 	ldw	r2,12(r2)
81136e44:	e0fffd17 	ldw	r3,-12(fp)
81136e48:	18c00517 	ldw	r3,20(r3)
81136e4c:	1809883a 	mov	r4,r3
81136e50:	103ee83a 	callr	r2
81136e54:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
81136e58:	e0bfff17 	ldw	r2,-4(fp)
81136e5c:	1000031e 	bne	r2,zero,81136e6c <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
81136e60:	e13ffd17 	ldw	r4,-12(fp)
81136e64:	1136d1c0 	call	81136d1c <alt_alarm_stop>
81136e68:	00000d06 	br	81136ea0 <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
81136e6c:	e0bffd17 	ldw	r2,-12(fp)
81136e70:	10c00217 	ldw	r3,8(r2)
81136e74:	e0bfff17 	ldw	r2,-4(fp)
81136e78:	1887883a 	add	r3,r3,r2
81136e7c:	e0bffd17 	ldw	r2,-12(fp)
81136e80:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
81136e84:	e0bffd17 	ldw	r2,-12(fp)
81136e88:	10c00217 	ldw	r3,8(r2)
81136e8c:	d0a08817 	ldw	r2,-32224(gp)
81136e90:	1880032e 	bgeu	r3,r2,81136ea0 <alt_tick+0xe0>
        {
          alarm->rollover = 1;
81136e94:	e0bffd17 	ldw	r2,-12(fp)
81136e98:	00c00044 	movi	r3,1
81136e9c:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
81136ea0:	e0bffe17 	ldw	r2,-8(fp)
81136ea4:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81136ea8:	e0fffd17 	ldw	r3,-12(fp)
81136eac:	d0a01404 	addi	r2,gp,-32688
81136eb0:	18bfcf1e 	bne	r3,r2,81136df0 <__reset+0xfb116df0>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
81136eb4:	11380f00 	call	811380f0 <OSTimeTick>
}
81136eb8:	0001883a 	nop
81136ebc:	e037883a 	mov	sp,fp
81136ec0:	dfc00117 	ldw	ra,4(sp)
81136ec4:	df000017 	ldw	fp,0(sp)
81136ec8:	dec00204 	addi	sp,sp,8
81136ecc:	f800283a 	ret

81136ed0 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
81136ed0:	defffb04 	addi	sp,sp,-20
81136ed4:	de00012e 	bgeu	sp,et,81136edc <usleep+0xc>
81136ed8:	003b68fa 	trap	3
81136edc:	dfc00415 	stw	ra,16(sp)
81136ee0:	df000315 	stw	fp,12(sp)
81136ee4:	df000304 	addi	fp,sp,12
81136ee8:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
81136eec:	d0a09003 	ldbu	r2,-32192(gp)
81136ef0:	10803fcc 	andi	r2,r2,255
81136ef4:	1000031e 	bne	r2,zero,81136f04 <usleep+0x34>
  {
    return alt_busy_sleep (us);
81136ef8:	e13fff17 	ldw	r4,-4(fp)
81136efc:	113545c0 	call	8113545c <alt_busy_sleep>
81136f00:	00003d06 	br	81136ff8 <usleep+0x128>
81136f04:	d0a08717 	ldw	r2,-32228(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
81136f08:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
81136f0c:	e0ffff17 	ldw	r3,-4(fp)
81136f10:	0090c734 	movhi	r2,17180
81136f14:	10b7a0c4 	addi	r2,r2,-8573
81136f18:	1888383a 	mulxuu	r4,r3,r2
81136f1c:	1885383a 	mul	r2,r3,r2
81136f20:	1013883a 	mov	r9,r2
81136f24:	2015883a 	mov	r10,r4
81136f28:	5006d4ba 	srli	r3,r10,18
81136f2c:	e0bffe17 	ldw	r2,-8(fp)
81136f30:	1893383a 	mul	r9,r3,r2
81136f34:	e0ffff17 	ldw	r3,-4(fp)
81136f38:	0090c734 	movhi	r2,17180
81136f3c:	10b7a0c4 	addi	r2,r2,-8573
81136f40:	1888383a 	mulxuu	r4,r3,r2
81136f44:	1885383a 	mul	r2,r3,r2
81136f48:	100f883a 	mov	r7,r2
81136f4c:	2011883a 	mov	r8,r4
81136f50:	4004d4ba 	srli	r2,r8,18
81136f54:	010003f4 	movhi	r4,15
81136f58:	21109004 	addi	r4,r4,16960
81136f5c:	1105383a 	mul	r2,r2,r4
81136f60:	1885c83a 	sub	r2,r3,r2
81136f64:	e0fffe17 	ldw	r3,-8(fp)
81136f68:	10c7383a 	mul	r3,r2,r3
81136f6c:	0090c734 	movhi	r2,17180
81136f70:	10b7a0c4 	addi	r2,r2,-8573
81136f74:	1888383a 	mulxuu	r4,r3,r2
81136f78:	1885383a 	mul	r2,r3,r2
81136f7c:	100b883a 	mov	r5,r2
81136f80:	200d883a 	mov	r6,r4
81136f84:	3004d4ba 	srli	r2,r6,18
81136f88:	4885883a 	add	r2,r9,r2
81136f8c:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81136f90:	00000706 	br	81136fb0 <usleep+0xe0>
  {
    OSTimeDly(0xffff);
81136f94:	013fffd4 	movui	r4,65535
81136f98:	113fb600 	call	8113fb60 <OSTimeDly>
    ticks -= 0xffff;
81136f9c:	e0fffd17 	ldw	r3,-12(fp)
81136fa0:	00bffff4 	movhi	r2,65535
81136fa4:	10800044 	addi	r2,r2,1
81136fa8:	1885883a 	add	r2,r3,r2
81136fac:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81136fb0:	e0bffd17 	ldw	r2,-12(fp)
81136fb4:	00ffffd4 	movui	r3,65535
81136fb8:	18bff636 	bltu	r3,r2,81136f94 <__reset+0xfb116f94>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
81136fbc:	e0bffd17 	ldw	r2,-12(fp)
81136fc0:	10bfffcc 	andi	r2,r2,65535
81136fc4:	1009883a 	mov	r4,r2
81136fc8:	113fb600 	call	8113fb60 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
81136fcc:	008003f4 	movhi	r2,15
81136fd0:	10909004 	addi	r2,r2,16960
81136fd4:	e0fffe17 	ldw	r3,-8(fp)
81136fd8:	10c7203a 	divu	r3,r2,r3
81136fdc:	e0bfff17 	ldw	r2,-4(fp)
81136fe0:	10c9203a 	divu	r4,r2,r3
81136fe4:	20c7383a 	mul	r3,r4,r3
81136fe8:	10c5c83a 	sub	r2,r2,r3
81136fec:	1009883a 	mov	r4,r2
81136ff0:	113545c0 	call	8113545c <alt_busy_sleep>

  return 0;  
81136ff4:	0005883a 	mov	r2,zero
}
81136ff8:	e037883a 	mov	sp,fp
81136ffc:	dfc00117 	ldw	ra,4(sp)
81137000:	df000017 	ldw	fp,0(sp)
81137004:	dec00204 	addi	sp,sp,8
81137008:	f800283a 	ret

8113700c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113700c:	defffe04 	addi	sp,sp,-8
81137010:	de00012e 	bgeu	sp,et,81137018 <alt_get_errno+0xc>
81137014:	003b68fa 	trap	3
81137018:	dfc00115 	stw	ra,4(sp)
8113701c:	df000015 	stw	fp,0(sp)
81137020:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81137024:	d0a01017 	ldw	r2,-32704(gp)
81137028:	10000326 	beq	r2,zero,81137038 <alt_get_errno+0x2c>
8113702c:	d0a01017 	ldw	r2,-32704(gp)
81137030:	103ee83a 	callr	r2
81137034:	00000106 	br	8113703c <alt_get_errno+0x30>
81137038:	d0a07704 	addi	r2,gp,-32292
}
8113703c:	e037883a 	mov	sp,fp
81137040:	dfc00117 	ldw	ra,4(sp)
81137044:	df000017 	ldw	fp,0(sp)
81137048:	dec00204 	addi	sp,sp,8
8113704c:	f800283a 	ret

81137050 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
81137050:	defff904 	addi	sp,sp,-28
81137054:	de00012e 	bgeu	sp,et,8113705c <write+0xc>
81137058:	003b68fa 	trap	3
8113705c:	dfc00615 	stw	ra,24(sp)
81137060:	df000515 	stw	fp,20(sp)
81137064:	df000504 	addi	fp,sp,20
81137068:	e13ffd15 	stw	r4,-12(fp)
8113706c:	e17ffe15 	stw	r5,-8(fp)
81137070:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81137074:	e0bffd17 	ldw	r2,-12(fp)
81137078:	10000616 	blt	r2,zero,81137094 <write+0x44>
8113707c:	e0bffd17 	ldw	r2,-12(fp)
81137080:	10c00324 	muli	r3,r2,12
81137084:	00a04574 	movhi	r2,33045
81137088:	10835104 	addi	r2,r2,3396
8113708c:	1885883a 	add	r2,r3,r2
81137090:	00000106 	br	81137098 <write+0x48>
81137094:	0005883a 	mov	r2,zero
81137098:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
8113709c:	e0bffb17 	ldw	r2,-20(fp)
811370a0:	10002426 	beq	r2,zero,81137134 <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
811370a4:	e0bffb17 	ldw	r2,-20(fp)
811370a8:	10800217 	ldw	r2,8(r2)
811370ac:	108000cc 	andi	r2,r2,3
811370b0:	10001b26 	beq	r2,zero,81137120 <write+0xd0>
811370b4:	e0bffb17 	ldw	r2,-20(fp)
811370b8:	10800017 	ldw	r2,0(r2)
811370bc:	10800617 	ldw	r2,24(r2)
811370c0:	10001726 	beq	r2,zero,81137120 <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
811370c4:	e17fff17 	ldw	r5,-4(fp)
811370c8:	e13ffe17 	ldw	r4,-8(fp)
811370cc:	11363d00 	call	811363d0 <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
811370d0:	e0bffb17 	ldw	r2,-20(fp)
811370d4:	10800017 	ldw	r2,0(r2)
811370d8:	10800617 	ldw	r2,24(r2)
811370dc:	e0ffff17 	ldw	r3,-4(fp)
811370e0:	180d883a 	mov	r6,r3
811370e4:	e17ffe17 	ldw	r5,-8(fp)
811370e8:	e13ffb17 	ldw	r4,-20(fp)
811370ec:	103ee83a 	callr	r2
811370f0:	e0bffc15 	stw	r2,-16(fp)
811370f4:	e0bffc17 	ldw	r2,-16(fp)
811370f8:	1000070e 	bge	r2,zero,81137118 <write+0xc8>
      {
        ALT_ERRNO = -rval;
811370fc:	113700c0 	call	8113700c <alt_get_errno>
81137100:	1007883a 	mov	r3,r2
81137104:	e0bffc17 	ldw	r2,-16(fp)
81137108:	0085c83a 	sub	r2,zero,r2
8113710c:	18800015 	stw	r2,0(r3)
        return -1;
81137110:	00bfffc4 	movi	r2,-1
81137114:	00000c06 	br	81137148 <write+0xf8>
      }
      return rval;
81137118:	e0bffc17 	ldw	r2,-16(fp)
8113711c:	00000a06 	br	81137148 <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
81137120:	113700c0 	call	8113700c <alt_get_errno>
81137124:	1007883a 	mov	r3,r2
81137128:	00800344 	movi	r2,13
8113712c:	18800015 	stw	r2,0(r3)
81137130:	00000406 	br	81137144 <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
81137134:	113700c0 	call	8113700c <alt_get_errno>
81137138:	1007883a 	mov	r3,r2
8113713c:	00801444 	movi	r2,81
81137140:	18800015 	stw	r2,0(r3)
  }
  return -1;
81137144:	00bfffc4 	movi	r2,-1
}
81137148:	e037883a 	mov	sp,fp
8113714c:	dfc00117 	ldw	ra,4(sp)
81137150:	df000017 	ldw	fp,0(sp)
81137154:	dec00204 	addi	sp,sp,8
81137158:	f800283a 	ret

8113715c <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
8113715c:	deffde04 	addi	sp,sp,-136
81137160:	de00012e 	bgeu	sp,et,81137168 <__env_lock+0xc>
81137164:	003b68fa 	trap	3
81137168:	dfc02115 	stw	ra,132(sp)
8113716c:	df002015 	stw	fp,128(sp)
81137170:	df002004 	addi	fp,sp,128
81137174:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81137178:	e0bfe104 	addi	r2,fp,-124
8113717c:	100b883a 	mov	r5,r2
81137180:	01003fc4 	movi	r4,255
81137184:	113f9bc0 	call	8113f9bc <OSTaskQuery>
81137188:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
8113718c:	e0bffe83 	ldbu	r2,-6(fp)
81137190:	10803fcc 	andi	r2,r2,255
81137194:	10001e1e 	bne	r2,zero,81137210 <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
81137198:	e0bfed83 	ldbu	r2,-74(fp)
8113719c:	10803fcc 	andi	r2,r2,255
811371a0:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
811371a4:	d0a08a17 	ldw	r2,-32216(gp)
811371a8:	e0fffc04 	addi	r3,fp,-16
811371ac:	180b883a 	mov	r5,r3
811371b0:	1009883a 	mov	r4,r2
811371b4:	113e1740 	call	8113e174 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
811371b8:	e0bffe03 	ldbu	r2,-8(fp)
811371bc:	10803fcc 	andi	r2,r2,255
811371c0:	10000726 	beq	r2,zero,811371e0 <__env_lock+0x84>
811371c4:	d0a01617 	ldw	r2,-32680(gp)
811371c8:	e0ffe017 	ldw	r3,-128(fp)
811371cc:	1880041e 	bne	r3,r2,811371e0 <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
811371d0:	d0a08917 	ldw	r2,-32220(gp)
811371d4:	10800044 	addi	r2,r2,1
811371d8:	d0a08915 	stw	r2,-32220(gp)
811371dc:	00000a06 	br	81137208 <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
811371e0:	d0a08a17 	ldw	r2,-32216(gp)
811371e4:	e0fffe84 	addi	r3,fp,-6
811371e8:	180d883a 	mov	r6,r3
811371ec:	000b883a 	mov	r5,zero
811371f0:	1009883a 	mov	r4,r2
811371f4:	113dcd40 	call	8113dcd4 <OSSemPend>
    locks  = 1;
811371f8:	00800044 	movi	r2,1
811371fc:	d0a08915 	stw	r2,-32220(gp)
    lockid = id;
81137200:	e0bfe017 	ldw	r2,-128(fp)
81137204:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81137208:	0001883a 	nop
8113720c:	00000106 	br	81137214 <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81137210:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81137214:	e037883a 	mov	sp,fp
81137218:	dfc00117 	ldw	ra,4(sp)
8113721c:	df000017 	ldw	fp,0(sp)
81137220:	dec00204 	addi	sp,sp,8
81137224:	f800283a 	ret

81137228 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
81137228:	defffd04 	addi	sp,sp,-12
8113722c:	de00012e 	bgeu	sp,et,81137234 <__env_unlock+0xc>
81137230:	003b68fa 	trap	3
81137234:	dfc00215 	stw	ra,8(sp)
81137238:	df000115 	stw	fp,4(sp)
8113723c:	df000104 	addi	fp,sp,4
81137240:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
81137244:	d0a08917 	ldw	r2,-32220(gp)
81137248:	10000b26 	beq	r2,zero,81137278 <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
8113724c:	d0a08917 	ldw	r2,-32220(gp)
81137250:	10bfffc4 	addi	r2,r2,-1
81137254:	d0a08915 	stw	r2,-32220(gp)
81137258:	d0a08917 	ldw	r2,-32220(gp)
8113725c:	1000071e 	bne	r2,zero,8113727c <__env_unlock+0x54>
  {
    lockid = -1;
81137260:	00bfffc4 	movi	r2,-1
81137264:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
81137268:	d0a08a17 	ldw	r2,-32216(gp)
8113726c:	1009883a 	mov	r4,r2
81137270:	113e05c0 	call	8113e05c <OSSemPost>
81137274:	00000106 	br	8113727c <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
81137278:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
8113727c:	e037883a 	mov	sp,fp
81137280:	dfc00117 	ldw	ra,4(sp)
81137284:	df000017 	ldw	fp,0(sp)
81137288:	dec00204 	addi	sp,sp,8
8113728c:	f800283a 	ret

81137290 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
81137290:	deffda04 	addi	sp,sp,-152
81137294:	de00012e 	bgeu	sp,et,8113729c <__malloc_lock+0xc>
81137298:	003b68fa 	trap	3
8113729c:	dfc02515 	stw	ra,148(sp)
811372a0:	df002415 	stw	fp,144(sp)
811372a4:	df002404 	addi	fp,sp,144
811372a8:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811372ac:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
811372b0:	d0a09003 	ldbu	r2,-32192(gp)
811372b4:	10803fcc 	andi	r2,r2,255
811372b8:	10800060 	cmpeqi	r2,r2,1
811372bc:	10003626 	beq	r2,zero,81137398 <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
811372c0:	e0bfe104 	addi	r2,fp,-124
811372c4:	100b883a 	mov	r5,r2
811372c8:	01003fc4 	movi	r4,255
811372cc:	113f9bc0 	call	8113f9bc <OSTaskQuery>
811372d0:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
811372d4:	e0bffe83 	ldbu	r2,-6(fp)
811372d8:	10803fcc 	andi	r2,r2,255
811372dc:	1000301e 	bne	r2,zero,811373a0 <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
811372e0:	e0bfed83 	ldbu	r2,-74(fp)
811372e4:	10803fcc 	andi	r2,r2,255
811372e8:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
811372ec:	d0a08c17 	ldw	r2,-32208(gp)
811372f0:	e0fffc04 	addi	r3,fp,-16
811372f4:	180b883a 	mov	r5,r3
811372f8:	1009883a 	mov	r4,r2
811372fc:	113e1740 	call	8113e174 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137300:	0005303a 	rdctl	r2,status
81137304:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137308:	e0ffe017 	ldw	r3,-128(fp)
8113730c:	00bfff84 	movi	r2,-2
81137310:	1884703a 	and	r2,r3,r2
81137314:	1001703a 	wrctl	status,r2
  
  return context;
81137318:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
8113731c:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
81137320:	e0bffc0b 	ldhu	r2,-16(fp)
81137324:	10bfffcc 	andi	r2,r2,65535
81137328:	10000b1e 	bne	r2,zero,81137358 <__malloc_lock+0xc8>
8113732c:	d0a01717 	ldw	r2,-32676(gp)
81137330:	e0ffdd17 	ldw	r3,-140(fp)
81137334:	1880081e 	bne	r3,r2,81137358 <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
81137338:	d0a08b17 	ldw	r2,-32212(gp)
8113733c:	10800044 	addi	r2,r2,1
81137340:	d0a08b15 	stw	r2,-32212(gp)
81137344:	e0bfdc17 	ldw	r2,-144(fp)
81137348:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113734c:	e0bfde17 	ldw	r2,-136(fp)
81137350:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
81137354:	00000e06 	br	81137390 <__malloc_lock+0x100>
81137358:	e0bfdc17 	ldw	r2,-144(fp)
8113735c:	e0bfdf15 	stw	r2,-132(fp)
81137360:	e0bfdf17 	ldw	r2,-132(fp)
81137364:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
81137368:	d0a08c17 	ldw	r2,-32208(gp)
8113736c:	e0fffe84 	addi	r3,fp,-6
81137370:	180d883a 	mov	r6,r3
81137374:	000b883a 	mov	r5,zero
81137378:	1009883a 	mov	r4,r2
8113737c:	113dcd40 	call	8113dcd4 <OSSemPend>
    locks  = 1;
81137380:	00800044 	movi	r2,1
81137384:	d0a08b15 	stw	r2,-32212(gp)
    lockid = id;
81137388:	e0bfdd17 	ldw	r2,-140(fp)
8113738c:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81137390:	0001883a 	nop
81137394:	00000306 	br	811373a4 <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
81137398:	0001883a 	nop
8113739c:	00000106 	br	811373a4 <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
811373a0:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
811373a4:	e037883a 	mov	sp,fp
811373a8:	dfc00117 	ldw	ra,4(sp)
811373ac:	df000017 	ldw	fp,0(sp)
811373b0:	dec00204 	addi	sp,sp,8
811373b4:	f800283a 	ret

811373b8 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
811373b8:	defff804 	addi	sp,sp,-32
811373bc:	de00012e 	bgeu	sp,et,811373c4 <__malloc_unlock+0xc>
811373c0:	003b68fa 	trap	3
811373c4:	dfc00715 	stw	ra,28(sp)
811373c8:	df000615 	stw	fp,24(sp)
811373cc:	df000604 	addi	fp,sp,24
811373d0:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811373d4:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
811373d8:	d0a09003 	ldbu	r2,-32192(gp)
811373dc:	10803fcc 	andi	r2,r2,255
811373e0:	10800060 	cmpeqi	r2,r2,1
811373e4:	10002326 	beq	r2,zero,81137474 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811373e8:	0005303a 	rdctl	r2,status
811373ec:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811373f0:	e0fffe17 	ldw	r3,-8(fp)
811373f4:	00bfff84 	movi	r2,-2
811373f8:	1884703a 	and	r2,r3,r2
811373fc:	1001703a 	wrctl	status,r2
  
  return context;
81137400:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
81137404:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
81137408:	d0a08b17 	ldw	r2,-32212(gp)
8113740c:	1000051e 	bne	r2,zero,81137424 <__malloc_unlock+0x6c>
81137410:	e0bffa17 	ldw	r2,-24(fp)
81137414:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137418:	e0bffb17 	ldw	r2,-20(fp)
8113741c:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
81137420:	00001506 	br	81137478 <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
81137424:	d0a08b17 	ldw	r2,-32212(gp)
81137428:	10bfffc4 	addi	r2,r2,-1
8113742c:	d0a08b15 	stw	r2,-32212(gp)
81137430:	d0a08b17 	ldw	r2,-32212(gp)
81137434:	10000a1e 	bne	r2,zero,81137460 <__malloc_unlock+0xa8>
  {
    lockid = -1;
81137438:	00bfffc4 	movi	r2,-1
8113743c:	d0a01715 	stw	r2,-32676(gp)
81137440:	e0bffa17 	ldw	r2,-24(fp)
81137444:	e0bffc15 	stw	r2,-16(fp)
81137448:	e0bffc17 	ldw	r2,-16(fp)
8113744c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
81137450:	d0a08c17 	ldw	r2,-32208(gp)
81137454:	1009883a 	mov	r4,r2
81137458:	113e05c0 	call	8113e05c <OSSemPost>
8113745c:	00000606 	br	81137478 <__malloc_unlock+0xc0>
81137460:	e0bffa17 	ldw	r2,-24(fp)
81137464:	e0bffd15 	stw	r2,-12(fp)
81137468:	e0bffd17 	ldw	r2,-12(fp)
8113746c:	1001703a 	wrctl	status,r2
81137470:	00000106 	br	81137478 <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
81137474:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81137478:	e037883a 	mov	sp,fp
8113747c:	dfc00117 	ldw	ra,4(sp)
81137480:	df000017 	ldw	fp,0(sp)
81137484:	dec00204 	addi	sp,sp,8
81137488:	f800283a 	ret

8113748c <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
8113748c:	defff704 	addi	sp,sp,-36
81137490:	de00012e 	bgeu	sp,et,81137498 <OSEventNameGet+0xc>
81137494:	003b68fa 	trap	3
81137498:	dfc00815 	stw	ra,32(sp)
8113749c:	df000715 	stw	fp,28(sp)
811374a0:	df000704 	addi	fp,sp,28
811374a4:	e13ffd15 	stw	r4,-12(fp)
811374a8:	e17ffe15 	stw	r5,-8(fp)
811374ac:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811374b0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811374b4:	e0bfff17 	ldw	r2,-4(fp)
811374b8:	1000021e 	bne	r2,zero,811374c4 <OSEventNameGet+0x38>
        return (0);
811374bc:	0005883a 	mov	r2,zero
811374c0:	00003706 	br	811375a0 <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
811374c4:	e0bffd17 	ldw	r2,-12(fp)
811374c8:	1000051e 	bne	r2,zero,811374e0 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
811374cc:	e0bfff17 	ldw	r2,-4(fp)
811374d0:	00c00104 	movi	r3,4
811374d4:	10c00005 	stb	r3,0(r2)
        return (0);
811374d8:	0005883a 	mov	r2,zero
811374dc:	00003006 	br	811375a0 <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
811374e0:	e0bffe17 	ldw	r2,-8(fp)
811374e4:	1000051e 	bne	r2,zero,811374fc <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
811374e8:	e0bfff17 	ldw	r2,-4(fp)
811374ec:	00c00304 	movi	r3,12
811374f0:	10c00005 	stb	r3,0(r2)
        return (0);
811374f4:	0005883a 	mov	r2,zero
811374f8:	00002906 	br	811375a0 <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
811374fc:	d0a0a003 	ldbu	r2,-32128(gp)
81137500:	10803fcc 	andi	r2,r2,255
81137504:	10000526 	beq	r2,zero,8113751c <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
81137508:	e0bfff17 	ldw	r2,-4(fp)
8113750c:	00c00444 	movi	r3,17
81137510:	10c00005 	stb	r3,0(r2)
        return (0);
81137514:	0005883a 	mov	r2,zero
81137518:	00002106 	br	811375a0 <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
8113751c:	e0bffd17 	ldw	r2,-12(fp)
81137520:	10800003 	ldbu	r2,0(r2)
81137524:	10803fcc 	andi	r2,r2,255
81137528:	10bfffc4 	addi	r2,r2,-1
8113752c:	10800128 	cmpgeui	r2,r2,4
81137530:	10000526 	beq	r2,zero,81137548 <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81137534:	e0bfff17 	ldw	r2,-4(fp)
81137538:	00c00044 	movi	r3,1
8113753c:	10c00005 	stb	r3,0(r2)
             return (0);
81137540:	0005883a 	mov	r2,zero
81137544:	00001606 	br	811375a0 <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81137548:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113754c:	0005303a 	rdctl	r2,status
81137550:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137554:	e0fffb17 	ldw	r3,-20(fp)
81137558:	00bfff84 	movi	r2,-2
8113755c:	1884703a 	and	r2,r3,r2
81137560:	1001703a 	wrctl	status,r2
  
  return context;
81137564:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
81137568:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
8113756c:	e0bffd17 	ldw	r2,-12(fp)
81137570:	10800444 	addi	r2,r2,17
81137574:	100b883a 	mov	r5,r2
81137578:	e13ffe17 	ldw	r4,-8(fp)
8113757c:	1138f780 	call	81138f78 <OS_StrCopy>
81137580:	e0bffa05 	stb	r2,-24(fp)
81137584:	e0bff917 	ldw	r2,-28(fp)
81137588:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113758c:	e0bffc17 	ldw	r2,-16(fp)
81137590:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81137594:	e0bfff17 	ldw	r2,-4(fp)
81137598:	10000005 	stb	zero,0(r2)
    return (len);
8113759c:	e0bffa03 	ldbu	r2,-24(fp)
}
811375a0:	e037883a 	mov	sp,fp
811375a4:	dfc00117 	ldw	ra,4(sp)
811375a8:	df000017 	ldw	fp,0(sp)
811375ac:	dec00204 	addi	sp,sp,8
811375b0:	f800283a 	ret

811375b4 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
811375b4:	defff604 	addi	sp,sp,-40
811375b8:	de00012e 	bgeu	sp,et,811375c0 <OSEventNameSet+0xc>
811375bc:	003b68fa 	trap	3
811375c0:	dfc00915 	stw	ra,36(sp)
811375c4:	df000815 	stw	fp,32(sp)
811375c8:	df000804 	addi	fp,sp,32
811375cc:	e13ffd15 	stw	r4,-12(fp)
811375d0:	e17ffe15 	stw	r5,-8(fp)
811375d4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811375d8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811375dc:	e0bfff17 	ldw	r2,-4(fp)
811375e0:	10004026 	beq	r2,zero,811376e4 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
811375e4:	e0bffd17 	ldw	r2,-12(fp)
811375e8:	1000041e 	bne	r2,zero,811375fc <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
811375ec:	e0bfff17 	ldw	r2,-4(fp)
811375f0:	00c00104 	movi	r3,4
811375f4:	10c00005 	stb	r3,0(r2)
        return;
811375f8:	00003b06 	br	811376e8 <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
811375fc:	e0bffe17 	ldw	r2,-8(fp)
81137600:	1000041e 	bne	r2,zero,81137614 <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81137604:	e0bfff17 	ldw	r2,-4(fp)
81137608:	00c00304 	movi	r3,12
8113760c:	10c00005 	stb	r3,0(r2)
        return;
81137610:	00003506 	br	811376e8 <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81137614:	d0a0a003 	ldbu	r2,-32128(gp)
81137618:	10803fcc 	andi	r2,r2,255
8113761c:	10000426 	beq	r2,zero,81137630 <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81137620:	e0bfff17 	ldw	r2,-4(fp)
81137624:	00c00484 	movi	r3,18
81137628:	10c00005 	stb	r3,0(r2)
        return;
8113762c:	00002e06 	br	811376e8 <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
81137630:	e0bffd17 	ldw	r2,-12(fp)
81137634:	10800003 	ldbu	r2,0(r2)
81137638:	10803fcc 	andi	r2,r2,255
8113763c:	10bfffc4 	addi	r2,r2,-1
81137640:	10800128 	cmpgeui	r2,r2,4
81137644:	10000426 	beq	r2,zero,81137658 <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81137648:	e0bfff17 	ldw	r2,-4(fp)
8113764c:	00c00044 	movi	r3,1
81137650:	10c00005 	stb	r3,0(r2)
             return;
81137654:	00002406 	br	811376e8 <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81137658:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113765c:	0005303a 	rdctl	r2,status
81137660:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137664:	e0fffc17 	ldw	r3,-16(fp)
81137668:	00bfff84 	movi	r2,-2
8113766c:	1884703a 	and	r2,r3,r2
81137670:	1001703a 	wrctl	status,r2
  
  return context;
81137674:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
81137678:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
8113767c:	e13ffe17 	ldw	r4,-8(fp)
81137680:	1138ff40 	call	81138ff4 <OS_StrLen>
81137684:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
81137688:	e0bffa03 	ldbu	r2,-24(fp)
8113768c:	10800830 	cmpltui	r2,r2,32
81137690:	1000081e 	bne	r2,zero,811376b4 <OSEventNameSet+0x100>
81137694:	e0bff817 	ldw	r2,-32(fp)
81137698:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113769c:	e0bff917 	ldw	r2,-28(fp)
811376a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
811376a4:	e0bfff17 	ldw	r2,-4(fp)
811376a8:	00c002c4 	movi	r3,11
811376ac:	10c00005 	stb	r3,0(r2)
        return;
811376b0:	00000d06 	br	811376e8 <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
811376b4:	e0bffd17 	ldw	r2,-12(fp)
811376b8:	10800444 	addi	r2,r2,17
811376bc:	e17ffe17 	ldw	r5,-8(fp)
811376c0:	1009883a 	mov	r4,r2
811376c4:	1138f780 	call	81138f78 <OS_StrCopy>
811376c8:	e0bff817 	ldw	r2,-32(fp)
811376cc:	e0bffb15 	stw	r2,-20(fp)
811376d0:	e0bffb17 	ldw	r2,-20(fp)
811376d4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811376d8:	e0bfff17 	ldw	r2,-4(fp)
811376dc:	10000005 	stb	zero,0(r2)
811376e0:	00000106 	br	811376e8 <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
811376e4:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
811376e8:	e037883a 	mov	sp,fp
811376ec:	dfc00117 	ldw	ra,4(sp)
811376f0:	df000017 	ldw	fp,0(sp)
811376f4:	dec00204 	addi	sp,sp,8
811376f8:	f800283a 	ret

811376fc <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
811376fc:	deffed04 	addi	sp,sp,-76
81137700:	de00012e 	bgeu	sp,et,81137708 <OSEventPendMulti+0xc>
81137704:	003b68fa 	trap	3
81137708:	dfc01215 	stw	ra,72(sp)
8113770c:	df001115 	stw	fp,68(sp)
81137710:	df001104 	addi	fp,sp,68
81137714:	e13ffc15 	stw	r4,-16(fp)
81137718:	e17ffd15 	stw	r5,-12(fp)
8113771c:	e1bffe15 	stw	r6,-8(fp)
81137720:	3805883a 	mov	r2,r7
81137724:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
81137728:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
8113772c:	e0800217 	ldw	r2,8(fp)
81137730:	1000021e 	bne	r2,zero,8113773c <OSEventPendMulti+0x40>
        return (0);
81137734:	0005883a 	mov	r2,zero
81137738:	00015006 	br	81137c7c <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
8113773c:	e0bffc17 	ldw	r2,-16(fp)
81137740:	1000051e 	bne	r2,zero,81137758 <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
81137744:	e0800217 	ldw	r2,8(fp)
81137748:	00c00104 	movi	r3,4
8113774c:	10c00005 	stb	r3,0(r2)
        return (0);
81137750:	0005883a 	mov	r2,zero
81137754:	00014906 	br	81137c7c <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
81137758:	e0bffd17 	ldw	r2,-12(fp)
8113775c:	1000051e 	bne	r2,zero,81137774 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
81137760:	e0800217 	ldw	r2,8(fp)
81137764:	00c00104 	movi	r3,4
81137768:	10c00005 	stb	r3,0(r2)
        return (0);
8113776c:	0005883a 	mov	r2,zero
81137770:	00014206 	br	81137c7c <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
81137774:	e0bffe17 	ldw	r2,-8(fp)
81137778:	1000051e 	bne	r2,zero,81137790 <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
8113777c:	e0800217 	ldw	r2,8(fp)
81137780:	00c00104 	movi	r3,4
81137784:	10c00005 	stb	r3,0(r2)
        return (0);
81137788:	0005883a 	mov	r2,zero
8113778c:	00013b06 	br	81137c7c <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
81137790:	e0bffd17 	ldw	r2,-12(fp)
81137794:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
81137798:	e0bffc17 	ldw	r2,-16(fp)
8113779c:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
811377a0:	e0bfef17 	ldw	r2,-68(fp)
811377a4:	10800017 	ldw	r2,0(r2)
811377a8:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
811377ac:	00001506 	br	81137804 <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
811377b0:	e0bff017 	ldw	r2,-64(fp)
811377b4:	10800003 	ldbu	r2,0(r2)
811377b8:	10803fcc 	andi	r2,r2,255
811377bc:	10c000a0 	cmpeqi	r3,r2,2
811377c0:	1800071e 	bne	r3,zero,811377e0 <OSEventPendMulti+0xe4>
811377c4:	108000e0 	cmpeqi	r2,r2,3
811377c8:	1000071e 	bne	r2,zero,811377e8 <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
811377cc:	e0800217 	ldw	r2,8(fp)
811377d0:	00c00044 	movi	r3,1
811377d4:	10c00005 	stb	r3,0(r2)
                 return (0);
811377d8:	0005883a 	mov	r2,zero
811377dc:	00012706 	br	81137c7c <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
811377e0:	0001883a 	nop
811377e4:	00000106 	br	811377ec <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
811377e8:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
811377ec:	e0bfef17 	ldw	r2,-68(fp)
811377f0:	10800104 	addi	r2,r2,4
811377f4:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
811377f8:	e0bfef17 	ldw	r2,-68(fp)
811377fc:	10800017 	ldw	r2,0(r2)
81137800:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
81137804:	e0bff017 	ldw	r2,-64(fp)
81137808:	103fe91e 	bne	r2,zero,811377b0 <__reset+0xfb1177b0>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
8113780c:	d0a0a003 	ldbu	r2,-32128(gp)
81137810:	10803fcc 	andi	r2,r2,255
81137814:	10000526 	beq	r2,zero,8113782c <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
81137818:	e0800217 	ldw	r2,8(fp)
8113781c:	00c00084 	movi	r3,2
81137820:	10c00005 	stb	r3,0(r2)
        return (0);
81137824:	0005883a 	mov	r2,zero
81137828:	00011406 	br	81137c7c <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
8113782c:	d0a08e03 	ldbu	r2,-32200(gp)
81137830:	10803fcc 	andi	r2,r2,255
81137834:	10000526 	beq	r2,zero,8113784c <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
81137838:	e0800217 	ldw	r2,8(fp)
8113783c:	00c00344 	movi	r3,13
81137840:	10c00005 	stb	r3,0(r2)
        return (0);
81137844:	0005883a 	mov	r2,zero
81137848:	00010c06 	br	81137c7c <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113784c:	0005303a 	rdctl	r2,status
81137850:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137854:	e0fffb17 	ldw	r3,-20(fp)
81137858:	00bfff84 	movi	r2,-2
8113785c:	1884703a 	and	r2,r3,r2
81137860:	1001703a 	wrctl	status,r2
  
  return context;
81137864:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
81137868:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
8113786c:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
81137870:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
81137874:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
81137878:	e0bffc17 	ldw	r2,-16(fp)
8113787c:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
81137880:	e0bfef17 	ldw	r2,-68(fp)
81137884:	10800017 	ldw	r2,0(r2)
81137888:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
8113788c:	00006406 	br	81137a20 <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
81137890:	e0bff017 	ldw	r2,-64(fp)
81137894:	10800003 	ldbu	r2,0(r2)
81137898:	10803fcc 	andi	r2,r2,255
8113789c:	10c000a0 	cmpeqi	r3,r2,2
811378a0:	18001f1e 	bne	r3,zero,81137920 <OSEventPendMulti+0x224>
811378a4:	108000e0 	cmpeqi	r2,r2,3
811378a8:	10004c26 	beq	r2,zero,811379dc <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
811378ac:	e0bff017 	ldw	r2,-64(fp)
811378b0:	1080020b 	ldhu	r2,8(r2)
811378b4:	10bfffcc 	andi	r2,r2,65535
811378b8:	10001526 	beq	r2,zero,81137910 <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
811378bc:	e0bff017 	ldw	r2,-64(fp)
811378c0:	1080020b 	ldhu	r2,8(r2)
811378c4:	10bfffc4 	addi	r2,r2,-1
811378c8:	1007883a 	mov	r3,r2
811378cc:	e0bff017 	ldw	r2,-64(fp)
811378d0:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
811378d4:	e0bffd17 	ldw	r2,-12(fp)
811378d8:	10c00104 	addi	r3,r2,4
811378dc:	e0fffd15 	stw	r3,-12(fp)
811378e0:	e0fff017 	ldw	r3,-64(fp)
811378e4:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
811378e8:	00800044 	movi	r2,1
811378ec:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
811378f0:	e0bffe17 	ldw	r2,-8(fp)
811378f4:	10c00104 	addi	r3,r2,4
811378f8:	e0fffe15 	stw	r3,-8(fp)
811378fc:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
81137900:	e0bff18b 	ldhu	r2,-58(fp)
81137904:	10800044 	addi	r2,r2,1
81137908:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
8113790c:	00003e06 	br	81137a08 <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
81137910:	e0bff203 	ldbu	r2,-56(fp)
81137914:	10800054 	ori	r2,r2,1
81137918:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
8113791c:	00003a06 	br	81137a08 <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
81137920:	e0bff017 	ldw	r2,-64(fp)
81137924:	10800117 	ldw	r2,4(r2)
81137928:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
8113792c:	e0bff517 	ldw	r2,-44(fp)
81137930:	1080058b 	ldhu	r2,22(r2)
81137934:	10bfffcc 	andi	r2,r2,65535
81137938:	10002426 	beq	r2,zero,811379cc <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
8113793c:	e0bffe17 	ldw	r2,-8(fp)
81137940:	10c00104 	addi	r3,r2,4
81137944:	e0fffe15 	stw	r3,-8(fp)
81137948:	e0fff517 	ldw	r3,-44(fp)
8113794c:	18c00417 	ldw	r3,16(r3)
81137950:	19400104 	addi	r5,r3,4
81137954:	e13ff517 	ldw	r4,-44(fp)
81137958:	21400415 	stw	r5,16(r4)
8113795c:	18c00017 	ldw	r3,0(r3)
81137960:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
81137964:	e0bff517 	ldw	r2,-44(fp)
81137968:	10c00417 	ldw	r3,16(r2)
8113796c:	e0bff517 	ldw	r2,-44(fp)
81137970:	10800217 	ldw	r2,8(r2)
81137974:	1880041e 	bne	r3,r2,81137988 <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
81137978:	e0bff517 	ldw	r2,-44(fp)
8113797c:	10c00117 	ldw	r3,4(r2)
81137980:	e0bff517 	ldw	r2,-44(fp)
81137984:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
81137988:	e0bff517 	ldw	r2,-44(fp)
8113798c:	1080058b 	ldhu	r2,22(r2)
81137990:	10bfffc4 	addi	r2,r2,-1
81137994:	1007883a 	mov	r3,r2
81137998:	e0bff517 	ldw	r2,-44(fp)
8113799c:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
811379a0:	e0bffd17 	ldw	r2,-12(fp)
811379a4:	10c00104 	addi	r3,r2,4
811379a8:	e0fffd15 	stw	r3,-12(fp)
811379ac:	e0fff017 	ldw	r3,-64(fp)
811379b0:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
811379b4:	00800044 	movi	r2,1
811379b8:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
811379bc:	e0bff18b 	ldhu	r2,-58(fp)
811379c0:	10800044 	addi	r2,r2,1
811379c4:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
811379c8:	00000f06 	br	81137a08 <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
811379cc:	e0bff203 	ldbu	r2,-56(fp)
811379d0:	10800114 	ori	r2,r2,4
811379d4:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
811379d8:	00000b06 	br	81137a08 <OSEventPendMulti+0x30c>
811379dc:	e0bff317 	ldw	r2,-52(fp)
811379e0:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811379e4:	e0bff417 	ldw	r2,-48(fp)
811379e8:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
811379ec:	e0bffd17 	ldw	r2,-12(fp)
811379f0:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
811379f4:	e0800217 	ldw	r2,8(fp)
811379f8:	00c00044 	movi	r3,1
811379fc:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
81137a00:	e0bff18b 	ldhu	r2,-58(fp)
81137a04:	00009d06 	br	81137c7c <OSEventPendMulti+0x580>
        }
        pevents++;
81137a08:	e0bfef17 	ldw	r2,-68(fp)
81137a0c:	10800104 	addi	r2,r2,4
81137a10:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
81137a14:	e0bfef17 	ldw	r2,-68(fp)
81137a18:	10800017 	ldw	r2,0(r2)
81137a1c:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
81137a20:	e0bff017 	ldw	r2,-64(fp)
81137a24:	103f9a1e 	bne	r2,zero,81137890 <__reset+0xfb117890>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
81137a28:	e0bff103 	ldbu	r2,-60(fp)
81137a2c:	10800058 	cmpnei	r2,r2,1
81137a30:	10000a1e 	bne	r2,zero,81137a5c <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
81137a34:	e0bffd17 	ldw	r2,-12(fp)
81137a38:	10000015 	stw	zero,0(r2)
81137a3c:	e0bff317 	ldw	r2,-52(fp)
81137a40:	e0bff615 	stw	r2,-40(fp)
81137a44:	e0bff617 	ldw	r2,-40(fp)
81137a48:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
81137a4c:	e0800217 	ldw	r2,8(fp)
81137a50:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
81137a54:	e0bff18b 	ldhu	r2,-58(fp)
81137a58:	00008806 	br	81137c7c <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
81137a5c:	d0a0a117 	ldw	r2,-32124(gp)
81137a60:	d0e0a117 	ldw	r3,-32124(gp)
81137a64:	19000c03 	ldbu	r4,48(r3)
81137a68:	e0fff203 	ldbu	r3,-56(fp)
81137a6c:	20c6b03a 	or	r3,r4,r3
81137a70:	1809883a 	mov	r4,r3
81137a74:	00ffe004 	movi	r3,-128
81137a78:	20c6b03a 	or	r3,r4,r3
81137a7c:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81137a80:	d0a0a117 	ldw	r2,-32124(gp)
81137a84:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
81137a88:	d0a0a117 	ldw	r2,-32124(gp)
81137a8c:	e0ffff0b 	ldhu	r3,-4(fp)
81137a90:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
81137a94:	e13ffc17 	ldw	r4,-16(fp)
81137a98:	11386200 	call	81138620 <OS_EventTaskWaitMulti>
81137a9c:	e0bff317 	ldw	r2,-52(fp)
81137aa0:	e0bff915 	stw	r2,-28(fp)
81137aa4:	e0bff917 	ldw	r2,-28(fp)
81137aa8:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
81137aac:	1138e240 	call	81138e24 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137ab0:	0005303a 	rdctl	r2,status
81137ab4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137ab8:	e0fff717 	ldw	r3,-36(fp)
81137abc:	00bfff84 	movi	r2,-2
81137ac0:	1884703a 	and	r2,r3,r2
81137ac4:	1001703a 	wrctl	status,r2
  
  return context;
81137ac8:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
81137acc:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
81137ad0:	d0a0a117 	ldw	r2,-32124(gp)
81137ad4:	10800c43 	ldbu	r2,49(r2)
81137ad8:	10803fcc 	andi	r2,r2,255
81137adc:	10000226 	beq	r2,zero,81137ae8 <OSEventPendMulti+0x3ec>
81137ae0:	108000a0 	cmpeqi	r2,r2,2
81137ae4:	10001826 	beq	r2,zero,81137b48 <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
81137ae8:	d0a0a117 	ldw	r2,-32124(gp)
81137aec:	10800717 	ldw	r2,28(r2)
81137af0:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
81137af4:	e0bff017 	ldw	r2,-64(fp)
81137af8:	10000b26 	beq	r2,zero,81137b28 <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
81137afc:	e0bffd17 	ldw	r2,-12(fp)
81137b00:	10c00104 	addi	r3,r2,4
81137b04:	e0fffd15 	stw	r3,-12(fp)
81137b08:	e0fff017 	ldw	r3,-64(fp)
81137b0c:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
81137b10:	e0bffd17 	ldw	r2,-12(fp)
81137b14:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
81137b18:	e0bff18b 	ldhu	r2,-58(fp)
81137b1c:	10800044 	addi	r2,r2,1
81137b20:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
81137b24:	00000d06 	br	81137b5c <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
81137b28:	d0a0a117 	ldw	r2,-32124(gp)
81137b2c:	00c00044 	movi	r3,1
81137b30:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
81137b34:	d0a0a117 	ldw	r2,-32124(gp)
81137b38:	e17ffc17 	ldw	r5,-16(fp)
81137b3c:	1009883a 	mov	r4,r2
81137b40:	11388380 	call	81138838 <OS_EventTaskRemoveMulti>
             }
			 break;
81137b44:	00000506 	br	81137b5c <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
81137b48:	d0a0a117 	ldw	r2,-32124(gp)
81137b4c:	e17ffc17 	ldw	r5,-16(fp)
81137b50:	1009883a 	mov	r4,r2
81137b54:	11388380 	call	81138838 <OS_EventTaskRemoveMulti>
             break;
81137b58:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
81137b5c:	d0a0a117 	ldw	r2,-32124(gp)
81137b60:	10800c43 	ldbu	r2,49(r2)
81137b64:	10803fcc 	andi	r2,r2,255
81137b68:	10000326 	beq	r2,zero,81137b78 <OSEventPendMulti+0x47c>
81137b6c:	108000a0 	cmpeqi	r2,r2,2
81137b70:	1000231e 	bne	r2,zero,81137c00 <OSEventPendMulti+0x504>
81137b74:	00002a06 	br	81137c20 <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
81137b78:	e0bff017 	ldw	r2,-64(fp)
81137b7c:	10800003 	ldbu	r2,0(r2)
81137b80:	10803fcc 	andi	r2,r2,255
81137b84:	0080100e 	bge	zero,r2,81137bc8 <OSEventPendMulti+0x4cc>
81137b88:	10c000d0 	cmplti	r3,r2,3
81137b8c:	1800071e 	bne	r3,zero,81137bac <OSEventPendMulti+0x4b0>
81137b90:	108000e0 	cmpeqi	r2,r2,3
81137b94:	10000c26 	beq	r2,zero,81137bc8 <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
81137b98:	e0bffe17 	ldw	r2,-8(fp)
81137b9c:	10c00104 	addi	r3,r2,4
81137ba0:	e0fffe15 	stw	r3,-8(fp)
81137ba4:	10000015 	stw	zero,0(r2)
                      break;
81137ba8:	00001206 	br	81137bf4 <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
81137bac:	e0bffe17 	ldw	r2,-8(fp)
81137bb0:	10c00104 	addi	r3,r2,4
81137bb4:	e0fffe15 	stw	r3,-8(fp)
81137bb8:	d0e0a117 	ldw	r3,-32124(gp)
81137bbc:	18c00917 	ldw	r3,36(r3)
81137bc0:	10c00015 	stw	r3,0(r2)
                      break;
81137bc4:	00000b06 	br	81137bf4 <OSEventPendMulti+0x4f8>
81137bc8:	e0bff317 	ldw	r2,-52(fp)
81137bcc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137bd0:	e0bff817 	ldw	r2,-32(fp)
81137bd4:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
81137bd8:	e0bffd17 	ldw	r2,-12(fp)
81137bdc:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
81137be0:	e0800217 	ldw	r2,8(fp)
81137be4:	00c00044 	movi	r3,1
81137be8:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
81137bec:	e0bff18b 	ldhu	r2,-58(fp)
81137bf0:	00002206 	br	81137c7c <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
81137bf4:	e0800217 	ldw	r2,8(fp)
81137bf8:	10000005 	stb	zero,0(r2)
             break;
81137bfc:	00001006 	br	81137c40 <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
81137c00:	e0bffe17 	ldw	r2,-8(fp)
81137c04:	10c00104 	addi	r3,r2,4
81137c08:	e0fffe15 	stw	r3,-8(fp)
81137c0c:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
81137c10:	e0800217 	ldw	r2,8(fp)
81137c14:	00c00384 	movi	r3,14
81137c18:	10c00005 	stb	r3,0(r2)
             break;
81137c1c:	00000806 	br	81137c40 <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
81137c20:	e0bffe17 	ldw	r2,-8(fp)
81137c24:	10c00104 	addi	r3,r2,4
81137c28:	e0fffe15 	stw	r3,-8(fp)
81137c2c:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
81137c30:	e0800217 	ldw	r2,8(fp)
81137c34:	00c00284 	movi	r3,10
81137c38:	10c00005 	stb	r3,0(r2)
             break;
81137c3c:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
81137c40:	d0a0a117 	ldw	r2,-32124(gp)
81137c44:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
81137c48:	d0a0a117 	ldw	r2,-32124(gp)
81137c4c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
81137c50:	d0a0a117 	ldw	r2,-32124(gp)
81137c54:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81137c58:	d0a0a117 	ldw	r2,-32124(gp)
81137c5c:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
81137c60:	d0a0a117 	ldw	r2,-32124(gp)
81137c64:	10000915 	stw	zero,36(r2)
81137c68:	e0bff317 	ldw	r2,-52(fp)
81137c6c:	e0bffa15 	stw	r2,-24(fp)
81137c70:	e0bffa17 	ldw	r2,-24(fp)
81137c74:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
81137c78:	e0bff18b 	ldhu	r2,-58(fp)
}
81137c7c:	e037883a 	mov	sp,fp
81137c80:	dfc00117 	ldw	ra,4(sp)
81137c84:	df000017 	ldw	fp,0(sp)
81137c88:	dec00204 	addi	sp,sp,8
81137c8c:	f800283a 	ret

81137c90 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
81137c90:	defffe04 	addi	sp,sp,-8
81137c94:	de00012e 	bgeu	sp,et,81137c9c <OSInit+0xc>
81137c98:	003b68fa 	trap	3
81137c9c:	dfc00115 	stw	ra,4(sp)
81137ca0:	df000015 	stw	fp,0(sp)
81137ca4:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
81137ca8:	114a1940 	call	8114a194 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
81137cac:	1138a980 	call	81138a98 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
81137cb0:	1138ae80 	call	81138ae8 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
81137cb4:	1138c6c0 	call	81138c6c <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
81137cb8:	11389b00 	call	811389b0 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
81137cbc:	113ac2c0 	call	8113ac2c <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
81137cc0:	113b5740 	call	8113b574 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
81137cc4:	113d8440 	call	8113d844 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
81137cc8:	1138b5c0 	call	81138b5c <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
81137ccc:	1138be40 	call	81138be4 <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
81137cd0:	1140be80 	call	81140be8 <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
81137cd4:	114a1c00 	call	8114a1c0 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
81137cd8:	11395480 	call	81139548 <OSDebugInit>
#endif
}
81137cdc:	0001883a 	nop
81137ce0:	e037883a 	mov	sp,fp
81137ce4:	dfc00117 	ldw	ra,4(sp)
81137ce8:	df000017 	ldw	fp,0(sp)
81137cec:	dec00204 	addi	sp,sp,8
81137cf0:	f800283a 	ret

81137cf4 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
81137cf4:	deffff04 	addi	sp,sp,-4
81137cf8:	de00012e 	bgeu	sp,et,81137d00 <OSIntEnter+0xc>
81137cfc:	003b68fa 	trap	3
81137d00:	df000015 	stw	fp,0(sp)
81137d04:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
81137d08:	d0a09003 	ldbu	r2,-32192(gp)
81137d0c:	10803fcc 	andi	r2,r2,255
81137d10:	10800058 	cmpnei	r2,r2,1
81137d14:	1000071e 	bne	r2,zero,81137d34 <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
81137d18:	d0a0a003 	ldbu	r2,-32128(gp)
81137d1c:	10803fcc 	andi	r2,r2,255
81137d20:	10803fe0 	cmpeqi	r2,r2,255
81137d24:	1000031e 	bne	r2,zero,81137d34 <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
81137d28:	d0a0a003 	ldbu	r2,-32128(gp)
81137d2c:	10800044 	addi	r2,r2,1
81137d30:	d0a0a005 	stb	r2,-32128(gp)
        }
    }
}
81137d34:	0001883a 	nop
81137d38:	e037883a 	mov	sp,fp
81137d3c:	df000017 	ldw	fp,0(sp)
81137d40:	dec00104 	addi	sp,sp,4
81137d44:	f800283a 	ret

81137d48 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
81137d48:	defffb04 	addi	sp,sp,-20
81137d4c:	de00012e 	bgeu	sp,et,81137d54 <OSIntExit+0xc>
81137d50:	003b68fa 	trap	3
81137d54:	dfc00415 	stw	ra,16(sp)
81137d58:	df000315 	stw	fp,12(sp)
81137d5c:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81137d60:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
81137d64:	d0a09003 	ldbu	r2,-32192(gp)
81137d68:	10803fcc 	andi	r2,r2,255
81137d6c:	10800058 	cmpnei	r2,r2,1
81137d70:	10002f1e 	bne	r2,zero,81137e30 <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137d74:	0005303a 	rdctl	r2,status
81137d78:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137d7c:	e0ffff17 	ldw	r3,-4(fp)
81137d80:	00bfff84 	movi	r2,-2
81137d84:	1884703a 	and	r2,r3,r2
81137d88:	1001703a 	wrctl	status,r2
  
  return context;
81137d8c:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81137d90:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
81137d94:	d0a0a003 	ldbu	r2,-32128(gp)
81137d98:	10803fcc 	andi	r2,r2,255
81137d9c:	10000326 	beq	r2,zero,81137dac <OSIntExit+0x64>
            OSIntNesting--;
81137da0:	d0a0a003 	ldbu	r2,-32128(gp)
81137da4:	10bfffc4 	addi	r2,r2,-1
81137da8:	d0a0a005 	stb	r2,-32128(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
81137dac:	d0a0a003 	ldbu	r2,-32128(gp)
81137db0:	10803fcc 	andi	r2,r2,255
81137db4:	10001a1e 	bne	r2,zero,81137e20 <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
81137db8:	d0a08e03 	ldbu	r2,-32200(gp)
81137dbc:	10803fcc 	andi	r2,r2,255
81137dc0:	1000171e 	bne	r2,zero,81137e20 <OSIntExit+0xd8>
                OS_SchedNew();
81137dc4:	1138efc0 	call	81138efc <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
81137dc8:	d0e09283 	ldbu	r3,-32182(gp)
81137dcc:	d0a092c3 	ldbu	r2,-32181(gp)
81137dd0:	18c03fcc 	andi	r3,r3,255
81137dd4:	10803fcc 	andi	r2,r2,255
81137dd8:	18801126 	beq	r3,r2,81137e20 <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
81137ddc:	d0a09283 	ldbu	r2,-32182(gp)
81137de0:	10c03fcc 	andi	r3,r2,255
81137de4:	00a045f4 	movhi	r2,33047
81137de8:	10af6e04 	addi	r2,r2,-16968
81137dec:	18c7883a 	add	r3,r3,r3
81137df0:	18c7883a 	add	r3,r3,r3
81137df4:	10c5883a 	add	r2,r2,r3
81137df8:	10800017 	ldw	r2,0(r2)
81137dfc:	d0a09b15 	stw	r2,-32148(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
81137e00:	d0a09b17 	ldw	r2,-32148(gp)
81137e04:	10c00e17 	ldw	r3,56(r2)
81137e08:	18c00044 	addi	r3,r3,1
81137e0c:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
81137e10:	d0a09517 	ldw	r2,-32172(gp)
81137e14:	10800044 	addi	r2,r2,1
81137e18:	d0a09515 	stw	r2,-32172(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
81137e1c:	1149e540 	call	81149e54 <OSCtxSw>
81137e20:	e0bffd17 	ldw	r2,-12(fp)
81137e24:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137e28:	e0bffe17 	ldw	r2,-8(fp)
81137e2c:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81137e30:	0001883a 	nop
81137e34:	e037883a 	mov	sp,fp
81137e38:	dfc00117 	ldw	ra,4(sp)
81137e3c:	df000017 	ldw	fp,0(sp)
81137e40:	dec00204 	addi	sp,sp,8
81137e44:	f800283a 	ret

81137e48 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
81137e48:	defffc04 	addi	sp,sp,-16
81137e4c:	de00012e 	bgeu	sp,et,81137e54 <OSSchedLock+0xc>
81137e50:	003b68fa 	trap	3
81137e54:	df000315 	stw	fp,12(sp)
81137e58:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137e5c:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
81137e60:	d0a09003 	ldbu	r2,-32192(gp)
81137e64:	10803fcc 	andi	r2,r2,255
81137e68:	10800058 	cmpnei	r2,r2,1
81137e6c:	1000161e 	bne	r2,zero,81137ec8 <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137e70:	0005303a 	rdctl	r2,status
81137e74:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137e78:	e0ffff17 	ldw	r3,-4(fp)
81137e7c:	00bfff84 	movi	r2,-2
81137e80:	1884703a 	and	r2,r3,r2
81137e84:	1001703a 	wrctl	status,r2
  
  return context;
81137e88:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81137e8c:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
81137e90:	d0a0a003 	ldbu	r2,-32128(gp)
81137e94:	10803fcc 	andi	r2,r2,255
81137e98:	1000071e 	bne	r2,zero,81137eb8 <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
81137e9c:	d0a08e03 	ldbu	r2,-32200(gp)
81137ea0:	10803fcc 	andi	r2,r2,255
81137ea4:	10803fe0 	cmpeqi	r2,r2,255
81137ea8:	1000031e 	bne	r2,zero,81137eb8 <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
81137eac:	d0a08e03 	ldbu	r2,-32200(gp)
81137eb0:	10800044 	addi	r2,r2,1
81137eb4:	d0a08e05 	stb	r2,-32200(gp)
81137eb8:	e0bffd17 	ldw	r2,-12(fp)
81137ebc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137ec0:	e0bffe17 	ldw	r2,-8(fp)
81137ec4:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81137ec8:	0001883a 	nop
81137ecc:	e037883a 	mov	sp,fp
81137ed0:	df000017 	ldw	fp,0(sp)
81137ed4:	dec00104 	addi	sp,sp,4
81137ed8:	f800283a 	ret

81137edc <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
81137edc:	defff804 	addi	sp,sp,-32
81137ee0:	de00012e 	bgeu	sp,et,81137ee8 <OSSchedUnlock+0xc>
81137ee4:	003b68fa 	trap	3
81137ee8:	dfc00715 	stw	ra,28(sp)
81137eec:	df000615 	stw	fp,24(sp)
81137ef0:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81137ef4:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
81137ef8:	d0a09003 	ldbu	r2,-32192(gp)
81137efc:	10803fcc 	andi	r2,r2,255
81137f00:	10800058 	cmpnei	r2,r2,1
81137f04:	1000281e 	bne	r2,zero,81137fa8 <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137f08:	0005303a 	rdctl	r2,status
81137f0c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137f10:	e0ffff17 	ldw	r3,-4(fp)
81137f14:	00bfff84 	movi	r2,-2
81137f18:	1884703a 	and	r2,r3,r2
81137f1c:	1001703a 	wrctl	status,r2
  
  return context;
81137f20:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81137f24:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
81137f28:	d0a08e03 	ldbu	r2,-32200(gp)
81137f2c:	10803fcc 	andi	r2,r2,255
81137f30:	10001926 	beq	r2,zero,81137f98 <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
81137f34:	d0a08e03 	ldbu	r2,-32200(gp)
81137f38:	10bfffc4 	addi	r2,r2,-1
81137f3c:	d0a08e05 	stb	r2,-32200(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
81137f40:	d0a08e03 	ldbu	r2,-32200(gp)
81137f44:	10803fcc 	andi	r2,r2,255
81137f48:	10000e1e 	bne	r2,zero,81137f84 <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
81137f4c:	d0a0a003 	ldbu	r2,-32128(gp)
81137f50:	10803fcc 	andi	r2,r2,255
81137f54:	1000061e 	bne	r2,zero,81137f70 <OSSchedUnlock+0x94>
81137f58:	e0bffa17 	ldw	r2,-24(fp)
81137f5c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137f60:	e0bffb17 	ldw	r2,-20(fp)
81137f64:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
81137f68:	1138e240 	call	81138e24 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
81137f6c:	00000e06 	br	81137fa8 <OSSchedUnlock+0xcc>
81137f70:	e0bffa17 	ldw	r2,-24(fp)
81137f74:	e0bffc15 	stw	r2,-16(fp)
81137f78:	e0bffc17 	ldw	r2,-16(fp)
81137f7c:	1001703a 	wrctl	status,r2
81137f80:	00000906 	br	81137fa8 <OSSchedUnlock+0xcc>
81137f84:	e0bffa17 	ldw	r2,-24(fp)
81137f88:	e0bffd15 	stw	r2,-12(fp)
81137f8c:	e0bffd17 	ldw	r2,-12(fp)
81137f90:	1001703a 	wrctl	status,r2
81137f94:	00000406 	br	81137fa8 <OSSchedUnlock+0xcc>
81137f98:	e0bffa17 	ldw	r2,-24(fp)
81137f9c:	e0bffe15 	stw	r2,-8(fp)
81137fa0:	e0bffe17 	ldw	r2,-8(fp)
81137fa4:	1001703a 	wrctl	status,r2
81137fa8:	0001883a 	nop
81137fac:	e037883a 	mov	sp,fp
81137fb0:	dfc00117 	ldw	ra,4(sp)
81137fb4:	df000017 	ldw	fp,0(sp)
81137fb8:	dec00204 	addi	sp,sp,8
81137fbc:	f800283a 	ret

81137fc0 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
81137fc0:	defffe04 	addi	sp,sp,-8
81137fc4:	de00012e 	bgeu	sp,et,81137fcc <OSStart+0xc>
81137fc8:	003b68fa 	trap	3
81137fcc:	dfc00115 	stw	ra,4(sp)
81137fd0:	df000015 	stw	fp,0(sp)
81137fd4:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
81137fd8:	d0a09003 	ldbu	r2,-32192(gp)
81137fdc:	10803fcc 	andi	r2,r2,255
81137fe0:	10000f1e 	bne	r2,zero,81138020 <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
81137fe4:	1138efc0 	call	81138efc <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
81137fe8:	d0a09283 	ldbu	r2,-32182(gp)
81137fec:	d0a092c5 	stb	r2,-32181(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
81137ff0:	d0a09283 	ldbu	r2,-32182(gp)
81137ff4:	10c03fcc 	andi	r3,r2,255
81137ff8:	00a045f4 	movhi	r2,33047
81137ffc:	10af6e04 	addi	r2,r2,-16968
81138000:	18c7883a 	add	r3,r3,r3
81138004:	18c7883a 	add	r3,r3,r3
81138008:	10c5883a 	add	r2,r2,r3
8113800c:	10800017 	ldw	r2,0(r2)
81138010:	d0a09b15 	stw	r2,-32148(gp)
        OSTCBCur      = OSTCBHighRdy;
81138014:	d0a09b17 	ldw	r2,-32148(gp)
81138018:	d0a0a115 	stw	r2,-32124(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
8113801c:	1149ef00 	call	81149ef0 <OSStartHighRdy>
    }
}
81138020:	0001883a 	nop
81138024:	e037883a 	mov	sp,fp
81138028:	dfc00117 	ldw	ra,4(sp)
8113802c:	df000017 	ldw	fp,0(sp)
81138030:	dec00204 	addi	sp,sp,8
81138034:	f800283a 	ret

81138038 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
81138038:	defff904 	addi	sp,sp,-28
8113803c:	de00012e 	bgeu	sp,et,81138044 <OSStatInit+0xc>
81138040:	003b68fa 	trap	3
81138044:	dfc00615 	stw	ra,24(sp)
81138048:	df000515 	stw	fp,20(sp)
8113804c:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138050:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
81138054:	01000084 	movi	r4,2
81138058:	113fb600 	call	8113fb60 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113805c:	0005303a 	rdctl	r2,status
81138060:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138064:	e0fffc17 	ldw	r3,-16(fp)
81138068:	00bfff84 	movi	r2,-2
8113806c:	1884703a 	and	r2,r3,r2
81138070:	1001703a 	wrctl	status,r2
  
  return context;
81138074:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
81138078:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
8113807c:	d0209115 	stw	zero,-32188(gp)
81138080:	e0bffb17 	ldw	r2,-20(fp)
81138084:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138088:	e0bffd17 	ldw	r2,-12(fp)
8113808c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
81138090:	01001904 	movi	r4,100
81138094:	113fb600 	call	8113fb60 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138098:	0005303a 	rdctl	r2,status
8113809c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811380a0:	e0fffe17 	ldw	r3,-8(fp)
811380a4:	00bfff84 	movi	r2,-2
811380a8:	1884703a 	and	r2,r3,r2
811380ac:	1001703a 	wrctl	status,r2
  
  return context;
811380b0:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
811380b4:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
811380b8:	d0a09117 	ldw	r2,-32188(gp)
811380bc:	d0a09715 	stw	r2,-32164(gp)
    OSStatRdy    = OS_TRUE;
811380c0:	00800044 	movi	r2,1
811380c4:	d0a0a605 	stb	r2,-32104(gp)
811380c8:	e0bffb17 	ldw	r2,-20(fp)
811380cc:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811380d0:	e0bfff17 	ldw	r2,-4(fp)
811380d4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
811380d8:	0001883a 	nop
811380dc:	e037883a 	mov	sp,fp
811380e0:	dfc00117 	ldw	ra,4(sp)
811380e4:	df000017 	ldw	fp,0(sp)
811380e8:	dec00204 	addi	sp,sp,8
811380ec:	f800283a 	ret

811380f0 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
811380f0:	defff704 	addi	sp,sp,-36
811380f4:	de00012e 	bgeu	sp,et,811380fc <OSTimeTick+0xc>
811380f8:	003b68fa 	trap	3
811380fc:	dfc00815 	stw	ra,32(sp)
81138100:	df000715 	stw	fp,28(sp)
81138104:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81138108:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
8113810c:	114a1400 	call	8114a140 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138110:	0005303a 	rdctl	r2,status
81138114:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138118:	e0fffd17 	ldw	r3,-12(fp)
8113811c:	00bfff84 	movi	r2,-2
81138120:	1884703a 	and	r2,r3,r2
81138124:	1001703a 	wrctl	status,r2
  
  return context;
81138128:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
8113812c:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
81138130:	d0a0a317 	ldw	r2,-32116(gp)
81138134:	10800044 	addi	r2,r2,1
81138138:	d0a0a315 	stw	r2,-32116(gp)
8113813c:	e0bffb17 	ldw	r2,-20(fp)
81138140:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138144:	e0bfff17 	ldw	r2,-4(fp)
81138148:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
8113814c:	d0a09003 	ldbu	r2,-32192(gp)
81138150:	10803fcc 	andi	r2,r2,255
81138154:	10800058 	cmpnei	r2,r2,1
81138158:	10006a1e 	bne	r2,zero,81138304 <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
8113815c:	d0a09403 	ldbu	r2,-32176(gp)
81138160:	10803fcc 	andi	r2,r2,255
81138164:	10c00060 	cmpeqi	r3,r2,1
81138168:	1800061e 	bne	r3,zero,81138184 <OSTimeTick+0x94>
8113816c:	10c000a0 	cmpeqi	r3,r2,2
81138170:	1800061e 	bne	r3,zero,8113818c <OSTimeTick+0x9c>
81138174:	10000a1e 	bne	r2,zero,811381a0 <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
81138178:	00800044 	movi	r2,1
8113817c:	e0bffa05 	stb	r2,-24(fp)
                 break;
81138180:	00000b06 	br	811381b0 <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
81138184:	e03ffa05 	stb	zero,-24(fp)
                 break;
81138188:	00000906 	br	811381b0 <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
8113818c:	00800044 	movi	r2,1
81138190:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
81138194:	00800044 	movi	r2,1
81138198:	d0a09405 	stb	r2,-32176(gp)
                 break;
8113819c:	00000406 	br	811381b0 <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
811381a0:	00800044 	movi	r2,1
811381a4:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
811381a8:	d0209405 	stb	zero,-32176(gp)
                 break;
811381ac:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
811381b0:	e0bffa03 	ldbu	r2,-24(fp)
811381b4:	10005226 	beq	r2,zero,81138300 <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
811381b8:	d0a09317 	ldw	r2,-32180(gp)
811381bc:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
811381c0:	00004906 	br	811382e8 <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811381c4:	0005303a 	rdctl	r2,status
811381c8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811381cc:	e0fffc17 	ldw	r3,-16(fp)
811381d0:	00bfff84 	movi	r2,-2
811381d4:	1884703a 	and	r2,r3,r2
811381d8:	1001703a 	wrctl	status,r2
  
  return context;
811381dc:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
811381e0:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
811381e4:	e0bff917 	ldw	r2,-28(fp)
811381e8:	10800b8b 	ldhu	r2,46(r2)
811381ec:	10bfffcc 	andi	r2,r2,65535
811381f0:	10003626 	beq	r2,zero,811382cc <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
811381f4:	e0bff917 	ldw	r2,-28(fp)
811381f8:	10800b8b 	ldhu	r2,46(r2)
811381fc:	10bfffc4 	addi	r2,r2,-1
81138200:	1007883a 	mov	r3,r2
81138204:	e0bff917 	ldw	r2,-28(fp)
81138208:	10c00b8d 	sth	r3,46(r2)
8113820c:	e0bff917 	ldw	r2,-28(fp)
81138210:	10800b8b 	ldhu	r2,46(r2)
81138214:	10bfffcc 	andi	r2,r2,65535
81138218:	10002c1e 	bne	r2,zero,811382cc <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8113821c:	e0bff917 	ldw	r2,-28(fp)
81138220:	10800c03 	ldbu	r2,48(r2)
81138224:	10803fcc 	andi	r2,r2,255
81138228:	10800dcc 	andi	r2,r2,55
8113822c:	10000b26 	beq	r2,zero,8113825c <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
81138230:	e0bff917 	ldw	r2,-28(fp)
81138234:	10c00c03 	ldbu	r3,48(r2)
81138238:	00bff204 	movi	r2,-56
8113823c:	1884703a 	and	r2,r3,r2
81138240:	1007883a 	mov	r3,r2
81138244:	e0bff917 	ldw	r2,-28(fp)
81138248:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
8113824c:	e0bff917 	ldw	r2,-28(fp)
81138250:	00c00044 	movi	r3,1
81138254:	10c00c45 	stb	r3,49(r2)
81138258:	00000206 	br	81138264 <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8113825c:	e0bff917 	ldw	r2,-28(fp)
81138260:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
81138264:	e0bff917 	ldw	r2,-28(fp)
81138268:	10800c03 	ldbu	r2,48(r2)
8113826c:	10803fcc 	andi	r2,r2,255
81138270:	1080020c 	andi	r2,r2,8
81138274:	1000151e 	bne	r2,zero,811382cc <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
81138278:	e0bff917 	ldw	r2,-28(fp)
8113827c:	10c00d83 	ldbu	r3,54(r2)
81138280:	d0a09d03 	ldbu	r2,-32140(gp)
81138284:	1884b03a 	or	r2,r3,r2
81138288:	d0a09d05 	stb	r2,-32140(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113828c:	e0bff917 	ldw	r2,-28(fp)
81138290:	10800d03 	ldbu	r2,52(r2)
81138294:	10c03fcc 	andi	r3,r2,255
81138298:	e0bff917 	ldw	r2,-28(fp)
8113829c:	10800d03 	ldbu	r2,52(r2)
811382a0:	11003fcc 	andi	r4,r2,255
811382a4:	d0a09d44 	addi	r2,gp,-32139
811382a8:	2085883a 	add	r2,r4,r2
811382ac:	11000003 	ldbu	r4,0(r2)
811382b0:	e0bff917 	ldw	r2,-28(fp)
811382b4:	10800d43 	ldbu	r2,53(r2)
811382b8:	2084b03a 	or	r2,r4,r2
811382bc:	1009883a 	mov	r4,r2
811382c0:	d0a09d44 	addi	r2,gp,-32139
811382c4:	1885883a 	add	r2,r3,r2
811382c8:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
811382cc:	e0bff917 	ldw	r2,-28(fp)
811382d0:	10800517 	ldw	r2,20(r2)
811382d4:	e0bff915 	stw	r2,-28(fp)
811382d8:	e0bffb17 	ldw	r2,-20(fp)
811382dc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811382e0:	e0bffe17 	ldw	r2,-8(fp)
811382e4:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
811382e8:	e0bff917 	ldw	r2,-28(fp)
811382ec:	10800c83 	ldbu	r2,50(r2)
811382f0:	10803fcc 	andi	r2,r2,255
811382f4:	10800a98 	cmpnei	r2,r2,42
811382f8:	103fb21e 	bne	r2,zero,811381c4 <__reset+0xfb1181c4>
811382fc:	00000106 	br	81138304 <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
81138300:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
81138304:	e037883a 	mov	sp,fp
81138308:	dfc00117 	ldw	ra,4(sp)
8113830c:	df000017 	ldw	fp,0(sp)
81138310:	dec00204 	addi	sp,sp,8
81138314:	f800283a 	ret

81138318 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
81138318:	deffff04 	addi	sp,sp,-4
8113831c:	de00012e 	bgeu	sp,et,81138324 <OSVersion+0xc>
81138320:	003b68fa 	trap	3
81138324:	df000015 	stw	fp,0(sp)
81138328:	d839883a 	mov	fp,sp
    return (OS_VERSION);
8113832c:	00804784 	movi	r2,286
}
81138330:	e037883a 	mov	sp,fp
81138334:	df000017 	ldw	fp,0(sp)
81138338:	dec00104 	addi	sp,sp,4
8113833c:	f800283a 	ret

81138340 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
81138340:	deffff04 	addi	sp,sp,-4
81138344:	de00012e 	bgeu	sp,et,8113834c <OS_Dummy+0xc>
81138348:	003b68fa 	trap	3
8113834c:	df000015 	stw	fp,0(sp)
81138350:	d839883a 	mov	fp,sp
}
81138354:	0001883a 	nop
81138358:	e037883a 	mov	sp,fp
8113835c:	df000017 	ldw	fp,0(sp)
81138360:	dec00104 	addi	sp,sp,4
81138364:	f800283a 	ret

81138368 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
81138368:	defff804 	addi	sp,sp,-32
8113836c:	de00012e 	bgeu	sp,et,81138374 <OS_EventTaskRdy+0xc>
81138370:	003b68fa 	trap	3
81138374:	dfc00715 	stw	ra,28(sp)
81138378:	df000615 	stw	fp,24(sp)
8113837c:	df000604 	addi	fp,sp,24
81138380:	e13ffc15 	stw	r4,-16(fp)
81138384:	e17ffd15 	stw	r5,-12(fp)
81138388:	3007883a 	mov	r3,r6
8113838c:	3805883a 	mov	r2,r7
81138390:	e0fffe05 	stb	r3,-8(fp)
81138394:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
81138398:	e0bffc17 	ldw	r2,-16(fp)
8113839c:	10800283 	ldbu	r2,10(r2)
811383a0:	10c03fcc 	andi	r3,r2,255
811383a4:	00a04574 	movhi	r2,33045
811383a8:	10bff404 	addi	r2,r2,-48
811383ac:	10c5883a 	add	r2,r2,r3
811383b0:	10800003 	ldbu	r2,0(r2)
811383b4:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
811383b8:	e0bffa03 	ldbu	r2,-24(fp)
811383bc:	e0fffc17 	ldw	r3,-16(fp)
811383c0:	1885883a 	add	r2,r3,r2
811383c4:	108002c4 	addi	r2,r2,11
811383c8:	10800003 	ldbu	r2,0(r2)
811383cc:	10c03fcc 	andi	r3,r2,255
811383d0:	00a04574 	movhi	r2,33045
811383d4:	10bff404 	addi	r2,r2,-48
811383d8:	10c5883a 	add	r2,r2,r3
811383dc:	10800003 	ldbu	r2,0(r2)
811383e0:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
811383e4:	e0bffa03 	ldbu	r2,-24(fp)
811383e8:	100490fa 	slli	r2,r2,3
811383ec:	1007883a 	mov	r3,r2
811383f0:	e0bffa43 	ldbu	r2,-23(fp)
811383f4:	1885883a 	add	r2,r3,r2
811383f8:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
811383fc:	e0fffa83 	ldbu	r3,-22(fp)
81138400:	00a045f4 	movhi	r2,33047
81138404:	10af6e04 	addi	r2,r2,-16968
81138408:	18c7883a 	add	r3,r3,r3
8113840c:	18c7883a 	add	r3,r3,r3
81138410:	10c5883a 	add	r2,r2,r3
81138414:	10800017 	ldw	r2,0(r2)
81138418:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
8113841c:	e0bffb17 	ldw	r2,-20(fp)
81138420:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
81138424:	e0bffb17 	ldw	r2,-20(fp)
81138428:	e0fffd17 	ldw	r3,-12(fp)
8113842c:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
81138430:	e0bffb17 	ldw	r2,-20(fp)
81138434:	10800c03 	ldbu	r2,48(r2)
81138438:	1007883a 	mov	r3,r2
8113843c:	e0bffe03 	ldbu	r2,-8(fp)
81138440:	0084303a 	nor	r2,zero,r2
81138444:	1884703a 	and	r2,r3,r2
81138448:	1007883a 	mov	r3,r2
8113844c:	e0bffb17 	ldw	r2,-20(fp)
81138450:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
81138454:	e0bffb17 	ldw	r2,-20(fp)
81138458:	e0ffff03 	ldbu	r3,-4(fp)
8113845c:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
81138460:	e0bffb17 	ldw	r2,-20(fp)
81138464:	10800c03 	ldbu	r2,48(r2)
81138468:	10803fcc 	andi	r2,r2,255
8113846c:	1080020c 	andi	r2,r2,8
81138470:	1000111e 	bne	r2,zero,811384b8 <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
81138474:	e0bffb17 	ldw	r2,-20(fp)
81138478:	10c00d83 	ldbu	r3,54(r2)
8113847c:	d0a09d03 	ldbu	r2,-32140(gp)
81138480:	1884b03a 	or	r2,r3,r2
81138484:	d0a09d05 	stb	r2,-32140(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
81138488:	e0fffa03 	ldbu	r3,-24(fp)
8113848c:	e13ffa03 	ldbu	r4,-24(fp)
81138490:	d0a09d44 	addi	r2,gp,-32139
81138494:	2085883a 	add	r2,r4,r2
81138498:	11000003 	ldbu	r4,0(r2)
8113849c:	e0bffb17 	ldw	r2,-20(fp)
811384a0:	10800d43 	ldbu	r2,53(r2)
811384a4:	2084b03a 	or	r2,r4,r2
811384a8:	1009883a 	mov	r4,r2
811384ac:	d0a09d44 	addi	r2,gp,-32139
811384b0:	1885883a 	add	r2,r3,r2
811384b4:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
811384b8:	e17ffc17 	ldw	r5,-16(fp)
811384bc:	e13ffb17 	ldw	r4,-20(fp)
811384c0:	11387780 	call	81138778 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
811384c4:	e0bffb17 	ldw	r2,-20(fp)
811384c8:	10800817 	ldw	r2,32(r2)
811384cc:	10000826 	beq	r2,zero,811384f0 <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
811384d0:	e0bffb17 	ldw	r2,-20(fp)
811384d4:	10800817 	ldw	r2,32(r2)
811384d8:	100b883a 	mov	r5,r2
811384dc:	e13ffb17 	ldw	r4,-20(fp)
811384e0:	11388380 	call	81138838 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
811384e4:	e0bffb17 	ldw	r2,-20(fp)
811384e8:	e0fffc17 	ldw	r3,-16(fp)
811384ec:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
811384f0:	e0bffa83 	ldbu	r2,-22(fp)
}
811384f4:	e037883a 	mov	sp,fp
811384f8:	dfc00117 	ldw	ra,4(sp)
811384fc:	df000017 	ldw	fp,0(sp)
81138500:	dec00204 	addi	sp,sp,8
81138504:	f800283a 	ret

81138508 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
81138508:	defffd04 	addi	sp,sp,-12
8113850c:	de00012e 	bgeu	sp,et,81138514 <OS_EventTaskWait+0xc>
81138510:	003b68fa 	trap	3
81138514:	df000215 	stw	fp,8(sp)
81138518:	df000204 	addi	fp,sp,8
8113851c:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
81138520:	d0a0a117 	ldw	r2,-32124(gp)
81138524:	e0ffff17 	ldw	r3,-4(fp)
81138528:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
8113852c:	d0a0a117 	ldw	r2,-32124(gp)
81138530:	10800d03 	ldbu	r2,52(r2)
81138534:	10803fcc 	andi	r2,r2,255
81138538:	d0e0a117 	ldw	r3,-32124(gp)
8113853c:	18c00d03 	ldbu	r3,52(r3)
81138540:	18c03fcc 	andi	r3,r3,255
81138544:	e13fff17 	ldw	r4,-4(fp)
81138548:	20c7883a 	add	r3,r4,r3
8113854c:	18c002c4 	addi	r3,r3,11
81138550:	19000003 	ldbu	r4,0(r3)
81138554:	d0e0a117 	ldw	r3,-32124(gp)
81138558:	18c00d43 	ldbu	r3,53(r3)
8113855c:	20c6b03a 	or	r3,r4,r3
81138560:	1809883a 	mov	r4,r3
81138564:	e0ffff17 	ldw	r3,-4(fp)
81138568:	1885883a 	add	r2,r3,r2
8113856c:	108002c4 	addi	r2,r2,11
81138570:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
81138574:	e0bfff17 	ldw	r2,-4(fp)
81138578:	10c00283 	ldbu	r3,10(r2)
8113857c:	d0a0a117 	ldw	r2,-32124(gp)
81138580:	10800d83 	ldbu	r2,54(r2)
81138584:	1884b03a 	or	r2,r3,r2
81138588:	1007883a 	mov	r3,r2
8113858c:	e0bfff17 	ldw	r2,-4(fp)
81138590:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
81138594:	d0a0a117 	ldw	r2,-32124(gp)
81138598:	10800d03 	ldbu	r2,52(r2)
8113859c:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
811385a0:	e0fffe03 	ldbu	r3,-8(fp)
811385a4:	e13ffe03 	ldbu	r4,-8(fp)
811385a8:	d0a09d44 	addi	r2,gp,-32139
811385ac:	2085883a 	add	r2,r4,r2
811385b0:	10800003 	ldbu	r2,0(r2)
811385b4:	1009883a 	mov	r4,r2
811385b8:	d0a0a117 	ldw	r2,-32124(gp)
811385bc:	10800d43 	ldbu	r2,53(r2)
811385c0:	0084303a 	nor	r2,zero,r2
811385c4:	2084703a 	and	r2,r4,r2
811385c8:	1009883a 	mov	r4,r2
811385cc:	d0a09d44 	addi	r2,gp,-32139
811385d0:	1885883a 	add	r2,r3,r2
811385d4:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
811385d8:	e0fffe03 	ldbu	r3,-8(fp)
811385dc:	d0a09d44 	addi	r2,gp,-32139
811385e0:	1885883a 	add	r2,r3,r2
811385e4:	10800003 	ldbu	r2,0(r2)
811385e8:	10803fcc 	andi	r2,r2,255
811385ec:	1000071e 	bne	r2,zero,8113860c <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
811385f0:	d0a0a117 	ldw	r2,-32124(gp)
811385f4:	10800d83 	ldbu	r2,54(r2)
811385f8:	0084303a 	nor	r2,zero,r2
811385fc:	1007883a 	mov	r3,r2
81138600:	d0a09d03 	ldbu	r2,-32140(gp)
81138604:	1884703a 	and	r2,r3,r2
81138608:	d0a09d05 	stb	r2,-32140(gp)
    }
}
8113860c:	0001883a 	nop
81138610:	e037883a 	mov	sp,fp
81138614:	df000017 	ldw	fp,0(sp)
81138618:	dec00104 	addi	sp,sp,4
8113861c:	f800283a 	ret

81138620 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
81138620:	defffb04 	addi	sp,sp,-20
81138624:	de00012e 	bgeu	sp,et,8113862c <OS_EventTaskWaitMulti+0xc>
81138628:	003b68fa 	trap	3
8113862c:	df000415 	stw	fp,16(sp)
81138630:	df000404 	addi	fp,sp,16
81138634:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
81138638:	d0a0a117 	ldw	r2,-32124(gp)
8113863c:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
81138640:	d0a0a117 	ldw	r2,-32124(gp)
81138644:	e0ffff17 	ldw	r3,-4(fp)
81138648:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
8113864c:	e0bfff17 	ldw	r2,-4(fp)
81138650:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
81138654:	e0bffc17 	ldw	r2,-16(fp)
81138658:	10800017 	ldw	r2,0(r2)
8113865c:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
81138660:	00002006 	br	811386e4 <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
81138664:	d0a0a117 	ldw	r2,-32124(gp)
81138668:	10800d03 	ldbu	r2,52(r2)
8113866c:	10803fcc 	andi	r2,r2,255
81138670:	d0e0a117 	ldw	r3,-32124(gp)
81138674:	18c00d03 	ldbu	r3,52(r3)
81138678:	18c03fcc 	andi	r3,r3,255
8113867c:	e13ffd17 	ldw	r4,-12(fp)
81138680:	20c7883a 	add	r3,r4,r3
81138684:	18c002c4 	addi	r3,r3,11
81138688:	19000003 	ldbu	r4,0(r3)
8113868c:	d0e0a117 	ldw	r3,-32124(gp)
81138690:	18c00d43 	ldbu	r3,53(r3)
81138694:	20c6b03a 	or	r3,r4,r3
81138698:	1809883a 	mov	r4,r3
8113869c:	e0fffd17 	ldw	r3,-12(fp)
811386a0:	1885883a 	add	r2,r3,r2
811386a4:	108002c4 	addi	r2,r2,11
811386a8:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
811386ac:	e0bffd17 	ldw	r2,-12(fp)
811386b0:	10c00283 	ldbu	r3,10(r2)
811386b4:	d0a0a117 	ldw	r2,-32124(gp)
811386b8:	10800d83 	ldbu	r2,54(r2)
811386bc:	1884b03a 	or	r2,r3,r2
811386c0:	1007883a 	mov	r3,r2
811386c4:	e0bffd17 	ldw	r2,-12(fp)
811386c8:	10c00285 	stb	r3,10(r2)
        pevents++;
811386cc:	e0bffc17 	ldw	r2,-16(fp)
811386d0:	10800104 	addi	r2,r2,4
811386d4:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
811386d8:	e0bffc17 	ldw	r2,-16(fp)
811386dc:	10800017 	ldw	r2,0(r2)
811386e0:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
811386e4:	e0bffd17 	ldw	r2,-12(fp)
811386e8:	103fde1e 	bne	r2,zero,81138664 <__reset+0xfb118664>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
811386ec:	d0a0a117 	ldw	r2,-32124(gp)
811386f0:	10800d03 	ldbu	r2,52(r2)
811386f4:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
811386f8:	e0fffe03 	ldbu	r3,-8(fp)
811386fc:	e13ffe03 	ldbu	r4,-8(fp)
81138700:	d0a09d44 	addi	r2,gp,-32139
81138704:	2085883a 	add	r2,r4,r2
81138708:	10800003 	ldbu	r2,0(r2)
8113870c:	1009883a 	mov	r4,r2
81138710:	d0a0a117 	ldw	r2,-32124(gp)
81138714:	10800d43 	ldbu	r2,53(r2)
81138718:	0084303a 	nor	r2,zero,r2
8113871c:	2084703a 	and	r2,r4,r2
81138720:	1009883a 	mov	r4,r2
81138724:	d0a09d44 	addi	r2,gp,-32139
81138728:	1885883a 	add	r2,r3,r2
8113872c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81138730:	e0fffe03 	ldbu	r3,-8(fp)
81138734:	d0a09d44 	addi	r2,gp,-32139
81138738:	1885883a 	add	r2,r3,r2
8113873c:	10800003 	ldbu	r2,0(r2)
81138740:	10803fcc 	andi	r2,r2,255
81138744:	1000071e 	bne	r2,zero,81138764 <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
81138748:	d0a0a117 	ldw	r2,-32124(gp)
8113874c:	10800d83 	ldbu	r2,54(r2)
81138750:	0084303a 	nor	r2,zero,r2
81138754:	1007883a 	mov	r3,r2
81138758:	d0a09d03 	ldbu	r2,-32140(gp)
8113875c:	1884703a 	and	r2,r3,r2
81138760:	d0a09d05 	stb	r2,-32140(gp)
    }
}
81138764:	0001883a 	nop
81138768:	e037883a 	mov	sp,fp
8113876c:	df000017 	ldw	fp,0(sp)
81138770:	dec00104 	addi	sp,sp,4
81138774:	f800283a 	ret

81138778 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
81138778:	defffc04 	addi	sp,sp,-16
8113877c:	de00012e 	bgeu	sp,et,81138784 <OS_EventTaskRemove+0xc>
81138780:	003b68fa 	trap	3
81138784:	df000315 	stw	fp,12(sp)
81138788:	df000304 	addi	fp,sp,12
8113878c:	e13ffe15 	stw	r4,-8(fp)
81138790:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
81138794:	e0bffe17 	ldw	r2,-8(fp)
81138798:	10800d03 	ldbu	r2,52(r2)
8113879c:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
811387a0:	e0bffd03 	ldbu	r2,-12(fp)
811387a4:	e0fffd03 	ldbu	r3,-12(fp)
811387a8:	e13fff17 	ldw	r4,-4(fp)
811387ac:	20c7883a 	add	r3,r4,r3
811387b0:	18c002c4 	addi	r3,r3,11
811387b4:	18c00003 	ldbu	r3,0(r3)
811387b8:	1809883a 	mov	r4,r3
811387bc:	e0fffe17 	ldw	r3,-8(fp)
811387c0:	18c00d43 	ldbu	r3,53(r3)
811387c4:	00c6303a 	nor	r3,zero,r3
811387c8:	20c6703a 	and	r3,r4,r3
811387cc:	1809883a 	mov	r4,r3
811387d0:	e0ffff17 	ldw	r3,-4(fp)
811387d4:	1885883a 	add	r2,r3,r2
811387d8:	108002c4 	addi	r2,r2,11
811387dc:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
811387e0:	e0bffd03 	ldbu	r2,-12(fp)
811387e4:	e0ffff17 	ldw	r3,-4(fp)
811387e8:	1885883a 	add	r2,r3,r2
811387ec:	108002c4 	addi	r2,r2,11
811387f0:	10800003 	ldbu	r2,0(r2)
811387f4:	10803fcc 	andi	r2,r2,255
811387f8:	10000a1e 	bne	r2,zero,81138824 <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
811387fc:	e0bfff17 	ldw	r2,-4(fp)
81138800:	10800283 	ldbu	r2,10(r2)
81138804:	1007883a 	mov	r3,r2
81138808:	e0bffe17 	ldw	r2,-8(fp)
8113880c:	10800d83 	ldbu	r2,54(r2)
81138810:	0084303a 	nor	r2,zero,r2
81138814:	1884703a 	and	r2,r3,r2
81138818:	1007883a 	mov	r3,r2
8113881c:	e0bfff17 	ldw	r2,-4(fp)
81138820:	10c00285 	stb	r3,10(r2)
    }
}
81138824:	0001883a 	nop
81138828:	e037883a 	mov	sp,fp
8113882c:	df000017 	ldw	fp,0(sp)
81138830:	dec00104 	addi	sp,sp,4
81138834:	f800283a 	ret

81138838 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
81138838:	defffa04 	addi	sp,sp,-24
8113883c:	de00012e 	bgeu	sp,et,81138844 <OS_EventTaskRemoveMulti+0xc>
81138840:	003b68fa 	trap	3
81138844:	df000515 	stw	fp,20(sp)
81138848:	df000504 	addi	fp,sp,20
8113884c:	e13ffe15 	stw	r4,-8(fp)
81138850:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
81138854:	e0bffe17 	ldw	r2,-8(fp)
81138858:	10800d03 	ldbu	r2,52(r2)
8113885c:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
81138860:	e0bffe17 	ldw	r2,-8(fp)
81138864:	10800d83 	ldbu	r2,54(r2)
81138868:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
8113886c:	e0bffe17 	ldw	r2,-8(fp)
81138870:	10800d43 	ldbu	r2,53(r2)
81138874:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
81138878:	e0bfff17 	ldw	r2,-4(fp)
8113887c:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
81138880:	e0bffb17 	ldw	r2,-20(fp)
81138884:	10800017 	ldw	r2,0(r2)
81138888:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
8113888c:	00002506 	br	81138924 <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
81138890:	e0bffd03 	ldbu	r2,-12(fp)
81138894:	e0fffd03 	ldbu	r3,-12(fp)
81138898:	e13ffc17 	ldw	r4,-16(fp)
8113889c:	20c7883a 	add	r3,r4,r3
811388a0:	18c002c4 	addi	r3,r3,11
811388a4:	18c00003 	ldbu	r3,0(r3)
811388a8:	1809883a 	mov	r4,r3
811388ac:	e0fffd83 	ldbu	r3,-10(fp)
811388b0:	00c6303a 	nor	r3,zero,r3
811388b4:	20c6703a 	and	r3,r4,r3
811388b8:	1809883a 	mov	r4,r3
811388bc:	e0fffc17 	ldw	r3,-16(fp)
811388c0:	1885883a 	add	r2,r3,r2
811388c4:	108002c4 	addi	r2,r2,11
811388c8:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
811388cc:	e0bffd03 	ldbu	r2,-12(fp)
811388d0:	e0fffc17 	ldw	r3,-16(fp)
811388d4:	1885883a 	add	r2,r3,r2
811388d8:	108002c4 	addi	r2,r2,11
811388dc:	10800003 	ldbu	r2,0(r2)
811388e0:	10803fcc 	andi	r2,r2,255
811388e4:	1000091e 	bne	r2,zero,8113890c <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
811388e8:	e0bffc17 	ldw	r2,-16(fp)
811388ec:	10800283 	ldbu	r2,10(r2)
811388f0:	1007883a 	mov	r3,r2
811388f4:	e0bffd43 	ldbu	r2,-11(fp)
811388f8:	0084303a 	nor	r2,zero,r2
811388fc:	1884703a 	and	r2,r3,r2
81138900:	1007883a 	mov	r3,r2
81138904:	e0bffc17 	ldw	r2,-16(fp)
81138908:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
8113890c:	e0bffb17 	ldw	r2,-20(fp)
81138910:	10800104 	addi	r2,r2,4
81138914:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
81138918:	e0bffb17 	ldw	r2,-20(fp)
8113891c:	10800017 	ldw	r2,0(r2)
81138920:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
81138924:	e0bffc17 	ldw	r2,-16(fp)
81138928:	103fd91e 	bne	r2,zero,81138890 <__reset+0xfb118890>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
8113892c:	0001883a 	nop
81138930:	e037883a 	mov	sp,fp
81138934:	df000017 	ldw	fp,0(sp)
81138938:	dec00104 	addi	sp,sp,4
8113893c:	f800283a 	ret

81138940 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
81138940:	defffc04 	addi	sp,sp,-16
81138944:	de00012e 	bgeu	sp,et,8113894c <OS_EventWaitListInit+0xc>
81138948:	003b68fa 	trap	3
8113894c:	df000315 	stw	fp,12(sp)
81138950:	df000304 	addi	fp,sp,12
81138954:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
81138958:	e0bfff17 	ldw	r2,-4(fp)
8113895c:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
81138960:	e0bfff17 	ldw	r2,-4(fp)
81138964:	108002c4 	addi	r2,r2,11
81138968:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113896c:	e03ffe05 	stb	zero,-8(fp)
81138970:	00000706 	br	81138990 <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
81138974:	e0bffd17 	ldw	r2,-12(fp)
81138978:	10c00044 	addi	r3,r2,1
8113897c:	e0fffd15 	stw	r3,-12(fp)
81138980:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81138984:	e0bffe03 	ldbu	r2,-8(fp)
81138988:	10800044 	addi	r2,r2,1
8113898c:	e0bffe05 	stb	r2,-8(fp)
81138990:	e0bffe03 	ldbu	r2,-8(fp)
81138994:	108001b0 	cmpltui	r2,r2,6
81138998:	103ff61e 	bne	r2,zero,81138974 <__reset+0xfb118974>
        *ptbl++ = 0;
    }
}
8113899c:	0001883a 	nop
811389a0:	e037883a 	mov	sp,fp
811389a4:	df000017 	ldw	fp,0(sp)
811389a8:	dec00104 	addi	sp,sp,4
811389ac:	f800283a 	ret

811389b0 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
811389b0:	defffb04 	addi	sp,sp,-20
811389b4:	de00012e 	bgeu	sp,et,811389bc <OS_InitEventList+0xc>
811389b8:	003b68fa 	trap	3
811389bc:	dfc00415 	stw	ra,16(sp)
811389c0:	df000315 	stw	fp,12(sp)
811389c4:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
811389c8:	01434004 	movi	r5,3328
811389cc:	012045f4 	movhi	r4,33047
811389d0:	2127c004 	addi	r4,r4,-24832
811389d4:	1138d580 	call	81138d58 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
811389d8:	00a045f4 	movhi	r2,33047
811389dc:	10a7c004 	addi	r2,r2,-24832
811389e0:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
811389e4:	00a045f4 	movhi	r2,33047
811389e8:	10a7cd04 	addi	r2,r2,-24780
811389ec:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
811389f0:	e03ffd0d 	sth	zero,-12(fp)
811389f4:	00001306 	br	81138a44 <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
811389f8:	e0bffe17 	ldw	r2,-8(fp)
811389fc:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
81138a00:	e0bffe17 	ldw	r2,-8(fp)
81138a04:	e0ffff17 	ldw	r3,-4(fp)
81138a08:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
81138a0c:	e0bffe17 	ldw	r2,-8(fp)
81138a10:	00c00fc4 	movi	r3,63
81138a14:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
81138a18:	e0bffe17 	ldw	r2,-8(fp)
81138a1c:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
81138a20:	e0bffe17 	ldw	r2,-8(fp)
81138a24:	10800d04 	addi	r2,r2,52
81138a28:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
81138a2c:	e0bfff17 	ldw	r2,-4(fp)
81138a30:	10800d04 	addi	r2,r2,52
81138a34:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
81138a38:	e0bffd0b 	ldhu	r2,-12(fp)
81138a3c:	10800044 	addi	r2,r2,1
81138a40:	e0bffd0d 	sth	r2,-12(fp)
81138a44:	e0bffd0b 	ldhu	r2,-12(fp)
81138a48:	10800ff0 	cmpltui	r2,r2,63
81138a4c:	103fea1e 	bne	r2,zero,811389f8 <__reset+0xfb1189f8>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
81138a50:	e0bffe17 	ldw	r2,-8(fp)
81138a54:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
81138a58:	e0bffe17 	ldw	r2,-8(fp)
81138a5c:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
81138a60:	e0bffe17 	ldw	r2,-8(fp)
81138a64:	00c00fc4 	movi	r3,63
81138a68:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
81138a6c:	e0bffe17 	ldw	r2,-8(fp)
81138a70:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
81138a74:	00a045f4 	movhi	r2,33047
81138a78:	10a7c004 	addi	r2,r2,-24832
81138a7c:	d0a09f15 	stw	r2,-32132(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
81138a80:	0001883a 	nop
81138a84:	e037883a 	mov	sp,fp
81138a88:	dfc00117 	ldw	ra,4(sp)
81138a8c:	df000017 	ldw	fp,0(sp)
81138a90:	dec00204 	addi	sp,sp,8
81138a94:	f800283a 	ret

81138a98 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
81138a98:	deffff04 	addi	sp,sp,-4
81138a9c:	de00012e 	bgeu	sp,et,81138aa4 <OS_InitMisc+0xc>
81138aa0:	003b68fa 	trap	3
81138aa4:	df000015 	stw	fp,0(sp)
81138aa8:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
81138aac:	d020a315 	stw	zero,-32116(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
81138ab0:	d020a005 	stb	zero,-32128(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
81138ab4:	d0208e05 	stb	zero,-32200(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
81138ab8:	d0209945 	stb	zero,-32155(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
81138abc:	d0209005 	stb	zero,-32192(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
81138ac0:	d0209515 	stw	zero,-32172(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
81138ac4:	d0209115 	stw	zero,-32188(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
81138ac8:	d020a715 	stw	zero,-32100(gp)
    OSIdleCtrMax  = 0L;
81138acc:	d0209715 	stw	zero,-32164(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
81138ad0:	d020a605 	stb	zero,-32104(gp)
#endif
}
81138ad4:	0001883a 	nop
81138ad8:	e037883a 	mov	sp,fp
81138adc:	df000017 	ldw	fp,0(sp)
81138ae0:	dec00104 	addi	sp,sp,4
81138ae4:	f800283a 	ret

81138ae8 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
81138ae8:	defffd04 	addi	sp,sp,-12
81138aec:	de00012e 	bgeu	sp,et,81138af4 <OS_InitRdyList+0xc>
81138af0:	003b68fa 	trap	3
81138af4:	df000215 	stw	fp,8(sp)
81138af8:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
81138afc:	d0209d05 	stb	zero,-32140(gp)
    prdytbl       = &OSRdyTbl[0];
81138b00:	d0a09d44 	addi	r2,gp,-32139
81138b04:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
81138b08:	e03ffe05 	stb	zero,-8(fp)
81138b0c:	00000706 	br	81138b2c <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
81138b10:	e0bfff17 	ldw	r2,-4(fp)
81138b14:	10c00044 	addi	r3,r2,1
81138b18:	e0ffff15 	stw	r3,-4(fp)
81138b1c:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
81138b20:	e0bffe03 	ldbu	r2,-8(fp)
81138b24:	10800044 	addi	r2,r2,1
81138b28:	e0bffe05 	stb	r2,-8(fp)
81138b2c:	e0bffe03 	ldbu	r2,-8(fp)
81138b30:	108001b0 	cmpltui	r2,r2,6
81138b34:	103ff61e 	bne	r2,zero,81138b10 <__reset+0xfb118b10>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
81138b38:	d02092c5 	stb	zero,-32181(gp)
    OSPrioHighRdy = 0;
81138b3c:	d0209285 	stb	zero,-32182(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
81138b40:	d0209b15 	stw	zero,-32148(gp)
    OSTCBCur      = (OS_TCB *)0;
81138b44:	d020a115 	stw	zero,-32124(gp)
}
81138b48:	0001883a 	nop
81138b4c:	e037883a 	mov	sp,fp
81138b50:	df000017 	ldw	fp,0(sp)
81138b54:	dec00104 	addi	sp,sp,4
81138b58:	f800283a 	ret

81138b5c <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
81138b5c:	defff804 	addi	sp,sp,-32
81138b60:	de00012e 	bgeu	sp,et,81138b68 <OS_InitTaskIdle+0xc>
81138b64:	003b68fa 	trap	3
81138b68:	dfc00715 	stw	ra,28(sp)
81138b6c:	df000615 	stw	fp,24(sp)
81138b70:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
81138b74:	008000c4 	movi	r2,3
81138b78:	d8800415 	stw	r2,16(sp)
81138b7c:	d8000315 	stw	zero,12(sp)
81138b80:	00810004 	movi	r2,1024
81138b84:	d8800215 	stw	r2,8(sp)
81138b88:	00a045f4 	movhi	r2,33047
81138b8c:	10a3c004 	addi	r2,r2,-28928
81138b90:	d8800115 	stw	r2,4(sp)
81138b94:	00bfffd4 	movui	r2,65535
81138b98:	d8800015 	stw	r2,0(sp)
81138b9c:	01c00a84 	movi	r7,42
81138ba0:	01a045f4 	movhi	r6,33047
81138ba4:	31a7bf04 	addi	r6,r6,-24836
81138ba8:	000b883a 	mov	r5,zero
81138bac:	01204534 	movhi	r4,33044
81138bb0:	21241404 	addi	r4,r4,-28592
81138bb4:	113ea400 	call	8113ea40 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
81138bb8:	e1bfff04 	addi	r6,fp,-4
81138bbc:	01604574 	movhi	r5,33045
81138bc0:	29403404 	addi	r5,r5,208
81138bc4:	01000a84 	movi	r4,42
81138bc8:	113f2700 	call	8113f270 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
81138bcc:	0001883a 	nop
81138bd0:	e037883a 	mov	sp,fp
81138bd4:	dfc00117 	ldw	ra,4(sp)
81138bd8:	df000017 	ldw	fp,0(sp)
81138bdc:	dec00204 	addi	sp,sp,8
81138be0:	f800283a 	ret

81138be4 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
81138be4:	defff804 	addi	sp,sp,-32
81138be8:	de00012e 	bgeu	sp,et,81138bf0 <OS_InitTaskStat+0xc>
81138bec:	003b68fa 	trap	3
81138bf0:	dfc00715 	stw	ra,28(sp)
81138bf4:	df000615 	stw	fp,24(sp)
81138bf8:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
81138bfc:	008000c4 	movi	r2,3
81138c00:	d8800415 	stw	r2,16(sp)
81138c04:	d8000315 	stw	zero,12(sp)
81138c08:	00810004 	movi	r2,1024
81138c0c:	d8800215 	stw	r2,8(sp)
81138c10:	00a045b4 	movhi	r2,33046
81138c14:	109d0004 	addi	r2,r2,29696
81138c18:	d8800115 	stw	r2,4(sp)
81138c1c:	00bfff94 	movui	r2,65534
81138c20:	d8800015 	stw	r2,0(sp)
81138c24:	01c00a44 	movi	r7,41
81138c28:	01a045f4 	movhi	r6,33047
81138c2c:	31a0ff04 	addi	r6,r6,-31748
81138c30:	000b883a 	mov	r5,zero
81138c34:	01204534 	movhi	r4,33044
81138c38:	21242d04 	addi	r4,r4,-28492
81138c3c:	113ea400 	call	8113ea40 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
81138c40:	e1bfff04 	addi	r6,fp,-4
81138c44:	01604574 	movhi	r5,33045
81138c48:	29403804 	addi	r5,r5,224
81138c4c:	01000a44 	movi	r4,41
81138c50:	113f2700 	call	8113f270 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
81138c54:	0001883a 	nop
81138c58:	e037883a 	mov	sp,fp
81138c5c:	dfc00117 	ldw	ra,4(sp)
81138c60:	df000017 	ldw	fp,0(sp)
81138c64:	dec00204 	addi	sp,sp,8
81138c68:	f800283a 	ret

81138c6c <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
81138c6c:	defffb04 	addi	sp,sp,-20
81138c70:	de00012e 	bgeu	sp,et,81138c78 <OS_InitTCBList+0xc>
81138c74:	003b68fa 	trap	3
81138c78:	dfc00415 	stw	ra,16(sp)
81138c7c:	df000315 	stw	fp,12(sp)
81138c80:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
81138c84:	01446e04 	movi	r5,4536
81138c88:	012045f4 	movhi	r4,33047
81138c8c:	212b0004 	addi	r4,r4,-21504
81138c90:	1138d580 	call	81138d58 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
81138c94:	01402b04 	movi	r5,172
81138c98:	012045f4 	movhi	r4,33047
81138c9c:	212f6e04 	addi	r4,r4,-16968
81138ca0:	1138d580 	call	81138d58 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
81138ca4:	00a045f4 	movhi	r2,33047
81138ca8:	10ab0004 	addi	r2,r2,-21504
81138cac:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
81138cb0:	00a045f4 	movhi	r2,33047
81138cb4:	10ab1b04 	addi	r2,r2,-21396
81138cb8:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81138cbc:	e03ffd05 	stb	zero,-12(fp)
81138cc0:	00001106 	br	81138d08 <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
81138cc4:	e0bffe17 	ldw	r2,-8(fp)
81138cc8:	e0ffff17 	ldw	r3,-4(fp)
81138ccc:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
81138cd0:	e0bffe17 	ldw	r2,-8(fp)
81138cd4:	00c00fc4 	movi	r3,63
81138cd8:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81138cdc:	e0bffe17 	ldw	r2,-8(fp)
81138ce0:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
81138ce4:	e0bffe17 	ldw	r2,-8(fp)
81138ce8:	10801b04 	addi	r2,r2,108
81138cec:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
81138cf0:	e0bfff17 	ldw	r2,-4(fp)
81138cf4:	10801b04 	addi	r2,r2,108
81138cf8:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81138cfc:	e0bffd03 	ldbu	r2,-12(fp)
81138d00:	10800044 	addi	r2,r2,1
81138d04:	e0bffd05 	stb	r2,-12(fp)
81138d08:	e0bffd03 	ldbu	r2,-12(fp)
81138d0c:	10800a70 	cmpltui	r2,r2,41
81138d10:	103fec1e 	bne	r2,zero,81138cc4 <__reset+0xfb118cc4>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
81138d14:	e0bffe17 	ldw	r2,-8(fp)
81138d18:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
81138d1c:	e0bffe17 	ldw	r2,-8(fp)
81138d20:	00c00fc4 	movi	r3,63
81138d24:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81138d28:	e0bffe17 	ldw	r2,-8(fp)
81138d2c:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
81138d30:	d0209315 	stw	zero,-32180(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
81138d34:	00a045f4 	movhi	r2,33047
81138d38:	10ab0004 	addi	r2,r2,-21504
81138d3c:	d0a09815 	stw	r2,-32160(gp)
}
81138d40:	0001883a 	nop
81138d44:	e037883a 	mov	sp,fp
81138d48:	dfc00117 	ldw	ra,4(sp)
81138d4c:	df000017 	ldw	fp,0(sp)
81138d50:	dec00204 	addi	sp,sp,8
81138d54:	f800283a 	ret

81138d58 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
81138d58:	defffd04 	addi	sp,sp,-12
81138d5c:	de00012e 	bgeu	sp,et,81138d64 <OS_MemClr+0xc>
81138d60:	003b68fa 	trap	3
81138d64:	df000215 	stw	fp,8(sp)
81138d68:	df000204 	addi	fp,sp,8
81138d6c:	e13ffe15 	stw	r4,-8(fp)
81138d70:	2805883a 	mov	r2,r5
81138d74:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81138d78:	00000706 	br	81138d98 <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
81138d7c:	e0bffe17 	ldw	r2,-8(fp)
81138d80:	10c00044 	addi	r3,r2,1
81138d84:	e0fffe15 	stw	r3,-8(fp)
81138d88:	10000005 	stb	zero,0(r2)
        size--;
81138d8c:	e0bfff0b 	ldhu	r2,-4(fp)
81138d90:	10bfffc4 	addi	r2,r2,-1
81138d94:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
81138d98:	e0bfff0b 	ldhu	r2,-4(fp)
81138d9c:	103ff71e 	bne	r2,zero,81138d7c <__reset+0xfb118d7c>
        *pdest++ = (INT8U)0;
        size--;
    }
}
81138da0:	0001883a 	nop
81138da4:	e037883a 	mov	sp,fp
81138da8:	df000017 	ldw	fp,0(sp)
81138dac:	dec00104 	addi	sp,sp,4
81138db0:	f800283a 	ret

81138db4 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
81138db4:	defffc04 	addi	sp,sp,-16
81138db8:	de00012e 	bgeu	sp,et,81138dc0 <OS_MemCopy+0xc>
81138dbc:	003b68fa 	trap	3
81138dc0:	df000315 	stw	fp,12(sp)
81138dc4:	df000304 	addi	fp,sp,12
81138dc8:	e13ffd15 	stw	r4,-12(fp)
81138dcc:	e17ffe15 	stw	r5,-8(fp)
81138dd0:	3005883a 	mov	r2,r6
81138dd4:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81138dd8:	00000b06 	br	81138e08 <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
81138ddc:	e0bffd17 	ldw	r2,-12(fp)
81138de0:	10c00044 	addi	r3,r2,1
81138de4:	e0fffd15 	stw	r3,-12(fp)
81138de8:	e0fffe17 	ldw	r3,-8(fp)
81138dec:	19000044 	addi	r4,r3,1
81138df0:	e13ffe15 	stw	r4,-8(fp)
81138df4:	18c00003 	ldbu	r3,0(r3)
81138df8:	10c00005 	stb	r3,0(r2)
        size--;
81138dfc:	e0bfff0b 	ldhu	r2,-4(fp)
81138e00:	10bfffc4 	addi	r2,r2,-1
81138e04:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
81138e08:	e0bfff0b 	ldhu	r2,-4(fp)
81138e0c:	103ff31e 	bne	r2,zero,81138ddc <__reset+0xfb118ddc>
        *pdest++ = *psrc++;
        size--;
    }
}
81138e10:	0001883a 	nop
81138e14:	e037883a 	mov	sp,fp
81138e18:	df000017 	ldw	fp,0(sp)
81138e1c:	dec00104 	addi	sp,sp,4
81138e20:	f800283a 	ret

81138e24 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
81138e24:	defffb04 	addi	sp,sp,-20
81138e28:	de00012e 	bgeu	sp,et,81138e30 <OS_Sched+0xc>
81138e2c:	003b68fa 	trap	3
81138e30:	dfc00415 	stw	ra,16(sp)
81138e34:	df000315 	stw	fp,12(sp)
81138e38:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81138e3c:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138e40:	0005303a 	rdctl	r2,status
81138e44:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138e48:	e0ffff17 	ldw	r3,-4(fp)
81138e4c:	00bfff84 	movi	r2,-2
81138e50:	1884703a 	and	r2,r3,r2
81138e54:	1001703a 	wrctl	status,r2
  
  return context;
81138e58:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
81138e5c:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
81138e60:	d0a0a003 	ldbu	r2,-32128(gp)
81138e64:	10803fcc 	andi	r2,r2,255
81138e68:	10001a1e 	bne	r2,zero,81138ed4 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
81138e6c:	d0a08e03 	ldbu	r2,-32200(gp)
81138e70:	10803fcc 	andi	r2,r2,255
81138e74:	1000171e 	bne	r2,zero,81138ed4 <OS_Sched+0xb0>
            OS_SchedNew();
81138e78:	1138efc0 	call	81138efc <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
81138e7c:	d0e09283 	ldbu	r3,-32182(gp)
81138e80:	d0a092c3 	ldbu	r2,-32181(gp)
81138e84:	18c03fcc 	andi	r3,r3,255
81138e88:	10803fcc 	andi	r2,r2,255
81138e8c:	18801126 	beq	r3,r2,81138ed4 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
81138e90:	d0a09283 	ldbu	r2,-32182(gp)
81138e94:	10c03fcc 	andi	r3,r2,255
81138e98:	00a045f4 	movhi	r2,33047
81138e9c:	10af6e04 	addi	r2,r2,-16968
81138ea0:	18c7883a 	add	r3,r3,r3
81138ea4:	18c7883a 	add	r3,r3,r3
81138ea8:	10c5883a 	add	r2,r2,r3
81138eac:	10800017 	ldw	r2,0(r2)
81138eb0:	d0a09b15 	stw	r2,-32148(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
81138eb4:	d0a09b17 	ldw	r2,-32148(gp)
81138eb8:	10c00e17 	ldw	r3,56(r2)
81138ebc:	18c00044 	addi	r3,r3,1
81138ec0:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
81138ec4:	d0a09517 	ldw	r2,-32172(gp)
81138ec8:	10800044 	addi	r2,r2,1
81138ecc:	d0a09515 	stw	r2,-32172(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
81138ed0:	1149e540 	call	81149e54 <OSCtxSw>
81138ed4:	e0bffd17 	ldw	r2,-12(fp)
81138ed8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138edc:	e0bffe17 	ldw	r2,-8(fp)
81138ee0:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
81138ee4:	0001883a 	nop
81138ee8:	e037883a 	mov	sp,fp
81138eec:	dfc00117 	ldw	ra,4(sp)
81138ef0:	df000017 	ldw	fp,0(sp)
81138ef4:	dec00204 	addi	sp,sp,8
81138ef8:	f800283a 	ret

81138efc <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
81138efc:	defffe04 	addi	sp,sp,-8
81138f00:	de00012e 	bgeu	sp,et,81138f08 <OS_SchedNew+0xc>
81138f04:	003b68fa 	trap	3
81138f08:	df000115 	stw	fp,4(sp)
81138f0c:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
81138f10:	d0a09d03 	ldbu	r2,-32140(gp)
81138f14:	10c03fcc 	andi	r3,r2,255
81138f18:	00a04574 	movhi	r2,33045
81138f1c:	10bff404 	addi	r2,r2,-48
81138f20:	10c5883a 	add	r2,r2,r3
81138f24:	10800003 	ldbu	r2,0(r2)
81138f28:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
81138f2c:	e0bfff03 	ldbu	r2,-4(fp)
81138f30:	100490fa 	slli	r2,r2,3
81138f34:	1009883a 	mov	r4,r2
81138f38:	e0ffff03 	ldbu	r3,-4(fp)
81138f3c:	d0a09d44 	addi	r2,gp,-32139
81138f40:	1885883a 	add	r2,r3,r2
81138f44:	10800003 	ldbu	r2,0(r2)
81138f48:	10c03fcc 	andi	r3,r2,255
81138f4c:	00a04574 	movhi	r2,33045
81138f50:	10bff404 	addi	r2,r2,-48
81138f54:	10c5883a 	add	r2,r2,r3
81138f58:	10800003 	ldbu	r2,0(r2)
81138f5c:	2085883a 	add	r2,r4,r2
81138f60:	d0a09285 	stb	r2,-32182(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
81138f64:	0001883a 	nop
81138f68:	e037883a 	mov	sp,fp
81138f6c:	df000017 	ldw	fp,0(sp)
81138f70:	dec00104 	addi	sp,sp,4
81138f74:	f800283a 	ret

81138f78 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
81138f78:	defffc04 	addi	sp,sp,-16
81138f7c:	de00012e 	bgeu	sp,et,81138f84 <OS_StrCopy+0xc>
81138f80:	003b68fa 	trap	3
81138f84:	df000315 	stw	fp,12(sp)
81138f88:	df000304 	addi	fp,sp,12
81138f8c:	e13ffe15 	stw	r4,-8(fp)
81138f90:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
81138f94:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
81138f98:	00000b06 	br	81138fc8 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
81138f9c:	e0bffe17 	ldw	r2,-8(fp)
81138fa0:	10c00044 	addi	r3,r2,1
81138fa4:	e0fffe15 	stw	r3,-8(fp)
81138fa8:	e0ffff17 	ldw	r3,-4(fp)
81138fac:	19000044 	addi	r4,r3,1
81138fb0:	e13fff15 	stw	r4,-4(fp)
81138fb4:	18c00003 	ldbu	r3,0(r3)
81138fb8:	10c00005 	stb	r3,0(r2)
        len++;
81138fbc:	e0bffd03 	ldbu	r2,-12(fp)
81138fc0:	10800044 	addi	r2,r2,1
81138fc4:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81138fc8:	e0bfff17 	ldw	r2,-4(fp)
81138fcc:	10800003 	ldbu	r2,0(r2)
81138fd0:	10803fcc 	andi	r2,r2,255
81138fd4:	103ff11e 	bne	r2,zero,81138f9c <__reset+0xfb118f9c>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
81138fd8:	e0bffe17 	ldw	r2,-8(fp)
81138fdc:	10000005 	stb	zero,0(r2)
    return (len);
81138fe0:	e0bffd03 	ldbu	r2,-12(fp)
}
81138fe4:	e037883a 	mov	sp,fp
81138fe8:	df000017 	ldw	fp,0(sp)
81138fec:	dec00104 	addi	sp,sp,4
81138ff0:	f800283a 	ret

81138ff4 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
81138ff4:	defffd04 	addi	sp,sp,-12
81138ff8:	de00012e 	bgeu	sp,et,81139000 <OS_StrLen+0xc>
81138ffc:	003b68fa 	trap	3
81139000:	df000215 	stw	fp,8(sp)
81139004:	df000204 	addi	fp,sp,8
81139008:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
8113900c:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
81139010:	00000606 	br	8113902c <OS_StrLen+0x38>
        psrc++;
81139014:	e0bfff17 	ldw	r2,-4(fp)
81139018:	10800044 	addi	r2,r2,1
8113901c:	e0bfff15 	stw	r2,-4(fp)
        len++;
81139020:	e0bffe03 	ldbu	r2,-8(fp)
81139024:	10800044 	addi	r2,r2,1
81139028:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
8113902c:	e0bfff17 	ldw	r2,-4(fp)
81139030:	10800003 	ldbu	r2,0(r2)
81139034:	10803fcc 	andi	r2,r2,255
81139038:	103ff61e 	bne	r2,zero,81139014 <__reset+0xfb119014>
        psrc++;
        len++;
    }
    return (len);
8113903c:	e0bffe03 	ldbu	r2,-8(fp)
}
81139040:	e037883a 	mov	sp,fp
81139044:	df000017 	ldw	fp,0(sp)
81139048:	dec00104 	addi	sp,sp,4
8113904c:	f800283a 	ret

81139050 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
81139050:	defffa04 	addi	sp,sp,-24
81139054:	de00012e 	bgeu	sp,et,8113905c <OS_TaskIdle+0xc>
81139058:	003b68fa 	trap	3
8113905c:	dfc00515 	stw	ra,20(sp)
81139060:	df000415 	stw	fp,16(sp)
81139064:	df000404 	addi	fp,sp,16
81139068:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113906c:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139070:	0005303a 	rdctl	r2,status
81139074:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139078:	e0fffd17 	ldw	r3,-12(fp)
8113907c:	00bfff84 	movi	r2,-2
81139080:	1884703a 	and	r2,r3,r2
81139084:	1001703a 	wrctl	status,r2
  
  return context;
81139088:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
8113908c:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
81139090:	d0a09117 	ldw	r2,-32188(gp)
81139094:	10800044 	addi	r2,r2,1
81139098:	d0a09115 	stw	r2,-32188(gp)
8113909c:	e0bffc17 	ldw	r2,-16(fp)
811390a0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811390a4:	e0bffe17 	ldw	r2,-8(fp)
811390a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
811390ac:	114a1e80 	call	8114a1e8 <OSTaskIdleHook>
    }
811390b0:	003fef06 	br	81139070 <__reset+0xfb119070>

811390b4 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
811390b4:	defff804 	addi	sp,sp,-32
811390b8:	de00012e 	bgeu	sp,et,811390c0 <OS_TaskStat+0xc>
811390bc:	003b68fa 	trap	3
811390c0:	dfc00715 	stw	ra,28(sp)
811390c4:	df000615 	stw	fp,24(sp)
811390c8:	dc400515 	stw	r17,20(sp)
811390cc:	dc000415 	stw	r16,16(sp)
811390d0:	df000604 	addi	fp,sp,24
811390d4:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811390d8:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
811390dc:	00000206 	br	811390e8 <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
811390e0:	01003204 	movi	r4,200
811390e4:	113fb600 	call	8113fb60 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
811390e8:	d0a0a603 	ldbu	r2,-32104(gp)
811390ec:	10803fcc 	andi	r2,r2,255
811390f0:	103ffb26 	beq	r2,zero,811390e0 <__reset+0xfb1190e0>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
811390f4:	d0e09717 	ldw	r3,-32164(gp)
811390f8:	00947b34 	movhi	r2,20972
811390fc:	10a147c4 	addi	r2,r2,-31457
81139100:	1888383a 	mulxuu	r4,r3,r2
81139104:	1885383a 	mul	r2,r3,r2
81139108:	1021883a 	mov	r16,r2
8113910c:	2023883a 	mov	r17,r4
81139110:	8804d17a 	srli	r2,r17,5
81139114:	d0a09715 	stw	r2,-32164(gp)
    if (OSIdleCtrMax == 0L) {
81139118:	d0a09717 	ldw	r2,-32164(gp)
8113911c:	1000031e 	bne	r2,zero,8113912c <OS_TaskStat+0x78>
        OSCPUUsage = 0;
81139120:	d0209905 	stb	zero,-32156(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
81139124:	01003fc4 	movi	r4,255
81139128:	113f7d00 	call	8113f7d0 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113912c:	0005303a 	rdctl	r2,status
81139130:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139134:	e0fffb17 	ldw	r3,-20(fp)
81139138:	00bfff84 	movi	r2,-2
8113913c:	1884703a 	and	r2,r3,r2
81139140:	1001703a 	wrctl	status,r2
  
  return context;
81139144:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
81139148:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
8113914c:	d0a09117 	ldw	r2,-32188(gp)
81139150:	d0a0a715 	stw	r2,-32100(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
81139154:	d0209115 	stw	zero,-32188(gp)
81139158:	e0bffa17 	ldw	r2,-24(fp)
8113915c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139160:	e0bffc17 	ldw	r2,-16(fp)
81139164:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
81139168:	d0e0a717 	ldw	r3,-32100(gp)
8113916c:	d0a09717 	ldw	r2,-32164(gp)
81139170:	1885203a 	divu	r2,r3,r2
81139174:	1007883a 	mov	r3,r2
81139178:	00801904 	movi	r2,100
8113917c:	10c5c83a 	sub	r2,r2,r3
81139180:	d0a09905 	stb	r2,-32156(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
81139184:	114a1180 	call	8114a118 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
81139188:	11391980 	call	81139198 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
8113918c:	01001904 	movi	r4,100
81139190:	113fb600 	call	8113fb60 <OSTimeDly>
    }
81139194:	003fe506 	br	8113912c <__reset+0xfb11912c>

81139198 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
81139198:	defffa04 	addi	sp,sp,-24
8113919c:	de00012e 	bgeu	sp,et,811391a4 <OS_TaskStatStkChk+0xc>
811391a0:	003b68fa 	trap	3
811391a4:	dfc00515 	stw	ra,20(sp)
811391a8:	df000415 	stw	fp,16(sp)
811391ac:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
811391b0:	e03ffc05 	stb	zero,-16(fp)
811391b4:	00002406 	br	81139248 <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
811391b8:	e0bffc03 	ldbu	r2,-16(fp)
811391bc:	e0fffe04 	addi	r3,fp,-8
811391c0:	180b883a 	mov	r5,r3
811391c4:	1009883a 	mov	r4,r2
811391c8:	113f6080 	call	8113f608 <OSTaskStkChk>
811391cc:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
811391d0:	e0bffc43 	ldbu	r2,-15(fp)
811391d4:	1000191e 	bne	r2,zero,8113923c <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
811391d8:	e0fffc03 	ldbu	r3,-16(fp)
811391dc:	00a045f4 	movhi	r2,33047
811391e0:	10af6e04 	addi	r2,r2,-16968
811391e4:	18c7883a 	add	r3,r3,r3
811391e8:	18c7883a 	add	r3,r3,r3
811391ec:	10c5883a 	add	r2,r2,r3
811391f0:	10800017 	ldw	r2,0(r2)
811391f4:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
811391f8:	e0bffd17 	ldw	r2,-12(fp)
811391fc:	10000f26 	beq	r2,zero,8113923c <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
81139200:	e0bffd17 	ldw	r2,-12(fp)
81139204:	10800060 	cmpeqi	r2,r2,1
81139208:	10000c1e 	bne	r2,zero,8113923c <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
8113920c:	e0bffd17 	ldw	r2,-12(fp)
81139210:	10c00217 	ldw	r3,8(r2)
81139214:	e0bffd17 	ldw	r2,-12(fp)
81139218:	10800317 	ldw	r2,12(r2)
8113921c:	1085883a 	add	r2,r2,r2
81139220:	1085883a 	add	r2,r2,r2
81139224:	1887883a 	add	r3,r3,r2
81139228:	e0bffd17 	ldw	r2,-12(fp)
8113922c:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
81139230:	e0ffff17 	ldw	r3,-4(fp)
81139234:	e0bffd17 	ldw	r2,-12(fp)
81139238:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
8113923c:	e0bffc03 	ldbu	r2,-16(fp)
81139240:	10800044 	addi	r2,r2,1
81139244:	e0bffc05 	stb	r2,-16(fp)
81139248:	e0bffc03 	ldbu	r2,-16(fp)
8113924c:	10800af0 	cmpltui	r2,r2,43
81139250:	103fd91e 	bne	r2,zero,811391b8 <__reset+0xfb1191b8>
#endif
                }
            }
        }
    }
}
81139254:	0001883a 	nop
81139258:	e037883a 	mov	sp,fp
8113925c:	dfc00117 	ldw	ra,4(sp)
81139260:	df000017 	ldw	fp,0(sp)
81139264:	dec00204 	addi	sp,sp,8
81139268:	f800283a 	ret

8113926c <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
8113926c:	defff204 	addi	sp,sp,-56
81139270:	de00012e 	bgeu	sp,et,81139278 <OS_TCBInit+0xc>
81139274:	003b68fa 	trap	3
81139278:	dfc00d15 	stw	ra,52(sp)
8113927c:	df000c15 	stw	fp,48(sp)
81139280:	df000c04 	addi	fp,sp,48
81139284:	e17ffc15 	stw	r5,-16(fp)
81139288:	e1bffd15 	stw	r6,-12(fp)
8113928c:	3807883a 	mov	r3,r7
81139290:	e0800417 	ldw	r2,16(fp)
81139294:	e13ffb05 	stb	r4,-20(fp)
81139298:	e0fffe0d 	sth	r3,-8(fp)
8113929c:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
811392a0:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811392a4:	0005303a 	rdctl	r2,status
811392a8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811392ac:	e0fffa17 	ldw	r3,-24(fp)
811392b0:	00bfff84 	movi	r2,-2
811392b4:	1884703a 	and	r2,r3,r2
811392b8:	1001703a 	wrctl	status,r2
  
  return context;
811392bc:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
811392c0:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
811392c4:	d0a09817 	ldw	r2,-32160(gp)
811392c8:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
811392cc:	e0bff617 	ldw	r2,-40(fp)
811392d0:	10009326 	beq	r2,zero,81139520 <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
811392d4:	e0bff617 	ldw	r2,-40(fp)
811392d8:	10800517 	ldw	r2,20(r2)
811392dc:	d0a09815 	stw	r2,-32160(gp)
811392e0:	e0bff417 	ldw	r2,-48(fp)
811392e4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811392e8:	e0bff817 	ldw	r2,-32(fp)
811392ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
811392f0:	e0bff617 	ldw	r2,-40(fp)
811392f4:	e0fffc17 	ldw	r3,-16(fp)
811392f8:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
811392fc:	e0bff617 	ldw	r2,-40(fp)
81139300:	e0fffb03 	ldbu	r3,-20(fp)
81139304:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
81139308:	e0bff617 	ldw	r2,-40(fp)
8113930c:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
81139310:	e0bff617 	ldw	r2,-40(fp)
81139314:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
81139318:	e0bff617 	ldw	r2,-40(fp)
8113931c:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
81139320:	e0bff617 	ldw	r2,-40(fp)
81139324:	e0c00317 	ldw	r3,12(fp)
81139328:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
8113932c:	e0bff617 	ldw	r2,-40(fp)
81139330:	e0c00217 	ldw	r3,8(fp)
81139334:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
81139338:	e0bff617 	ldw	r2,-40(fp)
8113933c:	e0fffd17 	ldw	r3,-12(fp)
81139340:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
81139344:	e0bff617 	ldw	r2,-40(fp)
81139348:	e0ffff0b 	ldhu	r3,-4(fp)
8113934c:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
81139350:	e0bff617 	ldw	r2,-40(fp)
81139354:	e0fffe0b 	ldhu	r3,-8(fp)
81139358:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
8113935c:	e0bff617 	ldw	r2,-40(fp)
81139360:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
81139364:	e0bffb03 	ldbu	r2,-20(fp)
81139368:	1004d0fa 	srli	r2,r2,3
8113936c:	1007883a 	mov	r3,r2
81139370:	e0bff617 	ldw	r2,-40(fp)
81139374:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
81139378:	e0bffb03 	ldbu	r2,-20(fp)
8113937c:	108001cc 	andi	r2,r2,7
81139380:	1007883a 	mov	r3,r2
81139384:	e0bff617 	ldw	r2,-40(fp)
81139388:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
8113938c:	e0bff617 	ldw	r2,-40(fp)
81139390:	10800d03 	ldbu	r2,52(r2)
81139394:	10803fcc 	andi	r2,r2,255
81139398:	00c00044 	movi	r3,1
8113939c:	1884983a 	sll	r2,r3,r2
811393a0:	1007883a 	mov	r3,r2
811393a4:	e0bff617 	ldw	r2,-40(fp)
811393a8:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
811393ac:	e0bff617 	ldw	r2,-40(fp)
811393b0:	10800cc3 	ldbu	r2,51(r2)
811393b4:	10803fcc 	andi	r2,r2,255
811393b8:	00c00044 	movi	r3,1
811393bc:	1884983a 	sll	r2,r3,r2
811393c0:	1007883a 	mov	r3,r2
811393c4:	e0bff617 	ldw	r2,-40(fp)
811393c8:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
811393cc:	e0bff617 	ldw	r2,-40(fp)
811393d0:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
811393d4:	e0bff617 	ldw	r2,-40(fp)
811393d8:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
811393dc:	e0bff617 	ldw	r2,-40(fp)
811393e0:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
811393e4:	e0bff617 	ldw	r2,-40(fp)
811393e8:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
811393ec:	e0bff617 	ldw	r2,-40(fp)
811393f0:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
811393f4:	e0bff617 	ldw	r2,-40(fp)
811393f8:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
811393fc:	e0bff617 	ldw	r2,-40(fp)
81139400:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
81139404:	e0bff617 	ldw	r2,-40(fp)
81139408:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
8113940c:	e0bff617 	ldw	r2,-40(fp)
81139410:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
81139414:	e0bff617 	ldw	r2,-40(fp)
81139418:	00c00fc4 	movi	r3,63
8113941c:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
81139420:	e0bff617 	ldw	r2,-40(fp)
81139424:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
81139428:	e13ff617 	ldw	r4,-40(fp)
8113942c:	114a2100 	call	8114a210 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
81139430:	e13ff617 	ldw	r4,-40(fp)
81139434:	114a0980 	call	8114a098 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139438:	0005303a 	rdctl	r2,status
8113943c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139440:	e0fff517 	ldw	r3,-44(fp)
81139444:	00bfff84 	movi	r2,-2
81139448:	1884703a 	and	r2,r3,r2
8113944c:	1001703a 	wrctl	status,r2
  
  return context;
81139450:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
81139454:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
81139458:	e0fffb03 	ldbu	r3,-20(fp)
8113945c:	00a045f4 	movhi	r2,33047
81139460:	10af6e04 	addi	r2,r2,-16968
81139464:	18c7883a 	add	r3,r3,r3
81139468:	18c7883a 	add	r3,r3,r3
8113946c:	10c5883a 	add	r2,r2,r3
81139470:	e0fff617 	ldw	r3,-40(fp)
81139474:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
81139478:	d0e09317 	ldw	r3,-32180(gp)
8113947c:	e0bff617 	ldw	r2,-40(fp)
81139480:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
81139484:	e0bff617 	ldw	r2,-40(fp)
81139488:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
8113948c:	d0a09317 	ldw	r2,-32180(gp)
81139490:	10000326 	beq	r2,zero,811394a0 <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
81139494:	d0a09317 	ldw	r2,-32180(gp)
81139498:	e0fff617 	ldw	r3,-40(fp)
8113949c:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
811394a0:	e0bff617 	ldw	r2,-40(fp)
811394a4:	d0a09315 	stw	r2,-32180(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
811394a8:	e0bff617 	ldw	r2,-40(fp)
811394ac:	10c00d83 	ldbu	r3,54(r2)
811394b0:	d0a09d03 	ldbu	r2,-32140(gp)
811394b4:	1884b03a 	or	r2,r3,r2
811394b8:	d0a09d05 	stb	r2,-32140(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811394bc:	e0bff617 	ldw	r2,-40(fp)
811394c0:	10800d03 	ldbu	r2,52(r2)
811394c4:	10c03fcc 	andi	r3,r2,255
811394c8:	e0bff617 	ldw	r2,-40(fp)
811394cc:	10800d03 	ldbu	r2,52(r2)
811394d0:	11003fcc 	andi	r4,r2,255
811394d4:	d0a09d44 	addi	r2,gp,-32139
811394d8:	2085883a 	add	r2,r4,r2
811394dc:	11000003 	ldbu	r4,0(r2)
811394e0:	e0bff617 	ldw	r2,-40(fp)
811394e4:	10800d43 	ldbu	r2,53(r2)
811394e8:	2084b03a 	or	r2,r4,r2
811394ec:	1009883a 	mov	r4,r2
811394f0:	d0a09d44 	addi	r2,gp,-32139
811394f4:	1885883a 	add	r2,r3,r2
811394f8:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
811394fc:	d0a09943 	ldbu	r2,-32155(gp)
81139500:	10800044 	addi	r2,r2,1
81139504:	d0a09945 	stb	r2,-32155(gp)
81139508:	e0bff417 	ldw	r2,-48(fp)
8113950c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139510:	e0bff717 	ldw	r2,-36(fp)
81139514:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
81139518:	0005883a 	mov	r2,zero
8113951c:	00000506 	br	81139534 <OS_TCBInit+0x2c8>
81139520:	e0bff417 	ldw	r2,-48(fp)
81139524:	e0bff915 	stw	r2,-28(fp)
81139528:	e0bff917 	ldw	r2,-28(fp)
8113952c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
81139530:	00801084 	movi	r2,66
}
81139534:	e037883a 	mov	sp,fp
81139538:	dfc00117 	ldw	ra,4(sp)
8113953c:	df000017 	ldw	fp,0(sp)
81139540:	dec00204 	addi	sp,sp,8
81139544:	f800283a 	ret

81139548 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
81139548:	defffe04 	addi	sp,sp,-8
8113954c:	de00012e 	bgeu	sp,et,81139554 <OSDebugInit+0xc>
81139550:	003b68fa 	trap	3
81139554:	df000115 	stw	fp,4(sp)
81139558:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
8113955c:	d0a01804 	addi	r2,gp,-32672
81139560:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
81139564:	d0a01904 	addi	r2,gp,-32668
81139568:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
8113956c:	d0a01a84 	addi	r2,gp,-32662
81139570:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
81139574:	d0a01b04 	addi	r2,gp,-32660
81139578:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
8113957c:	d0a01a04 	addi	r2,gp,-32664
81139580:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
81139584:	d0a01b84 	addi	r2,gp,-32658
81139588:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
8113958c:	d0a01c04 	addi	r2,gp,-32656
81139590:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
81139594:	d0a01c84 	addi	r2,gp,-32654
81139598:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
8113959c:	d0a01d04 	addi	r2,gp,-32652
811395a0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
811395a4:	d0a01d84 	addi	r2,gp,-32650
811395a8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
811395ac:	d0a01e04 	addi	r2,gp,-32648
811395b0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
811395b4:	d0a01e84 	addi	r2,gp,-32646
811395b8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
811395bc:	d0a01f04 	addi	r2,gp,-32644
811395c0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
811395c4:	d0a01f84 	addi	r2,gp,-32642
811395c8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
811395cc:	d0a02004 	addi	r2,gp,-32640
811395d0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
811395d4:	d0a02084 	addi	r2,gp,-32638
811395d8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
811395dc:	d0a02104 	addi	r2,gp,-32636
811395e0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
811395e4:	d0a02184 	addi	r2,gp,-32634
811395e8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
811395ec:	d0a02204 	addi	r2,gp,-32632
811395f0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
811395f4:	d0a02284 	addi	r2,gp,-32630
811395f8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
811395fc:	d0a02304 	addi	r2,gp,-32628
81139600:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
81139604:	d0a02384 	addi	r2,gp,-32626
81139608:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
8113960c:	d0a02404 	addi	r2,gp,-32624
81139610:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
81139614:	d0a02484 	addi	r2,gp,-32622
81139618:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
8113961c:	d0a02504 	addi	r2,gp,-32620
81139620:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
81139624:	d0a02584 	addi	r2,gp,-32618
81139628:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
8113962c:	d0a02604 	addi	r2,gp,-32616
81139630:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
81139634:	d0a02684 	addi	r2,gp,-32614
81139638:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
8113963c:	d0a02704 	addi	r2,gp,-32612
81139640:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
81139644:	d0a02784 	addi	r2,gp,-32610
81139648:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
8113964c:	d0a02804 	addi	r2,gp,-32608
81139650:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
81139654:	d0a02884 	addi	r2,gp,-32606
81139658:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
8113965c:	d0a02904 	addi	r2,gp,-32604
81139660:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
81139664:	d0a02984 	addi	r2,gp,-32602
81139668:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
8113966c:	d0a02a04 	addi	r2,gp,-32600
81139670:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
81139674:	d0a02a84 	addi	r2,gp,-32598
81139678:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
8113967c:	d0a02b04 	addi	r2,gp,-32596
81139680:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
81139684:	d0a02b84 	addi	r2,gp,-32594
81139688:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
8113968c:	d0a02c04 	addi	r2,gp,-32592
81139690:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
81139694:	d0a02c84 	addi	r2,gp,-32590
81139698:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
8113969c:	d0a02d04 	addi	r2,gp,-32588
811396a0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
811396a4:	d0a02d84 	addi	r2,gp,-32586
811396a8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
811396ac:	d0a02e04 	addi	r2,gp,-32584
811396b0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
811396b4:	d0a02e84 	addi	r2,gp,-32582
811396b8:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
811396bc:	00a045b4 	movhi	r2,33046
811396c0:	10998c04 	addi	r2,r2,26160
811396c4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
811396c8:	00a045b4 	movhi	r2,33046
811396cc:	10977804 	addi	r2,r2,24032
811396d0:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
811396d4:	d0a02f84 	addi	r2,gp,-32578
811396d8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
811396dc:	d0a03004 	addi	r2,gp,-32576
811396e0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
811396e4:	d0a03084 	addi	r2,gp,-32574
811396e8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
811396ec:	d0a03104 	addi	r2,gp,-32572
811396f0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
811396f4:	d0a03184 	addi	r2,gp,-32570
811396f8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
811396fc:	d0a03204 	addi	r2,gp,-32568
81139700:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
81139704:	d0a03284 	addi	r2,gp,-32566
81139708:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
8113970c:	d0a03304 	addi	r2,gp,-32564
81139710:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
81139714:	d0a03384 	addi	r2,gp,-32562
81139718:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
8113971c:	d0a02f04 	addi	r2,gp,-32580
81139720:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
81139724:	d0a03404 	addi	r2,gp,-32560
81139728:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
8113972c:	0001883a 	nop
81139730:	e037883a 	mov	sp,fp
81139734:	df000017 	ldw	fp,0(sp)
81139738:	dec00104 	addi	sp,sp,4
8113973c:	f800283a 	ret

81139740 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
81139740:	defff204 	addi	sp,sp,-56
81139744:	de00012e 	bgeu	sp,et,8113974c <OSFlagAccept+0xc>
81139748:	003b68fa 	trap	3
8113974c:	df000d15 	stw	fp,52(sp)
81139750:	df000d04 	addi	fp,sp,52
81139754:	e13ffc15 	stw	r4,-16(fp)
81139758:	2807883a 	mov	r3,r5
8113975c:	3005883a 	mov	r2,r6
81139760:	e1ffff15 	stw	r7,-4(fp)
81139764:	e0fffd0d 	sth	r3,-12(fp)
81139768:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113976c:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81139770:	e0bfff17 	ldw	r2,-4(fp)
81139774:	1000021e 	bne	r2,zero,81139780 <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
81139778:	0005883a 	mov	r2,zero
8113977c:	0000b006 	br	81139a40 <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81139780:	e0bffc17 	ldw	r2,-16(fp)
81139784:	1000051e 	bne	r2,zero,8113979c <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81139788:	e0bfff17 	ldw	r2,-4(fp)
8113978c:	00c01b84 	movi	r3,110
81139790:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81139794:	0005883a 	mov	r2,zero
81139798:	0000a906 	br	81139a40 <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8113979c:	e0bffc17 	ldw	r2,-16(fp)
811397a0:	10800003 	ldbu	r2,0(r2)
811397a4:	10803fcc 	andi	r2,r2,255
811397a8:	10800160 	cmpeqi	r2,r2,5
811397ac:	1000051e 	bne	r2,zero,811397c4 <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
811397b0:	e0bfff17 	ldw	r2,-4(fp)
811397b4:	00c00044 	movi	r3,1
811397b8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811397bc:	0005883a 	mov	r2,zero
811397c0:	00009f06 	br	81139a40 <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
811397c4:	e0fffe03 	ldbu	r3,-8(fp)
811397c8:	00bfe004 	movi	r2,-128
811397cc:	1884703a 	and	r2,r3,r2
811397d0:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
811397d4:	e0bff503 	ldbu	r2,-44(fp)
811397d8:	10000626 	beq	r2,zero,811397f4 <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
811397dc:	e0bffe03 	ldbu	r2,-8(fp)
811397e0:	10801fcc 	andi	r2,r2,127
811397e4:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
811397e8:	00800044 	movi	r2,1
811397ec:	e0bff385 	stb	r2,-50(fp)
811397f0:	00000106 	br	811397f8 <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
811397f4:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
811397f8:	e0bfff17 	ldw	r2,-4(fp)
811397fc:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139800:	0005303a 	rdctl	r2,status
81139804:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139808:	e0fffb17 	ldw	r3,-20(fp)
8113980c:	00bfff84 	movi	r2,-2
81139810:	1884703a 	and	r2,r3,r2
81139814:	1001703a 	wrctl	status,r2
  
  return context;
81139818:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
8113981c:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
81139820:	e0bffe03 	ldbu	r2,-8(fp)
81139824:	10c00060 	cmpeqi	r3,r2,1
81139828:	18005f1e 	bne	r3,zero,811399a8 <OSFlagAccept+0x268>
8113982c:	10c00088 	cmpgei	r3,r2,2
81139830:	1800021e 	bne	r3,zero,8113983c <OSFlagAccept+0xfc>
81139834:	10003f26 	beq	r2,zero,81139934 <OSFlagAccept+0x1f4>
81139838:	00007706 	br	81139a18 <OSFlagAccept+0x2d8>
8113983c:	10c000a0 	cmpeqi	r3,r2,2
81139840:	1800031e 	bne	r3,zero,81139850 <OSFlagAccept+0x110>
81139844:	108000e0 	cmpeqi	r2,r2,3
81139848:	10001e1e 	bne	r2,zero,811398c4 <OSFlagAccept+0x184>
8113984c:	00007206 	br	81139a18 <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
81139850:	e0bffc17 	ldw	r2,-16(fp)
81139854:	10c0020b 	ldhu	r3,8(r2)
81139858:	e0bffd0b 	ldhu	r2,-12(fp)
8113985c:	1884703a 	and	r2,r3,r2
81139860:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81139864:	e0fff30b 	ldhu	r3,-52(fp)
81139868:	e0bffd0b 	ldhu	r2,-12(fp)
8113986c:	18800d1e 	bne	r3,r2,811398a4 <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81139870:	e0bff383 	ldbu	r2,-50(fp)
81139874:	10800058 	cmpnei	r2,r2,1
81139878:	10000d1e 	bne	r2,zero,811398b0 <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8113987c:	e0bffc17 	ldw	r2,-16(fp)
81139880:	1080020b 	ldhu	r2,8(r2)
81139884:	1007883a 	mov	r3,r2
81139888:	e0bff30b 	ldhu	r2,-52(fp)
8113988c:	0084303a 	nor	r2,zero,r2
81139890:	1884703a 	and	r2,r3,r2
81139894:	1007883a 	mov	r3,r2
81139898:	e0bffc17 	ldw	r2,-16(fp)
8113989c:	10c0020d 	sth	r3,8(r2)
811398a0:	00000306 	br	811398b0 <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
811398a4:	e0bfff17 	ldw	r2,-4(fp)
811398a8:	00c01c04 	movi	r3,112
811398ac:	10c00005 	stb	r3,0(r2)
811398b0:	e0bff417 	ldw	r2,-48(fp)
811398b4:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811398b8:	e0bff617 	ldw	r2,-40(fp)
811398bc:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
811398c0:	00005e06 	br	81139a3c <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
811398c4:	e0bffc17 	ldw	r2,-16(fp)
811398c8:	10c0020b 	ldhu	r3,8(r2)
811398cc:	e0bffd0b 	ldhu	r2,-12(fp)
811398d0:	1884703a 	and	r2,r3,r2
811398d4:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
811398d8:	e0bff30b 	ldhu	r2,-52(fp)
811398dc:	10000d26 	beq	r2,zero,81139914 <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811398e0:	e0bff383 	ldbu	r2,-50(fp)
811398e4:	10800058 	cmpnei	r2,r2,1
811398e8:	10000d1e 	bne	r2,zero,81139920 <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
811398ec:	e0bffc17 	ldw	r2,-16(fp)
811398f0:	1080020b 	ldhu	r2,8(r2)
811398f4:	1007883a 	mov	r3,r2
811398f8:	e0bff30b 	ldhu	r2,-52(fp)
811398fc:	0084303a 	nor	r2,zero,r2
81139900:	1884703a 	and	r2,r3,r2
81139904:	1007883a 	mov	r3,r2
81139908:	e0bffc17 	ldw	r2,-16(fp)
8113990c:	10c0020d 	sth	r3,8(r2)
81139910:	00000306 	br	81139920 <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81139914:	e0bfff17 	ldw	r2,-4(fp)
81139918:	00c01c04 	movi	r3,112
8113991c:	10c00005 	stb	r3,0(r2)
81139920:	e0bff417 	ldw	r2,-48(fp)
81139924:	e0bff715 	stw	r2,-36(fp)
81139928:	e0bff717 	ldw	r2,-36(fp)
8113992c:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81139930:	00004206 	br	81139a3c <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
81139934:	e0bffc17 	ldw	r2,-16(fp)
81139938:	1080020b 	ldhu	r2,8(r2)
8113993c:	0084303a 	nor	r2,zero,r2
81139940:	1007883a 	mov	r3,r2
81139944:	e0bffd0b 	ldhu	r2,-12(fp)
81139948:	1884703a 	and	r2,r3,r2
8113994c:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81139950:	e0fff30b 	ldhu	r3,-52(fp)
81139954:	e0bffd0b 	ldhu	r2,-12(fp)
81139958:	18800b1e 	bne	r3,r2,81139988 <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113995c:	e0bff383 	ldbu	r2,-50(fp)
81139960:	10800058 	cmpnei	r2,r2,1
81139964:	10000b1e 	bne	r2,zero,81139994 <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
81139968:	e0bffc17 	ldw	r2,-16(fp)
8113996c:	10c0020b 	ldhu	r3,8(r2)
81139970:	e0bff30b 	ldhu	r2,-52(fp)
81139974:	1884b03a 	or	r2,r3,r2
81139978:	1007883a 	mov	r3,r2
8113997c:	e0bffc17 	ldw	r2,-16(fp)
81139980:	10c0020d 	sth	r3,8(r2)
81139984:	00000306 	br	81139994 <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81139988:	e0bfff17 	ldw	r2,-4(fp)
8113998c:	00c01c04 	movi	r3,112
81139990:	10c00005 	stb	r3,0(r2)
81139994:	e0bff417 	ldw	r2,-48(fp)
81139998:	e0bff815 	stw	r2,-32(fp)
8113999c:	e0bff817 	ldw	r2,-32(fp)
811399a0:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
811399a4:	00002506 	br	81139a3c <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
811399a8:	e0bffc17 	ldw	r2,-16(fp)
811399ac:	1080020b 	ldhu	r2,8(r2)
811399b0:	0084303a 	nor	r2,zero,r2
811399b4:	1007883a 	mov	r3,r2
811399b8:	e0bffd0b 	ldhu	r2,-12(fp)
811399bc:	1884703a 	and	r2,r3,r2
811399c0:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
811399c4:	e0bff30b 	ldhu	r2,-52(fp)
811399c8:	10000b26 	beq	r2,zero,811399f8 <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811399cc:	e0bff383 	ldbu	r2,-50(fp)
811399d0:	10800058 	cmpnei	r2,r2,1
811399d4:	10000b1e 	bne	r2,zero,81139a04 <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
811399d8:	e0bffc17 	ldw	r2,-16(fp)
811399dc:	10c0020b 	ldhu	r3,8(r2)
811399e0:	e0bff30b 	ldhu	r2,-52(fp)
811399e4:	1884b03a 	or	r2,r3,r2
811399e8:	1007883a 	mov	r3,r2
811399ec:	e0bffc17 	ldw	r2,-16(fp)
811399f0:	10c0020d 	sth	r3,8(r2)
811399f4:	00000306 	br	81139a04 <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
811399f8:	e0bfff17 	ldw	r2,-4(fp)
811399fc:	00c01c04 	movi	r3,112
81139a00:	10c00005 	stb	r3,0(r2)
81139a04:	e0bff417 	ldw	r2,-48(fp)
81139a08:	e0bff915 	stw	r2,-28(fp)
81139a0c:	e0bff917 	ldw	r2,-28(fp)
81139a10:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81139a14:	00000906 	br	81139a3c <OSFlagAccept+0x2fc>
81139a18:	e0bff417 	ldw	r2,-48(fp)
81139a1c:	e0bffa15 	stw	r2,-24(fp)
81139a20:	e0bffa17 	ldw	r2,-24(fp)
81139a24:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
81139a28:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
81139a2c:	e0bfff17 	ldw	r2,-4(fp)
81139a30:	00c01bc4 	movi	r3,111
81139a34:	10c00005 	stb	r3,0(r2)
             break;
81139a38:	0001883a 	nop
    }
    return (flags_rdy);
81139a3c:	e0bff30b 	ldhu	r2,-52(fp)
}
81139a40:	e037883a 	mov	sp,fp
81139a44:	df000017 	ldw	fp,0(sp)
81139a48:	dec00104 	addi	sp,sp,4
81139a4c:	f800283a 	ret

81139a50 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
81139a50:	defff804 	addi	sp,sp,-32
81139a54:	de00012e 	bgeu	sp,et,81139a5c <OSFlagCreate+0xc>
81139a58:	003b68fa 	trap	3
81139a5c:	df000715 	stw	fp,28(sp)
81139a60:	df000704 	addi	fp,sp,28
81139a64:	2005883a 	mov	r2,r4
81139a68:	e17fff15 	stw	r5,-4(fp)
81139a6c:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
81139a70:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
81139a74:	e0bfff17 	ldw	r2,-4(fp)
81139a78:	1000021e 	bne	r2,zero,81139a84 <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
81139a7c:	0005883a 	mov	r2,zero
81139a80:	00003306 	br	81139b50 <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
81139a84:	d0a0a003 	ldbu	r2,-32128(gp)
81139a88:	10803fcc 	andi	r2,r2,255
81139a8c:	10000526 	beq	r2,zero,81139aa4 <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
81139a90:	e0bfff17 	ldw	r2,-4(fp)
81139a94:	00c00404 	movi	r3,16
81139a98:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
81139a9c:	0005883a 	mov	r2,zero
81139aa0:	00002b06 	br	81139b50 <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139aa4:	0005303a 	rdctl	r2,status
81139aa8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139aac:	e0fffd17 	ldw	r3,-12(fp)
81139ab0:	00bfff84 	movi	r2,-2
81139ab4:	1884703a 	and	r2,r3,r2
81139ab8:	1001703a 	wrctl	status,r2
  
  return context;
81139abc:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81139ac0:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
81139ac4:	d0a0a517 	ldw	r2,-32108(gp)
81139ac8:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
81139acc:	e0bffb17 	ldw	r2,-20(fp)
81139ad0:	10001726 	beq	r2,zero,81139b30 <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
81139ad4:	d0a0a517 	ldw	r2,-32108(gp)
81139ad8:	10800117 	ldw	r2,4(r2)
81139adc:	d0a0a515 	stw	r2,-32108(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
81139ae0:	e0bffb17 	ldw	r2,-20(fp)
81139ae4:	00c00144 	movi	r3,5
81139ae8:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
81139aec:	e0bffb17 	ldw	r2,-20(fp)
81139af0:	e0fffe0b 	ldhu	r3,-8(fp)
81139af4:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
81139af8:	e0bffb17 	ldw	r2,-20(fp)
81139afc:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
81139b00:	e0bffb17 	ldw	r2,-20(fp)
81139b04:	00c00fc4 	movi	r3,63
81139b08:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81139b0c:	e0bffb17 	ldw	r2,-20(fp)
81139b10:	100002c5 	stb	zero,11(r2)
81139b14:	e0bff917 	ldw	r2,-28(fp)
81139b18:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139b1c:	e0bffa17 	ldw	r2,-24(fp)
81139b20:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
81139b24:	e0bfff17 	ldw	r2,-4(fp)
81139b28:	10000005 	stb	zero,0(r2)
81139b2c:	00000706 	br	81139b4c <OSFlagCreate+0xfc>
81139b30:	e0bff917 	ldw	r2,-28(fp)
81139b34:	e0bffc15 	stw	r2,-16(fp)
81139b38:	e0bffc17 	ldw	r2,-16(fp)
81139b3c:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
81139b40:	e0bfff17 	ldw	r2,-4(fp)
81139b44:	00c01c84 	movi	r3,114
81139b48:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
81139b4c:	e0bffb17 	ldw	r2,-20(fp)
}
81139b50:	e037883a 	mov	sp,fp
81139b54:	df000017 	ldw	fp,0(sp)
81139b58:	dec00104 	addi	sp,sp,4
81139b5c:	f800283a 	ret

81139b60 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
81139b60:	defff204 	addi	sp,sp,-56
81139b64:	de00012e 	bgeu	sp,et,81139b6c <OSFlagDel+0xc>
81139b68:	003b68fa 	trap	3
81139b6c:	dfc00d15 	stw	ra,52(sp)
81139b70:	df000c15 	stw	fp,48(sp)
81139b74:	df000c04 	addi	fp,sp,48
81139b78:	e13ffd15 	stw	r4,-12(fp)
81139b7c:	2805883a 	mov	r2,r5
81139b80:	e1bfff15 	stw	r6,-4(fp)
81139b84:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81139b88:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81139b8c:	e0bfff17 	ldw	r2,-4(fp)
81139b90:	1000021e 	bne	r2,zero,81139b9c <OSFlagDel+0x3c>
        return (pgrp);
81139b94:	e0bffd17 	ldw	r2,-12(fp)
81139b98:	00008006 	br	81139d9c <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81139b9c:	e0bffd17 	ldw	r2,-12(fp)
81139ba0:	1000051e 	bne	r2,zero,81139bb8 <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81139ba4:	e0bfff17 	ldw	r2,-4(fp)
81139ba8:	00c01b84 	movi	r3,110
81139bac:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81139bb0:	e0bffd17 	ldw	r2,-12(fp)
81139bb4:	00007906 	br	81139d9c <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81139bb8:	d0a0a003 	ldbu	r2,-32128(gp)
81139bbc:	10803fcc 	andi	r2,r2,255
81139bc0:	10000526 	beq	r2,zero,81139bd8 <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
81139bc4:	e0bfff17 	ldw	r2,-4(fp)
81139bc8:	00c003c4 	movi	r3,15
81139bcc:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81139bd0:	e0bffd17 	ldw	r2,-12(fp)
81139bd4:	00007106 	br	81139d9c <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
81139bd8:	e0bffd17 	ldw	r2,-12(fp)
81139bdc:	10800003 	ldbu	r2,0(r2)
81139be0:	10803fcc 	andi	r2,r2,255
81139be4:	10800160 	cmpeqi	r2,r2,5
81139be8:	1000051e 	bne	r2,zero,81139c00 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
81139bec:	e0bfff17 	ldw	r2,-4(fp)
81139bf0:	00c00044 	movi	r3,1
81139bf4:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81139bf8:	e0bffd17 	ldw	r2,-12(fp)
81139bfc:	00006706 	br	81139d9c <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139c00:	0005303a 	rdctl	r2,status
81139c04:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139c08:	e0fffc17 	ldw	r3,-16(fp)
81139c0c:	00bfff84 	movi	r2,-2
81139c10:	1884703a 	and	r2,r3,r2
81139c14:	1001703a 	wrctl	status,r2
  
  return context;
81139c18:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81139c1c:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
81139c20:	e0bffd17 	ldw	r2,-12(fp)
81139c24:	10800117 	ldw	r2,4(r2)
81139c28:	10000326 	beq	r2,zero,81139c38 <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81139c2c:	00800044 	movi	r2,1
81139c30:	e0bff405 	stb	r2,-48(fp)
81139c34:	00000106 	br	81139c3c <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81139c38:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
81139c3c:	e0bffe03 	ldbu	r2,-8(fp)
81139c40:	10000326 	beq	r2,zero,81139c50 <OSFlagDel+0xf0>
81139c44:	10800060 	cmpeqi	r2,r2,1
81139c48:	1000231e 	bne	r2,zero,81139cd8 <OSFlagDel+0x178>
81139c4c:	00004806 	br	81139d70 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
81139c50:	e0bff403 	ldbu	r2,-48(fp)
81139c54:	1000161e 	bne	r2,zero,81139cb0 <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
81139c58:	e0bffd17 	ldw	r2,-12(fp)
81139c5c:	00c00fc4 	movi	r3,63
81139c60:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81139c64:	e0bffd17 	ldw	r2,-12(fp)
81139c68:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81139c6c:	e0bffd17 	ldw	r2,-12(fp)
81139c70:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
81139c74:	d0e0a517 	ldw	r3,-32108(gp)
81139c78:	e0bffd17 	ldw	r2,-12(fp)
81139c7c:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
81139c80:	e0bffd17 	ldw	r2,-12(fp)
81139c84:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
81139c88:	e0bffd17 	ldw	r2,-12(fp)
81139c8c:	d0a0a515 	stw	r2,-32108(gp)
81139c90:	e0bff717 	ldw	r2,-36(fp)
81139c94:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139c98:	e0bff817 	ldw	r2,-32(fp)
81139c9c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
81139ca0:	e0bfff17 	ldw	r2,-4(fp)
81139ca4:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
81139ca8:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
81139cac:	00003a06 	br	81139d98 <OSFlagDel+0x238>
81139cb0:	e0bff717 	ldw	r2,-36(fp)
81139cb4:	e0bff915 	stw	r2,-28(fp)
81139cb8:	e0bff917 	ldw	r2,-28(fp)
81139cbc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
81139cc0:	e0bfff17 	ldw	r2,-4(fp)
81139cc4:	00c01244 	movi	r3,73
81139cc8:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
81139ccc:	e0bffd17 	ldw	r2,-12(fp)
81139cd0:	e0bff615 	stw	r2,-40(fp)
             }
             break;
81139cd4:	00003006 	br	81139d98 <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
81139cd8:	e0bffd17 	ldw	r2,-12(fp)
81139cdc:	10800117 	ldw	r2,4(r2)
81139ce0:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
81139ce4:	00000606 	br	81139d00 <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
81139ce8:	000b883a 	mov	r5,zero
81139cec:	e13ff517 	ldw	r4,-44(fp)
81139cf0:	113ad140 	call	8113ad14 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
81139cf4:	e0bff517 	ldw	r2,-44(fp)
81139cf8:	10800017 	ldw	r2,0(r2)
81139cfc:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
81139d00:	e0bff517 	ldw	r2,-44(fp)
81139d04:	103ff81e 	bne	r2,zero,81139ce8 <__reset+0xfb119ce8>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
81139d08:	e0bffd17 	ldw	r2,-12(fp)
81139d0c:	00c00fc4 	movi	r3,63
81139d10:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81139d14:	e0bffd17 	ldw	r2,-12(fp)
81139d18:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81139d1c:	e0bffd17 	ldw	r2,-12(fp)
81139d20:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
81139d24:	d0e0a517 	ldw	r3,-32108(gp)
81139d28:	e0bffd17 	ldw	r2,-12(fp)
81139d2c:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
81139d30:	e0bffd17 	ldw	r2,-12(fp)
81139d34:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
81139d38:	e0bffd17 	ldw	r2,-12(fp)
81139d3c:	d0a0a515 	stw	r2,-32108(gp)
81139d40:	e0bff717 	ldw	r2,-36(fp)
81139d44:	e0bffa15 	stw	r2,-24(fp)
81139d48:	e0bffa17 	ldw	r2,-24(fp)
81139d4c:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81139d50:	e0bff403 	ldbu	r2,-48(fp)
81139d54:	10800058 	cmpnei	r2,r2,1
81139d58:	1000011e 	bne	r2,zero,81139d60 <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81139d5c:	1138e240 	call	81138e24 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
81139d60:	e0bfff17 	ldw	r2,-4(fp)
81139d64:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
81139d68:	e03ff615 	stw	zero,-40(fp)
             break;
81139d6c:	00000a06 	br	81139d98 <OSFlagDel+0x238>
81139d70:	e0bff717 	ldw	r2,-36(fp)
81139d74:	e0bffb15 	stw	r2,-20(fp)
81139d78:	e0bffb17 	ldw	r2,-20(fp)
81139d7c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
81139d80:	e0bfff17 	ldw	r2,-4(fp)
81139d84:	00c001c4 	movi	r3,7
81139d88:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
81139d8c:	e0bffd17 	ldw	r2,-12(fp)
81139d90:	e0bff615 	stw	r2,-40(fp)
             break;
81139d94:	0001883a 	nop
    }
    return (pgrp_return);
81139d98:	e0bff617 	ldw	r2,-40(fp)
}
81139d9c:	e037883a 	mov	sp,fp
81139da0:	dfc00117 	ldw	ra,4(sp)
81139da4:	df000017 	ldw	fp,0(sp)
81139da8:	dec00204 	addi	sp,sp,8
81139dac:	f800283a 	ret

81139db0 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
81139db0:	defff604 	addi	sp,sp,-40
81139db4:	de00012e 	bgeu	sp,et,81139dbc <OSFlagNameGet+0xc>
81139db8:	003b68fa 	trap	3
81139dbc:	dfc00915 	stw	ra,36(sp)
81139dc0:	df000815 	stw	fp,32(sp)
81139dc4:	df000804 	addi	fp,sp,32
81139dc8:	e13ffd15 	stw	r4,-12(fp)
81139dcc:	e17ffe15 	stw	r5,-8(fp)
81139dd0:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139dd4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81139dd8:	e0bfff17 	ldw	r2,-4(fp)
81139ddc:	1000021e 	bne	r2,zero,81139de8 <OSFlagNameGet+0x38>
        return (0);
81139de0:	0005883a 	mov	r2,zero
81139de4:	00003906 	br	81139ecc <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
81139de8:	e0bffd17 	ldw	r2,-12(fp)
81139dec:	1000051e 	bne	r2,zero,81139e04 <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81139df0:	e0bfff17 	ldw	r2,-4(fp)
81139df4:	00c01b84 	movi	r3,110
81139df8:	10c00005 	stb	r3,0(r2)
        return (0);
81139dfc:	0005883a 	mov	r2,zero
81139e00:	00003206 	br	81139ecc <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81139e04:	e0bffe17 	ldw	r2,-8(fp)
81139e08:	1000051e 	bne	r2,zero,81139e20 <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81139e0c:	e0bfff17 	ldw	r2,-4(fp)
81139e10:	00c00304 	movi	r3,12
81139e14:	10c00005 	stb	r3,0(r2)
        return (0);
81139e18:	0005883a 	mov	r2,zero
81139e1c:	00002b06 	br	81139ecc <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81139e20:	d0a0a003 	ldbu	r2,-32128(gp)
81139e24:	10803fcc 	andi	r2,r2,255
81139e28:	10000526 	beq	r2,zero,81139e40 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
81139e2c:	e0bfff17 	ldw	r2,-4(fp)
81139e30:	00c00444 	movi	r3,17
81139e34:	10c00005 	stb	r3,0(r2)
        return (0);
81139e38:	0005883a 	mov	r2,zero
81139e3c:	00002306 	br	81139ecc <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139e40:	0005303a 	rdctl	r2,status
81139e44:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139e48:	e0fffc17 	ldw	r3,-16(fp)
81139e4c:	00bfff84 	movi	r2,-2
81139e50:	1884703a 	and	r2,r3,r2
81139e54:	1001703a 	wrctl	status,r2
  
  return context;
81139e58:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81139e5c:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
81139e60:	e0bffd17 	ldw	r2,-12(fp)
81139e64:	10800003 	ldbu	r2,0(r2)
81139e68:	10803fcc 	andi	r2,r2,255
81139e6c:	10800160 	cmpeqi	r2,r2,5
81139e70:	1000091e 	bne	r2,zero,81139e98 <OSFlagNameGet+0xe8>
81139e74:	e0bff817 	ldw	r2,-32(fp)
81139e78:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139e7c:	e0bff917 	ldw	r2,-28(fp)
81139e80:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
81139e84:	e0bfff17 	ldw	r2,-4(fp)
81139e88:	00c00044 	movi	r3,1
81139e8c:	10c00005 	stb	r3,0(r2)
        return (0);
81139e90:	0005883a 	mov	r2,zero
81139e94:	00000d06 	br	81139ecc <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
81139e98:	e0bffd17 	ldw	r2,-12(fp)
81139e9c:	10800284 	addi	r2,r2,10
81139ea0:	100b883a 	mov	r5,r2
81139ea4:	e13ffe17 	ldw	r4,-8(fp)
81139ea8:	1138f780 	call	81138f78 <OS_StrCopy>
81139eac:	e0bffb05 	stb	r2,-20(fp)
81139eb0:	e0bff817 	ldw	r2,-32(fp)
81139eb4:	e0bffa15 	stw	r2,-24(fp)
81139eb8:	e0bffa17 	ldw	r2,-24(fp)
81139ebc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81139ec0:	e0bfff17 	ldw	r2,-4(fp)
81139ec4:	10000005 	stb	zero,0(r2)
    return (len);
81139ec8:	e0bffb03 	ldbu	r2,-20(fp)
}
81139ecc:	e037883a 	mov	sp,fp
81139ed0:	dfc00117 	ldw	ra,4(sp)
81139ed4:	df000017 	ldw	fp,0(sp)
81139ed8:	dec00204 	addi	sp,sp,8
81139edc:	f800283a 	ret

81139ee0 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
81139ee0:	defff504 	addi	sp,sp,-44
81139ee4:	de00012e 	bgeu	sp,et,81139eec <OSFlagNameSet+0xc>
81139ee8:	003b68fa 	trap	3
81139eec:	dfc00a15 	stw	ra,40(sp)
81139ef0:	df000915 	stw	fp,36(sp)
81139ef4:	df000904 	addi	fp,sp,36
81139ef8:	e13ffd15 	stw	r4,-12(fp)
81139efc:	e17ffe15 	stw	r5,-8(fp)
81139f00:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139f04:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81139f08:	e0bfff17 	ldw	r2,-4(fp)
81139f0c:	10004326 	beq	r2,zero,8113a01c <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
81139f10:	e0bffd17 	ldw	r2,-12(fp)
81139f14:	1000041e 	bne	r2,zero,81139f28 <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81139f18:	e0bfff17 	ldw	r2,-4(fp)
81139f1c:	00c01b84 	movi	r3,110
81139f20:	10c00005 	stb	r3,0(r2)
        return;
81139f24:	00003e06 	br	8113a020 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81139f28:	e0bffe17 	ldw	r2,-8(fp)
81139f2c:	1000041e 	bne	r2,zero,81139f40 <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81139f30:	e0bfff17 	ldw	r2,-4(fp)
81139f34:	00c00304 	movi	r3,12
81139f38:	10c00005 	stb	r3,0(r2)
        return;
81139f3c:	00003806 	br	8113a020 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81139f40:	d0a0a003 	ldbu	r2,-32128(gp)
81139f44:	10803fcc 	andi	r2,r2,255
81139f48:	10000426 	beq	r2,zero,81139f5c <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81139f4c:	e0bfff17 	ldw	r2,-4(fp)
81139f50:	00c00484 	movi	r3,18
81139f54:	10c00005 	stb	r3,0(r2)
        return;
81139f58:	00003106 	br	8113a020 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139f5c:	0005303a 	rdctl	r2,status
81139f60:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139f64:	e0fffc17 	ldw	r3,-16(fp)
81139f68:	00bfff84 	movi	r2,-2
81139f6c:	1884703a 	and	r2,r3,r2
81139f70:	1001703a 	wrctl	status,r2
  
  return context;
81139f74:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81139f78:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
81139f7c:	e0bffd17 	ldw	r2,-12(fp)
81139f80:	10800003 	ldbu	r2,0(r2)
81139f84:	10803fcc 	andi	r2,r2,255
81139f88:	10800160 	cmpeqi	r2,r2,5
81139f8c:	1000081e 	bne	r2,zero,81139fb0 <OSFlagNameSet+0xd0>
81139f90:	e0bff717 	ldw	r2,-36(fp)
81139f94:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139f98:	e0bff817 	ldw	r2,-32(fp)
81139f9c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
81139fa0:	e0bfff17 	ldw	r2,-4(fp)
81139fa4:	00c00044 	movi	r3,1
81139fa8:	10c00005 	stb	r3,0(r2)
        return;
81139fac:	00001c06 	br	8113a020 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
81139fb0:	e13ffe17 	ldw	r4,-8(fp)
81139fb4:	1138ff40 	call	81138ff4 <OS_StrLen>
81139fb8:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
81139fbc:	e0bffa03 	ldbu	r2,-24(fp)
81139fc0:	10800830 	cmpltui	r2,r2,32
81139fc4:	1000081e 	bne	r2,zero,81139fe8 <OSFlagNameSet+0x108>
81139fc8:	e0bff717 	ldw	r2,-36(fp)
81139fcc:	e0bff915 	stw	r2,-28(fp)
81139fd0:	e0bff917 	ldw	r2,-28(fp)
81139fd4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
81139fd8:	e0bfff17 	ldw	r2,-4(fp)
81139fdc:	00c01cc4 	movi	r3,115
81139fe0:	10c00005 	stb	r3,0(r2)
        return;
81139fe4:	00000e06 	br	8113a020 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
81139fe8:	e0bffd17 	ldw	r2,-12(fp)
81139fec:	10800284 	addi	r2,r2,10
81139ff0:	e17ffe17 	ldw	r5,-8(fp)
81139ff4:	1009883a 	mov	r4,r2
81139ff8:	1138f780 	call	81138f78 <OS_StrCopy>
81139ffc:	e0bff717 	ldw	r2,-36(fp)
8113a000:	e0bffb15 	stw	r2,-20(fp)
8113a004:	e0bffb17 	ldw	r2,-20(fp)
8113a008:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113a00c:	e0bfff17 	ldw	r2,-4(fp)
8113a010:	10000005 	stb	zero,0(r2)
    return;
8113a014:	0001883a 	nop
8113a018:	00000106 	br	8113a020 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113a01c:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
8113a020:	e037883a 	mov	sp,fp
8113a024:	dfc00117 	ldw	ra,4(sp)
8113a028:	df000017 	ldw	fp,0(sp)
8113a02c:	dec00204 	addi	sp,sp,8
8113a030:	f800283a 	ret

8113a034 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
8113a034:	deffe104 	addi	sp,sp,-124
8113a038:	de00012e 	bgeu	sp,et,8113a040 <OSFlagPend+0xc>
8113a03c:	003b68fa 	trap	3
8113a040:	dfc01e15 	stw	ra,120(sp)
8113a044:	df001d15 	stw	fp,116(sp)
8113a048:	df001d04 	addi	fp,sp,116
8113a04c:	e13ffc15 	stw	r4,-16(fp)
8113a050:	2809883a 	mov	r4,r5
8113a054:	3007883a 	mov	r3,r6
8113a058:	3805883a 	mov	r2,r7
8113a05c:	e13ffd0d 	sth	r4,-12(fp)
8113a060:	e0fffe05 	stb	r3,-8(fp)
8113a064:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113a068:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113a06c:	e0800217 	ldw	r2,8(fp)
8113a070:	1000021e 	bne	r2,zero,8113a07c <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
8113a074:	0005883a 	mov	r2,zero
8113a078:	00015906 	br	8113a5e0 <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
8113a07c:	e0bffc17 	ldw	r2,-16(fp)
8113a080:	1000051e 	bne	r2,zero,8113a098 <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113a084:	e0800217 	ldw	r2,8(fp)
8113a088:	00c01b84 	movi	r3,110
8113a08c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113a090:	0005883a 	mov	r2,zero
8113a094:	00015206 	br	8113a5e0 <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113a098:	d0a0a003 	ldbu	r2,-32128(gp)
8113a09c:	10803fcc 	andi	r2,r2,255
8113a0a0:	10000526 	beq	r2,zero,8113a0b8 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113a0a4:	e0800217 	ldw	r2,8(fp)
8113a0a8:	00c00084 	movi	r3,2
8113a0ac:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113a0b0:	0005883a 	mov	r2,zero
8113a0b4:	00014a06 	br	8113a5e0 <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113a0b8:	d0a08e03 	ldbu	r2,-32200(gp)
8113a0bc:	10803fcc 	andi	r2,r2,255
8113a0c0:	10000526 	beq	r2,zero,8113a0d8 <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113a0c4:	e0800217 	ldw	r2,8(fp)
8113a0c8:	00c00344 	movi	r3,13
8113a0cc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113a0d0:	0005883a 	mov	r2,zero
8113a0d4:	00014206 	br	8113a5e0 <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8113a0d8:	e0bffc17 	ldw	r2,-16(fp)
8113a0dc:	10800003 	ldbu	r2,0(r2)
8113a0e0:	10803fcc 	andi	r2,r2,255
8113a0e4:	10800160 	cmpeqi	r2,r2,5
8113a0e8:	1000051e 	bne	r2,zero,8113a100 <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
8113a0ec:	e0800217 	ldw	r2,8(fp)
8113a0f0:	00c00044 	movi	r3,1
8113a0f4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113a0f8:	0005883a 	mov	r2,zero
8113a0fc:	00013806 	br	8113a5e0 <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
8113a100:	e0fffe03 	ldbu	r3,-8(fp)
8113a104:	00bfe004 	movi	r2,-128
8113a108:	1884703a 	and	r2,r3,r2
8113a10c:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
8113a110:	e0bfe603 	ldbu	r2,-104(fp)
8113a114:	10000626 	beq	r2,zero,8113a130 <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
8113a118:	e0bffe03 	ldbu	r2,-8(fp)
8113a11c:	10801fcc 	andi	r2,r2,127
8113a120:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113a124:	00800044 	movi	r2,1
8113a128:	e0bfe405 	stb	r2,-112(fp)
8113a12c:	00000106 	br	8113a134 <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
8113a130:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a134:	0005303a 	rdctl	r2,status
8113a138:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a13c:	e0fff617 	ldw	r3,-40(fp)
8113a140:	00bfff84 	movi	r2,-2
8113a144:	1884703a 	and	r2,r3,r2
8113a148:	1001703a 	wrctl	status,r2
  
  return context;
8113a14c:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113a150:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
8113a154:	e0bffe03 	ldbu	r2,-8(fp)
8113a158:	10c00060 	cmpeqi	r3,r2,1
8113a15c:	1800921e 	bne	r3,zero,8113a3a8 <OSFlagPend+0x374>
8113a160:	10c00088 	cmpgei	r3,r2,2
8113a164:	1800021e 	bne	r3,zero,8113a170 <OSFlagPend+0x13c>
8113a168:	10006126 	beq	r2,zero,8113a2f0 <OSFlagPend+0x2bc>
8113a16c:	0000bb06 	br	8113a45c <OSFlagPend+0x428>
8113a170:	10c000a0 	cmpeqi	r3,r2,2
8113a174:	1800031e 	bne	r3,zero,8113a184 <OSFlagPend+0x150>
8113a178:	108000e0 	cmpeqi	r2,r2,3
8113a17c:	10002f1e 	bne	r2,zero,8113a23c <OSFlagPend+0x208>
8113a180:	0000b606 	br	8113a45c <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
8113a184:	e0bffc17 	ldw	r2,-16(fp)
8113a188:	10c0020b 	ldhu	r3,8(r2)
8113a18c:	e0bffd0b 	ldhu	r2,-12(fp)
8113a190:	1884703a 	and	r2,r3,r2
8113a194:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113a198:	e0ffe80b 	ldhu	r3,-96(fp)
8113a19c:	e0bffd0b 	ldhu	r2,-12(fp)
8113a1a0:	1880171e 	bne	r3,r2,8113a200 <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113a1a4:	e0bfe403 	ldbu	r2,-112(fp)
8113a1a8:	10800058 	cmpnei	r2,r2,1
8113a1ac:	1000091e 	bne	r2,zero,8113a1d4 <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8113a1b0:	e0bffc17 	ldw	r2,-16(fp)
8113a1b4:	1080020b 	ldhu	r2,8(r2)
8113a1b8:	1007883a 	mov	r3,r2
8113a1bc:	e0bfe80b 	ldhu	r2,-96(fp)
8113a1c0:	0084303a 	nor	r2,zero,r2
8113a1c4:	1884703a 	and	r2,r3,r2
8113a1c8:	1007883a 	mov	r3,r2
8113a1cc:	e0bffc17 	ldw	r2,-16(fp)
8113a1d0:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113a1d4:	d0a0a117 	ldw	r2,-32124(gp)
8113a1d8:	e0ffe80b 	ldhu	r3,-96(fp)
8113a1dc:	10c00b0d 	sth	r3,44(r2)
8113a1e0:	e0bfe517 	ldw	r2,-108(fp)
8113a1e4:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a1e8:	e0bfe717 	ldw	r2,-100(fp)
8113a1ec:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113a1f0:	e0800217 	ldw	r2,8(fp)
8113a1f4:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113a1f8:	e0bfe80b 	ldhu	r2,-96(fp)
8113a1fc:	0000f806 	br	8113a5e0 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113a200:	e13ffd0b 	ldhu	r4,-12(fp)
8113a204:	e17ffe03 	ldbu	r5,-8(fp)
8113a208:	e0bfff0b 	ldhu	r2,-4(fp)
8113a20c:	e0fff704 	addi	r3,fp,-36
8113a210:	d8800015 	stw	r2,0(sp)
8113a214:	280f883a 	mov	r7,r5
8113a218:	200d883a 	mov	r6,r4
8113a21c:	180b883a 	mov	r5,r3
8113a220:	e13ffc17 	ldw	r4,-16(fp)
8113a224:	113aac40 	call	8113aac4 <OS_FlagBlock>
8113a228:	e0bfe517 	ldw	r2,-108(fp)
8113a22c:	e0bfe915 	stw	r2,-92(fp)
8113a230:	e0bfe917 	ldw	r2,-92(fp)
8113a234:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113a238:	00009206 	br	8113a484 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
8113a23c:	e0bffc17 	ldw	r2,-16(fp)
8113a240:	10c0020b 	ldhu	r3,8(r2)
8113a244:	e0bffd0b 	ldhu	r2,-12(fp)
8113a248:	1884703a 	and	r2,r3,r2
8113a24c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113a250:	e0bfe80b 	ldhu	r2,-96(fp)
8113a254:	10001726 	beq	r2,zero,8113a2b4 <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113a258:	e0bfe403 	ldbu	r2,-112(fp)
8113a25c:	10800058 	cmpnei	r2,r2,1
8113a260:	1000091e 	bne	r2,zero,8113a288 <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8113a264:	e0bffc17 	ldw	r2,-16(fp)
8113a268:	1080020b 	ldhu	r2,8(r2)
8113a26c:	1007883a 	mov	r3,r2
8113a270:	e0bfe80b 	ldhu	r2,-96(fp)
8113a274:	0084303a 	nor	r2,zero,r2
8113a278:	1884703a 	and	r2,r3,r2
8113a27c:	1007883a 	mov	r3,r2
8113a280:	e0bffc17 	ldw	r2,-16(fp)
8113a284:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113a288:	d0a0a117 	ldw	r2,-32124(gp)
8113a28c:	e0ffe80b 	ldhu	r3,-96(fp)
8113a290:	10c00b0d 	sth	r3,44(r2)
8113a294:	e0bfe517 	ldw	r2,-108(fp)
8113a298:	e0bfea15 	stw	r2,-88(fp)
8113a29c:	e0bfea17 	ldw	r2,-88(fp)
8113a2a0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113a2a4:	e0800217 	ldw	r2,8(fp)
8113a2a8:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113a2ac:	e0bfe80b 	ldhu	r2,-96(fp)
8113a2b0:	0000cb06 	br	8113a5e0 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113a2b4:	e13ffd0b 	ldhu	r4,-12(fp)
8113a2b8:	e17ffe03 	ldbu	r5,-8(fp)
8113a2bc:	e0bfff0b 	ldhu	r2,-4(fp)
8113a2c0:	e0fff704 	addi	r3,fp,-36
8113a2c4:	d8800015 	stw	r2,0(sp)
8113a2c8:	280f883a 	mov	r7,r5
8113a2cc:	200d883a 	mov	r6,r4
8113a2d0:	180b883a 	mov	r5,r3
8113a2d4:	e13ffc17 	ldw	r4,-16(fp)
8113a2d8:	113aac40 	call	8113aac4 <OS_FlagBlock>
8113a2dc:	e0bfe517 	ldw	r2,-108(fp)
8113a2e0:	e0bfeb15 	stw	r2,-84(fp)
8113a2e4:	e0bfeb17 	ldw	r2,-84(fp)
8113a2e8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113a2ec:	00006506 	br	8113a484 <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
8113a2f0:	e0bffc17 	ldw	r2,-16(fp)
8113a2f4:	1080020b 	ldhu	r2,8(r2)
8113a2f8:	0084303a 	nor	r2,zero,r2
8113a2fc:	1007883a 	mov	r3,r2
8113a300:	e0bffd0b 	ldhu	r2,-12(fp)
8113a304:	1884703a 	and	r2,r3,r2
8113a308:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113a30c:	e0ffe80b 	ldhu	r3,-96(fp)
8113a310:	e0bffd0b 	ldhu	r2,-12(fp)
8113a314:	1880151e 	bne	r3,r2,8113a36c <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113a318:	e0bfe403 	ldbu	r2,-112(fp)
8113a31c:	10800058 	cmpnei	r2,r2,1
8113a320:	1000071e 	bne	r2,zero,8113a340 <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113a324:	e0bffc17 	ldw	r2,-16(fp)
8113a328:	10c0020b 	ldhu	r3,8(r2)
8113a32c:	e0bfe80b 	ldhu	r2,-96(fp)
8113a330:	1884b03a 	or	r2,r3,r2
8113a334:	1007883a 	mov	r3,r2
8113a338:	e0bffc17 	ldw	r2,-16(fp)
8113a33c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113a340:	d0a0a117 	ldw	r2,-32124(gp)
8113a344:	e0ffe80b 	ldhu	r3,-96(fp)
8113a348:	10c00b0d 	sth	r3,44(r2)
8113a34c:	e0bfe517 	ldw	r2,-108(fp)
8113a350:	e0bfec15 	stw	r2,-80(fp)
8113a354:	e0bfec17 	ldw	r2,-80(fp)
8113a358:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113a35c:	e0800217 	ldw	r2,8(fp)
8113a360:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113a364:	e0bfe80b 	ldhu	r2,-96(fp)
8113a368:	00009d06 	br	8113a5e0 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113a36c:	e13ffd0b 	ldhu	r4,-12(fp)
8113a370:	e17ffe03 	ldbu	r5,-8(fp)
8113a374:	e0bfff0b 	ldhu	r2,-4(fp)
8113a378:	e0fff704 	addi	r3,fp,-36
8113a37c:	d8800015 	stw	r2,0(sp)
8113a380:	280f883a 	mov	r7,r5
8113a384:	200d883a 	mov	r6,r4
8113a388:	180b883a 	mov	r5,r3
8113a38c:	e13ffc17 	ldw	r4,-16(fp)
8113a390:	113aac40 	call	8113aac4 <OS_FlagBlock>
8113a394:	e0bfe517 	ldw	r2,-108(fp)
8113a398:	e0bfed15 	stw	r2,-76(fp)
8113a39c:	e0bfed17 	ldw	r2,-76(fp)
8113a3a0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113a3a4:	00003706 	br	8113a484 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113a3a8:	e0bffc17 	ldw	r2,-16(fp)
8113a3ac:	1080020b 	ldhu	r2,8(r2)
8113a3b0:	0084303a 	nor	r2,zero,r2
8113a3b4:	1007883a 	mov	r3,r2
8113a3b8:	e0bffd0b 	ldhu	r2,-12(fp)
8113a3bc:	1884703a 	and	r2,r3,r2
8113a3c0:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
8113a3c4:	e0bfe80b 	ldhu	r2,-96(fp)
8113a3c8:	10001526 	beq	r2,zero,8113a420 <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113a3cc:	e0bfe403 	ldbu	r2,-112(fp)
8113a3d0:	10800058 	cmpnei	r2,r2,1
8113a3d4:	1000071e 	bne	r2,zero,8113a3f4 <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113a3d8:	e0bffc17 	ldw	r2,-16(fp)
8113a3dc:	10c0020b 	ldhu	r3,8(r2)
8113a3e0:	e0bfe80b 	ldhu	r2,-96(fp)
8113a3e4:	1884b03a 	or	r2,r3,r2
8113a3e8:	1007883a 	mov	r3,r2
8113a3ec:	e0bffc17 	ldw	r2,-16(fp)
8113a3f0:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
8113a3f4:	d0a0a117 	ldw	r2,-32124(gp)
8113a3f8:	e0ffe80b 	ldhu	r3,-96(fp)
8113a3fc:	10c00b0d 	sth	r3,44(r2)
8113a400:	e0bfe517 	ldw	r2,-108(fp)
8113a404:	e0bfee15 	stw	r2,-72(fp)
8113a408:	e0bfee17 	ldw	r2,-72(fp)
8113a40c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113a410:	e0800217 	ldw	r2,8(fp)
8113a414:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113a418:	e0bfe80b 	ldhu	r2,-96(fp)
8113a41c:	00007006 	br	8113a5e0 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113a420:	e13ffd0b 	ldhu	r4,-12(fp)
8113a424:	e17ffe03 	ldbu	r5,-8(fp)
8113a428:	e0bfff0b 	ldhu	r2,-4(fp)
8113a42c:	e0fff704 	addi	r3,fp,-36
8113a430:	d8800015 	stw	r2,0(sp)
8113a434:	280f883a 	mov	r7,r5
8113a438:	200d883a 	mov	r6,r4
8113a43c:	180b883a 	mov	r5,r3
8113a440:	e13ffc17 	ldw	r4,-16(fp)
8113a444:	113aac40 	call	8113aac4 <OS_FlagBlock>
8113a448:	e0bfe517 	ldw	r2,-108(fp)
8113a44c:	e0bfef15 	stw	r2,-68(fp)
8113a450:	e0bfef17 	ldw	r2,-68(fp)
8113a454:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113a458:	00000a06 	br	8113a484 <OSFlagPend+0x450>
8113a45c:	e0bfe517 	ldw	r2,-108(fp)
8113a460:	e0bff015 	stw	r2,-64(fp)
8113a464:	e0bff017 	ldw	r2,-64(fp)
8113a468:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8113a46c:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
8113a470:	e0800217 	ldw	r2,8(fp)
8113a474:	00c01bc4 	movi	r3,111
8113a478:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
8113a47c:	e0bfe80b 	ldhu	r2,-96(fp)
8113a480:	00005706 	br	8113a5e0 <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
8113a484:	1138e240 	call	81138e24 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a488:	0005303a 	rdctl	r2,status
8113a48c:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a490:	e0fff117 	ldw	r3,-60(fp)
8113a494:	00bfff84 	movi	r2,-2
8113a498:	1884703a 	and	r2,r3,r2
8113a49c:	1001703a 	wrctl	status,r2
  
  return context;
8113a4a0:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
8113a4a4:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
8113a4a8:	d0a0a117 	ldw	r2,-32124(gp)
8113a4ac:	10800c43 	ldbu	r2,49(r2)
8113a4b0:	10803fcc 	andi	r2,r2,255
8113a4b4:	10001c26 	beq	r2,zero,8113a528 <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
8113a4b8:	d0a0a117 	ldw	r2,-32124(gp)
8113a4bc:	10800c43 	ldbu	r2,49(r2)
8113a4c0:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113a4c4:	d0a0a117 	ldw	r2,-32124(gp)
8113a4c8:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
8113a4cc:	e0bff704 	addi	r2,fp,-36
8113a4d0:	1009883a 	mov	r4,r2
8113a4d4:	113ae100 	call	8113ae10 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
8113a4d8:	d0a0a117 	ldw	r2,-32124(gp)
8113a4dc:	10000c05 	stb	zero,48(r2)
8113a4e0:	e0bfe517 	ldw	r2,-108(fp)
8113a4e4:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a4e8:	e0bff217 	ldw	r2,-56(fp)
8113a4ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
8113a4f0:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
8113a4f4:	e0bff303 	ldbu	r2,-52(fp)
8113a4f8:	108000a0 	cmpeqi	r2,r2,2
8113a4fc:	10000426 	beq	r2,zero,8113a510 <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
8113a500:	e0800217 	ldw	r2,8(fp)
8113a504:	00c00384 	movi	r3,14
8113a508:	10c00005 	stb	r3,0(r2)
                 break;
8113a50c:	00000406 	br	8113a520 <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
8113a510:	e0800217 	ldw	r2,8(fp)
8113a514:	00c00284 	movi	r3,10
8113a518:	10c00005 	stb	r3,0(r2)
                 break;
8113a51c:	0001883a 	nop
        }
        return (flags_rdy);
8113a520:	e0bfe80b 	ldhu	r2,-96(fp)
8113a524:	00002e06 	br	8113a5e0 <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
8113a528:	d0a0a117 	ldw	r2,-32124(gp)
8113a52c:	10800b0b 	ldhu	r2,44(r2)
8113a530:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
8113a534:	e0bfe403 	ldbu	r2,-112(fp)
8113a538:	10800058 	cmpnei	r2,r2,1
8113a53c:	1000211e 	bne	r2,zero,8113a5c4 <OSFlagPend+0x590>
        switch (wait_type) {
8113a540:	e0bffe03 	ldbu	r2,-8(fp)
8113a544:	10001616 	blt	r2,zero,8113a5a0 <OSFlagPend+0x56c>
8113a548:	10c00090 	cmplti	r3,r2,2
8113a54c:	18000c1e 	bne	r3,zero,8113a580 <OSFlagPend+0x54c>
8113a550:	10800108 	cmpgei	r2,r2,4
8113a554:	1000121e 	bne	r2,zero,8113a5a0 <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
8113a558:	e0bffc17 	ldw	r2,-16(fp)
8113a55c:	1080020b 	ldhu	r2,8(r2)
8113a560:	1007883a 	mov	r3,r2
8113a564:	e0bfe80b 	ldhu	r2,-96(fp)
8113a568:	0084303a 	nor	r2,zero,r2
8113a56c:	1884703a 	and	r2,r3,r2
8113a570:	1007883a 	mov	r3,r2
8113a574:	e0bffc17 	ldw	r2,-16(fp)
8113a578:	10c0020d 	sth	r3,8(r2)
                 break;
8113a57c:	00001106 	br	8113a5c4 <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
8113a580:	e0bffc17 	ldw	r2,-16(fp)
8113a584:	10c0020b 	ldhu	r3,8(r2)
8113a588:	e0bfe80b 	ldhu	r2,-96(fp)
8113a58c:	1884b03a 	or	r2,r3,r2
8113a590:	1007883a 	mov	r3,r2
8113a594:	e0bffc17 	ldw	r2,-16(fp)
8113a598:	10c0020d 	sth	r3,8(r2)
                 break;
8113a59c:	00000906 	br	8113a5c4 <OSFlagPend+0x590>
8113a5a0:	e0bfe517 	ldw	r2,-108(fp)
8113a5a4:	e0bff415 	stw	r2,-48(fp)
8113a5a8:	e0bff417 	ldw	r2,-48(fp)
8113a5ac:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113a5b0:	e0800217 	ldw	r2,8(fp)
8113a5b4:	00c01bc4 	movi	r3,111
8113a5b8:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8113a5bc:	0005883a 	mov	r2,zero
8113a5c0:	00000706 	br	8113a5e0 <OSFlagPend+0x5ac>
8113a5c4:	e0bfe517 	ldw	r2,-108(fp)
8113a5c8:	e0bff515 	stw	r2,-44(fp)
8113a5cc:	e0bff517 	ldw	r2,-44(fp)
8113a5d0:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
8113a5d4:	e0800217 	ldw	r2,8(fp)
8113a5d8:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
8113a5dc:	e0bfe80b 	ldhu	r2,-96(fp)
}
8113a5e0:	e037883a 	mov	sp,fp
8113a5e4:	dfc00117 	ldw	ra,4(sp)
8113a5e8:	df000017 	ldw	fp,0(sp)
8113a5ec:	dec00204 	addi	sp,sp,8
8113a5f0:	f800283a 	ret

8113a5f4 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
8113a5f4:	defffb04 	addi	sp,sp,-20
8113a5f8:	de00012e 	bgeu	sp,et,8113a600 <OSFlagPendGetFlagsRdy+0xc>
8113a5fc:	003b68fa 	trap	3
8113a600:	df000415 	stw	fp,16(sp)
8113a604:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113a608:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a60c:	0005303a 	rdctl	r2,status
8113a610:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a614:	e0fffe17 	ldw	r3,-8(fp)
8113a618:	00bfff84 	movi	r2,-2
8113a61c:	1884703a 	and	r2,r3,r2
8113a620:	1001703a 	wrctl	status,r2
  
  return context;
8113a624:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113a628:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
8113a62c:	d0a0a117 	ldw	r2,-32124(gp)
8113a630:	10800b0b 	ldhu	r2,44(r2)
8113a634:	e0bffd0d 	sth	r2,-12(fp)
8113a638:	e0bffc17 	ldw	r2,-16(fp)
8113a63c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a640:	e0bfff17 	ldw	r2,-4(fp)
8113a644:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
8113a648:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113a64c:	e037883a 	mov	sp,fp
8113a650:	df000017 	ldw	fp,0(sp)
8113a654:	dec00104 	addi	sp,sp,4
8113a658:	f800283a 	ret

8113a65c <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
8113a65c:	deffef04 	addi	sp,sp,-68
8113a660:	de00012e 	bgeu	sp,et,8113a668 <OSFlagPost+0xc>
8113a664:	003b68fa 	trap	3
8113a668:	dfc01015 	stw	ra,64(sp)
8113a66c:	df000f15 	stw	fp,60(sp)
8113a670:	df000f04 	addi	fp,sp,60
8113a674:	e13ffc15 	stw	r4,-16(fp)
8113a678:	2807883a 	mov	r3,r5
8113a67c:	3005883a 	mov	r2,r6
8113a680:	e1ffff15 	stw	r7,-4(fp)
8113a684:	e0fffd0d 	sth	r3,-12(fp)
8113a688:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
8113a68c:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113a690:	e0bfff17 	ldw	r2,-4(fp)
8113a694:	1000021e 	bne	r2,zero,8113a6a0 <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
8113a698:	0005883a 	mov	r2,zero
8113a69c:	0000d106 	br	8113a9e4 <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
8113a6a0:	e0bffc17 	ldw	r2,-16(fp)
8113a6a4:	1000051e 	bne	r2,zero,8113a6bc <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113a6a8:	e0bfff17 	ldw	r2,-4(fp)
8113a6ac:	00c01b84 	movi	r3,110
8113a6b0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113a6b4:	0005883a 	mov	r2,zero
8113a6b8:	0000ca06 	br	8113a9e4 <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
8113a6bc:	e0bffc17 	ldw	r2,-16(fp)
8113a6c0:	10800003 	ldbu	r2,0(r2)
8113a6c4:	10803fcc 	andi	r2,r2,255
8113a6c8:	10800160 	cmpeqi	r2,r2,5
8113a6cc:	1000051e 	bne	r2,zero,8113a6e4 <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
8113a6d0:	e0bfff17 	ldw	r2,-4(fp)
8113a6d4:	00c00044 	movi	r3,1
8113a6d8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113a6dc:	0005883a 	mov	r2,zero
8113a6e0:	0000c006 	br	8113a9e4 <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a6e4:	0005303a 	rdctl	r2,status
8113a6e8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a6ec:	e0fffb17 	ldw	r3,-20(fp)
8113a6f0:	00bfff84 	movi	r2,-2
8113a6f4:	1884703a 	and	r2,r3,r2
8113a6f8:	1001703a 	wrctl	status,r2
  
  return context;
8113a6fc:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113a700:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
8113a704:	e0bffe03 	ldbu	r2,-8(fp)
8113a708:	10000326 	beq	r2,zero,8113a718 <OSFlagPost+0xbc>
8113a70c:	10800060 	cmpeqi	r2,r2,1
8113a710:	10000b1e 	bne	r2,zero,8113a740 <OSFlagPost+0xe4>
8113a714:	00001206 	br	8113a760 <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
8113a718:	e0bffc17 	ldw	r2,-16(fp)
8113a71c:	1080020b 	ldhu	r2,8(r2)
8113a720:	1007883a 	mov	r3,r2
8113a724:	e0bffd0b 	ldhu	r2,-12(fp)
8113a728:	0084303a 	nor	r2,zero,r2
8113a72c:	1884703a 	and	r2,r3,r2
8113a730:	1007883a 	mov	r3,r2
8113a734:	e0bffc17 	ldw	r2,-16(fp)
8113a738:	10c0020d 	sth	r3,8(r2)
             break;
8113a73c:	00001106 	br	8113a784 <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
8113a740:	e0bffc17 	ldw	r2,-16(fp)
8113a744:	10c0020b 	ldhu	r3,8(r2)
8113a748:	e0bffd0b 	ldhu	r2,-12(fp)
8113a74c:	1884b03a 	or	r2,r3,r2
8113a750:	1007883a 	mov	r3,r2
8113a754:	e0bffc17 	ldw	r2,-16(fp)
8113a758:	10c0020d 	sth	r3,8(r2)
             break;
8113a75c:	00000906 	br	8113a784 <OSFlagPost+0x128>
8113a760:	e0bff317 	ldw	r2,-52(fp)
8113a764:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a768:	e0bff417 	ldw	r2,-48(fp)
8113a76c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
8113a770:	e0bfff17 	ldw	r2,-4(fp)
8113a774:	00c01c44 	movi	r3,113
8113a778:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
8113a77c:	0005883a 	mov	r2,zero
8113a780:	00009806 	br	8113a9e4 <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
8113a784:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113a788:	e0bffc17 	ldw	r2,-16(fp)
8113a78c:	10800117 	ldw	r2,4(r2)
8113a790:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8113a794:	00007706 	br	8113a974 <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
8113a798:	e0bff117 	ldw	r2,-60(fp)
8113a79c:	10800483 	ldbu	r2,18(r2)
8113a7a0:	10803fcc 	andi	r2,r2,255
8113a7a4:	10c00060 	cmpeqi	r3,r2,1
8113a7a8:	18004a1e 	bne	r3,zero,8113a8d4 <OSFlagPost+0x278>
8113a7ac:	10c00088 	cmpgei	r3,r2,2
8113a7b0:	1800021e 	bne	r3,zero,8113a7bc <OSFlagPost+0x160>
8113a7b4:	10002f26 	beq	r2,zero,8113a874 <OSFlagPost+0x218>
8113a7b8:	00005b06 	br	8113a928 <OSFlagPost+0x2cc>
8113a7bc:	10c000a0 	cmpeqi	r3,r2,2
8113a7c0:	1800031e 	bne	r3,zero,8113a7d0 <OSFlagPost+0x174>
8113a7c4:	108000e0 	cmpeqi	r2,r2,3
8113a7c8:	1000171e 	bne	r2,zero,8113a828 <OSFlagPost+0x1cc>
8113a7cc:	00005606 	br	8113a928 <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113a7d0:	e0bffc17 	ldw	r2,-16(fp)
8113a7d4:	10c0020b 	ldhu	r3,8(r2)
8113a7d8:	e0bff117 	ldw	r2,-60(fp)
8113a7dc:	1080040b 	ldhu	r2,16(r2)
8113a7e0:	1884703a 	and	r2,r3,r2
8113a7e4:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113a7e8:	e0bff117 	ldw	r2,-60(fp)
8113a7ec:	1080040b 	ldhu	r2,16(r2)
8113a7f0:	10ffffcc 	andi	r3,r2,65535
8113a7f4:	e0bff60b 	ldhu	r2,-40(fp)
8113a7f8:	1880541e 	bne	r3,r2,8113a94c <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113a7fc:	e0bff60b 	ldhu	r2,-40(fp)
8113a800:	100b883a 	mov	r5,r2
8113a804:	e13ff117 	ldw	r4,-60(fp)
8113a808:	113ad140 	call	8113ad14 <OS_FlagTaskRdy>
8113a80c:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113a810:	e0bff683 	ldbu	r2,-38(fp)
8113a814:	10800058 	cmpnei	r2,r2,1
8113a818:	10004c1e 	bne	r2,zero,8113a94c <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113a81c:	00800044 	movi	r2,1
8113a820:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113a824:	00004906 	br	8113a94c <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113a828:	e0bffc17 	ldw	r2,-16(fp)
8113a82c:	10c0020b 	ldhu	r3,8(r2)
8113a830:	e0bff117 	ldw	r2,-60(fp)
8113a834:	1080040b 	ldhu	r2,16(r2)
8113a838:	1884703a 	and	r2,r3,r2
8113a83c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113a840:	e0bff60b 	ldhu	r2,-40(fp)
8113a844:	10004326 	beq	r2,zero,8113a954 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113a848:	e0bff60b 	ldhu	r2,-40(fp)
8113a84c:	100b883a 	mov	r5,r2
8113a850:	e13ff117 	ldw	r4,-60(fp)
8113a854:	113ad140 	call	8113ad14 <OS_FlagTaskRdy>
8113a858:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113a85c:	e0bff683 	ldbu	r2,-38(fp)
8113a860:	10800058 	cmpnei	r2,r2,1
8113a864:	10003b1e 	bne	r2,zero,8113a954 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113a868:	00800044 	movi	r2,1
8113a86c:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113a870:	00003806 	br	8113a954 <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113a874:	e0bffc17 	ldw	r2,-16(fp)
8113a878:	1080020b 	ldhu	r2,8(r2)
8113a87c:	0084303a 	nor	r2,zero,r2
8113a880:	1007883a 	mov	r3,r2
8113a884:	e0bff117 	ldw	r2,-60(fp)
8113a888:	1080040b 	ldhu	r2,16(r2)
8113a88c:	1884703a 	and	r2,r3,r2
8113a890:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113a894:	e0bff117 	ldw	r2,-60(fp)
8113a898:	1080040b 	ldhu	r2,16(r2)
8113a89c:	10ffffcc 	andi	r3,r2,65535
8113a8a0:	e0bff60b 	ldhu	r2,-40(fp)
8113a8a4:	18802d1e 	bne	r3,r2,8113a95c <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113a8a8:	e0bff60b 	ldhu	r2,-40(fp)
8113a8ac:	100b883a 	mov	r5,r2
8113a8b0:	e13ff117 	ldw	r4,-60(fp)
8113a8b4:	113ad140 	call	8113ad14 <OS_FlagTaskRdy>
8113a8b8:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113a8bc:	e0bff683 	ldbu	r2,-38(fp)
8113a8c0:	10800058 	cmpnei	r2,r2,1
8113a8c4:	1000251e 	bne	r2,zero,8113a95c <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113a8c8:	00800044 	movi	r2,1
8113a8cc:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113a8d0:	00002206 	br	8113a95c <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113a8d4:	e0bffc17 	ldw	r2,-16(fp)
8113a8d8:	1080020b 	ldhu	r2,8(r2)
8113a8dc:	0084303a 	nor	r2,zero,r2
8113a8e0:	1007883a 	mov	r3,r2
8113a8e4:	e0bff117 	ldw	r2,-60(fp)
8113a8e8:	1080040b 	ldhu	r2,16(r2)
8113a8ec:	1884703a 	and	r2,r3,r2
8113a8f0:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
8113a8f4:	e0bff60b 	ldhu	r2,-40(fp)
8113a8f8:	10001a26 	beq	r2,zero,8113a964 <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113a8fc:	e0bff60b 	ldhu	r2,-40(fp)
8113a900:	100b883a 	mov	r5,r2
8113a904:	e13ff117 	ldw	r4,-60(fp)
8113a908:	113ad140 	call	8113ad14 <OS_FlagTaskRdy>
8113a90c:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113a910:	e0bff683 	ldbu	r2,-38(fp)
8113a914:	10800058 	cmpnei	r2,r2,1
8113a918:	1000121e 	bne	r2,zero,8113a964 <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113a91c:	00800044 	movi	r2,1
8113a920:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
8113a924:	00000f06 	br	8113a964 <OSFlagPost+0x308>
8113a928:	e0bff317 	ldw	r2,-52(fp)
8113a92c:	e0bff515 	stw	r2,-44(fp)
8113a930:	e0bff517 	ldw	r2,-44(fp)
8113a934:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113a938:	e0bfff17 	ldw	r2,-4(fp)
8113a93c:	00c01bc4 	movi	r3,111
8113a940:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
8113a944:	0005883a 	mov	r2,zero
8113a948:	00002606 	br	8113a9e4 <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113a94c:	0001883a 	nop
8113a950:	00000506 	br	8113a968 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113a954:	0001883a 	nop
8113a958:	00000306 	br	8113a968 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113a95c:	0001883a 	nop
8113a960:	00000106 	br	8113a968 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113a964:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
8113a968:	e0bff117 	ldw	r2,-60(fp)
8113a96c:	10800017 	ldw	r2,0(r2)
8113a970:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
8113a974:	e0bff117 	ldw	r2,-60(fp)
8113a978:	103f871e 	bne	r2,zero,8113a798 <__reset+0xfb11a798>
8113a97c:	e0bff317 	ldw	r2,-52(fp)
8113a980:	e0bff715 	stw	r2,-36(fp)
8113a984:	e0bff717 	ldw	r2,-36(fp)
8113a988:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
8113a98c:	e0bff203 	ldbu	r2,-56(fp)
8113a990:	10800058 	cmpnei	r2,r2,1
8113a994:	1000011e 	bne	r2,zero,8113a99c <OSFlagPost+0x340>
        OS_Sched();
8113a998:	1138e240 	call	81138e24 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a99c:	0005303a 	rdctl	r2,status
8113a9a0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a9a4:	e0fffa17 	ldw	r3,-24(fp)
8113a9a8:	00bfff84 	movi	r2,-2
8113a9ac:	1884703a 	and	r2,r3,r2
8113a9b0:	1001703a 	wrctl	status,r2
  
  return context;
8113a9b4:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
8113a9b8:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
8113a9bc:	e0bffc17 	ldw	r2,-16(fp)
8113a9c0:	1080020b 	ldhu	r2,8(r2)
8113a9c4:	e0bff90d 	sth	r2,-28(fp)
8113a9c8:	e0bff317 	ldw	r2,-52(fp)
8113a9cc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a9d0:	e0bff817 	ldw	r2,-32(fp)
8113a9d4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
8113a9d8:	e0bfff17 	ldw	r2,-4(fp)
8113a9dc:	10000005 	stb	zero,0(r2)
    return (flags_cur);
8113a9e0:	e0bff90b 	ldhu	r2,-28(fp)
}
8113a9e4:	e037883a 	mov	sp,fp
8113a9e8:	dfc00117 	ldw	ra,4(sp)
8113a9ec:	df000017 	ldw	fp,0(sp)
8113a9f0:	dec00204 	addi	sp,sp,8
8113a9f4:	f800283a 	ret

8113a9f8 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
8113a9f8:	defff904 	addi	sp,sp,-28
8113a9fc:	de00012e 	bgeu	sp,et,8113aa04 <OSFlagQuery+0xc>
8113aa00:	003b68fa 	trap	3
8113aa04:	df000615 	stw	fp,24(sp)
8113aa08:	df000604 	addi	fp,sp,24
8113aa0c:	e13ffe15 	stw	r4,-8(fp)
8113aa10:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
8113aa14:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
8113aa18:	e0bfff17 	ldw	r2,-4(fp)
8113aa1c:	1000021e 	bne	r2,zero,8113aa28 <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
8113aa20:	0005883a 	mov	r2,zero
8113aa24:	00002306 	br	8113aab4 <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
8113aa28:	e0bffe17 	ldw	r2,-8(fp)
8113aa2c:	1000051e 	bne	r2,zero,8113aa44 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113aa30:	e0bfff17 	ldw	r2,-4(fp)
8113aa34:	00c01b84 	movi	r3,110
8113aa38:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113aa3c:	0005883a 	mov	r2,zero
8113aa40:	00001c06 	br	8113aab4 <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
8113aa44:	e0bffe17 	ldw	r2,-8(fp)
8113aa48:	10800003 	ldbu	r2,0(r2)
8113aa4c:	10803fcc 	andi	r2,r2,255
8113aa50:	10800160 	cmpeqi	r2,r2,5
8113aa54:	1000051e 	bne	r2,zero,8113aa6c <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113aa58:	e0bfff17 	ldw	r2,-4(fp)
8113aa5c:	00c00044 	movi	r3,1
8113aa60:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113aa64:	0005883a 	mov	r2,zero
8113aa68:	00001206 	br	8113aab4 <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113aa6c:	0005303a 	rdctl	r2,status
8113aa70:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113aa74:	e0fffc17 	ldw	r3,-16(fp)
8113aa78:	00bfff84 	movi	r2,-2
8113aa7c:	1884703a 	and	r2,r3,r2
8113aa80:	1001703a 	wrctl	status,r2
  
  return context;
8113aa84:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113aa88:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
8113aa8c:	e0bffe17 	ldw	r2,-8(fp)
8113aa90:	1080020b 	ldhu	r2,8(r2)
8113aa94:	e0bffb0d 	sth	r2,-20(fp)
8113aa98:	e0bffa17 	ldw	r2,-24(fp)
8113aa9c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113aaa0:	e0bffd17 	ldw	r2,-12(fp)
8113aaa4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113aaa8:	e0bfff17 	ldw	r2,-4(fp)
8113aaac:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
8113aab0:	e0bffb0b 	ldhu	r2,-20(fp)
}
8113aab4:	e037883a 	mov	sp,fp
8113aab8:	df000017 	ldw	fp,0(sp)
8113aabc:	dec00104 	addi	sp,sp,4
8113aac0:	f800283a 	ret

8113aac4 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
8113aac4:	defff804 	addi	sp,sp,-32
8113aac8:	de00012e 	bgeu	sp,et,8113aad0 <OS_FlagBlock+0xc>
8113aacc:	003b68fa 	trap	3
8113aad0:	df000715 	stw	fp,28(sp)
8113aad4:	df000704 	addi	fp,sp,28
8113aad8:	e13ffb15 	stw	r4,-20(fp)
8113aadc:	e17ffc15 	stw	r5,-16(fp)
8113aae0:	3009883a 	mov	r4,r6
8113aae4:	3807883a 	mov	r3,r7
8113aae8:	e0800117 	ldw	r2,4(fp)
8113aaec:	e13ffd0d 	sth	r4,-12(fp)
8113aaf0:	e0fffe05 	stb	r3,-8(fp)
8113aaf4:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
8113aaf8:	d0a0a117 	ldw	r2,-32124(gp)
8113aafc:	d0e0a117 	ldw	r3,-32124(gp)
8113ab00:	18c00c03 	ldbu	r3,48(r3)
8113ab04:	18c00814 	ori	r3,r3,32
8113ab08:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
8113ab0c:	d0a0a117 	ldw	r2,-32124(gp)
8113ab10:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
8113ab14:	d0a0a117 	ldw	r2,-32124(gp)
8113ab18:	e0ffff0b 	ldhu	r3,-4(fp)
8113ab1c:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
8113ab20:	d0a0a117 	ldw	r2,-32124(gp)
8113ab24:	e0fffc17 	ldw	r3,-16(fp)
8113ab28:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
8113ab2c:	e0bffc17 	ldw	r2,-16(fp)
8113ab30:	e0fffd0b 	ldhu	r3,-12(fp)
8113ab34:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
8113ab38:	e0bffc17 	ldw	r2,-16(fp)
8113ab3c:	e0fffe03 	ldbu	r3,-8(fp)
8113ab40:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
8113ab44:	d0e0a117 	ldw	r3,-32124(gp)
8113ab48:	e0bffc17 	ldw	r2,-16(fp)
8113ab4c:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
8113ab50:	e0bffb17 	ldw	r2,-20(fp)
8113ab54:	10c00117 	ldw	r3,4(r2)
8113ab58:	e0bffc17 	ldw	r2,-16(fp)
8113ab5c:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
8113ab60:	e0bffc17 	ldw	r2,-16(fp)
8113ab64:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
8113ab68:	e0bffc17 	ldw	r2,-16(fp)
8113ab6c:	e0fffb17 	ldw	r3,-20(fp)
8113ab70:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113ab74:	e0bffb17 	ldw	r2,-20(fp)
8113ab78:	10800117 	ldw	r2,4(r2)
8113ab7c:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
8113ab80:	e0bff917 	ldw	r2,-28(fp)
8113ab84:	10000326 	beq	r2,zero,8113ab94 <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
8113ab88:	e0bff917 	ldw	r2,-28(fp)
8113ab8c:	e0fffc17 	ldw	r3,-16(fp)
8113ab90:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
8113ab94:	e0bffb17 	ldw	r2,-20(fp)
8113ab98:	e0fffc17 	ldw	r3,-16(fp)
8113ab9c:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
8113aba0:	d0a0a117 	ldw	r2,-32124(gp)
8113aba4:	10800d03 	ldbu	r2,52(r2)
8113aba8:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8113abac:	e0fffa03 	ldbu	r3,-24(fp)
8113abb0:	e13ffa03 	ldbu	r4,-24(fp)
8113abb4:	d0a09d44 	addi	r2,gp,-32139
8113abb8:	2085883a 	add	r2,r4,r2
8113abbc:	10800003 	ldbu	r2,0(r2)
8113abc0:	1009883a 	mov	r4,r2
8113abc4:	d0a0a117 	ldw	r2,-32124(gp)
8113abc8:	10800d43 	ldbu	r2,53(r2)
8113abcc:	0084303a 	nor	r2,zero,r2
8113abd0:	2084703a 	and	r2,r4,r2
8113abd4:	1009883a 	mov	r4,r2
8113abd8:	d0a09d44 	addi	r2,gp,-32139
8113abdc:	1885883a 	add	r2,r3,r2
8113abe0:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
8113abe4:	e0fffa03 	ldbu	r3,-24(fp)
8113abe8:	d0a09d44 	addi	r2,gp,-32139
8113abec:	1885883a 	add	r2,r3,r2
8113abf0:	10800003 	ldbu	r2,0(r2)
8113abf4:	10803fcc 	andi	r2,r2,255
8113abf8:	1000071e 	bne	r2,zero,8113ac18 <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8113abfc:	d0a0a117 	ldw	r2,-32124(gp)
8113ac00:	10800d83 	ldbu	r2,54(r2)
8113ac04:	0084303a 	nor	r2,zero,r2
8113ac08:	1007883a 	mov	r3,r2
8113ac0c:	d0a09d03 	ldbu	r2,-32140(gp)
8113ac10:	1884703a 	and	r2,r3,r2
8113ac14:	d0a09d05 	stb	r2,-32140(gp)
    }
}
8113ac18:	0001883a 	nop
8113ac1c:	e037883a 	mov	sp,fp
8113ac20:	df000017 	ldw	fp,0(sp)
8113ac24:	dec00104 	addi	sp,sp,4
8113ac28:	f800283a 	ret

8113ac2c <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
8113ac2c:	defffb04 	addi	sp,sp,-20
8113ac30:	de00012e 	bgeu	sp,et,8113ac38 <OS_FlagInit+0xc>
8113ac34:	003b68fa 	trap	3
8113ac38:	dfc00415 	stw	ra,16(sp)
8113ac3c:	df000315 	stw	fp,12(sp)
8113ac40:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
8113ac44:	01421004 	movi	r5,2112
8113ac48:	012045b4 	movhi	r4,33046
8113ac4c:	21177c04 	addi	r4,r4,24048
8113ac50:	1138d580 	call	81138d58 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
8113ac54:	00a045b4 	movhi	r2,33046
8113ac58:	10977c04 	addi	r2,r2,24048
8113ac5c:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
8113ac60:	00a045b4 	movhi	r2,33046
8113ac64:	10978704 	addi	r2,r2,24092
8113ac68:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8113ac6c:	e03ffd0d 	sth	zero,-12(fp)
8113ac70:	00001306 	br	8113acc0 <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113ac74:	e0bffe17 	ldw	r2,-8(fp)
8113ac78:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
8113ac7c:	e0bffe17 	ldw	r2,-8(fp)
8113ac80:	e0ffff17 	ldw	r3,-4(fp)
8113ac84:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
8113ac88:	e0bffe17 	ldw	r2,-8(fp)
8113ac8c:	00c00fc4 	movi	r3,63
8113ac90:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113ac94:	e0bffe17 	ldw	r2,-8(fp)
8113ac98:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
8113ac9c:	e0bffe17 	ldw	r2,-8(fp)
8113aca0:	10800b04 	addi	r2,r2,44
8113aca4:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
8113aca8:	e0bfff17 	ldw	r2,-4(fp)
8113acac:	10800b04 	addi	r2,r2,44
8113acb0:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
8113acb4:	e0bffd0b 	ldhu	r2,-12(fp)
8113acb8:	10800044 	addi	r2,r2,1
8113acbc:	e0bffd0d 	sth	r2,-12(fp)
8113acc0:	e0bffd0b 	ldhu	r2,-12(fp)
8113acc4:	10800bf0 	cmpltui	r2,r2,47
8113acc8:	103fea1e 	bne	r2,zero,8113ac74 <__reset+0xfb11ac74>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
8113accc:	e0bffe17 	ldw	r2,-8(fp)
8113acd0:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
8113acd4:	e0bffe17 	ldw	r2,-8(fp)
8113acd8:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
8113acdc:	e0bffe17 	ldw	r2,-8(fp)
8113ace0:	00c00fc4 	movi	r3,63
8113ace4:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113ace8:	e0bffe17 	ldw	r2,-8(fp)
8113acec:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
8113acf0:	00a045b4 	movhi	r2,33046
8113acf4:	10977c04 	addi	r2,r2,24048
8113acf8:	d0a0a515 	stw	r2,-32108(gp)
#endif
}
8113acfc:	0001883a 	nop
8113ad00:	e037883a 	mov	sp,fp
8113ad04:	dfc00117 	ldw	ra,4(sp)
8113ad08:	df000017 	ldw	fp,0(sp)
8113ad0c:	dec00204 	addi	sp,sp,8
8113ad10:	f800283a 	ret

8113ad14 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
8113ad14:	defffa04 	addi	sp,sp,-24
8113ad18:	de00012e 	bgeu	sp,et,8113ad20 <OS_FlagTaskRdy+0xc>
8113ad1c:	003b68fa 	trap	3
8113ad20:	dfc00515 	stw	ra,20(sp)
8113ad24:	df000415 	stw	fp,16(sp)
8113ad28:	df000404 	addi	fp,sp,16
8113ad2c:	e13ffe15 	stw	r4,-8(fp)
8113ad30:	2805883a 	mov	r2,r5
8113ad34:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
8113ad38:	e0bffe17 	ldw	r2,-8(fp)
8113ad3c:	10800217 	ldw	r2,8(r2)
8113ad40:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
8113ad44:	e0bffd17 	ldw	r2,-12(fp)
8113ad48:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
8113ad4c:	e0bffd17 	ldw	r2,-12(fp)
8113ad50:	e0ffff0b 	ldhu	r3,-4(fp)
8113ad54:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
8113ad58:	e0bffd17 	ldw	r2,-12(fp)
8113ad5c:	10c00c03 	ldbu	r3,48(r2)
8113ad60:	00bff7c4 	movi	r2,-33
8113ad64:	1884703a 	and	r2,r3,r2
8113ad68:	1007883a 	mov	r3,r2
8113ad6c:	e0bffd17 	ldw	r2,-12(fp)
8113ad70:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
8113ad74:	e0bffd17 	ldw	r2,-12(fp)
8113ad78:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
8113ad7c:	e0bffd17 	ldw	r2,-12(fp)
8113ad80:	10800c03 	ldbu	r2,48(r2)
8113ad84:	10803fcc 	andi	r2,r2,255
8113ad88:	1000181e 	bne	r2,zero,8113adec <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
8113ad8c:	e0bffd17 	ldw	r2,-12(fp)
8113ad90:	10c00d83 	ldbu	r3,54(r2)
8113ad94:	d0a09d03 	ldbu	r2,-32140(gp)
8113ad98:	1884b03a 	or	r2,r3,r2
8113ad9c:	d0a09d05 	stb	r2,-32140(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113ada0:	e0bffd17 	ldw	r2,-12(fp)
8113ada4:	10800d03 	ldbu	r2,52(r2)
8113ada8:	10c03fcc 	andi	r3,r2,255
8113adac:	e0bffd17 	ldw	r2,-12(fp)
8113adb0:	10800d03 	ldbu	r2,52(r2)
8113adb4:	11003fcc 	andi	r4,r2,255
8113adb8:	d0a09d44 	addi	r2,gp,-32139
8113adbc:	2085883a 	add	r2,r4,r2
8113adc0:	11000003 	ldbu	r4,0(r2)
8113adc4:	e0bffd17 	ldw	r2,-12(fp)
8113adc8:	10800d43 	ldbu	r2,53(r2)
8113adcc:	2084b03a 	or	r2,r4,r2
8113add0:	1009883a 	mov	r4,r2
8113add4:	d0a09d44 	addi	r2,gp,-32139
8113add8:	1885883a 	add	r2,r3,r2
8113addc:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
8113ade0:	00800044 	movi	r2,1
8113ade4:	e0bffc05 	stb	r2,-16(fp)
8113ade8:	00000106 	br	8113adf0 <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
8113adec:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
8113adf0:	e13ffe17 	ldw	r4,-8(fp)
8113adf4:	113ae100 	call	8113ae10 <OS_FlagUnlink>
    return (sched);
8113adf8:	e0bffc03 	ldbu	r2,-16(fp)
}
8113adfc:	e037883a 	mov	sp,fp
8113ae00:	dfc00117 	ldw	ra,4(sp)
8113ae04:	df000017 	ldw	fp,0(sp)
8113ae08:	dec00204 	addi	sp,sp,8
8113ae0c:	f800283a 	ret

8113ae10 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
8113ae10:	defffa04 	addi	sp,sp,-24
8113ae14:	de00012e 	bgeu	sp,et,8113ae1c <OS_FlagUnlink+0xc>
8113ae18:	003b68fa 	trap	3
8113ae1c:	df000515 	stw	fp,20(sp)
8113ae20:	df000504 	addi	fp,sp,20
8113ae24:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
8113ae28:	e0bfff17 	ldw	r2,-4(fp)
8113ae2c:	10800117 	ldw	r2,4(r2)
8113ae30:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
8113ae34:	e0bfff17 	ldw	r2,-4(fp)
8113ae38:	10800017 	ldw	r2,0(r2)
8113ae3c:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
8113ae40:	e0bffb17 	ldw	r2,-20(fp)
8113ae44:	10000b1e 	bne	r2,zero,8113ae74 <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
8113ae48:	e0bfff17 	ldw	r2,-4(fp)
8113ae4c:	10800317 	ldw	r2,12(r2)
8113ae50:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
8113ae54:	e0bffd17 	ldw	r2,-12(fp)
8113ae58:	e0fffc17 	ldw	r3,-16(fp)
8113ae5c:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
8113ae60:	e0bffc17 	ldw	r2,-16(fp)
8113ae64:	10000b26 	beq	r2,zero,8113ae94 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
8113ae68:	e0bffc17 	ldw	r2,-16(fp)
8113ae6c:	10000115 	stw	zero,4(r2)
8113ae70:	00000806 	br	8113ae94 <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
8113ae74:	e0bffb17 	ldw	r2,-20(fp)
8113ae78:	e0fffc17 	ldw	r3,-16(fp)
8113ae7c:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
8113ae80:	e0bffc17 	ldw	r2,-16(fp)
8113ae84:	10000326 	beq	r2,zero,8113ae94 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
8113ae88:	e0bffc17 	ldw	r2,-16(fp)
8113ae8c:	e0fffb17 	ldw	r3,-20(fp)
8113ae90:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
8113ae94:	e0bfff17 	ldw	r2,-4(fp)
8113ae98:	10800217 	ldw	r2,8(r2)
8113ae9c:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
8113aea0:	e0bffe17 	ldw	r2,-8(fp)
8113aea4:	10000a15 	stw	zero,40(r2)
#endif
}
8113aea8:	0001883a 	nop
8113aeac:	e037883a 	mov	sp,fp
8113aeb0:	df000017 	ldw	fp,0(sp)
8113aeb4:	dec00104 	addi	sp,sp,4
8113aeb8:	f800283a 	ret

8113aebc <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
8113aebc:	defff404 	addi	sp,sp,-48
8113aec0:	de00012e 	bgeu	sp,et,8113aec8 <OSMemCreate+0xc>
8113aec4:	003b68fa 	trap	3
8113aec8:	df000b15 	stw	fp,44(sp)
8113aecc:	df000b04 	addi	fp,sp,44
8113aed0:	e13ffc15 	stw	r4,-16(fp)
8113aed4:	e17ffd15 	stw	r5,-12(fp)
8113aed8:	e1bffe15 	stw	r6,-8(fp)
8113aedc:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113aee0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113aee4:	e0bfff17 	ldw	r2,-4(fp)
8113aee8:	1000021e 	bne	r2,zero,8113aef4 <OSMemCreate+0x38>
        return ((OS_MEM *)0);
8113aeec:	0005883a 	mov	r2,zero
8113aef0:	00006506 	br	8113b088 <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
8113aef4:	e0bffc17 	ldw	r2,-16(fp)
8113aef8:	1000051e 	bne	r2,zero,8113af10 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8113aefc:	e0bfff17 	ldw	r2,-4(fp)
8113af00:	00c01884 	movi	r3,98
8113af04:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113af08:	0005883a 	mov	r2,zero
8113af0c:	00005e06 	br	8113b088 <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
8113af10:	e0bffc17 	ldw	r2,-16(fp)
8113af14:	108000cc 	andi	r2,r2,3
8113af18:	10000526 	beq	r2,zero,8113af30 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
8113af1c:	e0bfff17 	ldw	r2,-4(fp)
8113af20:	00c01884 	movi	r3,98
8113af24:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113af28:	0005883a 	mov	r2,zero
8113af2c:	00005606 	br	8113b088 <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
8113af30:	e0bffd17 	ldw	r2,-12(fp)
8113af34:	108000a8 	cmpgeui	r2,r2,2
8113af38:	1000051e 	bne	r2,zero,8113af50 <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
8113af3c:	e0bfff17 	ldw	r2,-4(fp)
8113af40:	00c016c4 	movi	r3,91
8113af44:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113af48:	0005883a 	mov	r2,zero
8113af4c:	00004e06 	br	8113b088 <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
8113af50:	e0bffe17 	ldw	r2,-8(fp)
8113af54:	10800128 	cmpgeui	r2,r2,4
8113af58:	1000051e 	bne	r2,zero,8113af70 <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
8113af5c:	e0bfff17 	ldw	r2,-4(fp)
8113af60:	00c01704 	movi	r3,92
8113af64:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113af68:	0005883a 	mov	r2,zero
8113af6c:	00004606 	br	8113b088 <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113af70:	0005303a 	rdctl	r2,status
8113af74:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113af78:	e0fffb17 	ldw	r3,-20(fp)
8113af7c:	00bfff84 	movi	r2,-2
8113af80:	1884703a 	and	r2,r3,r2
8113af84:	1001703a 	wrctl	status,r2
  
  return context;
8113af88:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113af8c:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
8113af90:	d0a09a17 	ldw	r2,-32152(gp)
8113af94:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
8113af98:	d0a09a17 	ldw	r2,-32152(gp)
8113af9c:	10000326 	beq	r2,zero,8113afac <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
8113afa0:	d0a09a17 	ldw	r2,-32152(gp)
8113afa4:	10800117 	ldw	r2,4(r2)
8113afa8:	d0a09a15 	stw	r2,-32152(gp)
8113afac:	e0bff817 	ldw	r2,-32(fp)
8113afb0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113afb4:	e0bff917 	ldw	r2,-28(fp)
8113afb8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
8113afbc:	e0bffa17 	ldw	r2,-24(fp)
8113afc0:	1000051e 	bne	r2,zero,8113afd8 <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
8113afc4:	e0bfff17 	ldw	r2,-4(fp)
8113afc8:	00c01684 	movi	r3,90
8113afcc:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113afd0:	0005883a 	mov	r2,zero
8113afd4:	00002c06 	br	8113b088 <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
8113afd8:	e0bffc17 	ldw	r2,-16(fp)
8113afdc:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
8113afe0:	e0fffc17 	ldw	r3,-16(fp)
8113afe4:	e0bffe17 	ldw	r2,-8(fp)
8113afe8:	1885883a 	add	r2,r3,r2
8113afec:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
8113aff0:	e03ff715 	stw	zero,-36(fp)
8113aff4:	00000c06 	br	8113b028 <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
8113aff8:	e0bff617 	ldw	r2,-40(fp)
8113affc:	e0fff517 	ldw	r3,-44(fp)
8113b000:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
8113b004:	e0bff517 	ldw	r2,-44(fp)
8113b008:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
8113b00c:	e0fff517 	ldw	r3,-44(fp)
8113b010:	e0bffe17 	ldw	r2,-8(fp)
8113b014:	1885883a 	add	r2,r3,r2
8113b018:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
8113b01c:	e0bff717 	ldw	r2,-36(fp)
8113b020:	10800044 	addi	r2,r2,1
8113b024:	e0bff715 	stw	r2,-36(fp)
8113b028:	e0bffd17 	ldw	r2,-12(fp)
8113b02c:	10bfffc4 	addi	r2,r2,-1
8113b030:	e0fff717 	ldw	r3,-36(fp)
8113b034:	18bff036 	bltu	r3,r2,8113aff8 <__reset+0xfb11aff8>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
8113b038:	e0bff617 	ldw	r2,-40(fp)
8113b03c:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
8113b040:	e0bffa17 	ldw	r2,-24(fp)
8113b044:	e0fffc17 	ldw	r3,-16(fp)
8113b048:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
8113b04c:	e0bffa17 	ldw	r2,-24(fp)
8113b050:	e0fffc17 	ldw	r3,-16(fp)
8113b054:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
8113b058:	e0bffa17 	ldw	r2,-24(fp)
8113b05c:	e0fffd17 	ldw	r3,-12(fp)
8113b060:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
8113b064:	e0bffa17 	ldw	r2,-24(fp)
8113b068:	e0fffd17 	ldw	r3,-12(fp)
8113b06c:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
8113b070:	e0bffa17 	ldw	r2,-24(fp)
8113b074:	e0fffe17 	ldw	r3,-8(fp)
8113b078:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
8113b07c:	e0bfff17 	ldw	r2,-4(fp)
8113b080:	10000005 	stb	zero,0(r2)
    return (pmem);
8113b084:	e0bffa17 	ldw	r2,-24(fp)
}
8113b088:	e037883a 	mov	sp,fp
8113b08c:	df000017 	ldw	fp,0(sp)
8113b090:	dec00104 	addi	sp,sp,4
8113b094:	f800283a 	ret

8113b098 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
8113b098:	defff804 	addi	sp,sp,-32
8113b09c:	de00012e 	bgeu	sp,et,8113b0a4 <OSMemGet+0xc>
8113b0a0:	003b68fa 	trap	3
8113b0a4:	df000715 	stw	fp,28(sp)
8113b0a8:	df000704 	addi	fp,sp,28
8113b0ac:	e13ffe15 	stw	r4,-8(fp)
8113b0b0:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113b0b4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113b0b8:	e0bfff17 	ldw	r2,-4(fp)
8113b0bc:	1000021e 	bne	r2,zero,8113b0c8 <OSMemGet+0x30>
        return ((void *)0);
8113b0c0:	0005883a 	mov	r2,zero
8113b0c4:	00002e06 	br	8113b180 <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
8113b0c8:	e0bffe17 	ldw	r2,-8(fp)
8113b0cc:	1000051e 	bne	r2,zero,8113b0e4 <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113b0d0:	e0bfff17 	ldw	r2,-4(fp)
8113b0d4:	00c01804 	movi	r3,96
8113b0d8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113b0dc:	0005883a 	mov	r2,zero
8113b0e0:	00002706 	br	8113b180 <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b0e4:	0005303a 	rdctl	r2,status
8113b0e8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b0ec:	e0fffd17 	ldw	r3,-12(fp)
8113b0f0:	00bfff84 	movi	r2,-2
8113b0f4:	1884703a 	and	r2,r3,r2
8113b0f8:	1001703a 	wrctl	status,r2
  
  return context;
8113b0fc:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113b100:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
8113b104:	e0bffe17 	ldw	r2,-8(fp)
8113b108:	10800417 	ldw	r2,16(r2)
8113b10c:	10001426 	beq	r2,zero,8113b160 <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
8113b110:	e0bffe17 	ldw	r2,-8(fp)
8113b114:	10800117 	ldw	r2,4(r2)
8113b118:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
8113b11c:	e0bffb17 	ldw	r2,-20(fp)
8113b120:	10c00017 	ldw	r3,0(r2)
8113b124:	e0bffe17 	ldw	r2,-8(fp)
8113b128:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
8113b12c:	e0bffe17 	ldw	r2,-8(fp)
8113b130:	10800417 	ldw	r2,16(r2)
8113b134:	10ffffc4 	addi	r3,r2,-1
8113b138:	e0bffe17 	ldw	r2,-8(fp)
8113b13c:	10c00415 	stw	r3,16(r2)
8113b140:	e0bff917 	ldw	r2,-28(fp)
8113b144:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b148:	e0bffa17 	ldw	r2,-24(fp)
8113b14c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
8113b150:	e0bfff17 	ldw	r2,-4(fp)
8113b154:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
8113b158:	e0bffb17 	ldw	r2,-20(fp)
8113b15c:	00000806 	br	8113b180 <OSMemGet+0xe8>
8113b160:	e0bff917 	ldw	r2,-28(fp)
8113b164:	e0bffc15 	stw	r2,-16(fp)
8113b168:	e0bffc17 	ldw	r2,-16(fp)
8113b16c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
8113b170:	e0bfff17 	ldw	r2,-4(fp)
8113b174:	00c01744 	movi	r3,93
8113b178:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
8113b17c:	0005883a 	mov	r2,zero
}
8113b180:	e037883a 	mov	sp,fp
8113b184:	df000017 	ldw	fp,0(sp)
8113b188:	dec00104 	addi	sp,sp,4
8113b18c:	f800283a 	ret

8113b190 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113b190:	defff704 	addi	sp,sp,-36
8113b194:	de00012e 	bgeu	sp,et,8113b19c <OSMemNameGet+0xc>
8113b198:	003b68fa 	trap	3
8113b19c:	dfc00815 	stw	ra,32(sp)
8113b1a0:	df000715 	stw	fp,28(sp)
8113b1a4:	df000704 	addi	fp,sp,28
8113b1a8:	e13ffd15 	stw	r4,-12(fp)
8113b1ac:	e17ffe15 	stw	r5,-8(fp)
8113b1b0:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b1b4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113b1b8:	e0bfff17 	ldw	r2,-4(fp)
8113b1bc:	1000021e 	bne	r2,zero,8113b1c8 <OSMemNameGet+0x38>
        return (0);
8113b1c0:	0005883a 	mov	r2,zero
8113b1c4:	00002b06 	br	8113b274 <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113b1c8:	e0bffd17 	ldw	r2,-12(fp)
8113b1cc:	1000051e 	bne	r2,zero,8113b1e4 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113b1d0:	e0bfff17 	ldw	r2,-4(fp)
8113b1d4:	00c01804 	movi	r3,96
8113b1d8:	10c00005 	stb	r3,0(r2)
        return (0);
8113b1dc:	0005883a 	mov	r2,zero
8113b1e0:	00002406 	br	8113b274 <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113b1e4:	e0bffe17 	ldw	r2,-8(fp)
8113b1e8:	1000051e 	bne	r2,zero,8113b200 <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113b1ec:	e0bfff17 	ldw	r2,-4(fp)
8113b1f0:	00c00304 	movi	r3,12
8113b1f4:	10c00005 	stb	r3,0(r2)
        return (0);
8113b1f8:	0005883a 	mov	r2,zero
8113b1fc:	00001d06 	br	8113b274 <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113b200:	d0a0a003 	ldbu	r2,-32128(gp)
8113b204:	10803fcc 	andi	r2,r2,255
8113b208:	10000526 	beq	r2,zero,8113b220 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8113b20c:	e0bfff17 	ldw	r2,-4(fp)
8113b210:	00c00444 	movi	r3,17
8113b214:	10c00005 	stb	r3,0(r2)
        return (0);
8113b218:	0005883a 	mov	r2,zero
8113b21c:	00001506 	br	8113b274 <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b220:	0005303a 	rdctl	r2,status
8113b224:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b228:	e0fffb17 	ldw	r3,-20(fp)
8113b22c:	00bfff84 	movi	r2,-2
8113b230:	1884703a 	and	r2,r3,r2
8113b234:	1001703a 	wrctl	status,r2
  
  return context;
8113b238:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
8113b23c:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
8113b240:	e0bffd17 	ldw	r2,-12(fp)
8113b244:	10800504 	addi	r2,r2,20
8113b248:	100b883a 	mov	r5,r2
8113b24c:	e13ffe17 	ldw	r4,-8(fp)
8113b250:	1138f780 	call	81138f78 <OS_StrCopy>
8113b254:	e0bffa05 	stb	r2,-24(fp)
8113b258:	e0bff917 	ldw	r2,-28(fp)
8113b25c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b260:	e0bffc17 	ldw	r2,-16(fp)
8113b264:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113b268:	e0bfff17 	ldw	r2,-4(fp)
8113b26c:	10000005 	stb	zero,0(r2)
    return (len);
8113b270:	e0bffa03 	ldbu	r2,-24(fp)
}
8113b274:	e037883a 	mov	sp,fp
8113b278:	dfc00117 	ldw	ra,4(sp)
8113b27c:	df000017 	ldw	fp,0(sp)
8113b280:	dec00204 	addi	sp,sp,8
8113b284:	f800283a 	ret

8113b288 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113b288:	defff604 	addi	sp,sp,-40
8113b28c:	de00012e 	bgeu	sp,et,8113b294 <OSMemNameSet+0xc>
8113b290:	003b68fa 	trap	3
8113b294:	dfc00915 	stw	ra,36(sp)
8113b298:	df000815 	stw	fp,32(sp)
8113b29c:	df000804 	addi	fp,sp,32
8113b2a0:	e13ffd15 	stw	r4,-12(fp)
8113b2a4:	e17ffe15 	stw	r5,-8(fp)
8113b2a8:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b2ac:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113b2b0:	e0bfff17 	ldw	r2,-4(fp)
8113b2b4:	10003526 	beq	r2,zero,8113b38c <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113b2b8:	e0bffd17 	ldw	r2,-12(fp)
8113b2bc:	1000041e 	bne	r2,zero,8113b2d0 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113b2c0:	e0bfff17 	ldw	r2,-4(fp)
8113b2c4:	00c01804 	movi	r3,96
8113b2c8:	10c00005 	stb	r3,0(r2)
        return;
8113b2cc:	00003006 	br	8113b390 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113b2d0:	e0bffe17 	ldw	r2,-8(fp)
8113b2d4:	1000041e 	bne	r2,zero,8113b2e8 <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113b2d8:	e0bfff17 	ldw	r2,-4(fp)
8113b2dc:	00c00304 	movi	r3,12
8113b2e0:	10c00005 	stb	r3,0(r2)
        return;
8113b2e4:	00002a06 	br	8113b390 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113b2e8:	d0a0a003 	ldbu	r2,-32128(gp)
8113b2ec:	10803fcc 	andi	r2,r2,255
8113b2f0:	10000426 	beq	r2,zero,8113b304 <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113b2f4:	e0bfff17 	ldw	r2,-4(fp)
8113b2f8:	00c00484 	movi	r3,18
8113b2fc:	10c00005 	stb	r3,0(r2)
        return;
8113b300:	00002306 	br	8113b390 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b304:	0005303a 	rdctl	r2,status
8113b308:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b30c:	e0fffc17 	ldw	r3,-16(fp)
8113b310:	00bfff84 	movi	r2,-2
8113b314:	1884703a 	and	r2,r3,r2
8113b318:	1001703a 	wrctl	status,r2
  
  return context;
8113b31c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113b320:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8113b324:	e13ffe17 	ldw	r4,-8(fp)
8113b328:	1138ff40 	call	81138ff4 <OS_StrLen>
8113b32c:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
8113b330:	e0bffa03 	ldbu	r2,-24(fp)
8113b334:	10800830 	cmpltui	r2,r2,32
8113b338:	1000081e 	bne	r2,zero,8113b35c <OSMemNameSet+0xd4>
8113b33c:	e0bff817 	ldw	r2,-32(fp)
8113b340:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b344:	e0bff917 	ldw	r2,-28(fp)
8113b348:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
8113b34c:	e0bfff17 	ldw	r2,-4(fp)
8113b350:	00c018c4 	movi	r3,99
8113b354:	10c00005 	stb	r3,0(r2)
        return;
8113b358:	00000d06 	br	8113b390 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
8113b35c:	e0bffd17 	ldw	r2,-12(fp)
8113b360:	10800504 	addi	r2,r2,20
8113b364:	e17ffe17 	ldw	r5,-8(fp)
8113b368:	1009883a 	mov	r4,r2
8113b36c:	1138f780 	call	81138f78 <OS_StrCopy>
8113b370:	e0bff817 	ldw	r2,-32(fp)
8113b374:	e0bffb15 	stw	r2,-20(fp)
8113b378:	e0bffb17 	ldw	r2,-20(fp)
8113b37c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113b380:	e0bfff17 	ldw	r2,-4(fp)
8113b384:	10000005 	stb	zero,0(r2)
8113b388:	00000106 	br	8113b390 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113b38c:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113b390:	e037883a 	mov	sp,fp
8113b394:	dfc00117 	ldw	ra,4(sp)
8113b398:	df000017 	ldw	fp,0(sp)
8113b39c:	dec00204 	addi	sp,sp,8
8113b3a0:	f800283a 	ret

8113b3a4 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
8113b3a4:	defff904 	addi	sp,sp,-28
8113b3a8:	de00012e 	bgeu	sp,et,8113b3b0 <OSMemPut+0xc>
8113b3ac:	003b68fa 	trap	3
8113b3b0:	df000615 	stw	fp,24(sp)
8113b3b4:	df000604 	addi	fp,sp,24
8113b3b8:	e13ffe15 	stw	r4,-8(fp)
8113b3bc:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b3c0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113b3c4:	e0bffe17 	ldw	r2,-8(fp)
8113b3c8:	1000021e 	bne	r2,zero,8113b3d4 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113b3cc:	00801804 	movi	r2,96
8113b3d0:	00002806 	br	8113b474 <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
8113b3d4:	e0bfff17 	ldw	r2,-4(fp)
8113b3d8:	1000021e 	bne	r2,zero,8113b3e4 <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
8113b3dc:	008017c4 	movi	r2,95
8113b3e0:	00002406 	br	8113b474 <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b3e4:	0005303a 	rdctl	r2,status
8113b3e8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b3ec:	e0fffd17 	ldw	r3,-12(fp)
8113b3f0:	00bfff84 	movi	r2,-2
8113b3f4:	1884703a 	and	r2,r3,r2
8113b3f8:	1001703a 	wrctl	status,r2
  
  return context;
8113b3fc:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113b400:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
8113b404:	e0bffe17 	ldw	r2,-8(fp)
8113b408:	10c00417 	ldw	r3,16(r2)
8113b40c:	e0bffe17 	ldw	r2,-8(fp)
8113b410:	10800317 	ldw	r2,12(r2)
8113b414:	18800636 	bltu	r3,r2,8113b430 <OSMemPut+0x8c>
8113b418:	e0bffa17 	ldw	r2,-24(fp)
8113b41c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b420:	e0bffb17 	ldw	r2,-20(fp)
8113b424:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
8113b428:	00801784 	movi	r2,94
8113b42c:	00001106 	br	8113b474 <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
8113b430:	e0bffe17 	ldw	r2,-8(fp)
8113b434:	10c00117 	ldw	r3,4(r2)
8113b438:	e0bfff17 	ldw	r2,-4(fp)
8113b43c:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
8113b440:	e0bffe17 	ldw	r2,-8(fp)
8113b444:	e0ffff17 	ldw	r3,-4(fp)
8113b448:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
8113b44c:	e0bffe17 	ldw	r2,-8(fp)
8113b450:	10800417 	ldw	r2,16(r2)
8113b454:	10c00044 	addi	r3,r2,1
8113b458:	e0bffe17 	ldw	r2,-8(fp)
8113b45c:	10c00415 	stw	r3,16(r2)
8113b460:	e0bffa17 	ldw	r2,-24(fp)
8113b464:	e0bffc15 	stw	r2,-16(fp)
8113b468:	e0bffc17 	ldw	r2,-16(fp)
8113b46c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
8113b470:	0005883a 	mov	r2,zero
}
8113b474:	e037883a 	mov	sp,fp
8113b478:	df000017 	ldw	fp,0(sp)
8113b47c:	dec00104 	addi	sp,sp,4
8113b480:	f800283a 	ret

8113b484 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
8113b484:	defffa04 	addi	sp,sp,-24
8113b488:	de00012e 	bgeu	sp,et,8113b490 <OSMemQuery+0xc>
8113b48c:	003b68fa 	trap	3
8113b490:	df000515 	stw	fp,20(sp)
8113b494:	df000504 	addi	fp,sp,20
8113b498:	e13ffe15 	stw	r4,-8(fp)
8113b49c:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b4a0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113b4a4:	e0bffe17 	ldw	r2,-8(fp)
8113b4a8:	1000021e 	bne	r2,zero,8113b4b4 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113b4ac:	00801804 	movi	r2,96
8113b4b0:	00002c06 	br	8113b564 <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
8113b4b4:	e0bfff17 	ldw	r2,-4(fp)
8113b4b8:	1000021e 	bne	r2,zero,8113b4c4 <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
8113b4bc:	00801844 	movi	r2,97
8113b4c0:	00002806 	br	8113b564 <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b4c4:	0005303a 	rdctl	r2,status
8113b4c8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b4cc:	e0fffc17 	ldw	r3,-16(fp)
8113b4d0:	00bfff84 	movi	r2,-2
8113b4d4:	1884703a 	and	r2,r3,r2
8113b4d8:	1001703a 	wrctl	status,r2
  
  return context;
8113b4dc:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113b4e0:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
8113b4e4:	e0bffe17 	ldw	r2,-8(fp)
8113b4e8:	10c00017 	ldw	r3,0(r2)
8113b4ec:	e0bfff17 	ldw	r2,-4(fp)
8113b4f0:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
8113b4f4:	e0bffe17 	ldw	r2,-8(fp)
8113b4f8:	10c00117 	ldw	r3,4(r2)
8113b4fc:	e0bfff17 	ldw	r2,-4(fp)
8113b500:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
8113b504:	e0bffe17 	ldw	r2,-8(fp)
8113b508:	10c00217 	ldw	r3,8(r2)
8113b50c:	e0bfff17 	ldw	r2,-4(fp)
8113b510:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
8113b514:	e0bffe17 	ldw	r2,-8(fp)
8113b518:	10c00317 	ldw	r3,12(r2)
8113b51c:	e0bfff17 	ldw	r2,-4(fp)
8113b520:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
8113b524:	e0bffe17 	ldw	r2,-8(fp)
8113b528:	10c00417 	ldw	r3,16(r2)
8113b52c:	e0bfff17 	ldw	r2,-4(fp)
8113b530:	10c00415 	stw	r3,16(r2)
8113b534:	e0bffb17 	ldw	r2,-20(fp)
8113b538:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b53c:	e0bffd17 	ldw	r2,-12(fp)
8113b540:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
8113b544:	e0bfff17 	ldw	r2,-4(fp)
8113b548:	10c00317 	ldw	r3,12(r2)
8113b54c:	e0bfff17 	ldw	r2,-4(fp)
8113b550:	10800417 	ldw	r2,16(r2)
8113b554:	1887c83a 	sub	r3,r3,r2
8113b558:	e0bfff17 	ldw	r2,-4(fp)
8113b55c:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
8113b560:	0005883a 	mov	r2,zero
}
8113b564:	e037883a 	mov	sp,fp
8113b568:	df000017 	ldw	fp,0(sp)
8113b56c:	dec00104 	addi	sp,sp,4
8113b570:	f800283a 	ret

8113b574 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
8113b574:	defffc04 	addi	sp,sp,-16
8113b578:	de00012e 	bgeu	sp,et,8113b580 <OS_MemInit+0xc>
8113b57c:	003b68fa 	trap	3
8113b580:	dfc00315 	stw	ra,12(sp)
8113b584:	df000215 	stw	fp,8(sp)
8113b588:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
8113b58c:	01430c04 	movi	r5,3120
8113b590:	012045b4 	movhi	r4,33046
8113b594:	2119f404 	addi	r4,r4,26576
8113b598:	1138d580 	call	81138d58 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
8113b59c:	00a045b4 	movhi	r2,33046
8113b5a0:	1099f404 	addi	r2,r2,26576
8113b5a4:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113b5a8:	e03fff0d 	sth	zero,-4(fp)
8113b5ac:	00001306 	br	8113b5fc <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
8113b5b0:	e0bfff0b 	ldhu	r2,-4(fp)
8113b5b4:	10800044 	addi	r2,r2,1
8113b5b8:	10c00d24 	muli	r3,r2,52
8113b5bc:	00a045b4 	movhi	r2,33046
8113b5c0:	1099f404 	addi	r2,r2,26576
8113b5c4:	1887883a 	add	r3,r3,r2
8113b5c8:	e0bffe17 	ldw	r2,-8(fp)
8113b5cc:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
8113b5d0:	e0bffe17 	ldw	r2,-8(fp)
8113b5d4:	00c00fc4 	movi	r3,63
8113b5d8:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
8113b5dc:	e0bffe17 	ldw	r2,-8(fp)
8113b5e0:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
8113b5e4:	e0bffe17 	ldw	r2,-8(fp)
8113b5e8:	10800d04 	addi	r2,r2,52
8113b5ec:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113b5f0:	e0bfff0b 	ldhu	r2,-4(fp)
8113b5f4:	10800044 	addi	r2,r2,1
8113b5f8:	e0bfff0d 	sth	r2,-4(fp)
8113b5fc:	e0bfff0b 	ldhu	r2,-4(fp)
8113b600:	10800ef0 	cmpltui	r2,r2,59
8113b604:	103fea1e 	bne	r2,zero,8113b5b0 <__reset+0xfb11b5b0>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
8113b608:	e0bffe17 	ldw	r2,-8(fp)
8113b60c:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
8113b610:	e0bffe17 	ldw	r2,-8(fp)
8113b614:	00c00fc4 	movi	r3,63
8113b618:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
8113b61c:	e0bffe17 	ldw	r2,-8(fp)
8113b620:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
8113b624:	00a045b4 	movhi	r2,33046
8113b628:	1099f404 	addi	r2,r2,26576
8113b62c:	d0a09a15 	stw	r2,-32152(gp)
#endif
}
8113b630:	0001883a 	nop
8113b634:	e037883a 	mov	sp,fp
8113b638:	dfc00117 	ldw	ra,4(sp)
8113b63c:	df000017 	ldw	fp,0(sp)
8113b640:	dec00204 	addi	sp,sp,8
8113b644:	f800283a 	ret

8113b648 <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
8113b648:	defff704 	addi	sp,sp,-36
8113b64c:	de00012e 	bgeu	sp,et,8113b654 <OSMutexAccept+0xc>
8113b650:	003b68fa 	trap	3
8113b654:	df000815 	stw	fp,32(sp)
8113b658:	df000804 	addi	fp,sp,32
8113b65c:	e13ffe15 	stw	r4,-8(fp)
8113b660:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113b664:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
8113b668:	e0bfff17 	ldw	r2,-4(fp)
8113b66c:	1000021e 	bne	r2,zero,8113b678 <OSMutexAccept+0x30>
        return (OS_FALSE);
8113b670:	0005883a 	mov	r2,zero
8113b674:	00005b06 	br	8113b7e4 <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113b678:	e0bffe17 	ldw	r2,-8(fp)
8113b67c:	1000051e 	bne	r2,zero,8113b694 <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113b680:	e0bfff17 	ldw	r2,-4(fp)
8113b684:	00c00104 	movi	r3,4
8113b688:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113b68c:	0005883a 	mov	r2,zero
8113b690:	00005406 	br	8113b7e4 <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
8113b694:	e0bffe17 	ldw	r2,-8(fp)
8113b698:	10800003 	ldbu	r2,0(r2)
8113b69c:	10803fcc 	andi	r2,r2,255
8113b6a0:	10800120 	cmpeqi	r2,r2,4
8113b6a4:	1000051e 	bne	r2,zero,8113b6bc <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113b6a8:	e0bfff17 	ldw	r2,-4(fp)
8113b6ac:	00c00044 	movi	r3,1
8113b6b0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113b6b4:	0005883a 	mov	r2,zero
8113b6b8:	00004a06 	br	8113b7e4 <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
8113b6bc:	d0a0a003 	ldbu	r2,-32128(gp)
8113b6c0:	10803fcc 	andi	r2,r2,255
8113b6c4:	10000526 	beq	r2,zero,8113b6dc <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
8113b6c8:	e0bfff17 	ldw	r2,-4(fp)
8113b6cc:	00c00084 	movi	r3,2
8113b6d0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113b6d4:	0005883a 	mov	r2,zero
8113b6d8:	00004206 	br	8113b7e4 <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b6dc:	0005303a 	rdctl	r2,status
8113b6e0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b6e4:	e0fffd17 	ldw	r3,-12(fp)
8113b6e8:	00bfff84 	movi	r2,-2
8113b6ec:	1884703a 	and	r2,r3,r2
8113b6f0:	1001703a 	wrctl	status,r2
  
  return context;
8113b6f4:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
8113b6f8:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
8113b6fc:	e0bffe17 	ldw	r2,-8(fp)
8113b700:	1080020b 	ldhu	r2,8(r2)
8113b704:	10bfffcc 	andi	r2,r2,65535
8113b708:	1004d23a 	srli	r2,r2,8
8113b70c:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113b710:	e0bffe17 	ldw	r2,-8(fp)
8113b714:	1080020b 	ldhu	r2,8(r2)
8113b718:	10bfffcc 	andi	r2,r2,65535
8113b71c:	10803fcc 	andi	r2,r2,255
8113b720:	10803fd8 	cmpnei	r2,r2,255
8113b724:	1000281e 	bne	r2,zero,8113b7c8 <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
8113b728:	e0bffe17 	ldw	r2,-8(fp)
8113b72c:	10c0020b 	ldhu	r3,8(r2)
8113b730:	00bfc004 	movi	r2,-256
8113b734:	1884703a 	and	r2,r3,r2
8113b738:	1007883a 	mov	r3,r2
8113b73c:	e0bffe17 	ldw	r2,-8(fp)
8113b740:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
8113b744:	e0bffe17 	ldw	r2,-8(fp)
8113b748:	10c0020b 	ldhu	r3,8(r2)
8113b74c:	d0a0a117 	ldw	r2,-32124(gp)
8113b750:	10800c83 	ldbu	r2,50(r2)
8113b754:	10803fcc 	andi	r2,r2,255
8113b758:	1884b03a 	or	r2,r3,r2
8113b75c:	1007883a 	mov	r3,r2
8113b760:	e0bffe17 	ldw	r2,-8(fp)
8113b764:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
8113b768:	d0e0a117 	ldw	r3,-32124(gp)
8113b76c:	e0bffe17 	ldw	r2,-8(fp)
8113b770:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
8113b774:	d0a0a117 	ldw	r2,-32124(gp)
8113b778:	10800c83 	ldbu	r2,50(r2)
8113b77c:	10803fcc 	andi	r2,r2,255
8113b780:	e0fffa03 	ldbu	r3,-24(fp)
8113b784:	18800836 	bltu	r3,r2,8113b7a8 <OSMutexAccept+0x160>
8113b788:	e0bff817 	ldw	r2,-32(fp)
8113b78c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b790:	e0bff917 	ldw	r2,-28(fp)
8113b794:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
8113b798:	e0bfff17 	ldw	r2,-4(fp)
8113b79c:	00c01e04 	movi	r3,120
8113b7a0:	10c00005 	stb	r3,0(r2)
8113b7a4:	00000606 	br	8113b7c0 <OSMutexAccept+0x178>
8113b7a8:	e0bff817 	ldw	r2,-32(fp)
8113b7ac:	e0bffb15 	stw	r2,-20(fp)
8113b7b0:	e0bffb17 	ldw	r2,-20(fp)
8113b7b4:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113b7b8:	e0bfff17 	ldw	r2,-4(fp)
8113b7bc:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
8113b7c0:	00800044 	movi	r2,1
8113b7c4:	00000706 	br	8113b7e4 <OSMutexAccept+0x19c>
8113b7c8:	e0bff817 	ldw	r2,-32(fp)
8113b7cc:	e0bffc15 	stw	r2,-16(fp)
8113b7d0:	e0bffc17 	ldw	r2,-16(fp)
8113b7d4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113b7d8:	e0bfff17 	ldw	r2,-4(fp)
8113b7dc:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
8113b7e0:	0005883a 	mov	r2,zero
}
8113b7e4:	e037883a 	mov	sp,fp
8113b7e8:	df000017 	ldw	fp,0(sp)
8113b7ec:	dec00104 	addi	sp,sp,4
8113b7f0:	f800283a 	ret

8113b7f4 <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
8113b7f4:	defff604 	addi	sp,sp,-40
8113b7f8:	de00012e 	bgeu	sp,et,8113b800 <OSMutexCreate+0xc>
8113b7fc:	003b68fa 	trap	3
8113b800:	dfc00915 	stw	ra,36(sp)
8113b804:	df000815 	stw	fp,32(sp)
8113b808:	df000804 	addi	fp,sp,32
8113b80c:	2005883a 	mov	r2,r4
8113b810:	e17fff15 	stw	r5,-4(fp)
8113b814:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113b818:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113b81c:	e0bfff17 	ldw	r2,-4(fp)
8113b820:	1000021e 	bne	r2,zero,8113b82c <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
8113b824:	0005883a 	mov	r2,zero
8113b828:	00006106 	br	8113b9b0 <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
8113b82c:	e0bffe03 	ldbu	r2,-8(fp)
8113b830:	10800ab0 	cmpltui	r2,r2,42
8113b834:	1000051e 	bne	r2,zero,8113b84c <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
8113b838:	e0bfff17 	ldw	r2,-4(fp)
8113b83c:	00c00a84 	movi	r3,42
8113b840:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113b844:	0005883a 	mov	r2,zero
8113b848:	00005906 	br	8113b9b0 <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113b84c:	d0a0a003 	ldbu	r2,-32128(gp)
8113b850:	10803fcc 	andi	r2,r2,255
8113b854:	10000526 	beq	r2,zero,8113b86c <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
8113b858:	e0bfff17 	ldw	r2,-4(fp)
8113b85c:	00c00404 	movi	r3,16
8113b860:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113b864:	0005883a 	mov	r2,zero
8113b868:	00005106 	br	8113b9b0 <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b86c:	0005303a 	rdctl	r2,status
8113b870:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b874:	e0fffd17 	ldw	r3,-12(fp)
8113b878:	00bfff84 	movi	r2,-2
8113b87c:	1884703a 	and	r2,r3,r2
8113b880:	1001703a 	wrctl	status,r2
  
  return context;
8113b884:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113b888:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
8113b88c:	e0fffe03 	ldbu	r3,-8(fp)
8113b890:	00a045f4 	movhi	r2,33047
8113b894:	10af6e04 	addi	r2,r2,-16968
8113b898:	18c7883a 	add	r3,r3,r3
8113b89c:	18c7883a 	add	r3,r3,r3
8113b8a0:	10c5883a 	add	r2,r2,r3
8113b8a4:	10800017 	ldw	r2,0(r2)
8113b8a8:	10000926 	beq	r2,zero,8113b8d0 <OSMutexCreate+0xdc>
8113b8ac:	e0bff817 	ldw	r2,-32(fp)
8113b8b0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b8b4:	e0bff917 	ldw	r2,-28(fp)
8113b8b8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
8113b8bc:	e0bfff17 	ldw	r2,-4(fp)
8113b8c0:	00c00a04 	movi	r3,40
8113b8c4:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113b8c8:	0005883a 	mov	r2,zero
8113b8cc:	00003806 	br	8113b9b0 <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
8113b8d0:	e0fffe03 	ldbu	r3,-8(fp)
8113b8d4:	00a045f4 	movhi	r2,33047
8113b8d8:	10af6e04 	addi	r2,r2,-16968
8113b8dc:	18c7883a 	add	r3,r3,r3
8113b8e0:	18c7883a 	add	r3,r3,r3
8113b8e4:	10c5883a 	add	r2,r2,r3
8113b8e8:	00c00044 	movi	r3,1
8113b8ec:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
8113b8f0:	d0a09f17 	ldw	r2,-32132(gp)
8113b8f4:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
8113b8f8:	e0bffb17 	ldw	r2,-20(fp)
8113b8fc:	1000101e 	bne	r2,zero,8113b940 <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
8113b900:	e0fffe03 	ldbu	r3,-8(fp)
8113b904:	00a045f4 	movhi	r2,33047
8113b908:	10af6e04 	addi	r2,r2,-16968
8113b90c:	18c7883a 	add	r3,r3,r3
8113b910:	18c7883a 	add	r3,r3,r3
8113b914:	10c5883a 	add	r2,r2,r3
8113b918:	10000015 	stw	zero,0(r2)
8113b91c:	e0bff817 	ldw	r2,-32(fp)
8113b920:	e0bffa15 	stw	r2,-24(fp)
8113b924:	e0bffa17 	ldw	r2,-24(fp)
8113b928:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
8113b92c:	e0bfff17 	ldw	r2,-4(fp)
8113b930:	00c00104 	movi	r3,4
8113b934:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113b938:	e0bffb17 	ldw	r2,-20(fp)
8113b93c:	00001c06 	br	8113b9b0 <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
8113b940:	d0a09f17 	ldw	r2,-32132(gp)
8113b944:	10800117 	ldw	r2,4(r2)
8113b948:	d0a09f15 	stw	r2,-32132(gp)
8113b94c:	e0bff817 	ldw	r2,-32(fp)
8113b950:	e0bffc15 	stw	r2,-16(fp)
8113b954:	e0bffc17 	ldw	r2,-16(fp)
8113b958:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
8113b95c:	e0bffb17 	ldw	r2,-20(fp)
8113b960:	00c00104 	movi	r3,4
8113b964:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
8113b968:	e0bffe03 	ldbu	r2,-8(fp)
8113b96c:	1004923a 	slli	r2,r2,8
8113b970:	10803fd4 	ori	r2,r2,255
8113b974:	1007883a 	mov	r3,r2
8113b978:	e0bffb17 	ldw	r2,-20(fp)
8113b97c:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
8113b980:	e0bffb17 	ldw	r2,-20(fp)
8113b984:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
8113b988:	e0bffb17 	ldw	r2,-20(fp)
8113b98c:	00c00fc4 	movi	r3,63
8113b990:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
8113b994:	e0bffb17 	ldw	r2,-20(fp)
8113b998:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
8113b99c:	e13ffb17 	ldw	r4,-20(fp)
8113b9a0:	11389400 	call	81138940 <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
8113b9a4:	e0bfff17 	ldw	r2,-4(fp)
8113b9a8:	10000005 	stb	zero,0(r2)
    return (pevent);
8113b9ac:	e0bffb17 	ldw	r2,-20(fp)
}
8113b9b0:	e037883a 	mov	sp,fp
8113b9b4:	dfc00117 	ldw	ra,4(sp)
8113b9b8:	df000017 	ldw	fp,0(sp)
8113b9bc:	dec00204 	addi	sp,sp,8
8113b9c0:	f800283a 	ret

8113b9c4 <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113b9c4:	defff004 	addi	sp,sp,-64
8113b9c8:	de00012e 	bgeu	sp,et,8113b9d0 <OSMutexDel+0xc>
8113b9cc:	003b68fa 	trap	3
8113b9d0:	dfc00f15 	stw	ra,60(sp)
8113b9d4:	df000e15 	stw	fp,56(sp)
8113b9d8:	df000e04 	addi	fp,sp,56
8113b9dc:	e13ffd15 	stw	r4,-12(fp)
8113b9e0:	2805883a 	mov	r2,r5
8113b9e4:	e1bfff15 	stw	r6,-4(fp)
8113b9e8:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113b9ec:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113b9f0:	e0bfff17 	ldw	r2,-4(fp)
8113b9f4:	1000021e 	bne	r2,zero,8113ba00 <OSMutexDel+0x3c>
        return (pevent);
8113b9f8:	e0bffd17 	ldw	r2,-12(fp)
8113b9fc:	0000ad06 	br	8113bcb4 <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113ba00:	e0bffd17 	ldw	r2,-12(fp)
8113ba04:	1000051e 	bne	r2,zero,8113ba1c <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113ba08:	e0bfff17 	ldw	r2,-4(fp)
8113ba0c:	00c00104 	movi	r3,4
8113ba10:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113ba14:	e0bffd17 	ldw	r2,-12(fp)
8113ba18:	0000a606 	br	8113bcb4 <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113ba1c:	e0bffd17 	ldw	r2,-12(fp)
8113ba20:	10800003 	ldbu	r2,0(r2)
8113ba24:	10803fcc 	andi	r2,r2,255
8113ba28:	10800120 	cmpeqi	r2,r2,4
8113ba2c:	1000051e 	bne	r2,zero,8113ba44 <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113ba30:	e0bfff17 	ldw	r2,-4(fp)
8113ba34:	00c00044 	movi	r3,1
8113ba38:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113ba3c:	e0bffd17 	ldw	r2,-12(fp)
8113ba40:	00009c06 	br	8113bcb4 <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113ba44:	d0a0a003 	ldbu	r2,-32128(gp)
8113ba48:	10803fcc 	andi	r2,r2,255
8113ba4c:	10000526 	beq	r2,zero,8113ba64 <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113ba50:	e0bfff17 	ldw	r2,-4(fp)
8113ba54:	00c003c4 	movi	r3,15
8113ba58:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113ba5c:	e0bffd17 	ldw	r2,-12(fp)
8113ba60:	00009406 	br	8113bcb4 <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ba64:	0005303a 	rdctl	r2,status
8113ba68:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ba6c:	e0fffc17 	ldw	r3,-16(fp)
8113ba70:	00bfff84 	movi	r2,-2
8113ba74:	1884703a 	and	r2,r3,r2
8113ba78:	1001703a 	wrctl	status,r2
  
  return context;
8113ba7c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113ba80:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
8113ba84:	e0bffd17 	ldw	r2,-12(fp)
8113ba88:	10800283 	ldbu	r2,10(r2)
8113ba8c:	10803fcc 	andi	r2,r2,255
8113ba90:	10000326 	beq	r2,zero,8113baa0 <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113ba94:	00800044 	movi	r2,1
8113ba98:	e0bff205 	stb	r2,-56(fp)
8113ba9c:	00000106 	br	8113baa4 <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113baa0:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
8113baa4:	e0bffe03 	ldbu	r2,-8(fp)
8113baa8:	10000326 	beq	r2,zero,8113bab8 <OSMutexDel+0xf4>
8113baac:	10800060 	cmpeqi	r2,r2,1
8113bab0:	10002f1e 	bne	r2,zero,8113bb70 <OSMutexDel+0x1ac>
8113bab4:	00007406 	br	8113bc88 <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
8113bab8:	e0bff203 	ldbu	r2,-56(fp)
8113babc:	1000221e 	bne	r2,zero,8113bb48 <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113bac0:	e0bffd17 	ldw	r2,-12(fp)
8113bac4:	00c00fc4 	movi	r3,63
8113bac8:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113bacc:	e0bffd17 	ldw	r2,-12(fp)
8113bad0:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113bad4:	e0bffd17 	ldw	r2,-12(fp)
8113bad8:	1080020b 	ldhu	r2,8(r2)
8113badc:	10bfffcc 	andi	r2,r2,65535
8113bae0:	1004d23a 	srli	r2,r2,8
8113bae4:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
8113bae8:	e0fff603 	ldbu	r3,-40(fp)
8113baec:	00a045f4 	movhi	r2,33047
8113baf0:	10af6e04 	addi	r2,r2,-16968
8113baf4:	18c7883a 	add	r3,r3,r3
8113baf8:	18c7883a 	add	r3,r3,r3
8113bafc:	10c5883a 	add	r2,r2,r3
8113bb00:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113bb04:	e0bffd17 	ldw	r2,-12(fp)
8113bb08:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
8113bb0c:	d0e09f17 	ldw	r3,-32132(gp)
8113bb10:	e0bffd17 	ldw	r2,-12(fp)
8113bb14:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
8113bb18:	e0bffd17 	ldw	r2,-12(fp)
8113bb1c:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
8113bb20:	e0bffd17 	ldw	r2,-12(fp)
8113bb24:	d0a09f15 	stw	r2,-32132(gp)
8113bb28:	e0bff417 	ldw	r2,-48(fp)
8113bb2c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bb30:	e0bff517 	ldw	r2,-44(fp)
8113bb34:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
8113bb38:	e0bfff17 	ldw	r2,-4(fp)
8113bb3c:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
8113bb40:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
8113bb44:	00005a06 	br	8113bcb0 <OSMutexDel+0x2ec>
8113bb48:	e0bff417 	ldw	r2,-48(fp)
8113bb4c:	e0bff715 	stw	r2,-36(fp)
8113bb50:	e0bff717 	ldw	r2,-36(fp)
8113bb54:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
8113bb58:	e0bfff17 	ldw	r2,-4(fp)
8113bb5c:	00c01244 	movi	r3,73
8113bb60:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
8113bb64:	e0bffd17 	ldw	r2,-12(fp)
8113bb68:	e0bff315 	stw	r2,-52(fp)
             }
             break;
8113bb6c:	00005006 	br	8113bcb0 <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
8113bb70:	e0bffd17 	ldw	r2,-12(fp)
8113bb74:	1080020b 	ldhu	r2,8(r2)
8113bb78:	10bfffcc 	andi	r2,r2,65535
8113bb7c:	1004d23a 	srli	r2,r2,8
8113bb80:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
8113bb84:	e0bffd17 	ldw	r2,-12(fp)
8113bb88:	1080020b 	ldhu	r2,8(r2)
8113bb8c:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
8113bb90:	e0bffd17 	ldw	r2,-12(fp)
8113bb94:	10800117 	ldw	r2,4(r2)
8113bb98:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
8113bb9c:	e0bffa17 	ldw	r2,-24(fp)
8113bba0:	10000f26 	beq	r2,zero,8113bbe0 <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
8113bba4:	e0bffa17 	ldw	r2,-24(fp)
8113bba8:	10800c83 	ldbu	r2,50(r2)
8113bbac:	10c03fcc 	andi	r3,r2,255
8113bbb0:	e0bff603 	ldbu	r2,-40(fp)
8113bbb4:	18800a1e 	bne	r3,r2,8113bbe0 <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
8113bbb8:	e0bff903 	ldbu	r2,-28(fp)
8113bbbc:	100b883a 	mov	r5,r2
8113bbc0:	e13ffa17 	ldw	r4,-24(fp)
8113bbc4:	113c6000 	call	8113c600 <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113bbc8:	00000506 	br	8113bbe0 <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113bbcc:	000f883a 	mov	r7,zero
8113bbd0:	01800404 	movi	r6,16
8113bbd4:	000b883a 	mov	r5,zero
8113bbd8:	e13ffd17 	ldw	r4,-12(fp)
8113bbdc:	11383680 	call	81138368 <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113bbe0:	e0bffd17 	ldw	r2,-12(fp)
8113bbe4:	10800283 	ldbu	r2,10(r2)
8113bbe8:	10803fcc 	andi	r2,r2,255
8113bbec:	103ff71e 	bne	r2,zero,8113bbcc <__reset+0xfb11bbcc>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113bbf0:	e0bffd17 	ldw	r2,-12(fp)
8113bbf4:	00c00fc4 	movi	r3,63
8113bbf8:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113bbfc:	e0bffd17 	ldw	r2,-12(fp)
8113bc00:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113bc04:	e0bffd17 	ldw	r2,-12(fp)
8113bc08:	1080020b 	ldhu	r2,8(r2)
8113bc0c:	10bfffcc 	andi	r2,r2,65535
8113bc10:	1004d23a 	srli	r2,r2,8
8113bc14:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
8113bc18:	e0fff603 	ldbu	r3,-40(fp)
8113bc1c:	00a045f4 	movhi	r2,33047
8113bc20:	10af6e04 	addi	r2,r2,-16968
8113bc24:	18c7883a 	add	r3,r3,r3
8113bc28:	18c7883a 	add	r3,r3,r3
8113bc2c:	10c5883a 	add	r2,r2,r3
8113bc30:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113bc34:	e0bffd17 	ldw	r2,-12(fp)
8113bc38:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
8113bc3c:	d0e09f17 	ldw	r3,-32132(gp)
8113bc40:	e0bffd17 	ldw	r2,-12(fp)
8113bc44:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
8113bc48:	e0bffd17 	ldw	r2,-12(fp)
8113bc4c:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
8113bc50:	e0bffd17 	ldw	r2,-12(fp)
8113bc54:	d0a09f15 	stw	r2,-32132(gp)
8113bc58:	e0bff417 	ldw	r2,-48(fp)
8113bc5c:	e0bff815 	stw	r2,-32(fp)
8113bc60:	e0bff817 	ldw	r2,-32(fp)
8113bc64:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113bc68:	e0bff203 	ldbu	r2,-56(fp)
8113bc6c:	10800058 	cmpnei	r2,r2,1
8113bc70:	1000011e 	bne	r2,zero,8113bc78 <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113bc74:	1138e240 	call	81138e24 <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
8113bc78:	e0bfff17 	ldw	r2,-4(fp)
8113bc7c:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
8113bc80:	e03ff315 	stw	zero,-52(fp)
             break;
8113bc84:	00000a06 	br	8113bcb0 <OSMutexDel+0x2ec>
8113bc88:	e0bff417 	ldw	r2,-48(fp)
8113bc8c:	e0bffb15 	stw	r2,-20(fp)
8113bc90:	e0bffb17 	ldw	r2,-20(fp)
8113bc94:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
8113bc98:	e0bfff17 	ldw	r2,-4(fp)
8113bc9c:	00c001c4 	movi	r3,7
8113bca0:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
8113bca4:	e0bffd17 	ldw	r2,-12(fp)
8113bca8:	e0bff315 	stw	r2,-52(fp)
             break;
8113bcac:	0001883a 	nop
    }
    return (pevent_return);
8113bcb0:	e0bff317 	ldw	r2,-52(fp)
}
8113bcb4:	e037883a 	mov	sp,fp
8113bcb8:	dfc00117 	ldw	ra,4(sp)
8113bcbc:	df000017 	ldw	fp,0(sp)
8113bcc0:	dec00204 	addi	sp,sp,8
8113bcc4:	f800283a 	ret

8113bcc8 <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113bcc8:	deffee04 	addi	sp,sp,-72
8113bccc:	de00012e 	bgeu	sp,et,8113bcd4 <OSMutexPend+0xc>
8113bcd0:	003b68fa 	trap	3
8113bcd4:	dfc01115 	stw	ra,68(sp)
8113bcd8:	df001015 	stw	fp,64(sp)
8113bcdc:	df001004 	addi	fp,sp,64
8113bce0:	e13ffd15 	stw	r4,-12(fp)
8113bce4:	2805883a 	mov	r2,r5
8113bce8:	e1bfff15 	stw	r6,-4(fp)
8113bcec:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113bcf0:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113bcf4:	e0bfff17 	ldw	r2,-4(fp)
8113bcf8:	10015626 	beq	r2,zero,8113c254 <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113bcfc:	e0bffd17 	ldw	r2,-12(fp)
8113bd00:	1000041e 	bne	r2,zero,8113bd14 <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113bd04:	e0bfff17 	ldw	r2,-4(fp)
8113bd08:	00c00104 	movi	r3,4
8113bd0c:	10c00005 	stb	r3,0(r2)
        return;
8113bd10:	00015106 	br	8113c258 <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113bd14:	e0bffd17 	ldw	r2,-12(fp)
8113bd18:	10800003 	ldbu	r2,0(r2)
8113bd1c:	10803fcc 	andi	r2,r2,255
8113bd20:	10800120 	cmpeqi	r2,r2,4
8113bd24:	1000041e 	bne	r2,zero,8113bd38 <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113bd28:	e0bfff17 	ldw	r2,-4(fp)
8113bd2c:	00c00044 	movi	r3,1
8113bd30:	10c00005 	stb	r3,0(r2)
        return;
8113bd34:	00014806 	br	8113c258 <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113bd38:	d0a0a003 	ldbu	r2,-32128(gp)
8113bd3c:	10803fcc 	andi	r2,r2,255
8113bd40:	10000426 	beq	r2,zero,8113bd54 <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113bd44:	e0bfff17 	ldw	r2,-4(fp)
8113bd48:	00c00084 	movi	r3,2
8113bd4c:	10c00005 	stb	r3,0(r2)
        return;
8113bd50:	00014106 	br	8113c258 <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113bd54:	d0a08e03 	ldbu	r2,-32200(gp)
8113bd58:	10803fcc 	andi	r2,r2,255
8113bd5c:	10000426 	beq	r2,zero,8113bd70 <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113bd60:	e0bfff17 	ldw	r2,-4(fp)
8113bd64:	00c00344 	movi	r3,13
8113bd68:	10c00005 	stb	r3,0(r2)
        return;
8113bd6c:	00013a06 	br	8113c258 <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bd70:	0005303a 	rdctl	r2,status
8113bd74:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bd78:	e0fffc17 	ldw	r3,-16(fp)
8113bd7c:	00bfff84 	movi	r2,-2
8113bd80:	1884703a 	and	r2,r3,r2
8113bd84:	1001703a 	wrctl	status,r2
  
  return context;
8113bd88:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113bd8c:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
8113bd90:	e0bffd17 	ldw	r2,-12(fp)
8113bd94:	1080020b 	ldhu	r2,8(r2)
8113bd98:	10bfffcc 	andi	r2,r2,65535
8113bd9c:	1004d23a 	srli	r2,r2,8
8113bda0:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113bda4:	e0bffd17 	ldw	r2,-12(fp)
8113bda8:	1080020b 	ldhu	r2,8(r2)
8113bdac:	10803fcc 	andi	r2,r2,255
8113bdb0:	10803fd8 	cmpnei	r2,r2,255
8113bdb4:	1000271e 	bne	r2,zero,8113be54 <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
8113bdb8:	e0bffd17 	ldw	r2,-12(fp)
8113bdbc:	10c0020b 	ldhu	r3,8(r2)
8113bdc0:	00bfc004 	movi	r2,-256
8113bdc4:	1884703a 	and	r2,r3,r2
8113bdc8:	1007883a 	mov	r3,r2
8113bdcc:	e0bffd17 	ldw	r2,-12(fp)
8113bdd0:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
8113bdd4:	e0bffd17 	ldw	r2,-12(fp)
8113bdd8:	10c0020b 	ldhu	r3,8(r2)
8113bddc:	d0a0a117 	ldw	r2,-32124(gp)
8113bde0:	10800c83 	ldbu	r2,50(r2)
8113bde4:	10803fcc 	andi	r2,r2,255
8113bde8:	1884b03a 	or	r2,r3,r2
8113bdec:	1007883a 	mov	r3,r2
8113bdf0:	e0bffd17 	ldw	r2,-12(fp)
8113bdf4:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
8113bdf8:	d0e0a117 	ldw	r3,-32124(gp)
8113bdfc:	e0bffd17 	ldw	r2,-12(fp)
8113be00:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
8113be04:	d0a0a117 	ldw	r2,-32124(gp)
8113be08:	10800c83 	ldbu	r2,50(r2)
8113be0c:	10803fcc 	andi	r2,r2,255
8113be10:	e0fff303 	ldbu	r3,-52(fp)
8113be14:	18800836 	bltu	r3,r2,8113be38 <OSMutexPend+0x170>
8113be18:	e0bff117 	ldw	r2,-60(fp)
8113be1c:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113be20:	e0bff217 	ldw	r2,-56(fp)
8113be24:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
8113be28:	e0bfff17 	ldw	r2,-4(fp)
8113be2c:	00c01e04 	movi	r3,120
8113be30:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
8113be34:	00010806 	br	8113c258 <OSMutexPend+0x590>
8113be38:	e0bff117 	ldw	r2,-60(fp)
8113be3c:	e0bff415 	stw	r2,-48(fp)
8113be40:	e0bff417 	ldw	r2,-48(fp)
8113be44:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113be48:	e0bfff17 	ldw	r2,-4(fp)
8113be4c:	10000005 	stb	zero,0(r2)
        }
        return;
8113be50:	00010106 	br	8113c258 <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
8113be54:	e0bffd17 	ldw	r2,-12(fp)
8113be58:	1080020b 	ldhu	r2,8(r2)
8113be5c:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
8113be60:	e0bffd17 	ldw	r2,-12(fp)
8113be64:	10800117 	ldw	r2,4(r2)
8113be68:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
8113be6c:	e0bff717 	ldw	r2,-36(fp)
8113be70:	10800c83 	ldbu	r2,50(r2)
8113be74:	10803fcc 	andi	r2,r2,255
8113be78:	e0fff303 	ldbu	r3,-52(fp)
8113be7c:	1880b92e 	bgeu	r3,r2,8113c164 <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
8113be80:	d0a0a117 	ldw	r2,-32124(gp)
8113be84:	10800c83 	ldbu	r2,50(r2)
8113be88:	10c03fcc 	andi	r3,r2,255
8113be8c:	e0bff603 	ldbu	r2,-40(fp)
8113be90:	1880b42e 	bgeu	r3,r2,8113c164 <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
8113be94:	e0bff717 	ldw	r2,-36(fp)
8113be98:	10800d03 	ldbu	r2,52(r2)
8113be9c:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
8113bea0:	e0fff803 	ldbu	r3,-32(fp)
8113bea4:	d0a09d44 	addi	r2,gp,-32139
8113bea8:	1885883a 	add	r2,r3,r2
8113beac:	10c00003 	ldbu	r3,0(r2)
8113beb0:	e0bff717 	ldw	r2,-36(fp)
8113beb4:	10800d43 	ldbu	r2,53(r2)
8113beb8:	1884703a 	and	r2,r3,r2
8113bebc:	10803fcc 	andi	r2,r2,255
8113bec0:	10001e26 	beq	r2,zero,8113bf3c <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
8113bec4:	e0fff803 	ldbu	r3,-32(fp)
8113bec8:	e13ff803 	ldbu	r4,-32(fp)
8113becc:	d0a09d44 	addi	r2,gp,-32139
8113bed0:	2085883a 	add	r2,r4,r2
8113bed4:	10800003 	ldbu	r2,0(r2)
8113bed8:	1009883a 	mov	r4,r2
8113bedc:	e0bff717 	ldw	r2,-36(fp)
8113bee0:	10800d43 	ldbu	r2,53(r2)
8113bee4:	0084303a 	nor	r2,zero,r2
8113bee8:	2084703a 	and	r2,r4,r2
8113beec:	1009883a 	mov	r4,r2
8113bef0:	d0a09d44 	addi	r2,gp,-32139
8113bef4:	1885883a 	add	r2,r3,r2
8113bef8:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
8113befc:	e0fff803 	ldbu	r3,-32(fp)
8113bf00:	d0a09d44 	addi	r2,gp,-32139
8113bf04:	1885883a 	add	r2,r3,r2
8113bf08:	10800003 	ldbu	r2,0(r2)
8113bf0c:	10803fcc 	andi	r2,r2,255
8113bf10:	1000071e 	bne	r2,zero,8113bf30 <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
8113bf14:	e0bff717 	ldw	r2,-36(fp)
8113bf18:	10800d83 	ldbu	r2,54(r2)
8113bf1c:	0084303a 	nor	r2,zero,r2
8113bf20:	1007883a 	mov	r3,r2
8113bf24:	d0a09d03 	ldbu	r2,-32140(gp)
8113bf28:	1884703a 	and	r2,r3,r2
8113bf2c:	d0a09d05 	stb	r2,-32140(gp)
                }
                rdy = OS_TRUE;
8113bf30:	00800044 	movi	r2,1
8113bf34:	e0bff005 	stb	r2,-64(fp)
8113bf38:	00002a06 	br	8113bfe4 <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113bf3c:	e0bff717 	ldw	r2,-36(fp)
8113bf40:	10800717 	ldw	r2,28(r2)
8113bf44:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
8113bf48:	e0bff917 	ldw	r2,-28(fp)
8113bf4c:	10002426 	beq	r2,zero,8113bfe0 <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
8113bf50:	e0bff717 	ldw	r2,-36(fp)
8113bf54:	10800d03 	ldbu	r2,52(r2)
8113bf58:	10803fcc 	andi	r2,r2,255
8113bf5c:	e0fff717 	ldw	r3,-36(fp)
8113bf60:	18c00d03 	ldbu	r3,52(r3)
8113bf64:	18c03fcc 	andi	r3,r3,255
8113bf68:	e13ff917 	ldw	r4,-28(fp)
8113bf6c:	20c7883a 	add	r3,r4,r3
8113bf70:	18c002c4 	addi	r3,r3,11
8113bf74:	18c00003 	ldbu	r3,0(r3)
8113bf78:	1809883a 	mov	r4,r3
8113bf7c:	e0fff717 	ldw	r3,-36(fp)
8113bf80:	18c00d43 	ldbu	r3,53(r3)
8113bf84:	00c6303a 	nor	r3,zero,r3
8113bf88:	20c6703a 	and	r3,r4,r3
8113bf8c:	1809883a 	mov	r4,r3
8113bf90:	e0fff917 	ldw	r3,-28(fp)
8113bf94:	1887883a 	add	r3,r3,r2
8113bf98:	18c002c4 	addi	r3,r3,11
8113bf9c:	19000005 	stb	r4,0(r3)
8113bfa0:	e0fff917 	ldw	r3,-28(fp)
8113bfa4:	1885883a 	add	r2,r3,r2
8113bfa8:	108002c4 	addi	r2,r2,11
8113bfac:	10800003 	ldbu	r2,0(r2)
8113bfb0:	10803fcc 	andi	r2,r2,255
8113bfb4:	10000a1e 	bne	r2,zero,8113bfe0 <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
8113bfb8:	e0bff917 	ldw	r2,-28(fp)
8113bfbc:	10800283 	ldbu	r2,10(r2)
8113bfc0:	1007883a 	mov	r3,r2
8113bfc4:	e0bff717 	ldw	r2,-36(fp)
8113bfc8:	10800d83 	ldbu	r2,54(r2)
8113bfcc:	0084303a 	nor	r2,zero,r2
8113bfd0:	1884703a 	and	r2,r3,r2
8113bfd4:	1007883a 	mov	r3,r2
8113bfd8:	e0bff917 	ldw	r2,-28(fp)
8113bfdc:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
8113bfe0:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
8113bfe4:	e0bff717 	ldw	r2,-36(fp)
8113bfe8:	e0fff303 	ldbu	r3,-52(fp)
8113bfec:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
8113bff0:	e0bff717 	ldw	r2,-36(fp)
8113bff4:	10800c83 	ldbu	r2,50(r2)
8113bff8:	10803fcc 	andi	r2,r2,255
8113bffc:	1004d0fa 	srli	r2,r2,3
8113c000:	1007883a 	mov	r3,r2
8113c004:	e0bff717 	ldw	r2,-36(fp)
8113c008:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
8113c00c:	e0bff717 	ldw	r2,-36(fp)
8113c010:	10800c83 	ldbu	r2,50(r2)
8113c014:	108001cc 	andi	r2,r2,7
8113c018:	1007883a 	mov	r3,r2
8113c01c:	e0bff717 	ldw	r2,-36(fp)
8113c020:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
8113c024:	e0bff717 	ldw	r2,-36(fp)
8113c028:	10800d03 	ldbu	r2,52(r2)
8113c02c:	10803fcc 	andi	r2,r2,255
8113c030:	00c00044 	movi	r3,1
8113c034:	1884983a 	sll	r2,r3,r2
8113c038:	1007883a 	mov	r3,r2
8113c03c:	e0bff717 	ldw	r2,-36(fp)
8113c040:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
8113c044:	e0bff717 	ldw	r2,-36(fp)
8113c048:	10800cc3 	ldbu	r2,51(r2)
8113c04c:	10803fcc 	andi	r2,r2,255
8113c050:	00c00044 	movi	r3,1
8113c054:	1884983a 	sll	r2,r3,r2
8113c058:	1007883a 	mov	r3,r2
8113c05c:	e0bff717 	ldw	r2,-36(fp)
8113c060:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
8113c064:	e0bff003 	ldbu	r2,-64(fp)
8113c068:	10800058 	cmpnei	r2,r2,1
8113c06c:	1000161e 	bne	r2,zero,8113c0c8 <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
8113c070:	e0bff717 	ldw	r2,-36(fp)
8113c074:	10c00d83 	ldbu	r3,54(r2)
8113c078:	d0a09d03 	ldbu	r2,-32140(gp)
8113c07c:	1884b03a 	or	r2,r3,r2
8113c080:	d0a09d05 	stb	r2,-32140(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113c084:	e0bff717 	ldw	r2,-36(fp)
8113c088:	10800d03 	ldbu	r2,52(r2)
8113c08c:	10c03fcc 	andi	r3,r2,255
8113c090:	e0bff717 	ldw	r2,-36(fp)
8113c094:	10800d03 	ldbu	r2,52(r2)
8113c098:	11003fcc 	andi	r4,r2,255
8113c09c:	d0a09d44 	addi	r2,gp,-32139
8113c0a0:	2085883a 	add	r2,r4,r2
8113c0a4:	11000003 	ldbu	r4,0(r2)
8113c0a8:	e0bff717 	ldw	r2,-36(fp)
8113c0ac:	10800d43 	ldbu	r2,53(r2)
8113c0b0:	2084b03a 	or	r2,r4,r2
8113c0b4:	1009883a 	mov	r4,r2
8113c0b8:	d0a09d44 	addi	r2,gp,-32139
8113c0bc:	1885883a 	add	r2,r3,r2
8113c0c0:	11000005 	stb	r4,0(r2)
8113c0c4:	00001f06 	br	8113c144 <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113c0c8:	e0bff717 	ldw	r2,-36(fp)
8113c0cc:	10800717 	ldw	r2,28(r2)
8113c0d0:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
8113c0d4:	e0bff917 	ldw	r2,-28(fp)
8113c0d8:	10001a26 	beq	r2,zero,8113c144 <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
8113c0dc:	e0bff917 	ldw	r2,-28(fp)
8113c0e0:	10c00283 	ldbu	r3,10(r2)
8113c0e4:	e0bff717 	ldw	r2,-36(fp)
8113c0e8:	10800d83 	ldbu	r2,54(r2)
8113c0ec:	1884b03a 	or	r2,r3,r2
8113c0f0:	1007883a 	mov	r3,r2
8113c0f4:	e0bff917 	ldw	r2,-28(fp)
8113c0f8:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113c0fc:	e0bff717 	ldw	r2,-36(fp)
8113c100:	10800d03 	ldbu	r2,52(r2)
8113c104:	10803fcc 	andi	r2,r2,255
8113c108:	e0fff717 	ldw	r3,-36(fp)
8113c10c:	18c00d03 	ldbu	r3,52(r3)
8113c110:	18c03fcc 	andi	r3,r3,255
8113c114:	e13ff917 	ldw	r4,-28(fp)
8113c118:	20c7883a 	add	r3,r4,r3
8113c11c:	18c002c4 	addi	r3,r3,11
8113c120:	19000003 	ldbu	r4,0(r3)
8113c124:	e0fff717 	ldw	r3,-36(fp)
8113c128:	18c00d43 	ldbu	r3,53(r3)
8113c12c:	20c6b03a 	or	r3,r4,r3
8113c130:	1809883a 	mov	r4,r3
8113c134:	e0fff917 	ldw	r3,-28(fp)
8113c138:	1885883a 	add	r2,r3,r2
8113c13c:	108002c4 	addi	r2,r2,11
8113c140:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
8113c144:	e0fff303 	ldbu	r3,-52(fp)
8113c148:	00a045f4 	movhi	r2,33047
8113c14c:	10af6e04 	addi	r2,r2,-16968
8113c150:	18c7883a 	add	r3,r3,r3
8113c154:	18c7883a 	add	r3,r3,r3
8113c158:	10c5883a 	add	r2,r2,r3
8113c15c:	e0fff717 	ldw	r3,-36(fp)
8113c160:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
8113c164:	d0a0a117 	ldw	r2,-32124(gp)
8113c168:	d0e0a117 	ldw	r3,-32124(gp)
8113c16c:	18c00c03 	ldbu	r3,48(r3)
8113c170:	18c00414 	ori	r3,r3,16
8113c174:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113c178:	d0a0a117 	ldw	r2,-32124(gp)
8113c17c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
8113c180:	d0a0a117 	ldw	r2,-32124(gp)
8113c184:	e0fffe0b 	ldhu	r3,-8(fp)
8113c188:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113c18c:	e13ffd17 	ldw	r4,-12(fp)
8113c190:	11385080 	call	81138508 <OS_EventTaskWait>
8113c194:	e0bff117 	ldw	r2,-60(fp)
8113c198:	e0bffb15 	stw	r2,-20(fp)
8113c19c:	e0bffb17 	ldw	r2,-20(fp)
8113c1a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113c1a4:	1138e240 	call	81138e24 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c1a8:	0005303a 	rdctl	r2,status
8113c1ac:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c1b0:	e0fff517 	ldw	r3,-44(fp)
8113c1b4:	00bfff84 	movi	r2,-2
8113c1b8:	1884703a 	and	r2,r3,r2
8113c1bc:	1001703a 	wrctl	status,r2
  
  return context;
8113c1c0:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
8113c1c4:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113c1c8:	d0a0a117 	ldw	r2,-32124(gp)
8113c1cc:	10800c43 	ldbu	r2,49(r2)
8113c1d0:	10803fcc 	andi	r2,r2,255
8113c1d4:	10000326 	beq	r2,zero,8113c1e4 <OSMutexPend+0x51c>
8113c1d8:	108000a0 	cmpeqi	r2,r2,2
8113c1dc:	1000041e 	bne	r2,zero,8113c1f0 <OSMutexPend+0x528>
8113c1e0:	00000706 	br	8113c200 <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113c1e4:	e0bfff17 	ldw	r2,-4(fp)
8113c1e8:	10000005 	stb	zero,0(r2)
             break;
8113c1ec:	00000c06 	br	8113c220 <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
8113c1f0:	e0bfff17 	ldw	r2,-4(fp)
8113c1f4:	00c00384 	movi	r3,14
8113c1f8:	10c00005 	stb	r3,0(r2)
             break;
8113c1fc:	00000806 	br	8113c220 <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113c200:	d0a0a117 	ldw	r2,-32124(gp)
8113c204:	e17ffd17 	ldw	r5,-12(fp)
8113c208:	1009883a 	mov	r4,r2
8113c20c:	11387780 	call	81138778 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
8113c210:	e0bfff17 	ldw	r2,-4(fp)
8113c214:	00c00284 	movi	r3,10
8113c218:	10c00005 	stb	r3,0(r2)
             break;
8113c21c:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113c220:	d0a0a117 	ldw	r2,-32124(gp)
8113c224:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113c228:	d0a0a117 	ldw	r2,-32124(gp)
8113c22c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113c230:	d0a0a117 	ldw	r2,-32124(gp)
8113c234:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113c238:	d0a0a117 	ldw	r2,-32124(gp)
8113c23c:	10000815 	stw	zero,32(r2)
8113c240:	e0bff117 	ldw	r2,-60(fp)
8113c244:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c248:	e0bffa17 	ldw	r2,-24(fp)
8113c24c:	1001703a 	wrctl	status,r2
8113c250:	00000106 	br	8113c258 <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
8113c254:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113c258:	e037883a 	mov	sp,fp
8113c25c:	dfc00117 	ldw	ra,4(sp)
8113c260:	df000017 	ldw	fp,0(sp)
8113c264:	dec00204 	addi	sp,sp,8
8113c268:	f800283a 	ret

8113c26c <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
8113c26c:	defff604 	addi	sp,sp,-40
8113c270:	de00012e 	bgeu	sp,et,8113c278 <OSMutexPost+0xc>
8113c274:	003b68fa 	trap	3
8113c278:	dfc00915 	stw	ra,36(sp)
8113c27c:	df000815 	stw	fp,32(sp)
8113c280:	df000804 	addi	fp,sp,32
8113c284:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113c288:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113c28c:	d0a0a003 	ldbu	r2,-32128(gp)
8113c290:	10803fcc 	andi	r2,r2,255
8113c294:	10000226 	beq	r2,zero,8113c2a0 <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
8113c298:	00800144 	movi	r2,5
8113c29c:	00007606 	br	8113c478 <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113c2a0:	e0bfff17 	ldw	r2,-4(fp)
8113c2a4:	1000021e 	bne	r2,zero,8113c2b0 <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
8113c2a8:	00800104 	movi	r2,4
8113c2ac:	00007206 	br	8113c478 <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
8113c2b0:	e0bfff17 	ldw	r2,-4(fp)
8113c2b4:	10800003 	ldbu	r2,0(r2)
8113c2b8:	10803fcc 	andi	r2,r2,255
8113c2bc:	10800120 	cmpeqi	r2,r2,4
8113c2c0:	1000021e 	bne	r2,zero,8113c2cc <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
8113c2c4:	00800044 	movi	r2,1
8113c2c8:	00006b06 	br	8113c478 <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c2cc:	0005303a 	rdctl	r2,status
8113c2d0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c2d4:	e0fffe17 	ldw	r3,-8(fp)
8113c2d8:	00bfff84 	movi	r2,-2
8113c2dc:	1884703a 	and	r2,r3,r2
8113c2e0:	1001703a 	wrctl	status,r2
  
  return context;
8113c2e4:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113c2e8:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
8113c2ec:	e0bfff17 	ldw	r2,-4(fp)
8113c2f0:	1080020b 	ldhu	r2,8(r2)
8113c2f4:	10bfffcc 	andi	r2,r2,65535
8113c2f8:	1004d23a 	srli	r2,r2,8
8113c2fc:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
8113c300:	e0bfff17 	ldw	r2,-4(fp)
8113c304:	1080020b 	ldhu	r2,8(r2)
8113c308:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
8113c30c:	e0bfff17 	ldw	r2,-4(fp)
8113c310:	10c00117 	ldw	r3,4(r2)
8113c314:	d0a0a117 	ldw	r2,-32124(gp)
8113c318:	18800626 	beq	r3,r2,8113c334 <OSMutexPost+0xc8>
8113c31c:	e0bff817 	ldw	r2,-32(fp)
8113c320:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c324:	e0bff917 	ldw	r2,-28(fp)
8113c328:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
8113c32c:	00801904 	movi	r2,100
8113c330:	00005106 	br	8113c478 <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
8113c334:	d0a0a117 	ldw	r2,-32124(gp)
8113c338:	10800c83 	ldbu	r2,50(r2)
8113c33c:	10c03fcc 	andi	r3,r2,255
8113c340:	e0bffa03 	ldbu	r2,-24(fp)
8113c344:	1880051e 	bne	r3,r2,8113c35c <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
8113c348:	d0a0a117 	ldw	r2,-32124(gp)
8113c34c:	e0fffa43 	ldbu	r3,-23(fp)
8113c350:	180b883a 	mov	r5,r3
8113c354:	1009883a 	mov	r4,r2
8113c358:	113c6000 	call	8113c600 <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
8113c35c:	e0fffa03 	ldbu	r3,-24(fp)
8113c360:	00a045f4 	movhi	r2,33047
8113c364:	10af6e04 	addi	r2,r2,-16968
8113c368:	18c7883a 	add	r3,r3,r3
8113c36c:	18c7883a 	add	r3,r3,r3
8113c370:	10c5883a 	add	r2,r2,r3
8113c374:	00c00044 	movi	r3,1
8113c378:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
8113c37c:	e0bfff17 	ldw	r2,-4(fp)
8113c380:	10800283 	ldbu	r2,10(r2)
8113c384:	10803fcc 	andi	r2,r2,255
8113c388:	10002e26 	beq	r2,zero,8113c444 <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113c38c:	000f883a 	mov	r7,zero
8113c390:	01800404 	movi	r6,16
8113c394:	000b883a 	mov	r5,zero
8113c398:	e13fff17 	ldw	r4,-4(fp)
8113c39c:	11383680 	call	81138368 <OS_EventTaskRdy>
8113c3a0:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
8113c3a4:	e0bfff17 	ldw	r2,-4(fp)
8113c3a8:	10c0020b 	ldhu	r3,8(r2)
8113c3ac:	00bfc004 	movi	r2,-256
8113c3b0:	1884703a 	and	r2,r3,r2
8113c3b4:	1007883a 	mov	r3,r2
8113c3b8:	e0bfff17 	ldw	r2,-4(fp)
8113c3bc:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
8113c3c0:	e0bfff17 	ldw	r2,-4(fp)
8113c3c4:	10c0020b 	ldhu	r3,8(r2)
8113c3c8:	e0bffa43 	ldbu	r2,-23(fp)
8113c3cc:	1884b03a 	or	r2,r3,r2
8113c3d0:	1007883a 	mov	r3,r2
8113c3d4:	e0bfff17 	ldw	r2,-4(fp)
8113c3d8:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
8113c3dc:	e0fffa43 	ldbu	r3,-23(fp)
8113c3e0:	00a045f4 	movhi	r2,33047
8113c3e4:	10af6e04 	addi	r2,r2,-16968
8113c3e8:	18c7883a 	add	r3,r3,r3
8113c3ec:	18c7883a 	add	r3,r3,r3
8113c3f0:	10c5883a 	add	r2,r2,r3
8113c3f4:	10c00017 	ldw	r3,0(r2)
8113c3f8:	e0bfff17 	ldw	r2,-4(fp)
8113c3fc:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
8113c400:	e0bffa43 	ldbu	r2,-23(fp)
8113c404:	e0fffa03 	ldbu	r3,-24(fp)
8113c408:	18800736 	bltu	r3,r2,8113c428 <OSMutexPost+0x1bc>
8113c40c:	e0bff817 	ldw	r2,-32(fp)
8113c410:	e0bffb15 	stw	r2,-20(fp)
8113c414:	e0bffb17 	ldw	r2,-20(fp)
8113c418:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113c41c:	1138e240 	call	81138e24 <OS_Sched>
            return (OS_ERR_PIP_LOWER);
8113c420:	00801e04 	movi	r2,120
8113c424:	00001406 	br	8113c478 <OSMutexPost+0x20c>
8113c428:	e0bff817 	ldw	r2,-32(fp)
8113c42c:	e0bffc15 	stw	r2,-16(fp)
8113c430:	e0bffc17 	ldw	r2,-16(fp)
8113c434:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113c438:	1138e240 	call	81138e24 <OS_Sched>
            return (OS_ERR_NONE);
8113c43c:	0005883a 	mov	r2,zero
8113c440:	00000d06 	br	8113c478 <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
8113c444:	e0bfff17 	ldw	r2,-4(fp)
8113c448:	1080020b 	ldhu	r2,8(r2)
8113c44c:	10803fd4 	ori	r2,r2,255
8113c450:	1007883a 	mov	r3,r2
8113c454:	e0bfff17 	ldw	r2,-4(fp)
8113c458:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
8113c45c:	e0bfff17 	ldw	r2,-4(fp)
8113c460:	10000115 	stw	zero,4(r2)
8113c464:	e0bff817 	ldw	r2,-32(fp)
8113c468:	e0bffd15 	stw	r2,-12(fp)
8113c46c:	e0bffd17 	ldw	r2,-12(fp)
8113c470:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113c474:	0005883a 	mov	r2,zero
}
8113c478:	e037883a 	mov	sp,fp
8113c47c:	dfc00117 	ldw	ra,4(sp)
8113c480:	df000017 	ldw	fp,0(sp)
8113c484:	dec00204 	addi	sp,sp,8
8113c488:	f800283a 	ret

8113c48c <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
8113c48c:	defff704 	addi	sp,sp,-36
8113c490:	de00012e 	bgeu	sp,et,8113c498 <OSMutexQuery+0xc>
8113c494:	003b68fa 	trap	3
8113c498:	df000815 	stw	fp,32(sp)
8113c49c:	df000804 	addi	fp,sp,32
8113c4a0:	e13ffe15 	stw	r4,-8(fp)
8113c4a4:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113c4a8:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113c4ac:	d0a0a003 	ldbu	r2,-32128(gp)
8113c4b0:	10803fcc 	andi	r2,r2,255
8113c4b4:	10000226 	beq	r2,zero,8113c4c0 <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
8113c4b8:	00800184 	movi	r2,6
8113c4bc:	00004c06 	br	8113c5f0 <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113c4c0:	e0bffe17 	ldw	r2,-8(fp)
8113c4c4:	1000021e 	bne	r2,zero,8113c4d0 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
8113c4c8:	00800104 	movi	r2,4
8113c4cc:	00004806 	br	8113c5f0 <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
8113c4d0:	e0bfff17 	ldw	r2,-4(fp)
8113c4d4:	1000021e 	bne	r2,zero,8113c4e0 <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
8113c4d8:	00800244 	movi	r2,9
8113c4dc:	00004406 	br	8113c5f0 <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113c4e0:	e0bffe17 	ldw	r2,-8(fp)
8113c4e4:	10800003 	ldbu	r2,0(r2)
8113c4e8:	10803fcc 	andi	r2,r2,255
8113c4ec:	10800120 	cmpeqi	r2,r2,4
8113c4f0:	1000021e 	bne	r2,zero,8113c4fc <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
8113c4f4:	00800044 	movi	r2,1
8113c4f8:	00003d06 	br	8113c5f0 <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c4fc:	0005303a 	rdctl	r2,status
8113c500:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c504:	e0fffd17 	ldw	r3,-12(fp)
8113c508:	00bfff84 	movi	r2,-2
8113c50c:	1884703a 	and	r2,r3,r2
8113c510:	1001703a 	wrctl	status,r2
  
  return context;
8113c514:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113c518:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
8113c51c:	e0bffe17 	ldw	r2,-8(fp)
8113c520:	1080020b 	ldhu	r2,8(r2)
8113c524:	10bfffcc 	andi	r2,r2,65535
8113c528:	1004d23a 	srli	r2,r2,8
8113c52c:	1007883a 	mov	r3,r2
8113c530:	e0bfff17 	ldw	r2,-4(fp)
8113c534:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
8113c538:	e0bffe17 	ldw	r2,-8(fp)
8113c53c:	1080020b 	ldhu	r2,8(r2)
8113c540:	1007883a 	mov	r3,r2
8113c544:	e0bfff17 	ldw	r2,-4(fp)
8113c548:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
8113c54c:	e0bfff17 	ldw	r2,-4(fp)
8113c550:	10800203 	ldbu	r2,8(r2)
8113c554:	10803fcc 	andi	r2,r2,255
8113c558:	10803fd8 	cmpnei	r2,r2,255
8113c55c:	1000041e 	bne	r2,zero,8113c570 <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
8113c560:	e0bfff17 	ldw	r2,-4(fp)
8113c564:	00c00044 	movi	r3,1
8113c568:	10c001c5 	stb	r3,7(r2)
8113c56c:	00000206 	br	8113c578 <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
8113c570:	e0bfff17 	ldw	r2,-4(fp)
8113c574:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
8113c578:	e0bffe17 	ldw	r2,-8(fp)
8113c57c:	10c00283 	ldbu	r3,10(r2)
8113c580:	e0bfff17 	ldw	r2,-4(fp)
8113c584:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
8113c588:	e0bffe17 	ldw	r2,-8(fp)
8113c58c:	108002c4 	addi	r2,r2,11
8113c590:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
8113c594:	e0bfff17 	ldw	r2,-4(fp)
8113c598:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113c59c:	e03ff805 	stb	zero,-32(fp)
8113c5a0:	00000b06 	br	8113c5d0 <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
8113c5a4:	e0bffa17 	ldw	r2,-24(fp)
8113c5a8:	10c00044 	addi	r3,r2,1
8113c5ac:	e0fffa15 	stw	r3,-24(fp)
8113c5b0:	e0fff917 	ldw	r3,-28(fp)
8113c5b4:	19000044 	addi	r4,r3,1
8113c5b8:	e13ff915 	stw	r4,-28(fp)
8113c5bc:	18c00003 	ldbu	r3,0(r3)
8113c5c0:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113c5c4:	e0bff803 	ldbu	r2,-32(fp)
8113c5c8:	10800044 	addi	r2,r2,1
8113c5cc:	e0bff805 	stb	r2,-32(fp)
8113c5d0:	e0bff803 	ldbu	r2,-32(fp)
8113c5d4:	108001b0 	cmpltui	r2,r2,6
8113c5d8:	103ff21e 	bne	r2,zero,8113c5a4 <__reset+0xfb11c5a4>
8113c5dc:	e0bffb17 	ldw	r2,-20(fp)
8113c5e0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c5e4:	e0bffc17 	ldw	r2,-16(fp)
8113c5e8:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113c5ec:	0005883a 	mov	r2,zero
}
8113c5f0:	e037883a 	mov	sp,fp
8113c5f4:	df000017 	ldw	fp,0(sp)
8113c5f8:	dec00104 	addi	sp,sp,4
8113c5fc:	f800283a 	ret

8113c600 <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
8113c600:	defffc04 	addi	sp,sp,-16
8113c604:	de00012e 	bgeu	sp,et,8113c60c <OSMutex_RdyAtPrio+0xc>
8113c608:	003b68fa 	trap	3
8113c60c:	df000315 	stw	fp,12(sp)
8113c610:	df000304 	addi	fp,sp,12
8113c614:	e13ffe15 	stw	r4,-8(fp)
8113c618:	2805883a 	mov	r2,r5
8113c61c:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
8113c620:	e0bffe17 	ldw	r2,-8(fp)
8113c624:	10800d03 	ldbu	r2,52(r2)
8113c628:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
8113c62c:	e0fffd03 	ldbu	r3,-12(fp)
8113c630:	e13ffd03 	ldbu	r4,-12(fp)
8113c634:	d0a09d44 	addi	r2,gp,-32139
8113c638:	2085883a 	add	r2,r4,r2
8113c63c:	10800003 	ldbu	r2,0(r2)
8113c640:	1009883a 	mov	r4,r2
8113c644:	e0bffe17 	ldw	r2,-8(fp)
8113c648:	10800d43 	ldbu	r2,53(r2)
8113c64c:	0084303a 	nor	r2,zero,r2
8113c650:	2084703a 	and	r2,r4,r2
8113c654:	1009883a 	mov	r4,r2
8113c658:	d0a09d44 	addi	r2,gp,-32139
8113c65c:	1885883a 	add	r2,r3,r2
8113c660:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113c664:	e0fffd03 	ldbu	r3,-12(fp)
8113c668:	d0a09d44 	addi	r2,gp,-32139
8113c66c:	1885883a 	add	r2,r3,r2
8113c670:	10800003 	ldbu	r2,0(r2)
8113c674:	10803fcc 	andi	r2,r2,255
8113c678:	1000071e 	bne	r2,zero,8113c698 <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113c67c:	e0bffe17 	ldw	r2,-8(fp)
8113c680:	10800d83 	ldbu	r2,54(r2)
8113c684:	0084303a 	nor	r2,zero,r2
8113c688:	1007883a 	mov	r3,r2
8113c68c:	d0a09d03 	ldbu	r2,-32140(gp)
8113c690:	1884703a 	and	r2,r3,r2
8113c694:	d0a09d05 	stb	r2,-32140(gp)
    }
    ptcb->OSTCBPrio         = prio;
8113c698:	e0bffe17 	ldw	r2,-8(fp)
8113c69c:	e0ffff03 	ldbu	r3,-4(fp)
8113c6a0:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
8113c6a4:	e0bfff03 	ldbu	r2,-4(fp)
8113c6a8:	1004d0fa 	srli	r2,r2,3
8113c6ac:	108001cc 	andi	r2,r2,7
8113c6b0:	1007883a 	mov	r3,r2
8113c6b4:	e0bffe17 	ldw	r2,-8(fp)
8113c6b8:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
8113c6bc:	e0bfff03 	ldbu	r2,-4(fp)
8113c6c0:	108001cc 	andi	r2,r2,7
8113c6c4:	1007883a 	mov	r3,r2
8113c6c8:	e0bffe17 	ldw	r2,-8(fp)
8113c6cc:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
8113c6d0:	e0bffe17 	ldw	r2,-8(fp)
8113c6d4:	10800d03 	ldbu	r2,52(r2)
8113c6d8:	10803fcc 	andi	r2,r2,255
8113c6dc:	00c00044 	movi	r3,1
8113c6e0:	1884983a 	sll	r2,r3,r2
8113c6e4:	1007883a 	mov	r3,r2
8113c6e8:	e0bffe17 	ldw	r2,-8(fp)
8113c6ec:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
8113c6f0:	e0bffe17 	ldw	r2,-8(fp)
8113c6f4:	10800cc3 	ldbu	r2,51(r2)
8113c6f8:	10803fcc 	andi	r2,r2,255
8113c6fc:	00c00044 	movi	r3,1
8113c700:	1884983a 	sll	r2,r3,r2
8113c704:	1007883a 	mov	r3,r2
8113c708:	e0bffe17 	ldw	r2,-8(fp)
8113c70c:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
8113c710:	e0bffe17 	ldw	r2,-8(fp)
8113c714:	10c00d83 	ldbu	r3,54(r2)
8113c718:	d0a09d03 	ldbu	r2,-32140(gp)
8113c71c:	1884b03a 	or	r2,r3,r2
8113c720:	d0a09d05 	stb	r2,-32140(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113c724:	e0bffe17 	ldw	r2,-8(fp)
8113c728:	10800d03 	ldbu	r2,52(r2)
8113c72c:	10c03fcc 	andi	r3,r2,255
8113c730:	e0bffe17 	ldw	r2,-8(fp)
8113c734:	10800d03 	ldbu	r2,52(r2)
8113c738:	11003fcc 	andi	r4,r2,255
8113c73c:	d0a09d44 	addi	r2,gp,-32139
8113c740:	2085883a 	add	r2,r4,r2
8113c744:	11000003 	ldbu	r4,0(r2)
8113c748:	e0bffe17 	ldw	r2,-8(fp)
8113c74c:	10800d43 	ldbu	r2,53(r2)
8113c750:	2084b03a 	or	r2,r4,r2
8113c754:	1009883a 	mov	r4,r2
8113c758:	d0a09d44 	addi	r2,gp,-32139
8113c75c:	1885883a 	add	r2,r3,r2
8113c760:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
8113c764:	e0ffff03 	ldbu	r3,-4(fp)
8113c768:	00a045f4 	movhi	r2,33047
8113c76c:	10af6e04 	addi	r2,r2,-16968
8113c770:	18c7883a 	add	r3,r3,r3
8113c774:	18c7883a 	add	r3,r3,r3
8113c778:	10c5883a 	add	r2,r2,r3
8113c77c:	e0fffe17 	ldw	r3,-8(fp)
8113c780:	10c00015 	stw	r3,0(r2)
}
8113c784:	0001883a 	nop
8113c788:	e037883a 	mov	sp,fp
8113c78c:	df000017 	ldw	fp,0(sp)
8113c790:	dec00104 	addi	sp,sp,4
8113c794:	f800283a 	ret

8113c798 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
8113c798:	defff804 	addi	sp,sp,-32
8113c79c:	de00012e 	bgeu	sp,et,8113c7a4 <OSQAccept+0xc>
8113c7a0:	003b68fa 	trap	3
8113c7a4:	df000715 	stw	fp,28(sp)
8113c7a8:	df000704 	addi	fp,sp,28
8113c7ac:	e13ffe15 	stw	r4,-8(fp)
8113c7b0:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113c7b4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113c7b8:	e0bfff17 	ldw	r2,-4(fp)
8113c7bc:	1000021e 	bne	r2,zero,8113c7c8 <OSQAccept+0x30>
        return ((void *)0);
8113c7c0:	0005883a 	mov	r2,zero
8113c7c4:	00004206 	br	8113c8d0 <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113c7c8:	e0bffe17 	ldw	r2,-8(fp)
8113c7cc:	1000051e 	bne	r2,zero,8113c7e4 <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113c7d0:	e0bfff17 	ldw	r2,-4(fp)
8113c7d4:	00c00104 	movi	r3,4
8113c7d8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113c7dc:	0005883a 	mov	r2,zero
8113c7e0:	00003b06 	br	8113c8d0 <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113c7e4:	e0bffe17 	ldw	r2,-8(fp)
8113c7e8:	10800003 	ldbu	r2,0(r2)
8113c7ec:	10803fcc 	andi	r2,r2,255
8113c7f0:	108000a0 	cmpeqi	r2,r2,2
8113c7f4:	1000051e 	bne	r2,zero,8113c80c <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113c7f8:	e0bfff17 	ldw	r2,-4(fp)
8113c7fc:	00c00044 	movi	r3,1
8113c800:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113c804:	0005883a 	mov	r2,zero
8113c808:	00003106 	br	8113c8d0 <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c80c:	0005303a 	rdctl	r2,status
8113c810:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c814:	e0fffd17 	ldw	r3,-12(fp)
8113c818:	00bfff84 	movi	r2,-2
8113c81c:	1884703a 	and	r2,r3,r2
8113c820:	1001703a 	wrctl	status,r2
  
  return context;
8113c824:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113c828:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113c82c:	e0bffe17 	ldw	r2,-8(fp)
8113c830:	10800117 	ldw	r2,4(r2)
8113c834:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113c838:	e0bffc17 	ldw	r2,-16(fp)
8113c83c:	1080058b 	ldhu	r2,22(r2)
8113c840:	10bfffcc 	andi	r2,r2,65535
8113c844:	10001926 	beq	r2,zero,8113c8ac <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113c848:	e0bffc17 	ldw	r2,-16(fp)
8113c84c:	10800417 	ldw	r2,16(r2)
8113c850:	11000104 	addi	r4,r2,4
8113c854:	e0fffc17 	ldw	r3,-16(fp)
8113c858:	19000415 	stw	r4,16(r3)
8113c85c:	10800017 	ldw	r2,0(r2)
8113c860:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113c864:	e0bffc17 	ldw	r2,-16(fp)
8113c868:	1080058b 	ldhu	r2,22(r2)
8113c86c:	10bfffc4 	addi	r2,r2,-1
8113c870:	1007883a 	mov	r3,r2
8113c874:	e0bffc17 	ldw	r2,-16(fp)
8113c878:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113c87c:	e0bffc17 	ldw	r2,-16(fp)
8113c880:	10c00417 	ldw	r3,16(r2)
8113c884:	e0bffc17 	ldw	r2,-16(fp)
8113c888:	10800217 	ldw	r2,8(r2)
8113c88c:	1880041e 	bne	r3,r2,8113c8a0 <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
8113c890:	e0bffc17 	ldw	r2,-16(fp)
8113c894:	10c00117 	ldw	r3,4(r2)
8113c898:	e0bffc17 	ldw	r2,-16(fp)
8113c89c:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
8113c8a0:	e0bfff17 	ldw	r2,-4(fp)
8113c8a4:	10000005 	stb	zero,0(r2)
8113c8a8:	00000406 	br	8113c8bc <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
8113c8ac:	e0bfff17 	ldw	r2,-4(fp)
8113c8b0:	00c007c4 	movi	r3,31
8113c8b4:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
8113c8b8:	e03ff915 	stw	zero,-28(fp)
8113c8bc:	e0bffa17 	ldw	r2,-24(fp)
8113c8c0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c8c4:	e0bffb17 	ldw	r2,-20(fp)
8113c8c8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
8113c8cc:	e0bff917 	ldw	r2,-28(fp)
}
8113c8d0:	e037883a 	mov	sp,fp
8113c8d4:	df000017 	ldw	fp,0(sp)
8113c8d8:	dec00104 	addi	sp,sp,4
8113c8dc:	f800283a 	ret

8113c8e0 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
8113c8e0:	defff404 	addi	sp,sp,-48
8113c8e4:	de00012e 	bgeu	sp,et,8113c8ec <OSQCreate+0xc>
8113c8e8:	003b68fa 	trap	3
8113c8ec:	dfc00b15 	stw	ra,44(sp)
8113c8f0:	df000a15 	stw	fp,40(sp)
8113c8f4:	df000a04 	addi	fp,sp,40
8113c8f8:	e13ffe15 	stw	r4,-8(fp)
8113c8fc:	2805883a 	mov	r2,r5
8113c900:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113c904:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113c908:	d0a0a003 	ldbu	r2,-32128(gp)
8113c90c:	10803fcc 	andi	r2,r2,255
8113c910:	10000226 	beq	r2,zero,8113c91c <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
8113c914:	0005883a 	mov	r2,zero
8113c918:	00005906 	br	8113ca80 <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c91c:	0005303a 	rdctl	r2,status
8113c920:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c924:	e0fffd17 	ldw	r3,-12(fp)
8113c928:	00bfff84 	movi	r2,-2
8113c92c:	1884703a 	and	r2,r3,r2
8113c930:	1001703a 	wrctl	status,r2
  
  return context;
8113c934:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113c938:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
8113c93c:	d0a09f17 	ldw	r2,-32132(gp)
8113c940:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
8113c944:	d0a09f17 	ldw	r2,-32132(gp)
8113c948:	10000326 	beq	r2,zero,8113c958 <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113c94c:	d0a09f17 	ldw	r2,-32132(gp)
8113c950:	10800117 	ldw	r2,4(r2)
8113c954:	d0a09f15 	stw	r2,-32132(gp)
8113c958:	e0bff717 	ldw	r2,-36(fp)
8113c95c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c960:	e0bff817 	ldw	r2,-32(fp)
8113c964:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
8113c968:	e0bff617 	ldw	r2,-40(fp)
8113c96c:	10004326 	beq	r2,zero,8113ca7c <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c970:	0005303a 	rdctl	r2,status
8113c974:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c978:	e0fff917 	ldw	r3,-28(fp)
8113c97c:	00bfff84 	movi	r2,-2
8113c980:	1884703a 	and	r2,r3,r2
8113c984:	1001703a 	wrctl	status,r2
  
  return context;
8113c988:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
8113c98c:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
8113c990:	d0a09c17 	ldw	r2,-32144(gp)
8113c994:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
8113c998:	e0bffb17 	ldw	r2,-20(fp)
8113c99c:	10002d26 	beq	r2,zero,8113ca54 <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
8113c9a0:	d0a09c17 	ldw	r2,-32144(gp)
8113c9a4:	10800017 	ldw	r2,0(r2)
8113c9a8:	d0a09c15 	stw	r2,-32144(gp)
8113c9ac:	e0bff717 	ldw	r2,-36(fp)
8113c9b0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c9b4:	e0bffa17 	ldw	r2,-24(fp)
8113c9b8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
8113c9bc:	e0bffb17 	ldw	r2,-20(fp)
8113c9c0:	e0fffe17 	ldw	r3,-8(fp)
8113c9c4:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
8113c9c8:	e0bfff0b 	ldhu	r2,-4(fp)
8113c9cc:	1085883a 	add	r2,r2,r2
8113c9d0:	1085883a 	add	r2,r2,r2
8113c9d4:	1007883a 	mov	r3,r2
8113c9d8:	e0bffe17 	ldw	r2,-8(fp)
8113c9dc:	10c7883a 	add	r3,r2,r3
8113c9e0:	e0bffb17 	ldw	r2,-20(fp)
8113c9e4:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
8113c9e8:	e0bffb17 	ldw	r2,-20(fp)
8113c9ec:	e0fffe17 	ldw	r3,-8(fp)
8113c9f0:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
8113c9f4:	e0bffb17 	ldw	r2,-20(fp)
8113c9f8:	e0fffe17 	ldw	r3,-8(fp)
8113c9fc:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
8113ca00:	e0bffb17 	ldw	r2,-20(fp)
8113ca04:	e0ffff0b 	ldhu	r3,-4(fp)
8113ca08:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
8113ca0c:	e0bffb17 	ldw	r2,-20(fp)
8113ca10:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
8113ca14:	e0bff617 	ldw	r2,-40(fp)
8113ca18:	00c00084 	movi	r3,2
8113ca1c:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
8113ca20:	e0bff617 	ldw	r2,-40(fp)
8113ca24:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
8113ca28:	e0bff617 	ldw	r2,-40(fp)
8113ca2c:	e0fffb17 	ldw	r3,-20(fp)
8113ca30:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
8113ca34:	e0bff617 	ldw	r2,-40(fp)
8113ca38:	00c00fc4 	movi	r3,63
8113ca3c:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
8113ca40:	e0bff617 	ldw	r2,-40(fp)
8113ca44:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
8113ca48:	e13ff617 	ldw	r4,-40(fp)
8113ca4c:	11389400 	call	81138940 <OS_EventWaitListInit>
8113ca50:	00000a06 	br	8113ca7c <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
8113ca54:	d0e09f17 	ldw	r3,-32132(gp)
8113ca58:	e0bff617 	ldw	r2,-40(fp)
8113ca5c:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
8113ca60:	e0bff617 	ldw	r2,-40(fp)
8113ca64:	d0a09f15 	stw	r2,-32132(gp)
8113ca68:	e0bff717 	ldw	r2,-36(fp)
8113ca6c:	e0bffc15 	stw	r2,-16(fp)
8113ca70:	e0bffc17 	ldw	r2,-16(fp)
8113ca74:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
8113ca78:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
8113ca7c:	e0bff617 	ldw	r2,-40(fp)
}
8113ca80:	e037883a 	mov	sp,fp
8113ca84:	dfc00117 	ldw	ra,4(sp)
8113ca88:	df000017 	ldw	fp,0(sp)
8113ca8c:	dec00204 	addi	sp,sp,8
8113ca90:	f800283a 	ret

8113ca94 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113ca94:	defff204 	addi	sp,sp,-56
8113ca98:	de00012e 	bgeu	sp,et,8113caa0 <OSQDel+0xc>
8113ca9c:	003b68fa 	trap	3
8113caa0:	dfc00d15 	stw	ra,52(sp)
8113caa4:	df000c15 	stw	fp,48(sp)
8113caa8:	df000c04 	addi	fp,sp,48
8113caac:	e13ffd15 	stw	r4,-12(fp)
8113cab0:	2805883a 	mov	r2,r5
8113cab4:	e1bfff15 	stw	r6,-4(fp)
8113cab8:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113cabc:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113cac0:	e0bfff17 	ldw	r2,-4(fp)
8113cac4:	1000021e 	bne	r2,zero,8113cad0 <OSQDel+0x3c>
        return (pevent);
8113cac8:	e0bffd17 	ldw	r2,-12(fp)
8113cacc:	00008e06 	br	8113cd08 <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113cad0:	e0bffd17 	ldw	r2,-12(fp)
8113cad4:	1000051e 	bne	r2,zero,8113caec <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113cad8:	e0bfff17 	ldw	r2,-4(fp)
8113cadc:	00c00104 	movi	r3,4
8113cae0:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113cae4:	e0bffd17 	ldw	r2,-12(fp)
8113cae8:	00008706 	br	8113cd08 <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113caec:	e0bffd17 	ldw	r2,-12(fp)
8113caf0:	10800003 	ldbu	r2,0(r2)
8113caf4:	10803fcc 	andi	r2,r2,255
8113caf8:	108000a0 	cmpeqi	r2,r2,2
8113cafc:	1000051e 	bne	r2,zero,8113cb14 <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113cb00:	e0bfff17 	ldw	r2,-4(fp)
8113cb04:	00c00044 	movi	r3,1
8113cb08:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113cb0c:	e0bffd17 	ldw	r2,-12(fp)
8113cb10:	00007d06 	br	8113cd08 <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113cb14:	d0a0a003 	ldbu	r2,-32128(gp)
8113cb18:	10803fcc 	andi	r2,r2,255
8113cb1c:	10000526 	beq	r2,zero,8113cb34 <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113cb20:	e0bfff17 	ldw	r2,-4(fp)
8113cb24:	00c003c4 	movi	r3,15
8113cb28:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113cb2c:	e0bffd17 	ldw	r2,-12(fp)
8113cb30:	00007506 	br	8113cd08 <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cb34:	0005303a 	rdctl	r2,status
8113cb38:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cb3c:	e0fffc17 	ldw	r3,-16(fp)
8113cb40:	00bfff84 	movi	r2,-2
8113cb44:	1884703a 	and	r2,r3,r2
8113cb48:	1001703a 	wrctl	status,r2
  
  return context;
8113cb4c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113cb50:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
8113cb54:	e0bffd17 	ldw	r2,-12(fp)
8113cb58:	10800283 	ldbu	r2,10(r2)
8113cb5c:	10803fcc 	andi	r2,r2,255
8113cb60:	10000326 	beq	r2,zero,8113cb70 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113cb64:	00800044 	movi	r2,1
8113cb68:	e0bff405 	stb	r2,-48(fp)
8113cb6c:	00000106 	br	8113cb74 <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113cb70:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113cb74:	e0bffe03 	ldbu	r2,-8(fp)
8113cb78:	10000326 	beq	r2,zero,8113cb88 <OSQDel+0xf4>
8113cb7c:	10800060 	cmpeqi	r2,r2,1
8113cb80:	1000301e 	bne	r2,zero,8113cc44 <OSQDel+0x1b0>
8113cb84:	00005506 	br	8113ccdc <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
8113cb88:	e0bff403 	ldbu	r2,-48(fp)
8113cb8c:	10001e1e 	bne	r2,zero,8113cc08 <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113cb90:	e0bffd17 	ldw	r2,-12(fp)
8113cb94:	00c00fc4 	movi	r3,63
8113cb98:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113cb9c:	e0bffd17 	ldw	r2,-12(fp)
8113cba0:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
8113cba4:	e0bffd17 	ldw	r2,-12(fp)
8113cba8:	10800117 	ldw	r2,4(r2)
8113cbac:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
8113cbb0:	d0e09c17 	ldw	r3,-32144(gp)
8113cbb4:	e0bff817 	ldw	r2,-32(fp)
8113cbb8:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
8113cbbc:	e0bff817 	ldw	r2,-32(fp)
8113cbc0:	d0a09c15 	stw	r2,-32144(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113cbc4:	e0bffd17 	ldw	r2,-12(fp)
8113cbc8:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113cbcc:	d0e09f17 	ldw	r3,-32132(gp)
8113cbd0:	e0bffd17 	ldw	r2,-12(fp)
8113cbd4:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113cbd8:	e0bffd17 	ldw	r2,-12(fp)
8113cbdc:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113cbe0:	e0bffd17 	ldw	r2,-12(fp)
8113cbe4:	d0a09f15 	stw	r2,-32132(gp)
8113cbe8:	e0bff617 	ldw	r2,-40(fp)
8113cbec:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cbf0:	e0bff717 	ldw	r2,-36(fp)
8113cbf4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113cbf8:	e0bfff17 	ldw	r2,-4(fp)
8113cbfc:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
8113cc00:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113cc04:	00003f06 	br	8113cd04 <OSQDel+0x270>
8113cc08:	e0bff617 	ldw	r2,-40(fp)
8113cc0c:	e0bff915 	stw	r2,-28(fp)
8113cc10:	e0bff917 	ldw	r2,-28(fp)
8113cc14:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113cc18:	e0bfff17 	ldw	r2,-4(fp)
8113cc1c:	00c01244 	movi	r3,73
8113cc20:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113cc24:	e0bffd17 	ldw	r2,-12(fp)
8113cc28:	e0bff515 	stw	r2,-44(fp)
             }
             break;
8113cc2c:	00003506 	br	8113cd04 <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
8113cc30:	000f883a 	mov	r7,zero
8113cc34:	01800104 	movi	r6,4
8113cc38:	000b883a 	mov	r5,zero
8113cc3c:	e13ffd17 	ldw	r4,-12(fp)
8113cc40:	11383680 	call	81138368 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
8113cc44:	e0bffd17 	ldw	r2,-12(fp)
8113cc48:	10800283 	ldbu	r2,10(r2)
8113cc4c:	10803fcc 	andi	r2,r2,255
8113cc50:	103ff71e 	bne	r2,zero,8113cc30 <__reset+0xfb11cc30>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113cc54:	e0bffd17 	ldw	r2,-12(fp)
8113cc58:	00c00fc4 	movi	r3,63
8113cc5c:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113cc60:	e0bffd17 	ldw	r2,-12(fp)
8113cc64:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
8113cc68:	e0bffd17 	ldw	r2,-12(fp)
8113cc6c:	10800117 	ldw	r2,4(r2)
8113cc70:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
8113cc74:	d0e09c17 	ldw	r3,-32144(gp)
8113cc78:	e0bff817 	ldw	r2,-32(fp)
8113cc7c:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
8113cc80:	e0bff817 	ldw	r2,-32(fp)
8113cc84:	d0a09c15 	stw	r2,-32144(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113cc88:	e0bffd17 	ldw	r2,-12(fp)
8113cc8c:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113cc90:	d0e09f17 	ldw	r3,-32132(gp)
8113cc94:	e0bffd17 	ldw	r2,-12(fp)
8113cc98:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113cc9c:	e0bffd17 	ldw	r2,-12(fp)
8113cca0:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113cca4:	e0bffd17 	ldw	r2,-12(fp)
8113cca8:	d0a09f15 	stw	r2,-32132(gp)
8113ccac:	e0bff617 	ldw	r2,-40(fp)
8113ccb0:	e0bffa15 	stw	r2,-24(fp)
8113ccb4:	e0bffa17 	ldw	r2,-24(fp)
8113ccb8:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113ccbc:	e0bff403 	ldbu	r2,-48(fp)
8113ccc0:	10800058 	cmpnei	r2,r2,1
8113ccc4:	1000011e 	bne	r2,zero,8113cccc <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113ccc8:	1138e240 	call	81138e24 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113cccc:	e0bfff17 	ldw	r2,-4(fp)
8113ccd0:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
8113ccd4:	e03ff515 	stw	zero,-44(fp)
             break;
8113ccd8:	00000a06 	br	8113cd04 <OSQDel+0x270>
8113ccdc:	e0bff617 	ldw	r2,-40(fp)
8113cce0:	e0bffb15 	stw	r2,-20(fp)
8113cce4:	e0bffb17 	ldw	r2,-20(fp)
8113cce8:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113ccec:	e0bfff17 	ldw	r2,-4(fp)
8113ccf0:	00c001c4 	movi	r3,7
8113ccf4:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113ccf8:	e0bffd17 	ldw	r2,-12(fp)
8113ccfc:	e0bff515 	stw	r2,-44(fp)
             break;
8113cd00:	0001883a 	nop
    }
    return (pevent_return);
8113cd04:	e0bff517 	ldw	r2,-44(fp)
}
8113cd08:	e037883a 	mov	sp,fp
8113cd0c:	dfc00117 	ldw	ra,4(sp)
8113cd10:	df000017 	ldw	fp,0(sp)
8113cd14:	dec00204 	addi	sp,sp,8
8113cd18:	f800283a 	ret

8113cd1c <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
8113cd1c:	defffa04 	addi	sp,sp,-24
8113cd20:	de00012e 	bgeu	sp,et,8113cd28 <OSQFlush+0xc>
8113cd24:	003b68fa 	trap	3
8113cd28:	df000515 	stw	fp,20(sp)
8113cd2c:	df000504 	addi	fp,sp,20
8113cd30:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113cd34:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113cd38:	e0bfff17 	ldw	r2,-4(fp)
8113cd3c:	1000021e 	bne	r2,zero,8113cd48 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
8113cd40:	00800104 	movi	r2,4
8113cd44:	00002106 	br	8113cdcc <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113cd48:	e0bfff17 	ldw	r2,-4(fp)
8113cd4c:	10800003 	ldbu	r2,0(r2)
8113cd50:	10803fcc 	andi	r2,r2,255
8113cd54:	108000a0 	cmpeqi	r2,r2,2
8113cd58:	1000021e 	bne	r2,zero,8113cd64 <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
8113cd5c:	00800044 	movi	r2,1
8113cd60:	00001a06 	br	8113cdcc <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cd64:	0005303a 	rdctl	r2,status
8113cd68:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cd6c:	e0fffd17 	ldw	r3,-12(fp)
8113cd70:	00bfff84 	movi	r2,-2
8113cd74:	1884703a 	and	r2,r3,r2
8113cd78:	1001703a 	wrctl	status,r2
  
  return context;
8113cd7c:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113cd80:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
8113cd84:	e0bfff17 	ldw	r2,-4(fp)
8113cd88:	10800117 	ldw	r2,4(r2)
8113cd8c:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
8113cd90:	e0bffc17 	ldw	r2,-16(fp)
8113cd94:	10c00117 	ldw	r3,4(r2)
8113cd98:	e0bffc17 	ldw	r2,-16(fp)
8113cd9c:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
8113cda0:	e0bffc17 	ldw	r2,-16(fp)
8113cda4:	10c00117 	ldw	r3,4(r2)
8113cda8:	e0bffc17 	ldw	r2,-16(fp)
8113cdac:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
8113cdb0:	e0bffc17 	ldw	r2,-16(fp)
8113cdb4:	1000058d 	sth	zero,22(r2)
8113cdb8:	e0bffb17 	ldw	r2,-20(fp)
8113cdbc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cdc0:	e0bffe17 	ldw	r2,-8(fp)
8113cdc4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113cdc8:	0005883a 	mov	r2,zero
}
8113cdcc:	e037883a 	mov	sp,fp
8113cdd0:	df000017 	ldw	fp,0(sp)
8113cdd4:	dec00104 	addi	sp,sp,4
8113cdd8:	f800283a 	ret

8113cddc <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113cddc:	defff304 	addi	sp,sp,-52
8113cde0:	de00012e 	bgeu	sp,et,8113cde8 <OSQPend+0xc>
8113cde4:	003b68fa 	trap	3
8113cde8:	dfc00c15 	stw	ra,48(sp)
8113cdec:	df000b15 	stw	fp,44(sp)
8113cdf0:	df000b04 	addi	fp,sp,44
8113cdf4:	e13ffd15 	stw	r4,-12(fp)
8113cdf8:	2805883a 	mov	r2,r5
8113cdfc:	e1bfff15 	stw	r6,-4(fp)
8113ce00:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ce04:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113ce08:	e0bfff17 	ldw	r2,-4(fp)
8113ce0c:	1000021e 	bne	r2,zero,8113ce18 <OSQPend+0x3c>
        return ((void *)0);
8113ce10:	0005883a 	mov	r2,zero
8113ce14:	00009106 	br	8113d05c <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113ce18:	e0bffd17 	ldw	r2,-12(fp)
8113ce1c:	1000051e 	bne	r2,zero,8113ce34 <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113ce20:	e0bfff17 	ldw	r2,-4(fp)
8113ce24:	00c00104 	movi	r3,4
8113ce28:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113ce2c:	0005883a 	mov	r2,zero
8113ce30:	00008a06 	br	8113d05c <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113ce34:	e0bffd17 	ldw	r2,-12(fp)
8113ce38:	10800003 	ldbu	r2,0(r2)
8113ce3c:	10803fcc 	andi	r2,r2,255
8113ce40:	108000a0 	cmpeqi	r2,r2,2
8113ce44:	1000051e 	bne	r2,zero,8113ce5c <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113ce48:	e0bfff17 	ldw	r2,-4(fp)
8113ce4c:	00c00044 	movi	r3,1
8113ce50:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113ce54:	0005883a 	mov	r2,zero
8113ce58:	00008006 	br	8113d05c <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113ce5c:	d0a0a003 	ldbu	r2,-32128(gp)
8113ce60:	10803fcc 	andi	r2,r2,255
8113ce64:	10000526 	beq	r2,zero,8113ce7c <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
8113ce68:	e0bfff17 	ldw	r2,-4(fp)
8113ce6c:	00c00084 	movi	r3,2
8113ce70:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113ce74:	0005883a 	mov	r2,zero
8113ce78:	00007806 	br	8113d05c <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
8113ce7c:	d0a08e03 	ldbu	r2,-32200(gp)
8113ce80:	10803fcc 	andi	r2,r2,255
8113ce84:	10000526 	beq	r2,zero,8113ce9c <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
8113ce88:	e0bfff17 	ldw	r2,-4(fp)
8113ce8c:	00c00344 	movi	r3,13
8113ce90:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113ce94:	0005883a 	mov	r2,zero
8113ce98:	00007006 	br	8113d05c <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ce9c:	0005303a 	rdctl	r2,status
8113cea0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cea4:	e0fffc17 	ldw	r3,-16(fp)
8113cea8:	00bfff84 	movi	r2,-2
8113ceac:	1884703a 	and	r2,r3,r2
8113ceb0:	1001703a 	wrctl	status,r2
  
  return context;
8113ceb4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113ceb8:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113cebc:	e0bffd17 	ldw	r2,-12(fp)
8113cec0:	10800117 	ldw	r2,4(r2)
8113cec4:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113cec8:	e0bff817 	ldw	r2,-32(fp)
8113cecc:	1080058b 	ldhu	r2,22(r2)
8113ced0:	10bfffcc 	andi	r2,r2,65535
8113ced4:	10001e26 	beq	r2,zero,8113cf50 <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113ced8:	e0bff817 	ldw	r2,-32(fp)
8113cedc:	10800417 	ldw	r2,16(r2)
8113cee0:	11000104 	addi	r4,r2,4
8113cee4:	e0fff817 	ldw	r3,-32(fp)
8113cee8:	19000415 	stw	r4,16(r3)
8113ceec:	10800017 	ldw	r2,0(r2)
8113cef0:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113cef4:	e0bff817 	ldw	r2,-32(fp)
8113cef8:	1080058b 	ldhu	r2,22(r2)
8113cefc:	10bfffc4 	addi	r2,r2,-1
8113cf00:	1007883a 	mov	r3,r2
8113cf04:	e0bff817 	ldw	r2,-32(fp)
8113cf08:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113cf0c:	e0bff817 	ldw	r2,-32(fp)
8113cf10:	10c00417 	ldw	r3,16(r2)
8113cf14:	e0bff817 	ldw	r2,-32(fp)
8113cf18:	10800217 	ldw	r2,8(r2)
8113cf1c:	1880041e 	bne	r3,r2,8113cf30 <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
8113cf20:	e0bff817 	ldw	r2,-32(fp)
8113cf24:	10c00117 	ldw	r3,4(r2)
8113cf28:	e0bff817 	ldw	r2,-32(fp)
8113cf2c:	10c00415 	stw	r3,16(r2)
8113cf30:	e0bff617 	ldw	r2,-40(fp)
8113cf34:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cf38:	e0bff717 	ldw	r2,-36(fp)
8113cf3c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113cf40:	e0bfff17 	ldw	r2,-4(fp)
8113cf44:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
8113cf48:	e0bff517 	ldw	r2,-44(fp)
8113cf4c:	00004306 	br	8113d05c <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
8113cf50:	d0a0a117 	ldw	r2,-32124(gp)
8113cf54:	d0e0a117 	ldw	r3,-32124(gp)
8113cf58:	18c00c03 	ldbu	r3,48(r3)
8113cf5c:	18c00114 	ori	r3,r3,4
8113cf60:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113cf64:	d0a0a117 	ldw	r2,-32124(gp)
8113cf68:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
8113cf6c:	d0a0a117 	ldw	r2,-32124(gp)
8113cf70:	e0fffe0b 	ldhu	r3,-8(fp)
8113cf74:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
8113cf78:	e13ffd17 	ldw	r4,-12(fp)
8113cf7c:	11385080 	call	81138508 <OS_EventTaskWait>
8113cf80:	e0bff617 	ldw	r2,-40(fp)
8113cf84:	e0bffb15 	stw	r2,-20(fp)
8113cf88:	e0bffb17 	ldw	r2,-20(fp)
8113cf8c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
8113cf90:	1138e240 	call	81138e24 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cf94:	0005303a 	rdctl	r2,status
8113cf98:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cf9c:	e0fff917 	ldw	r3,-28(fp)
8113cfa0:	00bfff84 	movi	r2,-2
8113cfa4:	1884703a 	and	r2,r3,r2
8113cfa8:	1001703a 	wrctl	status,r2
  
  return context;
8113cfac:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113cfb0:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113cfb4:	d0a0a117 	ldw	r2,-32124(gp)
8113cfb8:	10800c43 	ldbu	r2,49(r2)
8113cfbc:	10803fcc 	andi	r2,r2,255
8113cfc0:	10000326 	beq	r2,zero,8113cfd0 <OSQPend+0x1f4>
8113cfc4:	108000a0 	cmpeqi	r2,r2,2
8113cfc8:	1000071e 	bne	r2,zero,8113cfe8 <OSQPend+0x20c>
8113cfcc:	00000b06 	br	8113cffc <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
8113cfd0:	d0a0a117 	ldw	r2,-32124(gp)
8113cfd4:	10800917 	ldw	r2,36(r2)
8113cfd8:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
8113cfdc:	e0bfff17 	ldw	r2,-4(fp)
8113cfe0:	10000005 	stb	zero,0(r2)
             break;
8113cfe4:	00000e06 	br	8113d020 <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
8113cfe8:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113cfec:	e0bfff17 	ldw	r2,-4(fp)
8113cff0:	00c00384 	movi	r3,14
8113cff4:	10c00005 	stb	r3,0(r2)
             break;
8113cff8:	00000906 	br	8113d020 <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113cffc:	d0a0a117 	ldw	r2,-32124(gp)
8113d000:	e17ffd17 	ldw	r5,-12(fp)
8113d004:	1009883a 	mov	r4,r2
8113d008:	11387780 	call	81138778 <OS_EventTaskRemove>
             pmsg = (void *)0;
8113d00c:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113d010:	e0bfff17 	ldw	r2,-4(fp)
8113d014:	00c00284 	movi	r3,10
8113d018:	10c00005 	stb	r3,0(r2)
             break;
8113d01c:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113d020:	d0a0a117 	ldw	r2,-32124(gp)
8113d024:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113d028:	d0a0a117 	ldw	r2,-32124(gp)
8113d02c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113d030:	d0a0a117 	ldw	r2,-32124(gp)
8113d034:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113d038:	d0a0a117 	ldw	r2,-32124(gp)
8113d03c:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
8113d040:	d0a0a117 	ldw	r2,-32124(gp)
8113d044:	10000915 	stw	zero,36(r2)
8113d048:	e0bff617 	ldw	r2,-40(fp)
8113d04c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d050:	e0bffa17 	ldw	r2,-24(fp)
8113d054:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
8113d058:	e0bff517 	ldw	r2,-44(fp)
}
8113d05c:	e037883a 	mov	sp,fp
8113d060:	dfc00117 	ldw	ra,4(sp)
8113d064:	df000017 	ldw	fp,0(sp)
8113d068:	dec00204 	addi	sp,sp,8
8113d06c:	f800283a 	ret

8113d070 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113d070:	defff604 	addi	sp,sp,-40
8113d074:	de00012e 	bgeu	sp,et,8113d07c <OSQPendAbort+0xc>
8113d078:	003b68fa 	trap	3
8113d07c:	dfc00915 	stw	ra,36(sp)
8113d080:	df000815 	stw	fp,32(sp)
8113d084:	df000804 	addi	fp,sp,32
8113d088:	e13ffd15 	stw	r4,-12(fp)
8113d08c:	2805883a 	mov	r2,r5
8113d090:	e1bfff15 	stw	r6,-4(fp)
8113d094:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113d098:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113d09c:	e0bfff17 	ldw	r2,-4(fp)
8113d0a0:	1000021e 	bne	r2,zero,8113d0ac <OSQPendAbort+0x3c>
        return (0);
8113d0a4:	0005883a 	mov	r2,zero
8113d0a8:	00004906 	br	8113d1d0 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113d0ac:	e0bffd17 	ldw	r2,-12(fp)
8113d0b0:	1000051e 	bne	r2,zero,8113d0c8 <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113d0b4:	e0bfff17 	ldw	r2,-4(fp)
8113d0b8:	00c00104 	movi	r3,4
8113d0bc:	10c00005 	stb	r3,0(r2)
        return (0);
8113d0c0:	0005883a 	mov	r2,zero
8113d0c4:	00004206 	br	8113d1d0 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113d0c8:	e0bffd17 	ldw	r2,-12(fp)
8113d0cc:	10800003 	ldbu	r2,0(r2)
8113d0d0:	10803fcc 	andi	r2,r2,255
8113d0d4:	108000a0 	cmpeqi	r2,r2,2
8113d0d8:	1000051e 	bne	r2,zero,8113d0f0 <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113d0dc:	e0bfff17 	ldw	r2,-4(fp)
8113d0e0:	00c00044 	movi	r3,1
8113d0e4:	10c00005 	stb	r3,0(r2)
        return (0);
8113d0e8:	0005883a 	mov	r2,zero
8113d0ec:	00003806 	br	8113d1d0 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d0f0:	0005303a 	rdctl	r2,status
8113d0f4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d0f8:	e0fffc17 	ldw	r3,-16(fp)
8113d0fc:	00bfff84 	movi	r2,-2
8113d100:	1884703a 	and	r2,r3,r2
8113d104:	1001703a 	wrctl	status,r2
  
  return context;
8113d108:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113d10c:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
8113d110:	e0bffd17 	ldw	r2,-12(fp)
8113d114:	10800283 	ldbu	r2,10(r2)
8113d118:	10803fcc 	andi	r2,r2,255
8113d11c:	10002526 	beq	r2,zero,8113d1b4 <OSQPendAbort+0x144>
        nbr_tasks = 0;
8113d120:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113d124:	e0bffe03 	ldbu	r2,-8(fp)
8113d128:	10800060 	cmpeqi	r2,r2,1
8113d12c:	10000e26 	beq	r2,zero,8113d168 <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113d130:	00000806 	br	8113d154 <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113d134:	01c00084 	movi	r7,2
8113d138:	01800104 	movi	r6,4
8113d13c:	000b883a 	mov	r5,zero
8113d140:	e13ffd17 	ldw	r4,-12(fp)
8113d144:	11383680 	call	81138368 <OS_EventTaskRdy>
                     nbr_tasks++;
8113d148:	e0bff803 	ldbu	r2,-32(fp)
8113d14c:	10800044 	addi	r2,r2,1
8113d150:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113d154:	e0bffd17 	ldw	r2,-12(fp)
8113d158:	10800283 	ldbu	r2,10(r2)
8113d15c:	10803fcc 	andi	r2,r2,255
8113d160:	103ff41e 	bne	r2,zero,8113d134 <__reset+0xfb11d134>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113d164:	00000906 	br	8113d18c <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113d168:	01c00084 	movi	r7,2
8113d16c:	01800104 	movi	r6,4
8113d170:	000b883a 	mov	r5,zero
8113d174:	e13ffd17 	ldw	r4,-12(fp)
8113d178:	11383680 	call	81138368 <OS_EventTaskRdy>
                 nbr_tasks++;
8113d17c:	e0bff803 	ldbu	r2,-32(fp)
8113d180:	10800044 	addi	r2,r2,1
8113d184:	e0bff805 	stb	r2,-32(fp)
                 break;
8113d188:	0001883a 	nop
8113d18c:	e0bff917 	ldw	r2,-28(fp)
8113d190:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d194:	e0bffa17 	ldw	r2,-24(fp)
8113d198:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
8113d19c:	1138e240 	call	81138e24 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113d1a0:	e0bfff17 	ldw	r2,-4(fp)
8113d1a4:	00c00384 	movi	r3,14
8113d1a8:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113d1ac:	e0bff803 	ldbu	r2,-32(fp)
8113d1b0:	00000706 	br	8113d1d0 <OSQPendAbort+0x160>
8113d1b4:	e0bff917 	ldw	r2,-28(fp)
8113d1b8:	e0bffb15 	stw	r2,-20(fp)
8113d1bc:	e0bffb17 	ldw	r2,-20(fp)
8113d1c0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113d1c4:	e0bfff17 	ldw	r2,-4(fp)
8113d1c8:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
8113d1cc:	0005883a 	mov	r2,zero
}
8113d1d0:	e037883a 	mov	sp,fp
8113d1d4:	dfc00117 	ldw	ra,4(sp)
8113d1d8:	df000017 	ldw	fp,0(sp)
8113d1dc:	dec00204 	addi	sp,sp,8
8113d1e0:	f800283a 	ret

8113d1e4 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
8113d1e4:	defff604 	addi	sp,sp,-40
8113d1e8:	de00012e 	bgeu	sp,et,8113d1f0 <OSQPost+0xc>
8113d1ec:	003b68fa 	trap	3
8113d1f0:	dfc00915 	stw	ra,36(sp)
8113d1f4:	df000815 	stw	fp,32(sp)
8113d1f8:	df000804 	addi	fp,sp,32
8113d1fc:	e13ffe15 	stw	r4,-8(fp)
8113d200:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113d204:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113d208:	e0bffe17 	ldw	r2,-8(fp)
8113d20c:	1000021e 	bne	r2,zero,8113d218 <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
8113d210:	00800104 	movi	r2,4
8113d214:	00004a06 	br	8113d340 <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113d218:	e0bffe17 	ldw	r2,-8(fp)
8113d21c:	10800003 	ldbu	r2,0(r2)
8113d220:	10803fcc 	andi	r2,r2,255
8113d224:	108000a0 	cmpeqi	r2,r2,2
8113d228:	1000021e 	bne	r2,zero,8113d234 <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
8113d22c:	00800044 	movi	r2,1
8113d230:	00004306 	br	8113d340 <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d234:	0005303a 	rdctl	r2,status
8113d238:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d23c:	e0fffd17 	ldw	r3,-12(fp)
8113d240:	00bfff84 	movi	r2,-2
8113d244:	1884703a 	and	r2,r3,r2
8113d248:	1001703a 	wrctl	status,r2
  
  return context;
8113d24c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113d250:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
8113d254:	e0bffe17 	ldw	r2,-8(fp)
8113d258:	10800283 	ldbu	r2,10(r2)
8113d25c:	10803fcc 	andi	r2,r2,255
8113d260:	10000c26 	beq	r2,zero,8113d294 <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113d264:	000f883a 	mov	r7,zero
8113d268:	01800104 	movi	r6,4
8113d26c:	e17fff17 	ldw	r5,-4(fp)
8113d270:	e13ffe17 	ldw	r4,-8(fp)
8113d274:	11383680 	call	81138368 <OS_EventTaskRdy>
8113d278:	e0bff817 	ldw	r2,-32(fp)
8113d27c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d280:	e0bff917 	ldw	r2,-28(fp)
8113d284:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
8113d288:	1138e240 	call	81138e24 <OS_Sched>
        return (OS_ERR_NONE);
8113d28c:	0005883a 	mov	r2,zero
8113d290:	00002b06 	br	8113d340 <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
8113d294:	e0bffe17 	ldw	r2,-8(fp)
8113d298:	10800117 	ldw	r2,4(r2)
8113d29c:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
8113d2a0:	e0bffb17 	ldw	r2,-20(fp)
8113d2a4:	10c0058b 	ldhu	r3,22(r2)
8113d2a8:	e0bffb17 	ldw	r2,-20(fp)
8113d2ac:	1080050b 	ldhu	r2,20(r2)
8113d2b0:	18ffffcc 	andi	r3,r3,65535
8113d2b4:	10bfffcc 	andi	r2,r2,65535
8113d2b8:	18800636 	bltu	r3,r2,8113d2d4 <OSQPost+0xf0>
8113d2bc:	e0bff817 	ldw	r2,-32(fp)
8113d2c0:	e0bffa15 	stw	r2,-24(fp)
8113d2c4:	e0bffa17 	ldw	r2,-24(fp)
8113d2c8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113d2cc:	00800784 	movi	r2,30
8113d2d0:	00001b06 	br	8113d340 <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
8113d2d4:	e0bffb17 	ldw	r2,-20(fp)
8113d2d8:	10800317 	ldw	r2,12(r2)
8113d2dc:	11000104 	addi	r4,r2,4
8113d2e0:	e0fffb17 	ldw	r3,-20(fp)
8113d2e4:	19000315 	stw	r4,12(r3)
8113d2e8:	e0ffff17 	ldw	r3,-4(fp)
8113d2ec:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
8113d2f0:	e0bffb17 	ldw	r2,-20(fp)
8113d2f4:	1080058b 	ldhu	r2,22(r2)
8113d2f8:	10800044 	addi	r2,r2,1
8113d2fc:	1007883a 	mov	r3,r2
8113d300:	e0bffb17 	ldw	r2,-20(fp)
8113d304:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
8113d308:	e0bffb17 	ldw	r2,-20(fp)
8113d30c:	10c00317 	ldw	r3,12(r2)
8113d310:	e0bffb17 	ldw	r2,-20(fp)
8113d314:	10800217 	ldw	r2,8(r2)
8113d318:	1880041e 	bne	r3,r2,8113d32c <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
8113d31c:	e0bffb17 	ldw	r2,-20(fp)
8113d320:	10c00117 	ldw	r3,4(r2)
8113d324:	e0bffb17 	ldw	r2,-20(fp)
8113d328:	10c00315 	stw	r3,12(r2)
8113d32c:	e0bff817 	ldw	r2,-32(fp)
8113d330:	e0bffc15 	stw	r2,-16(fp)
8113d334:	e0bffc17 	ldw	r2,-16(fp)
8113d338:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113d33c:	0005883a 	mov	r2,zero
}
8113d340:	e037883a 	mov	sp,fp
8113d344:	dfc00117 	ldw	ra,4(sp)
8113d348:	df000017 	ldw	fp,0(sp)
8113d34c:	dec00204 	addi	sp,sp,8
8113d350:	f800283a 	ret

8113d354 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
8113d354:	defff604 	addi	sp,sp,-40
8113d358:	de00012e 	bgeu	sp,et,8113d360 <OSQPostFront+0xc>
8113d35c:	003b68fa 	trap	3
8113d360:	dfc00915 	stw	ra,36(sp)
8113d364:	df000815 	stw	fp,32(sp)
8113d368:	df000804 	addi	fp,sp,32
8113d36c:	e13ffe15 	stw	r4,-8(fp)
8113d370:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113d374:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113d378:	e0bffe17 	ldw	r2,-8(fp)
8113d37c:	1000021e 	bne	r2,zero,8113d388 <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
8113d380:	00800104 	movi	r2,4
8113d384:	00004c06 	br	8113d4b8 <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113d388:	e0bffe17 	ldw	r2,-8(fp)
8113d38c:	10800003 	ldbu	r2,0(r2)
8113d390:	10803fcc 	andi	r2,r2,255
8113d394:	108000a0 	cmpeqi	r2,r2,2
8113d398:	1000021e 	bne	r2,zero,8113d3a4 <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
8113d39c:	00800044 	movi	r2,1
8113d3a0:	00004506 	br	8113d4b8 <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d3a4:	0005303a 	rdctl	r2,status
8113d3a8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d3ac:	e0fffd17 	ldw	r3,-12(fp)
8113d3b0:	00bfff84 	movi	r2,-2
8113d3b4:	1884703a 	and	r2,r3,r2
8113d3b8:	1001703a 	wrctl	status,r2
  
  return context;
8113d3bc:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113d3c0:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
8113d3c4:	e0bffe17 	ldw	r2,-8(fp)
8113d3c8:	10800283 	ldbu	r2,10(r2)
8113d3cc:	10803fcc 	andi	r2,r2,255
8113d3d0:	10000c26 	beq	r2,zero,8113d404 <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113d3d4:	000f883a 	mov	r7,zero
8113d3d8:	01800104 	movi	r6,4
8113d3dc:	e17fff17 	ldw	r5,-4(fp)
8113d3e0:	e13ffe17 	ldw	r4,-8(fp)
8113d3e4:	11383680 	call	81138368 <OS_EventTaskRdy>
8113d3e8:	e0bff817 	ldw	r2,-32(fp)
8113d3ec:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d3f0:	e0bff917 	ldw	r2,-28(fp)
8113d3f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
8113d3f8:	1138e240 	call	81138e24 <OS_Sched>
        return (OS_ERR_NONE);
8113d3fc:	0005883a 	mov	r2,zero
8113d400:	00002d06 	br	8113d4b8 <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113d404:	e0bffe17 	ldw	r2,-8(fp)
8113d408:	10800117 	ldw	r2,4(r2)
8113d40c:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113d410:	e0bffb17 	ldw	r2,-20(fp)
8113d414:	10c0058b 	ldhu	r3,22(r2)
8113d418:	e0bffb17 	ldw	r2,-20(fp)
8113d41c:	1080050b 	ldhu	r2,20(r2)
8113d420:	18ffffcc 	andi	r3,r3,65535
8113d424:	10bfffcc 	andi	r2,r2,65535
8113d428:	18800636 	bltu	r3,r2,8113d444 <OSQPostFront+0xf0>
8113d42c:	e0bff817 	ldw	r2,-32(fp)
8113d430:	e0bffa15 	stw	r2,-24(fp)
8113d434:	e0bffa17 	ldw	r2,-24(fp)
8113d438:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113d43c:	00800784 	movi	r2,30
8113d440:	00001d06 	br	8113d4b8 <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
8113d444:	e0bffb17 	ldw	r2,-20(fp)
8113d448:	10c00417 	ldw	r3,16(r2)
8113d44c:	e0bffb17 	ldw	r2,-20(fp)
8113d450:	10800117 	ldw	r2,4(r2)
8113d454:	1880041e 	bne	r3,r2,8113d468 <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
8113d458:	e0bffb17 	ldw	r2,-20(fp)
8113d45c:	10c00217 	ldw	r3,8(r2)
8113d460:	e0bffb17 	ldw	r2,-20(fp)
8113d464:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
8113d468:	e0bffb17 	ldw	r2,-20(fp)
8113d46c:	10800417 	ldw	r2,16(r2)
8113d470:	10ffff04 	addi	r3,r2,-4
8113d474:	e0bffb17 	ldw	r2,-20(fp)
8113d478:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
8113d47c:	e0bffb17 	ldw	r2,-20(fp)
8113d480:	10800417 	ldw	r2,16(r2)
8113d484:	e0ffff17 	ldw	r3,-4(fp)
8113d488:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113d48c:	e0bffb17 	ldw	r2,-20(fp)
8113d490:	1080058b 	ldhu	r2,22(r2)
8113d494:	10800044 	addi	r2,r2,1
8113d498:	1007883a 	mov	r3,r2
8113d49c:	e0bffb17 	ldw	r2,-20(fp)
8113d4a0:	10c0058d 	sth	r3,22(r2)
8113d4a4:	e0bff817 	ldw	r2,-32(fp)
8113d4a8:	e0bffc15 	stw	r2,-16(fp)
8113d4ac:	e0bffc17 	ldw	r2,-16(fp)
8113d4b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113d4b4:	0005883a 	mov	r2,zero
}
8113d4b8:	e037883a 	mov	sp,fp
8113d4bc:	dfc00117 	ldw	ra,4(sp)
8113d4c0:	df000017 	ldw	fp,0(sp)
8113d4c4:	dec00204 	addi	sp,sp,8
8113d4c8:	f800283a 	ret

8113d4cc <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
8113d4cc:	defff504 	addi	sp,sp,-44
8113d4d0:	de00012e 	bgeu	sp,et,8113d4d8 <OSQPostOpt+0xc>
8113d4d4:	003b68fa 	trap	3
8113d4d8:	dfc00a15 	stw	ra,40(sp)
8113d4dc:	df000915 	stw	fp,36(sp)
8113d4e0:	df000904 	addi	fp,sp,36
8113d4e4:	e13ffd15 	stw	r4,-12(fp)
8113d4e8:	e17ffe15 	stw	r5,-8(fp)
8113d4ec:	3005883a 	mov	r2,r6
8113d4f0:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113d4f4:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113d4f8:	e0bffd17 	ldw	r2,-12(fp)
8113d4fc:	1000021e 	bne	r2,zero,8113d508 <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
8113d500:	00800104 	movi	r2,4
8113d504:	00007106 	br	8113d6cc <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113d508:	e0bffd17 	ldw	r2,-12(fp)
8113d50c:	10800003 	ldbu	r2,0(r2)
8113d510:	10803fcc 	andi	r2,r2,255
8113d514:	108000a0 	cmpeqi	r2,r2,2
8113d518:	1000021e 	bne	r2,zero,8113d524 <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
8113d51c:	00800044 	movi	r2,1
8113d520:	00006a06 	br	8113d6cc <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d524:	0005303a 	rdctl	r2,status
8113d528:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d52c:	e0fffc17 	ldw	r3,-16(fp)
8113d530:	00bfff84 	movi	r2,-2
8113d534:	1884703a 	and	r2,r3,r2
8113d538:	1001703a 	wrctl	status,r2
  
  return context;
8113d53c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113d540:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
8113d544:	e0bffd17 	ldw	r2,-12(fp)
8113d548:	10800283 	ldbu	r2,10(r2)
8113d54c:	10803fcc 	andi	r2,r2,255
8113d550:	10001d26 	beq	r2,zero,8113d5c8 <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
8113d554:	e0bfff03 	ldbu	r2,-4(fp)
8113d558:	1080004c 	andi	r2,r2,1
8113d55c:	10000b26 	beq	r2,zero,8113d58c <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113d560:	00000506 	br	8113d578 <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113d564:	000f883a 	mov	r7,zero
8113d568:	01800104 	movi	r6,4
8113d56c:	e17ffe17 	ldw	r5,-8(fp)
8113d570:	e13ffd17 	ldw	r4,-12(fp)
8113d574:	11383680 	call	81138368 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113d578:	e0bffd17 	ldw	r2,-12(fp)
8113d57c:	10800283 	ldbu	r2,10(r2)
8113d580:	10803fcc 	andi	r2,r2,255
8113d584:	103ff71e 	bne	r2,zero,8113d564 <__reset+0xfb11d564>
8113d588:	00000506 	br	8113d5a0 <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113d58c:	000f883a 	mov	r7,zero
8113d590:	01800104 	movi	r6,4
8113d594:	e17ffe17 	ldw	r5,-8(fp)
8113d598:	e13ffd17 	ldw	r4,-12(fp)
8113d59c:	11383680 	call	81138368 <OS_EventTaskRdy>
8113d5a0:	e0bff717 	ldw	r2,-36(fp)
8113d5a4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d5a8:	e0bff817 	ldw	r2,-32(fp)
8113d5ac:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
8113d5b0:	e0bfff03 	ldbu	r2,-4(fp)
8113d5b4:	1080010c 	andi	r2,r2,4
8113d5b8:	1000011e 	bne	r2,zero,8113d5c0 <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
8113d5bc:	1138e240 	call	81138e24 <OS_Sched>
        }
        return (OS_ERR_NONE);
8113d5c0:	0005883a 	mov	r2,zero
8113d5c4:	00004106 	br	8113d6cc <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113d5c8:	e0bffd17 	ldw	r2,-12(fp)
8113d5cc:	10800117 	ldw	r2,4(r2)
8113d5d0:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113d5d4:	e0bffa17 	ldw	r2,-24(fp)
8113d5d8:	10c0058b 	ldhu	r3,22(r2)
8113d5dc:	e0bffa17 	ldw	r2,-24(fp)
8113d5e0:	1080050b 	ldhu	r2,20(r2)
8113d5e4:	18ffffcc 	andi	r3,r3,65535
8113d5e8:	10bfffcc 	andi	r2,r2,65535
8113d5ec:	18800636 	bltu	r3,r2,8113d608 <OSQPostOpt+0x13c>
8113d5f0:	e0bff717 	ldw	r2,-36(fp)
8113d5f4:	e0bff915 	stw	r2,-28(fp)
8113d5f8:	e0bff917 	ldw	r2,-28(fp)
8113d5fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113d600:	00800784 	movi	r2,30
8113d604:	00003106 	br	8113d6cc <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
8113d608:	e0bfff03 	ldbu	r2,-4(fp)
8113d60c:	1080008c 	andi	r2,r2,2
8113d610:	10001326 	beq	r2,zero,8113d660 <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
8113d614:	e0bffa17 	ldw	r2,-24(fp)
8113d618:	10c00417 	ldw	r3,16(r2)
8113d61c:	e0bffa17 	ldw	r2,-24(fp)
8113d620:	10800117 	ldw	r2,4(r2)
8113d624:	1880041e 	bne	r3,r2,8113d638 <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
8113d628:	e0bffa17 	ldw	r2,-24(fp)
8113d62c:	10c00217 	ldw	r3,8(r2)
8113d630:	e0bffa17 	ldw	r2,-24(fp)
8113d634:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
8113d638:	e0bffa17 	ldw	r2,-24(fp)
8113d63c:	10800417 	ldw	r2,16(r2)
8113d640:	10ffff04 	addi	r3,r2,-4
8113d644:	e0bffa17 	ldw	r2,-24(fp)
8113d648:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
8113d64c:	e0bffa17 	ldw	r2,-24(fp)
8113d650:	10800417 	ldw	r2,16(r2)
8113d654:	e0fffe17 	ldw	r3,-8(fp)
8113d658:	10c00015 	stw	r3,0(r2)
8113d65c:	00001006 	br	8113d6a0 <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
8113d660:	e0bffa17 	ldw	r2,-24(fp)
8113d664:	10800317 	ldw	r2,12(r2)
8113d668:	11000104 	addi	r4,r2,4
8113d66c:	e0fffa17 	ldw	r3,-24(fp)
8113d670:	19000315 	stw	r4,12(r3)
8113d674:	e0fffe17 	ldw	r3,-8(fp)
8113d678:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
8113d67c:	e0bffa17 	ldw	r2,-24(fp)
8113d680:	10c00317 	ldw	r3,12(r2)
8113d684:	e0bffa17 	ldw	r2,-24(fp)
8113d688:	10800217 	ldw	r2,8(r2)
8113d68c:	1880041e 	bne	r3,r2,8113d6a0 <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
8113d690:	e0bffa17 	ldw	r2,-24(fp)
8113d694:	10c00117 	ldw	r3,4(r2)
8113d698:	e0bffa17 	ldw	r2,-24(fp)
8113d69c:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113d6a0:	e0bffa17 	ldw	r2,-24(fp)
8113d6a4:	1080058b 	ldhu	r2,22(r2)
8113d6a8:	10800044 	addi	r2,r2,1
8113d6ac:	1007883a 	mov	r3,r2
8113d6b0:	e0bffa17 	ldw	r2,-24(fp)
8113d6b4:	10c0058d 	sth	r3,22(r2)
8113d6b8:	e0bff717 	ldw	r2,-36(fp)
8113d6bc:	e0bffb15 	stw	r2,-20(fp)
8113d6c0:	e0bffb17 	ldw	r2,-20(fp)
8113d6c4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113d6c8:	0005883a 	mov	r2,zero
}
8113d6cc:	e037883a 	mov	sp,fp
8113d6d0:	dfc00117 	ldw	ra,4(sp)
8113d6d4:	df000017 	ldw	fp,0(sp)
8113d6d8:	dec00204 	addi	sp,sp,8
8113d6dc:	f800283a 	ret

8113d6e0 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
8113d6e0:	defff604 	addi	sp,sp,-40
8113d6e4:	de00012e 	bgeu	sp,et,8113d6ec <OSQQuery+0xc>
8113d6e8:	003b68fa 	trap	3
8113d6ec:	df000915 	stw	fp,36(sp)
8113d6f0:	df000904 	addi	fp,sp,36
8113d6f4:	e13ffe15 	stw	r4,-8(fp)
8113d6f8:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113d6fc:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113d700:	e0bffe17 	ldw	r2,-8(fp)
8113d704:	1000021e 	bne	r2,zero,8113d710 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113d708:	00800104 	movi	r2,4
8113d70c:	00004906 	br	8113d834 <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
8113d710:	e0bfff17 	ldw	r2,-4(fp)
8113d714:	1000021e 	bne	r2,zero,8113d720 <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113d718:	00800244 	movi	r2,9
8113d71c:	00004506 	br	8113d834 <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113d720:	e0bffe17 	ldw	r2,-8(fp)
8113d724:	10800003 	ldbu	r2,0(r2)
8113d728:	10803fcc 	andi	r2,r2,255
8113d72c:	108000a0 	cmpeqi	r2,r2,2
8113d730:	1000021e 	bne	r2,zero,8113d73c <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113d734:	00800044 	movi	r2,1
8113d738:	00003e06 	br	8113d834 <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d73c:	0005303a 	rdctl	r2,status
8113d740:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d744:	e0fffd17 	ldw	r3,-12(fp)
8113d748:	00bfff84 	movi	r2,-2
8113d74c:	1884703a 	and	r2,r3,r2
8113d750:	1001703a 	wrctl	status,r2
  
  return context;
8113d754:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113d758:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
8113d75c:	e0bffe17 	ldw	r2,-8(fp)
8113d760:	10c00283 	ldbu	r3,10(r2)
8113d764:	e0bfff17 	ldw	r2,-4(fp)
8113d768:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
8113d76c:	e0bffe17 	ldw	r2,-8(fp)
8113d770:	108002c4 	addi	r2,r2,11
8113d774:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
8113d778:	e0bfff17 	ldw	r2,-4(fp)
8113d77c:	10800204 	addi	r2,r2,8
8113d780:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113d784:	e03ff705 	stb	zero,-36(fp)
8113d788:	00000b06 	br	8113d7b8 <OSQQuery+0xd8>
        *pdest++ = *psrc++;
8113d78c:	e0bff917 	ldw	r2,-28(fp)
8113d790:	10c00044 	addi	r3,r2,1
8113d794:	e0fff915 	stw	r3,-28(fp)
8113d798:	e0fff817 	ldw	r3,-32(fp)
8113d79c:	19000044 	addi	r4,r3,1
8113d7a0:	e13ff815 	stw	r4,-32(fp)
8113d7a4:	18c00003 	ldbu	r3,0(r3)
8113d7a8:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113d7ac:	e0bff703 	ldbu	r2,-36(fp)
8113d7b0:	10800044 	addi	r2,r2,1
8113d7b4:	e0bff705 	stb	r2,-36(fp)
8113d7b8:	e0bff703 	ldbu	r2,-36(fp)
8113d7bc:	108001b0 	cmpltui	r2,r2,6
8113d7c0:	103ff21e 	bne	r2,zero,8113d78c <__reset+0xfb11d78c>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
8113d7c4:	e0bffe17 	ldw	r2,-8(fp)
8113d7c8:	10800117 	ldw	r2,4(r2)
8113d7cc:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
8113d7d0:	e0bffc17 	ldw	r2,-16(fp)
8113d7d4:	1080058b 	ldhu	r2,22(r2)
8113d7d8:	10bfffcc 	andi	r2,r2,65535
8113d7dc:	10000626 	beq	r2,zero,8113d7f8 <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
8113d7e0:	e0bffc17 	ldw	r2,-16(fp)
8113d7e4:	10800417 	ldw	r2,16(r2)
8113d7e8:	10c00017 	ldw	r3,0(r2)
8113d7ec:	e0bfff17 	ldw	r2,-4(fp)
8113d7f0:	10c00015 	stw	r3,0(r2)
8113d7f4:	00000206 	br	8113d800 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
8113d7f8:	e0bfff17 	ldw	r2,-4(fp)
8113d7fc:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
8113d800:	e0bffc17 	ldw	r2,-16(fp)
8113d804:	10c0058b 	ldhu	r3,22(r2)
8113d808:	e0bfff17 	ldw	r2,-4(fp)
8113d80c:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
8113d810:	e0bffc17 	ldw	r2,-16(fp)
8113d814:	10c0050b 	ldhu	r3,20(r2)
8113d818:	e0bfff17 	ldw	r2,-4(fp)
8113d81c:	10c0018d 	sth	r3,6(r2)
8113d820:	e0bffa17 	ldw	r2,-24(fp)
8113d824:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d828:	e0bffb17 	ldw	r2,-20(fp)
8113d82c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113d830:	0005883a 	mov	r2,zero
}
8113d834:	e037883a 	mov	sp,fp
8113d838:	df000017 	ldw	fp,0(sp)
8113d83c:	dec00104 	addi	sp,sp,4
8113d840:	f800283a 	ret

8113d844 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
8113d844:	defffb04 	addi	sp,sp,-20
8113d848:	de00012e 	bgeu	sp,et,8113d850 <OS_QInit+0xc>
8113d84c:	003b68fa 	trap	3
8113d850:	dfc00415 	stw	ra,16(sp)
8113d854:	df000315 	stw	fp,12(sp)
8113d858:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
8113d85c:	0140c004 	movi	r5,768
8113d860:	012045f4 	movhi	r4,33047
8113d864:	21210004 	addi	r4,r4,-31744
8113d868:	1138d580 	call	81138d58 <OS_MemClr>
    pq1 = &OSQTbl[0];
8113d86c:	00a045f4 	movhi	r2,33047
8113d870:	10a10004 	addi	r2,r2,-31744
8113d874:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
8113d878:	00a045f4 	movhi	r2,33047
8113d87c:	10a10604 	addi	r2,r2,-31720
8113d880:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113d884:	e03ffd0d 	sth	zero,-12(fp)
8113d888:	00000c06 	br	8113d8bc <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
8113d88c:	e0bffe17 	ldw	r2,-8(fp)
8113d890:	e0ffff17 	ldw	r3,-4(fp)
8113d894:	10c00015 	stw	r3,0(r2)
        pq1++;
8113d898:	e0bffe17 	ldw	r2,-8(fp)
8113d89c:	10800604 	addi	r2,r2,24
8113d8a0:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
8113d8a4:	e0bfff17 	ldw	r2,-4(fp)
8113d8a8:	10800604 	addi	r2,r2,24
8113d8ac:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113d8b0:	e0bffd0b 	ldhu	r2,-12(fp)
8113d8b4:	10800044 	addi	r2,r2,1
8113d8b8:	e0bffd0d 	sth	r2,-12(fp)
8113d8bc:	e0bffd0b 	ldhu	r2,-12(fp)
8113d8c0:	108007f0 	cmpltui	r2,r2,31
8113d8c4:	103ff11e 	bne	r2,zero,8113d88c <__reset+0xfb11d88c>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
8113d8c8:	e0bffe17 	ldw	r2,-8(fp)
8113d8cc:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
8113d8d0:	00a045f4 	movhi	r2,33047
8113d8d4:	10a10004 	addi	r2,r2,-31744
8113d8d8:	d0a09c15 	stw	r2,-32144(gp)
#endif
}
8113d8dc:	0001883a 	nop
8113d8e0:	e037883a 	mov	sp,fp
8113d8e4:	dfc00117 	ldw	ra,4(sp)
8113d8e8:	df000017 	ldw	fp,0(sp)
8113d8ec:	dec00204 	addi	sp,sp,8
8113d8f0:	f800283a 	ret

8113d8f4 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
8113d8f4:	defffa04 	addi	sp,sp,-24
8113d8f8:	de00012e 	bgeu	sp,et,8113d900 <OSSemAccept+0xc>
8113d8fc:	003b68fa 	trap	3
8113d900:	df000515 	stw	fp,20(sp)
8113d904:	df000504 	addi	fp,sp,20
8113d908:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113d90c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113d910:	e0bfff17 	ldw	r2,-4(fp)
8113d914:	1000021e 	bne	r2,zero,8113d920 <OSSemAccept+0x2c>
        return (0);
8113d918:	0005883a 	mov	r2,zero
8113d91c:	00001f06 	br	8113d99c <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113d920:	e0bfff17 	ldw	r2,-4(fp)
8113d924:	10800003 	ldbu	r2,0(r2)
8113d928:	10803fcc 	andi	r2,r2,255
8113d92c:	108000e0 	cmpeqi	r2,r2,3
8113d930:	1000021e 	bne	r2,zero,8113d93c <OSSemAccept+0x48>
        return (0);
8113d934:	0005883a 	mov	r2,zero
8113d938:	00001806 	br	8113d99c <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d93c:	0005303a 	rdctl	r2,status
8113d940:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d944:	e0fffe17 	ldw	r3,-8(fp)
8113d948:	00bfff84 	movi	r2,-2
8113d94c:	1884703a 	and	r2,r3,r2
8113d950:	1001703a 	wrctl	status,r2
  
  return context;
8113d954:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113d958:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
8113d95c:	e0bfff17 	ldw	r2,-4(fp)
8113d960:	1080020b 	ldhu	r2,8(r2)
8113d964:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
8113d968:	e0bffd0b 	ldhu	r2,-12(fp)
8113d96c:	10000626 	beq	r2,zero,8113d988 <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
8113d970:	e0bfff17 	ldw	r2,-4(fp)
8113d974:	1080020b 	ldhu	r2,8(r2)
8113d978:	10bfffc4 	addi	r2,r2,-1
8113d97c:	1007883a 	mov	r3,r2
8113d980:	e0bfff17 	ldw	r2,-4(fp)
8113d984:	10c0020d 	sth	r3,8(r2)
8113d988:	e0bffb17 	ldw	r2,-20(fp)
8113d98c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d990:	e0bffc17 	ldw	r2,-16(fp)
8113d994:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
8113d998:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113d99c:	e037883a 	mov	sp,fp
8113d9a0:	df000017 	ldw	fp,0(sp)
8113d9a4:	dec00104 	addi	sp,sp,4
8113d9a8:	f800283a 	ret

8113d9ac <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
8113d9ac:	defff904 	addi	sp,sp,-28
8113d9b0:	de00012e 	bgeu	sp,et,8113d9b8 <OSSemCreate+0xc>
8113d9b4:	003b68fa 	trap	3
8113d9b8:	dfc00615 	stw	ra,24(sp)
8113d9bc:	df000515 	stw	fp,20(sp)
8113d9c0:	df000504 	addi	fp,sp,20
8113d9c4:	2005883a 	mov	r2,r4
8113d9c8:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113d9cc:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113d9d0:	d0a0a003 	ldbu	r2,-32128(gp)
8113d9d4:	10803fcc 	andi	r2,r2,255
8113d9d8:	10000226 	beq	r2,zero,8113d9e4 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
8113d9dc:	0005883a 	mov	r2,zero
8113d9e0:	00002506 	br	8113da78 <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d9e4:	0005303a 	rdctl	r2,status
8113d9e8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d9ec:	e0fffe17 	ldw	r3,-8(fp)
8113d9f0:	00bfff84 	movi	r2,-2
8113d9f4:	1884703a 	and	r2,r3,r2
8113d9f8:	1001703a 	wrctl	status,r2
  
  return context;
8113d9fc:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113da00:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
8113da04:	d0a09f17 	ldw	r2,-32132(gp)
8113da08:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
8113da0c:	d0a09f17 	ldw	r2,-32132(gp)
8113da10:	10000326 	beq	r2,zero,8113da20 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113da14:	d0a09f17 	ldw	r2,-32132(gp)
8113da18:	10800117 	ldw	r2,4(r2)
8113da1c:	d0a09f15 	stw	r2,-32132(gp)
8113da20:	e0bffb17 	ldw	r2,-20(fp)
8113da24:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113da28:	e0bffc17 	ldw	r2,-16(fp)
8113da2c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
8113da30:	e0bffd17 	ldw	r2,-12(fp)
8113da34:	10000f26 	beq	r2,zero,8113da74 <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
8113da38:	e0bffd17 	ldw	r2,-12(fp)
8113da3c:	00c000c4 	movi	r3,3
8113da40:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
8113da44:	e0bffd17 	ldw	r2,-12(fp)
8113da48:	e0ffff0b 	ldhu	r3,-4(fp)
8113da4c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
8113da50:	e0bffd17 	ldw	r2,-12(fp)
8113da54:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
8113da58:	e0bffd17 	ldw	r2,-12(fp)
8113da5c:	00c00fc4 	movi	r3,63
8113da60:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
8113da64:	e0bffd17 	ldw	r2,-12(fp)
8113da68:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
8113da6c:	e13ffd17 	ldw	r4,-12(fp)
8113da70:	11389400 	call	81138940 <OS_EventWaitListInit>
    }
    return (pevent);
8113da74:	e0bffd17 	ldw	r2,-12(fp)
}
8113da78:	e037883a 	mov	sp,fp
8113da7c:	dfc00117 	ldw	ra,4(sp)
8113da80:	df000017 	ldw	fp,0(sp)
8113da84:	dec00204 	addi	sp,sp,8
8113da88:	f800283a 	ret

8113da8c <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113da8c:	defff304 	addi	sp,sp,-52
8113da90:	de00012e 	bgeu	sp,et,8113da98 <OSSemDel+0xc>
8113da94:	003b68fa 	trap	3
8113da98:	dfc00c15 	stw	ra,48(sp)
8113da9c:	df000b15 	stw	fp,44(sp)
8113daa0:	df000b04 	addi	fp,sp,44
8113daa4:	e13ffd15 	stw	r4,-12(fp)
8113daa8:	2805883a 	mov	r2,r5
8113daac:	e1bfff15 	stw	r6,-4(fp)
8113dab0:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113dab4:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113dab8:	e0bfff17 	ldw	r2,-4(fp)
8113dabc:	1000021e 	bne	r2,zero,8113dac8 <OSSemDel+0x3c>
        return (pevent);
8113dac0:	e0bffd17 	ldw	r2,-12(fp)
8113dac4:	00007e06 	br	8113dcc0 <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113dac8:	e0bffd17 	ldw	r2,-12(fp)
8113dacc:	1000051e 	bne	r2,zero,8113dae4 <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113dad0:	e0bfff17 	ldw	r2,-4(fp)
8113dad4:	00c00104 	movi	r3,4
8113dad8:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113dadc:	e0bffd17 	ldw	r2,-12(fp)
8113dae0:	00007706 	br	8113dcc0 <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113dae4:	e0bffd17 	ldw	r2,-12(fp)
8113dae8:	10800003 	ldbu	r2,0(r2)
8113daec:	10803fcc 	andi	r2,r2,255
8113daf0:	108000e0 	cmpeqi	r2,r2,3
8113daf4:	1000051e 	bne	r2,zero,8113db0c <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113daf8:	e0bfff17 	ldw	r2,-4(fp)
8113dafc:	00c00044 	movi	r3,1
8113db00:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113db04:	e0bffd17 	ldw	r2,-12(fp)
8113db08:	00006d06 	br	8113dcc0 <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113db0c:	d0a0a003 	ldbu	r2,-32128(gp)
8113db10:	10803fcc 	andi	r2,r2,255
8113db14:	10000526 	beq	r2,zero,8113db2c <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113db18:	e0bfff17 	ldw	r2,-4(fp)
8113db1c:	00c003c4 	movi	r3,15
8113db20:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113db24:	e0bffd17 	ldw	r2,-12(fp)
8113db28:	00006506 	br	8113dcc0 <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113db2c:	0005303a 	rdctl	r2,status
8113db30:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113db34:	e0fffc17 	ldw	r3,-16(fp)
8113db38:	00bfff84 	movi	r2,-2
8113db3c:	1884703a 	and	r2,r3,r2
8113db40:	1001703a 	wrctl	status,r2
  
  return context;
8113db44:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113db48:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
8113db4c:	e0bffd17 	ldw	r2,-12(fp)
8113db50:	10800283 	ldbu	r2,10(r2)
8113db54:	10803fcc 	andi	r2,r2,255
8113db58:	10000326 	beq	r2,zero,8113db68 <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113db5c:	00800044 	movi	r2,1
8113db60:	e0bff505 	stb	r2,-44(fp)
8113db64:	00000106 	br	8113db6c <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113db68:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
8113db6c:	e0bffe03 	ldbu	r2,-8(fp)
8113db70:	10000326 	beq	r2,zero,8113db80 <OSSemDel+0xf4>
8113db74:	10800060 	cmpeqi	r2,r2,1
8113db78:	1000281e 	bne	r2,zero,8113dc1c <OSSemDel+0x190>
8113db7c:	00004506 	br	8113dc94 <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
8113db80:	e0bff503 	ldbu	r2,-44(fp)
8113db84:	1000161e 	bne	r2,zero,8113dbe0 <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113db88:	e0bffd17 	ldw	r2,-12(fp)
8113db8c:	00c00fc4 	movi	r3,63
8113db90:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113db94:	e0bffd17 	ldw	r2,-12(fp)
8113db98:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113db9c:	e0bffd17 	ldw	r2,-12(fp)
8113dba0:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113dba4:	d0e09f17 	ldw	r3,-32132(gp)
8113dba8:	e0bffd17 	ldw	r2,-12(fp)
8113dbac:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113dbb0:	e0bffd17 	ldw	r2,-12(fp)
8113dbb4:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113dbb8:	e0bffd17 	ldw	r2,-12(fp)
8113dbbc:	d0a09f15 	stw	r2,-32132(gp)
8113dbc0:	e0bff717 	ldw	r2,-36(fp)
8113dbc4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dbc8:	e0bff817 	ldw	r2,-32(fp)
8113dbcc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113dbd0:	e0bfff17 	ldw	r2,-4(fp)
8113dbd4:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
8113dbd8:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113dbdc:	00003706 	br	8113dcbc <OSSemDel+0x230>
8113dbe0:	e0bff717 	ldw	r2,-36(fp)
8113dbe4:	e0bff915 	stw	r2,-28(fp)
8113dbe8:	e0bff917 	ldw	r2,-28(fp)
8113dbec:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113dbf0:	e0bfff17 	ldw	r2,-4(fp)
8113dbf4:	00c01244 	movi	r3,73
8113dbf8:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113dbfc:	e0bffd17 	ldw	r2,-12(fp)
8113dc00:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113dc04:	00002d06 	br	8113dcbc <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113dc08:	000f883a 	mov	r7,zero
8113dc0c:	01800044 	movi	r6,1
8113dc10:	000b883a 	mov	r5,zero
8113dc14:	e13ffd17 	ldw	r4,-12(fp)
8113dc18:	11383680 	call	81138368 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
8113dc1c:	e0bffd17 	ldw	r2,-12(fp)
8113dc20:	10800283 	ldbu	r2,10(r2)
8113dc24:	10803fcc 	andi	r2,r2,255
8113dc28:	103ff71e 	bne	r2,zero,8113dc08 <__reset+0xfb11dc08>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113dc2c:	e0bffd17 	ldw	r2,-12(fp)
8113dc30:	00c00fc4 	movi	r3,63
8113dc34:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113dc38:	e0bffd17 	ldw	r2,-12(fp)
8113dc3c:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113dc40:	e0bffd17 	ldw	r2,-12(fp)
8113dc44:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113dc48:	d0e09f17 	ldw	r3,-32132(gp)
8113dc4c:	e0bffd17 	ldw	r2,-12(fp)
8113dc50:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113dc54:	e0bffd17 	ldw	r2,-12(fp)
8113dc58:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113dc5c:	e0bffd17 	ldw	r2,-12(fp)
8113dc60:	d0a09f15 	stw	r2,-32132(gp)
8113dc64:	e0bff717 	ldw	r2,-36(fp)
8113dc68:	e0bffa15 	stw	r2,-24(fp)
8113dc6c:	e0bffa17 	ldw	r2,-24(fp)
8113dc70:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113dc74:	e0bff503 	ldbu	r2,-44(fp)
8113dc78:	10800058 	cmpnei	r2,r2,1
8113dc7c:	1000011e 	bne	r2,zero,8113dc84 <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113dc80:	1138e240 	call	81138e24 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113dc84:	e0bfff17 	ldw	r2,-4(fp)
8113dc88:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
8113dc8c:	e03ff615 	stw	zero,-40(fp)
             break;
8113dc90:	00000a06 	br	8113dcbc <OSSemDel+0x230>
8113dc94:	e0bff717 	ldw	r2,-36(fp)
8113dc98:	e0bffb15 	stw	r2,-20(fp)
8113dc9c:	e0bffb17 	ldw	r2,-20(fp)
8113dca0:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113dca4:	e0bfff17 	ldw	r2,-4(fp)
8113dca8:	00c001c4 	movi	r3,7
8113dcac:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113dcb0:	e0bffd17 	ldw	r2,-12(fp)
8113dcb4:	e0bff615 	stw	r2,-40(fp)
             break;
8113dcb8:	0001883a 	nop
    }
    return (pevent_return);
8113dcbc:	e0bff617 	ldw	r2,-40(fp)
}
8113dcc0:	e037883a 	mov	sp,fp
8113dcc4:	dfc00117 	ldw	ra,4(sp)
8113dcc8:	df000017 	ldw	fp,0(sp)
8113dccc:	dec00204 	addi	sp,sp,8
8113dcd0:	f800283a 	ret

8113dcd4 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113dcd4:	defff504 	addi	sp,sp,-44
8113dcd8:	de00012e 	bgeu	sp,et,8113dce0 <OSSemPend+0xc>
8113dcdc:	003b68fa 	trap	3
8113dce0:	dfc00a15 	stw	ra,40(sp)
8113dce4:	df000915 	stw	fp,36(sp)
8113dce8:	df000904 	addi	fp,sp,36
8113dcec:	e13ffd15 	stw	r4,-12(fp)
8113dcf0:	2805883a 	mov	r2,r5
8113dcf4:	e1bfff15 	stw	r6,-4(fp)
8113dcf8:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113dcfc:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113dd00:	e0bfff17 	ldw	r2,-4(fp)
8113dd04:	10007226 	beq	r2,zero,8113ded0 <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113dd08:	e0bffd17 	ldw	r2,-12(fp)
8113dd0c:	1000041e 	bne	r2,zero,8113dd20 <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113dd10:	e0bfff17 	ldw	r2,-4(fp)
8113dd14:	00c00104 	movi	r3,4
8113dd18:	10c00005 	stb	r3,0(r2)
        return;
8113dd1c:	00006d06 	br	8113ded4 <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113dd20:	e0bffd17 	ldw	r2,-12(fp)
8113dd24:	10800003 	ldbu	r2,0(r2)
8113dd28:	10803fcc 	andi	r2,r2,255
8113dd2c:	108000e0 	cmpeqi	r2,r2,3
8113dd30:	1000041e 	bne	r2,zero,8113dd44 <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113dd34:	e0bfff17 	ldw	r2,-4(fp)
8113dd38:	00c00044 	movi	r3,1
8113dd3c:	10c00005 	stb	r3,0(r2)
        return;
8113dd40:	00006406 	br	8113ded4 <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113dd44:	d0a0a003 	ldbu	r2,-32128(gp)
8113dd48:	10803fcc 	andi	r2,r2,255
8113dd4c:	10000426 	beq	r2,zero,8113dd60 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
8113dd50:	e0bfff17 	ldw	r2,-4(fp)
8113dd54:	00c00084 	movi	r3,2
8113dd58:	10c00005 	stb	r3,0(r2)
        return;
8113dd5c:	00005d06 	br	8113ded4 <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
8113dd60:	d0a08e03 	ldbu	r2,-32200(gp)
8113dd64:	10803fcc 	andi	r2,r2,255
8113dd68:	10000426 	beq	r2,zero,8113dd7c <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
8113dd6c:	e0bfff17 	ldw	r2,-4(fp)
8113dd70:	00c00344 	movi	r3,13
8113dd74:	10c00005 	stb	r3,0(r2)
        return;
8113dd78:	00005606 	br	8113ded4 <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113dd7c:	0005303a 	rdctl	r2,status
8113dd80:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113dd84:	e0fffc17 	ldw	r3,-16(fp)
8113dd88:	00bfff84 	movi	r2,-2
8113dd8c:	1884703a 	and	r2,r3,r2
8113dd90:	1001703a 	wrctl	status,r2
  
  return context;
8113dd94:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113dd98:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
8113dd9c:	e0bffd17 	ldw	r2,-12(fp)
8113dda0:	1080020b 	ldhu	r2,8(r2)
8113dda4:	10bfffcc 	andi	r2,r2,65535
8113dda8:	10000d26 	beq	r2,zero,8113dde0 <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
8113ddac:	e0bffd17 	ldw	r2,-12(fp)
8113ddb0:	1080020b 	ldhu	r2,8(r2)
8113ddb4:	10bfffc4 	addi	r2,r2,-1
8113ddb8:	1007883a 	mov	r3,r2
8113ddbc:	e0bffd17 	ldw	r2,-12(fp)
8113ddc0:	10c0020d 	sth	r3,8(r2)
8113ddc4:	e0bff717 	ldw	r2,-36(fp)
8113ddc8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ddcc:	e0bff817 	ldw	r2,-32(fp)
8113ddd0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113ddd4:	e0bfff17 	ldw	r2,-4(fp)
8113ddd8:	10000005 	stb	zero,0(r2)
        return;
8113dddc:	00003d06 	br	8113ded4 <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
8113dde0:	d0a0a117 	ldw	r2,-32124(gp)
8113dde4:	d0e0a117 	ldw	r3,-32124(gp)
8113dde8:	18c00c03 	ldbu	r3,48(r3)
8113ddec:	18c00054 	ori	r3,r3,1
8113ddf0:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113ddf4:	d0a0a117 	ldw	r2,-32124(gp)
8113ddf8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
8113ddfc:	d0a0a117 	ldw	r2,-32124(gp)
8113de00:	e0fffe0b 	ldhu	r3,-8(fp)
8113de04:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113de08:	e13ffd17 	ldw	r4,-12(fp)
8113de0c:	11385080 	call	81138508 <OS_EventTaskWait>
8113de10:	e0bff717 	ldw	r2,-36(fp)
8113de14:	e0bffb15 	stw	r2,-20(fp)
8113de18:	e0bffb17 	ldw	r2,-20(fp)
8113de1c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113de20:	1138e240 	call	81138e24 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113de24:	0005303a 	rdctl	r2,status
8113de28:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113de2c:	e0fff917 	ldw	r3,-28(fp)
8113de30:	00bfff84 	movi	r2,-2
8113de34:	1884703a 	and	r2,r3,r2
8113de38:	1001703a 	wrctl	status,r2
  
  return context;
8113de3c:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113de40:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113de44:	d0a0a117 	ldw	r2,-32124(gp)
8113de48:	10800c43 	ldbu	r2,49(r2)
8113de4c:	10803fcc 	andi	r2,r2,255
8113de50:	10000326 	beq	r2,zero,8113de60 <OSSemPend+0x18c>
8113de54:	108000a0 	cmpeqi	r2,r2,2
8113de58:	1000041e 	bne	r2,zero,8113de6c <OSSemPend+0x198>
8113de5c:	00000706 	br	8113de7c <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113de60:	e0bfff17 	ldw	r2,-4(fp)
8113de64:	10000005 	stb	zero,0(r2)
             break;
8113de68:	00000c06 	br	8113de9c <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113de6c:	e0bfff17 	ldw	r2,-4(fp)
8113de70:	00c00384 	movi	r3,14
8113de74:	10c00005 	stb	r3,0(r2)
             break;
8113de78:	00000806 	br	8113de9c <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
8113de7c:	d0a0a117 	ldw	r2,-32124(gp)
8113de80:	e17ffd17 	ldw	r5,-12(fp)
8113de84:	1009883a 	mov	r4,r2
8113de88:	11387780 	call	81138778 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113de8c:	e0bfff17 	ldw	r2,-4(fp)
8113de90:	00c00284 	movi	r3,10
8113de94:	10c00005 	stb	r3,0(r2)
             break;
8113de98:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113de9c:	d0a0a117 	ldw	r2,-32124(gp)
8113dea0:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113dea4:	d0a0a117 	ldw	r2,-32124(gp)
8113dea8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113deac:	d0a0a117 	ldw	r2,-32124(gp)
8113deb0:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113deb4:	d0a0a117 	ldw	r2,-32124(gp)
8113deb8:	10000815 	stw	zero,32(r2)
8113debc:	e0bff717 	ldw	r2,-36(fp)
8113dec0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dec4:	e0bffa17 	ldw	r2,-24(fp)
8113dec8:	1001703a 	wrctl	status,r2
8113decc:	00000106 	br	8113ded4 <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113ded0:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113ded4:	e037883a 	mov	sp,fp
8113ded8:	dfc00117 	ldw	ra,4(sp)
8113dedc:	df000017 	ldw	fp,0(sp)
8113dee0:	dec00204 	addi	sp,sp,8
8113dee4:	f800283a 	ret

8113dee8 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113dee8:	defff604 	addi	sp,sp,-40
8113deec:	de00012e 	bgeu	sp,et,8113def4 <OSSemPendAbort+0xc>
8113def0:	003b68fa 	trap	3
8113def4:	dfc00915 	stw	ra,36(sp)
8113def8:	df000815 	stw	fp,32(sp)
8113defc:	df000804 	addi	fp,sp,32
8113df00:	e13ffd15 	stw	r4,-12(fp)
8113df04:	2805883a 	mov	r2,r5
8113df08:	e1bfff15 	stw	r6,-4(fp)
8113df0c:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113df10:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113df14:	e0bfff17 	ldw	r2,-4(fp)
8113df18:	1000021e 	bne	r2,zero,8113df24 <OSSemPendAbort+0x3c>
        return (0);
8113df1c:	0005883a 	mov	r2,zero
8113df20:	00004906 	br	8113e048 <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113df24:	e0bffd17 	ldw	r2,-12(fp)
8113df28:	1000051e 	bne	r2,zero,8113df40 <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113df2c:	e0bfff17 	ldw	r2,-4(fp)
8113df30:	00c00104 	movi	r3,4
8113df34:	10c00005 	stb	r3,0(r2)
        return (0);
8113df38:	0005883a 	mov	r2,zero
8113df3c:	00004206 	br	8113e048 <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113df40:	e0bffd17 	ldw	r2,-12(fp)
8113df44:	10800003 	ldbu	r2,0(r2)
8113df48:	10803fcc 	andi	r2,r2,255
8113df4c:	108000e0 	cmpeqi	r2,r2,3
8113df50:	1000051e 	bne	r2,zero,8113df68 <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113df54:	e0bfff17 	ldw	r2,-4(fp)
8113df58:	00c00044 	movi	r3,1
8113df5c:	10c00005 	stb	r3,0(r2)
        return (0);
8113df60:	0005883a 	mov	r2,zero
8113df64:	00003806 	br	8113e048 <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113df68:	0005303a 	rdctl	r2,status
8113df6c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113df70:	e0fffc17 	ldw	r3,-16(fp)
8113df74:	00bfff84 	movi	r2,-2
8113df78:	1884703a 	and	r2,r3,r2
8113df7c:	1001703a 	wrctl	status,r2
  
  return context;
8113df80:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113df84:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
8113df88:	e0bffd17 	ldw	r2,-12(fp)
8113df8c:	10800283 	ldbu	r2,10(r2)
8113df90:	10803fcc 	andi	r2,r2,255
8113df94:	10002526 	beq	r2,zero,8113e02c <OSSemPendAbort+0x144>
        nbr_tasks = 0;
8113df98:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113df9c:	e0bffe03 	ldbu	r2,-8(fp)
8113dfa0:	10800060 	cmpeqi	r2,r2,1
8113dfa4:	10000e26 	beq	r2,zero,8113dfe0 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8113dfa8:	00000806 	br	8113dfcc <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8113dfac:	01c00084 	movi	r7,2
8113dfb0:	01800044 	movi	r6,1
8113dfb4:	000b883a 	mov	r5,zero
8113dfb8:	e13ffd17 	ldw	r4,-12(fp)
8113dfbc:	11383680 	call	81138368 <OS_EventTaskRdy>
                     nbr_tasks++;
8113dfc0:	e0bff803 	ldbu	r2,-32(fp)
8113dfc4:	10800044 	addi	r2,r2,1
8113dfc8:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8113dfcc:	e0bffd17 	ldw	r2,-12(fp)
8113dfd0:	10800283 	ldbu	r2,10(r2)
8113dfd4:	10803fcc 	andi	r2,r2,255
8113dfd8:	103ff41e 	bne	r2,zero,8113dfac <__reset+0xfb11dfac>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113dfdc:	00000906 	br	8113e004 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8113dfe0:	01c00084 	movi	r7,2
8113dfe4:	01800044 	movi	r6,1
8113dfe8:	000b883a 	mov	r5,zero
8113dfec:	e13ffd17 	ldw	r4,-12(fp)
8113dff0:	11383680 	call	81138368 <OS_EventTaskRdy>
                 nbr_tasks++;
8113dff4:	e0bff803 	ldbu	r2,-32(fp)
8113dff8:	10800044 	addi	r2,r2,1
8113dffc:	e0bff805 	stb	r2,-32(fp)
                 break;
8113e000:	0001883a 	nop
8113e004:	e0bff917 	ldw	r2,-28(fp)
8113e008:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e00c:	e0bffa17 	ldw	r2,-24(fp)
8113e010:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8113e014:	1138e240 	call	81138e24 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113e018:	e0bfff17 	ldw	r2,-4(fp)
8113e01c:	00c00384 	movi	r3,14
8113e020:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113e024:	e0bff803 	ldbu	r2,-32(fp)
8113e028:	00000706 	br	8113e048 <OSSemPendAbort+0x160>
8113e02c:	e0bff917 	ldw	r2,-28(fp)
8113e030:	e0bffb15 	stw	r2,-20(fp)
8113e034:	e0bffb17 	ldw	r2,-20(fp)
8113e038:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113e03c:	e0bfff17 	ldw	r2,-4(fp)
8113e040:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
8113e044:	0005883a 	mov	r2,zero
}
8113e048:	e037883a 	mov	sp,fp
8113e04c:	dfc00117 	ldw	ra,4(sp)
8113e050:	df000017 	ldw	fp,0(sp)
8113e054:	dec00204 	addi	sp,sp,8
8113e058:	f800283a 	ret

8113e05c <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
8113e05c:	defff804 	addi	sp,sp,-32
8113e060:	de00012e 	bgeu	sp,et,8113e068 <OSSemPost+0xc>
8113e064:	003b68fa 	trap	3
8113e068:	dfc00715 	stw	ra,28(sp)
8113e06c:	df000615 	stw	fp,24(sp)
8113e070:	df000604 	addi	fp,sp,24
8113e074:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113e078:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113e07c:	e0bfff17 	ldw	r2,-4(fp)
8113e080:	1000021e 	bne	r2,zero,8113e08c <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
8113e084:	00800104 	movi	r2,4
8113e088:	00003506 	br	8113e160 <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113e08c:	e0bfff17 	ldw	r2,-4(fp)
8113e090:	10800003 	ldbu	r2,0(r2)
8113e094:	10803fcc 	andi	r2,r2,255
8113e098:	108000e0 	cmpeqi	r2,r2,3
8113e09c:	1000021e 	bne	r2,zero,8113e0a8 <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
8113e0a0:	00800044 	movi	r2,1
8113e0a4:	00002e06 	br	8113e160 <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e0a8:	0005303a 	rdctl	r2,status
8113e0ac:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e0b0:	e0fffe17 	ldw	r3,-8(fp)
8113e0b4:	00bfff84 	movi	r2,-2
8113e0b8:	1884703a 	and	r2,r3,r2
8113e0bc:	1001703a 	wrctl	status,r2
  
  return context;
8113e0c0:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113e0c4:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
8113e0c8:	e0bfff17 	ldw	r2,-4(fp)
8113e0cc:	10800283 	ldbu	r2,10(r2)
8113e0d0:	10803fcc 	andi	r2,r2,255
8113e0d4:	10000c26 	beq	r2,zero,8113e108 <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113e0d8:	000f883a 	mov	r7,zero
8113e0dc:	01800044 	movi	r6,1
8113e0e0:	000b883a 	mov	r5,zero
8113e0e4:	e13fff17 	ldw	r4,-4(fp)
8113e0e8:	11383680 	call	81138368 <OS_EventTaskRdy>
8113e0ec:	e0bffa17 	ldw	r2,-24(fp)
8113e0f0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e0f4:	e0bffb17 	ldw	r2,-20(fp)
8113e0f8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8113e0fc:	1138e240 	call	81138e24 <OS_Sched>
        return (OS_ERR_NONE);
8113e100:	0005883a 	mov	r2,zero
8113e104:	00001606 	br	8113e160 <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
8113e108:	e0bfff17 	ldw	r2,-4(fp)
8113e10c:	1080020b 	ldhu	r2,8(r2)
8113e110:	10ffffcc 	andi	r3,r2,65535
8113e114:	00bfffd4 	movui	r2,65535
8113e118:	18800c26 	beq	r3,r2,8113e14c <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
8113e11c:	e0bfff17 	ldw	r2,-4(fp)
8113e120:	1080020b 	ldhu	r2,8(r2)
8113e124:	10800044 	addi	r2,r2,1
8113e128:	1007883a 	mov	r3,r2
8113e12c:	e0bfff17 	ldw	r2,-4(fp)
8113e130:	10c0020d 	sth	r3,8(r2)
8113e134:	e0bffa17 	ldw	r2,-24(fp)
8113e138:	e0bffc15 	stw	r2,-16(fp)
8113e13c:	e0bffc17 	ldw	r2,-16(fp)
8113e140:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8113e144:	0005883a 	mov	r2,zero
8113e148:	00000506 	br	8113e160 <OSSemPost+0x104>
8113e14c:	e0bffa17 	ldw	r2,-24(fp)
8113e150:	e0bffd15 	stw	r2,-12(fp)
8113e154:	e0bffd17 	ldw	r2,-12(fp)
8113e158:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
8113e15c:	00800c84 	movi	r2,50
}
8113e160:	e037883a 	mov	sp,fp
8113e164:	dfc00117 	ldw	ra,4(sp)
8113e168:	df000017 	ldw	fp,0(sp)
8113e16c:	dec00204 	addi	sp,sp,8
8113e170:	f800283a 	ret

8113e174 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
8113e174:	defff704 	addi	sp,sp,-36
8113e178:	de00012e 	bgeu	sp,et,8113e180 <OSSemQuery+0xc>
8113e17c:	003b68fa 	trap	3
8113e180:	df000815 	stw	fp,32(sp)
8113e184:	df000804 	addi	fp,sp,32
8113e188:	e13ffe15 	stw	r4,-8(fp)
8113e18c:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113e190:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113e194:	e0bffe17 	ldw	r2,-8(fp)
8113e198:	1000021e 	bne	r2,zero,8113e1a4 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113e19c:	00800104 	movi	r2,4
8113e1a0:	00003606 	br	8113e27c <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
8113e1a4:	e0bfff17 	ldw	r2,-4(fp)
8113e1a8:	1000021e 	bne	r2,zero,8113e1b4 <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113e1ac:	00800244 	movi	r2,9
8113e1b0:	00003206 	br	8113e27c <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113e1b4:	e0bffe17 	ldw	r2,-8(fp)
8113e1b8:	10800003 	ldbu	r2,0(r2)
8113e1bc:	10803fcc 	andi	r2,r2,255
8113e1c0:	108000e0 	cmpeqi	r2,r2,3
8113e1c4:	1000021e 	bne	r2,zero,8113e1d0 <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113e1c8:	00800044 	movi	r2,1
8113e1cc:	00002b06 	br	8113e27c <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e1d0:	0005303a 	rdctl	r2,status
8113e1d4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e1d8:	e0fffd17 	ldw	r3,-12(fp)
8113e1dc:	00bfff84 	movi	r2,-2
8113e1e0:	1884703a 	and	r2,r3,r2
8113e1e4:	1001703a 	wrctl	status,r2
  
  return context;
8113e1e8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113e1ec:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
8113e1f0:	e0bffe17 	ldw	r2,-8(fp)
8113e1f4:	10c00283 	ldbu	r3,10(r2)
8113e1f8:	e0bfff17 	ldw	r2,-4(fp)
8113e1fc:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
8113e200:	e0bffe17 	ldw	r2,-8(fp)
8113e204:	108002c4 	addi	r2,r2,11
8113e208:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
8113e20c:	e0bfff17 	ldw	r2,-4(fp)
8113e210:	10800084 	addi	r2,r2,2
8113e214:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113e218:	e03ffa05 	stb	zero,-24(fp)
8113e21c:	00000b06 	br	8113e24c <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
8113e220:	e0bff917 	ldw	r2,-28(fp)
8113e224:	10c00044 	addi	r3,r2,1
8113e228:	e0fff915 	stw	r3,-28(fp)
8113e22c:	e0fff817 	ldw	r3,-32(fp)
8113e230:	19000044 	addi	r4,r3,1
8113e234:	e13ff815 	stw	r4,-32(fp)
8113e238:	18c00003 	ldbu	r3,0(r3)
8113e23c:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113e240:	e0bffa03 	ldbu	r2,-24(fp)
8113e244:	10800044 	addi	r2,r2,1
8113e248:	e0bffa05 	stb	r2,-24(fp)
8113e24c:	e0bffa03 	ldbu	r2,-24(fp)
8113e250:	108001b0 	cmpltui	r2,r2,6
8113e254:	103ff21e 	bne	r2,zero,8113e220 <__reset+0xfb11e220>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
8113e258:	e0bffe17 	ldw	r2,-8(fp)
8113e25c:	10c0020b 	ldhu	r3,8(r2)
8113e260:	e0bfff17 	ldw	r2,-4(fp)
8113e264:	10c0000d 	sth	r3,0(r2)
8113e268:	e0bffb17 	ldw	r2,-20(fp)
8113e26c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e270:	e0bffc17 	ldw	r2,-16(fp)
8113e274:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113e278:	0005883a 	mov	r2,zero
}
8113e27c:	e037883a 	mov	sp,fp
8113e280:	df000017 	ldw	fp,0(sp)
8113e284:	dec00104 	addi	sp,sp,4
8113e288:	f800283a 	ret

8113e28c <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
8113e28c:	defff904 	addi	sp,sp,-28
8113e290:	de00012e 	bgeu	sp,et,8113e298 <OSSemSet+0xc>
8113e294:	003b68fa 	trap	3
8113e298:	df000615 	stw	fp,24(sp)
8113e29c:	df000604 	addi	fp,sp,24
8113e2a0:	e13ffd15 	stw	r4,-12(fp)
8113e2a4:	2805883a 	mov	r2,r5
8113e2a8:	e1bfff15 	stw	r6,-4(fp)
8113e2ac:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113e2b0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113e2b4:	e0bfff17 	ldw	r2,-4(fp)
8113e2b8:	10003126 	beq	r2,zero,8113e380 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113e2bc:	e0bffd17 	ldw	r2,-12(fp)
8113e2c0:	1000041e 	bne	r2,zero,8113e2d4 <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
8113e2c4:	e0bfff17 	ldw	r2,-4(fp)
8113e2c8:	00c00104 	movi	r3,4
8113e2cc:	10c00005 	stb	r3,0(r2)
        return;
8113e2d0:	00002c06 	br	8113e384 <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113e2d4:	e0bffd17 	ldw	r2,-12(fp)
8113e2d8:	10800003 	ldbu	r2,0(r2)
8113e2dc:	10803fcc 	andi	r2,r2,255
8113e2e0:	108000e0 	cmpeqi	r2,r2,3
8113e2e4:	1000041e 	bne	r2,zero,8113e2f8 <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
8113e2e8:	e0bfff17 	ldw	r2,-4(fp)
8113e2ec:	00c00044 	movi	r3,1
8113e2f0:	10c00005 	stb	r3,0(r2)
        return;
8113e2f4:	00002306 	br	8113e384 <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e2f8:	0005303a 	rdctl	r2,status
8113e2fc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e300:	e0fffc17 	ldw	r3,-16(fp)
8113e304:	00bfff84 	movi	r2,-2
8113e308:	1884703a 	and	r2,r3,r2
8113e30c:	1001703a 	wrctl	status,r2
  
  return context;
8113e310:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113e314:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
8113e318:	e0bfff17 	ldw	r2,-4(fp)
8113e31c:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
8113e320:	e0bffd17 	ldw	r2,-12(fp)
8113e324:	1080020b 	ldhu	r2,8(r2)
8113e328:	10bfffcc 	andi	r2,r2,65535
8113e32c:	10000426 	beq	r2,zero,8113e340 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
8113e330:	e0bffd17 	ldw	r2,-12(fp)
8113e334:	e0fffe0b 	ldhu	r3,-8(fp)
8113e338:	10c0020d 	sth	r3,8(r2)
8113e33c:	00000b06 	br	8113e36c <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
8113e340:	e0bffd17 	ldw	r2,-12(fp)
8113e344:	10800283 	ldbu	r2,10(r2)
8113e348:	10803fcc 	andi	r2,r2,255
8113e34c:	1000041e 	bne	r2,zero,8113e360 <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
8113e350:	e0bffd17 	ldw	r2,-12(fp)
8113e354:	e0fffe0b 	ldhu	r3,-8(fp)
8113e358:	10c0020d 	sth	r3,8(r2)
8113e35c:	00000306 	br	8113e36c <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
8113e360:	e0bfff17 	ldw	r2,-4(fp)
8113e364:	00c01244 	movi	r3,73
8113e368:	10c00005 	stb	r3,0(r2)
8113e36c:	e0bffa17 	ldw	r2,-24(fp)
8113e370:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e374:	e0bffb17 	ldw	r2,-20(fp)
8113e378:	1001703a 	wrctl	status,r2
8113e37c:	00000106 	br	8113e384 <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113e380:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
8113e384:	e037883a 	mov	sp,fp
8113e388:	df000017 	ldw	fp,0(sp)
8113e38c:	dec00104 	addi	sp,sp,4
8113e390:	f800283a 	ret

8113e394 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
8113e394:	defff104 	addi	sp,sp,-60
8113e398:	de00012e 	bgeu	sp,et,8113e3a0 <OSTaskChangePrio+0xc>
8113e39c:	003b68fa 	trap	3
8113e3a0:	dfc00e15 	stw	ra,56(sp)
8113e3a4:	df000d15 	stw	fp,52(sp)
8113e3a8:	df000d04 	addi	fp,sp,52
8113e3ac:	2007883a 	mov	r3,r4
8113e3b0:	2805883a 	mov	r2,r5
8113e3b4:	e0fffe05 	stb	r3,-8(fp)
8113e3b8:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
8113e3bc:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
8113e3c0:	e0bffe03 	ldbu	r2,-8(fp)
8113e3c4:	10800ab0 	cmpltui	r2,r2,42
8113e3c8:	1000051e 	bne	r2,zero,8113e3e0 <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
8113e3cc:	e0bffe03 	ldbu	r2,-8(fp)
8113e3d0:	10803fe0 	cmpeqi	r2,r2,255
8113e3d4:	1000021e 	bne	r2,zero,8113e3e0 <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
8113e3d8:	00800a84 	movi	r2,42
8113e3dc:	00012606 	br	8113e878 <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
8113e3e0:	e0bfff03 	ldbu	r2,-4(fp)
8113e3e4:	10800ab0 	cmpltui	r2,r2,42
8113e3e8:	1000021e 	bne	r2,zero,8113e3f4 <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
8113e3ec:	00800a84 	movi	r2,42
8113e3f0:	00012106 	br	8113e878 <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e3f4:	0005303a 	rdctl	r2,status
8113e3f8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e3fc:	e0fffd17 	ldw	r3,-12(fp)
8113e400:	00bfff84 	movi	r2,-2
8113e404:	1884703a 	and	r2,r3,r2
8113e408:	1001703a 	wrctl	status,r2
  
  return context;
8113e40c:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113e410:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
8113e414:	e0ffff03 	ldbu	r3,-4(fp)
8113e418:	00a045f4 	movhi	r2,33047
8113e41c:	10af6e04 	addi	r2,r2,-16968
8113e420:	18c7883a 	add	r3,r3,r3
8113e424:	18c7883a 	add	r3,r3,r3
8113e428:	10c5883a 	add	r2,r2,r3
8113e42c:	10800017 	ldw	r2,0(r2)
8113e430:	10000626 	beq	r2,zero,8113e44c <OSTaskChangePrio+0xb8>
8113e434:	e0bff517 	ldw	r2,-44(fp)
8113e438:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e43c:	e0bff617 	ldw	r2,-40(fp)
8113e440:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
8113e444:	00800a04 	movi	r2,40
8113e448:	00010b06 	br	8113e878 <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
8113e44c:	e0bffe03 	ldbu	r2,-8(fp)
8113e450:	10803fd8 	cmpnei	r2,r2,255
8113e454:	1000031e 	bne	r2,zero,8113e464 <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
8113e458:	d0a0a117 	ldw	r2,-32124(gp)
8113e45c:	10800c83 	ldbu	r2,50(r2)
8113e460:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
8113e464:	e0fffe03 	ldbu	r3,-8(fp)
8113e468:	00a045f4 	movhi	r2,33047
8113e46c:	10af6e04 	addi	r2,r2,-16968
8113e470:	18c7883a 	add	r3,r3,r3
8113e474:	18c7883a 	add	r3,r3,r3
8113e478:	10c5883a 	add	r2,r2,r3
8113e47c:	10800017 	ldw	r2,0(r2)
8113e480:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
8113e484:	e0bff817 	ldw	r2,-32(fp)
8113e488:	1000061e 	bne	r2,zero,8113e4a4 <OSTaskChangePrio+0x110>
8113e48c:	e0bff517 	ldw	r2,-44(fp)
8113e490:	e0bff715 	stw	r2,-36(fp)
8113e494:	e0bff717 	ldw	r2,-36(fp)
8113e498:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
8113e49c:	00800a44 	movi	r2,41
8113e4a0:	0000f506 	br	8113e878 <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
8113e4a4:	e0bff817 	ldw	r2,-32(fp)
8113e4a8:	10800058 	cmpnei	r2,r2,1
8113e4ac:	1000061e 	bne	r2,zero,8113e4c8 <OSTaskChangePrio+0x134>
8113e4b0:	e0bff517 	ldw	r2,-44(fp)
8113e4b4:	e0bff915 	stw	r2,-28(fp)
8113e4b8:	e0bff917 	ldw	r2,-28(fp)
8113e4bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
8113e4c0:	008010c4 	movi	r2,67
8113e4c4:	0000ec06 	br	8113e878 <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
8113e4c8:	e0bfff03 	ldbu	r2,-4(fp)
8113e4cc:	1004d0fa 	srli	r2,r2,3
8113e4d0:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
8113e4d4:	e0bfff03 	ldbu	r2,-4(fp)
8113e4d8:	108001cc 	andi	r2,r2,7
8113e4dc:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
8113e4e0:	e0bffb03 	ldbu	r2,-20(fp)
8113e4e4:	00c00044 	movi	r3,1
8113e4e8:	1884983a 	sll	r2,r3,r2
8113e4ec:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
8113e4f0:	e0bffb43 	ldbu	r2,-19(fp)
8113e4f4:	00c00044 	movi	r3,1
8113e4f8:	1884983a 	sll	r2,r3,r2
8113e4fc:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
8113e500:	e0fffe03 	ldbu	r3,-8(fp)
8113e504:	00a045f4 	movhi	r2,33047
8113e508:	10af6e04 	addi	r2,r2,-16968
8113e50c:	18c7883a 	add	r3,r3,r3
8113e510:	18c7883a 	add	r3,r3,r3
8113e514:	10c5883a 	add	r2,r2,r3
8113e518:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
8113e51c:	e0ffff03 	ldbu	r3,-4(fp)
8113e520:	00a045f4 	movhi	r2,33047
8113e524:	10af6e04 	addi	r2,r2,-16968
8113e528:	18c7883a 	add	r3,r3,r3
8113e52c:	18c7883a 	add	r3,r3,r3
8113e530:	10c5883a 	add	r2,r2,r3
8113e534:	e0fff817 	ldw	r3,-32(fp)
8113e538:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
8113e53c:	e0bff817 	ldw	r2,-32(fp)
8113e540:	10800d03 	ldbu	r2,52(r2)
8113e544:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
8113e548:	e0bff817 	ldw	r2,-32(fp)
8113e54c:	10800d83 	ldbu	r2,54(r2)
8113e550:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
8113e554:	e0bff817 	ldw	r2,-32(fp)
8113e558:	10800d43 	ldbu	r2,53(r2)
8113e55c:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
8113e560:	e0fffc03 	ldbu	r3,-16(fp)
8113e564:	d0a09d44 	addi	r2,gp,-32139
8113e568:	1885883a 	add	r2,r3,r2
8113e56c:	10c00003 	ldbu	r3,0(r2)
8113e570:	e0bffc83 	ldbu	r2,-14(fp)
8113e574:	1884703a 	and	r2,r3,r2
8113e578:	10803fcc 	andi	r2,r2,255
8113e57c:	10002826 	beq	r2,zero,8113e620 <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
8113e580:	e0fffc03 	ldbu	r3,-16(fp)
8113e584:	e13ffc03 	ldbu	r4,-16(fp)
8113e588:	d0a09d44 	addi	r2,gp,-32139
8113e58c:	2085883a 	add	r2,r4,r2
8113e590:	10800003 	ldbu	r2,0(r2)
8113e594:	1009883a 	mov	r4,r2
8113e598:	e0bffc83 	ldbu	r2,-14(fp)
8113e59c:	0084303a 	nor	r2,zero,r2
8113e5a0:	2084703a 	and	r2,r4,r2
8113e5a4:	1009883a 	mov	r4,r2
8113e5a8:	d0a09d44 	addi	r2,gp,-32139
8113e5ac:	1885883a 	add	r2,r3,r2
8113e5b0:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
8113e5b4:	e0fffc03 	ldbu	r3,-16(fp)
8113e5b8:	d0a09d44 	addi	r2,gp,-32139
8113e5bc:	1885883a 	add	r2,r3,r2
8113e5c0:	10800003 	ldbu	r2,0(r2)
8113e5c4:	10803fcc 	andi	r2,r2,255
8113e5c8:	1000061e 	bne	r2,zero,8113e5e4 <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
8113e5cc:	e0bffc43 	ldbu	r2,-15(fp)
8113e5d0:	0084303a 	nor	r2,zero,r2
8113e5d4:	1007883a 	mov	r3,r2
8113e5d8:	d0a09d03 	ldbu	r2,-32140(gp)
8113e5dc:	1884703a 	and	r2,r3,r2
8113e5e0:	d0a09d05 	stb	r2,-32140(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
8113e5e4:	d0e09d03 	ldbu	r3,-32140(gp)
8113e5e8:	e0bffb83 	ldbu	r2,-18(fp)
8113e5ec:	1884b03a 	or	r2,r3,r2
8113e5f0:	d0a09d05 	stb	r2,-32140(gp)
         OSRdyTbl[y_new] |= bitx_new;
8113e5f4:	e0fffb03 	ldbu	r3,-20(fp)
8113e5f8:	e13ffb03 	ldbu	r4,-20(fp)
8113e5fc:	d0a09d44 	addi	r2,gp,-32139
8113e600:	2085883a 	add	r2,r4,r2
8113e604:	11000003 	ldbu	r4,0(r2)
8113e608:	e0bffbc3 	ldbu	r2,-17(fp)
8113e60c:	2084b03a 	or	r2,r4,r2
8113e610:	1009883a 	mov	r4,r2
8113e614:	d0a09d44 	addi	r2,gp,-32139
8113e618:	1885883a 	add	r2,r3,r2
8113e61c:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
8113e620:	e0bff817 	ldw	r2,-32(fp)
8113e624:	10800717 	ldw	r2,28(r2)
8113e628:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
8113e62c:	e0bff317 	ldw	r2,-52(fp)
8113e630:	10003326 	beq	r2,zero,8113e700 <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
8113e634:	e0bffc03 	ldbu	r2,-16(fp)
8113e638:	e0fffc03 	ldbu	r3,-16(fp)
8113e63c:	e13ff317 	ldw	r4,-52(fp)
8113e640:	20c7883a 	add	r3,r4,r3
8113e644:	18c002c4 	addi	r3,r3,11
8113e648:	18c00003 	ldbu	r3,0(r3)
8113e64c:	1809883a 	mov	r4,r3
8113e650:	e0fffc83 	ldbu	r3,-14(fp)
8113e654:	00c6303a 	nor	r3,zero,r3
8113e658:	20c6703a 	and	r3,r4,r3
8113e65c:	1809883a 	mov	r4,r3
8113e660:	e0fff317 	ldw	r3,-52(fp)
8113e664:	1885883a 	add	r2,r3,r2
8113e668:	108002c4 	addi	r2,r2,11
8113e66c:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
8113e670:	e0bffc03 	ldbu	r2,-16(fp)
8113e674:	e0fff317 	ldw	r3,-52(fp)
8113e678:	1885883a 	add	r2,r3,r2
8113e67c:	108002c4 	addi	r2,r2,11
8113e680:	10800003 	ldbu	r2,0(r2)
8113e684:	10803fcc 	andi	r2,r2,255
8113e688:	1000091e 	bne	r2,zero,8113e6b0 <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
8113e68c:	e0bff317 	ldw	r2,-52(fp)
8113e690:	10800283 	ldbu	r2,10(r2)
8113e694:	1007883a 	mov	r3,r2
8113e698:	e0bffc43 	ldbu	r2,-15(fp)
8113e69c:	0084303a 	nor	r2,zero,r2
8113e6a0:	1884703a 	and	r2,r3,r2
8113e6a4:	1007883a 	mov	r3,r2
8113e6a8:	e0bff317 	ldw	r2,-52(fp)
8113e6ac:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
8113e6b0:	e0bff317 	ldw	r2,-52(fp)
8113e6b4:	10c00283 	ldbu	r3,10(r2)
8113e6b8:	e0bffb83 	ldbu	r2,-18(fp)
8113e6bc:	1884b03a 	or	r2,r3,r2
8113e6c0:	1007883a 	mov	r3,r2
8113e6c4:	e0bff317 	ldw	r2,-52(fp)
8113e6c8:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
8113e6cc:	e0bffb03 	ldbu	r2,-20(fp)
8113e6d0:	e0fffb03 	ldbu	r3,-20(fp)
8113e6d4:	e13ff317 	ldw	r4,-52(fp)
8113e6d8:	20c7883a 	add	r3,r4,r3
8113e6dc:	18c002c4 	addi	r3,r3,11
8113e6e0:	19000003 	ldbu	r4,0(r3)
8113e6e4:	e0fffbc3 	ldbu	r3,-17(fp)
8113e6e8:	20c6b03a 	or	r3,r4,r3
8113e6ec:	1809883a 	mov	r4,r3
8113e6f0:	e0fff317 	ldw	r3,-52(fp)
8113e6f4:	1885883a 	add	r2,r3,r2
8113e6f8:	108002c4 	addi	r2,r2,11
8113e6fc:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
8113e700:	e0bff817 	ldw	r2,-32(fp)
8113e704:	10800817 	ldw	r2,32(r2)
8113e708:	10004226 	beq	r2,zero,8113e814 <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
8113e70c:	e0bff817 	ldw	r2,-32(fp)
8113e710:	10800817 	ldw	r2,32(r2)
8113e714:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
8113e718:	e0bff417 	ldw	r2,-48(fp)
8113e71c:	10800017 	ldw	r2,0(r2)
8113e720:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
8113e724:	00003906 	br	8113e80c <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
8113e728:	e0bffc03 	ldbu	r2,-16(fp)
8113e72c:	e0fffc03 	ldbu	r3,-16(fp)
8113e730:	e13ff317 	ldw	r4,-52(fp)
8113e734:	20c7883a 	add	r3,r4,r3
8113e738:	18c002c4 	addi	r3,r3,11
8113e73c:	18c00003 	ldbu	r3,0(r3)
8113e740:	1809883a 	mov	r4,r3
8113e744:	e0fffc83 	ldbu	r3,-14(fp)
8113e748:	00c6303a 	nor	r3,zero,r3
8113e74c:	20c6703a 	and	r3,r4,r3
8113e750:	1809883a 	mov	r4,r3
8113e754:	e0fff317 	ldw	r3,-52(fp)
8113e758:	1885883a 	add	r2,r3,r2
8113e75c:	108002c4 	addi	r2,r2,11
8113e760:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
8113e764:	e0bffc03 	ldbu	r2,-16(fp)
8113e768:	e0fff317 	ldw	r3,-52(fp)
8113e76c:	1885883a 	add	r2,r3,r2
8113e770:	108002c4 	addi	r2,r2,11
8113e774:	10800003 	ldbu	r2,0(r2)
8113e778:	10803fcc 	andi	r2,r2,255
8113e77c:	1000091e 	bne	r2,zero,8113e7a4 <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
8113e780:	e0bff317 	ldw	r2,-52(fp)
8113e784:	10800283 	ldbu	r2,10(r2)
8113e788:	1007883a 	mov	r3,r2
8113e78c:	e0bffc43 	ldbu	r2,-15(fp)
8113e790:	0084303a 	nor	r2,zero,r2
8113e794:	1884703a 	and	r2,r3,r2
8113e798:	1007883a 	mov	r3,r2
8113e79c:	e0bff317 	ldw	r2,-52(fp)
8113e7a0:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
8113e7a4:	e0bff317 	ldw	r2,-52(fp)
8113e7a8:	10c00283 	ldbu	r3,10(r2)
8113e7ac:	e0bffb83 	ldbu	r2,-18(fp)
8113e7b0:	1884b03a 	or	r2,r3,r2
8113e7b4:	1007883a 	mov	r3,r2
8113e7b8:	e0bff317 	ldw	r2,-52(fp)
8113e7bc:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
8113e7c0:	e0bffb03 	ldbu	r2,-20(fp)
8113e7c4:	e0fffb03 	ldbu	r3,-20(fp)
8113e7c8:	e13ff317 	ldw	r4,-52(fp)
8113e7cc:	20c7883a 	add	r3,r4,r3
8113e7d0:	18c002c4 	addi	r3,r3,11
8113e7d4:	19000003 	ldbu	r4,0(r3)
8113e7d8:	e0fffbc3 	ldbu	r3,-17(fp)
8113e7dc:	20c6b03a 	or	r3,r4,r3
8113e7e0:	1809883a 	mov	r4,r3
8113e7e4:	e0fff317 	ldw	r3,-52(fp)
8113e7e8:	1885883a 	add	r2,r3,r2
8113e7ec:	108002c4 	addi	r2,r2,11
8113e7f0:	11000005 	stb	r4,0(r2)
            pevents++;
8113e7f4:	e0bff417 	ldw	r2,-48(fp)
8113e7f8:	10800104 	addi	r2,r2,4
8113e7fc:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
8113e800:	e0bff417 	ldw	r2,-48(fp)
8113e804:	10800017 	ldw	r2,0(r2)
8113e808:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
8113e80c:	e0bff317 	ldw	r2,-52(fp)
8113e810:	103fc51e 	bne	r2,zero,8113e728 <__reset+0xfb11e728>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
8113e814:	e0bff817 	ldw	r2,-32(fp)
8113e818:	e0ffff03 	ldbu	r3,-4(fp)
8113e81c:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
8113e820:	e0bff817 	ldw	r2,-32(fp)
8113e824:	e0fffb03 	ldbu	r3,-20(fp)
8113e828:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
8113e82c:	e0bff817 	ldw	r2,-32(fp)
8113e830:	e0fffb43 	ldbu	r3,-19(fp)
8113e834:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
8113e838:	e0bff817 	ldw	r2,-32(fp)
8113e83c:	e0fffb83 	ldbu	r3,-18(fp)
8113e840:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
8113e844:	e0bff817 	ldw	r2,-32(fp)
8113e848:	e0fffbc3 	ldbu	r3,-17(fp)
8113e84c:	10c00d45 	stb	r3,53(r2)
8113e850:	e0bff517 	ldw	r2,-44(fp)
8113e854:	e0bffa15 	stw	r2,-24(fp)
8113e858:	e0bffa17 	ldw	r2,-24(fp)
8113e85c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113e860:	d0a09003 	ldbu	r2,-32192(gp)
8113e864:	10803fcc 	andi	r2,r2,255
8113e868:	10800058 	cmpnei	r2,r2,1
8113e86c:	1000011e 	bne	r2,zero,8113e874 <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
8113e870:	1138e240 	call	81138e24 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113e874:	0005883a 	mov	r2,zero
}
8113e878:	e037883a 	mov	sp,fp
8113e87c:	dfc00117 	ldw	ra,4(sp)
8113e880:	df000017 	ldw	fp,0(sp)
8113e884:	dec00204 	addi	sp,sp,8
8113e888:	f800283a 	ret

8113e88c <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
8113e88c:	deffee04 	addi	sp,sp,-72
8113e890:	de00012e 	bgeu	sp,et,8113e898 <OSTaskCreate+0xc>
8113e894:	003b68fa 	trap	3
8113e898:	dfc01115 	stw	ra,68(sp)
8113e89c:	df001015 	stw	fp,64(sp)
8113e8a0:	df001004 	addi	fp,sp,64
8113e8a4:	e13ffc15 	stw	r4,-16(fp)
8113e8a8:	e17ffd15 	stw	r5,-12(fp)
8113e8ac:	e1bffe15 	stw	r6,-8(fp)
8113e8b0:	3805883a 	mov	r2,r7
8113e8b4:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113e8b8:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113e8bc:	e0bfff03 	ldbu	r2,-4(fp)
8113e8c0:	10800af0 	cmpltui	r2,r2,43
8113e8c4:	1000021e 	bne	r2,zero,8113e8d0 <OSTaskCreate+0x44>
        return (OS_ERR_PRIO_INVALID);
8113e8c8:	00800a84 	movi	r2,42
8113e8cc:	00005706 	br	8113ea2c <OSTaskCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e8d0:	0005303a 	rdctl	r2,status
8113e8d4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e8d8:	e0fffb17 	ldw	r3,-20(fp)
8113e8dc:	00bfff84 	movi	r2,-2
8113e8e0:	1884703a 	and	r2,r3,r2
8113e8e4:	1001703a 	wrctl	status,r2
  
  return context;
8113e8e8:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113e8ec:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113e8f0:	d0a0a003 	ldbu	r2,-32128(gp)
8113e8f4:	10803fcc 	andi	r2,r2,255
8113e8f8:	10000626 	beq	r2,zero,8113e914 <OSTaskCreate+0x88>
8113e8fc:	e0bff317 	ldw	r2,-52(fp)
8113e900:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e904:	e0bff417 	ldw	r2,-48(fp)
8113e908:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113e90c:	00800f04 	movi	r2,60
8113e910:	00004606 	br	8113ea2c <OSTaskCreate+0x1a0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113e914:	e0ffff03 	ldbu	r3,-4(fp)
8113e918:	00a045f4 	movhi	r2,33047
8113e91c:	10af6e04 	addi	r2,r2,-16968
8113e920:	18c7883a 	add	r3,r3,r3
8113e924:	18c7883a 	add	r3,r3,r3
8113e928:	10c5883a 	add	r2,r2,r3
8113e92c:	10800017 	ldw	r2,0(r2)
8113e930:	1000391e 	bne	r2,zero,8113ea18 <OSTaskCreate+0x18c>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113e934:	e0ffff03 	ldbu	r3,-4(fp)
8113e938:	00a045f4 	movhi	r2,33047
8113e93c:	10af6e04 	addi	r2,r2,-16968
8113e940:	18c7883a 	add	r3,r3,r3
8113e944:	18c7883a 	add	r3,r3,r3
8113e948:	10c5883a 	add	r2,r2,r3
8113e94c:	00c00044 	movi	r3,1
8113e950:	10c00015 	stw	r3,0(r2)
8113e954:	e0bff317 	ldw	r2,-52(fp)
8113e958:	e0bff515 	stw	r2,-44(fp)
8113e95c:	e0bff517 	ldw	r2,-44(fp)
8113e960:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
8113e964:	000f883a 	mov	r7,zero
8113e968:	e1bffe17 	ldw	r6,-8(fp)
8113e96c:	e17ffd17 	ldw	r5,-12(fp)
8113e970:	e13ffc17 	ldw	r4,-16(fp)
8113e974:	1149f340 	call	81149f34 <OSTaskStkInit>
8113e978:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
8113e97c:	e0bfff03 	ldbu	r2,-4(fp)
8113e980:	d8000215 	stw	zero,8(sp)
8113e984:	d8000115 	stw	zero,4(sp)
8113e988:	d8000015 	stw	zero,0(sp)
8113e98c:	000f883a 	mov	r7,zero
8113e990:	000d883a 	mov	r6,zero
8113e994:	e17ff717 	ldw	r5,-36(fp)
8113e998:	1009883a 	mov	r4,r2
8113e99c:	113926c0 	call	8113926c <OS_TCBInit>
8113e9a0:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
8113e9a4:	e0bff803 	ldbu	r2,-32(fp)
8113e9a8:	1000061e 	bne	r2,zero,8113e9c4 <OSTaskCreate+0x138>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
8113e9ac:	d0a09003 	ldbu	r2,-32192(gp)
8113e9b0:	10803fcc 	andi	r2,r2,255
8113e9b4:	10800058 	cmpnei	r2,r2,1
8113e9b8:	1000151e 	bne	r2,zero,8113ea10 <OSTaskCreate+0x184>
                OS_Sched();
8113e9bc:	1138e240 	call	81138e24 <OS_Sched>
8113e9c0:	00001306 	br	8113ea10 <OSTaskCreate+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e9c4:	0005303a 	rdctl	r2,status
8113e9c8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e9cc:	e0fffa17 	ldw	r3,-24(fp)
8113e9d0:	00bfff84 	movi	r2,-2
8113e9d4:	1884703a 	and	r2,r3,r2
8113e9d8:	1001703a 	wrctl	status,r2
  
  return context;
8113e9dc:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113e9e0:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
8113e9e4:	e0ffff03 	ldbu	r3,-4(fp)
8113e9e8:	00a045f4 	movhi	r2,33047
8113e9ec:	10af6e04 	addi	r2,r2,-16968
8113e9f0:	18c7883a 	add	r3,r3,r3
8113e9f4:	18c7883a 	add	r3,r3,r3
8113e9f8:	10c5883a 	add	r2,r2,r3
8113e9fc:	10000015 	stw	zero,0(r2)
8113ea00:	e0bff317 	ldw	r2,-52(fp)
8113ea04:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ea08:	e0bff617 	ldw	r2,-40(fp)
8113ea0c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113ea10:	e0bff803 	ldbu	r2,-32(fp)
8113ea14:	00000506 	br	8113ea2c <OSTaskCreate+0x1a0>
8113ea18:	e0bff317 	ldw	r2,-52(fp)
8113ea1c:	e0bff915 	stw	r2,-28(fp)
8113ea20:	e0bff917 	ldw	r2,-28(fp)
8113ea24:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113ea28:	00800a04 	movi	r2,40
}
8113ea2c:	e037883a 	mov	sp,fp
8113ea30:	dfc00117 	ldw	ra,4(sp)
8113ea34:	df000017 	ldw	fp,0(sp)
8113ea38:	dec00204 	addi	sp,sp,8
8113ea3c:	f800283a 	ret

8113ea40 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
8113ea40:	deffec04 	addi	sp,sp,-80
8113ea44:	de00012e 	bgeu	sp,et,8113ea4c <OSTaskCreateExt+0xc>
8113ea48:	003b68fa 	trap	3
8113ea4c:	dfc01315 	stw	ra,76(sp)
8113ea50:	df001215 	stw	fp,72(sp)
8113ea54:	df001204 	addi	fp,sp,72
8113ea58:	e13ffa15 	stw	r4,-24(fp)
8113ea5c:	e17ffb15 	stw	r5,-20(fp)
8113ea60:	e1bffc15 	stw	r6,-16(fp)
8113ea64:	3809883a 	mov	r4,r7
8113ea68:	e0c00217 	ldw	r3,8(fp)
8113ea6c:	e0800617 	ldw	r2,24(fp)
8113ea70:	e13ffd05 	stb	r4,-12(fp)
8113ea74:	e0fffe0d 	sth	r3,-8(fp)
8113ea78:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113ea7c:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113ea80:	e0bffd03 	ldbu	r2,-12(fp)
8113ea84:	10800af0 	cmpltui	r2,r2,43
8113ea88:	1000021e 	bne	r2,zero,8113ea94 <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
8113ea8c:	00800a84 	movi	r2,42
8113ea90:	00006106 	br	8113ec18 <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ea94:	0005303a 	rdctl	r2,status
8113ea98:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ea9c:	e0fff917 	ldw	r3,-28(fp)
8113eaa0:	00bfff84 	movi	r2,-2
8113eaa4:	1884703a 	and	r2,r3,r2
8113eaa8:	1001703a 	wrctl	status,r2
  
  return context;
8113eaac:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113eab0:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113eab4:	d0a0a003 	ldbu	r2,-32128(gp)
8113eab8:	10803fcc 	andi	r2,r2,255
8113eabc:	10000626 	beq	r2,zero,8113ead8 <OSTaskCreateExt+0x98>
8113eac0:	e0bff117 	ldw	r2,-60(fp)
8113eac4:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113eac8:	e0bff217 	ldw	r2,-56(fp)
8113eacc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113ead0:	00800f04 	movi	r2,60
8113ead4:	00005006 	br	8113ec18 <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113ead8:	e0fffd03 	ldbu	r3,-12(fp)
8113eadc:	00a045f4 	movhi	r2,33047
8113eae0:	10af6e04 	addi	r2,r2,-16968
8113eae4:	18c7883a 	add	r3,r3,r3
8113eae8:	18c7883a 	add	r3,r3,r3
8113eaec:	10c5883a 	add	r2,r2,r3
8113eaf0:	10800017 	ldw	r2,0(r2)
8113eaf4:	1000431e 	bne	r2,zero,8113ec04 <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113eaf8:	e0fffd03 	ldbu	r3,-12(fp)
8113eafc:	00a045f4 	movhi	r2,33047
8113eb00:	10af6e04 	addi	r2,r2,-16968
8113eb04:	18c7883a 	add	r3,r3,r3
8113eb08:	18c7883a 	add	r3,r3,r3
8113eb0c:	10c5883a 	add	r2,r2,r3
8113eb10:	00c00044 	movi	r3,1
8113eb14:	10c00015 	stw	r3,0(r2)
8113eb18:	e0bff117 	ldw	r2,-60(fp)
8113eb1c:	e0bff315 	stw	r2,-52(fp)
8113eb20:	e0bff317 	ldw	r2,-52(fp)
8113eb24:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
8113eb28:	e0bfff0b 	ldhu	r2,-4(fp)
8113eb2c:	100d883a 	mov	r6,r2
8113eb30:	e1400417 	ldw	r5,16(fp)
8113eb34:	e1000317 	ldw	r4,12(fp)
8113eb38:	113fae80 	call	8113fae8 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
8113eb3c:	e0bfff0b 	ldhu	r2,-4(fp)
8113eb40:	100f883a 	mov	r7,r2
8113eb44:	e1bffc17 	ldw	r6,-16(fp)
8113eb48:	e17ffb17 	ldw	r5,-20(fp)
8113eb4c:	e13ffa17 	ldw	r4,-24(fp)
8113eb50:	1149f340 	call	81149f34 <OSTaskStkInit>
8113eb54:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
8113eb58:	e0fffd03 	ldbu	r3,-12(fp)
8113eb5c:	e13ffe0b 	ldhu	r4,-8(fp)
8113eb60:	e0bfff0b 	ldhu	r2,-4(fp)
8113eb64:	d8800215 	stw	r2,8(sp)
8113eb68:	e0800517 	ldw	r2,20(fp)
8113eb6c:	d8800115 	stw	r2,4(sp)
8113eb70:	e0800417 	ldw	r2,16(fp)
8113eb74:	d8800015 	stw	r2,0(sp)
8113eb78:	200f883a 	mov	r7,r4
8113eb7c:	e1800317 	ldw	r6,12(fp)
8113eb80:	e17ff517 	ldw	r5,-44(fp)
8113eb84:	1809883a 	mov	r4,r3
8113eb88:	113926c0 	call	8113926c <OS_TCBInit>
8113eb8c:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
8113eb90:	e0bff603 	ldbu	r2,-40(fp)
8113eb94:	1000061e 	bne	r2,zero,8113ebb0 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
8113eb98:	d0a09003 	ldbu	r2,-32192(gp)
8113eb9c:	10803fcc 	andi	r2,r2,255
8113eba0:	10800058 	cmpnei	r2,r2,1
8113eba4:	1000151e 	bne	r2,zero,8113ebfc <OSTaskCreateExt+0x1bc>
                OS_Sched();
8113eba8:	1138e240 	call	81138e24 <OS_Sched>
8113ebac:	00001306 	br	8113ebfc <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ebb0:	0005303a 	rdctl	r2,status
8113ebb4:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ebb8:	e0fff817 	ldw	r3,-32(fp)
8113ebbc:	00bfff84 	movi	r2,-2
8113ebc0:	1884703a 	and	r2,r3,r2
8113ebc4:	1001703a 	wrctl	status,r2
  
  return context;
8113ebc8:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113ebcc:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
8113ebd0:	e0fffd03 	ldbu	r3,-12(fp)
8113ebd4:	00a045f4 	movhi	r2,33047
8113ebd8:	10af6e04 	addi	r2,r2,-16968
8113ebdc:	18c7883a 	add	r3,r3,r3
8113ebe0:	18c7883a 	add	r3,r3,r3
8113ebe4:	10c5883a 	add	r2,r2,r3
8113ebe8:	10000015 	stw	zero,0(r2)
8113ebec:	e0bff117 	ldw	r2,-60(fp)
8113ebf0:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ebf4:	e0bff417 	ldw	r2,-48(fp)
8113ebf8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113ebfc:	e0bff603 	ldbu	r2,-40(fp)
8113ec00:	00000506 	br	8113ec18 <OSTaskCreateExt+0x1d8>
8113ec04:	e0bff117 	ldw	r2,-60(fp)
8113ec08:	e0bff715 	stw	r2,-36(fp)
8113ec0c:	e0bff717 	ldw	r2,-36(fp)
8113ec10:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113ec14:	00800a04 	movi	r2,40
}
8113ec18:	e037883a 	mov	sp,fp
8113ec1c:	dfc00117 	ldw	ra,4(sp)
8113ec20:	df000017 	ldw	fp,0(sp)
8113ec24:	dec00204 	addi	sp,sp,8
8113ec28:	f800283a 	ret

8113ec2c <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
8113ec2c:	defff404 	addi	sp,sp,-48
8113ec30:	de00012e 	bgeu	sp,et,8113ec38 <OSTaskDel+0xc>
8113ec34:	003b68fa 	trap	3
8113ec38:	dfc00b15 	stw	ra,44(sp)
8113ec3c:	df000a15 	stw	fp,40(sp)
8113ec40:	df000a04 	addi	fp,sp,40
8113ec44:	2005883a 	mov	r2,r4
8113ec48:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
8113ec4c:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
8113ec50:	d0a0a003 	ldbu	r2,-32128(gp)
8113ec54:	10803fcc 	andi	r2,r2,255
8113ec58:	10000226 	beq	r2,zero,8113ec64 <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
8113ec5c:	00801004 	movi	r2,64
8113ec60:	0000c006 	br	8113ef64 <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
8113ec64:	e0bfff03 	ldbu	r2,-4(fp)
8113ec68:	10800a98 	cmpnei	r2,r2,42
8113ec6c:	1000021e 	bne	r2,zero,8113ec78 <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
8113ec70:	00800f84 	movi	r2,62
8113ec74:	0000bb06 	br	8113ef64 <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
8113ec78:	e0bfff03 	ldbu	r2,-4(fp)
8113ec7c:	10800ab0 	cmpltui	r2,r2,42
8113ec80:	1000051e 	bne	r2,zero,8113ec98 <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
8113ec84:	e0bfff03 	ldbu	r2,-4(fp)
8113ec88:	10803fe0 	cmpeqi	r2,r2,255
8113ec8c:	1000021e 	bne	r2,zero,8113ec98 <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
8113ec90:	00800a84 	movi	r2,42
8113ec94:	0000b306 	br	8113ef64 <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ec98:	0005303a 	rdctl	r2,status
8113ec9c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113eca0:	e0fffe17 	ldw	r3,-8(fp)
8113eca4:	00bfff84 	movi	r2,-2
8113eca8:	1884703a 	and	r2,r3,r2
8113ecac:	1001703a 	wrctl	status,r2
  
  return context;
8113ecb0:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
8113ecb4:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
8113ecb8:	e0bfff03 	ldbu	r2,-4(fp)
8113ecbc:	10803fd8 	cmpnei	r2,r2,255
8113ecc0:	1000031e 	bne	r2,zero,8113ecd0 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
8113ecc4:	d0a0a117 	ldw	r2,-32124(gp)
8113ecc8:	10800c83 	ldbu	r2,50(r2)
8113eccc:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113ecd0:	e0ffff03 	ldbu	r3,-4(fp)
8113ecd4:	00a045f4 	movhi	r2,33047
8113ecd8:	10af6e04 	addi	r2,r2,-16968
8113ecdc:	18c7883a 	add	r3,r3,r3
8113ece0:	18c7883a 	add	r3,r3,r3
8113ece4:	10c5883a 	add	r2,r2,r3
8113ece8:	10800017 	ldw	r2,0(r2)
8113ecec:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
8113ecf0:	e0bff817 	ldw	r2,-32(fp)
8113ecf4:	1000061e 	bne	r2,zero,8113ed10 <OSTaskDel+0xe4>
8113ecf8:	e0bff617 	ldw	r2,-40(fp)
8113ecfc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ed00:	e0bff717 	ldw	r2,-36(fp)
8113ed04:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113ed08:	008010c4 	movi	r2,67
8113ed0c:	00009506 	br	8113ef64 <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
8113ed10:	e0bff817 	ldw	r2,-32(fp)
8113ed14:	10800058 	cmpnei	r2,r2,1
8113ed18:	1000061e 	bne	r2,zero,8113ed34 <OSTaskDel+0x108>
8113ed1c:	e0bff617 	ldw	r2,-40(fp)
8113ed20:	e0bff915 	stw	r2,-28(fp)
8113ed24:	e0bff917 	ldw	r2,-28(fp)
8113ed28:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113ed2c:	00800f44 	movi	r2,61
8113ed30:	00008c06 	br	8113ef64 <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
8113ed34:	e0bff817 	ldw	r2,-32(fp)
8113ed38:	10800d03 	ldbu	r2,52(r2)
8113ed3c:	10c03fcc 	andi	r3,r2,255
8113ed40:	e0bff817 	ldw	r2,-32(fp)
8113ed44:	10800d03 	ldbu	r2,52(r2)
8113ed48:	11003fcc 	andi	r4,r2,255
8113ed4c:	d0a09d44 	addi	r2,gp,-32139
8113ed50:	2085883a 	add	r2,r4,r2
8113ed54:	10800003 	ldbu	r2,0(r2)
8113ed58:	1009883a 	mov	r4,r2
8113ed5c:	e0bff817 	ldw	r2,-32(fp)
8113ed60:	10800d43 	ldbu	r2,53(r2)
8113ed64:	0084303a 	nor	r2,zero,r2
8113ed68:	2084703a 	and	r2,r4,r2
8113ed6c:	1009883a 	mov	r4,r2
8113ed70:	d0a09d44 	addi	r2,gp,-32139
8113ed74:	1885883a 	add	r2,r3,r2
8113ed78:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
8113ed7c:	e0bff817 	ldw	r2,-32(fp)
8113ed80:	10800d03 	ldbu	r2,52(r2)
8113ed84:	10c03fcc 	andi	r3,r2,255
8113ed88:	d0a09d44 	addi	r2,gp,-32139
8113ed8c:	1885883a 	add	r2,r3,r2
8113ed90:	10800003 	ldbu	r2,0(r2)
8113ed94:	10803fcc 	andi	r2,r2,255
8113ed98:	1000071e 	bne	r2,zero,8113edb8 <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
8113ed9c:	e0bff817 	ldw	r2,-32(fp)
8113eda0:	10800d83 	ldbu	r2,54(r2)
8113eda4:	0084303a 	nor	r2,zero,r2
8113eda8:	1007883a 	mov	r3,r2
8113edac:	d0a09d03 	ldbu	r2,-32140(gp)
8113edb0:	1884703a 	and	r2,r3,r2
8113edb4:	d0a09d05 	stb	r2,-32140(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
8113edb8:	e0bff817 	ldw	r2,-32(fp)
8113edbc:	10800717 	ldw	r2,28(r2)
8113edc0:	10000526 	beq	r2,zero,8113edd8 <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
8113edc4:	e0bff817 	ldw	r2,-32(fp)
8113edc8:	10800717 	ldw	r2,28(r2)
8113edcc:	100b883a 	mov	r5,r2
8113edd0:	e13ff817 	ldw	r4,-32(fp)
8113edd4:	11387780 	call	81138778 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
8113edd8:	e0bff817 	ldw	r2,-32(fp)
8113eddc:	10800817 	ldw	r2,32(r2)
8113ede0:	10000526 	beq	r2,zero,8113edf8 <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8113ede4:	e0bff817 	ldw	r2,-32(fp)
8113ede8:	10800817 	ldw	r2,32(r2)
8113edec:	100b883a 	mov	r5,r2
8113edf0:	e13ff817 	ldw	r4,-32(fp)
8113edf4:	11388380 	call	81138838 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
8113edf8:	e0bff817 	ldw	r2,-32(fp)
8113edfc:	10800a17 	ldw	r2,40(r2)
8113ee00:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
8113ee04:	e0bffb17 	ldw	r2,-20(fp)
8113ee08:	10000226 	beq	r2,zero,8113ee14 <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
8113ee0c:	e13ffb17 	ldw	r4,-20(fp)
8113ee10:	113ae100 	call	8113ae10 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
8113ee14:	e0bff817 	ldw	r2,-32(fp)
8113ee18:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
8113ee1c:	e0bff817 	ldw	r2,-32(fp)
8113ee20:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8113ee24:	e0bff817 	ldw	r2,-32(fp)
8113ee28:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
8113ee2c:	d0a08e03 	ldbu	r2,-32200(gp)
8113ee30:	10803fcc 	andi	r2,r2,255
8113ee34:	10803fe0 	cmpeqi	r2,r2,255
8113ee38:	1000031e 	bne	r2,zero,8113ee48 <OSTaskDel+0x21c>
        OSLockNesting++;
8113ee3c:	d0a08e03 	ldbu	r2,-32200(gp)
8113ee40:	10800044 	addi	r2,r2,1
8113ee44:	d0a08e05 	stb	r2,-32200(gp)
8113ee48:	e0bff617 	ldw	r2,-40(fp)
8113ee4c:	e0bffd15 	stw	r2,-12(fp)
8113ee50:	e0bffd17 	ldw	r2,-12(fp)
8113ee54:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
8113ee58:	11383400 	call	81138340 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ee5c:	0005303a 	rdctl	r2,status
8113ee60:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ee64:	e0fffa17 	ldw	r3,-24(fp)
8113ee68:	00bfff84 	movi	r2,-2
8113ee6c:	1884703a 	and	r2,r3,r2
8113ee70:	1001703a 	wrctl	status,r2
  
  return context;
8113ee74:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
8113ee78:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
8113ee7c:	d0a08e03 	ldbu	r2,-32200(gp)
8113ee80:	10803fcc 	andi	r2,r2,255
8113ee84:	10000326 	beq	r2,zero,8113ee94 <OSTaskDel+0x268>
        OSLockNesting--;
8113ee88:	d0a08e03 	ldbu	r2,-32200(gp)
8113ee8c:	10bfffc4 	addi	r2,r2,-1
8113ee90:	d0a08e05 	stb	r2,-32200(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
8113ee94:	e13ff817 	ldw	r4,-32(fp)
8113ee98:	114a0c40 	call	8114a0c4 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
8113ee9c:	d0a09943 	ldbu	r2,-32155(gp)
8113eea0:	10bfffc4 	addi	r2,r2,-1
8113eea4:	d0a09945 	stb	r2,-32155(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
8113eea8:	e0ffff03 	ldbu	r3,-4(fp)
8113eeac:	00a045f4 	movhi	r2,33047
8113eeb0:	10af6e04 	addi	r2,r2,-16968
8113eeb4:	18c7883a 	add	r3,r3,r3
8113eeb8:	18c7883a 	add	r3,r3,r3
8113eebc:	10c5883a 	add	r2,r2,r3
8113eec0:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
8113eec4:	e0bff817 	ldw	r2,-32(fp)
8113eec8:	10800617 	ldw	r2,24(r2)
8113eecc:	1000071e 	bne	r2,zero,8113eeec <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
8113eed0:	e0bff817 	ldw	r2,-32(fp)
8113eed4:	10800517 	ldw	r2,20(r2)
8113eed8:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
8113eedc:	e0bff817 	ldw	r2,-32(fp)
8113eee0:	10800517 	ldw	r2,20(r2)
8113eee4:	d0a09315 	stw	r2,-32180(gp)
8113eee8:	00000a06 	br	8113ef14 <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
8113eeec:	e0bff817 	ldw	r2,-32(fp)
8113eef0:	10800617 	ldw	r2,24(r2)
8113eef4:	e0fff817 	ldw	r3,-32(fp)
8113eef8:	18c00517 	ldw	r3,20(r3)
8113eefc:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
8113ef00:	e0bff817 	ldw	r2,-32(fp)
8113ef04:	10800517 	ldw	r2,20(r2)
8113ef08:	e0fff817 	ldw	r3,-32(fp)
8113ef0c:	18c00617 	ldw	r3,24(r3)
8113ef10:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
8113ef14:	d0e09817 	ldw	r3,-32160(gp)
8113ef18:	e0bff817 	ldw	r2,-32(fp)
8113ef1c:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
8113ef20:	e0bff817 	ldw	r2,-32(fp)
8113ef24:	d0a09815 	stw	r2,-32160(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
8113ef28:	e0bff817 	ldw	r2,-32(fp)
8113ef2c:	00c00fc4 	movi	r3,63
8113ef30:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8113ef34:	e0bff817 	ldw	r2,-32(fp)
8113ef38:	10001345 	stb	zero,77(r2)
8113ef3c:	e0bff617 	ldw	r2,-40(fp)
8113ef40:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ef44:	e0bffc17 	ldw	r2,-16(fp)
8113ef48:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113ef4c:	d0a09003 	ldbu	r2,-32192(gp)
8113ef50:	10803fcc 	andi	r2,r2,255
8113ef54:	10800058 	cmpnei	r2,r2,1
8113ef58:	1000011e 	bne	r2,zero,8113ef60 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
8113ef5c:	1138e240 	call	81138e24 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113ef60:	0005883a 	mov	r2,zero
}
8113ef64:	e037883a 	mov	sp,fp
8113ef68:	dfc00117 	ldw	ra,4(sp)
8113ef6c:	df000017 	ldw	fp,0(sp)
8113ef70:	dec00204 	addi	sp,sp,8
8113ef74:	f800283a 	ret

8113ef78 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
8113ef78:	defff504 	addi	sp,sp,-44
8113ef7c:	de00012e 	bgeu	sp,et,8113ef84 <OSTaskDelReq+0xc>
8113ef80:	003b68fa 	trap	3
8113ef84:	df000a15 	stw	fp,40(sp)
8113ef88:	df000a04 	addi	fp,sp,40
8113ef8c:	2005883a 	mov	r2,r4
8113ef90:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ef94:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
8113ef98:	e0bfff03 	ldbu	r2,-4(fp)
8113ef9c:	10800a98 	cmpnei	r2,r2,42
8113efa0:	1000021e 	bne	r2,zero,8113efac <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
8113efa4:	00800f84 	movi	r2,62
8113efa8:	00004506 	br	8113f0c0 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113efac:	e0bfff03 	ldbu	r2,-4(fp)
8113efb0:	10800ab0 	cmpltui	r2,r2,42
8113efb4:	1000051e 	bne	r2,zero,8113efcc <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
8113efb8:	e0bfff03 	ldbu	r2,-4(fp)
8113efbc:	10803fe0 	cmpeqi	r2,r2,255
8113efc0:	1000021e 	bne	r2,zero,8113efcc <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
8113efc4:	00800a84 	movi	r2,42
8113efc8:	00003d06 	br	8113f0c0 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
8113efcc:	e0bfff03 	ldbu	r2,-4(fp)
8113efd0:	10803fd8 	cmpnei	r2,r2,255
8113efd4:	1000111e 	bne	r2,zero,8113f01c <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113efd8:	0005303a 	rdctl	r2,status
8113efdc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113efe0:	e0fff917 	ldw	r3,-28(fp)
8113efe4:	00bfff84 	movi	r2,-2
8113efe8:	1884703a 	and	r2,r3,r2
8113efec:	1001703a 	wrctl	status,r2
  
  return context;
8113eff0:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
8113eff4:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
8113eff8:	d0a0a117 	ldw	r2,-32124(gp)
8113effc:	10800dc3 	ldbu	r2,55(r2)
8113f000:	e0bff805 	stb	r2,-32(fp)
8113f004:	e0bff617 	ldw	r2,-40(fp)
8113f008:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f00c:	e0bffe17 	ldw	r2,-8(fp)
8113f010:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
8113f014:	e0bff803 	ldbu	r2,-32(fp)
8113f018:	00002906 	br	8113f0c0 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f01c:	0005303a 	rdctl	r2,status
8113f020:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f024:	e0fff717 	ldw	r3,-36(fp)
8113f028:	00bfff84 	movi	r2,-2
8113f02c:	1884703a 	and	r2,r3,r2
8113f030:	1001703a 	wrctl	status,r2
  
  return context;
8113f034:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
8113f038:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113f03c:	e0ffff03 	ldbu	r3,-4(fp)
8113f040:	00a045f4 	movhi	r2,33047
8113f044:	10af6e04 	addi	r2,r2,-16968
8113f048:	18c7883a 	add	r3,r3,r3
8113f04c:	18c7883a 	add	r3,r3,r3
8113f050:	10c5883a 	add	r2,r2,r3
8113f054:	10800017 	ldw	r2,0(r2)
8113f058:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
8113f05c:	e0bffb17 	ldw	r2,-20(fp)
8113f060:	1000061e 	bne	r2,zero,8113f07c <OSTaskDelReq+0x104>
8113f064:	e0bff617 	ldw	r2,-40(fp)
8113f068:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f06c:	e0bffa17 	ldw	r2,-24(fp)
8113f070:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
8113f074:	008010c4 	movi	r2,67
8113f078:	00001106 	br	8113f0c0 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
8113f07c:	e0bffb17 	ldw	r2,-20(fp)
8113f080:	10800058 	cmpnei	r2,r2,1
8113f084:	1000061e 	bne	r2,zero,8113f0a0 <OSTaskDelReq+0x128>
8113f088:	e0bff617 	ldw	r2,-40(fp)
8113f08c:	e0bffc15 	stw	r2,-16(fp)
8113f090:	e0bffc17 	ldw	r2,-16(fp)
8113f094:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113f098:	00800f44 	movi	r2,61
8113f09c:	00000806 	br	8113f0c0 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
8113f0a0:	e0bffb17 	ldw	r2,-20(fp)
8113f0a4:	00c00fc4 	movi	r3,63
8113f0a8:	10c00dc5 	stb	r3,55(r2)
8113f0ac:	e0bff617 	ldw	r2,-40(fp)
8113f0b0:	e0bffd15 	stw	r2,-12(fp)
8113f0b4:	e0bffd17 	ldw	r2,-12(fp)
8113f0b8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113f0bc:	0005883a 	mov	r2,zero
}
8113f0c0:	e037883a 	mov	sp,fp
8113f0c4:	df000017 	ldw	fp,0(sp)
8113f0c8:	dec00104 	addi	sp,sp,4
8113f0cc:	f800283a 	ret

8113f0d0 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113f0d0:	defff404 	addi	sp,sp,-48
8113f0d4:	de00012e 	bgeu	sp,et,8113f0dc <OSTaskNameGet+0xc>
8113f0d8:	003b68fa 	trap	3
8113f0dc:	dfc00b15 	stw	ra,44(sp)
8113f0e0:	df000a15 	stw	fp,40(sp)
8113f0e4:	df000a04 	addi	fp,sp,40
8113f0e8:	2005883a 	mov	r2,r4
8113f0ec:	e17ffe15 	stw	r5,-8(fp)
8113f0f0:	e1bfff15 	stw	r6,-4(fp)
8113f0f4:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
8113f0f8:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
8113f0fc:	e0bfff17 	ldw	r2,-4(fp)
8113f100:	1000021e 	bne	r2,zero,8113f10c <OSTaskNameGet+0x3c>
        return (0);
8113f104:	0005883a 	mov	r2,zero
8113f108:	00005406 	br	8113f25c <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
8113f10c:	e0bffd03 	ldbu	r2,-12(fp)
8113f110:	10800af0 	cmpltui	r2,r2,43
8113f114:	1000081e 	bne	r2,zero,8113f138 <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
8113f118:	e0bffd03 	ldbu	r2,-12(fp)
8113f11c:	10803fe0 	cmpeqi	r2,r2,255
8113f120:	1000051e 	bne	r2,zero,8113f138 <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
8113f124:	e0bfff17 	ldw	r2,-4(fp)
8113f128:	00c00a84 	movi	r3,42
8113f12c:	10c00005 	stb	r3,0(r2)
            return (0);
8113f130:	0005883a 	mov	r2,zero
8113f134:	00004906 	br	8113f25c <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
8113f138:	e0bffe17 	ldw	r2,-8(fp)
8113f13c:	1000051e 	bne	r2,zero,8113f154 <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
8113f140:	e0bfff17 	ldw	r2,-4(fp)
8113f144:	00c00304 	movi	r3,12
8113f148:	10c00005 	stb	r3,0(r2)
        return (0);
8113f14c:	0005883a 	mov	r2,zero
8113f150:	00004206 	br	8113f25c <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
8113f154:	d0a0a003 	ldbu	r2,-32128(gp)
8113f158:	10803fcc 	andi	r2,r2,255
8113f15c:	10000526 	beq	r2,zero,8113f174 <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
8113f160:	e0bfff17 	ldw	r2,-4(fp)
8113f164:	00c00444 	movi	r3,17
8113f168:	10c00005 	stb	r3,0(r2)
        return (0);
8113f16c:	0005883a 	mov	r2,zero
8113f170:	00003a06 	br	8113f25c <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f174:	0005303a 	rdctl	r2,status
8113f178:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f17c:	e0fffc17 	ldw	r3,-16(fp)
8113f180:	00bfff84 	movi	r2,-2
8113f184:	1884703a 	and	r2,r3,r2
8113f188:	1001703a 	wrctl	status,r2
  
  return context;
8113f18c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113f190:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
8113f194:	e0bffd03 	ldbu	r2,-12(fp)
8113f198:	10803fd8 	cmpnei	r2,r2,255
8113f19c:	1000031e 	bne	r2,zero,8113f1ac <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
8113f1a0:	d0a0a117 	ldw	r2,-32124(gp)
8113f1a4:	10800c83 	ldbu	r2,50(r2)
8113f1a8:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113f1ac:	e0fffd03 	ldbu	r3,-12(fp)
8113f1b0:	00a045f4 	movhi	r2,33047
8113f1b4:	10af6e04 	addi	r2,r2,-16968
8113f1b8:	18c7883a 	add	r3,r3,r3
8113f1bc:	18c7883a 	add	r3,r3,r3
8113f1c0:	10c5883a 	add	r2,r2,r3
8113f1c4:	10800017 	ldw	r2,0(r2)
8113f1c8:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
8113f1cc:	e0bff817 	ldw	r2,-32(fp)
8113f1d0:	1000091e 	bne	r2,zero,8113f1f8 <OSTaskNameGet+0x128>
8113f1d4:	e0bff617 	ldw	r2,-40(fp)
8113f1d8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f1dc:	e0bff717 	ldw	r2,-36(fp)
8113f1e0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113f1e4:	e0bfff17 	ldw	r2,-4(fp)
8113f1e8:	00c010c4 	movi	r3,67
8113f1ec:	10c00005 	stb	r3,0(r2)
        return (0);
8113f1f0:	0005883a 	mov	r2,zero
8113f1f4:	00001906 	br	8113f25c <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
8113f1f8:	e0bff817 	ldw	r2,-32(fp)
8113f1fc:	10800058 	cmpnei	r2,r2,1
8113f200:	1000091e 	bne	r2,zero,8113f228 <OSTaskNameGet+0x158>
8113f204:	e0bff617 	ldw	r2,-40(fp)
8113f208:	e0bff915 	stw	r2,-28(fp)
8113f20c:	e0bff917 	ldw	r2,-28(fp)
8113f210:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113f214:	e0bfff17 	ldw	r2,-4(fp)
8113f218:	00c010c4 	movi	r3,67
8113f21c:	10c00005 	stb	r3,0(r2)
        return (0);
8113f220:	0005883a 	mov	r2,zero
8113f224:	00000d06 	br	8113f25c <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
8113f228:	e0bff817 	ldw	r2,-32(fp)
8113f22c:	10801304 	addi	r2,r2,76
8113f230:	100b883a 	mov	r5,r2
8113f234:	e13ffe17 	ldw	r4,-8(fp)
8113f238:	1138f780 	call	81138f78 <OS_StrCopy>
8113f23c:	e0bffb05 	stb	r2,-20(fp)
8113f240:	e0bff617 	ldw	r2,-40(fp)
8113f244:	e0bffa15 	stw	r2,-24(fp)
8113f248:	e0bffa17 	ldw	r2,-24(fp)
8113f24c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113f250:	e0bfff17 	ldw	r2,-4(fp)
8113f254:	10000005 	stb	zero,0(r2)
    return (len);
8113f258:	e0bffb03 	ldbu	r2,-20(fp)
}
8113f25c:	e037883a 	mov	sp,fp
8113f260:	dfc00117 	ldw	ra,4(sp)
8113f264:	df000017 	ldw	fp,0(sp)
8113f268:	dec00204 	addi	sp,sp,8
8113f26c:	f800283a 	ret

8113f270 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113f270:	defff304 	addi	sp,sp,-52
8113f274:	de00012e 	bgeu	sp,et,8113f27c <OSTaskNameSet+0xc>
8113f278:	003b68fa 	trap	3
8113f27c:	dfc00c15 	stw	ra,48(sp)
8113f280:	df000b15 	stw	fp,44(sp)
8113f284:	df000b04 	addi	fp,sp,44
8113f288:	2005883a 	mov	r2,r4
8113f28c:	e17ffe15 	stw	r5,-8(fp)
8113f290:	e1bfff15 	stw	r6,-4(fp)
8113f294:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113f298:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113f29c:	e0bfff17 	ldw	r2,-4(fp)
8113f2a0:	10005c26 	beq	r2,zero,8113f414 <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
8113f2a4:	e0bffd03 	ldbu	r2,-12(fp)
8113f2a8:	10800af0 	cmpltui	r2,r2,43
8113f2ac:	1000071e 	bne	r2,zero,8113f2cc <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
8113f2b0:	e0bffd03 	ldbu	r2,-12(fp)
8113f2b4:	10803fe0 	cmpeqi	r2,r2,255
8113f2b8:	1000041e 	bne	r2,zero,8113f2cc <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
8113f2bc:	e0bfff17 	ldw	r2,-4(fp)
8113f2c0:	00c00a84 	movi	r3,42
8113f2c4:	10c00005 	stb	r3,0(r2)
            return;
8113f2c8:	00005306 	br	8113f418 <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
8113f2cc:	e0bffe17 	ldw	r2,-8(fp)
8113f2d0:	1000041e 	bne	r2,zero,8113f2e4 <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
8113f2d4:	e0bfff17 	ldw	r2,-4(fp)
8113f2d8:	00c00304 	movi	r3,12
8113f2dc:	10c00005 	stb	r3,0(r2)
        return;
8113f2e0:	00004d06 	br	8113f418 <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
8113f2e4:	d0a0a003 	ldbu	r2,-32128(gp)
8113f2e8:	10803fcc 	andi	r2,r2,255
8113f2ec:	10000426 	beq	r2,zero,8113f300 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
8113f2f0:	e0bfff17 	ldw	r2,-4(fp)
8113f2f4:	00c00484 	movi	r3,18
8113f2f8:	10c00005 	stb	r3,0(r2)
        return;
8113f2fc:	00004606 	br	8113f418 <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f300:	0005303a 	rdctl	r2,status
8113f304:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f308:	e0fffc17 	ldw	r3,-16(fp)
8113f30c:	00bfff84 	movi	r2,-2
8113f310:	1884703a 	and	r2,r3,r2
8113f314:	1001703a 	wrctl	status,r2
  
  return context;
8113f318:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113f31c:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
8113f320:	e0bffd03 	ldbu	r2,-12(fp)
8113f324:	10803fd8 	cmpnei	r2,r2,255
8113f328:	1000031e 	bne	r2,zero,8113f338 <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
8113f32c:	d0a0a117 	ldw	r2,-32124(gp)
8113f330:	10800c83 	ldbu	r2,50(r2)
8113f334:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113f338:	e0fffd03 	ldbu	r3,-12(fp)
8113f33c:	00a045f4 	movhi	r2,33047
8113f340:	10af6e04 	addi	r2,r2,-16968
8113f344:	18c7883a 	add	r3,r3,r3
8113f348:	18c7883a 	add	r3,r3,r3
8113f34c:	10c5883a 	add	r2,r2,r3
8113f350:	10800017 	ldw	r2,0(r2)
8113f354:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
8113f358:	e0bff717 	ldw	r2,-36(fp)
8113f35c:	1000081e 	bne	r2,zero,8113f380 <OSTaskNameSet+0x110>
8113f360:	e0bff517 	ldw	r2,-44(fp)
8113f364:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f368:	e0bff617 	ldw	r2,-40(fp)
8113f36c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113f370:	e0bfff17 	ldw	r2,-4(fp)
8113f374:	00c010c4 	movi	r3,67
8113f378:	10c00005 	stb	r3,0(r2)
        return;
8113f37c:	00002606 	br	8113f418 <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
8113f380:	e0bff717 	ldw	r2,-36(fp)
8113f384:	10800058 	cmpnei	r2,r2,1
8113f388:	1000081e 	bne	r2,zero,8113f3ac <OSTaskNameSet+0x13c>
8113f38c:	e0bff517 	ldw	r2,-44(fp)
8113f390:	e0bff815 	stw	r2,-32(fp)
8113f394:	e0bff817 	ldw	r2,-32(fp)
8113f398:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113f39c:	e0bfff17 	ldw	r2,-4(fp)
8113f3a0:	00c010c4 	movi	r3,67
8113f3a4:	10c00005 	stb	r3,0(r2)
        return;
8113f3a8:	00001b06 	br	8113f418 <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
8113f3ac:	e13ffe17 	ldw	r4,-8(fp)
8113f3b0:	1138ff40 	call	81138ff4 <OS_StrLen>
8113f3b4:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
8113f3b8:	e0bffa03 	ldbu	r2,-24(fp)
8113f3bc:	10800830 	cmpltui	r2,r2,32
8113f3c0:	1000081e 	bne	r2,zero,8113f3e4 <OSTaskNameSet+0x174>
8113f3c4:	e0bff517 	ldw	r2,-44(fp)
8113f3c8:	e0bff915 	stw	r2,-28(fp)
8113f3cc:	e0bff917 	ldw	r2,-28(fp)
8113f3d0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
8113f3d4:	e0bfff17 	ldw	r2,-4(fp)
8113f3d8:	00c01044 	movi	r3,65
8113f3dc:	10c00005 	stb	r3,0(r2)
        return;
8113f3e0:	00000d06 	br	8113f418 <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
8113f3e4:	e0bff717 	ldw	r2,-36(fp)
8113f3e8:	10801304 	addi	r2,r2,76
8113f3ec:	e17ffe17 	ldw	r5,-8(fp)
8113f3f0:	1009883a 	mov	r4,r2
8113f3f4:	1138f780 	call	81138f78 <OS_StrCopy>
8113f3f8:	e0bff517 	ldw	r2,-44(fp)
8113f3fc:	e0bffb15 	stw	r2,-20(fp)
8113f400:	e0bffb17 	ldw	r2,-20(fp)
8113f404:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113f408:	e0bfff17 	ldw	r2,-4(fp)
8113f40c:	10000005 	stb	zero,0(r2)
8113f410:	00000106 	br	8113f418 <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
8113f414:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113f418:	e037883a 	mov	sp,fp
8113f41c:	dfc00117 	ldw	ra,4(sp)
8113f420:	df000017 	ldw	fp,0(sp)
8113f424:	dec00204 	addi	sp,sp,8
8113f428:	f800283a 	ret

8113f42c <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
8113f42c:	defff404 	addi	sp,sp,-48
8113f430:	de00012e 	bgeu	sp,et,8113f438 <OSTaskResume+0xc>
8113f434:	003b68fa 	trap	3
8113f438:	dfc00b15 	stw	ra,44(sp)
8113f43c:	df000a15 	stw	fp,40(sp)
8113f440:	df000a04 	addi	fp,sp,40
8113f444:	2005883a 	mov	r2,r4
8113f448:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113f44c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
8113f450:	e0bfff03 	ldbu	r2,-4(fp)
8113f454:	10800ab0 	cmpltui	r2,r2,42
8113f458:	1000021e 	bne	r2,zero,8113f464 <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8113f45c:	00800a84 	movi	r2,42
8113f460:	00006406 	br	8113f5f4 <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f464:	0005303a 	rdctl	r2,status
8113f468:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f46c:	e0fffe17 	ldw	r3,-8(fp)
8113f470:	00bfff84 	movi	r2,-2
8113f474:	1884703a 	and	r2,r3,r2
8113f478:	1001703a 	wrctl	status,r2
  
  return context;
8113f47c:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113f480:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113f484:	e0ffff03 	ldbu	r3,-4(fp)
8113f488:	00a045f4 	movhi	r2,33047
8113f48c:	10af6e04 	addi	r2,r2,-16968
8113f490:	18c7883a 	add	r3,r3,r3
8113f494:	18c7883a 	add	r3,r3,r3
8113f498:	10c5883a 	add	r2,r2,r3
8113f49c:	10800017 	ldw	r2,0(r2)
8113f4a0:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
8113f4a4:	e0bff817 	ldw	r2,-32(fp)
8113f4a8:	1000061e 	bne	r2,zero,8113f4c4 <OSTaskResume+0x98>
8113f4ac:	e0bff617 	ldw	r2,-40(fp)
8113f4b0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f4b4:	e0bff717 	ldw	r2,-36(fp)
8113f4b8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
8113f4bc:	00801184 	movi	r2,70
8113f4c0:	00004c06 	br	8113f5f4 <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
8113f4c4:	e0bff817 	ldw	r2,-32(fp)
8113f4c8:	10800058 	cmpnei	r2,r2,1
8113f4cc:	1000061e 	bne	r2,zero,8113f4e8 <OSTaskResume+0xbc>
8113f4d0:	e0bff617 	ldw	r2,-40(fp)
8113f4d4:	e0bff915 	stw	r2,-28(fp)
8113f4d8:	e0bff917 	ldw	r2,-28(fp)
8113f4dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113f4e0:	008010c4 	movi	r2,67
8113f4e4:	00004306 	br	8113f5f4 <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
8113f4e8:	e0bff817 	ldw	r2,-32(fp)
8113f4ec:	10800c03 	ldbu	r2,48(r2)
8113f4f0:	10803fcc 	andi	r2,r2,255
8113f4f4:	1080020c 	andi	r2,r2,8
8113f4f8:	10003926 	beq	r2,zero,8113f5e0 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
8113f4fc:	e0bff817 	ldw	r2,-32(fp)
8113f500:	10c00c03 	ldbu	r3,48(r2)
8113f504:	00bffdc4 	movi	r2,-9
8113f508:	1884703a 	and	r2,r3,r2
8113f50c:	1007883a 	mov	r3,r2
8113f510:	e0bff817 	ldw	r2,-32(fp)
8113f514:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
8113f518:	e0bff817 	ldw	r2,-32(fp)
8113f51c:	10800c03 	ldbu	r2,48(r2)
8113f520:	10803fcc 	andi	r2,r2,255
8113f524:	1000281e 	bne	r2,zero,8113f5c8 <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
8113f528:	e0bff817 	ldw	r2,-32(fp)
8113f52c:	10800b8b 	ldhu	r2,46(r2)
8113f530:	10bfffcc 	andi	r2,r2,65535
8113f534:	10001f1e 	bne	r2,zero,8113f5b4 <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
8113f538:	e0bff817 	ldw	r2,-32(fp)
8113f53c:	10c00d83 	ldbu	r3,54(r2)
8113f540:	d0a09d03 	ldbu	r2,-32140(gp)
8113f544:	1884b03a 	or	r2,r3,r2
8113f548:	d0a09d05 	stb	r2,-32140(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113f54c:	e0bff817 	ldw	r2,-32(fp)
8113f550:	10800d03 	ldbu	r2,52(r2)
8113f554:	10c03fcc 	andi	r3,r2,255
8113f558:	e0bff817 	ldw	r2,-32(fp)
8113f55c:	10800d03 	ldbu	r2,52(r2)
8113f560:	11003fcc 	andi	r4,r2,255
8113f564:	d0a09d44 	addi	r2,gp,-32139
8113f568:	2085883a 	add	r2,r4,r2
8113f56c:	11000003 	ldbu	r4,0(r2)
8113f570:	e0bff817 	ldw	r2,-32(fp)
8113f574:	10800d43 	ldbu	r2,53(r2)
8113f578:	2084b03a 	or	r2,r4,r2
8113f57c:	1009883a 	mov	r4,r2
8113f580:	d0a09d44 	addi	r2,gp,-32139
8113f584:	1885883a 	add	r2,r3,r2
8113f588:	11000005 	stb	r4,0(r2)
8113f58c:	e0bff617 	ldw	r2,-40(fp)
8113f590:	e0bffa15 	stw	r2,-24(fp)
8113f594:	e0bffa17 	ldw	r2,-24(fp)
8113f598:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
8113f59c:	d0a09003 	ldbu	r2,-32192(gp)
8113f5a0:	10803fcc 	andi	r2,r2,255
8113f5a4:	10800058 	cmpnei	r2,r2,1
8113f5a8:	10000b1e 	bne	r2,zero,8113f5d8 <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
8113f5ac:	1138e240 	call	81138e24 <OS_Sched>
8113f5b0:	00000906 	br	8113f5d8 <OSTaskResume+0x1ac>
8113f5b4:	e0bff617 	ldw	r2,-40(fp)
8113f5b8:	e0bffb15 	stw	r2,-20(fp)
8113f5bc:	e0bffb17 	ldw	r2,-20(fp)
8113f5c0:	1001703a 	wrctl	status,r2
8113f5c4:	00000406 	br	8113f5d8 <OSTaskResume+0x1ac>
8113f5c8:	e0bff617 	ldw	r2,-40(fp)
8113f5cc:	e0bffc15 	stw	r2,-16(fp)
8113f5d0:	e0bffc17 	ldw	r2,-16(fp)
8113f5d4:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
8113f5d8:	0005883a 	mov	r2,zero
8113f5dc:	00000506 	br	8113f5f4 <OSTaskResume+0x1c8>
8113f5e0:	e0bff617 	ldw	r2,-40(fp)
8113f5e4:	e0bffd15 	stw	r2,-12(fp)
8113f5e8:	e0bffd17 	ldw	r2,-12(fp)
8113f5ec:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
8113f5f0:	00801104 	movi	r2,68
}
8113f5f4:	e037883a 	mov	sp,fp
8113f5f8:	dfc00117 	ldw	ra,4(sp)
8113f5fc:	df000017 	ldw	fp,0(sp)
8113f600:	dec00204 	addi	sp,sp,8
8113f604:	f800283a 	ret

8113f608 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
8113f608:	defff304 	addi	sp,sp,-52
8113f60c:	de00012e 	bgeu	sp,et,8113f614 <OSTaskStkChk+0xc>
8113f610:	003b68fa 	trap	3
8113f614:	df000c15 	stw	fp,48(sp)
8113f618:	df000c04 	addi	fp,sp,48
8113f61c:	2005883a 	mov	r2,r4
8113f620:	e17fff15 	stw	r5,-4(fp)
8113f624:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113f628:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
8113f62c:	e0bffe03 	ldbu	r2,-8(fp)
8113f630:	10800af0 	cmpltui	r2,r2,43
8113f634:	1000051e 	bne	r2,zero,8113f64c <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
8113f638:	e0bffe03 	ldbu	r2,-8(fp)
8113f63c:	10803fe0 	cmpeqi	r2,r2,255
8113f640:	1000021e 	bne	r2,zero,8113f64c <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
8113f644:	00800a84 	movi	r2,42
8113f648:	00005d06 	br	8113f7c0 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
8113f64c:	e0bfff17 	ldw	r2,-4(fp)
8113f650:	1000021e 	bne	r2,zero,8113f65c <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
8113f654:	00800244 	movi	r2,9
8113f658:	00005906 	br	8113f7c0 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
8113f65c:	e0bfff17 	ldw	r2,-4(fp)
8113f660:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
8113f664:	e0bfff17 	ldw	r2,-4(fp)
8113f668:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f66c:	0005303a 	rdctl	r2,status
8113f670:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f674:	e0fffd17 	ldw	r3,-12(fp)
8113f678:	00bfff84 	movi	r2,-2
8113f67c:	1884703a 	and	r2,r3,r2
8113f680:	1001703a 	wrctl	status,r2
  
  return context;
8113f684:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
8113f688:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
8113f68c:	e0bffe03 	ldbu	r2,-8(fp)
8113f690:	10803fd8 	cmpnei	r2,r2,255
8113f694:	1000031e 	bne	r2,zero,8113f6a4 <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113f698:	d0a0a117 	ldw	r2,-32124(gp)
8113f69c:	10800c83 	ldbu	r2,50(r2)
8113f6a0:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113f6a4:	e0fffe03 	ldbu	r3,-8(fp)
8113f6a8:	00a045f4 	movhi	r2,33047
8113f6ac:	10af6e04 	addi	r2,r2,-16968
8113f6b0:	18c7883a 	add	r3,r3,r3
8113f6b4:	18c7883a 	add	r3,r3,r3
8113f6b8:	10c5883a 	add	r2,r2,r3
8113f6bc:	10800017 	ldw	r2,0(r2)
8113f6c0:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
8113f6c4:	e0bff817 	ldw	r2,-32(fp)
8113f6c8:	1000061e 	bne	r2,zero,8113f6e4 <OSTaskStkChk+0xdc>
8113f6cc:	e0bff617 	ldw	r2,-40(fp)
8113f6d0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f6d4:	e0bff717 	ldw	r2,-36(fp)
8113f6d8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113f6dc:	008010c4 	movi	r2,67
8113f6e0:	00003706 	br	8113f7c0 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113f6e4:	e0bff817 	ldw	r2,-32(fp)
8113f6e8:	10800058 	cmpnei	r2,r2,1
8113f6ec:	1000061e 	bne	r2,zero,8113f708 <OSTaskStkChk+0x100>
8113f6f0:	e0bff617 	ldw	r2,-40(fp)
8113f6f4:	e0bff915 	stw	r2,-28(fp)
8113f6f8:	e0bff917 	ldw	r2,-28(fp)
8113f6fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113f700:	008010c4 	movi	r2,67
8113f704:	00002e06 	br	8113f7c0 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
8113f708:	e0bff817 	ldw	r2,-32(fp)
8113f70c:	1080040b 	ldhu	r2,16(r2)
8113f710:	10bfffcc 	andi	r2,r2,65535
8113f714:	1080004c 	andi	r2,r2,1
8113f718:	1000061e 	bne	r2,zero,8113f734 <OSTaskStkChk+0x12c>
8113f71c:	e0bff617 	ldw	r2,-40(fp)
8113f720:	e0bffa15 	stw	r2,-24(fp)
8113f724:	e0bffa17 	ldw	r2,-24(fp)
8113f728:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
8113f72c:	00801144 	movi	r2,69
8113f730:	00002306 	br	8113f7c0 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
8113f734:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
8113f738:	e0bff817 	ldw	r2,-32(fp)
8113f73c:	10800317 	ldw	r2,12(r2)
8113f740:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
8113f744:	e0bff817 	ldw	r2,-32(fp)
8113f748:	10800217 	ldw	r2,8(r2)
8113f74c:	e0bff415 	stw	r2,-48(fp)
8113f750:	e0bff617 	ldw	r2,-40(fp)
8113f754:	e0bffb15 	stw	r2,-20(fp)
8113f758:	e0bffb17 	ldw	r2,-20(fp)
8113f75c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113f760:	00000306 	br	8113f770 <OSTaskStkChk+0x168>
        nfree++;
8113f764:	e0bff517 	ldw	r2,-44(fp)
8113f768:	10800044 	addi	r2,r2,1
8113f76c:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113f770:	e0bff417 	ldw	r2,-48(fp)
8113f774:	10c00104 	addi	r3,r2,4
8113f778:	e0fff415 	stw	r3,-48(fp)
8113f77c:	10800017 	ldw	r2,0(r2)
8113f780:	103ff826 	beq	r2,zero,8113f764 <__reset+0xfb11f764>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
8113f784:	e0bff517 	ldw	r2,-44(fp)
8113f788:	1085883a 	add	r2,r2,r2
8113f78c:	1085883a 	add	r2,r2,r2
8113f790:	1007883a 	mov	r3,r2
8113f794:	e0bfff17 	ldw	r2,-4(fp)
8113f798:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
8113f79c:	e0fffc17 	ldw	r3,-16(fp)
8113f7a0:	e0bff517 	ldw	r2,-44(fp)
8113f7a4:	1885c83a 	sub	r2,r3,r2
8113f7a8:	1085883a 	add	r2,r2,r2
8113f7ac:	1085883a 	add	r2,r2,r2
8113f7b0:	1007883a 	mov	r3,r2
8113f7b4:	e0bfff17 	ldw	r2,-4(fp)
8113f7b8:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
8113f7bc:	0005883a 	mov	r2,zero
}
8113f7c0:	e037883a 	mov	sp,fp
8113f7c4:	df000017 	ldw	fp,0(sp)
8113f7c8:	dec00104 	addi	sp,sp,4
8113f7cc:	f800283a 	ret

8113f7d0 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
8113f7d0:	defff504 	addi	sp,sp,-44
8113f7d4:	de00012e 	bgeu	sp,et,8113f7dc <OSTaskSuspend+0xc>
8113f7d8:	003b68fa 	trap	3
8113f7dc:	dfc00a15 	stw	ra,40(sp)
8113f7e0:	df000915 	stw	fp,36(sp)
8113f7e4:	df000904 	addi	fp,sp,36
8113f7e8:	2005883a 	mov	r2,r4
8113f7ec:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113f7f0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
8113f7f4:	e0bfff03 	ldbu	r2,-4(fp)
8113f7f8:	10800a98 	cmpnei	r2,r2,42
8113f7fc:	1000021e 	bne	r2,zero,8113f808 <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
8113f800:	008011c4 	movi	r2,71
8113f804:	00006806 	br	8113f9a8 <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113f808:	e0bfff03 	ldbu	r2,-4(fp)
8113f80c:	10800ab0 	cmpltui	r2,r2,42
8113f810:	1000051e 	bne	r2,zero,8113f828 <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
8113f814:	e0bfff03 	ldbu	r2,-4(fp)
8113f818:	10803fe0 	cmpeqi	r2,r2,255
8113f81c:	1000021e 	bne	r2,zero,8113f828 <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
8113f820:	00800a84 	movi	r2,42
8113f824:	00006006 	br	8113f9a8 <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113f828:	0005303a 	rdctl	r2,status
8113f82c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113f830:	e0fffe17 	ldw	r3,-8(fp)
8113f834:	00bfff84 	movi	r2,-2
8113f838:	1884703a 	and	r2,r3,r2
8113f83c:	1001703a 	wrctl	status,r2
  
  return context;
8113f840:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
8113f844:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
8113f848:	e0bfff03 	ldbu	r2,-4(fp)
8113f84c:	10803fd8 	cmpnei	r2,r2,255
8113f850:	1000061e 	bne	r2,zero,8113f86c <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113f854:	d0a0a117 	ldw	r2,-32124(gp)
8113f858:	10800c83 	ldbu	r2,50(r2)
8113f85c:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
8113f860:	00800044 	movi	r2,1
8113f864:	e0bff705 	stb	r2,-36(fp)
8113f868:	00000906 	br	8113f890 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
8113f86c:	d0a0a117 	ldw	r2,-32124(gp)
8113f870:	10800c83 	ldbu	r2,50(r2)
8113f874:	10c03fcc 	andi	r3,r2,255
8113f878:	e0bfff03 	ldbu	r2,-4(fp)
8113f87c:	1880031e 	bne	r3,r2,8113f88c <OSTaskSuspend+0xbc>
        self = OS_TRUE;
8113f880:	00800044 	movi	r2,1
8113f884:	e0bff705 	stb	r2,-36(fp)
8113f888:	00000106 	br	8113f890 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
8113f88c:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113f890:	e0ffff03 	ldbu	r3,-4(fp)
8113f894:	00a045f4 	movhi	r2,33047
8113f898:	10af6e04 	addi	r2,r2,-16968
8113f89c:	18c7883a 	add	r3,r3,r3
8113f8a0:	18c7883a 	add	r3,r3,r3
8113f8a4:	10c5883a 	add	r2,r2,r3
8113f8a8:	10800017 	ldw	r2,0(r2)
8113f8ac:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
8113f8b0:	e0bffa17 	ldw	r2,-24(fp)
8113f8b4:	1000061e 	bne	r2,zero,8113f8d0 <OSTaskSuspend+0x100>
8113f8b8:	e0bff817 	ldw	r2,-32(fp)
8113f8bc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113f8c0:	e0bff917 	ldw	r2,-28(fp)
8113f8c4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
8113f8c8:	00801204 	movi	r2,72
8113f8cc:	00003606 	br	8113f9a8 <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
8113f8d0:	e0bffa17 	ldw	r2,-24(fp)
8113f8d4:	10800058 	cmpnei	r2,r2,1
8113f8d8:	1000061e 	bne	r2,zero,8113f8f4 <OSTaskSuspend+0x124>
8113f8dc:	e0bff817 	ldw	r2,-32(fp)
8113f8e0:	e0bffb15 	stw	r2,-20(fp)
8113f8e4:	e0bffb17 	ldw	r2,-20(fp)
8113f8e8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113f8ec:	008010c4 	movi	r2,67
8113f8f0:	00002d06 	br	8113f9a8 <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
8113f8f4:	e0bffa17 	ldw	r2,-24(fp)
8113f8f8:	10800d03 	ldbu	r2,52(r2)
8113f8fc:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
8113f900:	e0fffd03 	ldbu	r3,-12(fp)
8113f904:	e13ffd03 	ldbu	r4,-12(fp)
8113f908:	d0a09d44 	addi	r2,gp,-32139
8113f90c:	2085883a 	add	r2,r4,r2
8113f910:	10800003 	ldbu	r2,0(r2)
8113f914:	1009883a 	mov	r4,r2
8113f918:	e0bffa17 	ldw	r2,-24(fp)
8113f91c:	10800d43 	ldbu	r2,53(r2)
8113f920:	0084303a 	nor	r2,zero,r2
8113f924:	2084703a 	and	r2,r4,r2
8113f928:	1009883a 	mov	r4,r2
8113f92c:	d0a09d44 	addi	r2,gp,-32139
8113f930:	1885883a 	add	r2,r3,r2
8113f934:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113f938:	e0fffd03 	ldbu	r3,-12(fp)
8113f93c:	d0a09d44 	addi	r2,gp,-32139
8113f940:	1885883a 	add	r2,r3,r2
8113f944:	10800003 	ldbu	r2,0(r2)
8113f948:	10803fcc 	andi	r2,r2,255
8113f94c:	1000071e 	bne	r2,zero,8113f96c <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113f950:	e0bffa17 	ldw	r2,-24(fp)
8113f954:	10800d83 	ldbu	r2,54(r2)
8113f958:	0084303a 	nor	r2,zero,r2
8113f95c:	1007883a 	mov	r3,r2
8113f960:	d0a09d03 	ldbu	r2,-32140(gp)
8113f964:	1884703a 	and	r2,r3,r2
8113f968:	d0a09d05 	stb	r2,-32140(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
8113f96c:	e0bffa17 	ldw	r2,-24(fp)
8113f970:	10800c03 	ldbu	r2,48(r2)
8113f974:	10800214 	ori	r2,r2,8
8113f978:	1007883a 	mov	r3,r2
8113f97c:	e0bffa17 	ldw	r2,-24(fp)
8113f980:	10c00c05 	stb	r3,48(r2)
8113f984:	e0bff817 	ldw	r2,-32(fp)
8113f988:	e0bffc15 	stw	r2,-16(fp)
8113f98c:	e0bffc17 	ldw	r2,-16(fp)
8113f990:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
8113f994:	e0bff703 	ldbu	r2,-36(fp)
8113f998:	10800058 	cmpnei	r2,r2,1
8113f99c:	1000011e 	bne	r2,zero,8113f9a4 <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
8113f9a0:	1138e240 	call	81138e24 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113f9a4:	0005883a 	mov	r2,zero
}
8113f9a8:	e037883a 	mov	sp,fp
8113f9ac:	dfc00117 	ldw	ra,4(sp)
8113f9b0:	df000017 	ldw	fp,0(sp)
8113f9b4:	dec00204 	addi	sp,sp,8
8113f9b8:	f800283a 	ret

8113f9bc <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
8113f9bc:	defff604 	addi	sp,sp,-40
8113f9c0:	de00012e 	bgeu	sp,et,8113f9c8 <OSTaskQuery+0xc>
8113f9c4:	003b68fa 	trap	3
8113f9c8:	dfc00915 	stw	ra,36(sp)
8113f9cc:	df000815 	stw	fp,32(sp)
8113f9d0:	df000804 	addi	fp,sp,32
8113f9d4:	2005883a 	mov	r2,r4
8113f9d8:	e17fff15 	stw	r5,-4(fp)
8113f9dc:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113f9e0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
8113f9e4:	e0bffe03 	ldbu	r2,-8(fp)
8113f9e8:	10800af0 	cmpltui	r2,r2,43
8113f9ec:	1000051e 	bne	r2,zero,8113fa04 <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
8113f9f0:	e0bffe03 	ldbu	r2,-8(fp)
8113f9f4:	10803fe0 	cmpeqi	r2,r2,255
8113f9f8:	1000021e 	bne	r2,zero,8113fa04 <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
8113f9fc:	00800a84 	movi	r2,42
8113fa00:	00003406 	br	8113fad4 <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
8113fa04:	e0bfff17 	ldw	r2,-4(fp)
8113fa08:	1000021e 	bne	r2,zero,8113fa14 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
8113fa0c:	00800244 	movi	r2,9
8113fa10:	00003006 	br	8113fad4 <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fa14:	0005303a 	rdctl	r2,status
8113fa18:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fa1c:	e0fffd17 	ldw	r3,-12(fp)
8113fa20:	00bfff84 	movi	r2,-2
8113fa24:	1884703a 	and	r2,r3,r2
8113fa28:	1001703a 	wrctl	status,r2
  
  return context;
8113fa2c:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113fa30:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
8113fa34:	e0bffe03 	ldbu	r2,-8(fp)
8113fa38:	10803fd8 	cmpnei	r2,r2,255
8113fa3c:	1000031e 	bne	r2,zero,8113fa4c <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
8113fa40:	d0a0a117 	ldw	r2,-32124(gp)
8113fa44:	10800c83 	ldbu	r2,50(r2)
8113fa48:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113fa4c:	e0fffe03 	ldbu	r3,-8(fp)
8113fa50:	00a045f4 	movhi	r2,33047
8113fa54:	10af6e04 	addi	r2,r2,-16968
8113fa58:	18c7883a 	add	r3,r3,r3
8113fa5c:	18c7883a 	add	r3,r3,r3
8113fa60:	10c5883a 	add	r2,r2,r3
8113fa64:	10800017 	ldw	r2,0(r2)
8113fa68:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
8113fa6c:	e0bffa17 	ldw	r2,-24(fp)
8113fa70:	1000061e 	bne	r2,zero,8113fa8c <OSTaskQuery+0xd0>
8113fa74:	e0bff817 	ldw	r2,-32(fp)
8113fa78:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fa7c:	e0bff917 	ldw	r2,-28(fp)
8113fa80:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
8113fa84:	00800a44 	movi	r2,41
8113fa88:	00001206 	br	8113fad4 <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
8113fa8c:	e0bffa17 	ldw	r2,-24(fp)
8113fa90:	10800058 	cmpnei	r2,r2,1
8113fa94:	1000061e 	bne	r2,zero,8113fab0 <OSTaskQuery+0xf4>
8113fa98:	e0bff817 	ldw	r2,-32(fp)
8113fa9c:	e0bffb15 	stw	r2,-20(fp)
8113faa0:	e0bffb17 	ldw	r2,-20(fp)
8113faa4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113faa8:	008010c4 	movi	r2,67
8113faac:	00000906 	br	8113fad4 <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
8113fab0:	01801b04 	movi	r6,108
8113fab4:	e17ffa17 	ldw	r5,-24(fp)
8113fab8:	e13fff17 	ldw	r4,-4(fp)
8113fabc:	1138db40 	call	81138db4 <OS_MemCopy>
8113fac0:	e0bff817 	ldw	r2,-32(fp)
8113fac4:	e0bffc15 	stw	r2,-16(fp)
8113fac8:	e0bffc17 	ldw	r2,-16(fp)
8113facc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113fad0:	0005883a 	mov	r2,zero
}
8113fad4:	e037883a 	mov	sp,fp
8113fad8:	dfc00117 	ldw	ra,4(sp)
8113fadc:	df000017 	ldw	fp,0(sp)
8113fae0:	dec00204 	addi	sp,sp,8
8113fae4:	f800283a 	ret

8113fae8 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
8113fae8:	defffc04 	addi	sp,sp,-16
8113faec:	de00012e 	bgeu	sp,et,8113faf4 <OS_TaskStkClr+0xc>
8113faf0:	003b68fa 	trap	3
8113faf4:	df000315 	stw	fp,12(sp)
8113faf8:	df000304 	addi	fp,sp,12
8113fafc:	e13ffd15 	stw	r4,-12(fp)
8113fb00:	e17ffe15 	stw	r5,-8(fp)
8113fb04:	3005883a 	mov	r2,r6
8113fb08:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
8113fb0c:	e0bfff0b 	ldhu	r2,-4(fp)
8113fb10:	1080004c 	andi	r2,r2,1
8113fb14:	10000d26 	beq	r2,zero,8113fb4c <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
8113fb18:	e0bfff0b 	ldhu	r2,-4(fp)
8113fb1c:	1080008c 	andi	r2,r2,2
8113fb20:	10000a26 	beq	r2,zero,8113fb4c <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8113fb24:	00000706 	br	8113fb44 <OS_TaskStkClr+0x5c>
                size--;
8113fb28:	e0bffe17 	ldw	r2,-8(fp)
8113fb2c:	10bfffc4 	addi	r2,r2,-1
8113fb30:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
8113fb34:	e0bffd17 	ldw	r2,-12(fp)
8113fb38:	10c00104 	addi	r3,r2,4
8113fb3c:	e0fffd15 	stw	r3,-12(fp)
8113fb40:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8113fb44:	e0bffe17 	ldw	r2,-8(fp)
8113fb48:	103ff71e 	bne	r2,zero,8113fb28 <__reset+0xfb11fb28>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
8113fb4c:	0001883a 	nop
8113fb50:	e037883a 	mov	sp,fp
8113fb54:	df000017 	ldw	fp,0(sp)
8113fb58:	dec00104 	addi	sp,sp,4
8113fb5c:	f800283a 	ret

8113fb60 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
8113fb60:	defff904 	addi	sp,sp,-28
8113fb64:	de00012e 	bgeu	sp,et,8113fb6c <OSTimeDly+0xc>
8113fb68:	003b68fa 	trap	3
8113fb6c:	dfc00615 	stw	ra,24(sp)
8113fb70:	df000515 	stw	fp,20(sp)
8113fb74:	df000504 	addi	fp,sp,20
8113fb78:	2005883a 	mov	r2,r4
8113fb7c:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113fb80:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113fb84:	d0a0a003 	ldbu	r2,-32128(gp)
8113fb88:	10803fcc 	andi	r2,r2,255
8113fb8c:	1000311e 	bne	r2,zero,8113fc54 <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
8113fb90:	e0bfff0b 	ldhu	r2,-4(fp)
8113fb94:	10003026 	beq	r2,zero,8113fc58 <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fb98:	0005303a 	rdctl	r2,status
8113fb9c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fba0:	e0fffe17 	ldw	r3,-8(fp)
8113fba4:	00bfff84 	movi	r2,-2
8113fba8:	1884703a 	and	r2,r3,r2
8113fbac:	1001703a 	wrctl	status,r2
  
  return context;
8113fbb0:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
8113fbb4:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
8113fbb8:	d0a0a117 	ldw	r2,-32124(gp)
8113fbbc:	10800d03 	ldbu	r2,52(r2)
8113fbc0:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8113fbc4:	e0fffd03 	ldbu	r3,-12(fp)
8113fbc8:	e13ffd03 	ldbu	r4,-12(fp)
8113fbcc:	d0a09d44 	addi	r2,gp,-32139
8113fbd0:	2085883a 	add	r2,r4,r2
8113fbd4:	10800003 	ldbu	r2,0(r2)
8113fbd8:	1009883a 	mov	r4,r2
8113fbdc:	d0a0a117 	ldw	r2,-32124(gp)
8113fbe0:	10800d43 	ldbu	r2,53(r2)
8113fbe4:	0084303a 	nor	r2,zero,r2
8113fbe8:	2084703a 	and	r2,r4,r2
8113fbec:	1009883a 	mov	r4,r2
8113fbf0:	d0a09d44 	addi	r2,gp,-32139
8113fbf4:	1885883a 	add	r2,r3,r2
8113fbf8:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
8113fbfc:	e0fffd03 	ldbu	r3,-12(fp)
8113fc00:	d0a09d44 	addi	r2,gp,-32139
8113fc04:	1885883a 	add	r2,r3,r2
8113fc08:	10800003 	ldbu	r2,0(r2)
8113fc0c:	10803fcc 	andi	r2,r2,255
8113fc10:	1000071e 	bne	r2,zero,8113fc30 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8113fc14:	d0a0a117 	ldw	r2,-32124(gp)
8113fc18:	10800d83 	ldbu	r2,54(r2)
8113fc1c:	0084303a 	nor	r2,zero,r2
8113fc20:	1007883a 	mov	r3,r2
8113fc24:	d0a09d03 	ldbu	r2,-32140(gp)
8113fc28:	1884703a 	and	r2,r3,r2
8113fc2c:	d0a09d05 	stb	r2,-32140(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
8113fc30:	d0a0a117 	ldw	r2,-32124(gp)
8113fc34:	e0ffff0b 	ldhu	r3,-4(fp)
8113fc38:	10c00b8d 	sth	r3,46(r2)
8113fc3c:	e0bffb17 	ldw	r2,-20(fp)
8113fc40:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fc44:	e0bffc17 	ldw	r2,-16(fp)
8113fc48:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
8113fc4c:	1138e240 	call	81138e24 <OS_Sched>
8113fc50:	00000106 	br	8113fc58 <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
8113fc54:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
8113fc58:	e037883a 	mov	sp,fp
8113fc5c:	dfc00117 	ldw	ra,4(sp)
8113fc60:	df000017 	ldw	fp,0(sp)
8113fc64:	dec00204 	addi	sp,sp,8
8113fc68:	f800283a 	ret

8113fc6c <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
8113fc6c:	defff804 	addi	sp,sp,-32
8113fc70:	de00012e 	bgeu	sp,et,8113fc78 <OSTimeDlyHMSM+0xc>
8113fc74:	003b68fa 	trap	3
8113fc78:	dfc00715 	stw	ra,28(sp)
8113fc7c:	df000615 	stw	fp,24(sp)
8113fc80:	df000604 	addi	fp,sp,24
8113fc84:	2015883a 	mov	r10,r4
8113fc88:	2809883a 	mov	r4,r5
8113fc8c:	3007883a 	mov	r3,r6
8113fc90:	3805883a 	mov	r2,r7
8113fc94:	e2bffc05 	stb	r10,-16(fp)
8113fc98:	e13ffd05 	stb	r4,-12(fp)
8113fc9c:	e0fffe05 	stb	r3,-8(fp)
8113fca0:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113fca4:	d0a0a003 	ldbu	r2,-32128(gp)
8113fca8:	10803fcc 	andi	r2,r2,255
8113fcac:	10000226 	beq	r2,zero,8113fcb8 <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
8113fcb0:	00801544 	movi	r2,85
8113fcb4:	00004106 	br	8113fdbc <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
8113fcb8:	e0bffc03 	ldbu	r2,-16(fp)
8113fcbc:	1000081e 	bne	r2,zero,8113fce0 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
8113fcc0:	e0bffd03 	ldbu	r2,-12(fp)
8113fcc4:	1000061e 	bne	r2,zero,8113fce0 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
8113fcc8:	e0bffe03 	ldbu	r2,-8(fp)
8113fccc:	1000041e 	bne	r2,zero,8113fce0 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
8113fcd0:	e0bfff0b 	ldhu	r2,-4(fp)
8113fcd4:	1000021e 	bne	r2,zero,8113fce0 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
8113fcd8:	00801504 	movi	r2,84
8113fcdc:	00003706 	br	8113fdbc <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
8113fce0:	e0bffd03 	ldbu	r2,-12(fp)
8113fce4:	10800f30 	cmpltui	r2,r2,60
8113fce8:	1000021e 	bne	r2,zero,8113fcf4 <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
8113fcec:	00801444 	movi	r2,81
8113fcf0:	00003206 	br	8113fdbc <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
8113fcf4:	e0bffe03 	ldbu	r2,-8(fp)
8113fcf8:	10800f30 	cmpltui	r2,r2,60
8113fcfc:	1000021e 	bne	r2,zero,8113fd08 <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
8113fd00:	00801484 	movi	r2,82
8113fd04:	00002d06 	br	8113fdbc <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
8113fd08:	e0bfff0b 	ldhu	r2,-4(fp)
8113fd0c:	1080fa30 	cmpltui	r2,r2,1000
8113fd10:	1000021e 	bne	r2,zero,8113fd1c <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
8113fd14:	008014c4 	movi	r2,83
8113fd18:	00002806 	br	8113fdbc <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8113fd1c:	e0bffc03 	ldbu	r2,-16(fp)
8113fd20:	10c38424 	muli	r3,r2,3600
8113fd24:	e0bffd03 	ldbu	r2,-12(fp)
8113fd28:	10800f24 	muli	r2,r2,60
8113fd2c:	1887883a 	add	r3,r3,r2
8113fd30:	e0bffe03 	ldbu	r2,-8(fp)
8113fd34:	1885883a 	add	r2,r3,r2
8113fd38:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
8113fd3c:	e0bfff0b 	ldhu	r2,-4(fp)
8113fd40:	10c0fa24 	muli	r3,r2,1000
8113fd44:	008418b4 	movhi	r2,4194
8113fd48:	109374c4 	addi	r2,r2,19923
8113fd4c:	188a383a 	mulxuu	r5,r3,r2
8113fd50:	1885383a 	mul	r2,r3,r2
8113fd54:	1011883a 	mov	r8,r2
8113fd58:	2813883a 	mov	r9,r5
8113fd5c:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8113fd60:	2085883a 	add	r2,r4,r2
8113fd64:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
8113fd68:	e0bffb17 	ldw	r2,-20(fp)
8113fd6c:	1004d43a 	srli	r2,r2,16
8113fd70:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
8113fd74:	e0bffb17 	ldw	r2,-20(fp)
8113fd78:	10bfffcc 	andi	r2,r2,65535
8113fd7c:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
8113fd80:	e0bffb17 	ldw	r2,-20(fp)
8113fd84:	10bfffcc 	andi	r2,r2,65535
8113fd88:	1009883a 	mov	r4,r2
8113fd8c:	113fb600 	call	8113fb60 <OSTimeDly>
    while (loops > 0) {
8113fd90:	00000706 	br	8113fdb0 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
8113fd94:	01200014 	movui	r4,32768
8113fd98:	113fb600 	call	8113fb60 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
8113fd9c:	01200014 	movui	r4,32768
8113fda0:	113fb600 	call	8113fb60 <OSTimeDly>
        loops--;
8113fda4:	e0bffa0b 	ldhu	r2,-24(fp)
8113fda8:	10bfffc4 	addi	r2,r2,-1
8113fdac:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
8113fdb0:	e0bffa0b 	ldhu	r2,-24(fp)
8113fdb4:	103ff71e 	bne	r2,zero,8113fd94 <__reset+0xfb11fd94>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
8113fdb8:	0005883a 	mov	r2,zero
}
8113fdbc:	e037883a 	mov	sp,fp
8113fdc0:	dfc00117 	ldw	ra,4(sp)
8113fdc4:	df000017 	ldw	fp,0(sp)
8113fdc8:	dec00204 	addi	sp,sp,8
8113fdcc:	f800283a 	ret

8113fdd0 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
8113fdd0:	defff504 	addi	sp,sp,-44
8113fdd4:	de00012e 	bgeu	sp,et,8113fddc <OSTimeDlyResume+0xc>
8113fdd8:	003b68fa 	trap	3
8113fddc:	dfc00a15 	stw	ra,40(sp)
8113fde0:	df000915 	stw	fp,36(sp)
8113fde4:	df000904 	addi	fp,sp,36
8113fde8:	2005883a 	mov	r2,r4
8113fdec:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113fdf0:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
8113fdf4:	e0bfff03 	ldbu	r2,-4(fp)
8113fdf8:	10800ab0 	cmpltui	r2,r2,42
8113fdfc:	1000021e 	bne	r2,zero,8113fe08 <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8113fe00:	00800a84 	movi	r2,42
8113fe04:	00006406 	br	8113ff98 <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fe08:	0005303a 	rdctl	r2,status
8113fe0c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fe10:	e0fffe17 	ldw	r3,-8(fp)
8113fe14:	00bfff84 	movi	r2,-2
8113fe18:	1884703a 	and	r2,r3,r2
8113fe1c:	1001703a 	wrctl	status,r2
  
  return context;
8113fe20:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113fe24:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
8113fe28:	e0ffff03 	ldbu	r3,-4(fp)
8113fe2c:	00a045f4 	movhi	r2,33047
8113fe30:	10af6e04 	addi	r2,r2,-16968
8113fe34:	18c7883a 	add	r3,r3,r3
8113fe38:	18c7883a 	add	r3,r3,r3
8113fe3c:	10c5883a 	add	r2,r2,r3
8113fe40:	10800017 	ldw	r2,0(r2)
8113fe44:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
8113fe48:	e0bff917 	ldw	r2,-28(fp)
8113fe4c:	1000061e 	bne	r2,zero,8113fe68 <OSTimeDlyResume+0x98>
8113fe50:	e0bff717 	ldw	r2,-36(fp)
8113fe54:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fe58:	e0bff817 	ldw	r2,-32(fp)
8113fe5c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8113fe60:	008010c4 	movi	r2,67
8113fe64:	00004c06 	br	8113ff98 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113fe68:	e0bff917 	ldw	r2,-28(fp)
8113fe6c:	10800058 	cmpnei	r2,r2,1
8113fe70:	1000061e 	bne	r2,zero,8113fe8c <OSTimeDlyResume+0xbc>
8113fe74:	e0bff717 	ldw	r2,-36(fp)
8113fe78:	e0bffa15 	stw	r2,-24(fp)
8113fe7c:	e0bffa17 	ldw	r2,-24(fp)
8113fe80:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8113fe84:	008010c4 	movi	r2,67
8113fe88:	00004306 	br	8113ff98 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
8113fe8c:	e0bff917 	ldw	r2,-28(fp)
8113fe90:	10800b8b 	ldhu	r2,46(r2)
8113fe94:	10bfffcc 	andi	r2,r2,65535
8113fe98:	1000061e 	bne	r2,zero,8113feb4 <OSTimeDlyResume+0xe4>
8113fe9c:	e0bff717 	ldw	r2,-36(fp)
8113fea0:	e0bffb15 	stw	r2,-20(fp)
8113fea4:	e0bffb17 	ldw	r2,-20(fp)
8113fea8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
8113feac:	00801404 	movi	r2,80
8113feb0:	00003906 	br	8113ff98 <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
8113feb4:	e0bff917 	ldw	r2,-28(fp)
8113feb8:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8113febc:	e0bff917 	ldw	r2,-28(fp)
8113fec0:	10800c03 	ldbu	r2,48(r2)
8113fec4:	10803fcc 	andi	r2,r2,255
8113fec8:	10800dcc 	andi	r2,r2,55
8113fecc:	10000b26 	beq	r2,zero,8113fefc <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
8113fed0:	e0bff917 	ldw	r2,-28(fp)
8113fed4:	10c00c03 	ldbu	r3,48(r2)
8113fed8:	00bff204 	movi	r2,-56
8113fedc:	1884703a 	and	r2,r3,r2
8113fee0:	1007883a 	mov	r3,r2
8113fee4:	e0bff917 	ldw	r2,-28(fp)
8113fee8:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
8113feec:	e0bff917 	ldw	r2,-28(fp)
8113fef0:	00c00044 	movi	r3,1
8113fef4:	10c00c45 	stb	r3,49(r2)
8113fef8:	00000206 	br	8113ff04 <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
8113fefc:	e0bff917 	ldw	r2,-28(fp)
8113ff00:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
8113ff04:	e0bff917 	ldw	r2,-28(fp)
8113ff08:	10800c03 	ldbu	r2,48(r2)
8113ff0c:	10803fcc 	andi	r2,r2,255
8113ff10:	1080020c 	andi	r2,r2,8
8113ff14:	10001b1e 	bne	r2,zero,8113ff84 <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
8113ff18:	e0bff917 	ldw	r2,-28(fp)
8113ff1c:	10c00d83 	ldbu	r3,54(r2)
8113ff20:	d0a09d03 	ldbu	r2,-32140(gp)
8113ff24:	1884b03a 	or	r2,r3,r2
8113ff28:	d0a09d05 	stb	r2,-32140(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113ff2c:	e0bff917 	ldw	r2,-28(fp)
8113ff30:	10800d03 	ldbu	r2,52(r2)
8113ff34:	10c03fcc 	andi	r3,r2,255
8113ff38:	e0bff917 	ldw	r2,-28(fp)
8113ff3c:	10800d03 	ldbu	r2,52(r2)
8113ff40:	11003fcc 	andi	r4,r2,255
8113ff44:	d0a09d44 	addi	r2,gp,-32139
8113ff48:	2085883a 	add	r2,r4,r2
8113ff4c:	11000003 	ldbu	r4,0(r2)
8113ff50:	e0bff917 	ldw	r2,-28(fp)
8113ff54:	10800d43 	ldbu	r2,53(r2)
8113ff58:	2084b03a 	or	r2,r4,r2
8113ff5c:	1009883a 	mov	r4,r2
8113ff60:	d0a09d44 	addi	r2,gp,-32139
8113ff64:	1885883a 	add	r2,r3,r2
8113ff68:	11000005 	stb	r4,0(r2)
8113ff6c:	e0bff717 	ldw	r2,-36(fp)
8113ff70:	e0bffc15 	stw	r2,-16(fp)
8113ff74:	e0bffc17 	ldw	r2,-16(fp)
8113ff78:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
8113ff7c:	1138e240 	call	81138e24 <OS_Sched>
8113ff80:	00000406 	br	8113ff94 <OSTimeDlyResume+0x1c4>
8113ff84:	e0bff717 	ldw	r2,-36(fp)
8113ff88:	e0bffd15 	stw	r2,-12(fp)
8113ff8c:	e0bffd17 	ldw	r2,-12(fp)
8113ff90:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
8113ff94:	0005883a 	mov	r2,zero
}
8113ff98:	e037883a 	mov	sp,fp
8113ff9c:	dfc00117 	ldw	ra,4(sp)
8113ffa0:	df000017 	ldw	fp,0(sp)
8113ffa4:	dec00204 	addi	sp,sp,8
8113ffa8:	f800283a 	ret

8113ffac <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
8113ffac:	defffb04 	addi	sp,sp,-20
8113ffb0:	de00012e 	bgeu	sp,et,8113ffb8 <OSTimeGet+0xc>
8113ffb4:	003b68fa 	trap	3
8113ffb8:	df000415 	stw	fp,16(sp)
8113ffbc:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ffc0:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ffc4:	0005303a 	rdctl	r2,status
8113ffc8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ffcc:	e0fffe17 	ldw	r3,-8(fp)
8113ffd0:	00bfff84 	movi	r2,-2
8113ffd4:	1884703a 	and	r2,r3,r2
8113ffd8:	1001703a 	wrctl	status,r2
  
  return context;
8113ffdc:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113ffe0:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
8113ffe4:	d0a0a317 	ldw	r2,-32116(gp)
8113ffe8:	e0bffd15 	stw	r2,-12(fp)
8113ffec:	e0bffc17 	ldw	r2,-16(fp)
8113fff0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fff4:	e0bfff17 	ldw	r2,-4(fp)
8113fff8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
8113fffc:	e0bffd17 	ldw	r2,-12(fp)
}
81140000:	e037883a 	mov	sp,fp
81140004:	df000017 	ldw	fp,0(sp)
81140008:	dec00104 	addi	sp,sp,4
8114000c:	f800283a 	ret

81140010 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
81140010:	defffb04 	addi	sp,sp,-20
81140014:	de00012e 	bgeu	sp,et,8114001c <OSTimeSet+0xc>
81140018:	003b68fa 	trap	3
8114001c:	df000415 	stw	fp,16(sp)
81140020:	df000404 	addi	fp,sp,16
81140024:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81140028:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114002c:	0005303a 	rdctl	r2,status
81140030:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140034:	e0fffd17 	ldw	r3,-12(fp)
81140038:	00bfff84 	movi	r2,-2
8114003c:	1884703a 	and	r2,r3,r2
81140040:	1001703a 	wrctl	status,r2
  
  return context;
81140044:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
81140048:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
8114004c:	e0bfff17 	ldw	r2,-4(fp)
81140050:	d0a0a315 	stw	r2,-32116(gp)
81140054:	e0bffc17 	ldw	r2,-16(fp)
81140058:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114005c:	e0bffe17 	ldw	r2,-8(fp)
81140060:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81140064:	0001883a 	nop
81140068:	e037883a 	mov	sp,fp
8114006c:	df000017 	ldw	fp,0(sp)
81140070:	dec00104 	addi	sp,sp,4
81140074:	f800283a 	ret

81140078 <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
81140078:	defff804 	addi	sp,sp,-32
8114007c:	de00012e 	bgeu	sp,et,81140084 <OSTmrCreate+0xc>
81140080:	003b68fa 	trap	3
81140084:	dfc00715 	stw	ra,28(sp)
81140088:	df000615 	stw	fp,24(sp)
8114008c:	df000604 	addi	fp,sp,24
81140090:	e13ffc15 	stw	r4,-16(fp)
81140094:	e17ffd15 	stw	r5,-12(fp)
81140098:	3005883a 	mov	r2,r6
8114009c:	e1ffff15 	stw	r7,-4(fp)
811400a0:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
811400a4:	e0800417 	ldw	r2,16(fp)
811400a8:	1000021e 	bne	r2,zero,811400b4 <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
811400ac:	0005883a 	mov	r2,zero
811400b0:	00005d06 	br	81140228 <OSTmrCreate+0x1b0>
    }
    switch (opt) {
811400b4:	e0bffe03 	ldbu	r2,-8(fp)
811400b8:	10c00060 	cmpeqi	r3,r2,1
811400bc:	1800091e 	bne	r3,zero,811400e4 <OSTmrCreate+0x6c>
811400c0:	108000a0 	cmpeqi	r2,r2,2
811400c4:	10000e26 	beq	r2,zero,81140100 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
811400c8:	e0bffd17 	ldw	r2,-12(fp)
811400cc:	1000111e 	bne	r2,zero,81140114 <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
811400d0:	e0800417 	ldw	r2,16(fp)
811400d4:	00ffe0c4 	movi	r3,-125
811400d8:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
811400dc:	0005883a 	mov	r2,zero
811400e0:	00005106 	br	81140228 <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
811400e4:	e0bffc17 	ldw	r2,-16(fp)
811400e8:	10000c1e 	bne	r2,zero,8114011c <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
811400ec:	e0800417 	ldw	r2,16(fp)
811400f0:	00ffe084 	movi	r3,-126
811400f4:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
811400f8:	0005883a 	mov	r2,zero
811400fc:	00004a06 	br	81140228 <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
81140100:	e0800417 	ldw	r2,16(fp)
81140104:	00ffe104 	movi	r3,-124
81140108:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
8114010c:	0005883a 	mov	r2,zero
81140110:	00004506 	br	81140228 <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
81140114:	0001883a 	nop
81140118:	00000106 	br	81140120 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
8114011c:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81140120:	d0a0a003 	ldbu	r2,-32128(gp)
81140124:	10803fcc 	andi	r2,r2,255
81140128:	10000526 	beq	r2,zero,81140140 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
8114012c:	e0800417 	ldw	r2,16(fp)
81140130:	00ffe2c4 	movi	r3,-117
81140134:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81140138:	0005883a 	mov	r2,zero
8114013c:	00003a06 	br	81140228 <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
81140140:	11410300 	call	81141030 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
81140144:	1140ad00 	call	81140ad0 <OSTmr_Alloc>
81140148:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
8114014c:	e0bffa17 	ldw	r2,-24(fp)
81140150:	1000061e 	bne	r2,zero,8114016c <OSTmrCreate+0xf4>
        OSTmr_Unlock();
81140154:	11410740 	call	81141074 <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
81140158:	e0800417 	ldw	r2,16(fp)
8114015c:	00ffe184 	movi	r3,-122
81140160:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81140164:	0005883a 	mov	r2,zero
81140168:	00002f06 	br	81140228 <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
8114016c:	e0bffa17 	ldw	r2,-24(fp)
81140170:	00c00044 	movi	r3,1
81140174:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
81140178:	e0bffa17 	ldw	r2,-24(fp)
8114017c:	e0fffc17 	ldw	r3,-16(fp)
81140180:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
81140184:	e0bffa17 	ldw	r2,-24(fp)
81140188:	e0fffd17 	ldw	r3,-12(fp)
8114018c:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
81140190:	e0bffa17 	ldw	r2,-24(fp)
81140194:	e0fffe03 	ldbu	r3,-8(fp)
81140198:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
8114019c:	e0bffa17 	ldw	r2,-24(fp)
811401a0:	e0ffff17 	ldw	r3,-4(fp)
811401a4:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
811401a8:	e0bffa17 	ldw	r2,-24(fp)
811401ac:	e0c00217 	ldw	r3,8(fp)
811401b0:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
811401b4:	e0800317 	ldw	r2,12(fp)
811401b8:	10001726 	beq	r2,zero,81140218 <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
811401bc:	e1000317 	ldw	r4,12(fp)
811401c0:	1138ff40 	call	81138ff4 <OS_StrLen>
811401c4:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
811401c8:	e0bffb03 	ldbu	r2,-20(fp)
811401cc:	10800428 	cmpgeui	r2,r2,16
811401d0:	1000061e 	bne	r2,zero,811401ec <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
811401d4:	e0bffa17 	ldw	r2,-24(fp)
811401d8:	10800804 	addi	r2,r2,32
811401dc:	e1400317 	ldw	r5,12(fp)
811401e0:	1009883a 	mov	r4,r2
811401e4:	1138f780 	call	81138f78 <OS_StrCopy>
811401e8:	00000b06 	br	81140218 <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
811401ec:	e0bffa17 	ldw	r2,-24(fp)
811401f0:	00c008c4 	movi	r3,35
811401f4:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
811401f8:	e0bffa17 	ldw	r2,-24(fp)
811401fc:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
81140200:	e0800417 	ldw	r2,16(fp)
81140204:	00ffe304 	movi	r3,-116
81140208:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
8114020c:	11410740 	call	81141074 <OSTmr_Unlock>
            return (ptmr);
81140210:	e0bffa17 	ldw	r2,-24(fp)
81140214:	00000406 	br	81140228 <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
81140218:	11410740 	call	81141074 <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
8114021c:	e0800417 	ldw	r2,16(fp)
81140220:	10000005 	stb	zero,0(r2)
    return (ptmr);
81140224:	e0bffa17 	ldw	r2,-24(fp)
}
81140228:	e037883a 	mov	sp,fp
8114022c:	dfc00117 	ldw	ra,4(sp)
81140230:	df000017 	ldw	fp,0(sp)
81140234:	dec00204 	addi	sp,sp,8
81140238:	f800283a 	ret

8114023c <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
8114023c:	defffc04 	addi	sp,sp,-16
81140240:	de00012e 	bgeu	sp,et,81140248 <OSTmrDel+0xc>
81140244:	003b68fa 	trap	3
81140248:	dfc00315 	stw	ra,12(sp)
8114024c:	df000215 	stw	fp,8(sp)
81140250:	df000204 	addi	fp,sp,8
81140254:	e13ffe15 	stw	r4,-8(fp)
81140258:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8114025c:	e0bfff17 	ldw	r2,-4(fp)
81140260:	1000021e 	bne	r2,zero,8114026c <OSTmrDel+0x30>
        return (OS_FALSE);
81140264:	0005883a 	mov	r2,zero
81140268:	00003f06 	br	81140368 <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8114026c:	e0bffe17 	ldw	r2,-8(fp)
81140270:	1000051e 	bne	r2,zero,81140288 <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81140274:	e0bfff17 	ldw	r2,-4(fp)
81140278:	00ffe284 	movi	r3,-118
8114027c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81140280:	0005883a 	mov	r2,zero
81140284:	00003806 	br	81140368 <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
81140288:	e0bffe17 	ldw	r2,-8(fp)
8114028c:	10800003 	ldbu	r2,0(r2)
81140290:	10803fcc 	andi	r2,r2,255
81140294:	10801920 	cmpeqi	r2,r2,100
81140298:	1000051e 	bne	r2,zero,811402b0 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8114029c:	e0bfff17 	ldw	r2,-4(fp)
811402a0:	00ffe244 	movi	r3,-119
811402a4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811402a8:	0005883a 	mov	r2,zero
811402ac:	00002e06 	br	81140368 <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
811402b0:	d0a0a003 	ldbu	r2,-32128(gp)
811402b4:	10803fcc 	andi	r2,r2,255
811402b8:	10000526 	beq	r2,zero,811402d0 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
811402bc:	e0bfff17 	ldw	r2,-4(fp)
811402c0:	00ffe2c4 	movi	r3,-117
811402c4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811402c8:	0005883a 	mov	r2,zero
811402cc:	00002606 	br	81140368 <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
811402d0:	11410300 	call	81141030 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
811402d4:	e0bffe17 	ldw	r2,-8(fp)
811402d8:	10800c43 	ldbu	r2,49(r2)
811402dc:	10803fcc 	andi	r2,r2,255
811402e0:	10c000c8 	cmpgei	r3,r2,3
811402e4:	1800031e 	bne	r3,zero,811402f4 <OSTmrDel+0xb8>
811402e8:	00800d16 	blt	zero,r2,81140320 <OSTmrDel+0xe4>
811402ec:	10001326 	beq	r2,zero,8114033c <OSTmrDel+0x100>
811402f0:	00001806 	br	81140354 <OSTmrDel+0x118>
811402f4:	108000e0 	cmpeqi	r2,r2,3
811402f8:	10001626 	beq	r2,zero,81140354 <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
811402fc:	e13ffe17 	ldw	r4,-8(fp)
81140300:	1140f340 	call	81140f34 <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81140304:	e13ffe17 	ldw	r4,-8(fp)
81140308:	1140b440 	call	81140b44 <OSTmr_Free>
             OSTmr_Unlock();
8114030c:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81140310:	e0bfff17 	ldw	r2,-4(fp)
81140314:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81140318:	00800044 	movi	r2,1
8114031c:	00001206 	br	81140368 <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81140320:	e13ffe17 	ldw	r4,-8(fp)
81140324:	1140b440 	call	81140b44 <OSTmr_Free>
             OSTmr_Unlock();
81140328:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8114032c:	e0bfff17 	ldw	r2,-4(fp)
81140330:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81140334:	00800044 	movi	r2,1
81140338:	00000b06 	br	81140368 <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
8114033c:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81140340:	e0bfff17 	ldw	r2,-4(fp)
81140344:	00ffe1c4 	movi	r3,-121
81140348:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8114034c:	0005883a 	mov	r2,zero
81140350:	00000506 	br	81140368 <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
81140354:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81140358:	e0bfff17 	ldw	r2,-4(fp)
8114035c:	00ffe344 	movi	r3,-115
81140360:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81140364:	0005883a 	mov	r2,zero
    }
}
81140368:	e037883a 	mov	sp,fp
8114036c:	dfc00117 	ldw	ra,4(sp)
81140370:	df000017 	ldw	fp,0(sp)
81140374:	dec00204 	addi	sp,sp,8
81140378:	f800283a 	ret

8114037c <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
8114037c:	defffa04 	addi	sp,sp,-24
81140380:	de00012e 	bgeu	sp,et,81140388 <OSTmrNameGet+0xc>
81140384:	003b68fa 	trap	3
81140388:	dfc00515 	stw	ra,20(sp)
8114038c:	df000415 	stw	fp,16(sp)
81140390:	df000404 	addi	fp,sp,16
81140394:	e13ffd15 	stw	r4,-12(fp)
81140398:	e17ffe15 	stw	r5,-8(fp)
8114039c:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
811403a0:	e0bfff17 	ldw	r2,-4(fp)
811403a4:	1000021e 	bne	r2,zero,811403b0 <OSTmrNameGet+0x34>
        return (0);
811403a8:	0005883a 	mov	r2,zero
811403ac:	00003e06 	br	811404a8 <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
811403b0:	e0bffe17 	ldw	r2,-8(fp)
811403b4:	1000051e 	bne	r2,zero,811403cc <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
811403b8:	e0bfff17 	ldw	r2,-4(fp)
811403bc:	00ffe204 	movi	r3,-120
811403c0:	10c00005 	stb	r3,0(r2)
        return (0);
811403c4:	0005883a 	mov	r2,zero
811403c8:	00003706 	br	811404a8 <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
811403cc:	e0bffd17 	ldw	r2,-12(fp)
811403d0:	1000051e 	bne	r2,zero,811403e8 <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
811403d4:	e0bfff17 	ldw	r2,-4(fp)
811403d8:	00ffe284 	movi	r3,-118
811403dc:	10c00005 	stb	r3,0(r2)
        return (0);
811403e0:	0005883a 	mov	r2,zero
811403e4:	00003006 	br	811404a8 <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
811403e8:	e0bffd17 	ldw	r2,-12(fp)
811403ec:	10800003 	ldbu	r2,0(r2)
811403f0:	10803fcc 	andi	r2,r2,255
811403f4:	10801920 	cmpeqi	r2,r2,100
811403f8:	1000051e 	bne	r2,zero,81140410 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
811403fc:	e0bfff17 	ldw	r2,-4(fp)
81140400:	00ffe244 	movi	r3,-119
81140404:	10c00005 	stb	r3,0(r2)
        return (0);
81140408:	0005883a 	mov	r2,zero
8114040c:	00002606 	br	811404a8 <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81140410:	d0a0a003 	ldbu	r2,-32128(gp)
81140414:	10803fcc 	andi	r2,r2,255
81140418:	10000526 	beq	r2,zero,81140430 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
8114041c:	e0bfff17 	ldw	r2,-4(fp)
81140420:	00c00444 	movi	r3,17
81140424:	10c00005 	stb	r3,0(r2)
        return (0);
81140428:	0005883a 	mov	r2,zero
8114042c:	00001e06 	br	811404a8 <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
81140430:	11410300 	call	81141030 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81140434:	e0bffd17 	ldw	r2,-12(fp)
81140438:	10800c43 	ldbu	r2,49(r2)
8114043c:	10803fcc 	andi	r2,r2,255
81140440:	10000e26 	beq	r2,zero,8114047c <OSTmrNameGet+0x100>
81140444:	10001316 	blt	r2,zero,81140494 <OSTmrNameGet+0x118>
81140448:	10800108 	cmpgei	r2,r2,4
8114044c:	1000111e 	bne	r2,zero,81140494 <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
81140450:	e0bffd17 	ldw	r2,-12(fp)
81140454:	10800804 	addi	r2,r2,32
81140458:	100b883a 	mov	r5,r2
8114045c:	e13ffe17 	ldw	r4,-8(fp)
81140460:	1138f780 	call	81138f78 <OS_StrCopy>
81140464:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
81140468:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8114046c:	e0bfff17 	ldw	r2,-4(fp)
81140470:	10000005 	stb	zero,0(r2)
             return (len);
81140474:	e0bffc03 	ldbu	r2,-16(fp)
81140478:	00000b06 	br	811404a8 <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
8114047c:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81140480:	e0bfff17 	ldw	r2,-4(fp)
81140484:	00ffe1c4 	movi	r3,-121
81140488:	10c00005 	stb	r3,0(r2)
             return (0);
8114048c:	0005883a 	mov	r2,zero
81140490:	00000506 	br	811404a8 <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
81140494:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81140498:	e0bfff17 	ldw	r2,-4(fp)
8114049c:	00ffe344 	movi	r3,-115
811404a0:	10c00005 	stb	r3,0(r2)
             return (0);
811404a4:	0005883a 	mov	r2,zero
    }
}
811404a8:	e037883a 	mov	sp,fp
811404ac:	dfc00117 	ldw	ra,4(sp)
811404b0:	df000017 	ldw	fp,0(sp)
811404b4:	dec00204 	addi	sp,sp,8
811404b8:	f800283a 	ret

811404bc <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
811404bc:	defffb04 	addi	sp,sp,-20
811404c0:	de00012e 	bgeu	sp,et,811404c8 <OSTmrRemainGet+0xc>
811404c4:	003b68fa 	trap	3
811404c8:	dfc00415 	stw	ra,16(sp)
811404cc:	df000315 	stw	fp,12(sp)
811404d0:	df000304 	addi	fp,sp,12
811404d4:	e13ffe15 	stw	r4,-8(fp)
811404d8:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
811404dc:	e0bfff17 	ldw	r2,-4(fp)
811404e0:	1000021e 	bne	r2,zero,811404ec <OSTmrRemainGet+0x30>
        return (0);
811404e4:	0005883a 	mov	r2,zero
811404e8:	00005d06 	br	81140660 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
811404ec:	e0bffe17 	ldw	r2,-8(fp)
811404f0:	1000051e 	bne	r2,zero,81140508 <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
811404f4:	e0bfff17 	ldw	r2,-4(fp)
811404f8:	00ffe284 	movi	r3,-118
811404fc:	10c00005 	stb	r3,0(r2)
        return (0);
81140500:	0005883a 	mov	r2,zero
81140504:	00005606 	br	81140660 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81140508:	e0bffe17 	ldw	r2,-8(fp)
8114050c:	10800003 	ldbu	r2,0(r2)
81140510:	10803fcc 	andi	r2,r2,255
81140514:	10801920 	cmpeqi	r2,r2,100
81140518:	1000051e 	bne	r2,zero,81140530 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8114051c:	e0bfff17 	ldw	r2,-4(fp)
81140520:	00ffe244 	movi	r3,-119
81140524:	10c00005 	stb	r3,0(r2)
        return (0);
81140528:	0005883a 	mov	r2,zero
8114052c:	00004c06 	br	81140660 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81140530:	d0a0a003 	ldbu	r2,-32128(gp)
81140534:	10803fcc 	andi	r2,r2,255
81140538:	10000526 	beq	r2,zero,81140550 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8114053c:	e0bfff17 	ldw	r2,-4(fp)
81140540:	00ffe2c4 	movi	r3,-117
81140544:	10c00005 	stb	r3,0(r2)
        return (0);
81140548:	0005883a 	mov	r2,zero
8114054c:	00004406 	br	81140660 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
81140550:	11410300 	call	81141030 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81140554:	e0bffe17 	ldw	r2,-8(fp)
81140558:	10800c43 	ldbu	r2,49(r2)
8114055c:	10803fcc 	andi	r2,r2,255
81140560:	10c00060 	cmpeqi	r3,r2,1
81140564:	1800121e 	bne	r3,zero,811405b0 <OSTmrRemainGet+0xf4>
81140568:	10c00088 	cmpgei	r3,r2,2
8114056c:	1800021e 	bne	r3,zero,81140578 <OSTmrRemainGet+0xbc>
81140570:	10003026 	beq	r2,zero,81140634 <OSTmrRemainGet+0x178>
81140574:	00003506 	br	8114064c <OSTmrRemainGet+0x190>
81140578:	10c000a0 	cmpeqi	r3,r2,2
8114057c:	1800281e 	bne	r3,zero,81140620 <OSTmrRemainGet+0x164>
81140580:	108000e0 	cmpeqi	r2,r2,3
81140584:	10003126 	beq	r2,zero,8114064c <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
81140588:	e0bffe17 	ldw	r2,-8(fp)
8114058c:	10c00517 	ldw	r3,20(r2)
81140590:	d0a0a217 	ldw	r2,-32120(gp)
81140594:	1885c83a 	sub	r2,r3,r2
81140598:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
8114059c:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
811405a0:	e0bfff17 	ldw	r2,-4(fp)
811405a4:	10000005 	stb	zero,0(r2)
             return (remain);
811405a8:	e0bffd17 	ldw	r2,-12(fp)
811405ac:	00002c06 	br	81140660 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
811405b0:	e0bffe17 	ldw	r2,-8(fp)
811405b4:	10800c03 	ldbu	r2,48(r2)
811405b8:	10803fcc 	andi	r2,r2,255
811405bc:	108000a0 	cmpeqi	r2,r2,2
811405c0:	10000e26 	beq	r2,zero,811405fc <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
811405c4:	e0bffe17 	ldw	r2,-8(fp)
811405c8:	10800617 	ldw	r2,24(r2)
811405cc:	1000041e 	bne	r2,zero,811405e0 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
811405d0:	e0bffe17 	ldw	r2,-8(fp)
811405d4:	10800717 	ldw	r2,28(r2)
811405d8:	e0bffd15 	stw	r2,-12(fp)
811405dc:	00000306 	br	811405ec <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
811405e0:	e0bffe17 	ldw	r2,-8(fp)
811405e4:	10800617 	ldw	r2,24(r2)
811405e8:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
811405ec:	11410740 	call	81141074 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
811405f0:	e0bfff17 	ldw	r2,-4(fp)
811405f4:	10000005 	stb	zero,0(r2)
                      break;
811405f8:	00000706 	br	81140618 <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
811405fc:	e0bffe17 	ldw	r2,-8(fp)
81140600:	10800617 	ldw	r2,24(r2)
81140604:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
81140608:	11410740 	call	81141074 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8114060c:	e0bfff17 	ldw	r2,-4(fp)
81140610:	10000005 	stb	zero,0(r2)
                      break;
81140614:	0001883a 	nop
             }
             return (remain);
81140618:	e0bffd17 	ldw	r2,-12(fp)
8114061c:	00001006 	br	81140660 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
81140620:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81140624:	e0bfff17 	ldw	r2,-4(fp)
81140628:	10000005 	stb	zero,0(r2)
             return (0);
8114062c:	0005883a 	mov	r2,zero
81140630:	00000b06 	br	81140660 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
81140634:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81140638:	e0bfff17 	ldw	r2,-4(fp)
8114063c:	00ffe1c4 	movi	r3,-121
81140640:	10c00005 	stb	r3,0(r2)
             return (0);
81140644:	0005883a 	mov	r2,zero
81140648:	00000506 	br	81140660 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
8114064c:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81140650:	e0bfff17 	ldw	r2,-4(fp)
81140654:	00ffe344 	movi	r3,-115
81140658:	10c00005 	stb	r3,0(r2)
             return (0);
8114065c:	0005883a 	mov	r2,zero
    }
}
81140660:	e037883a 	mov	sp,fp
81140664:	dfc00117 	ldw	ra,4(sp)
81140668:	df000017 	ldw	fp,0(sp)
8114066c:	dec00204 	addi	sp,sp,8
81140670:	f800283a 	ret

81140674 <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
81140674:	defffb04 	addi	sp,sp,-20
81140678:	de00012e 	bgeu	sp,et,81140680 <OSTmrStateGet+0xc>
8114067c:	003b68fa 	trap	3
81140680:	dfc00415 	stw	ra,16(sp)
81140684:	df000315 	stw	fp,12(sp)
81140688:	df000304 	addi	fp,sp,12
8114068c:	e13ffe15 	stw	r4,-8(fp)
81140690:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81140694:	e0bfff17 	ldw	r2,-4(fp)
81140698:	1000021e 	bne	r2,zero,811406a4 <OSTmrStateGet+0x30>
        return (0);
8114069c:	0005883a 	mov	r2,zero
811406a0:	00002a06 	br	8114074c <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
811406a4:	e0bffe17 	ldw	r2,-8(fp)
811406a8:	1000051e 	bne	r2,zero,811406c0 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
811406ac:	e0bfff17 	ldw	r2,-4(fp)
811406b0:	00ffe284 	movi	r3,-118
811406b4:	10c00005 	stb	r3,0(r2)
        return (0);
811406b8:	0005883a 	mov	r2,zero
811406bc:	00002306 	br	8114074c <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
811406c0:	e0bffe17 	ldw	r2,-8(fp)
811406c4:	10800003 	ldbu	r2,0(r2)
811406c8:	10803fcc 	andi	r2,r2,255
811406cc:	10801920 	cmpeqi	r2,r2,100
811406d0:	1000051e 	bne	r2,zero,811406e8 <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
811406d4:	e0bfff17 	ldw	r2,-4(fp)
811406d8:	00ffe244 	movi	r3,-119
811406dc:	10c00005 	stb	r3,0(r2)
        return (0);
811406e0:	0005883a 	mov	r2,zero
811406e4:	00001906 	br	8114074c <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
811406e8:	d0a0a003 	ldbu	r2,-32128(gp)
811406ec:	10803fcc 	andi	r2,r2,255
811406f0:	10000526 	beq	r2,zero,81140708 <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
811406f4:	e0bfff17 	ldw	r2,-4(fp)
811406f8:	00ffe2c4 	movi	r3,-117
811406fc:	10c00005 	stb	r3,0(r2)
        return (0);
81140700:	0005883a 	mov	r2,zero
81140704:	00001106 	br	8114074c <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
81140708:	11410300 	call	81141030 <OSTmr_Lock>
    state = ptmr->OSTmrState;
8114070c:	e0bffe17 	ldw	r2,-8(fp)
81140710:	10800c43 	ldbu	r2,49(r2)
81140714:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
81140718:	e0bffd03 	ldbu	r2,-12(fp)
8114071c:	1005883a 	mov	r2,r2
81140720:	10800128 	cmpgeui	r2,r2,4
81140724:	1000031e 	bne	r2,zero,81140734 <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
81140728:	e0bfff17 	ldw	r2,-4(fp)
8114072c:	10000005 	stb	zero,0(r2)
             break;
81140730:	00000406 	br	81140744 <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
81140734:	e0bfff17 	ldw	r2,-4(fp)
81140738:	00ffe344 	movi	r3,-115
8114073c:	10c00005 	stb	r3,0(r2)
             break;
81140740:	0001883a 	nop
    }
    OSTmr_Unlock();
81140744:	11410740 	call	81141074 <OSTmr_Unlock>
    return (state);
81140748:	e0bffd03 	ldbu	r2,-12(fp)
}
8114074c:	e037883a 	mov	sp,fp
81140750:	dfc00117 	ldw	ra,4(sp)
81140754:	df000017 	ldw	fp,0(sp)
81140758:	dec00204 	addi	sp,sp,8
8114075c:	f800283a 	ret

81140760 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
81140760:	defffc04 	addi	sp,sp,-16
81140764:	de00012e 	bgeu	sp,et,8114076c <OSTmrStart+0xc>
81140768:	003b68fa 	trap	3
8114076c:	dfc00315 	stw	ra,12(sp)
81140770:	df000215 	stw	fp,8(sp)
81140774:	df000204 	addi	fp,sp,8
81140778:	e13ffe15 	stw	r4,-8(fp)
8114077c:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81140780:	e0bfff17 	ldw	r2,-4(fp)
81140784:	1000021e 	bne	r2,zero,81140790 <OSTmrStart+0x30>
        return (OS_FALSE);
81140788:	0005883a 	mov	r2,zero
8114078c:	00004106 	br	81140894 <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
81140790:	e0bffe17 	ldw	r2,-8(fp)
81140794:	1000051e 	bne	r2,zero,811407ac <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81140798:	e0bfff17 	ldw	r2,-4(fp)
8114079c:	00ffe284 	movi	r3,-118
811407a0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811407a4:	0005883a 	mov	r2,zero
811407a8:	00003a06 	br	81140894 <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
811407ac:	e0bffe17 	ldw	r2,-8(fp)
811407b0:	10800003 	ldbu	r2,0(r2)
811407b4:	10803fcc 	andi	r2,r2,255
811407b8:	10801920 	cmpeqi	r2,r2,100
811407bc:	1000051e 	bne	r2,zero,811407d4 <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
811407c0:	e0bfff17 	ldw	r2,-4(fp)
811407c4:	00ffe244 	movi	r3,-119
811407c8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811407cc:	0005883a 	mov	r2,zero
811407d0:	00003006 	br	81140894 <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
811407d4:	d0a0a003 	ldbu	r2,-32128(gp)
811407d8:	10803fcc 	andi	r2,r2,255
811407dc:	10000526 	beq	r2,zero,811407f4 <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
811407e0:	e0bfff17 	ldw	r2,-4(fp)
811407e4:	00ffe2c4 	movi	r3,-117
811407e8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811407ec:	0005883a 	mov	r2,zero
811407f0:	00002806 	br	81140894 <OSTmrStart+0x134>
    }
    OSTmr_Lock();
811407f4:	11410300 	call	81141030 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
811407f8:	e0bffe17 	ldw	r2,-8(fp)
811407fc:	10800c43 	ldbu	r2,49(r2)
81140800:	10803fcc 	andi	r2,r2,255
81140804:	10c000c8 	cmpgei	r3,r2,3
81140808:	1800031e 	bne	r3,zero,81140818 <OSTmrStart+0xb8>
8114080c:	00800e16 	blt	zero,r2,81140848 <OSTmrStart+0xe8>
81140810:	10001526 	beq	r2,zero,81140868 <OSTmrStart+0x108>
81140814:	00001a06 	br	81140880 <OSTmrStart+0x120>
81140818:	108000e0 	cmpeqi	r2,r2,3
8114081c:	10001826 	beq	r2,zero,81140880 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
81140820:	e13ffe17 	ldw	r4,-8(fp)
81140824:	1140f340 	call	81140f34 <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
81140828:	000b883a 	mov	r5,zero
8114082c:	e13ffe17 	ldw	r4,-8(fp)
81140830:	1140de40 	call	81140de4 <OSTmr_Link>
             OSTmr_Unlock();
81140834:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81140838:	e0bfff17 	ldw	r2,-4(fp)
8114083c:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81140840:	00800044 	movi	r2,1
81140844:	00001306 	br	81140894 <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
81140848:	000b883a 	mov	r5,zero
8114084c:	e13ffe17 	ldw	r4,-8(fp)
81140850:	1140de40 	call	81140de4 <OSTmr_Link>
             OSTmr_Unlock();
81140854:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81140858:	e0bfff17 	ldw	r2,-4(fp)
8114085c:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81140860:	00800044 	movi	r2,1
81140864:	00000b06 	br	81140894 <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
81140868:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8114086c:	e0bfff17 	ldw	r2,-4(fp)
81140870:	00ffe1c4 	movi	r3,-121
81140874:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81140878:	0005883a 	mov	r2,zero
8114087c:	00000506 	br	81140894 <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
81140880:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81140884:	e0bfff17 	ldw	r2,-4(fp)
81140888:	00ffe344 	movi	r3,-115
8114088c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81140890:	0005883a 	mov	r2,zero
    }
}
81140894:	e037883a 	mov	sp,fp
81140898:	dfc00117 	ldw	ra,4(sp)
8114089c:	df000017 	ldw	fp,0(sp)
811408a0:	dec00204 	addi	sp,sp,8
811408a4:	f800283a 	ret

811408a8 <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
811408a8:	defff904 	addi	sp,sp,-28
811408ac:	de00012e 	bgeu	sp,et,811408b4 <OSTmrStop+0xc>
811408b0:	003b68fa 	trap	3
811408b4:	dfc00615 	stw	ra,24(sp)
811408b8:	df000515 	stw	fp,20(sp)
811408bc:	df000504 	addi	fp,sp,20
811408c0:	e13ffc15 	stw	r4,-16(fp)
811408c4:	2805883a 	mov	r2,r5
811408c8:	e1bffe15 	stw	r6,-8(fp)
811408cc:	e1ffff15 	stw	r7,-4(fp)
811408d0:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
811408d4:	e0bfff17 	ldw	r2,-4(fp)
811408d8:	1000021e 	bne	r2,zero,811408e4 <OSTmrStop+0x3c>
        return (OS_FALSE);
811408dc:	0005883a 	mov	r2,zero
811408e0:	00006606 	br	81140a7c <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
811408e4:	e0bffc17 	ldw	r2,-16(fp)
811408e8:	1000051e 	bne	r2,zero,81140900 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
811408ec:	e0bfff17 	ldw	r2,-4(fp)
811408f0:	00ffe284 	movi	r3,-118
811408f4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811408f8:	0005883a 	mov	r2,zero
811408fc:	00005f06 	br	81140a7c <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
81140900:	e0bffc17 	ldw	r2,-16(fp)
81140904:	10800003 	ldbu	r2,0(r2)
81140908:	10803fcc 	andi	r2,r2,255
8114090c:	10801920 	cmpeqi	r2,r2,100
81140910:	1000051e 	bne	r2,zero,81140928 <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81140914:	e0bfff17 	ldw	r2,-4(fp)
81140918:	00ffe244 	movi	r3,-119
8114091c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81140920:	0005883a 	mov	r2,zero
81140924:	00005506 	br	81140a7c <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
81140928:	d0a0a003 	ldbu	r2,-32128(gp)
8114092c:	10803fcc 	andi	r2,r2,255
81140930:	10000526 	beq	r2,zero,81140948 <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
81140934:	e0bfff17 	ldw	r2,-4(fp)
81140938:	00ffe2c4 	movi	r3,-117
8114093c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81140940:	0005883a 	mov	r2,zero
81140944:	00004d06 	br	81140a7c <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
81140948:	11410300 	call	81141030 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8114094c:	e0bffc17 	ldw	r2,-16(fp)
81140950:	10800c43 	ldbu	r2,49(r2)
81140954:	10803fcc 	andi	r2,r2,255
81140958:	10c000c8 	cmpgei	r3,r2,3
8114095c:	1800031e 	bne	r3,zero,8114096c <OSTmrStop+0xc4>
81140960:	00803516 	blt	zero,r2,81140a38 <OSTmrStop+0x190>
81140964:	10003a26 	beq	r2,zero,81140a50 <OSTmrStop+0x1a8>
81140968:	00003f06 	br	81140a68 <OSTmrStop+0x1c0>
8114096c:	108000e0 	cmpeqi	r2,r2,3
81140970:	10003d26 	beq	r2,zero,81140a68 <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
81140974:	e13ffc17 	ldw	r4,-16(fp)
81140978:	1140f340 	call	81140f34 <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
8114097c:	e0bfff17 	ldw	r2,-4(fp)
81140980:	10000005 	stb	zero,0(r2)
             switch (opt) {
81140984:	e0bffd03 	ldbu	r2,-12(fp)
81140988:	10c000e0 	cmpeqi	r3,r2,3
8114098c:	1800041e 	bne	r3,zero,811409a0 <OSTmrStop+0xf8>
81140990:	10c00120 	cmpeqi	r3,r2,4
81140994:	1800121e 	bne	r3,zero,811409e0 <OSTmrStop+0x138>
81140998:	10002326 	beq	r2,zero,81140a28 <OSTmrStop+0x180>
8114099c:	00001e06 	br	81140a18 <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
811409a0:	e0bffc17 	ldw	r2,-16(fp)
811409a4:	10800117 	ldw	r2,4(r2)
811409a8:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
811409ac:	e0bffb17 	ldw	r2,-20(fp)
811409b0:	10000726 	beq	r2,zero,811409d0 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
811409b4:	e0bffc17 	ldw	r2,-16(fp)
811409b8:	10c00217 	ldw	r3,8(r2)
811409bc:	e0bffb17 	ldw	r2,-20(fp)
811409c0:	180b883a 	mov	r5,r3
811409c4:	e13ffc17 	ldw	r4,-16(fp)
811409c8:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
811409cc:	00001706 	br	81140a2c <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
811409d0:	e0bfff17 	ldw	r2,-4(fp)
811409d4:	00ffe3c4 	movi	r3,-113
811409d8:	10c00005 	stb	r3,0(r2)
                      }
                      break;
811409dc:	00001306 	br	81140a2c <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
811409e0:	e0bffc17 	ldw	r2,-16(fp)
811409e4:	10800117 	ldw	r2,4(r2)
811409e8:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
811409ec:	e0bffb17 	ldw	r2,-20(fp)
811409f0:	10000526 	beq	r2,zero,81140a08 <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
811409f4:	e0bffb17 	ldw	r2,-20(fp)
811409f8:	e17ffe17 	ldw	r5,-8(fp)
811409fc:	e13ffc17 	ldw	r4,-16(fp)
81140a00:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
81140a04:	00000906 	br	81140a2c <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
81140a08:	e0bfff17 	ldw	r2,-4(fp)
81140a0c:	00ffe3c4 	movi	r3,-113
81140a10:	10c00005 	stb	r3,0(r2)
                      }
                      break;
81140a14:	00000506 	br	81140a2c <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
81140a18:	e0bfff17 	ldw	r2,-4(fp)
81140a1c:	00ffe104 	movi	r3,-124
81140a20:	10c00005 	stb	r3,0(r2)
                     break;
81140a24:	00000106 	br	81140a2c <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
81140a28:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
81140a2c:	11410740 	call	81141074 <OSTmr_Unlock>
             return (OS_TRUE);
81140a30:	00800044 	movi	r2,1
81140a34:	00001106 	br	81140a7c <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
81140a38:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
81140a3c:	e0bfff17 	ldw	r2,-4(fp)
81140a40:	00ffe384 	movi	r3,-114
81140a44:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
81140a48:	00800044 	movi	r2,1
81140a4c:	00000b06 	br	81140a7c <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
81140a50:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81140a54:	e0bfff17 	ldw	r2,-4(fp)
81140a58:	00ffe1c4 	movi	r3,-121
81140a5c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81140a60:	0005883a 	mov	r2,zero
81140a64:	00000506 	br	81140a7c <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
81140a68:	11410740 	call	81141074 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81140a6c:	e0bfff17 	ldw	r2,-4(fp)
81140a70:	00ffe344 	movi	r3,-115
81140a74:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81140a78:	0005883a 	mov	r2,zero
    }
}
81140a7c:	e037883a 	mov	sp,fp
81140a80:	dfc00117 	ldw	ra,4(sp)
81140a84:	df000017 	ldw	fp,0(sp)
81140a88:	dec00204 	addi	sp,sp,8
81140a8c:	f800283a 	ret

81140a90 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
81140a90:	defffd04 	addi	sp,sp,-12
81140a94:	de00012e 	bgeu	sp,et,81140a9c <OSTmrSignal+0xc>
81140a98:	003b68fa 	trap	3
81140a9c:	dfc00215 	stw	ra,8(sp)
81140aa0:	df000115 	stw	fp,4(sp)
81140aa4:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
81140aa8:	d0a08f17 	ldw	r2,-32196(gp)
81140aac:	1009883a 	mov	r4,r2
81140ab0:	113e05c0 	call	8113e05c <OSSemPost>
81140ab4:	e0bfff05 	stb	r2,-4(fp)
    return (err);
81140ab8:	e0bfff03 	ldbu	r2,-4(fp)
}
81140abc:	e037883a 	mov	sp,fp
81140ac0:	dfc00117 	ldw	ra,4(sp)
81140ac4:	df000017 	ldw	fp,0(sp)
81140ac8:	dec00204 	addi	sp,sp,8
81140acc:	f800283a 	ret

81140ad0 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
81140ad0:	defffe04 	addi	sp,sp,-8
81140ad4:	de00012e 	bgeu	sp,et,81140adc <OSTmr_Alloc+0xc>
81140ad8:	003b68fa 	trap	3
81140adc:	df000115 	stw	fp,4(sp)
81140ae0:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
81140ae4:	d0a08d17 	ldw	r2,-32204(gp)
81140ae8:	1000021e 	bne	r2,zero,81140af4 <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
81140aec:	0005883a 	mov	r2,zero
81140af0:	00001006 	br	81140b34 <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
81140af4:	d0a08d17 	ldw	r2,-32204(gp)
81140af8:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
81140afc:	e0bfff17 	ldw	r2,-4(fp)
81140b00:	10800317 	ldw	r2,12(r2)
81140b04:	d0a08d15 	stw	r2,-32204(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
81140b08:	e0bfff17 	ldw	r2,-4(fp)
81140b0c:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
81140b10:	e0bfff17 	ldw	r2,-4(fp)
81140b14:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
81140b18:	d0a0920b 	ldhu	r2,-32184(gp)
81140b1c:	10800044 	addi	r2,r2,1
81140b20:	d0a0920d 	sth	r2,-32184(gp)
    OSTmrFree--;
81140b24:	d0a0960b 	ldhu	r2,-32168(gp)
81140b28:	10bfffc4 	addi	r2,r2,-1
81140b2c:	d0a0960d 	sth	r2,-32168(gp)
    return (ptmr);
81140b30:	e0bfff17 	ldw	r2,-4(fp)
}
81140b34:	e037883a 	mov	sp,fp
81140b38:	df000017 	ldw	fp,0(sp)
81140b3c:	dec00104 	addi	sp,sp,4
81140b40:	f800283a 	ret

81140b44 <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
81140b44:	defffe04 	addi	sp,sp,-8
81140b48:	de00012e 	bgeu	sp,et,81140b50 <OSTmr_Free+0xc>
81140b4c:	003b68fa 	trap	3
81140b50:	df000115 	stw	fp,4(sp)
81140b54:	df000104 	addi	fp,sp,4
81140b58:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
81140b5c:	e0bfff17 	ldw	r2,-4(fp)
81140b60:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
81140b64:	e0bfff17 	ldw	r2,-4(fp)
81140b68:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
81140b6c:	e0bfff17 	ldw	r2,-4(fp)
81140b70:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
81140b74:	e0bfff17 	ldw	r2,-4(fp)
81140b78:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
81140b7c:	e0bfff17 	ldw	r2,-4(fp)
81140b80:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
81140b84:	e0bfff17 	ldw	r2,-4(fp)
81140b88:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
81140b8c:	e0bfff17 	ldw	r2,-4(fp)
81140b90:	00c00fc4 	movi	r3,63
81140b94:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
81140b98:	e0bfff17 	ldw	r2,-4(fp)
81140b9c:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
81140ba0:	e0bfff17 	ldw	r2,-4(fp)
81140ba4:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
81140ba8:	d0e08d17 	ldw	r3,-32204(gp)
81140bac:	e0bfff17 	ldw	r2,-4(fp)
81140bb0:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
81140bb4:	e0bfff17 	ldw	r2,-4(fp)
81140bb8:	d0a08d15 	stw	r2,-32204(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
81140bbc:	d0a0920b 	ldhu	r2,-32184(gp)
81140bc0:	10bfffc4 	addi	r2,r2,-1
81140bc4:	d0a0920d 	sth	r2,-32184(gp)
    OSTmrFree++;
81140bc8:	d0a0960b 	ldhu	r2,-32168(gp)
81140bcc:	10800044 	addi	r2,r2,1
81140bd0:	d0a0960d 	sth	r2,-32168(gp)
}
81140bd4:	0001883a 	nop
81140bd8:	e037883a 	mov	sp,fp
81140bdc:	df000017 	ldw	fp,0(sp)
81140be0:	dec00104 	addi	sp,sp,4
81140be4:	f800283a 	ret

81140be8 <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
81140be8:	defffa04 	addi	sp,sp,-24
81140bec:	de00012e 	bgeu	sp,et,81140bf4 <OSTmr_Init+0xc>
81140bf0:	003b68fa 	trap	3
81140bf4:	dfc00515 	stw	ra,20(sp)
81140bf8:	df000415 	stw	fp,16(sp)
81140bfc:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
81140c00:	01406804 	movi	r5,416
81140c04:	012045b4 	movhi	r4,33046
81140c08:	21198c04 	addi	r4,r4,26160
81140c0c:	1138d580 	call	81138d58 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
81140c10:	01400404 	movi	r5,16
81140c14:	012045b4 	movhi	r4,33046
81140c18:	21177804 	addi	r4,r4,24032
81140c1c:	1138d580 	call	81138d58 <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
81140c20:	00a045b4 	movhi	r2,33046
81140c24:	10998c04 	addi	r2,r2,26160
81140c28:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
81140c2c:	00a045b4 	movhi	r2,33046
81140c30:	10999904 	addi	r2,r2,26212
81140c34:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81140c38:	e03ffc0d 	sth	zero,-16(fp)
81140c3c:	00001606 	br	81140c98 <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
81140c40:	e0bffd17 	ldw	r2,-12(fp)
81140c44:	00c01904 	movi	r3,100
81140c48:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
81140c4c:	e0bffd17 	ldw	r2,-12(fp)
81140c50:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
81140c54:	e0bffd17 	ldw	r2,-12(fp)
81140c58:	e0fffe17 	ldw	r3,-8(fp)
81140c5c:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
81140c60:	e0bffd17 	ldw	r2,-12(fp)
81140c64:	00c00fc4 	movi	r3,63
81140c68:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81140c6c:	e0bffd17 	ldw	r2,-12(fp)
81140c70:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
81140c74:	e0bffd17 	ldw	r2,-12(fp)
81140c78:	10800d04 	addi	r2,r2,52
81140c7c:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
81140c80:	e0bffe17 	ldw	r2,-8(fp)
81140c84:	10800d04 	addi	r2,r2,52
81140c88:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
81140c8c:	e0bffc0b 	ldhu	r2,-16(fp)
81140c90:	10800044 	addi	r2,r2,1
81140c94:	e0bffc0d 	sth	r2,-16(fp)
81140c98:	e0bffc0b 	ldhu	r2,-16(fp)
81140c9c:	108001f0 	cmpltui	r2,r2,7
81140ca0:	103fe71e 	bne	r2,zero,81140c40 <__reset+0xfb120c40>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
81140ca4:	e0bffd17 	ldw	r2,-12(fp)
81140ca8:	00c01904 	movi	r3,100
81140cac:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
81140cb0:	e0bffd17 	ldw	r2,-12(fp)
81140cb4:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
81140cb8:	e0bffd17 	ldw	r2,-12(fp)
81140cbc:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
81140cc0:	e0bffd17 	ldw	r2,-12(fp)
81140cc4:	00c00fc4 	movi	r3,63
81140cc8:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
81140ccc:	e0bffd17 	ldw	r2,-12(fp)
81140cd0:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
81140cd4:	d020a215 	stw	zero,-32120(gp)
    OSTmrUsed           = 0;
81140cd8:	d020920d 	sth	zero,-32184(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
81140cdc:	00800204 	movi	r2,8
81140ce0:	d0a0960d 	sth	r2,-32168(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
81140ce4:	00a045b4 	movhi	r2,33046
81140ce8:	10998c04 	addi	r2,r2,26160
81140cec:	d0a08d15 	stw	r2,-32204(gp)
    OSTmrSem            = OSSemCreate(1);
81140cf0:	01000044 	movi	r4,1
81140cf4:	113d9ac0 	call	8113d9ac <OSSemCreate>
81140cf8:	d0a0a415 	stw	r2,-32112(gp)
    OSTmrSemSignal      = OSSemCreate(0);
81140cfc:	0009883a 	mov	r4,zero
81140d00:	113d9ac0 	call	8113d9ac <OSSemCreate>
81140d04:	d0a08f15 	stw	r2,-32196(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
81140d08:	d0a0a417 	ldw	r2,-32112(gp)
81140d0c:	e0ffff04 	addi	r3,fp,-4
81140d10:	180d883a 	mov	r6,r3
81140d14:	01604574 	movhi	r5,33045
81140d18:	29403c04 	addi	r5,r5,240
81140d1c:	1009883a 	mov	r4,r2
81140d20:	11375b40 	call	811375b4 <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
81140d24:	d0a08f17 	ldw	r2,-32196(gp)
81140d28:	e0ffff04 	addi	r3,fp,-4
81140d2c:	180d883a 	mov	r6,r3
81140d30:	01604574 	movhi	r5,33045
81140d34:	29404104 	addi	r5,r5,260
81140d38:	1009883a 	mov	r4,r2
81140d3c:	11375b40 	call	811375b4 <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
81140d40:	1140d5c0 	call	81140d5c <OSTmr_InitTask>
}
81140d44:	0001883a 	nop
81140d48:	e037883a 	mov	sp,fp
81140d4c:	dfc00117 	ldw	ra,4(sp)
81140d50:	df000017 	ldw	fp,0(sp)
81140d54:	dec00204 	addi	sp,sp,8
81140d58:	f800283a 	ret

81140d5c <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
81140d5c:	defff804 	addi	sp,sp,-32
81140d60:	de00012e 	bgeu	sp,et,81140d68 <OSTmr_InitTask+0xc>
81140d64:	003b68fa 	trap	3
81140d68:	dfc00715 	stw	ra,28(sp)
81140d6c:	df000615 	stw	fp,24(sp)
81140d70:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
81140d74:	008000c4 	movi	r2,3
81140d78:	d8800415 	stw	r2,16(sp)
81140d7c:	d8000315 	stw	zero,12(sp)
81140d80:	00808004 	movi	r2,512
81140d84:	d8800215 	stw	r2,8(sp)
81140d88:	00a045f4 	movhi	r2,33047
81140d8c:	10a1c004 	addi	r2,r2,-30976
81140d90:	d8800115 	stw	r2,4(sp)
81140d94:	00bfff54 	movui	r2,65533
81140d98:	d8800015 	stw	r2,0(sp)
81140d9c:	01c00744 	movi	r7,29
81140da0:	01a045f4 	movhi	r6,33047
81140da4:	31a3bf04 	addi	r6,r6,-28932
81140da8:	000b883a 	mov	r5,zero
81140dac:	01204534 	movhi	r4,33044
81140db0:	21042c04 	addi	r4,r4,4272
81140db4:	113ea400 	call	8113ea40 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
81140db8:	e1bfff04 	addi	r6,fp,-4
81140dbc:	01604574 	movhi	r5,33045
81140dc0:	29404604 	addi	r5,r5,280
81140dc4:	01000744 	movi	r4,29
81140dc8:	113f2700 	call	8113f270 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
81140dcc:	0001883a 	nop
81140dd0:	e037883a 	mov	sp,fp
81140dd4:	dfc00117 	ldw	ra,4(sp)
81140dd8:	df000017 	ldw	fp,0(sp)
81140ddc:	dec00204 	addi	sp,sp,8
81140de0:	f800283a 	ret

81140de4 <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
81140de4:	defffa04 	addi	sp,sp,-24
81140de8:	de00012e 	bgeu	sp,et,81140df0 <OSTmr_Link+0xc>
81140dec:	003b68fa 	trap	3
81140df0:	df000515 	stw	fp,20(sp)
81140df4:	df000504 	addi	fp,sp,20
81140df8:	e13ffe15 	stw	r4,-8(fp)
81140dfc:	2805883a 	mov	r2,r5
81140e00:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
81140e04:	e0bffe17 	ldw	r2,-8(fp)
81140e08:	00c000c4 	movi	r3,3
81140e0c:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
81140e10:	e0bfff03 	ldbu	r2,-4(fp)
81140e14:	10800058 	cmpnei	r2,r2,1
81140e18:	1000071e 	bne	r2,zero,81140e38 <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
81140e1c:	e0bffe17 	ldw	r2,-8(fp)
81140e20:	10c00717 	ldw	r3,28(r2)
81140e24:	d0a0a217 	ldw	r2,-32120(gp)
81140e28:	1887883a 	add	r3,r3,r2
81140e2c:	e0bffe17 	ldw	r2,-8(fp)
81140e30:	10c00515 	stw	r3,20(r2)
81140e34:	00001006 	br	81140e78 <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
81140e38:	e0bffe17 	ldw	r2,-8(fp)
81140e3c:	10800617 	ldw	r2,24(r2)
81140e40:	1000071e 	bne	r2,zero,81140e60 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
81140e44:	e0bffe17 	ldw	r2,-8(fp)
81140e48:	10c00717 	ldw	r3,28(r2)
81140e4c:	d0a0a217 	ldw	r2,-32120(gp)
81140e50:	1887883a 	add	r3,r3,r2
81140e54:	e0bffe17 	ldw	r2,-8(fp)
81140e58:	10c00515 	stw	r3,20(r2)
81140e5c:	00000606 	br	81140e78 <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
81140e60:	e0bffe17 	ldw	r2,-8(fp)
81140e64:	10c00617 	ldw	r3,24(r2)
81140e68:	d0a0a217 	ldw	r2,-32120(gp)
81140e6c:	1887883a 	add	r3,r3,r2
81140e70:	e0bffe17 	ldw	r2,-8(fp)
81140e74:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81140e78:	e0bffe17 	ldw	r2,-8(fp)
81140e7c:	10800517 	ldw	r2,20(r2)
81140e80:	1080004c 	andi	r2,r2,1
81140e84:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81140e88:	e0bffb0b 	ldhu	r2,-20(fp)
81140e8c:	100690fa 	slli	r3,r2,3
81140e90:	00a045b4 	movhi	r2,33046
81140e94:	10977804 	addi	r2,r2,24032
81140e98:	1885883a 	add	r2,r3,r2
81140e9c:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
81140ea0:	e0bffc17 	ldw	r2,-16(fp)
81140ea4:	10800017 	ldw	r2,0(r2)
81140ea8:	1000091e 	bne	r2,zero,81140ed0 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
81140eac:	e0bffc17 	ldw	r2,-16(fp)
81140eb0:	e0fffe17 	ldw	r3,-8(fp)
81140eb4:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
81140eb8:	e0bffe17 	ldw	r2,-8(fp)
81140ebc:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
81140ec0:	e0bffc17 	ldw	r2,-16(fp)
81140ec4:	00c00044 	movi	r3,1
81140ec8:	10c0010d 	sth	r3,4(r2)
81140ecc:	00001206 	br	81140f18 <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
81140ed0:	e0bffc17 	ldw	r2,-16(fp)
81140ed4:	10800017 	ldw	r2,0(r2)
81140ed8:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
81140edc:	e0bffc17 	ldw	r2,-16(fp)
81140ee0:	e0fffe17 	ldw	r3,-8(fp)
81140ee4:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
81140ee8:	e0bffe17 	ldw	r2,-8(fp)
81140eec:	e0fffd17 	ldw	r3,-12(fp)
81140ef0:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
81140ef4:	e0bffd17 	ldw	r2,-12(fp)
81140ef8:	e0fffe17 	ldw	r3,-8(fp)
81140efc:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
81140f00:	e0bffc17 	ldw	r2,-16(fp)
81140f04:	1080010b 	ldhu	r2,4(r2)
81140f08:	10800044 	addi	r2,r2,1
81140f0c:	1007883a 	mov	r3,r2
81140f10:	e0bffc17 	ldw	r2,-16(fp)
81140f14:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
81140f18:	e0bffe17 	ldw	r2,-8(fp)
81140f1c:	10000415 	stw	zero,16(r2)
}
81140f20:	0001883a 	nop
81140f24:	e037883a 	mov	sp,fp
81140f28:	df000017 	ldw	fp,0(sp)
81140f2c:	dec00104 	addi	sp,sp,4
81140f30:	f800283a 	ret

81140f34 <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
81140f34:	defffa04 	addi	sp,sp,-24
81140f38:	de00012e 	bgeu	sp,et,81140f40 <OSTmr_Unlink+0xc>
81140f3c:	003b68fa 	trap	3
81140f40:	df000515 	stw	fp,20(sp)
81140f44:	df000504 	addi	fp,sp,20
81140f48:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
81140f4c:	e0bfff17 	ldw	r2,-4(fp)
81140f50:	10800517 	ldw	r2,20(r2)
81140f54:	1080004c 	andi	r2,r2,1
81140f58:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
81140f5c:	e0bffb0b 	ldhu	r2,-20(fp)
81140f60:	100690fa 	slli	r3,r2,3
81140f64:	00a045b4 	movhi	r2,33046
81140f68:	10977804 	addi	r2,r2,24032
81140f6c:	1885883a 	add	r2,r3,r2
81140f70:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
81140f74:	e0bffc17 	ldw	r2,-16(fp)
81140f78:	10c00017 	ldw	r3,0(r2)
81140f7c:	e0bfff17 	ldw	r2,-4(fp)
81140f80:	18800b1e 	bne	r3,r2,81140fb0 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
81140f84:	e0bfff17 	ldw	r2,-4(fp)
81140f88:	10800317 	ldw	r2,12(r2)
81140f8c:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
81140f90:	e0bffc17 	ldw	r2,-16(fp)
81140f94:	e0fffd17 	ldw	r3,-12(fp)
81140f98:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
81140f9c:	e0bffd17 	ldw	r2,-12(fp)
81140fa0:	10001126 	beq	r2,zero,81140fe8 <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
81140fa4:	e0bffd17 	ldw	r2,-12(fp)
81140fa8:	10000415 	stw	zero,16(r2)
81140fac:	00000e06 	br	81140fe8 <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
81140fb0:	e0bfff17 	ldw	r2,-4(fp)
81140fb4:	10800417 	ldw	r2,16(r2)
81140fb8:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
81140fbc:	e0bfff17 	ldw	r2,-4(fp)
81140fc0:	10800317 	ldw	r2,12(r2)
81140fc4:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
81140fc8:	e0bffd17 	ldw	r2,-12(fp)
81140fcc:	e0fffe17 	ldw	r3,-8(fp)
81140fd0:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
81140fd4:	e0bffe17 	ldw	r2,-8(fp)
81140fd8:	10000326 	beq	r2,zero,81140fe8 <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
81140fdc:	e0bffe17 	ldw	r2,-8(fp)
81140fe0:	e0fffd17 	ldw	r3,-12(fp)
81140fe4:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
81140fe8:	e0bfff17 	ldw	r2,-4(fp)
81140fec:	00c00044 	movi	r3,1
81140ff0:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
81140ff4:	e0bfff17 	ldw	r2,-4(fp)
81140ff8:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
81140ffc:	e0bfff17 	ldw	r2,-4(fp)
81141000:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
81141004:	e0bffc17 	ldw	r2,-16(fp)
81141008:	1080010b 	ldhu	r2,4(r2)
8114100c:	10bfffc4 	addi	r2,r2,-1
81141010:	1007883a 	mov	r3,r2
81141014:	e0bffc17 	ldw	r2,-16(fp)
81141018:	10c0010d 	sth	r3,4(r2)
}
8114101c:	0001883a 	nop
81141020:	e037883a 	mov	sp,fp
81141024:	df000017 	ldw	fp,0(sp)
81141028:	dec00104 	addi	sp,sp,4
8114102c:	f800283a 	ret

81141030 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
81141030:	defffd04 	addi	sp,sp,-12
81141034:	de00012e 	bgeu	sp,et,8114103c <OSTmr_Lock+0xc>
81141038:	003b68fa 	trap	3
8114103c:	dfc00215 	stw	ra,8(sp)
81141040:	df000115 	stw	fp,4(sp)
81141044:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
81141048:	d0a0a417 	ldw	r2,-32112(gp)
8114104c:	e1bfff04 	addi	r6,fp,-4
81141050:	000b883a 	mov	r5,zero
81141054:	1009883a 	mov	r4,r2
81141058:	113dcd40 	call	8113dcd4 <OSSemPend>
    (void)err;
}
8114105c:	0001883a 	nop
81141060:	e037883a 	mov	sp,fp
81141064:	dfc00117 	ldw	ra,4(sp)
81141068:	df000017 	ldw	fp,0(sp)
8114106c:	dec00204 	addi	sp,sp,8
81141070:	f800283a 	ret

81141074 <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
81141074:	defffe04 	addi	sp,sp,-8
81141078:	de00012e 	bgeu	sp,et,81141080 <OSTmr_Unlock+0xc>
8114107c:	003b68fa 	trap	3
81141080:	dfc00115 	stw	ra,4(sp)
81141084:	df000015 	stw	fp,0(sp)
81141088:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
8114108c:	d0a0a417 	ldw	r2,-32112(gp)
81141090:	1009883a 	mov	r4,r2
81141094:	113e05c0 	call	8113e05c <OSSemPost>
}
81141098:	0001883a 	nop
8114109c:	e037883a 	mov	sp,fp
811410a0:	dfc00117 	ldw	ra,4(sp)
811410a4:	df000017 	ldw	fp,0(sp)
811410a8:	dec00204 	addi	sp,sp,8
811410ac:	f800283a 	ret

811410b0 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
811410b0:	defff704 	addi	sp,sp,-36
811410b4:	de00012e 	bgeu	sp,et,811410bc <OSTmr_Task+0xc>
811410b8:	003b68fa 	trap	3
811410bc:	dfc00815 	stw	ra,32(sp)
811410c0:	df000715 	stw	fp,28(sp)
811410c4:	df000704 	addi	fp,sp,28
811410c8:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
811410cc:	d0a08f17 	ldw	r2,-32196(gp)
811410d0:	e0fffe04 	addi	r3,fp,-8
811410d4:	180d883a 	mov	r6,r3
811410d8:	000b883a 	mov	r5,zero
811410dc:	1009883a 	mov	r4,r2
811410e0:	113dcd40 	call	8113dcd4 <OSSemPend>
        OSTmr_Lock();
811410e4:	11410300 	call	81141030 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
811410e8:	d0a0a217 	ldw	r2,-32120(gp)
811410ec:	10800044 	addi	r2,r2,1
811410f0:	d0a0a215 	stw	r2,-32120(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
811410f4:	d0a0a217 	ldw	r2,-32120(gp)
811410f8:	1080004c 	andi	r2,r2,1
811410fc:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
81141100:	e0bffa0b 	ldhu	r2,-24(fp)
81141104:	100690fa 	slli	r3,r2,3
81141108:	00a045b4 	movhi	r2,33046
8114110c:	10977804 	addi	r2,r2,24032
81141110:	1885883a 	add	r2,r3,r2
81141114:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
81141118:	e0bffb17 	ldw	r2,-20(fp)
8114111c:	10800017 	ldw	r2,0(r2)
81141120:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
81141124:	00002206 	br	811411b0 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
81141128:	e0bff917 	ldw	r2,-28(fp)
8114112c:	10800317 	ldw	r2,12(r2)
81141130:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
81141134:	e0bff917 	ldw	r2,-28(fp)
81141138:	10c00517 	ldw	r3,20(r2)
8114113c:	d0a0a217 	ldw	r2,-32120(gp)
81141140:	1880191e 	bne	r3,r2,811411a8 <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
81141144:	e0bff917 	ldw	r2,-28(fp)
81141148:	10800117 	ldw	r2,4(r2)
8114114c:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
81141150:	e0bffd17 	ldw	r2,-12(fp)
81141154:	10000626 	beq	r2,zero,81141170 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
81141158:	e0bff917 	ldw	r2,-28(fp)
8114115c:	10c00217 	ldw	r3,8(r2)
81141160:	e0bffd17 	ldw	r2,-12(fp)
81141164:	180b883a 	mov	r5,r3
81141168:	e13ff917 	ldw	r4,-28(fp)
8114116c:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
81141170:	e13ff917 	ldw	r4,-28(fp)
81141174:	1140f340 	call	81140f34 <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
81141178:	e0bff917 	ldw	r2,-28(fp)
8114117c:	10800c03 	ldbu	r2,48(r2)
81141180:	10803fcc 	andi	r2,r2,255
81141184:	10800098 	cmpnei	r2,r2,2
81141188:	1000041e 	bne	r2,zero,8114119c <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
8114118c:	01400044 	movi	r5,1
81141190:	e13ff917 	ldw	r4,-28(fp)
81141194:	1140de40 	call	81140de4 <OSTmr_Link>
81141198:	00000306 	br	811411a8 <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
8114119c:	e0bff917 	ldw	r2,-28(fp)
811411a0:	00c00084 	movi	r3,2
811411a4:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
811411a8:	e0bffc17 	ldw	r2,-16(fp)
811411ac:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
811411b0:	e0bff917 	ldw	r2,-28(fp)
811411b4:	103fdc1e 	bne	r2,zero,81141128 <__reset+0xfb121128>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
811411b8:	11410740 	call	81141074 <OSTmr_Unlock>
    }
811411bc:	003fc306 	br	811410cc <__reset+0xfb1210cc>

811411c0 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
811411c0:	defffd04 	addi	sp,sp,-12
811411c4:	de00012e 	bgeu	sp,et,811411cc <alt_dev_reg+0xc>
811411c8:	003b68fa 	trap	3
811411cc:	dfc00215 	stw	ra,8(sp)
811411d0:	df000115 	stw	fp,4(sp)
811411d4:	df000104 	addi	fp,sp,4
811411d8:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
811411dc:	d1600d04 	addi	r5,gp,-32716
811411e0:	e13fff17 	ldw	r4,-4(fp)
811411e4:	11494600 	call	81149460 <alt_dev_llist_insert>
}
811411e8:	e037883a 	mov	sp,fp
811411ec:	dfc00117 	ldw	ra,4(sp)
811411f0:	df000017 	ldw	fp,0(sp)
811411f4:	dec00204 	addi	sp,sp,8
811411f8:	f800283a 	ret

811411fc <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
811411fc:	defffd04 	addi	sp,sp,-12
81141200:	de00012e 	bgeu	sp,et,81141208 <alt_irq_init+0xc>
81141204:	003b68fa 	trap	3
81141208:	dfc00215 	stw	ra,8(sp)
8114120c:	df000115 	stw	fp,4(sp)
81141210:	df000104 	addi	fp,sp,4
81141214:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
81141218:	1149e280 	call	81149e28 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
8114121c:	00800044 	movi	r2,1
81141220:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
81141224:	0001883a 	nop
81141228:	e037883a 	mov	sp,fp
8114122c:	dfc00117 	ldw	ra,4(sp)
81141230:	df000017 	ldw	fp,0(sp)
81141234:	dec00204 	addi	sp,sp,8
81141238:	f800283a 	ret

8114123c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
8114123c:	defffe04 	addi	sp,sp,-8
81141240:	de00012e 	bgeu	sp,et,81141248 <alt_sys_init+0xc>
81141244:	003b68fa 	trap	3
81141248:	dfc00115 	stw	ra,4(sp)
8114124c:	df000015 	stw	fp,0(sp)
81141250:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
81141254:	01c0fa04 	movi	r7,1000
81141258:	01800304 	movi	r6,12
8114125c:	000b883a 	mov	r5,zero
81141260:	01200034 	movhi	r4,32768
81141264:	21022004 	addi	r4,r4,2176
81141268:	11465940 	call	81146594 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
8114126c:	018002c4 	movi	r6,11
81141270:	000b883a 	mov	r5,zero
81141274:	01204574 	movhi	r4,33045
81141278:	2103e204 	addi	r4,r4,3976
8114127c:	11458800 	call	81145880 <altera_avalon_jtag_uart_init>
81141280:	01204574 	movhi	r4,33045
81141284:	2103d804 	addi	r4,r4,3936
81141288:	11411c00 	call	811411c0 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
8114128c:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
81141290:	018003c4 	movi	r6,15
81141294:	000b883a 	mov	r5,zero
81141298:	01204574 	movhi	r4,33045
8114129c:	2107fd04 	addi	r4,r4,8180
811412a0:	11467400 	call	81146740 <altera_avalon_uart_init>
811412a4:	01204574 	movhi	r4,33045
811412a8:	2107f304 	addi	r4,r4,8140
811412ac:	11411c00 	call	811411c0 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
811412b0:	00a04574 	movhi	r2,33045
811412b4:	10882704 	addi	r2,r2,8348
811412b8:	10c00717 	ldw	r3,28(r2)
811412bc:	00a04574 	movhi	r2,33045
811412c0:	10882704 	addi	r2,r2,8348
811412c4:	10800817 	ldw	r2,32(r2)
811412c8:	100d883a 	mov	r6,r2
811412cc:	180b883a 	mov	r5,r3
811412d0:	01204574 	movhi	r4,33045
811412d4:	21082704 	addi	r4,r4,8348
811412d8:	1148fc80 	call	81148fc8 <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
811412dc:	00a04574 	movhi	r2,33045
811412e0:	10884004 	addi	r2,r2,8448
811412e4:	10c00717 	ldw	r3,28(r2)
811412e8:	00a04574 	movhi	r2,33045
811412ec:	10884004 	addi	r2,r2,8448
811412f0:	10800817 	ldw	r2,32(r2)
811412f4:	100d883a 	mov	r6,r2
811412f8:	180b883a 	mov	r5,r3
811412fc:	01204574 	movhi	r4,33045
81141300:	21084004 	addi	r4,r4,8448
81141304:	1148fc80 	call	81148fc8 <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
81141308:	01204574 	movhi	r4,33045
8114130c:	21085904 	addi	r4,r4,8548
81141310:	11411c00 	call	811411c0 <alt_dev_reg>
}
81141314:	0001883a 	nop
81141318:	e037883a 	mov	sp,fp
8114131c:	dfc00117 	ldw	ra,4(sp)
81141320:	df000017 	ldw	fp,0(sp)
81141324:	dec00204 	addi	sp,sp,8
81141328:	f800283a 	ret

8114132c <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
8114132c:	defffa04 	addi	sp,sp,-24
81141330:	de00012e 	bgeu	sp,et,81141338 <Write_Sector_Data+0xc>
81141334:	003b68fa 	trap	3
81141338:	dfc00515 	stw	ra,20(sp)
8114133c:	df000415 	stw	fp,16(sp)
81141340:	df000404 	addi	fp,sp,16
81141344:	e13ffe15 	stw	r4,-8(fp)
81141348:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
8114134c:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
81141350:	11441140 	call	81144114 <alt_up_sd_card_is_Present>
81141354:	10001e26 	beq	r2,zero,811413d0 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
81141358:	00803fc4 	movi	r2,255
8114135c:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
81141360:	d0a0ae17 	ldw	r2,-32072(gp)
81141364:	e13ffe17 	ldw	r4,-8(fp)
81141368:	e0ffff17 	ldw	r3,-4(fp)
8114136c:	20c7883a 	add	r3,r4,r3
81141370:	1806927a 	slli	r3,r3,9
81141374:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
81141378:	d0a0ad17 	ldw	r2,-32076(gp)
8114137c:	00c00604 	movi	r3,24
81141380:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
81141384:	d0a0aa17 	ldw	r2,-32088(gp)
81141388:	1080002b 	ldhuio	r2,0(r2)
8114138c:	10bfffcc 	andi	r2,r2,65535
81141390:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
81141394:	e0bffd0b 	ldhu	r2,-12(fp)
81141398:	10bfffcc 	andi	r2,r2,65535
8114139c:	1080010c 	andi	r2,r2,4
811413a0:	103ff81e 	bne	r2,zero,81141384 <__reset+0xfb121384>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
811413a4:	e0bffd0b 	ldhu	r2,-12(fp)
811413a8:	10bfffcc 	andi	r2,r2,65535
811413ac:	1080040c 	andi	r2,r2,16
811413b0:	1000071e 	bne	r2,zero,811413d0 <Write_Sector_Data+0xa4>
        {
            result = true;
811413b4:	00800044 	movi	r2,1
811413b8:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
811413bc:	d020b315 	stw	zero,-32052(gp)
            current_sector_index = sector_index+partition_offset;
811413c0:	e0fffe17 	ldw	r3,-8(fp)
811413c4:	e0bfff17 	ldw	r2,-4(fp)
811413c8:	1885883a 	add	r2,r3,r2
811413cc:	d0a0b415 	stw	r2,-32048(gp)
        }
    }
    return result;
811413d0:	e0bffc17 	ldw	r2,-16(fp)
}
811413d4:	e037883a 	mov	sp,fp
811413d8:	dfc00117 	ldw	ra,4(sp)
811413dc:	df000017 	ldw	fp,0(sp)
811413e0:	dec00204 	addi	sp,sp,8
811413e4:	f800283a 	ret

811413e8 <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
811413e8:	defffd04 	addi	sp,sp,-12
811413ec:	de00012e 	bgeu	sp,et,811413f4 <Save_Modified_Sector+0xc>
811413f0:	003b68fa 	trap	3
811413f4:	dfc00215 	stw	ra,8(sp)
811413f8:	df000115 	stw	fp,4(sp)
811413fc:	df000104 	addi	fp,sp,4
    bool result = true;
81141400:	00800044 	movi	r2,1
81141404:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
81141408:	d0a0b317 	ldw	r2,-32052(gp)
8114140c:	10000526 	beq	r2,zero,81141424 <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
81141410:	d0a0b417 	ldw	r2,-32048(gp)
81141414:	000b883a 	mov	r5,zero
81141418:	1009883a 	mov	r4,r2
8114141c:	114132c0 	call	8114132c <Write_Sector_Data>
81141420:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
81141424:	e0bfff17 	ldw	r2,-4(fp)
}
81141428:	e037883a 	mov	sp,fp
8114142c:	dfc00117 	ldw	ra,4(sp)
81141430:	df000017 	ldw	fp,0(sp)
81141434:	dec00204 	addi	sp,sp,8
81141438:	f800283a 	ret

8114143c <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
8114143c:	defffa04 	addi	sp,sp,-24
81141440:	de00012e 	bgeu	sp,et,81141448 <Read_Sector_Data+0xc>
81141444:	003b68fa 	trap	3
81141448:	dfc00515 	stw	ra,20(sp)
8114144c:	df000415 	stw	fp,16(sp)
81141450:	df000404 	addi	fp,sp,16
81141454:	e13ffe15 	stw	r4,-8(fp)
81141458:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
8114145c:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
81141460:	11441140 	call	81144114 <alt_up_sd_card_is_Present>
81141464:	10002726 	beq	r2,zero,81141504 <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
81141468:	00803fc4 	movi	r2,255
8114146c:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
81141470:	d0a0b317 	ldw	r2,-32052(gp)
81141474:	10000726 	beq	r2,zero,81141494 <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
81141478:	d0a0b417 	ldw	r2,-32048(gp)
8114147c:	000b883a 	mov	r5,zero
81141480:	1009883a 	mov	r4,r2
81141484:	114132c0 	call	8114132c <Write_Sector_Data>
81141488:	1000021e 	bne	r2,zero,81141494 <Read_Sector_Data+0x58>
            {
                return false;
8114148c:	0005883a 	mov	r2,zero
81141490:	00001d06 	br	81141508 <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
81141494:	d0a0ae17 	ldw	r2,-32072(gp)
81141498:	e13ffe17 	ldw	r4,-8(fp)
8114149c:	e0ffff17 	ldw	r3,-4(fp)
811414a0:	20c7883a 	add	r3,r4,r3
811414a4:	1806927a 	slli	r3,r3,9
811414a8:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
811414ac:	d0a0ad17 	ldw	r2,-32076(gp)
811414b0:	00c00444 	movi	r3,17
811414b4:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
811414b8:	d0a0aa17 	ldw	r2,-32088(gp)
811414bc:	1080002b 	ldhuio	r2,0(r2)
811414c0:	10bfffcc 	andi	r2,r2,65535
811414c4:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
811414c8:	e0bffd0b 	ldhu	r2,-12(fp)
811414cc:	10bfffcc 	andi	r2,r2,65535
811414d0:	1080010c 	andi	r2,r2,4
811414d4:	103ff81e 	bne	r2,zero,811414b8 <__reset+0xfb1214b8>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
811414d8:	e0bffd0b 	ldhu	r2,-12(fp)
811414dc:	10bfffcc 	andi	r2,r2,65535
811414e0:	1080040c 	andi	r2,r2,16
811414e4:	1000071e 	bne	r2,zero,81141504 <Read_Sector_Data+0xc8>
		{
			result = true;
811414e8:	00800044 	movi	r2,1
811414ec:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
811414f0:	d020b315 	stw	zero,-32052(gp)
            current_sector_index = sector_index+partition_offset;
811414f4:	e0fffe17 	ldw	r3,-8(fp)
811414f8:	e0bfff17 	ldw	r2,-4(fp)
811414fc:	1885883a 	add	r2,r3,r2
81141500:	d0a0b415 	stw	r2,-32048(gp)
		}
	}
	return result;
81141504:	e0bffc17 	ldw	r2,-16(fp)
}
81141508:	e037883a 	mov	sp,fp
8114150c:	dfc00117 	ldw	ra,4(sp)
81141510:	df000017 	ldw	fp,0(sp)
81141514:	dec00204 	addi	sp,sp,8
81141518:	f800283a 	ret

8114151c <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
8114151c:	defffb04 	addi	sp,sp,-20
81141520:	de00012e 	bgeu	sp,et,81141528 <get_cluster_flag+0xc>
81141524:	003b68fa 	trap	3
81141528:	dfc00415 	stw	ra,16(sp)
8114152c:	df000315 	stw	fp,12(sp)
81141530:	df000304 	addi	fp,sp,12
81141534:	e13ffe15 	stw	r4,-8(fp)
81141538:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
8114153c:	e0bffe17 	ldw	r2,-8(fp)
81141540:	1004d23a 	srli	r2,r2,8
81141544:	d0e0b017 	ldw	r3,-32064(gp)
81141548:	10c5883a 	add	r2,r2,r3
8114154c:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
81141550:	00a045f4 	movhi	r2,33047
81141554:	10af9e04 	addi	r2,r2,-16776
81141558:	10801117 	ldw	r2,68(r2)
8114155c:	e0fffd17 	ldw	r3,-12(fp)
81141560:	1885883a 	add	r2,r3,r2
81141564:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
81141568:	d0a0b417 	ldw	r2,-32048(gp)
8114156c:	e0fffd17 	ldw	r3,-12(fp)
81141570:	18800726 	beq	r3,r2,81141590 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
81141574:	e0bffd17 	ldw	r2,-12(fp)
81141578:	000b883a 	mov	r5,zero
8114157c:	1009883a 	mov	r4,r2
81141580:	114143c0 	call	8114143c <Read_Sector_Data>
81141584:	1000021e 	bne	r2,zero,81141590 <get_cluster_flag+0x74>
        {
            return false;
81141588:	0005883a 	mov	r2,zero
8114158c:	00000d06 	br	811415c4 <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
81141590:	e0bffe17 	ldw	r2,-8(fp)
81141594:	10803fcc 	andi	r2,r2,255
81141598:	1085883a 	add	r2,r2,r2
8114159c:	1007883a 	mov	r3,r2
811415a0:	d0a0b217 	ldw	r2,-32056(gp)
811415a4:	10800a17 	ldw	r2,40(r2)
811415a8:	1885883a 	add	r2,r3,r2
811415ac:	1080002b 	ldhuio	r2,0(r2)
811415b0:	10bfffcc 	andi	r2,r2,65535
811415b4:	1007883a 	mov	r3,r2
811415b8:	e0bfff17 	ldw	r2,-4(fp)
811415bc:	10c0000d 	sth	r3,0(r2)
    return true;
811415c0:	00800044 	movi	r2,1
}
811415c4:	e037883a 	mov	sp,fp
811415c8:	dfc00117 	ldw	ra,4(sp)
811415cc:	df000017 	ldw	fp,0(sp)
811415d0:	dec00204 	addi	sp,sp,8
811415d4:	f800283a 	ret

811415d8 <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
811415d8:	defffa04 	addi	sp,sp,-24
811415dc:	de00012e 	bgeu	sp,et,811415e4 <mark_cluster+0xc>
811415e0:	003b68fa 	trap	3
811415e4:	dfc00515 	stw	ra,20(sp)
811415e8:	df000415 	stw	fp,16(sp)
811415ec:	df000404 	addi	fp,sp,16
811415f0:	e13ffd15 	stw	r4,-12(fp)
811415f4:	2805883a 	mov	r2,r5
811415f8:	e1bfff15 	stw	r6,-4(fp)
811415fc:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
81141600:	e0bffd17 	ldw	r2,-12(fp)
81141604:	1004d23a 	srli	r2,r2,8
81141608:	d0e0b017 	ldw	r3,-32064(gp)
8114160c:	10c5883a 	add	r2,r2,r3
81141610:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
81141614:	e0bfff17 	ldw	r2,-4(fp)
81141618:	10000726 	beq	r2,zero,81141638 <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8114161c:	00a045f4 	movhi	r2,33047
81141620:	10af9e04 	addi	r2,r2,-16776
81141624:	10801117 	ldw	r2,68(r2)
81141628:	e0fffc17 	ldw	r3,-16(fp)
8114162c:	1885883a 	add	r2,r3,r2
81141630:	e0bffc15 	stw	r2,-16(fp)
81141634:	00000606 	br	81141650 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
81141638:	00a045f4 	movhi	r2,33047
8114163c:	10af9e04 	addi	r2,r2,-16776
81141640:	10801217 	ldw	r2,72(r2)
81141644:	e0fffc17 	ldw	r3,-16(fp)
81141648:	1885883a 	add	r2,r3,r2
8114164c:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
81141650:	d0a0b417 	ldw	r2,-32048(gp)
81141654:	e0fffc17 	ldw	r3,-16(fp)
81141658:	18800726 	beq	r3,r2,81141678 <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8114165c:	e0bffc17 	ldw	r2,-16(fp)
81141660:	000b883a 	mov	r5,zero
81141664:	1009883a 	mov	r4,r2
81141668:	114143c0 	call	8114143c <Read_Sector_Data>
8114166c:	1000021e 	bne	r2,zero,81141678 <mark_cluster+0xa0>
        {
            return false;
81141670:	0005883a 	mov	r2,zero
81141674:	00000d06 	br	811416ac <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
81141678:	e0bffd17 	ldw	r2,-12(fp)
8114167c:	10803fcc 	andi	r2,r2,255
81141680:	1085883a 	add	r2,r2,r2
81141684:	1007883a 	mov	r3,r2
81141688:	d0a0b217 	ldw	r2,-32056(gp)
8114168c:	10800a17 	ldw	r2,40(r2)
81141690:	1885883a 	add	r2,r3,r2
81141694:	1007883a 	mov	r3,r2
81141698:	e0bffe0f 	ldh	r2,-8(fp)
8114169c:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
811416a0:	00800044 	movi	r2,1
811416a4:	d0a0b315 	stw	r2,-32052(gp)
    return true;
811416a8:	00800044 	movi	r2,1
}
811416ac:	e037883a 	mov	sp,fp
811416b0:	dfc00117 	ldw	ra,4(sp)
811416b4:	df000017 	ldw	fp,0(sp)
811416b8:	dec00204 	addi	sp,sp,8
811416bc:	f800283a 	ret

811416c0 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
811416c0:	defff704 	addi	sp,sp,-36
811416c4:	de00012e 	bgeu	sp,et,811416cc <Check_for_Master_Boot_Record+0xc>
811416c8:	003b68fa 	trap	3
811416cc:	dfc00815 	stw	ra,32(sp)
811416d0:	df000715 	stw	fp,28(sp)
811416d4:	df000704 	addi	fp,sp,28
	bool result = false;
811416d8:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
811416dc:	000b883a 	mov	r5,zero
811416e0:	0009883a 	mov	r4,zero
811416e4:	114143c0 	call	8114143c <Read_Sector_Data>
811416e8:	10005a26 	beq	r2,zero,81141854 <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
811416ec:	d0a0b217 	ldw	r2,-32056(gp)
811416f0:	10800a17 	ldw	r2,40(r2)
811416f4:	10807f84 	addi	r2,r2,510
811416f8:	1080002b 	ldhuio	r2,0(r2)
811416fc:	10bfffcc 	andi	r2,r2,65535
81141700:	10bfffcc 	andi	r2,r2,65535
81141704:	10a0001c 	xori	r2,r2,32768
81141708:	10a00004 	addi	r2,r2,-32768
8114170c:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
81141710:	e0bffb17 	ldw	r2,-20(fp)
81141714:	10ffffcc 	andi	r3,r2,65535
81141718:	00aa9554 	movui	r2,43605
8114171c:	18804d1e 	bne	r3,r2,81141854 <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
81141720:	e03ffa15 	stw	zero,-24(fp)
81141724:	00004806 	br	81141848 <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
81141728:	e0bffa17 	ldw	r2,-24(fp)
8114172c:	1004913a 	slli	r2,r2,4
81141730:	10806f84 	addi	r2,r2,446
81141734:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
81141738:	d0a0b217 	ldw	r2,-32056(gp)
8114173c:	10c00a17 	ldw	r3,40(r2)
81141740:	e0bffc17 	ldw	r2,-16(fp)
81141744:	1885883a 	add	r2,r3,r2
81141748:	10800104 	addi	r2,r2,4
8114174c:	10800023 	ldbuio	r2,0(r2)
81141750:	10803fcc 	andi	r2,r2,255
81141754:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
81141758:	e0bffd07 	ldb	r2,-12(fp)
8114175c:	10800060 	cmpeqi	r2,r2,1
81141760:	1000091e 	bne	r2,zero,81141788 <Check_for_Master_Boot_Record+0xc8>
81141764:	e0bffd07 	ldb	r2,-12(fp)
81141768:	10800120 	cmpeqi	r2,r2,4
8114176c:	1000061e 	bne	r2,zero,81141788 <Check_for_Master_Boot_Record+0xc8>
81141770:	e0bffd07 	ldb	r2,-12(fp)
81141774:	108001a0 	cmpeqi	r2,r2,6
81141778:	1000031e 	bne	r2,zero,81141788 <Check_for_Master_Boot_Record+0xc8>
8114177c:	e0bffd07 	ldb	r2,-12(fp)
81141780:	10800398 	cmpnei	r2,r2,14
81141784:	10002d1e 	bne	r2,zero,8114183c <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
81141788:	d0a0b217 	ldw	r2,-32056(gp)
8114178c:	10c00a17 	ldw	r3,40(r2)
81141790:	e0bffc17 	ldw	r2,-16(fp)
81141794:	1885883a 	add	r2,r3,r2
81141798:	10800284 	addi	r2,r2,10
8114179c:	1080002b 	ldhuio	r2,0(r2)
811417a0:	10bfffcc 	andi	r2,r2,65535
811417a4:	1006943a 	slli	r3,r2,16
811417a8:	d0a0b217 	ldw	r2,-32056(gp)
811417ac:	11000a17 	ldw	r4,40(r2)
811417b0:	e0bffc17 	ldw	r2,-16(fp)
811417b4:	2085883a 	add	r2,r4,r2
811417b8:	10800204 	addi	r2,r2,8
811417bc:	1080002b 	ldhuio	r2,0(r2)
811417c0:	10bfffcc 	andi	r2,r2,65535
811417c4:	10bfffcc 	andi	r2,r2,65535
811417c8:	1884b03a 	or	r2,r3,r2
811417cc:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
811417d0:	d0a0b217 	ldw	r2,-32056(gp)
811417d4:	10c00a17 	ldw	r3,40(r2)
811417d8:	e0bffc17 	ldw	r2,-16(fp)
811417dc:	1885883a 	add	r2,r3,r2
811417e0:	10800384 	addi	r2,r2,14
811417e4:	1080002b 	ldhuio	r2,0(r2)
811417e8:	10bfffcc 	andi	r2,r2,65535
811417ec:	1006943a 	slli	r3,r2,16
811417f0:	d0a0b217 	ldw	r2,-32056(gp)
811417f4:	11000a17 	ldw	r4,40(r2)
811417f8:	e0bffc17 	ldw	r2,-16(fp)
811417fc:	2085883a 	add	r2,r4,r2
81141800:	10800304 	addi	r2,r2,12
81141804:	1080002b 	ldhuio	r2,0(r2)
81141808:	10bfffcc 	andi	r2,r2,65535
8114180c:	10bfffcc 	andi	r2,r2,65535
81141810:	1884b03a 	or	r2,r3,r2
81141814:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
81141818:	e0bfff17 	ldw	r2,-4(fp)
8114181c:	0080070e 	bge	zero,r2,8114183c <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
81141820:	00800044 	movi	r2,1
81141824:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
81141828:	e0bfff17 	ldw	r2,-4(fp)
8114182c:	d0a0b115 	stw	r2,-32060(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
81141830:	e0bffe17 	ldw	r2,-8(fp)
81141834:	d0a0b015 	stw	r2,-32064(gp)
						break;
81141838:	00000606 	br	81141854 <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8114183c:	e0bffa17 	ldw	r2,-24(fp)
81141840:	10800044 	addi	r2,r2,1
81141844:	e0bffa15 	stw	r2,-24(fp)
81141848:	e0bffa17 	ldw	r2,-24(fp)
8114184c:	10800110 	cmplti	r2,r2,4
81141850:	103fb51e 	bne	r2,zero,81141728 <__reset+0xfb121728>
				}
			}
		}
	}

	return result;
81141854:	e0bff917 	ldw	r2,-28(fp)
}
81141858:	e037883a 	mov	sp,fp
8114185c:	dfc00117 	ldw	ra,4(sp)
81141860:	df000017 	ldw	fp,0(sp)
81141864:	dec00204 	addi	sp,sp,8
81141868:	f800283a 	ret

8114186c <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
8114186c:	defff804 	addi	sp,sp,-32
81141870:	de00012e 	bgeu	sp,et,81141878 <Read_File_Record_At_Offset+0xc>
81141874:	003b68fa 	trap	3
81141878:	dfc00715 	stw	ra,28(sp)
8114187c:	df000615 	stw	fp,24(sp)
81141880:	df000604 	addi	fp,sp,24
81141884:	e13ffc15 	stw	r4,-16(fp)
81141888:	e17ffd15 	stw	r5,-12(fp)
8114188c:	e1bffe15 	stw	r6,-8(fp)
81141890:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
81141894:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81141898:	e0bffc17 	ldw	r2,-16(fp)
8114189c:	108007cc 	andi	r2,r2,31
811418a0:	10008d1e 	bne	r2,zero,81141ad8 <Read_File_Record_At_Offset+0x26c>
811418a4:	11441140 	call	81144114 <alt_up_sd_card_is_Present>
811418a8:	10008b26 	beq	r2,zero,81141ad8 <Read_File_Record_At_Offset+0x26c>
811418ac:	d0a0a917 	ldw	r2,-32092(gp)
811418b0:	10008926 	beq	r2,zero,81141ad8 <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
811418b4:	e03ffb15 	stw	zero,-20(fp)
811418b8:	00001106 	br	81141900 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
811418bc:	e0fffc17 	ldw	r3,-16(fp)
811418c0:	e0bffb17 	ldw	r2,-20(fp)
811418c4:	1885883a 	add	r2,r3,r2
811418c8:	1007883a 	mov	r3,r2
811418cc:	d0a0b217 	ldw	r2,-32056(gp)
811418d0:	10800a17 	ldw	r2,40(r2)
811418d4:	1885883a 	add	r2,r3,r2
811418d8:	10800023 	ldbuio	r2,0(r2)
811418dc:	10803fcc 	andi	r2,r2,255
811418e0:	1009883a 	mov	r4,r2
811418e4:	e0fffd17 	ldw	r3,-12(fp)
811418e8:	e0bffb17 	ldw	r2,-20(fp)
811418ec:	1885883a 	add	r2,r3,r2
811418f0:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
811418f4:	e0bffb17 	ldw	r2,-20(fp)
811418f8:	10800044 	addi	r2,r2,1
811418fc:	e0bffb15 	stw	r2,-20(fp)
81141900:	e0bffb17 	ldw	r2,-20(fp)
81141904:	10800210 	cmplti	r2,r2,8
81141908:	103fec1e 	bne	r2,zero,811418bc <__reset+0xfb1218bc>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8114190c:	e03ffb15 	stw	zero,-20(fp)
81141910:	00001306 	br	81141960 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
81141914:	e0fffc17 	ldw	r3,-16(fp)
81141918:	e0bffb17 	ldw	r2,-20(fp)
8114191c:	1885883a 	add	r2,r3,r2
81141920:	1007883a 	mov	r3,r2
81141924:	d0a0b217 	ldw	r2,-32056(gp)
81141928:	10800a17 	ldw	r2,40(r2)
8114192c:	1885883a 	add	r2,r3,r2
81141930:	10800204 	addi	r2,r2,8
81141934:	10800023 	ldbuio	r2,0(r2)
81141938:	10803fcc 	andi	r2,r2,255
8114193c:	1009883a 	mov	r4,r2
81141940:	e0fffd17 	ldw	r3,-12(fp)
81141944:	e0bffb17 	ldw	r2,-20(fp)
81141948:	1885883a 	add	r2,r3,r2
8114194c:	10800204 	addi	r2,r2,8
81141950:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
81141954:	e0bffb17 	ldw	r2,-20(fp)
81141958:	10800044 	addi	r2,r2,1
8114195c:	e0bffb15 	stw	r2,-20(fp)
81141960:	e0bffb17 	ldw	r2,-20(fp)
81141964:	108000d0 	cmplti	r2,r2,3
81141968:	103fea1e 	bne	r2,zero,81141914 <__reset+0xfb121914>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
8114196c:	d0a0b217 	ldw	r2,-32056(gp)
81141970:	10c00a17 	ldw	r3,40(r2)
81141974:	e0bffc17 	ldw	r2,-16(fp)
81141978:	1885883a 	add	r2,r3,r2
8114197c:	108002c4 	addi	r2,r2,11
81141980:	10800023 	ldbuio	r2,0(r2)
81141984:	10803fcc 	andi	r2,r2,255
81141988:	1007883a 	mov	r3,r2
8114198c:	e0bffd17 	ldw	r2,-12(fp)
81141990:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
81141994:	d0a0b217 	ldw	r2,-32056(gp)
81141998:	10c00a17 	ldw	r3,40(r2)
8114199c:	e0bffc17 	ldw	r2,-16(fp)
811419a0:	1885883a 	add	r2,r3,r2
811419a4:	10800384 	addi	r2,r2,14
811419a8:	1080002b 	ldhuio	r2,0(r2)
811419ac:	10bfffcc 	andi	r2,r2,65535
811419b0:	1007883a 	mov	r3,r2
811419b4:	e0bffd17 	ldw	r2,-12(fp)
811419b8:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
811419bc:	d0a0b217 	ldw	r2,-32056(gp)
811419c0:	10c00a17 	ldw	r3,40(r2)
811419c4:	e0bffc17 	ldw	r2,-16(fp)
811419c8:	1885883a 	add	r2,r3,r2
811419cc:	10800404 	addi	r2,r2,16
811419d0:	1080002b 	ldhuio	r2,0(r2)
811419d4:	10bfffcc 	andi	r2,r2,65535
811419d8:	1007883a 	mov	r3,r2
811419dc:	e0bffd17 	ldw	r2,-12(fp)
811419e0:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
811419e4:	d0a0b217 	ldw	r2,-32056(gp)
811419e8:	10c00a17 	ldw	r3,40(r2)
811419ec:	e0bffc17 	ldw	r2,-16(fp)
811419f0:	1885883a 	add	r2,r3,r2
811419f4:	10800484 	addi	r2,r2,18
811419f8:	1080002b 	ldhuio	r2,0(r2)
811419fc:	10bfffcc 	andi	r2,r2,65535
81141a00:	1007883a 	mov	r3,r2
81141a04:	e0bffd17 	ldw	r2,-12(fp)
81141a08:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
81141a0c:	d0a0b217 	ldw	r2,-32056(gp)
81141a10:	10c00a17 	ldw	r3,40(r2)
81141a14:	e0bffc17 	ldw	r2,-16(fp)
81141a18:	1885883a 	add	r2,r3,r2
81141a1c:	10800584 	addi	r2,r2,22
81141a20:	1080002b 	ldhuio	r2,0(r2)
81141a24:	10bfffcc 	andi	r2,r2,65535
81141a28:	1007883a 	mov	r3,r2
81141a2c:	e0bffd17 	ldw	r2,-12(fp)
81141a30:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
81141a34:	d0a0b217 	ldw	r2,-32056(gp)
81141a38:	10c00a17 	ldw	r3,40(r2)
81141a3c:	e0bffc17 	ldw	r2,-16(fp)
81141a40:	1885883a 	add	r2,r3,r2
81141a44:	10800604 	addi	r2,r2,24
81141a48:	1080002b 	ldhuio	r2,0(r2)
81141a4c:	10bfffcc 	andi	r2,r2,65535
81141a50:	1007883a 	mov	r3,r2
81141a54:	e0bffd17 	ldw	r2,-12(fp)
81141a58:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
81141a5c:	d0a0b217 	ldw	r2,-32056(gp)
81141a60:	10c00a17 	ldw	r3,40(r2)
81141a64:	e0bffc17 	ldw	r2,-16(fp)
81141a68:	1885883a 	add	r2,r3,r2
81141a6c:	10800684 	addi	r2,r2,26
81141a70:	1080002b 	ldhuio	r2,0(r2)
81141a74:	10bfffcc 	andi	r2,r2,65535
81141a78:	1007883a 	mov	r3,r2
81141a7c:	e0bffd17 	ldw	r2,-12(fp)
81141a80:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
81141a84:	d0a0b217 	ldw	r2,-32056(gp)
81141a88:	10c00a17 	ldw	r3,40(r2)
81141a8c:	e0bffc17 	ldw	r2,-16(fp)
81141a90:	1885883a 	add	r2,r3,r2
81141a94:	10800704 	addi	r2,r2,28
81141a98:	10800037 	ldwio	r2,0(r2)
81141a9c:	1007883a 	mov	r3,r2
81141aa0:	e0bffd17 	ldw	r2,-12(fp)
81141aa4:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
81141aa8:	e0bffd17 	ldw	r2,-12(fp)
81141aac:	e0fffe17 	ldw	r3,-8(fp)
81141ab0:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
81141ab4:	e0bffd17 	ldw	r2,-12(fp)
81141ab8:	e0ffff17 	ldw	r3,-4(fp)
81141abc:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
81141ac0:	e0bffc17 	ldw	r2,-16(fp)
81141ac4:	1007883a 	mov	r3,r2
81141ac8:	e0bffd17 	ldw	r2,-12(fp)
81141acc:	10c00c0d 	sth	r3,48(r2)
		result = true;
81141ad0:	00800044 	movi	r2,1
81141ad4:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
81141ad8:	e0bffa17 	ldw	r2,-24(fp)
}
81141adc:	e037883a 	mov	sp,fp
81141ae0:	dfc00117 	ldw	ra,4(sp)
81141ae4:	df000017 	ldw	fp,0(sp)
81141ae8:	dec00204 	addi	sp,sp,8
81141aec:	f800283a 	ret

81141af0 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
81141af0:	defff904 	addi	sp,sp,-28
81141af4:	de00012e 	bgeu	sp,et,81141afc <Write_File_Record_At_Offset+0xc>
81141af8:	003b68fa 	trap	3
81141afc:	dfc00615 	stw	ra,24(sp)
81141b00:	df000515 	stw	fp,20(sp)
81141b04:	df000504 	addi	fp,sp,20
81141b08:	e13ffe15 	stw	r4,-8(fp)
81141b0c:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
81141b10:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81141b14:	e0bffe17 	ldw	r2,-8(fp)
81141b18:	108007cc 	andi	r2,r2,31
81141b1c:	1000931e 	bne	r2,zero,81141d6c <Write_File_Record_At_Offset+0x27c>
81141b20:	11441140 	call	81144114 <alt_up_sd_card_is_Present>
81141b24:	10009126 	beq	r2,zero,81141d6c <Write_File_Record_At_Offset+0x27c>
81141b28:	d0a0a917 	ldw	r2,-32092(gp)
81141b2c:	10008f26 	beq	r2,zero,81141d6c <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
81141b30:	e03ffc15 	stw	zero,-16(fp)
81141b34:	00001f06 	br	81141bb4 <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
81141b38:	e0bffc17 	ldw	r2,-16(fp)
81141b3c:	10800044 	addi	r2,r2,1
81141b40:	e0ffff17 	ldw	r3,-4(fp)
81141b44:	1885883a 	add	r2,r3,r2
81141b48:	10800003 	ldbu	r2,0(r2)
81141b4c:	10803fcc 	andi	r2,r2,255
81141b50:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
81141b54:	e0bffd0f 	ldh	r2,-12(fp)
81141b58:	1004923a 	slli	r2,r2,8
81141b5c:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
81141b60:	e0ffff17 	ldw	r3,-4(fp)
81141b64:	e0bffc17 	ldw	r2,-16(fp)
81141b68:	1885883a 	add	r2,r3,r2
81141b6c:	10800003 	ldbu	r2,0(r2)
81141b70:	10c03fcc 	andi	r3,r2,255
81141b74:	e0bffd0b 	ldhu	r2,-12(fp)
81141b78:	1884b03a 	or	r2,r3,r2
81141b7c:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
81141b80:	e0fffe17 	ldw	r3,-8(fp)
81141b84:	e0bffc17 	ldw	r2,-16(fp)
81141b88:	1885883a 	add	r2,r3,r2
81141b8c:	1007883a 	mov	r3,r2
81141b90:	d0a0b217 	ldw	r2,-32056(gp)
81141b94:	10800a17 	ldw	r2,40(r2)
81141b98:	1885883a 	add	r2,r3,r2
81141b9c:	1007883a 	mov	r3,r2
81141ba0:	e0bffd0f 	ldh	r2,-12(fp)
81141ba4:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
81141ba8:	e0bffc17 	ldw	r2,-16(fp)
81141bac:	10800084 	addi	r2,r2,2
81141bb0:	e0bffc15 	stw	r2,-16(fp)
81141bb4:	e0bffc17 	ldw	r2,-16(fp)
81141bb8:	10800210 	cmplti	r2,r2,8
81141bbc:	103fde1e 	bne	r2,zero,81141b38 <__reset+0xfb121b38>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81141bc0:	e03ffc15 	stw	zero,-16(fp)
81141bc4:	00001306 	br	81141c14 <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
81141bc8:	e0fffe17 	ldw	r3,-8(fp)
81141bcc:	e0bffc17 	ldw	r2,-16(fp)
81141bd0:	1885883a 	add	r2,r3,r2
81141bd4:	1007883a 	mov	r3,r2
81141bd8:	d0a0b217 	ldw	r2,-32056(gp)
81141bdc:	10800a17 	ldw	r2,40(r2)
81141be0:	1885883a 	add	r2,r3,r2
81141be4:	10800204 	addi	r2,r2,8
81141be8:	1009883a 	mov	r4,r2
81141bec:	e0ffff17 	ldw	r3,-4(fp)
81141bf0:	e0bffc17 	ldw	r2,-16(fp)
81141bf4:	1885883a 	add	r2,r3,r2
81141bf8:	10800204 	addi	r2,r2,8
81141bfc:	10800003 	ldbu	r2,0(r2)
81141c00:	10803fcc 	andi	r2,r2,255
81141c04:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81141c08:	e0bffc17 	ldw	r2,-16(fp)
81141c0c:	10800044 	addi	r2,r2,1
81141c10:	e0bffc15 	stw	r2,-16(fp)
81141c14:	e0bffc17 	ldw	r2,-16(fp)
81141c18:	108000d0 	cmplti	r2,r2,3
81141c1c:	103fea1e 	bne	r2,zero,81141bc8 <__reset+0xfb121bc8>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
81141c20:	d0a0b217 	ldw	r2,-32056(gp)
81141c24:	10c00a17 	ldw	r3,40(r2)
81141c28:	e0bffe17 	ldw	r2,-8(fp)
81141c2c:	1885883a 	add	r2,r3,r2
81141c30:	108002c4 	addi	r2,r2,11
81141c34:	1007883a 	mov	r3,r2
81141c38:	e0bfff17 	ldw	r2,-4(fp)
81141c3c:	108002c3 	ldbu	r2,11(r2)
81141c40:	10803fcc 	andi	r2,r2,255
81141c44:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
81141c48:	d0a0b217 	ldw	r2,-32056(gp)
81141c4c:	10c00a17 	ldw	r3,40(r2)
81141c50:	e0bffe17 	ldw	r2,-8(fp)
81141c54:	1885883a 	add	r2,r3,r2
81141c58:	10800384 	addi	r2,r2,14
81141c5c:	1007883a 	mov	r3,r2
81141c60:	e0bfff17 	ldw	r2,-4(fp)
81141c64:	1080030b 	ldhu	r2,12(r2)
81141c68:	10bfffcc 	andi	r2,r2,65535
81141c6c:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
81141c70:	d0a0b217 	ldw	r2,-32056(gp)
81141c74:	10c00a17 	ldw	r3,40(r2)
81141c78:	e0bffe17 	ldw	r2,-8(fp)
81141c7c:	1885883a 	add	r2,r3,r2
81141c80:	10800404 	addi	r2,r2,16
81141c84:	1007883a 	mov	r3,r2
81141c88:	e0bfff17 	ldw	r2,-4(fp)
81141c8c:	1080038b 	ldhu	r2,14(r2)
81141c90:	10bfffcc 	andi	r2,r2,65535
81141c94:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
81141c98:	d0a0b217 	ldw	r2,-32056(gp)
81141c9c:	10c00a17 	ldw	r3,40(r2)
81141ca0:	e0bffe17 	ldw	r2,-8(fp)
81141ca4:	1885883a 	add	r2,r3,r2
81141ca8:	10800484 	addi	r2,r2,18
81141cac:	1007883a 	mov	r3,r2
81141cb0:	e0bfff17 	ldw	r2,-4(fp)
81141cb4:	1080040b 	ldhu	r2,16(r2)
81141cb8:	10bfffcc 	andi	r2,r2,65535
81141cbc:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
81141cc0:	d0a0b217 	ldw	r2,-32056(gp)
81141cc4:	10c00a17 	ldw	r3,40(r2)
81141cc8:	e0bffe17 	ldw	r2,-8(fp)
81141ccc:	1885883a 	add	r2,r3,r2
81141cd0:	10800584 	addi	r2,r2,22
81141cd4:	1007883a 	mov	r3,r2
81141cd8:	e0bfff17 	ldw	r2,-4(fp)
81141cdc:	1080048b 	ldhu	r2,18(r2)
81141ce0:	10bfffcc 	andi	r2,r2,65535
81141ce4:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
81141ce8:	d0a0b217 	ldw	r2,-32056(gp)
81141cec:	10c00a17 	ldw	r3,40(r2)
81141cf0:	e0bffe17 	ldw	r2,-8(fp)
81141cf4:	1885883a 	add	r2,r3,r2
81141cf8:	10800604 	addi	r2,r2,24
81141cfc:	1007883a 	mov	r3,r2
81141d00:	e0bfff17 	ldw	r2,-4(fp)
81141d04:	1080050b 	ldhu	r2,20(r2)
81141d08:	10bfffcc 	andi	r2,r2,65535
81141d0c:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
81141d10:	d0a0b217 	ldw	r2,-32056(gp)
81141d14:	10c00a17 	ldw	r3,40(r2)
81141d18:	e0bffe17 	ldw	r2,-8(fp)
81141d1c:	1885883a 	add	r2,r3,r2
81141d20:	10800684 	addi	r2,r2,26
81141d24:	1007883a 	mov	r3,r2
81141d28:	e0bfff17 	ldw	r2,-4(fp)
81141d2c:	1080058b 	ldhu	r2,22(r2)
81141d30:	10bfffcc 	andi	r2,r2,65535
81141d34:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
81141d38:	d0a0b217 	ldw	r2,-32056(gp)
81141d3c:	10c00a17 	ldw	r3,40(r2)
81141d40:	e0bffe17 	ldw	r2,-8(fp)
81141d44:	1885883a 	add	r2,r3,r2
81141d48:	10800704 	addi	r2,r2,28
81141d4c:	1007883a 	mov	r3,r2
81141d50:	e0bfff17 	ldw	r2,-4(fp)
81141d54:	10800617 	ldw	r2,24(r2)
81141d58:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
81141d5c:	00800044 	movi	r2,1
81141d60:	d0a0b315 	stw	r2,-32052(gp)
        result = true;
81141d64:	00800044 	movi	r2,1
81141d68:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
81141d6c:	e0bffb17 	ldw	r2,-20(fp)
}
81141d70:	e037883a 	mov	sp,fp
81141d74:	dfc00117 	ldw	ra,4(sp)
81141d78:	df000017 	ldw	fp,0(sp)
81141d7c:	dec00204 	addi	sp,sp,8
81141d80:	f800283a 	ret

81141d84 <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
81141d84:	defff904 	addi	sp,sp,-28
81141d88:	de00012e 	bgeu	sp,et,81141d90 <Check_for_DOS_FAT+0xc>
81141d8c:	003b68fa 	trap	3
81141d90:	dfc00615 	stw	ra,24(sp)
81141d94:	df000515 	stw	fp,20(sp)
81141d98:	df000504 	addi	fp,sp,20
81141d9c:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
81141da0:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
81141da4:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
81141da8:	e17fff17 	ldw	r5,-4(fp)
81141dac:	0009883a 	mov	r4,zero
81141db0:	114143c0 	call	8114143c <Read_Sector_Data>
81141db4:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
81141db8:	d0a0b217 	ldw	r2,-32056(gp)
81141dbc:	10800a17 	ldw	r2,40(r2)
81141dc0:	10807f84 	addi	r2,r2,510
81141dc4:	1080002b 	ldhuio	r2,0(r2)
81141dc8:	10bfffcc 	andi	r2,r2,65535
81141dcc:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
81141dd0:	e0bffe0f 	ldh	r2,-8(fp)
81141dd4:	10ffffcc 	andi	r3,r2,65535
81141dd8:	00aa9554 	movui	r2,43605
81141ddc:	1881841e 	bne	r3,r2,811423f0 <Check_for_DOS_FAT+0x66c>
81141de0:	e0bffb17 	ldw	r2,-20(fp)
81141de4:	10018226 	beq	r2,zero,811423f0 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
81141de8:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
81141dec:	d0a0b217 	ldw	r2,-32056(gp)
81141df0:	10800a17 	ldw	r2,40(r2)
81141df4:	10800023 	ldbuio	r2,0(r2)
81141df8:	10803fcc 	andi	r2,r2,255
81141dfc:	1007883a 	mov	r3,r2
81141e00:	00a045f4 	movhi	r2,33047
81141e04:	10af9e04 	addi	r2,r2,-16776
81141e08:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
81141e0c:	d0a0b217 	ldw	r2,-32056(gp)
81141e10:	10800a17 	ldw	r2,40(r2)
81141e14:	10800044 	addi	r2,r2,1
81141e18:	10800023 	ldbuio	r2,0(r2)
81141e1c:	10803fcc 	andi	r2,r2,255
81141e20:	1007883a 	mov	r3,r2
81141e24:	00a045f4 	movhi	r2,33047
81141e28:	10af9e04 	addi	r2,r2,-16776
81141e2c:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
81141e30:	d0a0b217 	ldw	r2,-32056(gp)
81141e34:	10800a17 	ldw	r2,40(r2)
81141e38:	10800084 	addi	r2,r2,2
81141e3c:	10800023 	ldbuio	r2,0(r2)
81141e40:	10803fcc 	andi	r2,r2,255
81141e44:	1007883a 	mov	r3,r2
81141e48:	00a045f4 	movhi	r2,33047
81141e4c:	10af9e04 	addi	r2,r2,-16776
81141e50:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
81141e54:	e03ffc15 	stw	zero,-16(fp)
81141e58:	00001106 	br	81141ea0 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
81141e5c:	d0a0b217 	ldw	r2,-32056(gp)
81141e60:	10c00a17 	ldw	r3,40(r2)
81141e64:	e0bffc17 	ldw	r2,-16(fp)
81141e68:	1885883a 	add	r2,r3,r2
81141e6c:	108000c4 	addi	r2,r2,3
81141e70:	10800023 	ldbuio	r2,0(r2)
81141e74:	10803fcc 	andi	r2,r2,255
81141e78:	1009883a 	mov	r4,r2
81141e7c:	00a045f4 	movhi	r2,33047
81141e80:	10af9e04 	addi	r2,r2,-16776
81141e84:	e0fffc17 	ldw	r3,-16(fp)
81141e88:	10c5883a 	add	r2,r2,r3
81141e8c:	108000c4 	addi	r2,r2,3
81141e90:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
81141e94:	e0bffc17 	ldw	r2,-16(fp)
81141e98:	10800044 	addi	r2,r2,1
81141e9c:	e0bffc15 	stw	r2,-16(fp)
81141ea0:	e0bffc17 	ldw	r2,-16(fp)
81141ea4:	10800210 	cmplti	r2,r2,8
81141ea8:	103fec1e 	bne	r2,zero,81141e5c <__reset+0xfb121e5c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
81141eac:	d0a0b217 	ldw	r2,-32056(gp)
81141eb0:	10800a17 	ldw	r2,40(r2)
81141eb4:	10800304 	addi	r2,r2,12
81141eb8:	10800023 	ldbuio	r2,0(r2)
81141ebc:	10803fcc 	andi	r2,r2,255
81141ec0:	1004923a 	slli	r2,r2,8
81141ec4:	1007883a 	mov	r3,r2
81141ec8:	d0a0b217 	ldw	r2,-32056(gp)
81141ecc:	10800a17 	ldw	r2,40(r2)
81141ed0:	108002c4 	addi	r2,r2,11
81141ed4:	10800023 	ldbuio	r2,0(r2)
81141ed8:	10803fcc 	andi	r2,r2,255
81141edc:	10803fcc 	andi	r2,r2,255
81141ee0:	1080201c 	xori	r2,r2,128
81141ee4:	10bfe004 	addi	r2,r2,-128
81141ee8:	1884b03a 	or	r2,r3,r2
81141eec:	1007883a 	mov	r3,r2
81141ef0:	00a045f4 	movhi	r2,33047
81141ef4:	10af9e04 	addi	r2,r2,-16776
81141ef8:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
81141efc:	d0a0b217 	ldw	r2,-32056(gp)
81141f00:	10800a17 	ldw	r2,40(r2)
81141f04:	10800344 	addi	r2,r2,13
81141f08:	10800023 	ldbuio	r2,0(r2)
81141f0c:	10803fcc 	andi	r2,r2,255
81141f10:	1007883a 	mov	r3,r2
81141f14:	00a045f4 	movhi	r2,33047
81141f18:	10af9e04 	addi	r2,r2,-16776
81141f1c:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
81141f20:	d0a0b217 	ldw	r2,-32056(gp)
81141f24:	10800a17 	ldw	r2,40(r2)
81141f28:	10800384 	addi	r2,r2,14
81141f2c:	1080002b 	ldhuio	r2,0(r2)
81141f30:	10bfffcc 	andi	r2,r2,65535
81141f34:	1007883a 	mov	r3,r2
81141f38:	00a045f4 	movhi	r2,33047
81141f3c:	10af9e04 	addi	r2,r2,-16776
81141f40:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
81141f44:	d0a0b217 	ldw	r2,-32056(gp)
81141f48:	10800a17 	ldw	r2,40(r2)
81141f4c:	10800404 	addi	r2,r2,16
81141f50:	10800023 	ldbuio	r2,0(r2)
81141f54:	10803fcc 	andi	r2,r2,255
81141f58:	1007883a 	mov	r3,r2
81141f5c:	00a045f4 	movhi	r2,33047
81141f60:	10af9e04 	addi	r2,r2,-16776
81141f64:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
81141f68:	d0a0b217 	ldw	r2,-32056(gp)
81141f6c:	10800a17 	ldw	r2,40(r2)
81141f70:	10800484 	addi	r2,r2,18
81141f74:	10800023 	ldbuio	r2,0(r2)
81141f78:	10803fcc 	andi	r2,r2,255
81141f7c:	1004923a 	slli	r2,r2,8
81141f80:	1007883a 	mov	r3,r2
81141f84:	d0a0b217 	ldw	r2,-32056(gp)
81141f88:	10800a17 	ldw	r2,40(r2)
81141f8c:	10800444 	addi	r2,r2,17
81141f90:	10800023 	ldbuio	r2,0(r2)
81141f94:	10803fcc 	andi	r2,r2,255
81141f98:	10803fcc 	andi	r2,r2,255
81141f9c:	1884b03a 	or	r2,r3,r2
81141fa0:	1007883a 	mov	r3,r2
81141fa4:	00a045f4 	movhi	r2,33047
81141fa8:	10af9e04 	addi	r2,r2,-16776
81141fac:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
81141fb0:	d0a0b217 	ldw	r2,-32056(gp)
81141fb4:	10800a17 	ldw	r2,40(r2)
81141fb8:	10800504 	addi	r2,r2,20
81141fbc:	10800023 	ldbuio	r2,0(r2)
81141fc0:	10803fcc 	andi	r2,r2,255
81141fc4:	1004923a 	slli	r2,r2,8
81141fc8:	1007883a 	mov	r3,r2
81141fcc:	d0a0b217 	ldw	r2,-32056(gp)
81141fd0:	10800a17 	ldw	r2,40(r2)
81141fd4:	108004c4 	addi	r2,r2,19
81141fd8:	10800023 	ldbuio	r2,0(r2)
81141fdc:	10803fcc 	andi	r2,r2,255
81141fe0:	10803fcc 	andi	r2,r2,255
81141fe4:	1884b03a 	or	r2,r3,r2
81141fe8:	1007883a 	mov	r3,r2
81141fec:	00a045f4 	movhi	r2,33047
81141ff0:	10af9e04 	addi	r2,r2,-16776
81141ff4:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
81141ff8:	d0a0b217 	ldw	r2,-32056(gp)
81141ffc:	10800a17 	ldw	r2,40(r2)
81142000:	10800544 	addi	r2,r2,21
81142004:	10800023 	ldbuio	r2,0(r2)
81142008:	10803fcc 	andi	r2,r2,255
8114200c:	1007883a 	mov	r3,r2
81142010:	00a045f4 	movhi	r2,33047
81142014:	10af9e04 	addi	r2,r2,-16776
81142018:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
8114201c:	d0a0b217 	ldw	r2,-32056(gp)
81142020:	10800a17 	ldw	r2,40(r2)
81142024:	10800584 	addi	r2,r2,22
81142028:	1080002b 	ldhuio	r2,0(r2)
8114202c:	10bfffcc 	andi	r2,r2,65535
81142030:	1007883a 	mov	r3,r2
81142034:	00a045f4 	movhi	r2,33047
81142038:	10af9e04 	addi	r2,r2,-16776
8114203c:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
81142040:	d0a0b217 	ldw	r2,-32056(gp)
81142044:	10800a17 	ldw	r2,40(r2)
81142048:	10800604 	addi	r2,r2,24
8114204c:	1080002b 	ldhuio	r2,0(r2)
81142050:	10bfffcc 	andi	r2,r2,65535
81142054:	1007883a 	mov	r3,r2
81142058:	00a045f4 	movhi	r2,33047
8114205c:	10af9e04 	addi	r2,r2,-16776
81142060:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
81142064:	d0a0b217 	ldw	r2,-32056(gp)
81142068:	10800a17 	ldw	r2,40(r2)
8114206c:	10800684 	addi	r2,r2,26
81142070:	1080002b 	ldhuio	r2,0(r2)
81142074:	10bfffcc 	andi	r2,r2,65535
81142078:	1007883a 	mov	r3,r2
8114207c:	00a045f4 	movhi	r2,33047
81142080:	10af9e04 	addi	r2,r2,-16776
81142084:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
81142088:	d0a0b217 	ldw	r2,-32056(gp)
8114208c:	10800a17 	ldw	r2,40(r2)
81142090:	10800704 	addi	r2,r2,28
81142094:	10800037 	ldwio	r2,0(r2)
81142098:	1007883a 	mov	r3,r2
8114209c:	00a045f4 	movhi	r2,33047
811420a0:	10af9e04 	addi	r2,r2,-16776
811420a4:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
811420a8:	d0a0b217 	ldw	r2,-32056(gp)
811420ac:	10800a17 	ldw	r2,40(r2)
811420b0:	10800804 	addi	r2,r2,32
811420b4:	10800037 	ldwio	r2,0(r2)
811420b8:	1007883a 	mov	r3,r2
811420bc:	00a045f4 	movhi	r2,33047
811420c0:	10af9e04 	addi	r2,r2,-16776
811420c4:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
811420c8:	d0a0b217 	ldw	r2,-32056(gp)
811420cc:	10800a17 	ldw	r2,40(r2)
811420d0:	10800904 	addi	r2,r2,36
811420d4:	10800023 	ldbuio	r2,0(r2)
811420d8:	10803fcc 	andi	r2,r2,255
811420dc:	1007883a 	mov	r3,r2
811420e0:	00a045f4 	movhi	r2,33047
811420e4:	10af9e04 	addi	r2,r2,-16776
811420e8:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
811420ec:	d0a0b217 	ldw	r2,-32056(gp)
811420f0:	10800a17 	ldw	r2,40(r2)
811420f4:	10800944 	addi	r2,r2,37
811420f8:	10800023 	ldbuio	r2,0(r2)
811420fc:	10803fcc 	andi	r2,r2,255
81142100:	1007883a 	mov	r3,r2
81142104:	00a045f4 	movhi	r2,33047
81142108:	10af9e04 	addi	r2,r2,-16776
8114210c:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
81142110:	d0a0b217 	ldw	r2,-32056(gp)
81142114:	10800a17 	ldw	r2,40(r2)
81142118:	10800984 	addi	r2,r2,38
8114211c:	10800023 	ldbuio	r2,0(r2)
81142120:	10803fcc 	andi	r2,r2,255
81142124:	1007883a 	mov	r3,r2
81142128:	00a045f4 	movhi	r2,33047
8114212c:	10af9e04 	addi	r2,r2,-16776
81142130:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
81142134:	00a045f4 	movhi	r2,33047
81142138:	10af9e04 	addi	r2,r2,-16776
8114213c:	1080040b 	ldhu	r2,16(r2)
81142140:	10ffffcc 	andi	r3,r2,65535
81142144:	00a045f4 	movhi	r2,33047
81142148:	10af9e04 	addi	r2,r2,-16776
8114214c:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
81142150:	00a045f4 	movhi	r2,33047
81142154:	10af9e04 	addi	r2,r2,-16776
81142158:	10c01117 	ldw	r3,68(r2)
8114215c:	00a045f4 	movhi	r2,33047
81142160:	10af9e04 	addi	r2,r2,-16776
81142164:	1080068b 	ldhu	r2,26(r2)
81142168:	10bfffcc 	andi	r2,r2,65535
8114216c:	1887883a 	add	r3,r3,r2
81142170:	00a045f4 	movhi	r2,33047
81142174:	10af9e04 	addi	r2,r2,-16776
81142178:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
8114217c:	00a045f4 	movhi	r2,33047
81142180:	10af9e04 	addi	r2,r2,-16776
81142184:	10c01217 	ldw	r3,72(r2)
81142188:	00a045f4 	movhi	r2,33047
8114218c:	10af9e04 	addi	r2,r2,-16776
81142190:	1080068b 	ldhu	r2,26(r2)
81142194:	10bfffcc 	andi	r2,r2,65535
81142198:	1887883a 	add	r3,r3,r2
8114219c:	00a045f4 	movhi	r2,33047
811421a0:	10af9e04 	addi	r2,r2,-16776
811421a4:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
811421a8:	00a045f4 	movhi	r2,33047
811421ac:	10af9e04 	addi	r2,r2,-16776
811421b0:	10c01317 	ldw	r3,76(r2)
811421b4:	00a045f4 	movhi	r2,33047
811421b8:	10af9e04 	addi	r2,r2,-16776
811421bc:	1080050b 	ldhu	r2,20(r2)
811421c0:	10bfffcc 	andi	r2,r2,65535
811421c4:	1008917a 	slli	r4,r2,5
811421c8:	00a045f4 	movhi	r2,33047
811421cc:	10af9e04 	addi	r2,r2,-16776
811421d0:	1080030b 	ldhu	r2,12(r2)
811421d4:	10bfffcc 	andi	r2,r2,65535
811421d8:	2085283a 	div	r2,r4,r2
811421dc:	1887883a 	add	r3,r3,r2
811421e0:	00a045f4 	movhi	r2,33047
811421e4:	10af9e04 	addi	r2,r2,-16776
811421e8:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
811421ec:	00a045f4 	movhi	r2,33047
811421f0:	10af9e04 	addi	r2,r2,-16776
811421f4:	1080058b 	ldhu	r2,22(r2)
811421f8:	10bfffcc 	andi	r2,r2,65535
811421fc:	10000b26 	beq	r2,zero,8114222c <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
81142200:	00a045f4 	movhi	r2,33047
81142204:	10af9e04 	addi	r2,r2,-16776
81142208:	1080058b 	ldhu	r2,22(r2)
8114220c:	10ffffcc 	andi	r3,r2,65535
81142210:	00a045f4 	movhi	r2,33047
81142214:	10af9e04 	addi	r2,r2,-16776
81142218:	10800383 	ldbu	r2,14(r2)
8114221c:	10803fcc 	andi	r2,r2,255
81142220:	1885283a 	div	r2,r3,r2
81142224:	e0bffd15 	stw	r2,-12(fp)
81142228:	00000906 	br	81142250 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
8114222c:	00a045f4 	movhi	r2,33047
81142230:	10af9e04 	addi	r2,r2,-16776
81142234:	10c00917 	ldw	r3,36(r2)
81142238:	00a045f4 	movhi	r2,33047
8114223c:	10af9e04 	addi	r2,r2,-16776
81142240:	10800383 	ldbu	r2,14(r2)
81142244:	10803fcc 	andi	r2,r2,255
81142248:	1885203a 	divu	r2,r3,r2
8114224c:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
81142250:	e0bffd17 	ldw	r2,-12(fp)
81142254:	1083fdc8 	cmpgei	r2,r2,4087
81142258:	1000051e 	bne	r2,zero,81142270 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
8114225c:	00a045f4 	movhi	r2,33047
81142260:	10af9e04 	addi	r2,r2,-16776
81142264:	00c00304 	movi	r3,12
81142268:	10c01085 	stb	r3,66(r2)
8114226c:	00000c06 	br	811422a0 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
81142270:	e0bffd17 	ldw	r2,-12(fp)
81142274:	00fffb54 	movui	r3,65517
81142278:	18800516 	blt	r3,r2,81142290 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
8114227c:	00a045f4 	movhi	r2,33047
81142280:	10af9e04 	addi	r2,r2,-16776
81142284:	00c00404 	movi	r3,16
81142288:	10c01085 	stb	r3,66(r2)
8114228c:	00000406 	br	811422a0 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
81142290:	00a045f4 	movhi	r2,33047
81142294:	10af9e04 	addi	r2,r2,-16776
81142298:	00c00804 	movi	r3,32
8114229c:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
811422a0:	e03ffc15 	stw	zero,-16(fp)
811422a4:	00001106 	br	811422ec <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
811422a8:	d0a0b217 	ldw	r2,-32056(gp)
811422ac:	10c00a17 	ldw	r3,40(r2)
811422b0:	e0bffc17 	ldw	r2,-16(fp)
811422b4:	1885883a 	add	r2,r3,r2
811422b8:	108009c4 	addi	r2,r2,39
811422bc:	10800023 	ldbuio	r2,0(r2)
811422c0:	10803fcc 	andi	r2,r2,255
811422c4:	1009883a 	mov	r4,r2
811422c8:	00a045f4 	movhi	r2,33047
811422cc:	10af9e04 	addi	r2,r2,-16776
811422d0:	e0fffc17 	ldw	r3,-16(fp)
811422d4:	10c5883a 	add	r2,r2,r3
811422d8:	10800ac4 	addi	r2,r2,43
811422dc:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
811422e0:	e0bffc17 	ldw	r2,-16(fp)
811422e4:	10800044 	addi	r2,r2,1
811422e8:	e0bffc15 	stw	r2,-16(fp)
811422ec:	e0bffc17 	ldw	r2,-16(fp)
811422f0:	10800110 	cmplti	r2,r2,4
811422f4:	103fec1e 	bne	r2,zero,811422a8 <__reset+0xfb1222a8>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
811422f8:	e03ffc15 	stw	zero,-16(fp)
811422fc:	00001106 	br	81142344 <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
81142300:	d0a0b217 	ldw	r2,-32056(gp)
81142304:	10c00a17 	ldw	r3,40(r2)
81142308:	e0bffc17 	ldw	r2,-16(fp)
8114230c:	1885883a 	add	r2,r3,r2
81142310:	10800ac4 	addi	r2,r2,43
81142314:	10800023 	ldbuio	r2,0(r2)
81142318:	10803fcc 	andi	r2,r2,255
8114231c:	1009883a 	mov	r4,r2
81142320:	00a045f4 	movhi	r2,33047
81142324:	10af9e04 	addi	r2,r2,-16776
81142328:	e0fffc17 	ldw	r3,-16(fp)
8114232c:	10c5883a 	add	r2,r2,r3
81142330:	10800bc4 	addi	r2,r2,47
81142334:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
81142338:	e0bffc17 	ldw	r2,-16(fp)
8114233c:	10800044 	addi	r2,r2,1
81142340:	e0bffc15 	stw	r2,-16(fp)
81142344:	e0bffc17 	ldw	r2,-16(fp)
81142348:	108002d0 	cmplti	r2,r2,11
8114234c:	103fec1e 	bne	r2,zero,81142300 <__reset+0xfb122300>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
81142350:	e03ffc15 	stw	zero,-16(fp)
81142354:	00001106 	br	8114239c <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
81142358:	d0a0b217 	ldw	r2,-32056(gp)
8114235c:	10c00a17 	ldw	r3,40(r2)
81142360:	e0bffc17 	ldw	r2,-16(fp)
81142364:	1885883a 	add	r2,r3,r2
81142368:	10800d84 	addi	r2,r2,54
8114236c:	10800023 	ldbuio	r2,0(r2)
81142370:	10803fcc 	andi	r2,r2,255
81142374:	1009883a 	mov	r4,r2
81142378:	00a045f4 	movhi	r2,33047
8114237c:	10af9e04 	addi	r2,r2,-16776
81142380:	e0fffc17 	ldw	r3,-16(fp)
81142384:	10c5883a 	add	r2,r2,r3
81142388:	10800e84 	addi	r2,r2,58
8114238c:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
81142390:	e0bffc17 	ldw	r2,-16(fp)
81142394:	10800044 	addi	r2,r2,1
81142398:	e0bffc15 	stw	r2,-16(fp)
8114239c:	e0bffc17 	ldw	r2,-16(fp)
811423a0:	10800210 	cmplti	r2,r2,8
811423a4:	103fec1e 	bne	r2,zero,81142358 <__reset+0xfb122358>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
811423a8:	e03ffc15 	stw	zero,-16(fp)
811423ac:	00000a06 	br	811423d8 <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
811423b0:	00a045f4 	movhi	r2,33047
811423b4:	10afb304 	addi	r2,r2,-16692
811423b8:	e0fffc17 	ldw	r3,-16(fp)
811423bc:	180691ba 	slli	r3,r3,6
811423c0:	10c5883a 	add	r2,r2,r3
811423c4:	10800f04 	addi	r2,r2,60
811423c8:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
811423cc:	e0bffc17 	ldw	r2,-16(fp)
811423d0:	10800044 	addi	r2,r2,1
811423d4:	e0bffc15 	stw	r2,-16(fp)
811423d8:	e0bffc17 	ldw	r2,-16(fp)
811423dc:	10800510 	cmplti	r2,r2,20
811423e0:	103ff31e 	bne	r2,zero,811423b0 <__reset+0xfb1223b0>
		{
			active_files[counter].in_use = false;
		}
		result = true;
811423e4:	00800044 	movi	r2,1
811423e8:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
811423ec:	00000106 	br	811423f4 <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
811423f0:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
811423f4:	e0bffb17 	ldw	r2,-20(fp)
}
811423f8:	e037883a 	mov	sp,fp
811423fc:	dfc00117 	ldw	ra,4(sp)
81142400:	df000017 	ldw	fp,0(sp)
81142404:	dec00204 	addi	sp,sp,8
81142408:	f800283a 	ret

8114240c <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
8114240c:	defffc04 	addi	sp,sp,-16
81142410:	de00012e 	bgeu	sp,et,81142418 <Look_for_FAT16+0xc>
81142414:	003b68fa 	trap	3
81142418:	dfc00315 	stw	ra,12(sp)
8114241c:	df000215 	stw	fp,8(sp)
81142420:	df000204 	addi	fp,sp,8
	bool result = false;
81142424:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
81142428:	11441140 	call	81144114 <alt_up_sd_card_is_Present>
8114242c:	10002e26 	beq	r2,zero,811424e8 <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
81142430:	d0a0ac17 	ldw	r2,-32080(gp)
81142434:	1080000b 	ldhu	r2,0(r2)
81142438:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
8114243c:	d020b015 	stw	zero,-32064(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
81142440:	d020b115 	stw	zero,-32060(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
81142444:	e0bfff0f 	ldh	r2,-4(fp)
81142448:	10002716 	blt	r2,zero,811424e8 <Look_for_FAT16+0xdc>
8114244c:	e0bfff0b 	ldhu	r2,-4(fp)
81142450:	10bfffcc 	andi	r2,r2,65535
81142454:	1083000c 	andi	r2,r2,3072
81142458:	10830020 	cmpeqi	r2,r2,3072
8114245c:	1000221e 	bne	r2,zero,811424e8 <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
81142460:	e0bfff0b 	ldhu	r2,-4(fp)
81142464:	10bfffcc 	andi	r2,r2,65535
81142468:	1083000c 	andi	r2,r2,3072
8114246c:	10810018 	cmpnei	r2,r2,1024
81142470:	1000031e 	bne	r2,zero,81142480 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
81142474:	0009883a 	mov	r4,zero
81142478:	1141d840 	call	81141d84 <Check_for_DOS_FAT>
8114247c:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
81142480:	e0bfff0b 	ldhu	r2,-4(fp)
81142484:	10bfffcc 	andi	r2,r2,65535
81142488:	1083000c 	andi	r2,r2,3072
8114248c:	1000061e 	bne	r2,zero,811424a8 <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
81142490:	11416c00 	call	811416c0 <Check_for_Master_Boot_Record>
81142494:	10000426 	beq	r2,zero,811424a8 <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
81142498:	d0a0b017 	ldw	r2,-32064(gp)
8114249c:	1009883a 	mov	r4,r2
811424a0:	1141d840 	call	81141d84 <Check_for_DOS_FAT>
811424a4:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
811424a8:	e0bffe17 	ldw	r2,-8(fp)
811424ac:	10800058 	cmpnei	r2,r2,1
811424b0:	10000d1e 	bne	r2,zero,811424e8 <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
811424b4:	00a045f4 	movhi	r2,33047
811424b8:	10af9e04 	addi	r2,r2,-16776
811424bc:	10801083 	ldbu	r2,66(r2)
811424c0:	10803fcc 	andi	r2,r2,255
811424c4:	10800420 	cmpeqi	r2,r2,16
811424c8:	1000021e 	bne	r2,zero,811424d4 <Look_for_FAT16+0xc8>
				{
					result = false;
811424cc:	e03ffe15 	stw	zero,-8(fp)
811424d0:	00000506 	br	811424e8 <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
811424d4:	00a045f4 	movhi	r2,33047
811424d8:	10af9e04 	addi	r2,r2,-16776
811424dc:	1080058b 	ldhu	r2,22(r2)
811424e0:	10bfffcc 	andi	r2,r2,65535
811424e4:	d0a0b115 	stw	r2,-32060(gp)
				}
			}
		}
	}
	return result;
811424e8:	e0bffe17 	ldw	r2,-8(fp)
}
811424ec:	e037883a 	mov	sp,fp
811424f0:	dfc00117 	ldw	ra,4(sp)
811424f4:	df000017 	ldw	fp,0(sp)
811424f8:	dec00204 	addi	sp,sp,8
811424fc:	f800283a 	ret

81142500 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
81142500:	defffb04 	addi	sp,sp,-20
81142504:	de00012e 	bgeu	sp,et,8114250c <filename_to_upper_case+0xc>
81142508:	003b68fa 	trap	3
8114250c:	dfc00415 	stw	ra,16(sp)
81142510:	df000315 	stw	fp,12(sp)
81142514:	df000304 	addi	fp,sp,12
81142518:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
8114251c:	e13fff17 	ldw	r4,-4(fp)
81142520:	112235c0 	call	8112235c <strlen>
81142524:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
81142528:	e03ffd15 	stw	zero,-12(fp)
8114252c:	00001e06 	br	811425a8 <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
81142530:	e0bffd17 	ldw	r2,-12(fp)
81142534:	e0ffff17 	ldw	r3,-4(fp)
81142538:	1885883a 	add	r2,r3,r2
8114253c:	10800003 	ldbu	r2,0(r2)
81142540:	10803fcc 	andi	r2,r2,255
81142544:	1080201c 	xori	r2,r2,128
81142548:	10bfe004 	addi	r2,r2,-128
8114254c:	10801850 	cmplti	r2,r2,97
81142550:	1000121e 	bne	r2,zero,8114259c <filename_to_upper_case+0x9c>
81142554:	e0bffd17 	ldw	r2,-12(fp)
81142558:	e0ffff17 	ldw	r3,-4(fp)
8114255c:	1885883a 	add	r2,r3,r2
81142560:	10800003 	ldbu	r2,0(r2)
81142564:	10803fcc 	andi	r2,r2,255
81142568:	1080201c 	xori	r2,r2,128
8114256c:	10bfe004 	addi	r2,r2,-128
81142570:	10801ec8 	cmpgei	r2,r2,123
81142574:	1000091e 	bne	r2,zero,8114259c <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
81142578:	e0bffd17 	ldw	r2,-12(fp)
8114257c:	e0ffff17 	ldw	r3,-4(fp)
81142580:	1885883a 	add	r2,r3,r2
81142584:	e0fffd17 	ldw	r3,-12(fp)
81142588:	e13fff17 	ldw	r4,-4(fp)
8114258c:	20c7883a 	add	r3,r4,r3
81142590:	18c00003 	ldbu	r3,0(r3)
81142594:	18fff804 	addi	r3,r3,-32
81142598:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
8114259c:	e0bffd17 	ldw	r2,-12(fp)
811425a0:	10800044 	addi	r2,r2,1
811425a4:	e0bffd15 	stw	r2,-12(fp)
811425a8:	e0fffd17 	ldw	r3,-12(fp)
811425ac:	e0bffe17 	ldw	r2,-8(fp)
811425b0:	18bfdf16 	blt	r3,r2,81142530 <__reset+0xfb122530>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
811425b4:	0001883a 	nop
811425b8:	e037883a 	mov	sp,fp
811425bc:	dfc00117 	ldw	ra,4(sp)
811425c0:	df000017 	ldw	fp,0(sp)
811425c4:	dec00204 	addi	sp,sp,8
811425c8:	f800283a 	ret

811425cc <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
811425cc:	defff804 	addi	sp,sp,-32
811425d0:	de00012e 	bgeu	sp,et,811425d8 <check_file_name_for_FAT16_compliance+0xc>
811425d4:	003b68fa 	trap	3
811425d8:	dfc00715 	stw	ra,28(sp)
811425dc:	df000615 	stw	fp,24(sp)
811425e0:	df000604 	addi	fp,sp,24
811425e4:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
811425e8:	e13fff17 	ldw	r4,-4(fp)
811425ec:	112235c0 	call	8112235c <strlen>
811425f0:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
811425f4:	00bfffc4 	movi	r2,-1
811425f8:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
811425fc:	00bfffc4 	movi	r2,-1
81142600:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
81142604:	00800044 	movi	r2,1
81142608:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
8114260c:	e03ffa15 	stw	zero,-24(fp)
81142610:	00006d06 	br	811427c8 <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
81142614:	e0bffa17 	ldw	r2,-24(fp)
81142618:	e0ffff17 	ldw	r3,-4(fp)
8114261c:	1885883a 	add	r2,r3,r2
81142620:	10800003 	ldbu	r2,0(r2)
81142624:	10803fcc 	andi	r2,r2,255
81142628:	1080201c 	xori	r2,r2,128
8114262c:	10bfe004 	addi	r2,r2,-128
81142630:	10800820 	cmpeqi	r2,r2,32
81142634:	10003e1e 	bne	r2,zero,81142730 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81142638:	e0bffa17 	ldw	r2,-24(fp)
8114263c:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
81142640:	e0bffb17 	ldw	r2,-20(fp)
81142644:	1880121e 	bne	r3,r2,81142690 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
81142648:	e0bffa17 	ldw	r2,-24(fp)
8114264c:	e0ffff17 	ldw	r3,-4(fp)
81142650:	1885883a 	add	r2,r3,r2
81142654:	10800003 	ldbu	r2,0(r2)
81142658:	10803fcc 	andi	r2,r2,255
8114265c:	1080201c 	xori	r2,r2,128
81142660:	10bfe004 	addi	r2,r2,-128
81142664:	10801720 	cmpeqi	r2,r2,92
81142668:	1000311e 	bne	r2,zero,81142730 <check_file_name_for_FAT16_compliance+0x164>
8114266c:	e0bffa17 	ldw	r2,-24(fp)
81142670:	e0ffff17 	ldw	r3,-4(fp)
81142674:	1885883a 	add	r2,r3,r2
81142678:	10800003 	ldbu	r2,0(r2)
8114267c:	10803fcc 	andi	r2,r2,255
81142680:	1080201c 	xori	r2,r2,128
81142684:	10bfe004 	addi	r2,r2,-128
81142688:	10800be0 	cmpeqi	r2,r2,47
8114268c:	1000281e 	bne	r2,zero,81142730 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
81142690:	e0fffa17 	ldw	r3,-24(fp)
81142694:	e0bffc17 	ldw	r2,-16(fp)
81142698:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8114269c:	10800258 	cmpnei	r2,r2,9
811426a0:	1000091e 	bne	r2,zero,811426c8 <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
811426a4:	e0bffa17 	ldw	r2,-24(fp)
811426a8:	e0ffff17 	ldw	r3,-4(fp)
811426ac:	1885883a 	add	r2,r3,r2
811426b0:	10800003 	ldbu	r2,0(r2)
811426b4:	10803fcc 	andi	r2,r2,255
811426b8:	1080201c 	xori	r2,r2,128
811426bc:	10bfe004 	addi	r2,r2,-128
811426c0:	10800b98 	cmpnei	r2,r2,46
811426c4:	10001a1e 	bne	r2,zero,81142730 <check_file_name_for_FAT16_compliance+0x164>
811426c8:	e0fffb17 	ldw	r3,-20(fp)
811426cc:	e0bffc17 	ldw	r2,-16(fp)
811426d0:	18801926 	beq	r3,r2,81142738 <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
811426d4:	e0fffa17 	ldw	r3,-24(fp)
811426d8:	e0bffc17 	ldw	r2,-16(fp)
811426dc:	1885c83a 	sub	r2,r3,r2
811426e0:	10800110 	cmplti	r2,r2,4
811426e4:	1000141e 	bne	r2,zero,81142738 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
811426e8:	e0bffa17 	ldw	r2,-24(fp)
811426ec:	e0ffff17 	ldw	r3,-4(fp)
811426f0:	1885883a 	add	r2,r3,r2
811426f4:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
811426f8:	10803fcc 	andi	r2,r2,255
811426fc:	1080201c 	xori	r2,r2,128
81142700:	10bfe004 	addi	r2,r2,-128
81142704:	10801720 	cmpeqi	r2,r2,92
81142708:	10000b1e 	bne	r2,zero,81142738 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8114270c:	e0bffa17 	ldw	r2,-24(fp)
81142710:	e0ffff17 	ldw	r3,-4(fp)
81142714:	1885883a 	add	r2,r3,r2
81142718:	10800003 	ldbu	r2,0(r2)
8114271c:	10803fcc 	andi	r2,r2,255
81142720:	1080201c 	xori	r2,r2,128
81142724:	10bfe004 	addi	r2,r2,-128
81142728:	10800be0 	cmpeqi	r2,r2,47
8114272c:	1000021e 	bne	r2,zero,81142738 <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
81142730:	e03ffd15 	stw	zero,-12(fp)
            break;
81142734:	00002706 	br	811427d4 <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
81142738:	e0bffa17 	ldw	r2,-24(fp)
8114273c:	e0ffff17 	ldw	r3,-4(fp)
81142740:	1885883a 	add	r2,r3,r2
81142744:	10800003 	ldbu	r2,0(r2)
81142748:	10803fcc 	andi	r2,r2,255
8114274c:	1080201c 	xori	r2,r2,128
81142750:	10bfe004 	addi	r2,r2,-128
81142754:	10801720 	cmpeqi	r2,r2,92
81142758:	1000091e 	bne	r2,zero,81142780 <check_file_name_for_FAT16_compliance+0x1b4>
8114275c:	e0bffa17 	ldw	r2,-24(fp)
81142760:	e0ffff17 	ldw	r3,-4(fp)
81142764:	1885883a 	add	r2,r3,r2
81142768:	10800003 	ldbu	r2,0(r2)
8114276c:	10803fcc 	andi	r2,r2,255
81142770:	1080201c 	xori	r2,r2,128
81142774:	10bfe004 	addi	r2,r2,-128
81142778:	10800bd8 	cmpnei	r2,r2,47
8114277c:	1000041e 	bne	r2,zero,81142790 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
81142780:	e0bffa17 	ldw	r2,-24(fp)
81142784:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
81142788:	e0bffa17 	ldw	r2,-24(fp)
8114278c:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
81142790:	e0bffa17 	ldw	r2,-24(fp)
81142794:	e0ffff17 	ldw	r3,-4(fp)
81142798:	1885883a 	add	r2,r3,r2
8114279c:	10800003 	ldbu	r2,0(r2)
811427a0:	10803fcc 	andi	r2,r2,255
811427a4:	1080201c 	xori	r2,r2,128
811427a8:	10bfe004 	addi	r2,r2,-128
811427ac:	10800b98 	cmpnei	r2,r2,46
811427b0:	1000021e 	bne	r2,zero,811427bc <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
811427b4:	e0bffa17 	ldw	r2,-24(fp)
811427b8:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
811427bc:	e0bffa17 	ldw	r2,-24(fp)
811427c0:	10800044 	addi	r2,r2,1
811427c4:	e0bffa15 	stw	r2,-24(fp)
811427c8:	e0fffa17 	ldw	r3,-24(fp)
811427cc:	e0bffe17 	ldw	r2,-8(fp)
811427d0:	18bf9016 	blt	r3,r2,81142614 <__reset+0xfb122614>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
811427d4:	e0bffe17 	ldw	r2,-8(fp)
811427d8:	10bfffc4 	addi	r2,r2,-1
811427dc:	e0ffff17 	ldw	r3,-4(fp)
811427e0:	1885883a 	add	r2,r3,r2
811427e4:	10800003 	ldbu	r2,0(r2)
811427e8:	10803fcc 	andi	r2,r2,255
811427ec:	1080201c 	xori	r2,r2,128
811427f0:	10bfe004 	addi	r2,r2,-128
811427f4:	10801720 	cmpeqi	r2,r2,92
811427f8:	10000a1e 	bne	r2,zero,81142824 <check_file_name_for_FAT16_compliance+0x258>
811427fc:	e0bffe17 	ldw	r2,-8(fp)
81142800:	10bfffc4 	addi	r2,r2,-1
81142804:	e0ffff17 	ldw	r3,-4(fp)
81142808:	1885883a 	add	r2,r3,r2
8114280c:	10800003 	ldbu	r2,0(r2)
81142810:	10803fcc 	andi	r2,r2,255
81142814:	1080201c 	xori	r2,r2,128
81142818:	10bfe004 	addi	r2,r2,-128
8114281c:	10800bd8 	cmpnei	r2,r2,47
81142820:	1000011e 	bne	r2,zero,81142828 <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
81142824:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
81142828:	e0bffd17 	ldw	r2,-12(fp)
}
8114282c:	e037883a 	mov	sp,fp
81142830:	dfc00117 	ldw	ra,4(sp)
81142834:	df000017 	ldw	fp,0(sp)
81142838:	dec00204 	addi	sp,sp,8
8114283c:	f800283a 	ret

81142840 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
81142840:	defffb04 	addi	sp,sp,-20
81142844:	de00012e 	bgeu	sp,et,8114284c <get_dir_divider_location+0xc>
81142848:	003b68fa 	trap	3
8114284c:	dfc00415 	stw	ra,16(sp)
81142850:	df000315 	stw	fp,12(sp)
81142854:	df000304 	addi	fp,sp,12
81142858:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
8114285c:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
81142860:	e13fff17 	ldw	r4,-4(fp)
81142864:	112235c0 	call	8112235c <strlen>
81142868:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
8114286c:	e03ffd15 	stw	zero,-12(fp)
81142870:	00001506 	br	811428c8 <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
81142874:	e0bffd17 	ldw	r2,-12(fp)
81142878:	e0ffff17 	ldw	r3,-4(fp)
8114287c:	1885883a 	add	r2,r3,r2
81142880:	10800003 	ldbu	r2,0(r2)
81142884:	10803fcc 	andi	r2,r2,255
81142888:	1080201c 	xori	r2,r2,128
8114288c:	10bfe004 	addi	r2,r2,-128
81142890:	10801720 	cmpeqi	r2,r2,92
81142894:	10000f1e 	bne	r2,zero,811428d4 <get_dir_divider_location+0x94>
81142898:	e0bffd17 	ldw	r2,-12(fp)
8114289c:	e0ffff17 	ldw	r3,-4(fp)
811428a0:	1885883a 	add	r2,r3,r2
811428a4:	10800003 	ldbu	r2,0(r2)
811428a8:	10803fcc 	andi	r2,r2,255
811428ac:	1080201c 	xori	r2,r2,128
811428b0:	10bfe004 	addi	r2,r2,-128
811428b4:	10800be0 	cmpeqi	r2,r2,47
811428b8:	1000061e 	bne	r2,zero,811428d4 <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
811428bc:	e0bffd17 	ldw	r2,-12(fp)
811428c0:	10800044 	addi	r2,r2,1
811428c4:	e0bffd15 	stw	r2,-12(fp)
811428c8:	e0fffd17 	ldw	r3,-12(fp)
811428cc:	e0bffe17 	ldw	r2,-8(fp)
811428d0:	18bfe816 	blt	r3,r2,81142874 <__reset+0xfb122874>
        {
            break;
        }
    }
    
    if (index == length)
811428d4:	e0fffd17 	ldw	r3,-12(fp)
811428d8:	e0bffe17 	ldw	r2,-8(fp)
811428dc:	1880021e 	bne	r3,r2,811428e8 <get_dir_divider_location+0xa8>
    {
        index = -1;
811428e0:	00bfffc4 	movi	r2,-1
811428e4:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
811428e8:	e0bffd17 	ldw	r2,-12(fp)
}
811428ec:	e037883a 	mov	sp,fp
811428f0:	dfc00117 	ldw	ra,4(sp)
811428f4:	df000017 	ldw	fp,0(sp)
811428f8:	dec00204 	addi	sp,sp,8
811428fc:	f800283a 	ret

81142900 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
81142900:	defffa04 	addi	sp,sp,-24
81142904:	de00012e 	bgeu	sp,et,8114290c <match_file_record_to_name_ext+0xc>
81142908:	003b68fa 	trap	3
8114290c:	df000515 	stw	fp,20(sp)
81142910:	df000504 	addi	fp,sp,20
81142914:	e13ffd15 	stw	r4,-12(fp)
81142918:	e17ffe15 	stw	r5,-8(fp)
8114291c:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
81142920:	00800044 	movi	r2,1
81142924:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
81142928:	e03ffc15 	stw	zero,-16(fp)
8114292c:	00004606 	br	81142a48 <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
81142930:	e0fffd17 	ldw	r3,-12(fp)
81142934:	e0bffc17 	ldw	r2,-16(fp)
81142938:	1885883a 	add	r2,r3,r2
8114293c:	10800003 	ldbu	r2,0(r2)
81142940:	10803fcc 	andi	r2,r2,255
81142944:	10801870 	cmpltui	r2,r2,97
81142948:	1000101e 	bne	r2,zero,8114298c <match_file_record_to_name_ext+0x8c>
8114294c:	e0fffd17 	ldw	r3,-12(fp)
81142950:	e0bffc17 	ldw	r2,-16(fp)
81142954:	1885883a 	add	r2,r3,r2
81142958:	10800003 	ldbu	r2,0(r2)
8114295c:	10803fcc 	andi	r2,r2,255
81142960:	10801ee8 	cmpgeui	r2,r2,123
81142964:	1000091e 	bne	r2,zero,8114298c <match_file_record_to_name_ext+0x8c>
81142968:	e0fffd17 	ldw	r3,-12(fp)
8114296c:	e0bffc17 	ldw	r2,-16(fp)
81142970:	1885883a 	add	r2,r3,r2
81142974:	10800003 	ldbu	r2,0(r2)
81142978:	10bff804 	addi	r2,r2,-32
8114297c:	10c03fcc 	andi	r3,r2,255
81142980:	18c0201c 	xori	r3,r3,128
81142984:	18ffe004 	addi	r3,r3,-128
81142988:	00000706 	br	811429a8 <match_file_record_to_name_ext+0xa8>
8114298c:	e0fffd17 	ldw	r3,-12(fp)
81142990:	e0bffc17 	ldw	r2,-16(fp)
81142994:	1885883a 	add	r2,r3,r2
81142998:	10800003 	ldbu	r2,0(r2)
8114299c:	10c03fcc 	andi	r3,r2,255
811429a0:	18c0201c 	xori	r3,r3,128
811429a4:	18ffe004 	addi	r3,r3,-128
811429a8:	e0bffc17 	ldw	r2,-16(fp)
811429ac:	e13ffe17 	ldw	r4,-8(fp)
811429b0:	2085883a 	add	r2,r4,r2
811429b4:	10800003 	ldbu	r2,0(r2)
811429b8:	10803fcc 	andi	r2,r2,255
811429bc:	1080201c 	xori	r2,r2,128
811429c0:	10bfe004 	addi	r2,r2,-128
811429c4:	10801850 	cmplti	r2,r2,97
811429c8:	1000121e 	bne	r2,zero,81142a14 <match_file_record_to_name_ext+0x114>
811429cc:	e0bffc17 	ldw	r2,-16(fp)
811429d0:	e13ffe17 	ldw	r4,-8(fp)
811429d4:	2085883a 	add	r2,r4,r2
811429d8:	10800003 	ldbu	r2,0(r2)
811429dc:	10803fcc 	andi	r2,r2,255
811429e0:	1080201c 	xori	r2,r2,128
811429e4:	10bfe004 	addi	r2,r2,-128
811429e8:	10801ec8 	cmpgei	r2,r2,123
811429ec:	1000091e 	bne	r2,zero,81142a14 <match_file_record_to_name_ext+0x114>
811429f0:	e0bffc17 	ldw	r2,-16(fp)
811429f4:	e13ffe17 	ldw	r4,-8(fp)
811429f8:	2085883a 	add	r2,r4,r2
811429fc:	10800003 	ldbu	r2,0(r2)
81142a00:	10bff804 	addi	r2,r2,-32
81142a04:	10803fcc 	andi	r2,r2,255
81142a08:	1080201c 	xori	r2,r2,128
81142a0c:	10bfe004 	addi	r2,r2,-128
81142a10:	00000706 	br	81142a30 <match_file_record_to_name_ext+0x130>
81142a14:	e0bffc17 	ldw	r2,-16(fp)
81142a18:	e13ffe17 	ldw	r4,-8(fp)
81142a1c:	2085883a 	add	r2,r4,r2
81142a20:	10800003 	ldbu	r2,0(r2)
81142a24:	10803fcc 	andi	r2,r2,255
81142a28:	1080201c 	xori	r2,r2,128
81142a2c:	10bfe004 	addi	r2,r2,-128
81142a30:	18800226 	beq	r3,r2,81142a3c <match_file_record_to_name_ext+0x13c>
        {
            match = false;
81142a34:	e03ffb15 	stw	zero,-20(fp)
			break;
81142a38:	00000606 	br	81142a54 <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
81142a3c:	e0bffc17 	ldw	r2,-16(fp)
81142a40:	10800044 	addi	r2,r2,1
81142a44:	e0bffc15 	stw	r2,-16(fp)
81142a48:	e0bffc17 	ldw	r2,-16(fp)
81142a4c:	10800210 	cmplti	r2,r2,8
81142a50:	103fb71e 	bne	r2,zero,81142930 <__reset+0xfb122930>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
81142a54:	e03ffc15 	stw	zero,-16(fp)
81142a58:	00004a06 	br	81142b84 <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
81142a5c:	e0fffd17 	ldw	r3,-12(fp)
81142a60:	e0bffc17 	ldw	r2,-16(fp)
81142a64:	1885883a 	add	r2,r3,r2
81142a68:	10800204 	addi	r2,r2,8
81142a6c:	10800003 	ldbu	r2,0(r2)
81142a70:	10803fcc 	andi	r2,r2,255
81142a74:	10801870 	cmpltui	r2,r2,97
81142a78:	1000121e 	bne	r2,zero,81142ac4 <match_file_record_to_name_ext+0x1c4>
81142a7c:	e0fffd17 	ldw	r3,-12(fp)
81142a80:	e0bffc17 	ldw	r2,-16(fp)
81142a84:	1885883a 	add	r2,r3,r2
81142a88:	10800204 	addi	r2,r2,8
81142a8c:	10800003 	ldbu	r2,0(r2)
81142a90:	10803fcc 	andi	r2,r2,255
81142a94:	10801ee8 	cmpgeui	r2,r2,123
81142a98:	10000a1e 	bne	r2,zero,81142ac4 <match_file_record_to_name_ext+0x1c4>
81142a9c:	e0fffd17 	ldw	r3,-12(fp)
81142aa0:	e0bffc17 	ldw	r2,-16(fp)
81142aa4:	1885883a 	add	r2,r3,r2
81142aa8:	10800204 	addi	r2,r2,8
81142aac:	10800003 	ldbu	r2,0(r2)
81142ab0:	10bff804 	addi	r2,r2,-32
81142ab4:	10c03fcc 	andi	r3,r2,255
81142ab8:	18c0201c 	xori	r3,r3,128
81142abc:	18ffe004 	addi	r3,r3,-128
81142ac0:	00000806 	br	81142ae4 <match_file_record_to_name_ext+0x1e4>
81142ac4:	e0fffd17 	ldw	r3,-12(fp)
81142ac8:	e0bffc17 	ldw	r2,-16(fp)
81142acc:	1885883a 	add	r2,r3,r2
81142ad0:	10800204 	addi	r2,r2,8
81142ad4:	10800003 	ldbu	r2,0(r2)
81142ad8:	10c03fcc 	andi	r3,r2,255
81142adc:	18c0201c 	xori	r3,r3,128
81142ae0:	18ffe004 	addi	r3,r3,-128
81142ae4:	e0bffc17 	ldw	r2,-16(fp)
81142ae8:	e13fff17 	ldw	r4,-4(fp)
81142aec:	2085883a 	add	r2,r4,r2
81142af0:	10800003 	ldbu	r2,0(r2)
81142af4:	10803fcc 	andi	r2,r2,255
81142af8:	1080201c 	xori	r2,r2,128
81142afc:	10bfe004 	addi	r2,r2,-128
81142b00:	10801850 	cmplti	r2,r2,97
81142b04:	1000121e 	bne	r2,zero,81142b50 <match_file_record_to_name_ext+0x250>
81142b08:	e0bffc17 	ldw	r2,-16(fp)
81142b0c:	e13fff17 	ldw	r4,-4(fp)
81142b10:	2085883a 	add	r2,r4,r2
81142b14:	10800003 	ldbu	r2,0(r2)
81142b18:	10803fcc 	andi	r2,r2,255
81142b1c:	1080201c 	xori	r2,r2,128
81142b20:	10bfe004 	addi	r2,r2,-128
81142b24:	10801ec8 	cmpgei	r2,r2,123
81142b28:	1000091e 	bne	r2,zero,81142b50 <match_file_record_to_name_ext+0x250>
81142b2c:	e0bffc17 	ldw	r2,-16(fp)
81142b30:	e13fff17 	ldw	r4,-4(fp)
81142b34:	2085883a 	add	r2,r4,r2
81142b38:	10800003 	ldbu	r2,0(r2)
81142b3c:	10bff804 	addi	r2,r2,-32
81142b40:	10803fcc 	andi	r2,r2,255
81142b44:	1080201c 	xori	r2,r2,128
81142b48:	10bfe004 	addi	r2,r2,-128
81142b4c:	00000706 	br	81142b6c <match_file_record_to_name_ext+0x26c>
81142b50:	e0bffc17 	ldw	r2,-16(fp)
81142b54:	e13fff17 	ldw	r4,-4(fp)
81142b58:	2085883a 	add	r2,r4,r2
81142b5c:	10800003 	ldbu	r2,0(r2)
81142b60:	10803fcc 	andi	r2,r2,255
81142b64:	1080201c 	xori	r2,r2,128
81142b68:	10bfe004 	addi	r2,r2,-128
81142b6c:	18800226 	beq	r3,r2,81142b78 <match_file_record_to_name_ext+0x278>
        {
            match = false;
81142b70:	e03ffb15 	stw	zero,-20(fp)
			break;
81142b74:	00000606 	br	81142b90 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
81142b78:	e0bffc17 	ldw	r2,-16(fp)
81142b7c:	10800044 	addi	r2,r2,1
81142b80:	e0bffc15 	stw	r2,-16(fp)
81142b84:	e0bffc17 	ldw	r2,-16(fp)
81142b88:	108000d0 	cmplti	r2,r2,3
81142b8c:	103fb31e 	bne	r2,zero,81142a5c <__reset+0xfb122a5c>
        {
            match = false;
			break;
        }
    }
	return match;
81142b90:	e0bffb17 	ldw	r2,-20(fp)
}
81142b94:	e037883a 	mov	sp,fp
81142b98:	df000017 	ldw	fp,0(sp)
81142b9c:	dec00104 	addi	sp,sp,4
81142ba0:	f800283a 	ret

81142ba4 <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
81142ba4:	deffe704 	addi	sp,sp,-100
81142ba8:	de00012e 	bgeu	sp,et,81142bb0 <get_home_directory_cluster_for_file+0xc>
81142bac:	003b68fa 	trap	3
81142bb0:	dfc01815 	stw	ra,96(sp)
81142bb4:	df001715 	stw	fp,92(sp)
81142bb8:	df001704 	addi	fp,sp,92
81142bbc:	e13ffd15 	stw	r4,-12(fp)
81142bc0:	e17ffe15 	stw	r5,-8(fp)
81142bc4:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
81142bc8:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
81142bcc:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
81142bd0:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
81142bd4:	e13ffd17 	ldw	r4,-12(fp)
81142bd8:	11428400 	call	81142840 <get_dir_divider_location>
81142bdc:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
81142be0:	00012f06 	br	811430a0 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81142be4:	00800804 	movi	r2,32
81142be8:	e0bff905 	stb	r2,-28(fp)
81142bec:	00800804 	movi	r2,32
81142bf0:	e0bff945 	stb	r2,-27(fp)
81142bf4:	00800804 	movi	r2,32
81142bf8:	e0bff985 	stb	r2,-26(fp)
81142bfc:	00800804 	movi	r2,32
81142c00:	e0bff9c5 	stb	r2,-25(fp)
81142c04:	00800804 	movi	r2,32
81142c08:	e0bffa05 	stb	r2,-24(fp)
81142c0c:	00800804 	movi	r2,32
81142c10:	e0bffa45 	stb	r2,-23(fp)
81142c14:	00800804 	movi	r2,32
81142c18:	e0bffa85 	stb	r2,-22(fp)
81142c1c:	00800804 	movi	r2,32
81142c20:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
81142c24:	00800804 	movi	r2,32
81142c28:	e0bffb05 	stb	r2,-20(fp)
81142c2c:	00800804 	movi	r2,32
81142c30:	e0bffb45 	stb	r2,-19(fp)
81142c34:	00800804 	movi	r2,32
81142c38:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
81142c3c:	00bfffc4 	movi	r2,-1
81142c40:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
81142c44:	e0bfea17 	ldw	r2,-88(fp)
81142c48:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81142c4c:	e03fec15 	stw	zero,-80(fp)
81142c50:	00002d06 	br	81142d08 <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
81142c54:	e0ffec17 	ldw	r3,-80(fp)
81142c58:	e0bfed17 	ldw	r2,-76(fp)
81142c5c:	1885883a 	add	r2,r3,r2
81142c60:	1007883a 	mov	r3,r2
81142c64:	e0bffd17 	ldw	r2,-12(fp)
81142c68:	10c5883a 	add	r2,r2,r3
81142c6c:	10800003 	ldbu	r2,0(r2)
81142c70:	10803fcc 	andi	r2,r2,255
81142c74:	1080201c 	xori	r2,r2,128
81142c78:	10bfe004 	addi	r2,r2,-128
81142c7c:	10800b98 	cmpnei	r2,r2,46
81142c80:	1000031e 	bne	r2,zero,81142c90 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
81142c84:	e0bfec17 	ldw	r2,-80(fp)
81142c88:	e0bfee15 	stw	r2,-72(fp)
81142c8c:	00001b06 	br	81142cfc <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
81142c90:	e0bfee17 	ldw	r2,-72(fp)
81142c94:	10000c0e 	bge	r2,zero,81142cc8 <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
81142c98:	e0ffec17 	ldw	r3,-80(fp)
81142c9c:	e0bfed17 	ldw	r2,-76(fp)
81142ca0:	1885883a 	add	r2,r3,r2
81142ca4:	1007883a 	mov	r3,r2
81142ca8:	e0bffd17 	ldw	r2,-12(fp)
81142cac:	10c5883a 	add	r2,r2,r3
81142cb0:	10c00003 	ldbu	r3,0(r2)
81142cb4:	e13ff904 	addi	r4,fp,-28
81142cb8:	e0bfec17 	ldw	r2,-80(fp)
81142cbc:	2085883a 	add	r2,r4,r2
81142cc0:	10c00005 	stb	r3,0(r2)
81142cc4:	00000d06 	br	81142cfc <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
81142cc8:	e0ffec17 	ldw	r3,-80(fp)
81142ccc:	e0bfee17 	ldw	r2,-72(fp)
81142cd0:	1885c83a 	sub	r2,r3,r2
81142cd4:	e13fec17 	ldw	r4,-80(fp)
81142cd8:	e0ffed17 	ldw	r3,-76(fp)
81142cdc:	20c7883a 	add	r3,r4,r3
81142ce0:	1809883a 	mov	r4,r3
81142ce4:	e0fffd17 	ldw	r3,-12(fp)
81142ce8:	1907883a 	add	r3,r3,r4
81142cec:	18c00003 	ldbu	r3,0(r3)
81142cf0:	e13ffb04 	addi	r4,fp,-20
81142cf4:	2085883a 	add	r2,r4,r2
81142cf8:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81142cfc:	e0bfec17 	ldw	r2,-80(fp)
81142d00:	10800044 	addi	r2,r2,1
81142d04:	e0bfec15 	stw	r2,-80(fp)
81142d08:	e0ffec17 	ldw	r3,-80(fp)
81142d0c:	e0bfeb17 	ldw	r2,-84(fp)
81142d10:	18bfd016 	blt	r3,r2,81142c54 <__reset+0xfb122c54>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
81142d14:	e0bfea17 	ldw	r2,-88(fp)
81142d18:	10005c1e 	bne	r2,zero,81142e8c <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81142d1c:	00a045f4 	movhi	r2,33047
81142d20:	10af9e04 	addi	r2,r2,-16776
81142d24:	1080050b 	ldhu	r2,20(r2)
81142d28:	10bfffcc 	andi	r2,r2,65535
81142d2c:	1006917a 	slli	r3,r2,5
81142d30:	00a045f4 	movhi	r2,33047
81142d34:	10af9e04 	addi	r2,r2,-16776
81142d38:	1080030b 	ldhu	r2,12(r2)
81142d3c:	10bfffcc 	andi	r2,r2,65535
81142d40:	1885283a 	div	r2,r3,r2
81142d44:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81142d48:	e03ff015 	stw	zero,-64(fp)
81142d4c:	00003b06 	br	81142e3c <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
81142d50:	00a045f4 	movhi	r2,33047
81142d54:	10af9e04 	addi	r2,r2,-16776
81142d58:	10c01317 	ldw	r3,76(r2)
81142d5c:	e0bff017 	ldw	r2,-64(fp)
81142d60:	1885883a 	add	r2,r3,r2
81142d64:	1007883a 	mov	r3,r2
81142d68:	d0a0b017 	ldw	r2,-32064(gp)
81142d6c:	100b883a 	mov	r5,r2
81142d70:	1809883a 	mov	r4,r3
81142d74:	114143c0 	call	8114143c <Read_Sector_Data>
81142d78:	10003426 	beq	r2,zero,81142e4c <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81142d7c:	e03ff115 	stw	zero,-60(fp)
81142d80:	00002506 	br	81142e18 <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81142d84:	e0bff117 	ldw	r2,-60(fp)
81142d88:	1004917a 	slli	r2,r2,5
81142d8c:	e0fff017 	ldw	r3,-64(fp)
81142d90:	180f883a 	mov	r7,r3
81142d94:	000d883a 	mov	r6,zero
81142d98:	e17fff17 	ldw	r5,-4(fp)
81142d9c:	1009883a 	mov	r4,r2
81142da0:	114186c0 	call	8114186c <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81142da4:	e0bfff17 	ldw	r2,-4(fp)
81142da8:	10800003 	ldbu	r2,0(r2)
81142dac:	10803fcc 	andi	r2,r2,255
81142db0:	10803960 	cmpeqi	r2,r2,229
81142db4:	1000151e 	bne	r2,zero,81142e0c <get_home_directory_cluster_for_file+0x268>
81142db8:	e0bfff17 	ldw	r2,-4(fp)
81142dbc:	10800003 	ldbu	r2,0(r2)
81142dc0:	10803fcc 	andi	r2,r2,255
81142dc4:	10001126 	beq	r2,zero,81142e0c <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81142dc8:	e0fffb04 	addi	r3,fp,-20
81142dcc:	e0bff904 	addi	r2,fp,-28
81142dd0:	180d883a 	mov	r6,r3
81142dd4:	100b883a 	mov	r5,r2
81142dd8:	e13fff17 	ldw	r4,-4(fp)
81142ddc:	11429000 	call	81142900 <match_file_record_to_name_ext>
81142de0:	e0bff815 	stw	r2,-32(fp)
                            if (match)
81142de4:	e0bff817 	ldw	r2,-32(fp)
81142de8:	10000826 	beq	r2,zero,81142e0c <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
81142dec:	e0bfff17 	ldw	r2,-4(fp)
81142df0:	1080058b 	ldhu	r2,22(r2)
81142df4:	10bfffcc 	andi	r2,r2,65535
81142df8:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
81142dfc:	e0bfff17 	ldw	r2,-4(fp)
81142e00:	00c00044 	movi	r3,1
81142e04:	10c00a15 	stw	r3,40(r2)
                                break;
81142e08:	00000606 	br	81142e24 <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81142e0c:	e0bff117 	ldw	r2,-60(fp)
81142e10:	10800044 	addi	r2,r2,1
81142e14:	e0bff115 	stw	r2,-60(fp)
81142e18:	e0bff117 	ldw	r2,-60(fp)
81142e1c:	10800410 	cmplti	r2,r2,16
81142e20:	103fd81e 	bne	r2,zero,81142d84 <__reset+0xfb122d84>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
81142e24:	e0ffef17 	ldw	r3,-68(fp)
81142e28:	e0bfea17 	ldw	r2,-88(fp)
81142e2c:	1880091e 	bne	r3,r2,81142e54 <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81142e30:	e0bff017 	ldw	r2,-64(fp)
81142e34:	10800044 	addi	r2,r2,1
81142e38:	e0bff015 	stw	r2,-64(fp)
81142e3c:	e0fff017 	ldw	r3,-64(fp)
81142e40:	e0bff717 	ldw	r2,-36(fp)
81142e44:	18bfc216 	blt	r3,r2,81142d50 <__reset+0xfb122d50>
81142e48:	00000306 	br	81142e58 <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
81142e4c:	0001883a 	nop
81142e50:	00000106 	br	81142e58 <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
81142e54:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
81142e58:	e0ffef17 	ldw	r3,-68(fp)
81142e5c:	e0bfea17 	ldw	r2,-88(fp)
81142e60:	18800826 	beq	r3,r2,81142e84 <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81142e64:	e0bfef17 	ldw	r2,-68(fp)
81142e68:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81142e6c:	e0ffed17 	ldw	r3,-76(fp)
81142e70:	e0bfeb17 	ldw	r2,-84(fp)
81142e74:	1885883a 	add	r2,r3,r2
81142e78:	10800044 	addi	r2,r2,1
81142e7c:	e0bfed15 	stw	r2,-76(fp)
81142e80:	00007d06 	br	81143078 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81142e84:	0005883a 	mov	r2,zero
81142e88:	00009106 	br	811430d0 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
81142e8c:	e0bfea17 	ldw	r2,-88(fp)
81142e90:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81142e94:	e0bff417 	ldw	r2,-48(fp)
81142e98:	10ffff84 	addi	r3,r2,-2
81142e9c:	00a045f4 	movhi	r2,33047
81142ea0:	10af9e04 	addi	r2,r2,-16776
81142ea4:	10800383 	ldbu	r2,14(r2)
81142ea8:	10803fcc 	andi	r2,r2,255
81142eac:	1885383a 	mul	r2,r3,r2
81142eb0:	1007883a 	mov	r3,r2
81142eb4:	00a045f4 	movhi	r2,33047
81142eb8:	10af9e04 	addi	r2,r2,-16776
81142ebc:	10801417 	ldw	r2,80(r2)
81142ec0:	1885883a 	add	r2,r3,r2
81142ec4:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81142ec8:	e03ff215 	stw	zero,-56(fp)
81142ecc:	00003606 	br	81142fa8 <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81142ed0:	e0fff217 	ldw	r3,-56(fp)
81142ed4:	e0bff517 	ldw	r2,-44(fp)
81142ed8:	1885883a 	add	r2,r3,r2
81142edc:	d0e0b017 	ldw	r3,-32064(gp)
81142ee0:	180b883a 	mov	r5,r3
81142ee4:	1009883a 	mov	r4,r2
81142ee8:	114143c0 	call	8114143c <Read_Sector_Data>
81142eec:	10003526 	beq	r2,zero,81142fc4 <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81142ef0:	e03ff315 	stw	zero,-52(fp)
81142ef4:	00002306 	br	81142f84 <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81142ef8:	e0bff317 	ldw	r2,-52(fp)
81142efc:	1004917a 	slli	r2,r2,5
81142f00:	e0fff417 	ldw	r3,-48(fp)
81142f04:	e13ff217 	ldw	r4,-56(fp)
81142f08:	200f883a 	mov	r7,r4
81142f0c:	180d883a 	mov	r6,r3
81142f10:	e17fff17 	ldw	r5,-4(fp)
81142f14:	1009883a 	mov	r4,r2
81142f18:	114186c0 	call	8114186c <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81142f1c:	e0bfff17 	ldw	r2,-4(fp)
81142f20:	10800003 	ldbu	r2,0(r2)
81142f24:	10803fcc 	andi	r2,r2,255
81142f28:	10803960 	cmpeqi	r2,r2,229
81142f2c:	1000121e 	bne	r2,zero,81142f78 <get_home_directory_cluster_for_file+0x3d4>
81142f30:	e0bfff17 	ldw	r2,-4(fp)
81142f34:	10800003 	ldbu	r2,0(r2)
81142f38:	10803fcc 	andi	r2,r2,255
81142f3c:	10000e26 	beq	r2,zero,81142f78 <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
81142f40:	e0fffb04 	addi	r3,fp,-20
81142f44:	e0bff904 	addi	r2,fp,-28
81142f48:	180d883a 	mov	r6,r3
81142f4c:	100b883a 	mov	r5,r2
81142f50:	e13fff17 	ldw	r4,-4(fp)
81142f54:	11429000 	call	81142900 <match_file_record_to_name_ext>
81142f58:	e0bff615 	stw	r2,-40(fp)
                                if (match)
81142f5c:	e0bff617 	ldw	r2,-40(fp)
81142f60:	10000526 	beq	r2,zero,81142f78 <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
81142f64:	e0bfff17 	ldw	r2,-4(fp)
81142f68:	1080058b 	ldhu	r2,22(r2)
81142f6c:	10bfffcc 	andi	r2,r2,65535
81142f70:	e0bfef15 	stw	r2,-68(fp)
                                    break;
81142f74:	00000606 	br	81142f90 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81142f78:	e0bff317 	ldw	r2,-52(fp)
81142f7c:	10800044 	addi	r2,r2,1
81142f80:	e0bff315 	stw	r2,-52(fp)
81142f84:	e0bff317 	ldw	r2,-52(fp)
81142f88:	10800410 	cmplti	r2,r2,16
81142f8c:	103fda1e 	bne	r2,zero,81142ef8 <__reset+0xfb122ef8>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
81142f90:	e0ffef17 	ldw	r3,-68(fp)
81142f94:	e0bfea17 	ldw	r2,-88(fp)
81142f98:	18800c1e 	bne	r3,r2,81142fcc <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81142f9c:	e0bff217 	ldw	r2,-56(fp)
81142fa0:	10800044 	addi	r2,r2,1
81142fa4:	e0bff215 	stw	r2,-56(fp)
81142fa8:	00a045f4 	movhi	r2,33047
81142fac:	10af9e04 	addi	r2,r2,-16776
81142fb0:	10800383 	ldbu	r2,14(r2)
81142fb4:	10803fcc 	andi	r2,r2,255
81142fb8:	e0fff217 	ldw	r3,-56(fp)
81142fbc:	18bfc416 	blt	r3,r2,81142ed0 <__reset+0xfb122ed0>
81142fc0:	00000306 	br	81142fd0 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
81142fc4:	0001883a 	nop
81142fc8:	00000106 	br	81142fd0 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
81142fcc:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
81142fd0:	e0ffef17 	ldw	r3,-68(fp)
81142fd4:	e0bfea17 	ldw	r2,-88(fp)
81142fd8:	1880141e 	bne	r3,r2,8114302c <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
81142fdc:	e0bfef17 	ldw	r2,-68(fp)
81142fe0:	e0fffc04 	addi	r3,fp,-16
81142fe4:	180b883a 	mov	r5,r3
81142fe8:	1009883a 	mov	r4,r2
81142fec:	114151c0 	call	8114151c <get_cluster_flag>
81142ff0:	10000c26 	beq	r2,zero,81143024 <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81142ff4:	e0bffc0b 	ldhu	r2,-16(fp)
81142ff8:	10bfffcc 	andi	r2,r2,65535
81142ffc:	10fffe0c 	andi	r3,r2,65528
81143000:	00bffe14 	movui	r2,65528
81143004:	1880021e 	bne	r3,r2,81143010 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
81143008:	0005883a 	mov	r2,zero
8114300c:	00003006 	br	811430d0 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
81143010:	e0bffc0b 	ldhu	r2,-16(fp)
81143014:	10bfffcc 	andi	r2,r2,65535
81143018:	10bffe0c 	andi	r2,r2,65528
8114301c:	e0bfef15 	stw	r2,-68(fp)
81143020:	00000206 	br	8114302c <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
81143024:	0005883a 	mov	r2,zero
81143028:	00002906 	br	811430d0 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
8114302c:	e0bff417 	ldw	r2,-48(fp)
81143030:	00fffdd4 	movui	r3,65527
81143034:	18800316 	blt	r3,r2,81143044 <get_home_directory_cluster_for_file+0x4a0>
81143038:	e0ffef17 	ldw	r3,-68(fp)
8114303c:	e0bfea17 	ldw	r2,-88(fp)
81143040:	18bf9426 	beq	r3,r2,81142e94 <__reset+0xfb122e94>
            if (new_cluster != home_dir_cluster)
81143044:	e0ffef17 	ldw	r3,-68(fp)
81143048:	e0bfea17 	ldw	r2,-88(fp)
8114304c:	18800826 	beq	r3,r2,81143070 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81143050:	e0bfef17 	ldw	r2,-68(fp)
81143054:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81143058:	e0ffed17 	ldw	r3,-76(fp)
8114305c:	e0bfeb17 	ldw	r2,-84(fp)
81143060:	1885883a 	add	r2,r3,r2
81143064:	10800044 	addi	r2,r2,1
81143068:	e0bfed15 	stw	r2,-76(fp)
8114306c:	00000206 	br	81143078 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81143070:	0005883a 	mov	r2,zero
81143074:	00001606 	br	811430d0 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
81143078:	e0bfed17 	ldw	r2,-76(fp)
8114307c:	e0fffd17 	ldw	r3,-12(fp)
81143080:	1885883a 	add	r2,r3,r2
81143084:	1009883a 	mov	r4,r2
81143088:	11428400 	call	81142840 <get_dir_divider_location>
8114308c:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
81143090:	e0bfeb17 	ldw	r2,-84(fp)
81143094:	1000020e 	bge	r2,zero,811430a0 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
81143098:	00800044 	movi	r2,1
8114309c:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
811430a0:	e0bfeb17 	ldw	r2,-84(fp)
811430a4:	00becf16 	blt	zero,r2,81142be4 <__reset+0xfb122be4>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
811430a8:	e0bffe17 	ldw	r2,-8(fp)
811430ac:	e0ffea17 	ldw	r3,-88(fp)
811430b0:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
811430b4:	e0bfea17 	ldw	r2,-88(fp)
811430b8:	1000041e 	bne	r2,zero,811430cc <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
811430bc:	e0bfff17 	ldw	r2,-4(fp)
811430c0:	10000a15 	stw	zero,40(r2)
		result = true;
811430c4:	00800044 	movi	r2,1
811430c8:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
811430cc:	e0bfe917 	ldw	r2,-92(fp)
}
811430d0:	e037883a 	mov	sp,fp
811430d4:	dfc00117 	ldw	ra,4(sp)
811430d8:	df000017 	ldw	fp,0(sp)
811430dc:	dec00204 	addi	sp,sp,8
811430e0:	f800283a 	ret

811430e4 <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
811430e4:	deffe804 	addi	sp,sp,-96
811430e8:	de00012e 	bgeu	sp,et,811430f0 <find_file_in_directory+0xc>
811430ec:	003b68fa 	trap	3
811430f0:	dfc01715 	stw	ra,92(sp)
811430f4:	df001615 	stw	fp,88(sp)
811430f8:	df001604 	addi	fp,sp,88
811430fc:	e13ffd15 	stw	r4,-12(fp)
81143100:	e17ffe15 	stw	r5,-8(fp)
81143104:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
81143108:	e13ffe17 	ldw	r4,-8(fp)
8114310c:	11428400 	call	81142840 <get_dir_divider_location>
81143110:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
81143114:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81143118:	00800804 	movi	r2,32
8114311c:	e0bff905 	stb	r2,-28(fp)
81143120:	00800804 	movi	r2,32
81143124:	e0bff945 	stb	r2,-27(fp)
81143128:	00800804 	movi	r2,32
8114312c:	e0bff985 	stb	r2,-26(fp)
81143130:	00800804 	movi	r2,32
81143134:	e0bff9c5 	stb	r2,-25(fp)
81143138:	00800804 	movi	r2,32
8114313c:	e0bffa05 	stb	r2,-24(fp)
81143140:	00800804 	movi	r2,32
81143144:	e0bffa45 	stb	r2,-23(fp)
81143148:	00800804 	movi	r2,32
8114314c:	e0bffa85 	stb	r2,-22(fp)
81143150:	00800804 	movi	r2,32
81143154:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
81143158:	00800804 	movi	r2,32
8114315c:	e0bffb05 	stb	r2,-20(fp)
81143160:	00800804 	movi	r2,32
81143164:	e0bffb45 	stb	r2,-19(fp)
81143168:	00800804 	movi	r2,32
8114316c:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
81143170:	00bfffc4 	movi	r2,-1
81143174:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
81143178:	e0bffd17 	ldw	r2,-12(fp)
8114317c:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
81143180:	e13ffe17 	ldw	r4,-8(fp)
81143184:	112235c0 	call	8112235c <strlen>
81143188:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
8114318c:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
81143190:	00000b06 	br	811431c0 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
81143194:	e0ffeb17 	ldw	r3,-84(fp)
81143198:	e0bfea17 	ldw	r2,-88(fp)
8114319c:	1885883a 	add	r2,r3,r2
811431a0:	10800044 	addi	r2,r2,1
811431a4:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
811431a8:	e0bfeb17 	ldw	r2,-84(fp)
811431ac:	e0fffe17 	ldw	r3,-8(fp)
811431b0:	1885883a 	add	r2,r3,r2
811431b4:	1009883a 	mov	r4,r2
811431b8:	11428400 	call	81142840 <get_dir_divider_location>
811431bc:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
811431c0:	e0bfea17 	ldw	r2,-88(fp)
811431c4:	00bff316 	blt	zero,r2,81143194 <__reset+0xfb123194>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
811431c8:	e0bfeb17 	ldw	r2,-84(fp)
811431cc:	e0bfee15 	stw	r2,-72(fp)
811431d0:	00002706 	br	81143270 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
811431d4:	e0bfee17 	ldw	r2,-72(fp)
811431d8:	e0fffe17 	ldw	r3,-8(fp)
811431dc:	1885883a 	add	r2,r3,r2
811431e0:	10800003 	ldbu	r2,0(r2)
811431e4:	10803fcc 	andi	r2,r2,255
811431e8:	1080201c 	xori	r2,r2,128
811431ec:	10bfe004 	addi	r2,r2,-128
811431f0:	10800b98 	cmpnei	r2,r2,46
811431f4:	1000031e 	bne	r2,zero,81143204 <find_file_in_directory+0x120>
        {
            ext_index = index;
811431f8:	e0bfee17 	ldw	r2,-72(fp)
811431fc:	e0bfec15 	stw	r2,-80(fp)
81143200:	00001806 	br	81143264 <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
81143204:	e0bfec17 	ldw	r2,-80(fp)
81143208:	10000b0e 	bge	r2,zero,81143238 <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
8114320c:	e0ffee17 	ldw	r3,-72(fp)
81143210:	e0bfeb17 	ldw	r2,-84(fp)
81143214:	1885c83a 	sub	r2,r3,r2
81143218:	e0ffee17 	ldw	r3,-72(fp)
8114321c:	e13ffe17 	ldw	r4,-8(fp)
81143220:	20c7883a 	add	r3,r4,r3
81143224:	18c00003 	ldbu	r3,0(r3)
81143228:	e13ff904 	addi	r4,fp,-28
8114322c:	2085883a 	add	r2,r4,r2
81143230:	10c00005 	stb	r3,0(r2)
81143234:	00000b06 	br	81143264 <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
81143238:	e0ffee17 	ldw	r3,-72(fp)
8114323c:	e0bfec17 	ldw	r2,-80(fp)
81143240:	1885c83a 	sub	r2,r3,r2
81143244:	10bfffc4 	addi	r2,r2,-1
81143248:	e0ffee17 	ldw	r3,-72(fp)
8114324c:	e13ffe17 	ldw	r4,-8(fp)
81143250:	20c7883a 	add	r3,r4,r3
81143254:	18c00003 	ldbu	r3,0(r3)
81143258:	e13ffb04 	addi	r4,fp,-20
8114325c:	2085883a 	add	r2,r4,r2
81143260:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
81143264:	e0bfee17 	ldw	r2,-72(fp)
81143268:	10800044 	addi	r2,r2,1
8114326c:	e0bfee15 	stw	r2,-72(fp)
81143270:	e0ffee17 	ldw	r3,-72(fp)
81143274:	e0bff417 	ldw	r2,-48(fp)
81143278:	18bfd616 	blt	r3,r2,811431d4 <__reset+0xfb1231d4>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
8114327c:	e0bffd17 	ldw	r2,-12(fp)
81143280:	1000461e 	bne	r2,zero,8114339c <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81143284:	00a045f4 	movhi	r2,33047
81143288:	10af9e04 	addi	r2,r2,-16776
8114328c:	1080050b 	ldhu	r2,20(r2)
81143290:	10bfffcc 	andi	r2,r2,65535
81143294:	1006917a 	slli	r3,r2,5
81143298:	00a045f4 	movhi	r2,33047
8114329c:	10af9e04 	addi	r2,r2,-16776
811432a0:	1080030b 	ldhu	r2,12(r2)
811432a4:	10bfffcc 	andi	r2,r2,65535
811432a8:	1885283a 	div	r2,r3,r2
811432ac:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811432b0:	e03ff015 	stw	zero,-64(fp)
811432b4:	00003506 	br	8114338c <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
811432b8:	00a045f4 	movhi	r2,33047
811432bc:	10af9e04 	addi	r2,r2,-16776
811432c0:	10c01317 	ldw	r3,76(r2)
811432c4:	e0bff017 	ldw	r2,-64(fp)
811432c8:	1885883a 	add	r2,r3,r2
811432cc:	1007883a 	mov	r3,r2
811432d0:	d0a0b017 	ldw	r2,-32064(gp)
811432d4:	100b883a 	mov	r5,r2
811432d8:	1809883a 	mov	r4,r3
811432dc:	114143c0 	call	8114143c <Read_Sector_Data>
811432e0:	10009626 	beq	r2,zero,8114353c <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
811432e4:	e03ff115 	stw	zero,-60(fp)
811432e8:	00002006 	br	8114336c <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
811432ec:	e0bff117 	ldw	r2,-60(fp)
811432f0:	1004917a 	slli	r2,r2,5
811432f4:	e0fff017 	ldw	r3,-64(fp)
811432f8:	180f883a 	mov	r7,r3
811432fc:	000d883a 	mov	r6,zero
81143300:	e17fff17 	ldw	r5,-4(fp)
81143304:	1009883a 	mov	r4,r2
81143308:	114186c0 	call	8114186c <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8114330c:	e0bfff17 	ldw	r2,-4(fp)
81143310:	10800003 	ldbu	r2,0(r2)
81143314:	10803fcc 	andi	r2,r2,255
81143318:	10803960 	cmpeqi	r2,r2,229
8114331c:	1000101e 	bne	r2,zero,81143360 <find_file_in_directory+0x27c>
81143320:	e0bfff17 	ldw	r2,-4(fp)
81143324:	10800003 	ldbu	r2,0(r2)
81143328:	10803fcc 	andi	r2,r2,255
8114332c:	10000c26 	beq	r2,zero,81143360 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
81143330:	e0fffb04 	addi	r3,fp,-20
81143334:	e0bff904 	addi	r2,fp,-28
81143338:	180d883a 	mov	r6,r3
8114333c:	100b883a 	mov	r5,r2
81143340:	e13fff17 	ldw	r4,-4(fp)
81143344:	11429000 	call	81142900 <match_file_record_to_name_ext>
81143348:	e0bff815 	stw	r2,-32(fp)

                        if (match)
8114334c:	e0bff817 	ldw	r2,-32(fp)
81143350:	10000326 	beq	r2,zero,81143360 <find_file_in_directory+0x27c>
                        {
                            result = true;
81143354:	00800044 	movi	r2,1
81143358:	e0bfef15 	stw	r2,-68(fp)
                            break;
8114335c:	00000606 	br	81143378 <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81143360:	e0bff117 	ldw	r2,-60(fp)
81143364:	10800044 	addi	r2,r2,1
81143368:	e0bff115 	stw	r2,-60(fp)
8114336c:	e0bff117 	ldw	r2,-60(fp)
81143370:	10800410 	cmplti	r2,r2,16
81143374:	103fdd1e 	bne	r2,zero,811432ec <__reset+0xfb1232ec>
            }
            else
            {
                break;
            }
            if (result)
81143378:	e0bfef17 	ldw	r2,-68(fp)
8114337c:	1000711e 	bne	r2,zero,81143544 <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81143380:	e0bff017 	ldw	r2,-64(fp)
81143384:	10800044 	addi	r2,r2,1
81143388:	e0bff015 	stw	r2,-64(fp)
8114338c:	e0fff017 	ldw	r3,-64(fp)
81143390:	e0bff717 	ldw	r2,-36(fp)
81143394:	18bfc816 	blt	r3,r2,811432b8 <__reset+0xfb1232b8>
81143398:	00006b06 	br	81143548 <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8114339c:	e0bfed17 	ldw	r2,-76(fp)
811433a0:	10ffff84 	addi	r3,r2,-2
811433a4:	00a045f4 	movhi	r2,33047
811433a8:	10af9e04 	addi	r2,r2,-16776
811433ac:	10800383 	ldbu	r2,14(r2)
811433b0:	10803fcc 	andi	r2,r2,255
811433b4:	1885383a 	mul	r2,r3,r2
811433b8:	1007883a 	mov	r3,r2
811433bc:	00a045f4 	movhi	r2,33047
811433c0:	10af9e04 	addi	r2,r2,-16776
811433c4:	10801417 	ldw	r2,80(r2)
811433c8:	1885883a 	add	r2,r3,r2
811433cc:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811433d0:	e03ff215 	stw	zero,-56(fp)
811433d4:	00003306 	br	811434a4 <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
811433d8:	e0fff217 	ldw	r3,-56(fp)
811433dc:	e0bff517 	ldw	r2,-44(fp)
811433e0:	1885883a 	add	r2,r3,r2
811433e4:	d0e0b017 	ldw	r3,-32064(gp)
811433e8:	180b883a 	mov	r5,r3
811433ec:	1009883a 	mov	r4,r2
811433f0:	114143c0 	call	8114143c <Read_Sector_Data>
811433f4:	10003226 	beq	r2,zero,811434c0 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
811433f8:	e03ff315 	stw	zero,-52(fp)
811433fc:	00002106 	br	81143484 <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81143400:	e0bff317 	ldw	r2,-52(fp)
81143404:	1004917a 	slli	r2,r2,5
81143408:	e0ffed17 	ldw	r3,-76(fp)
8114340c:	e13ff217 	ldw	r4,-56(fp)
81143410:	200f883a 	mov	r7,r4
81143414:	180d883a 	mov	r6,r3
81143418:	e17fff17 	ldw	r5,-4(fp)
8114341c:	1009883a 	mov	r4,r2
81143420:	114186c0 	call	8114186c <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81143424:	e0bfff17 	ldw	r2,-4(fp)
81143428:	10800003 	ldbu	r2,0(r2)
8114342c:	10803fcc 	andi	r2,r2,255
81143430:	10803960 	cmpeqi	r2,r2,229
81143434:	1000101e 	bne	r2,zero,81143478 <find_file_in_directory+0x394>
81143438:	e0bfff17 	ldw	r2,-4(fp)
8114343c:	10800003 	ldbu	r2,0(r2)
81143440:	10803fcc 	andi	r2,r2,255
81143444:	10000c26 	beq	r2,zero,81143478 <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81143448:	e0fffb04 	addi	r3,fp,-20
8114344c:	e0bff904 	addi	r2,fp,-28
81143450:	180d883a 	mov	r6,r3
81143454:	100b883a 	mov	r5,r2
81143458:	e13fff17 	ldw	r4,-4(fp)
8114345c:	11429000 	call	81142900 <match_file_record_to_name_ext>
81143460:	e0bff615 	stw	r2,-40(fp)

                            if (match)
81143464:	e0bff617 	ldw	r2,-40(fp)
81143468:	10000326 	beq	r2,zero,81143478 <find_file_in_directory+0x394>
                            {                               
                                result = true;
8114346c:	00800044 	movi	r2,1
81143470:	e0bfef15 	stw	r2,-68(fp)
                                break;
81143474:	00000606 	br	81143490 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81143478:	e0bff317 	ldw	r2,-52(fp)
8114347c:	10800044 	addi	r2,r2,1
81143480:	e0bff315 	stw	r2,-52(fp)
81143484:	e0bff317 	ldw	r2,-52(fp)
81143488:	10800410 	cmplti	r2,r2,16
8114348c:	103fdc1e 	bne	r2,zero,81143400 <__reset+0xfb123400>
                }
                else
                {
                    break;
                }
                if (result)
81143490:	e0bfef17 	ldw	r2,-68(fp)
81143494:	10000c1e 	bne	r2,zero,811434c8 <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81143498:	e0bff217 	ldw	r2,-56(fp)
8114349c:	10800044 	addi	r2,r2,1
811434a0:	e0bff215 	stw	r2,-56(fp)
811434a4:	00a045f4 	movhi	r2,33047
811434a8:	10af9e04 	addi	r2,r2,-16776
811434ac:	10800383 	ldbu	r2,14(r2)
811434b0:	10803fcc 	andi	r2,r2,255
811434b4:	e0fff217 	ldw	r3,-56(fp)
811434b8:	18bfc716 	blt	r3,r2,811433d8 <__reset+0xfb1233d8>
811434bc:	00000306 	br	811434cc <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
811434c0:	0001883a 	nop
811434c4:	00000106 	br	811434cc <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
811434c8:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
811434cc:	e0bfef17 	ldw	r2,-68(fp)
811434d0:	1000141e 	bne	r2,zero,81143524 <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
811434d4:	e0bfed17 	ldw	r2,-76(fp)
811434d8:	e0fffc04 	addi	r3,fp,-16
811434dc:	180b883a 	mov	r5,r3
811434e0:	1009883a 	mov	r4,r2
811434e4:	114151c0 	call	8114151c <get_cluster_flag>
811434e8:	10000c26 	beq	r2,zero,8114351c <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
811434ec:	e0bffc0b 	ldhu	r2,-16(fp)
811434f0:	10bfffcc 	andi	r2,r2,65535
811434f4:	10fffe0c 	andi	r3,r2,65528
811434f8:	00bffe14 	movui	r2,65528
811434fc:	1880021e 	bne	r3,r2,81143508 <find_file_in_directory+0x424>
					{
						return false;
81143500:	0005883a 	mov	r2,zero
81143504:	00001106 	br	8114354c <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
81143508:	e0bffc0b 	ldhu	r2,-16(fp)
8114350c:	10bfffcc 	andi	r2,r2,65535
81143510:	10bffe0c 	andi	r2,r2,65528
81143514:	e0bfed15 	stw	r2,-76(fp)
81143518:	00000206 	br	81143524 <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
8114351c:	0005883a 	mov	r2,zero
81143520:	00000a06 	br	8114354c <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
81143524:	e0bfed17 	ldw	r2,-76(fp)
81143528:	00fffdd4 	movui	r3,65527
8114352c:	18800616 	blt	r3,r2,81143548 <find_file_in_directory+0x464>
81143530:	e0bfef17 	ldw	r2,-68(fp)
81143534:	103f9926 	beq	r2,zero,8114339c <__reset+0xfb12339c>
81143538:	00000306 	br	81143548 <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
8114353c:	0001883a 	nop
81143540:	00000106 	br	81143548 <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
81143544:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
81143548:	e0bfef17 	ldw	r2,-68(fp)
}
8114354c:	e037883a 	mov	sp,fp
81143550:	dfc00117 	ldw	ra,4(sp)
81143554:	df000017 	ldw	fp,0(sp)
81143558:	dec00204 	addi	sp,sp,8
8114355c:	f800283a 	ret

81143560 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
81143560:	defff504 	addi	sp,sp,-44
81143564:	de00012e 	bgeu	sp,et,8114356c <find_first_empty_cluster+0xc>
81143568:	003b68fa 	trap	3
8114356c:	dfc00a15 	stw	ra,40(sp)
81143570:	df000915 	stw	fp,36(sp)
81143574:	df000904 	addi	fp,sp,36
81143578:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
8114357c:	00a045f4 	movhi	r2,33047
81143580:	10af9e04 	addi	r2,r2,-16776
81143584:	10801117 	ldw	r2,68(r2)
81143588:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
8114358c:	00800084 	movi	r2,2
81143590:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
81143594:	00bfffc4 	movi	r2,-1
81143598:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
8114359c:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
811435a0:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
811435a4:	00a045f4 	movhi	r2,33047
811435a8:	10af9e04 	addi	r2,r2,-16776
811435ac:	10801417 	ldw	r2,80(r2)
811435b0:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
811435b4:	00a045f4 	movhi	r2,33047
811435b8:	10af9e04 	addi	r2,r2,-16776
811435bc:	1080058b 	ldhu	r2,22(r2)
811435c0:	10bfffcc 	andi	r2,r2,65535
811435c4:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
811435c8:	00a045f4 	movhi	r2,33047
811435cc:	10af9e04 	addi	r2,r2,-16776
811435d0:	10800917 	ldw	r2,36(r2)
811435d4:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
811435d8:	e0bffd17 	ldw	r2,-12(fp)
811435dc:	e0fffe17 	ldw	r3,-8(fp)
811435e0:	18800b2e 	bgeu	r3,r2,81143610 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
811435e4:	e0fffd17 	ldw	r3,-12(fp)
811435e8:	e0bffc17 	ldw	r2,-16(fp)
811435ec:	1887c83a 	sub	r3,r3,r2
811435f0:	00a045f4 	movhi	r2,33047
811435f4:	10af9e04 	addi	r2,r2,-16776
811435f8:	10800383 	ldbu	r2,14(r2)
811435fc:	10803fcc 	andi	r2,r2,255
81143600:	1885203a 	divu	r2,r3,r2
81143604:	10800044 	addi	r2,r2,1
81143608:	e0bffb15 	stw	r2,-20(fp)
8114360c:	00002a06 	br	811436b8 <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81143610:	e0fffe17 	ldw	r3,-8(fp)
81143614:	e0bffc17 	ldw	r2,-16(fp)
81143618:	1887c83a 	sub	r3,r3,r2
8114361c:	00a045f4 	movhi	r2,33047
81143620:	10af9e04 	addi	r2,r2,-16776
81143624:	10800383 	ldbu	r2,14(r2)
81143628:	10803fcc 	andi	r2,r2,255
8114362c:	1885203a 	divu	r2,r3,r2
81143630:	10800044 	addi	r2,r2,1
81143634:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
81143638:	00001f06 	br	811436b8 <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
8114363c:	e0bff717 	ldw	r2,-36(fp)
81143640:	d0e0b017 	ldw	r3,-32064(gp)
81143644:	180b883a 	mov	r5,r3
81143648:	1009883a 	mov	r4,r2
8114364c:	114143c0 	call	8114143c <Read_Sector_Data>
81143650:	10001426 	beq	r2,zero,811436a4 <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
81143654:	e0bff817 	ldw	r2,-32(fp)
81143658:	10803fcc 	andi	r2,r2,255
8114365c:	1085883a 	add	r2,r2,r2
81143660:	1007883a 	mov	r3,r2
81143664:	d0a0b217 	ldw	r2,-32056(gp)
81143668:	10800a17 	ldw	r2,40(r2)
8114366c:	1885883a 	add	r2,r3,r2
81143670:	1080002b 	ldhuio	r2,0(r2)
81143674:	10bfffcc 	andi	r2,r2,65535
81143678:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
8114367c:	e0bff90f 	ldh	r2,-28(fp)
81143680:	10000726 	beq	r2,zero,811436a0 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
81143684:	e0bff817 	ldw	r2,-32(fp)
81143688:	10800044 	addi	r2,r2,1
8114368c:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
81143690:	e0bff817 	ldw	r2,-32(fp)
81143694:	10803fcc 	andi	r2,r2,255
81143698:	103fee1e 	bne	r2,zero,81143654 <__reset+0xfb123654>
8114369c:	00000106 	br	811436a4 <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
811436a0:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
811436a4:	e0bff90f 	ldh	r2,-28(fp)
811436a8:	10000926 	beq	r2,zero,811436d0 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
811436ac:	e0bff717 	ldw	r2,-36(fp)
811436b0:	10800044 	addi	r2,r2,1
811436b4:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
811436b8:	00a045f4 	movhi	r2,33047
811436bc:	10af9e04 	addi	r2,r2,-16776
811436c0:	10c01217 	ldw	r3,72(r2)
811436c4:	e0bff717 	ldw	r2,-36(fp)
811436c8:	18bfdc1e 	bne	r3,r2,8114363c <__reset+0xfb12363c>
811436cc:	00000106 	br	811436d4 <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
811436d0:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
811436d4:	e0bff90f 	ldh	r2,-28(fp)
811436d8:	1000081e 	bne	r2,zero,811436fc <find_first_empty_cluster+0x19c>
811436dc:	e0bff90f 	ldh	r2,-28(fp)
811436e0:	e0fffb17 	ldw	r3,-20(fp)
811436e4:	18800536 	bltu	r3,r2,811436fc <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
811436e8:	e0bfff17 	ldw	r2,-4(fp)
811436ec:	e0fff817 	ldw	r3,-32(fp)
811436f0:	10c00015 	stw	r3,0(r2)
		result = true;
811436f4:	00800044 	movi	r2,1
811436f8:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
811436fc:	e0bffa17 	ldw	r2,-24(fp)
}
81143700:	e037883a 	mov	sp,fp
81143704:	dfc00117 	ldw	ra,4(sp)
81143708:	df000017 	ldw	fp,0(sp)
8114370c:	dec00204 	addi	sp,sp,8
81143710:	f800283a 	ret

81143714 <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
81143714:	defff604 	addi	sp,sp,-40
81143718:	de00012e 	bgeu	sp,et,81143720 <find_first_empty_record_in_a_subdirectory+0xc>
8114371c:	003b68fa 	trap	3
81143720:	dfc00915 	stw	ra,36(sp)
81143724:	df000815 	stw	fp,32(sp)
81143728:	df000804 	addi	fp,sp,32
8114372c:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
81143730:	00bfffc4 	movi	r2,-1
81143734:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
81143738:	e0bfff17 	ldw	r2,-4(fp)
8114373c:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81143740:	e0bff917 	ldw	r2,-28(fp)
81143744:	10ffff84 	addi	r3,r2,-2
81143748:	00a045f4 	movhi	r2,33047
8114374c:	10af9e04 	addi	r2,r2,-16776
81143750:	10800383 	ldbu	r2,14(r2)
81143754:	10803fcc 	andi	r2,r2,255
81143758:	1885383a 	mul	r2,r3,r2
8114375c:	1007883a 	mov	r3,r2
81143760:	00a045f4 	movhi	r2,33047
81143764:	10af9e04 	addi	r2,r2,-16776
81143768:	10801417 	ldw	r2,80(r2)
8114376c:	1885883a 	add	r2,r3,r2
81143770:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81143774:	e03ffa15 	stw	zero,-24(fp)
81143778:	00002c06 	br	8114382c <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8114377c:	e0fffa17 	ldw	r3,-24(fp)
81143780:	e0bffc17 	ldw	r2,-16(fp)
81143784:	1885883a 	add	r2,r3,r2
81143788:	d0e0b017 	ldw	r3,-32064(gp)
8114378c:	180b883a 	mov	r5,r3
81143790:	1009883a 	mov	r4,r2
81143794:	114143c0 	call	8114143c <Read_Sector_Data>
81143798:	10002b26 	beq	r2,zero,81143848 <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8114379c:	e03ffb15 	stw	zero,-20(fp)
811437a0:	00001c06 	br	81143814 <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
811437a4:	e0bffb17 	ldw	r2,-20(fp)
811437a8:	1004917a 	slli	r2,r2,5
811437ac:	1007883a 	mov	r3,r2
811437b0:	d0a0b217 	ldw	r2,-32056(gp)
811437b4:	10800a17 	ldw	r2,40(r2)
811437b8:	1885883a 	add	r2,r3,r2
811437bc:	10800023 	ldbuio	r2,0(r2)
811437c0:	10803fcc 	andi	r2,r2,255
811437c4:	10803fcc 	andi	r2,r2,255
811437c8:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
811437cc:	e0bffd0b 	ldhu	r2,-12(fp)
811437d0:	10803960 	cmpeqi	r2,r2,229
811437d4:	1000021e 	bne	r2,zero,811437e0 <find_first_empty_record_in_a_subdirectory+0xcc>
811437d8:	e0bffd0b 	ldhu	r2,-12(fp)
811437dc:	10000a1e 	bne	r2,zero,81143808 <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
811437e0:	e0bffa17 	ldw	r2,-24(fp)
811437e4:	1006913a 	slli	r3,r2,4
811437e8:	e0bffb17 	ldw	r2,-20(fp)
811437ec:	1885883a 	add	r2,r3,r2
811437f0:	1006943a 	slli	r3,r2,16
811437f4:	e0bff917 	ldw	r2,-28(fp)
811437f8:	1884b03a 	or	r2,r3,r2
811437fc:	e0bff815 	stw	r2,-32(fp)
                        return result;
81143800:	e0bff817 	ldw	r2,-32(fp)
81143804:	00005306 	br	81143954 <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81143808:	e0bffb17 	ldw	r2,-20(fp)
8114380c:	10800044 	addi	r2,r2,1
81143810:	e0bffb15 	stw	r2,-20(fp)
81143814:	e0bffb17 	ldw	r2,-20(fp)
81143818:	10800410 	cmplti	r2,r2,16
8114381c:	103fe11e 	bne	r2,zero,811437a4 <__reset+0xfb1237a4>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81143820:	e0bffa17 	ldw	r2,-24(fp)
81143824:	10800044 	addi	r2,r2,1
81143828:	e0bffa15 	stw	r2,-24(fp)
8114382c:	00a045f4 	movhi	r2,33047
81143830:	10af9e04 	addi	r2,r2,-16776
81143834:	10800383 	ldbu	r2,14(r2)
81143838:	10803fcc 	andi	r2,r2,255
8114383c:	e0fffa17 	ldw	r3,-24(fp)
81143840:	18bfce16 	blt	r3,r2,8114377c <__reset+0xfb12377c>
81143844:	00000106 	br	8114384c <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
81143848:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
8114384c:	e0bff817 	ldw	r2,-32(fp)
81143850:	1000390e 	bge	r2,zero,81143938 <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
81143854:	e0bff917 	ldw	r2,-28(fp)
81143858:	e0fffd84 	addi	r3,fp,-10
8114385c:	180b883a 	mov	r5,r3
81143860:	1009883a 	mov	r4,r2
81143864:	114151c0 	call	8114151c <get_cluster_flag>
81143868:	10003126 	beq	r2,zero,81143930 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8114386c:	e0bffd8b 	ldhu	r2,-10(fp)
81143870:	10bfffcc 	andi	r2,r2,65535
81143874:	10fffe0c 	andi	r3,r2,65528
81143878:	00bffe14 	movui	r2,65528
8114387c:	18802e1e 	bne	r3,r2,81143938 <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
81143880:	e0bffe04 	addi	r2,fp,-8
81143884:	1009883a 	mov	r4,r2
81143888:	11435600 	call	81143560 <find_first_empty_cluster>
8114388c:	10002326 	beq	r2,zero,8114391c <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
81143890:	e0bff917 	ldw	r2,-28(fp)
81143894:	e0fffe17 	ldw	r3,-8(fp)
81143898:	18ffffcc 	andi	r3,r3,65535
8114389c:	18e0001c 	xori	r3,r3,32768
811438a0:	18e00004 	addi	r3,r3,-32768
811438a4:	01800044 	movi	r6,1
811438a8:	180b883a 	mov	r5,r3
811438ac:	1009883a 	mov	r4,r2
811438b0:	11415d80 	call	811415d8 <mark_cluster>
811438b4:	10001926 	beq	r2,zero,8114391c <find_first_empty_record_in_a_subdirectory+0x208>
811438b8:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
811438bc:	01800044 	movi	r6,1
811438c0:	017fffc4 	movi	r5,-1
811438c4:	1009883a 	mov	r4,r2
811438c8:	11415d80 	call	811415d8 <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
811438cc:	10001326 	beq	r2,zero,8114391c <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
811438d0:	e0bff917 	ldw	r2,-28(fp)
811438d4:	e0fffe17 	ldw	r3,-8(fp)
811438d8:	18ffffcc 	andi	r3,r3,65535
811438dc:	18e0001c 	xori	r3,r3,32768
811438e0:	18e00004 	addi	r3,r3,-32768
811438e4:	000d883a 	mov	r6,zero
811438e8:	180b883a 	mov	r5,r3
811438ec:	1009883a 	mov	r4,r2
811438f0:	11415d80 	call	811415d8 <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
811438f4:	10000926 	beq	r2,zero,8114391c <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
811438f8:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
811438fc:	000d883a 	mov	r6,zero
81143900:	017fffc4 	movi	r5,-1
81143904:	1009883a 	mov	r4,r2
81143908:	11415d80 	call	811415d8 <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8114390c:	10000326 	beq	r2,zero,8114391c <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
81143910:	11413e80 	call	811413e8 <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
81143914:	e0bffe17 	ldw	r2,-8(fp)
81143918:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
8114391c:	e0bffd8b 	ldhu	r2,-10(fp)
81143920:	10bfffcc 	andi	r2,r2,65535
81143924:	10bffe0c 	andi	r2,r2,65528
81143928:	e0bff915 	stw	r2,-28(fp)
8114392c:	00000206 	br	81143938 <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
81143930:	00bfffc4 	movi	r2,-1
81143934:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
81143938:	e0bff917 	ldw	r2,-28(fp)
8114393c:	00fffdd4 	movui	r3,65527
81143940:	18800316 	blt	r3,r2,81143950 <find_first_empty_record_in_a_subdirectory+0x23c>
81143944:	e0bff817 	ldw	r2,-32(fp)
81143948:	10bfffe0 	cmpeqi	r2,r2,-1
8114394c:	103f7c1e 	bne	r2,zero,81143740 <__reset+0xfb123740>
    return result; 
81143950:	e0bff817 	ldw	r2,-32(fp)
}
81143954:	e037883a 	mov	sp,fp
81143958:	dfc00117 	ldw	ra,4(sp)
8114395c:	df000017 	ldw	fp,0(sp)
81143960:	dec00204 	addi	sp,sp,8
81143964:	f800283a 	ret

81143968 <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
81143968:	defff904 	addi	sp,sp,-28
8114396c:	de00012e 	bgeu	sp,et,81143974 <find_first_empty_record_in_root_directory+0xc>
81143970:	003b68fa 	trap	3
81143974:	dfc00615 	stw	ra,24(sp)
81143978:	df000515 	stw	fp,20(sp)
8114397c:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81143980:	00a045f4 	movhi	r2,33047
81143984:	10af9e04 	addi	r2,r2,-16776
81143988:	1080050b 	ldhu	r2,20(r2)
8114398c:	10bfffcc 	andi	r2,r2,65535
81143990:	1006917a 	slli	r3,r2,5
81143994:	00a045f4 	movhi	r2,33047
81143998:	10af9e04 	addi	r2,r2,-16776
8114399c:	1080030b 	ldhu	r2,12(r2)
811439a0:	10bfffcc 	andi	r2,r2,65535
811439a4:	1885283a 	div	r2,r3,r2
811439a8:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
811439ac:	00bfffc4 	movi	r2,-1
811439b0:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811439b4:	e03ffb15 	stw	zero,-20(fp)
811439b8:	00002d06 	br	81143a70 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
811439bc:	00a045f4 	movhi	r2,33047
811439c0:	10af9e04 	addi	r2,r2,-16776
811439c4:	10c01317 	ldw	r3,76(r2)
811439c8:	e0bffb17 	ldw	r2,-20(fp)
811439cc:	1885883a 	add	r2,r3,r2
811439d0:	1007883a 	mov	r3,r2
811439d4:	d0a0b017 	ldw	r2,-32064(gp)
811439d8:	100b883a 	mov	r5,r2
811439dc:	1809883a 	mov	r4,r3
811439e0:	114143c0 	call	8114143c <Read_Sector_Data>
811439e4:	10002626 	beq	r2,zero,81143a80 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
811439e8:	e03ffc15 	stw	zero,-16(fp)
811439ec:	00001a06 	br	81143a58 <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
811439f0:	e0bffc17 	ldw	r2,-16(fp)
811439f4:	1004917a 	slli	r2,r2,5
811439f8:	1007883a 	mov	r3,r2
811439fc:	d0a0b217 	ldw	r2,-32056(gp)
81143a00:	10800a17 	ldw	r2,40(r2)
81143a04:	1885883a 	add	r2,r3,r2
81143a08:	10800023 	ldbuio	r2,0(r2)
81143a0c:	10803fcc 	andi	r2,r2,255
81143a10:	10803fcc 	andi	r2,r2,255
81143a14:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
81143a18:	e0bfff0b 	ldhu	r2,-4(fp)
81143a1c:	10803960 	cmpeqi	r2,r2,229
81143a20:	1000021e 	bne	r2,zero,81143a2c <find_first_empty_record_in_root_directory+0xc4>
81143a24:	e0bfff0b 	ldhu	r2,-4(fp)
81143a28:	1000081e 	bne	r2,zero,81143a4c <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
81143a2c:	e0bffb17 	ldw	r2,-20(fp)
81143a30:	1006913a 	slli	r3,r2,4
81143a34:	e0bffc17 	ldw	r2,-16(fp)
81143a38:	1885883a 	add	r2,r3,r2
81143a3c:	1004943a 	slli	r2,r2,16
81143a40:	e0bffe15 	stw	r2,-8(fp)
                    return result;
81143a44:	e0bffe17 	ldw	r2,-8(fp)
81143a48:	00000f06 	br	81143a88 <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
81143a4c:	e0bffc17 	ldw	r2,-16(fp)
81143a50:	10800044 	addi	r2,r2,1
81143a54:	e0bffc15 	stw	r2,-16(fp)
81143a58:	e0bffc17 	ldw	r2,-16(fp)
81143a5c:	10800410 	cmplti	r2,r2,16
81143a60:	103fe31e 	bne	r2,zero,811439f0 <__reset+0xfb1239f0>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81143a64:	e0bffb17 	ldw	r2,-20(fp)
81143a68:	10800044 	addi	r2,r2,1
81143a6c:	e0bffb15 	stw	r2,-20(fp)
81143a70:	e0fffb17 	ldw	r3,-20(fp)
81143a74:	e0bffd17 	ldw	r2,-12(fp)
81143a78:	18bfd016 	blt	r3,r2,811439bc <__reset+0xfb1239bc>
81143a7c:	00000106 	br	81143a84 <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
81143a80:	0001883a 	nop
        }
    }
    return result;
81143a84:	e0bffe17 	ldw	r2,-8(fp)
}
81143a88:	e037883a 	mov	sp,fp
81143a8c:	dfc00117 	ldw	ra,4(sp)
81143a90:	df000017 	ldw	fp,0(sp)
81143a94:	dec00204 	addi	sp,sp,8
81143a98:	f800283a 	ret

81143a9c <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
81143a9c:	defffa04 	addi	sp,sp,-24
81143aa0:	de00012e 	bgeu	sp,et,81143aa8 <convert_filename_to_name_extension+0xc>
81143aa4:	003b68fa 	trap	3
81143aa8:	df000515 	stw	fp,20(sp)
81143aac:	df000504 	addi	fp,sp,20
81143ab0:	e13ffd15 	stw	r4,-12(fp)
81143ab4:	e17ffe15 	stw	r5,-8(fp)
81143ab8:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
81143abc:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
81143ac0:	e03ffb15 	stw	zero,-20(fp)
81143ac4:	00002506 	br	81143b5c <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
81143ac8:	e0bffc17 	ldw	r2,-16(fp)
81143acc:	e0fffd17 	ldw	r3,-12(fp)
81143ad0:	1885883a 	add	r2,r3,r2
81143ad4:	10800003 	ldbu	r2,0(r2)
81143ad8:	10803fcc 	andi	r2,r2,255
81143adc:	1080201c 	xori	r2,r2,128
81143ae0:	10bfe004 	addi	r2,r2,-128
81143ae4:	10800ba0 	cmpeqi	r2,r2,46
81143ae8:	1000141e 	bne	r2,zero,81143b3c <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
81143aec:	e0bffb17 	ldw	r2,-20(fp)
81143af0:	e0fffe17 	ldw	r3,-8(fp)
81143af4:	1885883a 	add	r2,r3,r2
81143af8:	e0fffc17 	ldw	r3,-16(fp)
81143afc:	e13ffd17 	ldw	r4,-12(fp)
81143b00:	20c7883a 	add	r3,r4,r3
81143b04:	18c00003 	ldbu	r3,0(r3)
81143b08:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
81143b0c:	e0bffc17 	ldw	r2,-16(fp)
81143b10:	e0fffd17 	ldw	r3,-12(fp)
81143b14:	1885883a 	add	r2,r3,r2
81143b18:	10800003 	ldbu	r2,0(r2)
81143b1c:	10803fcc 	andi	r2,r2,255
81143b20:	1080201c 	xori	r2,r2,128
81143b24:	10bfe004 	addi	r2,r2,-128
81143b28:	10000926 	beq	r2,zero,81143b50 <convert_filename_to_name_extension+0xb4>
81143b2c:	e0bffc17 	ldw	r2,-16(fp)
81143b30:	10800044 	addi	r2,r2,1
81143b34:	e0bffc15 	stw	r2,-16(fp)
81143b38:	00000506 	br	81143b50 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
81143b3c:	e0bffb17 	ldw	r2,-20(fp)
81143b40:	e0fffe17 	ldw	r3,-8(fp)
81143b44:	1885883a 	add	r2,r3,r2
81143b48:	00c00804 	movi	r3,32
81143b4c:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
81143b50:	e0bffb17 	ldw	r2,-20(fp)
81143b54:	10800044 	addi	r2,r2,1
81143b58:	e0bffb15 	stw	r2,-20(fp)
81143b5c:	e0bffb17 	ldw	r2,-20(fp)
81143b60:	10800210 	cmplti	r2,r2,8
81143b64:	103fd81e 	bne	r2,zero,81143ac8 <__reset+0xfb123ac8>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
81143b68:	e0bffc17 	ldw	r2,-16(fp)
81143b6c:	e0fffd17 	ldw	r3,-12(fp)
81143b70:	1885883a 	add	r2,r3,r2
81143b74:	10800003 	ldbu	r2,0(r2)
81143b78:	10803fcc 	andi	r2,r2,255
81143b7c:	1080201c 	xori	r2,r2,128
81143b80:	10bfe004 	addi	r2,r2,-128
81143b84:	10800b98 	cmpnei	r2,r2,46
81143b88:	1000031e 	bne	r2,zero,81143b98 <convert_filename_to_name_extension+0xfc>
81143b8c:	e0bffc17 	ldw	r2,-16(fp)
81143b90:	10800044 	addi	r2,r2,1
81143b94:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
81143b98:	e03ffb15 	stw	zero,-20(fp)
81143b9c:	00001c06 	br	81143c10 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
81143ba0:	e0bffc17 	ldw	r2,-16(fp)
81143ba4:	e0fffd17 	ldw	r3,-12(fp)
81143ba8:	1885883a 	add	r2,r3,r2
81143bac:	10800003 	ldbu	r2,0(r2)
81143bb0:	10803fcc 	andi	r2,r2,255
81143bb4:	1080201c 	xori	r2,r2,128
81143bb8:	10bfe004 	addi	r2,r2,-128
81143bbc:	10000c26 	beq	r2,zero,81143bf0 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
81143bc0:	e0bffb17 	ldw	r2,-20(fp)
81143bc4:	e0ffff17 	ldw	r3,-4(fp)
81143bc8:	1885883a 	add	r2,r3,r2
81143bcc:	e0fffc17 	ldw	r3,-16(fp)
81143bd0:	e13ffd17 	ldw	r4,-12(fp)
81143bd4:	20c7883a 	add	r3,r4,r3
81143bd8:	18c00003 	ldbu	r3,0(r3)
81143bdc:	10c00005 	stb	r3,0(r2)
            local++;
81143be0:	e0bffc17 	ldw	r2,-16(fp)
81143be4:	10800044 	addi	r2,r2,1
81143be8:	e0bffc15 	stw	r2,-16(fp)
81143bec:	00000506 	br	81143c04 <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
81143bf0:	e0bffb17 	ldw	r2,-20(fp)
81143bf4:	e0ffff17 	ldw	r3,-4(fp)
81143bf8:	1885883a 	add	r2,r3,r2
81143bfc:	00c00804 	movi	r3,32
81143c00:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
81143c04:	e0bffb17 	ldw	r2,-20(fp)
81143c08:	10800044 	addi	r2,r2,1
81143c0c:	e0bffb15 	stw	r2,-20(fp)
81143c10:	e0bffb17 	ldw	r2,-20(fp)
81143c14:	108000d0 	cmplti	r2,r2,3
81143c18:	103fe11e 	bne	r2,zero,81143ba0 <__reset+0xfb123ba0>
        {
            extension[counter] = ' ';
        }
    }

}
81143c1c:	0001883a 	nop
81143c20:	e037883a 	mov	sp,fp
81143c24:	df000017 	ldw	fp,0(sp)
81143c28:	dec00104 	addi	sp,sp,4
81143c2c:	f800283a 	ret

81143c30 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
81143c30:	defff504 	addi	sp,sp,-44
81143c34:	de00012e 	bgeu	sp,et,81143c3c <create_file+0xc>
81143c38:	003b68fa 	trap	3
81143c3c:	dfc00a15 	stw	ra,40(sp)
81143c40:	df000915 	stw	fp,36(sp)
81143c44:	df000904 	addi	fp,sp,36
81143c48:	e13ffd15 	stw	r4,-12(fp)
81143c4c:	e17ffe15 	stw	r5,-8(fp)
81143c50:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
81143c54:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
81143c58:	e0bffc04 	addi	r2,fp,-16
81143c5c:	1009883a 	mov	r4,r2
81143c60:	11435600 	call	81143560 <find_first_empty_cluster>
81143c64:	1000a026 	beq	r2,zero,81143ee8 <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
81143c68:	e0bfff17 	ldw	r2,-4(fp)
81143c6c:	10800a17 	ldw	r2,40(r2)
81143c70:	1000031e 	bne	r2,zero,81143c80 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
81143c74:	11439680 	call	81143968 <find_first_empty_record_in_root_directory>
81143c78:	e0bff815 	stw	r2,-32(fp)
81143c7c:	00000606 	br	81143c98 <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
81143c80:	e0bfff17 	ldw	r2,-4(fp)
81143c84:	1080058b 	ldhu	r2,22(r2)
81143c88:	10bfffcc 	andi	r2,r2,65535
81143c8c:	1009883a 	mov	r4,r2
81143c90:	11437140 	call	81143714 <find_first_empty_record_in_a_subdirectory>
81143c94:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
81143c98:	e0bff817 	ldw	r2,-32(fp)
81143c9c:	10009216 	blt	r2,zero,81143ee8 <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
81143ca0:	e13ffd17 	ldw	r4,-12(fp)
81143ca4:	11428400 	call	81142840 <get_dir_divider_location>
81143ca8:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
81143cac:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
81143cb0:	00000b06 	br	81143ce0 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
81143cb4:	e0fffa17 	ldw	r3,-24(fp)
81143cb8:	e0bff917 	ldw	r2,-28(fp)
81143cbc:	1885883a 	add	r2,r3,r2
81143cc0:	10800044 	addi	r2,r2,1
81143cc4:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
81143cc8:	e0bffa17 	ldw	r2,-24(fp)
81143ccc:	e0fffd17 	ldw	r3,-12(fp)
81143cd0:	1885883a 	add	r2,r3,r2
81143cd4:	1009883a 	mov	r4,r2
81143cd8:	11428400 	call	81142840 <get_dir_divider_location>
81143cdc:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
81143ce0:	e0bff917 	ldw	r2,-28(fp)
81143ce4:	00bff316 	blt	zero,r2,81143cb4 <__reset+0xfb123cb4>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
81143ce8:	e0bffa17 	ldw	r2,-24(fp)
81143cec:	e0fffd17 	ldw	r3,-12(fp)
81143cf0:	1887883a 	add	r3,r3,r2
81143cf4:	e13ffe17 	ldw	r4,-8(fp)
81143cf8:	e0bffe17 	ldw	r2,-8(fp)
81143cfc:	10800204 	addi	r2,r2,8
81143d00:	100d883a 	mov	r6,r2
81143d04:	200b883a 	mov	r5,r4
81143d08:	1809883a 	mov	r4,r3
81143d0c:	1143a9c0 	call	81143a9c <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
81143d10:	e0bffe17 	ldw	r2,-8(fp)
81143d14:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
81143d18:	e0bffe17 	ldw	r2,-8(fp)
81143d1c:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
81143d20:	e0bffe17 	ldw	r2,-8(fp)
81143d24:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
81143d28:	e0bffe17 	ldw	r2,-8(fp)
81143d2c:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
81143d30:	e0bffe17 	ldw	r2,-8(fp)
81143d34:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
81143d38:	e0bffe17 	ldw	r2,-8(fp)
81143d3c:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
81143d40:	e0bffc17 	ldw	r2,-16(fp)
81143d44:	1007883a 	mov	r3,r2
81143d48:	e0bffe17 	ldw	r2,-8(fp)
81143d4c:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
81143d50:	e0bffe17 	ldw	r2,-8(fp)
81143d54:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
81143d58:	e0fffc17 	ldw	r3,-16(fp)
81143d5c:	e0bffe17 	ldw	r2,-8(fp)
81143d60:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
81143d64:	e0bffe17 	ldw	r2,-8(fp)
81143d68:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
81143d6c:	e0bffe17 	ldw	r2,-8(fp)
81143d70:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
81143d74:	e0bff817 	ldw	r2,-32(fp)
81143d78:	10ffffcc 	andi	r3,r2,65535
81143d7c:	e0bffe17 	ldw	r2,-8(fp)
81143d80:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
81143d84:	e0bff817 	ldw	r2,-32(fp)
81143d88:	1004d43a 	srli	r2,r2,16
81143d8c:	1000010e 	bge	r2,zero,81143d94 <create_file+0x164>
81143d90:	108003c4 	addi	r2,r2,15
81143d94:	1005d13a 	srai	r2,r2,4
81143d98:	1007883a 	mov	r3,r2
81143d9c:	e0bffe17 	ldw	r2,-8(fp)
81143da0:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
81143da4:	e0bff817 	ldw	r2,-32(fp)
81143da8:	1004d43a 	srli	r2,r2,16
81143dac:	1007883a 	mov	r3,r2
81143db0:	00a00034 	movhi	r2,32768
81143db4:	108003c4 	addi	r2,r2,15
81143db8:	1884703a 	and	r2,r3,r2
81143dbc:	1000040e 	bge	r2,zero,81143dd0 <create_file+0x1a0>
81143dc0:	10bfffc4 	addi	r2,r2,-1
81143dc4:	00fffc04 	movi	r3,-16
81143dc8:	10c4b03a 	or	r2,r2,r3
81143dcc:	10800044 	addi	r2,r2,1
81143dd0:	1004917a 	slli	r2,r2,5
81143dd4:	1007883a 	mov	r3,r2
81143dd8:	e0bffe17 	ldw	r2,-8(fp)
81143ddc:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
81143de0:	e0bfff17 	ldw	r2,-4(fp)
81143de4:	1080058b 	ldhu	r2,22(r2)
81143de8:	10ffffcc 	andi	r3,r2,65535
81143dec:	e0bffe17 	ldw	r2,-8(fp)
81143df0:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
81143df4:	e0bffe17 	ldw	r2,-8(fp)
81143df8:	00c00044 	movi	r3,1
81143dfc:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
81143e00:	e0bffe17 	ldw	r2,-8(fp)
81143e04:	00c00044 	movi	r3,1
81143e08:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81143e0c:	e0bffe17 	ldw	r2,-8(fp)
81143e10:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81143e14:	1000071e 	bne	r2,zero,81143e34 <create_file+0x204>
81143e18:	00a045f4 	movhi	r2,33047
81143e1c:	10af9e04 	addi	r2,r2,-16776
81143e20:	10c01317 	ldw	r3,76(r2)
81143e24:	e0bffe17 	ldw	r2,-8(fp)
81143e28:	10800b17 	ldw	r2,44(r2)
81143e2c:	1885883a 	add	r2,r3,r2
81143e30:	00000f06 	br	81143e70 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
81143e34:	00a045f4 	movhi	r2,33047
81143e38:	10af9e04 	addi	r2,r2,-16776
81143e3c:	10c01417 	ldw	r3,80(r2)
81143e40:	e0bffe17 	ldw	r2,-8(fp)
81143e44:	10800a17 	ldw	r2,40(r2)
81143e48:	113fff84 	addi	r4,r2,-2
81143e4c:	00a045f4 	movhi	r2,33047
81143e50:	10af9e04 	addi	r2,r2,-16776
81143e54:	10800383 	ldbu	r2,14(r2)
81143e58:	10803fcc 	andi	r2,r2,255
81143e5c:	2085383a 	mul	r2,r4,r2
81143e60:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
81143e64:	e0bffe17 	ldw	r2,-8(fp)
81143e68:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81143e6c:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81143e70:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
81143e74:	e0bffb17 	ldw	r2,-20(fp)
81143e78:	d0e0b017 	ldw	r3,-32064(gp)
81143e7c:	180b883a 	mov	r5,r3
81143e80:	1009883a 	mov	r4,r2
81143e84:	114143c0 	call	8114143c <Read_Sector_Data>
81143e88:	10001726 	beq	r2,zero,81143ee8 <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
81143e8c:	e0bffe17 	ldw	r2,-8(fp)
81143e90:	10800c0b 	ldhu	r2,48(r2)
81143e94:	10bfffcc 	andi	r2,r2,65535
81143e98:	10a0001c 	xori	r2,r2,32768
81143e9c:	10a00004 	addi	r2,r2,-32768
81143ea0:	e17ffe17 	ldw	r5,-8(fp)
81143ea4:	1009883a 	mov	r4,r2
81143ea8:	1141af00 	call	81141af0 <Write_File_Record_At_Offset>
81143eac:	10000e26 	beq	r2,zero,81143ee8 <create_file+0x2b8>
                {
                    Save_Modified_Sector();
81143eb0:	11413e80 	call	811413e8 <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
81143eb4:	e0bffc17 	ldw	r2,-16(fp)
81143eb8:	01800044 	movi	r6,1
81143ebc:	017fffc4 	movi	r5,-1
81143ec0:	1009883a 	mov	r4,r2
81143ec4:	11415d80 	call	811415d8 <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
81143ec8:	e0bffc17 	ldw	r2,-16(fp)
81143ecc:	000d883a 	mov	r6,zero
81143ed0:	017fffc4 	movi	r5,-1
81143ed4:	1009883a 	mov	r4,r2
81143ed8:	11415d80 	call	811415d8 <mark_cluster>
81143edc:	10000226 	beq	r2,zero,81143ee8 <create_file+0x2b8>
                    {
                        result = true;
81143ee0:	00800044 	movi	r2,1
81143ee4:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
81143ee8:	e0bff717 	ldw	r2,-36(fp)
}
81143eec:	e037883a 	mov	sp,fp
81143ef0:	dfc00117 	ldw	ra,4(sp)
81143ef4:	df000017 	ldw	fp,0(sp)
81143ef8:	dec00204 	addi	sp,sp,8
81143efc:	f800283a 	ret

81143f00 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
81143f00:	defffb04 	addi	sp,sp,-20
81143f04:	de00012e 	bgeu	sp,et,81143f0c <copy_file_record_name_to_string+0xc>
81143f08:	003b68fa 	trap	3
81143f0c:	df000415 	stw	fp,16(sp)
81143f10:	df000404 	addi	fp,sp,16
81143f14:	e13ffe15 	stw	r4,-8(fp)
81143f18:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
81143f1c:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81143f20:	e03ffc15 	stw	zero,-16(fp)
81143f24:	00001506 	br	81143f7c <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
81143f28:	e0fffe17 	ldw	r3,-8(fp)
81143f2c:	e0bffc17 	ldw	r2,-16(fp)
81143f30:	1885883a 	add	r2,r3,r2
81143f34:	10800003 	ldbu	r2,0(r2)
81143f38:	10803fcc 	andi	r2,r2,255
81143f3c:	10800820 	cmpeqi	r2,r2,32
81143f40:	10000b1e 	bne	r2,zero,81143f70 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
81143f44:	e0bffd17 	ldw	r2,-12(fp)
81143f48:	e0ffff17 	ldw	r3,-4(fp)
81143f4c:	1885883a 	add	r2,r3,r2
81143f50:	e13ffe17 	ldw	r4,-8(fp)
81143f54:	e0fffc17 	ldw	r3,-16(fp)
81143f58:	20c7883a 	add	r3,r4,r3
81143f5c:	18c00003 	ldbu	r3,0(r3)
81143f60:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
81143f64:	e0bffd17 	ldw	r2,-12(fp)
81143f68:	10800044 	addi	r2,r2,1
81143f6c:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81143f70:	e0bffc17 	ldw	r2,-16(fp)
81143f74:	10800044 	addi	r2,r2,1
81143f78:	e0bffc15 	stw	r2,-16(fp)
81143f7c:	e0bffc17 	ldw	r2,-16(fp)
81143f80:	10800210 	cmplti	r2,r2,8
81143f84:	103fe81e 	bne	r2,zero,81143f28 <__reset+0xfb123f28>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
81143f88:	e0bffe17 	ldw	r2,-8(fp)
81143f8c:	10800203 	ldbu	r2,8(r2)
81143f90:	10803fcc 	andi	r2,r2,255
81143f94:	10800820 	cmpeqi	r2,r2,32
81143f98:	1000241e 	bne	r2,zero,8114402c <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
81143f9c:	e0bffd17 	ldw	r2,-12(fp)
81143fa0:	e0ffff17 	ldw	r3,-4(fp)
81143fa4:	1885883a 	add	r2,r3,r2
81143fa8:	00c00b84 	movi	r3,46
81143fac:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
81143fb0:	e0bffd17 	ldw	r2,-12(fp)
81143fb4:	10800044 	addi	r2,r2,1
81143fb8:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
81143fbc:	e03ffc15 	stw	zero,-16(fp)
81143fc0:	00001706 	br	81144020 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
81143fc4:	e0fffe17 	ldw	r3,-8(fp)
81143fc8:	e0bffc17 	ldw	r2,-16(fp)
81143fcc:	1885883a 	add	r2,r3,r2
81143fd0:	10800204 	addi	r2,r2,8
81143fd4:	10800003 	ldbu	r2,0(r2)
81143fd8:	10803fcc 	andi	r2,r2,255
81143fdc:	10800820 	cmpeqi	r2,r2,32
81143fe0:	10000c1e 	bne	r2,zero,81144014 <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
81143fe4:	e0bffd17 	ldw	r2,-12(fp)
81143fe8:	e0ffff17 	ldw	r3,-4(fp)
81143fec:	1885883a 	add	r2,r3,r2
81143ff0:	e13ffe17 	ldw	r4,-8(fp)
81143ff4:	e0fffc17 	ldw	r3,-16(fp)
81143ff8:	20c7883a 	add	r3,r4,r3
81143ffc:	18c00204 	addi	r3,r3,8
81144000:	18c00003 	ldbu	r3,0(r3)
81144004:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
81144008:	e0bffd17 	ldw	r2,-12(fp)
8114400c:	10800044 	addi	r2,r2,1
81144010:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
81144014:	e0bffc17 	ldw	r2,-16(fp)
81144018:	10800044 	addi	r2,r2,1
8114401c:	e0bffc15 	stw	r2,-16(fp)
81144020:	e0bffc17 	ldw	r2,-16(fp)
81144024:	108000d0 	cmplti	r2,r2,3
81144028:	103fe61e 	bne	r2,zero,81143fc4 <__reset+0xfb123fc4>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
8114402c:	e0bffd17 	ldw	r2,-12(fp)
81144030:	e0ffff17 	ldw	r3,-4(fp)
81144034:	1885883a 	add	r2,r3,r2
81144038:	10000005 	stb	zero,0(r2)
}
8114403c:	0001883a 	nop
81144040:	e037883a 	mov	sp,fp
81144044:	df000017 	ldw	fp,0(sp)
81144048:	dec00104 	addi	sp,sp,4
8114404c:	f800283a 	ret

81144050 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
81144050:	defffc04 	addi	sp,sp,-16
81144054:	de00012e 	bgeu	sp,et,8114405c <alt_up_sd_card_open_dev+0xc>
81144058:	003b68fa 	trap	3
8114405c:	dfc00315 	stw	ra,12(sp)
81144060:	df000215 	stw	fp,8(sp)
81144064:	df000204 	addi	fp,sp,8
81144068:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
8114406c:	d1600d04 	addi	r5,gp,-32716
81144070:	e13fff17 	ldw	r4,-4(fp)
81144074:	114950c0 	call	8114950c <alt_find_dev>
81144078:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
8114407c:	e0bffe17 	ldw	r2,-8(fp)
81144080:	10001e26 	beq	r2,zero,811440fc <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
81144084:	e0bffe17 	ldw	r2,-8(fp)
81144088:	10800a17 	ldw	r2,40(r2)
8114408c:	10808d04 	addi	r2,r2,564
81144090:	d0a0aa15 	stw	r2,-32088(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
81144094:	e0bffe17 	ldw	r2,-8(fp)
81144098:	10800a17 	ldw	r2,40(r2)
8114409c:	10808904 	addi	r2,r2,548
811440a0:	d0a0ab15 	stw	r2,-32084(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
811440a4:	e0bffe17 	ldw	r2,-8(fp)
811440a8:	10800a17 	ldw	r2,40(r2)
811440ac:	10808404 	addi	r2,r2,528
811440b0:	d0a0ac15 	stw	r2,-32080(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
811440b4:	e0bffe17 	ldw	r2,-8(fp)
811440b8:	10800a17 	ldw	r2,40(r2)
811440bc:	10808c04 	addi	r2,r2,560
811440c0:	d0a0ad15 	stw	r2,-32076(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
811440c4:	e0bffe17 	ldw	r2,-8(fp)
811440c8:	10800a17 	ldw	r2,40(r2)
811440cc:	10808b04 	addi	r2,r2,556
811440d0:	d0a0ae15 	stw	r2,-32072(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
811440d4:	e0bffe17 	ldw	r2,-8(fp)
811440d8:	10800a17 	ldw	r2,40(r2)
811440dc:	d0a0af15 	stw	r2,-32068(gp)
		device_pointer = dev;
811440e0:	e0bffe17 	ldw	r2,-8(fp)
811440e4:	d0a0b215 	stw	r2,-32056(gp)
		initialized = false;
811440e8:	d020a815 	stw	zero,-32096(gp)
		is_sd_card_formated_as_FAT16 = false;
811440ec:	d020a915 	stw	zero,-32092(gp)
		search_data.valid = false;
811440f0:	00a045f4 	movhi	r2,33047
811440f4:	10af9904 	addi	r2,r2,-16796
811440f8:	10000415 	stw	zero,16(r2)
	}
	return dev;
811440fc:	e0bffe17 	ldw	r2,-8(fp)
}
81144100:	e037883a 	mov	sp,fp
81144104:	dfc00117 	ldw	ra,4(sp)
81144108:	df000017 	ldw	fp,0(sp)
8114410c:	dec00204 	addi	sp,sp,8
81144110:	f800283a 	ret

81144114 <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
81144114:	defffd04 	addi	sp,sp,-12
81144118:	de00012e 	bgeu	sp,et,81144120 <alt_up_sd_card_is_Present+0xc>
8114411c:	003b68fa 	trap	3
81144120:	df000215 	stw	fp,8(sp)
81144124:	df000204 	addi	fp,sp,8
    bool result = false;
81144128:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
8114412c:	d0a0b217 	ldw	r2,-32056(gp)
81144130:	10000826 	beq	r2,zero,81144154 <alt_up_sd_card_is_Present+0x40>
81144134:	d0a0aa17 	ldw	r2,-32088(gp)
81144138:	1080002b 	ldhuio	r2,0(r2)
8114413c:	10bfffcc 	andi	r2,r2,65535
81144140:	1080008c 	andi	r2,r2,2
81144144:	10000326 	beq	r2,zero,81144154 <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
81144148:	00800044 	movi	r2,1
8114414c:	e0bffe15 	stw	r2,-8(fp)
81144150:	00001e06 	br	811441cc <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
81144154:	d0a0a817 	ldw	r2,-32096(gp)
81144158:	10800058 	cmpnei	r2,r2,1
8114415c:	10001b1e 	bne	r2,zero,811441cc <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
81144160:	d020a815 	stw	zero,-32096(gp)
		search_data.valid = false;
81144164:	00a045f4 	movhi	r2,33047
81144168:	10af9904 	addi	r2,r2,-16796
8114416c:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
81144170:	d020a915 	stw	zero,-32092(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
81144174:	e03fff15 	stw	zero,-4(fp)
81144178:	00001106 	br	811441c0 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
8114417c:	00a045f4 	movhi	r2,33047
81144180:	10afb304 	addi	r2,r2,-16692
81144184:	e0ffff17 	ldw	r3,-4(fp)
81144188:	180691ba 	slli	r3,r3,6
8114418c:	10c5883a 	add	r2,r2,r3
81144190:	10800f04 	addi	r2,r2,60
81144194:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
81144198:	00a045f4 	movhi	r2,33047
8114419c:	10afb304 	addi	r2,r2,-16692
811441a0:	e0ffff17 	ldw	r3,-4(fp)
811441a4:	180691ba 	slli	r3,r3,6
811441a8:	10c5883a 	add	r2,r2,r3
811441ac:	10800e04 	addi	r2,r2,56
811441b0:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
811441b4:	e0bfff17 	ldw	r2,-4(fp)
811441b8:	10800044 	addi	r2,r2,1
811441bc:	e0bfff15 	stw	r2,-4(fp)
811441c0:	e0bfff17 	ldw	r2,-4(fp)
811441c4:	10800510 	cmplti	r2,r2,20
811441c8:	103fec1e 	bne	r2,zero,8114417c <__reset+0xfb12417c>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
811441cc:	e0bffe17 	ldw	r2,-8(fp)
}
811441d0:	e037883a 	mov	sp,fp
811441d4:	df000017 	ldw	fp,0(sp)
811441d8:	dec00104 	addi	sp,sp,4
811441dc:	f800283a 	ret

811441e0 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
811441e0:	defffd04 	addi	sp,sp,-12
811441e4:	de00012e 	bgeu	sp,et,811441ec <alt_up_sd_card_is_FAT16+0xc>
811441e8:	003b68fa 	trap	3
811441ec:	dfc00215 	stw	ra,8(sp)
811441f0:	df000115 	stw	fp,4(sp)
811441f4:	df000104 	addi	fp,sp,4
	bool result = false;
811441f8:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
811441fc:	11441140 	call	81144114 <alt_up_sd_card_is_Present>
81144200:	10000c26 	beq	r2,zero,81144234 <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
81144204:	d0a0a817 	ldw	r2,-32096(gp)
81144208:	1000071e 	bne	r2,zero,81144228 <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
8114420c:	114240c0 	call	8114240c <Look_for_FAT16>
81144210:	d0a0a915 	stw	r2,-32092(gp)
			initialized = is_sd_card_formated_as_FAT16;
81144214:	d0a0a917 	ldw	r2,-32092(gp)
81144218:	d0a0a815 	stw	r2,-32096(gp)
			search_data.valid = false;
8114421c:	00a045f4 	movhi	r2,33047
81144220:	10af9904 	addi	r2,r2,-16796
81144224:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
81144228:	d0a0a917 	ldw	r2,-32092(gp)
8114422c:	e0bfff15 	stw	r2,-4(fp)
81144230:	00000206 	br	8114423c <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
81144234:	d020a815 	stw	zero,-32096(gp)
		is_sd_card_formated_as_FAT16 = false;
81144238:	d020a915 	stw	zero,-32092(gp)
	}

	return result;
8114423c:	e0bfff17 	ldw	r2,-4(fp)
}
81144240:	e037883a 	mov	sp,fp
81144244:	dfc00117 	ldw	ra,4(sp)
81144248:	df000017 	ldw	fp,0(sp)
8114424c:	dec00204 	addi	sp,sp,8
81144250:	f800283a 	ret

81144254 <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
81144254:	deffea04 	addi	sp,sp,-88
81144258:	de00012e 	bgeu	sp,et,81144260 <alt_up_sd_card_find_first+0xc>
8114425c:	003b68fa 	trap	3
81144260:	dfc01515 	stw	ra,84(sp)
81144264:	df001415 	stw	fp,80(sp)
81144268:	df001404 	addi	fp,sp,80
8114426c:	e13ffe15 	stw	r4,-8(fp)
81144270:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
81144274:	00800084 	movi	r2,2
81144278:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8114427c:	11441140 	call	81144114 <alt_up_sd_card_is_Present>
81144280:	10002426 	beq	r2,zero,81144314 <alt_up_sd_card_find_first+0xc0>
81144284:	d0a0a917 	ldw	r2,-32092(gp)
81144288:	10002226 	beq	r2,zero,81144314 <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
8114428c:	e0ffee04 	addi	r3,fp,-72
81144290:	e0bfed04 	addi	r2,fp,-76
81144294:	180d883a 	mov	r6,r3
81144298:	100b883a 	mov	r5,r2
8114429c:	e13ffe17 	ldw	r4,-8(fp)
811442a0:	1142ba40 	call	81142ba4 <get_home_directory_cluster_for_file>
811442a4:	10001926 	beq	r2,zero,8114430c <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
811442a8:	e0bfed17 	ldw	r2,-76(fp)
811442ac:	1007883a 	mov	r3,r2
811442b0:	00a045f4 	movhi	r2,33047
811442b4:	10af9904 	addi	r2,r2,-16796
811442b8:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
811442bc:	e0bfed17 	ldw	r2,-76(fp)
811442c0:	1007883a 	mov	r3,r2
811442c4:	00a045f4 	movhi	r2,33047
811442c8:	10af9904 	addi	r2,r2,-16796
811442cc:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
811442d0:	00a045f4 	movhi	r2,33047
811442d4:	10af9904 	addi	r2,r2,-16796
811442d8:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
811442dc:	00a045f4 	movhi	r2,33047
811442e0:	10af9904 	addi	r2,r2,-16796
811442e4:	00ffffc4 	movi	r3,-1
811442e8:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
811442ec:	00a045f4 	movhi	r2,33047
811442f0:	10af9904 	addi	r2,r2,-16796
811442f4:	00c00044 	movi	r3,1
811442f8:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
811442fc:	e13fff17 	ldw	r4,-4(fp)
81144300:	114432c0 	call	8114432c <alt_up_sd_card_find_next>
81144304:	e0bfec0d 	sth	r2,-80(fp)
81144308:	00000206 	br	81144314 <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
8114430c:	00800044 	movi	r2,1
81144310:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
81144314:	e0bfec0b 	ldhu	r2,-80(fp)
}
81144318:	e037883a 	mov	sp,fp
8114431c:	dfc00117 	ldw	ra,4(sp)
81144320:	df000017 	ldw	fp,0(sp)
81144324:	dec00204 	addi	sp,sp,8
81144328:	f800283a 	ret

8114432c <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
8114432c:	deffe404 	addi	sp,sp,-112
81144330:	de00012e 	bgeu	sp,et,81144338 <alt_up_sd_card_find_next+0xc>
81144334:	003b68fa 	trap	3
81144338:	dfc01b15 	stw	ra,108(sp)
8114433c:	df001a15 	stw	fp,104(sp)
81144340:	df001a04 	addi	fp,sp,104
81144344:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
81144348:	00800084 	movi	r2,2
8114434c:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81144350:	11441140 	call	81144114 <alt_up_sd_card_is_Present>
81144354:	1000df26 	beq	r2,zero,811446d4 <alt_up_sd_card_find_next+0x3a8>
81144358:	d0a0a917 	ldw	r2,-32092(gp)
8114435c:	1000dd26 	beq	r2,zero,811446d4 <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
81144360:	00a045f4 	movhi	r2,33047
81144364:	10af9904 	addi	r2,r2,-16796
81144368:	10800417 	ldw	r2,16(r2)
8114436c:	1000d726 	beq	r2,zero,811446cc <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
81144370:	00a045f4 	movhi	r2,33047
81144374:	10af9904 	addi	r2,r2,-16796
81144378:	10800117 	ldw	r2,4(r2)
8114437c:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
81144380:	e0bfe717 	ldw	r2,-100(fp)
81144384:	1000561e 	bne	r2,zero,811444e0 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81144388:	00a045f4 	movhi	r2,33047
8114438c:	10af9e04 	addi	r2,r2,-16776
81144390:	1080050b 	ldhu	r2,20(r2)
81144394:	10bfffcc 	andi	r2,r2,65535
81144398:	1006917a 	slli	r3,r2,5
8114439c:	00a045f4 	movhi	r2,33047
811443a0:	10af9e04 	addi	r2,r2,-16776
811443a4:	1080030b 	ldhu	r2,12(r2)
811443a8:	10bfffcc 	andi	r2,r2,65535
811443ac:	1885283a 	div	r2,r3,r2
811443b0:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
811443b4:	00a045f4 	movhi	r2,33047
811443b8:	10af9904 	addi	r2,r2,-16796
811443bc:	10800217 	ldw	r2,8(r2)
811443c0:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
811443c4:	00a045f4 	movhi	r2,33047
811443c8:	10af9904 	addi	r2,r2,-16796
811443cc:	1080030b 	ldhu	r2,12(r2)
811443d0:	10bfffcc 	andi	r2,r2,65535
811443d4:	10a0001c 	xori	r2,r2,32768
811443d8:	10a00004 	addi	r2,r2,-32768
811443dc:	10800044 	addi	r2,r2,1
811443e0:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
811443e4:	00003606 	br	811444c0 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
811443e8:	00a045f4 	movhi	r2,33047
811443ec:	10af9e04 	addi	r2,r2,-16776
811443f0:	10c01317 	ldw	r3,76(r2)
811443f4:	e0bfe817 	ldw	r2,-96(fp)
811443f8:	1885883a 	add	r2,r3,r2
811443fc:	1007883a 	mov	r3,r2
81144400:	d0a0b017 	ldw	r2,-32064(gp)
81144404:	100b883a 	mov	r5,r2
81144408:	1809883a 	mov	r4,r3
8114440c:	114143c0 	call	8114143c <Read_Sector_Data>
81144410:	10002f26 	beq	r2,zero,811444d0 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81144414:	00002306 	br	811444a4 <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
81144418:	e0bfe917 	ldw	r2,-92(fp)
8114441c:	1004917a 	slli	r2,r2,5
81144420:	e13fe817 	ldw	r4,-96(fp)
81144424:	e0ffef04 	addi	r3,fp,-68
81144428:	200f883a 	mov	r7,r4
8114442c:	000d883a 	mov	r6,zero
81144430:	180b883a 	mov	r5,r3
81144434:	1009883a 	mov	r4,r2
81144438:	114186c0 	call	8114186c <Read_File_Record_At_Offset>
8114443c:	10001626 	beq	r2,zero,81144498 <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81144440:	e0bfef03 	ldbu	r2,-68(fp)
81144444:	10803fcc 	andi	r2,r2,255
81144448:	10001326 	beq	r2,zero,81144498 <alt_up_sd_card_find_next+0x16c>
8114444c:	e0bfef03 	ldbu	r2,-68(fp)
81144450:	10803fcc 	andi	r2,r2,255
81144454:	10803960 	cmpeqi	r2,r2,229
81144458:	10000f1e 	bne	r2,zero,81144498 <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
8114445c:	e0bfe917 	ldw	r2,-92(fp)
81144460:	1007883a 	mov	r3,r2
81144464:	00a045f4 	movhi	r2,33047
81144468:	10af9904 	addi	r2,r2,-16796
8114446c:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
81144470:	e0ffe817 	ldw	r3,-96(fp)
81144474:	00a045f4 	movhi	r2,33047
81144478:	10af9904 	addi	r2,r2,-16796
8114447c:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
81144480:	e0bfef04 	addi	r2,fp,-68
81144484:	e17fff17 	ldw	r5,-4(fp)
81144488:	1009883a 	mov	r4,r2
8114448c:	1143f000 	call	81143f00 <copy_file_record_name_to_string>
									return 0;
81144490:	0005883a 	mov	r2,zero
81144494:	00009006 	br	811446d8 <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81144498:	e0bfe917 	ldw	r2,-92(fp)
8114449c:	10800044 	addi	r2,r2,1
811444a0:	e0bfe915 	stw	r2,-92(fp)
811444a4:	e0bfe917 	ldw	r2,-92(fp)
811444a8:	10800410 	cmplti	r2,r2,16
811444ac:	103fda1e 	bne	r2,zero,81144418 <__reset+0xfb124418>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
811444b0:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
811444b4:	e0bfe817 	ldw	r2,-96(fp)
811444b8:	10800044 	addi	r2,r2,1
811444bc:	e0bfe815 	stw	r2,-96(fp)
811444c0:	e0ffe817 	ldw	r3,-96(fp)
811444c4:	e0bfec17 	ldw	r2,-80(fp)
811444c8:	18bfc716 	blt	r3,r2,811443e8 <__reset+0xfb1243e8>
811444cc:	00000106 	br	811444d4 <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
811444d0:	0001883a 	nop
					}
				}
				result = -1;
811444d4:	00bfffc4 	movi	r2,-1
811444d8:	e0bfe60d 	sth	r2,-104(fp)
811444dc:	00007d06 	br	811446d4 <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
811444e0:	00a045f4 	movhi	r2,33047
811444e4:	10af9904 	addi	r2,r2,-16796
811444e8:	1080030b 	ldhu	r2,12(r2)
811444ec:	10bfffcc 	andi	r2,r2,65535
811444f0:	10a0001c 	xori	r2,r2,32768
811444f4:	10a00004 	addi	r2,r2,-32768
811444f8:	10800044 	addi	r2,r2,1
811444fc:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81144500:	e0bfe717 	ldw	r2,-100(fp)
81144504:	10ffff84 	addi	r3,r2,-2
81144508:	00a045f4 	movhi	r2,33047
8114450c:	10af9e04 	addi	r2,r2,-16776
81144510:	10800383 	ldbu	r2,14(r2)
81144514:	10803fcc 	andi	r2,r2,255
81144518:	1885383a 	mul	r2,r3,r2
8114451c:	1007883a 	mov	r3,r2
81144520:	00a045f4 	movhi	r2,33047
81144524:	10af9e04 	addi	r2,r2,-16776
81144528:	10801417 	ldw	r2,80(r2)
8114452c:	1885883a 	add	r2,r3,r2
81144530:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
81144534:	00a045f4 	movhi	r2,33047
81144538:	10af9904 	addi	r2,r2,-16796
8114453c:	10800217 	ldw	r2,8(r2)
81144540:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81144544:	00003806 	br	81144628 <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81144548:	e0ffeb17 	ldw	r3,-84(fp)
8114454c:	e0bfed17 	ldw	r2,-76(fp)
81144550:	1885883a 	add	r2,r3,r2
81144554:	d0e0b017 	ldw	r3,-32064(gp)
81144558:	180b883a 	mov	r5,r3
8114455c:	1009883a 	mov	r4,r2
81144560:	114143c0 	call	8114143c <Read_Sector_Data>
81144564:	10003726 	beq	r2,zero,81144644 <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
81144568:	00002806 	br	8114460c <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
8114456c:	e0bfea17 	ldw	r2,-88(fp)
81144570:	1004917a 	slli	r2,r2,5
81144574:	e13fe717 	ldw	r4,-100(fp)
81144578:	e17feb17 	ldw	r5,-84(fp)
8114457c:	e0ffef04 	addi	r3,fp,-68
81144580:	280f883a 	mov	r7,r5
81144584:	200d883a 	mov	r6,r4
81144588:	180b883a 	mov	r5,r3
8114458c:	1009883a 	mov	r4,r2
81144590:	114186c0 	call	8114186c <Read_File_Record_At_Offset>
81144594:	10001a26 	beq	r2,zero,81144600 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81144598:	e0bfef03 	ldbu	r2,-68(fp)
8114459c:	10803fcc 	andi	r2,r2,255
811445a0:	10001726 	beq	r2,zero,81144600 <alt_up_sd_card_find_next+0x2d4>
811445a4:	e0bfef03 	ldbu	r2,-68(fp)
811445a8:	10803fcc 	andi	r2,r2,255
811445ac:	10803960 	cmpeqi	r2,r2,229
811445b0:	1000131e 	bne	r2,zero,81144600 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
811445b4:	e0ffe717 	ldw	r3,-100(fp)
811445b8:	00a045f4 	movhi	r2,33047
811445bc:	10af9904 	addi	r2,r2,-16796
811445c0:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
811445c4:	e0bfea17 	ldw	r2,-88(fp)
811445c8:	1007883a 	mov	r3,r2
811445cc:	00a045f4 	movhi	r2,33047
811445d0:	10af9904 	addi	r2,r2,-16796
811445d4:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
811445d8:	e0ffeb17 	ldw	r3,-84(fp)
811445dc:	00a045f4 	movhi	r2,33047
811445e0:	10af9904 	addi	r2,r2,-16796
811445e4:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
811445e8:	e0bfef04 	addi	r2,fp,-68
811445ec:	e17fff17 	ldw	r5,-4(fp)
811445f0:	1009883a 	mov	r4,r2
811445f4:	1143f000 	call	81143f00 <copy_file_record_name_to_string>
										return 0;
811445f8:	0005883a 	mov	r2,zero
811445fc:	00003606 	br	811446d8 <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
81144600:	e0bfea17 	ldw	r2,-88(fp)
81144604:	10800044 	addi	r2,r2,1
81144608:	e0bfea15 	stw	r2,-88(fp)
8114460c:	e0bfea17 	ldw	r2,-88(fp)
81144610:	10800410 	cmplti	r2,r2,16
81144614:	103fd51e 	bne	r2,zero,8114456c <__reset+0xfb12456c>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
81144618:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8114461c:	e0bfeb17 	ldw	r2,-84(fp)
81144620:	10800044 	addi	r2,r2,1
81144624:	e0bfeb15 	stw	r2,-84(fp)
81144628:	00a045f4 	movhi	r2,33047
8114462c:	10af9e04 	addi	r2,r2,-16776
81144630:	10800383 	ldbu	r2,14(r2)
81144634:	10803fcc 	andi	r2,r2,255
81144638:	e0ffeb17 	ldw	r3,-84(fp)
8114463c:	18bfc216 	blt	r3,r2,81144548 <__reset+0xfb124548>
81144640:	00000106 	br	81144648 <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
81144644:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
81144648:	00a045f4 	movhi	r2,33047
8114464c:	10af9e04 	addi	r2,r2,-16776
81144650:	10800383 	ldbu	r2,14(r2)
81144654:	10803fcc 	andi	r2,r2,255
81144658:	e0ffeb17 	ldw	r3,-84(fp)
8114465c:	18801716 	blt	r3,r2,811446bc <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
81144660:	e0bfe717 	ldw	r2,-100(fp)
81144664:	e0ffee04 	addi	r3,fp,-72
81144668:	180b883a 	mov	r5,r3
8114466c:	1009883a 	mov	r4,r2
81144670:	114151c0 	call	8114151c <get_cluster_flag>
81144674:	10000f26 	beq	r2,zero,811446b4 <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81144678:	e0bfee0b 	ldhu	r2,-72(fp)
8114467c:	10bfffcc 	andi	r2,r2,65535
81144680:	10fffe0c 	andi	r3,r2,65528
81144684:	00bffe14 	movui	r2,65528
81144688:	1880051e 	bne	r3,r2,811446a0 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
8114468c:	00bfffc4 	movi	r2,-1
81144690:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
81144694:	00a045f4 	movhi	r2,33047
81144698:	10af9904 	addi	r2,r2,-16796
8114469c:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
811446a0:	e0bfee0b 	ldhu	r2,-72(fp)
811446a4:	10bfffcc 	andi	r2,r2,65535
811446a8:	10bffe0c 	andi	r2,r2,65528
811446ac:	e0bfe715 	stw	r2,-100(fp)
811446b0:	00000206 	br	811446bc <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
811446b4:	00bfffc4 	movi	r2,-1
811446b8:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
811446bc:	e0bfe717 	ldw	r2,-100(fp)
811446c0:	00fffdd4 	movui	r3,65527
811446c4:	18bf8e0e 	bge	r3,r2,81144500 <__reset+0xfb124500>
811446c8:	00000206 	br	811446d4 <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
811446cc:	008000c4 	movi	r2,3
811446d0:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
811446d4:	e0bfe60b 	ldhu	r2,-104(fp)
}
811446d8:	e037883a 	mov	sp,fp
811446dc:	dfc00117 	ldw	ra,4(sp)
811446e0:	df000017 	ldw	fp,0(sp)
811446e4:	dec00204 	addi	sp,sp,8
811446e8:	f800283a 	ret

811446ec <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
811446ec:	deffe904 	addi	sp,sp,-92
811446f0:	de00012e 	bgeu	sp,et,811446f8 <alt_up_sd_card_fopen+0xc>
811446f4:	003b68fa 	trap	3
811446f8:	dfc01615 	stw	ra,88(sp)
811446fc:	df001515 	stw	fp,84(sp)
81144700:	df001504 	addi	fp,sp,84
81144704:	e13ffe15 	stw	r4,-8(fp)
81144708:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
8114470c:	00bfffc4 	movi	r2,-1
81144710:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81144714:	11441140 	call	81144114 <alt_up_sd_card_is_Present>
81144718:	1000cf26 	beq	r2,zero,81144a58 <alt_up_sd_card_fopen+0x36c>
8114471c:	d0a0a917 	ldw	r2,-32092(gp)
81144720:	1000cd26 	beq	r2,zero,81144a58 <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
81144724:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
81144728:	e13ffe17 	ldw	r4,-8(fp)
8114472c:	11425000 	call	81142500 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
81144730:	e13ffe17 	ldw	r4,-8(fp)
81144734:	11425cc0 	call	811425cc <check_file_name_for_FAT16_compliance>
81144738:	1000c726 	beq	r2,zero,81144a58 <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
8114473c:	e0ffee04 	addi	r3,fp,-72
81144740:	e0bfed04 	addi	r2,fp,-76
81144744:	180d883a 	mov	r6,r3
81144748:	100b883a 	mov	r5,r2
8114474c:	e13ffe17 	ldw	r4,-8(fp)
81144750:	1142ba40 	call	81142ba4 <get_home_directory_cluster_for_file>
81144754:	1000021e 	bne	r2,zero,81144760 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
81144758:	e0bfeb0b 	ldhu	r2,-84(fp)
8114475c:	0000bf06 	br	81144a5c <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
81144760:	e03fec15 	stw	zero,-80(fp)
81144764:	00000e06 	br	811447a0 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
81144768:	00a045f4 	movhi	r2,33047
8114476c:	10afb304 	addi	r2,r2,-16692
81144770:	e0ffec17 	ldw	r3,-80(fp)
81144774:	180691ba 	slli	r3,r3,6
81144778:	10c5883a 	add	r2,r2,r3
8114477c:	10800f04 	addi	r2,r2,60
81144780:	10800017 	ldw	r2,0(r2)
81144784:	1000031e 	bne	r2,zero,81144794 <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
81144788:	e0bfec17 	ldw	r2,-80(fp)
8114478c:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
81144790:	00000606 	br	811447ac <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
81144794:	e0bfec17 	ldw	r2,-80(fp)
81144798:	10800044 	addi	r2,r2,1
8114479c:	e0bfec15 	stw	r2,-80(fp)
811447a0:	e0bfec17 	ldw	r2,-80(fp)
811447a4:	10800510 	cmplti	r2,r2,20
811447a8:	103fef1e 	bne	r2,zero,81144768 <__reset+0xfb124768>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
811447ac:	e0bfeb0f 	ldh	r2,-84(fp)
811447b0:	1000a916 	blt	r2,zero,81144a58 <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
811447b4:	e0bfed17 	ldw	r2,-76(fp)
811447b8:	1009883a 	mov	r4,r2
811447bc:	e0bfeb0f 	ldh	r2,-84(fp)
811447c0:	100691ba 	slli	r3,r2,6
811447c4:	00a045f4 	movhi	r2,33047
811447c8:	10afb304 	addi	r2,r2,-16692
811447cc:	1885883a 	add	r2,r3,r2
811447d0:	100d883a 	mov	r6,r2
811447d4:	e17ffe17 	ldw	r5,-8(fp)
811447d8:	11430e40 	call	811430e4 <find_file_in_directory>
811447dc:	10007b26 	beq	r2,zero,811449cc <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
811447e0:	e0bfff17 	ldw	r2,-4(fp)
811447e4:	10000226 	beq	r2,zero,811447f0 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
811447e8:	00bfffc4 	movi	r2,-1
811447ec:	00009b06 	br	81144a5c <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
811447f0:	e13feb0f 	ldh	r4,-84(fp)
811447f4:	e0ffeb0f 	ldh	r3,-84(fp)
811447f8:	00a045f4 	movhi	r2,33047
811447fc:	10afb304 	addi	r2,r2,-16692
81144800:	180691ba 	slli	r3,r3,6
81144804:	10c5883a 	add	r2,r2,r3
81144808:	10800584 	addi	r2,r2,22
8114480c:	1080000b 	ldhu	r2,0(r2)
81144810:	10ffffcc 	andi	r3,r2,65535
81144814:	00a045f4 	movhi	r2,33047
81144818:	10afb304 	addi	r2,r2,-16692
8114481c:	200891ba 	slli	r4,r4,6
81144820:	1105883a 	add	r2,r2,r4
81144824:	10800704 	addi	r2,r2,28
81144828:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
8114482c:	e0ffeb0f 	ldh	r3,-84(fp)
81144830:	00a045f4 	movhi	r2,33047
81144834:	10afb304 	addi	r2,r2,-16692
81144838:	180691ba 	slli	r3,r3,6
8114483c:	10c5883a 	add	r2,r2,r3
81144840:	10800804 	addi	r2,r2,32
81144844:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
81144848:	e0ffeb0f 	ldh	r3,-84(fp)
8114484c:	00a045f4 	movhi	r2,33047
81144850:	10afb304 	addi	r2,r2,-16692
81144854:	180691ba 	slli	r3,r3,6
81144858:	10c5883a 	add	r2,r2,r3
8114485c:	10800904 	addi	r2,r2,36
81144860:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
81144864:	e0ffeb0f 	ldh	r3,-84(fp)
81144868:	00a045f4 	movhi	r2,33047
8114486c:	10afb304 	addi	r2,r2,-16692
81144870:	180691ba 	slli	r3,r3,6
81144874:	10c5883a 	add	r2,r2,r3
81144878:	10800f04 	addi	r2,r2,60
8114487c:	00c00044 	movi	r3,1
81144880:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
81144884:	e0ffeb0f 	ldh	r3,-84(fp)
81144888:	00a045f4 	movhi	r2,33047
8114488c:	10afb304 	addi	r2,r2,-16692
81144890:	180691ba 	slli	r3,r3,6
81144894:	10c5883a 	add	r2,r2,r3
81144898:	10800e04 	addi	r2,r2,56
8114489c:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
811448a0:	e03fec15 	stw	zero,-80(fp)
811448a4:	00004506 	br	811449bc <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
811448a8:	e0ffeb0f 	ldh	r3,-84(fp)
811448ac:	e0bfec17 	ldw	r2,-80(fp)
811448b0:	18803f26 	beq	r3,r2,811449b0 <alt_up_sd_card_fopen+0x2c4>
811448b4:	00a045f4 	movhi	r2,33047
811448b8:	10afb304 	addi	r2,r2,-16692
811448bc:	e0ffec17 	ldw	r3,-80(fp)
811448c0:	180691ba 	slli	r3,r3,6
811448c4:	10c5883a 	add	r2,r2,r3
811448c8:	10800f04 	addi	r2,r2,60
811448cc:	10800017 	ldw	r2,0(r2)
811448d0:	10800058 	cmpnei	r2,r2,1
811448d4:	1000361e 	bne	r2,zero,811449b0 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
811448d8:	e0ffeb0f 	ldh	r3,-84(fp)
811448dc:	00a045f4 	movhi	r2,33047
811448e0:	10afb304 	addi	r2,r2,-16692
811448e4:	180691ba 	slli	r3,r3,6
811448e8:	10c5883a 	add	r2,r2,r3
811448ec:	10800a04 	addi	r2,r2,40
811448f0:	10c00017 	ldw	r3,0(r2)
811448f4:	00a045f4 	movhi	r2,33047
811448f8:	10afb304 	addi	r2,r2,-16692
811448fc:	e13fec17 	ldw	r4,-80(fp)
81144900:	200891ba 	slli	r4,r4,6
81144904:	1105883a 	add	r2,r2,r4
81144908:	10800a04 	addi	r2,r2,40
8114490c:	10800017 	ldw	r2,0(r2)
81144910:	1880271e 	bne	r3,r2,811449b0 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81144914:	e0ffeb0f 	ldh	r3,-84(fp)
81144918:	00a045f4 	movhi	r2,33047
8114491c:	10afb304 	addi	r2,r2,-16692
81144920:	180691ba 	slli	r3,r3,6
81144924:	10c5883a 	add	r2,r2,r3
81144928:	10800b04 	addi	r2,r2,44
8114492c:	10c00017 	ldw	r3,0(r2)
81144930:	00a045f4 	movhi	r2,33047
81144934:	10afb304 	addi	r2,r2,-16692
81144938:	e13fec17 	ldw	r4,-80(fp)
8114493c:	200891ba 	slli	r4,r4,6
81144940:	1105883a 	add	r2,r2,r4
81144944:	10800b04 	addi	r2,r2,44
81144948:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
8114494c:	1880181e 	bne	r3,r2,811449b0 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
81144950:	e0ffeb0f 	ldh	r3,-84(fp)
81144954:	00a045f4 	movhi	r2,33047
81144958:	10afb304 	addi	r2,r2,-16692
8114495c:	180691ba 	slli	r3,r3,6
81144960:	10c5883a 	add	r2,r2,r3
81144964:	10800c04 	addi	r2,r2,48
81144968:	1100000b 	ldhu	r4,0(r2)
8114496c:	00a045f4 	movhi	r2,33047
81144970:	10afb304 	addi	r2,r2,-16692
81144974:	e0ffec17 	ldw	r3,-80(fp)
81144978:	180691ba 	slli	r3,r3,6
8114497c:	10c5883a 	add	r2,r2,r3
81144980:	10800c04 	addi	r2,r2,48
81144984:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81144988:	20ffffcc 	andi	r3,r4,65535
8114498c:	18e0001c 	xori	r3,r3,32768
81144990:	18e00004 	addi	r3,r3,-32768
81144994:	10bfffcc 	andi	r2,r2,65535
81144998:	10a0001c 	xori	r2,r2,32768
8114499c:	10a00004 	addi	r2,r2,-32768
811449a0:	1880031e 	bne	r3,r2,811449b0 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
811449a4:	00bfff84 	movi	r2,-2
811449a8:	e0bfeb0d 	sth	r2,-84(fp)
								break;
811449ac:	00002a06 	br	81144a58 <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
811449b0:	e0bfec17 	ldw	r2,-80(fp)
811449b4:	10800044 	addi	r2,r2,1
811449b8:	e0bfec15 	stw	r2,-80(fp)
811449bc:	e0bfec17 	ldw	r2,-80(fp)
811449c0:	10800510 	cmplti	r2,r2,20
811449c4:	103fb81e 	bne	r2,zero,811448a8 <__reset+0xfb1248a8>
811449c8:	00002306 	br	81144a58 <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
811449cc:	e0bfff17 	ldw	r2,-4(fp)
811449d0:	10001f26 	beq	r2,zero,81144a50 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
811449d4:	e0bfeb0f 	ldh	r2,-84(fp)
811449d8:	100691ba 	slli	r3,r2,6
811449dc:	00a045f4 	movhi	r2,33047
811449e0:	10afb304 	addi	r2,r2,-16692
811449e4:	1885883a 	add	r2,r3,r2
811449e8:	e0ffee04 	addi	r3,fp,-72
811449ec:	180d883a 	mov	r6,r3
811449f0:	100b883a 	mov	r5,r2
811449f4:	e13ffe17 	ldw	r4,-8(fp)
811449f8:	1143c300 	call	81143c30 <create_file>
811449fc:	10001126 	beq	r2,zero,81144a44 <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
81144a00:	e0ffeb0f 	ldh	r3,-84(fp)
81144a04:	00a045f4 	movhi	r2,33047
81144a08:	10afb304 	addi	r2,r2,-16692
81144a0c:	180691ba 	slli	r3,r3,6
81144a10:	10c5883a 	add	r2,r2,r3
81144a14:	10800f04 	addi	r2,r2,60
81144a18:	00c00044 	movi	r3,1
81144a1c:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
81144a20:	e0ffeb0f 	ldh	r3,-84(fp)
81144a24:	00a045f4 	movhi	r2,33047
81144a28:	10afb304 	addi	r2,r2,-16692
81144a2c:	180691ba 	slli	r3,r3,6
81144a30:	10c5883a 	add	r2,r2,r3
81144a34:	10800e04 	addi	r2,r2,56
81144a38:	00c00044 	movi	r3,1
81144a3c:	10c00015 	stw	r3,0(r2)
81144a40:	00000506 	br	81144a58 <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
81144a44:	00bfffc4 	movi	r2,-1
81144a48:	e0bfeb0d 	sth	r2,-84(fp)
81144a4c:	00000206 	br	81144a58 <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
81144a50:	00bfffc4 	movi	r2,-1
81144a54:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
81144a58:	e0bfeb0b 	ldhu	r2,-84(fp)
}
81144a5c:	e037883a 	mov	sp,fp
81144a60:	dfc00117 	ldw	ra,4(sp)
81144a64:	df000017 	ldw	fp,0(sp)
81144a68:	dec00204 	addi	sp,sp,8
81144a6c:	f800283a 	ret

81144a70 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81144a70:	defffd04 	addi	sp,sp,-12
81144a74:	de00012e 	bgeu	sp,et,81144a7c <alt_up_sd_card_set_attributes+0xc>
81144a78:	003b68fa 	trap	3
81144a7c:	df000215 	stw	fp,8(sp)
81144a80:	df000204 	addi	fp,sp,8
81144a84:	2007883a 	mov	r3,r4
81144a88:	2805883a 	mov	r2,r5
81144a8c:	e0fffe0d 	sth	r3,-8(fp)
81144a90:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81144a94:	e0bffe0f 	ldh	r2,-8(fp)
81144a98:	10001416 	blt	r2,zero,81144aec <alt_up_sd_card_set_attributes+0x7c>
81144a9c:	e0bffe0f 	ldh	r2,-8(fp)
81144aa0:	10800508 	cmpgei	r2,r2,20
81144aa4:	1000111e 	bne	r2,zero,81144aec <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
81144aa8:	e0fffe0f 	ldh	r3,-8(fp)
81144aac:	00a045f4 	movhi	r2,33047
81144ab0:	10afb304 	addi	r2,r2,-16692
81144ab4:	180691ba 	slli	r3,r3,6
81144ab8:	10c5883a 	add	r2,r2,r3
81144abc:	10800f04 	addi	r2,r2,60
81144ac0:	10800017 	ldw	r2,0(r2)
81144ac4:	10000926 	beq	r2,zero,81144aec <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
81144ac8:	e0fffe0f 	ldh	r3,-8(fp)
81144acc:	e0bfff0b 	ldhu	r2,-4(fp)
81144ad0:	1009883a 	mov	r4,r2
81144ad4:	00a045f4 	movhi	r2,33047
81144ad8:	10afb304 	addi	r2,r2,-16692
81144adc:	180691ba 	slli	r3,r3,6
81144ae0:	10c5883a 	add	r2,r2,r3
81144ae4:	108002c4 	addi	r2,r2,11
81144ae8:	11000005 	stb	r4,0(r2)
        }
    }
}
81144aec:	0001883a 	nop
81144af0:	e037883a 	mov	sp,fp
81144af4:	df000017 	ldw	fp,0(sp)
81144af8:	dec00104 	addi	sp,sp,4
81144afc:	f800283a 	ret

81144b00 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81144b00:	defffd04 	addi	sp,sp,-12
81144b04:	de00012e 	bgeu	sp,et,81144b0c <alt_up_sd_card_get_attributes+0xc>
81144b08:	003b68fa 	trap	3
81144b0c:	df000215 	stw	fp,8(sp)
81144b10:	df000204 	addi	fp,sp,8
81144b14:	2005883a 	mov	r2,r4
81144b18:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
81144b1c:	00bfffc4 	movi	r2,-1
81144b20:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81144b24:	e0bfff0f 	ldh	r2,-4(fp)
81144b28:	10001416 	blt	r2,zero,81144b7c <alt_up_sd_card_get_attributes+0x7c>
81144b2c:	e0bfff0f 	ldh	r2,-4(fp)
81144b30:	10800508 	cmpgei	r2,r2,20
81144b34:	1000111e 	bne	r2,zero,81144b7c <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
81144b38:	e0ffff0f 	ldh	r3,-4(fp)
81144b3c:	00a045f4 	movhi	r2,33047
81144b40:	10afb304 	addi	r2,r2,-16692
81144b44:	180691ba 	slli	r3,r3,6
81144b48:	10c5883a 	add	r2,r2,r3
81144b4c:	10800f04 	addi	r2,r2,60
81144b50:	10800017 	ldw	r2,0(r2)
81144b54:	10000926 	beq	r2,zero,81144b7c <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
81144b58:	e0ffff0f 	ldh	r3,-4(fp)
81144b5c:	00a045f4 	movhi	r2,33047
81144b60:	10afb304 	addi	r2,r2,-16692
81144b64:	180691ba 	slli	r3,r3,6
81144b68:	10c5883a 	add	r2,r2,r3
81144b6c:	108002c4 	addi	r2,r2,11
81144b70:	10800003 	ldbu	r2,0(r2)
81144b74:	10803fcc 	andi	r2,r2,255
81144b78:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
81144b7c:	e0bffe0b 	ldhu	r2,-8(fp)
}
81144b80:	e037883a 	mov	sp,fp
81144b84:	df000017 	ldw	fp,0(sp)
81144b88:	dec00104 	addi	sp,sp,4
81144b8c:	f800283a 	ret

81144b90 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
81144b90:	defffa04 	addi	sp,sp,-24
81144b94:	de00012e 	bgeu	sp,et,81144b9c <alt_up_sd_card_read+0xc>
81144b98:	003b68fa 	trap	3
81144b9c:	dfc00515 	stw	ra,20(sp)
81144ba0:	df000415 	stw	fp,16(sp)
81144ba4:	df000404 	addi	fp,sp,16
81144ba8:	2005883a 	mov	r2,r4
81144bac:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
81144bb0:	00bfffc4 	movi	r2,-1
81144bb4:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81144bb8:	e0bfff0f 	ldh	r2,-4(fp)
81144bbc:	1000ce16 	blt	r2,zero,81144ef8 <alt_up_sd_card_read+0x368>
81144bc0:	e0bfff0f 	ldh	r2,-4(fp)
81144bc4:	10800508 	cmpgei	r2,r2,20
81144bc8:	1000cb1e 	bne	r2,zero,81144ef8 <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
81144bcc:	e0ffff0f 	ldh	r3,-4(fp)
81144bd0:	00a045f4 	movhi	r2,33047
81144bd4:	10afb304 	addi	r2,r2,-16692
81144bd8:	180691ba 	slli	r3,r3,6
81144bdc:	10c5883a 	add	r2,r2,r3
81144be0:	10800f04 	addi	r2,r2,60
81144be4:	10800017 	ldw	r2,0(r2)
81144be8:	1000c326 	beq	r2,zero,81144ef8 <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81144bec:	e0ffff0f 	ldh	r3,-4(fp)
81144bf0:	00a045f4 	movhi	r2,33047
81144bf4:	10afb304 	addi	r2,r2,-16692
81144bf8:	180691ba 	slli	r3,r3,6
81144bfc:	10c5883a 	add	r2,r2,r3
81144c00:	10800904 	addi	r2,r2,36
81144c04:	10c00017 	ldw	r3,0(r2)
81144c08:	e13fff0f 	ldh	r4,-4(fp)
81144c0c:	00a045f4 	movhi	r2,33047
81144c10:	10afb304 	addi	r2,r2,-16692
81144c14:	200891ba 	slli	r4,r4,6
81144c18:	1105883a 	add	r2,r2,r4
81144c1c:	10800604 	addi	r2,r2,24
81144c20:	10800017 	ldw	r2,0(r2)
81144c24:	1880b42e 	bgeu	r3,r2,81144ef8 <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81144c28:	00a045f4 	movhi	r2,33047
81144c2c:	10af9e04 	addi	r2,r2,-16776
81144c30:	10c01417 	ldw	r3,80(r2)
81144c34:	e13fff0f 	ldh	r4,-4(fp)
81144c38:	00a045f4 	movhi	r2,33047
81144c3c:	10afb304 	addi	r2,r2,-16692
81144c40:	200891ba 	slli	r4,r4,6
81144c44:	1105883a 	add	r2,r2,r4
81144c48:	10800704 	addi	r2,r2,28
81144c4c:	10800017 	ldw	r2,0(r2)
81144c50:	113fff84 	addi	r4,r2,-2
81144c54:	00a045f4 	movhi	r2,33047
81144c58:	10af9e04 	addi	r2,r2,-16776
81144c5c:	10800383 	ldbu	r2,14(r2)
81144c60:	10803fcc 	andi	r2,r2,255
81144c64:	2085383a 	mul	r2,r4,r2
81144c68:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
81144c6c:	e13fff0f 	ldh	r4,-4(fp)
81144c70:	00a045f4 	movhi	r2,33047
81144c74:	10afb304 	addi	r2,r2,-16692
81144c78:	200891ba 	slli	r4,r4,6
81144c7c:	1105883a 	add	r2,r2,r4
81144c80:	10800804 	addi	r2,r2,32
81144c84:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81144c88:	1885883a 	add	r2,r3,r2
81144c8c:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
81144c90:	e0ffff0f 	ldh	r3,-4(fp)
81144c94:	00a045f4 	movhi	r2,33047
81144c98:	10afb304 	addi	r2,r2,-16692
81144c9c:	180691ba 	slli	r3,r3,6
81144ca0:	10c5883a 	add	r2,r2,r3
81144ca4:	10800904 	addi	r2,r2,36
81144ca8:	10800017 	ldw	r2,0(r2)
81144cac:	10006826 	beq	r2,zero,81144e50 <alt_up_sd_card_read+0x2c0>
81144cb0:	e0ffff0f 	ldh	r3,-4(fp)
81144cb4:	00a045f4 	movhi	r2,33047
81144cb8:	10afb304 	addi	r2,r2,-16692
81144cbc:	180691ba 	slli	r3,r3,6
81144cc0:	10c5883a 	add	r2,r2,r3
81144cc4:	10800904 	addi	r2,r2,36
81144cc8:	10800017 	ldw	r2,0(r2)
81144ccc:	10807fcc 	andi	r2,r2,511
81144cd0:	10005f1e 	bne	r2,zero,81144e50 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81144cd4:	e0ffff0f 	ldh	r3,-4(fp)
81144cd8:	00a045f4 	movhi	r2,33047
81144cdc:	10afb304 	addi	r2,r2,-16692
81144ce0:	180691ba 	slli	r3,r3,6
81144ce4:	10c5883a 	add	r2,r2,r3
81144ce8:	10800804 	addi	r2,r2,32
81144cec:	10c00017 	ldw	r3,0(r2)
81144cf0:	00a045f4 	movhi	r2,33047
81144cf4:	10af9e04 	addi	r2,r2,-16776
81144cf8:	10800383 	ldbu	r2,14(r2)
81144cfc:	10803fcc 	andi	r2,r2,255
81144d00:	10bfffc4 	addi	r2,r2,-1
81144d04:	1880401e 	bne	r3,r2,81144e08 <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81144d08:	e0ffff0f 	ldh	r3,-4(fp)
81144d0c:	00a045f4 	movhi	r2,33047
81144d10:	10afb304 	addi	r2,r2,-16692
81144d14:	180691ba 	slli	r3,r3,6
81144d18:	10c5883a 	add	r2,r2,r3
81144d1c:	10800704 	addi	r2,r2,28
81144d20:	10800017 	ldw	r2,0(r2)
81144d24:	e0fffe04 	addi	r3,fp,-8
81144d28:	180b883a 	mov	r5,r3
81144d2c:	1009883a 	mov	r4,r2
81144d30:	114151c0 	call	8114151c <get_cluster_flag>
81144d34:	10003226 	beq	r2,zero,81144e00 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81144d38:	e0bffe0b 	ldhu	r2,-8(fp)
81144d3c:	10bfffcc 	andi	r2,r2,65535
81144d40:	10fffe0c 	andi	r3,r2,65528
81144d44:	00bffe14 	movui	r2,65528
81144d48:	1880021e 	bne	r3,r2,81144d54 <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
81144d4c:	00bfffc4 	movi	r2,-1
81144d50:	00006a06 	br	81144efc <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81144d54:	e13fff0f 	ldh	r4,-4(fp)
81144d58:	e0bffe0b 	ldhu	r2,-8(fp)
81144d5c:	10ffffcc 	andi	r3,r2,65535
81144d60:	00a045f4 	movhi	r2,33047
81144d64:	10afb304 	addi	r2,r2,-16692
81144d68:	200891ba 	slli	r4,r4,6
81144d6c:	1105883a 	add	r2,r2,r4
81144d70:	10800704 	addi	r2,r2,28
81144d74:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81144d78:	e0ffff0f 	ldh	r3,-4(fp)
81144d7c:	00a045f4 	movhi	r2,33047
81144d80:	10afb304 	addi	r2,r2,-16692
81144d84:	180691ba 	slli	r3,r3,6
81144d88:	10c5883a 	add	r2,r2,r3
81144d8c:	10800804 	addi	r2,r2,32
81144d90:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81144d94:	00a045f4 	movhi	r2,33047
81144d98:	10af9e04 	addi	r2,r2,-16776
81144d9c:	10c01417 	ldw	r3,80(r2)
81144da0:	e13fff0f 	ldh	r4,-4(fp)
81144da4:	00a045f4 	movhi	r2,33047
81144da8:	10afb304 	addi	r2,r2,-16692
81144dac:	200891ba 	slli	r4,r4,6
81144db0:	1105883a 	add	r2,r2,r4
81144db4:	10800704 	addi	r2,r2,28
81144db8:	10800017 	ldw	r2,0(r2)
81144dbc:	113fff84 	addi	r4,r2,-2
81144dc0:	00a045f4 	movhi	r2,33047
81144dc4:	10af9e04 	addi	r2,r2,-16776
81144dc8:	10800383 	ldbu	r2,14(r2)
81144dcc:	10803fcc 	andi	r2,r2,255
81144dd0:	2085383a 	mul	r2,r4,r2
81144dd4:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81144dd8:	e13fff0f 	ldh	r4,-4(fp)
81144ddc:	00a045f4 	movhi	r2,33047
81144de0:	10afb304 	addi	r2,r2,-16692
81144de4:	200891ba 	slli	r4,r4,6
81144de8:	1105883a 	add	r2,r2,r4
81144dec:	10800804 	addi	r2,r2,32
81144df0:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81144df4:	1885883a 	add	r2,r3,r2
81144df8:	e0bffd15 	stw	r2,-12(fp)
81144dfc:	00001406 	br	81144e50 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
81144e00:	00bfff84 	movi	r2,-2
81144e04:	00003d06 	br	81144efc <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81144e08:	e13fff0f 	ldh	r4,-4(fp)
81144e0c:	e0ffff0f 	ldh	r3,-4(fp)
81144e10:	00a045f4 	movhi	r2,33047
81144e14:	10afb304 	addi	r2,r2,-16692
81144e18:	180691ba 	slli	r3,r3,6
81144e1c:	10c5883a 	add	r2,r2,r3
81144e20:	10800804 	addi	r2,r2,32
81144e24:	10800017 	ldw	r2,0(r2)
81144e28:	10c00044 	addi	r3,r2,1
81144e2c:	00a045f4 	movhi	r2,33047
81144e30:	10afb304 	addi	r2,r2,-16692
81144e34:	200891ba 	slli	r4,r4,6
81144e38:	1105883a 	add	r2,r2,r4
81144e3c:	10800804 	addi	r2,r2,32
81144e40:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81144e44:	e0bffd17 	ldw	r2,-12(fp)
81144e48:	10800044 	addi	r2,r2,1
81144e4c:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
81144e50:	d0e0b017 	ldw	r3,-32064(gp)
81144e54:	e0bffd17 	ldw	r2,-12(fp)
81144e58:	1885883a 	add	r2,r3,r2
81144e5c:	1007883a 	mov	r3,r2
81144e60:	d0a0b417 	ldw	r2,-32048(gp)
81144e64:	18800726 	beq	r3,r2,81144e84 <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81144e68:	d0a0b017 	ldw	r2,-32064(gp)
81144e6c:	100b883a 	mov	r5,r2
81144e70:	e13ffd17 	ldw	r4,-12(fp)
81144e74:	114143c0 	call	8114143c <Read_Sector_Data>
81144e78:	1000021e 	bne	r2,zero,81144e84 <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
81144e7c:	00bfff84 	movi	r2,-2
81144e80:	00001e06 	br	81144efc <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
81144e84:	d0e0af17 	ldw	r3,-32068(gp)
81144e88:	e13fff0f 	ldh	r4,-4(fp)
81144e8c:	00a045f4 	movhi	r2,33047
81144e90:	10afb304 	addi	r2,r2,-16692
81144e94:	200891ba 	slli	r4,r4,6
81144e98:	1105883a 	add	r2,r2,r4
81144e9c:	10800904 	addi	r2,r2,36
81144ea0:	10800017 	ldw	r2,0(r2)
81144ea4:	10807fcc 	andi	r2,r2,511
81144ea8:	1885883a 	add	r2,r3,r2
81144eac:	10800023 	ldbuio	r2,0(r2)
81144eb0:	10803fcc 	andi	r2,r2,255
81144eb4:	10803fcc 	andi	r2,r2,255
81144eb8:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81144ebc:	e13fff0f 	ldh	r4,-4(fp)
81144ec0:	e0ffff0f 	ldh	r3,-4(fp)
81144ec4:	00a045f4 	movhi	r2,33047
81144ec8:	10afb304 	addi	r2,r2,-16692
81144ecc:	180691ba 	slli	r3,r3,6
81144ed0:	10c5883a 	add	r2,r2,r3
81144ed4:	10800904 	addi	r2,r2,36
81144ed8:	10800017 	ldw	r2,0(r2)
81144edc:	10c00044 	addi	r3,r2,1
81144ee0:	00a045f4 	movhi	r2,33047
81144ee4:	10afb304 	addi	r2,r2,-16692
81144ee8:	200891ba 	slli	r4,r4,6
81144eec:	1105883a 	add	r2,r2,r4
81144ef0:	10800904 	addi	r2,r2,36
81144ef4:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
81144ef8:	e0bffc0b 	ldhu	r2,-16(fp)
}
81144efc:	e037883a 	mov	sp,fp
81144f00:	dfc00117 	ldw	ra,4(sp)
81144f04:	df000017 	ldw	fp,0(sp)
81144f08:	dec00204 	addi	sp,sp,8
81144f0c:	f800283a 	ret

81144f10 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
81144f10:	defff804 	addi	sp,sp,-32
81144f14:	de00012e 	bgeu	sp,et,81144f1c <alt_up_sd_card_write+0xc>
81144f18:	003b68fa 	trap	3
81144f1c:	dfc00715 	stw	ra,28(sp)
81144f20:	df000615 	stw	fp,24(sp)
81144f24:	df000604 	addi	fp,sp,24
81144f28:	2007883a 	mov	r3,r4
81144f2c:	2805883a 	mov	r2,r5
81144f30:	e0fffe0d 	sth	r3,-8(fp)
81144f34:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
81144f38:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81144f3c:	e0bffe0f 	ldh	r2,-8(fp)
81144f40:	10017716 	blt	r2,zero,81145520 <alt_up_sd_card_write+0x610>
81144f44:	e0bffe0f 	ldh	r2,-8(fp)
81144f48:	10800508 	cmpgei	r2,r2,20
81144f4c:	1001741e 	bne	r2,zero,81145520 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
81144f50:	e0fffe0f 	ldh	r3,-8(fp)
81144f54:	00a045f4 	movhi	r2,33047
81144f58:	10afb304 	addi	r2,r2,-16692
81144f5c:	180691ba 	slli	r3,r3,6
81144f60:	10c5883a 	add	r2,r2,r3
81144f64:	10800f04 	addi	r2,r2,60
81144f68:	10800017 	ldw	r2,0(r2)
81144f6c:	10016c26 	beq	r2,zero,81145520 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81144f70:	00a045f4 	movhi	r2,33047
81144f74:	10af9e04 	addi	r2,r2,-16776
81144f78:	10c01417 	ldw	r3,80(r2)
81144f7c:	e13ffe0f 	ldh	r4,-8(fp)
81144f80:	00a045f4 	movhi	r2,33047
81144f84:	10afb304 	addi	r2,r2,-16692
81144f88:	200891ba 	slli	r4,r4,6
81144f8c:	1105883a 	add	r2,r2,r4
81144f90:	10800704 	addi	r2,r2,28
81144f94:	10800017 	ldw	r2,0(r2)
81144f98:	113fff84 	addi	r4,r2,-2
81144f9c:	00a045f4 	movhi	r2,33047
81144fa0:	10af9e04 	addi	r2,r2,-16776
81144fa4:	10800383 	ldbu	r2,14(r2)
81144fa8:	10803fcc 	andi	r2,r2,255
81144fac:	2085383a 	mul	r2,r4,r2
81144fb0:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
81144fb4:	e13ffe0f 	ldh	r4,-8(fp)
81144fb8:	00a045f4 	movhi	r2,33047
81144fbc:	10afb304 	addi	r2,r2,-16692
81144fc0:	200891ba 	slli	r4,r4,6
81144fc4:	1105883a 	add	r2,r2,r4
81144fc8:	10800804 	addi	r2,r2,32
81144fcc:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81144fd0:	1885883a 	add	r2,r3,r2
81144fd4:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
81144fd8:	e0fffe0f 	ldh	r3,-8(fp)
81144fdc:	00a045f4 	movhi	r2,33047
81144fe0:	10afb304 	addi	r2,r2,-16692
81144fe4:	180691ba 	slli	r3,r3,6
81144fe8:	10c5883a 	add	r2,r2,r3
81144fec:	10800904 	addi	r2,r2,36
81144ff0:	10c00017 	ldw	r3,0(r2)
81144ff4:	00a045f4 	movhi	r2,33047
81144ff8:	10af9e04 	addi	r2,r2,-16776
81144ffc:	1080030b 	ldhu	r2,12(r2)
81145000:	10bfffcc 	andi	r2,r2,65535
81145004:	1889203a 	divu	r4,r3,r2
81145008:	2085383a 	mul	r2,r4,r2
8114500c:	1885c83a 	sub	r2,r3,r2
81145010:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81145014:	e0fffe0f 	ldh	r3,-8(fp)
81145018:	00a045f4 	movhi	r2,33047
8114501c:	10afb304 	addi	r2,r2,-16692
81145020:	180691ba 	slli	r3,r3,6
81145024:	10c5883a 	add	r2,r2,r3
81145028:	10800904 	addi	r2,r2,36
8114502c:	10c00017 	ldw	r3,0(r2)
81145030:	e13ffe0f 	ldh	r4,-8(fp)
81145034:	00a045f4 	movhi	r2,33047
81145038:	10afb304 	addi	r2,r2,-16692
8114503c:	200891ba 	slli	r4,r4,6
81145040:	1105883a 	add	r2,r2,r4
81145044:	10800604 	addi	r2,r2,24
81145048:	10800017 	ldw	r2,0(r2)
8114504c:	1880672e 	bgeu	r3,r2,811451ec <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81145050:	e0fffe0f 	ldh	r3,-8(fp)
81145054:	00a045f4 	movhi	r2,33047
81145058:	10afb304 	addi	r2,r2,-16692
8114505c:	180691ba 	slli	r3,r3,6
81145060:	10c5883a 	add	r2,r2,r3
81145064:	10800904 	addi	r2,r2,36
81145068:	10800017 	ldw	r2,0(r2)
8114506c:	1000e126 	beq	r2,zero,811453f4 <alt_up_sd_card_write+0x4e4>
81145070:	e0bffc0f 	ldh	r2,-16(fp)
81145074:	1000df1e 	bne	r2,zero,811453f4 <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81145078:	e0fffe0f 	ldh	r3,-8(fp)
8114507c:	00a045f4 	movhi	r2,33047
81145080:	10afb304 	addi	r2,r2,-16692
81145084:	180691ba 	slli	r3,r3,6
81145088:	10c5883a 	add	r2,r2,r3
8114508c:	10800804 	addi	r2,r2,32
81145090:	10c00017 	ldw	r3,0(r2)
81145094:	00a045f4 	movhi	r2,33047
81145098:	10af9e04 	addi	r2,r2,-16776
8114509c:	10800383 	ldbu	r2,14(r2)
811450a0:	10803fcc 	andi	r2,r2,255
811450a4:	10bfffc4 	addi	r2,r2,-1
811450a8:	18803d1e 	bne	r3,r2,811451a0 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
811450ac:	e0fffe0f 	ldh	r3,-8(fp)
811450b0:	00a045f4 	movhi	r2,33047
811450b4:	10afb304 	addi	r2,r2,-16692
811450b8:	180691ba 	slli	r3,r3,6
811450bc:	10c5883a 	add	r2,r2,r3
811450c0:	10800704 	addi	r2,r2,28
811450c4:	10800017 	ldw	r2,0(r2)
811450c8:	e0fffc84 	addi	r3,fp,-14
811450cc:	180b883a 	mov	r5,r3
811450d0:	1009883a 	mov	r4,r2
811450d4:	114151c0 	call	8114151c <get_cluster_flag>
811450d8:	10002f26 	beq	r2,zero,81145198 <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
811450dc:	e0bffc8b 	ldhu	r2,-14(fp)
811450e0:	10bfffcc 	andi	r2,r2,65535
811450e4:	10bffe28 	cmpgeui	r2,r2,65528
811450e8:	1000c21e 	bne	r2,zero,811453f4 <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
811450ec:	e13ffe0f 	ldh	r4,-8(fp)
811450f0:	e0bffc8b 	ldhu	r2,-14(fp)
811450f4:	10ffffcc 	andi	r3,r2,65535
811450f8:	00a045f4 	movhi	r2,33047
811450fc:	10afb304 	addi	r2,r2,-16692
81145100:	200891ba 	slli	r4,r4,6
81145104:	1105883a 	add	r2,r2,r4
81145108:	10800704 	addi	r2,r2,28
8114510c:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81145110:	e0fffe0f 	ldh	r3,-8(fp)
81145114:	00a045f4 	movhi	r2,33047
81145118:	10afb304 	addi	r2,r2,-16692
8114511c:	180691ba 	slli	r3,r3,6
81145120:	10c5883a 	add	r2,r2,r3
81145124:	10800804 	addi	r2,r2,32
81145128:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8114512c:	00a045f4 	movhi	r2,33047
81145130:	10af9e04 	addi	r2,r2,-16776
81145134:	10c01417 	ldw	r3,80(r2)
81145138:	e13ffe0f 	ldh	r4,-8(fp)
8114513c:	00a045f4 	movhi	r2,33047
81145140:	10afb304 	addi	r2,r2,-16692
81145144:	200891ba 	slli	r4,r4,6
81145148:	1105883a 	add	r2,r2,r4
8114514c:	10800704 	addi	r2,r2,28
81145150:	10800017 	ldw	r2,0(r2)
81145154:	113fff84 	addi	r4,r2,-2
81145158:	00a045f4 	movhi	r2,33047
8114515c:	10af9e04 	addi	r2,r2,-16776
81145160:	10800383 	ldbu	r2,14(r2)
81145164:	10803fcc 	andi	r2,r2,255
81145168:	2085383a 	mul	r2,r4,r2
8114516c:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81145170:	e13ffe0f 	ldh	r4,-8(fp)
81145174:	00a045f4 	movhi	r2,33047
81145178:	10afb304 	addi	r2,r2,-16692
8114517c:	200891ba 	slli	r4,r4,6
81145180:	1105883a 	add	r2,r2,r4
81145184:	10800804 	addi	r2,r2,32
81145188:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8114518c:	1885883a 	add	r2,r3,r2
81145190:	e0bffb15 	stw	r2,-20(fp)
81145194:	00009706 	br	811453f4 <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
81145198:	0005883a 	mov	r2,zero
8114519c:	0000e106 	br	81145524 <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
811451a0:	e13ffe0f 	ldh	r4,-8(fp)
811451a4:	e0fffe0f 	ldh	r3,-8(fp)
811451a8:	00a045f4 	movhi	r2,33047
811451ac:	10afb304 	addi	r2,r2,-16692
811451b0:	180691ba 	slli	r3,r3,6
811451b4:	10c5883a 	add	r2,r2,r3
811451b8:	10800804 	addi	r2,r2,32
811451bc:	10800017 	ldw	r2,0(r2)
811451c0:	10c00044 	addi	r3,r2,1
811451c4:	00a045f4 	movhi	r2,33047
811451c8:	10afb304 	addi	r2,r2,-16692
811451cc:	200891ba 	slli	r4,r4,6
811451d0:	1105883a 	add	r2,r2,r4
811451d4:	10800804 	addi	r2,r2,32
811451d8:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
811451dc:	e0bffb17 	ldw	r2,-20(fp)
811451e0:	10800044 	addi	r2,r2,1
811451e4:	e0bffb15 	stw	r2,-20(fp)
811451e8:	00008206 	br	811453f4 <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
811451ec:	e0fffe0f 	ldh	r3,-8(fp)
811451f0:	00a045f4 	movhi	r2,33047
811451f4:	10afb304 	addi	r2,r2,-16692
811451f8:	180691ba 	slli	r3,r3,6
811451fc:	10c5883a 	add	r2,r2,r3
81145200:	10800904 	addi	r2,r2,36
81145204:	10800017 	ldw	r2,0(r2)
81145208:	10007a26 	beq	r2,zero,811453f4 <alt_up_sd_card_write+0x4e4>
8114520c:	e0bffc0f 	ldh	r2,-16(fp)
81145210:	1000781e 	bne	r2,zero,811453f4 <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81145214:	e0fffe0f 	ldh	r3,-8(fp)
81145218:	00a045f4 	movhi	r2,33047
8114521c:	10afb304 	addi	r2,r2,-16692
81145220:	180691ba 	slli	r3,r3,6
81145224:	10c5883a 	add	r2,r2,r3
81145228:	10800804 	addi	r2,r2,32
8114522c:	10c00017 	ldw	r3,0(r2)
81145230:	00a045f4 	movhi	r2,33047
81145234:	10af9e04 	addi	r2,r2,-16776
81145238:	10800383 	ldbu	r2,14(r2)
8114523c:	10803fcc 	andi	r2,r2,255
81145240:	10bfffc4 	addi	r2,r2,-1
81145244:	18803e1e 	bne	r3,r2,81145340 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
81145248:	e0bffd04 	addi	r2,fp,-12
8114524c:	1009883a 	mov	r4,r2
81145250:	11435600 	call	81143560 <find_first_empty_cluster>
81145254:	10003826 	beq	r2,zero,81145338 <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
81145258:	e0fffe0f 	ldh	r3,-8(fp)
8114525c:	00a045f4 	movhi	r2,33047
81145260:	10afb304 	addi	r2,r2,-16692
81145264:	180691ba 	slli	r3,r3,6
81145268:	10c5883a 	add	r2,r2,r3
8114526c:	10800704 	addi	r2,r2,28
81145270:	10800017 	ldw	r2,0(r2)
81145274:	e0fffd17 	ldw	r3,-12(fp)
81145278:	18ffffcc 	andi	r3,r3,65535
8114527c:	18e0001c 	xori	r3,r3,32768
81145280:	18e00004 	addi	r3,r3,-32768
81145284:	01800044 	movi	r6,1
81145288:	180b883a 	mov	r5,r3
8114528c:	1009883a 	mov	r4,r2
81145290:	11415d80 	call	811415d8 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
81145294:	e0bffd17 	ldw	r2,-12(fp)
81145298:	01800044 	movi	r6,1
8114529c:	017fffc4 	movi	r5,-1
811452a0:	1009883a 	mov	r4,r2
811452a4:	11415d80 	call	811415d8 <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
811452a8:	e0fffe0f 	ldh	r3,-8(fp)
811452ac:	00a045f4 	movhi	r2,33047
811452b0:	10afb304 	addi	r2,r2,-16692
811452b4:	180691ba 	slli	r3,r3,6
811452b8:	10c5883a 	add	r2,r2,r3
811452bc:	10800704 	addi	r2,r2,28
811452c0:	10800017 	ldw	r2,0(r2)
811452c4:	e0fffd17 	ldw	r3,-12(fp)
811452c8:	18ffffcc 	andi	r3,r3,65535
811452cc:	18e0001c 	xori	r3,r3,32768
811452d0:	18e00004 	addi	r3,r3,-32768
811452d4:	000d883a 	mov	r6,zero
811452d8:	180b883a 	mov	r5,r3
811452dc:	1009883a 	mov	r4,r2
811452e0:	11415d80 	call	811415d8 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
811452e4:	e0bffd17 	ldw	r2,-12(fp)
811452e8:	000d883a 	mov	r6,zero
811452ec:	017fffc4 	movi	r5,-1
811452f0:	1009883a 	mov	r4,r2
811452f4:	11415d80 	call	811415d8 <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
811452f8:	e13ffe0f 	ldh	r4,-8(fp)
811452fc:	e0fffd17 	ldw	r3,-12(fp)
81145300:	00a045f4 	movhi	r2,33047
81145304:	10afb304 	addi	r2,r2,-16692
81145308:	200891ba 	slli	r4,r4,6
8114530c:	1105883a 	add	r2,r2,r4
81145310:	10800704 	addi	r2,r2,28
81145314:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
81145318:	e0fffe0f 	ldh	r3,-8(fp)
8114531c:	00a045f4 	movhi	r2,33047
81145320:	10afb304 	addi	r2,r2,-16692
81145324:	180691ba 	slli	r3,r3,6
81145328:	10c5883a 	add	r2,r2,r3
8114532c:	10800804 	addi	r2,r2,32
81145330:	10000015 	stw	zero,0(r2)
81145334:	00001506 	br	8114538c <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
81145338:	0005883a 	mov	r2,zero
8114533c:	00007906 	br	81145524 <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
81145340:	e13ffe0f 	ldh	r4,-8(fp)
81145344:	e0fffe0f 	ldh	r3,-8(fp)
81145348:	00a045f4 	movhi	r2,33047
8114534c:	10afb304 	addi	r2,r2,-16692
81145350:	180691ba 	slli	r3,r3,6
81145354:	10c5883a 	add	r2,r2,r3
81145358:	10800904 	addi	r2,r2,36
8114535c:	10c00017 	ldw	r3,0(r2)
81145360:	00a045f4 	movhi	r2,33047
81145364:	10af9e04 	addi	r2,r2,-16776
81145368:	1080030b 	ldhu	r2,12(r2)
8114536c:	10bfffcc 	andi	r2,r2,65535
81145370:	1887203a 	divu	r3,r3,r2
81145374:	00a045f4 	movhi	r2,33047
81145378:	10afb304 	addi	r2,r2,-16692
8114537c:	200891ba 	slli	r4,r4,6
81145380:	1105883a 	add	r2,r2,r4
81145384:	10800804 	addi	r2,r2,32
81145388:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8114538c:	00a045f4 	movhi	r2,33047
81145390:	10af9e04 	addi	r2,r2,-16776
81145394:	10c01417 	ldw	r3,80(r2)
81145398:	e13ffe0f 	ldh	r4,-8(fp)
8114539c:	00a045f4 	movhi	r2,33047
811453a0:	10afb304 	addi	r2,r2,-16692
811453a4:	200891ba 	slli	r4,r4,6
811453a8:	1105883a 	add	r2,r2,r4
811453ac:	10800704 	addi	r2,r2,28
811453b0:	10800017 	ldw	r2,0(r2)
811453b4:	113fff84 	addi	r4,r2,-2
811453b8:	00a045f4 	movhi	r2,33047
811453bc:	10af9e04 	addi	r2,r2,-16776
811453c0:	10800383 	ldbu	r2,14(r2)
811453c4:	10803fcc 	andi	r2,r2,255
811453c8:	2085383a 	mul	r2,r4,r2
811453cc:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
811453d0:	e13ffe0f 	ldh	r4,-8(fp)
811453d4:	00a045f4 	movhi	r2,33047
811453d8:	10afb304 	addi	r2,r2,-16692
811453dc:	200891ba 	slli	r4,r4,6
811453e0:	1105883a 	add	r2,r2,r4
811453e4:	10800804 	addi	r2,r2,32
811453e8:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811453ec:	1885883a 	add	r2,r3,r2
811453f0:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
811453f4:	d0e0b017 	ldw	r3,-32064(gp)
811453f8:	e0bffb17 	ldw	r2,-20(fp)
811453fc:	1885883a 	add	r2,r3,r2
81145400:	1007883a 	mov	r3,r2
81145404:	d0a0b417 	ldw	r2,-32048(gp)
81145408:	18800726 	beq	r3,r2,81145428 <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
8114540c:	d0a0b017 	ldw	r2,-32064(gp)
81145410:	100b883a 	mov	r5,r2
81145414:	e13ffb17 	ldw	r4,-20(fp)
81145418:	114143c0 	call	8114143c <Read_Sector_Data>
8114541c:	1000021e 	bne	r2,zero,81145428 <alt_up_sd_card_write+0x518>
                {
					return false;
81145420:	0005883a 	mov	r2,zero
81145424:	00003f06 	br	81145524 <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
81145428:	d0e0af17 	ldw	r3,-32068(gp)
8114542c:	e0bffc0f 	ldh	r2,-16(fp)
81145430:	1885883a 	add	r2,r3,r2
81145434:	e0ffff07 	ldb	r3,-4(fp)
81145438:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
8114543c:	e13ffe0f 	ldh	r4,-8(fp)
81145440:	e0fffe0f 	ldh	r3,-8(fp)
81145444:	00a045f4 	movhi	r2,33047
81145448:	10afb304 	addi	r2,r2,-16692
8114544c:	180691ba 	slli	r3,r3,6
81145450:	10c5883a 	add	r2,r2,r3
81145454:	10800904 	addi	r2,r2,36
81145458:	10800017 	ldw	r2,0(r2)
8114545c:	10c00044 	addi	r3,r2,1
81145460:	00a045f4 	movhi	r2,33047
81145464:	10afb304 	addi	r2,r2,-16692
81145468:	200891ba 	slli	r4,r4,6
8114546c:	1105883a 	add	r2,r2,r4
81145470:	10800904 	addi	r2,r2,36
81145474:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
81145478:	e0fffe0f 	ldh	r3,-8(fp)
8114547c:	00a045f4 	movhi	r2,33047
81145480:	10afb304 	addi	r2,r2,-16692
81145484:	180691ba 	slli	r3,r3,6
81145488:	10c5883a 	add	r2,r2,r3
8114548c:	10800904 	addi	r2,r2,36
81145490:	10c00017 	ldw	r3,0(r2)
81145494:	e13ffe0f 	ldh	r4,-8(fp)
81145498:	00a045f4 	movhi	r2,33047
8114549c:	10afb304 	addi	r2,r2,-16692
811454a0:	200891ba 	slli	r4,r4,6
811454a4:	1105883a 	add	r2,r2,r4
811454a8:	10800604 	addi	r2,r2,24
811454ac:	10800017 	ldw	r2,0(r2)
811454b0:	18801736 	bltu	r3,r2,81145510 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
811454b4:	e13ffe0f 	ldh	r4,-8(fp)
811454b8:	e0fffe0f 	ldh	r3,-8(fp)
811454bc:	00a045f4 	movhi	r2,33047
811454c0:	10afb304 	addi	r2,r2,-16692
811454c4:	180691ba 	slli	r3,r3,6
811454c8:	10c5883a 	add	r2,r2,r3
811454cc:	10800604 	addi	r2,r2,24
811454d0:	10800017 	ldw	r2,0(r2)
811454d4:	10c00044 	addi	r3,r2,1
811454d8:	00a045f4 	movhi	r2,33047
811454dc:	10afb304 	addi	r2,r2,-16692
811454e0:	200891ba 	slli	r4,r4,6
811454e4:	1105883a 	add	r2,r2,r4
811454e8:	10800604 	addi	r2,r2,24
811454ec:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
811454f0:	e0fffe0f 	ldh	r3,-8(fp)
811454f4:	00a045f4 	movhi	r2,33047
811454f8:	10afb304 	addi	r2,r2,-16692
811454fc:	180691ba 	slli	r3,r3,6
81145500:	10c5883a 	add	r2,r2,r3
81145504:	10800e04 	addi	r2,r2,56
81145508:	00c00044 	movi	r3,1
8114550c:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
81145510:	00800044 	movi	r2,1
81145514:	d0a0b315 	stw	r2,-32052(gp)
			result = true;
81145518:	00800044 	movi	r2,1
8114551c:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
81145520:	e0bffa17 	ldw	r2,-24(fp)
}
81145524:	e037883a 	mov	sp,fp
81145528:	dfc00117 	ldw	ra,4(sp)
8114552c:	df000017 	ldw	fp,0(sp)
81145530:	dec00204 	addi	sp,sp,8
81145534:	f800283a 	ret

81145538 <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
81145538:	defffb04 	addi	sp,sp,-20
8114553c:	de00012e 	bgeu	sp,et,81145544 <alt_up_sd_card_fclose+0xc>
81145540:	003b68fa 	trap	3
81145544:	dfc00415 	stw	ra,16(sp)
81145548:	df000315 	stw	fp,12(sp)
8114554c:	df000304 	addi	fp,sp,12
81145550:	2005883a 	mov	r2,r4
81145554:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
81145558:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8114555c:	11441140 	call	81144114 <alt_up_sd_card_is_Present>
81145560:	10006026 	beq	r2,zero,811456e4 <alt_up_sd_card_fclose+0x1ac>
81145564:	d0a0a917 	ldw	r2,-32092(gp)
81145568:	10005e26 	beq	r2,zero,811456e4 <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
8114556c:	e0ffff0f 	ldh	r3,-4(fp)
81145570:	00a045f4 	movhi	r2,33047
81145574:	10afb304 	addi	r2,r2,-16692
81145578:	180691ba 	slli	r3,r3,6
8114557c:	10c5883a 	add	r2,r2,r3
81145580:	10800f04 	addi	r2,r2,60
81145584:	10800017 	ldw	r2,0(r2)
81145588:	10005626 	beq	r2,zero,811456e4 <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
8114558c:	e0ffff0f 	ldh	r3,-4(fp)
81145590:	00a045f4 	movhi	r2,33047
81145594:	10afb304 	addi	r2,r2,-16692
81145598:	180691ba 	slli	r3,r3,6
8114559c:	10c5883a 	add	r2,r2,r3
811455a0:	10800e04 	addi	r2,r2,56
811455a4:	10800017 	ldw	r2,0(r2)
811455a8:	10004526 	beq	r2,zero,811456c0 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
811455ac:	e0ffff0f 	ldh	r3,-4(fp)
811455b0:	00a045f4 	movhi	r2,33047
811455b4:	10afb304 	addi	r2,r2,-16692
811455b8:	180691ba 	slli	r3,r3,6
811455bc:	10c5883a 	add	r2,r2,r3
811455c0:	10800b04 	addi	r2,r2,44
811455c4:	10800017 	ldw	r2,0(r2)
811455c8:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
811455cc:	e0ffff0f 	ldh	r3,-4(fp)
811455d0:	00a045f4 	movhi	r2,33047
811455d4:	10afb304 	addi	r2,r2,-16692
811455d8:	180691ba 	slli	r3,r3,6
811455dc:	10c5883a 	add	r2,r2,r3
811455e0:	10800a04 	addi	r2,r2,40
811455e4:	10800017 	ldw	r2,0(r2)
811455e8:	1000071e 	bne	r2,zero,81145608 <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
811455ec:	00a045f4 	movhi	r2,33047
811455f0:	10af9e04 	addi	r2,r2,-16776
811455f4:	10801317 	ldw	r2,76(r2)
811455f8:	e0fffe17 	ldw	r3,-8(fp)
811455fc:	1885883a 	add	r2,r3,r2
81145600:	e0bffe15 	stw	r2,-8(fp)
81145604:	00001406 	br	81145658 <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81145608:	00a045f4 	movhi	r2,33047
8114560c:	10af9e04 	addi	r2,r2,-16776
81145610:	10c01417 	ldw	r3,80(r2)
81145614:	e0bffe17 	ldw	r2,-8(fp)
81145618:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
8114561c:	e13fff0f 	ldh	r4,-4(fp)
81145620:	00a045f4 	movhi	r2,33047
81145624:	10afb304 	addi	r2,r2,-16692
81145628:	200891ba 	slli	r4,r4,6
8114562c:	1105883a 	add	r2,r2,r4
81145630:	10800a04 	addi	r2,r2,40
81145634:	10800017 	ldw	r2,0(r2)
81145638:	113fff84 	addi	r4,r2,-2
8114563c:	00a045f4 	movhi	r2,33047
81145640:	10af9e04 	addi	r2,r2,-16776
81145644:	10800383 	ldbu	r2,14(r2)
81145648:	10803fcc 	andi	r2,r2,255
8114564c:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81145650:	1885883a 	add	r2,r3,r2
81145654:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
81145658:	e0bffe17 	ldw	r2,-8(fp)
8114565c:	d0e0b017 	ldw	r3,-32064(gp)
81145660:	180b883a 	mov	r5,r3
81145664:	1009883a 	mov	r4,r2
81145668:	114143c0 	call	8114143c <Read_Sector_Data>
8114566c:	10001426 	beq	r2,zero,811456c0 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
81145670:	e0ffff0f 	ldh	r3,-4(fp)
81145674:	00a045f4 	movhi	r2,33047
81145678:	10afb304 	addi	r2,r2,-16692
8114567c:	180691ba 	slli	r3,r3,6
81145680:	10c5883a 	add	r2,r2,r3
81145684:	10800c04 	addi	r2,r2,48
81145688:	1080000b 	ldhu	r2,0(r2)
8114568c:	113fffcc 	andi	r4,r2,65535
81145690:	2120001c 	xori	r4,r4,32768
81145694:	21200004 	addi	r4,r4,-32768
81145698:	e0bfff0f 	ldh	r2,-4(fp)
8114569c:	100691ba 	slli	r3,r2,6
811456a0:	00a045f4 	movhi	r2,33047
811456a4:	10afb304 	addi	r2,r2,-16692
811456a8:	1885883a 	add	r2,r3,r2
811456ac:	100b883a 	mov	r5,r2
811456b0:	1141af00 	call	81141af0 <Write_File_Record_At_Offset>
811456b4:	10000226 	beq	r2,zero,811456c0 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
811456b8:	11413e80 	call	811413e8 <Save_Modified_Sector>
811456bc:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
811456c0:	e0ffff0f 	ldh	r3,-4(fp)
811456c4:	00a045f4 	movhi	r2,33047
811456c8:	10afb304 	addi	r2,r2,-16692
811456cc:	180691ba 	slli	r3,r3,6
811456d0:	10c5883a 	add	r2,r2,r3
811456d4:	10800f04 	addi	r2,r2,60
811456d8:	10000015 	stw	zero,0(r2)
			result = true;
811456dc:	00800044 	movi	r2,1
811456e0:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
811456e4:	e0bffd17 	ldw	r2,-12(fp)
}
811456e8:	e037883a 	mov	sp,fp
811456ec:	dfc00117 	ldw	ra,4(sp)
811456f0:	df000017 	ldw	fp,0(sp)
811456f4:	dec00204 	addi	sp,sp,8
811456f8:	f800283a 	ret

811456fc <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
811456fc:	defffa04 	addi	sp,sp,-24
81145700:	de00012e 	bgeu	sp,et,81145708 <altera_avalon_jtag_uart_read_fd+0xc>
81145704:	003b68fa 	trap	3
81145708:	dfc00515 	stw	ra,20(sp)
8114570c:	df000415 	stw	fp,16(sp)
81145710:	df000404 	addi	fp,sp,16
81145714:	e13ffd15 	stw	r4,-12(fp)
81145718:	e17ffe15 	stw	r5,-8(fp)
8114571c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81145720:	e0bffd17 	ldw	r2,-12(fp)
81145724:	10800017 	ldw	r2,0(r2)
81145728:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
8114572c:	e0bffc17 	ldw	r2,-16(fp)
81145730:	10c00a04 	addi	r3,r2,40
81145734:	e0bffd17 	ldw	r2,-12(fp)
81145738:	10800217 	ldw	r2,8(r2)
8114573c:	100f883a 	mov	r7,r2
81145740:	e1bfff17 	ldw	r6,-4(fp)
81145744:	e17ffe17 	ldw	r5,-8(fp)
81145748:	1809883a 	mov	r4,r3
8114574c:	1145f800 	call	81145f80 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
81145750:	e037883a 	mov	sp,fp
81145754:	dfc00117 	ldw	ra,4(sp)
81145758:	df000017 	ldw	fp,0(sp)
8114575c:	dec00204 	addi	sp,sp,8
81145760:	f800283a 	ret

81145764 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81145764:	defffa04 	addi	sp,sp,-24
81145768:	de00012e 	bgeu	sp,et,81145770 <altera_avalon_jtag_uart_write_fd+0xc>
8114576c:	003b68fa 	trap	3
81145770:	dfc00515 	stw	ra,20(sp)
81145774:	df000415 	stw	fp,16(sp)
81145778:	df000404 	addi	fp,sp,16
8114577c:	e13ffd15 	stw	r4,-12(fp)
81145780:	e17ffe15 	stw	r5,-8(fp)
81145784:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81145788:	e0bffd17 	ldw	r2,-12(fp)
8114578c:	10800017 	ldw	r2,0(r2)
81145790:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
81145794:	e0bffc17 	ldw	r2,-16(fp)
81145798:	10c00a04 	addi	r3,r2,40
8114579c:	e0bffd17 	ldw	r2,-12(fp)
811457a0:	10800217 	ldw	r2,8(r2)
811457a4:	100f883a 	mov	r7,r2
811457a8:	e1bfff17 	ldw	r6,-4(fp)
811457ac:	e17ffe17 	ldw	r5,-8(fp)
811457b0:	1809883a 	mov	r4,r3
811457b4:	11462440 	call	81146244 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
811457b8:	e037883a 	mov	sp,fp
811457bc:	dfc00117 	ldw	ra,4(sp)
811457c0:	df000017 	ldw	fp,0(sp)
811457c4:	dec00204 	addi	sp,sp,8
811457c8:	f800283a 	ret

811457cc <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
811457cc:	defffc04 	addi	sp,sp,-16
811457d0:	de00012e 	bgeu	sp,et,811457d8 <altera_avalon_jtag_uart_close_fd+0xc>
811457d4:	003b68fa 	trap	3
811457d8:	dfc00315 	stw	ra,12(sp)
811457dc:	df000215 	stw	fp,8(sp)
811457e0:	df000204 	addi	fp,sp,8
811457e4:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
811457e8:	e0bfff17 	ldw	r2,-4(fp)
811457ec:	10800017 	ldw	r2,0(r2)
811457f0:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
811457f4:	e0bffe17 	ldw	r2,-8(fp)
811457f8:	10c00a04 	addi	r3,r2,40
811457fc:	e0bfff17 	ldw	r2,-4(fp)
81145800:	10800217 	ldw	r2,8(r2)
81145804:	100b883a 	mov	r5,r2
81145808:	1809883a 	mov	r4,r3
8114580c:	1145e180 	call	81145e18 <altera_avalon_jtag_uart_close>
}
81145810:	e037883a 	mov	sp,fp
81145814:	dfc00117 	ldw	ra,4(sp)
81145818:	df000017 	ldw	fp,0(sp)
8114581c:	dec00204 	addi	sp,sp,8
81145820:	f800283a 	ret

81145824 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
81145824:	defffa04 	addi	sp,sp,-24
81145828:	de00012e 	bgeu	sp,et,81145830 <altera_avalon_jtag_uart_ioctl_fd+0xc>
8114582c:	003b68fa 	trap	3
81145830:	dfc00515 	stw	ra,20(sp)
81145834:	df000415 	stw	fp,16(sp)
81145838:	df000404 	addi	fp,sp,16
8114583c:	e13ffd15 	stw	r4,-12(fp)
81145840:	e17ffe15 	stw	r5,-8(fp)
81145844:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
81145848:	e0bffd17 	ldw	r2,-12(fp)
8114584c:	10800017 	ldw	r2,0(r2)
81145850:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
81145854:	e0bffc17 	ldw	r2,-16(fp)
81145858:	10800a04 	addi	r2,r2,40
8114585c:	e1bfff17 	ldw	r6,-4(fp)
81145860:	e17ffe17 	ldw	r5,-8(fp)
81145864:	1009883a 	mov	r4,r2
81145868:	1145e880 	call	81145e88 <altera_avalon_jtag_uart_ioctl>
}
8114586c:	e037883a 	mov	sp,fp
81145870:	dfc00117 	ldw	ra,4(sp)
81145874:	df000017 	ldw	fp,0(sp)
81145878:	dec00204 	addi	sp,sp,8
8114587c:	f800283a 	ret

81145880 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
81145880:	deffef04 	addi	sp,sp,-68
81145884:	de00012e 	bgeu	sp,et,8114588c <altera_avalon_jtag_uart_init+0xc>
81145888:	003b68fa 	trap	3
8114588c:	dfc01015 	stw	ra,64(sp)
81145890:	df000f15 	stw	fp,60(sp)
81145894:	dc400e15 	stw	r17,56(sp)
81145898:	dc000d15 	stw	r16,52(sp)
8114589c:	df000f04 	addi	fp,sp,60
811458a0:	e13ff715 	stw	r4,-36(fp)
811458a4:	e17ff815 	stw	r5,-32(fp)
811458a8:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
811458ac:	e0bff717 	ldw	r2,-36(fp)
811458b0:	10800c04 	addi	r2,r2,48
811458b4:	e0bff215 	stw	r2,-56(fp)
811458b8:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
811458bc:	e0bff60b 	ldhu	r2,-40(fp)
811458c0:	e0fff684 	addi	r3,fp,-38
811458c4:	180b883a 	mov	r5,r3
811458c8:	1009883a 	mov	r4,r2
811458cc:	1139a500 	call	81139a50 <OSFlagCreate>
811458d0:	1007883a 	mov	r3,r2
811458d4:	e0bff217 	ldw	r2,-56(fp)
811458d8:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
811458dc:	e0bff717 	ldw	r2,-36(fp)
811458e0:	10800a04 	addi	r2,r2,40
811458e4:	e0bff315 	stw	r2,-52(fp)
811458e8:	00800044 	movi	r2,1
811458ec:	e0bff58d 	sth	r2,-42(fp)
811458f0:	e0bff58b 	ldhu	r2,-42(fp)
811458f4:	1009883a 	mov	r4,r2
811458f8:	113d9ac0 	call	8113d9ac <OSSemCreate>
811458fc:	1007883a 	mov	r3,r2
81145900:	e0bff317 	ldw	r2,-52(fp)
81145904:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
81145908:	e0bff717 	ldw	r2,-36(fp)
8114590c:	10800b04 	addi	r2,r2,44
81145910:	e0bff415 	stw	r2,-48(fp)
81145914:	00800044 	movi	r2,1
81145918:	e0bff50d 	sth	r2,-44(fp)
8114591c:	e0bff50b 	ldhu	r2,-44(fp)
81145920:	1009883a 	mov	r4,r2
81145924:	113d9ac0 	call	8113d9ac <OSSemCreate>
81145928:	1007883a 	mov	r3,r2
8114592c:	e0bff417 	ldw	r2,-48(fp)
81145930:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81145934:	e0bff717 	ldw	r2,-36(fp)
81145938:	00c00044 	movi	r3,1
8114593c:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
81145940:	e0bff717 	ldw	r2,-36(fp)
81145944:	10800017 	ldw	r2,0(r2)
81145948:	10800104 	addi	r2,r2,4
8114594c:	1007883a 	mov	r3,r2
81145950:	e0bff717 	ldw	r2,-36(fp)
81145954:	10800817 	ldw	r2,32(r2)
81145958:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
8114595c:	e0bff817 	ldw	r2,-32(fp)
81145960:	e0fff917 	ldw	r3,-28(fp)
81145964:	d8000015 	stw	zero,0(sp)
81145968:	e1fff717 	ldw	r7,-36(fp)
8114596c:	01a04534 	movhi	r6,33044
81145970:	31969404 	addi	r6,r6,23120
81145974:	180b883a 	mov	r5,r3
81145978:	1009883a 	mov	r4,r2
8114597c:	11497980 	call	81149798 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
81145980:	e0bff717 	ldw	r2,-36(fp)
81145984:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
81145988:	e0bff717 	ldw	r2,-36(fp)
8114598c:	10800204 	addi	r2,r2,8
81145990:	d0e08717 	ldw	r3,-32228(gp)
81145994:	e1fff717 	ldw	r7,-36(fp)
81145998:	01a04534 	movhi	r6,33044
8114599c:	31974304 	addi	r6,r6,23820
811459a0:	180b883a 	mov	r5,r3
811459a4:	1009883a 	mov	r4,r2
811459a8:	11492e80 	call	811492e8 <alt_alarm_start>
811459ac:	1000040e 	bge	r2,zero,811459c0 <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
811459b0:	e0fff717 	ldw	r3,-36(fp)
811459b4:	00a00034 	movhi	r2,32768
811459b8:	10bfffc4 	addi	r2,r2,-1
811459bc:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
811459c0:	d0a08083 	ldbu	r2,-32254(gp)
811459c4:	10803fcc 	andi	r2,r2,255
811459c8:	10800058 	cmpnei	r2,r2,1
811459cc:	10000f1e 	bne	r2,zero,81145a0c <altera_avalon_jtag_uart_init+0x18c>
811459d0:	d0e08717 	ldw	r3,-32228(gp)
811459d4:	00b33374 	movhi	r2,52429
811459d8:	10b33344 	addi	r2,r2,-13107
811459dc:	1888383a 	mulxuu	r4,r3,r2
811459e0:	1885383a 	mul	r2,r3,r2
811459e4:	1021883a 	mov	r16,r2
811459e8:	2023883a 	mov	r17,r4
811459ec:	8804d0fa 	srli	r2,r17,3
811459f0:	e1fff717 	ldw	r7,-36(fp)
811459f4:	01a044f4 	movhi	r6,33043
811459f8:	31986004 	addi	r6,r6,24960
811459fc:	100b883a 	mov	r5,r2
81145a00:	012045b4 	movhi	r4,33046
81145a04:	21177204 	addi	r4,r4,24008
81145a08:	11492e80 	call	811492e8 <alt_alarm_start>
81145a0c:	d0a08103 	ldbu	r2,-32252(gp)
81145a10:	10803fcc 	andi	r2,r2,255
81145a14:	10800058 	cmpnei	r2,r2,1
81145a18:	1000051e 	bne	r2,zero,81145a30 <altera_avalon_jtag_uart_init+0x1b0>
81145a1c:	e0bff717 	ldw	r2,-36(fp)
81145a20:	10800017 	ldw	r2,0(r2)
81145a24:	100b883a 	mov	r5,r2
81145a28:	e13ff717 	ldw	r4,-36(fp)
81145a2c:	11363180 	call	81136318 <alt_log_jtag_uart_startup_info>
}
81145a30:	0001883a 	nop
81145a34:	e6fffe04 	addi	sp,fp,-8
81145a38:	dfc00317 	ldw	ra,12(sp)
81145a3c:	df000217 	ldw	fp,8(sp)
81145a40:	dc400117 	ldw	r17,4(sp)
81145a44:	dc000017 	ldw	r16,0(sp)
81145a48:	dec00404 	addi	sp,sp,16
81145a4c:	f800283a 	ret

81145a50 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
81145a50:	defff204 	addi	sp,sp,-56
81145a54:	de00012e 	bgeu	sp,et,81145a5c <altera_avalon_jtag_uart_irq+0xc>
81145a58:	003b68fa 	trap	3
81145a5c:	dfc00d15 	stw	ra,52(sp)
81145a60:	df000c15 	stw	fp,48(sp)
81145a64:	df000c04 	addi	fp,sp,48
81145a68:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
81145a6c:	e0bfff17 	ldw	r2,-4(fp)
81145a70:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
81145a74:	e0bff617 	ldw	r2,-40(fp)
81145a78:	10800017 	ldw	r2,0(r2)
81145a7c:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
81145a80:	e0bff717 	ldw	r2,-36(fp)
81145a84:	e17ff617 	ldw	r5,-40(fp)
81145a88:	1009883a 	mov	r4,r2
81145a8c:	113636c0 	call	8113636c <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81145a90:	e0bff717 	ldw	r2,-36(fp)
81145a94:	10800104 	addi	r2,r2,4
81145a98:	10800037 	ldwio	r2,0(r2)
81145a9c:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
81145aa0:	e0bff817 	ldw	r2,-32(fp)
81145aa4:	1080c00c 	andi	r2,r2,768
81145aa8:	10009126 	beq	r2,zero,81145cf0 <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
81145aac:	e0bff817 	ldw	r2,-32(fp)
81145ab0:	1080400c 	andi	r2,r2,256
81145ab4:	10004726 	beq	r2,zero,81145bd4 <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
81145ab8:	00800074 	movhi	r2,1
81145abc:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81145ac0:	e0bff617 	ldw	r2,-40(fp)
81145ac4:	10800d17 	ldw	r2,52(r2)
81145ac8:	10800044 	addi	r2,r2,1
81145acc:	1081ffcc 	andi	r2,r2,2047
81145ad0:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
81145ad4:	e0bff617 	ldw	r2,-40(fp)
81145ad8:	10c00e17 	ldw	r3,56(r2)
81145adc:	e0bff917 	ldw	r2,-28(fp)
81145ae0:	18802726 	beq	r3,r2,81145b80 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
81145ae4:	e0bff717 	ldw	r2,-36(fp)
81145ae8:	10800037 	ldwio	r2,0(r2)
81145aec:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
81145af0:	e0bff417 	ldw	r2,-48(fp)
81145af4:	10a0000c 	andi	r2,r2,32768
81145af8:	10002326 	beq	r2,zero,81145b88 <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
81145afc:	e0bff617 	ldw	r2,-40(fp)
81145b00:	10800d17 	ldw	r2,52(r2)
81145b04:	e0fff417 	ldw	r3,-48(fp)
81145b08:	1809883a 	mov	r4,r3
81145b0c:	e0fff617 	ldw	r3,-40(fp)
81145b10:	1885883a 	add	r2,r3,r2
81145b14:	10801104 	addi	r2,r2,68
81145b18:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81145b1c:	e0bff617 	ldw	r2,-40(fp)
81145b20:	10800d17 	ldw	r2,52(r2)
81145b24:	10800044 	addi	r2,r2,1
81145b28:	10c1ffcc 	andi	r3,r2,2047
81145b2c:	e0bff617 	ldw	r2,-40(fp)
81145b30:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
81145b34:	e0bff617 	ldw	r2,-40(fp)
81145b38:	10800c17 	ldw	r2,48(r2)
81145b3c:	e0bffb15 	stw	r2,-20(fp)
81145b40:	00800044 	movi	r2,1
81145b44:	e0bffc0d 	sth	r2,-16(fp)
81145b48:	00800044 	movi	r2,1
81145b4c:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81145b50:	d0a09003 	ldbu	r2,-32192(gp)
81145b54:	10803fcc 	andi	r2,r2,255
81145b58:	103fd926 	beq	r2,zero,81145ac0 <__reset+0xfb125ac0>
  {
    OSFlagPost (group, flags, opt, &err);
81145b5c:	e0bffc0b 	ldhu	r2,-16(fp)
81145b60:	e0fffc83 	ldbu	r3,-14(fp)
81145b64:	e13ffdc4 	addi	r4,fp,-9
81145b68:	200f883a 	mov	r7,r4
81145b6c:	180d883a 	mov	r6,r3
81145b70:	100b883a 	mov	r5,r2
81145b74:	e13ffb17 	ldw	r4,-20(fp)
81145b78:	113a65c0 	call	8113a65c <OSFlagPost>
      }
81145b7c:	003fd006 	br	81145ac0 <__reset+0xfb125ac0>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
81145b80:	0001883a 	nop
81145b84:	00000106 	br	81145b8c <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
81145b88:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
81145b8c:	e0bff417 	ldw	r2,-48(fp)
81145b90:	10bfffec 	andhi	r2,r2,65535
81145b94:	10000f26 	beq	r2,zero,81145bd4 <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81145b98:	e0bff617 	ldw	r2,-40(fp)
81145b9c:	10c00817 	ldw	r3,32(r2)
81145ba0:	00bfff84 	movi	r2,-2
81145ba4:	1886703a 	and	r3,r3,r2
81145ba8:	e0bff617 	ldw	r2,-40(fp)
81145bac:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
81145bb0:	e0bff717 	ldw	r2,-36(fp)
81145bb4:	10800104 	addi	r2,r2,4
81145bb8:	1007883a 	mov	r3,r2
81145bbc:	e0bff617 	ldw	r2,-40(fp)
81145bc0:	10800817 	ldw	r2,32(r2)
81145bc4:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81145bc8:	e0bff717 	ldw	r2,-36(fp)
81145bcc:	10800104 	addi	r2,r2,4
81145bd0:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
81145bd4:	e0bff817 	ldw	r2,-32(fp)
81145bd8:	1080800c 	andi	r2,r2,512
81145bdc:	103fac26 	beq	r2,zero,81145a90 <__reset+0xfb125a90>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
81145be0:	e0bff817 	ldw	r2,-32(fp)
81145be4:	1004d43a 	srli	r2,r2,16
81145be8:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
81145bec:	00002606 	br	81145c88 <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
81145bf0:	e0bff717 	ldw	r2,-36(fp)
81145bf4:	e0fff617 	ldw	r3,-40(fp)
81145bf8:	18c01017 	ldw	r3,64(r3)
81145bfc:	e13ff617 	ldw	r4,-40(fp)
81145c00:	20c7883a 	add	r3,r4,r3
81145c04:	18c21104 	addi	r3,r3,2116
81145c08:	18c00003 	ldbu	r3,0(r3)
81145c0c:	18c03fcc 	andi	r3,r3,255
81145c10:	18c0201c 	xori	r3,r3,128
81145c14:	18ffe004 	addi	r3,r3,-128
81145c18:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81145c1c:	e0bff617 	ldw	r2,-40(fp)
81145c20:	10801017 	ldw	r2,64(r2)
81145c24:	10800044 	addi	r2,r2,1
81145c28:	10c1ffcc 	andi	r3,r2,2047
81145c2c:	e0bff617 	ldw	r2,-40(fp)
81145c30:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
81145c34:	e0bff617 	ldw	r2,-40(fp)
81145c38:	10800c17 	ldw	r2,48(r2)
81145c3c:	e0bffa15 	stw	r2,-24(fp)
81145c40:	00800084 	movi	r2,2
81145c44:	e0bffd0d 	sth	r2,-12(fp)
81145c48:	00800044 	movi	r2,1
81145c4c:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81145c50:	d0a09003 	ldbu	r2,-32192(gp)
81145c54:	10803fcc 	andi	r2,r2,255
81145c58:	10000826 	beq	r2,zero,81145c7c <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
81145c5c:	e0bffd0b 	ldhu	r2,-12(fp)
81145c60:	e0fffd83 	ldbu	r3,-10(fp)
81145c64:	e13ffe04 	addi	r4,fp,-8
81145c68:	200f883a 	mov	r7,r4
81145c6c:	180d883a 	mov	r6,r3
81145c70:	100b883a 	mov	r5,r2
81145c74:	e13ffa17 	ldw	r4,-24(fp)
81145c78:	113a65c0 	call	8113a65c <OSFlagPost>

        space--;
81145c7c:	e0bff517 	ldw	r2,-44(fp)
81145c80:	10bfffc4 	addi	r2,r2,-1
81145c84:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
81145c88:	e0bff517 	ldw	r2,-44(fp)
81145c8c:	10000526 	beq	r2,zero,81145ca4 <altera_avalon_jtag_uart_irq+0x254>
81145c90:	e0bff617 	ldw	r2,-40(fp)
81145c94:	10c01017 	ldw	r3,64(r2)
81145c98:	e0bff617 	ldw	r2,-40(fp)
81145c9c:	10800f17 	ldw	r2,60(r2)
81145ca0:	18bfd31e 	bne	r3,r2,81145bf0 <__reset+0xfb125bf0>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
81145ca4:	e0bff517 	ldw	r2,-44(fp)
81145ca8:	103f7926 	beq	r2,zero,81145a90 <__reset+0xfb125a90>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81145cac:	e0bff617 	ldw	r2,-40(fp)
81145cb0:	10c00817 	ldw	r3,32(r2)
81145cb4:	00bfff44 	movi	r2,-3
81145cb8:	1886703a 	and	r3,r3,r2
81145cbc:	e0bff617 	ldw	r2,-40(fp)
81145cc0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81145cc4:	e0bff617 	ldw	r2,-40(fp)
81145cc8:	10800017 	ldw	r2,0(r2)
81145ccc:	10800104 	addi	r2,r2,4
81145cd0:	1007883a 	mov	r3,r2
81145cd4:	e0bff617 	ldw	r2,-40(fp)
81145cd8:	10800817 	ldw	r2,32(r2)
81145cdc:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81145ce0:	e0bff717 	ldw	r2,-36(fp)
81145ce4:	10800104 	addi	r2,r2,4
81145ce8:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
81145cec:	003f6806 	br	81145a90 <__reset+0xfb125a90>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
81145cf0:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
81145cf4:	0001883a 	nop
81145cf8:	e037883a 	mov	sp,fp
81145cfc:	dfc00117 	ldw	ra,4(sp)
81145d00:	df000017 	ldw	fp,0(sp)
81145d04:	dec00204 	addi	sp,sp,8
81145d08:	f800283a 	ret

81145d0c <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
81145d0c:	defff904 	addi	sp,sp,-28
81145d10:	de00012e 	bgeu	sp,et,81145d18 <altera_avalon_jtag_uart_timeout+0xc>
81145d14:	003b68fa 	trap	3
81145d18:	dfc00615 	stw	ra,24(sp)
81145d1c:	df000515 	stw	fp,20(sp)
81145d20:	df000504 	addi	fp,sp,20
81145d24:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
81145d28:	e0bfff17 	ldw	r2,-4(fp)
81145d2c:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
81145d30:	e0bffb17 	ldw	r2,-20(fp)
81145d34:	10800017 	ldw	r2,0(r2)
81145d38:	10800104 	addi	r2,r2,4
81145d3c:	10800037 	ldwio	r2,0(r2)
81145d40:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
81145d44:	e0bffc17 	ldw	r2,-16(fp)
81145d48:	1081000c 	andi	r2,r2,1024
81145d4c:	10000b26 	beq	r2,zero,81145d7c <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
81145d50:	e0bffb17 	ldw	r2,-20(fp)
81145d54:	10800017 	ldw	r2,0(r2)
81145d58:	10800104 	addi	r2,r2,4
81145d5c:	1007883a 	mov	r3,r2
81145d60:	e0bffb17 	ldw	r2,-20(fp)
81145d64:	10800817 	ldw	r2,32(r2)
81145d68:	10810014 	ori	r2,r2,1024
81145d6c:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
81145d70:	e0bffb17 	ldw	r2,-20(fp)
81145d74:	10000915 	stw	zero,36(r2)
81145d78:	00002106 	br	81145e00 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
81145d7c:	e0bffb17 	ldw	r2,-20(fp)
81145d80:	10c00917 	ldw	r3,36(r2)
81145d84:	00a00034 	movhi	r2,32768
81145d88:	10bfff04 	addi	r2,r2,-4
81145d8c:	10c01c36 	bltu	r2,r3,81145e00 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
81145d90:	e0bffb17 	ldw	r2,-20(fp)
81145d94:	10800917 	ldw	r2,36(r2)
81145d98:	10c00044 	addi	r3,r2,1
81145d9c:	e0bffb17 	ldw	r2,-20(fp)
81145da0:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
81145da4:	e0bffb17 	ldw	r2,-20(fp)
81145da8:	10c00917 	ldw	r3,36(r2)
81145dac:	e0bffb17 	ldw	r2,-20(fp)
81145db0:	10800117 	ldw	r2,4(r2)
81145db4:	18801236 	bltu	r3,r2,81145e00 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
81145db8:	e0bffb17 	ldw	r2,-20(fp)
81145dbc:	10800c17 	ldw	r2,48(r2)
81145dc0:	e0bffd15 	stw	r2,-12(fp)
81145dc4:	00800104 	movi	r2,4
81145dc8:	e0bffe0d 	sth	r2,-8(fp)
81145dcc:	00800044 	movi	r2,1
81145dd0:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81145dd4:	d0a09003 	ldbu	r2,-32192(gp)
81145dd8:	10803fcc 	andi	r2,r2,255
81145ddc:	10000826 	beq	r2,zero,81145e00 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
81145de0:	e0bffe0b 	ldhu	r2,-8(fp)
81145de4:	e0fffe83 	ldbu	r3,-6(fp)
81145de8:	e13ffec4 	addi	r4,fp,-5
81145dec:	200f883a 	mov	r7,r4
81145df0:	180d883a 	mov	r6,r3
81145df4:	100b883a 	mov	r5,r2
81145df8:	e13ffd17 	ldw	r4,-12(fp)
81145dfc:	113a65c0 	call	8113a65c <OSFlagPost>
81145e00:	d0a08717 	ldw	r2,-32228(gp)
    }
  }

  return alt_ticks_per_second();
}
81145e04:	e037883a 	mov	sp,fp
81145e08:	dfc00117 	ldw	ra,4(sp)
81145e0c:	df000017 	ldw	fp,0(sp)
81145e10:	dec00204 	addi	sp,sp,8
81145e14:	f800283a 	ret

81145e18 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
81145e18:	defffd04 	addi	sp,sp,-12
81145e1c:	de00012e 	bgeu	sp,et,81145e24 <altera_avalon_jtag_uart_close+0xc>
81145e20:	003b68fa 	trap	3
81145e24:	df000215 	stw	fp,8(sp)
81145e28:	df000204 	addi	fp,sp,8
81145e2c:	e13ffe15 	stw	r4,-8(fp)
81145e30:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81145e34:	00000506 	br	81145e4c <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81145e38:	e0bfff17 	ldw	r2,-4(fp)
81145e3c:	1090000c 	andi	r2,r2,16384
81145e40:	10000226 	beq	r2,zero,81145e4c <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
81145e44:	00bffd44 	movi	r2,-11
81145e48:	00000b06 	br	81145e78 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81145e4c:	e0bffe17 	ldw	r2,-8(fp)
81145e50:	10c01017 	ldw	r3,64(r2)
81145e54:	e0bffe17 	ldw	r2,-8(fp)
81145e58:	10800f17 	ldw	r2,60(r2)
81145e5c:	18800526 	beq	r3,r2,81145e74 <altera_avalon_jtag_uart_close+0x5c>
81145e60:	e0bffe17 	ldw	r2,-8(fp)
81145e64:	10c00917 	ldw	r3,36(r2)
81145e68:	e0bffe17 	ldw	r2,-8(fp)
81145e6c:	10800117 	ldw	r2,4(r2)
81145e70:	18bff136 	bltu	r3,r2,81145e38 <__reset+0xfb125e38>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81145e74:	0005883a 	mov	r2,zero
}
81145e78:	e037883a 	mov	sp,fp
81145e7c:	df000017 	ldw	fp,0(sp)
81145e80:	dec00104 	addi	sp,sp,4
81145e84:	f800283a 	ret

81145e88 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
81145e88:	defffa04 	addi	sp,sp,-24
81145e8c:	de00012e 	bgeu	sp,et,81145e94 <altera_avalon_jtag_uart_ioctl+0xc>
81145e90:	003b68fa 	trap	3
81145e94:	df000515 	stw	fp,20(sp)
81145e98:	df000504 	addi	fp,sp,20
81145e9c:	e13ffd15 	stw	r4,-12(fp)
81145ea0:	e17ffe15 	stw	r5,-8(fp)
81145ea4:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
81145ea8:	00bff9c4 	movi	r2,-25
81145eac:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
81145eb0:	e0bffe17 	ldw	r2,-8(fp)
81145eb4:	10da8060 	cmpeqi	r3,r2,27137
81145eb8:	1800031e 	bne	r3,zero,81145ec8 <altera_avalon_jtag_uart_ioctl+0x40>
81145ebc:	109a80a0 	cmpeqi	r2,r2,27138
81145ec0:	1000181e 	bne	r2,zero,81145f24 <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
81145ec4:	00002906 	br	81145f6c <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
81145ec8:	e0bffd17 	ldw	r2,-12(fp)
81145ecc:	10c00117 	ldw	r3,4(r2)
81145ed0:	00a00034 	movhi	r2,32768
81145ed4:	10bfffc4 	addi	r2,r2,-1
81145ed8:	18802126 	beq	r3,r2,81145f60 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
81145edc:	e0bfff17 	ldw	r2,-4(fp)
81145ee0:	10800017 	ldw	r2,0(r2)
81145ee4:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
81145ee8:	e0bffc17 	ldw	r2,-16(fp)
81145eec:	10800090 	cmplti	r2,r2,2
81145ef0:	1000061e 	bne	r2,zero,81145f0c <altera_avalon_jtag_uart_ioctl+0x84>
81145ef4:	e0fffc17 	ldw	r3,-16(fp)
81145ef8:	00a00034 	movhi	r2,32768
81145efc:	10bfffc4 	addi	r2,r2,-1
81145f00:	18800226 	beq	r3,r2,81145f0c <altera_avalon_jtag_uart_ioctl+0x84>
81145f04:	e0bffc17 	ldw	r2,-16(fp)
81145f08:	00000206 	br	81145f14 <altera_avalon_jtag_uart_ioctl+0x8c>
81145f0c:	00a00034 	movhi	r2,32768
81145f10:	10bfff84 	addi	r2,r2,-2
81145f14:	e0fffd17 	ldw	r3,-12(fp)
81145f18:	18800115 	stw	r2,4(r3)
      rc = 0;
81145f1c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81145f20:	00000f06 	br	81145f60 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
81145f24:	e0bffd17 	ldw	r2,-12(fp)
81145f28:	10c00117 	ldw	r3,4(r2)
81145f2c:	00a00034 	movhi	r2,32768
81145f30:	10bfffc4 	addi	r2,r2,-1
81145f34:	18800c26 	beq	r3,r2,81145f68 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
81145f38:	e0bffd17 	ldw	r2,-12(fp)
81145f3c:	10c00917 	ldw	r3,36(r2)
81145f40:	e0bffd17 	ldw	r2,-12(fp)
81145f44:	10800117 	ldw	r2,4(r2)
81145f48:	1885803a 	cmpltu	r2,r3,r2
81145f4c:	10c03fcc 	andi	r3,r2,255
81145f50:	e0bfff17 	ldw	r2,-4(fp)
81145f54:	10c00015 	stw	r3,0(r2)
      rc = 0;
81145f58:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81145f5c:	00000206 	br	81145f68 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
81145f60:	0001883a 	nop
81145f64:	00000106 	br	81145f6c <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
81145f68:	0001883a 	nop

  default:
    break;
  }

  return rc;
81145f6c:	e0bffb17 	ldw	r2,-20(fp)
}
81145f70:	e037883a 	mov	sp,fp
81145f74:	df000017 	ldw	fp,0(sp)
81145f78:	dec00104 	addi	sp,sp,4
81145f7c:	f800283a 	ret

81145f80 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
81145f80:	deffed04 	addi	sp,sp,-76
81145f84:	de00012e 	bgeu	sp,et,81145f8c <altera_avalon_jtag_uart_read+0xc>
81145f88:	003b68fa 	trap	3
81145f8c:	dfc01215 	stw	ra,72(sp)
81145f90:	df001115 	stw	fp,68(sp)
81145f94:	df001104 	addi	fp,sp,68
81145f98:	e13ffc15 	stw	r4,-16(fp)
81145f9c:	e17ffd15 	stw	r5,-12(fp)
81145fa0:	e1bffe15 	stw	r6,-8(fp)
81145fa4:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
81145fa8:	e0bffd17 	ldw	r2,-12(fp)
81145fac:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
81145fb0:	e0bffc17 	ldw	r2,-16(fp)
81145fb4:	10800a17 	ldw	r2,40(r2)
81145fb8:	e0bff815 	stw	r2,-32(fp)
81145fbc:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81145fc0:	e0bff90b 	ldhu	r2,-28(fp)
81145fc4:	e0fffb04 	addi	r3,fp,-20
81145fc8:	180d883a 	mov	r6,r3
81145fcc:	100b883a 	mov	r5,r2
81145fd0:	e13ff817 	ldw	r4,-32(fp)
81145fd4:	113dcd40 	call	8113dcd4 <OSSemPend>

  while (space > 0)
81145fd8:	00006106 	br	81146160 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
81145fdc:	e0bffc17 	ldw	r2,-16(fp)
81145fe0:	10800d17 	ldw	r2,52(r2)
81145fe4:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
81145fe8:	e0bffc17 	ldw	r2,-16(fp)
81145fec:	10800e17 	ldw	r2,56(r2)
81145ff0:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
81145ff4:	e0fff317 	ldw	r3,-52(fp)
81145ff8:	e0bff417 	ldw	r2,-48(fp)
81145ffc:	18800536 	bltu	r3,r2,81146014 <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
81146000:	e0fff317 	ldw	r3,-52(fp)
81146004:	e0bff417 	ldw	r2,-48(fp)
81146008:	1885c83a 	sub	r2,r3,r2
8114600c:	e0bff115 	stw	r2,-60(fp)
81146010:	00000406 	br	81146024 <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
81146014:	00c20004 	movi	r3,2048
81146018:	e0bff417 	ldw	r2,-48(fp)
8114601c:	1885c83a 	sub	r2,r3,r2
81146020:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81146024:	e0bff117 	ldw	r2,-60(fp)
81146028:	10001e26 	beq	r2,zero,811460a4 <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
8114602c:	e0fffe17 	ldw	r3,-8(fp)
81146030:	e0bff117 	ldw	r2,-60(fp)
81146034:	1880022e 	bgeu	r3,r2,81146040 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
81146038:	e0bffe17 	ldw	r2,-8(fp)
8114603c:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
81146040:	e0bffc17 	ldw	r2,-16(fp)
81146044:	10c01104 	addi	r3,r2,68
81146048:	e0bff417 	ldw	r2,-48(fp)
8114604c:	1885883a 	add	r2,r3,r2
81146050:	e1bff117 	ldw	r6,-60(fp)
81146054:	100b883a 	mov	r5,r2
81146058:	e13ff017 	ldw	r4,-64(fp)
8114605c:	11218680 	call	81121868 <memcpy>
      ptr   += n;
81146060:	e0fff017 	ldw	r3,-64(fp)
81146064:	e0bff117 	ldw	r2,-60(fp)
81146068:	1885883a 	add	r2,r3,r2
8114606c:	e0bff015 	stw	r2,-64(fp)
      space -= n;
81146070:	e0fffe17 	ldw	r3,-8(fp)
81146074:	e0bff117 	ldw	r2,-60(fp)
81146078:	1885c83a 	sub	r2,r3,r2
8114607c:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81146080:	e0fff417 	ldw	r3,-48(fp)
81146084:	e0bff117 	ldw	r2,-60(fp)
81146088:	1885883a 	add	r2,r3,r2
8114608c:	10c1ffcc 	andi	r3,r2,2047
81146090:	e0bffc17 	ldw	r2,-16(fp)
81146094:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
81146098:	e0bffe17 	ldw	r2,-8(fp)
8114609c:	00bfcf16 	blt	zero,r2,81145fdc <__reset+0xfb125fdc>
811460a0:	00000106 	br	811460a8 <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
811460a4:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
811460a8:	e0fff017 	ldw	r3,-64(fp)
811460ac:	e0bffd17 	ldw	r2,-12(fp)
811460b0:	18802e1e 	bne	r3,r2,8114616c <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
811460b4:	e0bfff17 	ldw	r2,-4(fp)
811460b8:	1090000c 	andi	r2,r2,16384
811460bc:	10002d1e 	bne	r2,zero,81146174 <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
811460c0:	d0a09003 	ldbu	r2,-32192(gp)
811460c4:	10803fcc 	andi	r2,r2,255
811460c8:	10800058 	cmpnei	r2,r2,1
811460cc:	1000161e 	bne	r2,zero,81146128 <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
811460d0:	e0bffc17 	ldw	r2,-16(fp)
811460d4:	10800c17 	ldw	r2,48(r2)
811460d8:	e0bff215 	stw	r2,-56(fp)
811460dc:	00800144 	movi	r2,5
811460e0:	e0bff98d 	sth	r2,-26(fp)
811460e4:	00bfe0c4 	movi	r2,-125
811460e8:	e0bffa05 	stb	r2,-24(fp)
811460ec:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
811460f0:	d0a09003 	ldbu	r2,-32192(gp)
811460f4:	10803fcc 	andi	r2,r2,255
811460f8:	10001526 	beq	r2,zero,81146150 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
811460fc:	e0fff98b 	ldhu	r3,-26(fp)
81146100:	e13ffa03 	ldbu	r4,-24(fp)
81146104:	e17ffa8b 	ldhu	r5,-22(fp)
81146108:	e0bffb44 	addi	r2,fp,-19
8114610c:	d8800015 	stw	r2,0(sp)
81146110:	280f883a 	mov	r7,r5
81146114:	200d883a 	mov	r6,r4
81146118:	180b883a 	mov	r5,r3
8114611c:	e13ff217 	ldw	r4,-56(fp)
81146120:	113a0340 	call	8113a034 <OSFlagPend>
81146124:	00000a06 	br	81146150 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
81146128:	0001883a 	nop
8114612c:	e0bffc17 	ldw	r2,-16(fp)
81146130:	10c00d17 	ldw	r3,52(r2)
81146134:	e0bff317 	ldw	r2,-52(fp)
81146138:	1880051e 	bne	r3,r2,81146150 <altera_avalon_jtag_uart_read+0x1d0>
8114613c:	e0bffc17 	ldw	r2,-16(fp)
81146140:	10c00917 	ldw	r3,36(r2)
81146144:	e0bffc17 	ldw	r2,-16(fp)
81146148:	10800117 	ldw	r2,4(r2)
8114614c:	18bff736 	bltu	r3,r2,8114612c <__reset+0xfb12612c>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
81146150:	e0bffc17 	ldw	r2,-16(fp)
81146154:	10c00d17 	ldw	r3,52(r2)
81146158:	e0bff317 	ldw	r2,-52(fp)
8114615c:	18800726 	beq	r3,r2,8114617c <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
81146160:	e0bffe17 	ldw	r2,-8(fp)
81146164:	00bf9d16 	blt	zero,r2,81145fdc <__reset+0xfb125fdc>
81146168:	00000506 	br	81146180 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
8114616c:	0001883a 	nop
81146170:	00000306 	br	81146180 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
81146174:	0001883a 	nop
81146178:	00000106 	br	81146180 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
8114617c:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81146180:	e0bffc17 	ldw	r2,-16(fp)
81146184:	10800a17 	ldw	r2,40(r2)
81146188:	1009883a 	mov	r4,r2
8114618c:	113e05c0 	call	8113e05c <OSSemPost>

  if (ptr != buffer)
81146190:	e0fff017 	ldw	r3,-64(fp)
81146194:	e0bffd17 	ldw	r2,-12(fp)
81146198:	18801826 	beq	r3,r2,811461fc <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114619c:	0005303a 	rdctl	r2,status
811461a0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811461a4:	e0fff717 	ldw	r3,-36(fp)
811461a8:	00bfff84 	movi	r2,-2
811461ac:	1884703a 	and	r2,r3,r2
811461b0:	1001703a 	wrctl	status,r2
  
  return context;
811461b4:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
811461b8:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
811461bc:	e0bffc17 	ldw	r2,-16(fp)
811461c0:	10800817 	ldw	r2,32(r2)
811461c4:	10c00054 	ori	r3,r2,1
811461c8:	e0bffc17 	ldw	r2,-16(fp)
811461cc:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811461d0:	e0bffc17 	ldw	r2,-16(fp)
811461d4:	10800017 	ldw	r2,0(r2)
811461d8:	10800104 	addi	r2,r2,4
811461dc:	1007883a 	mov	r3,r2
811461e0:	e0bffc17 	ldw	r2,-16(fp)
811461e4:	10800817 	ldw	r2,32(r2)
811461e8:	18800035 	stwio	r2,0(r3)
811461ec:	e0bff617 	ldw	r2,-40(fp)
811461f0:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811461f4:	e0bff517 	ldw	r2,-44(fp)
811461f8:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
811461fc:	e0fff017 	ldw	r3,-64(fp)
81146200:	e0bffd17 	ldw	r2,-12(fp)
81146204:	18800426 	beq	r3,r2,81146218 <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
81146208:	e0fff017 	ldw	r3,-64(fp)
8114620c:	e0bffd17 	ldw	r2,-12(fp)
81146210:	1885c83a 	sub	r2,r3,r2
81146214:	00000606 	br	81146230 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
81146218:	e0bfff17 	ldw	r2,-4(fp)
8114621c:	1090000c 	andi	r2,r2,16384
81146220:	10000226 	beq	r2,zero,8114622c <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
81146224:	00bffd44 	movi	r2,-11
81146228:	00000106 	br	81146230 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
8114622c:	00bffec4 	movi	r2,-5
}
81146230:	e037883a 	mov	sp,fp
81146234:	dfc00117 	ldw	ra,4(sp)
81146238:	df000017 	ldw	fp,0(sp)
8114623c:	dec00204 	addi	sp,sp,8
81146240:	f800283a 	ret

81146244 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
81146244:	deffed04 	addi	sp,sp,-76
81146248:	de00012e 	bgeu	sp,et,81146250 <altera_avalon_jtag_uart_write+0xc>
8114624c:	003b68fa 	trap	3
81146250:	dfc01215 	stw	ra,72(sp)
81146254:	df001115 	stw	fp,68(sp)
81146258:	df001104 	addi	fp,sp,68
8114625c:	e13ffc15 	stw	r4,-16(fp)
81146260:	e17ffd15 	stw	r5,-12(fp)
81146264:	e1bffe15 	stw	r6,-8(fp)
81146268:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
8114626c:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
81146270:	e0bffd17 	ldw	r2,-12(fp)
81146274:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
81146278:	e0bffc17 	ldw	r2,-16(fp)
8114627c:	10800b17 	ldw	r2,44(r2)
81146280:	e0bff815 	stw	r2,-32(fp)
81146284:	e03ff90d 	sth	zero,-28(fp)
81146288:	e0bff90b 	ldhu	r2,-28(fp)
8114628c:	e0fffb44 	addi	r3,fp,-19
81146290:	180d883a 	mov	r6,r3
81146294:	100b883a 	mov	r5,r2
81146298:	e13ff817 	ldw	r4,-32(fp)
8114629c:	113dcd40 	call	8113dcd4 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
811462a0:	00003706 	br	81146380 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
811462a4:	e0bffc17 	ldw	r2,-16(fp)
811462a8:	10800f17 	ldw	r2,60(r2)
811462ac:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
811462b0:	e0bffc17 	ldw	r2,-16(fp)
811462b4:	10801017 	ldw	r2,64(r2)
811462b8:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
811462bc:	e0fff417 	ldw	r3,-48(fp)
811462c0:	e0bff017 	ldw	r2,-64(fp)
811462c4:	1880062e 	bgeu	r3,r2,811462e0 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
811462c8:	e0fff017 	ldw	r3,-64(fp)
811462cc:	e0bff417 	ldw	r2,-48(fp)
811462d0:	1885c83a 	sub	r2,r3,r2
811462d4:	10bfffc4 	addi	r2,r2,-1
811462d8:	e0bff115 	stw	r2,-60(fp)
811462dc:	00000b06 	br	8114630c <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
811462e0:	e0bff017 	ldw	r2,-64(fp)
811462e4:	10000526 	beq	r2,zero,811462fc <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
811462e8:	00c20004 	movi	r3,2048
811462ec:	e0bff417 	ldw	r2,-48(fp)
811462f0:	1885c83a 	sub	r2,r3,r2
811462f4:	e0bff115 	stw	r2,-60(fp)
811462f8:	00000406 	br	8114630c <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
811462fc:	00c1ffc4 	movi	r3,2047
81146300:	e0bff417 	ldw	r2,-48(fp)
81146304:	1885c83a 	sub	r2,r3,r2
81146308:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
8114630c:	e0bff117 	ldw	r2,-60(fp)
81146310:	10001e26 	beq	r2,zero,8114638c <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
81146314:	e0fffe17 	ldw	r3,-8(fp)
81146318:	e0bff117 	ldw	r2,-60(fp)
8114631c:	1880022e 	bgeu	r3,r2,81146328 <altera_avalon_jtag_uart_write+0xe4>
        n = count;
81146320:	e0bffe17 	ldw	r2,-8(fp)
81146324:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
81146328:	e0bffc17 	ldw	r2,-16(fp)
8114632c:	10c21104 	addi	r3,r2,2116
81146330:	e0bff417 	ldw	r2,-48(fp)
81146334:	1885883a 	add	r2,r3,r2
81146338:	e1bff117 	ldw	r6,-60(fp)
8114633c:	e17ffd17 	ldw	r5,-12(fp)
81146340:	1009883a 	mov	r4,r2
81146344:	11218680 	call	81121868 <memcpy>
      ptr   += n;
81146348:	e0fffd17 	ldw	r3,-12(fp)
8114634c:	e0bff117 	ldw	r2,-60(fp)
81146350:	1885883a 	add	r2,r3,r2
81146354:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
81146358:	e0fffe17 	ldw	r3,-8(fp)
8114635c:	e0bff117 	ldw	r2,-60(fp)
81146360:	1885c83a 	sub	r2,r3,r2
81146364:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81146368:	e0fff417 	ldw	r3,-48(fp)
8114636c:	e0bff117 	ldw	r2,-60(fp)
81146370:	1885883a 	add	r2,r3,r2
81146374:	10c1ffcc 	andi	r3,r2,2047
81146378:	e0bffc17 	ldw	r2,-16(fp)
8114637c:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
81146380:	e0bffe17 	ldw	r2,-8(fp)
81146384:	00bfc716 	blt	zero,r2,811462a4 <__reset+0xfb1262a4>
81146388:	00000106 	br	81146390 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
8114638c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146390:	0005303a 	rdctl	r2,status
81146394:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81146398:	e0fff717 	ldw	r3,-36(fp)
8114639c:	00bfff84 	movi	r2,-2
811463a0:	1884703a 	and	r2,r3,r2
811463a4:	1001703a 	wrctl	status,r2
  
  return context;
811463a8:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
811463ac:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
811463b0:	e0bffc17 	ldw	r2,-16(fp)
811463b4:	10800817 	ldw	r2,32(r2)
811463b8:	10c00094 	ori	r3,r2,2
811463bc:	e0bffc17 	ldw	r2,-16(fp)
811463c0:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811463c4:	e0bffc17 	ldw	r2,-16(fp)
811463c8:	10800017 	ldw	r2,0(r2)
811463cc:	10800104 	addi	r2,r2,4
811463d0:	1007883a 	mov	r3,r2
811463d4:	e0bffc17 	ldw	r2,-16(fp)
811463d8:	10800817 	ldw	r2,32(r2)
811463dc:	18800035 	stwio	r2,0(r3)
811463e0:	e0bff617 	ldw	r2,-40(fp)
811463e4:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811463e8:	e0bff317 	ldw	r2,-52(fp)
811463ec:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
811463f0:	e0bffe17 	ldw	r2,-8(fp)
811463f4:	00802a0e 	bge	zero,r2,811464a0 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
811463f8:	e0bfff17 	ldw	r2,-4(fp)
811463fc:	1090000c 	andi	r2,r2,16384
81146400:	10002a1e 	bne	r2,zero,811464ac <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
81146404:	d0a09003 	ldbu	r2,-32192(gp)
81146408:	10803fcc 	andi	r2,r2,255
8114640c:	10800058 	cmpnei	r2,r2,1
81146410:	1000161e 	bne	r2,zero,8114646c <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
81146414:	e0bffc17 	ldw	r2,-16(fp)
81146418:	10800c17 	ldw	r2,48(r2)
8114641c:	e0bff515 	stw	r2,-44(fp)
81146420:	00800184 	movi	r2,6
81146424:	e0bff98d 	sth	r2,-26(fp)
81146428:	00bfe0c4 	movi	r2,-125
8114642c:	e0bffa05 	stb	r2,-24(fp)
81146430:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81146434:	d0a09003 	ldbu	r2,-32192(gp)
81146438:	10803fcc 	andi	r2,r2,255
8114643c:	10001526 	beq	r2,zero,81146494 <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81146440:	e0fff98b 	ldhu	r3,-26(fp)
81146444:	e13ffa03 	ldbu	r4,-24(fp)
81146448:	e17ffa8b 	ldhu	r5,-22(fp)
8114644c:	e0bffb04 	addi	r2,fp,-20
81146450:	d8800015 	stw	r2,0(sp)
81146454:	280f883a 	mov	r7,r5
81146458:	200d883a 	mov	r6,r4
8114645c:	180b883a 	mov	r5,r3
81146460:	e13ff517 	ldw	r4,-44(fp)
81146464:	113a0340 	call	8113a034 <OSFlagPend>
81146468:	00000a06 	br	81146494 <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
8114646c:	0001883a 	nop
81146470:	e0bffc17 	ldw	r2,-16(fp)
81146474:	10c01017 	ldw	r3,64(r2)
81146478:	e0bff017 	ldw	r2,-64(fp)
8114647c:	1880051e 	bne	r3,r2,81146494 <altera_avalon_jtag_uart_write+0x250>
81146480:	e0bffc17 	ldw	r2,-16(fp)
81146484:	10c00917 	ldw	r3,36(r2)
81146488:	e0bffc17 	ldw	r2,-16(fp)
8114648c:	10800117 	ldw	r2,4(r2)
81146490:	18bff736 	bltu	r3,r2,81146470 <__reset+0xfb126470>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
81146494:	e0bffc17 	ldw	r2,-16(fp)
81146498:	10800917 	ldw	r2,36(r2)
8114649c:	1000051e 	bne	r2,zero,811464b4 <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
811464a0:	e0bffe17 	ldw	r2,-8(fp)
811464a4:	00bfb616 	blt	zero,r2,81146380 <__reset+0xfb126380>
811464a8:	00000306 	br	811464b8 <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
811464ac:	0001883a 	nop
811464b0:	00000106 	br	811464b8 <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
811464b4:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
811464b8:	e0bffc17 	ldw	r2,-16(fp)
811464bc:	10800b17 	ldw	r2,44(r2)
811464c0:	1009883a 	mov	r4,r2
811464c4:	113e05c0 	call	8113e05c <OSSemPost>

  if (ptr != start)
811464c8:	e0fffd17 	ldw	r3,-12(fp)
811464cc:	e0bff217 	ldw	r2,-56(fp)
811464d0:	18800426 	beq	r3,r2,811464e4 <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
811464d4:	e0fffd17 	ldw	r3,-12(fp)
811464d8:	e0bff217 	ldw	r2,-56(fp)
811464dc:	1885c83a 	sub	r2,r3,r2
811464e0:	00000606 	br	811464fc <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
811464e4:	e0bfff17 	ldw	r2,-4(fp)
811464e8:	1090000c 	andi	r2,r2,16384
811464ec:	10000226 	beq	r2,zero,811464f8 <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
811464f0:	00bffd44 	movi	r2,-11
811464f4:	00000106 	br	811464fc <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
811464f8:	00bffec4 	movi	r2,-5
}
811464fc:	e037883a 	mov	sp,fp
81146500:	dfc00117 	ldw	ra,4(sp)
81146504:	df000017 	ldw	fp,0(sp)
81146508:	dec00204 	addi	sp,sp,8
8114650c:	f800283a 	ret

81146510 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
81146510:	defffa04 	addi	sp,sp,-24
81146514:	de00012e 	bgeu	sp,et,8114651c <alt_avalon_timer_sc_irq+0xc>
81146518:	003b68fa 	trap	3
8114651c:	dfc00515 	stw	ra,20(sp)
81146520:	df000415 	stw	fp,16(sp)
81146524:	df000404 	addi	fp,sp,16
81146528:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
8114652c:	0007883a 	mov	r3,zero
81146530:	e0bfff17 	ldw	r2,-4(fp)
81146534:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
81146538:	e0bfff17 	ldw	r2,-4(fp)
8114653c:	10800104 	addi	r2,r2,4
81146540:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
81146544:	11365100 	call	81136510 <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146548:	0005303a 	rdctl	r2,status
8114654c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81146550:	e0fffd17 	ldw	r3,-12(fp)
81146554:	00bfff84 	movi	r2,-2
81146558:	1884703a 	and	r2,r3,r2
8114655c:	1001703a 	wrctl	status,r2
  
  return context;
81146560:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
81146564:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
81146568:	1136dc00 	call	81136dc0 <alt_tick>
8114656c:	e0bffc17 	ldw	r2,-16(fp)
81146570:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81146574:	e0bffe17 	ldw	r2,-8(fp)
81146578:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
8114657c:	0001883a 	nop
81146580:	e037883a 	mov	sp,fp
81146584:	dfc00117 	ldw	ra,4(sp)
81146588:	df000017 	ldw	fp,0(sp)
8114658c:	dec00204 	addi	sp,sp,8
81146590:	f800283a 	ret

81146594 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
81146594:	defff804 	addi	sp,sp,-32
81146598:	de00012e 	bgeu	sp,et,811465a0 <alt_avalon_timer_sc_init+0xc>
8114659c:	003b68fa 	trap	3
811465a0:	dfc00715 	stw	ra,28(sp)
811465a4:	df000615 	stw	fp,24(sp)
811465a8:	df000604 	addi	fp,sp,24
811465ac:	e13ffc15 	stw	r4,-16(fp)
811465b0:	e17ffd15 	stw	r5,-12(fp)
811465b4:	e1bffe15 	stw	r6,-8(fp)
811465b8:	e1ffff15 	stw	r7,-4(fp)
811465bc:	e0bfff17 	ldw	r2,-4(fp)
811465c0:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
811465c4:	d0a08717 	ldw	r2,-32228(gp)
811465c8:	1000021e 	bne	r2,zero,811465d4 <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
811465cc:	e0bffb17 	ldw	r2,-20(fp)
811465d0:	d0a08715 	stw	r2,-32228(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
811465d4:	e0bffc17 	ldw	r2,-16(fp)
811465d8:	10800104 	addi	r2,r2,4
811465dc:	00c001c4 	movi	r3,7
811465e0:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
811465e4:	d8000015 	stw	zero,0(sp)
811465e8:	e1fffc17 	ldw	r7,-16(fp)
811465ec:	01a04534 	movhi	r6,33044
811465f0:	31994404 	addi	r6,r6,25872
811465f4:	e17ffe17 	ldw	r5,-8(fp)
811465f8:	e13ffd17 	ldw	r4,-12(fp)
811465fc:	11497980 	call	81149798 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
81146600:	0001883a 	nop
81146604:	e037883a 	mov	sp,fp
81146608:	dfc00117 	ldw	ra,4(sp)
8114660c:	df000017 	ldw	fp,0(sp)
81146610:	dec00204 	addi	sp,sp,8
81146614:	f800283a 	ret

81146618 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81146618:	defffa04 	addi	sp,sp,-24
8114661c:	de00012e 	bgeu	sp,et,81146624 <altera_avalon_uart_read_fd+0xc>
81146620:	003b68fa 	trap	3
81146624:	dfc00515 	stw	ra,20(sp)
81146628:	df000415 	stw	fp,16(sp)
8114662c:	df000404 	addi	fp,sp,16
81146630:	e13ffd15 	stw	r4,-12(fp)
81146634:	e17ffe15 	stw	r5,-8(fp)
81146638:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8114663c:	e0bffd17 	ldw	r2,-12(fp)
81146640:	10800017 	ldw	r2,0(r2)
81146644:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
81146648:	e0bffc17 	ldw	r2,-16(fp)
8114664c:	10c00a04 	addi	r3,r2,40
81146650:	e0bffd17 	ldw	r2,-12(fp)
81146654:	10800217 	ldw	r2,8(r2)
81146658:	100f883a 	mov	r7,r2
8114665c:	e1bfff17 	ldw	r6,-4(fp)
81146660:	e17ffe17 	ldw	r5,-8(fp)
81146664:	1809883a 	mov	r4,r3
81146668:	1146cd80 	call	81146cd8 <altera_avalon_uart_read>
      fd->fd_flags);
}
8114666c:	e037883a 	mov	sp,fp
81146670:	dfc00117 	ldw	ra,4(sp)
81146674:	df000017 	ldw	fp,0(sp)
81146678:	dec00204 	addi	sp,sp,8
8114667c:	f800283a 	ret

81146680 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81146680:	defffa04 	addi	sp,sp,-24
81146684:	de00012e 	bgeu	sp,et,8114668c <altera_avalon_uart_write_fd+0xc>
81146688:	003b68fa 	trap	3
8114668c:	dfc00515 	stw	ra,20(sp)
81146690:	df000415 	stw	fp,16(sp)
81146694:	df000404 	addi	fp,sp,16
81146698:	e13ffd15 	stw	r4,-12(fp)
8114669c:	e17ffe15 	stw	r5,-8(fp)
811466a0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
811466a4:	e0bffd17 	ldw	r2,-12(fp)
811466a8:	10800017 	ldw	r2,0(r2)
811466ac:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
811466b0:	e0bffc17 	ldw	r2,-16(fp)
811466b4:	10c00a04 	addi	r3,r2,40
811466b8:	e0bffd17 	ldw	r2,-12(fp)
811466bc:	10800217 	ldw	r2,8(r2)
811466c0:	100f883a 	mov	r7,r2
811466c4:	e1bfff17 	ldw	r6,-4(fp)
811466c8:	e17ffe17 	ldw	r5,-8(fp)
811466cc:	1809883a 	mov	r4,r3
811466d0:	1146f8c0 	call	81146f8c <altera_avalon_uart_write>
      fd->fd_flags);
}
811466d4:	e037883a 	mov	sp,fp
811466d8:	dfc00117 	ldw	ra,4(sp)
811466dc:	df000017 	ldw	fp,0(sp)
811466e0:	dec00204 	addi	sp,sp,8
811466e4:	f800283a 	ret

811466e8 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
811466e8:	defffc04 	addi	sp,sp,-16
811466ec:	de00012e 	bgeu	sp,et,811466f4 <altera_avalon_uart_close_fd+0xc>
811466f0:	003b68fa 	trap	3
811466f4:	dfc00315 	stw	ra,12(sp)
811466f8:	df000215 	stw	fp,8(sp)
811466fc:	df000204 	addi	fp,sp,8
81146700:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81146704:	e0bfff17 	ldw	r2,-4(fp)
81146708:	10800017 	ldw	r2,0(r2)
8114670c:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
81146710:	e0bffe17 	ldw	r2,-8(fp)
81146714:	10c00a04 	addi	r3,r2,40
81146718:	e0bfff17 	ldw	r2,-4(fp)
8114671c:	10800217 	ldw	r2,8(r2)
81146720:	100b883a 	mov	r5,r2
81146724:	1809883a 	mov	r4,r3
81146728:	1146c380 	call	81146c38 <altera_avalon_uart_close>
}
8114672c:	e037883a 	mov	sp,fp
81146730:	dfc00117 	ldw	ra,4(sp)
81146734:	df000017 	ldw	fp,0(sp)
81146738:	dec00204 	addi	sp,sp,8
8114673c:	f800283a 	ret

81146740 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
81146740:	defff304 	addi	sp,sp,-52
81146744:	de00012e 	bgeu	sp,et,8114674c <altera_avalon_uart_init+0xc>
81146748:	003b68fa 	trap	3
8114674c:	dfc00c15 	stw	ra,48(sp)
81146750:	df000b15 	stw	fp,44(sp)
81146754:	df000b04 	addi	fp,sp,44
81146758:	e13ffd15 	stw	r4,-12(fp)
8114675c:	e17ffe15 	stw	r5,-8(fp)
81146760:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
81146764:	e0bffd17 	ldw	r2,-12(fp)
81146768:	10800017 	ldw	r2,0(r2)
8114676c:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81146770:	e0bffd17 	ldw	r2,-12(fp)
81146774:	10800704 	addi	r2,r2,28
81146778:	e0bffa15 	stw	r2,-24(fp)
8114677c:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81146780:	e0bffb0b 	ldhu	r2,-20(fp)
81146784:	e0fffc84 	addi	r3,fp,-14
81146788:	180b883a 	mov	r5,r3
8114678c:	1009883a 	mov	r4,r2
81146790:	1139a500 	call	81139a50 <OSFlagCreate>
81146794:	1007883a 	mov	r3,r2
81146798:	e0bffa17 	ldw	r2,-24(fp)
8114679c:	10c00015 	stw	r3,0(r2)
  return err;
811467a0:	e0bffc83 	ldbu	r2,-14(fp)
811467a4:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
811467a8:	1000241e 	bne	r2,zero,8114683c <altera_avalon_uart_init+0xfc>
811467ac:	e0bffd17 	ldw	r2,-12(fp)
811467b0:	10800804 	addi	r2,r2,32
811467b4:	e0bff715 	stw	r2,-36(fp)
811467b8:	00800044 	movi	r2,1
811467bc:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811467c0:	e0bffb8b 	ldhu	r2,-18(fp)
811467c4:	1009883a 	mov	r4,r2
811467c8:	113d9ac0 	call	8113d9ac <OSSemCreate>
811467cc:	1007883a 	mov	r3,r2
811467d0:	e0bff717 	ldw	r2,-36(fp)
811467d4:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
811467d8:	e0bff717 	ldw	r2,-36(fp)
811467dc:	10800017 	ldw	r2,0(r2)
811467e0:	10000226 	beq	r2,zero,811467ec <altera_avalon_uart_init+0xac>
811467e4:	0005883a 	mov	r2,zero
811467e8:	00000106 	br	811467f0 <altera_avalon_uart_init+0xb0>
811467ec:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
811467f0:	1000121e 	bne	r2,zero,8114683c <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
811467f4:	e0bffd17 	ldw	r2,-12(fp)
811467f8:	10800904 	addi	r2,r2,36
811467fc:	e0bff815 	stw	r2,-32(fp)
81146800:	00800044 	movi	r2,1
81146804:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81146808:	e0bffc0b 	ldhu	r2,-16(fp)
8114680c:	1009883a 	mov	r4,r2
81146810:	113d9ac0 	call	8113d9ac <OSSemCreate>
81146814:	1007883a 	mov	r3,r2
81146818:	e0bff817 	ldw	r2,-32(fp)
8114681c:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81146820:	e0bff817 	ldw	r2,-32(fp)
81146824:	10800017 	ldw	r2,0(r2)
81146828:	10000226 	beq	r2,zero,81146834 <altera_avalon_uart_init+0xf4>
8114682c:	0005883a 	mov	r2,zero
81146830:	00000106 	br	81146838 <altera_avalon_uart_init+0xf8>
81146834:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81146838:	10000226 	beq	r2,zero,81146844 <altera_avalon_uart_init+0x104>
8114683c:	00800044 	movi	r2,1
81146840:	00000106 	br	81146848 <altera_avalon_uart_init+0x108>
81146844:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81146848:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
8114684c:	e0bff917 	ldw	r2,-28(fp)
81146850:	10000f1e 	bne	r2,zero,81146890 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
81146854:	e0bffd17 	ldw	r2,-12(fp)
81146858:	00c32004 	movi	r3,3200
8114685c:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
81146860:	e0bff617 	ldw	r2,-40(fp)
81146864:	10800304 	addi	r2,r2,12
81146868:	e0fffd17 	ldw	r3,-12(fp)
8114686c:	18c00117 	ldw	r3,4(r3)
81146870:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
81146874:	d8000015 	stw	zero,0(sp)
81146878:	e1fffd17 	ldw	r7,-12(fp)
8114687c:	01a04534 	movhi	r6,33044
81146880:	319a2a04 	addi	r6,r6,26792
81146884:	e17fff17 	ldw	r5,-4(fp)
81146888:	e13ffe17 	ldw	r4,-8(fp)
8114688c:	11497980 	call	81149798 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
81146890:	0001883a 	nop
81146894:	e037883a 	mov	sp,fp
81146898:	dfc00117 	ldw	ra,4(sp)
8114689c:	df000017 	ldw	fp,0(sp)
811468a0:	dec00204 	addi	sp,sp,8
811468a4:	f800283a 	ret

811468a8 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
811468a8:	defffa04 	addi	sp,sp,-24
811468ac:	de00012e 	bgeu	sp,et,811468b4 <altera_avalon_uart_irq+0xc>
811468b0:	003b68fa 	trap	3
811468b4:	dfc00515 	stw	ra,20(sp)
811468b8:	df000415 	stw	fp,16(sp)
811468bc:	df000404 	addi	fp,sp,16
811468c0:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
811468c4:	e0bfff17 	ldw	r2,-4(fp)
811468c8:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
811468cc:	e0bffc17 	ldw	r2,-16(fp)
811468d0:	10800017 	ldw	r2,0(r2)
811468d4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
811468d8:	e0bffd17 	ldw	r2,-12(fp)
811468dc:	10800204 	addi	r2,r2,8
811468e0:	10800037 	ldwio	r2,0(r2)
811468e4:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
811468e8:	e0bffd17 	ldw	r2,-12(fp)
811468ec:	10800204 	addi	r2,r2,8
811468f0:	0007883a 	mov	r3,zero
811468f4:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
811468f8:	e0bffd17 	ldw	r2,-12(fp)
811468fc:	10800204 	addi	r2,r2,8
81146900:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
81146904:	e0bffe17 	ldw	r2,-8(fp)
81146908:	1080200c 	andi	r2,r2,128
8114690c:	10000326 	beq	r2,zero,8114691c <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
81146910:	e17ffe17 	ldw	r5,-8(fp)
81146914:	e13ffc17 	ldw	r4,-16(fp)
81146918:	114694c0 	call	8114694c <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
8114691c:	e0bffe17 	ldw	r2,-8(fp)
81146920:	1081100c 	andi	r2,r2,1088
81146924:	10000326 	beq	r2,zero,81146934 <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
81146928:	e17ffe17 	ldw	r5,-8(fp)
8114692c:	e13ffc17 	ldw	r4,-16(fp)
81146930:	1146a8c0 	call	81146a8c <altera_avalon_uart_txirq>
  }
  

}
81146934:	0001883a 	nop
81146938:	e037883a 	mov	sp,fp
8114693c:	dfc00117 	ldw	ra,4(sp)
81146940:	df000017 	ldw	fp,0(sp)
81146944:	dec00204 	addi	sp,sp,8
81146948:	f800283a 	ret

8114694c <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
8114694c:	defff904 	addi	sp,sp,-28
81146950:	de00012e 	bgeu	sp,et,81146958 <altera_avalon_uart_rxirq+0xc>
81146954:	003b68fa 	trap	3
81146958:	dfc00615 	stw	ra,24(sp)
8114695c:	df000515 	stw	fp,20(sp)
81146960:	df000504 	addi	fp,sp,20
81146964:	e13ffe15 	stw	r4,-8(fp)
81146968:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
8114696c:	e0bfff17 	ldw	r2,-4(fp)
81146970:	108000cc 	andi	r2,r2,3
81146974:	10003f1e 	bne	r2,zero,81146a74 <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
81146978:	e0bffe17 	ldw	r2,-8(fp)
8114697c:	10c00317 	ldw	r3,12(r2)
81146980:	e0bffe17 	ldw	r2,-8(fp)
81146984:	10800217 	ldw	r2,8(r2)
81146988:	1880121e 	bne	r3,r2,811469d4 <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
8114698c:	e0bffe17 	ldw	r2,-8(fp)
81146990:	10800717 	ldw	r2,28(r2)
81146994:	e0bffc15 	stw	r2,-16(fp)
81146998:	00800044 	movi	r2,1
8114699c:	e0bffd0d 	sth	r2,-12(fp)
811469a0:	00800044 	movi	r2,1
811469a4:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811469a8:	d0a09003 	ldbu	r2,-32192(gp)
811469ac:	10803fcc 	andi	r2,r2,255
811469b0:	10000826 	beq	r2,zero,811469d4 <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
811469b4:	e0bffd0b 	ldhu	r2,-12(fp)
811469b8:	e0fffd83 	ldbu	r3,-10(fp)
811469bc:	e13ffdc4 	addi	r4,fp,-9
811469c0:	200f883a 	mov	r7,r4
811469c4:	180d883a 	mov	r6,r3
811469c8:	100b883a 	mov	r5,r2
811469cc:	e13ffc17 	ldw	r4,-16(fp)
811469d0:	113a65c0 	call	8113a65c <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
811469d4:	e0bffe17 	ldw	r2,-8(fp)
811469d8:	10800317 	ldw	r2,12(r2)
811469dc:	10800044 	addi	r2,r2,1
811469e0:	10800fcc 	andi	r2,r2,63
811469e4:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
811469e8:	e0bffe17 	ldw	r2,-8(fp)
811469ec:	10800317 	ldw	r2,12(r2)
811469f0:	e0fffe17 	ldw	r3,-8(fp)
811469f4:	18c00017 	ldw	r3,0(r3)
811469f8:	18c00037 	ldwio	r3,0(r3)
811469fc:	1809883a 	mov	r4,r3
81146a00:	e0fffe17 	ldw	r3,-8(fp)
81146a04:	1885883a 	add	r2,r3,r2
81146a08:	10800a04 	addi	r2,r2,40
81146a0c:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
81146a10:	e0bffe17 	ldw	r2,-8(fp)
81146a14:	e0fffb17 	ldw	r3,-20(fp)
81146a18:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81146a1c:	e0bffe17 	ldw	r2,-8(fp)
81146a20:	10800317 	ldw	r2,12(r2)
81146a24:	10800044 	addi	r2,r2,1
81146a28:	10800fcc 	andi	r2,r2,63
81146a2c:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
81146a30:	e0bffe17 	ldw	r2,-8(fp)
81146a34:	10c00217 	ldw	r3,8(r2)
81146a38:	e0bffb17 	ldw	r2,-20(fp)
81146a3c:	18800e1e 	bne	r3,r2,81146a78 <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81146a40:	e0bffe17 	ldw	r2,-8(fp)
81146a44:	10c00117 	ldw	r3,4(r2)
81146a48:	00bfdfc4 	movi	r2,-129
81146a4c:	1886703a 	and	r3,r3,r2
81146a50:	e0bffe17 	ldw	r2,-8(fp)
81146a54:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
81146a58:	e0bffe17 	ldw	r2,-8(fp)
81146a5c:	10800017 	ldw	r2,0(r2)
81146a60:	10800304 	addi	r2,r2,12
81146a64:	e0fffe17 	ldw	r3,-8(fp)
81146a68:	18c00117 	ldw	r3,4(r3)
81146a6c:	10c00035 	stwio	r3,0(r2)
81146a70:	00000106 	br	81146a78 <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
81146a74:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
81146a78:	e037883a 	mov	sp,fp
81146a7c:	dfc00117 	ldw	ra,4(sp)
81146a80:	df000017 	ldw	fp,0(sp)
81146a84:	dec00204 	addi	sp,sp,8
81146a88:	f800283a 	ret

81146a8c <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81146a8c:	defffa04 	addi	sp,sp,-24
81146a90:	de00012e 	bgeu	sp,et,81146a98 <altera_avalon_uart_txirq+0xc>
81146a94:	003b68fa 	trap	3
81146a98:	dfc00515 	stw	ra,20(sp)
81146a9c:	df000415 	stw	fp,16(sp)
81146aa0:	df000404 	addi	fp,sp,16
81146aa4:	e13ffe15 	stw	r4,-8(fp)
81146aa8:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
81146aac:	e0bffe17 	ldw	r2,-8(fp)
81146ab0:	10c00417 	ldw	r3,16(r2)
81146ab4:	e0bffe17 	ldw	r2,-8(fp)
81146ab8:	10800517 	ldw	r2,20(r2)
81146abc:	18804726 	beq	r3,r2,81146bdc <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
81146ac0:	e0bffe17 	ldw	r2,-8(fp)
81146ac4:	10800617 	ldw	r2,24(r2)
81146ac8:	1080008c 	andi	r2,r2,2
81146acc:	10000326 	beq	r2,zero,81146adc <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
81146ad0:	e0bfff17 	ldw	r2,-4(fp)
81146ad4:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
81146ad8:	10003226 	beq	r2,zero,81146ba4 <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
81146adc:	e0bffe17 	ldw	r2,-8(fp)
81146ae0:	10c00417 	ldw	r3,16(r2)
81146ae4:	e0bffe17 	ldw	r2,-8(fp)
81146ae8:	10800517 	ldw	r2,20(r2)
81146aec:	10800044 	addi	r2,r2,1
81146af0:	10800fcc 	andi	r2,r2,63
81146af4:	1880121e 	bne	r3,r2,81146b40 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
81146af8:	e0bffe17 	ldw	r2,-8(fp)
81146afc:	10800717 	ldw	r2,28(r2)
81146b00:	e0bffc15 	stw	r2,-16(fp)
81146b04:	00800084 	movi	r2,2
81146b08:	e0bffd0d 	sth	r2,-12(fp)
81146b0c:	00800044 	movi	r2,1
81146b10:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81146b14:	d0a09003 	ldbu	r2,-32192(gp)
81146b18:	10803fcc 	andi	r2,r2,255
81146b1c:	10000826 	beq	r2,zero,81146b40 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
81146b20:	e0bffd0b 	ldhu	r2,-12(fp)
81146b24:	e0fffd83 	ldbu	r3,-10(fp)
81146b28:	e13ffdc4 	addi	r4,fp,-9
81146b2c:	200f883a 	mov	r7,r4
81146b30:	180d883a 	mov	r6,r3
81146b34:	100b883a 	mov	r5,r2
81146b38:	e13ffc17 	ldw	r4,-16(fp)
81146b3c:	113a65c0 	call	8113a65c <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
81146b40:	e0bffe17 	ldw	r2,-8(fp)
81146b44:	10800017 	ldw	r2,0(r2)
81146b48:	10800104 	addi	r2,r2,4
81146b4c:	e0fffe17 	ldw	r3,-8(fp)
81146b50:	18c00417 	ldw	r3,16(r3)
81146b54:	e13ffe17 	ldw	r4,-8(fp)
81146b58:	20c7883a 	add	r3,r4,r3
81146b5c:	18c01a04 	addi	r3,r3,104
81146b60:	18c00003 	ldbu	r3,0(r3)
81146b64:	18c03fcc 	andi	r3,r3,255
81146b68:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
81146b6c:	e0bffe17 	ldw	r2,-8(fp)
81146b70:	10800417 	ldw	r2,16(r2)
81146b74:	10800044 	addi	r2,r2,1
81146b78:	e0fffe17 	ldw	r3,-8(fp)
81146b7c:	18800415 	stw	r2,16(r3)
81146b80:	10c00fcc 	andi	r3,r2,63
81146b84:	e0bffe17 	ldw	r2,-8(fp)
81146b88:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
81146b8c:	e0bffe17 	ldw	r2,-8(fp)
81146b90:	10800117 	ldw	r2,4(r2)
81146b94:	10c01014 	ori	r3,r2,64
81146b98:	e0bffe17 	ldw	r2,-8(fp)
81146b9c:	10c00115 	stw	r3,4(r2)
81146ba0:	00000e06 	br	81146bdc <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
81146ba4:	e0bffe17 	ldw	r2,-8(fp)
81146ba8:	10800017 	ldw	r2,0(r2)
81146bac:	10800204 	addi	r2,r2,8
81146bb0:	10800037 	ldwio	r2,0(r2)
81146bb4:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
81146bb8:	e0bfff17 	ldw	r2,-4(fp)
81146bbc:	1082000c 	andi	r2,r2,2048
81146bc0:	1000061e 	bne	r2,zero,81146bdc <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
81146bc4:	e0bffe17 	ldw	r2,-8(fp)
81146bc8:	10c00117 	ldw	r3,4(r2)
81146bcc:	00bfefc4 	movi	r2,-65
81146bd0:	1886703a 	and	r3,r3,r2
81146bd4:	e0bffe17 	ldw	r2,-8(fp)
81146bd8:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
81146bdc:	e0bffe17 	ldw	r2,-8(fp)
81146be0:	10c00417 	ldw	r3,16(r2)
81146be4:	e0bffe17 	ldw	r2,-8(fp)
81146be8:	10800517 	ldw	r2,20(r2)
81146bec:	1880061e 	bne	r3,r2,81146c08 <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81146bf0:	e0bffe17 	ldw	r2,-8(fp)
81146bf4:	10c00117 	ldw	r3,4(r2)
81146bf8:	00beefc4 	movi	r2,-1089
81146bfc:	1886703a 	and	r3,r3,r2
81146c00:	e0bffe17 	ldw	r2,-8(fp)
81146c04:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81146c08:	e0bffe17 	ldw	r2,-8(fp)
81146c0c:	10800017 	ldw	r2,0(r2)
81146c10:	10800304 	addi	r2,r2,12
81146c14:	e0fffe17 	ldw	r3,-8(fp)
81146c18:	18c00117 	ldw	r3,4(r3)
81146c1c:	10c00035 	stwio	r3,0(r2)
}
81146c20:	0001883a 	nop
81146c24:	e037883a 	mov	sp,fp
81146c28:	dfc00117 	ldw	ra,4(sp)
81146c2c:	df000017 	ldw	fp,0(sp)
81146c30:	dec00204 	addi	sp,sp,8
81146c34:	f800283a 	ret

81146c38 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
81146c38:	defffd04 	addi	sp,sp,-12
81146c3c:	de00012e 	bgeu	sp,et,81146c44 <altera_avalon_uart_close+0xc>
81146c40:	003b68fa 	trap	3
81146c44:	df000215 	stw	fp,8(sp)
81146c48:	df000204 	addi	fp,sp,8
81146c4c:	e13ffe15 	stw	r4,-8(fp)
81146c50:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81146c54:	00000506 	br	81146c6c <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81146c58:	e0bfff17 	ldw	r2,-4(fp)
81146c5c:	1090000c 	andi	r2,r2,16384
81146c60:	10000226 	beq	r2,zero,81146c6c <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
81146c64:	00bffd44 	movi	r2,-11
81146c68:	00000606 	br	81146c84 <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81146c6c:	e0bffe17 	ldw	r2,-8(fp)
81146c70:	10c00417 	ldw	r3,16(r2)
81146c74:	e0bffe17 	ldw	r2,-8(fp)
81146c78:	10800517 	ldw	r2,20(r2)
81146c7c:	18bff61e 	bne	r3,r2,81146c58 <__reset+0xfb126c58>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81146c80:	0005883a 	mov	r2,zero
}
81146c84:	e037883a 	mov	sp,fp
81146c88:	df000017 	ldw	fp,0(sp)
81146c8c:	dec00104 	addi	sp,sp,4
81146c90:	f800283a 	ret

81146c94 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81146c94:	defffe04 	addi	sp,sp,-8
81146c98:	de00012e 	bgeu	sp,et,81146ca0 <alt_get_errno+0xc>
81146c9c:	003b68fa 	trap	3
81146ca0:	dfc00115 	stw	ra,4(sp)
81146ca4:	df000015 	stw	fp,0(sp)
81146ca8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81146cac:	d0a01017 	ldw	r2,-32704(gp)
81146cb0:	10000326 	beq	r2,zero,81146cc0 <alt_get_errno+0x2c>
81146cb4:	d0a01017 	ldw	r2,-32704(gp)
81146cb8:	103ee83a 	callr	r2
81146cbc:	00000106 	br	81146cc4 <alt_get_errno+0x30>
81146cc0:	d0a07704 	addi	r2,gp,-32292
}
81146cc4:	e037883a 	mov	sp,fp
81146cc8:	dfc00117 	ldw	ra,4(sp)
81146ccc:	df000017 	ldw	fp,0(sp)
81146cd0:	dec00204 	addi	sp,sp,8
81146cd4:	f800283a 	ret

81146cd8 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
81146cd8:	deffec04 	addi	sp,sp,-80
81146cdc:	de00012e 	bgeu	sp,et,81146ce4 <altera_avalon_uart_read+0xc>
81146ce0:	003b68fa 	trap	3
81146ce4:	dfc01315 	stw	ra,76(sp)
81146ce8:	df001215 	stw	fp,72(sp)
81146cec:	df001204 	addi	fp,sp,72
81146cf0:	e13ffc15 	stw	r4,-16(fp)
81146cf4:	e17ffd15 	stw	r5,-12(fp)
81146cf8:	e1bffe15 	stw	r6,-8(fp)
81146cfc:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
81146d00:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
81146d04:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
81146d08:	e0bfff17 	ldw	r2,-4(fp)
81146d0c:	1090000c 	andi	r2,r2,16384
81146d10:	1005003a 	cmpeq	r2,r2,zero
81146d14:	10803fcc 	andi	r2,r2,255
81146d18:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
81146d1c:	e0bffc17 	ldw	r2,-16(fp)
81146d20:	10800817 	ldw	r2,32(r2)
81146d24:	e0bff815 	stw	r2,-32(fp)
81146d28:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81146d2c:	e0bff90b 	ldhu	r2,-28(fp)
81146d30:	e0fffb44 	addi	r3,fp,-19
81146d34:	180d883a 	mov	r6,r3
81146d38:	100b883a 	mov	r5,r2
81146d3c:	e13ff817 	ldw	r4,-32(fp)
81146d40:	113dcd40 	call	8113dcd4 <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81146d44:	00001306 	br	81146d94 <altera_avalon_uart_read+0xbc>
    {
      count++;
81146d48:	e0bff017 	ldw	r2,-64(fp)
81146d4c:	10800044 	addi	r2,r2,1
81146d50:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
81146d54:	e0bffd17 	ldw	r2,-12(fp)
81146d58:	10c00044 	addi	r3,r2,1
81146d5c:	e0fffd15 	stw	r3,-12(fp)
81146d60:	e0fffc17 	ldw	r3,-16(fp)
81146d64:	18c00217 	ldw	r3,8(r3)
81146d68:	e13ffc17 	ldw	r4,-16(fp)
81146d6c:	20c7883a 	add	r3,r4,r3
81146d70:	18c00a04 	addi	r3,r3,40
81146d74:	18c00003 	ldbu	r3,0(r3)
81146d78:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
81146d7c:	e0bffc17 	ldw	r2,-16(fp)
81146d80:	10800217 	ldw	r2,8(r2)
81146d84:	10800044 	addi	r2,r2,1
81146d88:	10c00fcc 	andi	r3,r2,63
81146d8c:	e0bffc17 	ldw	r2,-16(fp)
81146d90:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81146d94:	e0fff017 	ldw	r3,-64(fp)
81146d98:	e0bffe17 	ldw	r2,-8(fp)
81146d9c:	1880050e 	bge	r3,r2,81146db4 <altera_avalon_uart_read+0xdc>
81146da0:	e0bffc17 	ldw	r2,-16(fp)
81146da4:	10c00217 	ldw	r3,8(r2)
81146da8:	e0bffc17 	ldw	r2,-16(fp)
81146dac:	10800317 	ldw	r2,12(r2)
81146db0:	18bfe51e 	bne	r3,r2,81146d48 <__reset+0xfb126d48>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
81146db4:	e0bff017 	ldw	r2,-64(fp)
81146db8:	10003a1e 	bne	r2,zero,81146ea4 <altera_avalon_uart_read+0x1cc>
81146dbc:	e0bffc17 	ldw	r2,-16(fp)
81146dc0:	10c00217 	ldw	r3,8(r2)
81146dc4:	e0bffc17 	ldw	r2,-16(fp)
81146dc8:	10800317 	ldw	r2,12(r2)
81146dcc:	1880351e 	bne	r3,r2,81146ea4 <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
81146dd0:	e0bff117 	ldw	r2,-60(fp)
81146dd4:	1000071e 	bne	r2,zero,81146df4 <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
81146dd8:	1146c940 	call	81146c94 <alt_get_errno>
81146ddc:	1007883a 	mov	r3,r2
81146de0:	008002c4 	movi	r2,11
81146de4:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
81146de8:	00800044 	movi	r2,1
81146dec:	e0bfef05 	stb	r2,-68(fp)
        break;
81146df0:	00003006 	br	81146eb4 <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146df4:	0005303a 	rdctl	r2,status
81146df8:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81146dfc:	e0fff517 	ldw	r3,-44(fp)
81146e00:	00bfff84 	movi	r2,-2
81146e04:	1884703a 	and	r2,r3,r2
81146e08:	1001703a 	wrctl	status,r2
  
  return context;
81146e0c:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
81146e10:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81146e14:	e0bffc17 	ldw	r2,-16(fp)
81146e18:	10800117 	ldw	r2,4(r2)
81146e1c:	10c02014 	ori	r3,r2,128
81146e20:	e0bffc17 	ldw	r2,-16(fp)
81146e24:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81146e28:	e0bffc17 	ldw	r2,-16(fp)
81146e2c:	10800017 	ldw	r2,0(r2)
81146e30:	10800304 	addi	r2,r2,12
81146e34:	e0fffc17 	ldw	r3,-16(fp)
81146e38:	18c00117 	ldw	r3,4(r3)
81146e3c:	10c00035 	stwio	r3,0(r2)
81146e40:	e0bff417 	ldw	r2,-48(fp)
81146e44:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81146e48:	e0bff617 	ldw	r2,-40(fp)
81146e4c:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
81146e50:	e0bffc17 	ldw	r2,-16(fp)
81146e54:	10800717 	ldw	r2,28(r2)
81146e58:	e0bff215 	stw	r2,-56(fp)
81146e5c:	00800044 	movi	r2,1
81146e60:	e0bff98d 	sth	r2,-26(fp)
81146e64:	00bfe0c4 	movi	r2,-125
81146e68:	e0bffa05 	stb	r2,-24(fp)
81146e6c:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81146e70:	d0a09003 	ldbu	r2,-32192(gp)
81146e74:	10803fcc 	andi	r2,r2,255
81146e78:	10000a26 	beq	r2,zero,81146ea4 <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81146e7c:	e0fff98b 	ldhu	r3,-26(fp)
81146e80:	e13ffa03 	ldbu	r4,-24(fp)
81146e84:	e17ffa8b 	ldhu	r5,-22(fp)
81146e88:	e0bffb04 	addi	r2,fp,-20
81146e8c:	d8800015 	stw	r2,0(sp)
81146e90:	280f883a 	mov	r7,r5
81146e94:	200d883a 	mov	r6,r4
81146e98:	180b883a 	mov	r5,r3
81146e9c:	e13ff217 	ldw	r4,-56(fp)
81146ea0:	113a0340 	call	8113a034 <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
81146ea4:	e0bff017 	ldw	r2,-64(fp)
81146ea8:	1000021e 	bne	r2,zero,81146eb4 <altera_avalon_uart_read+0x1dc>
81146eac:	e0bffe17 	ldw	r2,-8(fp)
81146eb0:	103fb81e 	bne	r2,zero,81146d94 <__reset+0xfb126d94>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81146eb4:	e0bffc17 	ldw	r2,-16(fp)
81146eb8:	10800817 	ldw	r2,32(r2)
81146ebc:	1009883a 	mov	r4,r2
81146ec0:	113e05c0 	call	8113e05c <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146ec4:	0005303a 	rdctl	r2,status
81146ec8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81146ecc:	e0fff717 	ldw	r3,-36(fp)
81146ed0:	00bfff84 	movi	r2,-2
81146ed4:	1884703a 	and	r2,r3,r2
81146ed8:	1001703a 	wrctl	status,r2
  
  return context;
81146edc:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
81146ee0:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81146ee4:	e0bffc17 	ldw	r2,-16(fp)
81146ee8:	10800117 	ldw	r2,4(r2)
81146eec:	10c02014 	ori	r3,r2,128
81146ef0:	e0bffc17 	ldw	r2,-16(fp)
81146ef4:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81146ef8:	e0bffc17 	ldw	r2,-16(fp)
81146efc:	10800017 	ldw	r2,0(r2)
81146f00:	10800304 	addi	r2,r2,12
81146f04:	e0fffc17 	ldw	r3,-16(fp)
81146f08:	18c00117 	ldw	r3,4(r3)
81146f0c:	10c00035 	stwio	r3,0(r2)
81146f10:	e0bff417 	ldw	r2,-48(fp)
81146f14:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81146f18:	e0bff317 	ldw	r2,-52(fp)
81146f1c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
81146f20:	e0bfef03 	ldbu	r2,-68(fp)
81146f24:	10000226 	beq	r2,zero,81146f30 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
81146f28:	00bffd44 	movi	r2,-11
81146f2c:	00000106 	br	81146f34 <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
81146f30:	e0bff017 	ldw	r2,-64(fp)
  }
}
81146f34:	e037883a 	mov	sp,fp
81146f38:	dfc00117 	ldw	ra,4(sp)
81146f3c:	df000017 	ldw	fp,0(sp)
81146f40:	dec00204 	addi	sp,sp,8
81146f44:	f800283a 	ret

81146f48 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81146f48:	defffe04 	addi	sp,sp,-8
81146f4c:	de00012e 	bgeu	sp,et,81146f54 <alt_get_errno+0xc>
81146f50:	003b68fa 	trap	3
81146f54:	dfc00115 	stw	ra,4(sp)
81146f58:	df000015 	stw	fp,0(sp)
81146f5c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81146f60:	d0a01017 	ldw	r2,-32704(gp)
81146f64:	10000326 	beq	r2,zero,81146f74 <alt_get_errno+0x2c>
81146f68:	d0a01017 	ldw	r2,-32704(gp)
81146f6c:	103ee83a 	callr	r2
81146f70:	00000106 	br	81146f78 <alt_get_errno+0x30>
81146f74:	d0a07704 	addi	r2,gp,-32292
}
81146f78:	e037883a 	mov	sp,fp
81146f7c:	dfc00117 	ldw	ra,4(sp)
81146f80:	df000017 	ldw	fp,0(sp)
81146f84:	dec00204 	addi	sp,sp,8
81146f88:	f800283a 	ret

81146f8c <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
81146f8c:	deffec04 	addi	sp,sp,-80
81146f90:	de00012e 	bgeu	sp,et,81146f98 <altera_avalon_uart_write+0xc>
81146f94:	003b68fa 	trap	3
81146f98:	dfc01315 	stw	ra,76(sp)
81146f9c:	df001215 	stw	fp,72(sp)
81146fa0:	df001204 	addi	fp,sp,72
81146fa4:	e13ffc15 	stw	r4,-16(fp)
81146fa8:	e17ffd15 	stw	r5,-12(fp)
81146fac:	e1bffe15 	stw	r6,-8(fp)
81146fb0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
81146fb4:	e0bffe17 	ldw	r2,-8(fp)
81146fb8:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
81146fbc:	e0bfff17 	ldw	r2,-4(fp)
81146fc0:	1090000c 	andi	r2,r2,16384
81146fc4:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
81146fc8:	e0bffc17 	ldw	r2,-16(fp)
81146fcc:	10800917 	ldw	r2,36(r2)
81146fd0:	e0bff815 	stw	r2,-32(fp)
81146fd4:	e03ff90d 	sth	zero,-28(fp)
81146fd8:	e0bff90b 	ldhu	r2,-28(fp)
81146fdc:	e0fffb44 	addi	r3,fp,-19
81146fe0:	180d883a 	mov	r6,r3
81146fe4:	100b883a 	mov	r5,r2
81146fe8:	e13ff817 	ldw	r4,-32(fp)
81146fec:	113dcd40 	call	8113dcd4 <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81146ff0:	00005106 	br	81147138 <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81146ff4:	e0bffc17 	ldw	r2,-16(fp)
81146ff8:	10800517 	ldw	r2,20(r2)
81146ffc:	10800044 	addi	r2,r2,1
81147000:	10800fcc 	andi	r2,r2,63
81147004:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
81147008:	e0bffc17 	ldw	r2,-16(fp)
8114700c:	10c00417 	ldw	r3,16(r2)
81147010:	e0bff217 	ldw	r2,-56(fp)
81147014:	1880371e 	bne	r3,r2,811470f4 <altera_avalon_uart_write+0x168>
    {
      if (no_block)
81147018:	e0bff017 	ldw	r2,-64(fp)
8114701c:	10000526 	beq	r2,zero,81147034 <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
81147020:	1146f480 	call	81146f48 <alt_get_errno>
81147024:	1007883a 	mov	r3,r2
81147028:	008002c4 	movi	r2,11
8114702c:	18800015 	stw	r2,0(r3)
        break;
81147030:	00004306 	br	81147140 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147034:	0005303a 	rdctl	r2,status
81147038:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114703c:	e0fff517 	ldw	r3,-44(fp)
81147040:	00bfff84 	movi	r2,-2
81147044:	1884703a 	and	r2,r3,r2
81147048:	1001703a 	wrctl	status,r2
  
  return context;
8114704c:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
81147050:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81147054:	e0bffc17 	ldw	r2,-16(fp)
81147058:	10800117 	ldw	r2,4(r2)
8114705c:	10c11014 	ori	r3,r2,1088
81147060:	e0bffc17 	ldw	r2,-16(fp)
81147064:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81147068:	e0bffc17 	ldw	r2,-16(fp)
8114706c:	10800017 	ldw	r2,0(r2)
81147070:	10800304 	addi	r2,r2,12
81147074:	e0fffc17 	ldw	r3,-16(fp)
81147078:	18c00117 	ldw	r3,4(r3)
8114707c:	10c00035 	stwio	r3,0(r2)
81147080:	e0bff417 	ldw	r2,-48(fp)
81147084:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147088:	e0bff117 	ldw	r2,-60(fp)
8114708c:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
81147090:	e0bffc17 	ldw	r2,-16(fp)
81147094:	10800717 	ldw	r2,28(r2)
81147098:	e0bff315 	stw	r2,-52(fp)
8114709c:	00800084 	movi	r2,2
811470a0:	e0bff98d 	sth	r2,-26(fp)
811470a4:	00bfe0c4 	movi	r2,-125
811470a8:	e0bffa05 	stb	r2,-24(fp)
811470ac:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
811470b0:	d0a09003 	ldbu	r2,-32192(gp)
811470b4:	10803fcc 	andi	r2,r2,255
811470b8:	10000a26 	beq	r2,zero,811470e4 <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
811470bc:	e0fff98b 	ldhu	r3,-26(fp)
811470c0:	e13ffa03 	ldbu	r4,-24(fp)
811470c4:	e17ffa8b 	ldhu	r5,-22(fp)
811470c8:	e0bffb04 	addi	r2,fp,-20
811470cc:	d8800015 	stw	r2,0(sp)
811470d0:	280f883a 	mov	r7,r5
811470d4:	200d883a 	mov	r6,r4
811470d8:	180b883a 	mov	r5,r3
811470dc:	e13ff317 	ldw	r4,-52(fp)
811470e0:	113a0340 	call	8113a034 <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
811470e4:	e0bffc17 	ldw	r2,-16(fp)
811470e8:	10c00417 	ldw	r3,16(r2)
811470ec:	e0bff217 	ldw	r2,-56(fp)
811470f0:	18bfe726 	beq	r3,r2,81147090 <__reset+0xfb127090>
      }
    }

    count--;
811470f4:	e0bfef17 	ldw	r2,-68(fp)
811470f8:	10bfffc4 	addi	r2,r2,-1
811470fc:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
81147100:	e0bffc17 	ldw	r2,-16(fp)
81147104:	10c00517 	ldw	r3,20(r2)
81147108:	e0bffd17 	ldw	r2,-12(fp)
8114710c:	11000044 	addi	r4,r2,1
81147110:	e13ffd15 	stw	r4,-12(fp)
81147114:	10800003 	ldbu	r2,0(r2)
81147118:	1009883a 	mov	r4,r2
8114711c:	e0bffc17 	ldw	r2,-16(fp)
81147120:	10c5883a 	add	r2,r2,r3
81147124:	10801a04 	addi	r2,r2,104
81147128:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
8114712c:	e0bffc17 	ldw	r2,-16(fp)
81147130:	e0fff217 	ldw	r3,-56(fp)
81147134:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81147138:	e0bfef17 	ldw	r2,-68(fp)
8114713c:	103fad1e 	bne	r2,zero,81146ff4 <__reset+0xfb126ff4>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
81147140:	e0bffc17 	ldw	r2,-16(fp)
81147144:	10800917 	ldw	r2,36(r2)
81147148:	1009883a 	mov	r4,r2
8114714c:	113e05c0 	call	8113e05c <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147150:	0005303a 	rdctl	r2,status
81147154:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147158:	e0fff717 	ldw	r3,-36(fp)
8114715c:	00bfff84 	movi	r2,-2
81147160:	1884703a 	and	r2,r3,r2
81147164:	1001703a 	wrctl	status,r2
  
  return context;
81147168:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
8114716c:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81147170:	e0bffc17 	ldw	r2,-16(fp)
81147174:	10800117 	ldw	r2,4(r2)
81147178:	10c11014 	ori	r3,r2,1088
8114717c:	e0bffc17 	ldw	r2,-16(fp)
81147180:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81147184:	e0bffc17 	ldw	r2,-16(fp)
81147188:	10800017 	ldw	r2,0(r2)
8114718c:	10800304 	addi	r2,r2,12
81147190:	e0fffc17 	ldw	r3,-16(fp)
81147194:	18c00117 	ldw	r3,4(r3)
81147198:	10c00035 	stwio	r3,0(r2)
8114719c:	e0bff417 	ldw	r2,-48(fp)
811471a0:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811471a4:	e0bff617 	ldw	r2,-40(fp)
811471a8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
811471ac:	e0fffe17 	ldw	r3,-8(fp)
811471b0:	e0bfef17 	ldw	r2,-68(fp)
811471b4:	1885c83a 	sub	r2,r3,r2
}
811471b8:	e037883a 	mov	sp,fp
811471bc:	dfc00117 	ldw	ra,4(sp)
811471c0:	df000017 	ldw	fp,0(sp)
811471c4:	dec00204 	addi	sp,sp,8
811471c8:	f800283a 	ret

811471cc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811471cc:	defffe04 	addi	sp,sp,-8
811471d0:	de00012e 	bgeu	sp,et,811471d8 <alt_get_errno+0xc>
811471d4:	003b68fa 	trap	3
811471d8:	dfc00115 	stw	ra,4(sp)
811471dc:	df000015 	stw	fp,0(sp)
811471e0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811471e4:	d0a01017 	ldw	r2,-32704(gp)
811471e8:	10000326 	beq	r2,zero,811471f8 <alt_get_errno+0x2c>
811471ec:	d0a01017 	ldw	r2,-32704(gp)
811471f0:	103ee83a 	callr	r2
811471f4:	00000106 	br	811471fc <alt_get_errno+0x30>
811471f8:	d0a07704 	addi	r2,gp,-32292
}
811471fc:	e037883a 	mov	sp,fp
81147200:	dfc00117 	ldw	ra,4(sp)
81147204:	df000017 	ldw	fp,0(sp)
81147208:	dec00204 	addi	sp,sp,8
8114720c:	f800283a 	ret

81147210 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
81147210:	defffc04 	addi	sp,sp,-16
81147214:	de00012e 	bgeu	sp,et,8114721c <alt_msgdma_write_standard_descriptor+0xc>
81147218:	003b68fa 	trap	3
8114721c:	df000315 	stw	fp,12(sp)
81147220:	df000304 	addi	fp,sp,12
81147224:	e13ffd15 	stw	r4,-12(fp)
81147228:	e17ffe15 	stw	r5,-8(fp)
8114722c:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81147230:	e0bffd17 	ldw	r2,-12(fp)
81147234:	10800037 	ldwio	r2,0(r2)
81147238:	1080010c 	andi	r2,r2,4
8114723c:	10000226 	beq	r2,zero,81147248 <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
81147240:	00bff904 	movi	r2,-28
81147244:	00001506 	br	8114729c <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
81147248:	e0bfff17 	ldw	r2,-4(fp)
8114724c:	10800017 	ldw	r2,0(r2)
81147250:	1007883a 	mov	r3,r2
81147254:	e0bffe17 	ldw	r2,-8(fp)
81147258:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
8114725c:	e0bffe17 	ldw	r2,-8(fp)
81147260:	10800104 	addi	r2,r2,4
81147264:	e0ffff17 	ldw	r3,-4(fp)
81147268:	18c00117 	ldw	r3,4(r3)
8114726c:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
81147270:	e0bffe17 	ldw	r2,-8(fp)
81147274:	10800204 	addi	r2,r2,8
81147278:	e0ffff17 	ldw	r3,-4(fp)
8114727c:	18c00217 	ldw	r3,8(r3)
81147280:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
81147284:	e0bffe17 	ldw	r2,-8(fp)
81147288:	10800304 	addi	r2,r2,12
8114728c:	e0ffff17 	ldw	r3,-4(fp)
81147290:	18c00317 	ldw	r3,12(r3)
81147294:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
81147298:	0005883a 	mov	r2,zero
}
8114729c:	e037883a 	mov	sp,fp
811472a0:	df000017 	ldw	fp,0(sp)
811472a4:	dec00104 	addi	sp,sp,4
811472a8:	f800283a 	ret

811472ac <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
811472ac:	defffc04 	addi	sp,sp,-16
811472b0:	de00012e 	bgeu	sp,et,811472b8 <alt_msgdma_write_extended_descriptor+0xc>
811472b4:	003b68fa 	trap	3
811472b8:	df000315 	stw	fp,12(sp)
811472bc:	df000304 	addi	fp,sp,12
811472c0:	e13ffd15 	stw	r4,-12(fp)
811472c4:	e17ffe15 	stw	r5,-8(fp)
811472c8:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
811472cc:	e0bffd17 	ldw	r2,-12(fp)
811472d0:	10800037 	ldwio	r2,0(r2)
811472d4:	1080010c 	andi	r2,r2,4
811472d8:	10000226 	beq	r2,zero,811472e4 <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
811472dc:	00bff904 	movi	r2,-28
811472e0:	00003b06 	br	811473d0 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
811472e4:	e0bfff17 	ldw	r2,-4(fp)
811472e8:	10800017 	ldw	r2,0(r2)
811472ec:	1007883a 	mov	r3,r2
811472f0:	e0bffe17 	ldw	r2,-8(fp)
811472f4:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
811472f8:	e0bffe17 	ldw	r2,-8(fp)
811472fc:	10800104 	addi	r2,r2,4
81147300:	e0ffff17 	ldw	r3,-4(fp)
81147304:	18c00117 	ldw	r3,4(r3)
81147308:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
8114730c:	e0bffe17 	ldw	r2,-8(fp)
81147310:	10800204 	addi	r2,r2,8
81147314:	e0ffff17 	ldw	r3,-4(fp)
81147318:	18c00217 	ldw	r3,8(r3)
8114731c:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
81147320:	e0bffe17 	ldw	r2,-8(fp)
81147324:	10800304 	addi	r2,r2,12
81147328:	e0ffff17 	ldw	r3,-4(fp)
8114732c:	18c0030b 	ldhu	r3,12(r3)
81147330:	18ffffcc 	andi	r3,r3,65535
81147334:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
81147338:	e0bffe17 	ldw	r2,-8(fp)
8114733c:	10800384 	addi	r2,r2,14
81147340:	e0ffff17 	ldw	r3,-4(fp)
81147344:	18c00383 	ldbu	r3,14(r3)
81147348:	18c03fcc 	andi	r3,r3,255
8114734c:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
81147350:	e0bffe17 	ldw	r2,-8(fp)
81147354:	108003c4 	addi	r2,r2,15
81147358:	e0ffff17 	ldw	r3,-4(fp)
8114735c:	18c003c3 	ldbu	r3,15(r3)
81147360:	18c03fcc 	andi	r3,r3,255
81147364:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
81147368:	e0bffe17 	ldw	r2,-8(fp)
8114736c:	10800404 	addi	r2,r2,16
81147370:	e0ffff17 	ldw	r3,-4(fp)
81147374:	18c0040b 	ldhu	r3,16(r3)
81147378:	18ffffcc 	andi	r3,r3,65535
8114737c:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
81147380:	e0bffe17 	ldw	r2,-8(fp)
81147384:	10800484 	addi	r2,r2,18
81147388:	e0ffff17 	ldw	r3,-4(fp)
8114738c:	18c0048b 	ldhu	r3,18(r3)
81147390:	18ffffcc 	andi	r3,r3,65535
81147394:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
81147398:	e0bffe17 	ldw	r2,-8(fp)
8114739c:	10800504 	addi	r2,r2,20
811473a0:	0007883a 	mov	r3,zero
811473a4:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
811473a8:	e0bffe17 	ldw	r2,-8(fp)
811473ac:	10800604 	addi	r2,r2,24
811473b0:	0007883a 	mov	r3,zero
811473b4:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
811473b8:	e0bffe17 	ldw	r2,-8(fp)
811473bc:	10800704 	addi	r2,r2,28
811473c0:	e0ffff17 	ldw	r3,-4(fp)
811473c4:	18c00717 	ldw	r3,28(r3)
811473c8:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
811473cc:	0005883a 	mov	r2,zero
}
811473d0:	e037883a 	mov	sp,fp
811473d4:	df000017 	ldw	fp,0(sp)
811473d8:	dec00104 	addi	sp,sp,4
811473dc:	f800283a 	ret

811473e0 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
811473e0:	defff804 	addi	sp,sp,-32
811473e4:	de00012e 	bgeu	sp,et,811473ec <alt_msgdma_irq+0xc>
811473e8:	003b68fa 	trap	3
811473ec:	dfc00715 	stw	ra,28(sp)
811473f0:	df000615 	stw	fp,24(sp)
811473f4:	df000604 	addi	fp,sp,24
811473f8:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
811473fc:	e0bfff17 	ldw	r2,-4(fp)
81147400:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
81147404:	e0bffa17 	ldw	r2,-24(fp)
81147408:	10801783 	ldbu	r2,94(r2)
8114740c:	10803fcc 	andi	r2,r2,255
81147410:	10001126 	beq	r2,zero,81147458 <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81147414:	e0bffa17 	ldw	r2,-24(fp)
81147418:	10800617 	ldw	r2,24(r2)
8114741c:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
81147420:	1007883a 	mov	r3,r2
81147424:	00bffdc4 	movi	r2,-9
81147428:	1884703a 	and	r2,r3,r2
8114742c:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81147430:	e0bffa17 	ldw	r2,-24(fp)
81147434:	10800617 	ldw	r2,24(r2)
81147438:	e0fffb17 	ldw	r3,-20(fp)
8114743c:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
81147440:	e0bffa17 	ldw	r2,-24(fp)
81147444:	10800617 	ldw	r2,24(r2)
81147448:	10800404 	addi	r2,r2,16
8114744c:	00c00044 	movi	r3,1
81147450:	10c00035 	stwio	r3,0(r2)
81147454:	00001106 	br	8114749c <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81147458:	e0bffa17 	ldw	r2,-24(fp)
8114745c:	10800317 	ldw	r2,12(r2)
81147460:	10800104 	addi	r2,r2,4
81147464:	10800037 	ldwio	r2,0(r2)
81147468:	1007883a 	mov	r3,r2
8114746c:	00bffbc4 	movi	r2,-17
81147470:	1884703a 	and	r2,r3,r2
81147474:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81147478:	e0bffa17 	ldw	r2,-24(fp)
8114747c:	10800317 	ldw	r2,12(r2)
81147480:	10800104 	addi	r2,r2,4
81147484:	e0fffb17 	ldw	r3,-20(fp)
81147488:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8114748c:	e0bffa17 	ldw	r2,-24(fp)
81147490:	10800317 	ldw	r2,12(r2)
81147494:	00c08004 	movi	r3,512
81147498:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
8114749c:	e0bffa17 	ldw	r2,-24(fp)
811474a0:	10800b17 	ldw	r2,44(r2)
811474a4:	10001226 	beq	r2,zero,811474f0 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811474a8:	0005303a 	rdctl	r2,status
811474ac:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811474b0:	e0fffd17 	ldw	r3,-12(fp)
811474b4:	00bfff84 	movi	r2,-2
811474b8:	1884703a 	and	r2,r3,r2
811474bc:	1001703a 	wrctl	status,r2
  
  return context;
811474c0:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
811474c4:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
811474c8:	e0bffa17 	ldw	r2,-24(fp)
811474cc:	10800b17 	ldw	r2,44(r2)
811474d0:	e0fffa17 	ldw	r3,-24(fp)
811474d4:	18c00c17 	ldw	r3,48(r3)
811474d8:	1809883a 	mov	r4,r3
811474dc:	103ee83a 	callr	r2
811474e0:	e0bffc17 	ldw	r2,-16(fp)
811474e4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811474e8:	e0bffe17 	ldw	r2,-8(fp)
811474ec:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
811474f0:	e0bffa17 	ldw	r2,-24(fp)
811474f4:	10801783 	ldbu	r2,94(r2)
811474f8:	10803fcc 	andi	r2,r2,255
811474fc:	10000a26 	beq	r2,zero,81147528 <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81147500:	e0bffa17 	ldw	r2,-24(fp)
81147504:	10800617 	ldw	r2,24(r2)
81147508:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
8114750c:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
81147510:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81147514:	e0bffa17 	ldw	r2,-24(fp)
81147518:	10800617 	ldw	r2,24(r2)
8114751c:	e0fffb17 	ldw	r3,-20(fp)
81147520:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
81147524:	00000c06 	br	81147558 <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81147528:	e0bffa17 	ldw	r2,-24(fp)
8114752c:	10800317 	ldw	r2,12(r2)
81147530:	10800104 	addi	r2,r2,4
81147534:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
81147538:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
8114753c:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81147540:	e0bffa17 	ldw	r2,-24(fp)
81147544:	10800317 	ldw	r2,12(r2)
81147548:	10800104 	addi	r2,r2,4
8114754c:	e0fffb17 	ldw	r3,-20(fp)
81147550:	10c00035 	stwio	r3,0(r2)
    }

    return;
81147554:	0001883a 	nop
}
81147558:	e037883a 	mov	sp,fp
8114755c:	dfc00117 	ldw	ra,4(sp)
81147560:	df000017 	ldw	fp,0(sp)
81147564:	dec00204 	addi	sp,sp,8
81147568:	f800283a 	ret

8114756c <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114756c:	defffb04 	addi	sp,sp,-20
81147570:	de00012e 	bgeu	sp,et,81147578 <alt_msgdma_construct_standard_descriptor+0xc>
81147574:	003b68fa 	trap	3
81147578:	df000415 	stw	fp,16(sp)
8114757c:	df000404 	addi	fp,sp,16
81147580:	e13ffc15 	stw	r4,-16(fp)
81147584:	e17ffd15 	stw	r5,-12(fp)
81147588:	e1bffe15 	stw	r6,-8(fp)
8114758c:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81147590:	e0bffc17 	ldw	r2,-16(fp)
81147594:	10c01217 	ldw	r3,72(r2)
81147598:	e0800117 	ldw	r2,4(fp)
8114759c:	18800436 	bltu	r3,r2,811475b0 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
811475a0:	e0bffc17 	ldw	r2,-16(fp)
811475a4:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
811475a8:	10803fcc 	andi	r2,r2,255
811475ac:	10000226 	beq	r2,zero,811475b8 <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
811475b0:	00bffa84 	movi	r2,-22
811475b4:	00000e06 	br	811475f0 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
811475b8:	e0bffd17 	ldw	r2,-12(fp)
811475bc:	e0fffe17 	ldw	r3,-8(fp)
811475c0:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
811475c4:	e0bffd17 	ldw	r2,-12(fp)
811475c8:	e0ffff17 	ldw	r3,-4(fp)
811475cc:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
811475d0:	e0bffd17 	ldw	r2,-12(fp)
811475d4:	e0c00117 	ldw	r3,4(fp)
811475d8:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
811475dc:	e0800217 	ldw	r2,8(fp)
811475e0:	10e00034 	orhi	r3,r2,32768
811475e4:	e0bffd17 	ldw	r2,-12(fp)
811475e8:	10c00315 	stw	r3,12(r2)
    
    return 0;
811475ec:	0005883a 	mov	r2,zero
}
811475f0:	e037883a 	mov	sp,fp
811475f4:	df000017 	ldw	fp,0(sp)
811475f8:	dec00104 	addi	sp,sp,4
811475fc:	f800283a 	ret

81147600 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81147600:	defff604 	addi	sp,sp,-40
81147604:	de00012e 	bgeu	sp,et,8114760c <alt_msgdma_construct_extended_descriptor+0xc>
81147608:	003b68fa 	trap	3
8114760c:	df000915 	stw	fp,36(sp)
81147610:	df000904 	addi	fp,sp,36
81147614:	e13ff715 	stw	r4,-36(fp)
81147618:	e17ff815 	stw	r5,-32(fp)
8114761c:	e1bff915 	stw	r6,-28(fp)
81147620:	e1fffa15 	stw	r7,-24(fp)
81147624:	e1800317 	ldw	r6,12(fp)
81147628:	e1400417 	ldw	r5,16(fp)
8114762c:	e1000517 	ldw	r4,20(fp)
81147630:	e0c00617 	ldw	r3,24(fp)
81147634:	e0800717 	ldw	r2,28(fp)
81147638:	e1bffb0d 	sth	r6,-20(fp)
8114763c:	e17ffc05 	stb	r5,-16(fp)
81147640:	e13ffd05 	stb	r4,-12(fp)
81147644:	e0fffe0d 	sth	r3,-8(fp)
81147648:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
8114764c:	e0bff717 	ldw	r2,-36(fp)
81147650:	10c01217 	ldw	r3,72(r2)
81147654:	e0800117 	ldw	r2,4(fp)
81147658:	18801936 	bltu	r3,r2,811476c0 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
8114765c:	e13ff717 	ldw	r4,-36(fp)
81147660:	20801317 	ldw	r2,76(r4)
81147664:	20c01417 	ldw	r3,80(r4)
81147668:	e13ffe0b 	ldhu	r4,-8(fp)
8114766c:	213fffcc 	andi	r4,r4,65535
81147670:	2015883a 	mov	r10,r4
81147674:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
81147678:	1ac01136 	bltu	r3,r11,811476c0 <alt_msgdma_construct_extended_descriptor+0xc0>
8114767c:	58c0011e 	bne	r11,r3,81147684 <alt_msgdma_construct_extended_descriptor+0x84>
81147680:	12800f36 	bltu	r2,r10,811476c0 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81147684:	e13ff717 	ldw	r4,-36(fp)
81147688:	20801317 	ldw	r2,76(r4)
8114768c:	20c01417 	ldw	r3,80(r4)
81147690:	e13fff0b 	ldhu	r4,-4(fp)
81147694:	213fffcc 	andi	r4,r4,65535
81147698:	2011883a 	mov	r8,r4
8114769c:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
811476a0:	1a400736 	bltu	r3,r9,811476c0 <alt_msgdma_construct_extended_descriptor+0xc0>
811476a4:	48c0011e 	bne	r9,r3,811476ac <alt_msgdma_construct_extended_descriptor+0xac>
811476a8:	12000536 	bltu	r2,r8,811476c0 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
811476ac:	e0bff717 	ldw	r2,-36(fp)
811476b0:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811476b4:	10803fcc 	andi	r2,r2,255
811476b8:	10800060 	cmpeqi	r2,r2,1
811476bc:	1000021e 	bne	r2,zero,811476c8 <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
811476c0:	00bffa84 	movi	r2,-22
811476c4:	00002106 	br	8114774c <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
811476c8:	e0bff817 	ldw	r2,-32(fp)
811476cc:	e0fff917 	ldw	r3,-28(fp)
811476d0:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
811476d4:	e0bff817 	ldw	r2,-32(fp)
811476d8:	e0fffa17 	ldw	r3,-24(fp)
811476dc:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
811476e0:	e0bff817 	ldw	r2,-32(fp)
811476e4:	e0c00117 	ldw	r3,4(fp)
811476e8:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
811476ec:	e0bff817 	ldw	r2,-32(fp)
811476f0:	e0fffb0b 	ldhu	r3,-20(fp)
811476f4:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
811476f8:	e0bff817 	ldw	r2,-32(fp)
811476fc:	e0fffc03 	ldbu	r3,-16(fp)
81147700:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
81147704:	e0bff817 	ldw	r2,-32(fp)
81147708:	e0fffd03 	ldbu	r3,-12(fp)
8114770c:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
81147710:	e0bff817 	ldw	r2,-32(fp)
81147714:	e0fffe0b 	ldhu	r3,-8(fp)
81147718:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
8114771c:	e0bff817 	ldw	r2,-32(fp)
81147720:	e0ffff0b 	ldhu	r3,-4(fp)
81147724:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
81147728:	e0bff817 	ldw	r2,-32(fp)
8114772c:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
81147730:	e0bff817 	ldw	r2,-32(fp)
81147734:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81147738:	e0800217 	ldw	r2,8(fp)
8114773c:	10e00034 	orhi	r3,r2,32768
81147740:	e0bff817 	ldw	r2,-32(fp)
81147744:	10c00715 	stw	r3,28(r2)

  return 0 ;
81147748:	0005883a 	mov	r2,zero

}
8114774c:	e037883a 	mov	sp,fp
81147750:	df000017 	ldw	fp,0(sp)
81147754:	dec00104 	addi	sp,sp,4
81147758:	f800283a 	ret

8114775c <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
8114775c:	deffee04 	addi	sp,sp,-72
81147760:	de00012e 	bgeu	sp,et,81147768 <alt_msgdma_descriptor_async_transfer+0xc>
81147764:	003b68fa 	trap	3
81147768:	dfc01115 	stw	ra,68(sp)
8114776c:	df001015 	stw	fp,64(sp)
81147770:	df001004 	addi	fp,sp,64
81147774:	e13ffd15 	stw	r4,-12(fp)
81147778:	e17ffe15 	stw	r5,-8(fp)
8114777c:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
81147780:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
81147784:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
81147788:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114778c:	e0bffd17 	ldw	r2,-12(fp)
81147790:	10800317 	ldw	r2,12(r2)
81147794:	10800204 	addi	r2,r2,8
81147798:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
8114779c:	10bfffcc 	andi	r2,r2,65535
811477a0:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811477a4:	e0bffd17 	ldw	r2,-12(fp)
811477a8:	10800317 	ldw	r2,12(r2)
811477ac:	10800204 	addi	r2,r2,8
811477b0:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
811477b4:	1004d43a 	srli	r2,r2,16
811477b8:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811477bc:	e0bffd17 	ldw	r2,-12(fp)
811477c0:	10800917 	ldw	r2,36(r2)
811477c4:	e0fff417 	ldw	r3,-48(fp)
811477c8:	1880042e 	bgeu	r3,r2,811477dc <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
811477cc:	e0bffd17 	ldw	r2,-12(fp)
811477d0:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811477d4:	e0fff317 	ldw	r3,-52(fp)
811477d8:	18800236 	bltu	r3,r2,811477e4 <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
811477dc:	00bff904 	movi	r2,-28
811477e0:	0000a906 	br	81147a88 <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
811477e4:	e0bffd17 	ldw	r2,-12(fp)
811477e8:	10801817 	ldw	r2,96(r2)
811477ec:	e0bff615 	stw	r2,-40(fp)
811477f0:	e03ffc0d 	sth	zero,-16(fp)
811477f4:	e0bffc0b 	ldhu	r2,-16(fp)
811477f8:	e0fffc84 	addi	r3,fp,-14
811477fc:	180d883a 	mov	r6,r3
81147800:	100b883a 	mov	r5,r2
81147804:	e13ff617 	ldw	r4,-40(fp)
81147808:	113dcd40 	call	8113dcd4 <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8114780c:	00800804 	movi	r2,32
81147810:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147814:	0005303a 	rdctl	r2,status
81147818:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114781c:	e0fff717 	ldw	r3,-36(fp)
81147820:	00bfff84 	movi	r2,-2
81147824:	1884703a 	and	r2,r3,r2
81147828:	1001703a 	wrctl	status,r2
  
  return context;
8114782c:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81147830:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81147834:	e0bffd17 	ldw	r2,-12(fp)
81147838:	10800317 	ldw	r2,12(r2)
8114783c:	10800104 	addi	r2,r2,4
81147840:	e0fff117 	ldw	r3,-60(fp)
81147844:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
81147848:	e0bffd17 	ldw	r2,-12(fp)
8114784c:	10800317 	ldw	r2,12(r2)
81147850:	e0fffd17 	ldw	r3,-12(fp)
81147854:	18c00317 	ldw	r3,12(r3)
81147858:	18c00037 	ldwio	r3,0(r3)
8114785c:	10c00035 	stwio	r3,0(r2)
81147860:	e0bff217 	ldw	r2,-56(fp)
81147864:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147868:	e0bffb17 	ldw	r2,-20(fp)
8114786c:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81147870:	e0bffe17 	ldw	r2,-8(fp)
81147874:	10001e26 	beq	r2,zero,811478f0 <alt_msgdma_descriptor_async_transfer+0x194>
81147878:	e0bfff17 	ldw	r2,-4(fp)
8114787c:	10001c1e 	bne	r2,zero,811478f0 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81147880:	00001106 	br	811478c8 <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81147884:	01000044 	movi	r4,1
81147888:	113545c0 	call	8113545c <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114788c:	e0bff00b 	ldhu	r2,-64(fp)
81147890:	1084e230 	cmpltui	r2,r2,5000
81147894:	1000091e 	bne	r2,zero,811478bc <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
81147898:	01204574 	movhi	r4,33045
8114789c:	21006e04 	addi	r4,r4,440
811478a0:	1149bb00 	call	81149bb0 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811478a4:	e0bffd17 	ldw	r2,-12(fp)
811478a8:	10801817 	ldw	r2,96(r2)
811478ac:	1009883a 	mov	r4,r2
811478b0:	113e05c0 	call	8113e05c <OSSemPost>
				
                return -ETIME;
811478b4:	00bff084 	movi	r2,-62
811478b8:	00007306 	br	81147a88 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
811478bc:	e0bff00b 	ldhu	r2,-64(fp)
811478c0:	10800044 	addi	r2,r2,1
811478c4:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
811478c8:	e0bffd17 	ldw	r2,-12(fp)
811478cc:	10c00317 	ldw	r3,12(r2)
811478d0:	e0bffd17 	ldw	r2,-12(fp)
811478d4:	10800417 	ldw	r2,16(r2)
811478d8:	e1bffe17 	ldw	r6,-8(fp)
811478dc:	100b883a 	mov	r5,r2
811478e0:	1809883a 	mov	r4,r3
811478e4:	11472100 	call	81147210 <alt_msgdma_write_standard_descriptor>
811478e8:	103fe61e 	bne	r2,zero,81147884 <__reset+0xfb127884>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
811478ec:	00002706 	br	8114798c <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
811478f0:	e0bffe17 	ldw	r2,-8(fp)
811478f4:	10001f1e 	bne	r2,zero,81147974 <alt_msgdma_descriptor_async_transfer+0x218>
811478f8:	e0bfff17 	ldw	r2,-4(fp)
811478fc:	10001d26 	beq	r2,zero,81147974 <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
81147900:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81147904:	00001106 	br	8114794c <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81147908:	01000044 	movi	r4,1
8114790c:	113545c0 	call	8113545c <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81147910:	e0bff00b 	ldhu	r2,-64(fp)
81147914:	1084e230 	cmpltui	r2,r2,5000
81147918:	1000091e 	bne	r2,zero,81147940 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
8114791c:	01204574 	movhi	r4,33045
81147920:	21008404 	addi	r4,r4,528
81147924:	1149bb00 	call	81149bb0 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81147928:	e0bffd17 	ldw	r2,-12(fp)
8114792c:	10801817 	ldw	r2,96(r2)
81147930:	1009883a 	mov	r4,r2
81147934:	113e05c0 	call	8113e05c <OSSemPost>
				
                return -ETIME;
81147938:	00bff084 	movi	r2,-62
8114793c:	00005206 	br	81147a88 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81147940:	e0bff00b 	ldhu	r2,-64(fp)
81147944:	10800044 	addi	r2,r2,1
81147948:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8114794c:	e0bffd17 	ldw	r2,-12(fp)
81147950:	10c00317 	ldw	r3,12(r2)
81147954:	e0bffd17 	ldw	r2,-12(fp)
81147958:	10800417 	ldw	r2,16(r2)
8114795c:	e1bfff17 	ldw	r6,-4(fp)
81147960:	100b883a 	mov	r5,r2
81147964:	1809883a 	mov	r4,r3
81147968:	11472ac0 	call	811472ac <alt_msgdma_write_extended_descriptor>
8114796c:	103fe61e 	bne	r2,zero,81147908 <__reset+0xfb127908>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81147970:	00000606 	br	8114798c <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81147974:	e0bffd17 	ldw	r2,-12(fp)
81147978:	10801817 	ldw	r2,96(r2)
8114797c:	1009883a 	mov	r4,r2
81147980:	113e05c0 	call	8113e05c <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81147984:	00bfffc4 	movi	r2,-1
81147988:	00003f06 	br	81147a88 <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
8114798c:	e0bffd17 	ldw	r2,-12(fp)
81147990:	10800b17 	ldw	r2,44(r2)
81147994:	10001c26 	beq	r2,zero,81147a08 <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
81147998:	e0bffd17 	ldw	r2,-12(fp)
8114799c:	10c00d17 	ldw	r3,52(r2)
811479a0:	e0bff117 	ldw	r2,-60(fp)
811479a4:	1884b03a 	or	r2,r3,r2
811479a8:	10800514 	ori	r2,r2,20
811479ac:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
811479b0:	e0fff117 	ldw	r3,-60(fp)
811479b4:	00bff7c4 	movi	r2,-33
811479b8:	1884703a 	and	r2,r3,r2
811479bc:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811479c0:	0005303a 	rdctl	r2,status
811479c4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811479c8:	e0fff917 	ldw	r3,-28(fp)
811479cc:	00bfff84 	movi	r2,-2
811479d0:	1884703a 	and	r2,r3,r2
811479d4:	1001703a 	wrctl	status,r2
  
  return context;
811479d8:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
811479dc:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
811479e0:	e0bffd17 	ldw	r2,-12(fp)
811479e4:	10800317 	ldw	r2,12(r2)
811479e8:	10800104 	addi	r2,r2,4
811479ec:	e0fff117 	ldw	r3,-60(fp)
811479f0:	10c00035 	stwio	r3,0(r2)
811479f4:	e0bff217 	ldw	r2,-56(fp)
811479f8:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811479fc:	e0bff517 	ldw	r2,-44(fp)
81147a00:	1001703a 	wrctl	status,r2
81147a04:	00001b06 	br	81147a74 <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
81147a08:	e0bffd17 	ldw	r2,-12(fp)
81147a0c:	10c00d17 	ldw	r3,52(r2)
81147a10:	e0bff117 	ldw	r2,-60(fp)
81147a14:	1884b03a 	or	r2,r3,r2
81147a18:	10800114 	ori	r2,r2,4
81147a1c:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
81147a20:	e0fff117 	ldw	r3,-60(fp)
81147a24:	00bff3c4 	movi	r2,-49
81147a28:	1884703a 	and	r2,r3,r2
81147a2c:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147a30:	0005303a 	rdctl	r2,status
81147a34:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147a38:	e0fffa17 	ldw	r3,-24(fp)
81147a3c:	00bfff84 	movi	r2,-2
81147a40:	1884703a 	and	r2,r3,r2
81147a44:	1001703a 	wrctl	status,r2
  
  return context;
81147a48:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
81147a4c:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81147a50:	e0bffd17 	ldw	r2,-12(fp)
81147a54:	10800317 	ldw	r2,12(r2)
81147a58:	10800104 	addi	r2,r2,4
81147a5c:	e0fff117 	ldw	r3,-60(fp)
81147a60:	10c00035 	stwio	r3,0(r2)
81147a64:	e0bff217 	ldw	r2,-56(fp)
81147a68:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147a6c:	e0bff817 	ldw	r2,-32(fp)
81147a70:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
81147a74:	e0bffd17 	ldw	r2,-12(fp)
81147a78:	10801817 	ldw	r2,96(r2)
81147a7c:	1009883a 	mov	r4,r2
81147a80:	113e05c0 	call	8113e05c <OSSemPost>
    
    return 0;
81147a84:	0005883a 	mov	r2,zero
}
81147a88:	e037883a 	mov	sp,fp
81147a8c:	dfc00117 	ldw	ra,4(sp)
81147a90:	df000017 	ldw	fp,0(sp)
81147a94:	dec00204 	addi	sp,sp,8
81147a98:	f800283a 	ret

81147a9c <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
81147a9c:	deffee04 	addi	sp,sp,-72
81147aa0:	de00012e 	bgeu	sp,et,81147aa8 <alt_msgdma_descriptor_sync_transfer+0xc>
81147aa4:	003b68fa 	trap	3
81147aa8:	dfc01115 	stw	ra,68(sp)
81147aac:	df001015 	stw	fp,64(sp)
81147ab0:	df001004 	addi	fp,sp,64
81147ab4:	e13ffd15 	stw	r4,-12(fp)
81147ab8:	e17ffe15 	stw	r5,-8(fp)
81147abc:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
81147ac0:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
81147ac4:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
81147ac8:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
81147acc:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81147ad0:	e0bffd17 	ldw	r2,-12(fp)
81147ad4:	10800317 	ldw	r2,12(r2)
81147ad8:	10800204 	addi	r2,r2,8
81147adc:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
81147ae0:	10bfffcc 	andi	r2,r2,65535
81147ae4:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81147ae8:	e0bffd17 	ldw	r2,-12(fp)
81147aec:	10800317 	ldw	r2,12(r2)
81147af0:	10800204 	addi	r2,r2,8
81147af4:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
81147af8:	1004d43a 	srli	r2,r2,16
81147afc:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
81147b00:	00807804 	movi	r2,480
81147b04:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81147b08:	00001906 	br	81147b70 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
81147b0c:	01000044 	movi	r4,1
81147b10:	113545c0 	call	8113545c <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81147b14:	e0bff10b 	ldhu	r2,-60(fp)
81147b18:	1084e230 	cmpltui	r2,r2,5000
81147b1c:	1000051e 	bne	r2,zero,81147b34 <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
81147b20:	01204574 	movhi	r4,33045
81147b24:	21009a04 	addi	r4,r4,616
81147b28:	1149bb00 	call	81149bb0 <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
81147b2c:	00bff084 	movi	r2,-62
81147b30:	0000d706 	br	81147e90 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
81147b34:	e0bff10b 	ldhu	r2,-60(fp)
81147b38:	10800044 	addi	r2,r2,1
81147b3c:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81147b40:	e0bffd17 	ldw	r2,-12(fp)
81147b44:	10800317 	ldw	r2,12(r2)
81147b48:	10800204 	addi	r2,r2,8
81147b4c:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
81147b50:	10bfffcc 	andi	r2,r2,65535
81147b54:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81147b58:	e0bffd17 	ldw	r2,-12(fp)
81147b5c:	10800317 	ldw	r2,12(r2)
81147b60:	10800204 	addi	r2,r2,8
81147b64:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
81147b68:	1004d43a 	srli	r2,r2,16
81147b6c:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81147b70:	e0bffd17 	ldw	r2,-12(fp)
81147b74:	10800917 	ldw	r2,36(r2)
81147b78:	e0fff317 	ldw	r3,-52(fp)
81147b7c:	18bfe32e 	bgeu	r3,r2,81147b0c <__reset+0xfb127b0c>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
81147b80:	e0bffd17 	ldw	r2,-12(fp)
81147b84:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81147b88:	e0fff217 	ldw	r3,-56(fp)
81147b8c:	18bfdf2e 	bgeu	r3,r2,81147b0c <__reset+0xfb127b0c>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
81147b90:	e0bffd17 	ldw	r2,-12(fp)
81147b94:	10801817 	ldw	r2,96(r2)
81147b98:	e0bff815 	stw	r2,-32(fp)
81147b9c:	e03ffc0d 	sth	zero,-16(fp)
81147ba0:	e0bffc0b 	ldhu	r2,-16(fp)
81147ba4:	e0fffc84 	addi	r3,fp,-14
81147ba8:	180d883a 	mov	r6,r3
81147bac:	100b883a 	mov	r5,r2
81147bb0:	e13ff817 	ldw	r4,-32(fp)
81147bb4:	113dcd40 	call	8113dcd4 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147bb8:	0005303a 	rdctl	r2,status
81147bbc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147bc0:	e0fffb17 	ldw	r3,-20(fp)
81147bc4:	00bfff84 	movi	r2,-2
81147bc8:	1884703a 	and	r2,r3,r2
81147bcc:	1001703a 	wrctl	status,r2
  
  return context;
81147bd0:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
81147bd4:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81147bd8:	e0bffd17 	ldw	r2,-12(fp)
81147bdc:	10800317 	ldw	r2,12(r2)
81147be0:	10800104 	addi	r2,r2,4
81147be4:	00c00804 	movi	r3,32
81147be8:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81147bec:	e0bffd17 	ldw	r2,-12(fp)
81147bf0:	10800317 	ldw	r2,12(r2)
81147bf4:	e0fffd17 	ldw	r3,-12(fp)
81147bf8:	18c00317 	ldw	r3,12(r3)
81147bfc:	18c00037 	ldwio	r3,0(r3)
81147c00:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81147c04:	e0bffe17 	ldw	r2,-8(fp)
81147c08:	10001f26 	beq	r2,zero,81147c88 <alt_msgdma_descriptor_sync_transfer+0x1ec>
81147c0c:	e0bfff17 	ldw	r2,-4(fp)
81147c10:	10001d1e 	bne	r2,zero,81147c88 <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
81147c14:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81147c18:	00001106 	br	81147c60 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
81147c1c:	01000044 	movi	r4,1
81147c20:	113545c0 	call	8113545c <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81147c24:	e0bff10b 	ldhu	r2,-60(fp)
81147c28:	1084e230 	cmpltui	r2,r2,5000
81147c2c:	1000091e 	bne	r2,zero,81147c54 <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
81147c30:	01204574 	movhi	r4,33045
81147c34:	2100ae04 	addi	r4,r4,696
81147c38:	1149bb00 	call	81149bb0 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81147c3c:	e0bffd17 	ldw	r2,-12(fp)
81147c40:	10801817 	ldw	r2,96(r2)
81147c44:	1009883a 	mov	r4,r2
81147c48:	113e05c0 	call	8113e05c <OSSemPost>
				
                return -ETIME;
81147c4c:	00bff084 	movi	r2,-62
81147c50:	00008f06 	br	81147e90 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
81147c54:	e0bff10b 	ldhu	r2,-60(fp)
81147c58:	10800044 	addi	r2,r2,1
81147c5c:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81147c60:	e0bffd17 	ldw	r2,-12(fp)
81147c64:	10c00317 	ldw	r3,12(r2)
81147c68:	e0bffd17 	ldw	r2,-12(fp)
81147c6c:	10800417 	ldw	r2,16(r2)
81147c70:	e1bffe17 	ldw	r6,-8(fp)
81147c74:	100b883a 	mov	r5,r2
81147c78:	1809883a 	mov	r4,r3
81147c7c:	11472100 	call	81147210 <alt_msgdma_write_standard_descriptor>
81147c80:	103fe61e 	bne	r2,zero,81147c1c <__reset+0xfb127c1c>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81147c84:	00002706 	br	81147d24 <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81147c88:	e0bffe17 	ldw	r2,-8(fp)
81147c8c:	10001f1e 	bne	r2,zero,81147d0c <alt_msgdma_descriptor_sync_transfer+0x270>
81147c90:	e0bfff17 	ldw	r2,-4(fp)
81147c94:	10001d26 	beq	r2,zero,81147d0c <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
81147c98:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81147c9c:	00001106 	br	81147ce4 <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81147ca0:	01000044 	movi	r4,1
81147ca4:	113545c0 	call	8113545c <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81147ca8:	e0bff10b 	ldhu	r2,-60(fp)
81147cac:	1084e230 	cmpltui	r2,r2,5000
81147cb0:	1000091e 	bne	r2,zero,81147cd8 <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
81147cb4:	01204574 	movhi	r4,33045
81147cb8:	2100bf04 	addi	r4,r4,764
81147cbc:	1149bb00 	call	81149bb0 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81147cc0:	e0bffd17 	ldw	r2,-12(fp)
81147cc4:	10801817 	ldw	r2,96(r2)
81147cc8:	1009883a 	mov	r4,r2
81147ccc:	113e05c0 	call	8113e05c <OSSemPost>
				
                return -ETIME;
81147cd0:	00bff084 	movi	r2,-62
81147cd4:	00006e06 	br	81147e90 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
81147cd8:	e0bff10b 	ldhu	r2,-60(fp)
81147cdc:	10800044 	addi	r2,r2,1
81147ce0:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81147ce4:	e0bffd17 	ldw	r2,-12(fp)
81147ce8:	10c00317 	ldw	r3,12(r2)
81147cec:	e0bffd17 	ldw	r2,-12(fp)
81147cf0:	10800417 	ldw	r2,16(r2)
81147cf4:	e1bfff17 	ldw	r6,-4(fp)
81147cf8:	100b883a 	mov	r5,r2
81147cfc:	1809883a 	mov	r4,r3
81147d00:	11472ac0 	call	811472ac <alt_msgdma_write_extended_descriptor>
81147d04:	103fe61e 	bne	r2,zero,81147ca0 <__reset+0xfb127ca0>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81147d08:	00000606 	br	81147d24 <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81147d0c:	e0bffd17 	ldw	r2,-12(fp)
81147d10:	10801817 	ldw	r2,96(r2)
81147d14:	1009883a 	mov	r4,r2
81147d18:	113e05c0 	call	8113e05c <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81147d1c:	00bfffc4 	movi	r2,-1
81147d20:	00005b06 	br	81147e90 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81147d24:	e0bffd17 	ldw	r2,-12(fp)
81147d28:	10800317 	ldw	r2,12(r2)
81147d2c:	10800104 	addi	r2,r2,4
81147d30:	e0fffd17 	ldw	r3,-12(fp)
81147d34:	19000d17 	ldw	r4,52(r3)
81147d38:	00fff2c4 	movi	r3,-53
81147d3c:	20c6703a 	and	r3,r4,r3
81147d40:	18c00114 	ori	r3,r3,4
81147d44:	10c00035 	stwio	r3,0(r2)
81147d48:	e0bff517 	ldw	r2,-44(fp)
81147d4c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147d50:	e0bff717 	ldw	r2,-36(fp)
81147d54:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
81147d58:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81147d5c:	e0bffd17 	ldw	r2,-12(fp)
81147d60:	10800317 	ldw	r2,12(r2)
81147d64:	10800037 	ldwio	r2,0(r2)
81147d68:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81147d6c:	00001506 	br	81147dc4 <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
81147d70:	01000044 	movi	r4,1
81147d74:	113545c0 	call	8113545c <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81147d78:	e0bff10b 	ldhu	r2,-60(fp)
81147d7c:	1084e230 	cmpltui	r2,r2,5000
81147d80:	1000091e 	bne	r2,zero,81147da8 <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
81147d84:	01204574 	movhi	r4,33045
81147d88:	2100d004 	addi	r4,r4,832
81147d8c:	1149bb00 	call	81149bb0 <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
81147d90:	e0bffd17 	ldw	r2,-12(fp)
81147d94:	10801817 	ldw	r2,96(r2)
81147d98:	1009883a 	mov	r4,r2
81147d9c:	113e05c0 	call	8113e05c <OSSemPost>
			
            return -ETIME;
81147da0:	00bff084 	movi	r2,-62
81147da4:	00003a06 	br	81147e90 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
81147da8:	e0bff10b 	ldhu	r2,-60(fp)
81147dac:	10800044 	addi	r2,r2,1
81147db0:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81147db4:	e0bffd17 	ldw	r2,-12(fp)
81147db8:	10800317 	ldw	r2,12(r2)
81147dbc:	10800037 	ldwio	r2,0(r2)
81147dc0:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81147dc4:	e0fff017 	ldw	r3,-64(fp)
81147dc8:	e0bff617 	ldw	r2,-40(fp)
81147dcc:	1884703a 	and	r2,r3,r2
81147dd0:	1000031e 	bne	r2,zero,81147de0 <alt_msgdma_descriptor_sync_transfer+0x344>
81147dd4:	e0bff017 	ldw	r2,-64(fp)
81147dd8:	1080004c 	andi	r2,r2,1
81147ddc:	103fe41e 	bne	r2,zero,81147d70 <__reset+0xfb127d70>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
81147de0:	e0fff017 	ldw	r3,-64(fp)
81147de4:	e0bff617 	ldw	r2,-40(fp)
81147de8:	1884703a 	and	r2,r3,r2
81147dec:	10000626 	beq	r2,zero,81147e08 <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81147df0:	e0bffd17 	ldw	r2,-12(fp)
81147df4:	10801817 	ldw	r2,96(r2)
81147df8:	1009883a 	mov	r4,r2
81147dfc:	113e05c0 	call	8113e05c <OSSemPost>
		
        return error;
81147e00:	e0bff617 	ldw	r2,-40(fp)
81147e04:	00002206 	br	81147e90 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
81147e08:	e0bffd17 	ldw	r2,-12(fp)
81147e0c:	10800317 	ldw	r2,12(r2)
81147e10:	10800104 	addi	r2,r2,4
81147e14:	10800037 	ldwio	r2,0(r2)
81147e18:	10800814 	ori	r2,r2,32
81147e1c:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147e20:	0005303a 	rdctl	r2,status
81147e24:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147e28:	e0fffa17 	ldw	r3,-24(fp)
81147e2c:	00bfff84 	movi	r2,-2
81147e30:	1884703a 	and	r2,r3,r2
81147e34:	1001703a 	wrctl	status,r2
  
  return context;
81147e38:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
81147e3c:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81147e40:	e0bffd17 	ldw	r2,-12(fp)
81147e44:	10800317 	ldw	r2,12(r2)
81147e48:	10800104 	addi	r2,r2,4
81147e4c:	e0fff417 	ldw	r3,-48(fp)
81147e50:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81147e54:	e0bffd17 	ldw	r2,-12(fp)
81147e58:	10800317 	ldw	r2,12(r2)
81147e5c:	e0fffd17 	ldw	r3,-12(fp)
81147e60:	18c00317 	ldw	r3,12(r3)
81147e64:	18c00037 	ldwio	r3,0(r3)
81147e68:	10c00035 	stwio	r3,0(r2)
81147e6c:	e0bff517 	ldw	r2,-44(fp)
81147e70:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147e74:	e0bff917 	ldw	r2,-28(fp)
81147e78:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
81147e7c:	e0bffd17 	ldw	r2,-12(fp)
81147e80:	10801817 	ldw	r2,96(r2)
81147e84:	1009883a 	mov	r4,r2
81147e88:	113e05c0 	call	8113e05c <OSSemPost>
    
    return 0;
81147e8c:	0005883a 	mov	r2,zero

}
81147e90:	e037883a 	mov	sp,fp
81147e94:	dfc00117 	ldw	ra,4(sp)
81147e98:	df000017 	ldw	fp,0(sp)
81147e9c:	dec00204 	addi	sp,sp,8
81147ea0:	f800283a 	ret

81147ea4 <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
81147ea4:	defff804 	addi	sp,sp,-32
81147ea8:	de00012e 	bgeu	sp,et,81147eb0 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
81147eac:	003b68fa 	trap	3
81147eb0:	dfc00715 	stw	ra,28(sp)
81147eb4:	df000615 	stw	fp,24(sp)
81147eb8:	df000604 	addi	fp,sp,24
81147ebc:	e13ffc15 	stw	r4,-16(fp)
81147ec0:	e17ffd15 	stw	r5,-12(fp)
81147ec4:	e1bffe15 	stw	r6,-8(fp)
81147ec8:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
81147ecc:	e0800217 	ldw	r2,8(fp)
81147ed0:	d8800115 	stw	r2,4(sp)
81147ed4:	e0bfff17 	ldw	r2,-4(fp)
81147ed8:	d8800015 	stw	r2,0(sp)
81147edc:	e1fffe17 	ldw	r7,-8(fp)
81147ee0:	000d883a 	mov	r6,zero
81147ee4:	e17ffd17 	ldw	r5,-12(fp)
81147ee8:	e13ffc17 	ldw	r4,-16(fp)
81147eec:	114756c0 	call	8114756c <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81147ef0:	e037883a 	mov	sp,fp
81147ef4:	dfc00117 	ldw	ra,4(sp)
81147ef8:	df000017 	ldw	fp,0(sp)
81147efc:	dec00204 	addi	sp,sp,8
81147f00:	f800283a 	ret

81147f04 <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
81147f04:	defff804 	addi	sp,sp,-32
81147f08:	de00012e 	bgeu	sp,et,81147f10 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
81147f0c:	003b68fa 	trap	3
81147f10:	dfc00715 	stw	ra,28(sp)
81147f14:	df000615 	stw	fp,24(sp)
81147f18:	df000604 	addi	fp,sp,24
81147f1c:	e13ffc15 	stw	r4,-16(fp)
81147f20:	e17ffd15 	stw	r5,-12(fp)
81147f24:	e1bffe15 	stw	r6,-8(fp)
81147f28:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81147f2c:	e0800217 	ldw	r2,8(fp)
81147f30:	d8800115 	stw	r2,4(sp)
81147f34:	e0bfff17 	ldw	r2,-4(fp)
81147f38:	d8800015 	stw	r2,0(sp)
81147f3c:	000f883a 	mov	r7,zero
81147f40:	e1bffe17 	ldw	r6,-8(fp)
81147f44:	e17ffd17 	ldw	r5,-12(fp)
81147f48:	e13ffc17 	ldw	r4,-16(fp)
81147f4c:	114756c0 	call	8114756c <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
81147f50:	e037883a 	mov	sp,fp
81147f54:	dfc00117 	ldw	ra,4(sp)
81147f58:	df000017 	ldw	fp,0(sp)
81147f5c:	dec00204 	addi	sp,sp,8
81147f60:	f800283a 	ret

81147f64 <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81147f64:	defff804 	addi	sp,sp,-32
81147f68:	de00012e 	bgeu	sp,et,81147f70 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
81147f6c:	003b68fa 	trap	3
81147f70:	dfc00715 	stw	ra,28(sp)
81147f74:	df000615 	stw	fp,24(sp)
81147f78:	df000604 	addi	fp,sp,24
81147f7c:	e13ffc15 	stw	r4,-16(fp)
81147f80:	e17ffd15 	stw	r5,-12(fp)
81147f84:	e1bffe15 	stw	r6,-8(fp)
81147f88:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81147f8c:	e0800317 	ldw	r2,12(fp)
81147f90:	d8800115 	stw	r2,4(sp)
81147f94:	e0800217 	ldw	r2,8(fp)
81147f98:	d8800015 	stw	r2,0(sp)
81147f9c:	e1ffff17 	ldw	r7,-4(fp)
81147fa0:	e1bffe17 	ldw	r6,-8(fp)
81147fa4:	e17ffd17 	ldw	r5,-12(fp)
81147fa8:	e13ffc17 	ldw	r4,-16(fp)
81147fac:	114756c0 	call	8114756c <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81147fb0:	e037883a 	mov	sp,fp
81147fb4:	dfc00117 	ldw	ra,4(sp)
81147fb8:	df000017 	ldw	fp,0(sp)
81147fbc:	dec00204 	addi	sp,sp,8
81147fc0:	f800283a 	ret

81147fc4 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
81147fc4:	defff004 	addi	sp,sp,-64
81147fc8:	de00012e 	bgeu	sp,et,81147fd0 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
81147fcc:	003b68fa 	trap	3
81147fd0:	dfc00f15 	stw	ra,60(sp)
81147fd4:	df000e15 	stw	fp,56(sp)
81147fd8:	df000e04 	addi	fp,sp,56
81147fdc:	e13ff915 	stw	r4,-28(fp)
81147fe0:	e17ffa15 	stw	r5,-24(fp)
81147fe4:	e1bffb15 	stw	r6,-20(fp)
81147fe8:	e1fffc15 	stw	r7,-16(fp)
81147fec:	e1000317 	ldw	r4,12(fp)
81147ff0:	e0c00417 	ldw	r3,16(fp)
81147ff4:	e0800517 	ldw	r2,20(fp)
81147ff8:	e13ffd0d 	sth	r4,-12(fp)
81147ffc:	e0fffe05 	stb	r3,-8(fp)
81148000:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81148004:	e0bffd0b 	ldhu	r2,-12(fp)
81148008:	e0fffe03 	ldbu	r3,-8(fp)
8114800c:	e13fff0b 	ldhu	r4,-4(fp)
81148010:	d9000615 	stw	r4,24(sp)
81148014:	d8000515 	stw	zero,20(sp)
81148018:	d8c00415 	stw	r3,16(sp)
8114801c:	d8000315 	stw	zero,12(sp)
81148020:	d8800215 	stw	r2,8(sp)
81148024:	e0800217 	ldw	r2,8(fp)
81148028:	d8800115 	stw	r2,4(sp)
8114802c:	e0bffc17 	ldw	r2,-16(fp)
81148030:	d8800015 	stw	r2,0(sp)
81148034:	e1fffb17 	ldw	r7,-20(fp)
81148038:	000d883a 	mov	r6,zero
8114803c:	e17ffa17 	ldw	r5,-24(fp)
81148040:	e13ff917 	ldw	r4,-28(fp)
81148044:	11476000 	call	81147600 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
81148048:	e037883a 	mov	sp,fp
8114804c:	dfc00117 	ldw	ra,4(sp)
81148050:	df000017 	ldw	fp,0(sp)
81148054:	dec00204 	addi	sp,sp,8
81148058:	f800283a 	ret

8114805c <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
8114805c:	defff004 	addi	sp,sp,-64
81148060:	de00012e 	bgeu	sp,et,81148068 <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
81148064:	003b68fa 	trap	3
81148068:	dfc00f15 	stw	ra,60(sp)
8114806c:	df000e15 	stw	fp,56(sp)
81148070:	df000e04 	addi	fp,sp,56
81148074:	e13ff915 	stw	r4,-28(fp)
81148078:	e17ffa15 	stw	r5,-24(fp)
8114807c:	e1bffb15 	stw	r6,-20(fp)
81148080:	e1fffc15 	stw	r7,-16(fp)
81148084:	e1000317 	ldw	r4,12(fp)
81148088:	e0c00417 	ldw	r3,16(fp)
8114808c:	e0800517 	ldw	r2,20(fp)
81148090:	e13ffd0d 	sth	r4,-12(fp)
81148094:	e0fffe05 	stb	r3,-8(fp)
81148098:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
8114809c:	e0bffd0b 	ldhu	r2,-12(fp)
811480a0:	e0fffe03 	ldbu	r3,-8(fp)
811480a4:	e13fff0b 	ldhu	r4,-4(fp)
811480a8:	d8000615 	stw	zero,24(sp)
811480ac:	d9000515 	stw	r4,20(sp)
811480b0:	d8000415 	stw	zero,16(sp)
811480b4:	d8c00315 	stw	r3,12(sp)
811480b8:	d8800215 	stw	r2,8(sp)
811480bc:	e0800217 	ldw	r2,8(fp)
811480c0:	d8800115 	stw	r2,4(sp)
811480c4:	e0bffc17 	ldw	r2,-16(fp)
811480c8:	d8800015 	stw	r2,0(sp)
811480cc:	000f883a 	mov	r7,zero
811480d0:	e1bffb17 	ldw	r6,-20(fp)
811480d4:	e17ffa17 	ldw	r5,-24(fp)
811480d8:	e13ff917 	ldw	r4,-28(fp)
811480dc:	11476000 	call	81147600 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
811480e0:	e037883a 	mov	sp,fp
811480e4:	dfc00117 	ldw	ra,4(sp)
811480e8:	df000017 	ldw	fp,0(sp)
811480ec:	dec00204 	addi	sp,sp,8
811480f0:	f800283a 	ret

811480f4 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
811480f4:	deffee04 	addi	sp,sp,-72
811480f8:	de00012e 	bgeu	sp,et,81148100 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
811480fc:	003b68fa 	trap	3
81148100:	dfc01115 	stw	ra,68(sp)
81148104:	df001015 	stw	fp,64(sp)
81148108:	df001004 	addi	fp,sp,64
8114810c:	e13ff715 	stw	r4,-36(fp)
81148110:	e17ff815 	stw	r5,-32(fp)
81148114:	e1bff915 	stw	r6,-28(fp)
81148118:	e1fffa15 	stw	r7,-24(fp)
8114811c:	e1800417 	ldw	r6,16(fp)
81148120:	e1400517 	ldw	r5,20(fp)
81148124:	e1000617 	ldw	r4,24(fp)
81148128:	e0c00717 	ldw	r3,28(fp)
8114812c:	e0800817 	ldw	r2,32(fp)
81148130:	e1bffb0d 	sth	r6,-20(fp)
81148134:	e17ffc05 	stb	r5,-16(fp)
81148138:	e13ffd05 	stb	r4,-12(fp)
8114813c:	e0fffe0d 	sth	r3,-8(fp)
81148140:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81148144:	e0bffb0b 	ldhu	r2,-20(fp)
81148148:	e0fffc03 	ldbu	r3,-16(fp)
8114814c:	e13ffd03 	ldbu	r4,-12(fp)
81148150:	e17ffe0b 	ldhu	r5,-8(fp)
81148154:	e1bfff0b 	ldhu	r6,-4(fp)
81148158:	d9800615 	stw	r6,24(sp)
8114815c:	d9400515 	stw	r5,20(sp)
81148160:	d9000415 	stw	r4,16(sp)
81148164:	d8c00315 	stw	r3,12(sp)
81148168:	d8800215 	stw	r2,8(sp)
8114816c:	e0800317 	ldw	r2,12(fp)
81148170:	d8800115 	stw	r2,4(sp)
81148174:	e0800217 	ldw	r2,8(fp)
81148178:	d8800015 	stw	r2,0(sp)
8114817c:	e1fffa17 	ldw	r7,-24(fp)
81148180:	e1bff917 	ldw	r6,-28(fp)
81148184:	e17ff817 	ldw	r5,-32(fp)
81148188:	e13ff717 	ldw	r4,-36(fp)
8114818c:	11476000 	call	81147600 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
81148190:	e037883a 	mov	sp,fp
81148194:	dfc00117 	ldw	ra,4(sp)
81148198:	df000017 	ldw	fp,0(sp)
8114819c:	dec00204 	addi	sp,sp,8
811481a0:	f800283a 	ret

811481a4 <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
811481a4:	defffb04 	addi	sp,sp,-20
811481a8:	de00012e 	bgeu	sp,et,811481b0 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
811481ac:	003b68fa 	trap	3
811481b0:	df000415 	stw	fp,16(sp)
811481b4:	df000404 	addi	fp,sp,16
811481b8:	e13ffc15 	stw	r4,-16(fp)
811481bc:	e17ffd15 	stw	r5,-12(fp)
811481c0:	e1bffe15 	stw	r6,-8(fp)
811481c4:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
811481c8:	e0bffc17 	ldw	r2,-16(fp)
811481cc:	10c01217 	ldw	r3,72(r2)
811481d0:	e0800117 	ldw	r2,4(fp)
811481d4:	18800436 	bltu	r3,r2,811481e8 <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
811481d8:	e0bffc17 	ldw	r2,-16(fp)
811481dc:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
811481e0:	10803fcc 	andi	r2,r2,255
811481e4:	10000226 	beq	r2,zero,811481f0 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
811481e8:	00bffa84 	movi	r2,-22
811481ec:	00001406 	br	81148240 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
811481f0:	e0bffd17 	ldw	r2,-12(fp)
811481f4:	e0fffe17 	ldw	r3,-8(fp)
811481f8:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
811481fc:	e0bffd17 	ldw	r2,-12(fp)
81148200:	e0ffff17 	ldw	r3,-4(fp)
81148204:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81148208:	e0bffd17 	ldw	r2,-12(fp)
8114820c:	e0c00117 	ldw	r3,4(fp)
81148210:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
81148214:	e0fffd17 	ldw	r3,-12(fp)
81148218:	e0bffd17 	ldw	r2,-12(fp)
8114821c:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81148220:	e0c00217 	ldw	r3,8(fp)
81148224:	00900034 	movhi	r2,16384
81148228:	10bfffc4 	addi	r2,r2,-1
8114822c:	1884703a 	and	r2,r3,r2
81148230:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
81148234:	e0bffd17 	ldw	r2,-12(fp)
81148238:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
8114823c:	0005883a 	mov	r2,zero
}
81148240:	e037883a 	mov	sp,fp
81148244:	df000017 	ldw	fp,0(sp)
81148248:	dec00104 	addi	sp,sp,4
8114824c:	f800283a 	ret

81148250 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81148250:	defff404 	addi	sp,sp,-48
81148254:	de00012e 	bgeu	sp,et,8114825c <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
81148258:	003b68fa 	trap	3
8114825c:	df000b15 	stw	fp,44(sp)
81148260:	df000b04 	addi	fp,sp,44
81148264:	e13ff715 	stw	r4,-36(fp)
81148268:	e17ff815 	stw	r5,-32(fp)
8114826c:	e1bff915 	stw	r6,-28(fp)
81148270:	e1fffa15 	stw	r7,-24(fp)
81148274:	e1800517 	ldw	r6,20(fp)
81148278:	e1400617 	ldw	r5,24(fp)
8114827c:	e1000717 	ldw	r4,28(fp)
81148280:	e0c00817 	ldw	r3,32(fp)
81148284:	e0800917 	ldw	r2,36(fp)
81148288:	e1bffb0d 	sth	r6,-20(fp)
8114828c:	e17ffc05 	stb	r5,-16(fp)
81148290:	e13ffd05 	stb	r4,-12(fp)
81148294:	e0fffe0d 	sth	r3,-8(fp)
81148298:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
8114829c:	e0bff717 	ldw	r2,-36(fp)
811482a0:	10c01217 	ldw	r3,72(r2)
811482a4:	e0800317 	ldw	r2,12(fp)
811482a8:	18801936 	bltu	r3,r2,81148310 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
811482ac:	e13ff717 	ldw	r4,-36(fp)
811482b0:	20801317 	ldw	r2,76(r4)
811482b4:	20c01417 	ldw	r3,80(r4)
811482b8:	e13ffe0b 	ldhu	r4,-8(fp)
811482bc:	213fffcc 	andi	r4,r4,65535
811482c0:	2015883a 	mov	r10,r4
811482c4:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
811482c8:	1ac01136 	bltu	r3,r11,81148310 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
811482cc:	58c0011e 	bne	r11,r3,811482d4 <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
811482d0:	12800f36 	bltu	r2,r10,81148310 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811482d4:	e13ff717 	ldw	r4,-36(fp)
811482d8:	20801317 	ldw	r2,76(r4)
811482dc:	20c01417 	ldw	r3,80(r4)
811482e0:	e13fff0b 	ldhu	r4,-4(fp)
811482e4:	213fffcc 	andi	r4,r4,65535
811482e8:	2011883a 	mov	r8,r4
811482ec:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
811482f0:	1a400736 	bltu	r3,r9,81148310 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
811482f4:	48c0011e 	bne	r9,r3,811482fc <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
811482f8:	12000536 	bltu	r2,r8,81148310 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
811482fc:	e0bff717 	ldw	r2,-36(fp)
81148300:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81148304:	10803fcc 	andi	r2,r2,255
81148308:	10800060 	cmpeqi	r2,r2,1
8114830c:	1000021e 	bne	r2,zero,81148318 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81148310:	00bffa84 	movi	r2,-22
81148314:	00003106 	br	811483dc <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
81148318:	e0bff817 	ldw	r2,-32(fp)
8114831c:	e0fff917 	ldw	r3,-28(fp)
81148320:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
81148324:	e0bff817 	ldw	r2,-32(fp)
81148328:	e0fffa17 	ldw	r3,-24(fp)
8114832c:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
81148330:	e0bff817 	ldw	r2,-32(fp)
81148334:	e0c00117 	ldw	r3,4(fp)
81148338:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
8114833c:	e0bff817 	ldw	r2,-32(fp)
81148340:	e0c00217 	ldw	r3,8(fp)
81148344:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81148348:	e0bff817 	ldw	r2,-32(fp)
8114834c:	e0c00317 	ldw	r3,12(fp)
81148350:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81148354:	e0bff817 	ldw	r2,-32(fp)
81148358:	e0fffb0b 	ldhu	r3,-20(fp)
8114835c:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
81148360:	e0bff817 	ldw	r2,-32(fp)
81148364:	e0fffc03 	ldbu	r3,-16(fp)
81148368:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
8114836c:	e0bff817 	ldw	r2,-32(fp)
81148370:	e0fffd03 	ldbu	r3,-12(fp)
81148374:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
81148378:	e0bff817 	ldw	r2,-32(fp)
8114837c:	e0fffe0b 	ldhu	r3,-8(fp)
81148380:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
81148384:	e0bff817 	ldw	r2,-32(fp)
81148388:	e0ffff0b 	ldhu	r3,-4(fp)
8114838c:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
81148390:	e0bff817 	ldw	r2,-32(fp)
81148394:	1019883a 	mov	r12,r2
81148398:	001b883a 	mov	r13,zero
8114839c:	e33ff515 	stw	r12,-44(fp)
811483a0:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
811483a4:	e0fff517 	ldw	r3,-44(fp)
811483a8:	e0bff817 	ldw	r2,-32(fp)
811483ac:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
811483b0:	e0fff617 	ldw	r3,-40(fp)
811483b4:	e0bff817 	ldw	r2,-32(fp)
811483b8:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
811483bc:	e0c00417 	ldw	r3,16(fp)
811483c0:	00900034 	movhi	r2,16384
811483c4:	10bfffc4 	addi	r2,r2,-1
811483c8:	1884703a 	and	r2,r3,r2
811483cc:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
811483d0:	e0bff817 	ldw	r2,-32(fp)
811483d4:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
811483d8:	0005883a 	mov	r2,zero
}
811483dc:	e037883a 	mov	sp,fp
811483e0:	df000017 	ldw	fp,0(sp)
811483e4:	dec00104 	addi	sp,sp,4
811483e8:	f800283a 	ret

811483ec <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
811483ec:	defff804 	addi	sp,sp,-32
811483f0:	de00012e 	bgeu	sp,et,811483f8 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
811483f4:	003b68fa 	trap	3
811483f8:	dfc00715 	stw	ra,28(sp)
811483fc:	df000615 	stw	fp,24(sp)
81148400:	df000604 	addi	fp,sp,24
81148404:	e13ffc15 	stw	r4,-16(fp)
81148408:	e17ffd15 	stw	r5,-12(fp)
8114840c:	e1bffe15 	stw	r6,-8(fp)
81148410:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81148414:	e0800317 	ldw	r2,12(fp)
81148418:	d8800115 	stw	r2,4(sp)
8114841c:	e0800217 	ldw	r2,8(fp)
81148420:	d8800015 	stw	r2,0(sp)
81148424:	e1ffff17 	ldw	r7,-4(fp)
81148428:	e1bffe17 	ldw	r6,-8(fp)
8114842c:	e17ffd17 	ldw	r5,-12(fp)
81148430:	e13ffc17 	ldw	r4,-16(fp)
81148434:	11481a40 	call	811481a4 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
81148438:	e037883a 	mov	sp,fp
8114843c:	dfc00117 	ldw	ra,4(sp)
81148440:	df000017 	ldw	fp,0(sp)
81148444:	dec00204 	addi	sp,sp,8
81148448:	f800283a 	ret

8114844c <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114844c:	defff804 	addi	sp,sp,-32
81148450:	de00012e 	bgeu	sp,et,81148458 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
81148454:	003b68fa 	trap	3
81148458:	dfc00715 	stw	ra,28(sp)
8114845c:	df000615 	stw	fp,24(sp)
81148460:	df000604 	addi	fp,sp,24
81148464:	e13ffc15 	stw	r4,-16(fp)
81148468:	e17ffd15 	stw	r5,-12(fp)
8114846c:	e1bffe15 	stw	r6,-8(fp)
81148470:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81148474:	e0800217 	ldw	r2,8(fp)
81148478:	d8800115 	stw	r2,4(sp)
8114847c:	e0bfff17 	ldw	r2,-4(fp)
81148480:	d8800015 	stw	r2,0(sp)
81148484:	e1fffe17 	ldw	r7,-8(fp)
81148488:	000d883a 	mov	r6,zero
8114848c:	e17ffd17 	ldw	r5,-12(fp)
81148490:	e13ffc17 	ldw	r4,-16(fp)
81148494:	11481a40 	call	811481a4 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
81148498:	e037883a 	mov	sp,fp
8114849c:	dfc00117 	ldw	ra,4(sp)
811484a0:	df000017 	ldw	fp,0(sp)
811484a4:	dec00204 	addi	sp,sp,8
811484a8:	f800283a 	ret

811484ac <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
811484ac:	defff804 	addi	sp,sp,-32
811484b0:	de00012e 	bgeu	sp,et,811484b8 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
811484b4:	003b68fa 	trap	3
811484b8:	dfc00715 	stw	ra,28(sp)
811484bc:	df000615 	stw	fp,24(sp)
811484c0:	df000604 	addi	fp,sp,24
811484c4:	e13ffc15 	stw	r4,-16(fp)
811484c8:	e17ffd15 	stw	r5,-12(fp)
811484cc:	e1bffe15 	stw	r6,-8(fp)
811484d0:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
811484d4:	e0800217 	ldw	r2,8(fp)
811484d8:	d8800115 	stw	r2,4(sp)
811484dc:	e0bfff17 	ldw	r2,-4(fp)
811484e0:	d8800015 	stw	r2,0(sp)
811484e4:	000f883a 	mov	r7,zero
811484e8:	e1bffe17 	ldw	r6,-8(fp)
811484ec:	e17ffd17 	ldw	r5,-12(fp)
811484f0:	e13ffc17 	ldw	r4,-16(fp)
811484f4:	11481a40 	call	811481a4 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
811484f8:	e037883a 	mov	sp,fp
811484fc:	dfc00117 	ldw	ra,4(sp)
81148500:	df000017 	ldw	fp,0(sp)
81148504:	dec00204 	addi	sp,sp,8
81148508:	f800283a 	ret

8114850c <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
8114850c:	deffee04 	addi	sp,sp,-72
81148510:	de00012e 	bgeu	sp,et,81148518 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
81148514:	003b68fa 	trap	3
81148518:	dfc01115 	stw	ra,68(sp)
8114851c:	df001015 	stw	fp,64(sp)
81148520:	df001004 	addi	fp,sp,64
81148524:	e13ff915 	stw	r4,-28(fp)
81148528:	e17ffa15 	stw	r5,-24(fp)
8114852c:	e1bffb15 	stw	r6,-20(fp)
81148530:	e1fffc15 	stw	r7,-16(fp)
81148534:	e1000417 	ldw	r4,16(fp)
81148538:	e0c00517 	ldw	r3,20(fp)
8114853c:	e0800617 	ldw	r2,24(fp)
81148540:	e13ffd0d 	sth	r4,-12(fp)
81148544:	e0fffe05 	stb	r3,-8(fp)
81148548:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
8114854c:	e0bffd0b 	ldhu	r2,-12(fp)
81148550:	e0fffe03 	ldbu	r3,-8(fp)
81148554:	e13fff0b 	ldhu	r4,-4(fp)
81148558:	d9000815 	stw	r4,32(sp)
8114855c:	d8000715 	stw	zero,28(sp)
81148560:	d8c00615 	stw	r3,24(sp)
81148564:	d8000515 	stw	zero,20(sp)
81148568:	d8800415 	stw	r2,16(sp)
8114856c:	e0800317 	ldw	r2,12(fp)
81148570:	d8800315 	stw	r2,12(sp)
81148574:	e0800217 	ldw	r2,8(fp)
81148578:	d8800215 	stw	r2,8(sp)
8114857c:	e0bffc17 	ldw	r2,-16(fp)
81148580:	d8800115 	stw	r2,4(sp)
81148584:	e0bffb17 	ldw	r2,-20(fp)
81148588:	d8800015 	stw	r2,0(sp)
8114858c:	000f883a 	mov	r7,zero
81148590:	000d883a 	mov	r6,zero
81148594:	e17ffa17 	ldw	r5,-24(fp)
81148598:	e13ff917 	ldw	r4,-28(fp)
8114859c:	11482500 	call	81148250 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
811485a0:	e037883a 	mov	sp,fp
811485a4:	dfc00117 	ldw	ra,4(sp)
811485a8:	df000017 	ldw	fp,0(sp)
811485ac:	dec00204 	addi	sp,sp,8
811485b0:	f800283a 	ret

811485b4 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
811485b4:	deffee04 	addi	sp,sp,-72
811485b8:	de00012e 	bgeu	sp,et,811485c0 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
811485bc:	003b68fa 	trap	3
811485c0:	dfc01115 	stw	ra,68(sp)
811485c4:	df001015 	stw	fp,64(sp)
811485c8:	df001004 	addi	fp,sp,64
811485cc:	e13ff915 	stw	r4,-28(fp)
811485d0:	e17ffa15 	stw	r5,-24(fp)
811485d4:	e1bffb15 	stw	r6,-20(fp)
811485d8:	e1fffc15 	stw	r7,-16(fp)
811485dc:	e1000417 	ldw	r4,16(fp)
811485e0:	e0c00517 	ldw	r3,20(fp)
811485e4:	e0800617 	ldw	r2,24(fp)
811485e8:	e13ffd0d 	sth	r4,-12(fp)
811485ec:	e0fffe05 	stb	r3,-8(fp)
811485f0:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
811485f4:	e0bffd0b 	ldhu	r2,-12(fp)
811485f8:	e0fffe03 	ldbu	r3,-8(fp)
811485fc:	e13fff0b 	ldhu	r4,-4(fp)
81148600:	d8000815 	stw	zero,32(sp)
81148604:	d9000715 	stw	r4,28(sp)
81148608:	d8000615 	stw	zero,24(sp)
8114860c:	d8c00515 	stw	r3,20(sp)
81148610:	d8800415 	stw	r2,16(sp)
81148614:	e0800317 	ldw	r2,12(fp)
81148618:	d8800315 	stw	r2,12(sp)
8114861c:	e0800217 	ldw	r2,8(fp)
81148620:	d8800215 	stw	r2,8(sp)
81148624:	d8000115 	stw	zero,4(sp)
81148628:	d8000015 	stw	zero,0(sp)
8114862c:	e1fffc17 	ldw	r7,-16(fp)
81148630:	e1bffb17 	ldw	r6,-20(fp)
81148634:	e17ffa17 	ldw	r5,-24(fp)
81148638:	e13ff917 	ldw	r4,-28(fp)
8114863c:	11482500 	call	81148250 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
81148640:	e037883a 	mov	sp,fp
81148644:	dfc00117 	ldw	ra,4(sp)
81148648:	df000017 	ldw	fp,0(sp)
8114864c:	dec00204 	addi	sp,sp,8
81148650:	f800283a 	ret

81148654 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81148654:	deffec04 	addi	sp,sp,-80
81148658:	de00012e 	bgeu	sp,et,81148660 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
8114865c:	003b68fa 	trap	3
81148660:	dfc01315 	stw	ra,76(sp)
81148664:	df001215 	stw	fp,72(sp)
81148668:	df001204 	addi	fp,sp,72
8114866c:	e13ff715 	stw	r4,-36(fp)
81148670:	e17ff815 	stw	r5,-32(fp)
81148674:	e1bff915 	stw	r6,-28(fp)
81148678:	e1fffa15 	stw	r7,-24(fp)
8114867c:	e1800617 	ldw	r6,24(fp)
81148680:	e1400717 	ldw	r5,28(fp)
81148684:	e1000817 	ldw	r4,32(fp)
81148688:	e0c00917 	ldw	r3,36(fp)
8114868c:	e0800a17 	ldw	r2,40(fp)
81148690:	e1bffb0d 	sth	r6,-20(fp)
81148694:	e17ffc05 	stb	r5,-16(fp)
81148698:	e13ffd05 	stb	r4,-12(fp)
8114869c:	e0fffe0d 	sth	r3,-8(fp)
811486a0:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
811486a4:	e0bffb0b 	ldhu	r2,-20(fp)
811486a8:	e0fffc03 	ldbu	r3,-16(fp)
811486ac:	e13ffd03 	ldbu	r4,-12(fp)
811486b0:	e17ffe0b 	ldhu	r5,-8(fp)
811486b4:	e1bfff0b 	ldhu	r6,-4(fp)
811486b8:	d9800815 	stw	r6,32(sp)
811486bc:	d9400715 	stw	r5,28(sp)
811486c0:	d9000615 	stw	r4,24(sp)
811486c4:	d8c00515 	stw	r3,20(sp)
811486c8:	d8800415 	stw	r2,16(sp)
811486cc:	e0800517 	ldw	r2,20(fp)
811486d0:	d8800315 	stw	r2,12(sp)
811486d4:	e0800417 	ldw	r2,16(fp)
811486d8:	d8800215 	stw	r2,8(sp)
811486dc:	e0800317 	ldw	r2,12(fp)
811486e0:	d8800115 	stw	r2,4(sp)
811486e4:	e0800217 	ldw	r2,8(fp)
811486e8:	d8800015 	stw	r2,0(sp)
811486ec:	e1fffa17 	ldw	r7,-24(fp)
811486f0:	e1bff917 	ldw	r6,-28(fp)
811486f4:	e17ff817 	ldw	r5,-32(fp)
811486f8:	e13ff717 	ldw	r4,-36(fp)
811486fc:	11482500 	call	81148250 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
81148700:	e037883a 	mov	sp,fp
81148704:	dfc00117 	ldw	ra,4(sp)
81148708:	df000017 	ldw	fp,0(sp)
8114870c:	dec00204 	addi	sp,sp,8
81148710:	f800283a 	ret

81148714 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
81148714:	defffc04 	addi	sp,sp,-16
81148718:	de00012e 	bgeu	sp,et,81148720 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
8114871c:	003b68fa 	trap	3
81148720:	df000315 	stw	fp,12(sp)
81148724:	df000304 	addi	fp,sp,12
81148728:	e13ffe15 	stw	r4,-8(fp)
8114872c:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
81148730:	e0bfff17 	ldw	r2,-4(fp)
81148734:	1000021e 	bne	r2,zero,81148740 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
81148738:	00bffa84 	movi	r2,-22
8114873c:	00002f06 	br	811487fc <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
81148740:	e0bfff17 	ldw	r2,-4(fp)
81148744:	10c00317 	ldw	r3,12(r2)
81148748:	e0bfff17 	ldw	r2,-4(fp)
8114874c:	18800226 	beq	r3,r2,81148758 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
81148750:	00bffa84 	movi	r2,-22
81148754:	00002906 	br	811487fc <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
81148758:	e0bffe17 	ldw	r2,-8(fp)
8114875c:	10800017 	ldw	r2,0(r2)
81148760:	1000051e 	bne	r2,zero,81148778 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
81148764:	e0bffe17 	ldw	r2,-8(fp)
81148768:	e0ffff17 	ldw	r3,-4(fp)
8114876c:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
81148770:	0005883a 	mov	r2,zero
81148774:	00002106 	br	811487fc <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
81148778:	e0bffe17 	ldw	r2,-8(fp)
8114877c:	10c00017 	ldw	r3,0(r2)
81148780:	e0bfff17 	ldw	r2,-4(fp)
81148784:	1880021e 	bne	r3,r2,81148790 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
81148788:	00bffa84 	movi	r2,-22
8114878c:	00001b06 	br	811487fc <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
81148790:	e0bffe17 	ldw	r2,-8(fp)
81148794:	10800017 	ldw	r2,0(r2)
81148798:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
8114879c:	00000906 	br	811487c4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
811487a0:	e0bffd17 	ldw	r2,-12(fp)
811487a4:	10c00317 	ldw	r3,12(r2)
811487a8:	e0bfff17 	ldw	r2,-4(fp)
811487ac:	1880021e 	bne	r3,r2,811487b8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
811487b0:	00bffa84 	movi	r2,-22
811487b4:	00001106 	br	811487fc <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
811487b8:	e0bffd17 	ldw	r2,-12(fp)
811487bc:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
811487c0:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
811487c4:	e0bffd17 	ldw	r2,-12(fp)
811487c8:	10800317 	ldw	r2,12(r2)
811487cc:	e0fffe17 	ldw	r3,-8(fp)
811487d0:	18c00017 	ldw	r3,0(r3)
811487d4:	10fff21e 	bne	r2,r3,811487a0 <__reset+0xfb1287a0>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
811487d8:	e0ffff17 	ldw	r3,-4(fp)
811487dc:	e0bffd17 	ldw	r2,-12(fp)
811487e0:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
811487e4:	e0bffe17 	ldw	r2,-8(fp)
811487e8:	10800017 	ldw	r2,0(r2)
811487ec:	1007883a 	mov	r3,r2
811487f0:	e0bfff17 	ldw	r2,-4(fp)
811487f4:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
811487f8:	0005883a 	mov	r2,zero
}
811487fc:	e037883a 	mov	sp,fp
81148800:	df000017 	ldw	fp,0(sp)
81148804:	dec00104 	addi	sp,sp,4
81148808:	f800283a 	ret

8114880c <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
8114880c:	defff804 	addi	sp,sp,-32
81148810:	de00012e 	bgeu	sp,et,81148818 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
81148814:	003b68fa 	trap	3
81148818:	df000715 	stw	fp,28(sp)
8114881c:	df000704 	addi	fp,sp,28
81148820:	e13ffe15 	stw	r4,-8(fp)
81148824:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
81148828:	e13fff17 	ldw	r4,-4(fp)
8114882c:	2000021e 	bne	r4,zero,81148838 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
81148830:	00bffa84 	movi	r2,-22
81148834:	00005906 	br	8114899c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
81148838:	e13fff17 	ldw	r4,-4(fp)
8114883c:	2015883a 	mov	r10,r4
81148840:	0017883a 	mov	r11,zero
81148844:	e2bffc15 	stw	r10,-16(fp)
81148848:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8114884c:	e13fff17 	ldw	r4,-4(fp)
81148850:	21400317 	ldw	r5,12(r4)
81148854:	e13ffc17 	ldw	r4,-16(fp)
81148858:	29000626 	beq	r5,r4,81148874 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
8114885c:	e13fff17 	ldw	r4,-4(fp)
81148860:	21400b17 	ldw	r5,44(r4)
81148864:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
81148868:	29000226 	beq	r5,r4,81148874 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8114886c:	00bffa84 	movi	r2,-22
81148870:	00004a06 	br	8114899c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
81148874:	e13ffe17 	ldw	r4,-8(fp)
81148878:	21000017 	ldw	r4,0(r4)
8114887c:	2000051e 	bne	r4,zero,81148894 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
81148880:	e0bffe17 	ldw	r2,-8(fp)
81148884:	e0ffff17 	ldw	r3,-4(fp)
81148888:	10c00015 	stw	r3,0(r2)
		return 0;
8114888c:	0005883a 	mov	r2,zero
81148890:	00004206 	br	8114899c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
81148894:	e13ffe17 	ldw	r4,-8(fp)
81148898:	21400017 	ldw	r5,0(r4)
8114889c:	e13fff17 	ldw	r4,-4(fp)
811488a0:	2900021e 	bne	r5,r4,811488ac <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
811488a4:	00bffa84 	movi	r2,-22
811488a8:	00003c06 	br	8114899c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
811488ac:	e13ffe17 	ldw	r4,-8(fp)
811488b0:	21000017 	ldw	r4,0(r4)
811488b4:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
811488b8:	e13ffe17 	ldw	r4,-8(fp)
811488bc:	21000017 	ldw	r4,0(r4)
811488c0:	2011883a 	mov	r8,r4
811488c4:	0013883a 	mov	r9,zero
811488c8:	e23ffa15 	stw	r8,-24(fp)
811488cc:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
811488d0:	00001806 	br	81148934 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
811488d4:	e13fff17 	ldw	r4,-4(fp)
811488d8:	200d883a 	mov	r6,r4
811488dc:	000f883a 	mov	r7,zero
811488e0:	e1bffc15 	stw	r6,-16(fp)
811488e4:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
811488e8:	e13ff917 	ldw	r4,-28(fp)
811488ec:	21400317 	ldw	r5,12(r4)
811488f0:	e13ffc17 	ldw	r4,-16(fp)
811488f4:	2900061e 	bne	r5,r4,81148910 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
811488f8:	e13ff917 	ldw	r4,-28(fp)
811488fc:	21400b17 	ldw	r5,44(r4)
81148900:	e13ffd17 	ldw	r4,-12(fp)
81148904:	2900021e 	bne	r5,r4,81148910 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
81148908:	00bffa84 	movi	r2,-22
8114890c:	00002306 	br	8114899c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
81148910:	e13ff917 	ldw	r4,-28(fp)
81148914:	21000317 	ldw	r4,12(r4)
81148918:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
8114891c:	e13ff917 	ldw	r4,-28(fp)
81148920:	21000b17 	ldw	r4,44(r4)
81148924:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
81148928:	e13ffc17 	ldw	r4,-16(fp)
8114892c:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
81148930:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81148934:	e13ff917 	ldw	r4,-28(fp)
81148938:	21400317 	ldw	r5,12(r4)
8114893c:	e13ffa17 	ldw	r4,-24(fp)
81148940:	29000426 	beq	r5,r4,81148954 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
81148944:	e13ff917 	ldw	r4,-28(fp)
81148948:	21400b17 	ldw	r5,44(r4)
8114894c:	e13ffb17 	ldw	r4,-20(fp)
81148950:	293fe01e 	bne	r5,r4,811488d4 <__reset+0xfb1288d4>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
81148954:	e13fff17 	ldw	r4,-4(fp)
81148958:	2005883a 	mov	r2,r4
8114895c:	0007883a 	mov	r3,zero
81148960:	e0bffc15 	stw	r2,-16(fp)
81148964:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
81148968:	e0fffc17 	ldw	r3,-16(fp)
8114896c:	e0bff917 	ldw	r2,-28(fp)
81148970:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
81148974:	e0fffd17 	ldw	r3,-12(fp)
81148978:	e0bff917 	ldw	r2,-28(fp)
8114897c:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
81148980:	e0fffa17 	ldw	r3,-24(fp)
81148984:	e0bfff17 	ldw	r2,-4(fp)
81148988:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
8114898c:	e0fffb17 	ldw	r3,-20(fp)
81148990:	e0bfff17 	ldw	r2,-4(fp)
81148994:	10c00b15 	stw	r3,44(r2)
	return 0;
81148998:	0005883a 	mov	r2,zero
}
8114899c:	e037883a 	mov	sp,fp
811489a0:	df000017 	ldw	fp,0(sp)
811489a4:	dec00104 	addi	sp,sp,4
811489a8:	f800283a 	ret

811489ac <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
811489ac:	defffc04 	addi	sp,sp,-16
811489b0:	de00012e 	bgeu	sp,et,811489b8 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
811489b4:	003b68fa 	trap	3
811489b8:	df000315 	stw	fp,12(sp)
811489bc:	df000304 	addi	fp,sp,12
811489c0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
811489c4:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
811489c8:	e0bfff17 	ldw	r2,-4(fp)
811489cc:	1000021e 	bne	r2,zero,811489d8 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
811489d0:	00bffa84 	movi	r2,-22
811489d4:	00001906 	br	81148a3c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
811489d8:	e0bfff17 	ldw	r2,-4(fp)
811489dc:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
811489e0:	00000a06 	br	81148a0c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
811489e4:	e0bffd17 	ldw	r2,-12(fp)
811489e8:	10800717 	ldw	r2,28(r2)
811489ec:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
811489f0:	e0bffe17 	ldw	r2,-8(fp)
811489f4:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
811489f8:	e0bffd17 	ldw	r2,-12(fp)
811489fc:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
81148a00:	e0bffd17 	ldw	r2,-12(fp)
81148a04:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
81148a08:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
81148a0c:	e0bffd17 	ldw	r2,-12(fp)
81148a10:	10c00317 	ldw	r3,12(r2)
81148a14:	e0bfff17 	ldw	r2,-4(fp)
81148a18:	18bff21e 	bne	r3,r2,811489e4 <__reset+0xfb1289e4>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
81148a1c:	e0bffd17 	ldw	r2,-12(fp)
81148a20:	10800717 	ldw	r2,28(r2)
81148a24:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81148a28:	e0bffe17 	ldw	r2,-8(fp)
81148a2c:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
81148a30:	e0bffd17 	ldw	r2,-12(fp)
81148a34:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
81148a38:	0005883a 	mov	r2,zero
}
81148a3c:	e037883a 	mov	sp,fp
81148a40:	df000017 	ldw	fp,0(sp)
81148a44:	dec00104 	addi	sp,sp,4
81148a48:	f800283a 	ret

81148a4c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
81148a4c:	defff804 	addi	sp,sp,-32
81148a50:	de00012e 	bgeu	sp,et,81148a58 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
81148a54:	003b68fa 	trap	3
81148a58:	df000715 	stw	fp,28(sp)
81148a5c:	df000704 	addi	fp,sp,28
81148a60:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
81148a64:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
81148a68:	e13fff17 	ldw	r4,-4(fp)
81148a6c:	2000021e 	bne	r4,zero,81148a78 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
81148a70:	00bffa84 	movi	r2,-22
81148a74:	00002806 	br	81148b18 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
81148a78:	e13fff17 	ldw	r4,-4(fp)
81148a7c:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
81148a80:	e13fff17 	ldw	r4,-4(fp)
81148a84:	2005883a 	mov	r2,r4
81148a88:	0007883a 	mov	r3,zero
81148a8c:	e0bffb15 	stw	r2,-20(fp)
81148a90:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81148a94:	00001006 	br	81148ad8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
81148a98:	e0bff917 	ldw	r2,-28(fp)
81148a9c:	10800f17 	ldw	r2,60(r2)
81148aa0:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81148aa4:	e0bffa17 	ldw	r2,-24(fp)
81148aa8:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
81148aac:	e0bff917 	ldw	r2,-28(fp)
81148ab0:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
81148ab4:	e0bff917 	ldw	r2,-28(fp)
81148ab8:	10800317 	ldw	r2,12(r2)
81148abc:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
81148ac0:	e0bff917 	ldw	r2,-28(fp)
81148ac4:	10800b17 	ldw	r2,44(r2)
81148ac8:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
81148acc:	e0bffd17 	ldw	r2,-12(fp)
81148ad0:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
81148ad4:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81148ad8:	e0bff917 	ldw	r2,-28(fp)
81148adc:	10c00317 	ldw	r3,12(r2)
81148ae0:	e0bffb17 	ldw	r2,-20(fp)
81148ae4:	18800426 	beq	r3,r2,81148af8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
81148ae8:	e0bff917 	ldw	r2,-28(fp)
81148aec:	10c00b17 	ldw	r3,44(r2)
81148af0:	e0bffc17 	ldw	r2,-16(fp)
81148af4:	18bfe81e 	bne	r3,r2,81148a98 <__reset+0xfb128a98>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
81148af8:	e0bff917 	ldw	r2,-28(fp)
81148afc:	10800f17 	ldw	r2,60(r2)
81148b00:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81148b04:	e0bffa17 	ldw	r2,-24(fp)
81148b08:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
81148b0c:	e0bff917 	ldw	r2,-28(fp)
81148b10:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
81148b14:	0005883a 	mov	r2,zero
}
81148b18:	e037883a 	mov	sp,fp
81148b1c:	df000017 	ldw	fp,0(sp)
81148b20:	dec00104 	addi	sp,sp,4
81148b24:	f800283a 	ret

81148b28 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
81148b28:	deffeb04 	addi	sp,sp,-84
81148b2c:	de00012e 	bgeu	sp,et,81148b34 <alt_msgdma_start_prefetcher_with_list_addr+0xc>
81148b30:	003b68fa 	trap	3
81148b34:	dfc01415 	stw	ra,80(sp)
81148b38:	df001315 	stw	fp,76(sp)
81148b3c:	df001304 	addi	fp,sp,76
81148b40:	e13ffb15 	stw	r4,-20(fp)
81148b44:	e17ffc15 	stw	r5,-16(fp)
81148b48:	e1bffd15 	stw	r6,-12(fp)
81148b4c:	3807883a 	mov	r3,r7
81148b50:	e0800217 	ldw	r2,8(fp)
81148b54:	e0fffe05 	stb	r3,-8(fp)
81148b58:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
81148b5c:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
81148b60:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
81148b64:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
81148b68:	e0bffc17 	ldw	r2,-16(fp)
81148b6c:	e0bff815 	stw	r2,-32(fp)
81148b70:	e0bffd17 	ldw	r2,-12(fp)
81148b74:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
81148b78:	e0bffb17 	ldw	r2,-20(fp)
81148b7c:	10801817 	ldw	r2,96(r2)
81148b80:	e0bff615 	stw	r2,-40(fp)
81148b84:	e03ff70d 	sth	zero,-36(fp)
81148b88:	e0bff70b 	ldhu	r2,-36(fp)
81148b8c:	e0fffa04 	addi	r3,fp,-24
81148b90:	180d883a 	mov	r6,r3
81148b94:	100b883a 	mov	r5,r2
81148b98:	e13ff617 	ldw	r4,-40(fp)
81148b9c:	113dcd40 	call	8113dcd4 <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
81148ba0:	e0bffb17 	ldw	r2,-20(fp)
81148ba4:	10800617 	ldw	r2,24(r2)
81148ba8:	10800037 	ldwio	r2,0(r2)
81148bac:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
81148bb0:	e0bfed17 	ldw	r2,-76(fp)
81148bb4:	1080004c 	andi	r2,r2,1
81148bb8:	10000626 	beq	r2,zero,81148bd4 <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
81148bbc:	e0bffb17 	ldw	r2,-20(fp)
81148bc0:	10801817 	ldw	r2,96(r2)
81148bc4:	1009883a 	mov	r4,r2
81148bc8:	113e05c0 	call	8113e05c <OSSemPost>
		return -EBUSY;
81148bcc:	00bffc04 	movi	r2,-16
81148bd0:	00009606 	br	81148e2c <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81148bd4:	00800804 	movi	r2,32
81148bd8:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148bdc:	0005303a 	rdctl	r2,status
81148be0:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148be4:	e0fff217 	ldw	r3,-56(fp)
81148be8:	00bfff84 	movi	r2,-2
81148bec:	1884703a 	and	r2,r3,r2
81148bf0:	1001703a 	wrctl	status,r2
  
  return context;
81148bf4:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81148bf8:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81148bfc:	e0bffb17 	ldw	r2,-20(fp)
81148c00:	10800317 	ldw	r2,12(r2)
81148c04:	10800104 	addi	r2,r2,4
81148c08:	e0ffee17 	ldw	r3,-72(fp)
81148c0c:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
81148c10:	e0bffb17 	ldw	r2,-20(fp)
81148c14:	10800317 	ldw	r2,12(r2)
81148c18:	e0fffb17 	ldw	r3,-20(fp)
81148c1c:	18c00317 	ldw	r3,12(r3)
81148c20:	18c00037 	ldwio	r3,0(r3)
81148c24:	10c00035 	stwio	r3,0(r2)
81148c28:	e0bfef17 	ldw	r2,-68(fp)
81148c2c:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148c30:	e0bff017 	ldw	r2,-64(fp)
81148c34:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
81148c38:	e0bffb17 	ldw	r2,-20(fp)
81148c3c:	10800b17 	ldw	r2,44(r2)
81148c40:	10002326 	beq	r2,zero,81148cd0 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
81148c44:	e0bffb17 	ldw	r2,-20(fp)
81148c48:	10c00d17 	ldw	r3,52(r2)
81148c4c:	e0bfee17 	ldw	r2,-72(fp)
81148c50:	1884b03a 	or	r2,r3,r2
81148c54:	10800514 	ori	r2,r2,20
81148c58:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81148c5c:	e0ffee17 	ldw	r3,-72(fp)
81148c60:	00bff7c4 	movi	r2,-33
81148c64:	1884703a 	and	r2,r3,r2
81148c68:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81148c6c:	e0bfed17 	ldw	r2,-76(fp)
81148c70:	10800214 	ori	r2,r2,8
81148c74:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148c78:	0005303a 	rdctl	r2,status
81148c7c:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148c80:	e0fff417 	ldw	r3,-48(fp)
81148c84:	00bfff84 	movi	r2,-2
81148c88:	1884703a 	and	r2,r3,r2
81148c8c:	1001703a 	wrctl	status,r2
  
  return context;
81148c90:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
81148c94:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81148c98:	e0bffb17 	ldw	r2,-20(fp)
81148c9c:	10800317 	ldw	r2,12(r2)
81148ca0:	10800104 	addi	r2,r2,4
81148ca4:	e0ffee17 	ldw	r3,-72(fp)
81148ca8:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81148cac:	e0bffb17 	ldw	r2,-20(fp)
81148cb0:	10800617 	ldw	r2,24(r2)
81148cb4:	e0ffed17 	ldw	r3,-76(fp)
81148cb8:	10c00035 	stwio	r3,0(r2)
81148cbc:	e0bfef17 	ldw	r2,-68(fp)
81148cc0:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148cc4:	e0bff117 	ldw	r2,-60(fp)
81148cc8:	1001703a 	wrctl	status,r2
81148ccc:	00002306 	br	81148d5c <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
81148cd0:	e0bffb17 	ldw	r2,-20(fp)
81148cd4:	10c00d17 	ldw	r3,52(r2)
81148cd8:	e0bfee17 	ldw	r2,-72(fp)
81148cdc:	1884b03a 	or	r2,r3,r2
81148ce0:	10800114 	ori	r2,r2,4
81148ce4:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
81148ce8:	e0ffee17 	ldw	r3,-72(fp)
81148cec:	00bff3c4 	movi	r2,-49
81148cf0:	1884703a 	and	r2,r3,r2
81148cf4:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
81148cf8:	e0ffed17 	ldw	r3,-76(fp)
81148cfc:	00bffdc4 	movi	r2,-9
81148d00:	1884703a 	and	r2,r3,r2
81148d04:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148d08:	0005303a 	rdctl	r2,status
81148d0c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148d10:	e0fff517 	ldw	r3,-44(fp)
81148d14:	00bfff84 	movi	r2,-2
81148d18:	1884703a 	and	r2,r3,r2
81148d1c:	1001703a 	wrctl	status,r2
  
  return context;
81148d20:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
81148d24:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81148d28:	e0bffb17 	ldw	r2,-20(fp)
81148d2c:	10800317 	ldw	r2,12(r2)
81148d30:	10800104 	addi	r2,r2,4
81148d34:	e0ffee17 	ldw	r3,-72(fp)
81148d38:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81148d3c:	e0bffb17 	ldw	r2,-20(fp)
81148d40:	10800617 	ldw	r2,24(r2)
81148d44:	e0ffed17 	ldw	r3,-76(fp)
81148d48:	10c00035 	stwio	r3,0(r2)
81148d4c:	e0bfef17 	ldw	r2,-68(fp)
81148d50:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148d54:	e0bff317 	ldw	r2,-52(fp)
81148d58:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
81148d5c:	e0bffb17 	ldw	r2,-20(fp)
81148d60:	10800617 	ldw	r2,24(r2)
81148d64:	10800104 	addi	r2,r2,4
81148d68:	e0fff817 	ldw	r3,-32(fp)
81148d6c:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
81148d70:	e0bffb17 	ldw	r2,-20(fp)
81148d74:	10800617 	ldw	r2,24(r2)
81148d78:	10800204 	addi	r2,r2,8
81148d7c:	e0fff917 	ldw	r3,-28(fp)
81148d80:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
81148d84:	e0bffe03 	ldbu	r2,-8(fp)
81148d88:	10000426 	beq	r2,zero,81148d9c <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
81148d8c:	e0bfed17 	ldw	r2,-76(fp)
81148d90:	10800414 	ori	r2,r2,16
81148d94:	e0bfed15 	stw	r2,-76(fp)
81148d98:	00000406 	br	81148dac <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
81148d9c:	e0ffed17 	ldw	r3,-76(fp)
81148da0:	00bffbc4 	movi	r2,-17
81148da4:	1884703a 	and	r2,r3,r2
81148da8:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
81148dac:	e0bfff03 	ldbu	r2,-4(fp)
81148db0:	10000e26 	beq	r2,zero,81148dec <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
81148db4:	e0bfed17 	ldw	r2,-76(fp)
81148db8:	10800094 	ori	r2,r2,2
81148dbc:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
81148dc0:	e0bffb17 	ldw	r2,-20(fp)
81148dc4:	10800617 	ldw	r2,24(r2)
81148dc8:	10800304 	addi	r2,r2,12
81148dcc:	10800037 	ldwio	r2,0(r2)
81148dd0:	10000a1e 	bne	r2,zero,81148dfc <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
81148dd4:	e0bffb17 	ldw	r2,-20(fp)
81148dd8:	10800617 	ldw	r2,24(r2)
81148ddc:	10800304 	addi	r2,r2,12
81148de0:	00c03fc4 	movi	r3,255
81148de4:	10c00035 	stwio	r3,0(r2)
81148de8:	00000406 	br	81148dfc <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
81148dec:	e0ffed17 	ldw	r3,-76(fp)
81148df0:	00bfff44 	movi	r2,-3
81148df4:	1884703a 	and	r2,r3,r2
81148df8:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
81148dfc:	e0bfed17 	ldw	r2,-76(fp)
81148e00:	10800054 	ori	r2,r2,1
81148e04:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81148e08:	e0bffb17 	ldw	r2,-20(fp)
81148e0c:	10800617 	ldw	r2,24(r2)
81148e10:	e0ffed17 	ldw	r3,-76(fp)
81148e14:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
81148e18:	e0bffb17 	ldw	r2,-20(fp)
81148e1c:	10801817 	ldw	r2,96(r2)
81148e20:	1009883a 	mov	r4,r2
81148e24:	113e05c0 	call	8113e05c <OSSemPost>
	 
	 return 0;
81148e28:	0005883a 	mov	r2,zero
}
81148e2c:	e037883a 	mov	sp,fp
81148e30:	dfc00117 	ldw	ra,4(sp)
81148e34:	df000017 	ldw	fp,0(sp)
81148e38:	dec00204 	addi	sp,sp,8
81148e3c:	f800283a 	ret

81148e40 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
81148e40:	defff704 	addi	sp,sp,-36
81148e44:	de00012e 	bgeu	sp,et,81148e4c <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
81148e48:	003b68fa 	trap	3
81148e4c:	dfc00815 	stw	ra,32(sp)
81148e50:	df000715 	stw	fp,28(sp)
81148e54:	dc400615 	stw	r17,24(sp)
81148e58:	dc000515 	stw	r16,20(sp)
81148e5c:	df000704 	addi	fp,sp,28
81148e60:	e13ffa15 	stw	r4,-24(fp)
81148e64:	e17ffb15 	stw	r5,-20(fp)
81148e68:	3007883a 	mov	r3,r6
81148e6c:	3805883a 	mov	r2,r7
81148e70:	e0fffc05 	stb	r3,-16(fp)
81148e74:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
81148e78:	e13ffb17 	ldw	r4,-20(fp)
81148e7c:	11489ac0 	call	811489ac <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
81148e80:	10000226 	beq	r2,zero,81148e8c <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
81148e84:	00bffa84 	movi	r2,-22
81148e88:	00000b06 	br	81148eb8 <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
81148e8c:	e0bffb17 	ldw	r2,-20(fp)
81148e90:	1021883a 	mov	r16,r2
81148e94:	0023883a 	mov	r17,zero
81148e98:	e0fffc03 	ldbu	r3,-16(fp)
81148e9c:	e0bffd03 	ldbu	r2,-12(fp)
81148ea0:	d8800015 	stw	r2,0(sp)
81148ea4:	180f883a 	mov	r7,r3
81148ea8:	800b883a 	mov	r5,r16
81148eac:	880d883a 	mov	r6,r17
81148eb0:	e13ffa17 	ldw	r4,-24(fp)
81148eb4:	1148b280 	call	81148b28 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81148eb8:	e6fffe04 	addi	sp,fp,-8
81148ebc:	dfc00317 	ldw	ra,12(sp)
81148ec0:	df000217 	ldw	fp,8(sp)
81148ec4:	dc400117 	ldw	r17,4(sp)
81148ec8:	dc000017 	ldw	r16,0(sp)
81148ecc:	dec00404 	addi	sp,sp,16
81148ed0:	f800283a 	ret

81148ed4 <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
81148ed4:	defff704 	addi	sp,sp,-36
81148ed8:	de00012e 	bgeu	sp,et,81148ee0 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
81148edc:	003b68fa 	trap	3
81148ee0:	dfc00815 	stw	ra,32(sp)
81148ee4:	df000715 	stw	fp,28(sp)
81148ee8:	dc400615 	stw	r17,24(sp)
81148eec:	dc000515 	stw	r16,20(sp)
81148ef0:	df000704 	addi	fp,sp,28
81148ef4:	e13ffa15 	stw	r4,-24(fp)
81148ef8:	e17ffb15 	stw	r5,-20(fp)
81148efc:	3007883a 	mov	r3,r6
81148f00:	3805883a 	mov	r2,r7
81148f04:	e0fffc05 	stb	r3,-16(fp)
81148f08:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
81148f0c:	e13ffb17 	ldw	r4,-20(fp)
81148f10:	1148a4c0 	call	81148a4c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
81148f14:	10000226 	beq	r2,zero,81148f20 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
81148f18:	00bffa84 	movi	r2,-22
81148f1c:	00000b06 	br	81148f4c <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
81148f20:	e0bffb17 	ldw	r2,-20(fp)
81148f24:	1021883a 	mov	r16,r2
81148f28:	0023883a 	mov	r17,zero
81148f2c:	e0fffc03 	ldbu	r3,-16(fp)
81148f30:	e0bffd03 	ldbu	r2,-12(fp)
81148f34:	d8800015 	stw	r2,0(sp)
81148f38:	180f883a 	mov	r7,r3
81148f3c:	800b883a 	mov	r5,r16
81148f40:	880d883a 	mov	r6,r17
81148f44:	e13ffa17 	ldw	r4,-24(fp)
81148f48:	1148b280 	call	81148b28 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81148f4c:	e6fffe04 	addi	sp,fp,-8
81148f50:	dfc00317 	ldw	ra,12(sp)
81148f54:	df000217 	ldw	fp,8(sp)
81148f58:	dc400117 	ldw	r17,4(sp)
81148f5c:	dc000017 	ldw	r16,0(sp)
81148f60:	dec00404 	addi	sp,sp,16
81148f64:	f800283a 	ret

81148f68 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
81148f68:	defffc04 	addi	sp,sp,-16
81148f6c:	de00012e 	bgeu	sp,et,81148f74 <alt_msgdma_open+0xc>
81148f70:	003b68fa 	trap	3
81148f74:	dfc00315 	stw	ra,12(sp)
81148f78:	df000215 	stw	fp,8(sp)
81148f7c:	df000204 	addi	fp,sp,8
81148f80:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
81148f84:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
81148f88:	d1603504 	addi	r5,gp,-32556
81148f8c:	e13fff17 	ldw	r4,-4(fp)
81148f90:	114950c0 	call	8114950c <alt_find_dev>
81148f94:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
81148f98:	e0bffe17 	ldw	r2,-8(fp)
81148f9c:	1000041e 	bne	r2,zero,81148fb0 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
81148fa0:	11471cc0 	call	811471cc <alt_get_errno>
81148fa4:	1007883a 	mov	r3,r2
81148fa8:	008004c4 	movi	r2,19
81148fac:	18800015 	stw	r2,0(r3)
    }

    return dev;
81148fb0:	e0bffe17 	ldw	r2,-8(fp)
}
81148fb4:	e037883a 	mov	sp,fp
81148fb8:	dfc00117 	ldw	ra,4(sp)
81148fbc:	df000017 	ldw	fp,0(sp)
81148fc0:	dec00204 	addi	sp,sp,8
81148fc4:	f800283a 	ret

81148fc8 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
81148fc8:	defff604 	addi	sp,sp,-40
81148fcc:	de00012e 	bgeu	sp,et,81148fd4 <alt_msgdma_init+0xc>
81148fd0:	003b68fa 	trap	3
81148fd4:	dfc00915 	stw	ra,36(sp)
81148fd8:	df000815 	stw	fp,32(sp)
81148fdc:	df000804 	addi	fp,sp,32
81148fe0:	e13ffd15 	stw	r4,-12(fp)
81148fe4:	e17ffe15 	stw	r5,-8(fp)
81148fe8:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
81148fec:	e0bffd17 	ldw	r2,-12(fp)
81148ff0:	10801783 	ldbu	r2,94(r2)
81148ff4:	10803fcc 	andi	r2,r2,255
81148ff8:	10000b26 	beq	r2,zero,81149028 <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
81148ffc:	e0bffd17 	ldw	r2,-12(fp)
81149000:	10800617 	ldw	r2,24(r2)
81149004:	00c00104 	movi	r3,4
81149008:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
8114900c:	0001883a 	nop
81149010:	e0bffd17 	ldw	r2,-12(fp)
81149014:	10800617 	ldw	r2,24(r2)
81149018:	10800037 	ldwio	r2,0(r2)
8114901c:	1080010c 	andi	r2,r2,4
81149020:	1005d0ba 	srai	r2,r2,2
81149024:	103ffa1e 	bne	r2,zero,81149010 <__reset+0xfb129010>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81149028:	e0bffd17 	ldw	r2,-12(fp)
8114902c:	10800317 	ldw	r2,12(r2)
81149030:	10800104 	addi	r2,r2,4
81149034:	00c00084 	movi	r3,2
81149038:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
8114903c:	0001883a 	nop
81149040:	e0bffd17 	ldw	r2,-12(fp)
81149044:	10800317 	ldw	r2,12(r2)
81149048:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
8114904c:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81149050:	103ffb1e 	bne	r2,zero,81149040 <__reset+0xfb129040>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81149054:	e0bffd17 	ldw	r2,-12(fp)
81149058:	10800317 	ldw	r2,12(r2)
8114905c:	10800104 	addi	r2,r2,4
81149060:	10800037 	ldwio	r2,0(r2)
81149064:	1007883a 	mov	r3,r2
81149068:	00bffbc4 	movi	r2,-17
8114906c:	1884703a 	and	r2,r3,r2
81149070:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81149074:	e0bff917 	ldw	r2,-28(fp)
81149078:	10800814 	ori	r2,r2,32
8114907c:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81149080:	e0bffd17 	ldw	r2,-12(fp)
81149084:	10800317 	ldw	r2,12(r2)
81149088:	10800104 	addi	r2,r2,4
8114908c:	e0fff917 	ldw	r3,-28(fp)
81149090:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
81149094:	e0bffd17 	ldw	r2,-12(fp)
81149098:	10800317 	ldw	r2,12(r2)
8114909c:	e0fffd17 	ldw	r3,-12(fp)
811490a0:	18c00317 	ldw	r3,12(r3)
811490a4:	18c00037 	ldwio	r3,0(r3)
811490a8:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
811490ac:	e0bffd17 	ldw	r2,-12(fp)
811490b0:	10801783 	ldbu	r2,94(r2)
811490b4:	10803fcc 	andi	r2,r2,255
811490b8:	10000826 	beq	r2,zero,811490dc <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
811490bc:	e0bffd17 	ldw	r2,-12(fp)
811490c0:	10800617 	ldw	r2,24(r2)
811490c4:	10800404 	addi	r2,r2,16
811490c8:	e0fffd17 	ldw	r3,-12(fp)
811490cc:	18c00617 	ldw	r3,24(r3)
811490d0:	18c00404 	addi	r3,r3,16
811490d4:	18c00037 	ldwio	r3,0(r3)
811490d8:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
811490dc:	d1603504 	addi	r5,gp,-32556
811490e0:	e13ffd17 	ldw	r4,-12(fp)
811490e4:	11494600 	call	81149460 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
811490e8:	e0bffd17 	ldw	r2,-12(fp)
811490ec:	10801804 	addi	r2,r2,96
811490f0:	e0bffb15 	stw	r2,-20(fp)
811490f4:	00800044 	movi	r2,1
811490f8:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811490fc:	e0bffc0b 	ldhu	r2,-16(fp)
81149100:	1009883a 	mov	r4,r2
81149104:	113d9ac0 	call	8113d9ac <OSSemCreate>
81149108:	1007883a 	mov	r3,r2
8114910c:	e0bffb17 	ldw	r2,-20(fp)
81149110:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81149114:	e0bffb17 	ldw	r2,-20(fp)
81149118:	10800017 	ldw	r2,0(r2)
8114911c:	10000226 	beq	r2,zero,81149128 <alt_msgdma_init+0x160>
81149120:	0005883a 	mov	r2,zero
81149124:	00000106 	br	8114912c <alt_msgdma_init+0x164>
81149128:	00bfffc4 	movi	r2,-1
8114912c:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
81149130:	e0bffa17 	ldw	r2,-24(fp)
81149134:	1000081e 	bne	r2,zero,81149158 <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
81149138:	d8000015 	stw	zero,0(sp)
8114913c:	e1fffd17 	ldw	r7,-12(fp)
81149140:	01a04534 	movhi	r6,33044
81149144:	319cf804 	addi	r6,r6,29664
81149148:	e17fff17 	ldw	r5,-4(fp)
8114914c:	e13ffe17 	ldw	r4,-8(fp)
81149150:	11497980 	call	81149798 <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
81149154:	00000406 	br	81149168 <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
81149158:	01204574 	movhi	r4,33045
8114915c:	2100e204 	addi	r4,r4,904
81149160:	1149bb00 	call	81149bb0 <alt_printf>
    }
    
    return;
81149164:	0001883a 	nop

}
81149168:	e037883a 	mov	sp,fp
8114916c:	dfc00117 	ldw	ra,4(sp)
81149170:	df000017 	ldw	fp,0(sp)
81149174:	dec00204 	addi	sp,sp,8
81149178:	f800283a 	ret

8114917c <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
8114917c:	defffb04 	addi	sp,sp,-20
81149180:	de00012e 	bgeu	sp,et,81149188 <alt_msgdma_register_callback+0xc>
81149184:	003b68fa 	trap	3
81149188:	df000415 	stw	fp,16(sp)
8114918c:	df000404 	addi	fp,sp,16
81149190:	e13ffc15 	stw	r4,-16(fp)
81149194:	e17ffd15 	stw	r5,-12(fp)
81149198:	e1bffe15 	stw	r6,-8(fp)
8114919c:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
811491a0:	e0bffc17 	ldw	r2,-16(fp)
811491a4:	e0fffd17 	ldw	r3,-12(fp)
811491a8:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
811491ac:	e0bffc17 	ldw	r2,-16(fp)
811491b0:	e0ffff17 	ldw	r3,-4(fp)
811491b4:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
811491b8:	e0bffc17 	ldw	r2,-16(fp)
811491bc:	e0fffe17 	ldw	r3,-8(fp)
811491c0:	10c00d15 	stw	r3,52(r2)

    return ;
811491c4:	0001883a 	nop
}
811491c8:	e037883a 	mov	sp,fp
811491cc:	df000017 	ldw	fp,0(sp)
811491d0:	dec00104 	addi	sp,sp,4
811491d4:	f800283a 	ret

811491d8 <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
811491d8:	defffc04 	addi	sp,sp,-16
811491dc:	de00012e 	bgeu	sp,et,811491e4 <alt_msgdma_standard_descriptor_async_transfer+0xc>
811491e0:	003b68fa 	trap	3
811491e4:	dfc00315 	stw	ra,12(sp)
811491e8:	df000215 	stw	fp,8(sp)
811491ec:	df000204 	addi	fp,sp,8
811491f0:	e13ffe15 	stw	r4,-8(fp)
811491f4:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
811491f8:	000d883a 	mov	r6,zero
811491fc:	e17fff17 	ldw	r5,-4(fp)
81149200:	e13ffe17 	ldw	r4,-8(fp)
81149204:	114775c0 	call	8114775c <alt_msgdma_descriptor_async_transfer>

}
81149208:	e037883a 	mov	sp,fp
8114920c:	dfc00117 	ldw	ra,4(sp)
81149210:	df000017 	ldw	fp,0(sp)
81149214:	dec00204 	addi	sp,sp,8
81149218:	f800283a 	ret

8114921c <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
8114921c:	defffc04 	addi	sp,sp,-16
81149220:	de00012e 	bgeu	sp,et,81149228 <alt_msgdma_extended_descriptor_async_transfer+0xc>
81149224:	003b68fa 	trap	3
81149228:	dfc00315 	stw	ra,12(sp)
8114922c:	df000215 	stw	fp,8(sp)
81149230:	df000204 	addi	fp,sp,8
81149234:	e13ffe15 	stw	r4,-8(fp)
81149238:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
8114923c:	e1bfff17 	ldw	r6,-4(fp)
81149240:	000b883a 	mov	r5,zero
81149244:	e13ffe17 	ldw	r4,-8(fp)
81149248:	114775c0 	call	8114775c <alt_msgdma_descriptor_async_transfer>
}
8114924c:	e037883a 	mov	sp,fp
81149250:	dfc00117 	ldw	ra,4(sp)
81149254:	df000017 	ldw	fp,0(sp)
81149258:	dec00204 	addi	sp,sp,8
8114925c:	f800283a 	ret

81149260 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
81149260:	defffc04 	addi	sp,sp,-16
81149264:	de00012e 	bgeu	sp,et,8114926c <alt_msgdma_standard_descriptor_sync_transfer+0xc>
81149268:	003b68fa 	trap	3
8114926c:	dfc00315 	stw	ra,12(sp)
81149270:	df000215 	stw	fp,8(sp)
81149274:	df000204 	addi	fp,sp,8
81149278:	e13ffe15 	stw	r4,-8(fp)
8114927c:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
81149280:	000d883a 	mov	r6,zero
81149284:	e17fff17 	ldw	r5,-4(fp)
81149288:	e13ffe17 	ldw	r4,-8(fp)
8114928c:	1147a9c0 	call	81147a9c <alt_msgdma_descriptor_sync_transfer>
}
81149290:	e037883a 	mov	sp,fp
81149294:	dfc00117 	ldw	ra,4(sp)
81149298:	df000017 	ldw	fp,0(sp)
8114929c:	dec00204 	addi	sp,sp,8
811492a0:	f800283a 	ret

811492a4 <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
811492a4:	defffc04 	addi	sp,sp,-16
811492a8:	de00012e 	bgeu	sp,et,811492b0 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
811492ac:	003b68fa 	trap	3
811492b0:	dfc00315 	stw	ra,12(sp)
811492b4:	df000215 	stw	fp,8(sp)
811492b8:	df000204 	addi	fp,sp,8
811492bc:	e13ffe15 	stw	r4,-8(fp)
811492c0:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
811492c4:	e1bfff17 	ldw	r6,-4(fp)
811492c8:	000b883a 	mov	r5,zero
811492cc:	e13ffe17 	ldw	r4,-8(fp)
811492d0:	1147a9c0 	call	81147a9c <alt_msgdma_descriptor_sync_transfer>
}
811492d4:	e037883a 	mov	sp,fp
811492d8:	dfc00117 	ldw	ra,4(sp)
811492dc:	df000017 	ldw	fp,0(sp)
811492e0:	dec00204 	addi	sp,sp,8
811492e4:	f800283a 	ret

811492e8 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
811492e8:	defff504 	addi	sp,sp,-44
811492ec:	de00012e 	bgeu	sp,et,811492f4 <alt_alarm_start+0xc>
811492f0:	003b68fa 	trap	3
811492f4:	df000a15 	stw	fp,40(sp)
811492f8:	df000a04 	addi	fp,sp,40
811492fc:	e13ffc15 	stw	r4,-16(fp)
81149300:	e17ffd15 	stw	r5,-12(fp)
81149304:	e1bffe15 	stw	r6,-8(fp)
81149308:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
8114930c:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81149310:	d0a08717 	ldw	r2,-32228(gp)
  
  if (alt_ticks_per_second ())
81149314:	10003c26 	beq	r2,zero,81149408 <alt_alarm_start+0x120>
  {
    if (alarm)
81149318:	e0bffc17 	ldw	r2,-16(fp)
8114931c:	10003826 	beq	r2,zero,81149400 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
81149320:	e0bffc17 	ldw	r2,-16(fp)
81149324:	e0fffe17 	ldw	r3,-8(fp)
81149328:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
8114932c:	e0bffc17 	ldw	r2,-16(fp)
81149330:	e0ffff17 	ldw	r3,-4(fp)
81149334:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149338:	0005303a 	rdctl	r2,status
8114933c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81149340:	e0fff917 	ldw	r3,-28(fp)
81149344:	00bfff84 	movi	r2,-2
81149348:	1884703a 	and	r2,r3,r2
8114934c:	1001703a 	wrctl	status,r2
  
  return context;
81149350:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
81149354:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81149358:	d0a08817 	ldw	r2,-32224(gp)
      
      current_nticks = alt_nticks();
8114935c:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
81149360:	e0fffd17 	ldw	r3,-12(fp)
81149364:	e0bff617 	ldw	r2,-40(fp)
81149368:	1885883a 	add	r2,r3,r2
8114936c:	10c00044 	addi	r3,r2,1
81149370:	e0bffc17 	ldw	r2,-16(fp)
81149374:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
81149378:	e0bffc17 	ldw	r2,-16(fp)
8114937c:	10c00217 	ldw	r3,8(r2)
81149380:	e0bff617 	ldw	r2,-40(fp)
81149384:	1880042e 	bgeu	r3,r2,81149398 <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
81149388:	e0bffc17 	ldw	r2,-16(fp)
8114938c:	00c00044 	movi	r3,1
81149390:	10c00405 	stb	r3,16(r2)
81149394:	00000206 	br	811493a0 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
81149398:	e0bffc17 	ldw	r2,-16(fp)
8114939c:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
811493a0:	e0bffc17 	ldw	r2,-16(fp)
811493a4:	d0e01404 	addi	r3,gp,-32688
811493a8:	e0fffa15 	stw	r3,-24(fp)
811493ac:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
811493b0:	e0bffb17 	ldw	r2,-20(fp)
811493b4:	e0fffa17 	ldw	r3,-24(fp)
811493b8:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
811493bc:	e0bffa17 	ldw	r2,-24(fp)
811493c0:	10c00017 	ldw	r3,0(r2)
811493c4:	e0bffb17 	ldw	r2,-20(fp)
811493c8:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
811493cc:	e0bffa17 	ldw	r2,-24(fp)
811493d0:	10800017 	ldw	r2,0(r2)
811493d4:	e0fffb17 	ldw	r3,-20(fp)
811493d8:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
811493dc:	e0bffa17 	ldw	r2,-24(fp)
811493e0:	e0fffb17 	ldw	r3,-20(fp)
811493e4:	10c00015 	stw	r3,0(r2)
811493e8:	e0bff817 	ldw	r2,-32(fp)
811493ec:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811493f0:	e0bff717 	ldw	r2,-36(fp)
811493f4:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
811493f8:	0005883a 	mov	r2,zero
811493fc:	00000306 	br	8114940c <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
81149400:	00bffa84 	movi	r2,-22
81149404:	00000106 	br	8114940c <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
81149408:	00bfde84 	movi	r2,-134
  }
}
8114940c:	e037883a 	mov	sp,fp
81149410:	df000017 	ldw	fp,0(sp)
81149414:	dec00104 	addi	sp,sp,4
81149418:	f800283a 	ret

8114941c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8114941c:	defffe04 	addi	sp,sp,-8
81149420:	de00012e 	bgeu	sp,et,81149428 <alt_get_errno+0xc>
81149424:	003b68fa 	trap	3
81149428:	dfc00115 	stw	ra,4(sp)
8114942c:	df000015 	stw	fp,0(sp)
81149430:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81149434:	d0a01017 	ldw	r2,-32704(gp)
81149438:	10000326 	beq	r2,zero,81149448 <alt_get_errno+0x2c>
8114943c:	d0a01017 	ldw	r2,-32704(gp)
81149440:	103ee83a 	callr	r2
81149444:	00000106 	br	8114944c <alt_get_errno+0x30>
81149448:	d0a07704 	addi	r2,gp,-32292
}
8114944c:	e037883a 	mov	sp,fp
81149450:	dfc00117 	ldw	ra,4(sp)
81149454:	df000017 	ldw	fp,0(sp)
81149458:	dec00204 	addi	sp,sp,8
8114945c:	f800283a 	ret

81149460 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
81149460:	defffa04 	addi	sp,sp,-24
81149464:	de00012e 	bgeu	sp,et,8114946c <alt_dev_llist_insert+0xc>
81149468:	003b68fa 	trap	3
8114946c:	dfc00515 	stw	ra,20(sp)
81149470:	df000415 	stw	fp,16(sp)
81149474:	df000404 	addi	fp,sp,16
81149478:	e13ffe15 	stw	r4,-8(fp)
8114947c:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
81149480:	e0bffe17 	ldw	r2,-8(fp)
81149484:	10000326 	beq	r2,zero,81149494 <alt_dev_llist_insert+0x34>
81149488:	e0bffe17 	ldw	r2,-8(fp)
8114948c:	10800217 	ldw	r2,8(r2)
81149490:	1000061e 	bne	r2,zero,811494ac <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
81149494:	114941c0 	call	8114941c <alt_get_errno>
81149498:	1007883a 	mov	r3,r2
8114949c:	00800584 	movi	r2,22
811494a0:	18800015 	stw	r2,0(r3)
    return -EINVAL;
811494a4:	00bffa84 	movi	r2,-22
811494a8:	00001306 	br	811494f8 <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
811494ac:	e0bffe17 	ldw	r2,-8(fp)
811494b0:	e0ffff17 	ldw	r3,-4(fp)
811494b4:	e0fffc15 	stw	r3,-16(fp)
811494b8:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
811494bc:	e0bffd17 	ldw	r2,-12(fp)
811494c0:	e0fffc17 	ldw	r3,-16(fp)
811494c4:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
811494c8:	e0bffc17 	ldw	r2,-16(fp)
811494cc:	10c00017 	ldw	r3,0(r2)
811494d0:	e0bffd17 	ldw	r2,-12(fp)
811494d4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
811494d8:	e0bffc17 	ldw	r2,-16(fp)
811494dc:	10800017 	ldw	r2,0(r2)
811494e0:	e0fffd17 	ldw	r3,-12(fp)
811494e4:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
811494e8:	e0bffc17 	ldw	r2,-16(fp)
811494ec:	e0fffd17 	ldw	r3,-12(fp)
811494f0:	10c00015 	stw	r3,0(r2)

  return 0;  
811494f4:	0005883a 	mov	r2,zero
}
811494f8:	e037883a 	mov	sp,fp
811494fc:	dfc00117 	ldw	ra,4(sp)
81149500:	df000017 	ldw	fp,0(sp)
81149504:	dec00204 	addi	sp,sp,8
81149508:	f800283a 	ret

8114950c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
8114950c:	defffa04 	addi	sp,sp,-24
81149510:	de00012e 	bgeu	sp,et,81149518 <alt_find_dev+0xc>
81149514:	003b68fa 	trap	3
81149518:	dfc00515 	stw	ra,20(sp)
8114951c:	df000415 	stw	fp,16(sp)
81149520:	df000404 	addi	fp,sp,16
81149524:	e13ffe15 	stw	r4,-8(fp)
81149528:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
8114952c:	e0bfff17 	ldw	r2,-4(fp)
81149530:	10800017 	ldw	r2,0(r2)
81149534:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
81149538:	e13ffe17 	ldw	r4,-8(fp)
8114953c:	112235c0 	call	8112235c <strlen>
81149540:	10800044 	addi	r2,r2,1
81149544:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
81149548:	00000d06 	br	81149580 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
8114954c:	e0bffc17 	ldw	r2,-16(fp)
81149550:	10800217 	ldw	r2,8(r2)
81149554:	e0fffd17 	ldw	r3,-12(fp)
81149558:	180d883a 	mov	r6,r3
8114955c:	e17ffe17 	ldw	r5,-8(fp)
81149560:	1009883a 	mov	r4,r2
81149564:	114a3200 	call	8114a320 <memcmp>
81149568:	1000021e 	bne	r2,zero,81149574 <alt_find_dev+0x68>
    {
      /* match found */

      return next;
8114956c:	e0bffc17 	ldw	r2,-16(fp)
81149570:	00000706 	br	81149590 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
81149574:	e0bffc17 	ldw	r2,-16(fp)
81149578:	10800017 	ldw	r2,0(r2)
8114957c:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
81149580:	e0fffc17 	ldw	r3,-16(fp)
81149584:	e0bfff17 	ldw	r2,-4(fp)
81149588:	18bff01e 	bne	r3,r2,8114954c <__reset+0xfb12954c>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
8114958c:	0005883a 	mov	r2,zero
}
81149590:	e037883a 	mov	sp,fp
81149594:	dfc00117 	ldw	ra,4(sp)
81149598:	df000017 	ldw	fp,0(sp)
8114959c:	dec00204 	addi	sp,sp,8
811495a0:	f800283a 	ret

811495a4 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
811495a4:	defffb04 	addi	sp,sp,-20
811495a8:	de00012e 	bgeu	sp,et,811495b0 <alt_find_file+0xc>
811495ac:	003b68fa 	trap	3
811495b0:	dfc00415 	stw	ra,16(sp)
811495b4:	df000315 	stw	fp,12(sp)
811495b8:	df000304 	addi	fp,sp,12
811495bc:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
811495c0:	d0a00b17 	ldw	r2,-32724(gp)
811495c4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
811495c8:	00003106 	br	81149690 <alt_find_file+0xec>
  {
    len = strlen(next->name);
811495cc:	e0bffd17 	ldw	r2,-12(fp)
811495d0:	10800217 	ldw	r2,8(r2)
811495d4:	1009883a 	mov	r4,r2
811495d8:	112235c0 	call	8112235c <strlen>
811495dc:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
811495e0:	e0bffd17 	ldw	r2,-12(fp)
811495e4:	10c00217 	ldw	r3,8(r2)
811495e8:	e0bffe17 	ldw	r2,-8(fp)
811495ec:	10bfffc4 	addi	r2,r2,-1
811495f0:	1885883a 	add	r2,r3,r2
811495f4:	10800003 	ldbu	r2,0(r2)
811495f8:	10803fcc 	andi	r2,r2,255
811495fc:	1080201c 	xori	r2,r2,128
81149600:	10bfe004 	addi	r2,r2,-128
81149604:	10800bd8 	cmpnei	r2,r2,47
81149608:	1000031e 	bne	r2,zero,81149618 <alt_find_file+0x74>
    {
      len -= 1;
8114960c:	e0bffe17 	ldw	r2,-8(fp)
81149610:	10bfffc4 	addi	r2,r2,-1
81149614:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
81149618:	e0bffe17 	ldw	r2,-8(fp)
8114961c:	e0ffff17 	ldw	r3,-4(fp)
81149620:	1885883a 	add	r2,r3,r2
81149624:	10800003 	ldbu	r2,0(r2)
81149628:	10803fcc 	andi	r2,r2,255
8114962c:	1080201c 	xori	r2,r2,128
81149630:	10bfe004 	addi	r2,r2,-128
81149634:	10800be0 	cmpeqi	r2,r2,47
81149638:	1000081e 	bne	r2,zero,8114965c <alt_find_file+0xb8>
8114963c:	e0bffe17 	ldw	r2,-8(fp)
81149640:	e0ffff17 	ldw	r3,-4(fp)
81149644:	1885883a 	add	r2,r3,r2
81149648:	10800003 	ldbu	r2,0(r2)
8114964c:	10803fcc 	andi	r2,r2,255
81149650:	1080201c 	xori	r2,r2,128
81149654:	10bfe004 	addi	r2,r2,-128
81149658:	10000a1e 	bne	r2,zero,81149684 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
8114965c:	e0bffd17 	ldw	r2,-12(fp)
81149660:	10800217 	ldw	r2,8(r2)
81149664:	e0fffe17 	ldw	r3,-8(fp)
81149668:	180d883a 	mov	r6,r3
8114966c:	e17fff17 	ldw	r5,-4(fp)
81149670:	1009883a 	mov	r4,r2
81149674:	114a3200 	call	8114a320 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
81149678:	1000021e 	bne	r2,zero,81149684 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
8114967c:	e0bffd17 	ldw	r2,-12(fp)
81149680:	00000706 	br	811496a0 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
81149684:	e0bffd17 	ldw	r2,-12(fp)
81149688:	10800017 	ldw	r2,0(r2)
8114968c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
81149690:	e0fffd17 	ldw	r3,-12(fp)
81149694:	d0a00b04 	addi	r2,gp,-32724
81149698:	18bfcc1e 	bne	r3,r2,811495cc <__reset+0xfb1295cc>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
8114969c:	0005883a 	mov	r2,zero
}
811496a0:	e037883a 	mov	sp,fp
811496a4:	dfc00117 	ldw	ra,4(sp)
811496a8:	df000017 	ldw	fp,0(sp)
811496ac:	dec00204 	addi	sp,sp,8
811496b0:	f800283a 	ret

811496b4 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
811496b4:	defff904 	addi	sp,sp,-28
811496b8:	de00012e 	bgeu	sp,et,811496c0 <alt_get_fd+0xc>
811496bc:	003b68fa 	trap	3
811496c0:	dfc00615 	stw	ra,24(sp)
811496c4:	df000515 	stw	fp,20(sp)
811496c8:	df000504 	addi	fp,sp,20
811496cc:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
811496d0:	00bffa04 	movi	r2,-24
811496d4:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
811496d8:	d0a07e17 	ldw	r2,-32264(gp)
811496dc:	e0bffd15 	stw	r2,-12(fp)
811496e0:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
811496e4:	e0bffe0b 	ldhu	r2,-8(fp)
811496e8:	e0fffe84 	addi	r3,fp,-6
811496ec:	180d883a 	mov	r6,r3
811496f0:	100b883a 	mov	r5,r2
811496f4:	e13ffd17 	ldw	r4,-12(fp)
811496f8:	113dcd40 	call	8113dcd4 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
811496fc:	e03ffb15 	stw	zero,-20(fp)
81149700:	00001906 	br	81149768 <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
81149704:	00a04574 	movhi	r2,33045
81149708:	10835104 	addi	r2,r2,3396
8114970c:	e0fffb17 	ldw	r3,-20(fp)
81149710:	18c00324 	muli	r3,r3,12
81149714:	10c5883a 	add	r2,r2,r3
81149718:	10800017 	ldw	r2,0(r2)
8114971c:	10000f1e 	bne	r2,zero,8114975c <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
81149720:	00a04574 	movhi	r2,33045
81149724:	10835104 	addi	r2,r2,3396
81149728:	e0fffb17 	ldw	r3,-20(fp)
8114972c:	18c00324 	muli	r3,r3,12
81149730:	10c5883a 	add	r2,r2,r3
81149734:	e0ffff17 	ldw	r3,-4(fp)
81149738:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
8114973c:	d0e00f17 	ldw	r3,-32708(gp)
81149740:	e0bffb17 	ldw	r2,-20(fp)
81149744:	1880020e 	bge	r3,r2,81149750 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
81149748:	e0bffb17 	ldw	r2,-20(fp)
8114974c:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
81149750:	e0bffb17 	ldw	r2,-20(fp)
81149754:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
81149758:	00000606 	br	81149774 <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8114975c:	e0bffb17 	ldw	r2,-20(fp)
81149760:	10800044 	addi	r2,r2,1
81149764:	e0bffb15 	stw	r2,-20(fp)
81149768:	e0bffb17 	ldw	r2,-20(fp)
8114976c:	10800810 	cmplti	r2,r2,32
81149770:	103fe41e 	bne	r2,zero,81149704 <__reset+0xfb129704>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
81149774:	d0a07e17 	ldw	r2,-32264(gp)
81149778:	1009883a 	mov	r4,r2
8114977c:	113e05c0 	call	8113e05c <OSSemPost>

  return rc;
81149780:	e0bffc17 	ldw	r2,-16(fp)
}
81149784:	e037883a 	mov	sp,fp
81149788:	dfc00117 	ldw	ra,4(sp)
8114978c:	df000017 	ldw	fp,0(sp)
81149790:	dec00204 	addi	sp,sp,8
81149794:	f800283a 	ret

81149798 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
81149798:	defff904 	addi	sp,sp,-28
8114979c:	de00012e 	bgeu	sp,et,811497a4 <alt_ic_isr_register+0xc>
811497a0:	003b68fa 	trap	3
811497a4:	dfc00615 	stw	ra,24(sp)
811497a8:	df000515 	stw	fp,20(sp)
811497ac:	df000504 	addi	fp,sp,20
811497b0:	e13ffc15 	stw	r4,-16(fp)
811497b4:	e17ffd15 	stw	r5,-12(fp)
811497b8:	e1bffe15 	stw	r6,-8(fp)
811497bc:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
811497c0:	e0800217 	ldw	r2,8(fp)
811497c4:	d8800015 	stw	r2,0(sp)
811497c8:	e1ffff17 	ldw	r7,-4(fp)
811497cc:	e1bffe17 	ldw	r6,-8(fp)
811497d0:	e17ffd17 	ldw	r5,-12(fp)
811497d4:	e13ffc17 	ldw	r4,-16(fp)
811497d8:	11499680 	call	81149968 <alt_iic_isr_register>
}  
811497dc:	e037883a 	mov	sp,fp
811497e0:	dfc00117 	ldw	ra,4(sp)
811497e4:	df000017 	ldw	fp,0(sp)
811497e8:	dec00204 	addi	sp,sp,8
811497ec:	f800283a 	ret

811497f0 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
811497f0:	defff904 	addi	sp,sp,-28
811497f4:	de00012e 	bgeu	sp,et,811497fc <alt_ic_irq_enable+0xc>
811497f8:	003b68fa 	trap	3
811497fc:	df000615 	stw	fp,24(sp)
81149800:	df000604 	addi	fp,sp,24
81149804:	e13ffe15 	stw	r4,-8(fp)
81149808:	e17fff15 	stw	r5,-4(fp)
8114980c:	e0bfff17 	ldw	r2,-4(fp)
81149810:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81149814:	0005303a 	rdctl	r2,status
81149818:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114981c:	e0fffb17 	ldw	r3,-20(fp)
81149820:	00bfff84 	movi	r2,-2
81149824:	1884703a 	and	r2,r3,r2
81149828:	1001703a 	wrctl	status,r2
  
  return context;
8114982c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81149830:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
81149834:	00c00044 	movi	r3,1
81149838:	e0bffa17 	ldw	r2,-24(fp)
8114983c:	1884983a 	sll	r2,r3,r2
81149840:	1007883a 	mov	r3,r2
81149844:	d0a07f17 	ldw	r2,-32260(gp)
81149848:	1884b03a 	or	r2,r3,r2
8114984c:	d0a07f15 	stw	r2,-32260(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81149850:	d0a07f17 	ldw	r2,-32260(gp)
81149854:	100170fa 	wrctl	ienable,r2
81149858:	e0bffc17 	ldw	r2,-16(fp)
8114985c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149860:	e0bffd17 	ldw	r2,-12(fp)
81149864:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81149868:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
8114986c:	0001883a 	nop
}
81149870:	e037883a 	mov	sp,fp
81149874:	df000017 	ldw	fp,0(sp)
81149878:	dec00104 	addi	sp,sp,4
8114987c:	f800283a 	ret

81149880 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
81149880:	defff904 	addi	sp,sp,-28
81149884:	de00012e 	bgeu	sp,et,8114988c <alt_ic_irq_disable+0xc>
81149888:	003b68fa 	trap	3
8114988c:	df000615 	stw	fp,24(sp)
81149890:	df000604 	addi	fp,sp,24
81149894:	e13ffe15 	stw	r4,-8(fp)
81149898:	e17fff15 	stw	r5,-4(fp)
8114989c:	e0bfff17 	ldw	r2,-4(fp)
811498a0:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811498a4:	0005303a 	rdctl	r2,status
811498a8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811498ac:	e0fffb17 	ldw	r3,-20(fp)
811498b0:	00bfff84 	movi	r2,-2
811498b4:	1884703a 	and	r2,r3,r2
811498b8:	1001703a 	wrctl	status,r2
  
  return context;
811498bc:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
811498c0:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
811498c4:	00c00044 	movi	r3,1
811498c8:	e0bffa17 	ldw	r2,-24(fp)
811498cc:	1884983a 	sll	r2,r3,r2
811498d0:	0084303a 	nor	r2,zero,r2
811498d4:	1007883a 	mov	r3,r2
811498d8:	d0a07f17 	ldw	r2,-32260(gp)
811498dc:	1884703a 	and	r2,r3,r2
811498e0:	d0a07f15 	stw	r2,-32260(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
811498e4:	d0a07f17 	ldw	r2,-32260(gp)
811498e8:	100170fa 	wrctl	ienable,r2
811498ec:	e0bffc17 	ldw	r2,-16(fp)
811498f0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811498f4:	e0bffd17 	ldw	r2,-12(fp)
811498f8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
811498fc:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
81149900:	0001883a 	nop
}
81149904:	e037883a 	mov	sp,fp
81149908:	df000017 	ldw	fp,0(sp)
8114990c:	dec00104 	addi	sp,sp,4
81149910:	f800283a 	ret

81149914 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
81149914:	defffc04 	addi	sp,sp,-16
81149918:	de00012e 	bgeu	sp,et,81149920 <alt_ic_irq_enabled+0xc>
8114991c:	003b68fa 	trap	3
81149920:	df000315 	stw	fp,12(sp)
81149924:	df000304 	addi	fp,sp,12
81149928:	e13ffe15 	stw	r4,-8(fp)
8114992c:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
81149930:	000530fa 	rdctl	r2,ienable
81149934:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
81149938:	00c00044 	movi	r3,1
8114993c:	e0bfff17 	ldw	r2,-4(fp)
81149940:	1884983a 	sll	r2,r3,r2
81149944:	1007883a 	mov	r3,r2
81149948:	e0bffd17 	ldw	r2,-12(fp)
8114994c:	1884703a 	and	r2,r3,r2
81149950:	1004c03a 	cmpne	r2,r2,zero
81149954:	10803fcc 	andi	r2,r2,255
}
81149958:	e037883a 	mov	sp,fp
8114995c:	df000017 	ldw	fp,0(sp)
81149960:	dec00104 	addi	sp,sp,4
81149964:	f800283a 	ret

81149968 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
81149968:	defff504 	addi	sp,sp,-44
8114996c:	de00012e 	bgeu	sp,et,81149974 <alt_iic_isr_register+0xc>
81149970:	003b68fa 	trap	3
81149974:	dfc00a15 	stw	ra,40(sp)
81149978:	df000915 	stw	fp,36(sp)
8114997c:	df000904 	addi	fp,sp,36
81149980:	e13ffc15 	stw	r4,-16(fp)
81149984:	e17ffd15 	stw	r5,-12(fp)
81149988:	e1bffe15 	stw	r6,-8(fp)
8114998c:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
81149990:	00bffa84 	movi	r2,-22
81149994:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
81149998:	e0bffd17 	ldw	r2,-12(fp)
8114999c:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
811499a0:	e0bff817 	ldw	r2,-32(fp)
811499a4:	10800808 	cmpgei	r2,r2,32
811499a8:	1000271e 	bne	r2,zero,81149a48 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811499ac:	0005303a 	rdctl	r2,status
811499b0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811499b4:	e0fffb17 	ldw	r3,-20(fp)
811499b8:	00bfff84 	movi	r2,-2
811499bc:	1884703a 	and	r2,r3,r2
811499c0:	1001703a 	wrctl	status,r2
  
  return context;
811499c4:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
811499c8:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
811499cc:	00a045f4 	movhi	r2,33047
811499d0:	10b0f304 	addi	r2,r2,-15412
811499d4:	e0fff817 	ldw	r3,-32(fp)
811499d8:	180690fa 	slli	r3,r3,3
811499dc:	10c5883a 	add	r2,r2,r3
811499e0:	e0fffe17 	ldw	r3,-8(fp)
811499e4:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
811499e8:	00a045f4 	movhi	r2,33047
811499ec:	10b0f304 	addi	r2,r2,-15412
811499f0:	e0fff817 	ldw	r3,-32(fp)
811499f4:	180690fa 	slli	r3,r3,3
811499f8:	10c5883a 	add	r2,r2,r3
811499fc:	10800104 	addi	r2,r2,4
81149a00:	e0ffff17 	ldw	r3,-4(fp)
81149a04:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
81149a08:	e0bffe17 	ldw	r2,-8(fp)
81149a0c:	10000526 	beq	r2,zero,81149a24 <alt_iic_isr_register+0xbc>
81149a10:	e0bff817 	ldw	r2,-32(fp)
81149a14:	100b883a 	mov	r5,r2
81149a18:	e13ffc17 	ldw	r4,-16(fp)
81149a1c:	11497f00 	call	811497f0 <alt_ic_irq_enable>
81149a20:	00000406 	br	81149a34 <alt_iic_isr_register+0xcc>
81149a24:	e0bff817 	ldw	r2,-32(fp)
81149a28:	100b883a 	mov	r5,r2
81149a2c:	e13ffc17 	ldw	r4,-16(fp)
81149a30:	11498800 	call	81149880 <alt_ic_irq_disable>
81149a34:	e0bff715 	stw	r2,-36(fp)
81149a38:	e0bffa17 	ldw	r2,-24(fp)
81149a3c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81149a40:	e0bff917 	ldw	r2,-28(fp)
81149a44:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
81149a48:	e0bff717 	ldw	r2,-36(fp)
}
81149a4c:	e037883a 	mov	sp,fp
81149a50:	dfc00117 	ldw	ra,4(sp)
81149a54:	df000017 	ldw	fp,0(sp)
81149a58:	dec00204 	addi	sp,sp,8
81149a5c:	f800283a 	ret

81149a60 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
81149a60:	defff904 	addi	sp,sp,-28
81149a64:	de00012e 	bgeu	sp,et,81149a6c <alt_open_fd+0xc>
81149a68:	003b68fa 	trap	3
81149a6c:	dfc00615 	stw	ra,24(sp)
81149a70:	df000515 	stw	fp,20(sp)
81149a74:	df000504 	addi	fp,sp,20
81149a78:	e13ffc15 	stw	r4,-16(fp)
81149a7c:	e17ffd15 	stw	r5,-12(fp)
81149a80:	e1bffe15 	stw	r6,-8(fp)
81149a84:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
81149a88:	e1bfff17 	ldw	r6,-4(fp)
81149a8c:	e17ffe17 	ldw	r5,-8(fp)
81149a90:	e13ffd17 	ldw	r4,-12(fp)
81149a94:	11369100 	call	81136910 <open>
81149a98:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
81149a9c:	e0bffb17 	ldw	r2,-20(fp)
81149aa0:	10001c16 	blt	r2,zero,81149b14 <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
81149aa4:	00a04574 	movhi	r2,33045
81149aa8:	10835104 	addi	r2,r2,3396
81149aac:	e0fffb17 	ldw	r3,-20(fp)
81149ab0:	18c00324 	muli	r3,r3,12
81149ab4:	10c5883a 	add	r2,r2,r3
81149ab8:	10c00017 	ldw	r3,0(r2)
81149abc:	e0bffc17 	ldw	r2,-16(fp)
81149ac0:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
81149ac4:	00a04574 	movhi	r2,33045
81149ac8:	10835104 	addi	r2,r2,3396
81149acc:	e0fffb17 	ldw	r3,-20(fp)
81149ad0:	18c00324 	muli	r3,r3,12
81149ad4:	10c5883a 	add	r2,r2,r3
81149ad8:	10800104 	addi	r2,r2,4
81149adc:	10c00017 	ldw	r3,0(r2)
81149ae0:	e0bffc17 	ldw	r2,-16(fp)
81149ae4:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
81149ae8:	00a04574 	movhi	r2,33045
81149aec:	10835104 	addi	r2,r2,3396
81149af0:	e0fffb17 	ldw	r3,-20(fp)
81149af4:	18c00324 	muli	r3,r3,12
81149af8:	10c5883a 	add	r2,r2,r3
81149afc:	10800204 	addi	r2,r2,8
81149b00:	10c00017 	ldw	r3,0(r2)
81149b04:	e0bffc17 	ldw	r2,-16(fp)
81149b08:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
81149b0c:	e13ffb17 	ldw	r4,-20(fp)
81149b10:	1136bb40 	call	81136bb4 <alt_release_fd>
  }
} 
81149b14:	0001883a 	nop
81149b18:	e037883a 	mov	sp,fp
81149b1c:	dfc00117 	ldw	ra,4(sp)
81149b20:	df000017 	ldw	fp,0(sp)
81149b24:	dec00204 	addi	sp,sp,8
81149b28:	f800283a 	ret

81149b2c <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
81149b2c:	defffb04 	addi	sp,sp,-20
81149b30:	de00012e 	bgeu	sp,et,81149b38 <alt_io_redirect+0xc>
81149b34:	003b68fa 	trap	3
81149b38:	dfc00415 	stw	ra,16(sp)
81149b3c:	df000315 	stw	fp,12(sp)
81149b40:	df000304 	addi	fp,sp,12
81149b44:	e13ffd15 	stw	r4,-12(fp)
81149b48:	e17ffe15 	stw	r5,-8(fp)
81149b4c:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
81149b50:	01c07fc4 	movi	r7,511
81149b54:	01800044 	movi	r6,1
81149b58:	e17ffd17 	ldw	r5,-12(fp)
81149b5c:	01204574 	movhi	r4,33045
81149b60:	21035404 	addi	r4,r4,3408
81149b64:	1149a600 	call	81149a60 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
81149b68:	01c07fc4 	movi	r7,511
81149b6c:	000d883a 	mov	r6,zero
81149b70:	e17ffe17 	ldw	r5,-8(fp)
81149b74:	01204574 	movhi	r4,33045
81149b78:	21035104 	addi	r4,r4,3396
81149b7c:	1149a600 	call	81149a60 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
81149b80:	01c07fc4 	movi	r7,511
81149b84:	01800044 	movi	r6,1
81149b88:	e17fff17 	ldw	r5,-4(fp)
81149b8c:	01204574 	movhi	r4,33045
81149b90:	21035704 	addi	r4,r4,3420
81149b94:	1149a600 	call	81149a60 <alt_open_fd>
}  
81149b98:	0001883a 	nop
81149b9c:	e037883a 	mov	sp,fp
81149ba0:	dfc00117 	ldw	ra,4(sp)
81149ba4:	df000017 	ldw	fp,0(sp)
81149ba8:	dec00204 	addi	sp,sp,8
81149bac:	f800283a 	ret

81149bb0 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
81149bb0:	defff204 	addi	sp,sp,-56
81149bb4:	de00012e 	bgeu	sp,et,81149bbc <alt_printf+0xc>
81149bb8:	003b68fa 	trap	3
81149bbc:	dfc00a15 	stw	ra,40(sp)
81149bc0:	df000915 	stw	fp,36(sp)
81149bc4:	df000904 	addi	fp,sp,36
81149bc8:	e13fff15 	stw	r4,-4(fp)
81149bcc:	e1400215 	stw	r5,8(fp)
81149bd0:	e1800315 	stw	r6,12(fp)
81149bd4:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
81149bd8:	e0800204 	addi	r2,fp,8
81149bdc:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
81149be0:	e0bfff17 	ldw	r2,-4(fp)
81149be4:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
81149be8:	00006f06 	br	81149da8 <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
81149bec:	e0bff807 	ldb	r2,-32(fp)
81149bf0:	10800960 	cmpeqi	r2,r2,37
81149bf4:	1000041e 	bne	r2,zero,81149c08 <alt_printf+0x58>
        {
            alt_putchar(c);
81149bf8:	e0bff807 	ldb	r2,-32(fp)
81149bfc:	1009883a 	mov	r4,r2
81149c00:	1149de40 	call	81149de4 <alt_putchar>
81149c04:	00006806 	br	81149da8 <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
81149c08:	e0bff717 	ldw	r2,-36(fp)
81149c0c:	10c00044 	addi	r3,r2,1
81149c10:	e0fff715 	stw	r3,-36(fp)
81149c14:	10800003 	ldbu	r2,0(r2)
81149c18:	e0bff805 	stb	r2,-32(fp)
81149c1c:	e0bff807 	ldb	r2,-32(fp)
81149c20:	10006926 	beq	r2,zero,81149dc8 <alt_printf+0x218>
            {
                if (c == '%')
81149c24:	e0bff807 	ldb	r2,-32(fp)
81149c28:	10800958 	cmpnei	r2,r2,37
81149c2c:	1000041e 	bne	r2,zero,81149c40 <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
81149c30:	e0bff807 	ldb	r2,-32(fp)
81149c34:	1009883a 	mov	r4,r2
81149c38:	1149de40 	call	81149de4 <alt_putchar>
81149c3c:	00005a06 	br	81149da8 <alt_printf+0x1f8>
                } 
                else if (c == 'c')
81149c40:	e0bff807 	ldb	r2,-32(fp)
81149c44:	108018d8 	cmpnei	r2,r2,99
81149c48:	1000081e 	bne	r2,zero,81149c6c <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
81149c4c:	e0bffe17 	ldw	r2,-8(fp)
81149c50:	10c00104 	addi	r3,r2,4
81149c54:	e0fffe15 	stw	r3,-8(fp)
81149c58:	10800017 	ldw	r2,0(r2)
81149c5c:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
81149c60:	e13ffd17 	ldw	r4,-12(fp)
81149c64:	1149de40 	call	81149de4 <alt_putchar>
81149c68:	00004f06 	br	81149da8 <alt_printf+0x1f8>
                }
                else if (c == 'x')
81149c6c:	e0bff807 	ldb	r2,-32(fp)
81149c70:	10801e18 	cmpnei	r2,r2,120
81149c74:	1000341e 	bne	r2,zero,81149d48 <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
81149c78:	e0bffe17 	ldw	r2,-8(fp)
81149c7c:	10c00104 	addi	r3,r2,4
81149c80:	e0fffe15 	stw	r3,-8(fp)
81149c84:	10800017 	ldw	r2,0(r2)
81149c88:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
81149c8c:	e0bffb17 	ldw	r2,-20(fp)
81149c90:	1000031e 	bne	r2,zero,81149ca0 <alt_printf+0xf0>
                    {
                        alt_putchar('0');
81149c94:	01000c04 	movi	r4,48
81149c98:	1149de40 	call	81149de4 <alt_putchar>
                        continue;
81149c9c:	00004206 	br	81149da8 <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
81149ca0:	00800704 	movi	r2,28
81149ca4:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
81149ca8:	00000306 	br	81149cb8 <alt_printf+0x108>
                        digit_shift -= 4;
81149cac:	e0bff917 	ldw	r2,-28(fp)
81149cb0:	10bfff04 	addi	r2,r2,-4
81149cb4:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
81149cb8:	00c003c4 	movi	r3,15
81149cbc:	e0bff917 	ldw	r2,-28(fp)
81149cc0:	1884983a 	sll	r2,r3,r2
81149cc4:	1007883a 	mov	r3,r2
81149cc8:	e0bffb17 	ldw	r2,-20(fp)
81149ccc:	1884703a 	and	r2,r3,r2
81149cd0:	103ff626 	beq	r2,zero,81149cac <__reset+0xfb129cac>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
81149cd4:	00001906 	br	81149d3c <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
81149cd8:	00c003c4 	movi	r3,15
81149cdc:	e0bff917 	ldw	r2,-28(fp)
81149ce0:	1884983a 	sll	r2,r3,r2
81149ce4:	1007883a 	mov	r3,r2
81149ce8:	e0bffb17 	ldw	r2,-20(fp)
81149cec:	1886703a 	and	r3,r3,r2
81149cf0:	e0bff917 	ldw	r2,-28(fp)
81149cf4:	1884d83a 	srl	r2,r3,r2
81149cf8:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
81149cfc:	e0bffc17 	ldw	r2,-16(fp)
81149d00:	108002a8 	cmpgeui	r2,r2,10
81149d04:	1000041e 	bne	r2,zero,81149d18 <alt_printf+0x168>
                            c = '0' + digit;
81149d08:	e0bffc17 	ldw	r2,-16(fp)
81149d0c:	10800c04 	addi	r2,r2,48
81149d10:	e0bff805 	stb	r2,-32(fp)
81149d14:	00000306 	br	81149d24 <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
81149d18:	e0bffc17 	ldw	r2,-16(fp)
81149d1c:	108015c4 	addi	r2,r2,87
81149d20:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
81149d24:	e0bff807 	ldb	r2,-32(fp)
81149d28:	1009883a 	mov	r4,r2
81149d2c:	1149de40 	call	81149de4 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
81149d30:	e0bff917 	ldw	r2,-28(fp)
81149d34:	10bfff04 	addi	r2,r2,-4
81149d38:	e0bff915 	stw	r2,-28(fp)
81149d3c:	e0bff917 	ldw	r2,-28(fp)
81149d40:	103fe50e 	bge	r2,zero,81149cd8 <__reset+0xfb129cd8>
81149d44:	00001806 	br	81149da8 <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
81149d48:	e0bff807 	ldb	r2,-32(fp)
81149d4c:	10801cd8 	cmpnei	r2,r2,115
81149d50:	1000151e 	bne	r2,zero,81149da8 <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
81149d54:	e0bffe17 	ldw	r2,-8(fp)
81149d58:	10c00104 	addi	r3,r2,4
81149d5c:	e0fffe15 	stw	r3,-8(fp)
81149d60:	10800017 	ldw	r2,0(r2)
81149d64:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
81149d68:	00000906 	br	81149d90 <alt_printf+0x1e0>
                      alt_putchar(*s++);
81149d6c:	e0bffa17 	ldw	r2,-24(fp)
81149d70:	10c00044 	addi	r3,r2,1
81149d74:	e0fffa15 	stw	r3,-24(fp)
81149d78:	10800003 	ldbu	r2,0(r2)
81149d7c:	10803fcc 	andi	r2,r2,255
81149d80:	1080201c 	xori	r2,r2,128
81149d84:	10bfe004 	addi	r2,r2,-128
81149d88:	1009883a 	mov	r4,r2
81149d8c:	1149de40 	call	81149de4 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
81149d90:	e0bffa17 	ldw	r2,-24(fp)
81149d94:	10800003 	ldbu	r2,0(r2)
81149d98:	10803fcc 	andi	r2,r2,255
81149d9c:	1080201c 	xori	r2,r2,128
81149da0:	10bfe004 	addi	r2,r2,-128
81149da4:	103ff11e 	bne	r2,zero,81149d6c <__reset+0xfb129d6c>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
81149da8:	e0bff717 	ldw	r2,-36(fp)
81149dac:	10c00044 	addi	r3,r2,1
81149db0:	e0fff715 	stw	r3,-36(fp)
81149db4:	10800003 	ldbu	r2,0(r2)
81149db8:	e0bff805 	stb	r2,-32(fp)
81149dbc:	e0bff807 	ldb	r2,-32(fp)
81149dc0:	103f8a1e 	bne	r2,zero,81149bec <__reset+0xfb129bec>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
81149dc4:	00000106 	br	81149dcc <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
81149dc8:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
81149dcc:	0001883a 	nop
81149dd0:	e037883a 	mov	sp,fp
81149dd4:	dfc00117 	ldw	ra,4(sp)
81149dd8:	df000017 	ldw	fp,0(sp)
81149ddc:	dec00504 	addi	sp,sp,20
81149de0:	f800283a 	ret

81149de4 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
81149de4:	defffd04 	addi	sp,sp,-12
81149de8:	de00012e 	bgeu	sp,et,81149df0 <alt_putchar+0xc>
81149dec:	003b68fa 	trap	3
81149df0:	dfc00215 	stw	ra,8(sp)
81149df4:	df000115 	stw	fp,4(sp)
81149df8:	df000104 	addi	fp,sp,4
81149dfc:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
81149e00:	d0a00517 	ldw	r2,-32748(gp)
81149e04:	10800217 	ldw	r2,8(r2)
81149e08:	100b883a 	mov	r5,r2
81149e0c:	e13fff17 	ldw	r4,-4(fp)
81149e10:	1121c6c0 	call	81121c6c <putc>
#endif
#endif
}
81149e14:	e037883a 	mov	sp,fp
81149e18:	dfc00117 	ldw	ra,4(sp)
81149e1c:	df000017 	ldw	fp,0(sp)
81149e20:	dec00204 	addi	sp,sp,8
81149e24:	f800283a 	ret

81149e28 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
81149e28:	deffff04 	addi	sp,sp,-4
81149e2c:	de00012e 	bgeu	sp,et,81149e34 <altera_nios2_gen2_irq_init+0xc>
81149e30:	003b68fa 	trap	3
81149e34:	df000015 	stw	fp,0(sp)
81149e38:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
81149e3c:	000170fa 	wrctl	ienable,zero
}
81149e40:	0001883a 	nop
81149e44:	e037883a 	mov	sp,fp
81149e48:	df000017 	ldw	fp,0(sp)
81149e4c:	dec00104 	addi	sp,sp,4
81149e50:	f800283a 	ret

81149e54 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
81149e54:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
81149e58:	de002436 	bltu	sp,et,81149eec <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
81149e5c:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
81149e60:	d120a117 	ldw	r4,-32124(gp)

      stw ra,  0(sp)
81149e64:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
81149e68:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
81149e6c:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
81149e70:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
81149e74:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
81149e78:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
81149e7c:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
81149e80:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
81149e84:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
81149e88:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
81149e8c:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
81149e90:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
81149e94:	114a0f00 	call	8114a0f0 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
81149e98:	d1209b17 	ldw	r4,-32148(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
81149e9c:	d1609287 	ldb	r5,-32182(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
81149ea0:	d120a115 	stw	r4,-32124(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
81149ea4:	d16092c5 	stb	r5,-32181(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
81149ea8:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
81149eac:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
81149eb0:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
81149eb4:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
81149eb8:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
81149ebc:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
81149ec0:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
81149ec4:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
81149ec8:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
81149ecc:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
81149ed0:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
81149ed4:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
81149ed8:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
81149edc:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
81149ee0:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
81149ee4:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
81149ee8:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
81149eec:	003da0fa 	break	3

81149ef0 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
81149ef0:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
81149ef4:	047fff84 	movi	r17,-2
      and   r18, r18, r17
81149ef8:	9464703a 	and	r18,r18,r17
      wrctl status, r18
81149efc:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
81149f00:	114a0f00 	call	8114a0f0 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
81149f04:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
81149f08:	d4a09005 	stb	r18,-32192(gp)

      /*
       * start execution of the new task.
       */

      br 9b
81149f0c:	003fe206 	br	81149e98 <__reset+0xfb129e98>

81149f10 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
81149f10:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
81149f14:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
81149f18:	10800054 	ori	r2,r2,1
      wrctl status, r2
81149f1c:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
81149f20:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
81149f24:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
81149f28:	dec00204 	addi	sp,sp,8

      callr r2
81149f2c:	103ee83a 	callr	r2

      nop
81149f30:	0001883a 	nop

81149f34 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
81149f34:	defff704 	addi	sp,sp,-36
81149f38:	de00012e 	bgeu	sp,et,81149f40 <OSTaskStkInit+0xc>
81149f3c:	003b68fa 	trap	3
81149f40:	dfc00815 	stw	ra,32(sp)
81149f44:	df000715 	stw	fp,28(sp)
81149f48:	df000704 	addi	fp,sp,28
81149f4c:	e13ffc15 	stw	r4,-16(fp)
81149f50:	e17ffd15 	stw	r5,-12(fp)
81149f54:	e1bffe15 	stw	r6,-8(fp)
81149f58:	3805883a 	mov	r2,r7
81149f5c:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
81149f60:	e0fffe17 	ldw	r3,-8(fp)
81149f64:	00bfff04 	movi	r2,-4
81149f68:	1884703a 	and	r2,r3,r2
81149f6c:	10bef704 	addi	r2,r2,-1060
81149f70:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
81149f74:	01810904 	movi	r6,1060
81149f78:	000b883a 	mov	r5,zero
81149f7c:	e13ff917 	ldw	r4,-28(fp)
81149f80:	11219b80 	call	811219b8 <memset>
81149f84:	e0bff917 	ldw	r2,-28(fp)
81149f88:	10c0bb04 	addi	r3,r2,748
81149f8c:	e0bff917 	ldw	r2,-28(fp)
81149f90:	10c00115 	stw	r3,4(r2)
81149f94:	e0bff917 	ldw	r2,-28(fp)
81149f98:	10c0d504 	addi	r3,r2,852
81149f9c:	e0bff917 	ldw	r2,-28(fp)
81149fa0:	10c00215 	stw	r3,8(r2)
81149fa4:	e0bff917 	ldw	r2,-28(fp)
81149fa8:	10c0ef04 	addi	r3,r2,956
81149fac:	e0bff917 	ldw	r2,-28(fp)
81149fb0:	10c00315 	stw	r3,12(r2)
81149fb4:	e0fff917 	ldw	r3,-28(fp)
81149fb8:	00a04574 	movhi	r2,33045
81149fbc:	1080ea04 	addi	r2,r2,936
81149fc0:	18800d15 	stw	r2,52(r3)
81149fc4:	e0bff917 	ldw	r2,-28(fp)
81149fc8:	00c00044 	movi	r3,1
81149fcc:	10c02915 	stw	r3,164(r2)
81149fd0:	10002a15 	stw	zero,168(r2)
81149fd4:	e0bff917 	ldw	r2,-28(fp)
81149fd8:	00ccc384 	movi	r3,13070
81149fdc:	10c02b0d 	sth	r3,172(r2)
81149fe0:	e0bff917 	ldw	r2,-28(fp)
81149fe4:	00eaf344 	movi	r3,-21555
81149fe8:	10c02b8d 	sth	r3,174(r2)
81149fec:	e0bff917 	ldw	r2,-28(fp)
81149ff0:	00c48d04 	movi	r3,4660
81149ff4:	10c02c0d 	sth	r3,176(r2)
81149ff8:	e0bff917 	ldw	r2,-28(fp)
81149ffc:	00f99b44 	movi	r3,-6547
8114a000:	10c02c8d 	sth	r3,178(r2)
8114a004:	e0bff917 	ldw	r2,-28(fp)
8114a008:	00f7bb04 	movi	r3,-8468
8114a00c:	10c02d0d 	sth	r3,180(r2)
8114a010:	e0bff917 	ldw	r2,-28(fp)
8114a014:	00c00144 	movi	r3,5
8114a018:	10c02d8d 	sth	r3,182(r2)
8114a01c:	e0bff917 	ldw	r2,-28(fp)
8114a020:	00c002c4 	movi	r3,11
8114a024:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
8114a028:	e0bff917 	ldw	r2,-28(fp)
8114a02c:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
8114a030:	e0bffa17 	ldw	r2,-24(fp)
8114a034:	10bff304 	addi	r2,r2,-52
8114a038:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
8114a03c:	e0bffb17 	ldw	r2,-20(fp)
8114a040:	10800c04 	addi	r2,r2,48
8114a044:	e0fffc17 	ldw	r3,-16(fp)
8114a048:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
8114a04c:	e0bffb17 	ldw	r2,-20(fp)
8114a050:	10800b04 	addi	r2,r2,44
8114a054:	e0fffd17 	ldw	r3,-12(fp)
8114a058:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
8114a05c:	e0bffb17 	ldw	r2,-20(fp)
8114a060:	10800a04 	addi	r2,r2,40
8114a064:	e0fff917 	ldw	r3,-28(fp)
8114a068:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
8114a06c:	00a04574 	movhi	r2,33045
8114a070:	10a7c404 	addi	r2,r2,-24816
8114a074:	10c00104 	addi	r3,r2,4
8114a078:	e0bffb17 	ldw	r2,-20(fp)
8114a07c:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
8114a080:	e0bffb17 	ldw	r2,-20(fp)
}
8114a084:	e037883a 	mov	sp,fp
8114a088:	dfc00117 	ldw	ra,4(sp)
8114a08c:	df000017 	ldw	fp,0(sp)
8114a090:	dec00204 	addi	sp,sp,8
8114a094:	f800283a 	ret

8114a098 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
8114a098:	defffe04 	addi	sp,sp,-8
8114a09c:	de00012e 	bgeu	sp,et,8114a0a4 <OSTaskCreateHook+0xc>
8114a0a0:	003b68fa 	trap	3
8114a0a4:	df000115 	stw	fp,4(sp)
8114a0a8:	df000104 	addi	fp,sp,4
8114a0ac:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
8114a0b0:	0001883a 	nop
8114a0b4:	e037883a 	mov	sp,fp
8114a0b8:	df000017 	ldw	fp,0(sp)
8114a0bc:	dec00104 	addi	sp,sp,4
8114a0c0:	f800283a 	ret

8114a0c4 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
8114a0c4:	defffe04 	addi	sp,sp,-8
8114a0c8:	de00012e 	bgeu	sp,et,8114a0d0 <OSTaskDelHook+0xc>
8114a0cc:	003b68fa 	trap	3
8114a0d0:	df000115 	stw	fp,4(sp)
8114a0d4:	df000104 	addi	fp,sp,4
8114a0d8:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
8114a0dc:	0001883a 	nop
8114a0e0:	e037883a 	mov	sp,fp
8114a0e4:	df000017 	ldw	fp,0(sp)
8114a0e8:	dec00104 	addi	sp,sp,4
8114a0ec:	f800283a 	ret

8114a0f0 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
8114a0f0:	deffff04 	addi	sp,sp,-4
8114a0f4:	de00012e 	bgeu	sp,et,8114a0fc <OSTaskSwHook+0xc>
8114a0f8:	003b68fa 	trap	3
8114a0fc:	df000015 	stw	fp,0(sp)
8114a100:	d839883a 	mov	fp,sp
}
8114a104:	0001883a 	nop
8114a108:	e037883a 	mov	sp,fp
8114a10c:	df000017 	ldw	fp,0(sp)
8114a110:	dec00104 	addi	sp,sp,4
8114a114:	f800283a 	ret

8114a118 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
8114a118:	deffff04 	addi	sp,sp,-4
8114a11c:	de00012e 	bgeu	sp,et,8114a124 <OSTaskStatHook+0xc>
8114a120:	003b68fa 	trap	3
8114a124:	df000015 	stw	fp,0(sp)
8114a128:	d839883a 	mov	fp,sp
}
8114a12c:	0001883a 	nop
8114a130:	e037883a 	mov	sp,fp
8114a134:	df000017 	ldw	fp,0(sp)
8114a138:	dec00104 	addi	sp,sp,4
8114a13c:	f800283a 	ret

8114a140 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
8114a140:	defffe04 	addi	sp,sp,-8
8114a144:	de00012e 	bgeu	sp,et,8114a14c <OSTimeTickHook+0xc>
8114a148:	003b68fa 	trap	3
8114a14c:	dfc00115 	stw	ra,4(sp)
8114a150:	df000015 	stw	fp,0(sp)
8114a154:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
8114a158:	d0a0b50b 	ldhu	r2,-32044(gp)
8114a15c:	10800044 	addi	r2,r2,1
8114a160:	d0a0b50d 	sth	r2,-32044(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
8114a164:	d0a0b50b 	ldhu	r2,-32044(gp)
8114a168:	10bfffcc 	andi	r2,r2,65535
8114a16c:	10807d30 	cmpltui	r2,r2,500
8114a170:	1000021e 	bne	r2,zero,8114a17c <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
8114a174:	d020b50d 	sth	zero,-32044(gp)
        OSTmrSignal();
8114a178:	1140a900 	call	81140a90 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
8114a17c:	0001883a 	nop
8114a180:	e037883a 	mov	sp,fp
8114a184:	dfc00117 	ldw	ra,4(sp)
8114a188:	df000017 	ldw	fp,0(sp)
8114a18c:	dec00204 	addi	sp,sp,8
8114a190:	f800283a 	ret

8114a194 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
8114a194:	deffff04 	addi	sp,sp,-4
8114a198:	de00012e 	bgeu	sp,et,8114a1a0 <OSInitHookBegin+0xc>
8114a19c:	003b68fa 	trap	3
8114a1a0:	df000015 	stw	fp,0(sp)
8114a1a4:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
8114a1a8:	d020b50d 	sth	zero,-32044(gp)
#endif
}
8114a1ac:	0001883a 	nop
8114a1b0:	e037883a 	mov	sp,fp
8114a1b4:	df000017 	ldw	fp,0(sp)
8114a1b8:	dec00104 	addi	sp,sp,4
8114a1bc:	f800283a 	ret

8114a1c0 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
8114a1c0:	deffff04 	addi	sp,sp,-4
8114a1c4:	de00012e 	bgeu	sp,et,8114a1cc <OSInitHookEnd+0xc>
8114a1c8:	003b68fa 	trap	3
8114a1cc:	df000015 	stw	fp,0(sp)
8114a1d0:	d839883a 	mov	fp,sp
}
8114a1d4:	0001883a 	nop
8114a1d8:	e037883a 	mov	sp,fp
8114a1dc:	df000017 	ldw	fp,0(sp)
8114a1e0:	dec00104 	addi	sp,sp,4
8114a1e4:	f800283a 	ret

8114a1e8 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
8114a1e8:	deffff04 	addi	sp,sp,-4
8114a1ec:	de00012e 	bgeu	sp,et,8114a1f4 <OSTaskIdleHook+0xc>
8114a1f0:	003b68fa 	trap	3
8114a1f4:	df000015 	stw	fp,0(sp)
8114a1f8:	d839883a 	mov	fp,sp
}
8114a1fc:	0001883a 	nop
8114a200:	e037883a 	mov	sp,fp
8114a204:	df000017 	ldw	fp,0(sp)
8114a208:	dec00104 	addi	sp,sp,4
8114a20c:	f800283a 	ret

8114a210 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
8114a210:	defffe04 	addi	sp,sp,-8
8114a214:	de00012e 	bgeu	sp,et,8114a21c <OSTCBInitHook+0xc>
8114a218:	003b68fa 	trap	3
8114a21c:	df000115 	stw	fp,4(sp)
8114a220:	df000104 	addi	fp,sp,4
8114a224:	e13fff15 	stw	r4,-4(fp)
}
8114a228:	0001883a 	nop
8114a22c:	e037883a 	mov	sp,fp
8114a230:	df000017 	ldw	fp,0(sp)
8114a234:	dec00104 	addi	sp,sp,4
8114a238:	f800283a 	ret

8114a23c <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
8114a23c:	defffe04 	addi	sp,sp,-8
8114a240:	de00012e 	bgeu	sp,et,8114a248 <alt_exception_cause_generated_bad_addr+0xc>
8114a244:	003b68fa 	trap	3
8114a248:	df000115 	stw	fp,4(sp)
8114a24c:	df000104 	addi	fp,sp,4
8114a250:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
8114a254:	e0bfff17 	ldw	r2,-4(fp)
8114a258:	10bffe84 	addi	r2,r2,-6
8114a25c:	10c00428 	cmpgeui	r3,r2,16
8114a260:	18001a1e 	bne	r3,zero,8114a2cc <alt_exception_cause_generated_bad_addr+0x90>
8114a264:	100690ba 	slli	r3,r2,2
8114a268:	00a04574 	movhi	r2,33045
8114a26c:	10a89f04 	addi	r2,r2,-23940
8114a270:	1885883a 	add	r2,r3,r2
8114a274:	10800017 	ldw	r2,0(r2)
8114a278:	1000683a 	jmp	r2
8114a27c:	8114a2bc 	xorhi	r4,r16,21130
8114a280:	8114a2bc 	xorhi	r4,r16,21130
8114a284:	8114a2cc 	andi	r4,r16,21131
8114a288:	8114a2cc 	andi	r4,r16,21131
8114a28c:	8114a2cc 	andi	r4,r16,21131
8114a290:	8114a2bc 	xorhi	r4,r16,21130
8114a294:	8114a2c4 	addi	r4,r16,21131
8114a298:	8114a2cc 	andi	r4,r16,21131
8114a29c:	8114a2bc 	xorhi	r4,r16,21130
8114a2a0:	8114a2bc 	xorhi	r4,r16,21130
8114a2a4:	8114a2cc 	andi	r4,r16,21131
8114a2a8:	8114a2bc 	xorhi	r4,r16,21130
8114a2ac:	8114a2c4 	addi	r4,r16,21131
8114a2b0:	8114a2cc 	andi	r4,r16,21131
8114a2b4:	8114a2cc 	andi	r4,r16,21131
8114a2b8:	8114a2bc 	xorhi	r4,r16,21130
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
8114a2bc:	00800044 	movi	r2,1
8114a2c0:	00000306 	br	8114a2d0 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
8114a2c4:	0005883a 	mov	r2,zero
8114a2c8:	00000106 	br	8114a2d0 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
8114a2cc:	0005883a 	mov	r2,zero
  }
}
8114a2d0:	e037883a 	mov	sp,fp
8114a2d4:	df000017 	ldw	fp,0(sp)
8114a2d8:	dec00104 	addi	sp,sp,4
8114a2dc:	f800283a 	ret

8114a2e0 <exit>:
8114a2e0:	defffe04 	addi	sp,sp,-8
8114a2e4:	000b883a 	mov	r5,zero
8114a2e8:	de00012e 	bgeu	sp,et,8114a2f0 <exit+0x10>
8114a2ec:	003b68fa 	trap	3
8114a2f0:	dc000015 	stw	r16,0(sp)
8114a2f4:	dfc00115 	stw	ra,4(sp)
8114a2f8:	2021883a 	mov	r16,r4
8114a2fc:	114a4880 	call	8114a488 <__call_exitprocs>
8114a300:	00a04574 	movhi	r2,33045
8114a304:	10886804 	addi	r2,r2,8608
8114a308:	11000017 	ldw	r4,0(r2)
8114a30c:	20800f17 	ldw	r2,60(r4)
8114a310:	10000126 	beq	r2,zero,8114a318 <exit+0x38>
8114a314:	103ee83a 	callr	r2
8114a318:	8009883a 	mov	r4,r16
8114a31c:	114a6100 	call	8114a610 <_exit>

8114a320 <memcmp>:
8114a320:	01c000c4 	movi	r7,3
8114a324:	3980192e 	bgeu	r7,r6,8114a38c <memcmp+0x6c>
8114a328:	2144b03a 	or	r2,r4,r5
8114a32c:	11c4703a 	and	r2,r2,r7
8114a330:	10000f26 	beq	r2,zero,8114a370 <memcmp+0x50>
8114a334:	20800003 	ldbu	r2,0(r4)
8114a338:	28c00003 	ldbu	r3,0(r5)
8114a33c:	10c0151e 	bne	r2,r3,8114a394 <memcmp+0x74>
8114a340:	31bfff84 	addi	r6,r6,-2
8114a344:	01ffffc4 	movi	r7,-1
8114a348:	00000406 	br	8114a35c <memcmp+0x3c>
8114a34c:	20800003 	ldbu	r2,0(r4)
8114a350:	28c00003 	ldbu	r3,0(r5)
8114a354:	31bfffc4 	addi	r6,r6,-1
8114a358:	10c00e1e 	bne	r2,r3,8114a394 <memcmp+0x74>
8114a35c:	21000044 	addi	r4,r4,1
8114a360:	29400044 	addi	r5,r5,1
8114a364:	31fff91e 	bne	r6,r7,8114a34c <__reset+0xfb12a34c>
8114a368:	0005883a 	mov	r2,zero
8114a36c:	f800283a 	ret
8114a370:	20c00017 	ldw	r3,0(r4)
8114a374:	28800017 	ldw	r2,0(r5)
8114a378:	18bfee1e 	bne	r3,r2,8114a334 <__reset+0xfb12a334>
8114a37c:	31bfff04 	addi	r6,r6,-4
8114a380:	21000104 	addi	r4,r4,4
8114a384:	29400104 	addi	r5,r5,4
8114a388:	39bff936 	bltu	r7,r6,8114a370 <__reset+0xfb12a370>
8114a38c:	303fe91e 	bne	r6,zero,8114a334 <__reset+0xfb12a334>
8114a390:	003ff506 	br	8114a368 <__reset+0xfb12a368>
8114a394:	10c5c83a 	sub	r2,r2,r3
8114a398:	f800283a 	ret

8114a39c <strncpy>:
8114a39c:	2906b03a 	or	r3,r5,r4
8114a3a0:	18c000cc 	andi	r3,r3,3
8114a3a4:	2005883a 	mov	r2,r4
8114a3a8:	18002c1e 	bne	r3,zero,8114a45c <strncpy+0xc0>
8114a3ac:	010000c4 	movi	r4,3
8114a3b0:	21802a2e 	bgeu	r4,r6,8114a45c <strncpy+0xc0>
8114a3b4:	033fbff4 	movhi	r12,65279
8114a3b8:	02e02074 	movhi	r11,32897
8114a3bc:	633fbfc4 	addi	r12,r12,-257
8114a3c0:	5ae02004 	addi	r11,r11,-32640
8114a3c4:	100f883a 	mov	r7,r2
8114a3c8:	2a000017 	ldw	r8,0(r5)
8114a3cc:	3815883a 	mov	r10,r7
8114a3d0:	4313883a 	add	r9,r8,r12
8114a3d4:	0206303a 	nor	r3,zero,r8
8114a3d8:	48c6703a 	and	r3,r9,r3
8114a3dc:	1ac6703a 	and	r3,r3,r11
8114a3e0:	1800261e 	bne	r3,zero,8114a47c <strncpy+0xe0>
8114a3e4:	39c00104 	addi	r7,r7,4
8114a3e8:	52000015 	stw	r8,0(r10)
8114a3ec:	31bfff04 	addi	r6,r6,-4
8114a3f0:	3811883a 	mov	r8,r7
8114a3f4:	29400104 	addi	r5,r5,4
8114a3f8:	21bff336 	bltu	r4,r6,8114a3c8 <__reset+0xfb12a3c8>
8114a3fc:	30001e26 	beq	r6,zero,8114a478 <strncpy+0xdc>
8114a400:	29c00003 	ldbu	r7,0(r5)
8114a404:	31bfffc4 	addi	r6,r6,-1
8114a408:	40c00044 	addi	r3,r8,1
8114a40c:	41c00005 	stb	r7,0(r8)
8114a410:	39c03fcc 	andi	r7,r7,255
8114a414:	39c0201c 	xori	r7,r7,128
8114a418:	39ffe004 	addi	r7,r7,-128
8114a41c:	29400044 	addi	r5,r5,1
8114a420:	38001026 	beq	r7,zero,8114a464 <strncpy+0xc8>
8114a424:	1811883a 	mov	r8,r3
8114a428:	00000906 	br	8114a450 <strncpy+0xb4>
8114a42c:	29c00003 	ldbu	r7,0(r5)
8114a430:	31bfffc4 	addi	r6,r6,-1
8114a434:	29400044 	addi	r5,r5,1
8114a438:	41c00005 	stb	r7,0(r8)
8114a43c:	39c03fcc 	andi	r7,r7,255
8114a440:	39c0201c 	xori	r7,r7,128
8114a444:	39ffe004 	addi	r7,r7,-128
8114a448:	1811883a 	mov	r8,r3
8114a44c:	38000526 	beq	r7,zero,8114a464 <strncpy+0xc8>
8114a450:	18c00044 	addi	r3,r3,1
8114a454:	303ff51e 	bne	r6,zero,8114a42c <__reset+0xfb12a42c>
8114a458:	f800283a 	ret
8114a45c:	1011883a 	mov	r8,r2
8114a460:	003fe606 	br	8114a3fc <__reset+0xfb12a3fc>
8114a464:	30000726 	beq	r6,zero,8114a484 <strncpy+0xe8>
8114a468:	198d883a 	add	r6,r3,r6
8114a46c:	18000005 	stb	zero,0(r3)
8114a470:	18c00044 	addi	r3,r3,1
8114a474:	19bffd1e 	bne	r3,r6,8114a46c <__reset+0xfb12a46c>
8114a478:	f800283a 	ret
8114a47c:	3811883a 	mov	r8,r7
8114a480:	003fdf06 	br	8114a400 <__reset+0xfb12a400>
8114a484:	f800283a 	ret

8114a488 <__call_exitprocs>:
8114a488:	defff504 	addi	sp,sp,-44
8114a48c:	de00012e 	bgeu	sp,et,8114a494 <__call_exitprocs+0xc>
8114a490:	003b68fa 	trap	3
8114a494:	df000915 	stw	fp,36(sp)
8114a498:	dd400615 	stw	r21,24(sp)
8114a49c:	dc800315 	stw	r18,12(sp)
8114a4a0:	dfc00a15 	stw	ra,40(sp)
8114a4a4:	ddc00815 	stw	r23,32(sp)
8114a4a8:	dd800715 	stw	r22,28(sp)
8114a4ac:	dd000515 	stw	r20,20(sp)
8114a4b0:	dcc00415 	stw	r19,16(sp)
8114a4b4:	dc400215 	stw	r17,8(sp)
8114a4b8:	dc000115 	stw	r16,4(sp)
8114a4bc:	d9000015 	stw	r4,0(sp)
8114a4c0:	2839883a 	mov	fp,r5
8114a4c4:	04800044 	movi	r18,1
8114a4c8:	057fffc4 	movi	r21,-1
8114a4cc:	00a04574 	movhi	r2,33045
8114a4d0:	10886804 	addi	r2,r2,8608
8114a4d4:	12000017 	ldw	r8,0(r2)
8114a4d8:	45005217 	ldw	r20,328(r8)
8114a4dc:	44c05204 	addi	r19,r8,328
8114a4e0:	a0001c26 	beq	r20,zero,8114a554 <__call_exitprocs+0xcc>
8114a4e4:	a0800117 	ldw	r2,4(r20)
8114a4e8:	15ffffc4 	addi	r23,r2,-1
8114a4ec:	b8000d16 	blt	r23,zero,8114a524 <__call_exitprocs+0x9c>
8114a4f0:	14000044 	addi	r16,r2,1
8114a4f4:	8421883a 	add	r16,r16,r16
8114a4f8:	8421883a 	add	r16,r16,r16
8114a4fc:	84402004 	addi	r17,r16,128
8114a500:	a463883a 	add	r17,r20,r17
8114a504:	a421883a 	add	r16,r20,r16
8114a508:	e0001e26 	beq	fp,zero,8114a584 <__call_exitprocs+0xfc>
8114a50c:	80804017 	ldw	r2,256(r16)
8114a510:	e0801c26 	beq	fp,r2,8114a584 <__call_exitprocs+0xfc>
8114a514:	bdffffc4 	addi	r23,r23,-1
8114a518:	843fff04 	addi	r16,r16,-4
8114a51c:	8c7fff04 	addi	r17,r17,-4
8114a520:	bd7ff91e 	bne	r23,r21,8114a508 <__reset+0xfb12a508>
8114a524:	00800034 	movhi	r2,0
8114a528:	10800004 	addi	r2,r2,0
8114a52c:	10000926 	beq	r2,zero,8114a554 <__call_exitprocs+0xcc>
8114a530:	a0800117 	ldw	r2,4(r20)
8114a534:	1000301e 	bne	r2,zero,8114a5f8 <__call_exitprocs+0x170>
8114a538:	a0800017 	ldw	r2,0(r20)
8114a53c:	10003226 	beq	r2,zero,8114a608 <__call_exitprocs+0x180>
8114a540:	a009883a 	mov	r4,r20
8114a544:	98800015 	stw	r2,0(r19)
8114a548:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
8114a54c:	9d000017 	ldw	r20,0(r19)
8114a550:	a03fe41e 	bne	r20,zero,8114a4e4 <__reset+0xfb12a4e4>
8114a554:	dfc00a17 	ldw	ra,40(sp)
8114a558:	df000917 	ldw	fp,36(sp)
8114a55c:	ddc00817 	ldw	r23,32(sp)
8114a560:	dd800717 	ldw	r22,28(sp)
8114a564:	dd400617 	ldw	r21,24(sp)
8114a568:	dd000517 	ldw	r20,20(sp)
8114a56c:	dcc00417 	ldw	r19,16(sp)
8114a570:	dc800317 	ldw	r18,12(sp)
8114a574:	dc400217 	ldw	r17,8(sp)
8114a578:	dc000117 	ldw	r16,4(sp)
8114a57c:	dec00b04 	addi	sp,sp,44
8114a580:	f800283a 	ret
8114a584:	a0800117 	ldw	r2,4(r20)
8114a588:	80c00017 	ldw	r3,0(r16)
8114a58c:	10bfffc4 	addi	r2,r2,-1
8114a590:	15c01426 	beq	r2,r23,8114a5e4 <__call_exitprocs+0x15c>
8114a594:	80000015 	stw	zero,0(r16)
8114a598:	183fde26 	beq	r3,zero,8114a514 <__reset+0xfb12a514>
8114a59c:	95c8983a 	sll	r4,r18,r23
8114a5a0:	a0806217 	ldw	r2,392(r20)
8114a5a4:	a5800117 	ldw	r22,4(r20)
8114a5a8:	2084703a 	and	r2,r4,r2
8114a5ac:	10000b26 	beq	r2,zero,8114a5dc <__call_exitprocs+0x154>
8114a5b0:	a0806317 	ldw	r2,396(r20)
8114a5b4:	2088703a 	and	r4,r4,r2
8114a5b8:	20000c1e 	bne	r4,zero,8114a5ec <__call_exitprocs+0x164>
8114a5bc:	89400017 	ldw	r5,0(r17)
8114a5c0:	d9000017 	ldw	r4,0(sp)
8114a5c4:	183ee83a 	callr	r3
8114a5c8:	a0800117 	ldw	r2,4(r20)
8114a5cc:	15bfbf1e 	bne	r2,r22,8114a4cc <__reset+0xfb12a4cc>
8114a5d0:	98800017 	ldw	r2,0(r19)
8114a5d4:	153fcf26 	beq	r2,r20,8114a514 <__reset+0xfb12a514>
8114a5d8:	003fbc06 	br	8114a4cc <__reset+0xfb12a4cc>
8114a5dc:	183ee83a 	callr	r3
8114a5e0:	003ff906 	br	8114a5c8 <__reset+0xfb12a5c8>
8114a5e4:	a5c00115 	stw	r23,4(r20)
8114a5e8:	003feb06 	br	8114a598 <__reset+0xfb12a598>
8114a5ec:	89000017 	ldw	r4,0(r17)
8114a5f0:	183ee83a 	callr	r3
8114a5f4:	003ff406 	br	8114a5c8 <__reset+0xfb12a5c8>
8114a5f8:	a0800017 	ldw	r2,0(r20)
8114a5fc:	a027883a 	mov	r19,r20
8114a600:	1029883a 	mov	r20,r2
8114a604:	003fb606 	br	8114a4e0 <__reset+0xfb12a4e0>
8114a608:	0005883a 	mov	r2,zero
8114a60c:	003ffb06 	br	8114a5fc <__reset+0xfb12a5fc>

8114a610 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
8114a610:	defffc04 	addi	sp,sp,-16
8114a614:	de00012e 	bgeu	sp,et,8114a61c <_exit+0xc>
8114a618:	003b68fa 	trap	3
8114a61c:	dfc00315 	stw	ra,12(sp)
8114a620:	df000215 	stw	fp,8(sp)
8114a624:	df000204 	addi	fp,sp,8
8114a628:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
8114a62c:	d0a01217 	ldw	r2,-32696(gp)
8114a630:	10800058 	cmpnei	r2,r2,1
8114a634:	1000031e 	bne	r2,zero,8114a644 <_exit+0x34>
8114a638:	01204574 	movhi	r4,33045
8114a63c:	2100eb04 	addi	r4,r4,940
8114a640:	11361200 	call	81136120 <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
8114a644:	d0a01217 	ldw	r2,-32696(gp)
8114a648:	10800058 	cmpnei	r2,r2,1
8114a64c:	1000041e 	bne	r2,zero,8114a660 <_exit+0x50>
8114a650:	e17fff17 	ldw	r5,-4(fp)
8114a654:	01204574 	movhi	r4,33045
8114a658:	2100f604 	addi	r4,r4,984
8114a65c:	11361200 	call	81136120 <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
8114a660:	d0a01217 	ldw	r2,-32696(gp)
8114a664:	10800058 	cmpnei	r2,r2,1
8114a668:	1000031e 	bne	r2,zero,8114a678 <_exit+0x68>
8114a66c:	01204574 	movhi	r4,33045
8114a670:	21010104 	addi	r4,r4,1028
8114a674:	11361200 	call	81136120 <alt_log_printf_proc>
  ALT_OS_STOP();
8114a678:	d0209005 	stb	zero,-32192(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
8114a67c:	d0a01217 	ldw	r2,-32696(gp)
8114a680:	10800058 	cmpnei	r2,r2,1
8114a684:	1000031e 	bne	r2,zero,8114a694 <_exit+0x84>
8114a688:	01204574 	movhi	r4,33045
8114a68c:	21010b04 	addi	r4,r4,1068
8114a690:	11361200 	call	81136120 <alt_log_printf_proc>
8114a694:	e0bfff17 	ldw	r2,-4(fp)
8114a698:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
8114a69c:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
8114a6a0:	10000226 	beq	r2,zero,8114a6ac <_exit+0x9c>
    ALT_SIM_FAIL();
8114a6a4:	002af070 	cmpltui	zero,zero,43969
8114a6a8:	00000106 	br	8114a6b0 <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
8114a6ac:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
8114a6b0:	d0a01217 	ldw	r2,-32696(gp)
8114a6b4:	10800058 	cmpnei	r2,r2,1
8114a6b8:	1000031e 	bne	r2,zero,8114a6c8 <_exit+0xb8>
8114a6bc:	01204574 	movhi	r4,33045
8114a6c0:	21011504 	addi	r4,r4,1108
8114a6c4:	11361200 	call	81136120 <alt_log_printf_proc>
  while (1);
8114a6c8:	003fff06 	br	8114a6c8 <__reset+0xfb12a6c8>
