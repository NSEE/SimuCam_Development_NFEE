
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x000478e4 memsz 0x00061a54 flags rwx
    LOAD off    0x00049000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  00049000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000440f8  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000017bc  81144354  81144354  00045354  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  81145b10  81145b10  00046b10  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0001a170  81147904  81147904  00048904  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  81161a74  81161a74  00049000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  00049000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00049000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001c48  00000000  00000000  00049028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0005fc03  00000000  00000000  0004ac70  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0001425c  00000000  00000000  000aa873  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0001f55f  00000000  00000000  000beacf  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00009598  00000000  00000000  000de030  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000c87f  00000000  00000000  000e75c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    000260d4  00000000  00000000  000f3e47  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  00119f1c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00002288  00000000  00000000  00119f60  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  001283ed  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  001283f3  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  001283ff  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  00128400  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  00128401  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  00128405  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  00128409  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  0012840d  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  00128418  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  00128422  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  0012842c  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003f  00000000  00000000  0012843d  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     00226f57  00000000  00000000  0012847c  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
81144354 l    d  .rodata	00000000 .rodata
81145b10 l    d  .rwdata	00000000 .rwdata
81147904 l    d  .bss	00000000 .bss
81161a74 l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm_channel.c
81102ad0 l     F .text	00000050 uliCommReadReg
81102a7c l     F .text	00000054 vCommWriteReg
00000000 l    df *ABS*	00000000 data_packet.c
81103310 l     F .text	00000050 uliDpktReadReg
811032bc l     F .text	00000054 vDpktWriteReg
00000000 l    df *ABS*	00000000 fee_buffers.c
81147928 l     O .bss	00000004 viCh1HoldContext
8114792c l     O .bss	00000004 viCh2HoldContext
81147930 l     O .bss	00000004 viCh3HoldContext
81147934 l     O .bss	00000004 viCh4HoldContext
81147938 l     O .bss	00000004 viCh5HoldContext
8114793c l     O .bss	00000004 viCh6HoldContext
81147940 l     O .bss	00000004 viCh7HoldContext
81147944 l     O .bss	00000004 viCh8HoldContext
81104f54 l     F .text	00000054 vFeebWriteReg
81104fa8 l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
81147948 l     O .bss	00000004 viCh1HoldContext
8114794c l     O .bss	00000004 viCh2HoldContext
81147950 l     O .bss	00000004 viCh3HoldContext
81147954 l     O .bss	00000004 viCh4HoldContext
81147958 l     O .bss	00000004 viCh5HoldContext
8114795c l     O .bss	00000004 viCh6HoldContext
81147960 l     O .bss	00000004 viCh7HoldContext
81147964 l     O .bss	00000004 viCh8HoldContext
81108158 l     F .text	00000054 vRmapWriteReg
811081fc l     F .text	00000268 uliConvRmapCfgAddr
00000000 l    df *ABS*	00000000 spw_controller.c
81108b30 l     F .text	00000050 uliSpwcReadReg
81108adc l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
8114782c l     O .rwdata	00000001 ucIoValue
81108d30 l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
81109620 l     F .text	0000013c msgdma_write_extended_descriptor
8110975c l     F .text	00000164 msgdma_construct_extended_descriptor
811098c0 l     F .text	000002e0 msgdma_descriptor_async_transfer
81109ba0 l     F .text	0000038c msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8110a6ac l     F .text	00000054 vRstcWriteReg
8110a700 l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
8114796c l     O .bss	00000004 viHoldContext
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
81147974 l     O .bss	00000004 pxNFee.5670
81147978 l     O .bss	00000004 incrementador.5675
8114797c l     O .bss	00000004 tCodFeeTask.5673
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
81147982 l     O .bss	00000004 xRAckLocal.5601
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
81147988 l     O .bss	00000004 bDmaBack.5642
8114798c l     O .bss	00000001 ucWhoGetDMA.5643
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
8114798e l     O .bss	00000004 xSAckLocal.5586
00000000 l    df *ABS*	00000000 parser_comm_task.c
81147b04 l     O .bss	0000004c PreParsedLocal.5639
81147b50 l     O .bss	00000054 xTcPusL.5638
00000000 l    df *ABS*	00000000 receiver_uart_task.c
81147ba4 l     O .bss	0000004c xPreParsedReader.5631
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
81147bf0 l     O .bss	00000054 xPusLocal.5874
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
81144c27 l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 sync_handler.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 atoll.c
00000000 l    df *ABS*	00000000 ctype_.c
81144f53 l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 strtoll.c
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
8114511a l     O .rodata	00000010 zeroes.4389
8114512a l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
8114513a l     O .rodata	00000010 zeroes.4404
8111fb50 l     F .text	000000c4 __sbprintf
8114514a l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
81145162 l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
81121614 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
81123164 l     F .text	00000008 __fp_unlock
81123178 l     F .text	000001a4 __sinit.part.1
8112331c l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 impure.c
81145b10 l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
81145f54 l     O .rwdata	00000020 lc_ctype_charset
81145f34 l     O .rwdata	00000020 lc_message_charset
81145f74 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
811451a4 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 refill.c
81126764 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
81126d34 l     F .text	0000006c sulp
811452ec l     O .rodata	00000014 fpi.2737
81145300 l     O .rodata	00000028 tinytens
811452d8 l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
81145338 l     O .rodata	00000010 blanks.4332
81145328 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
8112a0bc l     F .text	00000104 __sprint_r.part.0
81145358 l     O .rodata	00000010 blanks.4348
81145348 l     O .rodata	00000010 zeroes.4349
8112b658 l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
8112bc34 l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
8112f09c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
8112f1e0 l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
8112f214 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
8112f498 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
8112f590 l       .text	00000000 tx_next_char
8112f5b8 l       .text	00000000 end_tx
8112f598 l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
81130094 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_read.c
81130310 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
81147874 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
811308b0 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
81147880 l     O .rwdata	00000004 lockid
81147a4c l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
81147884 l     O .rwdata	00000004 lockid
81147a54 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
8113233c l     F .text	00000050 OS_InitMisc
8113238c l     F .text	00000074 OS_InitRdyList
81132510 l     F .text	000000ec OS_InitTCBList
81132254 l     F .text	000000e8 OS_InitEventList
81132400 l     F .text	00000088 OS_InitTaskIdle
81132488 l     F .text	00000088 OS_InitTaskStat
811327a0 l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
811345b8 l     F .text	000000fc OS_FlagTaskRdy
81134368 l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
81135ea4 l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
8113a8d4 l     F .text	00000044 OSTmr_Lock
8113a374 l     F .text	00000074 OSTmr_Alloc
8113a918 l     F .text	0000003c OSTmr_Unlock
8113a7d8 l     F .text	000000fc OSTmr_Unlink
8113a3e8 l     F .text	000000a4 OSTmr_Free
8113a688 l     F .text	00000150 OSTmr_Link
8113a600 l     F .text	00000088 OSTmr_InitTask
8113a954 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
8113aa64 l     F .text	0000003c alt_dev_reg
811465f8 l     O .rwdata	0000106c jtag_uart_0
81147664 l     O .rwdata	000000d0 rs232_uart
81147734 l     O .rwdata	00000064 dma_DDR_M1
81147798 l     O .rwdata	00000064 dma_DDR_M2
811477fc l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
8113f2f4 l     F .text	000002bc altera_avalon_jtag_uart_irq
8113f5b0 l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
8113fdb4 l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
8114014c l     F .text	000000a4 altera_avalon_uart_irq
811401f0 l     F .text	00000140 altera_avalon_uart_rxirq
81140330 l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
81140538 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
811407ec l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
81140a70 l     F .text	00000044 alt_get_errno
81140ab4 l     F .text	0000009c alt_msgdma_write_standard_descriptor
81140b50 l     F .text	00000134 alt_msgdma_write_extended_descriptor
81140c84 l     F .text	0000018c alt_msgdma_irq
81140e10 l     F .text	00000094 alt_msgdma_construct_standard_descriptor
81140ea4 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
81141000 l     F .text	00000340 alt_msgdma_descriptor_async_transfer
81141340 l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
81141a48 l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
81141af4 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
81142cc0 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
81143110 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_open.c
81143260 l     F .text	00000044 alt_get_errno
811432a4 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
81147afc l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
81147b00 g     O .bss	00000004 alt_instruction_exception_handler
81105428 g     F .text	00000044 vRmapCh7IrqFlagClrWriteCmd
81148284 g     O .bss	00001000 vFeeTask0_stk
81116918 g     F .text	00000028 vFailDeleteInitialization
81115558 g     F .text	00000f30 vLoadDebugConfs
81147ad0 g     O .bss	00000004 aux_status_register
81149284 g     O .bss	00001000 vInAckHandlerTask_stk
81142a7c g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
81105770 g     F .text	00000050 uliRmapCh1WriteCmdAddress
8110ace0 g     F .text	0000004c vSyncInitIrq
811123e0 g     F .text	00000284 vCheckRetransmission128
81126078 g     F .text	0000007c _mprec_log10
8110aee8 g     F .text	00000040 bSyncSetMbt
81117204 g     F .text	00000030 vFailRequestDMAFromIRQ
81108f14 g     F .text	00000108 I2C_Read
811478d2 g     O .rwdata	00000002 OSTaskNameSize
81147998 g     O .bss	00000004 xWaitSyncQFee
8114a284 g     O .bss	00000260 xBuffer64
8112616c g     F .text	0000008c __any_on
8112c7d0 g     F .text	0000005c _isatty_r
811451b0 g     O .rodata	00000028 __mprec_tinytens
81105718 g     F .text	00000058 bRmapCh8IrqFlagWriteCmd
811301b4 g     F .text	0000015c alt_main
81104810 g     F .text	00000078 bFeebGetRightBufferEmpty
8111aea0 g     F .text	000000c8 _puts_r
81103a58 g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
81147a5c g     O .bss	00000004 OSTmrFreeList
81161974 g     O .bss	00000100 alt_irq
8112c82c g     F .text	00000068 _lseek_r
811182f0 g     F .text	00000030 vChangeDefaultAutoResetSync
81134e18 g     F .text	000000d4 OS_MemInit
811171d4 g     F .text	00000030 vFailRequestDMA
81104888 g     F .text	00000068 bFeebGetCh1LeftBufferEmpty
81114c20 g     F .text	00000938 vLoadDefaultETHConf
8110edd4 g     F .text	0000014c bCheckInAck64
8114a4e4 g     O .bss	00000150 xPus
811398b4 g     F .text	00000068 OSTimeSet
8111198c g     F .text	00000064 vPusType250run
81116f44 g     F .text	00000028 vCoudlNotCreateNFee2Task
811170dc g     F .text	00000028 vCouldNotGetMutexMebPus
8112ed40 g     F .text	00000088 .hidden __eqdf2
81111f68 g     F .text	00000088 vSendCmdQToDataCTRL
81101120 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
811181dc g     F .text	00000034 vLoadDefaultSyncSource
81116698 g     F .text	00000028 vFailCreateMutexDMA
8113af64 g     F .text	000001ac Check_for_Master_Boot_Record
8115b388 g     O .bss	00000010 OSTmrWheelTbl
81105810 g     F .text	00000050 uliRmapCh3WriteCmdAddress
81141808 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
8114a634 g     O .bss	00000020 xFeeQueueTBL3
81130fa0 g     F .text	00000594 OSEventPendMulti
8114799c g     O .bss	00000004 xNfeeSchedule
81161a74 g       *ABS*	00000000 __alt_heap_start
811439b4 g     F .text	0000002c OSTaskCreateHook
8113eddc g     F .text	000001c4 alt_up_sd_card_fclose
811479a0 g     O .bss	00000004 xSemCountBuffer64
81102840 g     F .text	0000016c bCommSetGlobalIrqEn
81105c14 g     F .text	00000088 bRmapGetIrqControl
8111ae5c g     F .text	00000044 printf
81147969 g     O .bss	00000001 SspdConfigControl
8110b304 g     F .text	00000054 bSyncCtrReset
811478aa g     O .rwdata	00000002 OSMboxEn
8110da3c g     F .text	0000026c vQCmdFeeRMAPWaitingSync
81118b1c g     F .text	000000a4 aatoh
81131598 g     F .text	00000054 OSIntEnter
8112cb2c g     F .text	000000a4 _wcrtomb_r
81103964 g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
811168c8 g     F .text	00000028 vFailReceiverCreate
811479a4 g     O .bss	00000004 xQMaskDataCtrl
811034b8 g     F .text	00000040 vFeebCh2HandleIrq
81126bec g     F .text	00000064 __sseek
811234cc g     F .text	00000010 __sinit
81109fec g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
8112c9cc g     F .text	00000148 __swbuf_r
81112bb8 g     F .text	00000470 bResourcesInitRTOS
8110867c g     F .text	000000f4 bSpwcGetLinkError
811478ba g     O .rwdata	00000002 OSQEn
8110d448 g     F .text	0000035c vQCmdFeeRMAPinStandBy
81105150 g     F .text	00000040 vRmapCh4HandleIrq
8112425c g     F .text	00000084 _setlocale_r
8114a654 g     O .bss	00000020 SyncTBL2
81147830 g     O .rwdata	00000004 LedsPainelControl
81123324 g     F .text	00000070 __sfmoreglue
8112a0a4 g     F .text	00000018 ungetc
81103c68 g     F .text	000000d4 bFeebCh1SetBufferSize
81130c5c g     F .text	000000d4 __malloc_unlock
8110141c g     F .text	00000214 DMA_MULTIPLE_TRANSFER
81143a34 g     F .text	00000028 OSTaskStatHook
81111dc4 g     F .text	00000088 vSendCmdQToNFeeCTRL
8111824c g     F .text	00000030 vChangeDefaultSyncSource
81147a60 g     O .bss	00000001 OSLockNesting
81147a64 g     O .bss	00000004 OSTmrSemSignal
811174a4 g     F .text	000001c8 vNFeeStructureInit
811479a8 g     O .bss	00000004 xSemCommInit
81100fa4 g     F .text	00000080 uliXorshift32
81126da0 g     F .text	00001600 _strtod_r
811479ac g     O .bss	00000004 xSemCountSenderACK
81118cb0 g     F .text	00000448 .hidden __divsf3
81147af4 g     O .bss	00000004 current_sector_modified
811478f8 g     O .rwdata	00000002 OSDataSize
81147a68 g     O .bss	00000001 OSRunning
81108958 g     F .text	00000184 bSpwcInitCh
8112fe7c g     F .text	00000064 alt_log_jtag_uart_isr_proc
8114a674 g     O .bss	00001000 senderTask_stk
81106708 g     F .text	00000094 bRmapGetMemConfigStat
8114b674 g     O .bss	00000048 xNfeeScheduleTBL
8110ec8c g     F .text	00000148 bCheckInAck128
81125040 g     F .text	0000015c memmove
81143ab0 g     F .text	0000002c OSInitHookBegin
8110b7a0 g     F .text	00000074 bSyncCtrCh8OutEnable
8110de14 g     F .text	00000098 bEnableDbBuffer
811478f0 g     O .rwdata	00000002 OSTmrSize
811234b4 g     F .text	00000018 _cleanup
81118694 g     F .text	00000040 siCloseFile
81104dd0 g     F .text	00000184 bFeebInitCh
8112519c g     F .text	000000b0 _Balloc
8111827c g     F .text	00000038 vLoadDefaultAutoResetSync
81105d24 g     F .text	000000d8 bRmapSetCodecConfig
8113d9b8 g     F .text	000000cc alt_up_sd_card_is_Present
81141748 g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
8114790c g     O .bss	00000004 pxDmaM1Dev
811011b8 g     F .text	000000a8 DMA_DISPATCHER_STOP
8113ac8c g     F .text	00000054 Save_Modified_Sector
81103bb8 g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
81147a6c g     O .bss	00000004 OSIdleCtr
81147a28 g     O .bss	00000001 alt_log_write_on_flag
81108b80 g     F .text	0000003c bEnableIsoDrivers
811195f4 g     F .text	000000dc .hidden __gtdf2
81143744 g     F .text	0000002c altera_nios2_gen2_irq_init
8114382c g       .text	00000000 OSStartTsk
8110b05c g     F .text	00000070 bSyncSetNCycles
81132b10 g     F .text	000002dc OS_TCBInit
81147a2b g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
81117e64 g     F .text	00000078 vInitSimucamBasicHW
8114b6bc g     O .bss	00001000 vTimeoutCheckerTask_stk
8110b6b8 g     F .text	00000074 bSyncCtrCh6OutEnable
81109290 g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
81147aec g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
81147a70 g     O .bss	00000002 OSTmrUsed
811479b0 g     O .bss	00000004 xSemCountBuffer128
81101828 g     F .text	000000f8 TEMP_Read
81105b6c g     F .text	000000a8 bRmapSetIrqControl
81103fb8 g     F .text	000000d4 bFeebCh5SetBufferSize
8114c6bc g     O .bss	00001000 vDataControlTask_stk
8110357c g     F .text	00000084 vFeebCh4HandleIrq
811478f6 g     O .rwdata	00000002 OSTmrWheelTblSize
81117b0c g     F .text	0000002c cFeeSpwChannelDisable
81147896 g     O .rwdata	00000002 OSEventSize
81147a72 g     O .bss	00000001 OSPrioHighRdy
8112bbd0 g     F .text	00000064 _fstat_r
811439e0 g     F .text	0000002c OSTaskDelHook
81147a1c g     O .bss	00000004 errno
8110ba94 g     F .text	0000003c uliSyncGetCtr
81121448 g     F .text	0000001c __svfscanf
81126b60 g     F .text	00000008 __seofread
8114380c g       .text	00000000 OSStartHighRdy
81117404 g     F .text	00000028 vEvtChangeFeeControllerMode
8110fa34 g     F .text	000000c8 bSendCmdQToNFeeInst
81105210 g     F .text	00000040 vRmapCh7HandleIrq
811382e4 g     F .text	000001ec OSTaskCreateExt
8115b35c g     O .bss	00000011 alt_log_write_buf
81102d4c g     F .text	0000012c bDpktGetPacketConfig
811059a0 g     F .text	00000050 uliRmapCh8WriteCmdAddress
81116a58 g     F .text	00000028 vFailGetCountSemaphorePreParsedBuffer
81128be8 g     F .text	00001244 ___svfiprintf_internal_r
81110e58 g     F .text	00000330 bPreParserV2
81133e98 g     F .text	00000068 OSFlagPendGetFlagsRdy
811478d6 g     O .rwdata	00000002 OSTaskStatStkSize
811049c0 g     F .text	00000068 bFeebGetCh2RightBufferEmpty
81132fe4 g     F .text	00000310 OSFlagAccept
811365c0 g     F .text	000000c0 OSQFlush
8114806c g     O .bss	00000118 xRmap
8113603c g     F .text	00000148 OSQAccept
81147a3c g     O .bss	00000004 alt_argv
8114f828 g       *ABS*	00000000 _gp
81116760 g     F .text	00000028 vFailSendPreAckReceiverSemaphore
81130774 g     F .text	0000013c usleep
8113df90 g     F .text	00000384 alt_up_sd_card_fopen
81118578 g     F .text	00000030 bSDcardIsPresent
81111188 g     F .text	000000d0 vSenderComTask
8113daf8 g     F .text	000000d8 alt_up_sd_card_find_first
81138130 g     F .text	000001b4 OSTaskCreate
81116af8 g     F .text	00000028 vFailSendNack
81147ae0 g     O .bss	00000004 command_argument_register
81137c38 g     F .text	000004f8 OSTaskChangePrio
81111654 g     F .text	00000090 vPusMebInTaskConfigMode
81116e18 g     F .text	0000002c vCouldNotSendTMPusCommand
81147a58 g     O .bss	00000004 alt_heapsem
811179ac g     F .text	000000b0 vResetMemCCDFEE
81109528 g     F .text	00000080 bSetBoardLeds
81132dec g     F .text	000001f8 OSDebugInit
811384d0 g     F .text	0000034c OSTaskDel
81134eec g     F .text	000001ac OSMutexAccept
8114d6bc g     O .bss	000002b8 xSimMeb
81117d48 g     F .text	00000040 vSetTimeCode
811422f0 g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
811479b4 g     O .bss	00000004 xSemCountPreParsed
811463dc g     O .rwdata	00000180 alt_fd_list
81103b08 g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
81146578 g     O .rwdata	0000001d alt_log_msg_alt_main
8115b398 g     O .bss	00000840 OSFlagTbl
811054b0 g     F .text	00000058 bRmapCh1IrqFlagWriteCmd
81116800 g     F .text	00000028 vFailGetCountSemaphoreReceiverTask
811058b0 g     F .text	00000050 uliRmapCh5WriteCmdAddress
81118134 g     F .text	0000003c vLoadDefaultRTValue
8113201c g     F .text	000000c0 OS_EventTaskRemove
8114d974 g     O .bss	00001000 vFeeTask5_stk
81147a2a g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
8113d20c g     F .text	00000134 find_first_empty_record_in_root_directory
81142db0 g     F .text	00000098 alt_find_dev
8111abac g     F .text	00000150 memcpy
8112c56c g     F .text	00000264 __hexnan
81103148 g     F .text	00000174 bDpktInitCh
8114e974 g     O .bss	00000160 xBuffer32
811478c0 g     O .rwdata	00000002 OSRdyTblSize
8115bbd8 g     O .bss	000001a0 OSTmrTbl
8112316c g     F .text	0000000c _cleanup_r
8111a774 g     F .text	000000e4 .hidden __floatsidf
81114848 g     F .text	000001a8 vSendPusTM64
8110ae58 g     F .text	0000004c ucSyncStatusErrorCode
81111ed4 g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
81117c08 g     F .text	00000034 cFeeRMAPLogDisable
8110fe84 g     F .text	00000708 vParserCommTask
811431dc g     F .text	00000084 alt_io_redirect
81117b9c g     F .text	00000034 cFeeRMAPEchoingDisable
8112edc8 g     F .text	000000f4 .hidden __ltdf2
8111708c g     F .text	00000028 vFailSendPUStoMebTask
811056c0 g     F .text	00000058 bRmapCh7IrqFlagWriteCmd
81104484 g     F .text	000000d4 bFeebSetIrqControl
81116d50 g     F .text	00000028 vCouldNotRetransmitB128TimeoutTask
811479b8 g     O .bss	00000004 xMutexReceivedACK
81101ec4 g     F .text	000000c4 bSdmaInitM2Dma
81147924 g     O .bss	00000004 EDpktMode
81142778 g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
81142ac0 g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
8110b3ac g     F .text	00000054 bSyncCtrErrInj
81142a20 g     F .text	0000005c alt_msgdma_register_callback
81117edc g     F .text	00000030 bLogWriteSDCard
81116968 g     F .text	00000028 vFailSetCountSemaphorexBuffer64
8111af68 g     F .text	00000014 puts
81118714 g     F .text	00000188 bInitSync
81143d4c g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8110aba8 g     F .text	0000010c vSyncHandleIrq
81130d30 g     F .text	00000128 OSEventNameGet
811037cc g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
811478a4 g     O .rwdata	00000002 OSFlagMax
81124dcc g     F .text	000000e0 mbrtowc
8113ce04 g     F .text	000001b4 find_first_empty_cluster
81111ff0 g     F .text	00000088 vSendCmdQToDataCTRL_PRIO
8110b644 g     F .text	00000074 bSyncCtrCh5OutEnable
81147970 g     O .bss	00000001 vucN
8112695c g     F .text	00000074 __fpclassifyd
8110adb8 g     F .text	00000054 bSyncStatusExtnIrq
81121464 g     F .text	00000054 _vfscanf_r
8113556c g     F .text	000005a4 OSMutexPend
81125fcc g     F .text	000000ac __ratio
8113d8f4 g     F .text	000000c4 alt_up_sd_card_open_dev
81116e44 g     F .text	00000028 vWarnCouldNotgetMutexRetrans128
811315ec g     F .text	00000100 OSIntExit
8110af28 g     F .text	00000040 bSyncSetBt
8112b63c g     F .text	0000001c __vfiprintf_internal
81117104 g     F .text	00000028 vCouldNotCreateQueueMaskNfeeCtrl
811478de g     O .rwdata	00000002 OSTCBSize
81103788 g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
81147a73 g     O .bss	00000001 OSPrioCur
8113f824 g     F .text	000002c4 altera_avalon_jtag_uart_read
81141fb8 g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
8111ae24 g     F .text	00000038 _printf_r
8112d8e4 g     F .text	00000064 .hidden __udivsi3
8112f4dc g     F .text	000000ac isatty
81147968 g     O .bss	00000001 LedsBoardControl
811479bc g     O .bss	00000004 xSemCountReceivedACK
811478c4 g     O .rwdata	00000002 OSStkWidth
8112422c g     F .text	00000030 iswspace
81145200 g     O .rodata	000000c8 __mprec_tens
811478b8 g     O .rwdata	00000002 OSPtrSize
81117234 g     F .text	00000030 vFailSendRMAPFromIRQ
81116fe4 g     F .text	00000028 vCoudlNotCreateNFeeControllerTask
811242e0 g     F .text	0000000c __locale_charset
8110b55c g     F .text	00000074 bSyncCtrCh3OutEnable
8111b450 g     F .text	0000001c strtoll
8112dad4 g     F .text	000000c8 .hidden __lesf2
81147898 g     O .rwdata	00000002 OSEventTblSize
81118c34 g     F .text	0000007c .hidden __fixunsdfsi
81143770 g       .text	00000000 OSCtxSw
8110901c g     F .text	00000160 I2C_MultipleRead
81130020 g     F .text	00000074 alt_log_system_clock
81147a18 g     O .bss	00000004 __malloc_top_pad
81147a74 g     O .bss	00000004 OSTCBList
8113a334 g     F .text	00000040 OSTmrSignal
81147a20 g     O .bss	00000004 alt_fd_list_lock
81128714 g     F .text	0000001c strtoul
81147840 g     O .rwdata	00000004 __mb_cur_max
81124310 g     F .text	0000000c _localeconv_r
81128730 g     F .text	000002e0 _strtoull_r
8110a63c g     F .text	00000070 vRstcHoldDeviceReset
811255c0 g     F .text	00000044 __i2b
81123bd0 g     F .text	000004c4 __sfvwrite_r
8113c0e4 g     F .text	000000c0 get_dir_divider_location
8110535c g     F .text	00000044 vRmapCh4IrqFlagClrWriteCmd
8115bd78 g     O .bss	00000c30 OSMemTbl
81147a78 g     O .bss	00000001 OSTickStepState
8112fc30 g     F .text	00000060 alt_log_printf_proc
81103084 g     F .text	000000c4 bDpktGetPixelDelay
8114ead4 g     O .bss	00001800 vReceiverUartTask_stk
811269d0 g     F .text	0000005c _sbrk_r
811479c0 g     O .bss	00000004 xSemTimeoutChecker
8113bda4 g     F .text	000000cc filename_to_upper_case
81147a2c g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
811478bc g     O .rwdata	00000002 OSQMax
8113e314 g     F .text	00000090 alt_up_sd_card_set_attributes
81135268 g     F .text	00000304 OSMutexDel
8115c9a8 g     O .bss	00001000 OSTaskStatStk
811185a8 g     F .text	00000030 bSDcardFAT16Check
81134a34 g     F .text	000000f8 OSMemNameGet
81116668 g     F .text	00000030 vFailCreateMutexSResources
8113b110 g     F .text	00000284 Read_File_Record_At_Offset
811502d4 g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
8114789c g     O .rwdata	00000002 OSFlagEn
8112c894 g     F .text	00000068 _read_r
811478e2 g     O .rwdata	00000002 OSTimeTickHookEn
811346b4 g     F .text	000000ac OS_FlagUnlink
81136a88 g     F .text	00000170 OSQPost
81100dd4 g     F .text	000001d0 bDdr2MemoryRandomReadTest
81147864 g     O .rwdata	00000004 alt_max_fd
81116c60 g     F .text	00000028 vFailTimeoutCheckerTaskCreate
81132658 g     F .text	00000070 OS_MemCopy
811326c8 g     F .text	000000d8 OS_Sched
8113c988 g     F .text	0000047c find_file_in_directory
8112b8ac g     F .text	000000f8 _fclose_r
8113493c g     F .text	000000f8 OSMemGet
81138b14 g     F .text	000001bc OSTaskNameSet
81123134 g     F .text	00000030 fflush
81147a14 g     O .bss	00000004 __malloc_max_sbrked_mem
81147a7c g     O .bss	00000004 OSCtxSwCtr
8110408c g     F .text	000000d4 bFeebCh6SetBufferSize
81143a5c g     F .text	00000054 OSTimeTickHook
81150314 g     O .bss	00001000 vOutAckHandlerTask_stk
8112f310 g     F .text	00000188 alt_irq_register
811478a6 g     O .rwdata	00000002 OSFlagNameSize
8111a858 g     F .text	00000118 .hidden __extendsfdf2
811320dc g     F .text	00000108 OS_EventTaskRemoveMulti
81116ec4 g     F .text	00000030 vFailCreateNFEESyncQueue
8113da84 g     F .text	00000074 alt_up_sd_card_is_FAT16
81108dac g     F .text	00000088 I2C_TestAdress
8112db9c g     F .text	000008b4 .hidden __adddf3
8115b370 g     O .bss	00000018 alt_log_jtag_uart_alarm_1
8112d9a0 g     F .text	00000078 .hidden __nesf2
81105318 g     F .text	00000044 vRmapCh3IrqFlagClrWriteCmd
811033ec g     F .text	0000008c usiLineTrDelayCalcPeriodNs
81131ec4 g     F .text	00000158 OS_EventTaskWaitMulti
81151314 g     O .bss	00000020 SyncTBL4
81125d64 g     F .text	00000114 __b2d
81141cf0 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
811478be g     O .rwdata	00000002 OSQSize
8112d2ac g     F .text	00000540 .hidden __umoddi3
811300d8 g     F .text	000000dc lseek
81137578 g     F .text	00000214 OSSemPend
811170b4 g     F .text	00000028 vCouldNotGetCmdQueueMeb
81105e88 g     F .text	00000160 bRmapGetCodecStatus
81108770 g     F .text	000000d0 bSpwcGetLinkStatus
81104bb0 g     F .text	00000088 bFeebGetWindowing
81147838 g     O .rwdata	00000004 _global_impure_ptr
8110ab5c g     F .text	0000004c bSSDisplayUpdate
8111aba0 g     F .text	0000000c _atoll_r
8113c448 g     F .text	00000540 get_home_directory_cluster_for_file
811261f8 g     F .text	0000056c _realloc_r
811478a8 g     O .rwdata	00000002 OSLowestPrio
81161a74 g       *ABS*	00000000 __bss_end
81143018 g     F .text	000000f8 alt_iic_isr_register
81143b2c g     F .text	0000002c OSTCBInitHook
811478ee g     O .rwdata	00000002 OSTmrCfgTicksPerSec
81130664 g     F .text	00000110 alt_tick
811059f0 g     F .text	0000017c vRmapInitIrq
811167d8 g     F .text	00000028 vFailGetMutexSenderTask
8110a55c g     F .text	0000006c vRstcSimucamReset
8110df18 g     F .text	000000a4 bSendRequestNFeeCtrl
81145368 g     O .rodata	00000100 __hexdig
8114286c g     F .text	000001b4 alt_msgdma_init
8112cd2c g     F .text	00000580 .hidden __udivdi3
81110b60 g     F .text	0000017c setPreAckSenderFreePos
8112bb24 g     F .text	00000024 _fputwc_r
81147890 g     O .rwdata	00000002 OSEventEn
811451d8 g     O .rodata	00000028 __mprec_bigtens
8112539c g     F .text	0000010c __s2b
811478ea g     O .rwdata	00000002 OSTmrCfgNameSize
81151334 g     O .bss	00000020 xFeeQueueTBL4
8110afe8 g     F .text	00000074 bSyncSetPolarity
81112664 g     F .text	0000028c vCheckRetransmission64
8112eebc g     F .text	000000b0 .hidden __floatunsidf
81147a30 g     O .bss	00000004 alt_system_clock_in_sec
8112fe28 g     F .text	00000054 alt_log_jtag_uart_startup_info
81116a30 g     F .text	00000028 vFailFoundBufferRetransmission
81125a9c g     F .text	00000060 __mcmp
81147af8 g     O .bss	00000004 current_sector_index
8113ffe4 g     F .text	00000168 altera_avalon_uart_init
81142b48 g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
811023e0 g     F .text	00000460 bSdmaDmaM2Transfer
81117d88 g     F .text	00000034 vResetTimeCode
81117ae0 g     F .text	0000002c cFeeSpwChannelEnable
811234ec g     F .text	00000018 __fp_lock_all
81117314 g     F .text	00000028 vFailSendMsgDataCTRL
81142fc4 g     F .text	00000054 alt_ic_irq_enabled
81108e34 g     F .text	000000e0 I2C_Write
81105560 g     F .text	00000058 bRmapCh3IrqFlagWriteCmd
81147a80 g     O .bss	00000002 OSTmrFree
811344d0 g     F .text	000000e8 OS_FlagInit
811305c0 g     F .text	000000a4 alt_alarm_stop
8111b434 g     F .text	0000001c strtol
81147a29 g     O .bss	00000001 alt_log_sys_clk_on_flag
81139ae0 g     F .text	00000140 OSTmrDel
8113ae7c g     F .text	000000e8 mark_cluster
811478cc g     O .rwdata	00000002 OSTaskIdleStkSize
81147a24 g     O .bss	00000004 alt_irq_active
81137198 g     F .text	000000b8 OSSemAccept
81113470 g     F .text	000001e8 vFillMemmoryPattern
8111b1b0 g     F .text	00000044 strnlen
81134c48 g     F .text	000000e0 OSMemPut
81134760 g     F .text	000001dc OSMemCreate
81147a84 g     O .bss	00000004 OSIdleCtrMax
811149f0 g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
8112f678 g     F .text	000005b8 alt_log_private_printf
811463b4 g     O .rwdata	00000028 alt_dev_null
81141900 g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
8110afa8 g     F .text	00000040 bSyncSetOst
811478e0 g     O .rwdata	00000002 OSTicksPerSec
8114655c g     O .rwdata	00000019 alt_log_msg_bss
8113d340 g     F .text	00000194 convert_filename_to_name_extension
8110679c g     F .text	0000104c bRmapSetRmapMemHKArea
81104a28 g     F .text	000000e0 bFeebSetBufferSize
81111258 g     F .text	000002a0 vSimMebTask
8110917c g     F .text	00000094 i2c_start
81143770 g       .text	00000000 OSIntCtxSw
81117264 g     F .text	00000030 vFailSendMsgSync
8110b5d0 g     F .text	00000074 bSyncCtrCh4OutEnable
811426e4 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
8112f1b8 g     F .text	00000028 alt_dcache_flush_all
811254a8 g     F .text	00000068 __hi0bits
811119f0 g     F .text	000000f0 vPusType251run
81105900 g     F .text	00000050 uliRmapCh6WriteCmdAddress
81118170 g     F .text	0000003c vChangeRTValue
81147acc g     O .bss	00000004 is_sd_card_formated_as_FAT16
81112274 g     F .text	0000016c vCheck
81117454 g     F .text	00000050 vNFeeNotInUse
8111a6f4 g     F .text	00000080 .hidden __fixdfsi
8110fafc g     F .text	000000c8 bSendCmdQToNFeeInst_Prio
81104234 g     F .text	000000d4 bFeebCh8SetBufferSize
81104cc0 g     F .text	00000088 bFeebStopCh
8110bbc0 g     F .text	00000084 uliPerCalcPeriodMs
8110f540 g     F .text	0000037c vNFeeControlTask
81151354 g     O .bss	00001000 vInitialTask_stk
811479c4 g     O .bss	00000002 usiIdCMD
81152354 g     O .bss	00000020 SyncTBL3
8110b2b0 g     F .text	00000054 bSyncCtrStart
8113cfb8 g     F .text	00000254 find_first_empty_record_in_a_subdirectory
811283a0 g     F .text	00000018 strtod
81104d48 g     F .text	00000088 bFeebClrCh
81147a88 g     O .bss	00000004 OSTCBFreeList
81105668 g     F .text	00000058 bRmapCh6IrqFlagWriteCmd
8113778c g     F .text	00000174 OSSemPendAbort
81116878 g     F .text	00000028 vFailGetMacRTC
81105860 g     F .text	00000050 uliRmapCh4WriteCmdAddress
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
81116c10 g     F .text	00000028 vFailCreateTimerRetransmisison
81116a08 g     F .text	00000028 vFailGetCountSemaphorexBuffer32
81113960 g     F .text	000002b8 bSendUART128v2
81117fa4 g     F .text	000000ec vSimucamStructureInit
8114785c g     O .rwdata	00000008 alt_dev_list
811308f4 g     F .text	0000010c write
81143eac g     F .text	000000a8 _putc_r
81147af0 g     O .bss	00000004 device_pointer
811478e4 g     O .rwdata	00000002 OSVersionNbr
8112da18 g     F .text	000000bc .hidden __gtsf2
8111738c g     F .text	00000028 vFailFlushMEBQueue
8111058c g     F .text	00000118 getPreParsedPacket
8110ddb4 g     F .text	00000060 bEnableSPWChannel
8112f258 g     F .text	000000b8 fstat
81117df0 g     F .text	00000040 vChangeIdNFEEMaster
81117bd0 g     F .text	00000038 cFeeRMAPLogEnable
81101308 g     F .text	00000114 DMA_SINGLE_TRANSFER
81103b60 g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
81116cb0 g     F .text	00000028 vFailPostBlockingSemTimeoutTask
8111899c g     F .text	00000058 _reg_write
81117e30 g     F .text	00000034 vChangeDefaultIdNFEEMaster
8112edc8 g     F .text	000000f4 .hidden __ledf2
81105190 g     F .text	00000040 vRmapCh5HandleIrq
8110dca8 g     F .text	00000054 bDisableRmapIRQ
81152374 g     O .bss	00001000 vStackMonitor_stk
81116df0 g     F .text	00000028 vCouldNotSendLog
81139d60 g     F .text	000001b8 OSTmrRemainGet
8114788c g     O .rwdata	00000004 OSEndiannessTest
8110a750 g     F .text	00000058 v_spi_start
81125804 g     F .text	00000148 __pow5mult
811057c0 g     F .text	00000050 uliRmapCh2WriteCmdAddress
8112a1d8 g     F .text	00001464 ___vfiprintf_internal_r
81147a0c g     O .bss	00000004 __nlocale_changed
8112d948 g     F .text	00000058 .hidden __umodsi3
8110b400 g     F .text	00000074 bSyncCtrSyncOutEnable
811185d8 g     F .text	00000080 bInitializeSDCard
81116b98 g     F .text	00000028 vFailParserCommTaskCreate
81116dc8 g     F .text	00000028 vCouldNotSendReset
8111afc0 g     F .text	00000038 _scanf_r
81116be8 g     F .text	00000028 vFailOutAckHandlerTaskCreate
8114789e g     O .rwdata	00000002 OSFlagGrpSize
811116e4 g     F .text	00000064 vPusType250conf
81153374 g     O .bss	00000058 xInUseRetrans
8110ad68 g     F .text	00000050 bSyncIrqFlagSync
81141d50 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
81139f18 g     F .text	000000ec OSTmrStateGet
81161a74 g       *ABS*	00000000 end
81103684 g     F .text	00000084 vFeebCh6HandleIrq
81113658 g     F .text	000001e8 vPrintMemmoryPattern
81116aa8 g     F .text	00000028 vNoContentInPreParsedBuffer
811106a4 g     F .text	00000168 bSendMessagePUStoMebTask
81116e94 g     F .text	00000030 vFailCreateNFEEQueue
8111ab88 g     F .text	0000000c _atoi_r
81140830 g     F .text	00000240 altera_avalon_uart_write
8112f5bc g     F .text	00000054 alt_log_txchar
811138d0 g     F .text	00000090 vCCDChangeValues
8113f124 g     F .text	000001d0 altera_avalon_jtag_uart_init
81132958 g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
811166e8 g     F .text	00000028 vFailTestCriticasParts
811fa000 g       *ABS*	00000000 __alt_stack_pointer
81100bf4 g     F .text	000001e0 bDdr2MemoryRandomWriteTest
8113fe38 g     F .text	00000084 alt_avalon_timer_sc_init
81104b08 g     F .text	000000a8 bFeebSetWindowing
8113ff24 g     F .text	00000068 altera_avalon_uart_write_fd
8111ab18 g     F .text	00000064 .hidden __clzsi2
8113ff8c g     F .text	00000058 altera_avalon_uart_close_fd
811533cc g     O .bss	00000020 xMebQTBL
8113fae8 g     F .text	000002cc altera_avalon_jtag_uart_write
8113a48c g     F .text	00000174 OSTmr_Init
811533ec g     O .bss	00000348 xBuffer128
811234dc g     F .text	00000004 __sfp_lock_acquire
81101920 g     F .text	00000048 sense_log_temp
81124f5c g     F .text	000000e4 memchr
811325fc g     F .text	0000005c OS_MemClr
8111d934 g     F .text	00002200 ___vfprintf_internal_r
81143850 g     F .text	00000164 OSTaskStkInit
8111aff8 g     F .text	00000060 _sprintf_r
81106434 g     F .text	000002d4 bRmapGetMemConfigArea
811479c6 g     O .bss	00000001 SemCount32
811238b8 g     F .text	00000318 _free_r
811434cc g     F .text	00000234 alt_printf
811147f8 g     F .text	00000050 vTimeoutCheck
81118a4c g     F .text	0000005c _print_codec_status
811242ec g     F .text	00000010 __locale_mb_cur_max
81131c0c g     F .text	000001a0 OS_EventTaskRdy
81105c9c g     F .text	00000088 bRmapGetIrqFlags
81101260 g     F .text	000000a8 DMA_DISPATCHER_RESET
81144110 g     F .text	00000188 __call_exitprocs
8110f940 g     F .text	000000f4 vPerformActionNFCRunning
81147a8c g     O .bss	00000001 OSCPUUsage
81116f94 g     F .text	00000028 vCoudlNotCreateNFee4Task
81147a08 g     O .bss	00000004 __mlocale_changed
8110f8bc g     F .text	00000084 vPerformActionNFCConfig
8110b358 g     F .text	00000054 bSyncCtrOneShot
81147844 g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
8110bad0 g     F .text	0000003c uliSyncReadStatus
81147a44 g     O .bss	00000004 _alt_tick_rate
81136680 g     F .text	00000294 OSQPend
8111b46c g     F .text	000002e8 _strtoll_r
81153734 g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
8115b2fc g     O .bss	00000044 xDefaults
81139404 g     F .text	0000010c OSTimeDly
811118fc g     F .text	00000090 vPusMebInTaskRunningMode
8110ad2c g     F .text	0000003c vSyncIrqFlagClrSync
8112594c g     F .text	00000150 __lshift
8110fbc4 g     F .text	000002c0 vOutAckHandlerTask
811417a8 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
81147a48 g     O .bss	00000004 _alt_nticks
81130354 g     F .text	00000104 read
8113aae0 g     F .text	000000f0 alt_sys_init
811052d4 g     F .text	00000044 vRmapCh2IrqFlagClrWriteCmd
81128a10 g     F .text	000001d8 __ssprint_r
8111893c g     F .text	00000060 bTestSimucamCriticalHW
8110468c g     F .text	0000010c bFeebGetBuffersStatus
81116488 g     F .text	000000a4 ucCrc8
811004b8 g     F .text	00000104 bDdr2EepromDump
81147a8d g     O .bss	00000001 OSTaskCtr
8112f588 g       .text	00000000 tx_log_str
811114f8 g     F .text	0000015c vPusMebTask
811147a8 g     F .text	00000050 siPosStr
81111e4c g     F .text	00000088 vSendCmdQToNFeeCTRL_PRIO
8112c8fc g     F .text	000000d0 strncmp
8110bb0c g     F .text	0000005c bSyncWriteReg
81105610 g     F .text	00000058 bRmapCh5IrqFlagWriteCmd
81139510 g     F .text	00000164 OSTimeDlyHMSM
81125604 g     F .text	00000200 __multiply
8113f6bc g     F .text	00000070 altera_avalon_jtag_uart_close
8110a920 g     F .text	00000058 v_spi_end
811186d4 g     F .text	00000040 cGetNextChar
81144024 g     F .text	000000ec strncpy
81147c44 g     O .bss	00000028 __malloc_current_mallinfo
81147892 g     O .rwdata	00000002 OSEventMax
8112d9a0 g     F .text	00000078 .hidden __eqsf2
81125e78 g     F .text	00000154 __d2b
81137900 g     F .text	00000118 OSSemPost
81103854 g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
811181ac g     F .text	00000030 vChangeDefaultRTValue
81103748 g     F .text	00000040 vFeebCh8HandleIrq
81147ac8 g     O .bss	00000004 initialized
81114658 g     F .text	00000100 vSendLog
81131780 g     F .text	000000e4 OSSchedUnlock
8110a978 g     F .text	00000114 RTCC_SPI_R_MAC
81147870 g     O .rwdata	00000004 alt_log_boot_on_flag
8113efa0 g     F .text	00000068 altera_avalon_jtag_uart_read_fd
811284c0 g     F .text	00000254 _strtoul_r
81153774 g     O .bss	00000020 xFeeQueueTBL5
81143c68 g     F .text	000000e4 alt_get_fd
81147a90 g     O .bss	00000004 OSMemFreeList
811318dc g     F .text	000000b8 OSStatInit
81118908 g     F .text	00000034 bClearCounterSync
81101024 g     F .text	00000064 DMA_OPEN_DEVICE
8116140c g     O .bss	00000014 search_data
81108464 g     F .text	00000134 bSpwcSetLink
8112ef6c g     F .text	00000130 alt_busy_sleep
8113429c g     F .text	000000cc OSFlagQuery
8110b474 g     F .text	00000074 bSyncCtrCh1OutEnable
811478c8 g     O .rwdata	00000002 OSTaskCreateExtEn
81118aa8 g     F .text	00000074 _split_codec_status
8112b784 g     F .text	0000005c _close_r
81116ad0 g     F .text	00000028 vCouldNotSendEthConfUART
8110f06c g     F .text	000004d4 vInitialTask
8112fd30 g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
81141c90 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
81143e30 g     F .text	0000007c memcmp
81131be4 g     F .text	00000028 OS_Dummy
8113f070 g     F .text	00000058 altera_avalon_jtag_uart_close_fd
81161a74 g       *ABS*	00000000 __alt_stack_base
81104160 g     F .text	000000d4 bFeebCh7SetBufferSize
8113f0c8 g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
81103898 g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
81112180 g     F .text	000000a4 vReleaseSyncMessages
81141db0 g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
811039a8 g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
811214b8 g     F .text	0000015c __swsetup_r
8115d9a8 g     O .bss	00000300 OSQTbl
81117154 g     F .text	00000028 vCouldNotGetQueueMaskNfeeCtrl
8115b340 g     O .bss	0000001c xConfEth
8112e450 g     F .text	000008f0 .hidden __divdf3
81118210 g     F .text	0000003c vChangeSyncSource
81123394 g     F .text	00000120 __sfp
81161420 g     O .bss	00000054 boot_sector_data
8111712c g     F .text	00000028 vCouldNotCreateQueueMaskDataCtrl
811088d0 g     F .text	00000088 bSpwcClearTimecode
8110116c g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
811260f4 g     F .text	00000078 __copybits
81145fac g     O .rwdata	00000408 __malloc_av_
811234e8 g     F .text	00000004 __sinit_lock_release
81147904 g     O .bss	00000004 uliInitialState
81109210 g     F .text	00000080 i2c_stop
81118bc0 g     F .text	00000040 Verif_Error
81118c00 g     F .text	00000034 toInt
81116788 g     F .text	00000028 vFailSendPreAckSenderSemaphore
81147a94 g     O .bss	00000004 OSTCBHighRdy
811196d0 g     F .text	00000720 .hidden __muldf3
81126b04 g     F .text	0000005c __sread
81123750 g     F .text	0000003c fread
81147a98 g     O .bss	00000004 OSQFreeList
81143b58 g     F .text	00000110 alt_find_file
81142d04 g     F .text	000000ac alt_dev_llist_insert
81130b34 g     F .text	00000128 __malloc_lock
811304c4 g     F .text	000000fc sbrk
81117a5c g     F .text	0000002c vFeeSpwRMAPLoadDefault
811169e0 g     F .text	00000028 vFailGetCountSemaphorexBuffer64
8111b754 g     F .text	000021e0 ___svfprintf_internal_r
81114b98 g     F .text	00000088 vTMPusTestConnection
811479c8 g     O .bss	00000004 xMebQ
81130e58 g     F .text	00000148 OSEventNameSet
811230d0 g     F .text	00000064 _fflush_r
8112b7e0 g     F .text	000000cc _calloc_r
81147a9c g     O .bss	00000001 OSRdyGrp
811172ec g     F .text	00000028 vFailSendMsgFeeCTRL
8110aea4 g     F .text	00000044 ucSyncStatusCycleNumber
81105dfc g     F .text	0000008c bRmapGetCodecConfig
8113a004 g     F .text	00000148 OSTmrStart
81103600 g     F .text	00000084 vFeebCh5HandleIrq
81101088 g     F .text	0000004c DMA_CONFIG
81147904 g       *ABS*	00000000 __bss_start
81103ee4 g     F .text	000000d4 bFeebCh4SetBufferSize
8111acfc g     F .text	00000128 memset
81110a24 g     F .text	0000013c setPreParsedFreePos
8110d0f4 g     F .text	00000190 vQCmdFEEinStandBy
8114280c g     F .text	00000060 alt_msgdma_open
81118368 g     F .text	00000210 pattern_createPattern
8111333c g     F .text	00000134 main
81116828 g     F .text	00000028 vFailGetMutexReceiverTask
81153794 g     O .bss	00001000 vNFeeControlTask_stk
8110546c g     F .text	00000044 vRmapCh8IrqFlagClrWriteCmd
811180c8 g     F .text	0000003c vChangeEPValue
811055b8 g     F .text	00000058 bRmapCh4IrqFlagWriteCmd
81147a40 g     O .bss	00000004 alt_envp
8111733c g     F .text	00000028 vFailFlushQueue
81147a10 g     O .bss	00000004 __malloc_max_total_mem
811420b0 g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
8111652c g     F .text	0000005c ucCrc8wInit
81116c38 g     F .text	00000028 vCouldNotCheckBufferTimeOutFunction
8113f008 g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81101630 g     F .text	000001f8 POWER_Read
811093c8 g     F .text	00000160 i2c_read
81154794 g     O .bss	00000020 SyncTBL5
8112cb14 g     F .text	00000018 __swbuf
81145668 g     O .rodata	00000100 OSUnMapTbl
8112dad4 g     F .text	000000c8 .hidden __ltsf2
8113e3a4 g     F .text	00000090 alt_up_sd_card_get_attributes
8112351c g     F .text	00000234 _fread_r
811167b0 g     F .text	00000028 vFailGetCountSemaphoreSenderTask
81108bbc g     F .text	0000003c bDisableIsoDrivers
811478c2 g     O .rwdata	00000002 OSSemEn
8113abd0 g     F .text	000000bc Write_Sector_Data
8113e7b4 g     F .text	00000628 alt_up_sd_card_write
811479cc g     O .bss	00000004 xFeeQ
811048f0 g     F .text	00000068 bFeebGetCh1RightBufferEmpty
81133f00 g     F .text	0000039c OSFlagPost
81126c50 g     F .text	00000008 __sclose
81116d78 g     F .text	00000028 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
8112b9a4 g     F .text	00000014 fclose
81131dac g     F .text	00000118 OS_EventTaskWait
81116d00 g     F .text	00000028 vCouldNotRetransmitB32TimeoutTask
8111b1f4 g     F .text	00000240 _strtol_r
8111a970 g     F .text	000001a8 .hidden __truncdfsf2
811547b4 g     O .bss	00000020 xFeeQueueTBL2
81132a3c g     F .text	000000d4 OS_TaskStatStkChk
8113881c g     F .text	00000158 OSTaskDelReq
81102e78 g     F .text	000000c4 bDpktGetPacketHeader
81104ff8 g     F .text	0000008c vRmapCh1HandleIrq
8112181c g     F .text	00001690 _dtoa_r
811423cc g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
81124504 g     F .text	00000814 _malloc_r
811547d4 g     O .bss	00000020 SyncTBL0
8112cc98 g     F .text	00000030 __ascii_wctomb
81135098 g     F .text	000001d0 OSMutexCreate
81116cd8 g     F .text	00000028 vFailCouldNotRetransmitTimeoutTask
8110ef20 g     F .text	0000014c bCheckInAck32
81147868 g     O .rwdata	00000004 alt_errno
81141ef8 g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
81131864 g     F .text	00000078 OSStart
81108598 g     F .text	000000e4 bSpwcGetLink
8110a074 g     F .text	000004e8 POWER_SPI_RW
81129e2c g     F .text	000000dc __submore
8112fc90 g     F .text	000000a0 altera_avalon_jtag_uart_report_log
81130acc g     F .text	00000068 __env_unlock
81116f1c g     F .text	00000028 vCoudlNotCreateNFee1Task
81124094 g     F .text	000000cc _fwalk
81138cd0 g     F .text	000001dc OSTaskResume
81134d28 g     F .text	000000f0 OSMemQuery
811478d4 g     O .rwdata	00000002 OSTaskStatEn
81161a74 g       *ABS*	00000000 __alt_stack_limit
81147914 g     O .bss	00000004 ECommSpwCh
811182b4 g     F .text	0000003c vChangeAutoResetSync
81124ef8 g     F .text	00000064 _mbtowc_r
8110e974 g     F .text	00000318 vInAckHandlerTaskV2
811478ae g     O .rwdata	00000002 OSMemMax
81136bf8 g     F .text	00000178 OSQPostFront
81143f54 g     F .text	000000d0 putc
8112d7ec g     F .text	00000084 .hidden __divsi3
81147a9d g     O .bss	00000006 OSRdyTbl
81147888 g     O .rwdata	00000002 OSDebugEn
811465cc g     O .rwdata	0000002a alt_log_msg_cache
8112378c g     F .text	0000012c _malloc_trim_r
81107fb4 g     F .text	000001a4 bRmapInitCh
811479fc g     O .bss	00000008 xSdHandle
811190f8 g     F .text	00000404 .hidden __mulsf3
811478a0 g     O .rwdata	00000002 OSFlagNodeSize
81147908 g     O .bss	00000004 pnt_memory
81118320 g     F .text	00000048 vSyncReset
8110e44c g     F .text	00000528 vLoadCtemp
8110af68 g     F .text	00000040 bSyncSetPer
81100308 g     F .text	000001b0 bDdr2EepromTest
81147ad4 g     O .bss	00000004 status_register
811478e8 g     O .rwdata	00000002 OSTmrCfgMax
8110b8fc g     F .text	00000074 bSyncIrqFlagClrError
81116b20 g     F .text	00000028 vFailSetPreAckSenderBuffer
81126c58 g     F .text	000000dc strcmp
81147adc g     O .bss	00000004 command_register
81136184 g     F .text	000001b4 OSQCreate
81138974 g     F .text	000001a0 OSTaskNameGet
811547f4 g     O .bss	00001000 vFeeTask4_stk
811557f4 g     O .bss	00000018 xReceivedACK
81136d70 g     F .text	00000214 OSQPostOpt
81131994 g     F .text	00000228 OSTimeTick
811478d0 g     O .rwdata	00000002 OSTaskMax
81137250 g     F .text	000000e0 OSSemCreate
811478f4 g     O .rwdata	00000002 OSTmrWheelSize
81116e6c g     F .text	00000028 vFailCreateScheduleQueue
811189f4 g     F .text	00000058 _reg_read
81135d30 g     F .text	00000174 OSMutexQuery
8110dfbc g     F .text	000000a4 bSendGiveBackNFeeCtrl
8112ed40 g     F .text	00000088 .hidden __nedf2
811478ca g     O .rwdata	00000002 OSTaskDelEn
81118090 g     F .text	00000038 vLoadDefaultEPValue
8115580c g     O .bss	00001000 vFeeTask1_stk
8110b72c g     F .text	00000074 bSyncCtrCh7OutEnable
81137a18 g     F .text	00000118 OSSemQuery
81136338 g     F .text	00000288 OSQDel
81136914 g     F .text	00000174 OSQPendAbort
811479d0 g     O .bss	00000004 xMutexPreParsed
8113aaa0 g     F .text	00000040 alt_irq_init
81130458 g     F .text	0000006c alt_release_fd
8113adc0 g     F .text	000000bc get_cluster_flag
8110b970 g     F .text	00000074 bSyncIrqFlagClrBlank
81142b04 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
8110acb4 g     F .text	0000002c vSyncClearCounter
8110e060 g     F .text	000003ec bPrepareDoubleBuffer
81146598 g     O .rwdata	00000031 alt_log_msg_stackpointer
8111b058 g     F .text	00000074 sprintf
81144d52 g     O .rodata	00000100 .hidden __clz_tab
8113b394 g     F .text	00000294 Write_File_Record_At_Offset
81100634 g     F .text	00000354 bDdr2MemoryWriteTest
81116850 g     F .text	00000028 vFailGetMutexTxUARTSenderTask
81147a04 g     O .bss	00000004 _PathLocale
8110ba3c g     F .text	00000058 bSyncIrqFlagBlank
81109f2c g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
8113a14c g     F .text	000001e8 OSTmrStop
811081ac g     F .text	00000050 uliRmapReadReg
81114758 g     F .text	00000050 usiGetIdCMD
8110bb68 g     F .text	00000058 uliSyncReadReg
811283b8 g     F .text	00000108 strtof
811034f8 g     F .text	00000084 vFeebCh3HandleIrq
8112da18 g     F .text	000000bc .hidden __gesf2
8111b0cc g     F .text	0000004c strcspn
8112b71c g     F .text	00000068 _write_r
8110a5c8 g     F .text	00000074 vRstcReleaseDeviceReset
81116bc0 g     F .text	00000028 vFailInAckHandlerTaskCreate
811316ec g     F .text	00000094 OSSchedLock
81116f6c g     F .text	00000028 vCoudlNotCreateNFee3Task
8112431c g     F .text	00000018 setlocale
81141e58 g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
8115dca8 g     O .bss	00000800 OSTmrTaskStk
8111af7c g     F .text	00000044 scanf
8111705c g     F .text	00000030 vFailCreateMutexSPUSQueueMeb
811332f4 g     F .text	00000110 OSFlagCreate
8113b628 g     F .text	00000688 Check_for_DOS_FAT
81112078 g     F .text	00000064 vMebInit
8113d4d4 g     F .text	000002d0 create_file
81126afc g     F .text	00000008 nanf
8114783c g     O .rwdata	00000004 _impure_ptr
81147ad8 g     O .bss	00000004 CSD_register_w0
81147a38 g     O .bss	00000004 alt_argc
811169b8 g     F .text	00000028 vFailGetCountSemaphorexBuffer128
81122eac g     F .text	00000224 __sflush_r
81124d18 g     F .text	000000b4 _mbrtowc_r
81108840 g     F .text	00000090 bSpwcGetTimecode
81124308 g     F .text	00000008 __locale_cjk_lang
81101968 g     F .text	000004a0 sense_log
81147918 g     O .bss	00000004 ESdmaBufferSide
8114789a g     O .rwdata	00000002 OSEventMultiEn
8115680c g     O .bss	00001800 vParserCommTask_stk
81118104 g     F .text	00000030 vChangeDefaultEPValue
811128f0 g     F .text	000002c8 vCheckRetransmission32
8113991c g     F .text	000001c4 OSTmrCreate
81126780 g     F .text	000001dc __srefill_r
81108bf8 g     F .text	0000003c bEnableLvdsBoard
811479d4 g     O .bss	00000004 xMutexBuffer32
81147980 g     O .bss	00000001 ucIterationSide
81105084 g     F .text	0000008c vRmapCh2HandleIrq
81133404 g     F .text	00000250 OSFlagDel
81147aa4 g     O .bss	00000004 OSEventFreeList
81108c70 g     F .text	000000c0 bSetPreEmphasys
8110cfb8 g     F .text	0000013c vQCmdFEEinConfig
81100020 g       .exceptions	00000000 alt_irq_entry
81124eac g     F .text	0000004c __ascii_mbtowc
8110b238 g     F .text	00000078 bSyncCtrExtnIrq
81104958 g     F .text	00000068 bFeebGetCh2LeftBufferEmpty
81125d00 g     F .text	00000064 __ulp
81117c3c g     F .text	0000010c vNFeeControlInit
811120dc g     F .text	000000a4 vSwapMemmory
811338d8 g     F .text	000005c0 OSFlagPend
811478e6 g     O .rwdata	00000002 OSTmrEn
81123504 g     F .text	00000018 __fp_unlock_all
8115800c g     O .bss	00000010 xDma
8110dcfc g     F .text	00000058 bEnableRmapIRQ
81113ed8 g     F .text	000002c0 bSendUART32v2
81110cdc g     F .text	0000017c setPreAckReceiverFreePos
8110b1f8 g     F .text	00000040 bSyncErrInj
81147854 g     O .rwdata	00000008 alt_fs_list
8115801c g     O .bss	00001000 vSimMebTask_stk
81117034 g     F .text	00000028 vCoudlNotCreateMebTask
8113be70 g     F .text	00000274 check_file_name_for_FAT16_compliance
8115901c g     O .bss	00001000 vFeeTask3_stk
81139c20 g     F .text	00000140 OSTmrNameGet
81147c6c g     O .bss	00000400 xSZData
8110d284 g     F .text	000001c4 vQCmdFEEinFullPattern
8113281c g     F .text	0000007c OS_StrCopy
81147ae4 g     O .bss	00000004 buffer_memory
81116a80 g     F .text	00000028 vFailGetxMutexPreParsedParserRxTask
81117f0c g     F .text	00000098 vLogWriteNUC
811478b0 g     O .rwdata	00000002 OSMemNameSize
81101e08 g     F .text	000000bc bSdmaInitM1Dma
8110b888 g     F .text	00000074 bSyncIrqEnableBlank
81143adc g     F .text	00000028 OSInitHookEnd
8111766c g     F .text	00000340 vUpdateMemMapFEE
81116b70 g     F .text	00000028 vFailSetPreAckReceiverBuffer
81103c10 g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
811478dc g     O .rwdata	00000002 OSTCBPrioTblMax
81124334 g     F .text	0000000c localeconv
8111700c g     F .text	00000028 vCoudlNotCreateDataControllerTask
811479d8 g     O .bss	00000004 xTimerRetransmission
8111080c g     F .text	00000218 vReceiverUartTask
81147a34 g     O .bss	00000004 alt_log_sys_clk_count
811478d8 g     O .rwdata	00000002 OSTaskStatStkChkEn
8112fee0 g     F .text	00000140 alt_log_write
8115a01c g     O .bss	00001000 vFeeTask2_stk
811479dc g     O .bss	00000004 xMutexBuffer128
81103478 g     F .text	00000040 vFeebCh1HandleIrq
8111889c g     F .text	0000003c bStartSync
81103708 g     F .text	00000040 vFeebCh7HandleIrq
811188d8 g     F .text	00000030 bStopSync
8114791c g     O .bss	00000004 ECommBufferSide
81142e48 g     F .text	00000058 alt_ic_isr_register
811478ac g     O .rwdata	00000002 OSMemEn
81105110 g     F .text	00000040 vRmapCh3HandleIrq
81147828 g     O .rwdata	00000004 alt_stack_limit_value
81111ae0 g     F .text	000002e4 vPusType252run
811172c4 g     F .text	00000028 vFailSendMsgMasterSyncMeb
81147ae8 g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
811478b6 g     O .rwdata	00000002 OSMutexEn
8111717c g     F .text	00000028 vCouldNotGetQueueMaskDataCtrl
81147904 g       *ABS*	00000000 _edata
8113febc g     F .text	00000068 altera_avalon_uart_read_fd
81117dbc g     F .text	00000034 vLoadDefaultIdNFEEMaster
81103360 g     F .text	0000008c usiAdcPxDelayCalcPeriodNs
81161a74 g       *ABS*	00000000 _end
81161474 g     O .bss	00000500 active_files
81147aa8 g     O .bss	00000001 OSIntNesting
811168a0 g     F .text	00000028 vFailInitialization
811005bc g     F .text	00000078 bDdr2SwitchMemory
81117b38 g     F .text	0000002c cFeeRMAPDump
81103e10 g     F .text	000000d4 bFeebCh3SetBufferSize
811479e0 g     O .bss	00000004 xSemCountBuffer32
8112b9b8 g     F .text	0000016c __fputwc
811479e4 g     O .bss	00000004 xQMaskFeeCtrl
81117a88 g     F .text	0000002c vFeeSpwRMAPChangeConfig
811213d8 g     F .text	00000070 vfscanf
8113d7a4 g     F .text	00000150 copy_file_record_name_to_string
8113f72c g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
81139674 g     F .text	000001dc OSTimeDlyResume
8113bcb0 g     F .text	000000f4 Look_for_FAT16
8110dd54 g     F .text	00000060 bDisableSPWChannel
81133784 g     F .text	00000154 OSFlagNameSet
8110deac g     F .text	0000006c bDisAndClrDbBuffer
811479e8 g     O .bss	00000004 xMutexBuffer64
81105fe8 g     F .text	00000160 bRmapGetCodecError
81138eac g     F .text	000001c8 OSTaskStkChk
81142f30 g     F .text	00000094 alt_ic_irq_disable
81101f88 g     F .text	00000458 bSdmaDmaM1Transfer
811478b2 g     O .rwdata	00000002 OSMemSize
81111778 g     F .text	00000184 vPusType252conf
81116940 g     F .text	00000028 vFailSetCountSemaphorexBuffer32
81126b68 g     F .text	00000084 __swrite
81147848 g     O .rwdata	00000004 __malloc_trim_threshold
811242fc g     F .text	0000000c __locale_msgcharset
8115b01c g     O .bss	00000020 xFeeQueueTBL1
81147aac g     O .bss	00000004 OSTCBCur
81116d28 g     F .text	00000028 vCouldNotRetransmitB64TimeoutTask
8110a030 g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
81143df0 g     F .text	00000040 exit
81135b10 g     F .text	00000220 OSMutexPost
8110b9e4 g     F .text	00000058 bSyncIrqFlagError
8113dbd0 g     F .text	000003c0 alt_up_sd_card_find_next
811478b4 g     O .rwdata	00000002 OSMemTblSize
81124160 g     F .text	000000cc _fwalk_reent
81142250 g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
811194fc g     F .text	000000f8 .hidden __floatunsisf
81125afc g     F .text	00000204 __mdiff
81116ef4 g     F .text	00000028 vCoudlNotCreateNFee0Task
81104308 g     F .text	0000017c vFeebInitIrq
81102b20 g     F .text	0000022c bDpktSetPacketConfig
811168f0 g     F .text	00000028 vFailSenderCreate
8112d870 g     F .text	00000074 .hidden __modsi3
81116fbc g     F .text	00000028 vCoudlNotCreateNFee5Task
8110b144 g     F .text	0000003c uliSyncGetPer
811051d0 g     F .text	00000040 vRmapCh6HandleIrq
811479ec g     O .bss	00000004 xMutexSenderACK
81116c88 g     F .text	00000028 vFailGetBlockingSemTimeoutTask
81147834 g     O .rwdata	00000004 __ctype_ptr__
81116b48 g     F .text	00000028 vFailSetPreParsedBuffer
8113ace0 g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
811234e0 g     F .text	00000004 __sfp_lock_release
81104558 g     F .text	000000ac bFeebGetIrqControl
81116da0 g     F .text	00000028 vCouldNotSendTurnOff
81131534 g     F .text	00000064 OSInit
811095a8 g     F .text	00000078 bSetPainelLeds
81141998 g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
81147ab0 g     O .bss	00000004 OSTmrTime
81100988 g     F .text	0000026c bDdr2MemoryReadTest
81106148 g     F .text	000002ec bRmapSetMemConfigArea
81139260 g     F .text	0000012c OSTaskQuery
8110b814 g     F .text	00000074 bSyncIrqEnableError
811479f0 g     O .bss	00000004 xMutexPus
811370e8 g     F .text	000000b0 OS_QInit
81126a2c g     F .text	000000d0 __sccl
8111ab7c g     F .text	0000000c atoi
8110bcc8 g     F .text	00001154 vFeeTask
81132898 g     F .text	0000005c OS_StrLen
811173b4 g     F .text	00000028 vFailFlushNFEEQueue
81103a00 g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
81116588 g     F .text	000000e0 vDataControllerInit
81134b2c g     F .text	0000011c OSMemNameSet
81144e52 g     O .rodata	00000101 _ctype_
8110b108 g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
81116990 g     F .text	00000028 vFailSetCountSemaphorexBuffer128
811478ce g     O .rwdata	00000002 OSTaskProfileEn
811173dc g     F .text	00000028 vEvtChangeMebMode
81141868 g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
811479f4 g     O .bss	00000004 xTxUARTMutex
81147ab4 g     O .bss	00000004 OSTime
8114784c g     O .rwdata	00000004 __mbtowc
811404dc g     F .text	0000005c altera_avalon_uart_close
8110ce1c g     F .text	0000019c vQCmdFEEinWaitingSync
81147ab8 g     O .bss	00000004 OSTmrSem
81111748 g     F .text	00000030 vPusType251conf
8115e4a8 g     O .bss	00001000 OSTaskIdleStk
81147994 g     O .bss	00000004 pdata
81144298 g     F .text	000000bc _exit
81104798 g     F .text	00000078 bFeebGetLeftBufferEmpty
81142b8c g     F .text	00000134 alt_alarm_start
81133654 g     F .text	00000130 OSFlagNameGet
81139850 g     F .text	00000064 OSTimeGet
81147920 g     O .bss	00000004 ESdmaChBufferId
8113e434 g     F .text	00000380 alt_up_sd_card_read
811053a0 g     F .text	00000044 vRmapCh5IrqFlagClrWriteCmd
81124340 g     F .text	000001c4 __smakebuf_r
811479f8 g     O .bss	00000001 SemCount64
81113c18 g     F .text	000002c0 bSendUART64v2
81117364 g     F .text	00000028 vFailFlushQueueData
81103ab0 g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
811478fc g     O .rwdata	00000008 alt_msgdma_list
8111b118 g     F .text	00000098 strlen
8110a86c g     F .text	000000b4 uc_spi_get_byte
811053e4 g     F .text	00000044 vRmapCh6IrqFlagClrWriteCmd
811171a4 g     F .text	00000030 vFailSendMsgAccessDMA
81143a0c g     F .text	00000028 OSTaskSwHook
81143370 g     F .text	0000015c open
811077e8 g     F .text	000007cc bRmapGetRmapMemHKArea
8115f4a8 g     O .bss	00000d00 OSEventTbl
81117ab4 g     F .text	0000002c vFeeSpwRMAPChangeDefault
811195f4 g     F .text	000000dc .hidden __gedf2
81117294 g     F .text	00000030 vFailSendMsgSyncRMAPTRIGGER
8115b03c g     O .bss	00000020 xSenderACK
81143700 g     F .text	00000044 alt_putchar
8111ab94 g     F .text	0000000c atoll
811601a8 g     O .bss	000011b8 OSTCBTbl
8112bd34 g     F .text	00000838 __gethex
81137b30 g     F .text	00000108 OSSemSet
81112224 g     F .text	00000050 vTimeoutCheckerTaskv2
81117b64 g     F .text	00000038 cFeeRMAPEchoingEnable
81147850 g     O .rwdata	00000004 __wctomb
81113028 g     F .text	00000314 vVariablesInitialization
8112a1c0 g     F .text	00000018 __sprint_r
8110d7a4 g     F .text	00000298 vQCmdFeeRMAPinFullPattern
81104604 g     F .text	00000088 bFeebGetIrqFlags
81147910 g     O .bss	00000004 pxDmaM2Dev
811166c0 g     F .text	00000028 vFailCreateSemaphoreResources
8114786c g     O .rwdata	00000004 alt_priority_mask
81108c34 g     F .text	0000003c bDisableLvdsBoard
81137330 g     F .text	00000248 OSSemDel
81103d3c g     F .text	000000d4 bFeebCh2SetBufferSize
81147abc g     O .bss	00000004 OSFlagFreeList
8110a7a8 g     F .text	000000c4 v_spi_send_byte
8110aa8c g     F .text	000000d0 bSSDisplayConfig
81142ea0 g     F .text	00000090 alt_ic_irq_enable
81147894 g     O .rwdata	00000002 OSEventNameSize
8111fb34 g     F .text	0000001c __vfprintf_internal
81147ac0 g     O .bss	00000001 OSStatRdy
8110b4e8 g     F .text	00000074 bSyncCtrCh2OutEnable
81161360 g     O .bss	000000ac OSTCBPrioTbl
8114057c g     F .text	00000270 altera_avalon_uart_read
8112ccc8 g     F .text	00000064 _wctomb_r
81130a00 g     F .text	000000cc __env_lock
811478da g     O .rwdata	00000002 OSTaskSwHookEn
81148184 g     O .bss	00000100 cTemp
81103810 g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
81119df0 g     F .text	00000904 .hidden __subdf3
8115b05c g     O .bss	00000260 xPreParsed
8110b180 g     F .text	0000003c uliSyncGetOst
811479f9 g     O .bss	00000001 SemCount128
81105250 g     F .text	00000040 vRmapCh8HandleIrq
811038dc g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
81114198 g     F .text	00000290 vSendEthConf
811029ac g     F .text	000000d0 bCommInitCh
81125510 g     F .text	000000b0 __lo0bits
8111fc14 g     F .text	000017c4 __svfscanf_r
81147878 g     O .rwdata	00000008 alt_alarm_list
81129f08 g     F .text	0000019c _ungetc_r
811478a2 g     O .rwdata	00000002 OSFlagWidth
81105290 g     F .text	00000044 vRmapCh1IrqFlagClrWriteCmd
811010d4 g     F .text	0000004c DMA_BUSY
8112cbd0 g     F .text	000000c8 wcrtomb
81102f3c g     F .text	00000148 bDpktSetPixelDelay
81113840 g     F .text	00000090 vCCDLoadDefaultValues
8112f0e0 g     F .text	000000d8 close
8110b1bc g     F .text	0000003c uliSyncGetGeneral
8111742c g     F .text	00000028 vEvtChangeDataControllerMode
81147a50 g     O .bss	00000004 alt_envsem
8112f610 g     F .text	00000068 alt_log_repchar
81147ac4 g     O .bss	00000004 OSIdleCtrRun
81131bbc g     F .text	00000028 OSVersion
811478ec g     O .rwdata	00000002 OSTmrCfgWheelSize
8113938c g     F .text	00000078 OS_TaskStkClr
81118658 g     F .text	0000003c siOpenFile
8110bc44 g     F .text	00000084 vDataControlTask
811478c6 g     O .rwdata	00000002 OSTaskCreateEn
81105508 g     F .text	00000058 bRmapCh2IrqFlagWriteCmd
81105950 g     F .text	00000050 uliRmapCh7WriteCmdAddress
81104c38 g     F .text	00000088 bFeebStartCh
81114428 g     F .text	00000118 vSendTurnOff
81116738 g     F .text	00000028 vFailSendPreParsedSemaphore
8113c1a4 g     F .text	000002a4 match_file_record_to_name_ext
811321e4 g     F .text	00000070 OS_EventWaitListInit
8112bb48 g     F .text	00000088 fputwc
8115b2bc g     O .bss	00000020 xFeeQueueTBL0
81116710 g     F .text	00000028 vFailSendxSemCommInit
81143b04 g     F .text	00000028 OSTaskIdleHook
81114540 g     F .text	00000118 vSendReset
811234e4 g     F .text	00000004 __sinit_lock_acquire
81125274 g     F .text	00000128 __multadd
8115b2dc g     O .bss	00000020 SyncTBL1
81103920 g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110ae0c g     F .text	0000004c ucSyncStatusState
81139074 g     F .text	000001ec OSTaskSuspend
8112524c g     F .text	00000028 _Bfree
8110b0cc g     F .text	0000003c uliSyncGetMbt
811328f4 g     F .text	00000064 OS_TaskIdle
811478f2 g     O .rwdata	00000002 OSTmrTblSize
81136f84 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	11315980 	call	81131598 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045b4 	movhi	r2,33046
81100150:	10865d04 	addi	r2,r2,6516
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045b4 	movhi	r2,33046
81100168:	10865d04 	addi	r2,r2,6516
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	11315ec0 	call	811315ec <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0b617 	ldw	r2,-32040(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0b617 	ldw	r2,-32040(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204534 	movhi	r4,33044
81100260:	211e1c04 	addi	r4,r4,30832
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204534 	movhi	r4,33044
81100270:	21197304 	addi	r4,r4,26060
81100274:	112f5880 	call	8112f588 <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204534 	movhi	r4,33044
8110027c:	211e1c04 	addi	r4,r4,30832
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204534 	movhi	r4,33044
8110028c:	21196604 	addi	r4,r4,26008
81100290:	112f5880 	call	8112f588 <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04534 	movhi	gp,33044
    ori gp, gp, %lo(_gp)
811002a0:	d6be0a14 	ori	gp,gp,63528
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204534 	movhi	r4,33044
811002a8:	211e1c04 	addi	r4,r4,30832
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204534 	movhi	r4,33044
811002b8:	21195704 	addi	r4,r4,25948
811002bc:	112f5880 	call	8112f588 <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04534 	movhi	r2,33044
    ori r2, r2, %lo(__bss_start)
811002c4:	109e4114 	ori	r2,r2,30980

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18c69d14 	ori	r3,r3,6772

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204534 	movhi	r4,33044
811002e8:	211e1c04 	addi	r4,r4,30832
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204534 	movhi	r4,33044
811002f8:	21195e04 	addi	r4,r4,25976
811002fc:	112f5880 	call	8112f588 <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	11301b40 	call	811301b4 <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
	debug(fp, cDebugBuffer);
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100328:	00bfe804 	movi	r2,-96
8110032c:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
81100330:	00800044 	movi	r2,1
81100334:	e0bff915 	stw	r2,-28(fp)
	switch (ucMemoryId) {
81100338:	e0bfff03 	ldbu	r2,-4(fp)
8110033c:	10000326 	beq	r2,zero,8110034c <bDdr2EepromTest+0x44>
81100340:	10800060 	cmpeqi	r2,r2,1
81100344:	1000081e 	bne	r2,zero,81100368 <bDdr2EepromTest+0x60>
81100348:	00000e06 	br	81100384 <bDdr2EepromTest+0x7c>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
8110034c:	00a00034 	movhi	r2,32768
81100350:	10827c04 	addi	r2,r2,2544
81100354:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100358:	00a00034 	movhi	r2,32768
8110035c:	10828004 	addi	r2,r2,2560
81100360:	e0bffb15 	stw	r2,-20(fp)
		break;
81100364:	00000a06 	br	81100390 <bDdr2EepromTest+0x88>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
81100368:	00a00034 	movhi	r2,32768
8110036c:	10825804 	addi	r2,r2,2400
81100370:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
81100374:	00a00034 	movhi	r2,32768
81100378:	10825c04 	addi	r2,r2,2416
8110037c:	e0bffb15 	stw	r2,-20(fp)
		break;
81100380:	00000306 	br	81100390 <bDdr2EepromTest+0x88>
	default:
		bSuccess = FALSE;
81100384:	e03ff915 	stw	zero,-28(fp)
		sprintf(cDebugBuffer,
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
		;
#endif
		return bSuccess;
81100388:	e0bff917 	ldw	r2,-28(fp)
8110038c:	00004506 	br	811004a4 <bDdr2EepromTest+0x19c>
	alt_u8 ucControlAddr, ucValue;
#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
81100390:	01138804 	movi	r4,20000
81100394:	11307740 	call	81130774 <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100398:	e03ffc15 	stw	zero,-16(fp)
8110039c:	00001206 	br	811003e8 <bDdr2EepromTest+0xe0>
		ucControlAddr = iI;
811003a0:	e0bffc17 	ldw	r2,-16(fp)
811003a4:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
811003a8:	e0bffd03 	ldbu	r2,-12(fp)
811003ac:	10c03fcc 	andi	r3,r2,255
811003b0:	18c0201c 	xori	r3,r3,128
811003b4:	18ffe004 	addi	r3,r3,-128
811003b8:	e13ffd43 	ldbu	r4,-11(fp)
811003bc:	e0bffe04 	addi	r2,fp,-8
811003c0:	d8800015 	stw	r2,0(sp)
811003c4:	200f883a 	mov	r7,r4
811003c8:	180d883a 	mov	r6,r3
811003cc:	e17ffb17 	ldw	r5,-20(fp)
811003d0:	e13ffa17 	ldw	r4,-24(fp)
811003d4:	1108f140 	call	81108f14 <I2C_Read>
811003d8:	e0bff915 	stw	r2,-28(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
811003dc:	e0bffc17 	ldw	r2,-16(fp)
811003e0:	10800044 	addi	r2,r2,1
811003e4:	e0bffc15 	stw	r2,-16(fp)
811003e8:	e0bffc17 	ldw	r2,-16(fp)
811003ec:	10804008 	cmpgei	r2,r2,256
811003f0:	1000021e 	bne	r2,zero,811003fc <bDdr2EepromTest+0xf4>
811003f4:	e0bff917 	ldw	r2,-28(fp)
811003f8:	103fe91e 	bne	r2,zero,811003a0 <__reset+0xfb0e03a0>

#if DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
	debug(fp, cDebugBuffer);
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
811003fc:	00800484 	movi	r2,18
81100400:	e0bffd85 	stb	r2,-10(fp)
81100404:	00bfe004 	movi	r2,-128
81100408:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
8110040c:	01138804 	movi	r4,20000
81100410:	11307740 	call	81130774 <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100414:	e0bffd03 	ldbu	r2,-12(fp)
81100418:	10c03fcc 	andi	r3,r2,255
8110041c:	18c0201c 	xori	r3,r3,128
81100420:	18ffe004 	addi	r3,r3,-128
81100424:	e13ffdc3 	ldbu	r4,-9(fp)
81100428:	e0bffd83 	ldbu	r2,-10(fp)
8110042c:	d8800015 	stw	r2,0(sp)
81100430:	200f883a 	mov	r7,r4
81100434:	180d883a 	mov	r6,r3
81100438:	e17ffb17 	ldw	r5,-20(fp)
8110043c:	e13ffa17 	ldw	r4,-24(fp)
81100440:	1108e340 	call	81108e34 <I2C_Write>
81100444:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
81100448:	e0bff917 	ldw	r2,-28(fp)
8110044c:	10001426 	beq	r2,zero,811004a0 <bDdr2EepromTest+0x198>
#if DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100450:	e0bffd03 	ldbu	r2,-12(fp)
81100454:	10c03fcc 	andi	r3,r2,255
81100458:	18c0201c 	xori	r3,r3,128
8110045c:	18ffe004 	addi	r3,r3,-128
81100460:	e13ffdc3 	ldbu	r4,-9(fp)
81100464:	e0bffe44 	addi	r2,fp,-7
81100468:	d8800015 	stw	r2,0(sp)
8110046c:	200f883a 	mov	r7,r4
81100470:	180d883a 	mov	r6,r3
81100474:	e17ffb17 	ldw	r5,-20(fp)
81100478:	e13ffa17 	ldw	r4,-24(fp)
8110047c:	1108f140 	call	81108f14 <I2C_Read>
81100480:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
81100484:	e0bff917 	ldw	r2,-28(fp)
81100488:	10000526 	beq	r2,zero,811004a0 <bDdr2EepromTest+0x198>
#if DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
			debug(fp, cDebugBuffer);
#endif
		} else {
			if (ucReadData != ucWriteData) {
8110048c:	e0bffe43 	ldbu	r2,-7(fp)
81100490:	10c03fcc 	andi	r3,r2,255
81100494:	e0bffd83 	ldbu	r2,-10(fp)
81100498:	18800126 	beq	r3,r2,811004a0 <bDdr2EepromTest+0x198>
				bSuccess = FALSE;
8110049c:	e03ff915 	stw	zero,-28(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
	debug(fp, cDebugBuffer);
#endif

	return bSuccess;
811004a0:	e0bff917 	ldw	r2,-28(fp)
}
811004a4:	e037883a 	mov	sp,fp
811004a8:	dfc00117 	ldw	ra,4(sp)
811004ac:	df000017 	ldw	fp,0(sp)
811004b0:	dec00204 	addi	sp,sp,8
811004b4:	f800283a 	ret

811004b8 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
811004b8:	deffb704 	addi	sp,sp,-292
811004bc:	de00012e 	bgeu	sp,et,811004c4 <bDdr2EepromDump+0xc>
811004c0:	003b68fa 	trap	3
811004c4:	dfc04815 	stw	ra,288(sp)
811004c8:	df004715 	stw	fp,284(sp)
811004cc:	df004704 	addi	fp,sp,284
811004d0:	2005883a 	mov	r2,r4
811004d4:	e0bfff05 	stb	r2,-4(fp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
	debug(fp, cDebugBuffer);
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
811004d8:	00bfe804 	movi	r2,-96
811004dc:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
811004e0:	00800044 	movi	r2,1
811004e4:	e0bfbe15 	stw	r2,-264(fp)
	switch (ucMemoryId) {
811004e8:	e0bfff03 	ldbu	r2,-4(fp)
811004ec:	10000326 	beq	r2,zero,811004fc <bDdr2EepromDump+0x44>
811004f0:	10800060 	cmpeqi	r2,r2,1
811004f4:	1000081e 	bne	r2,zero,81100518 <bDdr2EepromDump+0x60>
811004f8:	00000e06 	br	81100534 <bDdr2EepromDump+0x7c>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
811004fc:	00a00034 	movhi	r2,32768
81100500:	10827c04 	addi	r2,r2,2544
81100504:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100508:	00a00034 	movhi	r2,32768
8110050c:	10828004 	addi	r2,r2,2560
81100510:	e0bfbb15 	stw	r2,-276(fp)
		break;
81100514:	00000a06 	br	81100540 <bDdr2EepromDump+0x88>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
81100518:	00a00034 	movhi	r2,32768
8110051c:	10825804 	addi	r2,r2,2400
81100520:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
81100524:	00a00034 	movhi	r2,32768
81100528:	10825c04 	addi	r2,r2,2416
8110052c:	e0bfbb15 	stw	r2,-276(fp)
		break;
81100530:	00000306 	br	81100540 <bDdr2EepromDump+0x88>
	default:
		bSuccess = FALSE;
81100534:	e03fbe15 	stw	zero,-264(fp)
		sprintf(cDebugBuffer,
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
		;
#endif
		return bSuccess;
81100538:	e0bfbe17 	ldw	r2,-264(fp)
8110053c:	00001a06 	br	811005a8 <bDdr2EepromDump+0xf0>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100540:	e0bfbd03 	ldbu	r2,-268(fp)
81100544:	10c03fcc 	andi	r3,r2,255
81100548:	18c0201c 	xori	r3,r3,128
8110054c:	18ffe004 	addi	r3,r3,-128
81100550:	e13fbf04 	addi	r4,fp,-260
81100554:	00804004 	movi	r2,256
81100558:	d8800015 	stw	r2,0(sp)
8110055c:	200f883a 	mov	r7,r4
81100560:	180d883a 	mov	r6,r3
81100564:	e17fbb17 	ldw	r5,-276(fp)
81100568:	e13fba17 	ldw	r4,-280(fp)
8110056c:	110901c0 	call	8110901c <I2C_MultipleRead>
81100570:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
81100574:	e0bfbe17 	ldw	r2,-264(fp)
81100578:	10000a26 	beq	r2,zero,811005a4 <bDdr2EepromDump+0xec>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
8110057c:	e03fbc15 	stw	zero,-272(fp)
81100580:	00000306 	br	81100590 <bDdr2EepromDump+0xd8>
81100584:	e0bfbc17 	ldw	r2,-272(fp)
81100588:	10800044 	addi	r2,r2,1
8110058c:	e0bfbc15 	stw	r2,-272(fp)
81100590:	e0bfbc17 	ldw	r2,-272(fp)
81100594:	10804008 	cmpgei	r2,r2,256
81100598:	1000021e 	bne	r2,zero,811005a4 <bDdr2EepromDump+0xec>
8110059c:	e0bfbe17 	ldw	r2,-264(fp)
811005a0:	103ff81e 	bne	r2,zero,81100584 <__reset+0xfb0e0584>
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
	debug(fp, cDebugBuffer);
#endif

	return bSuccess;
811005a4:	e0bfbe17 	ldw	r2,-264(fp)
}
811005a8:	e037883a 	mov	sp,fp
811005ac:	dfc00117 	ldw	ra,4(sp)
811005b0:	df000017 	ldw	fp,0(sp)
811005b4:	dec00204 	addi	sp,sp,8
811005b8:	f800283a 	ret

811005bc <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811005bc:	defffc04 	addi	sp,sp,-16
811005c0:	de00012e 	bgeu	sp,et,811005c8 <bDdr2SwitchMemory+0xc>
811005c4:	003b68fa 	trap	3
811005c8:	df000315 	stw	fp,12(sp)
811005cc:	df000304 	addi	fp,sp,12
811005d0:	2005883a 	mov	r2,r4
811005d4:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess;
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
811005d8:	00a04834 	movhi	r2,33056
811005dc:	108c2204 	addi	r2,r2,12424
811005e0:	e0bffe15 	stw	r2,-8(fp)

	bSuccess = TRUE;
811005e4:	00800044 	movi	r2,1
811005e8:	e0bffd15 	stw	r2,-12(fp)
	switch (ucMemoryId) {
811005ec:	e0bfff03 	ldbu	r2,-4(fp)
811005f0:	10000326 	beq	r2,zero,81100600 <bDdr2SwitchMemory+0x44>
811005f4:	10800060 	cmpeqi	r2,r2,1
811005f8:	1000041e 	bne	r2,zero,8110060c <bDdr2SwitchMemory+0x50>
811005fc:	00000706 	br	8110061c <bDdr2SwitchMemory+0x60>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
81100600:	e0bffe17 	ldw	r2,-8(fp)
81100604:	10000015 	stw	zero,0(r2)
		break;
81100608:	00000506 	br	81100620 <bDdr2SwitchMemory+0x64>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
8110060c:	e0bffe17 	ldw	r2,-8(fp)
81100610:	00e00034 	movhi	r3,32768
81100614:	10c00015 	stw	r3,0(r2)
		break;
81100618:	00000106 	br	81100620 <bDdr2SwitchMemory+0x64>
	default:
		bSuccess = FALSE;
8110061c:	e03ffd15 	stw	zero,-12(fp)
		debug(fp, cDebugBuffer)
		;
#endif
	}

	return bSuccess;
81100620:	e0bffd17 	ldw	r2,-12(fp)
}
81100624:	e037883a 	mov	sp,fp
81100628:	df000017 	ldw	fp,0(sp)
8110062c:	dec00104 	addi	sp,sp,4
81100630:	f800283a 	ret

81100634 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
81100634:	deffe304 	addi	sp,sp,-116
81100638:	de00012e 	bgeu	sp,et,81100640 <bDdr2MemoryWriteTest+0xc>
8110063c:	003b68fa 	trap	3
81100640:	dfc01c15 	stw	ra,112(sp)
81100644:	df001b15 	stw	fp,108(sp)
81100648:	dc401a15 	stw	r17,104(sp)
8110064c:	dc001915 	stw	r16,100(sp)
81100650:	df001b04 	addi	fp,sp,108
81100654:	2005883a 	mov	r2,r4
81100658:	e0bffd05 	stb	r2,-12(fp)
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
8110065c:	00800044 	movi	r2,1
81100660:	e0bfed15 	stw	r2,-76(fp)
	switch (ucMemoryId) {
81100664:	e0bffd03 	ldbu	r2,-12(fp)
81100668:	10000326 	beq	r2,zero,81100678 <bDdr2MemoryWriteTest+0x44>
8110066c:	10800060 	cmpeqi	r2,r2,1
81100670:	1000081e 	bne	r2,zero,81100694 <bDdr2MemoryWriteTest+0x60>
81100674:	00000e06 	br	811006b0 <bDdr2MemoryWriteTest+0x7c>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81100678:	e0bffd03 	ldbu	r2,-12(fp)
8110067c:	1009883a 	mov	r4,r2
81100680:	11005bc0 	call	811005bc <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81100684:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81100688:	00a00034 	movhi	r2,32768
8110068c:	e0bfe615 	stw	r2,-104(fp)
		break;
81100690:	00000a06 	br	811006bc <bDdr2MemoryWriteTest+0x88>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81100694:	e0bffd03 	ldbu	r2,-12(fp)
81100698:	1009883a 	mov	r4,r2
8110069c:	11005bc0 	call	811005bc <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811006a0:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811006a4:	00a00034 	movhi	r2,32768
811006a8:	e0bfe615 	stw	r2,-104(fp)
		break;
811006ac:	00000306 	br	811006bc <bDdr2MemoryWriteTest+0x88>
	default:
		bSuccess = FALSE;
811006b0:	e03fed15 	stw	zero,-76(fp)
		sprintf(cDebugBuffer,
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
		;
#endif
		return bSuccess;
811006b4:	e0bfed17 	ldw	r2,-76(fp)
811006b8:	0000ac06 	br	8110096c <bDdr2MemoryWriteTest+0x338>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811006bc:	00800104 	movi	r2,4
811006c0:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811006c4:	e03fec15 	stw	zero,-80(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811006c8:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811006cc:	e03fe715 	stw	zero,-100(fp)
811006d0:	00001506 	br	81100728 <bDdr2MemoryWriteTest+0xf4>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
811006d4:	e0ffe617 	ldw	r3,-104(fp)
811006d8:	00b33374 	movhi	r2,52429
811006dc:	10b33344 	addi	r2,r2,-13107
811006e0:	1888383a 	mulxuu	r4,r3,r2
811006e4:	1885383a 	mul	r2,r3,r2
811006e8:	1021883a 	mov	r16,r2
811006ec:	2023883a 	mov	r17,r4
811006f0:	8804d0fa 	srli	r2,r17,3
811006f4:	e0ffe717 	ldw	r3,-100(fp)
811006f8:	18c00044 	addi	r3,r3,1
811006fc:	10c7383a 	mul	r3,r2,r3
81100700:	e0bfe717 	ldw	r2,-100(fp)
81100704:	1085883a 	add	r2,r2,r2
81100708:	1085883a 	add	r2,r2,r2
8110070c:	e13fe504 	addi	r4,fp,-108
81100710:	2085883a 	add	r2,r4,r2
81100714:	10800e04 	addi	r2,r2,56
81100718:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
8110071c:	e0bfe717 	ldw	r2,-100(fp)
81100720:	10800044 	addi	r2,r2,1
81100724:	e0bfe715 	stw	r2,-100(fp)
81100728:	e0bfe717 	ldw	r2,-100(fp)
8110072c:	10800290 	cmplti	r2,r2,10
81100730:	103fe81e 	bne	r2,zero,811006d4 <__reset+0xfb0e06d4>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81100734:	d0a08817 	ldw	r2,-32224(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81100738:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
8110073c:	00804004 	movi	r2,256
81100740:	e0bfea15 	stw	r2,-88(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81100744:	e03fe715 	stw	zero,-100(fp)
81100748:	00001e06 	br	811007c4 <bDdr2MemoryWriteTest+0x190>
		if (iI == 0) {
8110074c:	e0bfe717 	ldw	r2,-100(fp)
81100750:	1000091e 	bne	r2,zero,81100778 <bDdr2MemoryWriteTest+0x144>
			xSZData[iI] = uliInitValue;
81100754:	00a04534 	movhi	r2,33044
81100758:	109f1b04 	addi	r2,r2,31852
8110075c:	e0ffe717 	ldw	r3,-100(fp)
81100760:	18c7883a 	add	r3,r3,r3
81100764:	18c7883a 	add	r3,r3,r3
81100768:	10c5883a 	add	r2,r2,r3
8110076c:	e0fff017 	ldw	r3,-64(fp)
81100770:	10c00015 	stw	r3,0(r2)
81100774:	00001006 	br	811007b8 <bDdr2MemoryWriteTest+0x184>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
81100778:	e0bfe717 	ldw	r2,-100(fp)
8110077c:	10ffffc4 	addi	r3,r2,-1
81100780:	00a04534 	movhi	r2,33044
81100784:	109f1b04 	addi	r2,r2,31852
81100788:	18c7883a 	add	r3,r3,r3
8110078c:	18c7883a 	add	r3,r3,r3
81100790:	10c5883a 	add	r2,r2,r3
81100794:	10800017 	ldw	r2,0(r2)
81100798:	11000364 	muli	r4,r2,13
8110079c:	00a04534 	movhi	r2,33044
811007a0:	109f1b04 	addi	r2,r2,31852
811007a4:	e0ffe717 	ldw	r3,-100(fp)
811007a8:	18c7883a 	add	r3,r3,r3
811007ac:	18c7883a 	add	r3,r3,r3
811007b0:	10c5883a 	add	r2,r2,r3
811007b4:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811007b8:	e0bfe717 	ldw	r2,-100(fp)
811007bc:	10800044 	addi	r2,r2,1
811007c0:	e0bfe715 	stw	r2,-100(fp)
811007c4:	e0ffe717 	ldw	r3,-100(fp)
811007c8:	e0bfea17 	ldw	r2,-88(fp)
811007cc:	18bfdf16 	blt	r3,r2,8110074c <__reset+0xfb0e074c>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811007d0:	e0bfea17 	ldw	r2,-88(fp)
811007d4:	10ffffc4 	addi	r3,r2,-1
811007d8:	00a04534 	movhi	r2,33044
811007dc:	109f1b04 	addi	r2,r2,31852
811007e0:	18c7883a 	add	r3,r3,r3
811007e4:	18c7883a 	add	r3,r3,r3
811007e8:	10c7883a 	add	r3,r2,r3
811007ec:	00aaaaf4 	movhi	r2,43691
811007f0:	10aaaa84 	addi	r2,r2,-21846
811007f4:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
811007f8:	e0bfea17 	ldw	r2,-88(fp)
811007fc:	10ffff84 	addi	r3,r2,-2
81100800:	00a04534 	movhi	r2,33044
81100804:	109f1b04 	addi	r2,r2,31852
81100808:	18c7883a 	add	r3,r3,r3
8110080c:	18c7883a 	add	r3,r3,r3
81100810:	10c7883a 	add	r3,r2,r3
81100814:	00955574 	movhi	r2,21845
81100818:	10955544 	addi	r2,r2,21845
8110081c:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
81100820:	e0bfea17 	ldw	r2,-88(fp)
81100824:	10ffff44 	addi	r3,r2,-3
81100828:	00a04534 	movhi	r2,33044
8110082c:	109f1b04 	addi	r2,r2,31852
81100830:	18c7883a 	add	r3,r3,r3
81100834:	18c7883a 	add	r3,r3,r3
81100838:	10c5883a 	add	r2,r2,r3
8110083c:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
81100840:	e0bfea17 	ldw	r2,-88(fp)
81100844:	10ffff04 	addi	r3,r2,-4
81100848:	00a04534 	movhi	r2,33044
8110084c:	109f1b04 	addi	r2,r2,31852
81100850:	18c7883a 	add	r3,r3,r3
81100854:	18c7883a 	add	r3,r3,r3
81100858:	10c5883a 	add	r2,r2,r3
8110085c:	00ffffc4 	movi	r3,-1
81100860:	10c00015 	stw	r3,0(r2)
81100864:	d0a08817 	ldw	r2,-32224(gp)

#if DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
	debug(fp, cDebugBuffer);
#endif
	iTimeStart = alt_nticks();
81100868:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
8110086c:	e0bfe517 	ldw	r2,-108(fp)
81100870:	e0bfe915 	stw	r2,-92(fp)
	iNAccessLen = sizeof(xSZData);
81100874:	00810004 	movi	r2,1024
81100878:	e0bfe815 	stw	r2,-96(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
8110087c:	e0ffe817 	ldw	r3,-96(fp)
81100880:	e0bfee17 	ldw	r2,-72(fp)
81100884:	1885283a 	div	r2,r3,r2
81100888:	e0bfea15 	stw	r2,-88(fp)
	iNPos = 0;
8110088c:	e03feb15 	stw	zero,-84(fp)
	while (iNPos < uliByteLen) {
81100890:	00002d06 	br	81100948 <bDdr2MemoryWriteTest+0x314>
		iNRemainedLen = uliByteLen - iNPos;
81100894:	e0bfeb17 	ldw	r2,-84(fp)
81100898:	e0ffe617 	ldw	r3,-104(fp)
8110089c:	1885c83a 	sub	r2,r3,r2
811008a0:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
811008a4:	e0bfe817 	ldw	r2,-96(fp)
811008a8:	e0fff217 	ldw	r3,-56(fp)
811008ac:	1880060e 	bge	r3,r2,811008c8 <bDdr2MemoryWriteTest+0x294>
			iNAccessLen = iNRemainedLen;
811008b0:	e0bff217 	ldw	r2,-56(fp)
811008b4:	e0bfe815 	stw	r2,-96(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
811008b8:	e0ffe817 	ldw	r3,-96(fp)
811008bc:	e0bfee17 	ldw	r2,-72(fp)
811008c0:	1885283a 	div	r2,r3,r2
811008c4:	e0bfea15 	stw	r2,-88(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
811008c8:	e0bfe817 	ldw	r2,-96(fp)
811008cc:	100d883a 	mov	r6,r2
811008d0:	01604534 	movhi	r5,33044
811008d4:	295f1b04 	addi	r5,r5,31852
811008d8:	e13fe917 	ldw	r4,-92(fp)
811008dc:	111abac0 	call	8111abac <memcpy>
		pxDes += iNItemNum;
811008e0:	e0bfea17 	ldw	r2,-88(fp)
811008e4:	1085883a 	add	r2,r2,r2
811008e8:	1085883a 	add	r2,r2,r2
811008ec:	1007883a 	mov	r3,r2
811008f0:	e0bfe917 	ldw	r2,-92(fp)
811008f4:	10c5883a 	add	r2,r2,r3
811008f8:	e0bfe915 	stw	r2,-92(fp)
		iNPos += iNAccessLen;
811008fc:	e0ffeb17 	ldw	r3,-84(fp)
81100900:	e0bfe817 	ldw	r2,-96(fp)
81100904:	1885883a 	add	r2,r3,r2
81100908:	e0bfeb15 	stw	r2,-84(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
8110090c:	e0bfec17 	ldw	r2,-80(fp)
81100910:	10800288 	cmpgei	r2,r2,10
81100914:	10000c1e 	bne	r2,zero,81100948 <bDdr2MemoryWriteTest+0x314>
81100918:	e0bfec17 	ldw	r2,-80(fp)
8110091c:	1085883a 	add	r2,r2,r2
81100920:	1085883a 	add	r2,r2,r2
81100924:	e0ffe504 	addi	r3,fp,-108
81100928:	1885883a 	add	r2,r3,r2
8110092c:	10800e04 	addi	r2,r2,56
81100930:	10800017 	ldw	r2,0(r2)
81100934:	e0ffeb17 	ldw	r3,-84(fp)
81100938:	18800336 	bltu	r3,r2,81100948 <bDdr2MemoryWriteTest+0x314>
			iNProgressIndex++;
8110093c:	e0bfec17 	ldw	r2,-80(fp)
81100940:	10800044 	addi	r2,r2,1
81100944:	e0bfec15 	stw	r2,-80(fp)
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
81100948:	e0ffeb17 	ldw	r3,-84(fp)
8110094c:	e0bfe617 	ldw	r2,-104(fp)
81100950:	18bfd036 	bltu	r3,r2,81100894 <__reset+0xfb0e0894>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
81100954:	112f1b80 	call	8112f1b8 <alt_dcache_flush_all>
81100958:	d0e08817 	ldw	r3,-32224(gp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
	debug(fp, cDebugBuffer);
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
8110095c:	e0bff117 	ldw	r2,-60(fp)
81100960:	1885c83a 	sub	r2,r3,r2
81100964:	e0bfef15 	stw	r2,-68(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
	debug(fp, cDebugBuffer);
#endif

	return bSuccess;
81100968:	e0bfed17 	ldw	r2,-76(fp)
}
8110096c:	e6fffe04 	addi	sp,fp,-8
81100970:	dfc00317 	ldw	ra,12(sp)
81100974:	df000217 	ldw	fp,8(sp)
81100978:	dc400117 	ldw	r17,4(sp)
8110097c:	dc000017 	ldw	r16,0(sp)
81100980:	dec00404 	addi	sp,sp,16
81100984:	f800283a 	ret

81100988 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81100988:	deffe304 	addi	sp,sp,-116
8110098c:	de00012e 	bgeu	sp,et,81100994 <bDdr2MemoryReadTest+0xc>
81100990:	003b68fa 	trap	3
81100994:	dfc01c15 	stw	ra,112(sp)
81100998:	df001b15 	stw	fp,108(sp)
8110099c:	dc401a15 	stw	r17,104(sp)
811009a0:	dc001915 	stw	r16,100(sp)
811009a4:	df001b04 	addi	fp,sp,108
811009a8:	2005883a 	mov	r2,r4
811009ac:	e0bffd05 	stb	r2,-12(fp)
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811009b0:	00800044 	movi	r2,1
811009b4:	e0bfe515 	stw	r2,-108(fp)
	switch (ucMemoryId) {
811009b8:	e0bffd03 	ldbu	r2,-12(fp)
811009bc:	10000326 	beq	r2,zero,811009cc <bDdr2MemoryReadTest+0x44>
811009c0:	10800060 	cmpeqi	r2,r2,1
811009c4:	1000081e 	bne	r2,zero,811009e8 <bDdr2MemoryReadTest+0x60>
811009c8:	00000e06 	br	81100a04 <bDdr2MemoryReadTest+0x7c>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
811009cc:	e0bffd03 	ldbu	r2,-12(fp)
811009d0:	1009883a 	mov	r4,r2
811009d4:	11005bc0 	call	811005bc <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811009d8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811009dc:	00a00034 	movhi	r2,32768
811009e0:	e0bfe715 	stw	r2,-100(fp)
		break;
811009e4:	00000a06 	br	81100a10 <bDdr2MemoryReadTest+0x88>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811009e8:	e0bffd03 	ldbu	r2,-12(fp)
811009ec:	1009883a 	mov	r4,r2
811009f0:	11005bc0 	call	811005bc <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811009f4:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811009f8:	00a00034 	movhi	r2,32768
811009fc:	e0bfe715 	stw	r2,-100(fp)
		break;
81100a00:	00000306 	br	81100a10 <bDdr2MemoryReadTest+0x88>
	default:
		bSuccess = FALSE;
81100a04:	e03fe515 	stw	zero,-108(fp)
		sprintf(cDebugBuffer,
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
		;
#endif
		return bSuccess;
81100a08:	e0bfe517 	ldw	r2,-108(fp)
81100a0c:	00007206 	br	81100bd8 <bDdr2MemoryReadTest+0x250>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81100a10:	00804004 	movi	r2,256
81100a14:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81100a18:	00800104 	movi	r2,4
81100a1c:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81100a20:	e0ffec17 	ldw	r3,-80(fp)
81100a24:	e0bfef17 	ldw	r2,-68(fp)
81100a28:	1885383a 	mul	r2,r3,r2
81100a2c:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81100a30:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81100a34:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81100a38:	e03fe815 	stw	zero,-96(fp)
81100a3c:	00001506 	br	81100a94 <bDdr2MemoryReadTest+0x10c>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81100a40:	e0ffe717 	ldw	r3,-100(fp)
81100a44:	00b33374 	movhi	r2,52429
81100a48:	10b33344 	addi	r2,r2,-13107
81100a4c:	1888383a 	mulxuu	r4,r3,r2
81100a50:	1885383a 	mul	r2,r3,r2
81100a54:	1021883a 	mov	r16,r2
81100a58:	2023883a 	mov	r17,r4
81100a5c:	8804d0fa 	srli	r2,r17,3
81100a60:	e0ffe817 	ldw	r3,-96(fp)
81100a64:	18c00044 	addi	r3,r3,1
81100a68:	10c7383a 	mul	r3,r2,r3
81100a6c:	e0bfe817 	ldw	r2,-96(fp)
81100a70:	1085883a 	add	r2,r2,r2
81100a74:	1085883a 	add	r2,r2,r2
81100a78:	e13fe504 	addi	r4,fp,-108
81100a7c:	2085883a 	add	r2,r4,r2
81100a80:	10800e04 	addi	r2,r2,56
81100a84:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81100a88:	e0bfe817 	ldw	r2,-96(fp)
81100a8c:	10800044 	addi	r2,r2,1
81100a90:	e0bfe815 	stw	r2,-96(fp)
81100a94:	e0bfe817 	ldw	r2,-96(fp)
81100a98:	10800290 	cmplti	r2,r2,10
81100a9c:	103fe81e 	bne	r2,zero,81100a40 <__reset+0xfb0e0a40>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81100aa0:	e03fee15 	stw	zero,-72(fp)
81100aa4:	d0a08817 	ldw	r2,-32224(gp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
	debug(fp, cDebugBuffer);
#endif
	iTimeStart = alt_nticks();
81100aa8:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81100aac:	e0bfe617 	ldw	r2,-104(fp)
81100ab0:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81100ab4:	00810004 	movi	r2,1024
81100ab8:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81100abc:	e0ffe917 	ldw	r3,-92(fp)
81100ac0:	e0bfef17 	ldw	r2,-68(fp)
81100ac4:	1885283a 	div	r2,r3,r2
81100ac8:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81100acc:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81100ad0:	00003706 	br	81100bb0 <bDdr2MemoryReadTest+0x228>
		iNRemainedLen = uliByteLen - iNPos;
81100ad4:	e0bfed17 	ldw	r2,-76(fp)
81100ad8:	e0ffe717 	ldw	r3,-100(fp)
81100adc:	1885c83a 	sub	r2,r3,r2
81100ae0:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81100ae4:	e0bfe917 	ldw	r2,-92(fp)
81100ae8:	e0fff217 	ldw	r3,-56(fp)
81100aec:	1880060e 	bge	r3,r2,81100b08 <bDdr2MemoryReadTest+0x180>
			iNAccessLen = iNRemainedLen;
81100af0:	e0bff217 	ldw	r2,-56(fp)
81100af4:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81100af8:	e0ffe917 	ldw	r3,-92(fp)
81100afc:	e0bfef17 	ldw	r2,-68(fp)
81100b00:	1885283a 	div	r2,r3,r2
81100b04:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81100b08:	00a04534 	movhi	r2,33044
81100b0c:	109f1b04 	addi	r2,r2,31852
81100b10:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81100b14:	e03fe815 	stw	zero,-96(fp)
81100b18:	00000d06 	br	81100b50 <bDdr2MemoryReadTest+0x1c8>
			if (*pxSrc++ != *pxDes++) {
81100b1c:	e0bfeb17 	ldw	r2,-84(fp)
81100b20:	10c00104 	addi	r3,r2,4
81100b24:	e0ffeb15 	stw	r3,-84(fp)
81100b28:	10c00017 	ldw	r3,0(r2)
81100b2c:	e0bfea17 	ldw	r2,-88(fp)
81100b30:	11000104 	addi	r4,r2,4
81100b34:	e13fea15 	stw	r4,-88(fp)
81100b38:	10800017 	ldw	r2,0(r2)
81100b3c:	18800126 	beq	r3,r2,81100b44 <bDdr2MemoryReadTest+0x1bc>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
81100b40:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81100b44:	e0bfe817 	ldw	r2,-96(fp)
81100b48:	10800044 	addi	r2,r2,1
81100b4c:	e0bfe815 	stw	r2,-96(fp)
81100b50:	e0ffe817 	ldw	r3,-96(fp)
81100b54:	e0bfec17 	ldw	r2,-80(fp)
81100b58:	1880020e 	bge	r3,r2,81100b64 <bDdr2MemoryReadTest+0x1dc>
81100b5c:	e0bfe517 	ldw	r2,-108(fp)
81100b60:	103fee1e 	bne	r2,zero,81100b1c <__reset+0xfb0e0b1c>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81100b64:	e0ffed17 	ldw	r3,-76(fp)
81100b68:	e0bfe917 	ldw	r2,-92(fp)
81100b6c:	1885883a 	add	r2,r3,r2
81100b70:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81100b74:	e0bfee17 	ldw	r2,-72(fp)
81100b78:	10800288 	cmpgei	r2,r2,10
81100b7c:	10000c1e 	bne	r2,zero,81100bb0 <bDdr2MemoryReadTest+0x228>
81100b80:	e0bfee17 	ldw	r2,-72(fp)
81100b84:	1085883a 	add	r2,r2,r2
81100b88:	1085883a 	add	r2,r2,r2
81100b8c:	e0ffe504 	addi	r3,fp,-108
81100b90:	1885883a 	add	r2,r3,r2
81100b94:	10800e04 	addi	r2,r2,56
81100b98:	10800017 	ldw	r2,0(r2)
81100b9c:	e0ffed17 	ldw	r3,-76(fp)
81100ba0:	18800336 	bltu	r3,r2,81100bb0 <bDdr2MemoryReadTest+0x228>
			iNProgressIndex++;
81100ba4:	e0bfee17 	ldw	r2,-72(fp)
81100ba8:	10800044 	addi	r2,r2,1
81100bac:	e0bfee15 	stw	r2,-72(fp)

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81100bb0:	e0bfe517 	ldw	r2,-108(fp)
81100bb4:	10000326 	beq	r2,zero,81100bc4 <bDdr2MemoryReadTest+0x23c>
81100bb8:	e0ffed17 	ldw	r3,-76(fp)
81100bbc:	e0bfe717 	ldw	r2,-100(fp)
81100bc0:	18bfc436 	bltu	r3,r2,81100ad4 <__reset+0xfb0e0ad4>
81100bc4:	d0e08817 	ldw	r3,-32224(gp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
	debug(fp, cDebugBuffer);
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81100bc8:	e0bff117 	ldw	r2,-60(fp)
81100bcc:	1885c83a 	sub	r2,r3,r2
81100bd0:	e0bff015 	stw	r2,-64(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
	debug(fp, cDebugBuffer);
#endif

	return bSuccess;
81100bd4:	e0bfe517 	ldw	r2,-108(fp)
}
81100bd8:	e6fffe04 	addi	sp,fp,-8
81100bdc:	dfc00317 	ldw	ra,12(sp)
81100be0:	df000217 	ldw	fp,8(sp)
81100be4:	dc400117 	ldw	r17,4(sp)
81100be8:	dc000017 	ldw	r16,0(sp)
81100bec:	dec00404 	addi	sp,sp,16
81100bf0:	f800283a 	ret

81100bf4 <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81100bf4:	deffed04 	addi	sp,sp,-76
81100bf8:	de00012e 	bgeu	sp,et,81100c00 <bDdr2MemoryRandomWriteTest+0xc>
81100bfc:	003b68fa 	trap	3
81100c00:	dfc01215 	stw	ra,72(sp)
81100c04:	df001115 	stw	fp,68(sp)
81100c08:	dcc01015 	stw	r19,64(sp)
81100c0c:	dc800f15 	stw	r18,60(sp)
81100c10:	dc400e15 	stw	r17,56(sp)
81100c14:	dc000d15 	stw	r16,52(sp)
81100c18:	df001104 	addi	fp,sp,68
81100c1c:	2005883a 	mov	r2,r4
81100c20:	e17ffa15 	stw	r5,-24(fp)
81100c24:	e1bffb15 	stw	r6,-20(fp)
81100c28:	e0bff905 	stb	r2,-28(fp)
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81100c2c:	00800044 	movi	r2,1
81100c30:	e0bff415 	stw	r2,-48(fp)
	switch (ucMemoryId) {
81100c34:	e0bff903 	ldbu	r2,-28(fp)
81100c38:	10000326 	beq	r2,zero,81100c48 <bDdr2MemoryRandomWriteTest+0x54>
81100c3c:	10800060 	cmpeqi	r2,r2,1
81100c40:	1000081e 	bne	r2,zero,81100c64 <bDdr2MemoryRandomWriteTest+0x70>
81100c44:	00000e06 	br	81100c80 <bDdr2MemoryRandomWriteTest+0x8c>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81100c48:	e0bff903 	ldbu	r2,-28(fp)
81100c4c:	1009883a 	mov	r4,r2
81100c50:	11005bc0 	call	811005bc <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81100c54:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81100c58:	00a00034 	movhi	r2,32768
81100c5c:	e0bff015 	stw	r2,-64(fp)
		break;
81100c60:	00000a06 	br	81100c8c <bDdr2MemoryRandomWriteTest+0x98>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81100c64:	e0bff903 	ldbu	r2,-28(fp)
81100c68:	1009883a 	mov	r4,r2
81100c6c:	11005bc0 	call	811005bc <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81100c70:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81100c74:	00a00034 	movhi	r2,32768
81100c78:	e0bff015 	stw	r2,-64(fp)
		break;
81100c7c:	00000306 	br	81100c8c <bDdr2MemoryRandomWriteTest+0x98>
	default:
		bSuccess = FALSE;
81100c80:	e03ff415 	stw	zero,-48(fp)
		sprintf(cDebugBuffer,
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
		;
#endif
		return bSuccess;
81100c84:	e0bff417 	ldw	r2,-48(fp)
81100c88:	00004906 	br	81100db0 <bDdr2MemoryRandomWriteTest+0x1bc>
81100c8c:	d0a08817 	ldw	r2,-32224(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
81100c90:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
81100c94:	d0a03717 	ldw	r2,-32548(gp)
81100c98:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81100c9c:	e0ffef17 	ldw	r3,-68(fp)
81100ca0:	e0bff017 	ldw	r2,-64(fp)
81100ca4:	1885883a 	add	r2,r3,r2
81100ca8:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81100cac:	e0fff017 	ldw	r3,-64(fp)
81100cb0:	00b33374 	movhi	r2,52429
81100cb4:	10b33344 	addi	r2,r2,-13107
81100cb8:	1888383a 	mulxuu	r4,r3,r2
81100cbc:	1885383a 	mul	r2,r3,r2
81100cc0:	1025883a 	mov	r18,r2
81100cc4:	2027883a 	mov	r19,r4
81100cc8:	9806d13a 	srli	r3,r19,4
81100ccc:	e0bfef17 	ldw	r2,-68(fp)
81100cd0:	1885883a 	add	r2,r3,r2
81100cd4:	e0bff215 	stw	r2,-56(fp)
	ucPercentage = 5;
81100cd8:	00800144 	movi	r2,5
81100cdc:	e0bff305 	stb	r2,-52(fp)
#if DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
		debug(fp, cDebugBuffer);
#endif
	}
	int TimeStart, TimeElapsed = 0;
81100ce0:	e03ff615 	stw	zero,-40(fp)
81100ce4:	d0a08817 	ldw	r2,-32224(gp)

	TimeStart = alt_nticks();
81100ce8:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81100cec:	e0bfef17 	ldw	r2,-68(fp)
81100cf0:	e0bff115 	stw	r2,-60(fp)
81100cf4:	00002006 	br	81100d78 <bDdr2MemoryRandomWriteTest+0x184>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
81100cf8:	e0bff804 	addi	r2,fp,-32
81100cfc:	1009883a 	mov	r4,r2
81100d00:	1100fa40 	call	81100fa4 <uliXorshift32>
81100d04:	1007883a 	mov	r3,r2
81100d08:	e0bff117 	ldw	r2,-60(fp)
81100d0c:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
81100d10:	e0bffa17 	ldw	r2,-24(fp)
81100d14:	10800060 	cmpeqi	r2,r2,1
81100d18:	1009883a 	mov	r4,r2
81100d1c:	e0bff117 	ldw	r2,-60(fp)
81100d20:	e0fff217 	ldw	r3,-56(fp)
81100d24:	1885803a 	cmpltu	r2,r3,r2
81100d28:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
81100d2c:	10803fcc 	andi	r2,r2,255
81100d30:	10000e26 	beq	r2,zero,81100d6c <bDdr2MemoryRandomWriteTest+0x178>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#if DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
			debug(fp, cDebugBuffer);
#endif
			uliNextMilestone += uliByteLen / 20;
81100d34:	e0fff017 	ldw	r3,-64(fp)
81100d38:	00b33374 	movhi	r2,52429
81100d3c:	10b33344 	addi	r2,r2,-13107
81100d40:	1888383a 	mulxuu	r4,r3,r2
81100d44:	1885383a 	mul	r2,r3,r2
81100d48:	1021883a 	mov	r16,r2
81100d4c:	2023883a 	mov	r17,r4
81100d50:	8804d13a 	srli	r2,r17,4
81100d54:	e0fff217 	ldw	r3,-56(fp)
81100d58:	1885883a 	add	r2,r3,r2
81100d5c:	e0bff215 	stw	r2,-56(fp)
			ucPercentage += 5;
81100d60:	e0bff303 	ldbu	r2,-52(fp)
81100d64:	10800144 	addi	r2,r2,5
81100d68:	e0bff305 	stb	r2,-52(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
81100d6c:	e0bff117 	ldw	r2,-60(fp)
81100d70:	10800104 	addi	r2,r2,4
81100d74:	e0bff115 	stw	r2,-60(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
81100d78:	e0fff117 	ldw	r3,-60(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
81100d7c:	e0bff517 	ldw	r2,-44(fp)
81100d80:	18bfdd36 	bltu	r3,r2,81100cf8 <__reset+0xfb0e0cf8>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
81100d84:	112f1b80 	call	8112f1b8 <alt_dcache_flush_all>
		sprintf(cDebugBuffer, "..100%%\n");
		debug(fp, cDebugBuffer);
#endif
	}

	if (bSuccess) {
81100d88:	e0bff417 	ldw	r2,-48(fp)
81100d8c:	10000726 	beq	r2,zero,81100dac <bDdr2MemoryRandomWriteTest+0x1b8>
		if (bTime == TRUE) {
81100d90:	e0bffb17 	ldw	r2,-20(fp)
81100d94:	10800058 	cmpnei	r2,r2,1
81100d98:	1000041e 	bne	r2,zero,81100dac <bDdr2MemoryRandomWriteTest+0x1b8>
81100d9c:	d0e08817 	ldw	r3,-32224(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81100da0:	e0bff717 	ldw	r2,-36(fp)
81100da4:	1885c83a 	sub	r2,r3,r2
81100da8:	e0bff615 	stw	r2,-40(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
	debug(fp, cDebugBuffer);
#endif

	return bSuccess;
81100dac:	e0bff417 	ldw	r2,-48(fp)
}
81100db0:	e6fffc04 	addi	sp,fp,-16
81100db4:	dfc00517 	ldw	ra,20(sp)
81100db8:	df000417 	ldw	fp,16(sp)
81100dbc:	dcc00317 	ldw	r19,12(sp)
81100dc0:	dc800217 	ldw	r18,8(sp)
81100dc4:	dc400117 	ldw	r17,4(sp)
81100dc8:	dc000017 	ldw	r16,0(sp)
81100dcc:	dec00604 	addi	sp,sp,24
81100dd0:	f800283a 	ret

81100dd4 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81100dd4:	deffed04 	addi	sp,sp,-76
81100dd8:	de00012e 	bgeu	sp,et,81100de0 <bDdr2MemoryRandomReadTest+0xc>
81100ddc:	003b68fa 	trap	3
81100de0:	dfc01215 	stw	ra,72(sp)
81100de4:	df001115 	stw	fp,68(sp)
81100de8:	dcc01015 	stw	r19,64(sp)
81100dec:	dc800f15 	stw	r18,60(sp)
81100df0:	dc400e15 	stw	r17,56(sp)
81100df4:	dc000d15 	stw	r16,52(sp)
81100df8:	df001104 	addi	fp,sp,68
81100dfc:	2005883a 	mov	r2,r4
81100e00:	e17ffa15 	stw	r5,-24(fp)
81100e04:	e1bffb15 	stw	r6,-20(fp)
81100e08:	e0bff905 	stb	r2,-28(fp)
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81100e0c:	00800044 	movi	r2,1
81100e10:	e0bfef15 	stw	r2,-68(fp)
	switch (ucMemoryId) {
81100e14:	e0bff903 	ldbu	r2,-28(fp)
81100e18:	10000326 	beq	r2,zero,81100e28 <bDdr2MemoryRandomReadTest+0x54>
81100e1c:	10800060 	cmpeqi	r2,r2,1
81100e20:	1000081e 	bne	r2,zero,81100e44 <bDdr2MemoryRandomReadTest+0x70>
81100e24:	00000e06 	br	81100e60 <bDdr2MemoryRandomReadTest+0x8c>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81100e28:	e0bff903 	ldbu	r2,-28(fp)
81100e2c:	1009883a 	mov	r4,r2
81100e30:	11005bc0 	call	811005bc <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81100e34:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81100e38:	00a00034 	movhi	r2,32768
81100e3c:	e0bff115 	stw	r2,-60(fp)
		break;
81100e40:	00000a06 	br	81100e6c <bDdr2MemoryRandomReadTest+0x98>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81100e44:	e0bff903 	ldbu	r2,-28(fp)
81100e48:	1009883a 	mov	r4,r2
81100e4c:	11005bc0 	call	811005bc <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81100e50:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81100e54:	00a00034 	movhi	r2,32768
81100e58:	e0bff115 	stw	r2,-60(fp)
		break;
81100e5c:	00000306 	br	81100e6c <bDdr2MemoryRandomReadTest+0x98>
	default:
		bSuccess = FALSE;
81100e60:	e03fef15 	stw	zero,-68(fp)
		sprintf(cDebugBuffer,
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
		;
#endif
		return bSuccess;
81100e64:	e0bfef17 	ldw	r2,-68(fp)
81100e68:	00004506 	br	81100f80 <bDdr2MemoryRandomReadTest+0x1ac>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
81100e6c:	d0a03717 	ldw	r2,-32548(gp)
81100e70:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81100e74:	e0fff017 	ldw	r3,-64(fp)
81100e78:	e0bff117 	ldw	r2,-60(fp)
81100e7c:	1885883a 	add	r2,r3,r2
81100e80:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81100e84:	e0fff117 	ldw	r3,-60(fp)
81100e88:	00b33374 	movhi	r2,52429
81100e8c:	10b33344 	addi	r2,r2,-13107
81100e90:	1888383a 	mulxuu	r4,r3,r2
81100e94:	1885383a 	mul	r2,r3,r2
81100e98:	1025883a 	mov	r18,r2
81100e9c:	2027883a 	mov	r19,r4
81100ea0:	9806d13a 	srli	r3,r19,4
81100ea4:	e0bff017 	ldw	r2,-64(fp)
81100ea8:	1885883a 	add	r2,r3,r2
81100eac:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
81100eb0:	00800144 	movi	r2,5
81100eb4:	e0bff405 	stb	r2,-48(fp)
		sprintf(cDebugBuffer, "00%%..");
		debug(fp, cDebugBuffer);
#endif
	}

	int TimeStart, TimeElapsed = 0;
81100eb8:	e03ff615 	stw	zero,-40(fp)
81100ebc:	d0a08817 	ldw	r2,-32224(gp)

	TimeStart = alt_nticks();
81100ec0:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
81100ec4:	e0bff017 	ldw	r2,-64(fp)
81100ec8:	e0bff215 	stw	r2,-56(fp)
81100ecc:	00001f06 	br	81100f4c <bDdr2MemoryRandomReadTest+0x178>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
81100ed0:	e0bff804 	addi	r2,fp,-32
81100ed4:	1009883a 	mov	r4,r2
81100ed8:	1100fa40 	call	81100fa4 <uliXorshift32>
81100edc:	1007883a 	mov	r3,r2
81100ee0:	e0bff217 	ldw	r2,-56(fp)
81100ee4:	10800017 	ldw	r2,0(r2)
81100ee8:	18800126 	beq	r3,r2,81100ef0 <bDdr2MemoryRandomReadTest+0x11c>
			bSuccess = FALSE;
81100eec:	e03fef15 	stw	zero,-68(fp)
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
81100ef0:	e0bffa17 	ldw	r2,-24(fp)
81100ef4:	10800058 	cmpnei	r2,r2,1
81100ef8:	1000111e 	bne	r2,zero,81100f40 <bDdr2MemoryRandomReadTest+0x16c>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
81100efc:	e0bff217 	ldw	r2,-56(fp)
81100f00:	e0fff317 	ldw	r3,-52(fp)
81100f04:	18800e2e 	bgeu	r3,r2,81100f40 <bDdr2MemoryRandomReadTest+0x16c>
#if DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
			debug(fp, cDebugBuffer);
#endif
			uliNextMilestone += uliByteLen / 20;
81100f08:	e0fff117 	ldw	r3,-60(fp)
81100f0c:	00b33374 	movhi	r2,52429
81100f10:	10b33344 	addi	r2,r2,-13107
81100f14:	1888383a 	mulxuu	r4,r3,r2
81100f18:	1885383a 	mul	r2,r3,r2
81100f1c:	1021883a 	mov	r16,r2
81100f20:	2023883a 	mov	r17,r4
81100f24:	8804d13a 	srli	r2,r17,4
81100f28:	e0fff317 	ldw	r3,-52(fp)
81100f2c:	1885883a 	add	r2,r3,r2
81100f30:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
81100f34:	e0bff403 	ldbu	r2,-48(fp)
81100f38:	10800144 	addi	r2,r2,5
81100f3c:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
81100f40:	e0bff217 	ldw	r2,-56(fp)
81100f44:	10800104 	addi	r2,r2,4
81100f48:	e0bff215 	stw	r2,-56(fp)
81100f4c:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
81100f50:	e0bff517 	ldw	r2,-44(fp)
81100f54:	18bfde36 	bltu	r3,r2,81100ed0 <__reset+0xfb0e0ed0>
		sprintf(cDebugBuffer, "..100%%\n");
		debug(fp, cDebugBuffer);
#endif
	}

	if (bSuccess) {
81100f58:	e0bfef17 	ldw	r2,-68(fp)
81100f5c:	10000726 	beq	r2,zero,81100f7c <bDdr2MemoryRandomReadTest+0x1a8>
		if (bTime == TRUE) {
81100f60:	e0bffb17 	ldw	r2,-20(fp)
81100f64:	10800058 	cmpnei	r2,r2,1
81100f68:	1000041e 	bne	r2,zero,81100f7c <bDdr2MemoryRandomReadTest+0x1a8>
81100f6c:	d0e08817 	ldw	r3,-32224(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81100f70:	e0bff717 	ldw	r2,-36(fp)
81100f74:	1885c83a 	sub	r2,r3,r2
81100f78:	e0bff615 	stw	r2,-40(fp)
#if DEBUG_ON
	sprintf(cDebugBuffer, "\n");
	debug(fp, cDebugBuffer);
#endif

	return bSuccess;
81100f7c:	e0bfef17 	ldw	r2,-68(fp)
}
81100f80:	e6fffc04 	addi	sp,fp,-16
81100f84:	dfc00517 	ldw	ra,20(sp)
81100f88:	df000417 	ldw	fp,16(sp)
81100f8c:	dcc00317 	ldw	r19,12(sp)
81100f90:	dc800217 	ldw	r18,8(sp)
81100f94:	dc400117 	ldw	r17,4(sp)
81100f98:	dc000017 	ldw	r16,0(sp)
81100f9c:	dec00604 	addi	sp,sp,24
81100fa0:	f800283a 	ret

81100fa4 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
81100fa4:	defffd04 	addi	sp,sp,-12
81100fa8:	de00012e 	bgeu	sp,et,81100fb0 <uliXorshift32+0xc>
81100fac:	003b68fa 	trap	3
81100fb0:	df000215 	stw	fp,8(sp)
81100fb4:	df000204 	addi	fp,sp,8
81100fb8:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
81100fbc:	e0bfff17 	ldw	r2,-4(fp)
81100fc0:	10800017 	ldw	r2,0(r2)
81100fc4:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81100fc8:	e0bffe17 	ldw	r2,-8(fp)
81100fcc:	1004937a 	slli	r2,r2,13
81100fd0:	e0fffe17 	ldw	r3,-8(fp)
81100fd4:	1884f03a 	xor	r2,r3,r2
81100fd8:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
81100fdc:	e0bffe17 	ldw	r2,-8(fp)
81100fe0:	1004d47a 	srli	r2,r2,17
81100fe4:	e0fffe17 	ldw	r3,-8(fp)
81100fe8:	1884f03a 	xor	r2,r3,r2
81100fec:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
81100ff0:	e0bffe17 	ldw	r2,-8(fp)
81100ff4:	1004917a 	slli	r2,r2,5
81100ff8:	e0fffe17 	ldw	r3,-8(fp)
81100ffc:	1884f03a 	xor	r2,r3,r2
81101000:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
81101004:	e0bfff17 	ldw	r2,-4(fp)
81101008:	e0fffe17 	ldw	r3,-8(fp)
8110100c:	10c00015 	stw	r3,0(r2)

	return uliX;
81101010:	e0bffe17 	ldw	r2,-8(fp)
}
81101014:	e037883a 	mov	sp,fp
81101018:	df000017 	ldw	fp,0(sp)
8110101c:	dec00104 	addi	sp,sp,4
81101020:	f800283a 	ret

81101024 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
81101024:	defffb04 	addi	sp,sp,-20
81101028:	de00012e 	bgeu	sp,et,81101030 <DMA_OPEN_DEVICE+0xc>
8110102c:	003b68fa 	trap	3
81101030:	dfc00415 	stw	ra,16(sp)
81101034:	df000315 	stw	fp,12(sp)
81101038:	df000304 	addi	fp,sp,12
8110103c:	e13ffe15 	stw	r4,-8(fp)
81101040:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81101044:	00800044 	movi	r2,1
81101048:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
8110104c:	e13fff17 	ldw	r4,-4(fp)
81101050:	114280c0 	call	8114280c <alt_msgdma_open>
81101054:	1007883a 	mov	r3,r2
81101058:	e0bffe17 	ldw	r2,-8(fp)
8110105c:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
81101060:	e0bffe17 	ldw	r2,-8(fp)
81101064:	10800017 	ldw	r2,0(r2)
81101068:	1000011e 	bne	r2,zero,81101070 <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
8110106c:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
81101070:	e0bffd17 	ldw	r2,-12(fp)
}
81101074:	e037883a 	mov	sp,fp
81101078:	dfc00117 	ldw	ra,4(sp)
8110107c:	df000017 	ldw	fp,0(sp)
81101080:	dec00204 	addi	sp,sp,8
81101084:	f800283a 	ret

81101088 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
81101088:	defffc04 	addi	sp,sp,-16
8110108c:	de00012e 	bgeu	sp,et,81101094 <DMA_CONFIG+0xc>
81101090:	003b68fa 	trap	3
81101094:	df000315 	stw	fp,12(sp)
81101098:	df000304 	addi	fp,sp,12
8110109c:	e13ffe15 	stw	r4,-8(fp)
811010a0:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
811010a4:	00800044 	movi	r2,1
811010a8:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
811010ac:	e0bffe17 	ldw	r2,-8(fp)
811010b0:	10800317 	ldw	r2,12(r2)
811010b4:	10800104 	addi	r2,r2,4
811010b8:	e0ffff17 	ldw	r3,-4(fp)
811010bc:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
811010c0:	e0bffd17 	ldw	r2,-12(fp)
}
811010c4:	e037883a 	mov	sp,fp
811010c8:	df000017 	ldw	fp,0(sp)
811010cc:	dec00104 	addi	sp,sp,4
811010d0:	f800283a 	ret

811010d4 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
811010d4:	defffd04 	addi	sp,sp,-12
811010d8:	de00012e 	bgeu	sp,et,811010e0 <DMA_BUSY+0xc>
811010dc:	003b68fa 	trap	3
811010e0:	df000215 	stw	fp,8(sp)
811010e4:	df000204 	addi	fp,sp,8
811010e8:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
811010ec:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
811010f0:	e0bfff17 	ldw	r2,-4(fp)
811010f4:	10800317 	ldw	r2,12(r2)
811010f8:	10800037 	ldwio	r2,0(r2)
811010fc:	1080004c 	andi	r2,r2,1
81101100:	10000226 	beq	r2,zero,8110110c <DMA_BUSY+0x38>
    bBusy = TRUE;
81101104:	00800044 	movi	r2,1
81101108:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
8110110c:	e0bffe17 	ldw	r2,-8(fp)
}
81101110:	e037883a 	mov	sp,fp
81101114:	df000017 	ldw	fp,0(sp)
81101118:	dec00104 	addi	sp,sp,4
8110111c:	f800283a 	ret

81101120 <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81101120:	defffd04 	addi	sp,sp,-12
81101124:	de00012e 	bgeu	sp,et,8110112c <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81101128:	003b68fa 	trap	3
8110112c:	df000215 	stw	fp,8(sp)
81101130:	df000204 	addi	fp,sp,8
81101134:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81101138:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
8110113c:	e0bfff17 	ldw	r2,-4(fp)
81101140:	10800317 	ldw	r2,12(r2)
81101144:	10800037 	ldwio	r2,0(r2)
81101148:	1080010c 	andi	r2,r2,4
8110114c:	10000226 	beq	r2,zero,81101158 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81101150:	00800044 	movi	r2,1
81101154:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81101158:	e0bffe17 	ldw	r2,-8(fp)
}
8110115c:	e037883a 	mov	sp,fp
81101160:	df000017 	ldw	fp,0(sp)
81101164:	dec00104 	addi	sp,sp,4
81101168:	f800283a 	ret

8110116c <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
8110116c:	defffd04 	addi	sp,sp,-12
81101170:	de00012e 	bgeu	sp,et,81101178 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81101174:	003b68fa 	trap	3
81101178:	df000215 	stw	fp,8(sp)
8110117c:	df000204 	addi	fp,sp,8
81101180:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81101184:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81101188:	e0bfff17 	ldw	r2,-4(fp)
8110118c:	10800317 	ldw	r2,12(r2)
81101190:	10800037 	ldwio	r2,0(r2)
81101194:	1080008c 	andi	r2,r2,2
81101198:	10000226 	beq	r2,zero,811011a4 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
8110119c:	00800044 	movi	r2,1
811011a0:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
811011a4:	e0bffe17 	ldw	r2,-8(fp)
}
811011a8:	e037883a 	mov	sp,fp
811011ac:	df000017 	ldw	fp,0(sp)
811011b0:	dec00104 	addi	sp,sp,4
811011b4:	f800283a 	ret

811011b8 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
811011b8:	defffa04 	addi	sp,sp,-24
811011bc:	de00012e 	bgeu	sp,et,811011c4 <DMA_DISPATCHER_STOP+0xc>
811011c0:	003b68fa 	trap	3
811011c4:	dfc00515 	stw	ra,20(sp)
811011c8:	df000415 	stw	fp,16(sp)
811011cc:	df000404 	addi	fp,sp,16
811011d0:	e13ffd15 	stw	r4,-12(fp)
811011d4:	e17ffe15 	stw	r5,-8(fp)
811011d8:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
811011dc:	00800044 	movi	r2,1
811011e0:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
811011e4:	e0bffd17 	ldw	r2,-12(fp)
811011e8:	10800317 	ldw	r2,12(r2)
811011ec:	10800104 	addi	r2,r2,4
811011f0:	00c00044 	movi	r3,1
811011f4:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
811011f8:	e0bffe17 	ldw	r2,-8(fp)
811011fc:	10800058 	cmpnei	r2,r2,1
81101200:	10000f1e 	bne	r2,zero,81101240 <DMA_DISPATCHER_STOP+0x88>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81101204:	00000806 	br	81101228 <DMA_DISPATCHER_STOP+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81101208:	e0bfff17 	ldw	r2,-4(fp)
8110120c:	1000031e 	bne	r2,zero,8110121c <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81101210:	01000044 	movi	r4,1
81101214:	11307740 	call	81130774 <usleep>
81101218:	00000306 	br	81101228 <DMA_DISPATCHER_STOP+0x70>
      } else {
        usleep(WaitPeriodUs);
8110121c:	e0bfff17 	ldw	r2,-4(fp)
81101220:	1009883a 	mov	r4,r2
81101224:	11307740 	call	81130774 <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81101228:	e0bffd17 	ldw	r2,-12(fp)
8110122c:	10800317 	ldw	r2,12(r2)
81101230:	10800037 	ldwio	r2,0(r2)
81101234:	1080080c 	andi	r2,r2,32
81101238:	103ff31e 	bne	r2,zero,81101208 <__reset+0xfb0e1208>
8110123c:	00000206 	br	81101248 <DMA_DISPATCHER_STOP+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81101240:	e0bffc17 	ldw	r2,-16(fp)
81101244:	00000106 	br	8110124c <DMA_DISPATCHER_STOP+0x94>
  }
  
  return bSuccess;
81101248:	e0bffc17 	ldw	r2,-16(fp)
}
8110124c:	e037883a 	mov	sp,fp
81101250:	dfc00117 	ldw	ra,4(sp)
81101254:	df000017 	ldw	fp,0(sp)
81101258:	dec00204 	addi	sp,sp,8
8110125c:	f800283a 	ret

81101260 <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81101260:	defffa04 	addi	sp,sp,-24
81101264:	de00012e 	bgeu	sp,et,8110126c <DMA_DISPATCHER_RESET+0xc>
81101268:	003b68fa 	trap	3
8110126c:	dfc00515 	stw	ra,20(sp)
81101270:	df000415 	stw	fp,16(sp)
81101274:	df000404 	addi	fp,sp,16
81101278:	e13ffd15 	stw	r4,-12(fp)
8110127c:	e17ffe15 	stw	r5,-8(fp)
81101280:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81101284:	00800044 	movi	r2,1
81101288:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
8110128c:	e0bffd17 	ldw	r2,-12(fp)
81101290:	10800317 	ldw	r2,12(r2)
81101294:	10800104 	addi	r2,r2,4
81101298:	00c00084 	movi	r3,2
8110129c:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
811012a0:	e0bffe17 	ldw	r2,-8(fp)
811012a4:	10800058 	cmpnei	r2,r2,1
811012a8:	10000f1e 	bne	r2,zero,811012e8 <DMA_DISPATCHER_RESET+0x88>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
811012ac:	00000806 	br	811012d0 <DMA_DISPATCHER_RESET+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
811012b0:	e0bfff17 	ldw	r2,-4(fp)
811012b4:	1000031e 	bne	r2,zero,811012c4 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
811012b8:	01000044 	movi	r4,1
811012bc:	11307740 	call	81130774 <usleep>
811012c0:	00000306 	br	811012d0 <DMA_DISPATCHER_RESET+0x70>
      } else {
        usleep(WaitPeriodUs);
811012c4:	e0bfff17 	ldw	r2,-4(fp)
811012c8:	1009883a 	mov	r4,r2
811012cc:	11307740 	call	81130774 <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
811012d0:	e0bffd17 	ldw	r2,-12(fp)
811012d4:	10800317 	ldw	r2,12(r2)
811012d8:	10800037 	ldwio	r2,0(r2)
811012dc:	1080100c 	andi	r2,r2,64
811012e0:	103ff31e 	bne	r2,zero,811012b0 <__reset+0xfb0e12b0>
811012e4:	00000206 	br	811012f0 <DMA_DISPATCHER_RESET+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
811012e8:	e0bffc17 	ldw	r2,-16(fp)
811012ec:	00000106 	br	811012f4 <DMA_DISPATCHER_RESET+0x94>
  }
  
  return bSuccess;
811012f0:	e0bffc17 	ldw	r2,-16(fp)
}
811012f4:	e037883a 	mov	sp,fp
811012f8:	dfc00117 	ldw	ra,4(sp)
811012fc:	df000017 	ldw	fp,0(sp)
81101300:	dec00204 	addi	sp,sp,8
81101304:	f800283a 	ret

81101308 <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81101308:	defff604 	addi	sp,sp,-40
8110130c:	de00012e 	bgeu	sp,et,81101314 <DMA_SINGLE_TRANSFER+0xc>
81101310:	003b68fa 	trap	3
81101314:	dfc00915 	stw	ra,36(sp)
81101318:	df000815 	stw	fp,32(sp)
8110131c:	dc000715 	stw	r16,28(sp)
81101320:	df000804 	addi	fp,sp,32
81101324:	e13ffb15 	stw	r4,-20(fp)
81101328:	e17ffc15 	stw	r5,-16(fp)
8110132c:	e1bffd15 	stw	r6,-12(fp)
81101330:	e1fffe15 	stw	r7,-8(fp)
81101334:	defff804 	addi	sp,sp,-32
81101338:	d8800204 	addi	r2,sp,8
8110133c:	108003c4 	addi	r2,r2,15
81101340:	1004d13a 	srli	r2,r2,4
81101344:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81101348:	00800044 	movi	r2,1
8110134c:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81101350:	e0fffc17 	ldw	r3,-16(fp)
81101354:	e13ffd17 	ldw	r4,-12(fp)
81101358:	e0800217 	ldw	r2,8(fp)
8110135c:	d8800115 	stw	r2,4(sp)
81101360:	e0bffe17 	ldw	r2,-8(fp)
81101364:	d8800015 	stw	r2,0(sp)
81101368:	200f883a 	mov	r7,r4
8110136c:	180d883a 	mov	r6,r3
81101370:	800b883a 	mov	r5,r16
81101374:	e13ffb17 	ldw	r4,-20(fp)
81101378:	11418080 	call	81141808 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
8110137c:	10000326 	beq	r2,zero,8110138c <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81101380:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81101384:	e0bffa17 	ldw	r2,-24(fp)
81101388:	00001e06 	br	81101404 <DMA_SINGLE_TRANSFER+0xfc>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
8110138c:	800b883a 	mov	r5,r16
81101390:	e13ffb17 	ldw	r4,-20(fp)
81101394:	1142a7c0 	call	81142a7c <alt_msgdma_standard_descriptor_async_transfer>
81101398:	10000326 	beq	r2,zero,811013a8 <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
8110139c:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
811013a0:	e0bffa17 	ldw	r2,-24(fp)
811013a4:	00001706 	br	81101404 <DMA_SINGLE_TRANSFER+0xfc>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
811013a8:	e0bffa17 	ldw	r2,-24(fp)
811013ac:	10800060 	cmpeqi	r2,r2,1
811013b0:	1007883a 	mov	r3,r2
811013b4:	e0800317 	ldw	r2,12(fp)
811013b8:	10800060 	cmpeqi	r2,r2,1
811013bc:	1884703a 	and	r2,r3,r2
811013c0:	10803fcc 	andi	r2,r2,255
811013c4:	10000e26 	beq	r2,zero,81101400 <DMA_SINGLE_TRANSFER+0xf8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
811013c8:	00000806 	br	811013ec <DMA_SINGLE_TRANSFER+0xe4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
811013cc:	e0800417 	ldw	r2,16(fp)
811013d0:	1000031e 	bne	r2,zero,811013e0 <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
811013d4:	0100fa04 	movi	r4,1000
811013d8:	11307740 	call	81130774 <usleep>
811013dc:	00000306 	br	811013ec <DMA_SINGLE_TRANSFER+0xe4>
      } else {
        usleep(WaitPeriodUs);
811013e0:	e0800417 	ldw	r2,16(fp)
811013e4:	1009883a 	mov	r4,r2
811013e8:	11307740 	call	81130774 <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
811013ec:	e0bffb17 	ldw	r2,-20(fp)
811013f0:	10800317 	ldw	r2,12(r2)
811013f4:	10800037 	ldwio	r2,0(r2)
811013f8:	1080004c 	andi	r2,r2,1
811013fc:	103ff31e 	bne	r2,zero,811013cc <__reset+0xfb0e13cc>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81101400:	e0bffa17 	ldw	r2,-24(fp)
}
81101404:	e6ffff04 	addi	sp,fp,-4
81101408:	dfc00217 	ldw	ra,8(sp)
8110140c:	df000117 	ldw	fp,4(sp)
81101410:	dc000017 	ldw	r16,0(sp)
81101414:	dec00304 	addi	sp,sp,12
81101418:	f800283a 	ret

8110141c <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
8110141c:	defff504 	addi	sp,sp,-44
81101420:	de00012e 	bgeu	sp,et,81101428 <DMA_MULTIPLE_TRANSFER+0xc>
81101424:	003b68fa 	trap	3
81101428:	dfc00a15 	stw	ra,40(sp)
8110142c:	df000915 	stw	fp,36(sp)
81101430:	dc000815 	stw	r16,32(sp)
81101434:	df000904 	addi	fp,sp,36
81101438:	e13ffb15 	stw	r4,-20(fp)
8110143c:	e17ffc15 	stw	r5,-16(fp)
81101440:	e1bffd15 	stw	r6,-12(fp)
81101444:	3805883a 	mov	r2,r7
81101448:	e0bffe05 	stb	r2,-8(fp)
8110144c:	defff804 	addi	sp,sp,-32
81101450:	d8800204 	addi	r2,sp,8
81101454:	108003c4 	addi	r2,r2,15
81101458:	1004d13a 	srli	r2,r2,4
8110145c:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81101460:	00800044 	movi	r2,1
81101464:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81101468:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
8110146c:	00002506 	br	81101504 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81101470:	e0bffa03 	ldbu	r2,-24(fp)
81101474:	1085883a 	add	r2,r2,r2
81101478:	1085883a 	add	r2,r2,r2
8110147c:	1007883a 	mov	r3,r2
81101480:	e0bffc17 	ldw	r2,-16(fp)
81101484:	10c5883a 	add	r2,r2,r3
81101488:	10800017 	ldw	r2,0(r2)
8110148c:	1009883a 	mov	r4,r2
81101490:	e0bffa03 	ldbu	r2,-24(fp)
81101494:	1085883a 	add	r2,r2,r2
81101498:	1085883a 	add	r2,r2,r2
8110149c:	1007883a 	mov	r3,r2
811014a0:	e0bffd17 	ldw	r2,-12(fp)
811014a4:	10c5883a 	add	r2,r2,r3
811014a8:	10800017 	ldw	r2,0(r2)
811014ac:	1007883a 	mov	r3,r2
811014b0:	e0800317 	ldw	r2,12(fp)
811014b4:	10804034 	orhi	r2,r2,256
811014b8:	d8800115 	stw	r2,4(sp)
811014bc:	e0800217 	ldw	r2,8(fp)
811014c0:	d8800015 	stw	r2,0(sp)
811014c4:	180f883a 	mov	r7,r3
811014c8:	200d883a 	mov	r6,r4
811014cc:	800b883a 	mov	r5,r16
811014d0:	e13ffb17 	ldw	r4,-20(fp)
811014d4:	11418080 	call	81141808 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
811014d8:	10000226 	beq	r2,zero,811014e4 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
811014dc:	e03ff915 	stw	zero,-28(fp)
811014e0:	00000506 	br	811014f8 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
811014e4:	800b883a 	mov	r5,r16
811014e8:	e13ffb17 	ldw	r4,-20(fp)
811014ec:	1142a7c0 	call	81142a7c <alt_msgdma_standard_descriptor_async_transfer>
811014f0:	10000126 	beq	r2,zero,811014f8 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
811014f4:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
811014f8:	e0bffa03 	ldbu	r2,-24(fp)
811014fc:	10800044 	addi	r2,r2,1
81101500:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81101504:	e0bff917 	ldw	r2,-28(fp)
81101508:	10800060 	cmpeqi	r2,r2,1
8110150c:	1009883a 	mov	r4,r2
81101510:	e0fffa03 	ldbu	r3,-24(fp)
81101514:	e0bffe03 	ldbu	r2,-8(fp)
81101518:	10bfffc4 	addi	r2,r2,-1
8110151c:	1884803a 	cmplt	r2,r3,r2
81101520:	2084703a 	and	r2,r4,r2
81101524:	10803fcc 	andi	r2,r2,255
81101528:	103fd11e 	bne	r2,zero,81101470 <__reset+0xfb0e1470>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
8110152c:	e0bff917 	ldw	r2,-28(fp)
81101530:	10800058 	cmpnei	r2,r2,1
81101534:	1000211e 	bne	r2,zero,811015bc <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81101538:	e0bffa03 	ldbu	r2,-24(fp)
8110153c:	1085883a 	add	r2,r2,r2
81101540:	1085883a 	add	r2,r2,r2
81101544:	1007883a 	mov	r3,r2
81101548:	e0bffc17 	ldw	r2,-16(fp)
8110154c:	10c5883a 	add	r2,r2,r3
81101550:	10800017 	ldw	r2,0(r2)
81101554:	1009883a 	mov	r4,r2
81101558:	e0bffa03 	ldbu	r2,-24(fp)
8110155c:	1085883a 	add	r2,r2,r2
81101560:	1085883a 	add	r2,r2,r2
81101564:	1007883a 	mov	r3,r2
81101568:	e0bffd17 	ldw	r2,-12(fp)
8110156c:	10c5883a 	add	r2,r2,r3
81101570:	10800017 	ldw	r2,0(r2)
81101574:	1007883a 	mov	r3,r2
81101578:	e0800317 	ldw	r2,12(fp)
8110157c:	d8800115 	stw	r2,4(sp)
81101580:	e0800217 	ldw	r2,8(fp)
81101584:	d8800015 	stw	r2,0(sp)
81101588:	180f883a 	mov	r7,r3
8110158c:	200d883a 	mov	r6,r4
81101590:	800b883a 	mov	r5,r16
81101594:	e13ffb17 	ldw	r4,-20(fp)
81101598:	11418080 	call	81141808 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
8110159c:	10000226 	beq	r2,zero,811015a8 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
811015a0:	e03ff915 	stw	zero,-28(fp)
811015a4:	00000506 	br	811015bc <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
811015a8:	800b883a 	mov	r5,r16
811015ac:	e13ffb17 	ldw	r4,-20(fp)
811015b0:	1142a7c0 	call	81142a7c <alt_msgdma_standard_descriptor_async_transfer>
811015b4:	10000126 	beq	r2,zero,811015bc <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
811015b8:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
811015bc:	e0bff917 	ldw	r2,-28(fp)
811015c0:	10800060 	cmpeqi	r2,r2,1
811015c4:	1007883a 	mov	r3,r2
811015c8:	e0800417 	ldw	r2,16(fp)
811015cc:	10800060 	cmpeqi	r2,r2,1
811015d0:	1884703a 	and	r2,r3,r2
811015d4:	10803fcc 	andi	r2,r2,255
811015d8:	10000e26 	beq	r2,zero,81101614 <DMA_MULTIPLE_TRANSFER+0x1f8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
811015dc:	00000806 	br	81101600 <DMA_MULTIPLE_TRANSFER+0x1e4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
811015e0:	e0800517 	ldw	r2,20(fp)
811015e4:	1000031e 	bne	r2,zero,811015f4 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
811015e8:	0100fa04 	movi	r4,1000
811015ec:	11307740 	call	81130774 <usleep>
811015f0:	00000306 	br	81101600 <DMA_MULTIPLE_TRANSFER+0x1e4>
      } else {
    	usleep(WaitPeriodUs);
811015f4:	e0800517 	ldw	r2,20(fp)
811015f8:	1009883a 	mov	r4,r2
811015fc:	11307740 	call	81130774 <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81101600:	e0bffb17 	ldw	r2,-20(fp)
81101604:	10800317 	ldw	r2,12(r2)
81101608:	10800037 	ldwio	r2,0(r2)
8110160c:	1080004c 	andi	r2,r2,1
81101610:	103ff31e 	bne	r2,zero,811015e0 <__reset+0xfb0e15e0>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81101614:	e0bff917 	ldw	r2,-28(fp)
}
81101618:	e6ffff04 	addi	sp,fp,-4
8110161c:	dfc00217 	ldw	ra,8(sp)
81101620:	df000117 	ldw	fp,4(sp)
81101624:	dc000017 	ldw	r16,0(sp)
81101628:	dec00304 	addi	sp,sp,12
8110162c:	f800283a 	ret

81101630 <POWER_Read>:

#if DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81101630:	deffef04 	addi	sp,sp,-68
81101634:	de00012e 	bgeu	sp,et,8110163c <POWER_Read+0xc>
81101638:	003b68fa 	trap	3
8110163c:	dfc01015 	stw	ra,64(sp)
81101640:	df000f15 	stw	fp,60(sp)
81101644:	df000f04 	addi	fp,sp,60
81101648:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
8110164c:	00800044 	movi	r2,1
81101650:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81101654:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81101658:	00800204 	movi	r2,8
8110165c:	e0bffc15 	stw	r2,-16(fp)
81101660:	00800104 	movi	r2,4
81101664:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81101668:	00800044 	movi	r2,1
8110166c:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81101670:	00800044 	movi	r2,1
81101674:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81101678:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
8110167c:	e03ff515 	stw	zero,-44(fp)
81101680:	00005e06 	br	811017fc <POWER_Read+0x1cc>
		NextChannel = 0;
81101684:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81101688:	e0bff517 	ldw	r2,-44(fp)
8110168c:	10c03fcc 	andi	r3,r2,255
81101690:	e13ffa03 	ldbu	r4,-24(fp)
81101694:	e0bfff17 	ldw	r2,-4(fp)
81101698:	d8800115 	stw	r2,4(sp)
8110169c:	e0bff917 	ldw	r2,-28(fp)
811016a0:	d8800015 	stw	r2,0(sp)
811016a4:	e1fff817 	ldw	r7,-32(fp)
811016a8:	e1bff717 	ldw	r6,-36(fp)
811016ac:	200b883a 	mov	r5,r4
811016b0:	1809883a 	mov	r4,r3
811016b4:	110a0740 	call	8110a074 <POWER_SPI_RW>
811016b8:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
811016bc:	e03ff415 	stw	zero,-48(fp)
811016c0:	00004006 	br	811017c4 <POWER_Read+0x194>
			NextChannel = i + 1;
811016c4:	e0bff417 	ldw	r2,-48(fp)
811016c8:	10800044 	addi	r2,r2,1
811016cc:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
811016d0:	e0bff517 	ldw	r2,-44(fp)
811016d4:	10c03fcc 	andi	r3,r2,255
811016d8:	e13ffa03 	ldbu	r4,-24(fp)
811016dc:	e0bffe04 	addi	r2,fp,-8
811016e0:	d8800115 	stw	r2,4(sp)
811016e4:	e0bff917 	ldw	r2,-28(fp)
811016e8:	d8800015 	stw	r2,0(sp)
811016ec:	e1fff817 	ldw	r7,-32(fp)
811016f0:	e1bff717 	ldw	r6,-36(fp)
811016f4:	200b883a 	mov	r5,r4
811016f8:	1809883a 	mov	r4,r3
811016fc:	110a0740 	call	8110a074 <POWER_SPI_RW>
81101700:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
81101704:	e0bff317 	ldw	r2,-52(fp)
81101708:	10002b26 	beq	r2,zero,811017b8 <POWER_Read+0x188>
				HEAD = (Value32 >> 30) & 0x03;
8110170c:	e0bffe17 	ldw	r2,-8(fp)
81101710:	1004d7ba 	srli	r2,r2,30
81101714:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
81101718:	e0bffe17 	ldw	r2,-8(fp)
8110171c:	1004d07a 	srli	r2,r2,1
81101720:	108001cc 	andi	r2,r2,7
81101724:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
81101728:	e0bffe17 	ldw	r2,-8(fp)
8110172c:	1004d13a 	srli	r2,r2,4
81101730:	1080004c 	andi	r2,r2,1
81101734:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
81101738:	e0bffe17 	ldw	r2,-8(fp)
8110173c:	1004d17a 	srli	r2,r2,5
81101740:	1080004c 	andi	r2,r2,1
81101744:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
81101748:	e0bffe17 	ldw	r2,-8(fp)
8110174c:	1080004c 	andi	r2,r2,1
81101750:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
81101754:	e0bffa43 	ldbu	r2,-23(fp)
81101758:	10000226 	beq	r2,zero,81101764 <POWER_Read+0x134>
#if DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
8110175c:	e03ff315 	stw	zero,-52(fp)
81101760:	00000906 	br	81101788 <POWER_Read+0x158>
				} else if (Channel != i) {
81101764:	e0fffa83 	ldbu	r3,-22(fp)
81101768:	e0bff417 	ldw	r2,-48(fp)
8110176c:	18800226 	beq	r3,r2,81101778 <POWER_Read+0x148>
					sprintf(cDebugBuffer,
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
81101770:	e03ff315 	stw	zero,-52(fp)
81101774:	00000406 	br	81101788 <POWER_Read+0x158>
				} else if (SIGN ^ bSIGN) {
81101778:	e0fffac3 	ldbu	r3,-21(fp)
8110177c:	e0bff817 	ldw	r2,-32(fp)
81101780:	18800126 	beq	r3,r2,81101788 <POWER_Read+0x158>
#if DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
81101784:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
81101788:	e0bff317 	ldw	r2,-52(fp)
8110178c:	10000a26 	beq	r2,zero,811017b8 <POWER_Read+0x188>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
81101790:	e0bff617 	ldw	r2,-40(fp)
81101794:	10c00044 	addi	r3,r2,1
81101798:	e0fff615 	stw	r3,-40(fp)
8110179c:	1085883a 	add	r2,r2,r2
811017a0:	1085883a 	add	r2,r2,r2
811017a4:	1007883a 	mov	r3,r2
811017a8:	e0bfff17 	ldw	r2,-4(fp)
811017ac:	10c5883a 	add	r2,r2,r3
811017b0:	e0fffe17 	ldw	r3,-8(fp)
811017b4:	10c00015 	stw	r3,0(r2)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
811017b8:	e0bff417 	ldw	r2,-48(fp)
811017bc:	10800044 	addi	r2,r2,1
811017c0:	e0bff415 	stw	r2,-48(fp)
811017c4:	e0bff517 	ldw	r2,-44(fp)
811017c8:	1085883a 	add	r2,r2,r2
811017cc:	1085883a 	add	r2,r2,r2
811017d0:	e0fff304 	addi	r3,fp,-52
811017d4:	1885883a 	add	r2,r3,r2
811017d8:	10800904 	addi	r2,r2,36
811017dc:	10800017 	ldw	r2,0(r2)
811017e0:	e0fff417 	ldw	r3,-48(fp)
811017e4:	1880020e 	bge	r3,r2,811017f0 <POWER_Read+0x1c0>
811017e8:	e0bff317 	ldw	r2,-52(fp)
811017ec:	103fb51e 	bne	r2,zero,811016c4 <__reset+0xfb0e16c4>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
811017f0:	e0bff517 	ldw	r2,-44(fp)
811017f4:	10800044 	addi	r2,r2,1
811017f8:	e0bff515 	stw	r2,-44(fp)
811017fc:	e0bff517 	ldw	r2,-44(fp)
81101800:	10800088 	cmpgei	r2,r2,2
81101804:	1000021e 	bne	r2,zero,81101810 <POWER_Read+0x1e0>
81101808:	e0bff317 	ldw	r2,-52(fp)
8110180c:	103f9d1e 	bne	r2,zero,81101684 <__reset+0xfb0e1684>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
81101810:	e0bff317 	ldw	r2,-52(fp)
}
81101814:	e037883a 	mov	sp,fp
81101818:	dfc00117 	ldw	ra,4(sp)
8110181c:	df000017 	ldw	fp,0(sp)
81101820:	dec00204 	addi	sp,sp,8
81101824:	f800283a 	ret

81101828 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
81101828:	defff904 	addi	sp,sp,-28
8110182c:	de00012e 	bgeu	sp,et,81101834 <TEMP_Read+0xc>
81101830:	003b68fa 	trap	3
81101834:	dfc00615 	stw	ra,24(sp)
81101838:	df000515 	stw	fp,20(sp)
8110183c:	df000504 	addi	fp,sp,20
81101840:	e13ffe15 	stw	r4,-8(fp)
81101844:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
81101848:	00800c04 	movi	r2,48
8110184c:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
81101850:	e0bffd83 	ldbu	r2,-10(fp)
81101854:	10c03fcc 	andi	r3,r2,255
81101858:	18c0201c 	xori	r3,r3,128
8110185c:	18ffe004 	addi	r3,r3,-128
81101860:	e0bffdc4 	addi	r2,fp,-9
81101864:	d8800015 	stw	r2,0(sp)
81101868:	000f883a 	mov	r7,zero
8110186c:	180d883a 	mov	r6,r3
81101870:	01600034 	movhi	r5,32768
81101874:	29426004 	addi	r5,r5,2432
81101878:	01200034 	movhi	r4,32768
8110187c:	21026404 	addi	r4,r4,2448
81101880:	1108f140 	call	81108f14 <I2C_Read>
81101884:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
81101888:	e0bffc17 	ldw	r2,-16(fp)
8110188c:	10000226 	beq	r2,zero,81101898 <TEMP_Read+0x70>
		BoardTemp = Data;
81101890:	e0bffdc3 	ldbu	r2,-9(fp)
81101894:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
81101898:	e0bffc17 	ldw	r2,-16(fp)
8110189c:	10001226 	beq	r2,zero,811018e8 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
811018a0:	e0bffd83 	ldbu	r2,-10(fp)
811018a4:	10c03fcc 	andi	r3,r2,255
811018a8:	18c0201c 	xori	r3,r3,128
811018ac:	18ffe004 	addi	r3,r3,-128
811018b0:	e0bffdc4 	addi	r2,fp,-9
811018b4:	d8800015 	stw	r2,0(sp)
811018b8:	01c00044 	movi	r7,1
811018bc:	180d883a 	mov	r6,r3
811018c0:	01600034 	movhi	r5,32768
811018c4:	29426004 	addi	r5,r5,2432
811018c8:	01200034 	movhi	r4,32768
811018cc:	21026404 	addi	r4,r4,2448
811018d0:	1108f140 	call	81108f14 <I2C_Read>
811018d4:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
811018d8:	e0bffc17 	ldw	r2,-16(fp)
811018dc:	10000226 	beq	r2,zero,811018e8 <TEMP_Read+0xc0>
			FpgaTemp = Data;
811018e0:	e0bffdc3 	ldbu	r2,-9(fp)
811018e4:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
811018e8:	e0bffc17 	ldw	r2,-16(fp)
811018ec:	10000626 	beq	r2,zero,81101908 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
811018f0:	e0bffe17 	ldw	r2,-8(fp)
811018f4:	e0fffd03 	ldbu	r3,-12(fp)
811018f8:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
811018fc:	e0bfff17 	ldw	r2,-4(fp)
81101900:	e0fffd43 	ldbu	r3,-11(fp)
81101904:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81101908:	e0bffc17 	ldw	r2,-16(fp)
}
8110190c:	e037883a 	mov	sp,fp
81101910:	dfc00117 	ldw	ra,4(sp)
81101914:	df000017 	ldw	fp,0(sp)
81101918:	dec00204 	addi	sp,sp,8
8110191c:	f800283a 	ret

81101920 <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
81101920:	defffb04 	addi	sp,sp,-20
81101924:	de00012e 	bgeu	sp,et,8110192c <sense_log_temp+0xc>
81101928:	003b68fa 	trap	3
8110192c:	dfc00415 	stw	ra,16(sp)
81101930:	df000315 	stw	fp,12(sp)
81101934:	df000304 	addi	fp,sp,12
81101938:	e13ffe15 	stw	r4,-8(fp)
8110193c:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
81101940:	e17fff17 	ldw	r5,-4(fp)
81101944:	e13ffe17 	ldw	r4,-8(fp)
81101948:	11018280 	call	81101828 <TEMP_Read>
8110194c:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
81101950:	e0bffd17 	ldw	r2,-12(fp)
}
81101954:	e037883a 	mov	sp,fp
81101958:	dfc00117 	ldw	ra,4(sp)
8110195c:	df000017 	ldw	fp,0(sp)
81101960:	dec00204 	addi	sp,sp,8
81101964:	f800283a 	ret

81101968 <sense_log>:

void sense_log(void) {
81101968:	deff0e04 	addi	sp,sp,-968
8110196c:	de00012e 	bgeu	sp,et,81101974 <sense_log+0xc>
81101970:	003b68fa 	trap	3
81101974:	dfc0f115 	stw	ra,964(sp)
81101978:	df00f015 	stw	fp,960(sp)
8110197c:	dc40ef15 	stw	r17,956(sp)
81101980:	dc00ee15 	stw	r16,952(sp)
81101984:	df00f004 	addi	fp,sp,960
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
81101988:	00902834 	movhi	r2,16544
8110198c:	e0bf1215 	stw	r2,-952(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
81101990:	008ed174 	movhi	r2,15173
81101994:	10a6e984 	addi	r2,r2,-25690
81101998:	e0bf2615 	stw	r2,-872(fp)
8110199c:	008ea0f4 	movhi	r2,14979
811019a0:	10849bc4 	addi	r2,r2,4719
811019a4:	e0bf2715 	stw	r2,-868(fp)
811019a8:	008ed174 	movhi	r2,15173
811019ac:	10a6e984 	addi	r2,r2,-25690
811019b0:	e0bf2815 	stw	r2,-864(fp)
811019b4:	008ed174 	movhi	r2,15173
811019b8:	10a6e984 	addi	r2,r2,-25690
811019bc:	e0bf2915 	stw	r2,-860(fp)
811019c0:	008ed174 	movhi	r2,15173
811019c4:	10a6e984 	addi	r2,r2,-25690
811019c8:	e0bf2a15 	stw	r2,-856(fp)
811019cc:	008ed174 	movhi	r2,15173
811019d0:	10a6e984 	addi	r2,r2,-25690
811019d4:	e0bf2b15 	stw	r2,-852(fp)
811019d8:	008ed174 	movhi	r2,15173
811019dc:	10a6e984 	addi	r2,r2,-25690
811019e0:	e0bf2c15 	stw	r2,-848(fp)
811019e4:	008ed174 	movhi	r2,15173
811019e8:	10a6e984 	addi	r2,r2,-25690
811019ec:	e0bf2d15 	stw	r2,-844(fp)
811019f0:	008ed174 	movhi	r2,15173
811019f4:	10a6e984 	addi	r2,r2,-25690
811019f8:	e0bf2e15 	stw	r2,-840(fp)
811019fc:	008ed174 	movhi	r2,15173
81101a00:	10a6e984 	addi	r2,r2,-25690
81101a04:	e0bf2f15 	stw	r2,-836(fp)
81101a08:	008ed174 	movhi	r2,15173
81101a0c:	10a6e984 	addi	r2,r2,-25690
81101a10:	e0bf3015 	stw	r2,-832(fp)
81101a14:	008ed174 	movhi	r2,15173
81101a18:	10a6e984 	addi	r2,r2,-25690
81101a1c:	e0bf3115 	stw	r2,-828(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
81101a20:	008fd9b4 	movhi	r2,16230
81101a24:	10999984 	addi	r2,r2,26214
81101a28:	e0bf3215 	stw	r2,-824(fp)
81101a2c:	008fd9b4 	movhi	r2,16230
81101a30:	10999984 	addi	r2,r2,26214
81101a34:	e0bf3315 	stw	r2,-820(fp)
81101a38:	00901034 	movhi	r2,16448
81101a3c:	e0bf3415 	stw	r2,-816(fp)
81101a40:	008fd9b4 	movhi	r2,16230
81101a44:	10999984 	addi	r2,r2,26214
81101a48:	e0bf3515 	stw	r2,-812(fp)
81101a4c:	008ff9b4 	movhi	r2,16358
81101a50:	10999984 	addi	r2,r2,26214
81101a54:	e0bf3615 	stw	r2,-808(fp)
81101a58:	00900834 	movhi	r2,16416
81101a5c:	e0bf3715 	stw	r2,-804(fp)
81101a60:	008ff9b4 	movhi	r2,16358
81101a64:	10999984 	addi	r2,r2,26214
81101a68:	e0bf3815 	stw	r2,-800(fp)
81101a6c:	00900834 	movhi	r2,16416
81101a70:	e0bf3915 	stw	r2,-796(fp)
81101a74:	008fe374 	movhi	r2,16269
81101a78:	10b33344 	addi	r2,r2,-13107
81101a7c:	e0bf3a15 	stw	r2,-792(fp)
81101a80:	008fecf4 	movhi	r2,16307
81101a84:	108cccc4 	addi	r2,r2,13107
81101a88:	e0bf3b15 	stw	r2,-788(fp)
81101a8c:	009014f4 	movhi	r2,16467
81101a90:	108cccc4 	addi	r2,r2,13107
81101a94:	e0bf3c15 	stw	r2,-784(fp)
81101a98:	00900834 	movhi	r2,16416
81101a9c:	e0bf3d15 	stw	r2,-780(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
81101aa0:	00a04534 	movhi	r2,33044
81101aa4:	1090d504 	addi	r2,r2,17236
81101aa8:	e0ff3e04 	addi	r3,fp,-776
81101aac:	1009883a 	mov	r4,r2
81101ab0:	0080c004 	movi	r2,768
81101ab4:	100d883a 	mov	r6,r2
81101ab8:	200b883a 	mov	r5,r4
81101abc:	1809883a 	mov	r4,r3
81101ac0:	111abac0 	call	8111abac <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
81101ac4:	e0bf1a04 	addi	r2,fp,-920
81101ac8:	1009883a 	mov	r4,r2
81101acc:	11016300 	call	81101630 <POWER_Read>
81101ad0:	e0bf1315 	stw	r2,-948(fp)
	if (bSuccess) {
81101ad4:	e0bf1317 	ldw	r2,-948(fp)
81101ad8:	1000c326 	beq	r2,zero,81101de8 <sense_log+0x480>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81101adc:	e03f1015 	stw	zero,-960(fp)
81101ae0:	0000bc06 	br	81101dd4 <sense_log+0x46c>
			SIG = (szVol[i] >> 29) & 0x01;
81101ae4:	e0bf1017 	ldw	r2,-960(fp)
81101ae8:	1085883a 	add	r2,r2,r2
81101aec:	1085883a 	add	r2,r2,r2
81101af0:	e0ff1004 	addi	r3,fp,-960
81101af4:	1885883a 	add	r2,r3,r2
81101af8:	10800a04 	addi	r2,r2,40
81101afc:	10800017 	ldw	r2,0(r2)
81101b00:	1004d77a 	srli	r2,r2,29
81101b04:	1080004c 	andi	r2,r2,1
81101b08:	e0bf1415 	stw	r2,-944(fp)
			MSB = (szVol[i] >> 28) & 0x01;
81101b0c:	e0bf1017 	ldw	r2,-960(fp)
81101b10:	1085883a 	add	r2,r2,r2
81101b14:	1085883a 	add	r2,r2,r2
81101b18:	e0ff1004 	addi	r3,fp,-960
81101b1c:	1885883a 	add	r2,r3,r2
81101b20:	10800a04 	addi	r2,r2,40
81101b24:	10800017 	ldw	r2,0(r2)
81101b28:	1004d73a 	srli	r2,r2,28
81101b2c:	1080004c 	andi	r2,r2,1
81101b30:	e0bf1515 	stw	r2,-940(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
81101b34:	e0bf1017 	ldw	r2,-960(fp)
81101b38:	1085883a 	add	r2,r2,r2
81101b3c:	1085883a 	add	r2,r2,r2
81101b40:	e0ff1004 	addi	r3,fp,-960
81101b44:	1885883a 	add	r2,r3,r2
81101b48:	10800a04 	addi	r2,r2,40
81101b4c:	10800017 	ldw	r2,0(r2)
81101b50:	1006d1ba 	srli	r3,r2,6
81101b54:	00801034 	movhi	r2,64
81101b58:	10bfffc4 	addi	r2,r2,-1
81101b5c:	1884703a 	and	r2,r3,r2
81101b60:	e0bf1615 	stw	r2,-936(fp)
			if (MSB == 0)
81101b64:	e0bf1517 	ldw	r2,-940(fp)
81101b68:	1000091e 	bne	r2,zero,81101b90 <sense_log+0x228>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
81101b6c:	e13f1617 	ldw	r4,-936(fp)
81101b70:	11194fc0 	call	811194fc <__floatunsisf>
81101b74:	1007883a 	mov	r3,r2
81101b78:	0152a034 	movhi	r5,19072
81101b7c:	1809883a 	mov	r4,r3
81101b80:	1118cb00 	call	81118cb0 <__divsf3>
81101b84:	1007883a 	mov	r3,r2
81101b88:	e0ff1115 	stw	r3,-956(fp)
81101b8c:	00000106 	br	81101b94 <sense_log+0x22c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
81101b90:	e03f1115 	stw	zero,-956(fp)
			if (SIG && MSB) {
81101b94:	e0bf1417 	ldw	r2,-944(fp)
81101b98:	10000826 	beq	r2,zero,81101bbc <sense_log+0x254>
81101b9c:	e0bf1517 	ldw	r2,-940(fp)
81101ba0:	10000626 	beq	r2,zero,81101bbc <sense_log+0x254>
				fVol = fRef * 0.5;
81101ba4:	014fc034 	movhi	r5,16128
81101ba8:	e13f1217 	ldw	r4,-952(fp)
81101bac:	11190f80 	call	811190f8 <__mulsf3>
81101bb0:	1007883a 	mov	r3,r2
81101bb4:	e0ff1715 	stw	r3,-932(fp)
81101bb8:	00008306 	br	81101dc8 <sense_log+0x460>
#if DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
#endif
			} else if (SIG && !MSB) {
81101bbc:	e0bf1417 	ldw	r2,-944(fp)
81101bc0:	10003a26 	beq	r2,zero,81101cac <sense_log+0x344>
81101bc4:	e0bf1517 	ldw	r2,-940(fp)
81101bc8:	1000381e 	bne	r2,zero,81101cac <sense_log+0x344>
				fVol = fRef * 0.5 * fVolDrop;
81101bcc:	e13f1217 	ldw	r4,-952(fp)
81101bd0:	111a8580 	call	8111a858 <__extendsfdf2>
81101bd4:	1011883a 	mov	r8,r2
81101bd8:	1813883a 	mov	r9,r3
81101bdc:	000d883a 	mov	r6,zero
81101be0:	01cff834 	movhi	r7,16352
81101be4:	4009883a 	mov	r4,r8
81101be8:	480b883a 	mov	r5,r9
81101bec:	11196d00 	call	811196d0 <__muldf3>
81101bf0:	1009883a 	mov	r4,r2
81101bf4:	180b883a 	mov	r5,r3
81101bf8:	2021883a 	mov	r16,r4
81101bfc:	2823883a 	mov	r17,r5
81101c00:	e13f1117 	ldw	r4,-956(fp)
81101c04:	111a8580 	call	8111a858 <__extendsfdf2>
81101c08:	1009883a 	mov	r4,r2
81101c0c:	180b883a 	mov	r5,r3
81101c10:	200d883a 	mov	r6,r4
81101c14:	280f883a 	mov	r7,r5
81101c18:	8009883a 	mov	r4,r16
81101c1c:	880b883a 	mov	r5,r17
81101c20:	11196d00 	call	811196d0 <__muldf3>
81101c24:	1009883a 	mov	r4,r2
81101c28:	180b883a 	mov	r5,r3
81101c2c:	2005883a 	mov	r2,r4
81101c30:	2807883a 	mov	r3,r5
81101c34:	1009883a 	mov	r4,r2
81101c38:	180b883a 	mov	r5,r3
81101c3c:	111a9700 	call	8111a970 <__truncdfsf2>
81101c40:	1007883a 	mov	r3,r2
81101c44:	e0ff1715 	stw	r3,-932(fp)
				fCurrent = fVolDrop / szRes[i];
81101c48:	e0bf1017 	ldw	r2,-960(fp)
81101c4c:	1085883a 	add	r2,r2,r2
81101c50:	1085883a 	add	r2,r2,r2
81101c54:	e0ff1004 	addi	r3,fp,-960
81101c58:	1885883a 	add	r2,r3,r2
81101c5c:	10801604 	addi	r2,r2,88
81101c60:	10c00017 	ldw	r3,0(r2)
81101c64:	180b883a 	mov	r5,r3
81101c68:	e13f1117 	ldw	r4,-956(fp)
81101c6c:	1118cb00 	call	81118cb0 <__divsf3>
81101c70:	1007883a 	mov	r3,r2
81101c74:	e0ff1815 	stw	r3,-928(fp)
				fPower = szRefVol[i] * fCurrent;
81101c78:	e0bf1017 	ldw	r2,-960(fp)
81101c7c:	1085883a 	add	r2,r2,r2
81101c80:	1085883a 	add	r2,r2,r2
81101c84:	e0ff1004 	addi	r3,fp,-960
81101c88:	1885883a 	add	r2,r3,r2
81101c8c:	10802204 	addi	r2,r2,136
81101c90:	10c00017 	ldw	r3,0(r2)
81101c94:	e17f1817 	ldw	r5,-928(fp)
81101c98:	1809883a 	mov	r4,r3
81101c9c:	11190f80 	call	811190f8 <__mulsf3>
81101ca0:	1007883a 	mov	r3,r2
81101ca4:	e0ff1915 	stw	r3,-924(fp)
81101ca8:	00004706 	br	81101dc8 <sense_log+0x460>
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && MSB) {
81101cac:	e0bf1417 	ldw	r2,-944(fp)
81101cb0:	10003a1e 	bne	r2,zero,81101d9c <sense_log+0x434>
81101cb4:	e0bf1517 	ldw	r2,-940(fp)
81101cb8:	10003826 	beq	r2,zero,81101d9c <sense_log+0x434>
				fVol = fRef * 0.5 * fVolDrop;
81101cbc:	e13f1217 	ldw	r4,-952(fp)
81101cc0:	111a8580 	call	8111a858 <__extendsfdf2>
81101cc4:	1011883a 	mov	r8,r2
81101cc8:	1813883a 	mov	r9,r3
81101ccc:	000d883a 	mov	r6,zero
81101cd0:	01cff834 	movhi	r7,16352
81101cd4:	4009883a 	mov	r4,r8
81101cd8:	480b883a 	mov	r5,r9
81101cdc:	11196d00 	call	811196d0 <__muldf3>
81101ce0:	1009883a 	mov	r4,r2
81101ce4:	180b883a 	mov	r5,r3
81101ce8:	2021883a 	mov	r16,r4
81101cec:	2823883a 	mov	r17,r5
81101cf0:	e13f1117 	ldw	r4,-956(fp)
81101cf4:	111a8580 	call	8111a858 <__extendsfdf2>
81101cf8:	1009883a 	mov	r4,r2
81101cfc:	180b883a 	mov	r5,r3
81101d00:	200d883a 	mov	r6,r4
81101d04:	280f883a 	mov	r7,r5
81101d08:	8009883a 	mov	r4,r16
81101d0c:	880b883a 	mov	r5,r17
81101d10:	11196d00 	call	811196d0 <__muldf3>
81101d14:	1009883a 	mov	r4,r2
81101d18:	180b883a 	mov	r5,r3
81101d1c:	2005883a 	mov	r2,r4
81101d20:	2807883a 	mov	r3,r5
81101d24:	1009883a 	mov	r4,r2
81101d28:	180b883a 	mov	r5,r3
81101d2c:	111a9700 	call	8111a970 <__truncdfsf2>
81101d30:	1007883a 	mov	r3,r2
81101d34:	e0ff1715 	stw	r3,-932(fp)
				fCurrent = fVolDrop / szRes[i];
81101d38:	e0bf1017 	ldw	r2,-960(fp)
81101d3c:	1085883a 	add	r2,r2,r2
81101d40:	1085883a 	add	r2,r2,r2
81101d44:	e0ff1004 	addi	r3,fp,-960
81101d48:	1885883a 	add	r2,r3,r2
81101d4c:	10801604 	addi	r2,r2,88
81101d50:	10c00017 	ldw	r3,0(r2)
81101d54:	180b883a 	mov	r5,r3
81101d58:	e13f1117 	ldw	r4,-956(fp)
81101d5c:	1118cb00 	call	81118cb0 <__divsf3>
81101d60:	1007883a 	mov	r3,r2
81101d64:	e0ff1815 	stw	r3,-928(fp)
				fPower = szRefVol[i] * fCurrent;
81101d68:	e0bf1017 	ldw	r2,-960(fp)
81101d6c:	1085883a 	add	r2,r2,r2
81101d70:	1085883a 	add	r2,r2,r2
81101d74:	e0ff1004 	addi	r3,fp,-960
81101d78:	1885883a 	add	r2,r3,r2
81101d7c:	10802204 	addi	r2,r2,136
81101d80:	10c00017 	ldw	r3,0(r2)
81101d84:	e17f1817 	ldw	r5,-928(fp)
81101d88:	1809883a 	mov	r4,r3
81101d8c:	11190f80 	call	811190f8 <__mulsf3>
81101d90:	1007883a 	mov	r3,r2
81101d94:	e0ff1915 	stw	r3,-924(fp)
81101d98:	00000b06 	br	81101dc8 <sense_log+0x460>
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
81101d9c:	e0bf1417 	ldw	r2,-944(fp)
81101da0:	1000091e 	bne	r2,zero,81101dc8 <sense_log+0x460>
81101da4:	e0bf1517 	ldw	r2,-940(fp)
81101da8:	1000071e 	bne	r2,zero,81101dc8 <sense_log+0x460>
				fVol = -fRef * 0.5;
81101dac:	e0bf1217 	ldw	r2,-952(fp)
81101db0:	10a0003c 	xorhi	r2,r2,32768
81101db4:	014fc034 	movhi	r5,16128
81101db8:	1009883a 	mov	r4,r2
81101dbc:	11190f80 	call	811190f8 <__mulsf3>
81101dc0:	1007883a 	mov	r3,r2
81101dc4:	e0ff1715 	stw	r3,-932(fp)
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81101dc8:	e0bf1017 	ldw	r2,-960(fp)
81101dcc:	10800044 	addi	r2,r2,1
81101dd0:	e0bf1015 	stw	r2,-960(fp)
81101dd4:	e0bf1017 	ldw	r2,-960(fp)
81101dd8:	10800308 	cmpgei	r2,r2,12
81101ddc:	1000021e 	bne	r2,zero,81101de8 <sense_log+0x480>
81101de0:	e0bf1317 	ldw	r2,-948(fp)
81101de4:	103f3f1e 	bne	r2,zero,81101ae4 <__reset+0xfb0e1ae4>
#if DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81101de8:	0001883a 	nop
81101dec:	e6fffe04 	addi	sp,fp,-8
81101df0:	dfc00317 	ldw	ra,12(sp)
81101df4:	df000217 	ldw	fp,8(sp)
81101df8:	dc400117 	ldw	r17,4(sp)
81101dfc:	dc000017 	ldw	r16,0(sp)
81101e00:	dec00404 	addi	sp,sp,16
81101e04:	f800283a 	ret

81101e08 <bSdmaInitM1Dma>:
alt_msgdma_dev *pxDmaM1Dev = NULL;
alt_msgdma_dev *pxDmaM2Dev = NULL;
//! [data memory public global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81101e08:	defffb04 	addi	sp,sp,-20
81101e0c:	de00012e 	bgeu	sp,et,81101e14 <bSdmaInitM1Dma+0xc>
81101e10:	003b68fa 	trap	3
81101e14:	dfc00415 	stw	ra,16(sp)
81101e18:	df000315 	stw	fp,12(sp)
81101e1c:	df000304 	addi	fp,sp,12
	bool bStatus = FALSE;
81101e20:	e03ffd15 	stw	zero,-12(fp)
	bool bFailDispatcher = FALSE;
81101e24:	e03ffe15 	stw	zero,-8(fp)
	alt_u16 usiCounter = 0;
81101e28:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81101e2c:	01204534 	movhi	r4,33044
81101e30:	21119504 	addi	r4,r4,18004
81101e34:	114280c0 	call	8114280c <alt_msgdma_open>
81101e38:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev != NULL) {
81101e3c:	d0a03917 	ldw	r2,-32540(gp)
81101e40:	10001a26 	beq	r2,zero,81101eac <bSdmaInitM1Dma+0xa4>
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81101e44:	d0a03917 	ldw	r2,-32540(gp)
81101e48:	10800317 	ldw	r2,12(r2)
81101e4c:	10800104 	addi	r2,r2,4
81101e50:	00c00084 	movi	r3,2
81101e54:	10c00035 	stwio	r3,0(r2)
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81101e58:	00000b06 	br	81101e88 <bSdmaInitM1Dma+0x80>
			usleep(1);
81101e5c:	01000044 	movi	r4,1
81101e60:	11307740 	call	81130774 <usleep>
			usiCounter++;
81101e64:	e0bfff0b 	ldhu	r2,-4(fp)
81101e68:	10800044 	addi	r2,r2,1
81101e6c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81101e70:	e0bfff0b 	ldhu	r2,-4(fp)
81101e74:	1084e230 	cmpltui	r2,r2,5000
81101e78:	1000031e 	bne	r2,zero,81101e88 <bSdmaInitM1Dma+0x80>
				bFailDispatcher = TRUE;
81101e7c:	00800044 	movi	r2,1
81101e80:	e0bffe15 	stw	r2,-8(fp)
				break;
81101e84:	00000506 	br	81101e9c <bSdmaInitM1Dma+0x94>
	// check if the device was opened
	if (pxDmaM1Dev != NULL) {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81101e88:	d0a03917 	ldw	r2,-32540(gp)
81101e8c:	10800317 	ldw	r2,12(r2)
81101e90:	10800037 	ldwio	r2,0(r2)
81101e94:	1080100c 	andi	r2,r2,64
81101e98:	103ff01e 	bne	r2,zero,81101e5c <__reset+0xfb0e1e5c>
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
				bFailDispatcher = TRUE;
				break;
			}
		}
		if (bFailDispatcher == FALSE)
81101e9c:	e0bffe17 	ldw	r2,-8(fp)
81101ea0:	1000021e 	bne	r2,zero,81101eac <bSdmaInitM1Dma+0xa4>
			bStatus = TRUE;
81101ea4:	00800044 	movi	r2,1
81101ea8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81101eac:	e0bffd17 	ldw	r2,-12(fp)
}
81101eb0:	e037883a 	mov	sp,fp
81101eb4:	dfc00117 	ldw	ra,4(sp)
81101eb8:	df000017 	ldw	fp,0(sp)
81101ebc:	dec00204 	addi	sp,sp,8
81101ec0:	f800283a 	ret

81101ec4 <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81101ec4:	defffb04 	addi	sp,sp,-20
81101ec8:	de00012e 	bgeu	sp,et,81101ed0 <bSdmaInitM2Dma+0xc>
81101ecc:	003b68fa 	trap	3
81101ed0:	dfc00415 	stw	ra,16(sp)
81101ed4:	df000315 	stw	fp,12(sp)
81101ed8:	df000304 	addi	fp,sp,12
	bool bStatus = FALSE;
81101edc:	e03ffd15 	stw	zero,-12(fp)
	bool bFailDispatcher = FALSE;
81101ee0:	e03ffe15 	stw	zero,-8(fp)
	alt_u16 usiCounter = 0;
81101ee4:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81101ee8:	01204534 	movhi	r4,33044
81101eec:	21119a04 	addi	r4,r4,18024
81101ef0:	114280c0 	call	8114280c <alt_msgdma_open>
81101ef4:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81101ef8:	d0a03a17 	ldw	r2,-32536(gp)
81101efc:	1000021e 	bne	r2,zero,81101f08 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81101f00:	e03ffd15 	stw	zero,-12(fp)
81101f04:	00001a06 	br	81101f70 <bSdmaInitM2Dma+0xac>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81101f08:	d0a03a17 	ldw	r2,-32536(gp)
81101f0c:	10800317 	ldw	r2,12(r2)
81101f10:	10800104 	addi	r2,r2,4
81101f14:	00c00084 	movi	r3,2
81101f18:	10c00035 	stwio	r3,0(r2)
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81101f1c:	00000b06 	br	81101f4c <bSdmaInitM2Dma+0x88>
			usleep(1);
81101f20:	01000044 	movi	r4,1
81101f24:	11307740 	call	81130774 <usleep>
			usiCounter++;
81101f28:	e0bfff0b 	ldhu	r2,-4(fp)
81101f2c:	10800044 	addi	r2,r2,1
81101f30:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81101f34:	e0bfff0b 	ldhu	r2,-4(fp)
81101f38:	1084e230 	cmpltui	r2,r2,5000
81101f3c:	1000031e 	bne	r2,zero,81101f4c <bSdmaInitM2Dma+0x88>
				bFailDispatcher = TRUE;
81101f40:	00800044 	movi	r2,1
81101f44:	e0bffe15 	stw	r2,-8(fp)
				break;
81101f48:	00000506 	br	81101f60 <bSdmaInitM2Dma+0x9c>
		bStatus = FALSE;
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81101f4c:	d0a03a17 	ldw	r2,-32536(gp)
81101f50:	10800317 	ldw	r2,12(r2)
81101f54:	10800037 	ldwio	r2,0(r2)
81101f58:	1080100c 	andi	r2,r2,64
81101f5c:	103ff01e 	bne	r2,zero,81101f20 <__reset+0xfb0e1f20>
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
				bFailDispatcher = TRUE;
				break;
			}
		}
		if (bFailDispatcher == FALSE)
81101f60:	e0bffe17 	ldw	r2,-8(fp)
81101f64:	1000021e 	bne	r2,zero,81101f70 <bSdmaInitM2Dma+0xac>
			bStatus = TRUE;
81101f68:	00800044 	movi	r2,1
81101f6c:	e0bffd15 	stw	r2,-12(fp)
	}
	return bStatus;
81101f70:	e0bffd17 	ldw	r2,-12(fp)
}
81101f74:	e037883a 	mov	sp,fp
81101f78:	dfc00117 	ldw	ra,4(sp)
81101f7c:	df000017 	ldw	fp,0(sp)
81101f80:	dec00204 	addi	sp,sp,8
81101f84:	f800283a 	ret

81101f88 <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr, alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide, alt_u8 ucChBufferId) {
81101f88:	deffe704 	addi	sp,sp,-100
81101f8c:	de00012e 	bgeu	sp,et,81101f94 <bSdmaDmaM1Transfer+0xc>
81101f90:	003b68fa 	trap	3
81101f94:	dfc01815 	stw	ra,96(sp)
81101f98:	df001715 	stw	fp,92(sp)
81101f9c:	dc001615 	stw	r16,88(sp)
81101fa0:	df001704 	addi	fp,sp,92
81101fa4:	e13ffb15 	stw	r4,-20(fp)
81101fa8:	2809883a 	mov	r4,r5
81101fac:	3007883a 	mov	r3,r6
81101fb0:	3805883a 	mov	r2,r7
81101fb4:	e13ffc0d 	sth	r4,-16(fp)
81101fb8:	e0fffd05 	stb	r3,-12(fp)
81101fbc:	e0bffe05 	stb	r2,-8(fp)
81101fc0:	defff004 	addi	sp,sp,-64
81101fc4:	d8800904 	addi	r2,sp,36
81101fc8:	108007c4 	addi	r2,r2,31
81101fcc:	1004d17a 	srli	r2,r2,5
81101fd0:	1020917a 	slli	r16,r2,5
	bool bStatus;
	alt_u16 usiCnt = 0;
81101fd4:	e03ff70d 	sth	zero,-36(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81101fd8:	e03ff315 	stw	zero,-52(fp)
	alt_u32 uliDestAddrHigh = 0;
81101fdc:	e03ff415 	stw	zero,-48(fp)

	alt_u32 uliSrcAddrLow = 0;
81101fe0:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81101fe4:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81101fe8:	e03ffa15 	stw	zero,-24(fp)
	bool bBufferEmptyFlag;
	bool bChannelFlag;

	/* Assuming that the channel selected exist, change to FALSE if doesn't */
	bChannelFlag = TRUE;
81101fec:	00800044 	movi	r2,1
81101ff0:	e0bff615 	stw	r2,-40(fp)
	bStatus = FALSE;
81101ff4:	e03ff215 	stw	zero,-56(fp)
	bBufferEmptyFlag = FALSE;
81101ff8:	e03ff515 	stw	zero,-44(fp)
	switch (ucChBufferId) {
81101ffc:	e0bffe03 	ldbu	r2,-8(fp)
81102000:	10c00228 	cmpgeui	r3,r2,8
81102004:	1800b81e 	bne	r3,zero,811022e8 <bSdmaDmaM1Transfer+0x360>
81102008:	100690ba 	slli	r3,r2,2
8110200c:	00a04434 	movhi	r2,33040
81102010:	10880804 	addi	r2,r2,8224
81102014:	1885883a 	add	r2,r3,r2
81102018:	10800017 	ldw	r2,0(r2)
8110201c:	1000683a 	jmp	r2
81102020:	81102040 	call	88110204 <__reset+0x20f0204>
81102024:	81102094 	ori	r4,r16,16514
81102028:	811020f0 	cmpltui	r4,r16,16515
8110202c:	81102144 	addi	r4,r16,16517
81102030:	81102198 	cmpnei	r4,r16,16518
81102034:	811021ec 	andhi	r4,r16,16519
81102038:	81102240 	call	88110224 <__reset+0x20f0224>
8110203c:	81102294 	ori	r4,r16,16522
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81102040:	e0bffd03 	ldbu	r2,-12(fp)
81102044:	10000826 	beq	r2,zero,81102068 <bSdmaDmaM1Transfer+0xe0>
81102048:	10800060 	cmpeqi	r2,r2,1
8110204c:	10000d26 	beq	r2,zero,81102084 <bSdmaDmaM1Transfer+0xfc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81102050:	e03ff315 	stw	zero,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81102054:	00800044 	movi	r2,1
81102058:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
8110205c:	11048f00 	call	811048f0 <bFeebGetCh1RightBufferEmpty>
81102060:	e0bff515 	stw	r2,-44(fp)
			break;
81102064:	00000a06 	br	81102090 <bSdmaDmaM1Transfer+0x108>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81102068:	00800074 	movhi	r2,1
8110206c:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81102070:	00800044 	movi	r2,1
81102074:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
81102078:	11048880 	call	81104888 <bFeebGetCh1LeftBufferEmpty>
8110207c:	e0bff515 	stw	r2,-44(fp)
			break;
81102080:	00000306 	br	81102090 <bSdmaDmaM1Transfer+0x108>
		default:
			bChannelFlag = FALSE;
81102084:	e03ff615 	stw	zero,-40(fp)
			bBufferEmptyFlag = FALSE;
81102088:	e03ff515 	stw	zero,-44(fp)
			break;
8110208c:	0001883a 	nop
		}
		break;
81102090:	00009706 	br	811022f0 <bSdmaDmaM1Transfer+0x368>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81102094:	e0bffd03 	ldbu	r2,-12(fp)
81102098:	10000926 	beq	r2,zero,811020c0 <bSdmaDmaM1Transfer+0x138>
8110209c:	10800060 	cmpeqi	r2,r2,1
811020a0:	10000f26 	beq	r2,zero,811020e0 <bSdmaDmaM1Transfer+0x158>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
811020a4:	00880004 	movi	r2,8192
811020a8:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
811020ac:	00800044 	movi	r2,1
811020b0:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
811020b4:	11049c00 	call	811049c0 <bFeebGetCh2RightBufferEmpty>
811020b8:	e0bff515 	stw	r2,-44(fp)
			break;
811020bc:	00000b06 	br	811020ec <bSdmaDmaM1Transfer+0x164>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
811020c0:	00800074 	movhi	r2,1
811020c4:	10880004 	addi	r2,r2,8192
811020c8:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
811020cc:	00800044 	movi	r2,1
811020d0:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
811020d4:	11049580 	call	81104958 <bFeebGetCh2LeftBufferEmpty>
811020d8:	e0bff515 	stw	r2,-44(fp)
			break;
811020dc:	00000306 	br	811020ec <bSdmaDmaM1Transfer+0x164>
		default:
			bChannelFlag = FALSE;
811020e0:	e03ff615 	stw	zero,-40(fp)
			bBufferEmptyFlag = FALSE;
811020e4:	e03ff515 	stw	zero,-44(fp)
			break;
811020e8:	0001883a 	nop
		}
		break;
811020ec:	00008006 	br	811022f0 <bSdmaDmaM1Transfer+0x368>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
811020f0:	e0bffd03 	ldbu	r2,-12(fp)
811020f4:	10000826 	beq	r2,zero,81102118 <bSdmaDmaM1Transfer+0x190>
811020f8:	10800060 	cmpeqi	r2,r2,1
811020fc:	10000d26 	beq	r2,zero,81102134 <bSdmaDmaM1Transfer+0x1ac>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81102100:	00900004 	movi	r2,16384
81102104:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81102108:	00800044 	movi	r2,1
8110210c:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
81102110:	e03ff515 	stw	zero,-44(fp)
			break;
81102114:	00000a06 	br	81102140 <bSdmaDmaM1Transfer+0x1b8>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81102118:	00800074 	movhi	r2,1
8110211c:	10900004 	addi	r2,r2,16384
81102120:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81102124:	00800044 	movi	r2,1
81102128:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
8110212c:	e03ff515 	stw	zero,-44(fp)
			break;
81102130:	00000306 	br	81102140 <bSdmaDmaM1Transfer+0x1b8>
		default:
			bChannelFlag = FALSE;
81102134:	e03ff615 	stw	zero,-40(fp)
			bBufferEmptyFlag = FALSE;
81102138:	e03ff515 	stw	zero,-44(fp)
			break;
8110213c:	0001883a 	nop
		}
		break;
81102140:	00006b06 	br	811022f0 <bSdmaDmaM1Transfer+0x368>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81102144:	e0bffd03 	ldbu	r2,-12(fp)
81102148:	10000826 	beq	r2,zero,8110216c <bSdmaDmaM1Transfer+0x1e4>
8110214c:	10800060 	cmpeqi	r2,r2,1
81102150:	10000d26 	beq	r2,zero,81102188 <bSdmaDmaM1Transfer+0x200>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81102154:	00980004 	movi	r2,24576
81102158:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
8110215c:	00800044 	movi	r2,1
81102160:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
81102164:	e03ff515 	stw	zero,-44(fp)
			break;
81102168:	00000a06 	br	81102194 <bSdmaDmaM1Transfer+0x20c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
8110216c:	00800074 	movhi	r2,1
81102170:	10980004 	addi	r2,r2,24576
81102174:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81102178:	00800044 	movi	r2,1
8110217c:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
81102180:	e03ff515 	stw	zero,-44(fp)
			break;
81102184:	00000306 	br	81102194 <bSdmaDmaM1Transfer+0x20c>
		default:
			bChannelFlag = FALSE;
81102188:	e03ff615 	stw	zero,-40(fp)
			bBufferEmptyFlag = FALSE;
8110218c:	e03ff515 	stw	zero,-44(fp)
			break;
81102190:	0001883a 	nop
		}
		break;
81102194:	00005606 	br	811022f0 <bSdmaDmaM1Transfer+0x368>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81102198:	e0bffd03 	ldbu	r2,-12(fp)
8110219c:	10000826 	beq	r2,zero,811021c0 <bSdmaDmaM1Transfer+0x238>
811021a0:	10800060 	cmpeqi	r2,r2,1
811021a4:	10000d26 	beq	r2,zero,811021dc <bSdmaDmaM1Transfer+0x254>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
811021a8:	00a00014 	movui	r2,32768
811021ac:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
811021b0:	00800044 	movi	r2,1
811021b4:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
811021b8:	e03ff515 	stw	zero,-44(fp)
			break;
811021bc:	00000a06 	br	811021e8 <bSdmaDmaM1Transfer+0x260>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
811021c0:	008000b4 	movhi	r2,2
811021c4:	10a00004 	addi	r2,r2,-32768
811021c8:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
811021cc:	00800044 	movi	r2,1
811021d0:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
811021d4:	e03ff515 	stw	zero,-44(fp)
			break;
811021d8:	00000306 	br	811021e8 <bSdmaDmaM1Transfer+0x260>
		default:
			bChannelFlag = FALSE;
811021dc:	e03ff615 	stw	zero,-40(fp)
			bBufferEmptyFlag = FALSE;
811021e0:	e03ff515 	stw	zero,-44(fp)
			break;
811021e4:	0001883a 	nop
		}
		break;
811021e8:	00004106 	br	811022f0 <bSdmaDmaM1Transfer+0x368>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
811021ec:	e0bffd03 	ldbu	r2,-12(fp)
811021f0:	10000826 	beq	r2,zero,81102214 <bSdmaDmaM1Transfer+0x28c>
811021f4:	10800060 	cmpeqi	r2,r2,1
811021f8:	10000d26 	beq	r2,zero,81102230 <bSdmaDmaM1Transfer+0x2a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
811021fc:	00a80014 	movui	r2,40960
81102200:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81102204:	00800044 	movi	r2,1
81102208:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
8110220c:	e03ff515 	stw	zero,-44(fp)
			break;
81102210:	00000a06 	br	8110223c <bSdmaDmaM1Transfer+0x2b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81102214:	008000b4 	movhi	r2,2
81102218:	10a80004 	addi	r2,r2,-24576
8110221c:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81102220:	00800044 	movi	r2,1
81102224:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
81102228:	e03ff515 	stw	zero,-44(fp)
			break;
8110222c:	00000306 	br	8110223c <bSdmaDmaM1Transfer+0x2b4>
		default:
			bChannelFlag = FALSE;
81102230:	e03ff615 	stw	zero,-40(fp)
			bBufferEmptyFlag = FALSE;
81102234:	e03ff515 	stw	zero,-44(fp)
			break;
81102238:	0001883a 	nop
		}
		break;
8110223c:	00002c06 	br	811022f0 <bSdmaDmaM1Transfer+0x368>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81102240:	e0bffd03 	ldbu	r2,-12(fp)
81102244:	10000826 	beq	r2,zero,81102268 <bSdmaDmaM1Transfer+0x2e0>
81102248:	10800060 	cmpeqi	r2,r2,1
8110224c:	10000d26 	beq	r2,zero,81102284 <bSdmaDmaM1Transfer+0x2fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81102250:	00b00014 	movui	r2,49152
81102254:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81102258:	00800044 	movi	r2,1
8110225c:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
81102260:	e03ff515 	stw	zero,-44(fp)
			break;
81102264:	00000a06 	br	81102290 <bSdmaDmaM1Transfer+0x308>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81102268:	008000b4 	movhi	r2,2
8110226c:	10b00004 	addi	r2,r2,-16384
81102270:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81102274:	00800044 	movi	r2,1
81102278:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
8110227c:	e03ff515 	stw	zero,-44(fp)
			break;
81102280:	00000306 	br	81102290 <bSdmaDmaM1Transfer+0x308>
		default:
			bChannelFlag = FALSE;
81102284:	e03ff615 	stw	zero,-40(fp)
			bBufferEmptyFlag = FALSE;
81102288:	e03ff515 	stw	zero,-44(fp)
			break;
8110228c:	0001883a 	nop
		}
		break;
81102290:	00001706 	br	811022f0 <bSdmaDmaM1Transfer+0x368>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81102294:	e0bffd03 	ldbu	r2,-12(fp)
81102298:	10000826 	beq	r2,zero,811022bc <bSdmaDmaM1Transfer+0x334>
8110229c:	10800060 	cmpeqi	r2,r2,1
811022a0:	10000d26 	beq	r2,zero,811022d8 <bSdmaDmaM1Transfer+0x350>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
811022a4:	00b80014 	movui	r2,57344
811022a8:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
811022ac:	00800044 	movi	r2,1
811022b0:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
811022b4:	e03ff515 	stw	zero,-44(fp)
			break;
811022b8:	00000a06 	br	811022e4 <bSdmaDmaM1Transfer+0x35c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
811022bc:	008000b4 	movhi	r2,2
811022c0:	10b80004 	addi	r2,r2,-8192
811022c4:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
811022c8:	00800044 	movi	r2,1
811022cc:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
811022d0:	e03ff515 	stw	zero,-44(fp)
			break;
811022d4:	00000306 	br	811022e4 <bSdmaDmaM1Transfer+0x35c>
		default:
			bChannelFlag = FALSE;
811022d8:	e03ff615 	stw	zero,-40(fp)
			bBufferEmptyFlag = FALSE;
811022dc:	e03ff515 	stw	zero,-44(fp)
			break;
811022e0:	0001883a 	nop
		}
		break;
811022e4:	00000206 	br	811022f0 <bSdmaDmaM1Transfer+0x368>
	default:
		bChannelFlag = FALSE;
811022e8:	e03ff615 	stw	zero,-40(fp)
		break;
811022ec:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW	+ (alt_u32) uliDdrInitialAddr;
811022f0:	e0bffb17 	ldw	r2,-20(fp)
811022f4:	e0bff815 	stw	r2,-32(fp)
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
811022f8:	e03ff915 	stw	zero,-28(fp)

	if ( (bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
811022fc:	e0bff617 	ldw	r2,-40(fp)
81102300:	10003026 	beq	r2,zero,811023c4 <bSdmaDmaM1Transfer+0x43c>
81102304:	e0bff517 	ldw	r2,-44(fp)
81102308:	10002e26 	beq	r2,zero,811023c4 <bSdmaDmaM1Transfer+0x43c>
8110230c:	e0bffc0b 	ldhu	r2,-16(fp)
81102310:	10800468 	cmpgeui	r2,r2,17
81102314:	10002b1e 	bne	r2,zero,811023c4 <bSdmaDmaM1Transfer+0x43c>

		if (pxDmaM1Dev != NULL) {
81102318:	d0a03917 	ldw	r2,-32540(gp)
8110231c:	10002926 	beq	r2,zero,811023c4 <bSdmaDmaM1Transfer+0x43c>
			// hold transfers for descriptor fifo space
			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81102320:	00000206 	br	8110232c <bSdmaDmaM1Transfer+0x3a4>
				alt_busy_sleep(1); /* delay 1us */
81102324:	01000044 	movi	r4,1
81102328:	112ef6c0 	call	8112ef6c <alt_busy_sleep>

	if ( (bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {

		if (pxDmaM1Dev != NULL) {
			// hold transfers for descriptor fifo space
			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
8110232c:	d0a03917 	ldw	r2,-32540(gp)
81102330:	10800317 	ldw	r2,12(r2)
81102334:	10800037 	ldwio	r2,0(r2)
81102338:	1080010c 	andi	r2,r2,4
8110233c:	103ff91e 	bne	r2,zero,81102324 <__reset+0xfb0e2324>
				alt_busy_sleep(1); /* delay 1us */
			}
			/* Success = 0 */
			if (0 == iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
81102340:	d2203917 	ldw	r8,-32540(gp)
81102344:	e1bff817 	ldw	r6,-32(fp)
81102348:	e1fff317 	ldw	r7,-52(fp)
8110234c:	e0bffc0b 	ldhu	r2,-16(fp)
81102350:	10802224 	muli	r2,r2,136
81102354:	e0fff917 	ldw	r3,-28(fp)
81102358:	e13ff417 	ldw	r4,-48(fp)
8110235c:	01400044 	movi	r5,1
81102360:	d9400815 	stw	r5,32(sp)
81102364:	01400044 	movi	r5,1
81102368:	d9400715 	stw	r5,28(sp)
8110236c:	01400044 	movi	r5,1
81102370:	d9400615 	stw	r5,24(sp)
81102374:	01400044 	movi	r5,1
81102378:	d9400515 	stw	r5,20(sp)
8110237c:	01400044 	movi	r5,1
81102380:	d9400415 	stw	r5,16(sp)
81102384:	d9000315 	stw	r4,12(sp)
81102388:	d8c00215 	stw	r3,8(sp)
8110238c:	e0fffa17 	ldw	r3,-24(fp)
81102390:	d8c00115 	stw	r3,4(sp)
81102394:	d8800015 	stw	r2,0(sp)
81102398:	800b883a 	mov	r5,r16
8110239c:	4009883a 	mov	r4,r8
811023a0:	1109f2c0 	call	81109f2c <iMsgdmaConstructExtendedMmToMmDescriptor>
811023a4:	1000071e 	bne	r2,zero,811023c4 <bSdmaDmaM1Transfer+0x43c>
					(alt_u32 *) uliDestAddrLow,
					SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
					(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
					1, 1, 1, 1, 1)	) {
				/* Success = 0 */
				if (0 == iMsgdmaExtendedDescriptorAsyncTransfer(pxDmaM1Dev,	&xDmaExtendedDescriptor)) {
811023a8:	d0a03917 	ldw	r2,-32540(gp)
811023ac:	800b883a 	mov	r5,r16
811023b0:	1009883a 	mov	r4,r2
811023b4:	1109fec0 	call	81109fec <iMsgdmaExtendedDescriptorAsyncTransfer>
811023b8:	1000021e 	bne	r2,zero,811023c4 <bSdmaDmaM1Transfer+0x43c>
					bStatus = TRUE;
811023bc:	00800044 	movi	r2,1
811023c0:	e0bff215 	stw	r2,-56(fp)
				}
			}
		}
	}
	return bStatus;
811023c4:	e0bff217 	ldw	r2,-56(fp)
}
811023c8:	e6ffff04 	addi	sp,fp,-4
811023cc:	dfc00217 	ldw	ra,8(sp)
811023d0:	df000117 	ldw	fp,4(sp)
811023d4:	dc000017 	ldw	r16,0(sp)
811023d8:	dec00304 	addi	sp,sp,12
811023dc:	f800283a 	ret

811023e0 <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr, alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide, alt_u8 ucChBufferId) {
811023e0:	deffe704 	addi	sp,sp,-100
811023e4:	de00012e 	bgeu	sp,et,811023ec <bSdmaDmaM2Transfer+0xc>
811023e8:	003b68fa 	trap	3
811023ec:	dfc01815 	stw	ra,96(sp)
811023f0:	df001715 	stw	fp,92(sp)
811023f4:	dc001615 	stw	r16,88(sp)
811023f8:	df001704 	addi	fp,sp,92
811023fc:	e13ffb15 	stw	r4,-20(fp)
81102400:	2809883a 	mov	r4,r5
81102404:	3007883a 	mov	r3,r6
81102408:	3805883a 	mov	r2,r7
8110240c:	e13ffc0d 	sth	r4,-16(fp)
81102410:	e0fffd05 	stb	r3,-12(fp)
81102414:	e0bffe05 	stb	r2,-8(fp)
81102418:	defff004 	addi	sp,sp,-64
8110241c:	d8800904 	addi	r2,sp,36
81102420:	108007c4 	addi	r2,r2,31
81102424:	1004d17a 	srli	r2,r2,5
81102428:	1020917a 	slli	r16,r2,5
	bool bStatus;
	alt_u16 usiCnt = 0;
8110242c:	e03ff70d 	sth	zero,-36(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81102430:	e03ff315 	stw	zero,-52(fp)
	alt_u32 uliDestAddrHigh = 0;
81102434:	e03ff415 	stw	zero,-48(fp)

	alt_u32 uliSrcAddrLow = 0;
81102438:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
8110243c:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81102440:	e03ffa15 	stw	zero,-24(fp)
	bool bBufferEmptyFlag;
	bool bChannelFlag;


	/* Assuming that the channel selected exist, change to FALSE if doesn't */
	bChannelFlag = TRUE;
81102444:	00800044 	movi	r2,1
81102448:	e0bff615 	stw	r2,-40(fp)
	bStatus = FALSE;
8110244c:	e03ff215 	stw	zero,-56(fp)
	bBufferEmptyFlag = FALSE;
81102450:	e03ff515 	stw	zero,-44(fp)
	switch (ucChBufferId) {
81102454:	e0bffe03 	ldbu	r2,-8(fp)
81102458:	10c00228 	cmpgeui	r3,r2,8
8110245c:	1800b81e 	bne	r3,zero,81102740 <bSdmaDmaM2Transfer+0x360>
81102460:	100690ba 	slli	r3,r2,2
81102464:	00a04434 	movhi	r2,33040
81102468:	10891e04 	addi	r2,r2,9336
8110246c:	1885883a 	add	r2,r3,r2
81102470:	10800017 	ldw	r2,0(r2)
81102474:	1000683a 	jmp	r2
81102478:	81102498 	cmpnei	r4,r16,16530
8110247c:	811024ec 	andhi	r4,r16,16531
81102480:	81102548 	cmpgei	r4,r16,16533
81102484:	8110259c 	xori	r4,r16,16534
81102488:	811025f0 	cmpltui	r4,r16,16535
8110248c:	81102644 	addi	r4,r16,16537
81102490:	81102698 	cmpnei	r4,r16,16538
81102494:	811026ec 	andhi	r4,r16,16539
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81102498:	e0bffd03 	ldbu	r2,-12(fp)
8110249c:	10000826 	beq	r2,zero,811024c0 <bSdmaDmaM2Transfer+0xe0>
811024a0:	10800060 	cmpeqi	r2,r2,1
811024a4:	10000d26 	beq	r2,zero,811024dc <bSdmaDmaM2Transfer+0xfc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
811024a8:	e03ff315 	stw	zero,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
811024ac:	00800044 	movi	r2,1
811024b0:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
811024b4:	11048f00 	call	811048f0 <bFeebGetCh1RightBufferEmpty>
811024b8:	e0bff515 	stw	r2,-44(fp)
			break;
811024bc:	00000a06 	br	811024e8 <bSdmaDmaM2Transfer+0x108>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
811024c0:	00800074 	movhi	r2,1
811024c4:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
811024c8:	00800044 	movi	r2,1
811024cc:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
811024d0:	11048880 	call	81104888 <bFeebGetCh1LeftBufferEmpty>
811024d4:	e0bff515 	stw	r2,-44(fp)
			break;
811024d8:	00000306 	br	811024e8 <bSdmaDmaM2Transfer+0x108>
		default:
			bChannelFlag = FALSE;
811024dc:	e03ff615 	stw	zero,-40(fp)
			bBufferEmptyFlag = FALSE;
811024e0:	e03ff515 	stw	zero,-44(fp)
			break;
811024e4:	0001883a 	nop
		}
		break;
811024e8:	00009706 	br	81102748 <bSdmaDmaM2Transfer+0x368>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
811024ec:	e0bffd03 	ldbu	r2,-12(fp)
811024f0:	10000926 	beq	r2,zero,81102518 <bSdmaDmaM2Transfer+0x138>
811024f4:	10800060 	cmpeqi	r2,r2,1
811024f8:	10000f26 	beq	r2,zero,81102538 <bSdmaDmaM2Transfer+0x158>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
811024fc:	00880004 	movi	r2,8192
81102500:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81102504:	00800044 	movi	r2,1
81102508:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
8110250c:	11049c00 	call	811049c0 <bFeebGetCh2RightBufferEmpty>
81102510:	e0bff515 	stw	r2,-44(fp)
			break;
81102514:	00000b06 	br	81102544 <bSdmaDmaM2Transfer+0x164>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81102518:	00800074 	movhi	r2,1
8110251c:	10880004 	addi	r2,r2,8192
81102520:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81102524:	00800044 	movi	r2,1
81102528:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
8110252c:	11049580 	call	81104958 <bFeebGetCh2LeftBufferEmpty>
81102530:	e0bff515 	stw	r2,-44(fp)
			break;
81102534:	00000306 	br	81102544 <bSdmaDmaM2Transfer+0x164>
		default:
			bChannelFlag = FALSE;
81102538:	e03ff615 	stw	zero,-40(fp)
			bBufferEmptyFlag = FALSE;
8110253c:	e03ff515 	stw	zero,-44(fp)
			break;
81102540:	0001883a 	nop
		}
		break;
81102544:	00008006 	br	81102748 <bSdmaDmaM2Transfer+0x368>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81102548:	e0bffd03 	ldbu	r2,-12(fp)
8110254c:	10000826 	beq	r2,zero,81102570 <bSdmaDmaM2Transfer+0x190>
81102550:	10800060 	cmpeqi	r2,r2,1
81102554:	10000d26 	beq	r2,zero,8110258c <bSdmaDmaM2Transfer+0x1ac>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81102558:	00900004 	movi	r2,16384
8110255c:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81102560:	00800044 	movi	r2,1
81102564:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
81102568:	e03ff515 	stw	zero,-44(fp)
			break;
8110256c:	00000a06 	br	81102598 <bSdmaDmaM2Transfer+0x1b8>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81102570:	00800074 	movhi	r2,1
81102574:	10900004 	addi	r2,r2,16384
81102578:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
8110257c:	00800044 	movi	r2,1
81102580:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
81102584:	e03ff515 	stw	zero,-44(fp)
			break;
81102588:	00000306 	br	81102598 <bSdmaDmaM2Transfer+0x1b8>
		default:
			bChannelFlag = FALSE;
8110258c:	e03ff615 	stw	zero,-40(fp)
			bBufferEmptyFlag = FALSE;
81102590:	e03ff515 	stw	zero,-44(fp)
			break;
81102594:	0001883a 	nop
		}
		break;
81102598:	00006b06 	br	81102748 <bSdmaDmaM2Transfer+0x368>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
8110259c:	e0bffd03 	ldbu	r2,-12(fp)
811025a0:	10000826 	beq	r2,zero,811025c4 <bSdmaDmaM2Transfer+0x1e4>
811025a4:	10800060 	cmpeqi	r2,r2,1
811025a8:	10000d26 	beq	r2,zero,811025e0 <bSdmaDmaM2Transfer+0x200>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
811025ac:	00980004 	movi	r2,24576
811025b0:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
811025b4:	00800044 	movi	r2,1
811025b8:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
811025bc:	e03ff515 	stw	zero,-44(fp)
			break;
811025c0:	00000a06 	br	811025ec <bSdmaDmaM2Transfer+0x20c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
811025c4:	00800074 	movhi	r2,1
811025c8:	10980004 	addi	r2,r2,24576
811025cc:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
811025d0:	00800044 	movi	r2,1
811025d4:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
811025d8:	e03ff515 	stw	zero,-44(fp)
			break;
811025dc:	00000306 	br	811025ec <bSdmaDmaM2Transfer+0x20c>
		default:
			bChannelFlag = FALSE;
811025e0:	e03ff615 	stw	zero,-40(fp)
			bBufferEmptyFlag = FALSE;
811025e4:	e03ff515 	stw	zero,-44(fp)
			break;
811025e8:	0001883a 	nop
		}
		break;
811025ec:	00005606 	br	81102748 <bSdmaDmaM2Transfer+0x368>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
811025f0:	e0bffd03 	ldbu	r2,-12(fp)
811025f4:	10000826 	beq	r2,zero,81102618 <bSdmaDmaM2Transfer+0x238>
811025f8:	10800060 	cmpeqi	r2,r2,1
811025fc:	10000d26 	beq	r2,zero,81102634 <bSdmaDmaM2Transfer+0x254>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81102600:	00a00014 	movui	r2,32768
81102604:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81102608:	00800044 	movi	r2,1
8110260c:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
81102610:	e03ff515 	stw	zero,-44(fp)
			break;
81102614:	00000a06 	br	81102640 <bSdmaDmaM2Transfer+0x260>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81102618:	008000b4 	movhi	r2,2
8110261c:	10a00004 	addi	r2,r2,-32768
81102620:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81102624:	00800044 	movi	r2,1
81102628:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
8110262c:	e03ff515 	stw	zero,-44(fp)
			break;
81102630:	00000306 	br	81102640 <bSdmaDmaM2Transfer+0x260>
		default:
			bChannelFlag = FALSE;
81102634:	e03ff615 	stw	zero,-40(fp)
			bBufferEmptyFlag = FALSE;
81102638:	e03ff515 	stw	zero,-44(fp)
			break;
8110263c:	0001883a 	nop
		}
		break;
81102640:	00004106 	br	81102748 <bSdmaDmaM2Transfer+0x368>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81102644:	e0bffd03 	ldbu	r2,-12(fp)
81102648:	10000826 	beq	r2,zero,8110266c <bSdmaDmaM2Transfer+0x28c>
8110264c:	10800060 	cmpeqi	r2,r2,1
81102650:	10000d26 	beq	r2,zero,81102688 <bSdmaDmaM2Transfer+0x2a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81102654:	00a80014 	movui	r2,40960
81102658:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
8110265c:	00800044 	movi	r2,1
81102660:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
81102664:	e03ff515 	stw	zero,-44(fp)
			break;
81102668:	00000a06 	br	81102694 <bSdmaDmaM2Transfer+0x2b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
8110266c:	008000b4 	movhi	r2,2
81102670:	10a80004 	addi	r2,r2,-24576
81102674:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81102678:	00800044 	movi	r2,1
8110267c:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
81102680:	e03ff515 	stw	zero,-44(fp)
			break;
81102684:	00000306 	br	81102694 <bSdmaDmaM2Transfer+0x2b4>
		default:
			bChannelFlag = FALSE;
81102688:	e03ff615 	stw	zero,-40(fp)
			bBufferEmptyFlag = FALSE;
8110268c:	e03ff515 	stw	zero,-44(fp)
			break;
81102690:	0001883a 	nop
		}
		break;
81102694:	00002c06 	br	81102748 <bSdmaDmaM2Transfer+0x368>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81102698:	e0bffd03 	ldbu	r2,-12(fp)
8110269c:	10000826 	beq	r2,zero,811026c0 <bSdmaDmaM2Transfer+0x2e0>
811026a0:	10800060 	cmpeqi	r2,r2,1
811026a4:	10000d26 	beq	r2,zero,811026dc <bSdmaDmaM2Transfer+0x2fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
811026a8:	00b00014 	movui	r2,49152
811026ac:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
811026b0:	00800044 	movi	r2,1
811026b4:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
811026b8:	e03ff515 	stw	zero,-44(fp)
			break;
811026bc:	00000a06 	br	811026e8 <bSdmaDmaM2Transfer+0x308>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
811026c0:	008000b4 	movhi	r2,2
811026c4:	10b00004 	addi	r2,r2,-16384
811026c8:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
811026cc:	00800044 	movi	r2,1
811026d0:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
811026d4:	e03ff515 	stw	zero,-44(fp)
			break;
811026d8:	00000306 	br	811026e8 <bSdmaDmaM2Transfer+0x308>
		default:
			bChannelFlag = FALSE;
811026dc:	e03ff615 	stw	zero,-40(fp)
			bBufferEmptyFlag = FALSE;
811026e0:	e03ff515 	stw	zero,-44(fp)
			break;
811026e4:	0001883a 	nop
		}
		break;
811026e8:	00001706 	br	81102748 <bSdmaDmaM2Transfer+0x368>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
811026ec:	e0bffd03 	ldbu	r2,-12(fp)
811026f0:	10000826 	beq	r2,zero,81102714 <bSdmaDmaM2Transfer+0x334>
811026f4:	10800060 	cmpeqi	r2,r2,1
811026f8:	10000d26 	beq	r2,zero,81102730 <bSdmaDmaM2Transfer+0x350>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
811026fc:	00b80014 	movui	r2,57344
81102700:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81102704:	00800044 	movi	r2,1
81102708:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
8110270c:	e03ff515 	stw	zero,-44(fp)
			break;
81102710:	00000a06 	br	8110273c <bSdmaDmaM2Transfer+0x35c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81102714:	008000b4 	movhi	r2,2
81102718:	10b80004 	addi	r2,r2,-8192
8110271c:	e0bff315 	stw	r2,-52(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81102720:	00800044 	movi	r2,1
81102724:	e0bff415 	stw	r2,-48(fp)
			bBufferEmptyFlag = FALSE;
81102728:	e03ff515 	stw	zero,-44(fp)
			break;
8110272c:	00000306 	br	8110273c <bSdmaDmaM2Transfer+0x35c>
		default:
			bChannelFlag = FALSE;
81102730:	e03ff615 	stw	zero,-40(fp)
			bBufferEmptyFlag = FALSE;
81102734:	e03ff515 	stw	zero,-44(fp)
			break;
81102738:	0001883a 	nop
		}
		break;
8110273c:	00000206 	br	81102748 <bSdmaDmaM2Transfer+0x368>
	default:
		bChannelFlag = FALSE;
81102740:	e03ff615 	stw	zero,-40(fp)
		break;
81102744:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
81102748:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bChannelFlag = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
8110274c:	00a00034 	movhi	r2,32768
81102750:	1885883a 	add	r2,r3,r2
81102754:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
81102758:	e03ff915 	stw	zero,-28(fp)

	if ((bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
8110275c:	e0bff617 	ldw	r2,-40(fp)
81102760:	10003026 	beq	r2,zero,81102824 <bSdmaDmaM2Transfer+0x444>
81102764:	e0bff517 	ldw	r2,-44(fp)
81102768:	10002e26 	beq	r2,zero,81102824 <bSdmaDmaM2Transfer+0x444>
8110276c:	e0bffc0b 	ldhu	r2,-16(fp)
81102770:	10800468 	cmpgeui	r2,r2,17
81102774:	10002b1e 	bne	r2,zero,81102824 <bSdmaDmaM2Transfer+0x444>
		if (pxDmaM2Dev != NULL) {
81102778:	d0a03a17 	ldw	r2,-32536(gp)
8110277c:	10002926 	beq	r2,zero,81102824 <bSdmaDmaM2Transfer+0x444>

			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81102780:	00000206 	br	8110278c <bSdmaDmaM2Transfer+0x3ac>
				alt_busy_sleep(1); /* delay 1us */
81102784:	01000044 	movi	r4,1
81102788:	112ef6c0 	call	8112ef6c <alt_busy_sleep>
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;

	if ((bChannelFlag) && (bBufferEmptyFlag) && (usiTransferSizeInBlocks <= 16)) {
		if (pxDmaM2Dev != NULL) {

			while (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
8110278c:	d0a03a17 	ldw	r2,-32536(gp)
81102790:	10800317 	ldw	r2,12(r2)
81102794:	10800037 	ldwio	r2,0(r2)
81102798:	1080010c 	andi	r2,r2,4
8110279c:	103ff91e 	bne	r2,zero,81102784 <__reset+0xfb0e2784>
				alt_busy_sleep(1); /* delay 1us */
			}
			/* Success = 0 */
			if ( 0 == iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
811027a0:	d2203a17 	ldw	r8,-32536(gp)
811027a4:	e1bff817 	ldw	r6,-32(fp)
811027a8:	e1fff317 	ldw	r7,-52(fp)
811027ac:	e0bffc0b 	ldhu	r2,-16(fp)
811027b0:	10802224 	muli	r2,r2,136
811027b4:	e0fff917 	ldw	r3,-28(fp)
811027b8:	e13ff417 	ldw	r4,-48(fp)
811027bc:	01400044 	movi	r5,1
811027c0:	d9400815 	stw	r5,32(sp)
811027c4:	01400044 	movi	r5,1
811027c8:	d9400715 	stw	r5,28(sp)
811027cc:	01400044 	movi	r5,1
811027d0:	d9400615 	stw	r5,24(sp)
811027d4:	01400044 	movi	r5,1
811027d8:	d9400515 	stw	r5,20(sp)
811027dc:	01400044 	movi	r5,1
811027e0:	d9400415 	stw	r5,16(sp)
811027e4:	d9000315 	stw	r4,12(sp)
811027e8:	d8c00215 	stw	r3,8(sp)
811027ec:	e0fffa17 	ldw	r3,-24(fp)
811027f0:	d8c00115 	stw	r3,4(sp)
811027f4:	d8800015 	stw	r2,0(sp)
811027f8:	800b883a 	mov	r5,r16
811027fc:	4009883a 	mov	r4,r8
81102800:	1109f2c0 	call	81109f2c <iMsgdmaConstructExtendedMmToMmDescriptor>
81102804:	1000071e 	bne	r2,zero,81102824 <bSdmaDmaM2Transfer+0x444>
					(alt_u32 *) uliDestAddrLow,
					SDMA_PIXEL_BLOCK_SIZE_BYTES*usiTransferSizeInBlocks, uliControlBits,
					(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
					1, 1, 1, 1, 1)) {
				/* Success = 0 */
				if ( 0 == iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
81102808:	d0a03a17 	ldw	r2,-32536(gp)
8110280c:	800b883a 	mov	r5,r16
81102810:	1009883a 	mov	r4,r2
81102814:	110a0300 	call	8110a030 <iMsgdmaExtendedDescriptorSyncTransfer>
81102818:	1000021e 	bne	r2,zero,81102824 <bSdmaDmaM2Transfer+0x444>
						&xDmaExtendedDescriptor)) {
					bStatus = TRUE;
8110281c:	00800044 	movi	r2,1
81102820:	e0bff215 	stw	r2,-56(fp)
				}
			}
		}
	}
	return bStatus;
81102824:	e0bff217 	ldw	r2,-56(fp)
}
81102828:	e6ffff04 	addi	sp,fp,-4
8110282c:	dfc00217 	ldw	ra,8(sp)
81102830:	df000117 	ldw	fp,4(sp)
81102834:	dc000017 	ldw	r16,0(sp)
81102838:	dec00304 	addi	sp,sp,12
8110283c:	f800283a 	ret

81102840 <bCommSetGlobalIrqEn>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bCommSetGlobalIrqEn(bool bGlobalIrqEnable, alt_u8 ucCommCh) {
81102840:	defff904 	addi	sp,sp,-28
81102844:	de00012e 	bgeu	sp,et,8110284c <bCommSetGlobalIrqEn+0xc>
81102848:	003b68fa 	trap	3
8110284c:	dfc00615 	stw	ra,24(sp)
81102850:	df000515 	stw	fp,20(sp)
81102854:	df000504 	addi	fp,sp,20
81102858:	e13ffe15 	stw	r4,-8(fp)
8110285c:	2805883a 	mov	r2,r5
81102860:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81102864:	00800044 	movi	r2,1
81102868:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
8110286c:	e03ffc15 	stw	zero,-16(fp)
	alt_u32 *puliCommAddr = 0;
81102870:	e03ffd15 	stw	zero,-12(fp)

	switch (ucCommCh) {
81102874:	e0bfff03 	ldbu	r2,-4(fp)
81102878:	10c00228 	cmpgeui	r3,r2,8
8110287c:	18002e1e 	bne	r3,zero,81102938 <bCommSetGlobalIrqEn+0xf8>
81102880:	100690ba 	slli	r3,r2,2
81102884:	00a04434 	movhi	r2,33040
81102888:	108a2604 	addi	r2,r2,10392
8110288c:	1885883a 	add	r2,r3,r2
81102890:	10800017 	ldw	r2,0(r2)
81102894:	1000683a 	jmp	r2
81102898:	811028b8 	rdprs	r4,r16,16546
8110289c:	811028c8 	cmpgei	r4,r16,16547
811028a0:	811028d8 	cmpnei	r4,r16,16547
811028a4:	811028e8 	cmpgeui	r4,r16,16547
811028a8:	811028f8 	rdprs	r4,r16,16547
811028ac:	81102908 	cmpgei	r4,r16,16548
811028b0:	81102918 	cmpnei	r4,r16,16548
811028b4:	81102928 	cmpgeui	r4,r16,16548
	case eCommSpwCh1:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
811028b8:	00a04834 	movhi	r2,33056
811028bc:	108b0004 	addi	r2,r2,11264
811028c0:	e0bffd15 	stw	r2,-12(fp)
		break;
811028c4:	00001e06 	br	81102940 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh2:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
811028c8:	00a04834 	movhi	r2,33056
811028cc:	108a0004 	addi	r2,r2,10240
811028d0:	e0bffd15 	stw	r2,-12(fp)
		break;
811028d4:	00001a06 	br	81102940 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh3:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811028d8:	00a04834 	movhi	r2,33056
811028dc:	108b0004 	addi	r2,r2,11264
811028e0:	e0bffd15 	stw	r2,-12(fp)
		break;
811028e4:	00001606 	br	81102940 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh4:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
811028e8:	00a04834 	movhi	r2,33056
811028ec:	108a0004 	addi	r2,r2,10240
811028f0:	e0bffd15 	stw	r2,-12(fp)
		break;
811028f4:	00001206 	br	81102940 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh5:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
811028f8:	00a04834 	movhi	r2,33056
811028fc:	108b0004 	addi	r2,r2,11264
81102900:	e0bffd15 	stw	r2,-12(fp)
		break;
81102904:	00000e06 	br	81102940 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh6:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81102908:	00a04834 	movhi	r2,33056
8110290c:	108a0004 	addi	r2,r2,10240
81102910:	e0bffd15 	stw	r2,-12(fp)
		break;
81102914:	00000a06 	br	81102940 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh7:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81102918:	00a04834 	movhi	r2,33056
8110291c:	108b0004 	addi	r2,r2,11264
81102920:	e0bffd15 	stw	r2,-12(fp)
		break;
81102924:	00000606 	br	81102940 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh8:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81102928:	00a04834 	movhi	r2,33056
8110292c:	108a0004 	addi	r2,r2,10240
81102930:	e0bffd15 	stw	r2,-12(fp)
		break;
81102934:	00000206 	br	81102940 <bCommSetGlobalIrqEn+0x100>
	default:
		bStatus = FALSE;
81102938:	e03ffb15 	stw	zero,-20(fp)
		break;
8110293c:	0001883a 	nop
	}

	if (bStatus) {
81102940:	e0bffb17 	ldw	r2,-20(fp)
81102944:	10001326 	beq	r2,zero,81102994 <bCommSetGlobalIrqEn+0x154>
		uliReg = uliCommReadReg(puliCommAddr,
81102948:	01400444 	movi	r5,17
8110294c:	e13ffd17 	ldw	r4,-12(fp)
81102950:	1102ad00 	call	81102ad0 <uliCommReadReg>
81102954:	e0bffc15 	stw	r2,-16(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (bGlobalIrqEnable) {
81102958:	e0bffe17 	ldw	r2,-8(fp)
8110295c:	10000426 	beq	r2,zero,81102970 <bCommSetGlobalIrqEn+0x130>
			uliReg |= COMM_IRQ_GLOBAL_EN_MSK;
81102960:	e0bffc17 	ldw	r2,-16(fp)
81102964:	10800074 	orhi	r2,r2,1
81102968:	e0bffc15 	stw	r2,-16(fp)
8110296c:	00000506 	br	81102984 <bCommSetGlobalIrqEn+0x144>
		} else {
			uliReg &= (~COMM_IRQ_GLOBAL_EN_MSK);
81102970:	e0fffc17 	ldw	r3,-16(fp)
81102974:	00bffff4 	movhi	r2,65535
81102978:	10bfffc4 	addi	r2,r2,-1
8110297c:	1884703a 	and	r2,r3,r2
81102980:	e0bffc15 	stw	r2,-16(fp)
		}

		vCommWriteReg(puliCommAddr, COMM_IRQ_CONTROL_REG_OFST, uliReg);
81102984:	e1bffc17 	ldw	r6,-16(fp)
81102988:	01400444 	movi	r5,17
8110298c:	e13ffd17 	ldw	r4,-12(fp)
81102990:	1102a7c0 	call	81102a7c <vCommWriteReg>
	}

	return bStatus;
81102994:	e0bffb17 	ldw	r2,-20(fp)
}
81102998:	e037883a 	mov	sp,fp
8110299c:	dfc00117 	ldw	ra,4(sp)
811029a0:	df000017 	ldw	fp,0(sp)
811029a4:	dec00204 	addi	sp,sp,8
811029a8:	f800283a 	ret

811029ac <bCommInitCh>:

bool bCommInitCh(TCommChannel *pxCommCh, alt_u8 ucCommCh) {
811029ac:	defffb04 	addi	sp,sp,-20
811029b0:	de00012e 	bgeu	sp,et,811029b8 <bCommInitCh+0xc>
811029b4:	003b68fa 	trap	3
811029b8:	dfc00415 	stw	ra,16(sp)
811029bc:	df000315 	stw	fp,12(sp)
811029c0:	df000304 	addi	fp,sp,12
811029c4:	e13ffe15 	stw	r4,-8(fp)
811029c8:	2805883a 	mov	r2,r5
811029cc:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811029d0:	00800044 	movi	r2,1
811029d4:	e0bffd15 	stw	r2,-12(fp)

	if (!bSpwcInitCh(&(pxCommCh->xSpacewire), ucCommCh)) {
811029d8:	e0bffe17 	ldw	r2,-8(fp)
811029dc:	10805704 	addi	r2,r2,348
811029e0:	e0ffff03 	ldbu	r3,-4(fp)
811029e4:	180b883a 	mov	r5,r3
811029e8:	1009883a 	mov	r4,r2
811029ec:	11089580 	call	81108958 <bSpwcInitCh>
811029f0:	1000011e 	bne	r2,zero,811029f8 <bCommInitCh+0x4c>
		bStatus = FALSE;
811029f4:	e03ffd15 	stw	zero,-12(fp)
	}
	//vFeebInitIrq(ucCommCh);

	if (!bFeebInitCh(&(pxCommCh->xFeeBuffer), ucCommCh)) {
811029f8:	e0bffe17 	ldw	r2,-8(fp)
811029fc:	10800904 	addi	r2,r2,36
81102a00:	e0ffff03 	ldbu	r3,-4(fp)
81102a04:	180b883a 	mov	r5,r3
81102a08:	1009883a 	mov	r4,r2
81102a0c:	1104dd00 	call	81104dd0 <bFeebInitCh>
81102a10:	1000011e 	bne	r2,zero,81102a18 <bCommInitCh+0x6c>
		bStatus = FALSE;
81102a14:	e03ffd15 	stw	zero,-12(fp)
	}
	if (!bRmapInitCh(&(pxCommCh->xRmap), ucCommCh)) {
81102a18:	e0bffe17 	ldw	r2,-8(fp)
81102a1c:	10801104 	addi	r2,r2,68
81102a20:	e0ffff03 	ldbu	r3,-4(fp)
81102a24:	180b883a 	mov	r5,r3
81102a28:	1009883a 	mov	r4,r2
81102a2c:	1107fb40 	call	81107fb4 <bRmapInitCh>
81102a30:	1000011e 	bne	r2,zero,81102a38 <bCommInitCh+0x8c>
		bStatus = FALSE;
81102a34:	e03ffd15 	stw	zero,-12(fp)
	}
	vRmapInitIrq(ucCommCh);
81102a38:	e0bfff03 	ldbu	r2,-4(fp)
81102a3c:	1009883a 	mov	r4,r2
81102a40:	11059f00 	call	811059f0 <vRmapInitIrq>

	if (!bDpktInitCh(&(pxCommCh->xDataPacket), ucCommCh)) {
81102a44:	e0bffe17 	ldw	r2,-8(fp)
81102a48:	10800104 	addi	r2,r2,4
81102a4c:	e0ffff03 	ldbu	r3,-4(fp)
81102a50:	180b883a 	mov	r5,r3
81102a54:	1009883a 	mov	r4,r2
81102a58:	11031480 	call	81103148 <bDpktInitCh>
81102a5c:	1000011e 	bne	r2,zero,81102a64 <bCommInitCh+0xb8>
		bStatus = FALSE;
81102a60:	e03ffd15 	stw	zero,-12(fp)
	}
	return bStatus;
81102a64:	e0bffd17 	ldw	r2,-12(fp)
}
81102a68:	e037883a 	mov	sp,fp
81102a6c:	dfc00117 	ldw	ra,4(sp)
81102a70:	df000017 	ldw	fp,0(sp)
81102a74:	dec00204 	addi	sp,sp,8
81102a78:	f800283a 	ret

81102a7c <vCommWriteReg>:
//! [public functions]

//! [private functions]
static void vCommWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81102a7c:	defffc04 	addi	sp,sp,-16
81102a80:	de00012e 	bgeu	sp,et,81102a88 <vCommWriteReg+0xc>
81102a84:	003b68fa 	trap	3
81102a88:	df000315 	stw	fp,12(sp)
81102a8c:	df000304 	addi	fp,sp,12
81102a90:	e13ffd15 	stw	r4,-12(fp)
81102a94:	e17ffe15 	stw	r5,-8(fp)
81102a98:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81102a9c:	e0bffe17 	ldw	r2,-8(fp)
81102aa0:	1085883a 	add	r2,r2,r2
81102aa4:	1085883a 	add	r2,r2,r2
81102aa8:	1007883a 	mov	r3,r2
81102aac:	e0bffd17 	ldw	r2,-12(fp)
81102ab0:	10c5883a 	add	r2,r2,r3
81102ab4:	e0ffff17 	ldw	r3,-4(fp)
81102ab8:	10c00015 	stw	r3,0(r2)
}
81102abc:	0001883a 	nop
81102ac0:	e037883a 	mov	sp,fp
81102ac4:	df000017 	ldw	fp,0(sp)
81102ac8:	dec00104 	addi	sp,sp,4
81102acc:	f800283a 	ret

81102ad0 <uliCommReadReg>:

static alt_u32 uliCommReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81102ad0:	defffc04 	addi	sp,sp,-16
81102ad4:	de00012e 	bgeu	sp,et,81102adc <uliCommReadReg+0xc>
81102ad8:	003b68fa 	trap	3
81102adc:	df000315 	stw	fp,12(sp)
81102ae0:	df000304 	addi	fp,sp,12
81102ae4:	e13ffe15 	stw	r4,-8(fp)
81102ae8:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81102aec:	e0bfff17 	ldw	r2,-4(fp)
81102af0:	1085883a 	add	r2,r2,r2
81102af4:	1085883a 	add	r2,r2,r2
81102af8:	1007883a 	mov	r3,r2
81102afc:	e0bffe17 	ldw	r2,-8(fp)
81102b00:	10c5883a 	add	r2,r2,r3
81102b04:	10800017 	ldw	r2,0(r2)
81102b08:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81102b0c:	e0bffd17 	ldw	r2,-12(fp)
}
81102b10:	e037883a 	mov	sp,fp
81102b14:	df000017 	ldw	fp,0(sp)
81102b18:	dec00104 	addi	sp,sp,4
81102b1c:	f800283a 	ret

81102b20 <bDpktSetPacketConfig>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bDpktSetPacketConfig(TDpktChannel *pxDpktCh) {
81102b20:	defffb04 	addi	sp,sp,-20
81102b24:	de00012e 	bgeu	sp,et,81102b2c <bDpktSetPacketConfig+0xc>
81102b28:	003b68fa 	trap	3
81102b2c:	dfc00415 	stw	ra,16(sp)
81102b30:	df000315 	stw	fp,12(sp)
81102b34:	df000304 	addi	fp,sp,12
81102b38:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81102b3c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81102b40:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81102b44:	e0bfff17 	ldw	r2,-4(fp)
81102b48:	10007a26 	beq	r2,zero,81102d34 <bDpktSetPacketConfig+0x214>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81102b4c:	e0bfff17 	ldw	r2,-4(fp)
81102b50:	10800017 	ldw	r2,0(r2)
81102b54:	01400204 	movi	r5,8
81102b58:	1009883a 	mov	r4,r2
81102b5c:	11033100 	call	81103310 <uliDpktReadReg>
81102b60:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
81102b64:	e0bffe17 	ldw	r2,-8(fp)
81102b68:	10bfffec 	andhi	r2,r2,65535
81102b6c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
81102b70:	e0bfff17 	ldw	r2,-4(fp)
81102b74:	1080010b 	ldhu	r2,4(r2)
81102b78:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
81102b7c:	e0fffe17 	ldw	r3,-8(fp)
81102b80:	1884b03a 	or	r2,r3,r2
81102b84:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
81102b88:	e0bffe17 	ldw	r2,-8(fp)
81102b8c:	10bfffcc 	andi	r2,r2,65535
81102b90:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));
81102b94:	e0bfff17 	ldw	r2,-4(fp)
81102b98:	1080018b 	ldhu	r2,6(r2)
81102b9c:	10bfffcc 	andi	r2,r2,65535
81102ba0:	1004943a 	slli	r2,r2,16
81102ba4:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
81102ba8:	e0bffe17 	ldw	r2,-8(fp)
81102bac:	10c4b03a 	or	r2,r2,r3
81102bb0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_1_REG_OFST,
81102bb4:	e0bfff17 	ldw	r2,-4(fp)
81102bb8:	10800017 	ldw	r2,0(r2)
81102bbc:	e1bffe17 	ldw	r6,-8(fp)
81102bc0:	01400204 	movi	r5,8
81102bc4:	1009883a 	mov	r4,r2
81102bc8:	11032bc0 	call	811032bc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81102bcc:	e0bfff17 	ldw	r2,-4(fp)
81102bd0:	10800017 	ldw	r2,0(r2)
81102bd4:	01400244 	movi	r5,9
81102bd8:	1009883a 	mov	r4,r2
81102bdc:	11033100 	call	81103310 <uliDpktReadReg>
81102be0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
81102be4:	e0bffe17 	ldw	r2,-8(fp)
81102be8:	10bfffec 	andhi	r2,r2,65535
81102bec:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
81102bf0:	e0bfff17 	ldw	r2,-4(fp)
81102bf4:	1080020b 	ldhu	r2,8(r2)
81102bf8:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
81102bfc:	e0fffe17 	ldw	r3,-8(fp)
81102c00:	1884b03a 	or	r2,r3,r2
81102c04:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
81102c08:	e0bffe17 	ldw	r2,-8(fp)
81102c0c:	10bfffcc 	andi	r2,r2,65535
81102c10:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
81102c14:	e0bfff17 	ldw	r2,-4(fp)
81102c18:	1080028b 	ldhu	r2,10(r2)
										<< 16));
81102c1c:	10bfffcc 	andi	r2,r2,65535
81102c20:	1004943a 	slli	r2,r2,16
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
81102c24:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
81102c28:	e0bffe17 	ldw	r2,-8(fp)
81102c2c:	10c4b03a 	or	r2,r2,r3
81102c30:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
										<< 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_2_REG_OFST,
81102c34:	e0bfff17 	ldw	r2,-4(fp)
81102c38:	10800017 	ldw	r2,0(r2)
81102c3c:	e1bffe17 	ldw	r6,-8(fp)
81102c40:	01400244 	movi	r5,9
81102c44:	1009883a 	mov	r4,r2
81102c48:	11032bc0 	call	811032bc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81102c4c:	e0bfff17 	ldw	r2,-4(fp)
81102c50:	10800017 	ldw	r2,0(r2)
81102c54:	01400284 	movi	r5,10
81102c58:	1009883a 	mov	r4,r2
81102c5c:	11033100 	call	81103310 <uliDpktReadReg>
81102c60:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
81102c64:	e0bffe17 	ldw	r2,-8(fp)
81102c68:	10bfffec 	andhi	r2,r2,65535
81102c6c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
81102c70:	e0bfff17 	ldw	r2,-4(fp)
81102c74:	1080030b 	ldhu	r2,12(r2)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
81102c78:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
81102c7c:	e0fffe17 	ldw	r3,-8(fp)
81102c80:	1884b03a 	or	r2,r3,r2
81102c84:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
										<< 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_3_REG_OFST,
81102c88:	e0bfff17 	ldw	r2,-4(fp)
81102c8c:	10800017 	ldw	r2,0(r2)
81102c90:	e1bffe17 	ldw	r6,-8(fp)
81102c94:	01400284 	movi	r5,10
81102c98:	1009883a 	mov	r4,r2
81102c9c:	11032bc0 	call	811032bc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81102ca0:	e0bfff17 	ldw	r2,-4(fp)
81102ca4:	10800017 	ldw	r2,0(r2)
81102ca8:	014002c4 	movi	r5,11
81102cac:	1009883a 	mov	r4,r2
81102cb0:	11033100 	call	81103310 <uliDpktReadReg>
81102cb4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
81102cb8:	e0fffe17 	ldw	r3,-8(fp)
81102cbc:	00bfc004 	movi	r2,-256
81102cc0:	1884703a 	and	r2,r3,r2
81102cc4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
81102cc8:	e0bfff17 	ldw	r2,-4(fp)
81102ccc:	10800383 	ldbu	r2,14(r2)
81102cd0:	10803fcc 	andi	r2,r2,255
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
81102cd4:	e0fffe17 	ldw	r3,-8(fp)
81102cd8:	1884b03a 	or	r2,r3,r2
81102cdc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
81102ce0:	e0fffe17 	ldw	r3,-8(fp)
81102ce4:	00bffff4 	movhi	r2,65535
81102ce8:	10803fc4 	addi	r2,r2,255
81102cec:	1884703a 	and	r2,r3,r2
81102cf0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
81102cf4:	e0bfff17 	ldw	r2,-4(fp)
81102cf8:	108003c3 	ldbu	r2,15(r2)
81102cfc:	10803fcc 	andi	r2,r2,255
81102d00:	1004923a 	slli	r2,r2,8
81102d04:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
81102d08:	e0fffe17 	ldw	r3,-8(fp)
81102d0c:	1884b03a 	or	r2,r3,r2
81102d10:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_4_REG_OFST,
81102d14:	e0bfff17 	ldw	r2,-4(fp)
81102d18:	10800017 	ldw	r2,0(r2)
81102d1c:	e1bffe17 	ldw	r6,-8(fp)
81102d20:	014002c4 	movi	r5,11
81102d24:	1009883a 	mov	r4,r2
81102d28:	11032bc0 	call	811032bc <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81102d2c:	00800044 	movi	r2,1
81102d30:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81102d34:	e0bffd17 	ldw	r2,-12(fp)
}
81102d38:	e037883a 	mov	sp,fp
81102d3c:	dfc00117 	ldw	ra,4(sp)
81102d40:	df000017 	ldw	fp,0(sp)
81102d44:	dec00204 	addi	sp,sp,8
81102d48:	f800283a 	ret

81102d4c <bDpktGetPacketConfig>:

bool bDpktGetPacketConfig(TDpktChannel *pxDpktCh) {
81102d4c:	defffb04 	addi	sp,sp,-20
81102d50:	de00012e 	bgeu	sp,et,81102d58 <bDpktGetPacketConfig+0xc>
81102d54:	003b68fa 	trap	3
81102d58:	dfc00415 	stw	ra,16(sp)
81102d5c:	df000315 	stw	fp,12(sp)
81102d60:	df000304 	addi	fp,sp,12
81102d64:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81102d68:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81102d6c:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81102d70:	e0bfff17 	ldw	r2,-4(fp)
81102d74:	10003a26 	beq	r2,zero,81102e60 <bDpktGetPacketConfig+0x114>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81102d78:	e0bfff17 	ldw	r2,-4(fp)
81102d7c:	10800017 	ldw	r2,0(r2)
81102d80:	01400204 	movi	r5,8
81102d84:	1009883a 	mov	r4,r2
81102d88:	11033100 	call	81103310 <uliDpktReadReg>
81102d8c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
81102d90:	e0bffe17 	ldw	r2,-8(fp)
81102d94:	1007883a 	mov	r3,r2
81102d98:	e0bfff17 	ldw	r2,-4(fp)
81102d9c:	10c0010d 	sth	r3,4(r2)
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);
81102da0:	e0bffe17 	ldw	r2,-8(fp)
81102da4:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
81102da8:	1007883a 	mov	r3,r2
81102dac:	e0bfff17 	ldw	r2,-4(fp)
81102db0:	10c0018d 	sth	r3,6(r2)
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81102db4:	e0bfff17 	ldw	r2,-4(fp)
81102db8:	10800017 	ldw	r2,0(r2)
81102dbc:	01400244 	movi	r5,9
81102dc0:	1009883a 	mov	r4,r2
81102dc4:	11033100 	call	81103310 <uliDpktReadReg>
81102dc8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
81102dcc:	e0bffe17 	ldw	r2,-8(fp)
81102dd0:	1007883a 	mov	r3,r2
81102dd4:	e0bfff17 	ldw	r2,-4(fp)
81102dd8:	10c0020d 	sth	r3,8(r2)
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);
81102ddc:	e0bffe17 	ldw	r2,-8(fp)
81102de0:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
81102de4:	1007883a 	mov	r3,r2
81102de8:	e0bfff17 	ldw	r2,-4(fp)
81102dec:	10c0028d 	sth	r3,10(r2)
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81102df0:	e0bfff17 	ldw	r2,-4(fp)
81102df4:	10800017 	ldw	r2,0(r2)
81102df8:	01400284 	movi	r5,10
81102dfc:	1009883a 	mov	r4,r2
81102e00:	11033100 	call	81103310 <uliDpktReadReg>
81102e04:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiPacketLength = (alt_u16)(
81102e08:	e0bffe17 	ldw	r2,-8(fp)
81102e0c:	1007883a 	mov	r3,r2
81102e10:	e0bfff17 	ldw	r2,-4(fp)
81102e14:	10c0030d 	sth	r3,12(r2)
				(uliReg & COMM_DATA_PKT_LENGTH_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81102e18:	e0bfff17 	ldw	r2,-4(fp)
81102e1c:	10800017 	ldw	r2,0(r2)
81102e20:	014002c4 	movi	r5,11
81102e24:	1009883a 	mov	r4,r2
81102e28:	11033100 	call	81103310 <uliDpktReadReg>
81102e2c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
81102e30:	e0bffe17 	ldw	r2,-8(fp)
81102e34:	1007883a 	mov	r3,r2
81102e38:	e0bfff17 	ldw	r2,-4(fp)
81102e3c:	10c00385 	stb	r3,14(r2)
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
81102e40:	e0bffe17 	ldw	r2,-8(fp)
81102e44:	10bfc00c 	andi	r2,r2,65280
81102e48:	1004d23a 	srli	r2,r2,8
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
81102e4c:	1007883a 	mov	r3,r2
81102e50:	e0bfff17 	ldw	r2,-4(fp)
81102e54:	10c003c5 	stb	r3,15(r2)
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);

		bStatus = TRUE;
81102e58:	00800044 	movi	r2,1
81102e5c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81102e60:	e0bffd17 	ldw	r2,-12(fp)
}
81102e64:	e037883a 	mov	sp,fp
81102e68:	dfc00117 	ldw	ra,4(sp)
81102e6c:	df000017 	ldw	fp,0(sp)
81102e70:	dec00204 	addi	sp,sp,8
81102e74:	f800283a 	ret

81102e78 <bDpktGetPacketHeader>:

bool bDpktGetPacketHeader(TDpktChannel *pxDpktCh) {
81102e78:	defffb04 	addi	sp,sp,-20
81102e7c:	de00012e 	bgeu	sp,et,81102e84 <bDpktGetPacketHeader+0xc>
81102e80:	003b68fa 	trap	3
81102e84:	dfc00415 	stw	ra,16(sp)
81102e88:	df000315 	stw	fp,12(sp)
81102e8c:	df000304 	addi	fp,sp,12
81102e90:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81102e94:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81102e98:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81102e9c:	e0bfff17 	ldw	r2,-4(fp)
81102ea0:	10002026 	beq	r2,zero,81102f24 <bDpktGetPacketHeader+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81102ea4:	e0bfff17 	ldw	r2,-4(fp)
81102ea8:	10800017 	ldw	r2,0(r2)
81102eac:	01400304 	movi	r5,12
81102eb0:	1009883a 	mov	r4,r2
81102eb4:	11033100 	call	81103310 <uliDpktReadReg>
81102eb8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
81102ebc:	e0bffe17 	ldw	r2,-8(fp)
81102ec0:	1007883a 	mov	r3,r2
81102ec4:	e0bfff17 	ldw	r2,-4(fp)
81102ec8:	10c0040d 	sth	r3,16(r2)
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);
81102ecc:	e0bffe17 	ldw	r2,-8(fp)
81102ed0:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
81102ed4:	1007883a 	mov	r3,r2
81102ed8:	e0bfff17 	ldw	r2,-4(fp)
81102edc:	10c0048d 	sth	r3,18(r2)
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81102ee0:	e0bfff17 	ldw	r2,-4(fp)
81102ee4:	10800017 	ldw	r2,0(r2)
81102ee8:	01400344 	movi	r5,13
81102eec:	1009883a 	mov	r4,r2
81102ef0:	11033100 	call	81103310 <uliDpktReadReg>
81102ef4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
81102ef8:	e0bffe17 	ldw	r2,-8(fp)
81102efc:	1007883a 	mov	r3,r2
81102f00:	e0bfff17 	ldw	r2,-4(fp)
81102f04:	10c0050d 	sth	r3,20(r2)
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);
81102f08:	e0bffe17 	ldw	r2,-8(fp)
81102f0c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
81102f10:	1007883a 	mov	r3,r2
81102f14:	e0bfff17 	ldw	r2,-4(fp)
81102f18:	10c0058d 	sth	r3,22(r2)
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);

		bStatus = TRUE;
81102f1c:	00800044 	movi	r2,1
81102f20:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81102f24:	e0bffd17 	ldw	r2,-12(fp)
}
81102f28:	e037883a 	mov	sp,fp
81102f2c:	dfc00117 	ldw	ra,4(sp)
81102f30:	df000017 	ldw	fp,0(sp)
81102f34:	dec00204 	addi	sp,sp,8
81102f38:	f800283a 	ret

81102f3c <bDpktSetPixelDelay>:

bool bDpktSetPixelDelay(TDpktChannel *pxDpktCh) {
81102f3c:	defffb04 	addi	sp,sp,-20
81102f40:	de00012e 	bgeu	sp,et,81102f48 <bDpktSetPixelDelay+0xc>
81102f44:	003b68fa 	trap	3
81102f48:	dfc00415 	stw	ra,16(sp)
81102f4c:	df000315 	stw	fp,12(sp)
81102f50:	df000304 	addi	fp,sp,12
81102f54:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81102f58:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81102f5c:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81102f60:	e0bfff17 	ldw	r2,-4(fp)
81102f64:	10004126 	beq	r2,zero,8110306c <bDpktSetPixelDelay+0x130>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81102f68:	e0bfff17 	ldw	r2,-4(fp)
81102f6c:	10800017 	ldw	r2,0(r2)
81102f70:	01400384 	movi	r5,14
81102f74:	1009883a 	mov	r4,r2
81102f78:	11033100 	call	81103310 <uliDpktReadReg>
81102f7c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
81102f80:	e0bffe17 	ldw	r2,-8(fp)
81102f84:	10bfffec 	andhi	r2,r2,65535
81102f88:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));
81102f8c:	e0bfff17 	ldw	r2,-4(fp)
81102f90:	1080060b 	ldhu	r2,24(r2)
81102f94:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
81102f98:	e0fffe17 	ldw	r3,-8(fp)
81102f9c:	1884b03a 	or	r2,r3,r2
81102fa0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_1_REG_OFST,
81102fa4:	e0bfff17 	ldw	r2,-4(fp)
81102fa8:	10800017 	ldw	r2,0(r2)
81102fac:	e1bffe17 	ldw	r6,-8(fp)
81102fb0:	01400384 	movi	r5,14
81102fb4:	1009883a 	mov	r4,r2
81102fb8:	11032bc0 	call	811032bc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81102fbc:	e0bfff17 	ldw	r2,-4(fp)
81102fc0:	10800017 	ldw	r2,0(r2)
81102fc4:	014003c4 	movi	r5,15
81102fc8:	1009883a 	mov	r4,r2
81102fcc:	11033100 	call	81103310 <uliDpktReadReg>
81102fd0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
81102fd4:	e0bffe17 	ldw	r2,-8(fp)
81102fd8:	10bfffec 	andhi	r2,r2,65535
81102fdc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));
81102fe0:	e0bfff17 	ldw	r2,-4(fp)
81102fe4:	1080068b 	ldhu	r2,26(r2)
81102fe8:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
81102fec:	e0fffe17 	ldw	r3,-8(fp)
81102ff0:	1884b03a 	or	r2,r3,r2
81102ff4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_2_REG_OFST,
81102ff8:	e0bfff17 	ldw	r2,-4(fp)
81102ffc:	10800017 	ldw	r2,0(r2)
81103000:	e1bffe17 	ldw	r6,-8(fp)
81103004:	014003c4 	movi	r5,15
81103008:	1009883a 	mov	r4,r2
8110300c:	11032bc0 	call	811032bc <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81103010:	e0bfff17 	ldw	r2,-4(fp)
81103014:	10800017 	ldw	r2,0(r2)
81103018:	01400404 	movi	r5,16
8110301c:	1009883a 	mov	r4,r2
81103020:	11033100 	call	81103310 <uliDpktReadReg>
81103024:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
81103028:	e0bffe17 	ldw	r2,-8(fp)
8110302c:	10bfffec 	andhi	r2,r2,65535
81103030:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));
81103034:	e0bfff17 	ldw	r2,-4(fp)
81103038:	1080070b 	ldhu	r2,28(r2)
8110303c:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
81103040:	e0fffe17 	ldw	r3,-8(fp)
81103044:	1884b03a 	or	r2,r3,r2
81103048:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_3_REG_OFST,
8110304c:	e0bfff17 	ldw	r2,-4(fp)
81103050:	10800017 	ldw	r2,0(r2)
81103054:	e1bffe17 	ldw	r6,-8(fp)
81103058:	01400404 	movi	r5,16
8110305c:	1009883a 	mov	r4,r2
81103060:	11032bc0 	call	811032bc <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81103064:	00800044 	movi	r2,1
81103068:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110306c:	e0bffd17 	ldw	r2,-12(fp)
}
81103070:	e037883a 	mov	sp,fp
81103074:	dfc00117 	ldw	ra,4(sp)
81103078:	df000017 	ldw	fp,0(sp)
8110307c:	dec00204 	addi	sp,sp,8
81103080:	f800283a 	ret

81103084 <bDpktGetPixelDelay>:

bool bDpktGetPixelDelay(TDpktChannel *pxDpktCh) {
81103084:	defffb04 	addi	sp,sp,-20
81103088:	de00012e 	bgeu	sp,et,81103090 <bDpktGetPixelDelay+0xc>
8110308c:	003b68fa 	trap	3
81103090:	dfc00415 	stw	ra,16(sp)
81103094:	df000315 	stw	fp,12(sp)
81103098:	df000304 	addi	fp,sp,12
8110309c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811030a0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811030a4:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
811030a8:	e0bfff17 	ldw	r2,-4(fp)
811030ac:	10002026 	beq	r2,zero,81103130 <bDpktGetPixelDelay+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811030b0:	e0bfff17 	ldw	r2,-4(fp)
811030b4:	10800017 	ldw	r2,0(r2)
811030b8:	01400384 	movi	r5,14
811030bc:	1009883a 	mov	r4,r2
811030c0:	11033100 	call	81103310 <uliDpktReadReg>
811030c4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiLineDelay = (alt_u16)(
811030c8:	e0bffe17 	ldw	r2,-8(fp)
811030cc:	1007883a 	mov	r3,r2
811030d0:	e0bfff17 	ldw	r2,-4(fp)
811030d4:	10c0060d 	sth	r3,24(r2)
				(uliReg & COMM_DATA_PKT_LINE_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811030d8:	e0bfff17 	ldw	r2,-4(fp)
811030dc:	10800017 	ldw	r2,0(r2)
811030e0:	014003c4 	movi	r5,15
811030e4:	1009883a 	mov	r4,r2
811030e8:	11033100 	call	81103310 <uliDpktReadReg>
811030ec:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiColumnDelay = (alt_u16)(
811030f0:	e0bffe17 	ldw	r2,-8(fp)
811030f4:	1007883a 	mov	r3,r2
811030f8:	e0bfff17 	ldw	r2,-4(fp)
811030fc:	10c0068d 	sth	r3,26(r2)
				(uliReg & COMM_DATA_PKT_COLUMN_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81103100:	e0bfff17 	ldw	r2,-4(fp)
81103104:	10800017 	ldw	r2,0(r2)
81103108:	01400404 	movi	r5,16
8110310c:	1009883a 	mov	r4,r2
81103110:	11033100 	call	81103310 <uliDpktReadReg>
81103114:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiAdcDelay = (alt_u16)(
81103118:	e0bffe17 	ldw	r2,-8(fp)
8110311c:	1007883a 	mov	r3,r2
81103120:	e0bfff17 	ldw	r2,-4(fp)
81103124:	10c0070d 	sth	r3,28(r2)
				(uliReg & COMM_DATA_PKT_ADC_DLY_MSK) >> 0);

		bStatus = TRUE;
81103128:	00800044 	movi	r2,1
8110312c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81103130:	e0bffd17 	ldw	r2,-12(fp)
}
81103134:	e037883a 	mov	sp,fp
81103138:	dfc00117 	ldw	ra,4(sp)
8110313c:	df000017 	ldw	fp,0(sp)
81103140:	dec00204 	addi	sp,sp,8
81103144:	f800283a 	ret

81103148 <bDpktInitCh>:

bool bDpktInitCh(TDpktChannel *pxDpktCh, alt_u8 ucCommCh) {
81103148:	defffb04 	addi	sp,sp,-20
8110314c:	de00012e 	bgeu	sp,et,81103154 <bDpktInitCh+0xc>
81103150:	003b68fa 	trap	3
81103154:	dfc00415 	stw	ra,16(sp)
81103158:	df000315 	stw	fp,12(sp)
8110315c:	df000304 	addi	fp,sp,12
81103160:	e13ffe15 	stw	r4,-8(fp)
81103164:	2805883a 	mov	r2,r5
81103168:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110316c:	e03ffd15 	stw	zero,-12(fp)

	if (pxDpktCh != NULL) {
81103170:	e0bffe17 	ldw	r2,-8(fp)
81103174:	10004b26 	beq	r2,zero,811032a4 <bDpktInitCh+0x15c>
		bStatus = TRUE;
81103178:	00800044 	movi	r2,1
8110317c:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81103180:	e0bfff03 	ldbu	r2,-4(fp)
81103184:	10c00228 	cmpgeui	r3,r2,8
81103188:	1800361e 	bne	r3,zero,81103264 <bDpktInitCh+0x11c>
8110318c:	100690ba 	slli	r3,r2,2
81103190:	00a04434 	movhi	r2,33040
81103194:	108c6904 	addi	r2,r2,12708
81103198:	1885883a 	add	r2,r3,r2
8110319c:	10800017 	ldw	r2,0(r2)
811031a0:	1000683a 	jmp	r2
811031a4:	811031c4 	addi	r4,r16,16583
811031a8:	811031d8 	cmpnei	r4,r16,16583
811031ac:	811031ec 	andhi	r4,r16,16583
811031b0:	81103200 	call	88110320 <__reset+0x20f0320>
811031b4:	81103214 	ori	r4,r16,16584
811031b8:	81103228 	cmpgeui	r4,r16,16584
811031bc:	8110323c 	xorhi	r4,r16,16584
811031c0:	81103250 	cmplti	r4,r16,16585
		case eCommSpwCh1:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
811031c4:	e0fffe17 	ldw	r3,-8(fp)
811031c8:	00a04834 	movhi	r2,33056
811031cc:	108b0004 	addi	r2,r2,11264
811031d0:	18800015 	stw	r2,0(r3)
			break;
811031d4:	00002506 	br	8110326c <bDpktInitCh+0x124>
		case eCommSpwCh2:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
811031d8:	e0fffe17 	ldw	r3,-8(fp)
811031dc:	00a04834 	movhi	r2,33056
811031e0:	108a0004 	addi	r2,r2,10240
811031e4:	18800015 	stw	r2,0(r3)
			break;
811031e8:	00002006 	br	8110326c <bDpktInitCh+0x124>
		case eCommSpwCh3:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811031ec:	e0fffe17 	ldw	r3,-8(fp)
811031f0:	00a04834 	movhi	r2,33056
811031f4:	108b0004 	addi	r2,r2,11264
811031f8:	18800015 	stw	r2,0(r3)
			break;
811031fc:	00001b06 	br	8110326c <bDpktInitCh+0x124>
		case eCommSpwCh4:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81103200:	e0fffe17 	ldw	r3,-8(fp)
81103204:	00a04834 	movhi	r2,33056
81103208:	108a0004 	addi	r2,r2,10240
8110320c:	18800015 	stw	r2,0(r3)
			break;
81103210:	00001606 	br	8110326c <bDpktInitCh+0x124>
		case eCommSpwCh5:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81103214:	e0fffe17 	ldw	r3,-8(fp)
81103218:	00a04834 	movhi	r2,33056
8110321c:	108b0004 	addi	r2,r2,11264
81103220:	18800015 	stw	r2,0(r3)
			break;
81103224:	00001106 	br	8110326c <bDpktInitCh+0x124>
		case eCommSpwCh6:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81103228:	e0fffe17 	ldw	r3,-8(fp)
8110322c:	00a04834 	movhi	r2,33056
81103230:	108a0004 	addi	r2,r2,10240
81103234:	18800015 	stw	r2,0(r3)
			break;
81103238:	00000c06 	br	8110326c <bDpktInitCh+0x124>
		case eCommSpwCh7:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
8110323c:	e0fffe17 	ldw	r3,-8(fp)
81103240:	00a04834 	movhi	r2,33056
81103244:	108b0004 	addi	r2,r2,11264
81103248:	18800015 	stw	r2,0(r3)
			break;
8110324c:	00000706 	br	8110326c <bDpktInitCh+0x124>
		case eCommSpwCh8:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81103250:	e0fffe17 	ldw	r3,-8(fp)
81103254:	00a04834 	movhi	r2,33056
81103258:	108a0004 	addi	r2,r2,10240
8110325c:	18800015 	stw	r2,0(r3)
			break;
81103260:	00000206 	br	8110326c <bDpktInitCh+0x124>
		default:
			bStatus = FALSE;
81103264:	e03ffd15 	stw	zero,-12(fp)
			break;
81103268:	0001883a 	nop
		}

		if (bStatus) {
8110326c:	e0bffd17 	ldw	r2,-12(fp)
81103270:	10000c26 	beq	r2,zero,811032a4 <bDpktInitCh+0x15c>
			if (!bDpktGetPacketConfig(pxDpktCh)) {
81103274:	e13ffe17 	ldw	r4,-8(fp)
81103278:	1102d4c0 	call	81102d4c <bDpktGetPacketConfig>
8110327c:	1000011e 	bne	r2,zero,81103284 <bDpktInitCh+0x13c>
				bStatus = FALSE;
81103280:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPacketHeader(pxDpktCh)) {
81103284:	e13ffe17 	ldw	r4,-8(fp)
81103288:	1102e780 	call	81102e78 <bDpktGetPacketHeader>
8110328c:	1000011e 	bne	r2,zero,81103294 <bDpktInitCh+0x14c>
				bStatus = FALSE;
81103290:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPixelDelay(pxDpktCh)) {
81103294:	e13ffe17 	ldw	r4,-8(fp)
81103298:	11030840 	call	81103084 <bDpktGetPixelDelay>
8110329c:	1000011e 	bne	r2,zero,811032a4 <bDpktInitCh+0x15c>
				bStatus = FALSE;
811032a0:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
811032a4:	e0bffd17 	ldw	r2,-12(fp)
}
811032a8:	e037883a 	mov	sp,fp
811032ac:	dfc00117 	ldw	ra,4(sp)
811032b0:	df000017 	ldw	fp,0(sp)
811032b4:	dec00204 	addi	sp,sp,8
811032b8:	f800283a 	ret

811032bc <vDpktWriteReg>:
//! [public functions]

//! [private functions]
static void vDpktWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
811032bc:	defffc04 	addi	sp,sp,-16
811032c0:	de00012e 	bgeu	sp,et,811032c8 <vDpktWriteReg+0xc>
811032c4:	003b68fa 	trap	3
811032c8:	df000315 	stw	fp,12(sp)
811032cc:	df000304 	addi	fp,sp,12
811032d0:	e13ffd15 	stw	r4,-12(fp)
811032d4:	e17ffe15 	stw	r5,-8(fp)
811032d8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
811032dc:	e0bffe17 	ldw	r2,-8(fp)
811032e0:	1085883a 	add	r2,r2,r2
811032e4:	1085883a 	add	r2,r2,r2
811032e8:	1007883a 	mov	r3,r2
811032ec:	e0bffd17 	ldw	r2,-12(fp)
811032f0:	10c5883a 	add	r2,r2,r3
811032f4:	e0ffff17 	ldw	r3,-4(fp)
811032f8:	10c00015 	stw	r3,0(r2)
}
811032fc:	0001883a 	nop
81103300:	e037883a 	mov	sp,fp
81103304:	df000017 	ldw	fp,0(sp)
81103308:	dec00104 	addi	sp,sp,4
8110330c:	f800283a 	ret

81103310 <uliDpktReadReg>:

static alt_u32 uliDpktReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81103310:	defffc04 	addi	sp,sp,-16
81103314:	de00012e 	bgeu	sp,et,8110331c <uliDpktReadReg+0xc>
81103318:	003b68fa 	trap	3
8110331c:	df000315 	stw	fp,12(sp)
81103320:	df000304 	addi	fp,sp,12
81103324:	e13ffe15 	stw	r4,-8(fp)
81103328:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110332c:	e0bfff17 	ldw	r2,-4(fp)
81103330:	1085883a 	add	r2,r2,r2
81103334:	1085883a 	add	r2,r2,r2
81103338:	1007883a 	mov	r3,r2
8110333c:	e0bffe17 	ldw	r2,-8(fp)
81103340:	10c5883a 	add	r2,r2,r3
81103344:	10800017 	ldw	r2,0(r2)
81103348:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110334c:	e0bffd17 	ldw	r2,-12(fp)
}
81103350:	e037883a 	mov	sp,fp
81103354:	df000017 	ldw	fp,0(sp)
81103358:	dec00104 	addi	sp,sp,4
8110335c:	f800283a 	ret

81103360 <usiAdcPxDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * ADC Pixel Delay period in uliPeriodNs ns.
 */
alt_u16 usiAdcPxDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
81103360:	defffc04 	addi	sp,sp,-16
81103364:	de00012e 	bgeu	sp,et,8110336c <usiAdcPxDelayCalcPeriodNs+0xc>
81103368:	003b68fa 	trap	3
8110336c:	dfc00315 	stw	ra,12(sp)
81103370:	df000215 	stw	fp,8(sp)
81103374:	df000204 	addi	fp,sp,8
81103378:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 10 = Delay[ns] * 1e-1
	 * AdcPxDelay = Delay[ns] * 1e-1
	 */

	alt_u16 usiAdcPxDelay;
	usiAdcPxDelay = (alt_u16) ((float) uliPeriodNs * 1e-1);
8110337c:	e13fff17 	ldw	r4,-4(fp)
81103380:	11194fc0 	call	811194fc <__floatunsisf>
81103384:	1007883a 	mov	r3,r2
81103388:	1809883a 	mov	r4,r3
8110338c:	111a8580 	call	8111a858 <__extendsfdf2>
81103390:	1011883a 	mov	r8,r2
81103394:	1813883a 	mov	r9,r3
81103398:	01a666b4 	movhi	r6,39322
8110339c:	31a66684 	addi	r6,r6,-26214
811033a0:	01cfeeb4 	movhi	r7,16314
811033a4:	39e66644 	addi	r7,r7,-26215
811033a8:	4009883a 	mov	r4,r8
811033ac:	480b883a 	mov	r5,r9
811033b0:	11196d00 	call	811196d0 <__muldf3>
811033b4:	1009883a 	mov	r4,r2
811033b8:	180b883a 	mov	r5,r3
811033bc:	2005883a 	mov	r2,r4
811033c0:	2807883a 	mov	r3,r5
811033c4:	1009883a 	mov	r4,r2
811033c8:	180b883a 	mov	r5,r3
811033cc:	1118c340 	call	81118c34 <__fixunsdfsi>
811033d0:	e0bffe0d 	sth	r2,-8(fp)

	return usiAdcPxDelay;
811033d4:	e0bffe0b 	ldhu	r2,-8(fp)
}
811033d8:	e037883a 	mov	sp,fp
811033dc:	dfc00117 	ldw	ra,4(sp)
811033e0:	df000017 	ldw	fp,0(sp)
811033e4:	dec00204 	addi	sp,sp,8
811033e8:	f800283a 	ret

811033ec <usiLineTrDelayCalcPeriodNs>:

/*
 * Return the necessary delay value for a
 * Line Transfer Delay period in uliPeriodNs ns.
 */
alt_u16 usiLineTrDelayCalcPeriodNs(alt_u32 uliPeriodNs) {
811033ec:	defffc04 	addi	sp,sp,-16
811033f0:	de00012e 	bgeu	sp,et,811033f8 <usiLineTrDelayCalcPeriodNs+0xc>
811033f4:	003b68fa 	trap	3
811033f8:	dfc00315 	stw	ra,12(sp)
811033fc:	df000215 	stw	fp,8(sp)
81103400:	df000204 	addi	fp,sp,8
81103404:	e13fff15 	stw	r4,-4(fp)
	 * Delay[ns] / 100 = Delay[ns] * 1e-2
	 * LineTrDelay = Delay[ns] * 1e-2
	 */

	alt_u16 LineTrDelay;
	LineTrDelay = (alt_u16) ((float) uliPeriodNs * 1e-2);
81103408:	e13fff17 	ldw	r4,-4(fp)
8110340c:	11194fc0 	call	811194fc <__floatunsisf>
81103410:	1007883a 	mov	r3,r2
81103414:	1809883a 	mov	r4,r3
81103418:	111a8580 	call	8111a858 <__extendsfdf2>
8110341c:	1011883a 	mov	r8,r2
81103420:	1813883a 	mov	r9,r3
81103424:	0191ebb4 	movhi	r6,18350
81103428:	31851ec4 	addi	r6,r6,5243
8110342c:	01cfe134 	movhi	r7,16260
81103430:	39deb844 	addi	r7,r7,31457
81103434:	4009883a 	mov	r4,r8
81103438:	480b883a 	mov	r5,r9
8110343c:	11196d00 	call	811196d0 <__muldf3>
81103440:	1009883a 	mov	r4,r2
81103444:	180b883a 	mov	r5,r3
81103448:	2005883a 	mov	r2,r4
8110344c:	2807883a 	mov	r3,r5
81103450:	1009883a 	mov	r4,r2
81103454:	180b883a 	mov	r5,r3
81103458:	1118c340 	call	81118c34 <__fixunsdfsi>
8110345c:	e0bffe0d 	sth	r2,-8(fp)

	return LineTrDelay;
81103460:	e0bffe0b 	ldhu	r2,-8(fp)
}
81103464:	e037883a 	mov	sp,fp
81103468:	dfc00117 	ldw	ra,4(sp)
8110346c:	df000017 	ldw	fp,0(sp)
81103470:	dec00204 	addi	sp,sp,8
81103474:	f800283a 	ret

81103478 <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81103478:	defffb04 	addi	sp,sp,-20
8110347c:	de00012e 	bgeu	sp,et,81103484 <vFeebCh1HandleIrq+0xc>
81103480:	003b68fa 	trap	3
81103484:	dfc00415 	stw	ra,16(sp)
81103488:	df000315 	stw	fp,12(sp)
8110348c:	df000304 	addi	fp,sp,12
81103490:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81103494:	e0bfff17 	ldw	r2,-4(fp)
81103498:	e0bffd15 	stw	r2,-12(fp)
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	INT8U error_codel;
	tQMask uiCmdtoSend;

	vFeebCh1IrqFlagClrBufferEmpty();
8110349c:	11037880 	call	81103788 <vFeebCh1IrqFlagClrBufferEmpty>
	/* Make one requests for the Double buffer */
	/* Address of the NFEE is hard coded */



}
811034a0:	0001883a 	nop
811034a4:	e037883a 	mov	sp,fp
811034a8:	dfc00117 	ldw	ra,4(sp)
811034ac:	df000017 	ldw	fp,0(sp)
811034b0:	dec00204 	addi	sp,sp,8
811034b4:	f800283a 	ret

811034b8 <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
811034b8:	defffb04 	addi	sp,sp,-20
811034bc:	de00012e 	bgeu	sp,et,811034c4 <vFeebCh2HandleIrq+0xc>
811034c0:	003b68fa 	trap	3
811034c4:	dfc00415 	stw	ra,16(sp)
811034c8:	df000315 	stw	fp,12(sp)
811034cc:	df000304 	addi	fp,sp,12
811034d0:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811034d4:	e0bfff17 	ldw	r2,-4(fp)
811034d8:	e0bffd15 	stw	r2,-12(fp)

	INT8U error_codel;
	tQMask uiCmdtoSend;

	vFeebCh2IrqFlagClrBufferEmpty();
811034dc:	11037cc0 	call	811037cc <vFeebCh2IrqFlagClrBufferEmpty>
	if ( error_codel != OS_ERR_NONE ) {
		vFailRequestDMAFromIRQ( 1 );
	}
*/

}
811034e0:	0001883a 	nop
811034e4:	e037883a 	mov	sp,fp
811034e8:	dfc00117 	ldw	ra,4(sp)
811034ec:	df000017 	ldw	fp,0(sp)
811034f0:	dec00204 	addi	sp,sp,8
811034f4:	f800283a 	ret

811034f8 <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
811034f8:	defffa04 	addi	sp,sp,-24
811034fc:	de00012e 	bgeu	sp,et,81103504 <vFeebCh3HandleIrq+0xc>
81103500:	003b68fa 	trap	3
81103504:	dfc00515 	stw	ra,20(sp)
81103508:	df000415 	stw	fp,16(sp)
8110350c:	df000404 	addi	fp,sp,16
81103510:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81103514:	e0bfff17 	ldw	r2,-4(fp)
81103518:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110351c:	00800404 	movi	r2,16
81103520:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81103524:	00bfe004 	movi	r2,-128
81103528:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
8110352c:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 2;
81103530:	00800084 	movi	r2,2
81103534:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81103538:	d0a05d17 	ldw	r2,-32396(gp)
8110353c:	e0fffe17 	ldw	r3,-8(fp)
81103540:	180b883a 	mov	r5,r3
81103544:	1009883a 	mov	r4,r2
81103548:	1136a880 	call	81136a88 <OSQPost>
8110354c:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81103550:	e0bffd03 	ldbu	r2,-12(fp)
81103554:	10000226 	beq	r2,zero,81103560 <vFeebCh3HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 2 );
81103558:	01000084 	movi	r4,2
8110355c:	11172040 	call	81117204 <vFailRequestDMAFromIRQ>
	}

	vFeebCh3IrqFlagClrBufferEmpty();
81103560:	11038100 	call	81103810 <vFeebCh3IrqFlagClrBufferEmpty>
}
81103564:	0001883a 	nop
81103568:	e037883a 	mov	sp,fp
8110356c:	dfc00117 	ldw	ra,4(sp)
81103570:	df000017 	ldw	fp,0(sp)
81103574:	dec00204 	addi	sp,sp,8
81103578:	f800283a 	ret

8110357c <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
8110357c:	defffa04 	addi	sp,sp,-24
81103580:	de00012e 	bgeu	sp,et,81103588 <vFeebCh4HandleIrq+0xc>
81103584:	003b68fa 	trap	3
81103588:	dfc00515 	stw	ra,20(sp)
8110358c:	df000415 	stw	fp,16(sp)
81103590:	df000404 	addi	fp,sp,16
81103594:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81103598:	e0bfff17 	ldw	r2,-4(fp)
8110359c:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811035a0:	00800404 	movi	r2,16
811035a4:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811035a8:	00bfe004 	movi	r2,-128
811035ac:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811035b0:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 3;
811035b4:	008000c4 	movi	r2,3
811035b8:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811035bc:	d0a05d17 	ldw	r2,-32396(gp)
811035c0:	e0fffe17 	ldw	r3,-8(fp)
811035c4:	180b883a 	mov	r5,r3
811035c8:	1009883a 	mov	r4,r2
811035cc:	1136a880 	call	81136a88 <OSQPost>
811035d0:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811035d4:	e0bffd03 	ldbu	r2,-12(fp)
811035d8:	10000226 	beq	r2,zero,811035e4 <vFeebCh4HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 3 );
811035dc:	010000c4 	movi	r4,3
811035e0:	11172040 	call	81117204 <vFailRequestDMAFromIRQ>
	}

	vFeebCh4IrqFlagClrBufferEmpty();
811035e4:	11038540 	call	81103854 <vFeebCh4IrqFlagClrBufferEmpty>
}
811035e8:	0001883a 	nop
811035ec:	e037883a 	mov	sp,fp
811035f0:	dfc00117 	ldw	ra,4(sp)
811035f4:	df000017 	ldw	fp,0(sp)
811035f8:	dec00204 	addi	sp,sp,8
811035fc:	f800283a 	ret

81103600 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
81103600:	defffa04 	addi	sp,sp,-24
81103604:	de00012e 	bgeu	sp,et,8110360c <vFeebCh5HandleIrq+0xc>
81103608:	003b68fa 	trap	3
8110360c:	dfc00515 	stw	ra,20(sp)
81103610:	df000415 	stw	fp,16(sp)
81103614:	df000404 	addi	fp,sp,16
81103618:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110361c:	e0bfff17 	ldw	r2,-4(fp)
81103620:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81103624:	00800404 	movi	r2,16
81103628:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
8110362c:	00bfe004 	movi	r2,-128
81103630:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81103634:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 4;
81103638:	00800104 	movi	r2,4
8110363c:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81103640:	d0a05d17 	ldw	r2,-32396(gp)
81103644:	e0fffe17 	ldw	r3,-8(fp)
81103648:	180b883a 	mov	r5,r3
8110364c:	1009883a 	mov	r4,r2
81103650:	1136a880 	call	81136a88 <OSQPost>
81103654:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81103658:	e0bffd03 	ldbu	r2,-12(fp)
8110365c:	10000226 	beq	r2,zero,81103668 <vFeebCh5HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 4 );
81103660:	01000104 	movi	r4,4
81103664:	11172040 	call	81117204 <vFailRequestDMAFromIRQ>
	}

	vFeebCh5IrqFlagClrBufferEmpty();
81103668:	11038980 	call	81103898 <vFeebCh5IrqFlagClrBufferEmpty>
}
8110366c:	0001883a 	nop
81103670:	e037883a 	mov	sp,fp
81103674:	dfc00117 	ldw	ra,4(sp)
81103678:	df000017 	ldw	fp,0(sp)
8110367c:	dec00204 	addi	sp,sp,8
81103680:	f800283a 	ret

81103684 <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
81103684:	defffa04 	addi	sp,sp,-24
81103688:	de00012e 	bgeu	sp,et,81103690 <vFeebCh6HandleIrq+0xc>
8110368c:	003b68fa 	trap	3
81103690:	dfc00515 	stw	ra,20(sp)
81103694:	df000415 	stw	fp,16(sp)
81103698:	df000404 	addi	fp,sp,16
8110369c:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811036a0:	e0bfff17 	ldw	r2,-4(fp)
811036a4:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811036a8:	00800404 	movi	r2,16
811036ac:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811036b0:	00bfe004 	movi	r2,-128
811036b4:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811036b8:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 5;
811036bc:	00800144 	movi	r2,5
811036c0:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811036c4:	d0a05d17 	ldw	r2,-32396(gp)
811036c8:	e0fffe17 	ldw	r3,-8(fp)
811036cc:	180b883a 	mov	r5,r3
811036d0:	1009883a 	mov	r4,r2
811036d4:	1136a880 	call	81136a88 <OSQPost>
811036d8:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811036dc:	e0bffd03 	ldbu	r2,-12(fp)
811036e0:	10000226 	beq	r2,zero,811036ec <vFeebCh6HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 5 );
811036e4:	01000144 	movi	r4,5
811036e8:	11172040 	call	81117204 <vFailRequestDMAFromIRQ>
	}


	vFeebCh6IrqFlagClrBufferEmpty();
811036ec:	11038dc0 	call	811038dc <vFeebCh6IrqFlagClrBufferEmpty>
}
811036f0:	0001883a 	nop
811036f4:	e037883a 	mov	sp,fp
811036f8:	dfc00117 	ldw	ra,4(sp)
811036fc:	df000017 	ldw	fp,0(sp)
81103700:	dec00204 	addi	sp,sp,8
81103704:	f800283a 	ret

81103708 <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
81103708:	defffc04 	addi	sp,sp,-16
8110370c:	de00012e 	bgeu	sp,et,81103714 <vFeebCh7HandleIrq+0xc>
81103710:	003b68fa 	trap	3
81103714:	dfc00315 	stw	ra,12(sp)
81103718:	df000215 	stw	fp,8(sp)
8110371c:	df000204 	addi	fp,sp,8
81103720:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81103724:	e0bfff17 	ldw	r2,-4(fp)
81103728:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh7IrqFlagClrBufferEmpty();
8110372c:	11039200 	call	81103920 <vFeebCh7IrqFlagClrBufferEmpty>
}
81103730:	0001883a 	nop
81103734:	e037883a 	mov	sp,fp
81103738:	dfc00117 	ldw	ra,4(sp)
8110373c:	df000017 	ldw	fp,0(sp)
81103740:	dec00204 	addi	sp,sp,8
81103744:	f800283a 	ret

81103748 <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
81103748:	defffc04 	addi	sp,sp,-16
8110374c:	de00012e 	bgeu	sp,et,81103754 <vFeebCh8HandleIrq+0xc>
81103750:	003b68fa 	trap	3
81103754:	dfc00315 	stw	ra,12(sp)
81103758:	df000215 	stw	fp,8(sp)
8110375c:	df000204 	addi	fp,sp,8
81103760:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81103764:	e0bfff17 	ldw	r2,-4(fp)
81103768:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh8IrqFlagClrBufferEmpty();
8110376c:	11039640 	call	81103964 <vFeebCh8IrqFlagClrBufferEmpty>
}
81103770:	0001883a 	nop
81103774:	e037883a 	mov	sp,fp
81103778:	dfc00117 	ldw	ra,4(sp)
8110377c:	df000017 	ldw	fp,0(sp)
81103780:	dec00204 	addi	sp,sp,8
81103784:	f800283a 	ret

81103788 <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
81103788:	defffe04 	addi	sp,sp,-8
8110378c:	de00012e 	bgeu	sp,et,81103794 <vFeebCh1IrqFlagClrBufferEmpty+0xc>
81103790:	003b68fa 	trap	3
81103794:	dfc00115 	stw	ra,4(sp)
81103798:	df000015 	stw	fp,0(sp)
8110379c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811037a0:	01804004 	movi	r6,256
811037a4:	014004c4 	movi	r5,19
811037a8:	01204834 	movhi	r4,33056
811037ac:	210b0004 	addi	r4,r4,11264
811037b0:	1104f540 	call	81104f54 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811037b4:	0001883a 	nop
811037b8:	e037883a 	mov	sp,fp
811037bc:	dfc00117 	ldw	ra,4(sp)
811037c0:	df000017 	ldw	fp,0(sp)
811037c4:	dec00204 	addi	sp,sp,8
811037c8:	f800283a 	ret

811037cc <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
811037cc:	defffe04 	addi	sp,sp,-8
811037d0:	de00012e 	bgeu	sp,et,811037d8 <vFeebCh2IrqFlagClrBufferEmpty+0xc>
811037d4:	003b68fa 	trap	3
811037d8:	dfc00115 	stw	ra,4(sp)
811037dc:	df000015 	stw	fp,0(sp)
811037e0:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811037e4:	01804004 	movi	r6,256
811037e8:	014004c4 	movi	r5,19
811037ec:	01204834 	movhi	r4,33056
811037f0:	210a0004 	addi	r4,r4,10240
811037f4:	1104f540 	call	81104f54 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811037f8:	0001883a 	nop
811037fc:	e037883a 	mov	sp,fp
81103800:	dfc00117 	ldw	ra,4(sp)
81103804:	df000017 	ldw	fp,0(sp)
81103808:	dec00204 	addi	sp,sp,8
8110380c:	f800283a 	ret

81103810 <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
81103810:	defffe04 	addi	sp,sp,-8
81103814:	de00012e 	bgeu	sp,et,8110381c <vFeebCh3IrqFlagClrBufferEmpty+0xc>
81103818:	003b68fa 	trap	3
8110381c:	dfc00115 	stw	ra,4(sp)
81103820:	df000015 	stw	fp,0(sp)
81103824:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81103828:	01804004 	movi	r6,256
8110382c:	014004c4 	movi	r5,19
81103830:	01204834 	movhi	r4,33056
81103834:	210b0004 	addi	r4,r4,11264
81103838:	1104f540 	call	81104f54 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110383c:	0001883a 	nop
81103840:	e037883a 	mov	sp,fp
81103844:	dfc00117 	ldw	ra,4(sp)
81103848:	df000017 	ldw	fp,0(sp)
8110384c:	dec00204 	addi	sp,sp,8
81103850:	f800283a 	ret

81103854 <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
81103854:	defffe04 	addi	sp,sp,-8
81103858:	de00012e 	bgeu	sp,et,81103860 <vFeebCh4IrqFlagClrBufferEmpty+0xc>
8110385c:	003b68fa 	trap	3
81103860:	dfc00115 	stw	ra,4(sp)
81103864:	df000015 	stw	fp,0(sp)
81103868:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
8110386c:	01804004 	movi	r6,256
81103870:	014004c4 	movi	r5,19
81103874:	01204834 	movhi	r4,33056
81103878:	210a0004 	addi	r4,r4,10240
8110387c:	1104f540 	call	81104f54 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81103880:	0001883a 	nop
81103884:	e037883a 	mov	sp,fp
81103888:	dfc00117 	ldw	ra,4(sp)
8110388c:	df000017 	ldw	fp,0(sp)
81103890:	dec00204 	addi	sp,sp,8
81103894:	f800283a 	ret

81103898 <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
81103898:	defffe04 	addi	sp,sp,-8
8110389c:	de00012e 	bgeu	sp,et,811038a4 <vFeebCh5IrqFlagClrBufferEmpty+0xc>
811038a0:	003b68fa 	trap	3
811038a4:	dfc00115 	stw	ra,4(sp)
811038a8:	df000015 	stw	fp,0(sp)
811038ac:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811038b0:	01804004 	movi	r6,256
811038b4:	014004c4 	movi	r5,19
811038b8:	01204834 	movhi	r4,33056
811038bc:	210b0004 	addi	r4,r4,11264
811038c0:	1104f540 	call	81104f54 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811038c4:	0001883a 	nop
811038c8:	e037883a 	mov	sp,fp
811038cc:	dfc00117 	ldw	ra,4(sp)
811038d0:	df000017 	ldw	fp,0(sp)
811038d4:	dec00204 	addi	sp,sp,8
811038d8:	f800283a 	ret

811038dc <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
811038dc:	defffe04 	addi	sp,sp,-8
811038e0:	de00012e 	bgeu	sp,et,811038e8 <vFeebCh6IrqFlagClrBufferEmpty+0xc>
811038e4:	003b68fa 	trap	3
811038e8:	dfc00115 	stw	ra,4(sp)
811038ec:	df000015 	stw	fp,0(sp)
811038f0:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811038f4:	01804004 	movi	r6,256
811038f8:	014004c4 	movi	r5,19
811038fc:	01204834 	movhi	r4,33056
81103900:	210a0004 	addi	r4,r4,10240
81103904:	1104f540 	call	81104f54 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81103908:	0001883a 	nop
8110390c:	e037883a 	mov	sp,fp
81103910:	dfc00117 	ldw	ra,4(sp)
81103914:	df000017 	ldw	fp,0(sp)
81103918:	dec00204 	addi	sp,sp,8
8110391c:	f800283a 	ret

81103920 <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
81103920:	defffe04 	addi	sp,sp,-8
81103924:	de00012e 	bgeu	sp,et,8110392c <vFeebCh7IrqFlagClrBufferEmpty+0xc>
81103928:	003b68fa 	trap	3
8110392c:	dfc00115 	stw	ra,4(sp)
81103930:	df000015 	stw	fp,0(sp)
81103934:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81103938:	01804004 	movi	r6,256
8110393c:	014004c4 	movi	r5,19
81103940:	01204834 	movhi	r4,33056
81103944:	210b0004 	addi	r4,r4,11264
81103948:	1104f540 	call	81104f54 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110394c:	0001883a 	nop
81103950:	e037883a 	mov	sp,fp
81103954:	dfc00117 	ldw	ra,4(sp)
81103958:	df000017 	ldw	fp,0(sp)
8110395c:	dec00204 	addi	sp,sp,8
81103960:	f800283a 	ret

81103964 <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
81103964:	defffe04 	addi	sp,sp,-8
81103968:	de00012e 	bgeu	sp,et,81103970 <vFeebCh8IrqFlagClrBufferEmpty+0xc>
8110396c:	003b68fa 	trap	3
81103970:	dfc00115 	stw	ra,4(sp)
81103974:	df000015 	stw	fp,0(sp)
81103978:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
8110397c:	01804004 	movi	r6,256
81103980:	014004c4 	movi	r5,19
81103984:	01204834 	movhi	r4,33056
81103988:	210a0004 	addi	r4,r4,10240
8110398c:	1104f540 	call	81104f54 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81103990:	0001883a 	nop
81103994:	e037883a 	mov	sp,fp
81103998:	dfc00117 	ldw	ra,4(sp)
8110399c:	df000017 	ldw	fp,0(sp)
811039a0:	dec00204 	addi	sp,sp,8
811039a4:	f800283a 	ret

811039a8 <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
811039a8:	defffd04 	addi	sp,sp,-12
811039ac:	de00012e 	bgeu	sp,et,811039b4 <bFeebCh1IrqFlagBufferEmpty+0xc>
811039b0:	003b68fa 	trap	3
811039b4:	dfc00215 	stw	ra,8(sp)
811039b8:	df000115 	stw	fp,4(sp)
811039bc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811039c0:	01400484 	movi	r5,18
811039c4:	01204834 	movhi	r4,33056
811039c8:	210b0004 	addi	r4,r4,11264
811039cc:	1104fa80 	call	81104fa8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811039d0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811039d4:	10000326 	beq	r2,zero,811039e4 <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811039d8:	00800044 	movi	r2,1
811039dc:	e0bfff15 	stw	r2,-4(fp)
811039e0:	00000106 	br	811039e8 <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811039e4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811039e8:	e0bfff17 	ldw	r2,-4(fp)
}
811039ec:	e037883a 	mov	sp,fp
811039f0:	dfc00117 	ldw	ra,4(sp)
811039f4:	df000017 	ldw	fp,0(sp)
811039f8:	dec00204 	addi	sp,sp,8
811039fc:	f800283a 	ret

81103a00 <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
81103a00:	defffd04 	addi	sp,sp,-12
81103a04:	de00012e 	bgeu	sp,et,81103a0c <bFeebCh2IrqFlagBufferEmpty+0xc>
81103a08:	003b68fa 	trap	3
81103a0c:	dfc00215 	stw	ra,8(sp)
81103a10:	df000115 	stw	fp,4(sp)
81103a14:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81103a18:	01400484 	movi	r5,18
81103a1c:	01204834 	movhi	r4,33056
81103a20:	210a0004 	addi	r4,r4,10240
81103a24:	1104fa80 	call	81104fa8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81103a28:	1080400c 	andi	r2,r2,256
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81103a2c:	10000326 	beq	r2,zero,81103a3c <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81103a30:	00800044 	movi	r2,1
81103a34:	e0bfff15 	stw	r2,-4(fp)
81103a38:	00000106 	br	81103a40 <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81103a3c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81103a40:	e0bfff17 	ldw	r2,-4(fp)
}
81103a44:	e037883a 	mov	sp,fp
81103a48:	dfc00117 	ldw	ra,4(sp)
81103a4c:	df000017 	ldw	fp,0(sp)
81103a50:	dec00204 	addi	sp,sp,8
81103a54:	f800283a 	ret

81103a58 <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
81103a58:	defffd04 	addi	sp,sp,-12
81103a5c:	de00012e 	bgeu	sp,et,81103a64 <bFeebCh3IrqFlagBufferEmpty+0xc>
81103a60:	003b68fa 	trap	3
81103a64:	dfc00215 	stw	ra,8(sp)
81103a68:	df000115 	stw	fp,4(sp)
81103a6c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81103a70:	01400484 	movi	r5,18
81103a74:	01204834 	movhi	r4,33056
81103a78:	210b0004 	addi	r4,r4,11264
81103a7c:	1104fa80 	call	81104fa8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81103a80:	1080400c 	andi	r2,r2,256
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81103a84:	10000326 	beq	r2,zero,81103a94 <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81103a88:	00800044 	movi	r2,1
81103a8c:	e0bfff15 	stw	r2,-4(fp)
81103a90:	00000106 	br	81103a98 <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81103a94:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81103a98:	e0bfff17 	ldw	r2,-4(fp)
}
81103a9c:	e037883a 	mov	sp,fp
81103aa0:	dfc00117 	ldw	ra,4(sp)
81103aa4:	df000017 	ldw	fp,0(sp)
81103aa8:	dec00204 	addi	sp,sp,8
81103aac:	f800283a 	ret

81103ab0 <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
81103ab0:	defffd04 	addi	sp,sp,-12
81103ab4:	de00012e 	bgeu	sp,et,81103abc <bFeebCh4IrqFlagBufferEmpty+0xc>
81103ab8:	003b68fa 	trap	3
81103abc:	dfc00215 	stw	ra,8(sp)
81103ac0:	df000115 	stw	fp,4(sp)
81103ac4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81103ac8:	01400484 	movi	r5,18
81103acc:	01204834 	movhi	r4,33056
81103ad0:	210a0004 	addi	r4,r4,10240
81103ad4:	1104fa80 	call	81104fa8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81103ad8:	1080400c 	andi	r2,r2,256
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81103adc:	10000326 	beq	r2,zero,81103aec <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81103ae0:	00800044 	movi	r2,1
81103ae4:	e0bfff15 	stw	r2,-4(fp)
81103ae8:	00000106 	br	81103af0 <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81103aec:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81103af0:	e0bfff17 	ldw	r2,-4(fp)
}
81103af4:	e037883a 	mov	sp,fp
81103af8:	dfc00117 	ldw	ra,4(sp)
81103afc:	df000017 	ldw	fp,0(sp)
81103b00:	dec00204 	addi	sp,sp,8
81103b04:	f800283a 	ret

81103b08 <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
81103b08:	defffd04 	addi	sp,sp,-12
81103b0c:	de00012e 	bgeu	sp,et,81103b14 <bFeebCh5IrqFlagBufferEmpty+0xc>
81103b10:	003b68fa 	trap	3
81103b14:	dfc00215 	stw	ra,8(sp)
81103b18:	df000115 	stw	fp,4(sp)
81103b1c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81103b20:	01400484 	movi	r5,18
81103b24:	01204834 	movhi	r4,33056
81103b28:	210b0004 	addi	r4,r4,11264
81103b2c:	1104fa80 	call	81104fa8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81103b30:	1080400c 	andi	r2,r2,256
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81103b34:	10000326 	beq	r2,zero,81103b44 <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81103b38:	00800044 	movi	r2,1
81103b3c:	e0bfff15 	stw	r2,-4(fp)
81103b40:	00000106 	br	81103b48 <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81103b44:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81103b48:	e0bfff17 	ldw	r2,-4(fp)
}
81103b4c:	e037883a 	mov	sp,fp
81103b50:	dfc00117 	ldw	ra,4(sp)
81103b54:	df000017 	ldw	fp,0(sp)
81103b58:	dec00204 	addi	sp,sp,8
81103b5c:	f800283a 	ret

81103b60 <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
81103b60:	defffd04 	addi	sp,sp,-12
81103b64:	de00012e 	bgeu	sp,et,81103b6c <bFeebCh6IrqFlagBufferEmpty+0xc>
81103b68:	003b68fa 	trap	3
81103b6c:	dfc00215 	stw	ra,8(sp)
81103b70:	df000115 	stw	fp,4(sp)
81103b74:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81103b78:	01400484 	movi	r5,18
81103b7c:	01204834 	movhi	r4,33056
81103b80:	210a0004 	addi	r4,r4,10240
81103b84:	1104fa80 	call	81104fa8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81103b88:	1080400c 	andi	r2,r2,256
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81103b8c:	10000326 	beq	r2,zero,81103b9c <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81103b90:	00800044 	movi	r2,1
81103b94:	e0bfff15 	stw	r2,-4(fp)
81103b98:	00000106 	br	81103ba0 <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81103b9c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81103ba0:	e0bfff17 	ldw	r2,-4(fp)
}
81103ba4:	e037883a 	mov	sp,fp
81103ba8:	dfc00117 	ldw	ra,4(sp)
81103bac:	df000017 	ldw	fp,0(sp)
81103bb0:	dec00204 	addi	sp,sp,8
81103bb4:	f800283a 	ret

81103bb8 <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
81103bb8:	defffd04 	addi	sp,sp,-12
81103bbc:	de00012e 	bgeu	sp,et,81103bc4 <bFeebCh7IrqFlagBufferEmpty+0xc>
81103bc0:	003b68fa 	trap	3
81103bc4:	dfc00215 	stw	ra,8(sp)
81103bc8:	df000115 	stw	fp,4(sp)
81103bcc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81103bd0:	01400484 	movi	r5,18
81103bd4:	01204834 	movhi	r4,33056
81103bd8:	210b0004 	addi	r4,r4,11264
81103bdc:	1104fa80 	call	81104fa8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81103be0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81103be4:	10000326 	beq	r2,zero,81103bf4 <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81103be8:	00800044 	movi	r2,1
81103bec:	e0bfff15 	stw	r2,-4(fp)
81103bf0:	00000106 	br	81103bf8 <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81103bf4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81103bf8:	e0bfff17 	ldw	r2,-4(fp)
}
81103bfc:	e037883a 	mov	sp,fp
81103c00:	dfc00117 	ldw	ra,4(sp)
81103c04:	df000017 	ldw	fp,0(sp)
81103c08:	dec00204 	addi	sp,sp,8
81103c0c:	f800283a 	ret

81103c10 <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
81103c10:	defffd04 	addi	sp,sp,-12
81103c14:	de00012e 	bgeu	sp,et,81103c1c <bFeebCh8IrqFlagBufferEmpty+0xc>
81103c18:	003b68fa 	trap	3
81103c1c:	dfc00215 	stw	ra,8(sp)
81103c20:	df000115 	stw	fp,4(sp)
81103c24:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81103c28:	01400484 	movi	r5,18
81103c2c:	01204834 	movhi	r4,33056
81103c30:	210a0004 	addi	r4,r4,10240
81103c34:	1104fa80 	call	81104fa8 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81103c38:	1080400c 	andi	r2,r2,256
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81103c3c:	10000326 	beq	r2,zero,81103c4c <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81103c40:	00800044 	movi	r2,1
81103c44:	e0bfff15 	stw	r2,-4(fp)
81103c48:	00000106 	br	81103c50 <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81103c4c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81103c50:	e0bfff17 	ldw	r2,-4(fp)
}
81103c54:	e037883a 	mov	sp,fp
81103c58:	dfc00117 	ldw	ra,4(sp)
81103c5c:	df000017 	ldw	fp,0(sp)
81103c60:	dec00204 	addi	sp,sp,8
81103c64:	f800283a 	ret

81103c68 <bFeebCh1SetBufferSize>:

bool bFeebCh1SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81103c68:	defffa04 	addi	sp,sp,-24
81103c6c:	de00012e 	bgeu	sp,et,81103c74 <bFeebCh1SetBufferSize+0xc>
81103c70:	003b68fa 	trap	3
81103c74:	dfc00515 	stw	ra,20(sp)
81103c78:	df000415 	stw	fp,16(sp)
81103c7c:	df000404 	addi	fp,sp,16
81103c80:	2007883a 	mov	r3,r4
81103c84:	2805883a 	mov	r2,r5
81103c88:	e0fffe05 	stb	r3,-8(fp)
81103c8c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81103c90:	00800044 	movi	r2,1
81103c94:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81103c98:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81103c9c:	e0bffe03 	ldbu	r2,-8(fp)
81103ca0:	10001f26 	beq	r2,zero,81103d20 <bFeebCh1SetBufferSize+0xb8>
81103ca4:	e0bffe03 	ldbu	r2,-8(fp)
81103ca8:	10800468 	cmpgeui	r2,r2,17
81103cac:	10001c1e 	bne	r2,zero,81103d20 <bFeebCh1SetBufferSize+0xb8>
		switch (ucBufferSide) {
81103cb0:	e0bfff03 	ldbu	r2,-4(fp)
81103cb4:	10000326 	beq	r2,zero,81103cc4 <bFeebCh1SetBufferSize+0x5c>
81103cb8:	10800060 	cmpeqi	r2,r2,1
81103cbc:	10000b1e 	bne	r2,zero,81103cec <bFeebCh1SetBufferSize+0x84>
81103cc0:	00001406 	br	81103d14 <bFeebCh1SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81103cc4:	e0bffe03 	ldbu	r2,-8(fp)
81103cc8:	10bfffc4 	addi	r2,r2,-1
81103ccc:	108003cc 	andi	r2,r2,15
81103cd0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81103cd4:	e1bffd17 	ldw	r6,-12(fp)
81103cd8:	01400544 	movi	r5,21
81103cdc:	01204834 	movhi	r4,33056
81103ce0:	210b0004 	addi	r4,r4,11264
81103ce4:	1104f540 	call	81104f54 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81103ce8:	00000c06 	br	81103d1c <bFeebCh1SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81103cec:	e0bffe03 	ldbu	r2,-8(fp)
81103cf0:	10bfffc4 	addi	r2,r2,-1
81103cf4:	108003cc 	andi	r2,r2,15
81103cf8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81103cfc:	e1bffd17 	ldw	r6,-12(fp)
81103d00:	01400504 	movi	r5,20
81103d04:	01204834 	movhi	r4,33056
81103d08:	210b0004 	addi	r4,r4,11264
81103d0c:	1104f540 	call	81104f54 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81103d10:	00000206 	br	81103d1c <bFeebCh1SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81103d14:	e03ffc15 	stw	zero,-16(fp)
			break;
81103d18:	0001883a 	nop
		}
	} else {
81103d1c:	00000106 	br	81103d24 <bFeebCh1SetBufferSize+0xbc>
		bStatus = FALSE;
81103d20:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81103d24:	e0bffc17 	ldw	r2,-16(fp)
}
81103d28:	e037883a 	mov	sp,fp
81103d2c:	dfc00117 	ldw	ra,4(sp)
81103d30:	df000017 	ldw	fp,0(sp)
81103d34:	dec00204 	addi	sp,sp,8
81103d38:	f800283a 	ret

81103d3c <bFeebCh2SetBufferSize>:

bool bFeebCh2SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81103d3c:	defffa04 	addi	sp,sp,-24
81103d40:	de00012e 	bgeu	sp,et,81103d48 <bFeebCh2SetBufferSize+0xc>
81103d44:	003b68fa 	trap	3
81103d48:	dfc00515 	stw	ra,20(sp)
81103d4c:	df000415 	stw	fp,16(sp)
81103d50:	df000404 	addi	fp,sp,16
81103d54:	2007883a 	mov	r3,r4
81103d58:	2805883a 	mov	r2,r5
81103d5c:	e0fffe05 	stb	r3,-8(fp)
81103d60:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81103d64:	00800044 	movi	r2,1
81103d68:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81103d6c:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81103d70:	e0bffe03 	ldbu	r2,-8(fp)
81103d74:	10001f26 	beq	r2,zero,81103df4 <bFeebCh2SetBufferSize+0xb8>
81103d78:	e0bffe03 	ldbu	r2,-8(fp)
81103d7c:	10800468 	cmpgeui	r2,r2,17
81103d80:	10001c1e 	bne	r2,zero,81103df4 <bFeebCh2SetBufferSize+0xb8>
		switch (ucBufferSide) {
81103d84:	e0bfff03 	ldbu	r2,-4(fp)
81103d88:	10000326 	beq	r2,zero,81103d98 <bFeebCh2SetBufferSize+0x5c>
81103d8c:	10800060 	cmpeqi	r2,r2,1
81103d90:	10000b1e 	bne	r2,zero,81103dc0 <bFeebCh2SetBufferSize+0x84>
81103d94:	00001406 	br	81103de8 <bFeebCh2SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81103d98:	e0bffe03 	ldbu	r2,-8(fp)
81103d9c:	10bfffc4 	addi	r2,r2,-1
81103da0:	108003cc 	andi	r2,r2,15
81103da4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81103da8:	e1bffd17 	ldw	r6,-12(fp)
81103dac:	01400544 	movi	r5,21
81103db0:	01204834 	movhi	r4,33056
81103db4:	210a0004 	addi	r4,r4,10240
81103db8:	1104f540 	call	81104f54 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81103dbc:	00000c06 	br	81103df0 <bFeebCh2SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81103dc0:	e0bffe03 	ldbu	r2,-8(fp)
81103dc4:	10bfffc4 	addi	r2,r2,-1
81103dc8:	108003cc 	andi	r2,r2,15
81103dcc:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81103dd0:	e1bffd17 	ldw	r6,-12(fp)
81103dd4:	01400504 	movi	r5,20
81103dd8:	01204834 	movhi	r4,33056
81103ddc:	210a0004 	addi	r4,r4,10240
81103de0:	1104f540 	call	81104f54 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81103de4:	00000206 	br	81103df0 <bFeebCh2SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81103de8:	e03ffc15 	stw	zero,-16(fp)
			break;
81103dec:	0001883a 	nop
		}
	} else {
81103df0:	00000106 	br	81103df8 <bFeebCh2SetBufferSize+0xbc>
		bStatus = FALSE;
81103df4:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81103df8:	e0bffc17 	ldw	r2,-16(fp)
}
81103dfc:	e037883a 	mov	sp,fp
81103e00:	dfc00117 	ldw	ra,4(sp)
81103e04:	df000017 	ldw	fp,0(sp)
81103e08:	dec00204 	addi	sp,sp,8
81103e0c:	f800283a 	ret

81103e10 <bFeebCh3SetBufferSize>:

bool bFeebCh3SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81103e10:	defffa04 	addi	sp,sp,-24
81103e14:	de00012e 	bgeu	sp,et,81103e1c <bFeebCh3SetBufferSize+0xc>
81103e18:	003b68fa 	trap	3
81103e1c:	dfc00515 	stw	ra,20(sp)
81103e20:	df000415 	stw	fp,16(sp)
81103e24:	df000404 	addi	fp,sp,16
81103e28:	2007883a 	mov	r3,r4
81103e2c:	2805883a 	mov	r2,r5
81103e30:	e0fffe05 	stb	r3,-8(fp)
81103e34:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81103e38:	00800044 	movi	r2,1
81103e3c:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81103e40:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81103e44:	e0bffe03 	ldbu	r2,-8(fp)
81103e48:	10001f26 	beq	r2,zero,81103ec8 <bFeebCh3SetBufferSize+0xb8>
81103e4c:	e0bffe03 	ldbu	r2,-8(fp)
81103e50:	10800468 	cmpgeui	r2,r2,17
81103e54:	10001c1e 	bne	r2,zero,81103ec8 <bFeebCh3SetBufferSize+0xb8>
		switch (ucBufferSide) {
81103e58:	e0bfff03 	ldbu	r2,-4(fp)
81103e5c:	10000326 	beq	r2,zero,81103e6c <bFeebCh3SetBufferSize+0x5c>
81103e60:	10800060 	cmpeqi	r2,r2,1
81103e64:	10000b1e 	bne	r2,zero,81103e94 <bFeebCh3SetBufferSize+0x84>
81103e68:	00001406 	br	81103ebc <bFeebCh3SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81103e6c:	e0bffe03 	ldbu	r2,-8(fp)
81103e70:	10bfffc4 	addi	r2,r2,-1
81103e74:	108003cc 	andi	r2,r2,15
81103e78:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81103e7c:	e1bffd17 	ldw	r6,-12(fp)
81103e80:	01400544 	movi	r5,21
81103e84:	01204834 	movhi	r4,33056
81103e88:	210b0004 	addi	r4,r4,11264
81103e8c:	1104f540 	call	81104f54 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81103e90:	00000c06 	br	81103ec4 <bFeebCh3SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81103e94:	e0bffe03 	ldbu	r2,-8(fp)
81103e98:	10bfffc4 	addi	r2,r2,-1
81103e9c:	108003cc 	andi	r2,r2,15
81103ea0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81103ea4:	e1bffd17 	ldw	r6,-12(fp)
81103ea8:	01400504 	movi	r5,20
81103eac:	01204834 	movhi	r4,33056
81103eb0:	210b0004 	addi	r4,r4,11264
81103eb4:	1104f540 	call	81104f54 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81103eb8:	00000206 	br	81103ec4 <bFeebCh3SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81103ebc:	e03ffc15 	stw	zero,-16(fp)
			break;
81103ec0:	0001883a 	nop
		}
	} else {
81103ec4:	00000106 	br	81103ecc <bFeebCh3SetBufferSize+0xbc>
		bStatus = FALSE;
81103ec8:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81103ecc:	e0bffc17 	ldw	r2,-16(fp)
}
81103ed0:	e037883a 	mov	sp,fp
81103ed4:	dfc00117 	ldw	ra,4(sp)
81103ed8:	df000017 	ldw	fp,0(sp)
81103edc:	dec00204 	addi	sp,sp,8
81103ee0:	f800283a 	ret

81103ee4 <bFeebCh4SetBufferSize>:

bool bFeebCh4SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81103ee4:	defffa04 	addi	sp,sp,-24
81103ee8:	de00012e 	bgeu	sp,et,81103ef0 <bFeebCh4SetBufferSize+0xc>
81103eec:	003b68fa 	trap	3
81103ef0:	dfc00515 	stw	ra,20(sp)
81103ef4:	df000415 	stw	fp,16(sp)
81103ef8:	df000404 	addi	fp,sp,16
81103efc:	2007883a 	mov	r3,r4
81103f00:	2805883a 	mov	r2,r5
81103f04:	e0fffe05 	stb	r3,-8(fp)
81103f08:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81103f0c:	00800044 	movi	r2,1
81103f10:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81103f14:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81103f18:	e0bffe03 	ldbu	r2,-8(fp)
81103f1c:	10001f26 	beq	r2,zero,81103f9c <bFeebCh4SetBufferSize+0xb8>
81103f20:	e0bffe03 	ldbu	r2,-8(fp)
81103f24:	10800468 	cmpgeui	r2,r2,17
81103f28:	10001c1e 	bne	r2,zero,81103f9c <bFeebCh4SetBufferSize+0xb8>
		switch (ucBufferSide) {
81103f2c:	e0bfff03 	ldbu	r2,-4(fp)
81103f30:	10000326 	beq	r2,zero,81103f40 <bFeebCh4SetBufferSize+0x5c>
81103f34:	10800060 	cmpeqi	r2,r2,1
81103f38:	10000b1e 	bne	r2,zero,81103f68 <bFeebCh4SetBufferSize+0x84>
81103f3c:	00001406 	br	81103f90 <bFeebCh4SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81103f40:	e0bffe03 	ldbu	r2,-8(fp)
81103f44:	10bfffc4 	addi	r2,r2,-1
81103f48:	108003cc 	andi	r2,r2,15
81103f4c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81103f50:	e1bffd17 	ldw	r6,-12(fp)
81103f54:	01400544 	movi	r5,21
81103f58:	01204834 	movhi	r4,33056
81103f5c:	210a0004 	addi	r4,r4,10240
81103f60:	1104f540 	call	81104f54 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81103f64:	00000c06 	br	81103f98 <bFeebCh4SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81103f68:	e0bffe03 	ldbu	r2,-8(fp)
81103f6c:	10bfffc4 	addi	r2,r2,-1
81103f70:	108003cc 	andi	r2,r2,15
81103f74:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81103f78:	e1bffd17 	ldw	r6,-12(fp)
81103f7c:	01400504 	movi	r5,20
81103f80:	01204834 	movhi	r4,33056
81103f84:	210a0004 	addi	r4,r4,10240
81103f88:	1104f540 	call	81104f54 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81103f8c:	00000206 	br	81103f98 <bFeebCh4SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81103f90:	e03ffc15 	stw	zero,-16(fp)
			break;
81103f94:	0001883a 	nop
		}
	} else {
81103f98:	00000106 	br	81103fa0 <bFeebCh4SetBufferSize+0xbc>
		bStatus = FALSE;
81103f9c:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81103fa0:	e0bffc17 	ldw	r2,-16(fp)
}
81103fa4:	e037883a 	mov	sp,fp
81103fa8:	dfc00117 	ldw	ra,4(sp)
81103fac:	df000017 	ldw	fp,0(sp)
81103fb0:	dec00204 	addi	sp,sp,8
81103fb4:	f800283a 	ret

81103fb8 <bFeebCh5SetBufferSize>:

bool bFeebCh5SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81103fb8:	defffa04 	addi	sp,sp,-24
81103fbc:	de00012e 	bgeu	sp,et,81103fc4 <bFeebCh5SetBufferSize+0xc>
81103fc0:	003b68fa 	trap	3
81103fc4:	dfc00515 	stw	ra,20(sp)
81103fc8:	df000415 	stw	fp,16(sp)
81103fcc:	df000404 	addi	fp,sp,16
81103fd0:	2007883a 	mov	r3,r4
81103fd4:	2805883a 	mov	r2,r5
81103fd8:	e0fffe05 	stb	r3,-8(fp)
81103fdc:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81103fe0:	00800044 	movi	r2,1
81103fe4:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81103fe8:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81103fec:	e0bffe03 	ldbu	r2,-8(fp)
81103ff0:	10001f26 	beq	r2,zero,81104070 <bFeebCh5SetBufferSize+0xb8>
81103ff4:	e0bffe03 	ldbu	r2,-8(fp)
81103ff8:	10800468 	cmpgeui	r2,r2,17
81103ffc:	10001c1e 	bne	r2,zero,81104070 <bFeebCh5SetBufferSize+0xb8>
		switch (ucBufferSide) {
81104000:	e0bfff03 	ldbu	r2,-4(fp)
81104004:	10000326 	beq	r2,zero,81104014 <bFeebCh5SetBufferSize+0x5c>
81104008:	10800060 	cmpeqi	r2,r2,1
8110400c:	10000b1e 	bne	r2,zero,8110403c <bFeebCh5SetBufferSize+0x84>
81104010:	00001406 	br	81104064 <bFeebCh5SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81104014:	e0bffe03 	ldbu	r2,-8(fp)
81104018:	10bfffc4 	addi	r2,r2,-1
8110401c:	108003cc 	andi	r2,r2,15
81104020:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81104024:	e1bffd17 	ldw	r6,-12(fp)
81104028:	01400544 	movi	r5,21
8110402c:	01204834 	movhi	r4,33056
81104030:	210b0004 	addi	r4,r4,11264
81104034:	1104f540 	call	81104f54 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81104038:	00000c06 	br	8110406c <bFeebCh5SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
8110403c:	e0bffe03 	ldbu	r2,-8(fp)
81104040:	10bfffc4 	addi	r2,r2,-1
81104044:	108003cc 	andi	r2,r2,15
81104048:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
8110404c:	e1bffd17 	ldw	r6,-12(fp)
81104050:	01400504 	movi	r5,20
81104054:	01204834 	movhi	r4,33056
81104058:	210b0004 	addi	r4,r4,11264
8110405c:	1104f540 	call	81104f54 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81104060:	00000206 	br	8110406c <bFeebCh5SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81104064:	e03ffc15 	stw	zero,-16(fp)
			break;
81104068:	0001883a 	nop
		}
	} else {
8110406c:	00000106 	br	81104074 <bFeebCh5SetBufferSize+0xbc>
		bStatus = FALSE;
81104070:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81104074:	e0bffc17 	ldw	r2,-16(fp)
}
81104078:	e037883a 	mov	sp,fp
8110407c:	dfc00117 	ldw	ra,4(sp)
81104080:	df000017 	ldw	fp,0(sp)
81104084:	dec00204 	addi	sp,sp,8
81104088:	f800283a 	ret

8110408c <bFeebCh6SetBufferSize>:

bool bFeebCh6SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
8110408c:	defffa04 	addi	sp,sp,-24
81104090:	de00012e 	bgeu	sp,et,81104098 <bFeebCh6SetBufferSize+0xc>
81104094:	003b68fa 	trap	3
81104098:	dfc00515 	stw	ra,20(sp)
8110409c:	df000415 	stw	fp,16(sp)
811040a0:	df000404 	addi	fp,sp,16
811040a4:	2007883a 	mov	r3,r4
811040a8:	2805883a 	mov	r2,r5
811040ac:	e0fffe05 	stb	r3,-8(fp)
811040b0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811040b4:	00800044 	movi	r2,1
811040b8:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
811040bc:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
811040c0:	e0bffe03 	ldbu	r2,-8(fp)
811040c4:	10001f26 	beq	r2,zero,81104144 <bFeebCh6SetBufferSize+0xb8>
811040c8:	e0bffe03 	ldbu	r2,-8(fp)
811040cc:	10800468 	cmpgeui	r2,r2,17
811040d0:	10001c1e 	bne	r2,zero,81104144 <bFeebCh6SetBufferSize+0xb8>
		switch (ucBufferSide) {
811040d4:	e0bfff03 	ldbu	r2,-4(fp)
811040d8:	10000326 	beq	r2,zero,811040e8 <bFeebCh6SetBufferSize+0x5c>
811040dc:	10800060 	cmpeqi	r2,r2,1
811040e0:	10000b1e 	bne	r2,zero,81104110 <bFeebCh6SetBufferSize+0x84>
811040e4:	00001406 	br	81104138 <bFeebCh6SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811040e8:	e0bffe03 	ldbu	r2,-8(fp)
811040ec:	10bfffc4 	addi	r2,r2,-1
811040f0:	108003cc 	andi	r2,r2,15
811040f4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811040f8:	e1bffd17 	ldw	r6,-12(fp)
811040fc:	01400544 	movi	r5,21
81104100:	01204834 	movhi	r4,33056
81104104:	210a0004 	addi	r4,r4,10240
81104108:	1104f540 	call	81104f54 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
8110410c:	00000c06 	br	81104140 <bFeebCh6SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81104110:	e0bffe03 	ldbu	r2,-8(fp)
81104114:	10bfffc4 	addi	r2,r2,-1
81104118:	108003cc 	andi	r2,r2,15
8110411c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81104120:	e1bffd17 	ldw	r6,-12(fp)
81104124:	01400504 	movi	r5,20
81104128:	01204834 	movhi	r4,33056
8110412c:	210a0004 	addi	r4,r4,10240
81104130:	1104f540 	call	81104f54 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81104134:	00000206 	br	81104140 <bFeebCh6SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81104138:	e03ffc15 	stw	zero,-16(fp)
			break;
8110413c:	0001883a 	nop
		}
	} else {
81104140:	00000106 	br	81104148 <bFeebCh6SetBufferSize+0xbc>
		bStatus = FALSE;
81104144:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81104148:	e0bffc17 	ldw	r2,-16(fp)
}
8110414c:	e037883a 	mov	sp,fp
81104150:	dfc00117 	ldw	ra,4(sp)
81104154:	df000017 	ldw	fp,0(sp)
81104158:	dec00204 	addi	sp,sp,8
8110415c:	f800283a 	ret

81104160 <bFeebCh7SetBufferSize>:

bool bFeebCh7SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81104160:	defffa04 	addi	sp,sp,-24
81104164:	de00012e 	bgeu	sp,et,8110416c <bFeebCh7SetBufferSize+0xc>
81104168:	003b68fa 	trap	3
8110416c:	dfc00515 	stw	ra,20(sp)
81104170:	df000415 	stw	fp,16(sp)
81104174:	df000404 	addi	fp,sp,16
81104178:	2007883a 	mov	r3,r4
8110417c:	2805883a 	mov	r2,r5
81104180:	e0fffe05 	stb	r3,-8(fp)
81104184:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81104188:	00800044 	movi	r2,1
8110418c:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81104190:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81104194:	e0bffe03 	ldbu	r2,-8(fp)
81104198:	10001f26 	beq	r2,zero,81104218 <bFeebCh7SetBufferSize+0xb8>
8110419c:	e0bffe03 	ldbu	r2,-8(fp)
811041a0:	10800468 	cmpgeui	r2,r2,17
811041a4:	10001c1e 	bne	r2,zero,81104218 <bFeebCh7SetBufferSize+0xb8>
		switch (ucBufferSide) {
811041a8:	e0bfff03 	ldbu	r2,-4(fp)
811041ac:	10000326 	beq	r2,zero,811041bc <bFeebCh7SetBufferSize+0x5c>
811041b0:	10800060 	cmpeqi	r2,r2,1
811041b4:	10000b1e 	bne	r2,zero,811041e4 <bFeebCh7SetBufferSize+0x84>
811041b8:	00001406 	br	8110420c <bFeebCh7SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811041bc:	e0bffe03 	ldbu	r2,-8(fp)
811041c0:	10bfffc4 	addi	r2,r2,-1
811041c4:	108003cc 	andi	r2,r2,15
811041c8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811041cc:	e1bffd17 	ldw	r6,-12(fp)
811041d0:	01400544 	movi	r5,21
811041d4:	01204834 	movhi	r4,33056
811041d8:	210b0004 	addi	r4,r4,11264
811041dc:	1104f540 	call	81104f54 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811041e0:	00000c06 	br	81104214 <bFeebCh7SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811041e4:	e0bffe03 	ldbu	r2,-8(fp)
811041e8:	10bfffc4 	addi	r2,r2,-1
811041ec:	108003cc 	andi	r2,r2,15
811041f0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811041f4:	e1bffd17 	ldw	r6,-12(fp)
811041f8:	01400504 	movi	r5,20
811041fc:	01204834 	movhi	r4,33056
81104200:	210b0004 	addi	r4,r4,11264
81104204:	1104f540 	call	81104f54 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81104208:	00000206 	br	81104214 <bFeebCh7SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
8110420c:	e03ffc15 	stw	zero,-16(fp)
			break;
81104210:	0001883a 	nop
		}
	} else {
81104214:	00000106 	br	8110421c <bFeebCh7SetBufferSize+0xbc>
		bStatus = FALSE;
81104218:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
8110421c:	e0bffc17 	ldw	r2,-16(fp)
}
81104220:	e037883a 	mov	sp,fp
81104224:	dfc00117 	ldw	ra,4(sp)
81104228:	df000017 	ldw	fp,0(sp)
8110422c:	dec00204 	addi	sp,sp,8
81104230:	f800283a 	ret

81104234 <bFeebCh8SetBufferSize>:

bool bFeebCh8SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81104234:	defffa04 	addi	sp,sp,-24
81104238:	de00012e 	bgeu	sp,et,81104240 <bFeebCh8SetBufferSize+0xc>
8110423c:	003b68fa 	trap	3
81104240:	dfc00515 	stw	ra,20(sp)
81104244:	df000415 	stw	fp,16(sp)
81104248:	df000404 	addi	fp,sp,16
8110424c:	2007883a 	mov	r3,r4
81104250:	2805883a 	mov	r2,r5
81104254:	e0fffe05 	stb	r3,-8(fp)
81104258:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
8110425c:	00800044 	movi	r2,1
81104260:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81104264:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81104268:	e0bffe03 	ldbu	r2,-8(fp)
8110426c:	10001f26 	beq	r2,zero,811042ec <bFeebCh8SetBufferSize+0xb8>
81104270:	e0bffe03 	ldbu	r2,-8(fp)
81104274:	10800468 	cmpgeui	r2,r2,17
81104278:	10001c1e 	bne	r2,zero,811042ec <bFeebCh8SetBufferSize+0xb8>
		switch (ucBufferSide) {
8110427c:	e0bfff03 	ldbu	r2,-4(fp)
81104280:	10000326 	beq	r2,zero,81104290 <bFeebCh8SetBufferSize+0x5c>
81104284:	10800060 	cmpeqi	r2,r2,1
81104288:	10000b1e 	bne	r2,zero,811042b8 <bFeebCh8SetBufferSize+0x84>
8110428c:	00001406 	br	811042e0 <bFeebCh8SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81104290:	e0bffe03 	ldbu	r2,-8(fp)
81104294:	10bfffc4 	addi	r2,r2,-1
81104298:	108003cc 	andi	r2,r2,15
8110429c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811042a0:	e1bffd17 	ldw	r6,-12(fp)
811042a4:	01400544 	movi	r5,21
811042a8:	01204834 	movhi	r4,33056
811042ac:	210a0004 	addi	r4,r4,10240
811042b0:	1104f540 	call	81104f54 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811042b4:	00000c06 	br	811042e8 <bFeebCh8SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811042b8:	e0bffe03 	ldbu	r2,-8(fp)
811042bc:	10bfffc4 	addi	r2,r2,-1
811042c0:	108003cc 	andi	r2,r2,15
811042c4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811042c8:	e1bffd17 	ldw	r6,-12(fp)
811042cc:	01400504 	movi	r5,20
811042d0:	01204834 	movhi	r4,33056
811042d4:	210a0004 	addi	r4,r4,10240
811042d8:	1104f540 	call	81104f54 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811042dc:	00000206 	br	811042e8 <bFeebCh8SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
811042e0:	e03ffc15 	stw	zero,-16(fp)
			break;
811042e4:	0001883a 	nop
		}
	} else {
811042e8:	00000106 	br	811042f0 <bFeebCh8SetBufferSize+0xbc>
		bStatus = FALSE;
811042ec:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
811042f0:	e0bffc17 	ldw	r2,-16(fp)
}
811042f4:	e037883a 	mov	sp,fp
811042f8:	dfc00117 	ldw	ra,4(sp)
811042fc:	df000017 	ldw	fp,0(sp)
81104300:	dec00204 	addi	sp,sp,8
81104304:	f800283a 	ret

81104308 <vFeebInitIrq>:

void vFeebInitIrq(alt_u8 ucCommCh) {
81104308:	defffc04 	addi	sp,sp,-16
8110430c:	de00012e 	bgeu	sp,et,81104314 <vFeebInitIrq+0xc>
81104310:	003b68fa 	trap	3
81104314:	dfc00315 	stw	ra,12(sp)
81104318:	df000215 	stw	fp,8(sp)
8110431c:	df000204 	addi	fp,sp,8
81104320:	2005883a 	mov	r2,r4
81104324:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81104328:	e0bfff03 	ldbu	r2,-4(fp)
8110432c:	10c00228 	cmpgeui	r3,r2,8
81104330:	18004e1e 	bne	r3,zero,8110446c <vFeebInitIrq+0x164>
81104334:	100690ba 	slli	r3,r2,2
81104338:	00a04434 	movhi	r2,33040
8110433c:	1090d304 	addi	r2,r2,17228
81104340:	1885883a 	add	r2,r3,r2
81104344:	10800017 	ldw	r2,0(r2)
81104348:	1000683a 	jmp	r2
8110434c:	8110436c 	andhi	r4,r16,16653
81104350:	8110438c 	andi	r4,r16,16654
81104354:	811043ac 	andhi	r4,r16,16654
81104358:	811043cc 	andi	r4,r16,16655
8110435c:	811043ec 	andhi	r4,r16,16655
81104360:	8110440c 	andi	r4,r16,16656
81104364:	8110442c 	andhi	r4,r16,16656
81104368:	8110444c 	andi	r4,r16,16657
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
8110436c:	d0a04004 	addi	r2,gp,-32512
81104370:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_BUFFERS_IRQ, pvHoldContext,
81104374:	01a04434 	movhi	r6,33040
81104378:	318d1e04 	addi	r6,r6,13432
8110437c:	e17ffe17 	ldw	r5,-8(fp)
81104380:	01000584 	movi	r4,22
81104384:	112f3100 	call	8112f310 <alt_irq_register>
				vFeebCh1HandleIrq);
		break;
81104388:	00003806 	br	8110446c <vFeebInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
8110438c:	d0a04104 	addi	r2,gp,-32508
81104390:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_BUFFERS_IRQ, pvHoldContext,
81104394:	01a04434 	movhi	r6,33040
81104398:	318d2e04 	addi	r6,r6,13496
8110439c:	e17ffe17 	ldw	r5,-8(fp)
811043a0:	01000504 	movi	r4,20
811043a4:	112f3100 	call	8112f310 <alt_irq_register>
				vFeebCh2HandleIrq);
		break;
811043a8:	00003006 	br	8110446c <vFeebInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
811043ac:	d0a04204 	addi	r2,gp,-32504
811043b0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_BUFFERS_IRQ, pvHoldContext,
811043b4:	01a04434 	movhi	r6,33040
811043b8:	318d3e04 	addi	r6,r6,13560
811043bc:	e17ffe17 	ldw	r5,-8(fp)
811043c0:	01000484 	movi	r4,18
811043c4:	112f3100 	call	8112f310 <alt_irq_register>
				vFeebCh3HandleIrq);
		break;
811043c8:	00002806 	br	8110446c <vFeebInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
811043cc:	d0a04304 	addi	r2,gp,-32500
811043d0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_BUFFERS_IRQ, pvHoldContext,
811043d4:	01a04434 	movhi	r6,33040
811043d8:	318d5f04 	addi	r6,r6,13692
811043dc:	e17ffe17 	ldw	r5,-8(fp)
811043e0:	01000404 	movi	r4,16
811043e4:	112f3100 	call	8112f310 <alt_irq_register>
				vFeebCh4HandleIrq);
		break;
811043e8:	00002006 	br	8110446c <vFeebInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
811043ec:	d0a04404 	addi	r2,gp,-32496
811043f0:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_BUFFERS_IRQ, pvHoldContext,
811043f4:	01a04434 	movhi	r6,33040
811043f8:	318d8004 	addi	r6,r6,13824
811043fc:	e17ffe17 	ldw	r5,-8(fp)
81104400:	01000204 	movi	r4,8
81104404:	112f3100 	call	8112f310 <alt_irq_register>
				vFeebCh5HandleIrq);
		break;
81104408:	00001806 	br	8110446c <vFeebInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
8110440c:	d0a04504 	addi	r2,gp,-32492
81104410:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_BUFFERS_IRQ, pvHoldContext,
81104414:	01a04434 	movhi	r6,33040
81104418:	318da104 	addi	r6,r6,13956
8110441c:	e17ffe17 	ldw	r5,-8(fp)
81104420:	01000184 	movi	r4,6
81104424:	112f3100 	call	8112f310 <alt_irq_register>
				vFeebCh6HandleIrq);
		break;
81104428:	00001006 	br	8110446c <vFeebInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
8110442c:	d0a04604 	addi	r2,gp,-32488
81104430:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_BUFFERS_IRQ, pvHoldContext,
81104434:	01a04434 	movhi	r6,33040
81104438:	318dc204 	addi	r6,r6,14088
8110443c:	e17ffe17 	ldw	r5,-8(fp)
81104440:	01000144 	movi	r4,5
81104444:	112f3100 	call	8112f310 <alt_irq_register>
				vFeebCh7HandleIrq);
		break;
81104448:	00000806 	br	8110446c <vFeebInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
8110444c:	d0a04704 	addi	r2,gp,-32484
81104450:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_BUFFERS_IRQ, pvHoldContext,
81104454:	01a04434 	movhi	r6,33040
81104458:	318dd204 	addi	r6,r6,14152
8110445c:	e17ffe17 	ldw	r5,-8(fp)
81104460:	01000084 	movi	r4,2
81104464:	112f3100 	call	8112f310 <alt_irq_register>
				vFeebCh8HandleIrq);
		break;
81104468:	0001883a 	nop
	}
}
8110446c:	0001883a 	nop
81104470:	e037883a 	mov	sp,fp
81104474:	dfc00117 	ldw	ra,4(sp)
81104478:	df000017 	ldw	fp,0(sp)
8110447c:	dec00204 	addi	sp,sp,8
81104480:	f800283a 	ret

81104484 <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
81104484:	defffb04 	addi	sp,sp,-20
81104488:	de00012e 	bgeu	sp,et,81104490 <bFeebSetIrqControl+0xc>
8110448c:	003b68fa 	trap	3
81104490:	dfc00415 	stw	ra,16(sp)
81104494:	df000315 	stw	fp,12(sp)
81104498:	df000304 	addi	fp,sp,12
8110449c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811044a0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811044a4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811044a8:	e0bfff17 	ldw	r2,-4(fp)
811044ac:	10002426 	beq	r2,zero,81104540 <bFeebSetIrqControl+0xbc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811044b0:	e0bfff17 	ldw	r2,-4(fp)
811044b4:	10800017 	ldw	r2,0(r2)
811044b8:	01400444 	movi	r5,17
811044bc:	1009883a 	mov	r4,r2
811044c0:	1104fa80 	call	81104fa8 <uliFeebReadReg>
811044c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
811044c8:	e0bfff17 	ldw	r2,-4(fp)
811044cc:	10800217 	ldw	r2,8(r2)
811044d0:	10000426 	beq	r2,zero,811044e4 <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_LEFT_BUFF_EPY_EN_MSK;
811044d4:	e0bffe17 	ldw	r2,-8(fp)
811044d8:	10808014 	ori	r2,r2,512
811044dc:	e0bffe15 	stw	r2,-8(fp)
811044e0:	00000406 	br	811044f4 <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_LEFT_BUFF_EPY_EN_MSK);
811044e4:	e0fffe17 	ldw	r3,-8(fp)
811044e8:	00bf7fc4 	movi	r2,-513
811044ec:	1884703a 	and	r2,r3,r2
811044f0:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
811044f4:	e0bfff17 	ldw	r2,-4(fp)
811044f8:	10800317 	ldw	r2,12(r2)
811044fc:	10000426 	beq	r2,zero,81104510 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_RIGH_BUFF_EPY_EN_MSK;
81104500:	e0bffe17 	ldw	r2,-8(fp)
81104504:	10804014 	ori	r2,r2,256
81104508:	e0bffe15 	stw	r2,-8(fp)
8110450c:	00000406 	br	81104520 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_RIGH_BUFF_EPY_EN_MSK);
81104510:	e0fffe17 	ldw	r3,-8(fp)
81104514:	00bfbfc4 	movi	r2,-257
81104518:	1884703a 	and	r2,r3,r2
8110451c:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CONTROL_REG_OFST,
81104520:	e0bfff17 	ldw	r2,-4(fp)
81104524:	10800017 	ldw	r2,0(r2)
81104528:	e1bffe17 	ldw	r6,-8(fp)
8110452c:	01400444 	movi	r5,17
81104530:	1009883a 	mov	r4,r2
81104534:	1104f540 	call	81104f54 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81104538:	00800044 	movi	r2,1
8110453c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104540:	e0bffd17 	ldw	r2,-12(fp)
}
81104544:	e037883a 	mov	sp,fp
81104548:	dfc00117 	ldw	ra,4(sp)
8110454c:	df000017 	ldw	fp,0(sp)
81104550:	dec00204 	addi	sp,sp,8
81104554:	f800283a 	ret

81104558 <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
81104558:	defffb04 	addi	sp,sp,-20
8110455c:	de00012e 	bgeu	sp,et,81104564 <bFeebGetIrqControl+0xc>
81104560:	003b68fa 	trap	3
81104564:	dfc00415 	stw	ra,16(sp)
81104568:	df000315 	stw	fp,12(sp)
8110456c:	df000304 	addi	fp,sp,12
81104570:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104574:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104578:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110457c:	e0bfff17 	ldw	r2,-4(fp)
81104580:	10001a26 	beq	r2,zero,811045ec <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104584:	e0bfff17 	ldw	r2,-4(fp)
81104588:	10800017 	ldw	r2,0(r2)
8110458c:	01400444 	movi	r5,17
81104590:	1009883a 	mov	r4,r2
81104594:	1104fa80 	call	81104fa8 <uliFeebReadReg>
81104598:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_LEFT_BUFF_EPY_EN_MSK) {
8110459c:	e0bffe17 	ldw	r2,-8(fp)
811045a0:	1080800c 	andi	r2,r2,512
811045a4:	10000426 	beq	r2,zero,811045b8 <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
811045a8:	e0bfff17 	ldw	r2,-4(fp)
811045ac:	00c00044 	movi	r3,1
811045b0:	10c00215 	stw	r3,8(r2)
811045b4:	00000206 	br	811045c0 <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
811045b8:	e0bfff17 	ldw	r2,-4(fp)
811045bc:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_RIGH_BUFF_EPY_EN_MSK) {
811045c0:	e0bffe17 	ldw	r2,-8(fp)
811045c4:	1080400c 	andi	r2,r2,256
811045c8:	10000426 	beq	r2,zero,811045dc <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
811045cc:	e0bfff17 	ldw	r2,-4(fp)
811045d0:	00c00044 	movi	r3,1
811045d4:	10c00315 	stw	r3,12(r2)
811045d8:	00000206 	br	811045e4 <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
811045dc:	e0bfff17 	ldw	r2,-4(fp)
811045e0:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
811045e4:	00800044 	movi	r2,1
811045e8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811045ec:	e0bffd17 	ldw	r2,-12(fp)
}
811045f0:	e037883a 	mov	sp,fp
811045f4:	dfc00117 	ldw	ra,4(sp)
811045f8:	df000017 	ldw	fp,0(sp)
811045fc:	dec00204 	addi	sp,sp,8
81104600:	f800283a 	ret

81104604 <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
81104604:	defffb04 	addi	sp,sp,-20
81104608:	de00012e 	bgeu	sp,et,81104610 <bFeebGetIrqFlags+0xc>
8110460c:	003b68fa 	trap	3
81104610:	dfc00415 	stw	ra,16(sp)
81104614:	df000315 	stw	fp,12(sp)
81104618:	df000304 	addi	fp,sp,12
8110461c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104620:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104624:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104628:	e0bfff17 	ldw	r2,-4(fp)
8110462c:	10001126 	beq	r2,zero,81104674 <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104630:	e0bfff17 	ldw	r2,-4(fp)
81104634:	10800017 	ldw	r2,0(r2)
81104638:	01400484 	movi	r5,18
8110463c:	1009883a 	mov	r4,r2
81104640:	1104fa80 	call	81104fa8 <uliFeebReadReg>
81104644:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81104648:	e0bffe17 	ldw	r2,-8(fp)
8110464c:	1080400c 	andi	r2,r2,256
81104650:	10000426 	beq	r2,zero,81104664 <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
81104654:	e0bfff17 	ldw	r2,-4(fp)
81104658:	00c00044 	movi	r3,1
8110465c:	10c00415 	stw	r3,16(r2)
81104660:	00000206 	br	8110466c <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
81104664:	e0bfff17 	ldw	r2,-4(fp)
81104668:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
8110466c:	00800044 	movi	r2,1
81104670:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104674:	e0bffd17 	ldw	r2,-12(fp)
}
81104678:	e037883a 	mov	sp,fp
8110467c:	dfc00117 	ldw	ra,4(sp)
81104680:	df000017 	ldw	fp,0(sp)
81104684:	dec00204 	addi	sp,sp,8
81104688:	f800283a 	ret

8110468c <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
8110468c:	defffb04 	addi	sp,sp,-20
81104690:	de00012e 	bgeu	sp,et,81104698 <bFeebGetBuffersStatus+0xc>
81104694:	003b68fa 	trap	3
81104698:	dfc00415 	stw	ra,16(sp)
8110469c:	df000315 	stw	fp,12(sp)
811046a0:	df000304 	addi	fp,sp,12
811046a4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811046a8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811046ac:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811046b0:	e0bfff17 	ldw	r2,-4(fp)
811046b4:	10003226 	beq	r2,zero,81104780 <bFeebGetBuffersStatus+0xf4>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811046b8:	e0bfff17 	ldw	r2,-4(fp)
811046bc:	10800017 	ldw	r2,0(r2)
811046c0:	014000c4 	movi	r5,3
811046c4:	1009883a 	mov	r4,r2
811046c8:	1104fa80 	call	81104fa8 <uliFeebReadReg>
811046cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811046d0:	e0bffe17 	ldw	r2,-8(fp)
811046d4:	1080008c 	andi	r2,r2,2
811046d8:	10000426 	beq	r2,zero,811046ec <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
811046dc:	e0bfff17 	ldw	r2,-4(fp)
811046e0:	00c00044 	movi	r3,1
811046e4:	10c00515 	stw	r3,20(r2)
811046e8:	00000206 	br	811046f4 <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
811046ec:	e0bfff17 	ldw	r2,-4(fp)
811046f0:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
811046f4:	e0bffe17 	ldw	r2,-8(fp)
811046f8:	1080004c 	andi	r2,r2,1
811046fc:	10000426 	beq	r2,zero,81104710 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
81104700:	e0bfff17 	ldw	r2,-4(fp)
81104704:	00c00044 	movi	r3,1
81104708:	10c00615 	stw	r3,24(r2)
8110470c:	00000206 	br	81104718 <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
81104710:	e0bfff17 	ldw	r2,-4(fp)
81104714:	10000615 	stw	zero,24(r2)
		}

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104718:	e0bfff17 	ldw	r2,-4(fp)
8110471c:	10800017 	ldw	r2,0(r2)
81104720:	01400504 	movi	r5,20
81104724:	1009883a 	mov	r4,r2
81104728:	1104fa80 	call	81104fa8 <uliFeebReadReg>
8110472c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RIGT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
81104730:	e0bffe17 	ldw	r2,-8(fp)
81104734:	108003cc 	andi	r2,r2,15
81104738:	10800044 	addi	r2,r2,1
8110473c:	1007883a 	mov	r3,r2
81104740:	e0bfff17 	ldw	r2,-4(fp)
81104744:	10c00745 	stb	r3,29(r2)
				& COMM_RIGT_FEEBUFF_SIZE_MSK) + 1;

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104748:	e0bfff17 	ldw	r2,-4(fp)
8110474c:	10800017 	ldw	r2,0(r2)
81104750:	01400544 	movi	r5,21
81104754:	1009883a 	mov	r4,r2
81104758:	1104fa80 	call	81104fa8 <uliFeebReadReg>
8110475c:	e0bffe15 	stw	r2,-8(fp)
		COMM_LEFT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
81104760:	e0bffe17 	ldw	r2,-8(fp)
81104764:	108003cc 	andi	r2,r2,15
81104768:	10800044 	addi	r2,r2,1
8110476c:	1007883a 	mov	r3,r2
81104770:	e0bfff17 	ldw	r2,-4(fp)
81104774:	10c00745 	stb	r3,29(r2)
				& COMM_LEFT_FEEBUFF_SIZE_MSK) + 1;

		bStatus = TRUE;
81104778:	00800044 	movi	r2,1
8110477c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104780:	e0bffd17 	ldw	r2,-12(fp)
}
81104784:	e037883a 	mov	sp,fp
81104788:	dfc00117 	ldw	ra,4(sp)
8110478c:	df000017 	ldw	fp,0(sp)
81104790:	dec00204 	addi	sp,sp,8
81104794:	f800283a 	ret

81104798 <bFeebGetLeftBufferEmpty>:

bool bFeebGetLeftBufferEmpty(TFeebChannel *pxFeebCh){
81104798:	defffb04 	addi	sp,sp,-20
8110479c:	de00012e 	bgeu	sp,et,811047a4 <bFeebGetLeftBufferEmpty+0xc>
811047a0:	003b68fa 	trap	3
811047a4:	dfc00415 	stw	ra,16(sp)
811047a8:	df000315 	stw	fp,12(sp)
811047ac:	df000304 	addi	fp,sp,12
811047b0:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
811047b4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811047b8:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811047bc:	e0bfff17 	ldw	r2,-4(fp)
811047c0:	10000d26 	beq	r2,zero,811047f8 <bFeebGetLeftBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811047c4:	e0bfff17 	ldw	r2,-4(fp)
811047c8:	10800017 	ldw	r2,0(r2)
811047cc:	014000c4 	movi	r5,3
811047d0:	1009883a 	mov	r4,r2
811047d4:	1104fa80 	call	81104fa8 <uliFeebReadReg>
811047d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811047dc:	e0bffe17 	ldw	r2,-8(fp)
811047e0:	1080008c 	andi	r2,r2,2
811047e4:	10000326 	beq	r2,zero,811047f4 <bFeebGetLeftBufferEmpty+0x5c>
			bFlag = TRUE;
811047e8:	00800044 	movi	r2,1
811047ec:	e0bffd15 	stw	r2,-12(fp)
811047f0:	00000106 	br	811047f8 <bFeebGetLeftBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
811047f4:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
811047f8:	e0bffd17 	ldw	r2,-12(fp)
}
811047fc:	e037883a 	mov	sp,fp
81104800:	dfc00117 	ldw	ra,4(sp)
81104804:	df000017 	ldw	fp,0(sp)
81104808:	dec00204 	addi	sp,sp,8
8110480c:	f800283a 	ret

81104810 <bFeebGetRightBufferEmpty>:

bool bFeebGetRightBufferEmpty(TFeebChannel *pxFeebCh){
81104810:	defffb04 	addi	sp,sp,-20
81104814:	de00012e 	bgeu	sp,et,8110481c <bFeebGetRightBufferEmpty+0xc>
81104818:	003b68fa 	trap	3
8110481c:	dfc00415 	stw	ra,16(sp)
81104820:	df000315 	stw	fp,12(sp)
81104824:	df000304 	addi	fp,sp,12
81104828:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
8110482c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104830:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104834:	e0bfff17 	ldw	r2,-4(fp)
81104838:	10000d26 	beq	r2,zero,81104870 <bFeebGetRightBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
8110483c:	e0bfff17 	ldw	r2,-4(fp)
81104840:	10800017 	ldw	r2,0(r2)
81104844:	014000c4 	movi	r5,3
81104848:	1009883a 	mov	r4,r2
8110484c:	1104fa80 	call	81104fa8 <uliFeebReadReg>
81104850:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81104854:	e0bffe17 	ldw	r2,-8(fp)
81104858:	1080004c 	andi	r2,r2,1
8110485c:	10000326 	beq	r2,zero,8110486c <bFeebGetRightBufferEmpty+0x5c>
			bFlag = TRUE;
81104860:	00800044 	movi	r2,1
81104864:	e0bffd15 	stw	r2,-12(fp)
81104868:	00000106 	br	81104870 <bFeebGetRightBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
8110486c:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
81104870:	e0bffd17 	ldw	r2,-12(fp)
}
81104874:	e037883a 	mov	sp,fp
81104878:	dfc00117 	ldw	ra,4(sp)
8110487c:	df000017 	ldw	fp,0(sp)
81104880:	dec00204 	addi	sp,sp,8
81104884:	f800283a 	ret

81104888 <bFeebGetCh1LeftBufferEmpty>:

bool bFeebGetCh1LeftBufferEmpty(void){
81104888:	defffc04 	addi	sp,sp,-16
8110488c:	de00012e 	bgeu	sp,et,81104894 <bFeebGetCh1LeftBufferEmpty+0xc>
81104890:	003b68fa 	trap	3
81104894:	dfc00315 	stw	ra,12(sp)
81104898:	df000215 	stw	fp,8(sp)
8110489c:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
811048a0:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
811048a4:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
811048a8:	014000c4 	movi	r5,3
811048ac:	01204834 	movhi	r4,33056
811048b0:	210b0004 	addi	r4,r4,11264
811048b4:	1104fa80 	call	81104fa8 <uliFeebReadReg>
811048b8:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811048bc:	e0bfff17 	ldw	r2,-4(fp)
811048c0:	1080008c 	andi	r2,r2,2
811048c4:	10000326 	beq	r2,zero,811048d4 <bFeebGetCh1LeftBufferEmpty+0x4c>
			bFlag = TRUE;
811048c8:	00800044 	movi	r2,1
811048cc:	e0bffe15 	stw	r2,-8(fp)
811048d0:	00000106 	br	811048d8 <bFeebGetCh1LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
811048d4:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
811048d8:	e0bffe17 	ldw	r2,-8(fp)
}
811048dc:	e037883a 	mov	sp,fp
811048e0:	dfc00117 	ldw	ra,4(sp)
811048e4:	df000017 	ldw	fp,0(sp)
811048e8:	dec00204 	addi	sp,sp,8
811048ec:	f800283a 	ret

811048f0 <bFeebGetCh1RightBufferEmpty>:

bool bFeebGetCh1RightBufferEmpty(void){
811048f0:	defffc04 	addi	sp,sp,-16
811048f4:	de00012e 	bgeu	sp,et,811048fc <bFeebGetCh1RightBufferEmpty+0xc>
811048f8:	003b68fa 	trap	3
811048fc:	dfc00315 	stw	ra,12(sp)
81104900:	df000215 	stw	fp,8(sp)
81104904:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81104908:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
8110490c:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
81104910:	014000c4 	movi	r5,3
81104914:	01204834 	movhi	r4,33056
81104918:	210b0004 	addi	r4,r4,11264
8110491c:	1104fa80 	call	81104fa8 <uliFeebReadReg>
81104920:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81104924:	e0bfff17 	ldw	r2,-4(fp)
81104928:	1080004c 	andi	r2,r2,1
8110492c:	10000326 	beq	r2,zero,8110493c <bFeebGetCh1RightBufferEmpty+0x4c>
			bFlag = TRUE;
81104930:	00800044 	movi	r2,1
81104934:	e0bffe15 	stw	r2,-8(fp)
81104938:	00000106 	br	81104940 <bFeebGetCh1RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
8110493c:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81104940:	e0bffe17 	ldw	r2,-8(fp)
}
81104944:	e037883a 	mov	sp,fp
81104948:	dfc00117 	ldw	ra,4(sp)
8110494c:	df000017 	ldw	fp,0(sp)
81104950:	dec00204 	addi	sp,sp,8
81104954:	f800283a 	ret

81104958 <bFeebGetCh2LeftBufferEmpty>:

bool bFeebGetCh2LeftBufferEmpty(void){
81104958:	defffc04 	addi	sp,sp,-16
8110495c:	de00012e 	bgeu	sp,et,81104964 <bFeebGetCh2LeftBufferEmpty+0xc>
81104960:	003b68fa 	trap	3
81104964:	dfc00315 	stw	ra,12(sp)
81104968:	df000215 	stw	fp,8(sp)
8110496c:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81104970:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
81104974:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
81104978:	014000c4 	movi	r5,3
8110497c:	01204834 	movhi	r4,33056
81104980:	210a0004 	addi	r4,r4,10240
81104984:	1104fa80 	call	81104fa8 <uliFeebReadReg>
81104988:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
8110498c:	e0bfff17 	ldw	r2,-4(fp)
81104990:	1080008c 	andi	r2,r2,2
81104994:	10000326 	beq	r2,zero,811049a4 <bFeebGetCh2LeftBufferEmpty+0x4c>
			bFlag = TRUE;
81104998:	00800044 	movi	r2,1
8110499c:	e0bffe15 	stw	r2,-8(fp)
811049a0:	00000106 	br	811049a8 <bFeebGetCh2LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
811049a4:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
811049a8:	e0bffe17 	ldw	r2,-8(fp)
}
811049ac:	e037883a 	mov	sp,fp
811049b0:	dfc00117 	ldw	ra,4(sp)
811049b4:	df000017 	ldw	fp,0(sp)
811049b8:	dec00204 	addi	sp,sp,8
811049bc:	f800283a 	ret

811049c0 <bFeebGetCh2RightBufferEmpty>:

bool bFeebGetCh2RightBufferEmpty(void){
811049c0:	defffc04 	addi	sp,sp,-16
811049c4:	de00012e 	bgeu	sp,et,811049cc <bFeebGetCh2RightBufferEmpty+0xc>
811049c8:	003b68fa 	trap	3
811049cc:	dfc00315 	stw	ra,12(sp)
811049d0:	df000215 	stw	fp,8(sp)
811049d4:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
811049d8:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
811049dc:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
811049e0:	014000c4 	movi	r5,3
811049e4:	01204834 	movhi	r4,33056
811049e8:	210a0004 	addi	r4,r4,10240
811049ec:	1104fa80 	call	81104fa8 <uliFeebReadReg>
811049f0:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
811049f4:	e0bfff17 	ldw	r2,-4(fp)
811049f8:	1080004c 	andi	r2,r2,1
811049fc:	10000326 	beq	r2,zero,81104a0c <bFeebGetCh2RightBufferEmpty+0x4c>
			bFlag = TRUE;
81104a00:	00800044 	movi	r2,1
81104a04:	e0bffe15 	stw	r2,-8(fp)
81104a08:	00000106 	br	81104a10 <bFeebGetCh2RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81104a0c:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81104a10:	e0bffe17 	ldw	r2,-8(fp)
}
81104a14:	e037883a 	mov	sp,fp
81104a18:	dfc00117 	ldw	ra,4(sp)
81104a1c:	df000017 	ldw	fp,0(sp)
81104a20:	dec00204 	addi	sp,sp,8
81104a24:	f800283a 	ret

81104a28 <bFeebSetBufferSize>:

bool bFeebSetBufferSize(TFeebChannel *pxFeebCh, alt_u8 ucBufferSizeInBlocks,
		alt_u8 ucBufferSide) {
81104a28:	defff904 	addi	sp,sp,-28
81104a2c:	de00012e 	bgeu	sp,et,81104a34 <bFeebSetBufferSize+0xc>
81104a30:	003b68fa 	trap	3
81104a34:	dfc00615 	stw	ra,24(sp)
81104a38:	df000515 	stw	fp,20(sp)
81104a3c:	df000504 	addi	fp,sp,20
81104a40:	e13ffd15 	stw	r4,-12(fp)
81104a44:	2807883a 	mov	r3,r5
81104a48:	3005883a 	mov	r2,r6
81104a4c:	e0fffe05 	stb	r3,-8(fp)
81104a50:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81104a54:	00800044 	movi	r2,1
81104a58:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
81104a5c:	e03ffc15 	stw	zero,-16(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81104a60:	e0bffe03 	ldbu	r2,-8(fp)
81104a64:	10002126 	beq	r2,zero,81104aec <bFeebSetBufferSize+0xc4>
81104a68:	e0bffe03 	ldbu	r2,-8(fp)
81104a6c:	10800468 	cmpgeui	r2,r2,17
81104a70:	10001e1e 	bne	r2,zero,81104aec <bFeebSetBufferSize+0xc4>
		switch (ucBufferSide) {
81104a74:	e0bfff03 	ldbu	r2,-4(fp)
81104a78:	10000326 	beq	r2,zero,81104a88 <bFeebSetBufferSize+0x60>
81104a7c:	10800060 	cmpeqi	r2,r2,1
81104a80:	10000c1e 	bne	r2,zero,81104ab4 <bFeebSetBufferSize+0x8c>
81104a84:	00001606 	br	81104ae0 <bFeebSetBufferSize+0xb8>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81104a88:	e0bffe03 	ldbu	r2,-8(fp)
81104a8c:	10bfffc4 	addi	r2,r2,-1
81104a90:	108003cc 	andi	r2,r2,15
81104a94:	e0bffc15 	stw	r2,-16(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
81104a98:	e0bffd17 	ldw	r2,-12(fp)
81104a9c:	10800017 	ldw	r2,0(r2)
81104aa0:	e1bffc17 	ldw	r6,-16(fp)
81104aa4:	01400544 	movi	r5,21
81104aa8:	1009883a 	mov	r4,r2
81104aac:	1104f540 	call	81104f54 <vFeebWriteReg>
					COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81104ab0:	00000d06 	br	81104ae8 <bFeebSetBufferSize+0xc0>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81104ab4:	e0bffe03 	ldbu	r2,-8(fp)
81104ab8:	10bfffc4 	addi	r2,r2,-1
81104abc:	108003cc 	andi	r2,r2,15
81104ac0:	e0bffc15 	stw	r2,-16(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
81104ac4:	e0bffd17 	ldw	r2,-12(fp)
81104ac8:	10800017 	ldw	r2,0(r2)
81104acc:	e1bffc17 	ldw	r6,-16(fp)
81104ad0:	01400504 	movi	r5,20
81104ad4:	1009883a 	mov	r4,r2
81104ad8:	1104f540 	call	81104f54 <vFeebWriteReg>
					COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81104adc:	00000206 	br	81104ae8 <bFeebSetBufferSize+0xc0>
		default:
			bStatus = FALSE;
81104ae0:	e03ffb15 	stw	zero,-20(fp)
			break;
81104ae4:	0001883a 	nop
		}
	} else {
81104ae8:	00000106 	br	81104af0 <bFeebSetBufferSize+0xc8>
		bStatus = FALSE;
81104aec:	e03ffb15 	stw	zero,-20(fp)
	}

	return bStatus;
81104af0:	e0bffb17 	ldw	r2,-20(fp)
}
81104af4:	e037883a 	mov	sp,fp
81104af8:	dfc00117 	ldw	ra,4(sp)
81104afc:	df000017 	ldw	fp,0(sp)
81104b00:	dec00204 	addi	sp,sp,8
81104b04:	f800283a 	ret

81104b08 <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
81104b08:	defffb04 	addi	sp,sp,-20
81104b0c:	de00012e 	bgeu	sp,et,81104b14 <bFeebSetWindowing+0xc>
81104b10:	003b68fa 	trap	3
81104b14:	dfc00415 	stw	ra,16(sp)
81104b18:	df000315 	stw	fp,12(sp)
81104b1c:	df000304 	addi	fp,sp,12
81104b20:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104b24:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104b28:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104b2c:	e0bfff17 	ldw	r2,-4(fp)
81104b30:	10001926 	beq	r2,zero,81104b98 <bFeebSetWindowing+0x90>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104b34:	e0bfff17 	ldw	r2,-4(fp)
81104b38:	10800017 	ldw	r2,0(r2)
81104b3c:	01400084 	movi	r5,2
81104b40:	1009883a 	mov	r4,r2
81104b44:	1104fa80 	call	81104fa8 <uliFeebReadReg>
81104b48:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (pxFeebCh->xWindowingConfig.bMasking) {
81104b4c:	e0bfff17 	ldw	r2,-4(fp)
81104b50:	10800117 	ldw	r2,4(r2)
81104b54:	10000426 	beq	r2,zero,81104b68 <bFeebSetWindowing+0x60>
			uliReg |= COMM_FEE_MASKING_EN_MSK;
81104b58:	e0bffe17 	ldw	r2,-8(fp)
81104b5c:	10800214 	ori	r2,r2,8
81104b60:	e0bffe15 	stw	r2,-8(fp)
81104b64:	00000406 	br	81104b78 <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_FEE_MASKING_EN_MSK);
81104b68:	e0fffe17 	ldw	r3,-8(fp)
81104b6c:	00bffdc4 	movi	r2,-9
81104b70:	1884703a 	and	r2,r3,r2
81104b74:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81104b78:	e0bfff17 	ldw	r2,-4(fp)
81104b7c:	10800017 	ldw	r2,0(r2)
81104b80:	e1bffe17 	ldw	r6,-8(fp)
81104b84:	01400084 	movi	r5,2
81104b88:	1009883a 	mov	r4,r2
81104b8c:	1104f540 	call	81104f54 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81104b90:	00800044 	movi	r2,1
81104b94:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104b98:	e0bffd17 	ldw	r2,-12(fp)
}
81104b9c:	e037883a 	mov	sp,fp
81104ba0:	dfc00117 	ldw	ra,4(sp)
81104ba4:	df000017 	ldw	fp,0(sp)
81104ba8:	dec00204 	addi	sp,sp,8
81104bac:	f800283a 	ret

81104bb0 <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
81104bb0:	defffb04 	addi	sp,sp,-20
81104bb4:	de00012e 	bgeu	sp,et,81104bbc <bFeebGetWindowing+0xc>
81104bb8:	003b68fa 	trap	3
81104bbc:	dfc00415 	stw	ra,16(sp)
81104bc0:	df000315 	stw	fp,12(sp)
81104bc4:	df000304 	addi	fp,sp,12
81104bc8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104bcc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104bd0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104bd4:	e0bfff17 	ldw	r2,-4(fp)
81104bd8:	10001126 	beq	r2,zero,81104c20 <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104bdc:	e0bfff17 	ldw	r2,-4(fp)
81104be0:	10800017 	ldw	r2,0(r2)
81104be4:	01400084 	movi	r5,2
81104be8:	1009883a 	mov	r4,r2
81104bec:	1104fa80 	call	81104fa8 <uliFeebReadReg>
81104bf0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (uliReg & COMM_FEE_MASKING_EN_MSK) {
81104bf4:	e0bffe17 	ldw	r2,-8(fp)
81104bf8:	1080020c 	andi	r2,r2,8
81104bfc:	10000426 	beq	r2,zero,81104c10 <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
81104c00:	e0bfff17 	ldw	r2,-4(fp)
81104c04:	00c00044 	movi	r3,1
81104c08:	10c00115 	stw	r3,4(r2)
81104c0c:	00000206 	br	81104c18 <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
81104c10:	e0bfff17 	ldw	r2,-4(fp)
81104c14:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
81104c18:	00800044 	movi	r2,1
81104c1c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104c20:	e0bffd17 	ldw	r2,-12(fp)
}
81104c24:	e037883a 	mov	sp,fp
81104c28:	dfc00117 	ldw	ra,4(sp)
81104c2c:	df000017 	ldw	fp,0(sp)
81104c30:	dec00204 	addi	sp,sp,8
81104c34:	f800283a 	ret

81104c38 <bFeebStartCh>:

bool bFeebStartCh(TFeebChannel *pxFeebCh) {
81104c38:	defffb04 	addi	sp,sp,-20
81104c3c:	de00012e 	bgeu	sp,et,81104c44 <bFeebStartCh+0xc>
81104c40:	003b68fa 	trap	3
81104c44:	dfc00415 	stw	ra,16(sp)
81104c48:	df000315 	stw	fp,12(sp)
81104c4c:	df000304 	addi	fp,sp,12
81104c50:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104c54:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104c58:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104c5c:	e0bfff17 	ldw	r2,-4(fp)
81104c60:	10001126 	beq	r2,zero,81104ca8 <bFeebStartCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104c64:	e0bfff17 	ldw	r2,-4(fp)
81104c68:	10800017 	ldw	r2,0(r2)
81104c6c:	01400084 	movi	r5,2
81104c70:	1009883a 	mov	r4,r2
81104c74:	1104fa80 	call	81104fa8 <uliFeebReadReg>
81104c78:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_START_MSK;
81104c7c:	e0bffe17 	ldw	r2,-8(fp)
81104c80:	10800114 	ori	r2,r2,4
81104c84:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81104c88:	e0bfff17 	ldw	r2,-4(fp)
81104c8c:	10800017 	ldw	r2,0(r2)
81104c90:	e1bffe17 	ldw	r6,-8(fp)
81104c94:	01400084 	movi	r5,2
81104c98:	1009883a 	mov	r4,r2
81104c9c:	1104f540 	call	81104f54 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81104ca0:	00800044 	movi	r2,1
81104ca4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104ca8:	e0bffd17 	ldw	r2,-12(fp)
}
81104cac:	e037883a 	mov	sp,fp
81104cb0:	dfc00117 	ldw	ra,4(sp)
81104cb4:	df000017 	ldw	fp,0(sp)
81104cb8:	dec00204 	addi	sp,sp,8
81104cbc:	f800283a 	ret

81104cc0 <bFeebStopCh>:

bool bFeebStopCh(TFeebChannel *pxFeebCh) {
81104cc0:	defffb04 	addi	sp,sp,-20
81104cc4:	de00012e 	bgeu	sp,et,81104ccc <bFeebStopCh+0xc>
81104cc8:	003b68fa 	trap	3
81104ccc:	dfc00415 	stw	ra,16(sp)
81104cd0:	df000315 	stw	fp,12(sp)
81104cd4:	df000304 	addi	fp,sp,12
81104cd8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104cdc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104ce0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104ce4:	e0bfff17 	ldw	r2,-4(fp)
81104ce8:	10001126 	beq	r2,zero,81104d30 <bFeebStopCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104cec:	e0bfff17 	ldw	r2,-4(fp)
81104cf0:	10800017 	ldw	r2,0(r2)
81104cf4:	01400084 	movi	r5,2
81104cf8:	1009883a 	mov	r4,r2
81104cfc:	1104fa80 	call	81104fa8 <uliFeebReadReg>
81104d00:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_STOP_MSK;
81104d04:	e0bffe17 	ldw	r2,-8(fp)
81104d08:	10800094 	ori	r2,r2,2
81104d0c:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81104d10:	e0bfff17 	ldw	r2,-4(fp)
81104d14:	10800017 	ldw	r2,0(r2)
81104d18:	e1bffe17 	ldw	r6,-8(fp)
81104d1c:	01400084 	movi	r5,2
81104d20:	1009883a 	mov	r4,r2
81104d24:	1104f540 	call	81104f54 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81104d28:	00800044 	movi	r2,1
81104d2c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104d30:	e0bffd17 	ldw	r2,-12(fp)
}
81104d34:	e037883a 	mov	sp,fp
81104d38:	dfc00117 	ldw	ra,4(sp)
81104d3c:	df000017 	ldw	fp,0(sp)
81104d40:	dec00204 	addi	sp,sp,8
81104d44:	f800283a 	ret

81104d48 <bFeebClrCh>:

bool bFeebClrCh(TFeebChannel *pxFeebCh) {
81104d48:	defffb04 	addi	sp,sp,-20
81104d4c:	de00012e 	bgeu	sp,et,81104d54 <bFeebClrCh+0xc>
81104d50:	003b68fa 	trap	3
81104d54:	dfc00415 	stw	ra,16(sp)
81104d58:	df000315 	stw	fp,12(sp)
81104d5c:	df000304 	addi	fp,sp,12
81104d60:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104d64:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104d68:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81104d6c:	e0bfff17 	ldw	r2,-4(fp)
81104d70:	10001126 	beq	r2,zero,81104db8 <bFeebClrCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81104d74:	e0bfff17 	ldw	r2,-4(fp)
81104d78:	10800017 	ldw	r2,0(r2)
81104d7c:	01400084 	movi	r5,2
81104d80:	1009883a 	mov	r4,r2
81104d84:	1104fa80 	call	81104fa8 <uliFeebReadReg>
81104d88:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_CLR_MSK;
81104d8c:	e0bffe17 	ldw	r2,-8(fp)
81104d90:	10800054 	ori	r2,r2,1
81104d94:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81104d98:	e0bfff17 	ldw	r2,-4(fp)
81104d9c:	10800017 	ldw	r2,0(r2)
81104da0:	e1bffe17 	ldw	r6,-8(fp)
81104da4:	01400084 	movi	r5,2
81104da8:	1009883a 	mov	r4,r2
81104dac:	1104f540 	call	81104f54 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81104db0:	00800044 	movi	r2,1
81104db4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104db8:	e0bffd17 	ldw	r2,-12(fp)
}
81104dbc:	e037883a 	mov	sp,fp
81104dc0:	dfc00117 	ldw	ra,4(sp)
81104dc4:	df000017 	ldw	fp,0(sp)
81104dc8:	dec00204 	addi	sp,sp,8
81104dcc:	f800283a 	ret

81104dd0 <bFeebInitCh>:

bool bFeebInitCh(TFeebChannel *pxFeebCh, alt_u8 ucCommCh) {
81104dd0:	defffb04 	addi	sp,sp,-20
81104dd4:	de00012e 	bgeu	sp,et,81104ddc <bFeebInitCh+0xc>
81104dd8:	003b68fa 	trap	3
81104ddc:	dfc00415 	stw	ra,16(sp)
81104de0:	df000315 	stw	fp,12(sp)
81104de4:	df000304 	addi	fp,sp,12
81104de8:	e13ffe15 	stw	r4,-8(fp)
81104dec:	2805883a 	mov	r2,r5
81104df0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81104df4:	e03ffd15 	stw	zero,-12(fp)

	if (pxFeebCh != NULL) {
81104df8:	e0bffe17 	ldw	r2,-8(fp)
81104dfc:	10004f26 	beq	r2,zero,81104f3c <bFeebInitCh+0x16c>
		bStatus = TRUE;
81104e00:	00800044 	movi	r2,1
81104e04:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81104e08:	e0bfff03 	ldbu	r2,-4(fp)
81104e0c:	10c00228 	cmpgeui	r3,r2,8
81104e10:	1800361e 	bne	r3,zero,81104eec <bFeebInitCh+0x11c>
81104e14:	100690ba 	slli	r3,r2,2
81104e18:	00a04434 	movhi	r2,33040
81104e1c:	10938b04 	addi	r2,r2,20012
81104e20:	1885883a 	add	r2,r3,r2
81104e24:	10800017 	ldw	r2,0(r2)
81104e28:	1000683a 	jmp	r2
81104e2c:	81104e4c 	andi	r4,r16,16697
81104e30:	81104e60 	cmpeqi	r4,r16,16697
81104e34:	81104e74 	orhi	r4,r16,16697
81104e38:	81104e88 	cmpgei	r4,r16,16698
81104e3c:	81104e9c 	xori	r4,r16,16698
81104e40:	81104eb0 	cmpltui	r4,r16,16698
81104e44:	81104ec4 	addi	r4,r16,16699
81104e48:	81104ed8 	cmpnei	r4,r16,16699
		case eCommSpwCh1:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81104e4c:	e0fffe17 	ldw	r3,-8(fp)
81104e50:	00a04834 	movhi	r2,33056
81104e54:	108b0004 	addi	r2,r2,11264
81104e58:	18800015 	stw	r2,0(r3)
			break;
81104e5c:	00002506 	br	81104ef4 <bFeebInitCh+0x124>
		case eCommSpwCh2:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104e60:	e0fffe17 	ldw	r3,-8(fp)
81104e64:	00a04834 	movhi	r2,33056
81104e68:	108a0004 	addi	r2,r2,10240
81104e6c:	18800015 	stw	r2,0(r3)
			break;
81104e70:	00002006 	br	81104ef4 <bFeebInitCh+0x124>
		case eCommSpwCh3:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81104e74:	e0fffe17 	ldw	r3,-8(fp)
81104e78:	00a04834 	movhi	r2,33056
81104e7c:	108b0004 	addi	r2,r2,11264
81104e80:	18800015 	stw	r2,0(r3)
			break;
81104e84:	00001b06 	br	81104ef4 <bFeebInitCh+0x124>
		case eCommSpwCh4:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104e88:	e0fffe17 	ldw	r3,-8(fp)
81104e8c:	00a04834 	movhi	r2,33056
81104e90:	108a0004 	addi	r2,r2,10240
81104e94:	18800015 	stw	r2,0(r3)
			break;
81104e98:	00001606 	br	81104ef4 <bFeebInitCh+0x124>
		case eCommSpwCh5:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104e9c:	e0fffe17 	ldw	r3,-8(fp)
81104ea0:	00a04834 	movhi	r2,33056
81104ea4:	108b0004 	addi	r2,r2,11264
81104ea8:	18800015 	stw	r2,0(r3)
			break;
81104eac:	00001106 	br	81104ef4 <bFeebInitCh+0x124>
		case eCommSpwCh6:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104eb0:	e0fffe17 	ldw	r3,-8(fp)
81104eb4:	00a04834 	movhi	r2,33056
81104eb8:	108a0004 	addi	r2,r2,10240
81104ebc:	18800015 	stw	r2,0(r3)
			break;
81104ec0:	00000c06 	br	81104ef4 <bFeebInitCh+0x124>
		case eCommSpwCh7:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104ec4:	e0fffe17 	ldw	r3,-8(fp)
81104ec8:	00a04834 	movhi	r2,33056
81104ecc:	108b0004 	addi	r2,r2,11264
81104ed0:	18800015 	stw	r2,0(r3)
			break;
81104ed4:	00000706 	br	81104ef4 <bFeebInitCh+0x124>
		case eCommSpwCh8:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104ed8:	e0fffe17 	ldw	r3,-8(fp)
81104edc:	00a04834 	movhi	r2,33056
81104ee0:	108a0004 	addi	r2,r2,10240
81104ee4:	18800015 	stw	r2,0(r3)
			break;
81104ee8:	00000206 	br	81104ef4 <bFeebInitCh+0x124>
		default:
			bStatus = FALSE;
81104eec:	e03ffd15 	stw	zero,-12(fp)
			break;
81104ef0:	0001883a 	nop
		}

		if (bStatus) {
81104ef4:	e0bffd17 	ldw	r2,-12(fp)
81104ef8:	10001026 	beq	r2,zero,81104f3c <bFeebInitCh+0x16c>
			if (!bFeebGetIrqControl(pxFeebCh)) {
81104efc:	e13ffe17 	ldw	r4,-8(fp)
81104f00:	11045580 	call	81104558 <bFeebGetIrqControl>
81104f04:	1000011e 	bne	r2,zero,81104f0c <bFeebInitCh+0x13c>
				bStatus = FALSE;
81104f08:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetIrqFlags(pxFeebCh)) {
81104f0c:	e13ffe17 	ldw	r4,-8(fp)
81104f10:	11046040 	call	81104604 <bFeebGetIrqFlags>
81104f14:	1000011e 	bne	r2,zero,81104f1c <bFeebInitCh+0x14c>
				bStatus = FALSE;
81104f18:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetBuffersStatus(pxFeebCh)) {
81104f1c:	e13ffe17 	ldw	r4,-8(fp)
81104f20:	110468c0 	call	8110468c <bFeebGetBuffersStatus>
81104f24:	1000011e 	bne	r2,zero,81104f2c <bFeebInitCh+0x15c>
				bStatus = FALSE;
81104f28:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetWindowing(pxFeebCh)) {
81104f2c:	e13ffe17 	ldw	r4,-8(fp)
81104f30:	1104bb00 	call	81104bb0 <bFeebGetWindowing>
81104f34:	1000011e 	bne	r2,zero,81104f3c <bFeebInitCh+0x16c>
				bStatus = FALSE;
81104f38:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81104f3c:	e0bffd17 	ldw	r2,-12(fp)
}
81104f40:	e037883a 	mov	sp,fp
81104f44:	dfc00117 	ldw	ra,4(sp)
81104f48:	df000017 	ldw	fp,0(sp)
81104f4c:	dec00204 	addi	sp,sp,8
81104f50:	f800283a 	ret

81104f54 <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104f54:	defffc04 	addi	sp,sp,-16
81104f58:	de00012e 	bgeu	sp,et,81104f60 <vFeebWriteReg+0xc>
81104f5c:	003b68fa 	trap	3
81104f60:	df000315 	stw	fp,12(sp)
81104f64:	df000304 	addi	fp,sp,12
81104f68:	e13ffd15 	stw	r4,-12(fp)
81104f6c:	e17ffe15 	stw	r5,-8(fp)
81104f70:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104f74:	e0bffe17 	ldw	r2,-8(fp)
81104f78:	1085883a 	add	r2,r2,r2
81104f7c:	1085883a 	add	r2,r2,r2
81104f80:	1007883a 	mov	r3,r2
81104f84:	e0bffd17 	ldw	r2,-12(fp)
81104f88:	10c5883a 	add	r2,r2,r3
81104f8c:	e0ffff17 	ldw	r3,-4(fp)
81104f90:	10c00015 	stw	r3,0(r2)
}
81104f94:	0001883a 	nop
81104f98:	e037883a 	mov	sp,fp
81104f9c:	df000017 	ldw	fp,0(sp)
81104fa0:	dec00104 	addi	sp,sp,4
81104fa4:	f800283a 	ret

81104fa8 <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81104fa8:	defffc04 	addi	sp,sp,-16
81104fac:	de00012e 	bgeu	sp,et,81104fb4 <uliFeebReadReg+0xc>
81104fb0:	003b68fa 	trap	3
81104fb4:	df000315 	stw	fp,12(sp)
81104fb8:	df000304 	addi	fp,sp,12
81104fbc:	e13ffe15 	stw	r4,-8(fp)
81104fc0:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81104fc4:	e0bfff17 	ldw	r2,-4(fp)
81104fc8:	1085883a 	add	r2,r2,r2
81104fcc:	1085883a 	add	r2,r2,r2
81104fd0:	1007883a 	mov	r3,r2
81104fd4:	e0bffe17 	ldw	r2,-8(fp)
81104fd8:	10c5883a 	add	r2,r2,r3
81104fdc:	10800017 	ldw	r2,0(r2)
81104fe0:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81104fe4:	e0bffd17 	ldw	r2,-12(fp)
}
81104fe8:	e037883a 	mov	sp,fp
81104fec:	df000017 	ldw	fp,0(sp)
81104ff0:	dec00104 	addi	sp,sp,4
81104ff4:	f800283a 	ret

81104ff8 <vRmapCh1HandleIrq>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
/* todo:Trigger not working right */
void vRmapCh1HandleIrq(void* pvContext) {
81104ff8:	defffa04 	addi	sp,sp,-24
81104ffc:	de00012e 	bgeu	sp,et,81105004 <vRmapCh1HandleIrq+0xc>
81105000:	003b68fa 	trap	3
81105004:	dfc00515 	stw	ra,20(sp)
81105008:	df000415 	stw	fp,16(sp)
8110500c:	df000404 	addi	fp,sp,16
81105010:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105014:	e0bfff17 	ldw	r2,-4(fp)
81105018:	e0bffc15 	stw	r2,-16(fp)

#if DEBUG_ON
	fprintf(fp,"IRQ RMAP.\n");
#endif

	ucADDRReg = (unsigned char)uliRmapCh1WriteCmdAddress();
8110501c:	11057700 	call	81105770 <uliRmapCh1WriteCmdAddress>
81105020:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
81105024:	00800444 	movi	r2,17
81105028:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
8110502c:	00bffc04 	movi	r2,-16
81105030:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
81105034:	e0bffd03 	ldbu	r2,-12(fp)
81105038:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
8110503c:	e03ffe05 	stb	zero,-8(fp)

#if DEBUG_ON
	fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
81105040:	d0a06917 	ldw	r2,-32348(gp)
81105044:	e0fffe17 	ldw	r3,-8(fp)
81105048:	180b883a 	mov	r5,r3
8110504c:	1009883a 	mov	r4,r2
81105050:	1136bf80 	call	81136bf8 <OSQPostFront>
81105054:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105058:	e0bffd43 	ldbu	r2,-11(fp)
8110505c:	10000226 	beq	r2,zero,81105068 <vRmapCh1HandleIrq+0x70>
		vFailSendRMAPFromIRQ( 0 );
81105060:	0009883a 	mov	r4,zero
81105064:	11172340 	call	81117234 <vFailSendRMAPFromIRQ>
	}

	vRmapCh1IrqFlagClrWriteCmd();
81105068:	11052900 	call	81105290 <vRmapCh1IrqFlagClrWriteCmd>
}
8110506c:	0001883a 	nop
81105070:	e037883a 	mov	sp,fp
81105074:	dfc00117 	ldw	ra,4(sp)
81105078:	df000017 	ldw	fp,0(sp)
8110507c:	dec00204 	addi	sp,sp,8
81105080:	f800283a 	ret

81105084 <vRmapCh2HandleIrq>:

void vRmapCh2HandleIrq(void* pvContext) {
81105084:	defffa04 	addi	sp,sp,-24
81105088:	de00012e 	bgeu	sp,et,81105090 <vRmapCh2HandleIrq+0xc>
8110508c:	003b68fa 	trap	3
81105090:	dfc00515 	stw	ra,20(sp)
81105094:	df000415 	stw	fp,16(sp)
81105098:	df000404 	addi	fp,sp,16
8110509c:	e13fff15 	stw	r4,-4(fp)
	INT8U ucADDRReg;
	INT32U ucValueReg;
	INT32U ucValueMasked;
	INT8U error_codel;

	volatile int* pviHoldContext = (volatile int*) pvContext;
811050a0:	e0bfff17 	ldw	r2,-4(fp)
811050a4:	e0bffc15 	stw	r2,-16(fp)

	ucADDRReg = (unsigned char)uliRmapCh2WriteCmdAddress();
811050a8:	11057c00 	call	811057c0 <uliRmapCh2WriteCmdAddress>
811050ac:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
811050b0:	00800444 	movi	r2,17
811050b4:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
811050b8:	00bffc04 	movi	r2,-16
811050bc:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
811050c0:	e0bffd03 	ldbu	r2,-12(fp)
811050c4:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
811050c8:	e03ffe05 	stb	zero,-8(fp)

#if DEBUG_ON
	fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord); /*todo: Fee number Hard Coded*/
811050cc:	d0a06917 	ldw	r2,-32348(gp)
811050d0:	e0fffe17 	ldw	r3,-8(fp)
811050d4:	180b883a 	mov	r5,r3
811050d8:	1009883a 	mov	r4,r2
811050dc:	1136bf80 	call	81136bf8 <OSQPostFront>
811050e0:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
811050e4:	e0bffd43 	ldbu	r2,-11(fp)
811050e8:	10000226 	beq	r2,zero,811050f4 <vRmapCh2HandleIrq+0x70>
		vFailSendRMAPFromIRQ( 0 );
811050ec:	0009883a 	mov	r4,zero
811050f0:	11172340 	call	81117234 <vFailSendRMAPFromIRQ>
	}


	vRmapCh2IrqFlagClrWriteCmd();
811050f4:	11052d40 	call	811052d4 <vRmapCh2IrqFlagClrWriteCmd>
}
811050f8:	0001883a 	nop
811050fc:	e037883a 	mov	sp,fp
81105100:	dfc00117 	ldw	ra,4(sp)
81105104:	df000017 	ldw	fp,0(sp)
81105108:	dec00204 	addi	sp,sp,8
8110510c:	f800283a 	ret

81105110 <vRmapCh3HandleIrq>:

void vRmapCh3HandleIrq(void* pvContext) {
81105110:	defffc04 	addi	sp,sp,-16
81105114:	de00012e 	bgeu	sp,et,8110511c <vRmapCh3HandleIrq+0xc>
81105118:	003b68fa 	trap	3
8110511c:	dfc00315 	stw	ra,12(sp)
81105120:	df000215 	stw	fp,8(sp)
81105124:	df000204 	addi	fp,sp,8
81105128:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110512c:	e0bfff17 	ldw	r2,-4(fp)
81105130:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh3IrqFlagClrWriteCmd();
81105134:	11053180 	call	81105318 <vRmapCh3IrqFlagClrWriteCmd>
}
81105138:	0001883a 	nop
8110513c:	e037883a 	mov	sp,fp
81105140:	dfc00117 	ldw	ra,4(sp)
81105144:	df000017 	ldw	fp,0(sp)
81105148:	dec00204 	addi	sp,sp,8
8110514c:	f800283a 	ret

81105150 <vRmapCh4HandleIrq>:

void vRmapCh4HandleIrq(void* pvContext) {
81105150:	defffc04 	addi	sp,sp,-16
81105154:	de00012e 	bgeu	sp,et,8110515c <vRmapCh4HandleIrq+0xc>
81105158:	003b68fa 	trap	3
8110515c:	dfc00315 	stw	ra,12(sp)
81105160:	df000215 	stw	fp,8(sp)
81105164:	df000204 	addi	fp,sp,8
81105168:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110516c:	e0bfff17 	ldw	r2,-4(fp)
81105170:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh4IrqFlagClrWriteCmd();
81105174:	110535c0 	call	8110535c <vRmapCh4IrqFlagClrWriteCmd>
}
81105178:	0001883a 	nop
8110517c:	e037883a 	mov	sp,fp
81105180:	dfc00117 	ldw	ra,4(sp)
81105184:	df000017 	ldw	fp,0(sp)
81105188:	dec00204 	addi	sp,sp,8
8110518c:	f800283a 	ret

81105190 <vRmapCh5HandleIrq>:

void vRmapCh5HandleIrq(void* pvContext) {
81105190:	defffc04 	addi	sp,sp,-16
81105194:	de00012e 	bgeu	sp,et,8110519c <vRmapCh5HandleIrq+0xc>
81105198:	003b68fa 	trap	3
8110519c:	dfc00315 	stw	ra,12(sp)
811051a0:	df000215 	stw	fp,8(sp)
811051a4:	df000204 	addi	fp,sp,8
811051a8:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811051ac:	e0bfff17 	ldw	r2,-4(fp)
811051b0:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh5IrqFlagClrWriteCmd();
811051b4:	11053a00 	call	811053a0 <vRmapCh5IrqFlagClrWriteCmd>
}
811051b8:	0001883a 	nop
811051bc:	e037883a 	mov	sp,fp
811051c0:	dfc00117 	ldw	ra,4(sp)
811051c4:	df000017 	ldw	fp,0(sp)
811051c8:	dec00204 	addi	sp,sp,8
811051cc:	f800283a 	ret

811051d0 <vRmapCh6HandleIrq>:

void vRmapCh6HandleIrq(void* pvContext) {
811051d0:	defffc04 	addi	sp,sp,-16
811051d4:	de00012e 	bgeu	sp,et,811051dc <vRmapCh6HandleIrq+0xc>
811051d8:	003b68fa 	trap	3
811051dc:	dfc00315 	stw	ra,12(sp)
811051e0:	df000215 	stw	fp,8(sp)
811051e4:	df000204 	addi	fp,sp,8
811051e8:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811051ec:	e0bfff17 	ldw	r2,-4(fp)
811051f0:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vRmapCh6IrqFlagClrWriteCmd();
811051f4:	11053e40 	call	811053e4 <vRmapCh6IrqFlagClrWriteCmd>
}
811051f8:	0001883a 	nop
811051fc:	e037883a 	mov	sp,fp
81105200:	dfc00117 	ldw	ra,4(sp)
81105204:	df000017 	ldw	fp,0(sp)
81105208:	dec00204 	addi	sp,sp,8
8110520c:	f800283a 	ret

81105210 <vRmapCh7HandleIrq>:

void vRmapCh7HandleIrq(void* pvContext) {
81105210:	defffc04 	addi	sp,sp,-16
81105214:	de00012e 	bgeu	sp,et,8110521c <vRmapCh7HandleIrq+0xc>
81105218:	003b68fa 	trap	3
8110521c:	dfc00315 	stw	ra,12(sp)
81105220:	df000215 	stw	fp,8(sp)
81105224:	df000204 	addi	fp,sp,8
81105228:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110522c:	e0bfff17 	ldw	r2,-4(fp)
81105230:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh7IrqFlagClrWriteCmd();
81105234:	11054280 	call	81105428 <vRmapCh7IrqFlagClrWriteCmd>
}
81105238:	0001883a 	nop
8110523c:	e037883a 	mov	sp,fp
81105240:	dfc00117 	ldw	ra,4(sp)
81105244:	df000017 	ldw	fp,0(sp)
81105248:	dec00204 	addi	sp,sp,8
8110524c:	f800283a 	ret

81105250 <vRmapCh8HandleIrq>:

void vRmapCh8HandleIrq(void* pvContext) {
81105250:	defffc04 	addi	sp,sp,-16
81105254:	de00012e 	bgeu	sp,et,8110525c <vRmapCh8HandleIrq+0xc>
81105258:	003b68fa 	trap	3
8110525c:	dfc00315 	stw	ra,12(sp)
81105260:	df000215 	stw	fp,8(sp)
81105264:	df000204 	addi	fp,sp,8
81105268:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110526c:	e0bfff17 	ldw	r2,-4(fp)
81105270:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh8IrqFlagClrWriteCmd();
81105274:	110546c0 	call	8110546c <vRmapCh8IrqFlagClrWriteCmd>
}
81105278:	0001883a 	nop
8110527c:	e037883a 	mov	sp,fp
81105280:	dfc00117 	ldw	ra,4(sp)
81105284:	df000017 	ldw	fp,0(sp)
81105288:	dec00204 	addi	sp,sp,8
8110528c:	f800283a 	ret

81105290 <vRmapCh1IrqFlagClrWriteCmd>:

void vRmapCh1IrqFlagClrWriteCmd(void) {
81105290:	defffe04 	addi	sp,sp,-8
81105294:	de00012e 	bgeu	sp,et,8110529c <vRmapCh1IrqFlagClrWriteCmd+0xc>
81105298:	003b68fa 	trap	3
8110529c:	dfc00115 	stw	ra,4(sp)
811052a0:	df000015 	stw	fp,0(sp)
811052a4:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811052a8:	01800044 	movi	r6,1
811052ac:	014004c4 	movi	r5,19
811052b0:	01204834 	movhi	r4,33056
811052b4:	210b0004 	addi	r4,r4,11264
811052b8:	11081580 	call	81108158 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811052bc:	0001883a 	nop
811052c0:	e037883a 	mov	sp,fp
811052c4:	dfc00117 	ldw	ra,4(sp)
811052c8:	df000017 	ldw	fp,0(sp)
811052cc:	dec00204 	addi	sp,sp,8
811052d0:	f800283a 	ret

811052d4 <vRmapCh2IrqFlagClrWriteCmd>:

void vRmapCh2IrqFlagClrWriteCmd(void) {
811052d4:	defffe04 	addi	sp,sp,-8
811052d8:	de00012e 	bgeu	sp,et,811052e0 <vRmapCh2IrqFlagClrWriteCmd+0xc>
811052dc:	003b68fa 	trap	3
811052e0:	dfc00115 	stw	ra,4(sp)
811052e4:	df000015 	stw	fp,0(sp)
811052e8:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811052ec:	01800044 	movi	r6,1
811052f0:	014004c4 	movi	r5,19
811052f4:	01204834 	movhi	r4,33056
811052f8:	210a0004 	addi	r4,r4,10240
811052fc:	11081580 	call	81108158 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81105300:	0001883a 	nop
81105304:	e037883a 	mov	sp,fp
81105308:	dfc00117 	ldw	ra,4(sp)
8110530c:	df000017 	ldw	fp,0(sp)
81105310:	dec00204 	addi	sp,sp,8
81105314:	f800283a 	ret

81105318 <vRmapCh3IrqFlagClrWriteCmd>:

void vRmapCh3IrqFlagClrWriteCmd(void) {
81105318:	defffe04 	addi	sp,sp,-8
8110531c:	de00012e 	bgeu	sp,et,81105324 <vRmapCh3IrqFlagClrWriteCmd+0xc>
81105320:	003b68fa 	trap	3
81105324:	dfc00115 	stw	ra,4(sp)
81105328:	df000015 	stw	fp,0(sp)
8110532c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105330:	01800044 	movi	r6,1
81105334:	014004c4 	movi	r5,19
81105338:	01204834 	movhi	r4,33056
8110533c:	210b0004 	addi	r4,r4,11264
81105340:	11081580 	call	81108158 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81105344:	0001883a 	nop
81105348:	e037883a 	mov	sp,fp
8110534c:	dfc00117 	ldw	ra,4(sp)
81105350:	df000017 	ldw	fp,0(sp)
81105354:	dec00204 	addi	sp,sp,8
81105358:	f800283a 	ret

8110535c <vRmapCh4IrqFlagClrWriteCmd>:

void vRmapCh4IrqFlagClrWriteCmd(void) {
8110535c:	defffe04 	addi	sp,sp,-8
81105360:	de00012e 	bgeu	sp,et,81105368 <vRmapCh4IrqFlagClrWriteCmd+0xc>
81105364:	003b68fa 	trap	3
81105368:	dfc00115 	stw	ra,4(sp)
8110536c:	df000015 	stw	fp,0(sp)
81105370:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105374:	01800044 	movi	r6,1
81105378:	014004c4 	movi	r5,19
8110537c:	01204834 	movhi	r4,33056
81105380:	210a0004 	addi	r4,r4,10240
81105384:	11081580 	call	81108158 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81105388:	0001883a 	nop
8110538c:	e037883a 	mov	sp,fp
81105390:	dfc00117 	ldw	ra,4(sp)
81105394:	df000017 	ldw	fp,0(sp)
81105398:	dec00204 	addi	sp,sp,8
8110539c:	f800283a 	ret

811053a0 <vRmapCh5IrqFlagClrWriteCmd>:

void vRmapCh5IrqFlagClrWriteCmd(void) {
811053a0:	defffe04 	addi	sp,sp,-8
811053a4:	de00012e 	bgeu	sp,et,811053ac <vRmapCh5IrqFlagClrWriteCmd+0xc>
811053a8:	003b68fa 	trap	3
811053ac:	dfc00115 	stw	ra,4(sp)
811053b0:	df000015 	stw	fp,0(sp)
811053b4:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811053b8:	01800044 	movi	r6,1
811053bc:	014004c4 	movi	r5,19
811053c0:	01204834 	movhi	r4,33056
811053c4:	210b0004 	addi	r4,r4,11264
811053c8:	11081580 	call	81108158 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811053cc:	0001883a 	nop
811053d0:	e037883a 	mov	sp,fp
811053d4:	dfc00117 	ldw	ra,4(sp)
811053d8:	df000017 	ldw	fp,0(sp)
811053dc:	dec00204 	addi	sp,sp,8
811053e0:	f800283a 	ret

811053e4 <vRmapCh6IrqFlagClrWriteCmd>:

void vRmapCh6IrqFlagClrWriteCmd(void) {
811053e4:	defffe04 	addi	sp,sp,-8
811053e8:	de00012e 	bgeu	sp,et,811053f0 <vRmapCh6IrqFlagClrWriteCmd+0xc>
811053ec:	003b68fa 	trap	3
811053f0:	dfc00115 	stw	ra,4(sp)
811053f4:	df000015 	stw	fp,0(sp)
811053f8:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811053fc:	01800044 	movi	r6,1
81105400:	014004c4 	movi	r5,19
81105404:	01204834 	movhi	r4,33056
81105408:	210a0004 	addi	r4,r4,10240
8110540c:	11081580 	call	81108158 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81105410:	0001883a 	nop
81105414:	e037883a 	mov	sp,fp
81105418:	dfc00117 	ldw	ra,4(sp)
8110541c:	df000017 	ldw	fp,0(sp)
81105420:	dec00204 	addi	sp,sp,8
81105424:	f800283a 	ret

81105428 <vRmapCh7IrqFlagClrWriteCmd>:

void vRmapCh7IrqFlagClrWriteCmd(void) {
81105428:	defffe04 	addi	sp,sp,-8
8110542c:	de00012e 	bgeu	sp,et,81105434 <vRmapCh7IrqFlagClrWriteCmd+0xc>
81105430:	003b68fa 	trap	3
81105434:	dfc00115 	stw	ra,4(sp)
81105438:	df000015 	stw	fp,0(sp)
8110543c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105440:	01800044 	movi	r6,1
81105444:	014004c4 	movi	r5,19
81105448:	01204834 	movhi	r4,33056
8110544c:	210b0004 	addi	r4,r4,11264
81105450:	11081580 	call	81108158 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81105454:	0001883a 	nop
81105458:	e037883a 	mov	sp,fp
8110545c:	dfc00117 	ldw	ra,4(sp)
81105460:	df000017 	ldw	fp,0(sp)
81105464:	dec00204 	addi	sp,sp,8
81105468:	f800283a 	ret

8110546c <vRmapCh8IrqFlagClrWriteCmd>:

void vRmapCh8IrqFlagClrWriteCmd(void) {
8110546c:	defffe04 	addi	sp,sp,-8
81105470:	de00012e 	bgeu	sp,et,81105478 <vRmapCh8IrqFlagClrWriteCmd+0xc>
81105474:	003b68fa 	trap	3
81105478:	dfc00115 	stw	ra,4(sp)
8110547c:	df000015 	stw	fp,0(sp)
81105480:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105484:	01800044 	movi	r6,1
81105488:	014004c4 	movi	r5,19
8110548c:	01204834 	movhi	r4,33056
81105490:	210a0004 	addi	r4,r4,10240
81105494:	11081580 	call	81108158 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81105498:	0001883a 	nop
8110549c:	e037883a 	mov	sp,fp
811054a0:	dfc00117 	ldw	ra,4(sp)
811054a4:	df000017 	ldw	fp,0(sp)
811054a8:	dec00204 	addi	sp,sp,8
811054ac:	f800283a 	ret

811054b0 <bRmapCh1IrqFlagWriteCmd>:

bool bRmapCh1IrqFlagWriteCmd(void) {
811054b0:	defffd04 	addi	sp,sp,-12
811054b4:	de00012e 	bgeu	sp,et,811054bc <bRmapCh1IrqFlagWriteCmd+0xc>
811054b8:	003b68fa 	trap	3
811054bc:	dfc00215 	stw	ra,8(sp)
811054c0:	df000115 	stw	fp,4(sp)
811054c4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811054c8:	01400484 	movi	r5,18
811054cc:	01204834 	movhi	r4,33056
811054d0:	210b0004 	addi	r4,r4,11264
811054d4:	11081ac0 	call	811081ac <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811054d8:	1080004c 	andi	r2,r2,1
}

bool bRmapCh1IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811054dc:	10000326 	beq	r2,zero,811054ec <bRmapCh1IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811054e0:	00800044 	movi	r2,1
811054e4:	e0bfff15 	stw	r2,-4(fp)
811054e8:	00000106 	br	811054f0 <bRmapCh1IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811054ec:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811054f0:	e0bfff17 	ldw	r2,-4(fp)
}
811054f4:	e037883a 	mov	sp,fp
811054f8:	dfc00117 	ldw	ra,4(sp)
811054fc:	df000017 	ldw	fp,0(sp)
81105500:	dec00204 	addi	sp,sp,8
81105504:	f800283a 	ret

81105508 <bRmapCh2IrqFlagWriteCmd>:

bool bRmapCh2IrqFlagWriteCmd(void) {
81105508:	defffd04 	addi	sp,sp,-12
8110550c:	de00012e 	bgeu	sp,et,81105514 <bRmapCh2IrqFlagWriteCmd+0xc>
81105510:	003b68fa 	trap	3
81105514:	dfc00215 	stw	ra,8(sp)
81105518:	df000115 	stw	fp,4(sp)
8110551c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105520:	01400484 	movi	r5,18
81105524:	01204834 	movhi	r4,33056
81105528:	210a0004 	addi	r4,r4,10240
8110552c:	11081ac0 	call	811081ac <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81105530:	1080004c 	andi	r2,r2,1
}

bool bRmapCh2IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105534:	10000326 	beq	r2,zero,81105544 <bRmapCh2IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81105538:	00800044 	movi	r2,1
8110553c:	e0bfff15 	stw	r2,-4(fp)
81105540:	00000106 	br	81105548 <bRmapCh2IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81105544:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105548:	e0bfff17 	ldw	r2,-4(fp)
}
8110554c:	e037883a 	mov	sp,fp
81105550:	dfc00117 	ldw	ra,4(sp)
81105554:	df000017 	ldw	fp,0(sp)
81105558:	dec00204 	addi	sp,sp,8
8110555c:	f800283a 	ret

81105560 <bRmapCh3IrqFlagWriteCmd>:

bool bRmapCh3IrqFlagWriteCmd(void) {
81105560:	defffd04 	addi	sp,sp,-12
81105564:	de00012e 	bgeu	sp,et,8110556c <bRmapCh3IrqFlagWriteCmd+0xc>
81105568:	003b68fa 	trap	3
8110556c:	dfc00215 	stw	ra,8(sp)
81105570:	df000115 	stw	fp,4(sp)
81105574:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105578:	01400484 	movi	r5,18
8110557c:	01204834 	movhi	r4,33056
81105580:	210b0004 	addi	r4,r4,11264
81105584:	11081ac0 	call	811081ac <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81105588:	1080004c 	andi	r2,r2,1
}

bool bRmapCh3IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8110558c:	10000326 	beq	r2,zero,8110559c <bRmapCh3IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81105590:	00800044 	movi	r2,1
81105594:	e0bfff15 	stw	r2,-4(fp)
81105598:	00000106 	br	811055a0 <bRmapCh3IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110559c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811055a0:	e0bfff17 	ldw	r2,-4(fp)
}
811055a4:	e037883a 	mov	sp,fp
811055a8:	dfc00117 	ldw	ra,4(sp)
811055ac:	df000017 	ldw	fp,0(sp)
811055b0:	dec00204 	addi	sp,sp,8
811055b4:	f800283a 	ret

811055b8 <bRmapCh4IrqFlagWriteCmd>:

bool bRmapCh4IrqFlagWriteCmd(void) {
811055b8:	defffd04 	addi	sp,sp,-12
811055bc:	de00012e 	bgeu	sp,et,811055c4 <bRmapCh4IrqFlagWriteCmd+0xc>
811055c0:	003b68fa 	trap	3
811055c4:	dfc00215 	stw	ra,8(sp)
811055c8:	df000115 	stw	fp,4(sp)
811055cc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811055d0:	01400484 	movi	r5,18
811055d4:	01204834 	movhi	r4,33056
811055d8:	210a0004 	addi	r4,r4,10240
811055dc:	11081ac0 	call	811081ac <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811055e0:	1080004c 	andi	r2,r2,1
}

bool bRmapCh4IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811055e4:	10000326 	beq	r2,zero,811055f4 <bRmapCh4IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811055e8:	00800044 	movi	r2,1
811055ec:	e0bfff15 	stw	r2,-4(fp)
811055f0:	00000106 	br	811055f8 <bRmapCh4IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811055f4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811055f8:	e0bfff17 	ldw	r2,-4(fp)
}
811055fc:	e037883a 	mov	sp,fp
81105600:	dfc00117 	ldw	ra,4(sp)
81105604:	df000017 	ldw	fp,0(sp)
81105608:	dec00204 	addi	sp,sp,8
8110560c:	f800283a 	ret

81105610 <bRmapCh5IrqFlagWriteCmd>:

bool bRmapCh5IrqFlagWriteCmd(void) {
81105610:	defffd04 	addi	sp,sp,-12
81105614:	de00012e 	bgeu	sp,et,8110561c <bRmapCh5IrqFlagWriteCmd+0xc>
81105618:	003b68fa 	trap	3
8110561c:	dfc00215 	stw	ra,8(sp)
81105620:	df000115 	stw	fp,4(sp)
81105624:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105628:	01400484 	movi	r5,18
8110562c:	01204834 	movhi	r4,33056
81105630:	210b0004 	addi	r4,r4,11264
81105634:	11081ac0 	call	811081ac <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81105638:	1080004c 	andi	r2,r2,1
}

bool bRmapCh5IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
8110563c:	10000326 	beq	r2,zero,8110564c <bRmapCh5IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81105640:	00800044 	movi	r2,1
81105644:	e0bfff15 	stw	r2,-4(fp)
81105648:	00000106 	br	81105650 <bRmapCh5IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110564c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105650:	e0bfff17 	ldw	r2,-4(fp)
}
81105654:	e037883a 	mov	sp,fp
81105658:	dfc00117 	ldw	ra,4(sp)
8110565c:	df000017 	ldw	fp,0(sp)
81105660:	dec00204 	addi	sp,sp,8
81105664:	f800283a 	ret

81105668 <bRmapCh6IrqFlagWriteCmd>:

bool bRmapCh6IrqFlagWriteCmd(void) {
81105668:	defffd04 	addi	sp,sp,-12
8110566c:	de00012e 	bgeu	sp,et,81105674 <bRmapCh6IrqFlagWriteCmd+0xc>
81105670:	003b68fa 	trap	3
81105674:	dfc00215 	stw	ra,8(sp)
81105678:	df000115 	stw	fp,4(sp)
8110567c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105680:	01400484 	movi	r5,18
81105684:	01204834 	movhi	r4,33056
81105688:	210a0004 	addi	r4,r4,10240
8110568c:	11081ac0 	call	811081ac <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81105690:	1080004c 	andi	r2,r2,1
}

bool bRmapCh6IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105694:	10000326 	beq	r2,zero,811056a4 <bRmapCh6IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81105698:	00800044 	movi	r2,1
8110569c:	e0bfff15 	stw	r2,-4(fp)
811056a0:	00000106 	br	811056a8 <bRmapCh6IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811056a4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811056a8:	e0bfff17 	ldw	r2,-4(fp)
}
811056ac:	e037883a 	mov	sp,fp
811056b0:	dfc00117 	ldw	ra,4(sp)
811056b4:	df000017 	ldw	fp,0(sp)
811056b8:	dec00204 	addi	sp,sp,8
811056bc:	f800283a 	ret

811056c0 <bRmapCh7IrqFlagWriteCmd>:

bool bRmapCh7IrqFlagWriteCmd(void) {
811056c0:	defffd04 	addi	sp,sp,-12
811056c4:	de00012e 	bgeu	sp,et,811056cc <bRmapCh7IrqFlagWriteCmd+0xc>
811056c8:	003b68fa 	trap	3
811056cc:	dfc00215 	stw	ra,8(sp)
811056d0:	df000115 	stw	fp,4(sp)
811056d4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811056d8:	01400484 	movi	r5,18
811056dc:	01204834 	movhi	r4,33056
811056e0:	210b0004 	addi	r4,r4,11264
811056e4:	11081ac0 	call	811081ac <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811056e8:	1080004c 	andi	r2,r2,1
}

bool bRmapCh7IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811056ec:	10000326 	beq	r2,zero,811056fc <bRmapCh7IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811056f0:	00800044 	movi	r2,1
811056f4:	e0bfff15 	stw	r2,-4(fp)
811056f8:	00000106 	br	81105700 <bRmapCh7IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811056fc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105700:	e0bfff17 	ldw	r2,-4(fp)
}
81105704:	e037883a 	mov	sp,fp
81105708:	dfc00117 	ldw	ra,4(sp)
8110570c:	df000017 	ldw	fp,0(sp)
81105710:	dec00204 	addi	sp,sp,8
81105714:	f800283a 	ret

81105718 <bRmapCh8IrqFlagWriteCmd>:

bool bRmapCh8IrqFlagWriteCmd(void) {
81105718:	defffd04 	addi	sp,sp,-12
8110571c:	de00012e 	bgeu	sp,et,81105724 <bRmapCh8IrqFlagWriteCmd+0xc>
81105720:	003b68fa 	trap	3
81105724:	dfc00215 	stw	ra,8(sp)
81105728:	df000115 	stw	fp,4(sp)
8110572c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105730:	01400484 	movi	r5,18
81105734:	01204834 	movhi	r4,33056
81105738:	210a0004 	addi	r4,r4,10240
8110573c:	11081ac0 	call	811081ac <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81105740:	1080004c 	andi	r2,r2,1
}

bool bRmapCh8IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105744:	10000326 	beq	r2,zero,81105754 <bRmapCh8IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81105748:	00800044 	movi	r2,1
8110574c:	e0bfff15 	stw	r2,-4(fp)
81105750:	00000106 	br	81105758 <bRmapCh8IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81105754:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105758:	e0bfff17 	ldw	r2,-4(fp)
}
8110575c:	e037883a 	mov	sp,fp
81105760:	dfc00117 	ldw	ra,4(sp)
81105764:	df000017 	ldw	fp,0(sp)
81105768:	dec00204 	addi	sp,sp,8
8110576c:	f800283a 	ret

81105770 <uliRmapCh1WriteCmdAddress>:

alt_u32 uliRmapCh1WriteCmdAddress(void) {
81105770:	defffd04 	addi	sp,sp,-12
81105774:	de00012e 	bgeu	sp,et,8110577c <uliRmapCh1WriteCmdAddress+0xc>
81105778:	003b68fa 	trap	3
8110577c:	dfc00215 	stw	ra,8(sp)
81105780:	df000115 	stw	fp,4(sp)
81105784:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81105788:	01400184 	movi	r5,6
8110578c:	01204834 	movhi	r4,33056
81105790:	210b0004 	addi	r4,r4,11264
81105794:	11081ac0 	call	811081ac <uliRmapReadReg>
81105798:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_1_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);


	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110579c:	e13fff17 	ldw	r4,-4(fp)
811057a0:	11081fc0 	call	811081fc <uliConvRmapCfgAddr>
811057a4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811057a8:	e0bfff17 	ldw	r2,-4(fp)
}
811057ac:	e037883a 	mov	sp,fp
811057b0:	dfc00117 	ldw	ra,4(sp)
811057b4:	df000017 	ldw	fp,0(sp)
811057b8:	dec00204 	addi	sp,sp,8
811057bc:	f800283a 	ret

811057c0 <uliRmapCh2WriteCmdAddress>:

alt_u32 uliRmapCh2WriteCmdAddress(void) {
811057c0:	defffd04 	addi	sp,sp,-12
811057c4:	de00012e 	bgeu	sp,et,811057cc <uliRmapCh2WriteCmdAddress+0xc>
811057c8:	003b68fa 	trap	3
811057cc:	dfc00215 	stw	ra,8(sp)
811057d0:	df000115 	stw	fp,4(sp)
811057d4:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811057d8:	01400184 	movi	r5,6
811057dc:	01204834 	movhi	r4,33056
811057e0:	210a0004 	addi	r4,r4,10240
811057e4:	11081ac0 	call	811081ac <uliRmapReadReg>
811057e8:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_2_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811057ec:	e13fff17 	ldw	r4,-4(fp)
811057f0:	11081fc0 	call	811081fc <uliConvRmapCfgAddr>
811057f4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811057f8:	e0bfff17 	ldw	r2,-4(fp)
}
811057fc:	e037883a 	mov	sp,fp
81105800:	dfc00117 	ldw	ra,4(sp)
81105804:	df000017 	ldw	fp,0(sp)
81105808:	dec00204 	addi	sp,sp,8
8110580c:	f800283a 	ret

81105810 <uliRmapCh3WriteCmdAddress>:

alt_u32 uliRmapCh3WriteCmdAddress(void) {
81105810:	defffd04 	addi	sp,sp,-12
81105814:	de00012e 	bgeu	sp,et,8110581c <uliRmapCh3WriteCmdAddress+0xc>
81105818:	003b68fa 	trap	3
8110581c:	dfc00215 	stw	ra,8(sp)
81105820:	df000115 	stw	fp,4(sp)
81105824:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81105828:	01400184 	movi	r5,6
8110582c:	01204834 	movhi	r4,33056
81105830:	210b0004 	addi	r4,r4,11264
81105834:	11081ac0 	call	811081ac <uliRmapReadReg>
81105838:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_3_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110583c:	e13fff17 	ldw	r4,-4(fp)
81105840:	11081fc0 	call	811081fc <uliConvRmapCfgAddr>
81105844:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81105848:	e0bfff17 	ldw	r2,-4(fp)
}
8110584c:	e037883a 	mov	sp,fp
81105850:	dfc00117 	ldw	ra,4(sp)
81105854:	df000017 	ldw	fp,0(sp)
81105858:	dec00204 	addi	sp,sp,8
8110585c:	f800283a 	ret

81105860 <uliRmapCh4WriteCmdAddress>:

alt_u32 uliRmapCh4WriteCmdAddress(void) {
81105860:	defffd04 	addi	sp,sp,-12
81105864:	de00012e 	bgeu	sp,et,8110586c <uliRmapCh4WriteCmdAddress+0xc>
81105868:	003b68fa 	trap	3
8110586c:	dfc00215 	stw	ra,8(sp)
81105870:	df000115 	stw	fp,4(sp)
81105874:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81105878:	01400184 	movi	r5,6
8110587c:	01204834 	movhi	r4,33056
81105880:	210a0004 	addi	r4,r4,10240
81105884:	11081ac0 	call	811081ac <uliRmapReadReg>
81105888:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_4_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110588c:	e13fff17 	ldw	r4,-4(fp)
81105890:	11081fc0 	call	811081fc <uliConvRmapCfgAddr>
81105894:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81105898:	e0bfff17 	ldw	r2,-4(fp)
}
8110589c:	e037883a 	mov	sp,fp
811058a0:	dfc00117 	ldw	ra,4(sp)
811058a4:	df000017 	ldw	fp,0(sp)
811058a8:	dec00204 	addi	sp,sp,8
811058ac:	f800283a 	ret

811058b0 <uliRmapCh5WriteCmdAddress>:

alt_u32 uliRmapCh5WriteCmdAddress(void) {
811058b0:	defffd04 	addi	sp,sp,-12
811058b4:	de00012e 	bgeu	sp,et,811058bc <uliRmapCh5WriteCmdAddress+0xc>
811058b8:	003b68fa 	trap	3
811058bc:	dfc00215 	stw	ra,8(sp)
811058c0:	df000115 	stw	fp,4(sp)
811058c4:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811058c8:	01400184 	movi	r5,6
811058cc:	01204834 	movhi	r4,33056
811058d0:	210b0004 	addi	r4,r4,11264
811058d4:	11081ac0 	call	811081ac <uliRmapReadReg>
811058d8:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_5_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811058dc:	e13fff17 	ldw	r4,-4(fp)
811058e0:	11081fc0 	call	811081fc <uliConvRmapCfgAddr>
811058e4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811058e8:	e0bfff17 	ldw	r2,-4(fp)
}
811058ec:	e037883a 	mov	sp,fp
811058f0:	dfc00117 	ldw	ra,4(sp)
811058f4:	df000017 	ldw	fp,0(sp)
811058f8:	dec00204 	addi	sp,sp,8
811058fc:	f800283a 	ret

81105900 <uliRmapCh6WriteCmdAddress>:

alt_u32 uliRmapCh6WriteCmdAddress(void) {
81105900:	defffd04 	addi	sp,sp,-12
81105904:	de00012e 	bgeu	sp,et,8110590c <uliRmapCh6WriteCmdAddress+0xc>
81105908:	003b68fa 	trap	3
8110590c:	dfc00215 	stw	ra,8(sp)
81105910:	df000115 	stw	fp,4(sp)
81105914:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81105918:	01400184 	movi	r5,6
8110591c:	01204834 	movhi	r4,33056
81105920:	210a0004 	addi	r4,r4,10240
81105924:	11081ac0 	call	811081ac <uliRmapReadReg>
81105928:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_6_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110592c:	e13fff17 	ldw	r4,-4(fp)
81105930:	11081fc0 	call	811081fc <uliConvRmapCfgAddr>
81105934:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81105938:	e0bfff17 	ldw	r2,-4(fp)
}
8110593c:	e037883a 	mov	sp,fp
81105940:	dfc00117 	ldw	ra,4(sp)
81105944:	df000017 	ldw	fp,0(sp)
81105948:	dec00204 	addi	sp,sp,8
8110594c:	f800283a 	ret

81105950 <uliRmapCh7WriteCmdAddress>:

alt_u32 uliRmapCh7WriteCmdAddress(void) {
81105950:	defffd04 	addi	sp,sp,-12
81105954:	de00012e 	bgeu	sp,et,8110595c <uliRmapCh7WriteCmdAddress+0xc>
81105958:	003b68fa 	trap	3
8110595c:	dfc00215 	stw	ra,8(sp)
81105960:	df000115 	stw	fp,4(sp)
81105964:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81105968:	01400184 	movi	r5,6
8110596c:	01204834 	movhi	r4,33056
81105970:	210b0004 	addi	r4,r4,11264
81105974:	11081ac0 	call	811081ac <uliRmapReadReg>
81105978:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_7_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110597c:	e13fff17 	ldw	r4,-4(fp)
81105980:	11081fc0 	call	811081fc <uliConvRmapCfgAddr>
81105984:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81105988:	e0bfff17 	ldw	r2,-4(fp)
}
8110598c:	e037883a 	mov	sp,fp
81105990:	dfc00117 	ldw	ra,4(sp)
81105994:	df000017 	ldw	fp,0(sp)
81105998:	dec00204 	addi	sp,sp,8
8110599c:	f800283a 	ret

811059a0 <uliRmapCh8WriteCmdAddress>:

alt_u32 uliRmapCh8WriteCmdAddress(void) {
811059a0:	defffd04 	addi	sp,sp,-12
811059a4:	de00012e 	bgeu	sp,et,811059ac <uliRmapCh8WriteCmdAddress+0xc>
811059a8:	003b68fa 	trap	3
811059ac:	dfc00215 	stw	ra,8(sp)
811059b0:	df000115 	stw	fp,4(sp)
811059b4:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811059b8:	01400184 	movi	r5,6
811059bc:	01204834 	movhi	r4,33056
811059c0:	210a0004 	addi	r4,r4,10240
811059c4:	11081ac0 	call	811081ac <uliRmapReadReg>
811059c8:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_8_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811059cc:	e13fff17 	ldw	r4,-4(fp)
811059d0:	11081fc0 	call	811081fc <uliConvRmapCfgAddr>
811059d4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811059d8:	e0bfff17 	ldw	r2,-4(fp)
}
811059dc:	e037883a 	mov	sp,fp
811059e0:	dfc00117 	ldw	ra,4(sp)
811059e4:	df000017 	ldw	fp,0(sp)
811059e8:	dec00204 	addi	sp,sp,8
811059ec:	f800283a 	ret

811059f0 <vRmapInitIrq>:

void vRmapInitIrq(alt_u8 ucCommCh) {
811059f0:	defffc04 	addi	sp,sp,-16
811059f4:	de00012e 	bgeu	sp,et,811059fc <vRmapInitIrq+0xc>
811059f8:	003b68fa 	trap	3
811059fc:	dfc00315 	stw	ra,12(sp)
81105a00:	df000215 	stw	fp,8(sp)
81105a04:	df000204 	addi	fp,sp,8
81105a08:	2005883a 	mov	r2,r4
81105a0c:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81105a10:	e0bfff03 	ldbu	r2,-4(fp)
81105a14:	10c00228 	cmpgeui	r3,r2,8
81105a18:	18004e1e 	bne	r3,zero,81105b54 <vRmapInitIrq+0x164>
81105a1c:	100690ba 	slli	r3,r2,2
81105a20:	00a04434 	movhi	r2,33040
81105a24:	10968d04 	addi	r2,r2,23092
81105a28:	1885883a 	add	r2,r3,r2
81105a2c:	10800017 	ldw	r2,0(r2)
81105a30:	1000683a 	jmp	r2
81105a34:	81105a54 	ori	r4,r16,16745
81105a38:	81105a74 	orhi	r4,r16,16745
81105a3c:	81105a94 	ori	r4,r16,16746
81105a40:	81105ab4 	orhi	r4,r16,16746
81105a44:	81105ad4 	ori	r4,r16,16747
81105a48:	81105af4 	orhi	r4,r16,16747
81105a4c:	81105b14 	ori	r4,r16,16748
81105a50:	81105b34 	orhi	r4,r16,16748
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81105a54:	d0a04804 	addi	r2,gp,-32480
81105a58:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_RMAP_IRQ, pvHoldContext, vRmapCh1HandleIrq);
81105a5c:	01a04434 	movhi	r6,33040
81105a60:	3193fe04 	addi	r6,r6,20472
81105a64:	e17ffe17 	ldw	r5,-8(fp)
81105a68:	010005c4 	movi	r4,23
81105a6c:	112f3100 	call	8112f310 <alt_irq_register>
		break;
81105a70:	00003806 	br	81105b54 <vRmapInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
81105a74:	d0a04904 	addi	r2,gp,-32476
81105a78:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_RMAP_IRQ, pvHoldContext, vRmapCh2HandleIrq);
81105a7c:	01a04434 	movhi	r6,33040
81105a80:	31942104 	addi	r6,r6,20612
81105a84:	e17ffe17 	ldw	r5,-8(fp)
81105a88:	01000544 	movi	r4,21
81105a8c:	112f3100 	call	8112f310 <alt_irq_register>
		break;
81105a90:	00003006 	br	81105b54 <vRmapInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
81105a94:	d0a04a04 	addi	r2,gp,-32472
81105a98:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_RMAP_IRQ, pvHoldContext, vRmapCh3HandleIrq);
81105a9c:	01a04434 	movhi	r6,33040
81105aa0:	31944404 	addi	r6,r6,20752
81105aa4:	e17ffe17 	ldw	r5,-8(fp)
81105aa8:	010004c4 	movi	r4,19
81105aac:	112f3100 	call	8112f310 <alt_irq_register>
		break;
81105ab0:	00002806 	br	81105b54 <vRmapInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81105ab4:	d0a04b04 	addi	r2,gp,-32468
81105ab8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_RMAP_IRQ, pvHoldContext, vRmapCh4HandleIrq);
81105abc:	01a04434 	movhi	r6,33040
81105ac0:	31945404 	addi	r6,r6,20816
81105ac4:	e17ffe17 	ldw	r5,-8(fp)
81105ac8:	01000444 	movi	r4,17
81105acc:	112f3100 	call	8112f310 <alt_irq_register>
		break;
81105ad0:	00002006 	br	81105b54 <vRmapInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81105ad4:	d0a04c04 	addi	r2,gp,-32464
81105ad8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_RMAP_IRQ, pvHoldContext, vRmapCh5HandleIrq);
81105adc:	01a04434 	movhi	r6,33040
81105ae0:	31946404 	addi	r6,r6,20880
81105ae4:	e17ffe17 	ldw	r5,-8(fp)
81105ae8:	01000244 	movi	r4,9
81105aec:	112f3100 	call	8112f310 <alt_irq_register>
		break;
81105af0:	00001806 	br	81105b54 <vRmapInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81105af4:	d0a04d04 	addi	r2,gp,-32460
81105af8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_RMAP_IRQ, pvHoldContext, vRmapCh6HandleIrq);
81105afc:	01a04434 	movhi	r6,33040
81105b00:	31947404 	addi	r6,r6,20944
81105b04:	e17ffe17 	ldw	r5,-8(fp)
81105b08:	010001c4 	movi	r4,7
81105b0c:	112f3100 	call	8112f310 <alt_irq_register>
		break;
81105b10:	00001006 	br	81105b54 <vRmapInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81105b14:	d0a04e04 	addi	r2,gp,-32456
81105b18:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_RMAP_IRQ, pvHoldContext, vRmapCh7HandleIrq);
81105b1c:	01a04434 	movhi	r6,33040
81105b20:	31948404 	addi	r6,r6,21008
81105b24:	e17ffe17 	ldw	r5,-8(fp)
81105b28:	01000104 	movi	r4,4
81105b2c:	112f3100 	call	8112f310 <alt_irq_register>
		break;
81105b30:	00000806 	br	81105b54 <vRmapInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81105b34:	d0a04f04 	addi	r2,gp,-32452
81105b38:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_RMAP_IRQ, pvHoldContext, vRmapCh8HandleIrq);
81105b3c:	01a04434 	movhi	r6,33040
81105b40:	31949404 	addi	r6,r6,21072
81105b44:	e17ffe17 	ldw	r5,-8(fp)
81105b48:	010000c4 	movi	r4,3
81105b4c:	112f3100 	call	8112f310 <alt_irq_register>
		break;
81105b50:	0001883a 	nop
	}
}
81105b54:	0001883a 	nop
81105b58:	e037883a 	mov	sp,fp
81105b5c:	dfc00117 	ldw	ra,4(sp)
81105b60:	df000017 	ldw	fp,0(sp)
81105b64:	dec00204 	addi	sp,sp,8
81105b68:	f800283a 	ret

81105b6c <bRmapSetIrqControl>:

bool bRmapSetIrqControl(TRmapChannel *pxRmapCh) {
81105b6c:	defffb04 	addi	sp,sp,-20
81105b70:	de00012e 	bgeu	sp,et,81105b78 <bRmapSetIrqControl+0xc>
81105b74:	003b68fa 	trap	3
81105b78:	dfc00415 	stw	ra,16(sp)
81105b7c:	df000315 	stw	fp,12(sp)
81105b80:	df000304 	addi	fp,sp,12
81105b84:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105b88:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105b8c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81105b90:	e0bfff17 	ldw	r2,-4(fp)
81105b94:	10001926 	beq	r2,zero,81105bfc <bRmapSetIrqControl+0x90>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81105b98:	e0bfff17 	ldw	r2,-4(fp)
81105b9c:	10800017 	ldw	r2,0(r2)
81105ba0:	01400444 	movi	r5,17
81105ba4:	1009883a 	mov	r4,r2
81105ba8:	11081ac0 	call	811081ac <uliRmapReadReg>
81105bac:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxRmapCh->xRmapIrqControl.bWriteCmdEn) {
81105bb0:	e0bfff17 	ldw	r2,-4(fp)
81105bb4:	10801017 	ldw	r2,64(r2)
81105bb8:	10000426 	beq	r2,zero,81105bcc <bRmapSetIrqControl+0x60>
			uliReg |= COMM_IRQ_RMAP_WRCMD_EN_MSK;
81105bbc:	e0bffe17 	ldw	r2,-8(fp)
81105bc0:	10800054 	ori	r2,r2,1
81105bc4:	e0bffe15 	stw	r2,-8(fp)
81105bc8:	00000406 	br	81105bdc <bRmapSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_RMAP_WRCMD_EN_MSK);
81105bcc:	e0fffe17 	ldw	r3,-8(fp)
81105bd0:	00bfff84 	movi	r2,-2
81105bd4:	1884703a 	and	r2,r3,r2
81105bd8:	e0bffe15 	stw	r2,-8(fp)
		}

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_IRQ_CONTROL_REG_OFST,
81105bdc:	e0bfff17 	ldw	r2,-4(fp)
81105be0:	10800017 	ldw	r2,0(r2)
81105be4:	e1bffe17 	ldw	r6,-8(fp)
81105be8:	01400444 	movi	r5,17
81105bec:	1009883a 	mov	r4,r2
81105bf0:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);
		bStatus = TRUE;
81105bf4:	00800044 	movi	r2,1
81105bf8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105bfc:	e0bffd17 	ldw	r2,-12(fp)
}
81105c00:	e037883a 	mov	sp,fp
81105c04:	dfc00117 	ldw	ra,4(sp)
81105c08:	df000017 	ldw	fp,0(sp)
81105c0c:	dec00204 	addi	sp,sp,8
81105c10:	f800283a 	ret

81105c14 <bRmapGetIrqControl>:

bool bRmapGetIrqControl(TRmapChannel *pxRmapCh) {
81105c14:	defffb04 	addi	sp,sp,-20
81105c18:	de00012e 	bgeu	sp,et,81105c20 <bRmapGetIrqControl+0xc>
81105c1c:	003b68fa 	trap	3
81105c20:	dfc00415 	stw	ra,16(sp)
81105c24:	df000315 	stw	fp,12(sp)
81105c28:	df000304 	addi	fp,sp,12
81105c2c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105c30:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105c34:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81105c38:	e0bfff17 	ldw	r2,-4(fp)
81105c3c:	10001126 	beq	r2,zero,81105c84 <bRmapGetIrqControl+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81105c40:	e0bfff17 	ldw	r2,-4(fp)
81105c44:	10800017 	ldw	r2,0(r2)
81105c48:	01400444 	movi	r5,17
81105c4c:	1009883a 	mov	r4,r2
81105c50:	11081ac0 	call	811081ac <uliRmapReadReg>
81105c54:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_EN_MSK) {
81105c58:	e0bffe17 	ldw	r2,-8(fp)
81105c5c:	1080004c 	andi	r2,r2,1
81105c60:	10000426 	beq	r2,zero,81105c74 <bRmapGetIrqControl+0x60>
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
81105c64:	e0bfff17 	ldw	r2,-4(fp)
81105c68:	00c00044 	movi	r3,1
81105c6c:	10c01015 	stw	r3,64(r2)
81105c70:	00000206 	br	81105c7c <bRmapGetIrqControl+0x68>
		} else {
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
81105c74:	e0bfff17 	ldw	r2,-4(fp)
81105c78:	10001015 	stw	zero,64(r2)
		}

		bStatus = TRUE;
81105c7c:	00800044 	movi	r2,1
81105c80:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105c84:	e0bffd17 	ldw	r2,-12(fp)
}
81105c88:	e037883a 	mov	sp,fp
81105c8c:	dfc00117 	ldw	ra,4(sp)
81105c90:	df000017 	ldw	fp,0(sp)
81105c94:	dec00204 	addi	sp,sp,8
81105c98:	f800283a 	ret

81105c9c <bRmapGetIrqFlags>:

bool bRmapGetIrqFlags(TRmapChannel *pxRmapCh) {
81105c9c:	defffb04 	addi	sp,sp,-20
81105ca0:	de00012e 	bgeu	sp,et,81105ca8 <bRmapGetIrqFlags+0xc>
81105ca4:	003b68fa 	trap	3
81105ca8:	dfc00415 	stw	ra,16(sp)
81105cac:	df000315 	stw	fp,12(sp)
81105cb0:	df000304 	addi	fp,sp,12
81105cb4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105cb8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105cbc:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81105cc0:	e0bfff17 	ldw	r2,-4(fp)
81105cc4:	10001126 	beq	r2,zero,81105d0c <bRmapGetIrqFlags+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81105cc8:	e0bfff17 	ldw	r2,-4(fp)
81105ccc:	10800017 	ldw	r2,0(r2)
81105cd0:	01400484 	movi	r5,18
81105cd4:	1009883a 	mov	r4,r2
81105cd8:	11081ac0 	call	811081ac <uliRmapReadReg>
81105cdc:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81105ce0:	e0bffe17 	ldw	r2,-8(fp)
81105ce4:	1080004c 	andi	r2,r2,1
81105ce8:	10000426 	beq	r2,zero,81105cfc <bRmapGetIrqFlags+0x60>
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = TRUE;
81105cec:	e0bfff17 	ldw	r2,-4(fp)
81105cf0:	00c00044 	movi	r3,1
81105cf4:	10c01115 	stw	r3,68(r2)
81105cf8:	00000206 	br	81105d04 <bRmapGetIrqFlags+0x68>
		} else {
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = FALSE;
81105cfc:	e0bfff17 	ldw	r2,-4(fp)
81105d00:	10001115 	stw	zero,68(r2)
		}

		bStatus = TRUE;
81105d04:	00800044 	movi	r2,1
81105d08:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105d0c:	e0bffd17 	ldw	r2,-12(fp)
}
81105d10:	e037883a 	mov	sp,fp
81105d14:	dfc00117 	ldw	ra,4(sp)
81105d18:	df000017 	ldw	fp,0(sp)
81105d1c:	dec00204 	addi	sp,sp,8
81105d20:	f800283a 	ret

81105d24 <bRmapSetCodecConfig>:

bool bRmapSetCodecConfig(TRmapChannel *pxRmapCh) {
81105d24:	defffb04 	addi	sp,sp,-20
81105d28:	de00012e 	bgeu	sp,et,81105d30 <bRmapSetCodecConfig+0xc>
81105d2c:	003b68fa 	trap	3
81105d30:	dfc00415 	stw	ra,16(sp)
81105d34:	df000315 	stw	fp,12(sp)
81105d38:	df000304 	addi	fp,sp,12
81105d3c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105d40:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105d44:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81105d48:	e0bfff17 	ldw	r2,-4(fp)
81105d4c:	10002526 	beq	r2,zero,81105de4 <bRmapSetCodecConfig+0xc0>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81105d50:	e0bfff17 	ldw	r2,-4(fp)
81105d54:	10800017 	ldw	r2,0(r2)
81105d58:	01400104 	movi	r5,4
81105d5c:	1009883a 	mov	r4,r2
81105d60:	11081ac0 	call	811081ac <uliRmapReadReg>
81105d64:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
81105d68:	e0fffe17 	ldw	r3,-8(fp)
81105d6c:	00bfc004 	movi	r2,-256
81105d70:	1884703a 	and	r2,r3,r2
81105d74:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
81105d78:	e0bfff17 	ldw	r2,-4(fp)
81105d7c:	10800143 	ldbu	r2,5(r2)
81105d80:	10803fcc 	andi	r2,r2,255

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
81105d84:	e0fffe17 	ldw	r3,-8(fp)
81105d88:	1884b03a 	or	r2,r3,r2
81105d8c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
81105d90:	e0fffe17 	ldw	r3,-8(fp)
81105d94:	00bffff4 	movhi	r2,65535
81105d98:	10803fc4 	addi	r2,r2,255
81105d9c:	1884703a 	and	r2,r3,r2
81105da0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));
81105da4:	e0bfff17 	ldw	r2,-4(fp)
81105da8:	10800103 	ldbu	r2,4(r2)
81105dac:	10803fcc 	andi	r2,r2,255
81105db0:	1004923a 	slli	r2,r2,8
81105db4:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
81105db8:	e0fffe17 	ldw	r3,-8(fp)
81105dbc:	1884b03a 	or	r2,r3,r2
81105dc0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CODEC_CFG_REG_OFST,
81105dc4:	e0bfff17 	ldw	r2,-4(fp)
81105dc8:	10800017 	ldw	r2,0(r2)
81105dcc:	e1bffe17 	ldw	r6,-8(fp)
81105dd0:	01400104 	movi	r5,4
81105dd4:	1009883a 	mov	r4,r2
81105dd8:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81105ddc:	00800044 	movi	r2,1
81105de0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105de4:	e0bffd17 	ldw	r2,-12(fp)
}
81105de8:	e037883a 	mov	sp,fp
81105dec:	dfc00117 	ldw	ra,4(sp)
81105df0:	df000017 	ldw	fp,0(sp)
81105df4:	dec00204 	addi	sp,sp,8
81105df8:	f800283a 	ret

81105dfc <bRmapGetCodecConfig>:

bool bRmapGetCodecConfig(TRmapChannel *pxRmapCh) {
81105dfc:	defffb04 	addi	sp,sp,-20
81105e00:	de00012e 	bgeu	sp,et,81105e08 <bRmapGetCodecConfig+0xc>
81105e04:	003b68fa 	trap	3
81105e08:	dfc00415 	stw	ra,16(sp)
81105e0c:	df000315 	stw	fp,12(sp)
81105e10:	df000304 	addi	fp,sp,12
81105e14:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105e18:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105e1c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81105e20:	e0bfff17 	ldw	r2,-4(fp)
81105e24:	10001226 	beq	r2,zero,81105e70 <bRmapGetCodecConfig+0x74>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81105e28:	e0bfff17 	ldw	r2,-4(fp)
81105e2c:	10800017 	ldw	r2,0(r2)
81105e30:	01400104 	movi	r5,4
81105e34:	1009883a 	mov	r4,r2
81105e38:	11081ac0 	call	811081ac <uliRmapReadReg>
81105e3c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
81105e40:	e0bffe17 	ldw	r2,-8(fp)
81105e44:	1007883a 	mov	r3,r2
81105e48:	e0bfff17 	ldw	r2,-4(fp)
81105e4c:	10c00145 	stb	r3,5(r2)
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);
81105e50:	e0bffe17 	ldw	r2,-8(fp)
81105e54:	10bfc00c 	andi	r2,r2,65280
81105e58:	1004d23a 	srli	r2,r2,8
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
81105e5c:	1007883a 	mov	r3,r2
81105e60:	e0bfff17 	ldw	r2,-4(fp)
81105e64:	10c00105 	stb	r3,4(r2)
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);

		bStatus = TRUE;
81105e68:	00800044 	movi	r2,1
81105e6c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105e70:	e0bffd17 	ldw	r2,-12(fp)
}
81105e74:	e037883a 	mov	sp,fp
81105e78:	dfc00117 	ldw	ra,4(sp)
81105e7c:	df000017 	ldw	fp,0(sp)
81105e80:	dec00204 	addi	sp,sp,8
81105e84:	f800283a 	ret

81105e88 <bRmapGetCodecStatus>:

bool bRmapGetCodecStatus(TRmapChannel *pxRmapCh) {
81105e88:	defffb04 	addi	sp,sp,-20
81105e8c:	de00012e 	bgeu	sp,et,81105e94 <bRmapGetCodecStatus+0xc>
81105e90:	003b68fa 	trap	3
81105e94:	dfc00415 	stw	ra,16(sp)
81105e98:	df000315 	stw	fp,12(sp)
81105e9c:	df000304 	addi	fp,sp,12
81105ea0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105ea4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105ea8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81105eac:	e0bfff17 	ldw	r2,-4(fp)
81105eb0:	10004726 	beq	r2,zero,81105fd0 <bRmapGetCodecStatus+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81105eb4:	e0bfff17 	ldw	r2,-4(fp)
81105eb8:	10800017 	ldw	r2,0(r2)
81105ebc:	01400144 	movi	r5,5
81105ec0:	1009883a 	mov	r4,r2
81105ec4:	11081ac0 	call	811081ac <uliRmapReadReg>
81105ec8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_STAT_CMD_RECEIVED_MSK) {
81105ecc:	e0bffe17 	ldw	r2,-8(fp)
81105ed0:	1080004c 	andi	r2,r2,1
81105ed4:	10000426 	beq	r2,zero,81105ee8 <bRmapGetCodecStatus+0x60>
			pxRmapCh->xRmapCodecStatus.bCommandReceived = TRUE;
81105ed8:	e0bfff17 	ldw	r2,-4(fp)
81105edc:	00c00044 	movi	r3,1
81105ee0:	10c00215 	stw	r3,8(r2)
81105ee4:	00000206 	br	81105ef0 <bRmapGetCodecStatus+0x68>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81105ee8:	e0bfff17 	ldw	r2,-4(fp)
81105eec:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_REQ_MSK) {
81105ef0:	e0bffe17 	ldw	r2,-8(fp)
81105ef4:	1080008c 	andi	r2,r2,2
81105ef8:	10000426 	beq	r2,zero,81105f0c <bRmapGetCodecStatus+0x84>
			pxRmapCh->xRmapCodecStatus.bWriteRequested = TRUE;
81105efc:	e0bfff17 	ldw	r2,-4(fp)
81105f00:	00c00044 	movi	r3,1
81105f04:	10c00315 	stw	r3,12(r2)
81105f08:	00000206 	br	81105f14 <bRmapGetCodecStatus+0x8c>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteRequested = FALSE;
81105f0c:	e0bfff17 	ldw	r2,-4(fp)
81105f10:	10000315 	stw	zero,12(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_AUTH_MSK) {
81105f14:	e0bffe17 	ldw	r2,-8(fp)
81105f18:	1080010c 	andi	r2,r2,4
81105f1c:	10000426 	beq	r2,zero,81105f30 <bRmapGetCodecStatus+0xa8>
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = TRUE;
81105f20:	e0bfff17 	ldw	r2,-4(fp)
81105f24:	00c00044 	movi	r3,1
81105f28:	10c00415 	stw	r3,16(r2)
81105f2c:	00000206 	br	81105f38 <bRmapGetCodecStatus+0xb0>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = FALSE;
81105f30:	e0bfff17 	ldw	r2,-4(fp)
81105f34:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_REQ_MSK) {
81105f38:	e0bffe17 	ldw	r2,-8(fp)
81105f3c:	1080020c 	andi	r2,r2,8
81105f40:	10000426 	beq	r2,zero,81105f54 <bRmapGetCodecStatus+0xcc>
			pxRmapCh->xRmapCodecStatus.bReadRequested = TRUE;
81105f44:	e0bfff17 	ldw	r2,-4(fp)
81105f48:	00c00044 	movi	r3,1
81105f4c:	10c00515 	stw	r3,20(r2)
81105f50:	00000206 	br	81105f5c <bRmapGetCodecStatus+0xd4>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadRequested = FALSE;
81105f54:	e0bfff17 	ldw	r2,-4(fp)
81105f58:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_AUTH_MSK) {
81105f5c:	e0bffe17 	ldw	r2,-8(fp)
81105f60:	1080040c 	andi	r2,r2,16
81105f64:	10000426 	beq	r2,zero,81105f78 <bRmapGetCodecStatus+0xf0>
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = TRUE;
81105f68:	e0bfff17 	ldw	r2,-4(fp)
81105f6c:	00c00044 	movi	r3,1
81105f70:	10c00615 	stw	r3,24(r2)
81105f74:	00000206 	br	81105f80 <bRmapGetCodecStatus+0xf8>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = FALSE;
81105f78:	e0bfff17 	ldw	r2,-4(fp)
81105f7c:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_RMAP_STAT_REPLY_SEND_MSK) {
81105f80:	e0bffe17 	ldw	r2,-8(fp)
81105f84:	1080080c 	andi	r2,r2,32
81105f88:	10000426 	beq	r2,zero,81105f9c <bRmapGetCodecStatus+0x114>
			pxRmapCh->xRmapCodecStatus.bReplySended = TRUE;
81105f8c:	e0bfff17 	ldw	r2,-4(fp)
81105f90:	00c00044 	movi	r3,1
81105f94:	10c00715 	stw	r3,28(r2)
81105f98:	00000206 	br	81105fa4 <bRmapGetCodecStatus+0x11c>
		} else {
			pxRmapCh->xRmapCodecStatus.bReplySended = FALSE;
81105f9c:	e0bfff17 	ldw	r2,-4(fp)
81105fa0:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_RMAP_STAT_DISCARD_PKG_MSK) {
81105fa4:	e0bffe17 	ldw	r2,-8(fp)
81105fa8:	1080100c 	andi	r2,r2,64
81105fac:	10000426 	beq	r2,zero,81105fc0 <bRmapGetCodecStatus+0x138>
			pxRmapCh->xRmapCodecStatus.bDiscardedPackage = TRUE;
81105fb0:	e0bfff17 	ldw	r2,-4(fp)
81105fb4:	00c00044 	movi	r3,1
81105fb8:	10c00815 	stw	r3,32(r2)
81105fbc:	00000206 	br	81105fc8 <bRmapGetCodecStatus+0x140>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81105fc0:	e0bfff17 	ldw	r2,-4(fp)
81105fc4:	10000215 	stw	zero,8(r2)
		}

		bStatus = TRUE;
81105fc8:	00800044 	movi	r2,1
81105fcc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105fd0:	e0bffd17 	ldw	r2,-12(fp)
}
81105fd4:	e037883a 	mov	sp,fp
81105fd8:	dfc00117 	ldw	ra,4(sp)
81105fdc:	df000017 	ldw	fp,0(sp)
81105fe0:	dec00204 	addi	sp,sp,8
81105fe4:	f800283a 	ret

81105fe8 <bRmapGetCodecError>:

bool bRmapGetCodecError(TRmapChannel *pxRmapCh) {
81105fe8:	defffb04 	addi	sp,sp,-20
81105fec:	de00012e 	bgeu	sp,et,81105ff4 <bRmapGetCodecError+0xc>
81105ff0:	003b68fa 	trap	3
81105ff4:	dfc00415 	stw	ra,16(sp)
81105ff8:	df000315 	stw	fp,12(sp)
81105ffc:	df000304 	addi	fp,sp,12
81106000:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106004:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106008:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110600c:	e0bfff17 	ldw	r2,-4(fp)
81106010:	10004726 	beq	r2,zero,81106130 <bRmapGetCodecError+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106014:	e0bfff17 	ldw	r2,-4(fp)
81106018:	10800017 	ldw	r2,0(r2)
8110601c:	01400144 	movi	r5,5
81106020:	1009883a 	mov	r4,r2
81106024:	11081ac0 	call	811081ac <uliRmapReadReg>
81106028:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_ERR_EARLY_EOP_MSK) {
8110602c:	e0bffe17 	ldw	r2,-8(fp)
81106030:	1080006c 	andhi	r2,r2,1
81106034:	10000426 	beq	r2,zero,81106048 <bRmapGetCodecError+0x60>
			pxRmapCh->xRmapCodecError.bEarlyEop = TRUE;
81106038:	e0bfff17 	ldw	r2,-4(fp)
8110603c:	00c00044 	movi	r3,1
81106040:	10c00915 	stw	r3,36(r2)
81106044:	00000206 	br	81106050 <bRmapGetCodecError+0x68>
		} else {
			pxRmapCh->xRmapCodecError.bEarlyEop = FALSE;
81106048:	e0bfff17 	ldw	r2,-4(fp)
8110604c:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_RMAP_ERR_EEP_MSK) {
81106050:	e0bffe17 	ldw	r2,-8(fp)
81106054:	108000ac 	andhi	r2,r2,2
81106058:	10000426 	beq	r2,zero,8110606c <bRmapGetCodecError+0x84>
			pxRmapCh->xRmapCodecError.bEep = TRUE;
8110605c:	e0bfff17 	ldw	r2,-4(fp)
81106060:	00c00044 	movi	r3,1
81106064:	10c00a15 	stw	r3,40(r2)
81106068:	00000206 	br	81106074 <bRmapGetCodecError+0x8c>
		} else {
			pxRmapCh->xRmapCodecError.bEep = FALSE;
8110606c:	e0bfff17 	ldw	r2,-4(fp)
81106070:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_RMAP_ERR_HEADER_CRC_MSK) {
81106074:	e0bffe17 	ldw	r2,-8(fp)
81106078:	1080012c 	andhi	r2,r2,4
8110607c:	10000426 	beq	r2,zero,81106090 <bRmapGetCodecError+0xa8>
			pxRmapCh->xRmapCodecError.bHeaderCRC = TRUE;
81106080:	e0bfff17 	ldw	r2,-4(fp)
81106084:	00c00044 	movi	r3,1
81106088:	10c00b15 	stw	r3,44(r2)
8110608c:	00000206 	br	81106098 <bRmapGetCodecError+0xb0>
		} else {
			pxRmapCh->xRmapCodecError.bHeaderCRC = FALSE;
81106090:	e0bfff17 	ldw	r2,-4(fp)
81106094:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_RMAP_ERR_UNUSED_PKT_MSK) {
81106098:	e0bffe17 	ldw	r2,-8(fp)
8110609c:	1080022c 	andhi	r2,r2,8
811060a0:	10000426 	beq	r2,zero,811060b4 <bRmapGetCodecError+0xcc>
			pxRmapCh->xRmapCodecError.bUnusedPacketType = TRUE;
811060a4:	e0bfff17 	ldw	r2,-4(fp)
811060a8:	00c00044 	movi	r3,1
811060ac:	10c00c15 	stw	r3,48(r2)
811060b0:	00000206 	br	811060bc <bRmapGetCodecError+0xd4>
		} else {
			pxRmapCh->xRmapCodecError.bUnusedPacketType = FALSE;
811060b4:	e0bfff17 	ldw	r2,-4(fp)
811060b8:	10000c15 	stw	zero,48(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_CMD_MSK) {
811060bc:	e0bffe17 	ldw	r2,-8(fp)
811060c0:	1080042c 	andhi	r2,r2,16
811060c4:	10000426 	beq	r2,zero,811060d8 <bRmapGetCodecError+0xf0>
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = TRUE;
811060c8:	e0bfff17 	ldw	r2,-4(fp)
811060cc:	00c00044 	movi	r3,1
811060d0:	10c00d15 	stw	r3,52(r2)
811060d4:	00000206 	br	811060e0 <bRmapGetCodecError+0xf8>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = FALSE;
811060d8:	e0bfff17 	ldw	r2,-4(fp)
811060dc:	10000d15 	stw	zero,52(r2)
		}
		if (uliReg & COMM_RMAP_ERR_TOO_MUCH_DATA_MSK) {
811060e0:	e0bffe17 	ldw	r2,-8(fp)
811060e4:	1080082c 	andhi	r2,r2,32
811060e8:	10000426 	beq	r2,zero,811060fc <bRmapGetCodecError+0x114>
			pxRmapCh->xRmapCodecError.bTooMuchData = TRUE;
811060ec:	e0bfff17 	ldw	r2,-4(fp)
811060f0:	00c00044 	movi	r3,1
811060f4:	10c00e15 	stw	r3,56(r2)
811060f8:	00000206 	br	81106104 <bRmapGetCodecError+0x11c>
		} else {
			pxRmapCh->xRmapCodecError.bTooMuchData = FALSE;
811060fc:	e0bfff17 	ldw	r2,-4(fp)
81106100:	10000e15 	stw	zero,56(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_DCRC_MSK) {
81106104:	e0bffe17 	ldw	r2,-8(fp)
81106108:	1080102c 	andhi	r2,r2,64
8110610c:	10000426 	beq	r2,zero,81106120 <bRmapGetCodecError+0x138>
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = TRUE;
81106110:	e0bfff17 	ldw	r2,-4(fp)
81106114:	00c00044 	movi	r3,1
81106118:	10c00f15 	stw	r3,60(r2)
8110611c:	00000206 	br	81106128 <bRmapGetCodecError+0x140>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = FALSE;
81106120:	e0bfff17 	ldw	r2,-4(fp)
81106124:	10000f15 	stw	zero,60(r2)
		}

		bStatus = TRUE;
81106128:	00800044 	movi	r2,1
8110612c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106130:	e0bffd17 	ldw	r2,-12(fp)
}
81106134:	e037883a 	mov	sp,fp
81106138:	dfc00117 	ldw	ra,4(sp)
8110613c:	df000017 	ldw	fp,0(sp)
81106140:	dec00204 	addi	sp,sp,8
81106144:	f800283a 	ret

81106148 <bRmapSetMemConfigArea>:

bool bRmapSetMemConfigArea(TRmapChannel *pxRmapCh) {
81106148:	defffb04 	addi	sp,sp,-20
8110614c:	de00012e 	bgeu	sp,et,81106154 <bRmapSetMemConfigArea+0xc>
81106150:	003b68fa 	trap	3
81106154:	dfc00415 	stw	ra,16(sp)
81106158:	df000315 	stw	fp,12(sp)
8110615c:	df000304 	addi	fp,sp,12
81106160:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106164:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106168:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110616c:	e0bfff17 	ldw	r2,-4(fp)
81106170:	1000aa26 	beq	r2,zero,8110641c <bRmapSetMemConfigArea+0x2d4>

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config;
81106174:	e0bfff17 	ldw	r2,-4(fp)
81106178:	10801217 	ldw	r2,72(r2)
8110617c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_REGCLK_DIR_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 3));
//			uliReg &= (~COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 4));
//			uliReg &= (~COMM_RMAP_REGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 20));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106180:	e0bfff17 	ldw	r2,-4(fp)
81106184:	10800017 	ldw	r2,0(r2)
81106188:	e1bffe17 	ldw	r6,-8(fp)
8110618c:	01401004 	movi	r5,64
81106190:	1009883a 	mov	r4,r2
81106194:	11081580 	call	81108158 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config;
81106198:	e0bfff17 	ldw	r2,-4(fp)
8110619c:	10801317 	ldw	r2,76(r2)
811061a0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK);
//			uliReg |= (COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811061a4:	e0bfff17 	ldw	r2,-4(fp)
811061a8:	10800017 	ldw	r2,0(r2)
811061ac:	e1bffe17 	ldw	r6,-8(fp)
811061b0:	01401044 	movi	r5,65
811061b4:	1009883a 	mov	r4,r2
811061b8:	11081580 	call	81108158 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config;
811061bc:	e0bfff17 	ldw	r2,-4(fp)
811061c0:	10801417 	ldw	r2,80(r2)
811061c4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_DIGITISE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_PACKET_SIZE_CTRL_MSK);
//			uliReg |= (COMM_RMAP_PACKET_SIZE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811061c8:	e0bfff17 	ldw	r2,-4(fp)
811061cc:	10800017 	ldw	r2,0(r2)
811061d0:	e1bffe17 	ldw	r6,-8(fp)
811061d4:	01401084 	movi	r5,66
811061d8:	1009883a 	mov	r4,r2
811061dc:	11081580 	call	81108158 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config;
811061e0:	e0bfff17 	ldw	r2,-4(fp)
811061e4:	10801517 	ldw	r2,84(r2)
811061e8:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811061ec:	e0bfff17 	ldw	r2,-4(fp)
811061f0:	10800017 	ldw	r2,0(r2)
811061f4:	e1bffe17 	ldw	r6,-8(fp)
811061f8:	014010c4 	movi	r5,67
811061fc:	1009883a 	mov	r4,r2
81106200:	11081580 	call	81108158 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81106204:	e0bfff17 	ldw	r2,-4(fp)
81106208:	10802217 	ldw	r2,136(r2)
8110620c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106210:	e0bfff17 	ldw	r2,-4(fp)
81106214:	10800017 	ldw	r2,0(r2)
81106218:	e1bffe17 	ldw	r6,-8(fp)
8110621c:	01401104 	movi	r5,68
81106220:	1009883a 	mov	r4,r2
81106224:	11081580 	call	81108158 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config;
81106228:	e0bfff17 	ldw	r2,-4(fp)
8110622c:	10801717 	ldw	r2,92(r2)
81106230:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106234:	e0bfff17 	ldw	r2,-4(fp)
81106238:	10800017 	ldw	r2,0(r2)
8110623c:	e1bffe17 	ldw	r6,-8(fp)
81106240:	01401144 	movi	r5,69
81106244:	1009883a 	mov	r4,r2
81106248:	11081580 	call	81108158 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config;
8110624c:	e0bfff17 	ldw	r2,-4(fp)
81106250:	10801817 	ldw	r2,96(r2)
81106254:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106258:	e0bfff17 	ldw	r2,-4(fp)
8110625c:	10800017 	ldw	r2,0(r2)
81106260:	e1bffe17 	ldw	r6,-8(fp)
81106264:	01401184 	movi	r5,70
81106268:	1009883a 	mov	r4,r2
8110626c:	11081580 	call	81108158 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config;
81106270:	e0bfff17 	ldw	r2,-4(fp)
81106274:	10801917 	ldw	r2,100(r2)
81106278:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110627c:	e0bfff17 	ldw	r2,-4(fp)
81106280:	10800017 	ldw	r2,0(r2)
81106284:	e1bffe17 	ldw	r6,-8(fp)
81106288:	014011c4 	movi	r5,71
8110628c:	1009883a 	mov	r4,r2
81106290:	11081580 	call	81108158 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config;
81106294:	e0bfff17 	ldw	r2,-4(fp)
81106298:	10801a17 	ldw	r2,104(r2)
8110629c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811062a0:	e0bfff17 	ldw	r2,-4(fp)
811062a4:	10800017 	ldw	r2,0(r2)
811062a8:	e1bffe17 	ldw	r6,-8(fp)
811062ac:	01401204 	movi	r5,72
811062b0:	1009883a 	mov	r4,r2
811062b4:	11081580 	call	81108158 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config;
811062b8:	e0bfff17 	ldw	r2,-4(fp)
811062bc:	10801b17 	ldw	r2,108(r2)
811062c0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811062c4:	e0bfff17 	ldw	r2,-4(fp)
811062c8:	10800017 	ldw	r2,0(r2)
811062cc:	e1bffe17 	ldw	r6,-8(fp)
811062d0:	01401244 	movi	r5,73
811062d4:	1009883a 	mov	r4,r2
811062d8:	11081580 	call	81108158 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST, uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811062dc:	e0bfff17 	ldw	r2,-4(fp)
811062e0:	10800017 	ldw	r2,0(r2)
811062e4:	01401284 	movi	r5,74
811062e8:	1009883a 	mov	r4,r2
811062ec:	11081ac0 	call	811081ac <uliRmapReadReg>
811062f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config;
811062f4:	e0bfff17 	ldw	r2,-4(fp)
811062f8:	10801c17 	ldw	r2,112(r2)
811062fc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106300:	e0bfff17 	ldw	r2,-4(fp)
81106304:	10800017 	ldw	r2,0(r2)
81106308:	e1bffe17 	ldw	r6,-8(fp)
8110630c:	01401284 	movi	r5,74
81106310:	1009883a 	mov	r4,r2
81106314:	11081580 	call	81108158 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config;
81106318:	e0bfff17 	ldw	r2,-4(fp)
8110631c:	10801d17 	ldw	r2,116(r2)
81106320:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81106324:	e0bfff17 	ldw	r2,-4(fp)
81106328:	10800017 	ldw	r2,0(r2)
8110632c:	e1bffe17 	ldw	r6,-8(fp)
81106330:	014012c4 	movi	r5,75
81106334:	1009883a 	mov	r4,r2
81106338:	11081580 	call	81108158 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig;
8110633c:	e0bfff17 	ldw	r2,-4(fp)
81106340:	10801e17 	ldw	r2,120(r2)
81106344:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_MODE_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_MODE_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST,
81106348:	e0bfff17 	ldw	r2,-4(fp)
8110634c:	10800017 	ldw	r2,0(r2)
81106350:	e1bffe17 	ldw	r6,-8(fp)
81106354:	01401304 	movi	r5,76
81106358:	1009883a 	mov	r4,r2
8110635c:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSyncConfig;
81106360:	e0bfff17 	ldw	r2,-4(fp)
81106364:	10801f17 	ldw	r2,124(r2)
81106368:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SYNC_CFG_MSK);
//			uliReg |= (COMM_RMAP_SYNC_CFG_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
//			uliReg &= (~COMM_RMAP_SELF_TRIGGER_CTRL_MSK);
//			uliReg |= (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST,
8110636c:	e0bfff17 	ldw	r2,-4(fp)
81106370:	10800017 	ldw	r2,0(r2)
81106374:	e1bffe17 	ldw	r6,-8(fp)
81106378:	01401344 	movi	r5,77
8110637c:	1009883a 	mov	r4,r2
81106380:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliDacControl;
81106384:	e0bfff17 	ldw	r2,-4(fp)
81106388:	10802017 	ldw	r2,128(r2)
8110638c:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST,
81106390:	e0bfff17 	ldw	r2,-4(fp)
81106394:	10800017 	ldw	r2,0(r2)
81106398:	e1bffe17 	ldw	r6,-8(fp)
8110639c:	01401384 	movi	r5,78
811063a0:	1009883a 	mov	r4,r2
811063a4:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
811063a8:	e0bfff17 	ldw	r2,-4(fp)
811063ac:	10802217 	ldw	r2,136(r2)
811063b0:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811063b4:	e0bfff17 	ldw	r2,-4(fp)
811063b8:	10800017 	ldw	r2,0(r2)
811063bc:	e1bffe17 	ldw	r6,-8(fp)
811063c0:	014013c4 	movi	r5,79
811063c4:	1009883a 	mov	r4,r2
811063c8:	11081580 	call	81108158 <vRmapWriteReg>
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
811063cc:	e0bfff17 	ldw	r2,-4(fp)
811063d0:	10802217 	ldw	r2,136(r2)
811063d4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_FRAME_NUMBER_MSK);
//			uliReg |= (COMM_RMAP_FRAME_NUMBER_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliFrameNumber. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST,
811063d8:	e0bfff17 	ldw	r2,-4(fp)
811063dc:	10800017 	ldw	r2,0(r2)
811063e0:	e1bffe17 	ldw	r6,-8(fp)
811063e4:	01401404 	movi	r5,80
811063e8:	1009883a 	mov	r4,r2
811063ec:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCurrentMode;
811063f0:	e0bfff17 	ldw	r2,-4(fp)
811063f4:	10802317 	ldw	r2,140(r2)
811063f8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_CURRENT_MODE_MSK);
//			uliReg |= (COMM_RMAP_CURRENT_MODE_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCurrentMode. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST,
811063fc:	e0bfff17 	ldw	r2,-4(fp)
81106400:	10800017 	ldw	r2,0(r2)
81106404:	e1bffe17 	ldw	r6,-8(fp)
81106408:	01401444 	movi	r5,81
8110640c:	1009883a 	mov	r4,r2
81106410:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81106414:	00800044 	movi	r2,1
81106418:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110641c:	e0bffd17 	ldw	r2,-12(fp)
}
81106420:	e037883a 	mov	sp,fp
81106424:	dfc00117 	ldw	ra,4(sp)
81106428:	df000017 	ldw	fp,0(sp)
8110642c:	dec00204 	addi	sp,sp,8
81106430:	f800283a 	ret

81106434 <bRmapGetMemConfigArea>:

bool bRmapGetMemConfigArea(TRmapChannel *pxRmapCh) {
81106434:	defffb04 	addi	sp,sp,-20
81106438:	de00012e 	bgeu	sp,et,81106440 <bRmapGetMemConfigArea+0xc>
8110643c:	003b68fa 	trap	3
81106440:	dfc00415 	stw	ra,16(sp)
81106444:	df000315 	stw	fp,12(sp)
81106448:	df000304 	addi	fp,sp,12
8110644c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106450:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106454:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106458:	e0bfff17 	ldw	r2,-4(fp)
8110645c:	1000a426 	beq	r2,zero,811066f0 <bRmapGetMemConfigArea+0x2bc>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106460:	e0bfff17 	ldw	r2,-4(fp)
81106464:	10800017 	ldw	r2,0(r2)
81106468:	01401004 	movi	r5,64
8110646c:	1009883a 	mov	r4,r2
81106470:	11081ac0 	call	811081ac <uliRmapReadReg>
81106474:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config = uliReg;
81106478:	e0bfff17 	ldw	r2,-4(fp)
8110647c:	e0fffe17 	ldw	r3,-8(fp)
81106480:	10c01215 	stw	r3,72(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106484:	e0bfff17 	ldw	r2,-4(fp)
81106488:	10800017 	ldw	r2,0(r2)
8110648c:	01401044 	movi	r5,65
81106490:	1009883a 	mov	r4,r2
81106494:	11081ac0 	call	811081ac <uliRmapReadReg>
81106498:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config = uliReg;
8110649c:	e0bfff17 	ldw	r2,-4(fp)
811064a0:	e0fffe17 	ldw	r3,-8(fp)
811064a4:	10c01315 	stw	r3,76(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811064a8:	e0bfff17 	ldw	r2,-4(fp)
811064ac:	10800017 	ldw	r2,0(r2)
811064b0:	01401084 	movi	r5,66
811064b4:	1009883a 	mov	r4,r2
811064b8:	11081ac0 	call	811081ac <uliRmapReadReg>
811064bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config = uliReg;
811064c0:	e0bfff17 	ldw	r2,-4(fp)
811064c4:	e0fffe17 	ldw	r3,-8(fp)
811064c8:	10c01415 	stw	r3,80(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811064cc:	e0bfff17 	ldw	r2,-4(fp)
811064d0:	10800017 	ldw	r2,0(r2)
811064d4:	014010c4 	movi	r5,67
811064d8:	1009883a 	mov	r4,r2
811064dc:	11081ac0 	call	811081ac <uliRmapReadReg>
811064e0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config = uliReg;
811064e4:	e0bfff17 	ldw	r2,-4(fp)
811064e8:	e0fffe17 	ldw	r3,-8(fp)
811064ec:	10c01515 	stw	r3,84(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811064f0:	e0bfff17 	ldw	r2,-4(fp)
811064f4:	10800017 	ldw	r2,0(r2)
811064f8:	01401104 	movi	r5,68
811064fc:	1009883a 	mov	r4,r2
81106500:	11081ac0 	call	811081ac <uliRmapReadReg>
81106504:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81106508:	e0bfff17 	ldw	r2,-4(fp)
8110650c:	e0fffe17 	ldw	r3,-8(fp)
81106510:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106514:	e0bfff17 	ldw	r2,-4(fp)
81106518:	10800017 	ldw	r2,0(r2)
8110651c:	01401144 	movi	r5,69
81106520:	1009883a 	mov	r4,r2
81106524:	11081ac0 	call	811081ac <uliRmapReadReg>
81106528:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config = uliReg;
8110652c:	e0bfff17 	ldw	r2,-4(fp)
81106530:	e0fffe17 	ldw	r3,-8(fp)
81106534:	10c01715 	stw	r3,92(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106538:	e0bfff17 	ldw	r2,-4(fp)
8110653c:	10800017 	ldw	r2,0(r2)
81106540:	01401184 	movi	r5,70
81106544:	1009883a 	mov	r4,r2
81106548:	11081ac0 	call	811081ac <uliRmapReadReg>
8110654c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config = uliReg;
81106550:	e0bfff17 	ldw	r2,-4(fp)
81106554:	e0fffe17 	ldw	r3,-8(fp)
81106558:	10c01815 	stw	r3,96(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110655c:	e0bfff17 	ldw	r2,-4(fp)
81106560:	10800017 	ldw	r2,0(r2)
81106564:	014011c4 	movi	r5,71
81106568:	1009883a 	mov	r4,r2
8110656c:	11081ac0 	call	811081ac <uliRmapReadReg>
81106570:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config = uliReg;
81106574:	e0bfff17 	ldw	r2,-4(fp)
81106578:	e0fffe17 	ldw	r3,-8(fp)
8110657c:	10c01915 	stw	r3,100(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106580:	e0bfff17 	ldw	r2,-4(fp)
81106584:	10800017 	ldw	r2,0(r2)
81106588:	01401204 	movi	r5,72
8110658c:	1009883a 	mov	r4,r2
81106590:	11081ac0 	call	811081ac <uliRmapReadReg>
81106594:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config = uliReg;
81106598:	e0bfff17 	ldw	r2,-4(fp)
8110659c:	e0fffe17 	ldw	r3,-8(fp)
811065a0:	10c01a15 	stw	r3,104(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811065a4:	e0bfff17 	ldw	r2,-4(fp)
811065a8:	10800017 	ldw	r2,0(r2)
811065ac:	01401244 	movi	r5,73
811065b0:	1009883a 	mov	r4,r2
811065b4:	11081ac0 	call	811081ac <uliRmapReadReg>
811065b8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config = uliReg;
811065bc:	e0bfff17 	ldw	r2,-4(fp)
811065c0:	e0fffe17 	ldw	r3,-8(fp)
811065c4:	10c01b15 	stw	r3,108(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811065c8:	e0bfff17 	ldw	r2,-4(fp)
811065cc:	10800017 	ldw	r2,0(r2)
811065d0:	01401284 	movi	r5,74
811065d4:	1009883a 	mov	r4,r2
811065d8:	11081ac0 	call	811081ac <uliRmapReadReg>
811065dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config = uliReg;
811065e0:	e0bfff17 	ldw	r2,-4(fp)
811065e4:	e0fffe17 	ldw	r3,-8(fp)
811065e8:	10c01c15 	stw	r3,112(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811065ec:	e0bfff17 	ldw	r2,-4(fp)
811065f0:	10800017 	ldw	r2,0(r2)
811065f4:	014012c4 	movi	r5,75
811065f8:	1009883a 	mov	r4,r2
811065fc:	11081ac0 	call	811081ac <uliRmapReadReg>
81106600:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config = uliReg;
81106604:	e0bfff17 	ldw	r2,-4(fp)
81106608:	e0fffe17 	ldw	r3,-8(fp)
8110660c:	10c01d15 	stw	r3,116(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106610:	e0bfff17 	ldw	r2,-4(fp)
81106614:	10800017 	ldw	r2,0(r2)
81106618:	01401304 	movi	r5,76
8110661c:	1009883a 	mov	r4,r2
81106620:	11081ac0 	call	811081ac <uliRmapReadReg>
81106624:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_OP_MODE_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig = uliReg;
81106628:	e0bfff17 	ldw	r2,-4(fp)
8110662c:	e0fffe17 	ldw	r3,-8(fp)
81106630:	10c01e15 	stw	r3,120(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106634:	e0bfff17 	ldw	r2,-4(fp)
81106638:	10800017 	ldw	r2,0(r2)
8110663c:	01401344 	movi	r5,77
81106640:	1009883a 	mov	r4,r2
81106644:	11081ac0 	call	811081ac <uliRmapReadReg>
81106648:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SYNC_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSyncConfig = uliReg;
8110664c:	e0bfff17 	ldw	r2,-4(fp)
81106650:	e0fffe17 	ldw	r3,-8(fp)
81106654:	10c01f15 	stw	r3,124(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106658:	e0bfff17 	ldw	r2,-4(fp)
8110665c:	10800017 	ldw	r2,0(r2)
81106660:	01401384 	movi	r5,78
81106664:	1009883a 	mov	r4,r2
81106668:	11081ac0 	call	811081ac <uliRmapReadReg>
8110666c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_DAC_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliDacControl = uliReg;
81106670:	e0bfff17 	ldw	r2,-4(fp)
81106674:	e0fffe17 	ldw	r3,-8(fp)
81106678:	10c02015 	stw	r3,128(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110667c:	e0bfff17 	ldw	r2,-4(fp)
81106680:	10800017 	ldw	r2,0(r2)
81106684:	014013c4 	movi	r5,79
81106688:	1009883a 	mov	r4,r2
8110668c:	11081ac0 	call	811081ac <uliRmapReadReg>
81106690:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81106694:	e0bfff17 	ldw	r2,-4(fp)
81106698:	e0fffe17 	ldw	r3,-8(fp)
8110669c:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811066a0:	e0bfff17 	ldw	r2,-4(fp)
811066a4:	10800017 	ldw	r2,0(r2)
811066a8:	01401404 	movi	r5,80
811066ac:	1009883a 	mov	r4,r2
811066b0:	11081ac0 	call	811081ac <uliRmapReadReg>
811066b4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_FRAME_NUMBER_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811066b8:	e0bfff17 	ldw	r2,-4(fp)
811066bc:	e0fffe17 	ldw	r3,-8(fp)
811066c0:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811066c4:	e0bfff17 	ldw	r2,-4(fp)
811066c8:	10800017 	ldw	r2,0(r2)
811066cc:	01401444 	movi	r5,81
811066d0:	1009883a 	mov	r4,r2
811066d4:	11081ac0 	call	811081ac <uliRmapReadReg>
811066d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CURRENT_MODE_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCurrentMode = uliReg;
811066dc:	e0bfff17 	ldw	r2,-4(fp)
811066e0:	e0fffe17 	ldw	r3,-8(fp)
811066e4:	10c02315 	stw	r3,140(r2)

		bStatus = TRUE;
811066e8:	00800044 	movi	r2,1
811066ec:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811066f0:	e0bffd17 	ldw	r2,-12(fp)
}
811066f4:	e037883a 	mov	sp,fp
811066f8:	dfc00117 	ldw	ra,4(sp)
811066fc:	df000017 	ldw	fp,0(sp)
81106700:	dec00204 	addi	sp,sp,8
81106704:	f800283a 	ret

81106708 <bRmapGetMemConfigStat>:

bool bRmapGetMemConfigStat(TRmapChannel *pxRmapCh) {
81106708:	defffb04 	addi	sp,sp,-20
8110670c:	de00012e 	bgeu	sp,et,81106714 <bRmapGetMemConfigStat+0xc>
81106710:	003b68fa 	trap	3
81106714:	dfc00415 	stw	ra,16(sp)
81106718:	df000315 	stw	fp,12(sp)
8110671c:	df000304 	addi	fp,sp,12
81106720:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106724:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106728:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110672c:	e0bfff17 	ldw	r2,-4(fp)
81106730:	10001426 	beq	r2,zero,81106784 <bRmapGetMemConfigStat+0x7c>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106734:	e0bfff17 	ldw	r2,-4(fp)
81106738:	10800017 	ldw	r2,0(r2)
8110673c:	014001c4 	movi	r5,7
81106740:	1009883a 	mov	r4,r2
81106744:	11081ac0 	call	811081ac <uliRmapReadReg>
81106748:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_RD_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastReadAddress = (alt_u32) ((uliReg
8110674c:	e0bfff17 	ldw	r2,-4(fp)
81106750:	e0fffe17 	ldw	r3,-8(fp)
81106754:	10c02515 	stw	r3,148(r2)
				& COMM_RMAP_LST_RD_ADDR_MSK) >> 0);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106758:	e0bfff17 	ldw	r2,-4(fp)
8110675c:	10800017 	ldw	r2,0(r2)
81106760:	01400184 	movi	r5,6
81106764:	1009883a 	mov	r4,r2
81106768:	11081ac0 	call	811081ac <uliRmapReadReg>
8110676c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_WR_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastWriteAddress = (alt_u32) ((uliReg
81106770:	e0bfff17 	ldw	r2,-4(fp)
81106774:	e0fffe17 	ldw	r3,-8(fp)
81106778:	10c02415 	stw	r3,144(r2)
				& COMM_RMAP_LST_WR_ADDR_MSK) >> 0);

		bStatus = TRUE;
8110677c:	00800044 	movi	r2,1
81106780:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106784:	e0bffd17 	ldw	r2,-12(fp)
}
81106788:	e037883a 	mov	sp,fp
8110678c:	dfc00117 	ldw	ra,4(sp)
81106790:	df000017 	ldw	fp,0(sp)
81106794:	dec00204 	addi	sp,sp,8
81106798:	f800283a 	ret

8110679c <bRmapSetRmapMemHKArea>:

bool bRmapSetRmapMemHKArea(TRmapChannel *pxRmapCh) {
8110679c:	defffb04 	addi	sp,sp,-20
811067a0:	de00012e 	bgeu	sp,et,811067a8 <bRmapSetRmapMemHKArea+0xc>
811067a4:	003b68fa 	trap	3
811067a8:	dfc00415 	stw	ra,16(sp)
811067ac:	df000315 	stw	fp,12(sp)
811067b0:	df000304 	addi	fp,sp,12
811067b4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811067b8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811067bc:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811067c0:	e0bfff17 	ldw	r2,-4(fp)
811067c4:	10040226 	beq	r2,zero,811077d0 <bRmapSetRmapMemHKArea+0x1034>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811067c8:	e0bfff17 	ldw	r2,-4(fp)
811067cc:	10800017 	ldw	r2,0(r2)
811067d0:	01402804 	movi	r5,160
811067d4:	1009883a 	mov	r4,r2
811067d8:	11081ac0 	call	811081ac <uliRmapReadReg>
811067dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
811067e0:	e0bffe17 	ldw	r2,-8(fp)
811067e4:	10bfffec 	andhi	r2,r2,65535
811067e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
811067ec:	e0bfff17 	ldw	r2,-4(fp)
811067f0:	1080260b 	ldhu	r2,152(r2)
811067f4:	10bfffcc 	andi	r2,r2,65535
	if (pxRmapCh != NULL) {

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
811067f8:	e0fffe17 	ldw	r3,-8(fp)
811067fc:	1884b03a 	or	r2,r3,r2
81106800:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
81106804:	e0bffe17 	ldw	r2,-8(fp)
81106808:	10bfffcc 	andi	r2,r2,65535
8110680c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
81106810:	e0bfff17 	ldw	r2,-4(fp)
81106814:	1080268b 	ldhu	r2,154(r2)
81106818:	10bfffcc 	andi	r2,r2,65535
8110681c:	1004943a 	slli	r2,r2,16
81106820:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
81106824:	e0bffe17 	ldw	r2,-8(fp)
81106828:	10c4b03a 	or	r2,r2,r3
8110682c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_0_REG_OFST,
81106830:	e0bfff17 	ldw	r2,-4(fp)
81106834:	10800017 	ldw	r2,0(r2)
81106838:	e1bffe17 	ldw	r6,-8(fp)
8110683c:	01402804 	movi	r5,160
81106840:	1009883a 	mov	r4,r2
81106844:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106848:	e0bfff17 	ldw	r2,-4(fp)
8110684c:	10800017 	ldw	r2,0(r2)
81106850:	01402844 	movi	r5,161
81106854:	1009883a 	mov	r4,r2
81106858:	11081ac0 	call	811081ac <uliRmapReadReg>
8110685c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
81106860:	e0bffe17 	ldw	r2,-8(fp)
81106864:	10bfffec 	andhi	r2,r2,65535
81106868:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
8110686c:	e0bfff17 	ldw	r2,-4(fp)
81106870:	1080270b 	ldhu	r2,156(r2)
81106874:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
81106878:	e0fffe17 	ldw	r3,-8(fp)
8110687c:	1884b03a 	or	r2,r3,r2
81106880:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
81106884:	e0bffe17 	ldw	r2,-8(fp)
81106888:	10bfffcc 	andi	r2,r2,65535
8110688c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
81106890:	e0bfff17 	ldw	r2,-4(fp)
81106894:	1080278b 	ldhu	r2,158(r2)
81106898:	10bfffcc 	andi	r2,r2,65535
8110689c:	1004943a 	slli	r2,r2,16
811068a0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
811068a4:	e0bffe17 	ldw	r2,-8(fp)
811068a8:	10c4b03a 	or	r2,r2,r3
811068ac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_1_REG_OFST,
811068b0:	e0bfff17 	ldw	r2,-4(fp)
811068b4:	10800017 	ldw	r2,0(r2)
811068b8:	e1bffe17 	ldw	r6,-8(fp)
811068bc:	01402844 	movi	r5,161
811068c0:	1009883a 	mov	r4,r2
811068c4:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811068c8:	e0bfff17 	ldw	r2,-4(fp)
811068cc:	10800017 	ldw	r2,0(r2)
811068d0:	01402884 	movi	r5,162
811068d4:	1009883a 	mov	r4,r2
811068d8:	11081ac0 	call	811081ac <uliRmapReadReg>
811068dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
811068e0:	e0bffe17 	ldw	r2,-8(fp)
811068e4:	10bfffec 	andhi	r2,r2,65535
811068e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
811068ec:	e0bfff17 	ldw	r2,-4(fp)
811068f0:	1080280b 	ldhu	r2,160(r2)
811068f4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
811068f8:	e0fffe17 	ldw	r3,-8(fp)
811068fc:	1884b03a 	or	r2,r3,r2
81106900:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
81106904:	e0bffe17 	ldw	r2,-8(fp)
81106908:	10bfffcc 	andi	r2,r2,65535
8110690c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
81106910:	e0bfff17 	ldw	r2,-4(fp)
81106914:	1080288b 	ldhu	r2,162(r2)
81106918:	10bfffcc 	andi	r2,r2,65535
8110691c:	1004943a 	slli	r2,r2,16
81106920:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
81106924:	e0bffe17 	ldw	r2,-8(fp)
81106928:	10c4b03a 	or	r2,r2,r3
8110692c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_2_REG_OFST,
81106930:	e0bfff17 	ldw	r2,-4(fp)
81106934:	10800017 	ldw	r2,0(r2)
81106938:	e1bffe17 	ldw	r6,-8(fp)
8110693c:	01402884 	movi	r5,162
81106940:	1009883a 	mov	r4,r2
81106944:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106948:	e0bfff17 	ldw	r2,-4(fp)
8110694c:	10800017 	ldw	r2,0(r2)
81106950:	014028c4 	movi	r5,163
81106954:	1009883a 	mov	r4,r2
81106958:	11081ac0 	call	811081ac <uliRmapReadReg>
8110695c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
81106960:	e0bffe17 	ldw	r2,-8(fp)
81106964:	10bfffec 	andhi	r2,r2,65535
81106968:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
8110696c:	e0bfff17 	ldw	r2,-4(fp)
81106970:	1080290b 	ldhu	r2,164(r2)
81106974:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
81106978:	e0fffe17 	ldw	r3,-8(fp)
8110697c:	1884b03a 	or	r2,r3,r2
81106980:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
81106984:	e0bffe17 	ldw	r2,-8(fp)
81106988:	10bfffcc 	andi	r2,r2,65535
8110698c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
81106990:	e0bfff17 	ldw	r2,-4(fp)
81106994:	1080298b 	ldhu	r2,166(r2)
81106998:	10bfffcc 	andi	r2,r2,65535
8110699c:	1004943a 	slli	r2,r2,16
811069a0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
811069a4:	e0bffe17 	ldw	r2,-8(fp)
811069a8:	10c4b03a 	or	r2,r2,r3
811069ac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_3_REG_OFST,
811069b0:	e0bfff17 	ldw	r2,-4(fp)
811069b4:	10800017 	ldw	r2,0(r2)
811069b8:	e1bffe17 	ldw	r6,-8(fp)
811069bc:	014028c4 	movi	r5,163
811069c0:	1009883a 	mov	r4,r2
811069c4:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811069c8:	e0bfff17 	ldw	r2,-4(fp)
811069cc:	10800017 	ldw	r2,0(r2)
811069d0:	01402904 	movi	r5,164
811069d4:	1009883a 	mov	r4,r2
811069d8:	11081ac0 	call	811081ac <uliRmapReadReg>
811069dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
811069e0:	e0bffe17 	ldw	r2,-8(fp)
811069e4:	10bfffec 	andhi	r2,r2,65535
811069e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
811069ec:	e0bfff17 	ldw	r2,-4(fp)
811069f0:	10802a0b 	ldhu	r2,168(r2)
811069f4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
811069f8:	e0fffe17 	ldw	r3,-8(fp)
811069fc:	1884b03a 	or	r2,r3,r2
81106a00:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
81106a04:	e0bffe17 	ldw	r2,-8(fp)
81106a08:	10bfffcc 	andi	r2,r2,65535
81106a0c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
81106a10:	e0bfff17 	ldw	r2,-4(fp)
81106a14:	10802a8b 	ldhu	r2,170(r2)
81106a18:	10bfffcc 	andi	r2,r2,65535
81106a1c:	1004943a 	slli	r2,r2,16
81106a20:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
81106a24:	e0bffe17 	ldw	r2,-8(fp)
81106a28:	10c4b03a 	or	r2,r2,r3
81106a2c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_4_REG_OFST,
81106a30:	e0bfff17 	ldw	r2,-4(fp)
81106a34:	10800017 	ldw	r2,0(r2)
81106a38:	e1bffe17 	ldw	r6,-8(fp)
81106a3c:	01402904 	movi	r5,164
81106a40:	1009883a 	mov	r4,r2
81106a44:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106a48:	e0bfff17 	ldw	r2,-4(fp)
81106a4c:	10800017 	ldw	r2,0(r2)
81106a50:	01402944 	movi	r5,165
81106a54:	1009883a 	mov	r4,r2
81106a58:	11081ac0 	call	811081ac <uliRmapReadReg>
81106a5c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
81106a60:	e0bffe17 	ldw	r2,-8(fp)
81106a64:	10bfffec 	andhi	r2,r2,65535
81106a68:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
81106a6c:	e0bfff17 	ldw	r2,-4(fp)
81106a70:	10802b0b 	ldhu	r2,172(r2)
81106a74:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
81106a78:	e0fffe17 	ldw	r3,-8(fp)
81106a7c:	1884b03a 	or	r2,r3,r2
81106a80:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
81106a84:	e0bffe17 	ldw	r2,-8(fp)
81106a88:	10bfffcc 	andi	r2,r2,65535
81106a8c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
81106a90:	e0bfff17 	ldw	r2,-4(fp)
81106a94:	10802b8b 	ldhu	r2,174(r2)
81106a98:	10bfffcc 	andi	r2,r2,65535
81106a9c:	1004943a 	slli	r2,r2,16
81106aa0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
81106aa4:	e0bffe17 	ldw	r2,-8(fp)
81106aa8:	10c4b03a 	or	r2,r2,r3
81106aac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_5_REG_OFST,
81106ab0:	e0bfff17 	ldw	r2,-4(fp)
81106ab4:	10800017 	ldw	r2,0(r2)
81106ab8:	e1bffe17 	ldw	r6,-8(fp)
81106abc:	01402944 	movi	r5,165
81106ac0:	1009883a 	mov	r4,r2
81106ac4:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106ac8:	e0bfff17 	ldw	r2,-4(fp)
81106acc:	10800017 	ldw	r2,0(r2)
81106ad0:	01402984 	movi	r5,166
81106ad4:	1009883a 	mov	r4,r2
81106ad8:	11081ac0 	call	811081ac <uliRmapReadReg>
81106adc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
81106ae0:	e0bffe17 	ldw	r2,-8(fp)
81106ae4:	10bfffec 	andhi	r2,r2,65535
81106ae8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
81106aec:	e0bfff17 	ldw	r2,-4(fp)
81106af0:	10802c0b 	ldhu	r2,176(r2)
81106af4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
81106af8:	e0fffe17 	ldw	r3,-8(fp)
81106afc:	1884b03a 	or	r2,r3,r2
81106b00:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
81106b04:	e0bffe17 	ldw	r2,-8(fp)
81106b08:	10bfffcc 	andi	r2,r2,65535
81106b0c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
81106b10:	e0bfff17 	ldw	r2,-4(fp)
81106b14:	10802c8b 	ldhu	r2,178(r2)
81106b18:	10bfffcc 	andi	r2,r2,65535
81106b1c:	1004943a 	slli	r2,r2,16
81106b20:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
81106b24:	e0bffe17 	ldw	r2,-8(fp)
81106b28:	10c4b03a 	or	r2,r2,r3
81106b2c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_6_REG_OFST,
81106b30:	e0bfff17 	ldw	r2,-4(fp)
81106b34:	10800017 	ldw	r2,0(r2)
81106b38:	e1bffe17 	ldw	r6,-8(fp)
81106b3c:	01402984 	movi	r5,166
81106b40:	1009883a 	mov	r4,r2
81106b44:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106b48:	e0bfff17 	ldw	r2,-4(fp)
81106b4c:	10800017 	ldw	r2,0(r2)
81106b50:	014029c4 	movi	r5,167
81106b54:	1009883a 	mov	r4,r2
81106b58:	11081ac0 	call	811081ac <uliRmapReadReg>
81106b5c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
81106b60:	e0bffe17 	ldw	r2,-8(fp)
81106b64:	10bfffec 	andhi	r2,r2,65535
81106b68:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
81106b6c:	e0bfff17 	ldw	r2,-4(fp)
81106b70:	10802d0b 	ldhu	r2,180(r2)
81106b74:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
81106b78:	e0fffe17 	ldw	r3,-8(fp)
81106b7c:	1884b03a 	or	r2,r3,r2
81106b80:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
81106b84:	e0bffe17 	ldw	r2,-8(fp)
81106b88:	10bfffcc 	andi	r2,r2,65535
81106b8c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
81106b90:	e0bfff17 	ldw	r2,-4(fp)
81106b94:	10802d8b 	ldhu	r2,182(r2)
81106b98:	10bfffcc 	andi	r2,r2,65535
81106b9c:	1004943a 	slli	r2,r2,16
81106ba0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
81106ba4:	e0bffe17 	ldw	r2,-8(fp)
81106ba8:	10c4b03a 	or	r2,r2,r3
81106bac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_7_REG_OFST,
81106bb0:	e0bfff17 	ldw	r2,-4(fp)
81106bb4:	10800017 	ldw	r2,0(r2)
81106bb8:	e1bffe17 	ldw	r6,-8(fp)
81106bbc:	014029c4 	movi	r5,167
81106bc0:	1009883a 	mov	r4,r2
81106bc4:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106bc8:	e0bfff17 	ldw	r2,-4(fp)
81106bcc:	10800017 	ldw	r2,0(r2)
81106bd0:	01402a04 	movi	r5,168
81106bd4:	1009883a 	mov	r4,r2
81106bd8:	11081ac0 	call	811081ac <uliRmapReadReg>
81106bdc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
81106be0:	e0bffe17 	ldw	r2,-8(fp)
81106be4:	10bfffec 	andhi	r2,r2,65535
81106be8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
81106bec:	e0bfff17 	ldw	r2,-4(fp)
81106bf0:	10802e0b 	ldhu	r2,184(r2)
81106bf4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
81106bf8:	e0fffe17 	ldw	r3,-8(fp)
81106bfc:	1884b03a 	or	r2,r3,r2
81106c00:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
81106c04:	e0bffe17 	ldw	r2,-8(fp)
81106c08:	10bfffcc 	andi	r2,r2,65535
81106c0c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
81106c10:	e0bfff17 	ldw	r2,-4(fp)
81106c14:	10802e8b 	ldhu	r2,186(r2)
81106c18:	10bfffcc 	andi	r2,r2,65535
81106c1c:	1004943a 	slli	r2,r2,16
81106c20:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
81106c24:	e0bffe17 	ldw	r2,-8(fp)
81106c28:	10c4b03a 	or	r2,r2,r3
81106c2c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_8_REG_OFST,
81106c30:	e0bfff17 	ldw	r2,-4(fp)
81106c34:	10800017 	ldw	r2,0(r2)
81106c38:	e1bffe17 	ldw	r6,-8(fp)
81106c3c:	01402a04 	movi	r5,168
81106c40:	1009883a 	mov	r4,r2
81106c44:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106c48:	e0bfff17 	ldw	r2,-4(fp)
81106c4c:	10800017 	ldw	r2,0(r2)
81106c50:	01402a44 	movi	r5,169
81106c54:	1009883a 	mov	r4,r2
81106c58:	11081ac0 	call	811081ac <uliRmapReadReg>
81106c5c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
81106c60:	e0bffe17 	ldw	r2,-8(fp)
81106c64:	10bfffec 	andhi	r2,r2,65535
81106c68:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
81106c6c:	e0bfff17 	ldw	r2,-4(fp)
81106c70:	10802f0b 	ldhu	r2,188(r2)
81106c74:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
81106c78:	e0fffe17 	ldw	r3,-8(fp)
81106c7c:	1884b03a 	or	r2,r3,r2
81106c80:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
81106c84:	e0bffe17 	ldw	r2,-8(fp)
81106c88:	10bfffcc 	andi	r2,r2,65535
81106c8c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
81106c90:	e0bfff17 	ldw	r2,-4(fp)
81106c94:	10802f8b 	ldhu	r2,190(r2)
81106c98:	10bfffcc 	andi	r2,r2,65535
81106c9c:	1004943a 	slli	r2,r2,16
81106ca0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
81106ca4:	e0bffe17 	ldw	r2,-8(fp)
81106ca8:	10c4b03a 	or	r2,r2,r3
81106cac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_9_REG_OFST,
81106cb0:	e0bfff17 	ldw	r2,-4(fp)
81106cb4:	10800017 	ldw	r2,0(r2)
81106cb8:	e1bffe17 	ldw	r6,-8(fp)
81106cbc:	01402a44 	movi	r5,169
81106cc0:	1009883a 	mov	r4,r2
81106cc4:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106cc8:	e0bfff17 	ldw	r2,-4(fp)
81106ccc:	10800017 	ldw	r2,0(r2)
81106cd0:	01402a84 	movi	r5,170
81106cd4:	1009883a 	mov	r4,r2
81106cd8:	11081ac0 	call	811081ac <uliRmapReadReg>
81106cdc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
81106ce0:	e0bffe17 	ldw	r2,-8(fp)
81106ce4:	10bfffec 	andhi	r2,r2,65535
81106ce8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
81106cec:	e0bfff17 	ldw	r2,-4(fp)
81106cf0:	1080300b 	ldhu	r2,192(r2)
81106cf4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
81106cf8:	e0fffe17 	ldw	r3,-8(fp)
81106cfc:	1884b03a 	or	r2,r3,r2
81106d00:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
81106d04:	e0bffe17 	ldw	r2,-8(fp)
81106d08:	10bfffcc 	andi	r2,r2,65535
81106d0c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
81106d10:	e0bfff17 	ldw	r2,-4(fp)
81106d14:	1080308b 	ldhu	r2,194(r2)
81106d18:	10bfffcc 	andi	r2,r2,65535
81106d1c:	1004943a 	slli	r2,r2,16
81106d20:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
81106d24:	e0bffe17 	ldw	r2,-8(fp)
81106d28:	10c4b03a 	or	r2,r2,r3
81106d2c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_10_REG_OFST,
81106d30:	e0bfff17 	ldw	r2,-4(fp)
81106d34:	10800017 	ldw	r2,0(r2)
81106d38:	e1bffe17 	ldw	r6,-8(fp)
81106d3c:	01402a84 	movi	r5,170
81106d40:	1009883a 	mov	r4,r2
81106d44:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106d48:	e0bfff17 	ldw	r2,-4(fp)
81106d4c:	10800017 	ldw	r2,0(r2)
81106d50:	01402ac4 	movi	r5,171
81106d54:	1009883a 	mov	r4,r2
81106d58:	11081ac0 	call	811081ac <uliRmapReadReg>
81106d5c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
81106d60:	e0bffe17 	ldw	r2,-8(fp)
81106d64:	10bfffec 	andhi	r2,r2,65535
81106d68:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
81106d6c:	e0bfff17 	ldw	r2,-4(fp)
81106d70:	1080310b 	ldhu	r2,196(r2)
81106d74:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
81106d78:	e0fffe17 	ldw	r3,-8(fp)
81106d7c:	1884b03a 	or	r2,r3,r2
81106d80:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
81106d84:	e0bffe17 	ldw	r2,-8(fp)
81106d88:	10bfffcc 	andi	r2,r2,65535
81106d8c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
81106d90:	e0bfff17 	ldw	r2,-4(fp)
81106d94:	1080318b 	ldhu	r2,198(r2)
81106d98:	10bfffcc 	andi	r2,r2,65535
81106d9c:	1004943a 	slli	r2,r2,16
81106da0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
81106da4:	e0bffe17 	ldw	r2,-8(fp)
81106da8:	10c4b03a 	or	r2,r2,r3
81106dac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_11_REG_OFST,
81106db0:	e0bfff17 	ldw	r2,-4(fp)
81106db4:	10800017 	ldw	r2,0(r2)
81106db8:	e1bffe17 	ldw	r6,-8(fp)
81106dbc:	01402ac4 	movi	r5,171
81106dc0:	1009883a 	mov	r4,r2
81106dc4:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106dc8:	e0bfff17 	ldw	r2,-4(fp)
81106dcc:	10800017 	ldw	r2,0(r2)
81106dd0:	01402b04 	movi	r5,172
81106dd4:	1009883a 	mov	r4,r2
81106dd8:	11081ac0 	call	811081ac <uliRmapReadReg>
81106ddc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
81106de0:	e0bffe17 	ldw	r2,-8(fp)
81106de4:	10bfffec 	andhi	r2,r2,65535
81106de8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
81106dec:	e0bfff17 	ldw	r2,-4(fp)
81106df0:	1080320b 	ldhu	r2,200(r2)
81106df4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
81106df8:	e0fffe17 	ldw	r3,-8(fp)
81106dfc:	1884b03a 	or	r2,r3,r2
81106e00:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
81106e04:	e0bffe17 	ldw	r2,-8(fp)
81106e08:	10bfffcc 	andi	r2,r2,65535
81106e0c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
81106e10:	e0bfff17 	ldw	r2,-4(fp)
81106e14:	1080328b 	ldhu	r2,202(r2)
81106e18:	10bfffcc 	andi	r2,r2,65535
81106e1c:	1004943a 	slli	r2,r2,16
81106e20:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
81106e24:	e0bffe17 	ldw	r2,-8(fp)
81106e28:	10c4b03a 	or	r2,r2,r3
81106e2c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_12_REG_OFST,
81106e30:	e0bfff17 	ldw	r2,-4(fp)
81106e34:	10800017 	ldw	r2,0(r2)
81106e38:	e1bffe17 	ldw	r6,-8(fp)
81106e3c:	01402b04 	movi	r5,172
81106e40:	1009883a 	mov	r4,r2
81106e44:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106e48:	e0bfff17 	ldw	r2,-4(fp)
81106e4c:	10800017 	ldw	r2,0(r2)
81106e50:	01402b44 	movi	r5,173
81106e54:	1009883a 	mov	r4,r2
81106e58:	11081ac0 	call	811081ac <uliRmapReadReg>
81106e5c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
81106e60:	e0bffe17 	ldw	r2,-8(fp)
81106e64:	10bfffec 	andhi	r2,r2,65535
81106e68:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
81106e6c:	e0bfff17 	ldw	r2,-4(fp)
81106e70:	1080330b 	ldhu	r2,204(r2)
81106e74:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
81106e78:	e0fffe17 	ldw	r3,-8(fp)
81106e7c:	1884b03a 	or	r2,r3,r2
81106e80:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
81106e84:	e0bffe17 	ldw	r2,-8(fp)
81106e88:	10bfffcc 	andi	r2,r2,65535
81106e8c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
81106e90:	e0bfff17 	ldw	r2,-4(fp)
81106e94:	1080338b 	ldhu	r2,206(r2)
81106e98:	10bfffcc 	andi	r2,r2,65535
81106e9c:	1004943a 	slli	r2,r2,16
81106ea0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
81106ea4:	e0bffe17 	ldw	r2,-8(fp)
81106ea8:	10c4b03a 	or	r2,r2,r3
81106eac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_13_REG_OFST,
81106eb0:	e0bfff17 	ldw	r2,-4(fp)
81106eb4:	10800017 	ldw	r2,0(r2)
81106eb8:	e1bffe17 	ldw	r6,-8(fp)
81106ebc:	01402b44 	movi	r5,173
81106ec0:	1009883a 	mov	r4,r2
81106ec4:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106ec8:	e0bfff17 	ldw	r2,-4(fp)
81106ecc:	10800017 	ldw	r2,0(r2)
81106ed0:	01402b84 	movi	r5,174
81106ed4:	1009883a 	mov	r4,r2
81106ed8:	11081ac0 	call	811081ac <uliRmapReadReg>
81106edc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
81106ee0:	e0bffe17 	ldw	r2,-8(fp)
81106ee4:	10bfffec 	andhi	r2,r2,65535
81106ee8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
81106eec:	e0bfff17 	ldw	r2,-4(fp)
81106ef0:	1080340b 	ldhu	r2,208(r2)
81106ef4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
81106ef8:	e0fffe17 	ldw	r3,-8(fp)
81106efc:	1884b03a 	or	r2,r3,r2
81106f00:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
81106f04:	e0bffe17 	ldw	r2,-8(fp)
81106f08:	10bfffcc 	andi	r2,r2,65535
81106f0c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
81106f10:	e0bfff17 	ldw	r2,-4(fp)
81106f14:	1080348b 	ldhu	r2,210(r2)
81106f18:	10bfffcc 	andi	r2,r2,65535
81106f1c:	1004943a 	slli	r2,r2,16
81106f20:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
81106f24:	e0bffe17 	ldw	r2,-8(fp)
81106f28:	10c4b03a 	or	r2,r2,r3
81106f2c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_14_REG_OFST,
81106f30:	e0bfff17 	ldw	r2,-4(fp)
81106f34:	10800017 	ldw	r2,0(r2)
81106f38:	e1bffe17 	ldw	r6,-8(fp)
81106f3c:	01402b84 	movi	r5,174
81106f40:	1009883a 	mov	r4,r2
81106f44:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106f48:	e0bfff17 	ldw	r2,-4(fp)
81106f4c:	10800017 	ldw	r2,0(r2)
81106f50:	01402bc4 	movi	r5,175
81106f54:	1009883a 	mov	r4,r2
81106f58:	11081ac0 	call	811081ac <uliRmapReadReg>
81106f5c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
81106f60:	e0bffe17 	ldw	r2,-8(fp)
81106f64:	10bfffec 	andhi	r2,r2,65535
81106f68:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
81106f6c:	e0bfff17 	ldw	r2,-4(fp)
81106f70:	1080350b 	ldhu	r2,212(r2)
81106f74:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
81106f78:	e0fffe17 	ldw	r3,-8(fp)
81106f7c:	1884b03a 	or	r2,r3,r2
81106f80:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
81106f84:	e0bffe17 	ldw	r2,-8(fp)
81106f88:	10bfffcc 	andi	r2,r2,65535
81106f8c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
81106f90:	e0bfff17 	ldw	r2,-4(fp)
81106f94:	1080358b 	ldhu	r2,214(r2)
81106f98:	10bfffcc 	andi	r2,r2,65535
81106f9c:	1004943a 	slli	r2,r2,16
81106fa0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
81106fa4:	e0bffe17 	ldw	r2,-8(fp)
81106fa8:	10c4b03a 	or	r2,r2,r3
81106fac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_15_REG_OFST,
81106fb0:	e0bfff17 	ldw	r2,-4(fp)
81106fb4:	10800017 	ldw	r2,0(r2)
81106fb8:	e1bffe17 	ldw	r6,-8(fp)
81106fbc:	01402bc4 	movi	r5,175
81106fc0:	1009883a 	mov	r4,r2
81106fc4:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106fc8:	e0bfff17 	ldw	r2,-4(fp)
81106fcc:	10800017 	ldw	r2,0(r2)
81106fd0:	01402c04 	movi	r5,176
81106fd4:	1009883a 	mov	r4,r2
81106fd8:	11081ac0 	call	811081ac <uliRmapReadReg>
81106fdc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
81106fe0:	e0bffe17 	ldw	r2,-8(fp)
81106fe4:	10bfffec 	andhi	r2,r2,65535
81106fe8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
81106fec:	e0bfff17 	ldw	r2,-4(fp)
81106ff0:	1080360b 	ldhu	r2,216(r2)
81106ff4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
81106ff8:	e0fffe17 	ldw	r3,-8(fp)
81106ffc:	1884b03a 	or	r2,r3,r2
81107000:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
81107004:	e0bffe17 	ldw	r2,-8(fp)
81107008:	10bfffcc 	andi	r2,r2,65535
8110700c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
81107010:	e0bfff17 	ldw	r2,-4(fp)
81107014:	1080368b 	ldhu	r2,218(r2)
81107018:	10bfffcc 	andi	r2,r2,65535
8110701c:	1004943a 	slli	r2,r2,16
81107020:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
81107024:	e0bffe17 	ldw	r2,-8(fp)
81107028:	10c4b03a 	or	r2,r2,r3
8110702c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_16_REG_OFST,
81107030:	e0bfff17 	ldw	r2,-4(fp)
81107034:	10800017 	ldw	r2,0(r2)
81107038:	e1bffe17 	ldw	r6,-8(fp)
8110703c:	01402c04 	movi	r5,176
81107040:	1009883a 	mov	r4,r2
81107044:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107048:	e0bfff17 	ldw	r2,-4(fp)
8110704c:	10800017 	ldw	r2,0(r2)
81107050:	01402c44 	movi	r5,177
81107054:	1009883a 	mov	r4,r2
81107058:	11081ac0 	call	811081ac <uliRmapReadReg>
8110705c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
81107060:	e0bffe17 	ldw	r2,-8(fp)
81107064:	10bfffec 	andhi	r2,r2,65535
81107068:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
8110706c:	e0bfff17 	ldw	r2,-4(fp)
81107070:	1080370b 	ldhu	r2,220(r2)
81107074:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
81107078:	e0fffe17 	ldw	r3,-8(fp)
8110707c:	1884b03a 	or	r2,r3,r2
81107080:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
81107084:	e0bffe17 	ldw	r2,-8(fp)
81107088:	10bfffcc 	andi	r2,r2,65535
8110708c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
81107090:	e0bfff17 	ldw	r2,-4(fp)
81107094:	1080378b 	ldhu	r2,222(r2)
81107098:	10bfffcc 	andi	r2,r2,65535
8110709c:	1004943a 	slli	r2,r2,16
811070a0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
811070a4:	e0bffe17 	ldw	r2,-8(fp)
811070a8:	10c4b03a 	or	r2,r2,r3
811070ac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_17_REG_OFST,
811070b0:	e0bfff17 	ldw	r2,-4(fp)
811070b4:	10800017 	ldw	r2,0(r2)
811070b8:	e1bffe17 	ldw	r6,-8(fp)
811070bc:	01402c44 	movi	r5,177
811070c0:	1009883a 	mov	r4,r2
811070c4:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811070c8:	e0bfff17 	ldw	r2,-4(fp)
811070cc:	10800017 	ldw	r2,0(r2)
811070d0:	01402c84 	movi	r5,178
811070d4:	1009883a 	mov	r4,r2
811070d8:	11081ac0 	call	811081ac <uliRmapReadReg>
811070dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
811070e0:	e0bffe17 	ldw	r2,-8(fp)
811070e4:	10bfffec 	andhi	r2,r2,65535
811070e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
811070ec:	e0bfff17 	ldw	r2,-4(fp)
811070f0:	1080380b 	ldhu	r2,224(r2)
811070f4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
811070f8:	e0fffe17 	ldw	r3,-8(fp)
811070fc:	1884b03a 	or	r2,r3,r2
81107100:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
81107104:	e0bffe17 	ldw	r2,-8(fp)
81107108:	10bfffcc 	andi	r2,r2,65535
8110710c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
81107110:	e0bfff17 	ldw	r2,-4(fp)
81107114:	1080388b 	ldhu	r2,226(r2)
81107118:	10bfffcc 	andi	r2,r2,65535
8110711c:	1004943a 	slli	r2,r2,16
81107120:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
81107124:	e0bffe17 	ldw	r2,-8(fp)
81107128:	10c4b03a 	or	r2,r2,r3
8110712c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_18_REG_OFST,
81107130:	e0bfff17 	ldw	r2,-4(fp)
81107134:	10800017 	ldw	r2,0(r2)
81107138:	e1bffe17 	ldw	r6,-8(fp)
8110713c:	01402c84 	movi	r5,178
81107140:	1009883a 	mov	r4,r2
81107144:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107148:	e0bfff17 	ldw	r2,-4(fp)
8110714c:	10800017 	ldw	r2,0(r2)
81107150:	01402cc4 	movi	r5,179
81107154:	1009883a 	mov	r4,r2
81107158:	11081ac0 	call	811081ac <uliRmapReadReg>
8110715c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
81107160:	e0bffe17 	ldw	r2,-8(fp)
81107164:	10bfffec 	andhi	r2,r2,65535
81107168:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
8110716c:	e0bfff17 	ldw	r2,-4(fp)
81107170:	1080390b 	ldhu	r2,228(r2)
81107174:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
81107178:	e0fffe17 	ldw	r3,-8(fp)
8110717c:	1884b03a 	or	r2,r3,r2
81107180:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
81107184:	e0bffe17 	ldw	r2,-8(fp)
81107188:	10bfffcc 	andi	r2,r2,65535
8110718c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
81107190:	e0bfff17 	ldw	r2,-4(fp)
81107194:	1080398b 	ldhu	r2,230(r2)
81107198:	10bfffcc 	andi	r2,r2,65535
8110719c:	1004943a 	slli	r2,r2,16
811071a0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
811071a4:	e0bffe17 	ldw	r2,-8(fp)
811071a8:	10c4b03a 	or	r2,r2,r3
811071ac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_19_REG_OFST,
811071b0:	e0bfff17 	ldw	r2,-4(fp)
811071b4:	10800017 	ldw	r2,0(r2)
811071b8:	e1bffe17 	ldw	r6,-8(fp)
811071bc:	01402cc4 	movi	r5,179
811071c0:	1009883a 	mov	r4,r2
811071c4:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811071c8:	e0bfff17 	ldw	r2,-4(fp)
811071cc:	10800017 	ldw	r2,0(r2)
811071d0:	01402d04 	movi	r5,180
811071d4:	1009883a 	mov	r4,r2
811071d8:	11081ac0 	call	811081ac <uliRmapReadReg>
811071dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
811071e0:	e0bffe17 	ldw	r2,-8(fp)
811071e4:	10bfffec 	andhi	r2,r2,65535
811071e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
811071ec:	e0bfff17 	ldw	r2,-4(fp)
811071f0:	10803a0b 	ldhu	r2,232(r2)
811071f4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
811071f8:	e0fffe17 	ldw	r3,-8(fp)
811071fc:	1884b03a 	or	r2,r3,r2
81107200:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
81107204:	e0bffe17 	ldw	r2,-8(fp)
81107208:	10bfffcc 	andi	r2,r2,65535
8110720c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
81107210:	e0bfff17 	ldw	r2,-4(fp)
81107214:	10803a8b 	ldhu	r2,234(r2)
81107218:	10bfffcc 	andi	r2,r2,65535
8110721c:	1004943a 	slli	r2,r2,16
81107220:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
81107224:	e0bffe17 	ldw	r2,-8(fp)
81107228:	10c4b03a 	or	r2,r2,r3
8110722c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_20_REG_OFST,
81107230:	e0bfff17 	ldw	r2,-4(fp)
81107234:	10800017 	ldw	r2,0(r2)
81107238:	e1bffe17 	ldw	r6,-8(fp)
8110723c:	01402d04 	movi	r5,180
81107240:	1009883a 	mov	r4,r2
81107244:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107248:	e0bfff17 	ldw	r2,-4(fp)
8110724c:	10800017 	ldw	r2,0(r2)
81107250:	01402d44 	movi	r5,181
81107254:	1009883a 	mov	r4,r2
81107258:	11081ac0 	call	811081ac <uliRmapReadReg>
8110725c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
81107260:	e0bffe17 	ldw	r2,-8(fp)
81107264:	10bfffec 	andhi	r2,r2,65535
81107268:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
8110726c:	e0bfff17 	ldw	r2,-4(fp)
81107270:	10803b0b 	ldhu	r2,236(r2)
81107274:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
81107278:	e0fffe17 	ldw	r3,-8(fp)
8110727c:	1884b03a 	or	r2,r3,r2
81107280:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
81107284:	e0bffe17 	ldw	r2,-8(fp)
81107288:	10bfffcc 	andi	r2,r2,65535
8110728c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
81107290:	e0bfff17 	ldw	r2,-4(fp)
81107294:	10803b8b 	ldhu	r2,238(r2)
81107298:	10bfffcc 	andi	r2,r2,65535
8110729c:	1004943a 	slli	r2,r2,16
811072a0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
811072a4:	e0bffe17 	ldw	r2,-8(fp)
811072a8:	10c4b03a 	or	r2,r2,r3
811072ac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_21_REG_OFST,
811072b0:	e0bfff17 	ldw	r2,-4(fp)
811072b4:	10800017 	ldw	r2,0(r2)
811072b8:	e1bffe17 	ldw	r6,-8(fp)
811072bc:	01402d44 	movi	r5,181
811072c0:	1009883a 	mov	r4,r2
811072c4:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811072c8:	e0bfff17 	ldw	r2,-4(fp)
811072cc:	10800017 	ldw	r2,0(r2)
811072d0:	01402d84 	movi	r5,182
811072d4:	1009883a 	mov	r4,r2
811072d8:	11081ac0 	call	811081ac <uliRmapReadReg>
811072dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
811072e0:	e0bffe17 	ldw	r2,-8(fp)
811072e4:	10bfffec 	andhi	r2,r2,65535
811072e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
811072ec:	e0bfff17 	ldw	r2,-4(fp)
811072f0:	10803c0b 	ldhu	r2,240(r2)
811072f4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
811072f8:	e0fffe17 	ldw	r3,-8(fp)
811072fc:	1884b03a 	or	r2,r3,r2
81107300:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
81107304:	e0bffe17 	ldw	r2,-8(fp)
81107308:	10bfffcc 	andi	r2,r2,65535
8110730c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
81107310:	e0bfff17 	ldw	r2,-4(fp)
81107314:	10803c8b 	ldhu	r2,242(r2)
81107318:	10bfffcc 	andi	r2,r2,65535
8110731c:	1004943a 	slli	r2,r2,16
81107320:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
81107324:	e0bffe17 	ldw	r2,-8(fp)
81107328:	10c4b03a 	or	r2,r2,r3
8110732c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_22_REG_OFST,
81107330:	e0bfff17 	ldw	r2,-4(fp)
81107334:	10800017 	ldw	r2,0(r2)
81107338:	e1bffe17 	ldw	r6,-8(fp)
8110733c:	01402d84 	movi	r5,182
81107340:	1009883a 	mov	r4,r2
81107344:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107348:	e0bfff17 	ldw	r2,-4(fp)
8110734c:	10800017 	ldw	r2,0(r2)
81107350:	01402dc4 	movi	r5,183
81107354:	1009883a 	mov	r4,r2
81107358:	11081ac0 	call	811081ac <uliRmapReadReg>
8110735c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
81107360:	e0bffe17 	ldw	r2,-8(fp)
81107364:	10bfffec 	andhi	r2,r2,65535
81107368:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
8110736c:	e0bfff17 	ldw	r2,-4(fp)
81107370:	10803d0b 	ldhu	r2,244(r2)
81107374:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
81107378:	e0fffe17 	ldw	r3,-8(fp)
8110737c:	1884b03a 	or	r2,r3,r2
81107380:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
81107384:	e0bffe17 	ldw	r2,-8(fp)
81107388:	10bfffcc 	andi	r2,r2,65535
8110738c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
81107390:	e0bfff17 	ldw	r2,-4(fp)
81107394:	10803d8b 	ldhu	r2,246(r2)
81107398:	10bfffcc 	andi	r2,r2,65535
8110739c:	1004943a 	slli	r2,r2,16
811073a0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
811073a4:	e0bffe17 	ldw	r2,-8(fp)
811073a8:	10c4b03a 	or	r2,r2,r3
811073ac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_23_REG_OFST,
811073b0:	e0bfff17 	ldw	r2,-4(fp)
811073b4:	10800017 	ldw	r2,0(r2)
811073b8:	e1bffe17 	ldw	r6,-8(fp)
811073bc:	01402dc4 	movi	r5,183
811073c0:	1009883a 	mov	r4,r2
811073c4:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811073c8:	e0bfff17 	ldw	r2,-4(fp)
811073cc:	10800017 	ldw	r2,0(r2)
811073d0:	01402e04 	movi	r5,184
811073d4:	1009883a 	mov	r4,r2
811073d8:	11081ac0 	call	811081ac <uliRmapReadReg>
811073dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
811073e0:	e0bffe17 	ldw	r2,-8(fp)
811073e4:	10bfffec 	andhi	r2,r2,65535
811073e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
811073ec:	e0bfff17 	ldw	r2,-4(fp)
811073f0:	10803e0b 	ldhu	r2,248(r2)
811073f4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
811073f8:	e0fffe17 	ldw	r3,-8(fp)
811073fc:	1884b03a 	or	r2,r3,r2
81107400:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
81107404:	e0bffe17 	ldw	r2,-8(fp)
81107408:	10bfffcc 	andi	r2,r2,65535
8110740c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
81107410:	e0bfff17 	ldw	r2,-4(fp)
81107414:	10803e8b 	ldhu	r2,250(r2)
81107418:	10bfffcc 	andi	r2,r2,65535
8110741c:	1004943a 	slli	r2,r2,16
81107420:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
81107424:	e0bffe17 	ldw	r2,-8(fp)
81107428:	10c4b03a 	or	r2,r2,r3
8110742c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_24_REG_OFST,
81107430:	e0bfff17 	ldw	r2,-4(fp)
81107434:	10800017 	ldw	r2,0(r2)
81107438:	e1bffe17 	ldw	r6,-8(fp)
8110743c:	01402e04 	movi	r5,184
81107440:	1009883a 	mov	r4,r2
81107444:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107448:	e0bfff17 	ldw	r2,-4(fp)
8110744c:	10800017 	ldw	r2,0(r2)
81107450:	01402e44 	movi	r5,185
81107454:	1009883a 	mov	r4,r2
81107458:	11081ac0 	call	811081ac <uliRmapReadReg>
8110745c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
81107460:	e0bffe17 	ldw	r2,-8(fp)
81107464:	10bfffec 	andhi	r2,r2,65535
81107468:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
8110746c:	e0bfff17 	ldw	r2,-4(fp)
81107470:	10803f0b 	ldhu	r2,252(r2)
81107474:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
81107478:	e0fffe17 	ldw	r3,-8(fp)
8110747c:	1884b03a 	or	r2,r3,r2
81107480:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
81107484:	e0bffe17 	ldw	r2,-8(fp)
81107488:	10bfffcc 	andi	r2,r2,65535
8110748c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
81107490:	e0bfff17 	ldw	r2,-4(fp)
81107494:	10803f8b 	ldhu	r2,254(r2)
81107498:	10bfffcc 	andi	r2,r2,65535
8110749c:	1004943a 	slli	r2,r2,16
811074a0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
811074a4:	e0bffe17 	ldw	r2,-8(fp)
811074a8:	10c4b03a 	or	r2,r2,r3
811074ac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_25_REG_OFST,
811074b0:	e0bfff17 	ldw	r2,-4(fp)
811074b4:	10800017 	ldw	r2,0(r2)
811074b8:	e1bffe17 	ldw	r6,-8(fp)
811074bc:	01402e44 	movi	r5,185
811074c0:	1009883a 	mov	r4,r2
811074c4:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811074c8:	e0bfff17 	ldw	r2,-4(fp)
811074cc:	10800017 	ldw	r2,0(r2)
811074d0:	01402e84 	movi	r5,186
811074d4:	1009883a 	mov	r4,r2
811074d8:	11081ac0 	call	811081ac <uliRmapReadReg>
811074dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
811074e0:	e0bffe17 	ldw	r2,-8(fp)
811074e4:	10bfffec 	andhi	r2,r2,65535
811074e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
811074ec:	e0bfff17 	ldw	r2,-4(fp)
811074f0:	1080400b 	ldhu	r2,256(r2)
811074f4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
811074f8:	e0fffe17 	ldw	r3,-8(fp)
811074fc:	1884b03a 	or	r2,r3,r2
81107500:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
81107504:	e0bffe17 	ldw	r2,-8(fp)
81107508:	10bfffcc 	andi	r2,r2,65535
8110750c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
81107510:	e0bfff17 	ldw	r2,-4(fp)
81107514:	1080408b 	ldhu	r2,258(r2)
81107518:	10bfffcc 	andi	r2,r2,65535
8110751c:	1004943a 	slli	r2,r2,16
81107520:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
81107524:	e0bffe17 	ldw	r2,-8(fp)
81107528:	10c4b03a 	or	r2,r2,r3
8110752c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_26_REG_OFST,
81107530:	e0bfff17 	ldw	r2,-4(fp)
81107534:	10800017 	ldw	r2,0(r2)
81107538:	e1bffe17 	ldw	r6,-8(fp)
8110753c:	01402e84 	movi	r5,186
81107540:	1009883a 	mov	r4,r2
81107544:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107548:	e0bfff17 	ldw	r2,-4(fp)
8110754c:	10800017 	ldw	r2,0(r2)
81107550:	01402ec4 	movi	r5,187
81107554:	1009883a 	mov	r4,r2
81107558:	11081ac0 	call	811081ac <uliRmapReadReg>
8110755c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
81107560:	e0bffe17 	ldw	r2,-8(fp)
81107564:	10bfffec 	andhi	r2,r2,65535
81107568:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
8110756c:	e0bfff17 	ldw	r2,-4(fp)
81107570:	1080410b 	ldhu	r2,260(r2)
81107574:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
81107578:	e0fffe17 	ldw	r3,-8(fp)
8110757c:	1884b03a 	or	r2,r3,r2
81107580:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
81107584:	e0bffe17 	ldw	r2,-8(fp)
81107588:	10bfffcc 	andi	r2,r2,65535
8110758c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
81107590:	e0bfff17 	ldw	r2,-4(fp)
81107594:	1080418b 	ldhu	r2,262(r2)
81107598:	10bfffcc 	andi	r2,r2,65535
8110759c:	1004943a 	slli	r2,r2,16
811075a0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
811075a4:	e0bffe17 	ldw	r2,-8(fp)
811075a8:	10c4b03a 	or	r2,r2,r3
811075ac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_27_REG_OFST,
811075b0:	e0bfff17 	ldw	r2,-4(fp)
811075b4:	10800017 	ldw	r2,0(r2)
811075b8:	e1bffe17 	ldw	r6,-8(fp)
811075bc:	01402ec4 	movi	r5,187
811075c0:	1009883a 	mov	r4,r2
811075c4:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811075c8:	e0bfff17 	ldw	r2,-4(fp)
811075cc:	10800017 	ldw	r2,0(r2)
811075d0:	01402f04 	movi	r5,188
811075d4:	1009883a 	mov	r4,r2
811075d8:	11081ac0 	call	811081ac <uliRmapReadReg>
811075dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
811075e0:	e0bffe17 	ldw	r2,-8(fp)
811075e4:	10bfffec 	andhi	r2,r2,65535
811075e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
811075ec:	e0bfff17 	ldw	r2,-4(fp)
811075f0:	1080420b 	ldhu	r2,264(r2)
811075f4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
811075f8:	e0fffe17 	ldw	r3,-8(fp)
811075fc:	1884b03a 	or	r2,r3,r2
81107600:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
81107604:	e0bffe17 	ldw	r2,-8(fp)
81107608:	10bfffcc 	andi	r2,r2,65535
8110760c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
81107610:	e0bfff17 	ldw	r2,-4(fp)
81107614:	1080428b 	ldhu	r2,266(r2)
81107618:	10bfffcc 	andi	r2,r2,65535
8110761c:	1004943a 	slli	r2,r2,16
81107620:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
81107624:	e0bffe17 	ldw	r2,-8(fp)
81107628:	10c4b03a 	or	r2,r2,r3
8110762c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_28_REG_OFST,
81107630:	e0bfff17 	ldw	r2,-4(fp)
81107634:	10800017 	ldw	r2,0(r2)
81107638:	e1bffe17 	ldw	r6,-8(fp)
8110763c:	01402f04 	movi	r5,188
81107640:	1009883a 	mov	r4,r2
81107644:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107648:	e0bfff17 	ldw	r2,-4(fp)
8110764c:	10800017 	ldw	r2,0(r2)
81107650:	01402f44 	movi	r5,189
81107654:	1009883a 	mov	r4,r2
81107658:	11081ac0 	call	811081ac <uliRmapReadReg>
8110765c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
81107660:	e0bffe17 	ldw	r2,-8(fp)
81107664:	10bfffec 	andhi	r2,r2,65535
81107668:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
8110766c:	e0bfff17 	ldw	r2,-4(fp)
81107670:	1080430b 	ldhu	r2,268(r2)
81107674:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
81107678:	e0fffe17 	ldw	r3,-8(fp)
8110767c:	1884b03a 	or	r2,r3,r2
81107680:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
81107684:	e0bffe17 	ldw	r2,-8(fp)
81107688:	10bfffcc 	andi	r2,r2,65535
8110768c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
81107690:	e0bfff17 	ldw	r2,-4(fp)
81107694:	1080438b 	ldhu	r2,270(r2)
81107698:	10bfffcc 	andi	r2,r2,65535
8110769c:	1004943a 	slli	r2,r2,16
811076a0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
811076a4:	e0bffe17 	ldw	r2,-8(fp)
811076a8:	10c4b03a 	or	r2,r2,r3
811076ac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_29_REG_OFST,
811076b0:	e0bfff17 	ldw	r2,-4(fp)
811076b4:	10800017 	ldw	r2,0(r2)
811076b8:	e1bffe17 	ldw	r6,-8(fp)
811076bc:	01402f44 	movi	r5,189
811076c0:	1009883a 	mov	r4,r2
811076c4:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811076c8:	e0bfff17 	ldw	r2,-4(fp)
811076cc:	10800017 	ldw	r2,0(r2)
811076d0:	01402f84 	movi	r5,190
811076d4:	1009883a 	mov	r4,r2
811076d8:	11081ac0 	call	811081ac <uliRmapReadReg>
811076dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
811076e0:	e0bffe17 	ldw	r2,-8(fp)
811076e4:	10bfffec 	andhi	r2,r2,65535
811076e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
811076ec:	e0bfff17 	ldw	r2,-4(fp)
811076f0:	1080440b 	ldhu	r2,272(r2)
811076f4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
811076f8:	e0fffe17 	ldw	r3,-8(fp)
811076fc:	1884b03a 	or	r2,r3,r2
81107700:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
81107704:	e0bffe17 	ldw	r2,-8(fp)
81107708:	10bfffcc 	andi	r2,r2,65535
8110770c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
81107710:	e0bfff17 	ldw	r2,-4(fp)
81107714:	1080448b 	ldhu	r2,274(r2)
81107718:	10bfffcc 	andi	r2,r2,65535
8110771c:	1004943a 	slli	r2,r2,16
81107720:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
81107724:	e0bffe17 	ldw	r2,-8(fp)
81107728:	10c4b03a 	or	r2,r2,r3
8110772c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_30_REG_OFST,
81107730:	e0bfff17 	ldw	r2,-4(fp)
81107734:	10800017 	ldw	r2,0(r2)
81107738:	e1bffe17 	ldw	r6,-8(fp)
8110773c:	01402f84 	movi	r5,190
81107740:	1009883a 	mov	r4,r2
81107744:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107748:	e0bfff17 	ldw	r2,-4(fp)
8110774c:	10800017 	ldw	r2,0(r2)
81107750:	01402fc4 	movi	r5,191
81107754:	1009883a 	mov	r4,r2
81107758:	11081ac0 	call	811081ac <uliRmapReadReg>
8110775c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
81107760:	e0bffe17 	ldw	r2,-8(fp)
81107764:	10bfffec 	andhi	r2,r2,65535
81107768:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
8110776c:	e0bfff17 	ldw	r2,-4(fp)
81107770:	1080450b 	ldhu	r2,276(r2)
81107774:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
81107778:	e0fffe17 	ldw	r3,-8(fp)
8110777c:	1884b03a 	or	r2,r3,r2
81107780:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
81107784:	e0bffe17 	ldw	r2,-8(fp)
81107788:	10bfffcc 	andi	r2,r2,65535
8110778c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
81107790:	e0bfff17 	ldw	r2,-4(fp)
81107794:	1080458b 	ldhu	r2,278(r2)
81107798:	10bfffcc 	andi	r2,r2,65535
8110779c:	1004943a 	slli	r2,r2,16
811077a0:	1007883a 	mov	r3,r2
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
811077a4:	e0bffe17 	ldw	r2,-8(fp)
811077a8:	10c4b03a 	or	r2,r2,r3
811077ac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp << 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_31_REG_OFST,
811077b0:	e0bfff17 	ldw	r2,-4(fp)
811077b4:	10800017 	ldw	r2,0(r2)
811077b8:	e1bffe17 	ldw	r6,-8(fp)
811077bc:	01402fc4 	movi	r5,191
811077c0:	1009883a 	mov	r4,r2
811077c4:	11081580 	call	81108158 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
811077c8:	00800044 	movi	r2,1
811077cc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811077d0:	e0bffd17 	ldw	r2,-12(fp)
}
811077d4:	e037883a 	mov	sp,fp
811077d8:	dfc00117 	ldw	ra,4(sp)
811077dc:	df000017 	ldw	fp,0(sp)
811077e0:	dec00204 	addi	sp,sp,8
811077e4:	f800283a 	ret

811077e8 <bRmapGetRmapMemHKArea>:

bool bRmapGetRmapMemHKArea(TRmapChannel *pxRmapCh) {
811077e8:	defffb04 	addi	sp,sp,-20
811077ec:	de00012e 	bgeu	sp,et,811077f4 <bRmapGetRmapMemHKArea+0xc>
811077f0:	003b68fa 	trap	3
811077f4:	dfc00415 	stw	ra,16(sp)
811077f8:	df000315 	stw	fp,12(sp)
811077fc:	df000304 	addi	fp,sp,12
81107800:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107804:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107808:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110780c:	e0bfff17 	ldw	r2,-4(fp)
81107810:	1001e226 	beq	r2,zero,81107f9c <bRmapGetRmapMemHKArea+0x7b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107814:	e0bfff17 	ldw	r2,-4(fp)
81107818:	10800017 	ldw	r2,0(r2)
8110781c:	01402804 	movi	r5,160
81107820:	1009883a 	mov	r4,r2
81107824:	11081ac0 	call	811081ac <uliRmapReadReg>
81107828:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
8110782c:	e0bffe17 	ldw	r2,-8(fp)
81107830:	1007883a 	mov	r3,r2
81107834:	e0bfff17 	ldw	r2,-4(fp)
81107838:	10c0260d 	sth	r3,152(r2)
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);
8110783c:	e0bffe17 	ldw	r2,-8(fp)
81107840:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
81107844:	1007883a 	mov	r3,r2
81107848:	e0bfff17 	ldw	r2,-4(fp)
8110784c:	10c0268d 	sth	r3,154(r2)
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107850:	e0bfff17 	ldw	r2,-4(fp)
81107854:	10800017 	ldw	r2,0(r2)
81107858:	01402844 	movi	r5,161
8110785c:	1009883a 	mov	r4,r2
81107860:	11081ac0 	call	811081ac <uliRmapReadReg>
81107864:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
81107868:	e0bffe17 	ldw	r2,-8(fp)
8110786c:	1007883a 	mov	r3,r2
81107870:	e0bfff17 	ldw	r2,-4(fp)
81107874:	10c0270d 	sth	r3,156(r2)
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);
81107878:	e0bffe17 	ldw	r2,-8(fp)
8110787c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
81107880:	1007883a 	mov	r3,r2
81107884:	e0bfff17 	ldw	r2,-4(fp)
81107888:	10c0278d 	sth	r3,158(r2)
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110788c:	e0bfff17 	ldw	r2,-4(fp)
81107890:	10800017 	ldw	r2,0(r2)
81107894:	01402884 	movi	r5,162
81107898:	1009883a 	mov	r4,r2
8110789c:	11081ac0 	call	811081ac <uliRmapReadReg>
811078a0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
811078a4:	e0bffe17 	ldw	r2,-8(fp)
811078a8:	1007883a 	mov	r3,r2
811078ac:	e0bfff17 	ldw	r2,-4(fp)
811078b0:	10c0280d 	sth	r3,160(r2)
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);
811078b4:	e0bffe17 	ldw	r2,-8(fp)
811078b8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
811078bc:	1007883a 	mov	r3,r2
811078c0:	e0bfff17 	ldw	r2,-4(fp)
811078c4:	10c0288d 	sth	r3,162(r2)
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811078c8:	e0bfff17 	ldw	r2,-4(fp)
811078cc:	10800017 	ldw	r2,0(r2)
811078d0:	014028c4 	movi	r5,163
811078d4:	1009883a 	mov	r4,r2
811078d8:	11081ac0 	call	811081ac <uliRmapReadReg>
811078dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
811078e0:	e0bffe17 	ldw	r2,-8(fp)
811078e4:	1007883a 	mov	r3,r2
811078e8:	e0bfff17 	ldw	r2,-4(fp)
811078ec:	10c0290d 	sth	r3,164(r2)
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);
811078f0:	e0bffe17 	ldw	r2,-8(fp)
811078f4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
811078f8:	1007883a 	mov	r3,r2
811078fc:	e0bfff17 	ldw	r2,-4(fp)
81107900:	10c0298d 	sth	r3,166(r2)
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107904:	e0bfff17 	ldw	r2,-4(fp)
81107908:	10800017 	ldw	r2,0(r2)
8110790c:	01402904 	movi	r5,164
81107910:	1009883a 	mov	r4,r2
81107914:	11081ac0 	call	811081ac <uliRmapReadReg>
81107918:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
8110791c:	e0bffe17 	ldw	r2,-8(fp)
81107920:	1007883a 	mov	r3,r2
81107924:	e0bfff17 	ldw	r2,-4(fp)
81107928:	10c02a0d 	sth	r3,168(r2)
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);
8110792c:	e0bffe17 	ldw	r2,-8(fp)
81107930:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
81107934:	1007883a 	mov	r3,r2
81107938:	e0bfff17 	ldw	r2,-4(fp)
8110793c:	10c02a8d 	sth	r3,170(r2)
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107940:	e0bfff17 	ldw	r2,-4(fp)
81107944:	10800017 	ldw	r2,0(r2)
81107948:	01402944 	movi	r5,165
8110794c:	1009883a 	mov	r4,r2
81107950:	11081ac0 	call	811081ac <uliRmapReadReg>
81107954:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
81107958:	e0bffe17 	ldw	r2,-8(fp)
8110795c:	1007883a 	mov	r3,r2
81107960:	e0bfff17 	ldw	r2,-4(fp)
81107964:	10c02b0d 	sth	r3,172(r2)
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);
81107968:	e0bffe17 	ldw	r2,-8(fp)
8110796c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
81107970:	1007883a 	mov	r3,r2
81107974:	e0bfff17 	ldw	r2,-4(fp)
81107978:	10c02b8d 	sth	r3,174(r2)
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110797c:	e0bfff17 	ldw	r2,-4(fp)
81107980:	10800017 	ldw	r2,0(r2)
81107984:	01402984 	movi	r5,166
81107988:	1009883a 	mov	r4,r2
8110798c:	11081ac0 	call	811081ac <uliRmapReadReg>
81107990:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
81107994:	e0bffe17 	ldw	r2,-8(fp)
81107998:	1007883a 	mov	r3,r2
8110799c:	e0bfff17 	ldw	r2,-4(fp)
811079a0:	10c02c0d 	sth	r3,176(r2)
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);
811079a4:	e0bffe17 	ldw	r2,-8(fp)
811079a8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
811079ac:	1007883a 	mov	r3,r2
811079b0:	e0bfff17 	ldw	r2,-4(fp)
811079b4:	10c02c8d 	sth	r3,178(r2)
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811079b8:	e0bfff17 	ldw	r2,-4(fp)
811079bc:	10800017 	ldw	r2,0(r2)
811079c0:	014029c4 	movi	r5,167
811079c4:	1009883a 	mov	r4,r2
811079c8:	11081ac0 	call	811081ac <uliRmapReadReg>
811079cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
811079d0:	e0bffe17 	ldw	r2,-8(fp)
811079d4:	1007883a 	mov	r3,r2
811079d8:	e0bfff17 	ldw	r2,-4(fp)
811079dc:	10c02d0d 	sth	r3,180(r2)
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);
811079e0:	e0bffe17 	ldw	r2,-8(fp)
811079e4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
811079e8:	1007883a 	mov	r3,r2
811079ec:	e0bfff17 	ldw	r2,-4(fp)
811079f0:	10c02d8d 	sth	r3,182(r2)
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811079f4:	e0bfff17 	ldw	r2,-4(fp)
811079f8:	10800017 	ldw	r2,0(r2)
811079fc:	01402a04 	movi	r5,168
81107a00:	1009883a 	mov	r4,r2
81107a04:	11081ac0 	call	811081ac <uliRmapReadReg>
81107a08:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
81107a0c:	e0bffe17 	ldw	r2,-8(fp)
81107a10:	1007883a 	mov	r3,r2
81107a14:	e0bfff17 	ldw	r2,-4(fp)
81107a18:	10c02e0d 	sth	r3,184(r2)
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);
81107a1c:	e0bffe17 	ldw	r2,-8(fp)
81107a20:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
81107a24:	1007883a 	mov	r3,r2
81107a28:	e0bfff17 	ldw	r2,-4(fp)
81107a2c:	10c02e8d 	sth	r3,186(r2)
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107a30:	e0bfff17 	ldw	r2,-4(fp)
81107a34:	10800017 	ldw	r2,0(r2)
81107a38:	01402a44 	movi	r5,169
81107a3c:	1009883a 	mov	r4,r2
81107a40:	11081ac0 	call	811081ac <uliRmapReadReg>
81107a44:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
81107a48:	e0bffe17 	ldw	r2,-8(fp)
81107a4c:	1007883a 	mov	r3,r2
81107a50:	e0bfff17 	ldw	r2,-4(fp)
81107a54:	10c02f0d 	sth	r3,188(r2)
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);
81107a58:	e0bffe17 	ldw	r2,-8(fp)
81107a5c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
81107a60:	1007883a 	mov	r3,r2
81107a64:	e0bfff17 	ldw	r2,-4(fp)
81107a68:	10c02f8d 	sth	r3,190(r2)
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107a6c:	e0bfff17 	ldw	r2,-4(fp)
81107a70:	10800017 	ldw	r2,0(r2)
81107a74:	01402a84 	movi	r5,170
81107a78:	1009883a 	mov	r4,r2
81107a7c:	11081ac0 	call	811081ac <uliRmapReadReg>
81107a80:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
81107a84:	e0bffe17 	ldw	r2,-8(fp)
81107a88:	1007883a 	mov	r3,r2
81107a8c:	e0bfff17 	ldw	r2,-4(fp)
81107a90:	10c0300d 	sth	r3,192(r2)
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);
81107a94:	e0bffe17 	ldw	r2,-8(fp)
81107a98:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
81107a9c:	1007883a 	mov	r3,r2
81107aa0:	e0bfff17 	ldw	r2,-4(fp)
81107aa4:	10c0308d 	sth	r3,194(r2)
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107aa8:	e0bfff17 	ldw	r2,-4(fp)
81107aac:	10800017 	ldw	r2,0(r2)
81107ab0:	01402ac4 	movi	r5,171
81107ab4:	1009883a 	mov	r4,r2
81107ab8:	11081ac0 	call	811081ac <uliRmapReadReg>
81107abc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
81107ac0:	e0bffe17 	ldw	r2,-8(fp)
81107ac4:	1007883a 	mov	r3,r2
81107ac8:	e0bfff17 	ldw	r2,-4(fp)
81107acc:	10c0310d 	sth	r3,196(r2)
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VREF_MSK) >> 16);
81107ad0:	e0bffe17 	ldw	r2,-8(fp)
81107ad4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
81107ad8:	1007883a 	mov	r3,r2
81107adc:	e0bfff17 	ldw	r2,-4(fp)
81107ae0:	10c0318d 	sth	r3,198(r2)
				& COMM_RMAP_HK_5VREF_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ae4:	e0bfff17 	ldw	r2,-4(fp)
81107ae8:	10800017 	ldw	r2,0(r2)
81107aec:	01402b04 	movi	r5,172
81107af0:	1009883a 	mov	r4,r2
81107af4:	11081ac0 	call	811081ac <uliRmapReadReg>
81107af8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
81107afc:	e0bffe17 	ldw	r2,-8(fp)
81107b00:	1007883a 	mov	r3,r2
81107b04:	e0bfff17 	ldw	r2,-4(fp)
81107b08:	10c0320d 	sth	r3,200(r2)
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);
81107b0c:	e0bffe17 	ldw	r2,-8(fp)
81107b10:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
81107b14:	1007883a 	mov	r3,r2
81107b18:	e0bfff17 	ldw	r2,-4(fp)
81107b1c:	10c0328d 	sth	r3,202(r2)
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b20:	e0bfff17 	ldw	r2,-4(fp)
81107b24:	10800017 	ldw	r2,0(r2)
81107b28:	01402b44 	movi	r5,173
81107b2c:	1009883a 	mov	r4,r2
81107b30:	11081ac0 	call	811081ac <uliRmapReadReg>
81107b34:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
81107b38:	e0bffe17 	ldw	r2,-8(fp)
81107b3c:	1007883a 	mov	r3,r2
81107b40:	e0bfff17 	ldw	r2,-4(fp)
81107b44:	10c0330d 	sth	r3,204(r2)
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);
81107b48:	e0bffe17 	ldw	r2,-8(fp)
81107b4c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
81107b50:	1007883a 	mov	r3,r2
81107b54:	e0bfff17 	ldw	r2,-4(fp)
81107b58:	10c0338d 	sth	r3,206(r2)
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b5c:	e0bfff17 	ldw	r2,-4(fp)
81107b60:	10800017 	ldw	r2,0(r2)
81107b64:	01402b84 	movi	r5,174
81107b68:	1009883a 	mov	r4,r2
81107b6c:	11081ac0 	call	811081ac <uliRmapReadReg>
81107b70:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
81107b74:	e0bffe17 	ldw	r2,-8(fp)
81107b78:	1007883a 	mov	r3,r2
81107b7c:	e0bfff17 	ldw	r2,-4(fp)
81107b80:	10c0340d 	sth	r3,208(r2)
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);
81107b84:	e0bffe17 	ldw	r2,-8(fp)
81107b88:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
81107b8c:	1007883a 	mov	r3,r2
81107b90:	e0bfff17 	ldw	r2,-4(fp)
81107b94:	10c0348d 	sth	r3,210(r2)
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b98:	e0bfff17 	ldw	r2,-4(fp)
81107b9c:	10800017 	ldw	r2,0(r2)
81107ba0:	01402bc4 	movi	r5,175
81107ba4:	1009883a 	mov	r4,r2
81107ba8:	11081ac0 	call	811081ac <uliRmapReadReg>
81107bac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
81107bb0:	e0bffe17 	ldw	r2,-8(fp)
81107bb4:	1007883a 	mov	r3,r2
81107bb8:	e0bfff17 	ldw	r2,-4(fp)
81107bbc:	10c0350d 	sth	r3,212(r2)
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);
81107bc0:	e0bffe17 	ldw	r2,-8(fp)
81107bc4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
81107bc8:	1007883a 	mov	r3,r2
81107bcc:	e0bfff17 	ldw	r2,-4(fp)
81107bd0:	10c0358d 	sth	r3,214(r2)
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107bd4:	e0bfff17 	ldw	r2,-4(fp)
81107bd8:	10800017 	ldw	r2,0(r2)
81107bdc:	01402c04 	movi	r5,176
81107be0:	1009883a 	mov	r4,r2
81107be4:	11081ac0 	call	811081ac <uliRmapReadReg>
81107be8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
81107bec:	e0bffe17 	ldw	r2,-8(fp)
81107bf0:	1007883a 	mov	r3,r2
81107bf4:	e0bfff17 	ldw	r2,-4(fp)
81107bf8:	10c0360d 	sth	r3,216(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);
81107bfc:	e0bffe17 	ldw	r2,-8(fp)
81107c00:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
81107c04:	1007883a 	mov	r3,r2
81107c08:	e0bfff17 	ldw	r2,-4(fp)
81107c0c:	10c0368d 	sth	r3,218(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107c10:	e0bfff17 	ldw	r2,-4(fp)
81107c14:	10800017 	ldw	r2,0(r2)
81107c18:	01402c44 	movi	r5,177
81107c1c:	1009883a 	mov	r4,r2
81107c20:	11081ac0 	call	811081ac <uliRmapReadReg>
81107c24:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
81107c28:	e0bffe17 	ldw	r2,-8(fp)
81107c2c:	1007883a 	mov	r3,r2
81107c30:	e0bfff17 	ldw	r2,-4(fp)
81107c34:	10c0370d 	sth	r3,220(r2)
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);
81107c38:	e0bffe17 	ldw	r2,-8(fp)
81107c3c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
81107c40:	1007883a 	mov	r3,r2
81107c44:	e0bfff17 	ldw	r2,-4(fp)
81107c48:	10c0378d 	sth	r3,222(r2)
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107c4c:	e0bfff17 	ldw	r2,-4(fp)
81107c50:	10800017 	ldw	r2,0(r2)
81107c54:	01402c84 	movi	r5,178
81107c58:	1009883a 	mov	r4,r2
81107c5c:	11081ac0 	call	811081ac <uliRmapReadReg>
81107c60:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
81107c64:	e0bffe17 	ldw	r2,-8(fp)
81107c68:	1007883a 	mov	r3,r2
81107c6c:	e0bfff17 	ldw	r2,-4(fp)
81107c70:	10c0380d 	sth	r3,224(r2)
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);
81107c74:	e0bffe17 	ldw	r2,-8(fp)
81107c78:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
81107c7c:	1007883a 	mov	r3,r2
81107c80:	e0bfff17 	ldw	r2,-4(fp)
81107c84:	10c0388d 	sth	r3,226(r2)
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107c88:	e0bfff17 	ldw	r2,-4(fp)
81107c8c:	10800017 	ldw	r2,0(r2)
81107c90:	01402cc4 	movi	r5,179
81107c94:	1009883a 	mov	r4,r2
81107c98:	11081ac0 	call	811081ac <uliRmapReadReg>
81107c9c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
81107ca0:	e0bffe17 	ldw	r2,-8(fp)
81107ca4:	1007883a 	mov	r3,r2
81107ca8:	e0bfff17 	ldw	r2,-4(fp)
81107cac:	10c0390d 	sth	r3,228(r2)
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);
81107cb0:	e0bffe17 	ldw	r2,-8(fp)
81107cb4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
81107cb8:	1007883a 	mov	r3,r2
81107cbc:	e0bfff17 	ldw	r2,-4(fp)
81107cc0:	10c0398d 	sth	r3,230(r2)
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107cc4:	e0bfff17 	ldw	r2,-4(fp)
81107cc8:	10800017 	ldw	r2,0(r2)
81107ccc:	01402d04 	movi	r5,180
81107cd0:	1009883a 	mov	r4,r2
81107cd4:	11081ac0 	call	811081ac <uliRmapReadReg>
81107cd8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
81107cdc:	e0bffe17 	ldw	r2,-8(fp)
81107ce0:	1007883a 	mov	r3,r2
81107ce4:	e0bfff17 	ldw	r2,-4(fp)
81107ce8:	10c03a0d 	sth	r3,232(r2)
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);
81107cec:	e0bffe17 	ldw	r2,-8(fp)
81107cf0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
81107cf4:	1007883a 	mov	r3,r2
81107cf8:	e0bfff17 	ldw	r2,-4(fp)
81107cfc:	10c03a8d 	sth	r3,234(r2)
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d00:	e0bfff17 	ldw	r2,-4(fp)
81107d04:	10800017 	ldw	r2,0(r2)
81107d08:	01402d44 	movi	r5,181
81107d0c:	1009883a 	mov	r4,r2
81107d10:	11081ac0 	call	811081ac <uliRmapReadReg>
81107d14:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
81107d18:	e0bffe17 	ldw	r2,-8(fp)
81107d1c:	1007883a 	mov	r3,r2
81107d20:	e0bfff17 	ldw	r2,-4(fp)
81107d24:	10c03b0d 	sth	r3,236(r2)
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);
81107d28:	e0bffe17 	ldw	r2,-8(fp)
81107d2c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
81107d30:	1007883a 	mov	r3,r2
81107d34:	e0bfff17 	ldw	r2,-4(fp)
81107d38:	10c03b8d 	sth	r3,238(r2)
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d3c:	e0bfff17 	ldw	r2,-4(fp)
81107d40:	10800017 	ldw	r2,0(r2)
81107d44:	01402d84 	movi	r5,182
81107d48:	1009883a 	mov	r4,r2
81107d4c:	11081ac0 	call	811081ac <uliRmapReadReg>
81107d50:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
81107d54:	e0bffe17 	ldw	r2,-8(fp)
81107d58:	1007883a 	mov	r3,r2
81107d5c:	e0bfff17 	ldw	r2,-4(fp)
81107d60:	10c03c0d 	sth	r3,240(r2)
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);
81107d64:	e0bffe17 	ldw	r2,-8(fp)
81107d68:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
81107d6c:	1007883a 	mov	r3,r2
81107d70:	e0bfff17 	ldw	r2,-4(fp)
81107d74:	10c03c8d 	sth	r3,242(r2)
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d78:	e0bfff17 	ldw	r2,-4(fp)
81107d7c:	10800017 	ldw	r2,0(r2)
81107d80:	01402dc4 	movi	r5,183
81107d84:	1009883a 	mov	r4,r2
81107d88:	11081ac0 	call	811081ac <uliRmapReadReg>
81107d8c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
81107d90:	e0bffe17 	ldw	r2,-8(fp)
81107d94:	1007883a 	mov	r3,r2
81107d98:	e0bfff17 	ldw	r2,-4(fp)
81107d9c:	10c03d0d 	sth	r3,244(r2)
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);
81107da0:	e0bffe17 	ldw	r2,-8(fp)
81107da4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
81107da8:	1007883a 	mov	r3,r2
81107dac:	e0bfff17 	ldw	r2,-4(fp)
81107db0:	10c03d8d 	sth	r3,246(r2)
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107db4:	e0bfff17 	ldw	r2,-4(fp)
81107db8:	10800017 	ldw	r2,0(r2)
81107dbc:	01402e04 	movi	r5,184
81107dc0:	1009883a 	mov	r4,r2
81107dc4:	11081ac0 	call	811081ac <uliRmapReadReg>
81107dc8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
81107dcc:	e0bffe17 	ldw	r2,-8(fp)
81107dd0:	1007883a 	mov	r3,r2
81107dd4:	e0bfff17 	ldw	r2,-4(fp)
81107dd8:	10c03e0d 	sth	r3,248(r2)
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);
81107ddc:	e0bffe17 	ldw	r2,-8(fp)
81107de0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
81107de4:	1007883a 	mov	r3,r2
81107de8:	e0bfff17 	ldw	r2,-4(fp)
81107dec:	10c03e8d 	sth	r3,250(r2)
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107df0:	e0bfff17 	ldw	r2,-4(fp)
81107df4:	10800017 	ldw	r2,0(r2)
81107df8:	01402e44 	movi	r5,185
81107dfc:	1009883a 	mov	r4,r2
81107e00:	11081ac0 	call	811081ac <uliRmapReadReg>
81107e04:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
81107e08:	e0bffe17 	ldw	r2,-8(fp)
81107e0c:	1007883a 	mov	r3,r2
81107e10:	e0bfff17 	ldw	r2,-4(fp)
81107e14:	10c03f0d 	sth	r3,252(r2)
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);
81107e18:	e0bffe17 	ldw	r2,-8(fp)
81107e1c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
81107e20:	1007883a 	mov	r3,r2
81107e24:	e0bfff17 	ldw	r2,-4(fp)
81107e28:	10c03f8d 	sth	r3,254(r2)
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e2c:	e0bfff17 	ldw	r2,-4(fp)
81107e30:	10800017 	ldw	r2,0(r2)
81107e34:	01402e84 	movi	r5,186
81107e38:	1009883a 	mov	r4,r2
81107e3c:	11081ac0 	call	811081ac <uliRmapReadReg>
81107e40:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
81107e44:	e0bffe17 	ldw	r2,-8(fp)
81107e48:	1007883a 	mov	r3,r2
81107e4c:	e0bfff17 	ldw	r2,-4(fp)
81107e50:	10c0400d 	sth	r3,256(r2)
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);
81107e54:	e0bffe17 	ldw	r2,-8(fp)
81107e58:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
81107e5c:	1007883a 	mov	r3,r2
81107e60:	e0bfff17 	ldw	r2,-4(fp)
81107e64:	10c0408d 	sth	r3,258(r2)
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e68:	e0bfff17 	ldw	r2,-4(fp)
81107e6c:	10800017 	ldw	r2,0(r2)
81107e70:	01402ec4 	movi	r5,187
81107e74:	1009883a 	mov	r4,r2
81107e78:	11081ac0 	call	811081ac <uliRmapReadReg>
81107e7c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
81107e80:	e0bffe17 	ldw	r2,-8(fp)
81107e84:	1007883a 	mov	r3,r2
81107e88:	e0bfff17 	ldw	r2,-4(fp)
81107e8c:	10c0410d 	sth	r3,260(r2)
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);
81107e90:	e0bffe17 	ldw	r2,-8(fp)
81107e94:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
81107e98:	1007883a 	mov	r3,r2
81107e9c:	e0bfff17 	ldw	r2,-4(fp)
81107ea0:	10c0418d 	sth	r3,262(r2)
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ea4:	e0bfff17 	ldw	r2,-4(fp)
81107ea8:	10800017 	ldw	r2,0(r2)
81107eac:	01402f04 	movi	r5,188
81107eb0:	1009883a 	mov	r4,r2
81107eb4:	11081ac0 	call	811081ac <uliRmapReadReg>
81107eb8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
81107ebc:	e0bffe17 	ldw	r2,-8(fp)
81107ec0:	1007883a 	mov	r3,r2
81107ec4:	e0bfff17 	ldw	r2,-4(fp)
81107ec8:	10c0420d 	sth	r3,264(r2)
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);
81107ecc:	e0bffe17 	ldw	r2,-8(fp)
81107ed0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
81107ed4:	1007883a 	mov	r3,r2
81107ed8:	e0bfff17 	ldw	r2,-4(fp)
81107edc:	10c0428d 	sth	r3,266(r2)
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ee0:	e0bfff17 	ldw	r2,-4(fp)
81107ee4:	10800017 	ldw	r2,0(r2)
81107ee8:	01402f44 	movi	r5,189
81107eec:	1009883a 	mov	r4,r2
81107ef0:	11081ac0 	call	811081ac <uliRmapReadReg>
81107ef4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
81107ef8:	e0bffe17 	ldw	r2,-8(fp)
81107efc:	1007883a 	mov	r3,r2
81107f00:	e0bfff17 	ldw	r2,-4(fp)
81107f04:	10c0430d 	sth	r3,268(r2)
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);
81107f08:	e0bffe17 	ldw	r2,-8(fp)
81107f0c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
81107f10:	1007883a 	mov	r3,r2
81107f14:	e0bfff17 	ldw	r2,-4(fp)
81107f18:	10c0438d 	sth	r3,270(r2)
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107f1c:	e0bfff17 	ldw	r2,-4(fp)
81107f20:	10800017 	ldw	r2,0(r2)
81107f24:	01402f84 	movi	r5,190
81107f28:	1009883a 	mov	r4,r2
81107f2c:	11081ac0 	call	811081ac <uliRmapReadReg>
81107f30:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
81107f34:	e0bffe17 	ldw	r2,-8(fp)
81107f38:	1007883a 	mov	r3,r2
81107f3c:	e0bfff17 	ldw	r2,-4(fp)
81107f40:	10c0440d 	sth	r3,272(r2)
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);
81107f44:	e0bffe17 	ldw	r2,-8(fp)
81107f48:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
81107f4c:	1007883a 	mov	r3,r2
81107f50:	e0bfff17 	ldw	r2,-4(fp)
81107f54:	10c0448d 	sth	r3,274(r2)
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107f58:	e0bfff17 	ldw	r2,-4(fp)
81107f5c:	10800017 	ldw	r2,0(r2)
81107f60:	01402fc4 	movi	r5,191
81107f64:	1009883a 	mov	r4,r2
81107f68:	11081ac0 	call	811081ac <uliRmapReadReg>
81107f6c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
81107f70:	e0bffe17 	ldw	r2,-8(fp)
81107f74:	1007883a 	mov	r3,r2
81107f78:	e0bfff17 	ldw	r2,-4(fp)
81107f7c:	10c0450d 	sth	r3,276(r2)
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);
81107f80:	e0bffe17 	ldw	r2,-8(fp)
81107f84:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
81107f88:	1007883a 	mov	r3,r2
81107f8c:	e0bfff17 	ldw	r2,-4(fp)
81107f90:	10c0458d 	sth	r3,278(r2)
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);

		bStatus = TRUE;
81107f94:	00800044 	movi	r2,1
81107f98:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107f9c:	e0bffd17 	ldw	r2,-12(fp)
}
81107fa0:	e037883a 	mov	sp,fp
81107fa4:	dfc00117 	ldw	ra,4(sp)
81107fa8:	df000017 	ldw	fp,0(sp)
81107fac:	dec00204 	addi	sp,sp,8
81107fb0:	f800283a 	ret

81107fb4 <bRmapInitCh>:

bool bRmapInitCh(TRmapChannel *pxRmapCh, alt_u8 ucCommCh) {
81107fb4:	defffb04 	addi	sp,sp,-20
81107fb8:	de00012e 	bgeu	sp,et,81107fc0 <bRmapInitCh+0xc>
81107fbc:	003b68fa 	trap	3
81107fc0:	dfc00415 	stw	ra,16(sp)
81107fc4:	df000315 	stw	fp,12(sp)
81107fc8:	df000304 	addi	fp,sp,12
81107fcc:	e13ffe15 	stw	r4,-8(fp)
81107fd0:	2805883a 	mov	r2,r5
81107fd4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81107fd8:	e03ffd15 	stw	zero,-12(fp)

	if (pxRmapCh != NULL) {
81107fdc:	e0bffe17 	ldw	r2,-8(fp)
81107fe0:	10005726 	beq	r2,zero,81108140 <bRmapInitCh+0x18c>
		bStatus = TRUE;
81107fe4:	00800044 	movi	r2,1
81107fe8:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81107fec:	e0bfff03 	ldbu	r2,-4(fp)
81107ff0:	10c00228 	cmpgeui	r3,r2,8
81107ff4:	1800361e 	bne	r3,zero,811080d0 <bRmapInitCh+0x11c>
81107ff8:	100690ba 	slli	r3,r2,2
81107ffc:	00a04474 	movhi	r2,33041
81108000:	10a00404 	addi	r2,r2,-32752
81108004:	1885883a 	add	r2,r3,r2
81108008:	10800017 	ldw	r2,0(r2)
8110800c:	1000683a 	jmp	r2
81108010:	81108030 	cmpltui	r4,r16,16896
81108014:	81108044 	addi	r4,r16,16897
81108018:	81108058 	cmpnei	r4,r16,16897
8110801c:	8110806c 	andhi	r4,r16,16897
81108020:	81108080 	call	88110808 <__reset+0x20f0808>
81108024:	81108094 	ori	r4,r16,16898
81108028:	811080a8 	cmpgeui	r4,r16,16898
8110802c:	811080bc 	xorhi	r4,r16,16898
		case eCommSpwCh1:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81108030:	e0fffe17 	ldw	r3,-8(fp)
81108034:	00a04834 	movhi	r2,33056
81108038:	108b0004 	addi	r2,r2,11264
8110803c:	18800015 	stw	r2,0(r3)
			break;
81108040:	00002506 	br	811080d8 <bRmapInitCh+0x124>
		case eCommSpwCh2:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81108044:	e0fffe17 	ldw	r3,-8(fp)
81108048:	00a04834 	movhi	r2,33056
8110804c:	108a0004 	addi	r2,r2,10240
81108050:	18800015 	stw	r2,0(r3)
			break;
81108054:	00002006 	br	811080d8 <bRmapInitCh+0x124>
		case eCommSpwCh3:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81108058:	e0fffe17 	ldw	r3,-8(fp)
8110805c:	00a04834 	movhi	r2,33056
81108060:	108b0004 	addi	r2,r2,11264
81108064:	18800015 	stw	r2,0(r3)
			break;
81108068:	00001b06 	br	811080d8 <bRmapInitCh+0x124>
		case eCommSpwCh4:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8110806c:	e0fffe17 	ldw	r3,-8(fp)
81108070:	00a04834 	movhi	r2,33056
81108074:	108a0004 	addi	r2,r2,10240
81108078:	18800015 	stw	r2,0(r3)
			break;
8110807c:	00001606 	br	811080d8 <bRmapInitCh+0x124>
		case eCommSpwCh5:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81108080:	e0fffe17 	ldw	r3,-8(fp)
81108084:	00a04834 	movhi	r2,33056
81108088:	108b0004 	addi	r2,r2,11264
8110808c:	18800015 	stw	r2,0(r3)
			break;
81108090:	00001106 	br	811080d8 <bRmapInitCh+0x124>
		case eCommSpwCh6:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81108094:	e0fffe17 	ldw	r3,-8(fp)
81108098:	00a04834 	movhi	r2,33056
8110809c:	108a0004 	addi	r2,r2,10240
811080a0:	18800015 	stw	r2,0(r3)
			break;
811080a4:	00000c06 	br	811080d8 <bRmapInitCh+0x124>
		case eCommSpwCh7:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
811080a8:	e0fffe17 	ldw	r3,-8(fp)
811080ac:	00a04834 	movhi	r2,33056
811080b0:	108b0004 	addi	r2,r2,11264
811080b4:	18800015 	stw	r2,0(r3)
			break;
811080b8:	00000706 	br	811080d8 <bRmapInitCh+0x124>
		case eCommSpwCh8:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
811080bc:	e0fffe17 	ldw	r3,-8(fp)
811080c0:	00a04834 	movhi	r2,33056
811080c4:	108a0004 	addi	r2,r2,10240
811080c8:	18800015 	stw	r2,0(r3)
			break;
811080cc:	00000206 	br	811080d8 <bRmapInitCh+0x124>
		default:
			bStatus = FALSE;
811080d0:	e03ffd15 	stw	zero,-12(fp)
			break;
811080d4:	0001883a 	nop
		}

		if (bStatus) {
811080d8:	e0bffd17 	ldw	r2,-12(fp)
811080dc:	10001826 	beq	r2,zero,81108140 <bRmapInitCh+0x18c>
			if (!bRmapGetIrqControl(pxRmapCh)) {
811080e0:	e13ffe17 	ldw	r4,-8(fp)
811080e4:	1105c140 	call	81105c14 <bRmapGetIrqControl>
811080e8:	1000011e 	bne	r2,zero,811080f0 <bRmapInitCh+0x13c>
				bStatus = FALSE;
811080ec:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecConfig(pxRmapCh)) {
811080f0:	e13ffe17 	ldw	r4,-8(fp)
811080f4:	1105dfc0 	call	81105dfc <bRmapGetCodecConfig>
811080f8:	1000011e 	bne	r2,zero,81108100 <bRmapInitCh+0x14c>
				bStatus = FALSE;
811080fc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecStatus(pxRmapCh)) {
81108100:	e13ffe17 	ldw	r4,-8(fp)
81108104:	1105e880 	call	81105e88 <bRmapGetCodecStatus>
81108108:	1000011e 	bne	r2,zero,81108110 <bRmapInitCh+0x15c>
				bStatus = FALSE;
8110810c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigArea(pxRmapCh)) {
81108110:	e13ffe17 	ldw	r4,-8(fp)
81108114:	11064340 	call	81106434 <bRmapGetMemConfigArea>
81108118:	1000011e 	bne	r2,zero,81108120 <bRmapInitCh+0x16c>
				bStatus = FALSE;
8110811c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigStat(pxRmapCh)) {
81108120:	e13ffe17 	ldw	r4,-8(fp)
81108124:	11067080 	call	81106708 <bRmapGetMemConfigStat>
81108128:	1000011e 	bne	r2,zero,81108130 <bRmapInitCh+0x17c>
				bStatus = FALSE;
8110812c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetRmapMemHKArea(pxRmapCh)) {
81108130:	e13ffe17 	ldw	r4,-8(fp)
81108134:	11077e80 	call	811077e8 <bRmapGetRmapMemHKArea>
81108138:	1000011e 	bne	r2,zero,81108140 <bRmapInitCh+0x18c>
				bStatus = FALSE;
8110813c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81108140:	e0bffd17 	ldw	r2,-12(fp)
}
81108144:	e037883a 	mov	sp,fp
81108148:	dfc00117 	ldw	ra,4(sp)
8110814c:	df000017 	ldw	fp,0(sp)
81108150:	dec00204 	addi	sp,sp,8
81108154:	f800283a 	ret

81108158 <vRmapWriteReg>:
//! [public functions]

//! [private functions]
static void vRmapWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81108158:	defffc04 	addi	sp,sp,-16
8110815c:	de00012e 	bgeu	sp,et,81108164 <vRmapWriteReg+0xc>
81108160:	003b68fa 	trap	3
81108164:	df000315 	stw	fp,12(sp)
81108168:	df000304 	addi	fp,sp,12
8110816c:	e13ffd15 	stw	r4,-12(fp)
81108170:	e17ffe15 	stw	r5,-8(fp)
81108174:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81108178:	e0bffe17 	ldw	r2,-8(fp)
8110817c:	1085883a 	add	r2,r2,r2
81108180:	1085883a 	add	r2,r2,r2
81108184:	1007883a 	mov	r3,r2
81108188:	e0bffd17 	ldw	r2,-12(fp)
8110818c:	10c5883a 	add	r2,r2,r3
81108190:	e0ffff17 	ldw	r3,-4(fp)
81108194:	10c00015 	stw	r3,0(r2)
}
81108198:	0001883a 	nop
8110819c:	e037883a 	mov	sp,fp
811081a0:	df000017 	ldw	fp,0(sp)
811081a4:	dec00104 	addi	sp,sp,4
811081a8:	f800283a 	ret

811081ac <uliRmapReadReg>:

alt_u32 uliRmapReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
811081ac:	defffc04 	addi	sp,sp,-16
811081b0:	de00012e 	bgeu	sp,et,811081b8 <uliRmapReadReg+0xc>
811081b4:	003b68fa 	trap	3
811081b8:	df000315 	stw	fp,12(sp)
811081bc:	df000304 	addi	fp,sp,12
811081c0:	e13ffe15 	stw	r4,-8(fp)
811081c4:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
811081c8:	e0bfff17 	ldw	r2,-4(fp)
811081cc:	1085883a 	add	r2,r2,r2
811081d0:	1085883a 	add	r2,r2,r2
811081d4:	1007883a 	mov	r3,r2
811081d8:	e0bffe17 	ldw	r2,-8(fp)
811081dc:	10c5883a 	add	r2,r2,r3
811081e0:	10800017 	ldw	r2,0(r2)
811081e4:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
811081e8:	e0bffd17 	ldw	r2,-12(fp)
}
811081ec:	e037883a 	mov	sp,fp
811081f0:	df000017 	ldw	fp,0(sp)
811081f4:	dec00104 	addi	sp,sp,4
811081f8:	f800283a 	ret

811081fc <uliConvRmapCfgAddr>:

static alt_u32 uliConvRmapCfgAddr(alt_u32 puliRmapAddr) {
811081fc:	defffd04 	addi	sp,sp,-12
81108200:	de00012e 	bgeu	sp,et,81108208 <uliConvRmapCfgAddr+0xc>
81108204:	003b68fa 	trap	3
81108208:	df000215 	stw	fp,8(sp)
8110820c:	df000204 	addi	fp,sp,8
81108210:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliValue;

	switch (puliRmapAddr) {
81108214:	e0bfff17 	ldw	r2,-4(fp)
81108218:	10801368 	cmpgeui	r2,r2,77
8110821c:	10008a1e 	bne	r2,zero,81108448 <uliConvRmapCfgAddr+0x24c>
81108220:	e0bfff17 	ldw	r2,-4(fp)
81108224:	100690ba 	slli	r3,r2,2
81108228:	00a04474 	movhi	r2,33041
8110822c:	10a08f04 	addi	r2,r2,-32196
81108230:	1885883a 	add	r2,r3,r2
81108234:	10800017 	ldw	r2,0(r2)
81108238:	1000683a 	jmp	r2
8110823c:	81108370 	cmpltui	r4,r16,16909
81108240:	81108448 	cmpgei	r4,r16,16913
81108244:	81108448 	cmpgei	r4,r16,16913
81108248:	81108448 	cmpgei	r4,r16,16913
8110824c:	8110837c 	xorhi	r4,r16,16909
81108250:	81108448 	cmpgei	r4,r16,16913
81108254:	81108448 	cmpgei	r4,r16,16913
81108258:	81108448 	cmpgei	r4,r16,16913
8110825c:	81108388 	cmpgei	r4,r16,16910
81108260:	81108448 	cmpgei	r4,r16,16913
81108264:	81108448 	cmpgei	r4,r16,16913
81108268:	81108448 	cmpgei	r4,r16,16913
8110826c:	81108394 	ori	r4,r16,16910
81108270:	81108448 	cmpgei	r4,r16,16913
81108274:	81108448 	cmpgei	r4,r16,16913
81108278:	81108448 	cmpgei	r4,r16,16913
8110827c:	811083a0 	cmpeqi	r4,r16,16910
81108280:	81108448 	cmpgei	r4,r16,16913
81108284:	81108448 	cmpgei	r4,r16,16913
81108288:	81108448 	cmpgei	r4,r16,16913
8110828c:	811083ac 	andhi	r4,r16,16910
81108290:	81108448 	cmpgei	r4,r16,16913
81108294:	81108448 	cmpgei	r4,r16,16913
81108298:	81108448 	cmpgei	r4,r16,16913
8110829c:	811083b8 	rdprs	r4,r16,16910
811082a0:	81108448 	cmpgei	r4,r16,16913
811082a4:	81108448 	cmpgei	r4,r16,16913
811082a8:	81108448 	cmpgei	r4,r16,16913
811082ac:	811083c4 	addi	r4,r16,16911
811082b0:	81108448 	cmpgei	r4,r16,16913
811082b4:	81108448 	cmpgei	r4,r16,16913
811082b8:	81108448 	cmpgei	r4,r16,16913
811082bc:	811083d0 	cmplti	r4,r16,16911
811082c0:	81108448 	cmpgei	r4,r16,16913
811082c4:	81108448 	cmpgei	r4,r16,16913
811082c8:	81108448 	cmpgei	r4,r16,16913
811082cc:	811083dc 	xori	r4,r16,16911
811082d0:	81108448 	cmpgei	r4,r16,16913
811082d4:	81108448 	cmpgei	r4,r16,16913
811082d8:	81108448 	cmpgei	r4,r16,16913
811082dc:	811083e8 	cmpgeui	r4,r16,16911
811082e0:	81108448 	cmpgei	r4,r16,16913
811082e4:	81108448 	cmpgei	r4,r16,16913
811082e8:	81108448 	cmpgei	r4,r16,16913
811082ec:	811083f4 	orhi	r4,r16,16911
811082f0:	81108448 	cmpgei	r4,r16,16913
811082f4:	81108448 	cmpgei	r4,r16,16913
811082f8:	81108448 	cmpgei	r4,r16,16913
811082fc:	81108448 	cmpgei	r4,r16,16913
81108300:	81108448 	cmpgei	r4,r16,16913
81108304:	81108448 	cmpgei	r4,r16,16913
81108308:	81108448 	cmpgei	r4,r16,16913
8110830c:	81108448 	cmpgei	r4,r16,16913
81108310:	81108448 	cmpgei	r4,r16,16913
81108314:	81108448 	cmpgei	r4,r16,16913
81108318:	81108448 	cmpgei	r4,r16,16913
8110831c:	81108400 	call	88110840 <__reset+0x20f0840>
81108320:	81108448 	cmpgei	r4,r16,16913
81108324:	81108448 	cmpgei	r4,r16,16913
81108328:	81108448 	cmpgei	r4,r16,16913
8110832c:	8110840c 	andi	r4,r16,16912
81108330:	81108448 	cmpgei	r4,r16,16913
81108334:	81108448 	cmpgei	r4,r16,16913
81108338:	81108448 	cmpgei	r4,r16,16913
8110833c:	81108418 	cmpnei	r4,r16,16912
81108340:	81108448 	cmpgei	r4,r16,16913
81108344:	81108448 	cmpgei	r4,r16,16913
81108348:	81108448 	cmpgei	r4,r16,16913
8110834c:	81108424 	muli	r4,r16,16912
81108350:	81108448 	cmpgei	r4,r16,16913
81108354:	81108448 	cmpgei	r4,r16,16913
81108358:	81108448 	cmpgei	r4,r16,16913
8110835c:	81108430 	cmpltui	r4,r16,16912
81108360:	81108448 	cmpgei	r4,r16,16913
81108364:	81108448 	cmpgei	r4,r16,16913
81108368:	81108448 	cmpgei	r4,r16,16913
8110836c:	8110843c 	xorhi	r4,r16,16912
	case 0x00000000:
		uliValue = 0x00000040;
81108370:	00801004 	movi	r2,64
81108374:	e0bffe15 	stw	r2,-8(fp)
		break;
81108378:	00003506 	br	81108450 <uliConvRmapCfgAddr+0x254>
	case 0x00000004:
		uliValue = 0x00000041;
8110837c:	00801044 	movi	r2,65
81108380:	e0bffe15 	stw	r2,-8(fp)
		break;
81108384:	00003206 	br	81108450 <uliConvRmapCfgAddr+0x254>
	case 0x00000008:
		uliValue = 0x00000042;
81108388:	00801084 	movi	r2,66
8110838c:	e0bffe15 	stw	r2,-8(fp)
		break;
81108390:	00002f06 	br	81108450 <uliConvRmapCfgAddr+0x254>
	case 0x0000000C:
		uliValue = 0x00000043;
81108394:	008010c4 	movi	r2,67
81108398:	e0bffe15 	stw	r2,-8(fp)
		break;
8110839c:	00002c06 	br	81108450 <uliConvRmapCfgAddr+0x254>
	case 0x00000010:
		uliValue = 0x00000044;
811083a0:	00801104 	movi	r2,68
811083a4:	e0bffe15 	stw	r2,-8(fp)
		break;
811083a8:	00002906 	br	81108450 <uliConvRmapCfgAddr+0x254>
	case 0x00000014:
		uliValue = 0x00000045;
811083ac:	00801144 	movi	r2,69
811083b0:	e0bffe15 	stw	r2,-8(fp)
		break;
811083b4:	00002606 	br	81108450 <uliConvRmapCfgAddr+0x254>
	case 0x00000018:
		uliValue = 0x00000046;
811083b8:	00801184 	movi	r2,70
811083bc:	e0bffe15 	stw	r2,-8(fp)
		break;
811083c0:	00002306 	br	81108450 <uliConvRmapCfgAddr+0x254>
	case 0x0000001C:
		uliValue = 0x00000047;
811083c4:	008011c4 	movi	r2,71
811083c8:	e0bffe15 	stw	r2,-8(fp)
		break;
811083cc:	00002006 	br	81108450 <uliConvRmapCfgAddr+0x254>
	case 0x00000020:
		uliValue = 0x00000048;
811083d0:	00801204 	movi	r2,72
811083d4:	e0bffe15 	stw	r2,-8(fp)
		break;
811083d8:	00001d06 	br	81108450 <uliConvRmapCfgAddr+0x254>
	case 0x00000024:
		uliValue = 0x00000049;
811083dc:	00801244 	movi	r2,73
811083e0:	e0bffe15 	stw	r2,-8(fp)
		break;
811083e4:	00001a06 	br	81108450 <uliConvRmapCfgAddr+0x254>
	case 0x00000028:
		uliValue = 0x0000004A;
811083e8:	00801284 	movi	r2,74
811083ec:	e0bffe15 	stw	r2,-8(fp)
		break;
811083f0:	00001706 	br	81108450 <uliConvRmapCfgAddr+0x254>
	case 0x0000002C:
		uliValue = 0x0000004B;
811083f4:	008012c4 	movi	r2,75
811083f8:	e0bffe15 	stw	r2,-8(fp)
		break;
811083fc:	00001406 	br	81108450 <uliConvRmapCfgAddr+0x254>
	case 0x00000038:
		uliValue = 0x0000004C;
81108400:	00801304 	movi	r2,76
81108404:	e0bffe15 	stw	r2,-8(fp)
		break;
81108408:	00001106 	br	81108450 <uliConvRmapCfgAddr+0x254>
	case 0x0000003C:
		uliValue = 0x0000004D;
8110840c:	00801344 	movi	r2,77
81108410:	e0bffe15 	stw	r2,-8(fp)
		break;
81108414:	00000e06 	br	81108450 <uliConvRmapCfgAddr+0x254>
	case 0x00000040:
		uliValue = 0x0000004E;
81108418:	00801384 	movi	r2,78
8110841c:	e0bffe15 	stw	r2,-8(fp)
		break;
81108420:	00000b06 	br	81108450 <uliConvRmapCfgAddr+0x254>
	case 0x00000044:
		uliValue = 0x0000004F;
81108424:	008013c4 	movi	r2,79
81108428:	e0bffe15 	stw	r2,-8(fp)
		break;
8110842c:	00000806 	br	81108450 <uliConvRmapCfgAddr+0x254>
	case 0x00000048:
		uliValue = 0x00000050;
81108430:	00801404 	movi	r2,80
81108434:	e0bffe15 	stw	r2,-8(fp)
		break;
81108438:	00000506 	br	81108450 <uliConvRmapCfgAddr+0x254>
	case 0x0000004C:
		uliValue = 0x00000051;
8110843c:	00801444 	movi	r2,81
81108440:	e0bffe15 	stw	r2,-8(fp)
		break;
81108444:	00000206 	br	81108450 <uliConvRmapCfgAddr+0x254>
	default:
		uliValue = 0x00000000;
81108448:	e03ffe15 	stw	zero,-8(fp)
		break;
8110844c:	0001883a 	nop
	}

	return uliValue;
81108450:	e0bffe17 	ldw	r2,-8(fp)
}
81108454:	e037883a 	mov	sp,fp
81108458:	df000017 	ldw	fp,0(sp)
8110845c:	dec00104 	addi	sp,sp,4
81108460:	f800283a 	ret

81108464 <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
81108464:	defffb04 	addi	sp,sp,-20
81108468:	de00012e 	bgeu	sp,et,81108470 <bSpwcSetLink+0xc>
8110846c:	003b68fa 	trap	3
81108470:	dfc00415 	stw	ra,16(sp)
81108474:	df000315 	stw	fp,12(sp)
81108478:	df000304 	addi	fp,sp,12
8110847c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108480:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108484:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81108488:	e0bfff17 	ldw	r2,-4(fp)
8110848c:	10003c26 	beq	r2,zero,81108580 <bSpwcSetLink+0x11c>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81108490:	e0bfff17 	ldw	r2,-4(fp)
81108494:	10800017 	ldw	r2,0(r2)
81108498:	000b883a 	mov	r5,zero
8110849c:	1009883a 	mov	r4,r2
811084a0:	1108b300 	call	81108b30 <uliSpwcReadReg>
811084a4:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
811084a8:	e0bfff17 	ldw	r2,-4(fp)
811084ac:	10800117 	ldw	r2,4(r2)
811084b0:	10000426 	beq	r2,zero,811084c4 <bSpwcSetLink+0x60>
			uliReg |= COMM_SPW_LNKCFG_AUTOSTART_MSK;
811084b4:	e0bffe17 	ldw	r2,-8(fp)
811084b8:	10800114 	ori	r2,r2,4
811084bc:	e0bffe15 	stw	r2,-8(fp)
811084c0:	00000406 	br	811084d4 <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_AUTOSTART_MSK);
811084c4:	e0fffe17 	ldw	r3,-8(fp)
811084c8:	00bffec4 	movi	r2,-5
811084cc:	1884703a 	and	r2,r3,r2
811084d0:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bLinkStart) {
811084d4:	e0bfff17 	ldw	r2,-4(fp)
811084d8:	10800217 	ldw	r2,8(r2)
811084dc:	10000426 	beq	r2,zero,811084f0 <bSpwcSetLink+0x8c>
			uliReg |= COMM_SPW_LNKCFG_LINKSTART_MSK;
811084e0:	e0bffe17 	ldw	r2,-8(fp)
811084e4:	10800094 	ori	r2,r2,2
811084e8:	e0bffe15 	stw	r2,-8(fp)
811084ec:	00000406 	br	81108500 <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_LINKSTART_MSK);
811084f0:	e0fffe17 	ldw	r3,-8(fp)
811084f4:	00bfff44 	movi	r2,-3
811084f8:	1884703a 	and	r2,r3,r2
811084fc:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
81108500:	e0bfff17 	ldw	r2,-4(fp)
81108504:	10800317 	ldw	r2,12(r2)
81108508:	10000426 	beq	r2,zero,8110851c <bSpwcSetLink+0xb8>
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
8110850c:	e0bffe17 	ldw	r2,-8(fp)
81108510:	10800054 	ori	r2,r2,1
81108514:	e0bffe15 	stw	r2,-8(fp)
81108518:	00000406 	br	8110852c <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
8110851c:	e0fffe17 	ldw	r3,-8(fp)
81108520:	00bfff84 	movi	r2,-2
81108524:	1884703a 	and	r2,r3,r2
81108528:	e0bffe15 	stw	r2,-8(fp)
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
8110852c:	e0fffe17 	ldw	r3,-8(fp)
81108530:	00804034 	movhi	r2,256
81108534:	10bfffc4 	addi	r2,r2,-1
81108538:	1884703a 	and	r2,r3,r2
8110853c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));
81108540:	e0bfff17 	ldw	r2,-4(fp)
81108544:	10800403 	ldbu	r2,16(r2)
81108548:	10803fcc 	andi	r2,r2,255
8110854c:	1004963a 	slli	r2,r2,24
81108550:	1007883a 	mov	r3,r2
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
81108554:	e0bffe17 	ldw	r2,-8(fp)
81108558:	10c4b03a 	or	r2,r2,r3
8110855c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_LINK_CFG_STAT_REG_OFST,
81108560:	e0bfff17 	ldw	r2,-4(fp)
81108564:	10800017 	ldw	r2,0(r2)
81108568:	e1bffe17 	ldw	r6,-8(fp)
8110856c:	000b883a 	mov	r5,zero
81108570:	1009883a 	mov	r4,r2
81108574:	1108adc0 	call	81108adc <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
81108578:	00800044 	movi	r2,1
8110857c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108580:	e0bffd17 	ldw	r2,-12(fp)
}
81108584:	e037883a 	mov	sp,fp
81108588:	dfc00117 	ldw	ra,4(sp)
8110858c:	df000017 	ldw	fp,0(sp)
81108590:	dec00204 	addi	sp,sp,8
81108594:	f800283a 	ret

81108598 <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
81108598:	defffb04 	addi	sp,sp,-20
8110859c:	de00012e 	bgeu	sp,et,811085a4 <bSpwcGetLink+0xc>
811085a0:	003b68fa 	trap	3
811085a4:	dfc00415 	stw	ra,16(sp)
811085a8:	df000315 	stw	fp,12(sp)
811085ac:	df000304 	addi	fp,sp,12
811085b0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811085b4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811085b8:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811085bc:	e0bfff17 	ldw	r2,-4(fp)
811085c0:	10002826 	beq	r2,zero,81108664 <bSpwcGetLink+0xcc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811085c4:	e0bfff17 	ldw	r2,-4(fp)
811085c8:	10800017 	ldw	r2,0(r2)
811085cc:	000b883a 	mov	r5,zero
811085d0:	1009883a 	mov	r4,r2
811085d4:	1108b300 	call	81108b30 <uliSpwcReadReg>
811085d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKCFG_AUTOSTART_MSK) {
811085dc:	e0bffe17 	ldw	r2,-8(fp)
811085e0:	1080010c 	andi	r2,r2,4
811085e4:	10000426 	beq	r2,zero,811085f8 <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
811085e8:	e0bfff17 	ldw	r2,-4(fp)
811085ec:	00c00044 	movi	r3,1
811085f0:	10c00115 	stw	r3,4(r2)
811085f4:	00000206 	br	81108600 <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
811085f8:	e0bfff17 	ldw	r2,-4(fp)
811085fc:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_LINKSTART_MSK) {
81108600:	e0bffe17 	ldw	r2,-8(fp)
81108604:	1080008c 	andi	r2,r2,2
81108608:	10000426 	beq	r2,zero,8110861c <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bLinkStart = TRUE;
8110860c:	e0bfff17 	ldw	r2,-4(fp)
81108610:	00c00044 	movi	r3,1
81108614:	10c00215 	stw	r3,8(r2)
81108618:	00000206 	br	81108624 <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bLinkStart = FALSE;
8110861c:	e0bfff17 	ldw	r2,-4(fp)
81108620:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
81108624:	e0bffe17 	ldw	r2,-8(fp)
81108628:	1080004c 	andi	r2,r2,1
8110862c:	10000426 	beq	r2,zero,81108640 <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
81108630:	e0bfff17 	ldw	r2,-4(fp)
81108634:	00c00044 	movi	r3,1
81108638:	10c00315 	stw	r3,12(r2)
8110863c:	00000206 	br	81108648 <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
81108640:	e0bfff17 	ldw	r2,-4(fp)
81108644:	10000315 	stw	zero,12(r2)
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);
81108648:	e0bffe17 	ldw	r2,-8(fp)
8110864c:	1004d63a 	srli	r2,r2,24
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
81108650:	1007883a 	mov	r3,r2
81108654:	e0bfff17 	ldw	r2,-4(fp)
81108658:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);

		bStatus = TRUE;
8110865c:	00800044 	movi	r2,1
81108660:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108664:	e0bffd17 	ldw	r2,-12(fp)
}
81108668:	e037883a 	mov	sp,fp
8110866c:	dfc00117 	ldw	ra,4(sp)
81108670:	df000017 	ldw	fp,0(sp)
81108674:	dec00204 	addi	sp,sp,8
81108678:	f800283a 	ret

8110867c <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
8110867c:	defffb04 	addi	sp,sp,-20
81108680:	de00012e 	bgeu	sp,et,81108688 <bSpwcGetLinkError+0xc>
81108684:	003b68fa 	trap	3
81108688:	dfc00415 	stw	ra,16(sp)
8110868c:	df000315 	stw	fp,12(sp)
81108690:	df000304 	addi	fp,sp,12
81108694:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108698:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110869c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811086a0:	e0bfff17 	ldw	r2,-4(fp)
811086a4:	10002c26 	beq	r2,zero,81108758 <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811086a8:	e0bfff17 	ldw	r2,-4(fp)
811086ac:	10800017 	ldw	r2,0(r2)
811086b0:	000b883a 	mov	r5,zero
811086b4:	1009883a 	mov	r4,r2
811086b8:	1108b300 	call	81108b30 <uliSpwcReadReg>
811086bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKERR_DISCONNECT_MSK) {
811086c0:	e0bffe17 	ldw	r2,-8(fp)
811086c4:	1080006c 	andhi	r2,r2,1
811086c8:	10000426 	beq	r2,zero,811086dc <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
811086cc:	e0bfff17 	ldw	r2,-4(fp)
811086d0:	00c00044 	movi	r3,1
811086d4:	10c00515 	stw	r3,20(r2)
811086d8:	00000206 	br	811086e4 <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
811086dc:	e0bfff17 	ldw	r2,-4(fp)
811086e0:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_PARITY_MSK) {
811086e4:	e0bffe17 	ldw	r2,-8(fp)
811086e8:	108000ac 	andhi	r2,r2,2
811086ec:	10000426 	beq	r2,zero,81108700 <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
811086f0:	e0bfff17 	ldw	r2,-4(fp)
811086f4:	00c00044 	movi	r3,1
811086f8:	10c00615 	stw	r3,24(r2)
811086fc:	00000206 	br	81108708 <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
81108700:	e0bfff17 	ldw	r2,-4(fp)
81108704:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_ESCAPE_MSK) {
81108708:	e0bffe17 	ldw	r2,-8(fp)
8110870c:	1080012c 	andhi	r2,r2,4
81108710:	10000426 	beq	r2,zero,81108724 <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
81108714:	e0bfff17 	ldw	r2,-4(fp)
81108718:	00c00044 	movi	r3,1
8110871c:	10c00715 	stw	r3,28(r2)
81108720:	00000206 	br	8110872c <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
81108724:	e0bfff17 	ldw	r2,-4(fp)
81108728:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_CREDIT_MSK) {
8110872c:	e0bffe17 	ldw	r2,-8(fp)
81108730:	1080022c 	andhi	r2,r2,8
81108734:	10000426 	beq	r2,zero,81108748 <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
81108738:	e0bfff17 	ldw	r2,-4(fp)
8110873c:	00c00044 	movi	r3,1
81108740:	10c00815 	stw	r3,32(r2)
81108744:	00000206 	br	81108750 <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
81108748:	e0bfff17 	ldw	r2,-4(fp)
8110874c:	10000815 	stw	zero,32(r2)
		}

		bStatus = TRUE;
81108750:	00800044 	movi	r2,1
81108754:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108758:	e0bffd17 	ldw	r2,-12(fp)
}
8110875c:	e037883a 	mov	sp,fp
81108760:	dfc00117 	ldw	ra,4(sp)
81108764:	df000017 	ldw	fp,0(sp)
81108768:	dec00204 	addi	sp,sp,8
8110876c:	f800283a 	ret

81108770 <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
81108770:	defffb04 	addi	sp,sp,-20
81108774:	de00012e 	bgeu	sp,et,8110877c <bSpwcGetLinkStatus+0xc>
81108778:	003b68fa 	trap	3
8110877c:	dfc00415 	stw	ra,16(sp)
81108780:	df000315 	stw	fp,12(sp)
81108784:	df000304 	addi	fp,sp,12
81108788:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110878c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108790:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81108794:	e0bfff17 	ldw	r2,-4(fp)
81108798:	10002326 	beq	r2,zero,81108828 <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110879c:	e0bfff17 	ldw	r2,-4(fp)
811087a0:	10800017 	ldw	r2,0(r2)
811087a4:	000b883a 	mov	r5,zero
811087a8:	1009883a 	mov	r4,r2
811087ac:	1108b300 	call	81108b30 <uliSpwcReadReg>
811087b0:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKSTAT_STARTED_MSK) {
811087b4:	e0bffe17 	ldw	r2,-8(fp)
811087b8:	1081000c 	andi	r2,r2,1024
811087bc:	10000426 	beq	r2,zero,811087d0 <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
811087c0:	e0bfff17 	ldw	r2,-4(fp)
811087c4:	00c00044 	movi	r3,1
811087c8:	10c00915 	stw	r3,36(r2)
811087cc:	00000206 	br	811087d8 <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
811087d0:	e0bfff17 	ldw	r2,-4(fp)
811087d4:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_CONNECTING_MSK) {
811087d8:	e0bffe17 	ldw	r2,-8(fp)
811087dc:	1080800c 	andi	r2,r2,512
811087e0:	10000426 	beq	r2,zero,811087f4 <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
811087e4:	e0bfff17 	ldw	r2,-4(fp)
811087e8:	00c00044 	movi	r3,1
811087ec:	10c00a15 	stw	r3,40(r2)
811087f0:	00000206 	br	811087fc <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
811087f4:	e0bfff17 	ldw	r2,-4(fp)
811087f8:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_RUNNING_MSK) {
811087fc:	e0bffe17 	ldw	r2,-8(fp)
81108800:	1080400c 	andi	r2,r2,256
81108804:	10000426 	beq	r2,zero,81108818 <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
81108808:	e0bfff17 	ldw	r2,-4(fp)
8110880c:	00c00044 	movi	r3,1
81108810:	10c00b15 	stw	r3,44(r2)
81108814:	00000206 	br	81108820 <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
81108818:	e0bfff17 	ldw	r2,-4(fp)
8110881c:	10000b15 	stw	zero,44(r2)
		}

		bStatus = TRUE;
81108820:	00800044 	movi	r2,1
81108824:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108828:	e0bffd17 	ldw	r2,-12(fp)
}
8110882c:	e037883a 	mov	sp,fp
81108830:	dfc00117 	ldw	ra,4(sp)
81108834:	df000017 	ldw	fp,0(sp)
81108838:	dec00204 	addi	sp,sp,8
8110883c:	f800283a 	ret

81108840 <bSpwcGetTimecode>:

bool bSpwcGetTimecode(TSpwcChannel *pxSpwcCh) {
81108840:	defffb04 	addi	sp,sp,-20
81108844:	de00012e 	bgeu	sp,et,8110884c <bSpwcGetTimecode+0xc>
81108848:	003b68fa 	trap	3
8110884c:	dfc00415 	stw	ra,16(sp)
81108850:	df000315 	stw	fp,12(sp)
81108854:	df000304 	addi	fp,sp,12
81108858:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110885c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108860:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81108864:	e0bfff17 	ldw	r2,-4(fp)
81108868:	10001326 	beq	r2,zero,811088b8 <bSpwcGetTimecode+0x78>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110886c:	e0bfff17 	ldw	r2,-4(fp)
81108870:	10800017 	ldw	r2,0(r2)
81108874:	01400044 	movi	r5,1
81108878:	1009883a 	mov	r4,r2
8110887c:	1108b300 	call	81108b30 <uliSpwcReadReg>
81108880:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
81108884:	e0bffe17 	ldw	r2,-8(fp)
81108888:	1080300c 	andi	r2,r2,192
8110888c:	1004d1ba 	srli	r2,r2,6

	if (pxSpwcCh != NULL) {
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
81108890:	1007883a 	mov	r3,r2
81108894:	e0bfff17 	ldw	r2,-4(fp)
81108898:	10c00c05 	stb	r3,48(r2)
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
		pxSpwcCh->xTimecode.ucCounter= (alt_u8)(
8110889c:	e0bffe17 	ldw	r2,-8(fp)
811088a0:	10800fcc 	andi	r2,r2,63
811088a4:	1007883a 	mov	r3,r2
811088a8:	e0bfff17 	ldw	r2,-4(fp)
811088ac:	10c00c45 	stb	r3,49(r2)
				(uliReg & COMM_TIMECODE_TIME_MSK) >> 0);

		bStatus = TRUE;
811088b0:	00800044 	movi	r2,1
811088b4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811088b8:	e0bffd17 	ldw	r2,-12(fp)
}
811088bc:	e037883a 	mov	sp,fp
811088c0:	dfc00117 	ldw	ra,4(sp)
811088c4:	df000017 	ldw	fp,0(sp)
811088c8:	dec00204 	addi	sp,sp,8
811088cc:	f800283a 	ret

811088d0 <bSpwcClearTimecode>:

bool bSpwcClearTimecode(TSpwcChannel *pxSpwcCh) {
811088d0:	defffb04 	addi	sp,sp,-20
811088d4:	de00012e 	bgeu	sp,et,811088dc <bSpwcClearTimecode+0xc>
811088d8:	003b68fa 	trap	3
811088dc:	dfc00415 	stw	ra,16(sp)
811088e0:	df000315 	stw	fp,12(sp)
811088e4:	df000304 	addi	fp,sp,12
811088e8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811088ec:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811088f0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811088f4:	e0bfff17 	ldw	r2,-4(fp)
811088f8:	10001126 	beq	r2,zero,81108940 <bSpwcClearTimecode+0x70>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811088fc:	e0bfff17 	ldw	r2,-4(fp)
81108900:	10800017 	ldw	r2,0(r2)
81108904:	01400044 	movi	r5,1
81108908:	1009883a 	mov	r4,r2
8110890c:	1108b300 	call	81108b30 <uliSpwcReadReg>
81108910:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		uliReg |= COMM_TIMECODE_CLR_MSK;
81108914:	e0bffe17 	ldw	r2,-8(fp)
81108918:	10804014 	ori	r2,r2,256
8110891c:	e0bffe15 	stw	r2,-8(fp)

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_TIMECODE_REG_OFST, uliReg);
81108920:	e0bfff17 	ldw	r2,-4(fp)
81108924:	10800017 	ldw	r2,0(r2)
81108928:	e1bffe17 	ldw	r6,-8(fp)
8110892c:	01400044 	movi	r5,1
81108930:	1009883a 	mov	r4,r2
81108934:	1108adc0 	call	81108adc <vSpwcWriteReg>
		bStatus = TRUE;
81108938:	00800044 	movi	r2,1
8110893c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108940:	e0bffd17 	ldw	r2,-12(fp)
}
81108944:	e037883a 	mov	sp,fp
81108948:	dfc00117 	ldw	ra,4(sp)
8110894c:	df000017 	ldw	fp,0(sp)
81108950:	dec00204 	addi	sp,sp,8
81108954:	f800283a 	ret

81108958 <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
81108958:	defffb04 	addi	sp,sp,-20
8110895c:	de00012e 	bgeu	sp,et,81108964 <bSpwcInitCh+0xc>
81108960:	003b68fa 	trap	3
81108964:	dfc00415 	stw	ra,16(sp)
81108968:	df000315 	stw	fp,12(sp)
8110896c:	df000304 	addi	fp,sp,12
81108970:	e13ffe15 	stw	r4,-8(fp)
81108974:	2805883a 	mov	r2,r5
81108978:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110897c:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
81108980:	e0bffe17 	ldw	r2,-8(fp)
81108984:	10004f26 	beq	r2,zero,81108ac4 <bSpwcInitCh+0x16c>
		bStatus = TRUE;
81108988:	00800044 	movi	r2,1
8110898c:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81108990:	e0bfff03 	ldbu	r2,-4(fp)
81108994:	10c00228 	cmpgeui	r3,r2,8
81108998:	1800361e 	bne	r3,zero,81108a74 <bSpwcInitCh+0x11c>
8110899c:	100690ba 	slli	r3,r2,2
811089a0:	00a04474 	movhi	r2,33041
811089a4:	10a26d04 	addi	r2,r2,-30284
811089a8:	1885883a 	add	r2,r3,r2
811089ac:	10800017 	ldw	r2,0(r2)
811089b0:	1000683a 	jmp	r2
811089b4:	811089d4 	ori	r4,r16,16935
811089b8:	811089e8 	cmpgeui	r4,r16,16935
811089bc:	811089fc 	xorhi	r4,r16,16935
811089c0:	81108a10 	cmplti	r4,r16,16936
811089c4:	81108a24 	muli	r4,r16,16936
811089c8:	81108a38 	rdprs	r4,r16,16936
811089cc:	81108a4c 	andi	r4,r16,16937
811089d0:	81108a60 	cmpeqi	r4,r16,16937
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
811089d4:	e0fffe17 	ldw	r3,-8(fp)
811089d8:	00a04834 	movhi	r2,33056
811089dc:	108b0004 	addi	r2,r2,11264
811089e0:	18800015 	stw	r2,0(r3)
			break;
811089e4:	00002506 	br	81108a7c <bSpwcInitCh+0x124>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
811089e8:	e0fffe17 	ldw	r3,-8(fp)
811089ec:	00a04834 	movhi	r2,33056
811089f0:	108a0004 	addi	r2,r2,10240
811089f4:	18800015 	stw	r2,0(r3)
			break;
811089f8:	00002006 	br	81108a7c <bSpwcInitCh+0x124>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811089fc:	e0fffe17 	ldw	r3,-8(fp)
81108a00:	00a04834 	movhi	r2,33056
81108a04:	108b0004 	addi	r2,r2,11264
81108a08:	18800015 	stw	r2,0(r3)
			break;
81108a0c:	00001b06 	br	81108a7c <bSpwcInitCh+0x124>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81108a10:	e0fffe17 	ldw	r3,-8(fp)
81108a14:	00a04834 	movhi	r2,33056
81108a18:	108a0004 	addi	r2,r2,10240
81108a1c:	18800015 	stw	r2,0(r3)
			break;
81108a20:	00001606 	br	81108a7c <bSpwcInitCh+0x124>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81108a24:	e0fffe17 	ldw	r3,-8(fp)
81108a28:	00a04834 	movhi	r2,33056
81108a2c:	108b0004 	addi	r2,r2,11264
81108a30:	18800015 	stw	r2,0(r3)
			break;
81108a34:	00001106 	br	81108a7c <bSpwcInitCh+0x124>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81108a38:	e0fffe17 	ldw	r3,-8(fp)
81108a3c:	00a04834 	movhi	r2,33056
81108a40:	108a0004 	addi	r2,r2,10240
81108a44:	18800015 	stw	r2,0(r3)
			break;
81108a48:	00000c06 	br	81108a7c <bSpwcInitCh+0x124>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81108a4c:	e0fffe17 	ldw	r3,-8(fp)
81108a50:	00a04834 	movhi	r2,33056
81108a54:	108b0004 	addi	r2,r2,11264
81108a58:	18800015 	stw	r2,0(r3)
			break;
81108a5c:	00000706 	br	81108a7c <bSpwcInitCh+0x124>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81108a60:	e0fffe17 	ldw	r3,-8(fp)
81108a64:	00a04834 	movhi	r2,33056
81108a68:	108a0004 	addi	r2,r2,10240
81108a6c:	18800015 	stw	r2,0(r3)
			break;
81108a70:	00000206 	br	81108a7c <bSpwcInitCh+0x124>
		default:
			bStatus = FALSE;
81108a74:	e03ffd15 	stw	zero,-12(fp)
			break;
81108a78:	0001883a 	nop
		}

		if (bStatus) {
81108a7c:	e0bffd17 	ldw	r2,-12(fp)
81108a80:	10001026 	beq	r2,zero,81108ac4 <bSpwcInitCh+0x16c>
			if (!bSpwcGetLink(pxSpwcCh)) {
81108a84:	e13ffe17 	ldw	r4,-8(fp)
81108a88:	11085980 	call	81108598 <bSpwcGetLink>
81108a8c:	1000011e 	bne	r2,zero,81108a94 <bSpwcInitCh+0x13c>
				bStatus = FALSE;
81108a90:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
81108a94:	e13ffe17 	ldw	r4,-8(fp)
81108a98:	110867c0 	call	8110867c <bSpwcGetLinkError>
81108a9c:	1000011e 	bne	r2,zero,81108aa4 <bSpwcInitCh+0x14c>
				bStatus = FALSE;
81108aa0:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
81108aa4:	e13ffe17 	ldw	r4,-8(fp)
81108aa8:	11087700 	call	81108770 <bSpwcGetLinkStatus>
81108aac:	1000011e 	bne	r2,zero,81108ab4 <bSpwcInitCh+0x15c>
				bStatus = FALSE;
81108ab0:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetTimecode(pxSpwcCh)) {
81108ab4:	e13ffe17 	ldw	r4,-8(fp)
81108ab8:	11088400 	call	81108840 <bSpwcGetTimecode>
81108abc:	1000011e 	bne	r2,zero,81108ac4 <bSpwcInitCh+0x16c>
				bStatus = FALSE;
81108ac0:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81108ac4:	e0bffd17 	ldw	r2,-12(fp)
}
81108ac8:	e037883a 	mov	sp,fp
81108acc:	dfc00117 	ldw	ra,4(sp)
81108ad0:	df000017 	ldw	fp,0(sp)
81108ad4:	dec00204 	addi	sp,sp,8
81108ad8:	f800283a 	ret

81108adc <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81108adc:	defffc04 	addi	sp,sp,-16
81108ae0:	de00012e 	bgeu	sp,et,81108ae8 <vSpwcWriteReg+0xc>
81108ae4:	003b68fa 	trap	3
81108ae8:	df000315 	stw	fp,12(sp)
81108aec:	df000304 	addi	fp,sp,12
81108af0:	e13ffd15 	stw	r4,-12(fp)
81108af4:	e17ffe15 	stw	r5,-8(fp)
81108af8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81108afc:	e0bffe17 	ldw	r2,-8(fp)
81108b00:	1085883a 	add	r2,r2,r2
81108b04:	1085883a 	add	r2,r2,r2
81108b08:	1007883a 	mov	r3,r2
81108b0c:	e0bffd17 	ldw	r2,-12(fp)
81108b10:	10c5883a 	add	r2,r2,r3
81108b14:	e0ffff17 	ldw	r3,-4(fp)
81108b18:	10c00015 	stw	r3,0(r2)
}
81108b1c:	0001883a 	nop
81108b20:	e037883a 	mov	sp,fp
81108b24:	df000017 	ldw	fp,0(sp)
81108b28:	dec00104 	addi	sp,sp,4
81108b2c:	f800283a 	ret

81108b30 <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81108b30:	defffc04 	addi	sp,sp,-16
81108b34:	de00012e 	bgeu	sp,et,81108b3c <uliSpwcReadReg+0xc>
81108b38:	003b68fa 	trap	3
81108b3c:	df000315 	stw	fp,12(sp)
81108b40:	df000304 	addi	fp,sp,12
81108b44:	e13ffe15 	stw	r4,-8(fp)
81108b48:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81108b4c:	e0bfff17 	ldw	r2,-4(fp)
81108b50:	1085883a 	add	r2,r2,r2
81108b54:	1085883a 	add	r2,r2,r2
81108b58:	1007883a 	mov	r3,r2
81108b5c:	e0bffe17 	ldw	r2,-8(fp)
81108b60:	10c5883a 	add	r2,r2,r3
81108b64:	10800017 	ldw	r2,0(r2)
81108b68:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81108b6c:	e0bffd17 	ldw	r2,-12(fp)
}
81108b70:	e037883a 	mov	sp,fp
81108b74:	df000017 	ldw	fp,0(sp)
81108b78:	dec00104 	addi	sp,sp,4
81108b7c:	f800283a 	ret

81108b80 <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
81108b80:	defffe04 	addi	sp,sp,-8
81108b84:	de00012e 	bgeu	sp,et,81108b8c <bEnableIsoDrivers+0xc>
81108b88:	003b68fa 	trap	3
81108b8c:	dfc00115 	stw	ra,4(sp)
81108b90:	df000015 	stw	fp,0(sp)
81108b94:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
81108b98:	01400204 	movi	r5,8
81108b9c:	01000044 	movi	r4,1
81108ba0:	1108d300 	call	81108d30 <bCtrlIoLvdsDrive>
  return  TRUE;
81108ba4:	00800044 	movi	r2,1
}
81108ba8:	e037883a 	mov	sp,fp
81108bac:	dfc00117 	ldw	ra,4(sp)
81108bb0:	df000017 	ldw	fp,0(sp)
81108bb4:	dec00204 	addi	sp,sp,8
81108bb8:	f800283a 	ret

81108bbc <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
81108bbc:	defffe04 	addi	sp,sp,-8
81108bc0:	de00012e 	bgeu	sp,et,81108bc8 <bDisableIsoDrivers+0xc>
81108bc4:	003b68fa 	trap	3
81108bc8:	dfc00115 	stw	ra,4(sp)
81108bcc:	df000015 	stw	fp,0(sp)
81108bd0:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
81108bd4:	01400204 	movi	r5,8
81108bd8:	0009883a 	mov	r4,zero
81108bdc:	1108d300 	call	81108d30 <bCtrlIoLvdsDrive>
  return  TRUE;
81108be0:	00800044 	movi	r2,1
}
81108be4:	e037883a 	mov	sp,fp
81108be8:	dfc00117 	ldw	ra,4(sp)
81108bec:	df000017 	ldw	fp,0(sp)
81108bf0:	dec00204 	addi	sp,sp,8
81108bf4:	f800283a 	ret

81108bf8 <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
81108bf8:	defffe04 	addi	sp,sp,-8
81108bfc:	de00012e 	bgeu	sp,et,81108c04 <bEnableLvdsBoard+0xc>
81108c00:	003b68fa 	trap	3
81108c04:	dfc00115 	stw	ra,4(sp)
81108c08:	df000015 	stw	fp,0(sp)
81108c0c:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
81108c10:	01400104 	movi	r5,4
81108c14:	01000044 	movi	r4,1
81108c18:	1108d300 	call	81108d30 <bCtrlIoLvdsDrive>
  return  TRUE;
81108c1c:	00800044 	movi	r2,1
}
81108c20:	e037883a 	mov	sp,fp
81108c24:	dfc00117 	ldw	ra,4(sp)
81108c28:	df000017 	ldw	fp,0(sp)
81108c2c:	dec00204 	addi	sp,sp,8
81108c30:	f800283a 	ret

81108c34 <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
81108c34:	defffe04 	addi	sp,sp,-8
81108c38:	de00012e 	bgeu	sp,et,81108c40 <bDisableLvdsBoard+0xc>
81108c3c:	003b68fa 	trap	3
81108c40:	dfc00115 	stw	ra,4(sp)
81108c44:	df000015 	stw	fp,0(sp)
81108c48:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
81108c4c:	01400104 	movi	r5,4
81108c50:	0009883a 	mov	r4,zero
81108c54:	1108d300 	call	81108d30 <bCtrlIoLvdsDrive>
  return  TRUE;
81108c58:	00800044 	movi	r2,1
}
81108c5c:	e037883a 	mov	sp,fp
81108c60:	dfc00117 	ldw	ra,4(sp)
81108c64:	df000017 	ldw	fp,0(sp)
81108c68:	dec00204 	addi	sp,sp,8
81108c6c:	f800283a 	ret

81108c70 <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
81108c70:	defffd04 	addi	sp,sp,-12
81108c74:	de00012e 	bgeu	sp,et,81108c7c <bSetPreEmphasys+0xc>
81108c78:	003b68fa 	trap	3
81108c7c:	dfc00215 	stw	ra,8(sp)
81108c80:	df000115 	stw	fp,4(sp)
81108c84:	df000104 	addi	fp,sp,4
81108c88:	2005883a 	mov	r2,r4
81108c8c:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
81108c90:	e0bfff03 	ldbu	r2,-4(fp)
81108c94:	10c00060 	cmpeqi	r3,r2,1
81108c98:	18000d1e 	bne	r3,zero,81108cd0 <bSetPreEmphasys+0x60>
81108c9c:	10c00088 	cmpgei	r3,r2,2
81108ca0:	1800021e 	bne	r3,zero,81108cac <bSetPreEmphasys+0x3c>
81108ca4:	10000626 	beq	r2,zero,81108cc0 <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
81108ca8:	00001b06 	br	81108d18 <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
81108cac:	10c000a0 	cmpeqi	r3,r2,2
81108cb0:	18000e1e 	bne	r3,zero,81108cec <bSetPreEmphasys+0x7c>
81108cb4:	108000e0 	cmpeqi	r2,r2,3
81108cb8:	1000131e 	bne	r2,zero,81108d08 <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
81108cbc:	00001606 	br	81108d18 <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
81108cc0:	014000c4 	movi	r5,3
81108cc4:	0009883a 	mov	r4,zero
81108cc8:	1108d300 	call	81108d30 <bCtrlIoLvdsDrive>
      break;
81108ccc:	00001206 	br	81108d18 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
81108cd0:	01400084 	movi	r5,2
81108cd4:	0009883a 	mov	r4,zero
81108cd8:	1108d300 	call	81108d30 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
81108cdc:	01400044 	movi	r5,1
81108ce0:	01000044 	movi	r4,1
81108ce4:	1108d300 	call	81108d30 <bCtrlIoLvdsDrive>
      break;
81108ce8:	00000b06 	br	81108d18 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
81108cec:	01400044 	movi	r5,1
81108cf0:	0009883a 	mov	r4,zero
81108cf4:	1108d300 	call	81108d30 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
81108cf8:	01400084 	movi	r5,2
81108cfc:	01000044 	movi	r4,1
81108d00:	1108d300 	call	81108d30 <bCtrlIoLvdsDrive>
      break;
81108d04:	00000406 	br	81108d18 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
81108d08:	014000c4 	movi	r5,3
81108d0c:	01000044 	movi	r4,1
81108d10:	1108d300 	call	81108d30 <bCtrlIoLvdsDrive>
      break;
81108d14:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
81108d18:	00800044 	movi	r2,1
}
81108d1c:	e037883a 	mov	sp,fp
81108d20:	dfc00117 	ldw	ra,4(sp)
81108d24:	df000017 	ldw	fp,0(sp)
81108d28:	dec00204 	addi	sp,sp,8
81108d2c:	f800283a 	ret

81108d30 <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
81108d30:	defffd04 	addi	sp,sp,-12
81108d34:	de00012e 	bgeu	sp,et,81108d3c <bCtrlIoLvdsDrive+0xc>
81108d38:	003b68fa 	trap	3
81108d3c:	df000215 	stw	fp,8(sp)
81108d40:	df000204 	addi	fp,sp,8
81108d44:	e13ffe15 	stw	r4,-8(fp)
81108d48:	2805883a 	mov	r2,r5
81108d4c:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
81108d50:	e0bffe17 	ldw	r2,-8(fp)
81108d54:	1000071e 	bne	r2,zero,81108d74 <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
81108d58:	e0bfff03 	ldbu	r2,-4(fp)
81108d5c:	0084303a 	nor	r2,zero,r2
81108d60:	1007883a 	mov	r3,r2
81108d64:	d0a00103 	ldbu	r2,-32764(gp)
81108d68:	1884703a 	and	r2,r3,r2
81108d6c:	d0a00105 	stb	r2,-32764(gp)
81108d70:	00000406 	br	81108d84 <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
81108d74:	d0e00103 	ldbu	r3,-32764(gp)
81108d78:	e0bfff03 	ldbu	r2,-4(fp)
81108d7c:	1884b03a 	or	r2,r3,r2
81108d80:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
81108d84:	d0a00103 	ldbu	r2,-32764(gp)
81108d88:	10c03fcc 	andi	r3,r2,255
81108d8c:	00a00034 	movhi	r2,32768
81108d90:	10822804 	addi	r2,r2,2208
81108d94:	10c00035 	stwio	r3,0(r2)
  return TRUE;
81108d98:	00800044 	movi	r2,1
}
81108d9c:	e037883a 	mov	sp,fp
81108da0:	df000017 	ldw	fp,0(sp)
81108da4:	dec00104 	addi	sp,sp,4
81108da8:	f800283a 	ret

81108dac <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
81108dac:	defffa04 	addi	sp,sp,-24
81108db0:	de00012e 	bgeu	sp,et,81108db8 <I2C_TestAdress+0xc>
81108db4:	003b68fa 	trap	3
81108db8:	dfc00515 	stw	ra,20(sp)
81108dbc:	df000415 	stw	fp,16(sp)
81108dc0:	df000404 	addi	fp,sp,16
81108dc4:	e13ffd15 	stw	r4,-12(fp)
81108dc8:	e17ffe15 	stw	r5,-8(fp)
81108dcc:	3005883a 	mov	r2,r6
81108dd0:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81108dd4:	00800044 	movi	r2,1
81108dd8:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81108ddc:	e17ffe17 	ldw	r5,-8(fp)
81108de0:	e13ffd17 	ldw	r4,-12(fp)
81108de4:	110917c0 	call	8110917c <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81108de8:	e0bfff03 	ldbu	r2,-4(fp)
81108dec:	10803fcc 	andi	r2,r2,255
81108df0:	100d883a 	mov	r6,r2
81108df4:	e17ffe17 	ldw	r5,-8(fp)
81108df8:	e13ffd17 	ldw	r4,-12(fp)
81108dfc:	11092900 	call	81109290 <i2c_write>
81108e00:	1000011e 	bne	r2,zero,81108e08 <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
81108e04:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
81108e08:	e17ffe17 	ldw	r5,-8(fp)
81108e0c:	e13ffd17 	ldw	r4,-12(fp)
81108e10:	11092100 	call	81109210 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
81108e14:	0106d604 	movi	r4,7000
81108e18:	11307740 	call	81130774 <usleep>
    
    return bSuccess;
81108e1c:	e0bffc17 	ldw	r2,-16(fp)

}
81108e20:	e037883a 	mov	sp,fp
81108e24:	dfc00117 	ldw	ra,4(sp)
81108e28:	df000017 	ldw	fp,0(sp)
81108e2c:	dec00204 	addi	sp,sp,8
81108e30:	f800283a 	ret

81108e34 <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
81108e34:	defff804 	addi	sp,sp,-32
81108e38:	de00012e 	bgeu	sp,et,81108e40 <I2C_Write+0xc>
81108e3c:	003b68fa 	trap	3
81108e40:	dfc00715 	stw	ra,28(sp)
81108e44:	df000615 	stw	fp,24(sp)
81108e48:	df000604 	addi	fp,sp,24
81108e4c:	e13ffb15 	stw	r4,-20(fp)
81108e50:	e17ffc15 	stw	r5,-16(fp)
81108e54:	3009883a 	mov	r4,r6
81108e58:	3807883a 	mov	r3,r7
81108e5c:	e0800217 	ldw	r2,8(fp)
81108e60:	e13ffd05 	stb	r4,-12(fp)
81108e64:	e0fffe05 	stb	r3,-8(fp)
81108e68:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81108e6c:	00800044 	movi	r2,1
81108e70:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81108e74:	e17ffc17 	ldw	r5,-16(fp)
81108e78:	e13ffb17 	ldw	r4,-20(fp)
81108e7c:	110917c0 	call	8110917c <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81108e80:	e0bffd03 	ldbu	r2,-12(fp)
81108e84:	10803fcc 	andi	r2,r2,255
81108e88:	100d883a 	mov	r6,r2
81108e8c:	e17ffc17 	ldw	r5,-16(fp)
81108e90:	e13ffb17 	ldw	r4,-20(fp)
81108e94:	11092900 	call	81109290 <i2c_write>
81108e98:	1000011e 	bne	r2,zero,81108ea0 <I2C_Write+0x6c>
        bSuccess = FALSE;
81108e9c:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81108ea0:	e0bffa17 	ldw	r2,-24(fp)
81108ea4:	10000726 	beq	r2,zero,81108ec4 <I2C_Write+0x90>
81108ea8:	e0bffe03 	ldbu	r2,-8(fp)
81108eac:	100d883a 	mov	r6,r2
81108eb0:	e17ffc17 	ldw	r5,-16(fp)
81108eb4:	e13ffb17 	ldw	r4,-20(fp)
81108eb8:	11092900 	call	81109290 <i2c_write>
81108ebc:	1000011e 	bne	r2,zero,81108ec4 <I2C_Write+0x90>
        bSuccess = FALSE;
81108ec0:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
81108ec4:	e0bffa17 	ldw	r2,-24(fp)
81108ec8:	10000726 	beq	r2,zero,81108ee8 <I2C_Write+0xb4>
81108ecc:	e0bfff03 	ldbu	r2,-4(fp)
81108ed0:	100d883a 	mov	r6,r2
81108ed4:	e17ffc17 	ldw	r5,-16(fp)
81108ed8:	e13ffb17 	ldw	r4,-20(fp)
81108edc:	11092900 	call	81109290 <i2c_write>
81108ee0:	1000011e 	bne	r2,zero,81108ee8 <I2C_Write+0xb4>
        bSuccess = FALSE;
81108ee4:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
81108ee8:	e17ffc17 	ldw	r5,-16(fp)
81108eec:	e13ffb17 	ldw	r4,-20(fp)
81108ef0:	11092100 	call	81109210 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
81108ef4:	0106d604 	movi	r4,7000
81108ef8:	11307740 	call	81130774 <usleep>
    
    return bSuccess;
81108efc:	e0bffa17 	ldw	r2,-24(fp)

}
81108f00:	e037883a 	mov	sp,fp
81108f04:	dfc00117 	ldw	ra,4(sp)
81108f08:	df000017 	ldw	fp,0(sp)
81108f0c:	dec00204 	addi	sp,sp,8
81108f10:	f800283a 	ret

81108f14 <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
81108f14:	defff904 	addi	sp,sp,-28
81108f18:	de00012e 	bgeu	sp,et,81108f20 <I2C_Read+0xc>
81108f1c:	003b68fa 	trap	3
81108f20:	dfc00615 	stw	ra,24(sp)
81108f24:	df000515 	stw	fp,20(sp)
81108f28:	df000504 	addi	fp,sp,20
81108f2c:	e13ffc15 	stw	r4,-16(fp)
81108f30:	e17ffd15 	stw	r5,-12(fp)
81108f34:	3007883a 	mov	r3,r6
81108f38:	3805883a 	mov	r2,r7
81108f3c:	e0fffe05 	stb	r3,-8(fp)
81108f40:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81108f44:	00800044 	movi	r2,1
81108f48:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81108f4c:	e17ffd17 	ldw	r5,-12(fp)
81108f50:	e13ffc17 	ldw	r4,-16(fp)
81108f54:	110917c0 	call	8110917c <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81108f58:	e0bffe03 	ldbu	r2,-8(fp)
81108f5c:	10803fcc 	andi	r2,r2,255
81108f60:	100d883a 	mov	r6,r2
81108f64:	e17ffd17 	ldw	r5,-12(fp)
81108f68:	e13ffc17 	ldw	r4,-16(fp)
81108f6c:	11092900 	call	81109290 <i2c_write>
81108f70:	1000011e 	bne	r2,zero,81108f78 <I2C_Read+0x64>
        bSuccess = FALSE;
81108f74:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81108f78:	e0bffb17 	ldw	r2,-20(fp)
81108f7c:	10000726 	beq	r2,zero,81108f9c <I2C_Read+0x88>
81108f80:	e0bfff03 	ldbu	r2,-4(fp)
81108f84:	100d883a 	mov	r6,r2
81108f88:	e17ffd17 	ldw	r5,-12(fp)
81108f8c:	e13ffc17 	ldw	r4,-16(fp)
81108f90:	11092900 	call	81109290 <i2c_write>
81108f94:	1000011e 	bne	r2,zero,81108f9c <I2C_Read+0x88>
        bSuccess = FALSE;
81108f98:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
81108f9c:	e17ffd17 	ldw	r5,-12(fp)
81108fa0:	e13ffc17 	ldw	r4,-16(fp)
81108fa4:	110917c0 	call	8110917c <i2c_start>
    DeviceAddr |= 1; // Read
81108fa8:	e0bffe03 	ldbu	r2,-8(fp)
81108fac:	10800054 	ori	r2,r2,1
81108fb0:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
81108fb4:	e0bffb17 	ldw	r2,-20(fp)
81108fb8:	10000826 	beq	r2,zero,81108fdc <I2C_Read+0xc8>
81108fbc:	e0bffe03 	ldbu	r2,-8(fp)
81108fc0:	10803fcc 	andi	r2,r2,255
81108fc4:	100d883a 	mov	r6,r2
81108fc8:	e17ffd17 	ldw	r5,-12(fp)
81108fcc:	e13ffc17 	ldw	r4,-16(fp)
81108fd0:	11092900 	call	81109290 <i2c_write>
81108fd4:	1000011e 	bne	r2,zero,81108fdc <I2C_Read+0xc8>
        bSuccess = FALSE;
81108fd8:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
81108fdc:	e0bffb17 	ldw	r2,-20(fp)
81108fe0:	10000526 	beq	r2,zero,81108ff8 <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
81108fe4:	000f883a 	mov	r7,zero
81108fe8:	e1800217 	ldw	r6,8(fp)
81108fec:	e17ffd17 	ldw	r5,-12(fp)
81108ff0:	e13ffc17 	ldw	r4,-16(fp)
81108ff4:	11093c80 	call	811093c8 <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
81108ff8:	e17ffd17 	ldw	r5,-12(fp)
81108ffc:	e13ffc17 	ldw	r4,-16(fp)
81109000:	11092100 	call	81109210 <i2c_stop>
    
    return bSuccess;
81109004:	e0bffb17 	ldw	r2,-20(fp)
}
81109008:	e037883a 	mov	sp,fp
8110900c:	dfc00117 	ldw	ra,4(sp)
81109010:	df000017 	ldw	fp,0(sp)
81109014:	dec00204 	addi	sp,sp,8
81109018:	f800283a 	ret

8110901c <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
8110901c:	defff604 	addi	sp,sp,-40
81109020:	de00012e 	bgeu	sp,et,81109028 <I2C_MultipleRead+0xc>
81109024:	003b68fa 	trap	3
81109028:	dfc00915 	stw	ra,36(sp)
8110902c:	df000815 	stw	fp,32(sp)
81109030:	df000804 	addi	fp,sp,32
81109034:	e13ffb15 	stw	r4,-20(fp)
81109038:	e17ffc15 	stw	r5,-16(fp)
8110903c:	3007883a 	mov	r3,r6
81109040:	e1fffe15 	stw	r7,-8(fp)
81109044:	e0800217 	ldw	r2,8(fp)
81109048:	e0fffd05 	stb	r3,-12(fp)
8110904c:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
81109050:	00800044 	movi	r2,1
81109054:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
81109058:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110905c:	e17ffc17 	ldw	r5,-16(fp)
81109060:	e13ffb17 	ldw	r4,-20(fp)
81109064:	110917c0 	call	8110917c <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81109068:	e0bffd03 	ldbu	r2,-12(fp)
8110906c:	10803fcc 	andi	r2,r2,255
81109070:	100d883a 	mov	r6,r2
81109074:	e17ffc17 	ldw	r5,-16(fp)
81109078:	e13ffb17 	ldw	r4,-20(fp)
8110907c:	11092900 	call	81109290 <i2c_write>
81109080:	1000011e 	bne	r2,zero,81109088 <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
81109084:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81109088:	e0bff917 	ldw	r2,-28(fp)
8110908c:	10000726 	beq	r2,zero,811090ac <I2C_MultipleRead+0x90>
81109090:	e0bffa03 	ldbu	r2,-24(fp)
81109094:	100d883a 	mov	r6,r2
81109098:	e17ffc17 	ldw	r5,-16(fp)
8110909c:	e13ffb17 	ldw	r4,-20(fp)
811090a0:	11092900 	call	81109290 <i2c_write>
811090a4:	1000011e 	bne	r2,zero,811090ac <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
811090a8:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
811090ac:	e0bff917 	ldw	r2,-28(fp)
811090b0:	10000326 	beq	r2,zero,811090c0 <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
811090b4:	e17ffc17 	ldw	r5,-16(fp)
811090b8:	e13ffb17 	ldw	r4,-20(fp)
811090bc:	110917c0 	call	8110917c <i2c_start>
    DeviceAddr |= 1; // Read
811090c0:	e0bffd03 	ldbu	r2,-12(fp)
811090c4:	10800054 	ori	r2,r2,1
811090c8:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
811090cc:	e0bff917 	ldw	r2,-28(fp)
811090d0:	10000826 	beq	r2,zero,811090f4 <I2C_MultipleRead+0xd8>
811090d4:	e0bffd03 	ldbu	r2,-12(fp)
811090d8:	10803fcc 	andi	r2,r2,255
811090dc:	100d883a 	mov	r6,r2
811090e0:	e17ffc17 	ldw	r5,-16(fp)
811090e4:	e13ffb17 	ldw	r4,-20(fp)
811090e8:	11092900 	call	81109290 <i2c_write>
811090ec:	1000011e 	bne	r2,zero,811090f4 <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
811090f0:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
811090f4:	e0bff917 	ldw	r2,-28(fp)
811090f8:	10001726 	beq	r2,zero,81109158 <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
811090fc:	e03ff815 	stw	zero,-32(fp)
81109100:	00001006 	br	81109144 <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
81109104:	e0bff817 	ldw	r2,-32(fp)
81109108:	e0fffe17 	ldw	r3,-8(fp)
8110910c:	1889883a 	add	r4,r3,r2
81109110:	e0bfff0b 	ldhu	r2,-4(fp)
81109114:	10ffffc4 	addi	r3,r2,-1
81109118:	e0bff817 	ldw	r2,-32(fp)
8110911c:	1884c03a 	cmpne	r2,r3,r2
81109120:	10803fcc 	andi	r2,r2,255
81109124:	100f883a 	mov	r7,r2
81109128:	200d883a 	mov	r6,r4
8110912c:	e17ffc17 	ldw	r5,-16(fp)
81109130:	e13ffb17 	ldw	r4,-20(fp)
81109134:	11093c80 	call	811093c8 <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
81109138:	e0bff817 	ldw	r2,-32(fp)
8110913c:	10800044 	addi	r2,r2,1
81109140:	e0bff815 	stw	r2,-32(fp)
81109144:	e0bfff0b 	ldhu	r2,-4(fp)
81109148:	e0fff817 	ldw	r3,-32(fp)
8110914c:	1880020e 	bge	r3,r2,81109158 <I2C_MultipleRead+0x13c>
81109150:	e0bff917 	ldw	r2,-28(fp)
81109154:	103feb1e 	bne	r2,zero,81109104 <__reset+0xfb0e9104>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
81109158:	e17ffc17 	ldw	r5,-16(fp)
8110915c:	e13ffb17 	ldw	r4,-20(fp)
81109160:	11092100 	call	81109210 <i2c_stop>
    
    return bSuccess;    
81109164:	e0bff917 	ldw	r2,-28(fp)
    
}
81109168:	e037883a 	mov	sp,fp
8110916c:	dfc00117 	ldw	ra,4(sp)
81109170:	df000017 	ldw	fp,0(sp)
81109174:	dec00204 	addi	sp,sp,8
81109178:	f800283a 	ret

8110917c <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
8110917c:	defffc04 	addi	sp,sp,-16
81109180:	de00012e 	bgeu	sp,et,81109188 <i2c_start+0xc>
81109184:	003b68fa 	trap	3
81109188:	dfc00315 	stw	ra,12(sp)
8110918c:	df000215 	stw	fp,8(sp)
81109190:	df000204 	addi	fp,sp,8
81109194:	e13ffe15 	stw	r4,-8(fp)
81109198:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
8110919c:	e0bfff17 	ldw	r2,-4(fp)
811091a0:	10800104 	addi	r2,r2,4
811091a4:	1007883a 	mov	r3,r2
811091a8:	00800044 	movi	r2,1
811091ac:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
811091b0:	e0bfff17 	ldw	r2,-4(fp)
811091b4:	00c00044 	movi	r3,1
811091b8:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
811091bc:	e0bffe17 	ldw	r2,-8(fp)
811091c0:	00c00044 	movi	r3,1
811091c4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
811091c8:	01000044 	movi	r4,1
811091cc:	11307740 	call	81130774 <usleep>
     
    SDA_LOW(data_base); // data low
811091d0:	e0bfff17 	ldw	r2,-4(fp)
811091d4:	0007883a 	mov	r3,zero
811091d8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
811091dc:	01000044 	movi	r4,1
811091e0:	11307740 	call	81130774 <usleep>
    SCL_LOW(clk_base); // clock low
811091e4:	e0bffe17 	ldw	r2,-8(fp)
811091e8:	0007883a 	mov	r3,zero
811091ec:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
811091f0:	01000044 	movi	r4,1
811091f4:	11307740 	call	81130774 <usleep>
}
811091f8:	0001883a 	nop
811091fc:	e037883a 	mov	sp,fp
81109200:	dfc00117 	ldw	ra,4(sp)
81109204:	df000017 	ldw	fp,0(sp)
81109208:	dec00204 	addi	sp,sp,8
8110920c:	f800283a 	ret

81109210 <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
81109210:	defffc04 	addi	sp,sp,-16
81109214:	de00012e 	bgeu	sp,et,8110921c <i2c_stop+0xc>
81109218:	003b68fa 	trap	3
8110921c:	dfc00315 	stw	ra,12(sp)
81109220:	df000215 	stw	fp,8(sp)
81109224:	df000204 	addi	fp,sp,8
81109228:	e13ffe15 	stw	r4,-8(fp)
8110922c:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
81109230:	e0bfff17 	ldw	r2,-4(fp)
81109234:	10800104 	addi	r2,r2,4
81109238:	1007883a 	mov	r3,r2
8110923c:	00800044 	movi	r2,1
81109240:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
81109244:	e0bfff17 	ldw	r2,-4(fp)
81109248:	0007883a 	mov	r3,zero
8110924c:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
81109250:	e0bffe17 	ldw	r2,-8(fp)
81109254:	00c00044 	movi	r3,1
81109258:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
8110925c:	01000044 	movi	r4,1
81109260:	11307740 	call	81130774 <usleep>
    SDA_HIGH(data_base); // data high
81109264:	e0bfff17 	ldw	r2,-4(fp)
81109268:	00c00044 	movi	r3,1
8110926c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
81109270:	01000044 	movi	r4,1
81109274:	11307740 	call	81130774 <usleep>
    

    
}
81109278:	0001883a 	nop
8110927c:	e037883a 	mov	sp,fp
81109280:	dfc00117 	ldw	ra,4(sp)
81109284:	df000017 	ldw	fp,0(sp)
81109288:	dec00204 	addi	sp,sp,8
8110928c:	f800283a 	ret

81109290 <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
81109290:	defff804 	addi	sp,sp,-32
81109294:	de00012e 	bgeu	sp,et,8110929c <i2c_write+0xc>
81109298:	003b68fa 	trap	3
8110929c:	dfc00715 	stw	ra,28(sp)
811092a0:	df000615 	stw	fp,24(sp)
811092a4:	df000604 	addi	fp,sp,24
811092a8:	e13ffd15 	stw	r4,-12(fp)
811092ac:	e17ffe15 	stw	r5,-8(fp)
811092b0:	3005883a 	mov	r2,r6
811092b4:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
811092b8:	00bfe004 	movi	r2,-128
811092bc:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
811092c0:	e0bffe17 	ldw	r2,-8(fp)
811092c4:	10800104 	addi	r2,r2,4
811092c8:	1007883a 	mov	r3,r2
811092cc:	00800044 	movi	r2,1
811092d0:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
811092d4:	e03ffb15 	stw	zero,-20(fp)
811092d8:	00001f06 	br	81109358 <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
811092dc:	e0bffd17 	ldw	r2,-12(fp)
811092e0:	0007883a 	mov	r3,zero
811092e4:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
811092e8:	e0ffff03 	ldbu	r3,-4(fp)
811092ec:	e0bffa03 	ldbu	r2,-24(fp)
811092f0:	1884703a 	and	r2,r3,r2
811092f4:	10803fcc 	andi	r2,r2,255
811092f8:	10000426 	beq	r2,zero,8110930c <i2c_write+0x7c>
            SDA_HIGH(data_base);
811092fc:	e0bffe17 	ldw	r2,-8(fp)
81109300:	00c00044 	movi	r3,1
81109304:	10c00035 	stwio	r3,0(r2)
81109308:	00000306 	br	81109318 <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
8110930c:	e0bffe17 	ldw	r2,-8(fp)
81109310:	0007883a 	mov	r3,zero
81109314:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
81109318:	e0bffa03 	ldbu	r2,-24(fp)
8110931c:	1004d07a 	srli	r2,r2,1
81109320:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
81109324:	e0bffd17 	ldw	r2,-12(fp)
81109328:	00c00044 	movi	r3,1
8110932c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81109330:	01000044 	movi	r4,1
81109334:	11307740 	call	81130774 <usleep>
        SCL_LOW(clk_base);
81109338:	e0bffd17 	ldw	r2,-12(fp)
8110933c:	0007883a 	mov	r3,zero
81109340:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81109344:	01000044 	movi	r4,1
81109348:	11307740 	call	81130774 <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
8110934c:	e0bffb17 	ldw	r2,-20(fp)
81109350:	10800044 	addi	r2,r2,1
81109354:	e0bffb15 	stw	r2,-20(fp)
81109358:	e0bffb17 	ldw	r2,-20(fp)
8110935c:	10800210 	cmplti	r2,r2,8
81109360:	103fde1e 	bne	r2,zero,811092dc <__reset+0xfb0e92dc>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
81109364:	e0bffe17 	ldw	r2,-8(fp)
81109368:	10800104 	addi	r2,r2,4
8110936c:	0007883a 	mov	r3,zero
81109370:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
81109374:	e0bffd17 	ldw	r2,-12(fp)
81109378:	00c00044 	movi	r3,1
8110937c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
81109380:	01000044 	movi	r4,1
81109384:	11307740 	call	81130774 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
81109388:	e0bffe17 	ldw	r2,-8(fp)
8110938c:	10800037 	ldwio	r2,0(r2)
81109390:	1005003a 	cmpeq	r2,r2,zero
81109394:	10803fcc 	andi	r2,r2,255
81109398:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
8110939c:	e0bffd17 	ldw	r2,-12(fp)
811093a0:	0007883a 	mov	r3,zero
811093a4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
811093a8:	01000044 	movi	r4,1
811093ac:	11307740 	call	81130774 <usleep>
    return bAck;
811093b0:	e0bffc17 	ldw	r2,-16(fp)
}    
811093b4:	e037883a 	mov	sp,fp
811093b8:	dfc00117 	ldw	ra,4(sp)
811093bc:	df000017 	ldw	fp,0(sp)
811093c0:	dec00204 	addi	sp,sp,8
811093c4:	f800283a 	ret

811093c8 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
811093c8:	defff804 	addi	sp,sp,-32
811093cc:	de00012e 	bgeu	sp,et,811093d4 <i2c_read+0xc>
811093d0:	003b68fa 	trap	3
811093d4:	dfc00715 	stw	ra,28(sp)
811093d8:	df000615 	stw	fp,24(sp)
811093dc:	df000604 	addi	fp,sp,24
811093e0:	e13ffc15 	stw	r4,-16(fp)
811093e4:	e17ffd15 	stw	r5,-12(fp)
811093e8:	e1bffe15 	stw	r6,-8(fp)
811093ec:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
811093f0:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
811093f4:	e0bffd17 	ldw	r2,-12(fp)
811093f8:	10800104 	addi	r2,r2,4
811093fc:	0007883a 	mov	r3,zero
81109400:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
81109404:	e0bffc17 	ldw	r2,-16(fp)
81109408:	0007883a 	mov	r3,zero
8110940c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
81109410:	01000044 	movi	r4,1
81109414:	11307740 	call	81130774 <usleep>

    for(i=0;i<8;i++){
81109418:	e03ffb15 	stw	zero,-20(fp)
8110941c:	00001606 	br	81109478 <i2c_read+0xb0>
        Data <<= 1;
81109420:	e0bffa03 	ldbu	r2,-24(fp)
81109424:	1085883a 	add	r2,r2,r2
81109428:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
8110942c:	e0bffc17 	ldw	r2,-16(fp)
81109430:	00c00044 	movi	r3,1
81109434:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81109438:	01000044 	movi	r4,1
8110943c:	11307740 	call	81130774 <usleep>
        if (SDA_READ(data_base))  // read data   
81109440:	e0bffd17 	ldw	r2,-12(fp)
81109444:	10800037 	ldwio	r2,0(r2)
81109448:	10000326 	beq	r2,zero,81109458 <i2c_read+0x90>
            Data |= 0x01;
8110944c:	e0bffa03 	ldbu	r2,-24(fp)
81109450:	10800054 	ori	r2,r2,1
81109454:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
81109458:	e0bffc17 	ldw	r2,-16(fp)
8110945c:	0007883a 	mov	r3,zero
81109460:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
81109464:	01000044 	movi	r4,1
81109468:	11307740 	call	81130774 <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
8110946c:	e0bffb17 	ldw	r2,-20(fp)
81109470:	10800044 	addi	r2,r2,1
81109474:	e0bffb15 	stw	r2,-20(fp)
81109478:	e0bffb17 	ldw	r2,-20(fp)
8110947c:	10800210 	cmplti	r2,r2,8
81109480:	103fe71e 	bne	r2,zero,81109420 <__reset+0xfb0e9420>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
81109484:	e0bffc17 	ldw	r2,-16(fp)
81109488:	0007883a 	mov	r3,zero
8110948c:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
81109490:	e0bffd17 	ldw	r2,-12(fp)
81109494:	10800104 	addi	r2,r2,4
81109498:	1007883a 	mov	r3,r2
8110949c:	00800044 	movi	r2,1
811094a0:	18800035 	stwio	r2,0(r3)
    if (bAck)
811094a4:	e0bfff17 	ldw	r2,-4(fp)
811094a8:	10000426 	beq	r2,zero,811094bc <i2c_read+0xf4>
        SDA_LOW(data_base);
811094ac:	e0bffd17 	ldw	r2,-12(fp)
811094b0:	0007883a 	mov	r3,zero
811094b4:	10c00035 	stwio	r3,0(r2)
811094b8:	00000306 	br	811094c8 <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
811094bc:	e0bffd17 	ldw	r2,-12(fp)
811094c0:	00c00044 	movi	r3,1
811094c4:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
811094c8:	e0bffc17 	ldw	r2,-16(fp)
811094cc:	00c00044 	movi	r3,1
811094d0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
811094d4:	01000044 	movi	r4,1
811094d8:	11307740 	call	81130774 <usleep>
    SCL_LOW(clk_base); // clock low
811094dc:	e0bffc17 	ldw	r2,-16(fp)
811094e0:	0007883a 	mov	r3,zero
811094e4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
811094e8:	01000044 	movi	r4,1
811094ec:	11307740 	call	81130774 <usleep>
    SDA_LOW(data_base);  // data low
811094f0:	e0bffd17 	ldw	r2,-12(fp)
811094f4:	0007883a 	mov	r3,zero
811094f8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
811094fc:	01000044 	movi	r4,1
81109500:	11307740 	call	81130774 <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
81109504:	e0bffe17 	ldw	r2,-8(fp)
81109508:	e0fffa03 	ldbu	r3,-24(fp)
8110950c:	10c00005 	stb	r3,0(r2)
}
81109510:	0001883a 	nop
81109514:	e037883a 	mov	sp,fp
81109518:	dfc00117 	ldw	ra,4(sp)
8110951c:	df000017 	ldw	fp,0(sp)
81109520:	dec00204 	addi	sp,sp,8
81109524:	f800283a 	ret

81109528 <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
81109528:	defffd04 	addi	sp,sp,-12
8110952c:	de00012e 	bgeu	sp,et,81109534 <bSetBoardLeds+0xc>
81109530:	003b68fa 	trap	3
81109534:	df000215 	stw	fp,8(sp)
81109538:	df000204 	addi	fp,sp,8
8110953c:	e13ffe15 	stw	r4,-8(fp)
81109540:	2805883a 	mov	r2,r5
81109544:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
81109548:	e0bffe17 	ldw	r2,-8(fp)
8110954c:	10800058 	cmpnei	r2,r2,1
81109550:	1000071e 	bne	r2,zero,81109570 <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
81109554:	e0bfff03 	ldbu	r2,-4(fp)
81109558:	0084303a 	nor	r2,zero,r2
8110955c:	1007883a 	mov	r3,r2
81109560:	d0a05003 	ldbu	r2,-32448(gp)
81109564:	1884703a 	and	r2,r3,r2
81109568:	d0a05005 	stb	r2,-32448(gp)
8110956c:	00000406 	br	81109580 <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
81109570:	d0e05003 	ldbu	r3,-32448(gp)
81109574:	e0bfff03 	ldbu	r2,-4(fp)
81109578:	1884b03a 	or	r2,r3,r2
8110957c:	d0a05005 	stb	r2,-32448(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
81109580:	d0a05003 	ldbu	r2,-32448(gp)
81109584:	10c03fcc 	andi	r3,r2,255
81109588:	00a00034 	movhi	r2,32768
8110958c:	10827404 	addi	r2,r2,2512
81109590:	10c00035 	stwio	r3,0(r2)

  return TRUE;
81109594:	00800044 	movi	r2,1
}
81109598:	e037883a 	mov	sp,fp
8110959c:	df000017 	ldw	fp,0(sp)
811095a0:	dec00104 	addi	sp,sp,4
811095a4:	f800283a 	ret

811095a8 <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
811095a8:	defffd04 	addi	sp,sp,-12
811095ac:	de00012e 	bgeu	sp,et,811095b4 <bSetPainelLeds+0xc>
811095b0:	003b68fa 	trap	3
811095b4:	df000215 	stw	fp,8(sp)
811095b8:	df000204 	addi	fp,sp,8
811095bc:	e13ffe15 	stw	r4,-8(fp)
811095c0:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
811095c4:	e0bffe17 	ldw	r2,-8(fp)
811095c8:	10800058 	cmpnei	r2,r2,1
811095cc:	1000051e 	bne	r2,zero,811095e4 <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
811095d0:	d0e00217 	ldw	r3,-32760(gp)
811095d4:	e0bfff17 	ldw	r2,-4(fp)
811095d8:	1884b03a 	or	r2,r3,r2
811095dc:	d0a00215 	stw	r2,-32760(gp)
811095e0:	00000506 	br	811095f8 <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
811095e4:	e0bfff17 	ldw	r2,-4(fp)
811095e8:	0086303a 	nor	r3,zero,r2
811095ec:	d0a00217 	ldw	r2,-32760(gp)
811095f0:	1884703a 	and	r2,r3,r2
811095f4:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
811095f8:	d0a00217 	ldw	r2,-32760(gp)
811095fc:	1007883a 	mov	r3,r2
81109600:	00a00034 	movhi	r2,32768
81109604:	10824004 	addi	r2,r2,2304
81109608:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110960c:	00800044 	movi	r2,1
}
81109610:	e037883a 	mov	sp,fp
81109614:	df000017 	ldw	fp,0(sp)
81109618:	dec00104 	addi	sp,sp,4
8110961c:	f800283a 	ret

81109620 <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
81109620:	defffc04 	addi	sp,sp,-16
81109624:	de00012e 	bgeu	sp,et,8110962c <msgdma_write_extended_descriptor+0xc>
81109628:	003b68fa 	trap	3
8110962c:	df000315 	stw	fp,12(sp)
81109630:	df000304 	addi	fp,sp,12
81109634:	e13ffd15 	stw	r4,-12(fp)
81109638:	e17ffe15 	stw	r5,-8(fp)
8110963c:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
81109640:	e0bffd17 	ldw	r2,-12(fp)
81109644:	10800037 	ldwio	r2,0(r2)
81109648:	1080010c 	andi	r2,r2,4
8110964c:	10000226 	beq	r2,zero,81109658 <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
81109650:	00bff904 	movi	r2,-28
81109654:	00003d06 	br	8110974c <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
81109658:	e0bfff17 	ldw	r2,-4(fp)
8110965c:	10800017 	ldw	r2,0(r2)
81109660:	1007883a 	mov	r3,r2
81109664:	e0bffe17 	ldw	r2,-8(fp)
81109668:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
8110966c:	e0bffe17 	ldw	r2,-8(fp)
81109670:	10800104 	addi	r2,r2,4
81109674:	e0ffff17 	ldw	r3,-4(fp)
81109678:	18c00117 	ldw	r3,4(r3)
8110967c:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
81109680:	e0bffe17 	ldw	r2,-8(fp)
81109684:	10800204 	addi	r2,r2,8
81109688:	e0ffff17 	ldw	r3,-4(fp)
8110968c:	18c00217 	ldw	r3,8(r3)
81109690:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
81109694:	e0bffe17 	ldw	r2,-8(fp)
81109698:	10800304 	addi	r2,r2,12
8110969c:	e0ffff17 	ldw	r3,-4(fp)
811096a0:	18c0030b 	ldhu	r3,12(r3)
811096a4:	18ffffcc 	andi	r3,r3,65535
811096a8:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
811096ac:	e0bffe17 	ldw	r2,-8(fp)
811096b0:	10800384 	addi	r2,r2,14
811096b4:	e0ffff17 	ldw	r3,-4(fp)
811096b8:	18c00383 	ldbu	r3,14(r3)
811096bc:	18c03fcc 	andi	r3,r3,255
811096c0:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
811096c4:	e0bffe17 	ldw	r2,-8(fp)
811096c8:	108003c4 	addi	r2,r2,15
811096cc:	e0ffff17 	ldw	r3,-4(fp)
811096d0:	18c003c3 	ldbu	r3,15(r3)
811096d4:	18c03fcc 	andi	r3,r3,255
811096d8:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
811096dc:	e0bffe17 	ldw	r2,-8(fp)
811096e0:	10800404 	addi	r2,r2,16
811096e4:	e0ffff17 	ldw	r3,-4(fp)
811096e8:	18c0040b 	ldhu	r3,16(r3)
811096ec:	18ffffcc 	andi	r3,r3,65535
811096f0:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
811096f4:	e0bffe17 	ldw	r2,-8(fp)
811096f8:	10800484 	addi	r2,r2,18
811096fc:	e0ffff17 	ldw	r3,-4(fp)
81109700:	18c0048b 	ldhu	r3,18(r3)
81109704:	18ffffcc 	andi	r3,r3,65535
81109708:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
8110970c:	e0bffe17 	ldw	r2,-8(fp)
81109710:	10800504 	addi	r2,r2,20
81109714:	e0ffff17 	ldw	r3,-4(fp)
81109718:	18c00517 	ldw	r3,20(r3)
8110971c:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
81109720:	e0bffe17 	ldw	r2,-8(fp)
81109724:	10800604 	addi	r2,r2,24
81109728:	e0ffff17 	ldw	r3,-4(fp)
8110972c:	18c00617 	ldw	r3,24(r3)
81109730:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
81109734:	e0bffe17 	ldw	r2,-8(fp)
81109738:	10800704 	addi	r2,r2,28
8110973c:	e0ffff17 	ldw	r3,-4(fp)
81109740:	18c00717 	ldw	r3,28(r3)
81109744:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
81109748:	0005883a 	mov	r2,zero
}
8110974c:	e037883a 	mov	sp,fp
81109750:	df000017 	ldw	fp,0(sp)
81109754:	dec00104 	addi	sp,sp,4
81109758:	f800283a 	ret

8110975c <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
8110975c:	defff604 	addi	sp,sp,-40
81109760:	de00012e 	bgeu	sp,et,81109768 <msgdma_construct_extended_descriptor+0xc>
81109764:	003b68fa 	trap	3
81109768:	df000915 	stw	fp,36(sp)
8110976c:	df000904 	addi	fp,sp,36
81109770:	e13ff715 	stw	r4,-36(fp)
81109774:	e17ff815 	stw	r5,-32(fp)
81109778:	e1bff915 	stw	r6,-28(fp)
8110977c:	e1fffa15 	stw	r7,-24(fp)
81109780:	e1800517 	ldw	r6,20(fp)
81109784:	e1400617 	ldw	r5,24(fp)
81109788:	e1000717 	ldw	r4,28(fp)
8110978c:	e0c00817 	ldw	r3,32(fp)
81109790:	e0800917 	ldw	r2,36(fp)
81109794:	e1bffb0d 	sth	r6,-20(fp)
81109798:	e17ffc05 	stb	r5,-16(fp)
8110979c:	e13ffd05 	stb	r4,-12(fp)
811097a0:	e0fffe0d 	sth	r3,-8(fp)
811097a4:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
811097a8:	e0bff717 	ldw	r2,-36(fp)
811097ac:	10c01217 	ldw	r3,72(r2)
811097b0:	e0800117 	ldw	r2,4(fp)
811097b4:	18801936 	bltu	r3,r2,8110981c <msgdma_construct_extended_descriptor+0xc0>
811097b8:	e13ff717 	ldw	r4,-36(fp)
811097bc:	20801317 	ldw	r2,76(r4)
811097c0:	20c01417 	ldw	r3,80(r4)
811097c4:	e13ffe0b 	ldhu	r4,-8(fp)
811097c8:	213fffcc 	andi	r4,r4,65535
811097cc:	2015883a 	mov	r10,r4
811097d0:	0017883a 	mov	r11,zero
811097d4:	1ac01136 	bltu	r3,r11,8110981c <msgdma_construct_extended_descriptor+0xc0>
811097d8:	58c0011e 	bne	r11,r3,811097e0 <msgdma_construct_extended_descriptor+0x84>
811097dc:	12800f36 	bltu	r2,r10,8110981c <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
811097e0:	e13ff717 	ldw	r4,-36(fp)
811097e4:	20801317 	ldw	r2,76(r4)
811097e8:	20c01417 	ldw	r3,80(r4)
811097ec:	e13fff0b 	ldhu	r4,-4(fp)
811097f0:	213fffcc 	andi	r4,r4,65535
811097f4:	2011883a 	mov	r8,r4
811097f8:	0013883a 	mov	r9,zero
811097fc:	1a400736 	bltu	r3,r9,8110981c <msgdma_construct_extended_descriptor+0xc0>
81109800:	48c0011e 	bne	r9,r3,81109808 <msgdma_construct_extended_descriptor+0xac>
81109804:	12000536 	bltu	r2,r8,8110981c <msgdma_construct_extended_descriptor+0xc0>
81109808:	e0bff717 	ldw	r2,-36(fp)
8110980c:	10801703 	ldbu	r2,92(r2)
81109810:	10803fcc 	andi	r2,r2,255
81109814:	10800060 	cmpeqi	r2,r2,1
81109818:	1000021e 	bne	r2,zero,81109824 <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
8110981c:	00bffa84 	movi	r2,-22
81109820:	00002306 	br	811098b0 <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
81109824:	e0bff817 	ldw	r2,-32(fp)
81109828:	e0fff917 	ldw	r3,-28(fp)
8110982c:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
81109830:	e0bff817 	ldw	r2,-32(fp)
81109834:	e0fffa17 	ldw	r3,-24(fp)
81109838:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
8110983c:	e0bff817 	ldw	r2,-32(fp)
81109840:	e0c00117 	ldw	r3,4(fp)
81109844:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
81109848:	e0bff817 	ldw	r2,-32(fp)
8110984c:	e0fffb0b 	ldhu	r3,-20(fp)
81109850:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
81109854:	e0bff817 	ldw	r2,-32(fp)
81109858:	e0fffc03 	ldbu	r3,-16(fp)
8110985c:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
81109860:	e0bff817 	ldw	r2,-32(fp)
81109864:	e0fffd03 	ldbu	r3,-12(fp)
81109868:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
8110986c:	e0bff817 	ldw	r2,-32(fp)
81109870:	e0fffe0b 	ldhu	r3,-8(fp)
81109874:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
81109878:	e0bff817 	ldw	r2,-32(fp)
8110987c:	e0ffff0b 	ldhu	r3,-4(fp)
81109880:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
81109884:	e0bff817 	ldw	r2,-32(fp)
81109888:	e0c00317 	ldw	r3,12(fp)
8110988c:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
81109890:	e0bff817 	ldw	r2,-32(fp)
81109894:	e0c00417 	ldw	r3,16(fp)
81109898:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8110989c:	e0800217 	ldw	r2,8(fp)
811098a0:	10e00034 	orhi	r3,r2,32768
811098a4:	e0bff817 	ldw	r2,-32(fp)
811098a8:	10c00715 	stw	r3,28(r2)

	return 0;
811098ac:	0005883a 	mov	r2,zero

}
811098b0:	e037883a 	mov	sp,fp
811098b4:	df000017 	ldw	fp,0(sp)
811098b8:	dec00104 	addi	sp,sp,4
811098bc:	f800283a 	ret

811098c0 <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
811098c0:	deffee04 	addi	sp,sp,-72
811098c4:	de00012e 	bgeu	sp,et,811098cc <msgdma_descriptor_async_transfer+0xc>
811098c8:	003b68fa 	trap	3
811098cc:	dfc01115 	stw	ra,68(sp)
811098d0:	df001015 	stw	fp,64(sp)
811098d4:	df001004 	addi	fp,sp,64
811098d8:	e13ffd15 	stw	r4,-12(fp)
811098dc:	e17ffe15 	stw	r5,-8(fp)
811098e0:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
811098e4:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
811098e8:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
811098ec:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
811098f0:	e0bffd17 	ldw	r2,-12(fp)
811098f4:	10800317 	ldw	r2,12(r2)
811098f8:	10800204 	addi	r2,r2,8
811098fc:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
81109900:	10bfffcc 	andi	r2,r2,65535
81109904:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
81109908:	e0bffd17 	ldw	r2,-12(fp)
8110990c:	10800317 	ldw	r2,12(r2)
81109910:	10800204 	addi	r2,r2,8
81109914:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
81109918:	1004d43a 	srli	r2,r2,16
8110991c:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
81109920:	e0bffd17 	ldw	r2,-12(fp)
81109924:	10800917 	ldw	r2,36(r2)
81109928:	e0fff417 	ldw	r3,-48(fp)
8110992c:	1880042e 	bgeu	r3,r2,81109940 <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
81109930:	e0bffd17 	ldw	r2,-12(fp)
81109934:	10800917 	ldw	r2,36(r2)
81109938:	e0fff317 	ldw	r3,-52(fp)
8110993c:	18800236 	bltu	r3,r2,81109948 <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
81109940:	00bff904 	movi	r2,-28
81109944:	00009106 	br	81109b8c <msgdma_descriptor_async_transfer+0x2cc>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
81109948:	e0bffd17 	ldw	r2,-12(fp)
8110994c:	10801817 	ldw	r2,96(r2)
81109950:	e0bff615 	stw	r2,-40(fp)
81109954:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81109958:	e0bffc0b 	ldhu	r2,-16(fp)
8110995c:	e0fffc84 	addi	r3,fp,-14
81109960:	180d883a 	mov	r6,r3
81109964:	100b883a 	mov	r5,r2
81109968:	e13ff617 	ldw	r4,-40(fp)
8110996c:	11375780 	call	81137578 <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81109970:	00800804 	movi	r2,32
81109974:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81109978:	0005303a 	rdctl	r2,status
8110997c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81109980:	e0fff717 	ldw	r3,-36(fp)
81109984:	00bfff84 	movi	r2,-2
81109988:	1884703a 	and	r2,r3,r2
8110998c:	1001703a 	wrctl	status,r2
  
  return context;
81109990:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81109994:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81109998:	e0bffd17 	ldw	r2,-12(fp)
8110999c:	10800317 	ldw	r2,12(r2)
811099a0:	10800104 	addi	r2,r2,4
811099a4:	e0fff117 	ldw	r3,-60(fp)
811099a8:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
811099ac:	e0bffd17 	ldw	r2,-12(fp)
811099b0:	10800317 	ldw	r2,12(r2)
811099b4:	e0fffd17 	ldw	r3,-12(fp)
811099b8:	18c00317 	ldw	r3,12(r3)
811099bc:	18c00037 	ldwio	r3,0(r3)
811099c0:	10c00035 	stwio	r3,0(r2)
811099c4:	e0bff217 	ldw	r2,-56(fp)
811099c8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811099cc:	e0bffb17 	ldw	r2,-20(fp)
811099d0:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
811099d4:	e0bffe17 	ldw	r2,-8(fp)
811099d8:	10000926 	beq	r2,zero,81109a00 <msgdma_descriptor_async_transfer+0x140>
811099dc:	e0bfff17 	ldw	r2,-4(fp)
811099e0:	1000071e 	bne	r2,zero,81109a00 <msgdma_descriptor_async_transfer+0x140>
		counter = 0; /* reset counter */
811099e4:	e03ff00d 	sth	zero,-64(fp)
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
811099e8:	e0bffd17 	ldw	r2,-12(fp)
811099ec:	10801817 	ldw	r2,96(r2)
811099f0:	1009883a 	mov	r4,r2
811099f4:	11379000 	call	81137900 <OSSemPost>

		return -ETIME;
811099f8:	00bff084 	movi	r2,-62
811099fc:	00006306 	br	81109b8c <msgdma_descriptor_async_transfer+0x2cc>
	} else if (NULL == standard_desc && NULL != extended_desc) {
81109a00:	e0bffe17 	ldw	r2,-8(fp)
81109a04:	10001c1e 	bne	r2,zero,81109a78 <msgdma_descriptor_async_transfer+0x1b8>
81109a08:	e0bfff17 	ldw	r2,-4(fp)
81109a0c:	10001a26 	beq	r2,zero,81109a78 <msgdma_descriptor_async_transfer+0x1b8>
		counter = 0; /* reset counter */
81109a10:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
81109a14:	00000e06 	br	81109a50 <msgdma_descriptor_async_transfer+0x190>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
81109a18:	01000044 	movi	r4,1
81109a1c:	112ef6c0 	call	8112ef6c <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
81109a20:	e0bff00b 	ldhu	r2,-64(fp)
81109a24:	1084e230 	cmpltui	r2,r2,5000
81109a28:	1000061e 	bne	r2,zero,81109a44 <msgdma_descriptor_async_transfer+0x184>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
81109a2c:	e0bffd17 	ldw	r2,-12(fp)
81109a30:	10801817 	ldw	r2,96(r2)
81109a34:	1009883a 	mov	r4,r2
81109a38:	11379000 	call	81137900 <OSSemPost>

				return -ETIME;
81109a3c:	00bff084 	movi	r2,-62
81109a40:	00005206 	br	81109b8c <msgdma_descriptor_async_transfer+0x2cc>
			}
			counter++;
81109a44:	e0bff00b 	ldhu	r2,-64(fp)
81109a48:	10800044 	addi	r2,r2,1
81109a4c:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
81109a50:	e0bffd17 	ldw	r2,-12(fp)
81109a54:	10c00317 	ldw	r3,12(r2)
81109a58:	e0bffd17 	ldw	r2,-12(fp)
81109a5c:	10800417 	ldw	r2,16(r2)
81109a60:	e1bfff17 	ldw	r6,-4(fp)
81109a64:	100b883a 	mov	r5,r2
81109a68:	1809883a 	mov	r4,r3
81109a6c:	11096200 	call	81109620 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
81109a70:	103fe91e 	bne	r2,zero,81109a18 <__reset+0xfb0e9a18>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
81109a74:	00000606 	br	81109a90 <msgdma_descriptor_async_transfer+0x1d0>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
81109a78:	e0bffd17 	ldw	r2,-12(fp)
81109a7c:	10801817 	ldw	r2,96(r2)
81109a80:	1009883a 	mov	r4,r2
81109a84:	11379000 	call	81137900 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
81109a88:	00bfffc4 	movi	r2,-1
81109a8c:	00003f06 	br	81109b8c <msgdma_descriptor_async_transfer+0x2cc>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
81109a90:	e0bffd17 	ldw	r2,-12(fp)
81109a94:	10800b17 	ldw	r2,44(r2)
81109a98:	10001c26 	beq	r2,zero,81109b0c <msgdma_descriptor_async_transfer+0x24c>

		control |= (dev->control |
81109a9c:	e0bffd17 	ldw	r2,-12(fp)
81109aa0:	10c00d17 	ldw	r3,52(r2)
81109aa4:	e0bff117 	ldw	r2,-60(fp)
81109aa8:	1884b03a 	or	r2,r3,r2
81109aac:	10800514 	ori	r2,r2,20
81109ab0:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81109ab4:	e0fff117 	ldw	r3,-60(fp)
81109ab8:	00bff7c4 	movi	r2,-33
81109abc:	1884703a 	and	r2,r3,r2
81109ac0:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81109ac4:	0005303a 	rdctl	r2,status
81109ac8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81109acc:	e0fff917 	ldw	r3,-28(fp)
81109ad0:	00bfff84 	movi	r2,-2
81109ad4:	1884703a 	and	r2,r3,r2
81109ad8:	1001703a 	wrctl	status,r2
  
  return context;
81109adc:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
81109ae0:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81109ae4:	e0bffd17 	ldw	r2,-12(fp)
81109ae8:	10800317 	ldw	r2,12(r2)
81109aec:	10800104 	addi	r2,r2,4
81109af0:	e0fff117 	ldw	r3,-60(fp)
81109af4:	10c00035 	stwio	r3,0(r2)
81109af8:	e0bff217 	ldw	r2,-56(fp)
81109afc:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81109b00:	e0bff517 	ldw	r2,-44(fp)
81109b04:	1001703a 	wrctl	status,r2
81109b08:	00001b06 	br	81109b78 <msgdma_descriptor_async_transfer+0x2b8>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
81109b0c:	e0bffd17 	ldw	r2,-12(fp)
81109b10:	10c00d17 	ldw	r3,52(r2)
81109b14:	e0bff117 	ldw	r2,-60(fp)
81109b18:	1884b03a 	or	r2,r3,r2
81109b1c:	10800114 	ori	r2,r2,4
81109b20:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
81109b24:	e0fff117 	ldw	r3,-60(fp)
81109b28:	00bff3c4 	movi	r2,-49
81109b2c:	1884703a 	and	r2,r3,r2
81109b30:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81109b34:	0005303a 	rdctl	r2,status
81109b38:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81109b3c:	e0fffa17 	ldw	r3,-24(fp)
81109b40:	00bfff84 	movi	r2,-2
81109b44:	1884703a 	and	r2,r3,r2
81109b48:	1001703a 	wrctl	status,r2
  
  return context;
81109b4c:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
81109b50:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81109b54:	e0bffd17 	ldw	r2,-12(fp)
81109b58:	10800317 	ldw	r2,12(r2)
81109b5c:	10800104 	addi	r2,r2,4
81109b60:	e0fff117 	ldw	r3,-60(fp)
81109b64:	10c00035 	stwio	r3,0(r2)
81109b68:	e0bff217 	ldw	r2,-56(fp)
81109b6c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81109b70:	e0bff817 	ldw	r2,-32(fp)
81109b74:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
81109b78:	e0bffd17 	ldw	r2,-12(fp)
81109b7c:	10801817 	ldw	r2,96(r2)
81109b80:	1009883a 	mov	r4,r2
81109b84:	11379000 	call	81137900 <OSSemPost>

	return 0;
81109b88:	0005883a 	mov	r2,zero
}
81109b8c:	e037883a 	mov	sp,fp
81109b90:	dfc00117 	ldw	ra,4(sp)
81109b94:	df000017 	ldw	fp,0(sp)
81109b98:	dec00204 	addi	sp,sp,8
81109b9c:	f800283a 	ret

81109ba0 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
81109ba0:	deffee04 	addi	sp,sp,-72
81109ba4:	de00012e 	bgeu	sp,et,81109bac <msgdma_descriptor_sync_transfer+0xc>
81109ba8:	003b68fa 	trap	3
81109bac:	dfc01115 	stw	ra,68(sp)
81109bb0:	df001015 	stw	fp,64(sp)
81109bb4:	df001004 	addi	fp,sp,64
81109bb8:	e13ffd15 	stw	r4,-12(fp)
81109bbc:	e17ffe15 	stw	r5,-8(fp)
81109bc0:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
81109bc4:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
81109bc8:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
81109bcc:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
81109bd0:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
81109bd4:	e0bffd17 	ldw	r2,-12(fp)
81109bd8:	10800317 	ldw	r2,12(r2)
81109bdc:	10800204 	addi	r2,r2,8
81109be0:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
81109be4:	10bfffcc 	andi	r2,r2,65535
81109be8:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
81109bec:	e0bffd17 	ldw	r2,-12(fp)
81109bf0:	10800317 	ldw	r2,12(r2)
81109bf4:	10800204 	addi	r2,r2,8
81109bf8:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
81109bfc:	1004d43a 	srli	r2,r2,16
81109c00:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
81109c04:	00807804 	movi	r2,480
81109c08:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
81109c0c:	00001606 	br	81109c68 <msgdma_descriptor_sync_transfer+0xc8>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
81109c10:	01000044 	movi	r4,1
81109c14:	112ef6c0 	call	8112ef6c <alt_busy_sleep>
#if DEBUG_ON
	fprintf(fp,"\n-- DMA can't write in the descriptor \n ");
#endif
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
81109c18:	e0bff10b 	ldhu	r2,-60(fp)
81109c1c:	1084e230 	cmpltui	r2,r2,5000
81109c20:	1000021e 	bne	r2,zero,81109c2c <msgdma_descriptor_sync_transfer+0x8c>
		{
#if DEBUG_ON
			debug(fp,
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
81109c24:	00bff084 	movi	r2,-62
81109c28:	0000bb06 	br	81109f18 <msgdma_descriptor_sync_transfer+0x378>
		}
		counter++;
81109c2c:	e0bff10b 	ldhu	r2,-60(fp)
81109c30:	10800044 	addi	r2,r2,1
81109c34:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
81109c38:	e0bffd17 	ldw	r2,-12(fp)
81109c3c:	10800317 	ldw	r2,12(r2)
81109c40:	10800204 	addi	r2,r2,8
81109c44:	10800037 	ldwio	r2,0(r2)
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
81109c48:	10bfffcc 	andi	r2,r2,65535
81109c4c:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
81109c50:	e0bffd17 	ldw	r2,-12(fp)
81109c54:	10800317 	ldw	r2,12(r2)
81109c58:	10800204 	addi	r2,r2,8
81109c5c:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
81109c60:	1004d43a 	srli	r2,r2,16
81109c64:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
81109c68:	e0bffd17 	ldw	r2,-12(fp)
81109c6c:	10800917 	ldw	r2,36(r2)
81109c70:	e0fff317 	ldw	r3,-52(fp)
81109c74:	18bfe62e 	bgeu	r3,r2,81109c10 <__reset+0xfb0e9c10>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
81109c78:	e0bffd17 	ldw	r2,-12(fp)
81109c7c:	10800917 	ldw	r2,36(r2)
81109c80:	e0fff217 	ldw	r3,-56(fp)
81109c84:	18bfe22e 	bgeu	r3,r2,81109c10 <__reset+0xfb0e9c10>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
81109c88:	e0bffd17 	ldw	r2,-12(fp)
81109c8c:	10801817 	ldw	r2,96(r2)
81109c90:	e0bff815 	stw	r2,-32(fp)
81109c94:	e03ffc0d 	sth	zero,-16(fp)
81109c98:	e0bffc0b 	ldhu	r2,-16(fp)
81109c9c:	e0fffc84 	addi	r3,fp,-14
81109ca0:	180d883a 	mov	r6,r3
81109ca4:	100b883a 	mov	r5,r2
81109ca8:	e13ff817 	ldw	r4,-32(fp)
81109cac:	11375780 	call	81137578 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81109cb0:	0005303a 	rdctl	r2,status
81109cb4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81109cb8:	e0fffb17 	ldw	r3,-20(fp)
81109cbc:	00bfff84 	movi	r2,-2
81109cc0:	1884703a 	and	r2,r3,r2
81109cc4:	1001703a 	wrctl	status,r2
  
  return context;
81109cc8:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81109ccc:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81109cd0:	e0bffd17 	ldw	r2,-12(fp)
81109cd4:	10800317 	ldw	r2,12(r2)
81109cd8:	10800104 	addi	r2,r2,4
81109cdc:	00c00804 	movi	r3,32
81109ce0:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
81109ce4:	e0bffd17 	ldw	r2,-12(fp)
81109ce8:	10800317 	ldw	r2,12(r2)
81109cec:	e0fffd17 	ldw	r3,-12(fp)
81109cf0:	18c00317 	ldw	r3,12(r3)
81109cf4:	18c00037 	ldwio	r3,0(r3)
81109cf8:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
81109cfc:	e0bffe17 	ldw	r2,-8(fp)
81109d00:	10000926 	beq	r2,zero,81109d28 <msgdma_descriptor_sync_transfer+0x188>
81109d04:	e0bfff17 	ldw	r2,-4(fp)
81109d08:	1000071e 	bne	r2,zero,81109d28 <msgdma_descriptor_sync_transfer+0x188>
		counter = 0; /* reset counter */
81109d0c:	e03ff10d 	sth	zero,-60(fp)
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
81109d10:	e0bffd17 	ldw	r2,-12(fp)
81109d14:	10801817 	ldw	r2,96(r2)
81109d18:	1009883a 	mov	r4,r2
81109d1c:	11379000 	call	81137900 <OSSemPost>

		return -ETIME;
81109d20:	00bff084 	movi	r2,-62
81109d24:	00007c06 	br	81109f18 <msgdma_descriptor_sync_transfer+0x378>
	} else if (NULL == standard_desc && NULL != extended_desc) {
81109d28:	e0bffe17 	ldw	r2,-8(fp)
81109d2c:	10001c1e 	bne	r2,zero,81109da0 <msgdma_descriptor_sync_transfer+0x200>
81109d30:	e0bfff17 	ldw	r2,-4(fp)
81109d34:	10001a26 	beq	r2,zero,81109da0 <msgdma_descriptor_sync_transfer+0x200>
		counter = 0; /* reset counter */
81109d38:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
81109d3c:	00000e06 	br	81109d78 <msgdma_descriptor_sync_transfer+0x1d8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
81109d40:	01000044 	movi	r4,1
81109d44:	112ef6c0 	call	8112ef6c <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
81109d48:	e0bff10b 	ldhu	r2,-60(fp)
81109d4c:	1084e230 	cmpltui	r2,r2,5000
81109d50:	1000061e 	bne	r2,zero,81109d6c <msgdma_descriptor_sync_transfer+0x1cc>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
81109d54:	e0bffd17 	ldw	r2,-12(fp)
81109d58:	10801817 	ldw	r2,96(r2)
81109d5c:	1009883a 	mov	r4,r2
81109d60:	11379000 	call	81137900 <OSSemPost>

				return -ETIME;
81109d64:	00bff084 	movi	r2,-62
81109d68:	00006b06 	br	81109f18 <msgdma_descriptor_sync_transfer+0x378>
			}
			counter++;
81109d6c:	e0bff10b 	ldhu	r2,-60(fp)
81109d70:	10800044 	addi	r2,r2,1
81109d74:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
81109d78:	e0bffd17 	ldw	r2,-12(fp)
81109d7c:	10c00317 	ldw	r3,12(r2)
81109d80:	e0bffd17 	ldw	r2,-12(fp)
81109d84:	10800417 	ldw	r2,16(r2)
81109d88:	e1bfff17 	ldw	r6,-4(fp)
81109d8c:	100b883a 	mov	r5,r2
81109d90:	1809883a 	mov	r4,r3
81109d94:	11096200 	call	81109620 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
81109d98:	103fe91e 	bne	r2,zero,81109d40 <__reset+0xfb0e9d40>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
81109d9c:	00000606 	br	81109db8 <msgdma_descriptor_sync_transfer+0x218>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
81109da0:	e0bffd17 	ldw	r2,-12(fp)
81109da4:	10801817 	ldw	r2,96(r2)
81109da8:	1009883a 	mov	r4,r2
81109dac:	11379000 	call	81137900 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
81109db0:	00bfffc4 	movi	r2,-1
81109db4:	00005806 	br	81109f18 <msgdma_descriptor_sync_transfer+0x378>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81109db8:	e0bffd17 	ldw	r2,-12(fp)
81109dbc:	10800317 	ldw	r2,12(r2)
81109dc0:	10800104 	addi	r2,r2,4
81109dc4:	e0fffd17 	ldw	r3,-12(fp)
81109dc8:	19000d17 	ldw	r4,52(r3)
81109dcc:	00fff2c4 	movi	r3,-53
81109dd0:	20c6703a 	and	r3,r4,r3
81109dd4:	18c00114 	ori	r3,r3,4
81109dd8:	10c00035 	stwio	r3,0(r2)
81109ddc:	e0bff517 	ldw	r2,-44(fp)
81109de0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81109de4:	e0bff717 	ldw	r2,-36(fp)
81109de8:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
81109dec:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81109df0:	e0bffd17 	ldw	r2,-12(fp)
81109df4:	10800317 	ldw	r2,12(r2)
81109df8:	10800037 	ldwio	r2,0(r2)
81109dfc:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
81109e00:	00001206 	br	81109e4c <msgdma_descriptor_sync_transfer+0x2ac>
		alt_busy_sleep(1); /* delay 1us */
81109e04:	01000044 	movi	r4,1
81109e08:	112ef6c0 	call	8112ef6c <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
81109e0c:	e0bff10b 	ldhu	r2,-60(fp)
81109e10:	1084e230 	cmpltui	r2,r2,5000
81109e14:	1000061e 	bne	r2,zero,81109e30 <msgdma_descriptor_sync_transfer+0x290>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
81109e18:	e0bffd17 	ldw	r2,-12(fp)
81109e1c:	10801817 	ldw	r2,96(r2)
81109e20:	1009883a 	mov	r4,r2
81109e24:	11379000 	call	81137900 <OSSemPost>

			return -ETIME;
81109e28:	00bff084 	movi	r2,-62
81109e2c:	00003a06 	br	81109f18 <msgdma_descriptor_sync_transfer+0x378>
		}
		counter++;
81109e30:	e0bff10b 	ldhu	r2,-60(fp)
81109e34:	10800044 	addi	r2,r2,1
81109e38:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81109e3c:	e0bffd17 	ldw	r2,-12(fp)
81109e40:	10800317 	ldw	r2,12(r2)
81109e44:	10800037 	ldwio	r2,0(r2)
81109e48:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
81109e4c:	e0fff017 	ldw	r3,-64(fp)
81109e50:	e0bff617 	ldw	r2,-40(fp)
81109e54:	1884703a 	and	r2,r3,r2
81109e58:	1000031e 	bne	r2,zero,81109e68 <msgdma_descriptor_sync_transfer+0x2c8>
81109e5c:	e0bff017 	ldw	r2,-64(fp)
81109e60:	1080004c 	andi	r2,r2,1
81109e64:	103fe71e 	bne	r2,zero,81109e04 <__reset+0xfb0e9e04>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
81109e68:	e0fff017 	ldw	r3,-64(fp)
81109e6c:	e0bff617 	ldw	r2,-40(fp)
81109e70:	1884703a 	and	r2,r3,r2
81109e74:	10000626 	beq	r2,zero,81109e90 <msgdma_descriptor_sync_transfer+0x2f0>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
81109e78:	e0bffd17 	ldw	r2,-12(fp)
81109e7c:	10801817 	ldw	r2,96(r2)
81109e80:	1009883a 	mov	r4,r2
81109e84:	11379000 	call	81137900 <OSSemPost>

		return error;
81109e88:	e0bff617 	ldw	r2,-40(fp)
81109e8c:	00002206 	br	81109f18 <msgdma_descriptor_sync_transfer+0x378>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
81109e90:	e0bffd17 	ldw	r2,-12(fp)
81109e94:	10800317 	ldw	r2,12(r2)
81109e98:	10800104 	addi	r2,r2,4
81109e9c:	10800037 	ldwio	r2,0(r2)
81109ea0:	10800814 	ori	r2,r2,32
81109ea4:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81109ea8:	0005303a 	rdctl	r2,status
81109eac:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81109eb0:	e0fffa17 	ldw	r3,-24(fp)
81109eb4:	00bfff84 	movi	r2,-2
81109eb8:	1884703a 	and	r2,r3,r2
81109ebc:	1001703a 	wrctl	status,r2
  
  return context;
81109ec0:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81109ec4:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81109ec8:	e0bffd17 	ldw	r2,-12(fp)
81109ecc:	10800317 	ldw	r2,12(r2)
81109ed0:	10800104 	addi	r2,r2,4
81109ed4:	e0fff417 	ldw	r3,-48(fp)
81109ed8:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
81109edc:	e0bffd17 	ldw	r2,-12(fp)
81109ee0:	10800317 	ldw	r2,12(r2)
81109ee4:	e0fffd17 	ldw	r3,-12(fp)
81109ee8:	18c00317 	ldw	r3,12(r3)
81109eec:	18c00037 	ldwio	r3,0(r3)
81109ef0:	10c00035 	stwio	r3,0(r2)
81109ef4:	e0bff517 	ldw	r2,-44(fp)
81109ef8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81109efc:	e0bff917 	ldw	r2,-28(fp)
81109f00:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
81109f04:	e0bffd17 	ldw	r2,-12(fp)
81109f08:	10801817 	ldw	r2,96(r2)
81109f0c:	1009883a 	mov	r4,r2
81109f10:	11379000 	call	81137900 <OSSemPost>

	return 0;
81109f14:	0005883a 	mov	r2,zero

}
81109f18:	e037883a 	mov	sp,fp
81109f1c:	dfc00117 	ldw	ra,4(sp)
81109f20:	df000017 	ldw	fp,0(sp)
81109f24:	dec00204 	addi	sp,sp,8
81109f28:	f800283a 	ret

81109f2c <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
81109f2c:	deffec04 	addi	sp,sp,-80
81109f30:	de00012e 	bgeu	sp,et,81109f38 <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
81109f34:	003b68fa 	trap	3
81109f38:	dfc01315 	stw	ra,76(sp)
81109f3c:	df001215 	stw	fp,72(sp)
81109f40:	df001204 	addi	fp,sp,72
81109f44:	e13ff715 	stw	r4,-36(fp)
81109f48:	e17ff815 	stw	r5,-32(fp)
81109f4c:	e1bff915 	stw	r6,-28(fp)
81109f50:	e1fffa15 	stw	r7,-24(fp)
81109f54:	e1800617 	ldw	r6,24(fp)
81109f58:	e1400717 	ldw	r5,28(fp)
81109f5c:	e1000817 	ldw	r4,32(fp)
81109f60:	e0c00917 	ldw	r3,36(fp)
81109f64:	e0800a17 	ldw	r2,40(fp)
81109f68:	e1bffb0d 	sth	r6,-20(fp)
81109f6c:	e17ffc05 	stb	r5,-16(fp)
81109f70:	e13ffd05 	stb	r4,-12(fp)
81109f74:	e0fffe0d 	sth	r3,-8(fp)
81109f78:	e0bfff0d 	sth	r2,-4(fp)

	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
81109f7c:	e0bffb0b 	ldhu	r2,-20(fp)
81109f80:	e0fffc03 	ldbu	r3,-16(fp)
81109f84:	e13ffd03 	ldbu	r4,-12(fp)
81109f88:	e17ffe0b 	ldhu	r5,-8(fp)
81109f8c:	e1bfff0b 	ldhu	r6,-4(fp)
81109f90:	d9800815 	stw	r6,32(sp)
81109f94:	d9400715 	stw	r5,28(sp)
81109f98:	d9000615 	stw	r4,24(sp)
81109f9c:	d8c00515 	stw	r3,20(sp)
81109fa0:	d8800415 	stw	r2,16(sp)
81109fa4:	e0800517 	ldw	r2,20(fp)
81109fa8:	d8800315 	stw	r2,12(sp)
81109fac:	e0800417 	ldw	r2,16(fp)
81109fb0:	d8800215 	stw	r2,8(sp)
81109fb4:	e0800317 	ldw	r2,12(fp)
81109fb8:	d8800115 	stw	r2,4(sp)
81109fbc:	e0800217 	ldw	r2,8(fp)
81109fc0:	d8800015 	stw	r2,0(sp)
81109fc4:	e1fffa17 	ldw	r7,-24(fp)
81109fc8:	e1bff917 	ldw	r6,-28(fp)
81109fcc:	e17ff817 	ldw	r5,-32(fp)
81109fd0:	e13ff717 	ldw	r4,-36(fp)
81109fd4:	110975c0 	call	8110975c <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
81109fd8:	e037883a 	mov	sp,fp
81109fdc:	dfc00117 	ldw	ra,4(sp)
81109fe0:	df000017 	ldw	fp,0(sp)
81109fe4:	dec00204 	addi	sp,sp,8
81109fe8:	f800283a 	ret

81109fec <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
81109fec:	defffc04 	addi	sp,sp,-16
81109ff0:	de00012e 	bgeu	sp,et,81109ff8 <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
81109ff4:	003b68fa 	trap	3
81109ff8:	dfc00315 	stw	ra,12(sp)
81109ffc:	df000215 	stw	fp,8(sp)
8110a000:	df000204 	addi	fp,sp,8
8110a004:	e13ffe15 	stw	r4,-8(fp)
8110a008:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
8110a00c:	e1bfff17 	ldw	r6,-4(fp)
8110a010:	000b883a 	mov	r5,zero
8110a014:	e13ffe17 	ldw	r4,-8(fp)
8110a018:	11098c00 	call	811098c0 <msgdma_descriptor_async_transfer>
}
8110a01c:	e037883a 	mov	sp,fp
8110a020:	dfc00117 	ldw	ra,4(sp)
8110a024:	df000017 	ldw	fp,0(sp)
8110a028:	dec00204 	addi	sp,sp,8
8110a02c:	f800283a 	ret

8110a030 <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110a030:	defffc04 	addi	sp,sp,-16
8110a034:	de00012e 	bgeu	sp,et,8110a03c <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
8110a038:	003b68fa 	trap	3
8110a03c:	dfc00315 	stw	ra,12(sp)
8110a040:	df000215 	stw	fp,8(sp)
8110a044:	df000204 	addi	fp,sp,8
8110a048:	e13ffe15 	stw	r4,-8(fp)
8110a04c:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
8110a050:	e1bfff17 	ldw	r6,-4(fp)
8110a054:	000b883a 	mov	r5,zero
8110a058:	e13ffe17 	ldw	r4,-8(fp)
8110a05c:	1109ba00 	call	81109ba0 <msgdma_descriptor_sync_transfer>
}
8110a060:	e037883a 	mov	sp,fp
8110a064:	dfc00117 	ldw	ra,4(sp)
8110a068:	df000017 	ldw	fp,0(sp)
8110a06c:	dec00204 	addi	sp,sp,8
8110a070:	f800283a 	ret

8110a074 <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
8110a074:	defff204 	addi	sp,sp,-56
8110a078:	de00012e 	bgeu	sp,et,8110a080 <POWER_SPI_RW+0xc>
8110a07c:	003b68fa 	trap	3
8110a080:	dfc00d15 	stw	ra,52(sp)
8110a084:	df000c15 	stw	fp,48(sp)
8110a088:	df000c04 	addi	fp,sp,48
8110a08c:	2007883a 	mov	r3,r4
8110a090:	2805883a 	mov	r2,r5
8110a094:	e1bffe15 	stw	r6,-8(fp)
8110a098:	e1ffff15 	stw	r7,-4(fp)
8110a09c:	e0fffc05 	stb	r3,-16(fp)
8110a0a0:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
8110a0a4:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
8110a0a8:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
8110a0ac:	008003f4 	movhi	r2,15
8110a0b0:	10909004 	addi	r2,r2,16960
8110a0b4:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
8110a0b8:	00bfe004 	movi	r2,-128
8110a0bc:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
8110a0c0:	e0bffe17 	ldw	r2,-8(fp)
8110a0c4:	10000226 	beq	r2,zero,8110a0d0 <POWER_SPI_RW+0x5c>
8110a0c8:	00800804 	movi	r2,32
8110a0cc:	00000106 	br	8110a0d4 <POWER_SPI_RW+0x60>
8110a0d0:	0005883a 	mov	r2,zero
8110a0d4:	e0fff403 	ldbu	r3,-48(fp)
8110a0d8:	10c4b03a 	or	r2,r2,r3
8110a0dc:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
8110a0e0:	e0800217 	ldw	r2,8(fp)
8110a0e4:	10000226 	beq	r2,zero,8110a0f0 <POWER_SPI_RW+0x7c>
8110a0e8:	00800404 	movi	r2,16
8110a0ec:	00000106 	br	8110a0f4 <POWER_SPI_RW+0x80>
8110a0f0:	0005883a 	mov	r2,zero
8110a0f4:	e0fff403 	ldbu	r3,-48(fp)
8110a0f8:	10c4b03a 	or	r2,r2,r3
8110a0fc:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
8110a100:	e0bfff17 	ldw	r2,-4(fp)
8110a104:	10000226 	beq	r2,zero,8110a110 <POWER_SPI_RW+0x9c>
8110a108:	00800204 	movi	r2,8
8110a10c:	00000106 	br	8110a114 <POWER_SPI_RW+0xa0>
8110a110:	0005883a 	mov	r2,zero
8110a114:	e0fff403 	ldbu	r3,-48(fp)
8110a118:	10c4b03a 	or	r2,r2,r3
8110a11c:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
8110a120:	e0bffd03 	ldbu	r2,-12(fp)
8110a124:	108001cc 	andi	r2,r2,7
8110a128:	1007883a 	mov	r3,r2
8110a12c:	e0bff403 	ldbu	r2,-48(fp)
8110a130:	1884b03a 	or	r2,r3,r2
8110a134:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
8110a138:	0007883a 	mov	r3,zero
8110a13c:	00a00034 	movhi	r2,32768
8110a140:	10824404 	addi	r2,r2,2320
8110a144:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
8110a148:	0007883a 	mov	r3,zero
8110a14c:	00a00034 	movhi	r2,32768
8110a150:	10824c04 	addi	r2,r2,2352
8110a154:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
8110a158:	e0bffc03 	ldbu	r2,-16(fp)
8110a15c:	1000021e 	bne	r2,zero,8110a168 <POWER_SPI_RW+0xf4>
8110a160:	00c00084 	movi	r3,2
8110a164:	00000106 	br	8110a16c <POWER_SPI_RW+0xf8>
8110a168:	00c00044 	movi	r3,1
8110a16c:	00a00034 	movhi	r2,32768
8110a170:	10824804 	addi	r2,r2,2336
8110a174:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110a178:	010003c4 	movi	r4,15
8110a17c:	11307740 	call	81130774 <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110a180:	00000306 	br	8110a190 <POWER_SPI_RW+0x11c>
		nWait++;
8110a184:	e0bff817 	ldw	r2,-32(fp)
8110a188:	10800044 	addi	r2,r2,1
8110a18c:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110a190:	00a00034 	movhi	r2,32768
8110a194:	10825404 	addi	r2,r2,2384
8110a198:	10800037 	ldwio	r2,0(r2)
8110a19c:	1080004c 	andi	r2,r2,1
8110a1a0:	10000326 	beq	r2,zero,8110a1b0 <POWER_SPI_RW+0x13c>
8110a1a4:	e0fff817 	ldw	r3,-32(fp)
8110a1a8:	e0bffa17 	ldw	r2,-24(fp)
8110a1ac:	18bff516 	blt	r3,r2,8110a184 <__reset+0xfb0ea184>
		nWait++;
	}

	if (SPI_SDO) {
8110a1b0:	00a00034 	movhi	r2,32768
8110a1b4:	10825404 	addi	r2,r2,2384
8110a1b8:	10800037 	ldwio	r2,0(r2)
8110a1bc:	1080004c 	andi	r2,r2,1
8110a1c0:	10000626 	beq	r2,zero,8110a1dc <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110a1c4:	00c000c4 	movi	r3,3
8110a1c8:	00a00034 	movhi	r2,32768
8110a1cc:	10824804 	addi	r2,r2,2336
8110a1d0:	10c00035 	stwio	r3,0(r2)
#if DEBUG_ON
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
8110a1d4:	0005883a 	mov	r2,zero
8110a1d8:	0000db06 	br	8110a548 <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110a1dc:	e03ff715 	stw	zero,-36(fp)
8110a1e0:	00002406 	br	8110a274 <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
8110a1e4:	e0bff403 	ldbu	r2,-48(fp)
8110a1e8:	10803fcc 	andi	r2,r2,255
8110a1ec:	1004d1fa 	srli	r2,r2,7
8110a1f0:	10c03fcc 	andi	r3,r2,255
8110a1f4:	00a00034 	movhi	r2,32768
8110a1f8:	10825004 	addi	r2,r2,2368
8110a1fc:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110a200:	e0bff403 	ldbu	r2,-48(fp)
8110a204:	1085883a 	add	r2,r2,r2
8110a208:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110a20c:	e0bff517 	ldw	r2,-44(fp)
8110a210:	1085883a 	add	r2,r2,r2
8110a214:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110a218:	00a00034 	movhi	r2,32768
8110a21c:	10825404 	addi	r2,r2,2384
8110a220:	10800037 	ldwio	r2,0(r2)
8110a224:	1080004c 	andi	r2,r2,1
8110a228:	1007883a 	mov	r3,r2
8110a22c:	e0bff517 	ldw	r2,-44(fp)
8110a230:	10c4b03a 	or	r2,r2,r3
8110a234:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110a238:	00c00044 	movi	r3,1
8110a23c:	00a00034 	movhi	r2,32768
8110a240:	10824c04 	addi	r2,r2,2352
8110a244:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110a248:	010003c4 	movi	r4,15
8110a24c:	11307740 	call	81130774 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110a250:	0007883a 	mov	r3,zero
8110a254:	00a00034 	movhi	r2,32768
8110a258:	10824c04 	addi	r2,r2,2352
8110a25c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110a260:	010003c4 	movi	r4,15
8110a264:	11307740 	call	81130774 <usleep>
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110a268:	e0bff717 	ldw	r2,-36(fp)
8110a26c:	10800044 	addi	r2,r2,1
8110a270:	e0bff715 	stw	r2,-36(fp)
8110a274:	e0bff717 	ldw	r2,-36(fp)
8110a278:	10800090 	cmplti	r2,r2,2
8110a27c:	103fd91e 	bne	r2,zero,8110a1e4 <__reset+0xfb0ea1e4>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110a280:	e03ff715 	stw	zero,-36(fp)
8110a284:	00002406 	br	8110a318 <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
8110a288:	e0bff403 	ldbu	r2,-48(fp)
8110a28c:	10803fcc 	andi	r2,r2,255
8110a290:	1004d1fa 	srli	r2,r2,7
8110a294:	10c03fcc 	andi	r3,r2,255
8110a298:	00a00034 	movhi	r2,32768
8110a29c:	10825004 	addi	r2,r2,2368
8110a2a0:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110a2a4:	e0bff403 	ldbu	r2,-48(fp)
8110a2a8:	1085883a 	add	r2,r2,r2
8110a2ac:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
8110a2b0:	e0bff517 	ldw	r2,-44(fp)
8110a2b4:	1085883a 	add	r2,r2,r2
8110a2b8:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
8110a2bc:	00a00034 	movhi	r2,32768
8110a2c0:	10825404 	addi	r2,r2,2384
8110a2c4:	10800037 	ldwio	r2,0(r2)
8110a2c8:	1080004c 	andi	r2,r2,1
8110a2cc:	1007883a 	mov	r3,r2
8110a2d0:	e0bff517 	ldw	r2,-44(fp)
8110a2d4:	10c4b03a 	or	r2,r2,r3
8110a2d8:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110a2dc:	00c00044 	movi	r3,1
8110a2e0:	00a00034 	movhi	r2,32768
8110a2e4:	10824c04 	addi	r2,r2,2352
8110a2e8:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110a2ec:	010003c4 	movi	r4,15
8110a2f0:	11307740 	call	81130774 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110a2f4:	0007883a 	mov	r3,zero
8110a2f8:	00a00034 	movhi	r2,32768
8110a2fc:	10824c04 	addi	r2,r2,2352
8110a300:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110a304:	010003c4 	movi	r4,15
8110a308:	11307740 	call	81130774 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110a30c:	e0bff717 	ldw	r2,-36(fp)
8110a310:	10800044 	addi	r2,r2,1
8110a314:	e0bff715 	stw	r2,-36(fp)
8110a318:	e0bff717 	ldw	r2,-36(fp)
8110a31c:	10800210 	cmplti	r2,r2,8
8110a320:	103fd91e 	bne	r2,zero,8110a288 <__reset+0xfb0ea288>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110a324:	e03ff715 	stw	zero,-36(fp)
8110a328:	00001a06 	br	8110a394 <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
8110a32c:	e0bff517 	ldw	r2,-44(fp)
8110a330:	1085883a 	add	r2,r2,r2
8110a334:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
8110a338:	00a00034 	movhi	r2,32768
8110a33c:	10825404 	addi	r2,r2,2384
8110a340:	10800037 	ldwio	r2,0(r2)
8110a344:	1080004c 	andi	r2,r2,1
8110a348:	1007883a 	mov	r3,r2
8110a34c:	e0bff517 	ldw	r2,-44(fp)
8110a350:	10c4b03a 	or	r2,r2,r3
8110a354:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110a358:	00c00044 	movi	r3,1
8110a35c:	00a00034 	movhi	r2,32768
8110a360:	10824c04 	addi	r2,r2,2352
8110a364:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110a368:	010003c4 	movi	r4,15
8110a36c:	11307740 	call	81130774 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110a370:	0007883a 	mov	r3,zero
8110a374:	00a00034 	movhi	r2,32768
8110a378:	10824c04 	addi	r2,r2,2352
8110a37c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110a380:	010003c4 	movi	r4,15
8110a384:	11307740 	call	81130774 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110a388:	e0bff717 	ldw	r2,-36(fp)
8110a38c:	10800044 	addi	r2,r2,1
8110a390:	e0bff715 	stw	r2,-36(fp)
8110a394:	e0bff717 	ldw	r2,-36(fp)
8110a398:	10800210 	cmplti	r2,r2,8
8110a39c:	103fe31e 	bne	r2,zero,8110a32c <__reset+0xfb0ea32c>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110a3a0:	e03ff715 	stw	zero,-36(fp)
8110a3a4:	00001a06 	br	8110a410 <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8110a3a8:	e0bff517 	ldw	r2,-44(fp)
8110a3ac:	1085883a 	add	r2,r2,r2
8110a3b0:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
8110a3b4:	00a00034 	movhi	r2,32768
8110a3b8:	10825404 	addi	r2,r2,2384
8110a3bc:	10800037 	ldwio	r2,0(r2)
8110a3c0:	1080004c 	andi	r2,r2,1
8110a3c4:	1007883a 	mov	r3,r2
8110a3c8:	e0bff517 	ldw	r2,-44(fp)
8110a3cc:	10c4b03a 	or	r2,r2,r3
8110a3d0:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110a3d4:	00c00044 	movi	r3,1
8110a3d8:	00a00034 	movhi	r2,32768
8110a3dc:	10824c04 	addi	r2,r2,2352
8110a3e0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110a3e4:	010003c4 	movi	r4,15
8110a3e8:	11307740 	call	81130774 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110a3ec:	0007883a 	mov	r3,zero
8110a3f0:	00a00034 	movhi	r2,32768
8110a3f4:	10824c04 	addi	r2,r2,2352
8110a3f8:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110a3fc:	010003c4 	movi	r4,15
8110a400:	11307740 	call	81130774 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110a404:	e0bff717 	ldw	r2,-36(fp)
8110a408:	10800044 	addi	r2,r2,1
8110a40c:	e0bff715 	stw	r2,-36(fp)
8110a410:	e0bff717 	ldw	r2,-36(fp)
8110a414:	10800210 	cmplti	r2,r2,8
8110a418:	103fe31e 	bne	r2,zero,8110a3a8 <__reset+0xfb0ea3a8>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110a41c:	e03ff715 	stw	zero,-36(fp)
8110a420:	00001a06 	br	8110a48c <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110a424:	e0bff517 	ldw	r2,-44(fp)
8110a428:	1085883a 	add	r2,r2,r2
8110a42c:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110a430:	00a00034 	movhi	r2,32768
8110a434:	10825404 	addi	r2,r2,2384
8110a438:	10800037 	ldwio	r2,0(r2)
8110a43c:	1080004c 	andi	r2,r2,1
8110a440:	1007883a 	mov	r3,r2
8110a444:	e0bff517 	ldw	r2,-44(fp)
8110a448:	10c4b03a 	or	r2,r2,r3
8110a44c:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110a450:	00c00044 	movi	r3,1
8110a454:	00a00034 	movhi	r2,32768
8110a458:	10824c04 	addi	r2,r2,2352
8110a45c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110a460:	010003c4 	movi	r4,15
8110a464:	11307740 	call	81130774 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110a468:	0007883a 	mov	r3,zero
8110a46c:	00a00034 	movhi	r2,32768
8110a470:	10824c04 	addi	r2,r2,2352
8110a474:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110a478:	010003c4 	movi	r4,15
8110a47c:	11307740 	call	81130774 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110a480:	e0bff717 	ldw	r2,-36(fp)
8110a484:	10800044 	addi	r2,r2,1
8110a488:	e0bff715 	stw	r2,-36(fp)
8110a48c:	e0bff717 	ldw	r2,-36(fp)
8110a490:	10800190 	cmplti	r2,r2,6
8110a494:	103fe31e 	bne	r2,zero,8110a424 <__reset+0xfb0ea424>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8110a498:	00c00044 	movi	r3,1
8110a49c:	00a00034 	movhi	r2,32768
8110a4a0:	10824c04 	addi	r2,r2,2352
8110a4a4:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110a4a8:	010003c4 	movi	r4,15
8110a4ac:	11307740 	call	81130774 <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110a4b0:	00c000c4 	movi	r3,3
8110a4b4:	00a00034 	movhi	r2,32768
8110a4b8:	10824804 	addi	r2,r2,2336
8110a4bc:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
8110a4c0:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
8110a4c4:	00800044 	movi	r2,1
8110a4c8:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8110a4cc:	e03ff715 	stw	zero,-36(fp)
8110a4d0:	00000d06 	br	8110a508 <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
8110a4d4:	e0fff517 	ldw	r3,-44(fp)
8110a4d8:	e0bff617 	ldw	r2,-40(fp)
8110a4dc:	1884703a 	and	r2,r3,r2
8110a4e0:	1000031e 	bne	r2,zero,8110a4f0 <POWER_SPI_RW+0x47c>
			nZeroCnt++;
8110a4e4:	e0bff917 	ldw	r2,-28(fp)
8110a4e8:	10800044 	addi	r2,r2,1
8110a4ec:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
8110a4f0:	e0bff617 	ldw	r2,-40(fp)
8110a4f4:	1085883a 	add	r2,r2,r2
8110a4f8:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8110a4fc:	e0bff717 	ldw	r2,-36(fp)
8110a500:	10800044 	addi	r2,r2,1
8110a504:	e0bff715 	stw	r2,-36(fp)
8110a508:	e0bff717 	ldw	r2,-36(fp)
8110a50c:	10800810 	cmplti	r2,r2,32
8110a510:	103ff01e 	bne	r2,zero,8110a4d4 <__reset+0xfb0ea4d4>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
8110a514:	e0bff917 	ldw	r2,-28(fp)
8110a518:	1080004c 	andi	r2,r2,1
8110a51c:	1005003a 	cmpeq	r2,r2,zero
8110a520:	10803fcc 	andi	r2,r2,255
8110a524:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8110a528:	e0bffb17 	ldw	r2,-20(fp)
8110a52c:	1000021e 	bne	r2,zero,8110a538 <POWER_SPI_RW+0x4c4>
#if DEBUG_ON
//		debug(fp, "Parity Check Error \r\n");
#endif
		return FALSE;
8110a530:	0005883a 	mov	r2,zero
8110a534:	00000406 	br	8110a548 <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8110a538:	e0800317 	ldw	r2,12(fp)
8110a53c:	e0fff517 	ldw	r3,-44(fp)
8110a540:	10c00015 	stw	r3,0(r2)

	return bSuccess;
8110a544:	e0bffb17 	ldw	r2,-20(fp)
}
8110a548:	e037883a 	mov	sp,fp
8110a54c:	dfc00117 	ldw	ra,4(sp)
8110a550:	df000017 	ldw	fp,0(sp)
8110a554:	dec00204 	addi	sp,sp,8
8110a558:	f800283a 	ret

8110a55c <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
8110a55c:	defffc04 	addi	sp,sp,-16
8110a560:	de00012e 	bgeu	sp,et,8110a568 <vRstcSimucamReset+0xc>
8110a564:	003b68fa 	trap	3
8110a568:	dfc00315 	stw	ra,12(sp)
8110a56c:	df000215 	stw	fp,8(sp)
8110a570:	df000204 	addi	fp,sp,8
8110a574:	2005883a 	mov	r2,r4
8110a578:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8110a57c:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
8110a580:	e0bfff0b 	ldhu	r2,-4(fp)
8110a584:	e0fffe17 	ldw	r3,-8(fp)
8110a588:	1884b03a 	or	r2,r3,r2
8110a58c:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
8110a590:	e0bffe17 	ldw	r2,-8(fp)
8110a594:	10800074 	orhi	r2,r2,1
8110a598:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110a59c:	e1bffe17 	ldw	r6,-8(fp)
8110a5a0:	000b883a 	mov	r5,zero
8110a5a4:	01200034 	movhi	r4,32768
8110a5a8:	21020004 	addi	r4,r4,2048
8110a5ac:	110a6ac0 	call	8110a6ac <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
8110a5b0:	0001883a 	nop
8110a5b4:	e037883a 	mov	sp,fp
8110a5b8:	dfc00117 	ldw	ra,4(sp)
8110a5bc:	df000017 	ldw	fp,0(sp)
8110a5c0:	dec00204 	addi	sp,sp,8
8110a5c4:	f800283a 	ret

8110a5c8 <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110a5c8:	defffc04 	addi	sp,sp,-16
8110a5cc:	de00012e 	bgeu	sp,et,8110a5d4 <vRstcReleaseDeviceReset+0xc>
8110a5d0:	003b68fa 	trap	3
8110a5d4:	dfc00315 	stw	ra,12(sp)
8110a5d8:	df000215 	stw	fp,8(sp)
8110a5dc:	df000204 	addi	fp,sp,8
8110a5e0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110a5e4:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110a5e8:	01400044 	movi	r5,1
8110a5ec:	01200034 	movhi	r4,32768
8110a5f0:	21020004 	addi	r4,r4,2048
8110a5f4:	110a7000 	call	8110a700 <uliRstReadReg>
8110a5f8:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8110a5fc:	e0bfff17 	ldw	r2,-4(fp)
8110a600:	0084303a 	nor	r2,zero,r2
8110a604:	e0fffe17 	ldw	r3,-8(fp)
8110a608:	1884703a 	and	r2,r3,r2
8110a60c:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110a610:	e1bffe17 	ldw	r6,-8(fp)
8110a614:	01400044 	movi	r5,1
8110a618:	01200034 	movhi	r4,32768
8110a61c:	21020004 	addi	r4,r4,2048
8110a620:	110a6ac0 	call	8110a6ac <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110a624:	0001883a 	nop
8110a628:	e037883a 	mov	sp,fp
8110a62c:	dfc00117 	ldw	ra,4(sp)
8110a630:	df000017 	ldw	fp,0(sp)
8110a634:	dec00204 	addi	sp,sp,8
8110a638:	f800283a 	ret

8110a63c <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
8110a63c:	defffc04 	addi	sp,sp,-16
8110a640:	de00012e 	bgeu	sp,et,8110a648 <vRstcHoldDeviceReset+0xc>
8110a644:	003b68fa 	trap	3
8110a648:	dfc00315 	stw	ra,12(sp)
8110a64c:	df000215 	stw	fp,8(sp)
8110a650:	df000204 	addi	fp,sp,8
8110a654:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110a658:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110a65c:	01400044 	movi	r5,1
8110a660:	01200034 	movhi	r4,32768
8110a664:	21020004 	addi	r4,r4,2048
8110a668:	110a7000 	call	8110a700 <uliRstReadReg>
8110a66c:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
8110a670:	e0fffe17 	ldw	r3,-8(fp)
8110a674:	e0bfff17 	ldw	r2,-4(fp)
8110a678:	1884b03a 	or	r2,r3,r2
8110a67c:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110a680:	e1bffe17 	ldw	r6,-8(fp)
8110a684:	01400044 	movi	r5,1
8110a688:	01200034 	movhi	r4,32768
8110a68c:	21020004 	addi	r4,r4,2048
8110a690:	110a6ac0 	call	8110a6ac <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110a694:	0001883a 	nop
8110a698:	e037883a 	mov	sp,fp
8110a69c:	dfc00117 	ldw	ra,4(sp)
8110a6a0:	df000017 	ldw	fp,0(sp)
8110a6a4:	dec00204 	addi	sp,sp,8
8110a6a8:	f800283a 	ret

8110a6ac <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110a6ac:	defffc04 	addi	sp,sp,-16
8110a6b0:	de00012e 	bgeu	sp,et,8110a6b8 <vRstcWriteReg+0xc>
8110a6b4:	003b68fa 	trap	3
8110a6b8:	df000315 	stw	fp,12(sp)
8110a6bc:	df000304 	addi	fp,sp,12
8110a6c0:	e13ffd15 	stw	r4,-12(fp)
8110a6c4:	e17ffe15 	stw	r5,-8(fp)
8110a6c8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110a6cc:	e0bffe17 	ldw	r2,-8(fp)
8110a6d0:	1085883a 	add	r2,r2,r2
8110a6d4:	1085883a 	add	r2,r2,r2
8110a6d8:	1007883a 	mov	r3,r2
8110a6dc:	e0bffd17 	ldw	r2,-12(fp)
8110a6e0:	10c5883a 	add	r2,r2,r3
8110a6e4:	e0ffff17 	ldw	r3,-4(fp)
8110a6e8:	10c00015 	stw	r3,0(r2)
}
8110a6ec:	0001883a 	nop
8110a6f0:	e037883a 	mov	sp,fp
8110a6f4:	df000017 	ldw	fp,0(sp)
8110a6f8:	dec00104 	addi	sp,sp,4
8110a6fc:	f800283a 	ret

8110a700 <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110a700:	defffc04 	addi	sp,sp,-16
8110a704:	de00012e 	bgeu	sp,et,8110a70c <uliRstReadReg+0xc>
8110a708:	003b68fa 	trap	3
8110a70c:	df000315 	stw	fp,12(sp)
8110a710:	df000304 	addi	fp,sp,12
8110a714:	e13ffe15 	stw	r4,-8(fp)
8110a718:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110a71c:	e0bfff17 	ldw	r2,-4(fp)
8110a720:	1085883a 	add	r2,r2,r2
8110a724:	1085883a 	add	r2,r2,r2
8110a728:	1007883a 	mov	r3,r2
8110a72c:	e0bffe17 	ldw	r2,-8(fp)
8110a730:	10c5883a 	add	r2,r2,r3
8110a734:	10800017 	ldw	r2,0(r2)
8110a738:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110a73c:	e0bffd17 	ldw	r2,-12(fp)
}
8110a740:	e037883a 	mov	sp,fp
8110a744:	df000017 	ldw	fp,0(sp)
8110a748:	dec00104 	addi	sp,sp,4
8110a74c:	f800283a 	ret

8110a750 <v_spi_start>:

#if DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
8110a750:	defffe04 	addi	sp,sp,-8
8110a754:	de00012e 	bgeu	sp,et,8110a75c <v_spi_start+0xc>
8110a758:	003b68fa 	trap	3
8110a75c:	dfc00115 	stw	ra,4(sp)
8110a760:	df000015 	stw	fp,0(sp)
8110a764:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8110a768:	0007883a 	mov	r3,zero
8110a76c:	00a00034 	movhi	r2,32768
8110a770:	10823004 	addi	r2,r2,2240
8110a774:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8110a778:	0007883a 	mov	r3,zero
8110a77c:	00a00034 	movhi	r2,32768
8110a780:	10822c04 	addi	r2,r2,2224
8110a784:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110a788:	01002584 	movi	r4,150
8110a78c:	11307740 	call	81130774 <usleep>
}
8110a790:	0001883a 	nop
8110a794:	e037883a 	mov	sp,fp
8110a798:	dfc00117 	ldw	ra,4(sp)
8110a79c:	df000017 	ldw	fp,0(sp)
8110a7a0:	dec00204 	addi	sp,sp,8
8110a7a4:	f800283a 	ret

8110a7a8 <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8110a7a8:	defffc04 	addi	sp,sp,-16
8110a7ac:	de00012e 	bgeu	sp,et,8110a7b4 <v_spi_send_byte+0xc>
8110a7b0:	003b68fa 	trap	3
8110a7b4:	dfc00315 	stw	ra,12(sp)
8110a7b8:	df000215 	stw	fp,8(sp)
8110a7bc:	df000204 	addi	fp,sp,8
8110a7c0:	2005883a 	mov	r2,r4
8110a7c4:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110a7c8:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8110a7cc:	00bfe004 	movi	r2,-128
8110a7d0:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
8110a7d4:	e03ffe05 	stb	zero,-8(fp)
8110a7d8:	00001b06 	br	8110a848 <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8110a7dc:	e0ffff03 	ldbu	r3,-4(fp)
8110a7e0:	e0bffe43 	ldbu	r2,-7(fp)
8110a7e4:	1884703a 	and	r2,r3,r2
8110a7e8:	10803fcc 	andi	r2,r2,255
8110a7ec:	1004c03a 	cmpne	r2,r2,zero
8110a7f0:	10c03fcc 	andi	r3,r2,255
8110a7f4:	00a00034 	movhi	r2,32768
8110a7f8:	10823404 	addi	r2,r2,2256
8110a7fc:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
8110a800:	e0bffe43 	ldbu	r2,-7(fp)
8110a804:	1004d07a 	srli	r2,r2,1
8110a808:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
8110a80c:	00c00044 	movi	r3,1
8110a810:	00a00034 	movhi	r2,32768
8110a814:	10823004 	addi	r2,r2,2240
8110a818:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110a81c:	01002584 	movi	r4,150
8110a820:	11307740 	call	81130774 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110a824:	0007883a 	mov	r3,zero
8110a828:	00a00034 	movhi	r2,32768
8110a82c:	10823004 	addi	r2,r2,2240
8110a830:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110a834:	01002584 	movi	r4,150
8110a838:	11307740 	call	81130774 <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
8110a83c:	e0bffe03 	ldbu	r2,-8(fp)
8110a840:	10800044 	addi	r2,r2,1
8110a844:	e0bffe05 	stb	r2,-8(fp)
8110a848:	e0bffe03 	ldbu	r2,-8(fp)
8110a84c:	10800230 	cmpltui	r2,r2,8
8110a850:	103fe21e 	bne	r2,zero,8110a7dc <__reset+0xfb0ea7dc>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
8110a854:	0001883a 	nop
8110a858:	e037883a 	mov	sp,fp
8110a85c:	dfc00117 	ldw	ra,4(sp)
8110a860:	df000017 	ldw	fp,0(sp)
8110a864:	dec00204 	addi	sp,sp,8
8110a868:	f800283a 	ret

8110a86c <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8110a86c:	defffd04 	addi	sp,sp,-12
8110a870:	de00012e 	bgeu	sp,et,8110a878 <uc_spi_get_byte+0xc>
8110a874:	003b68fa 	trap	3
8110a878:	dfc00215 	stw	ra,8(sp)
8110a87c:	df000115 	stw	fp,4(sp)
8110a880:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
8110a884:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8110a888:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8110a88c:	e03fff05 	stb	zero,-4(fp)
8110a890:	00001a06 	br	8110a8fc <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
8110a894:	e0bfff43 	ldbu	r2,-3(fp)
8110a898:	1085883a 	add	r2,r2,r2
8110a89c:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
8110a8a0:	00a00034 	movhi	r2,32768
8110a8a4:	10823804 	addi	r2,r2,2272
8110a8a8:	10800037 	ldwio	r2,0(r2)
8110a8ac:	1080004c 	andi	r2,r2,1
8110a8b0:	1007883a 	mov	r3,r2
8110a8b4:	e0bfff43 	ldbu	r2,-3(fp)
8110a8b8:	1884b03a 	or	r2,r3,r2
8110a8bc:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
8110a8c0:	00c00044 	movi	r3,1
8110a8c4:	00a00034 	movhi	r2,32768
8110a8c8:	10823004 	addi	r2,r2,2240
8110a8cc:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110a8d0:	01002584 	movi	r4,150
8110a8d4:	11307740 	call	81130774 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110a8d8:	0007883a 	mov	r3,zero
8110a8dc:	00a00034 	movhi	r2,32768
8110a8e0:	10823004 	addi	r2,r2,2240
8110a8e4:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110a8e8:	01002584 	movi	r4,150
8110a8ec:	11307740 	call	81130774 <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
8110a8f0:	e0bfff03 	ldbu	r2,-4(fp)
8110a8f4:	10800044 	addi	r2,r2,1
8110a8f8:	e0bfff05 	stb	r2,-4(fp)
8110a8fc:	e0bfff03 	ldbu	r2,-4(fp)
8110a900:	10800230 	cmpltui	r2,r2,8
8110a904:	103fe31e 	bne	r2,zero,8110a894 <__reset+0xfb0ea894>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8110a908:	e0bfff43 	ldbu	r2,-3(fp)
}
8110a90c:	e037883a 	mov	sp,fp
8110a910:	dfc00117 	ldw	ra,4(sp)
8110a914:	df000017 	ldw	fp,0(sp)
8110a918:	dec00204 	addi	sp,sp,8
8110a91c:	f800283a 	ret

8110a920 <v_spi_end>:

void v_spi_end(void){
8110a920:	defffe04 	addi	sp,sp,-8
8110a924:	de00012e 	bgeu	sp,et,8110a92c <v_spi_end+0xc>
8110a928:	003b68fa 	trap	3
8110a92c:	dfc00115 	stw	ra,4(sp)
8110a930:	df000015 	stw	fp,0(sp)
8110a934:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8110a938:	0007883a 	mov	r3,zero
8110a93c:	00a00034 	movhi	r2,32768
8110a940:	10823004 	addi	r2,r2,2240
8110a944:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110a948:	01002584 	movi	r4,150
8110a94c:	11307740 	call	81130774 <usleep>
    SPI_CS_N(1);
8110a950:	00c00044 	movi	r3,1
8110a954:	00a00034 	movhi	r2,32768
8110a958:	10822c04 	addi	r2,r2,2224
8110a95c:	10c00035 	stwio	r3,0(r2)
}
8110a960:	0001883a 	nop
8110a964:	e037883a 	mov	sp,fp
8110a968:	dfc00117 	ldw	ra,4(sp)
8110a96c:	df000017 	ldw	fp,0(sp)
8110a970:	dec00204 	addi	sp,sp,8
8110a974:	f800283a 	ret

8110a978 <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8110a978:	defffa04 	addi	sp,sp,-24
8110a97c:	de00012e 	bgeu	sp,et,8110a984 <RTCC_SPI_R_MAC+0xc>
8110a980:	003b68fa 	trap	3
8110a984:	dfc00515 	stw	ra,20(sp)
8110a988:	df000415 	stw	fp,16(sp)
8110a98c:	df000404 	addi	fp,sp,16
8110a990:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110a994:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8110a998:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8110a99c:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
8110a9a0:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
8110a9a4:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8110a9a8:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8110a9ac:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
8110a9b0:	00800084 	movi	r2,2
8110a9b4:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110a9b8:	00800cc4 	movi	r2,51
8110a9bc:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
8110a9c0:	110a7500 	call	8110a750 <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
8110a9c4:	e0bffec3 	ldbu	r2,-5(fp)
8110a9c8:	1009883a 	mov	r4,r2
8110a9cc:	110a7a80 	call	8110a7a8 <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
8110a9d0:	e0bffe83 	ldbu	r2,-6(fp)
8110a9d4:	1009883a 	mov	r4,r2
8110a9d8:	110a7a80 	call	8110a7a8 <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8110a9dc:	110a86c0 	call	8110a86c <uc_spi_get_byte>
8110a9e0:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
8110a9e4:	110a86c0 	call	8110a86c <uc_spi_get_byte>
8110a9e8:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8110a9ec:	110a86c0 	call	8110a86c <uc_spi_get_byte>
8110a9f0:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
8110a9f4:	110a86c0 	call	8110a86c <uc_spi_get_byte>
8110a9f8:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8110a9fc:	110a86c0 	call	8110a86c <uc_spi_get_byte>
8110aa00:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
8110aa04:	110a86c0 	call	8110a86c <uc_spi_get_byte>
8110aa08:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
8110aa0c:	110a9200 	call	8110a920 <v_spi_end>

    bSuccess = TRUE;
8110aa10:	00800044 	movi	r2,1
8110aa14:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8110aa18:	e0bfff17 	ldw	r2,-4(fp)
8110aa1c:	e0fffd03 	ldbu	r3,-12(fp)
8110aa20:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
8110aa24:	e0bfff17 	ldw	r2,-4(fp)
8110aa28:	10800044 	addi	r2,r2,1
8110aa2c:	e0fffd43 	ldbu	r3,-11(fp)
8110aa30:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
8110aa34:	e0bfff17 	ldw	r2,-4(fp)
8110aa38:	10800084 	addi	r2,r2,2
8110aa3c:	e0fffd83 	ldbu	r3,-10(fp)
8110aa40:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
8110aa44:	e0bfff17 	ldw	r2,-4(fp)
8110aa48:	108000c4 	addi	r2,r2,3
8110aa4c:	e0fffdc3 	ldbu	r3,-9(fp)
8110aa50:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
8110aa54:	e0bfff17 	ldw	r2,-4(fp)
8110aa58:	10800104 	addi	r2,r2,4
8110aa5c:	e0fffe03 	ldbu	r3,-8(fp)
8110aa60:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
8110aa64:	e0bfff17 	ldw	r2,-4(fp)
8110aa68:	10800144 	addi	r2,r2,5
8110aa6c:	e0fffe43 	ldbu	r3,-7(fp)
8110aa70:	10c00005 	stb	r3,0(r2)
#if DEBUG_ON
	sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
	debug(fp, cDebugBuffer);
#endif

    return bSuccess;
8110aa74:	e0bffc17 	ldw	r2,-16(fp)
}
8110aa78:	e037883a 	mov	sp,fp
8110aa7c:	dfc00117 	ldw	ra,4(sp)
8110aa80:	df000017 	ldw	fp,0(sp)
8110aa84:	dec00204 	addi	sp,sp,8
8110aa88:	f800283a 	ret

8110aa8c <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8110aa8c:	defffd04 	addi	sp,sp,-12
8110aa90:	de00012e 	bgeu	sp,et,8110aa98 <bSSDisplayConfig+0xc>
8110aa94:	003b68fa 	trap	3
8110aa98:	df000215 	stw	fp,8(sp)
8110aa9c:	df000204 	addi	fp,sp,8
8110aaa0:	2005883a 	mov	r2,r4
8110aaa4:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8110aaa8:	e0bfff03 	ldbu	r2,-4(fp)
8110aaac:	10c00168 	cmpgeui	r3,r2,5
8110aab0:	18001c1e 	bne	r3,zero,8110ab24 <bSSDisplayConfig+0x98>
8110aab4:	100690ba 	slli	r3,r2,2
8110aab8:	00a04474 	movhi	r2,33041
8110aabc:	10aab304 	addi	r2,r2,-21812
8110aac0:	1885883a 	add	r2,r3,r2
8110aac4:	10800017 	ldw	r2,0(r2)
8110aac8:	1000683a 	jmp	r2
8110aacc:	8110aae0 	cmpeqi	r4,r16,17067
8110aad0:	8110aaec 	andhi	r4,r16,17067
8110aad4:	8110aaf8 	rdprs	r4,r16,17067
8110aad8:	8110ab0c 	andi	r4,r16,17068
8110aadc:	8110ab1c 	xori	r4,r16,17068
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
8110aae0:	00800cc4 	movi	r2,51
8110aae4:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110aae8:	00001006 	br	8110ab2c <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
8110aaec:	00801544 	movi	r2,85
8110aaf0:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110aaf4:	00000d06 	br	8110ab2c <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110aaf8:	d0e05043 	ldbu	r3,-32447(gp)
8110aafc:	00bff744 	movi	r2,-35
8110ab00:	1884703a 	and	r2,r3,r2
8110ab04:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110ab08:	00000806 	br	8110ab2c <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
8110ab0c:	d0a05043 	ldbu	r2,-32447(gp)
8110ab10:	10800894 	ori	r2,r2,34
8110ab14:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110ab18:	00000406 	br	8110ab2c <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8110ab1c:	d0205045 	stb	zero,-32447(gp)
	    break;
8110ab20:	00000206 	br	8110ab2c <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
8110ab24:	0005883a 	mov	r2,zero
8110ab28:	00000806 	br	8110ab4c <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110ab2c:	00a00034 	movhi	r2,32768
8110ab30:	10828404 	addi	r2,r2,2576
8110ab34:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8110ab38:	d0a05043 	ldbu	r2,-32447(gp)
8110ab3c:	10c03fcc 	andi	r3,r2,255
8110ab40:	e0bffe17 	ldw	r2,-8(fp)
8110ab44:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110ab48:	00800044 	movi	r2,1
}
8110ab4c:	e037883a 	mov	sp,fp
8110ab50:	df000017 	ldw	fp,0(sp)
8110ab54:	dec00104 	addi	sp,sp,4
8110ab58:	f800283a 	ret

8110ab5c <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8110ab5c:	defffd04 	addi	sp,sp,-12
8110ab60:	de00012e 	bgeu	sp,et,8110ab68 <bSSDisplayUpdate+0xc>
8110ab64:	003b68fa 	trap	3
8110ab68:	df000215 	stw	fp,8(sp)
8110ab6c:	df000204 	addi	fp,sp,8
8110ab70:	2005883a 	mov	r2,r4
8110ab74:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110ab78:	00a00034 	movhi	r2,32768
8110ab7c:	10828404 	addi	r2,r2,2576
8110ab80:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
8110ab84:	e0bffe17 	ldw	r2,-8(fp)
8110ab88:	10800104 	addi	r2,r2,4
8110ab8c:	e0ffff03 	ldbu	r3,-4(fp)
8110ab90:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110ab94:	00800044 	movi	r2,1
}
8110ab98:	e037883a 	mov	sp,fp
8110ab9c:	df000017 	ldw	fp,0(sp)
8110aba0:	dec00104 	addi	sp,sp,4
8110aba4:	f800283a 	ret

8110aba8 <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8110aba8:	defff904 	addi	sp,sp,-28
8110abac:	de00012e 	bgeu	sp,et,8110abb4 <vSyncHandleIrq+0xc>
8110abb0:	003b68fa 	trap	3
8110abb4:	dfc00615 	stw	ra,24(sp)
8110abb8:	df000515 	stw	fp,20(sp)
8110abbc:	df000504 	addi	fp,sp,20
8110abc0:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	volatile int* pviHoldContext = (volatile int*) pvContext;
8110abc4:	e0bfff17 	ldw	r2,-4(fp)
8110abc8:	e0bffc15 	stw	r2,-16(fp)


	uiCmdtoSend.ulWord = 0;
8110abcc:	e03ffe15 	stw	zero,-8(fp)
	/* MasterSync? */
	ucSyncL = (vucN % 4);
8110abd0:	d0a05203 	ldbu	r2,-32440(gp)
8110abd4:	108000cc 	andi	r2,r2,3
8110abd8:	e0bffd05 	stb	r2,-12(fp)
	if ( ucSyncL == 0 )
8110abdc:	e0bffd03 	ldbu	r2,-12(fp)
8110abe0:	1000031e 	bne	r2,zero,8110abf0 <vSyncHandleIrq+0x48>
		uiCmdtoSend.ucByte[2] = M_MASTER_SYNC;
8110abe4:	00bff804 	movi	r2,-32
8110abe8:	e0bffe85 	stb	r2,-6(fp)
8110abec:	00000206 	br	8110abf8 <vSyncHandleIrq+0x50>
	else
		uiCmdtoSend.ucByte[2] = M_SYNC;
8110abf0:	00bff844 	movi	r2,-31
8110abf4:	e0bffe85 	stb	r2,-6(fp)

	uiCmdtoSend.ucByte[3] = M_MEB_ADDR;
8110abf8:	00800044 	movi	r2,1
8110abfc:	e0bffec5 	stb	r2,-5(fp)

	/* Send Priority message to the Meb Task to indicate the Master Sync */
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
8110ac00:	d0a06817 	ldw	r2,-32352(gp)
8110ac04:	e0fffe17 	ldw	r3,-8(fp)
8110ac08:	180b883a 	mov	r5,r3
8110ac0c:	1009883a 	mov	r4,r2
8110ac10:	1136bf80 	call	81136bf8 <OSQPostFront>
8110ac14:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110ac18:	e0bffd43 	ldbu	r2,-11(fp)
8110ac1c:	10000126 	beq	r2,zero,8110ac24 <vSyncHandleIrq+0x7c>
		vFailSendMsgMasterSyncMeb( );
8110ac20:	11172c40 	call	811172c4 <vFailSendMsgMasterSyncMeb>
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110ac24:	e03ffb05 	stb	zero,-20(fp)
8110ac28:	00001606 	br	8110ac84 <vSyncHandleIrq+0xdc>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8110ac2c:	e0bffb03 	ldbu	r2,-20(fp)
8110ac30:	10800444 	addi	r2,r2,17
8110ac34:	e0bffec5 	stb	r2,-5(fp)
		error_codel = OSQPostFront(xFeeQ[ ucIL ], (void *)uiCmdtoSend.ulWord);
8110ac38:	e0bffb03 	ldbu	r2,-20(fp)
8110ac3c:	1085883a 	add	r2,r2,r2
8110ac40:	1087883a 	add	r3,r2,r2
8110ac44:	d0a06904 	addi	r2,gp,-32348
8110ac48:	1885883a 	add	r2,r3,r2
8110ac4c:	10800017 	ldw	r2,0(r2)
8110ac50:	e0fffe17 	ldw	r3,-8(fp)
8110ac54:	180b883a 	mov	r5,r3
8110ac58:	1009883a 	mov	r4,r2
8110ac5c:	1136bf80 	call	81136bf8 <OSQPostFront>
8110ac60:	e0bffd45 	stb	r2,-11(fp)
		if ( error_codel != OS_ERR_NONE ) {
8110ac64:	e0bffd43 	ldbu	r2,-11(fp)
8110ac68:	10000326 	beq	r2,zero,8110ac78 <vSyncHandleIrq+0xd0>
			vFailSendMsgSync( ucIL );
8110ac6c:	e0bffb03 	ldbu	r2,-20(fp)
8110ac70:	1009883a 	mov	r4,r2
8110ac74:	11172640 	call	81117264 <vFailSendMsgSync>
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
	if ( error_codel != OS_ERR_NONE ) {
		vFailSendMsgMasterSyncMeb( );
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110ac78:	e0bffb03 	ldbu	r2,-20(fp)
8110ac7c:	10800044 	addi	r2,r2,1
8110ac80:	e0bffb05 	stb	r2,-20(fp)
8110ac84:	e0bffb03 	ldbu	r2,-20(fp)
8110ac88:	103fe826 	beq	r2,zero,8110ac2c <__reset+0xfb0eac2c>
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}

	vucN += 1;
8110ac8c:	d0a05203 	ldbu	r2,-32440(gp)
8110ac90:	10800044 	addi	r2,r2,1
8110ac94:	d0a05205 	stb	r2,-32440(gp)

	#if DEBUG_ON
		fprintf(fp,"Sync %hu \n", ucSyncL);
	#endif

	vSyncIrqFlagClrSync();
8110ac98:	110ad2c0 	call	8110ad2c <vSyncIrqFlagClrSync>
}
8110ac9c:	0001883a 	nop
8110aca0:	e037883a 	mov	sp,fp
8110aca4:	dfc00117 	ldw	ra,4(sp)
8110aca8:	df000017 	ldw	fp,0(sp)
8110acac:	dec00204 	addi	sp,sp,8
8110acb0:	f800283a 	ret

8110acb4 <vSyncClearCounter>:

void vSyncClearCounter(void) {
8110acb4:	deffff04 	addi	sp,sp,-4
8110acb8:	de00012e 	bgeu	sp,et,8110acc0 <vSyncClearCounter+0xc>
8110acbc:	003b68fa 	trap	3
8110acc0:	df000015 	stw	fp,0(sp)
8110acc4:	d839883a 	mov	fp,sp
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	vucN = 0;
8110acc8:	d0205205 	stb	zero,-32440(gp)
}
8110accc:	0001883a 	nop
8110acd0:	e037883a 	mov	sp,fp
8110acd4:	df000017 	ldw	fp,0(sp)
8110acd8:	dec00104 	addi	sp,sp,4
8110acdc:	f800283a 	ret

8110ace0 <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8110ace0:	defffd04 	addi	sp,sp,-12
8110ace4:	de00012e 	bgeu	sp,et,8110acec <vSyncInitIrq+0xc>
8110ace8:	003b68fa 	trap	3
8110acec:	dfc00215 	stw	ra,8(sp)
8110acf0:	df000115 	stw	fp,4(sp)
8110acf4:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
8110acf8:	d0a05104 	addi	r2,gp,-32444
8110acfc:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8110ad00:	01a04474 	movhi	r6,33041
8110ad04:	31aaea04 	addi	r6,r6,-21592
8110ad08:	e17fff17 	ldw	r5,-4(fp)
8110ad0c:	01000284 	movi	r4,10
8110ad10:	112f3100 	call	8112f310 <alt_irq_register>
}
8110ad14:	0001883a 	nop
8110ad18:	e037883a 	mov	sp,fp
8110ad1c:	dfc00117 	ldw	ra,4(sp)
8110ad20:	df000017 	ldw	fp,0(sp)
8110ad24:	dec00204 	addi	sp,sp,8
8110ad28:	f800283a 	ret

8110ad2c <vSyncIrqFlagClrSync>:

void vSyncIrqFlagClrSync(void) {
8110ad2c:	defffe04 	addi	sp,sp,-8
8110ad30:	de00012e 	bgeu	sp,et,8110ad38 <vSyncIrqFlagClrSync+0xc>
8110ad34:	003b68fa 	trap	3
8110ad38:	dfc00115 	stw	ra,4(sp)
8110ad3c:	df000015 	stw	fp,0(sp)
8110ad40:	d839883a 	mov	fp,sp
	bSyncWriteReg(SYNC_IRQ_FG_CLR_REG_OFFSET, (alt_u32) SYNC_IRQ_FG_CLR_MSK);
8110ad44:	01400044 	movi	r5,1
8110ad48:	010002c4 	movi	r4,11
8110ad4c:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
}
8110ad50:	0001883a 	nop
8110ad54:	e037883a 	mov	sp,fp
8110ad58:	dfc00117 	ldw	ra,4(sp)
8110ad5c:	df000017 	ldw	fp,0(sp)
8110ad60:	dec00204 	addi	sp,sp,8
8110ad64:	f800283a 	ret

8110ad68 <bSyncIrqFlagSync>:

bool bSyncIrqFlagSync(void) {
8110ad68:	defffd04 	addi	sp,sp,-12
8110ad6c:	de00012e 	bgeu	sp,et,8110ad74 <bSyncIrqFlagSync+0xc>
8110ad70:	003b68fa 	trap	3
8110ad74:	dfc00215 	stw	ra,8(sp)
8110ad78:	df000115 	stw	fp,4(sp)
8110ad7c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliSyncReadReg(SYNC_IRQ_FG_REG_OFFSET) & SYNC_IRQ_FG_MSK) {
8110ad80:	01000304 	movi	r4,12
8110ad84:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110ad88:	1080004c 	andi	r2,r2,1
8110ad8c:	10000326 	beq	r2,zero,8110ad9c <bSyncIrqFlagSync+0x34>
		bFlag = TRUE;
8110ad90:	00800044 	movi	r2,1
8110ad94:	e0bfff15 	stw	r2,-4(fp)
8110ad98:	00000106 	br	8110ada0 <bSyncIrqFlagSync+0x38>
	} else {
		bFlag = FALSE;
8110ad9c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110ada0:	e0bfff17 	ldw	r2,-4(fp)
}
8110ada4:	e037883a 	mov	sp,fp
8110ada8:	dfc00117 	ldw	ra,4(sp)
8110adac:	df000017 	ldw	fp,0(sp)
8110adb0:	dec00204 	addi	sp,sp,8
8110adb4:	f800283a 	ret

8110adb8 <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
8110adb8:	defffc04 	addi	sp,sp,-16
8110adbc:	de00012e 	bgeu	sp,et,8110adc4 <bSyncStatusExtnIrq+0xc>
8110adc0:	003b68fa 	trap	3
8110adc4:	dfc00315 	stw	ra,12(sp)
8110adc8:	df000215 	stw	fp,8(sp)
8110adcc:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110add0:	0009883a 	mov	r4,zero
8110add4:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110add8:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8110addc:	e0bfff17 	ldw	r2,-4(fp)
8110ade0:	1000030e 	bge	r2,zero,8110adf0 <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
8110ade4:	00800044 	movi	r2,1
8110ade8:	e0bffe15 	stw	r2,-8(fp)
8110adec:	00000106 	br	8110adf4 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8110adf0:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110adf4:	e0bffe17 	ldw	r2,-8(fp)
}
8110adf8:	e037883a 	mov	sp,fp
8110adfc:	dfc00117 	ldw	ra,4(sp)
8110ae00:	df000017 	ldw	fp,0(sp)
8110ae04:	dec00204 	addi	sp,sp,8
8110ae08:	f800283a 	ret

8110ae0c <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110ae0c:	defffc04 	addi	sp,sp,-16
8110ae10:	de00012e 	bgeu	sp,et,8110ae18 <ucSyncStatusState+0xc>
8110ae14:	003b68fa 	trap	3
8110ae18:	dfc00315 	stw	ra,12(sp)
8110ae1c:	df000215 	stw	fp,8(sp)
8110ae20:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110ae24:	0009883a 	mov	r4,zero
8110ae28:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110ae2c:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8110ae30:	e0bffe17 	ldw	r2,-8(fp)
8110ae34:	10803fec 	andhi	r2,r2,255
8110ae38:	1004d43a 	srli	r2,r2,16
8110ae3c:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110ae40:	e0bfff03 	ldbu	r2,-4(fp)
}
8110ae44:	e037883a 	mov	sp,fp
8110ae48:	dfc00117 	ldw	ra,4(sp)
8110ae4c:	df000017 	ldw	fp,0(sp)
8110ae50:	dec00204 	addi	sp,sp,8
8110ae54:	f800283a 	ret

8110ae58 <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
8110ae58:	defffc04 	addi	sp,sp,-16
8110ae5c:	de00012e 	bgeu	sp,et,8110ae64 <ucSyncStatusErrorCode+0xc>
8110ae60:	003b68fa 	trap	3
8110ae64:	dfc00315 	stw	ra,12(sp)
8110ae68:	df000215 	stw	fp,8(sp)
8110ae6c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110ae70:	0009883a 	mov	r4,zero
8110ae74:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110ae78:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8110ae7c:	e0bffe17 	ldw	r2,-8(fp)
8110ae80:	10bfc00c 	andi	r2,r2,65280
8110ae84:	1004d23a 	srli	r2,r2,8
8110ae88:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110ae8c:	e0bfff03 	ldbu	r2,-4(fp)
}
8110ae90:	e037883a 	mov	sp,fp
8110ae94:	dfc00117 	ldw	ra,4(sp)
8110ae98:	df000017 	ldw	fp,0(sp)
8110ae9c:	dec00204 	addi	sp,sp,8
8110aea0:	f800283a 	ret

8110aea4 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
8110aea4:	defffc04 	addi	sp,sp,-16
8110aea8:	de00012e 	bgeu	sp,et,8110aeb0 <ucSyncStatusCycleNumber+0xc>
8110aeac:	003b68fa 	trap	3
8110aeb0:	dfc00315 	stw	ra,12(sp)
8110aeb4:	df000215 	stw	fp,8(sp)
8110aeb8:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110aebc:	0009883a 	mov	r4,zero
8110aec0:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110aec4:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
8110aec8:	e0bffe17 	ldw	r2,-8(fp)
8110aecc:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110aed0:	e0bfff03 	ldbu	r2,-4(fp)
}
8110aed4:	e037883a 	mov	sp,fp
8110aed8:	dfc00117 	ldw	ra,4(sp)
8110aedc:	df000017 	ldw	fp,0(sp)
8110aee0:	dec00204 	addi	sp,sp,8
8110aee4:	f800283a 	ret

8110aee8 <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
8110aee8:	defffd04 	addi	sp,sp,-12
8110aeec:	de00012e 	bgeu	sp,et,8110aef4 <bSyncSetMbt+0xc>
8110aef0:	003b68fa 	trap	3
8110aef4:	dfc00215 	stw	ra,8(sp)
8110aef8:	df000115 	stw	fp,4(sp)
8110aefc:	df000104 	addi	fp,sp,4
8110af00:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
8110af04:	e17fff17 	ldw	r5,-4(fp)
8110af08:	01000104 	movi	r4,4
8110af0c:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110af10:	00800044 	movi	r2,1
}
8110af14:	e037883a 	mov	sp,fp
8110af18:	dfc00117 	ldw	ra,4(sp)
8110af1c:	df000017 	ldw	fp,0(sp)
8110af20:	dec00204 	addi	sp,sp,8
8110af24:	f800283a 	ret

8110af28 <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
8110af28:	defffd04 	addi	sp,sp,-12
8110af2c:	de00012e 	bgeu	sp,et,8110af34 <bSyncSetBt+0xc>
8110af30:	003b68fa 	trap	3
8110af34:	dfc00215 	stw	ra,8(sp)
8110af38:	df000115 	stw	fp,4(sp)
8110af3c:	df000104 	addi	fp,sp,4
8110af40:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
8110af44:	e17fff17 	ldw	r5,-4(fp)
8110af48:	01000144 	movi	r4,5
8110af4c:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110af50:	00800044 	movi	r2,1
}
8110af54:	e037883a 	mov	sp,fp
8110af58:	dfc00117 	ldw	ra,4(sp)
8110af5c:	df000017 	ldw	fp,0(sp)
8110af60:	dec00204 	addi	sp,sp,8
8110af64:	f800283a 	ret

8110af68 <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
8110af68:	defffd04 	addi	sp,sp,-12
8110af6c:	de00012e 	bgeu	sp,et,8110af74 <bSyncSetPer+0xc>
8110af70:	003b68fa 	trap	3
8110af74:	dfc00215 	stw	ra,8(sp)
8110af78:	df000115 	stw	fp,4(sp)
8110af7c:	df000104 	addi	fp,sp,4
8110af80:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
8110af84:	e17fff17 	ldw	r5,-4(fp)
8110af88:	01000184 	movi	r4,6
8110af8c:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110af90:	00800044 	movi	r2,1
}
8110af94:	e037883a 	mov	sp,fp
8110af98:	dfc00117 	ldw	ra,4(sp)
8110af9c:	df000017 	ldw	fp,0(sp)
8110afa0:	dec00204 	addi	sp,sp,8
8110afa4:	f800283a 	ret

8110afa8 <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
8110afa8:	defffd04 	addi	sp,sp,-12
8110afac:	de00012e 	bgeu	sp,et,8110afb4 <bSyncSetOst+0xc>
8110afb0:	003b68fa 	trap	3
8110afb4:	dfc00215 	stw	ra,8(sp)
8110afb8:	df000115 	stw	fp,4(sp)
8110afbc:	df000104 	addi	fp,sp,4
8110afc0:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
8110afc4:	e17fff17 	ldw	r5,-4(fp)
8110afc8:	010001c4 	movi	r4,7
8110afcc:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110afd0:	00800044 	movi	r2,1
}
8110afd4:	e037883a 	mov	sp,fp
8110afd8:	dfc00117 	ldw	ra,4(sp)
8110afdc:	df000017 	ldw	fp,0(sp)
8110afe0:	dec00204 	addi	sp,sp,8
8110afe4:	f800283a 	ret

8110afe8 <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
8110afe8:	defffc04 	addi	sp,sp,-16
8110afec:	de00012e 	bgeu	sp,et,8110aff4 <bSyncSetPolarity+0xc>
8110aff0:	003b68fa 	trap	3
8110aff4:	dfc00315 	stw	ra,12(sp)
8110aff8:	df000215 	stw	fp,8(sp)
8110affc:	df000204 	addi	fp,sp,8
8110b000:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110b004:	01000204 	movi	r4,8
8110b008:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b00c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110b010:	e0bfff17 	ldw	r2,-4(fp)
8110b014:	1000051e 	bne	r2,zero,8110b02c <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
8110b018:	e0fffe17 	ldw	r3,-8(fp)
8110b01c:	00bfbfc4 	movi	r2,-257
8110b020:	1884703a 	and	r2,r3,r2
8110b024:	e0bffe15 	stw	r2,-8(fp)
8110b028:	00000306 	br	8110b038 <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
8110b02c:	e0bffe17 	ldw	r2,-8(fp)
8110b030:	10804014 	ori	r2,r2,256
8110b034:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110b038:	e17ffe17 	ldw	r5,-8(fp)
8110b03c:	01000204 	movi	r4,8
8110b040:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b044:	00800044 	movi	r2,1
}
8110b048:	e037883a 	mov	sp,fp
8110b04c:	dfc00117 	ldw	ra,4(sp)
8110b050:	df000017 	ldw	fp,0(sp)
8110b054:	dec00204 	addi	sp,sp,8
8110b058:	f800283a 	ret

8110b05c <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
8110b05c:	defffc04 	addi	sp,sp,-16
8110b060:	de00012e 	bgeu	sp,et,8110b068 <bSyncSetNCycles+0xc>
8110b064:	003b68fa 	trap	3
8110b068:	dfc00315 	stw	ra,12(sp)
8110b06c:	df000215 	stw	fp,8(sp)
8110b070:	df000204 	addi	fp,sp,8
8110b074:	2005883a 	mov	r2,r4
8110b078:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110b07c:	01000204 	movi	r4,8
8110b080:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b084:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
8110b088:	e0fffe17 	ldw	r3,-8(fp)
8110b08c:	00bfc004 	movi	r2,-256
8110b090:	1884703a 	and	r2,r3,r2
8110b094:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
8110b098:	e0bfff03 	ldbu	r2,-4(fp)
8110b09c:	e0fffe17 	ldw	r3,-8(fp)
8110b0a0:	1884b03a 	or	r2,r3,r2
8110b0a4:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110b0a8:	e17ffe17 	ldw	r5,-8(fp)
8110b0ac:	01000204 	movi	r4,8
8110b0b0:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b0b4:	00800044 	movi	r2,1
}
8110b0b8:	e037883a 	mov	sp,fp
8110b0bc:	dfc00117 	ldw	ra,4(sp)
8110b0c0:	df000017 	ldw	fp,0(sp)
8110b0c4:	dec00204 	addi	sp,sp,8
8110b0c8:	f800283a 	ret

8110b0cc <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
8110b0cc:	defffd04 	addi	sp,sp,-12
8110b0d0:	de00012e 	bgeu	sp,et,8110b0d8 <uliSyncGetMbt+0xc>
8110b0d4:	003b68fa 	trap	3
8110b0d8:	dfc00215 	stw	ra,8(sp)
8110b0dc:	df000115 	stw	fp,4(sp)
8110b0e0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
8110b0e4:	01000104 	movi	r4,4
8110b0e8:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b0ec:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110b0f0:	e0bfff17 	ldw	r2,-4(fp)
}
8110b0f4:	e037883a 	mov	sp,fp
8110b0f8:	dfc00117 	ldw	ra,4(sp)
8110b0fc:	df000017 	ldw	fp,0(sp)
8110b100:	dec00204 	addi	sp,sp,8
8110b104:	f800283a 	ret

8110b108 <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
8110b108:	defffd04 	addi	sp,sp,-12
8110b10c:	de00012e 	bgeu	sp,et,8110b114 <uliSyncGetBt+0xc>
8110b110:	003b68fa 	trap	3
8110b114:	dfc00215 	stw	ra,8(sp)
8110b118:	df000115 	stw	fp,4(sp)
8110b11c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
8110b120:	01000144 	movi	r4,5
8110b124:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b128:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110b12c:	e0bfff17 	ldw	r2,-4(fp)
}
8110b130:	e037883a 	mov	sp,fp
8110b134:	dfc00117 	ldw	ra,4(sp)
8110b138:	df000017 	ldw	fp,0(sp)
8110b13c:	dec00204 	addi	sp,sp,8
8110b140:	f800283a 	ret

8110b144 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
8110b144:	defffd04 	addi	sp,sp,-12
8110b148:	de00012e 	bgeu	sp,et,8110b150 <uliSyncGetPer+0xc>
8110b14c:	003b68fa 	trap	3
8110b150:	dfc00215 	stw	ra,8(sp)
8110b154:	df000115 	stw	fp,4(sp)
8110b158:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
8110b15c:	01000184 	movi	r4,6
8110b160:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b164:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110b168:	e0bfff17 	ldw	r2,-4(fp)
}
8110b16c:	e037883a 	mov	sp,fp
8110b170:	dfc00117 	ldw	ra,4(sp)
8110b174:	df000017 	ldw	fp,0(sp)
8110b178:	dec00204 	addi	sp,sp,8
8110b17c:	f800283a 	ret

8110b180 <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
8110b180:	defffd04 	addi	sp,sp,-12
8110b184:	de00012e 	bgeu	sp,et,8110b18c <uliSyncGetOst+0xc>
8110b188:	003b68fa 	trap	3
8110b18c:	dfc00215 	stw	ra,8(sp)
8110b190:	df000115 	stw	fp,4(sp)
8110b194:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
8110b198:	010001c4 	movi	r4,7
8110b19c:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b1a0:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110b1a4:	e0bfff17 	ldw	r2,-4(fp)
}
8110b1a8:	e037883a 	mov	sp,fp
8110b1ac:	dfc00117 	ldw	ra,4(sp)
8110b1b0:	df000017 	ldw	fp,0(sp)
8110b1b4:	dec00204 	addi	sp,sp,8
8110b1b8:	f800283a 	ret

8110b1bc <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
8110b1bc:	defffd04 	addi	sp,sp,-12
8110b1c0:	de00012e 	bgeu	sp,et,8110b1c8 <uliSyncGetGeneral+0xc>
8110b1c4:	003b68fa 	trap	3
8110b1c8:	dfc00215 	stw	ra,8(sp)
8110b1cc:	df000115 	stw	fp,4(sp)
8110b1d0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110b1d4:	01000204 	movi	r4,8
8110b1d8:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b1dc:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110b1e0:	e0bfff17 	ldw	r2,-4(fp)
}
8110b1e4:	e037883a 	mov	sp,fp
8110b1e8:	dfc00117 	ldw	ra,4(sp)
8110b1ec:	df000017 	ldw	fp,0(sp)
8110b1f0:	dec00204 	addi	sp,sp,8
8110b1f4:	f800283a 	ret

8110b1f8 <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
8110b1f8:	defffd04 	addi	sp,sp,-12
8110b1fc:	de00012e 	bgeu	sp,et,8110b204 <bSyncErrInj+0xc>
8110b200:	003b68fa 	trap	3
8110b204:	dfc00215 	stw	ra,8(sp)
8110b208:	df000115 	stw	fp,4(sp)
8110b20c:	df000104 	addi	fp,sp,4
8110b210:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
8110b214:	e17fff17 	ldw	r5,-4(fp)
8110b218:	01000244 	movi	r4,9
8110b21c:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b220:	00800044 	movi	r2,1
}
8110b224:	e037883a 	mov	sp,fp
8110b228:	dfc00117 	ldw	ra,4(sp)
8110b22c:	df000017 	ldw	fp,0(sp)
8110b230:	dec00204 	addi	sp,sp,8
8110b234:	f800283a 	ret

8110b238 <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
8110b238:	defffc04 	addi	sp,sp,-16
8110b23c:	de00012e 	bgeu	sp,et,8110b244 <bSyncCtrExtnIrq+0xc>
8110b240:	003b68fa 	trap	3
8110b244:	dfc00315 	stw	ra,12(sp)
8110b248:	df000215 	stw	fp,8(sp)
8110b24c:	df000204 	addi	fp,sp,8
8110b250:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110b254:	01000284 	movi	r4,10
8110b258:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b25c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110b260:	e0bfff17 	ldw	r2,-4(fp)
8110b264:	1000061e 	bne	r2,zero,8110b280 <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
8110b268:	e0fffe17 	ldw	r3,-8(fp)
8110b26c:	00a00034 	movhi	r2,32768
8110b270:	10bfffc4 	addi	r2,r2,-1
8110b274:	1884703a 	and	r2,r3,r2
8110b278:	e0bffe15 	stw	r2,-8(fp)
8110b27c:	00000306 	br	8110b28c <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
8110b280:	e0bffe17 	ldw	r2,-8(fp)
8110b284:	10a00034 	orhi	r2,r2,32768
8110b288:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110b28c:	e17ffe17 	ldw	r5,-8(fp)
8110b290:	01000284 	movi	r4,10
8110b294:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b298:	00800044 	movi	r2,1
}
8110b29c:	e037883a 	mov	sp,fp
8110b2a0:	dfc00117 	ldw	ra,4(sp)
8110b2a4:	df000017 	ldw	fp,0(sp)
8110b2a8:	dec00204 	addi	sp,sp,8
8110b2ac:	f800283a 	ret

8110b2b0 <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
8110b2b0:	defffd04 	addi	sp,sp,-12
8110b2b4:	de00012e 	bgeu	sp,et,8110b2bc <bSyncCtrStart+0xc>
8110b2b8:	003b68fa 	trap	3
8110b2bc:	dfc00215 	stw	ra,8(sp)
8110b2c0:	df000115 	stw	fp,4(sp)
8110b2c4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110b2c8:	01000284 	movi	r4,10
8110b2cc:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b2d0:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
8110b2d4:	e0bfff17 	ldw	r2,-4(fp)
8110b2d8:	10800234 	orhi	r2,r2,8
8110b2dc:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110b2e0:	e17fff17 	ldw	r5,-4(fp)
8110b2e4:	01000284 	movi	r4,10
8110b2e8:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b2ec:	00800044 	movi	r2,1
}
8110b2f0:	e037883a 	mov	sp,fp
8110b2f4:	dfc00117 	ldw	ra,4(sp)
8110b2f8:	df000017 	ldw	fp,0(sp)
8110b2fc:	dec00204 	addi	sp,sp,8
8110b300:	f800283a 	ret

8110b304 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
8110b304:	defffd04 	addi	sp,sp,-12
8110b308:	de00012e 	bgeu	sp,et,8110b310 <bSyncCtrReset+0xc>
8110b30c:	003b68fa 	trap	3
8110b310:	dfc00215 	stw	ra,8(sp)
8110b314:	df000115 	stw	fp,4(sp)
8110b318:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110b31c:	01000284 	movi	r4,10
8110b320:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b324:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
8110b328:	e0bfff17 	ldw	r2,-4(fp)
8110b32c:	10800134 	orhi	r2,r2,4
8110b330:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110b334:	e17fff17 	ldw	r5,-4(fp)
8110b338:	01000284 	movi	r4,10
8110b33c:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b340:	00800044 	movi	r2,1
}
8110b344:	e037883a 	mov	sp,fp
8110b348:	dfc00117 	ldw	ra,4(sp)
8110b34c:	df000017 	ldw	fp,0(sp)
8110b350:	dec00204 	addi	sp,sp,8
8110b354:	f800283a 	ret

8110b358 <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
8110b358:	defffd04 	addi	sp,sp,-12
8110b35c:	de00012e 	bgeu	sp,et,8110b364 <bSyncCtrOneShot+0xc>
8110b360:	003b68fa 	trap	3
8110b364:	dfc00215 	stw	ra,8(sp)
8110b368:	df000115 	stw	fp,4(sp)
8110b36c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110b370:	01000284 	movi	r4,10
8110b374:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b378:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
8110b37c:	e0bfff17 	ldw	r2,-4(fp)
8110b380:	108000b4 	orhi	r2,r2,2
8110b384:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110b388:	e17fff17 	ldw	r5,-4(fp)
8110b38c:	01000284 	movi	r4,10
8110b390:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b394:	00800044 	movi	r2,1
}
8110b398:	e037883a 	mov	sp,fp
8110b39c:	dfc00117 	ldw	ra,4(sp)
8110b3a0:	df000017 	ldw	fp,0(sp)
8110b3a4:	dec00204 	addi	sp,sp,8
8110b3a8:	f800283a 	ret

8110b3ac <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
8110b3ac:	defffd04 	addi	sp,sp,-12
8110b3b0:	de00012e 	bgeu	sp,et,8110b3b8 <bSyncCtrErrInj+0xc>
8110b3b4:	003b68fa 	trap	3
8110b3b8:	dfc00215 	stw	ra,8(sp)
8110b3bc:	df000115 	stw	fp,4(sp)
8110b3c0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110b3c4:	01000284 	movi	r4,10
8110b3c8:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b3cc:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
8110b3d0:	e0bfff17 	ldw	r2,-4(fp)
8110b3d4:	10800074 	orhi	r2,r2,1
8110b3d8:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110b3dc:	e17fff17 	ldw	r5,-4(fp)
8110b3e0:	01000284 	movi	r4,10
8110b3e4:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b3e8:	00800044 	movi	r2,1
}
8110b3ec:	e037883a 	mov	sp,fp
8110b3f0:	dfc00117 	ldw	ra,4(sp)
8110b3f4:	df000017 	ldw	fp,0(sp)
8110b3f8:	dec00204 	addi	sp,sp,8
8110b3fc:	f800283a 	ret

8110b400 <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
8110b400:	defffc04 	addi	sp,sp,-16
8110b404:	de00012e 	bgeu	sp,et,8110b40c <bSyncCtrSyncOutEnable+0xc>
8110b408:	003b68fa 	trap	3
8110b40c:	dfc00315 	stw	ra,12(sp)
8110b410:	df000215 	stw	fp,8(sp)
8110b414:	df000204 	addi	fp,sp,8
8110b418:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110b41c:	01000284 	movi	r4,10
8110b420:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b424:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110b428:	e0bfff17 	ldw	r2,-4(fp)
8110b42c:	1000051e 	bne	r2,zero,8110b444 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
8110b430:	e0fffe17 	ldw	r3,-8(fp)
8110b434:	00bfbfc4 	movi	r2,-257
8110b438:	1884703a 	and	r2,r3,r2
8110b43c:	e0bffe15 	stw	r2,-8(fp)
8110b440:	00000306 	br	8110b450 <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
8110b444:	e0bffe17 	ldw	r2,-8(fp)
8110b448:	10804014 	ori	r2,r2,256
8110b44c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110b450:	e17ffe17 	ldw	r5,-8(fp)
8110b454:	01000284 	movi	r4,10
8110b458:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b45c:	00800044 	movi	r2,1
}
8110b460:	e037883a 	mov	sp,fp
8110b464:	dfc00117 	ldw	ra,4(sp)
8110b468:	df000017 	ldw	fp,0(sp)
8110b46c:	dec00204 	addi	sp,sp,8
8110b470:	f800283a 	ret

8110b474 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
8110b474:	defffc04 	addi	sp,sp,-16
8110b478:	de00012e 	bgeu	sp,et,8110b480 <bSyncCtrCh1OutEnable+0xc>
8110b47c:	003b68fa 	trap	3
8110b480:	dfc00315 	stw	ra,12(sp)
8110b484:	df000215 	stw	fp,8(sp)
8110b488:	df000204 	addi	fp,sp,8
8110b48c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110b490:	01000284 	movi	r4,10
8110b494:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b498:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110b49c:	e0bfff17 	ldw	r2,-4(fp)
8110b4a0:	1000051e 	bne	r2,zero,8110b4b8 <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
8110b4a4:	e0fffe17 	ldw	r3,-8(fp)
8110b4a8:	00bfff84 	movi	r2,-2
8110b4ac:	1884703a 	and	r2,r3,r2
8110b4b0:	e0bffe15 	stw	r2,-8(fp)
8110b4b4:	00000306 	br	8110b4c4 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
8110b4b8:	e0bffe17 	ldw	r2,-8(fp)
8110b4bc:	10800054 	ori	r2,r2,1
8110b4c0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110b4c4:	e17ffe17 	ldw	r5,-8(fp)
8110b4c8:	01000284 	movi	r4,10
8110b4cc:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b4d0:	00800044 	movi	r2,1
}
8110b4d4:	e037883a 	mov	sp,fp
8110b4d8:	dfc00117 	ldw	ra,4(sp)
8110b4dc:	df000017 	ldw	fp,0(sp)
8110b4e0:	dec00204 	addi	sp,sp,8
8110b4e4:	f800283a 	ret

8110b4e8 <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
8110b4e8:	defffc04 	addi	sp,sp,-16
8110b4ec:	de00012e 	bgeu	sp,et,8110b4f4 <bSyncCtrCh2OutEnable+0xc>
8110b4f0:	003b68fa 	trap	3
8110b4f4:	dfc00315 	stw	ra,12(sp)
8110b4f8:	df000215 	stw	fp,8(sp)
8110b4fc:	df000204 	addi	fp,sp,8
8110b500:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110b504:	01000284 	movi	r4,10
8110b508:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b50c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110b510:	e0bfff17 	ldw	r2,-4(fp)
8110b514:	1000051e 	bne	r2,zero,8110b52c <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
8110b518:	e0fffe17 	ldw	r3,-8(fp)
8110b51c:	00bfff44 	movi	r2,-3
8110b520:	1884703a 	and	r2,r3,r2
8110b524:	e0bffe15 	stw	r2,-8(fp)
8110b528:	00000306 	br	8110b538 <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8110b52c:	e0bffe17 	ldw	r2,-8(fp)
8110b530:	10800094 	ori	r2,r2,2
8110b534:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110b538:	e17ffe17 	ldw	r5,-8(fp)
8110b53c:	01000284 	movi	r4,10
8110b540:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b544:	00800044 	movi	r2,1
}
8110b548:	e037883a 	mov	sp,fp
8110b54c:	dfc00117 	ldw	ra,4(sp)
8110b550:	df000017 	ldw	fp,0(sp)
8110b554:	dec00204 	addi	sp,sp,8
8110b558:	f800283a 	ret

8110b55c <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8110b55c:	defffc04 	addi	sp,sp,-16
8110b560:	de00012e 	bgeu	sp,et,8110b568 <bSyncCtrCh3OutEnable+0xc>
8110b564:	003b68fa 	trap	3
8110b568:	dfc00315 	stw	ra,12(sp)
8110b56c:	df000215 	stw	fp,8(sp)
8110b570:	df000204 	addi	fp,sp,8
8110b574:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110b578:	01000284 	movi	r4,10
8110b57c:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b580:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110b584:	e0bfff17 	ldw	r2,-4(fp)
8110b588:	1000051e 	bne	r2,zero,8110b5a0 <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8110b58c:	e0fffe17 	ldw	r3,-8(fp)
8110b590:	00bffec4 	movi	r2,-5
8110b594:	1884703a 	and	r2,r3,r2
8110b598:	e0bffe15 	stw	r2,-8(fp)
8110b59c:	00000306 	br	8110b5ac <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8110b5a0:	e0bffe17 	ldw	r2,-8(fp)
8110b5a4:	10800114 	ori	r2,r2,4
8110b5a8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110b5ac:	e17ffe17 	ldw	r5,-8(fp)
8110b5b0:	01000284 	movi	r4,10
8110b5b4:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b5b8:	00800044 	movi	r2,1
}
8110b5bc:	e037883a 	mov	sp,fp
8110b5c0:	dfc00117 	ldw	ra,4(sp)
8110b5c4:	df000017 	ldw	fp,0(sp)
8110b5c8:	dec00204 	addi	sp,sp,8
8110b5cc:	f800283a 	ret

8110b5d0 <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8110b5d0:	defffc04 	addi	sp,sp,-16
8110b5d4:	de00012e 	bgeu	sp,et,8110b5dc <bSyncCtrCh4OutEnable+0xc>
8110b5d8:	003b68fa 	trap	3
8110b5dc:	dfc00315 	stw	ra,12(sp)
8110b5e0:	df000215 	stw	fp,8(sp)
8110b5e4:	df000204 	addi	fp,sp,8
8110b5e8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110b5ec:	01000284 	movi	r4,10
8110b5f0:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b5f4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110b5f8:	e0bfff17 	ldw	r2,-4(fp)
8110b5fc:	1000051e 	bne	r2,zero,8110b614 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8110b600:	e0fffe17 	ldw	r3,-8(fp)
8110b604:	00bffdc4 	movi	r2,-9
8110b608:	1884703a 	and	r2,r3,r2
8110b60c:	e0bffe15 	stw	r2,-8(fp)
8110b610:	00000306 	br	8110b620 <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
8110b614:	e0bffe17 	ldw	r2,-8(fp)
8110b618:	10800214 	ori	r2,r2,8
8110b61c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110b620:	e17ffe17 	ldw	r5,-8(fp)
8110b624:	01000284 	movi	r4,10
8110b628:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b62c:	00800044 	movi	r2,1
}
8110b630:	e037883a 	mov	sp,fp
8110b634:	dfc00117 	ldw	ra,4(sp)
8110b638:	df000017 	ldw	fp,0(sp)
8110b63c:	dec00204 	addi	sp,sp,8
8110b640:	f800283a 	ret

8110b644 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
8110b644:	defffc04 	addi	sp,sp,-16
8110b648:	de00012e 	bgeu	sp,et,8110b650 <bSyncCtrCh5OutEnable+0xc>
8110b64c:	003b68fa 	trap	3
8110b650:	dfc00315 	stw	ra,12(sp)
8110b654:	df000215 	stw	fp,8(sp)
8110b658:	df000204 	addi	fp,sp,8
8110b65c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110b660:	01000284 	movi	r4,10
8110b664:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b668:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110b66c:	e0bfff17 	ldw	r2,-4(fp)
8110b670:	1000051e 	bne	r2,zero,8110b688 <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
8110b674:	e0fffe17 	ldw	r3,-8(fp)
8110b678:	00bffbc4 	movi	r2,-17
8110b67c:	1884703a 	and	r2,r3,r2
8110b680:	e0bffe15 	stw	r2,-8(fp)
8110b684:	00000306 	br	8110b694 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
8110b688:	e0bffe17 	ldw	r2,-8(fp)
8110b68c:	10800414 	ori	r2,r2,16
8110b690:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110b694:	e17ffe17 	ldw	r5,-8(fp)
8110b698:	01000284 	movi	r4,10
8110b69c:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b6a0:	00800044 	movi	r2,1
}
8110b6a4:	e037883a 	mov	sp,fp
8110b6a8:	dfc00117 	ldw	ra,4(sp)
8110b6ac:	df000017 	ldw	fp,0(sp)
8110b6b0:	dec00204 	addi	sp,sp,8
8110b6b4:	f800283a 	ret

8110b6b8 <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
8110b6b8:	defffc04 	addi	sp,sp,-16
8110b6bc:	de00012e 	bgeu	sp,et,8110b6c4 <bSyncCtrCh6OutEnable+0xc>
8110b6c0:	003b68fa 	trap	3
8110b6c4:	dfc00315 	stw	ra,12(sp)
8110b6c8:	df000215 	stw	fp,8(sp)
8110b6cc:	df000204 	addi	fp,sp,8
8110b6d0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110b6d4:	01000284 	movi	r4,10
8110b6d8:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b6dc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110b6e0:	e0bfff17 	ldw	r2,-4(fp)
8110b6e4:	1000051e 	bne	r2,zero,8110b6fc <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
8110b6e8:	e0fffe17 	ldw	r3,-8(fp)
8110b6ec:	00bff7c4 	movi	r2,-33
8110b6f0:	1884703a 	and	r2,r3,r2
8110b6f4:	e0bffe15 	stw	r2,-8(fp)
8110b6f8:	00000306 	br	8110b708 <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110b6fc:	e0bffe17 	ldw	r2,-8(fp)
8110b700:	10800814 	ori	r2,r2,32
8110b704:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110b708:	e17ffe17 	ldw	r5,-8(fp)
8110b70c:	01000284 	movi	r4,10
8110b710:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b714:	00800044 	movi	r2,1
}
8110b718:	e037883a 	mov	sp,fp
8110b71c:	dfc00117 	ldw	ra,4(sp)
8110b720:	df000017 	ldw	fp,0(sp)
8110b724:	dec00204 	addi	sp,sp,8
8110b728:	f800283a 	ret

8110b72c <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8110b72c:	defffc04 	addi	sp,sp,-16
8110b730:	de00012e 	bgeu	sp,et,8110b738 <bSyncCtrCh7OutEnable+0xc>
8110b734:	003b68fa 	trap	3
8110b738:	dfc00315 	stw	ra,12(sp)
8110b73c:	df000215 	stw	fp,8(sp)
8110b740:	df000204 	addi	fp,sp,8
8110b744:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110b748:	01000284 	movi	r4,10
8110b74c:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b750:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110b754:	e0bfff17 	ldw	r2,-4(fp)
8110b758:	1000051e 	bne	r2,zero,8110b770 <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8110b75c:	e0fffe17 	ldw	r3,-8(fp)
8110b760:	00bfefc4 	movi	r2,-65
8110b764:	1884703a 	and	r2,r3,r2
8110b768:	e0bffe15 	stw	r2,-8(fp)
8110b76c:	00000306 	br	8110b77c <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
8110b770:	e0bffe17 	ldw	r2,-8(fp)
8110b774:	10801014 	ori	r2,r2,64
8110b778:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110b77c:	e17ffe17 	ldw	r5,-8(fp)
8110b780:	01000284 	movi	r4,10
8110b784:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b788:	00800044 	movi	r2,1
}
8110b78c:	e037883a 	mov	sp,fp
8110b790:	dfc00117 	ldw	ra,4(sp)
8110b794:	df000017 	ldw	fp,0(sp)
8110b798:	dec00204 	addi	sp,sp,8
8110b79c:	f800283a 	ret

8110b7a0 <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8110b7a0:	defffc04 	addi	sp,sp,-16
8110b7a4:	de00012e 	bgeu	sp,et,8110b7ac <bSyncCtrCh8OutEnable+0xc>
8110b7a8:	003b68fa 	trap	3
8110b7ac:	dfc00315 	stw	ra,12(sp)
8110b7b0:	df000215 	stw	fp,8(sp)
8110b7b4:	df000204 	addi	fp,sp,8
8110b7b8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110b7bc:	01000284 	movi	r4,10
8110b7c0:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b7c4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110b7c8:	e0bfff17 	ldw	r2,-4(fp)
8110b7cc:	1000051e 	bne	r2,zero,8110b7e4 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8110b7d0:	e0fffe17 	ldw	r3,-8(fp)
8110b7d4:	00bfdfc4 	movi	r2,-129
8110b7d8:	1884703a 	and	r2,r3,r2
8110b7dc:	e0bffe15 	stw	r2,-8(fp)
8110b7e0:	00000306 	br	8110b7f0 <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
8110b7e4:	e0bffe17 	ldw	r2,-8(fp)
8110b7e8:	10802014 	ori	r2,r2,128
8110b7ec:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110b7f0:	e17ffe17 	ldw	r5,-8(fp)
8110b7f4:	01000284 	movi	r4,10
8110b7f8:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b7fc:	00800044 	movi	r2,1
}
8110b800:	e037883a 	mov	sp,fp
8110b804:	dfc00117 	ldw	ra,4(sp)
8110b808:	df000017 	ldw	fp,0(sp)
8110b80c:	dec00204 	addi	sp,sp,8
8110b810:	f800283a 	ret

8110b814 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
8110b814:	defffc04 	addi	sp,sp,-16
8110b818:	de00012e 	bgeu	sp,et,8110b820 <bSyncIrqEnableError+0xc>
8110b81c:	003b68fa 	trap	3
8110b820:	dfc00315 	stw	ra,12(sp)
8110b824:	df000215 	stw	fp,8(sp)
8110b828:	df000204 	addi	fp,sp,8
8110b82c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110b830:	01000044 	movi	r4,1
8110b834:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b838:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110b83c:	e0bfff17 	ldw	r2,-4(fp)
8110b840:	1000051e 	bne	r2,zero,8110b858 <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
8110b844:	e0fffe17 	ldw	r3,-8(fp)
8110b848:	00bfff44 	movi	r2,-3
8110b84c:	1884703a 	and	r2,r3,r2
8110b850:	e0bffe15 	stw	r2,-8(fp)
8110b854:	00000306 	br	8110b864 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
8110b858:	e0bffe17 	ldw	r2,-8(fp)
8110b85c:	10800094 	ori	r2,r2,2
8110b860:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110b864:	e17ffe17 	ldw	r5,-8(fp)
8110b868:	01000044 	movi	r4,1
8110b86c:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b870:	00800044 	movi	r2,1
}
8110b874:	e037883a 	mov	sp,fp
8110b878:	dfc00117 	ldw	ra,4(sp)
8110b87c:	df000017 	ldw	fp,0(sp)
8110b880:	dec00204 	addi	sp,sp,8
8110b884:	f800283a 	ret

8110b888 <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
8110b888:	defffc04 	addi	sp,sp,-16
8110b88c:	de00012e 	bgeu	sp,et,8110b894 <bSyncIrqEnableBlank+0xc>
8110b890:	003b68fa 	trap	3
8110b894:	dfc00315 	stw	ra,12(sp)
8110b898:	df000215 	stw	fp,8(sp)
8110b89c:	df000204 	addi	fp,sp,8
8110b8a0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110b8a4:	01000044 	movi	r4,1
8110b8a8:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b8ac:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110b8b0:	e0bfff17 	ldw	r2,-4(fp)
8110b8b4:	1000051e 	bne	r2,zero,8110b8cc <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
8110b8b8:	e0fffe17 	ldw	r3,-8(fp)
8110b8bc:	00bfff84 	movi	r2,-2
8110b8c0:	1884703a 	and	r2,r3,r2
8110b8c4:	e0bffe15 	stw	r2,-8(fp)
8110b8c8:	00000306 	br	8110b8d8 <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8110b8cc:	e0bffe17 	ldw	r2,-8(fp)
8110b8d0:	10800054 	ori	r2,r2,1
8110b8d4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110b8d8:	e17ffe17 	ldw	r5,-8(fp)
8110b8dc:	01000044 	movi	r4,1
8110b8e0:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b8e4:	00800044 	movi	r2,1
}
8110b8e8:	e037883a 	mov	sp,fp
8110b8ec:	dfc00117 	ldw	ra,4(sp)
8110b8f0:	df000017 	ldw	fp,0(sp)
8110b8f4:	dec00204 	addi	sp,sp,8
8110b8f8:	f800283a 	ret

8110b8fc <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110b8fc:	defffc04 	addi	sp,sp,-16
8110b900:	de00012e 	bgeu	sp,et,8110b908 <bSyncIrqFlagClrError+0xc>
8110b904:	003b68fa 	trap	3
8110b908:	dfc00315 	stw	ra,12(sp)
8110b90c:	df000215 	stw	fp,8(sp)
8110b910:	df000204 	addi	fp,sp,8
8110b914:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110b918:	01000084 	movi	r4,2
8110b91c:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b920:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110b924:	e0bfff17 	ldw	r2,-4(fp)
8110b928:	1000051e 	bne	r2,zero,8110b940 <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110b92c:	e0fffe17 	ldw	r3,-8(fp)
8110b930:	00bfff44 	movi	r2,-3
8110b934:	1884703a 	and	r2,r3,r2
8110b938:	e0bffe15 	stw	r2,-8(fp)
8110b93c:	00000306 	br	8110b94c <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110b940:	e0bffe17 	ldw	r2,-8(fp)
8110b944:	10800094 	ori	r2,r2,2
8110b948:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110b94c:	e17ffe17 	ldw	r5,-8(fp)
8110b950:	01000084 	movi	r4,2
8110b954:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b958:	00800044 	movi	r2,1
}
8110b95c:	e037883a 	mov	sp,fp
8110b960:	dfc00117 	ldw	ra,4(sp)
8110b964:	df000017 	ldw	fp,0(sp)
8110b968:	dec00204 	addi	sp,sp,8
8110b96c:	f800283a 	ret

8110b970 <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
8110b970:	defffc04 	addi	sp,sp,-16
8110b974:	de00012e 	bgeu	sp,et,8110b97c <bSyncIrqFlagClrBlank+0xc>
8110b978:	003b68fa 	trap	3
8110b97c:	dfc00315 	stw	ra,12(sp)
8110b980:	df000215 	stw	fp,8(sp)
8110b984:	df000204 	addi	fp,sp,8
8110b988:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110b98c:	01000084 	movi	r4,2
8110b990:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110b994:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110b998:	e0bfff17 	ldw	r2,-4(fp)
8110b99c:	1000051e 	bne	r2,zero,8110b9b4 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110b9a0:	e0fffe17 	ldw	r3,-8(fp)
8110b9a4:	00bfff84 	movi	r2,-2
8110b9a8:	1884703a 	and	r2,r3,r2
8110b9ac:	e0bffe15 	stw	r2,-8(fp)
8110b9b0:	00000306 	br	8110b9c0 <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110b9b4:	e0bffe17 	ldw	r2,-8(fp)
8110b9b8:	10800054 	ori	r2,r2,1
8110b9bc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110b9c0:	e17ffe17 	ldw	r5,-8(fp)
8110b9c4:	01000084 	movi	r4,2
8110b9c8:	110bb0c0 	call	8110bb0c <bSyncWriteReg>
	return TRUE;
8110b9cc:	00800044 	movi	r2,1
}
8110b9d0:	e037883a 	mov	sp,fp
8110b9d4:	dfc00117 	ldw	ra,4(sp)
8110b9d8:	df000017 	ldw	fp,0(sp)
8110b9dc:	dec00204 	addi	sp,sp,8
8110b9e0:	f800283a 	ret

8110b9e4 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
8110b9e4:	defffc04 	addi	sp,sp,-16
8110b9e8:	de00012e 	bgeu	sp,et,8110b9f0 <bSyncIrqFlagError+0xc>
8110b9ec:	003b68fa 	trap	3
8110b9f0:	dfc00315 	stw	ra,12(sp)
8110b9f4:	df000215 	stw	fp,8(sp)
8110b9f8:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110b9fc:	010000c4 	movi	r4,3
8110ba00:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110ba04:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
8110ba08:	e0bfff17 	ldw	r2,-4(fp)
8110ba0c:	1080008c 	andi	r2,r2,2
8110ba10:	10000326 	beq	r2,zero,8110ba20 <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
8110ba14:	00800044 	movi	r2,1
8110ba18:	e0bffe15 	stw	r2,-8(fp)
8110ba1c:	00000106 	br	8110ba24 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8110ba20:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110ba24:	e0bffe17 	ldw	r2,-8(fp)
}
8110ba28:	e037883a 	mov	sp,fp
8110ba2c:	dfc00117 	ldw	ra,4(sp)
8110ba30:	df000017 	ldw	fp,0(sp)
8110ba34:	dec00204 	addi	sp,sp,8
8110ba38:	f800283a 	ret

8110ba3c <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8110ba3c:	defffc04 	addi	sp,sp,-16
8110ba40:	de00012e 	bgeu	sp,et,8110ba48 <bSyncIrqFlagBlank+0xc>
8110ba44:	003b68fa 	trap	3
8110ba48:	dfc00315 	stw	ra,12(sp)
8110ba4c:	df000215 	stw	fp,8(sp)
8110ba50:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110ba54:	010000c4 	movi	r4,3
8110ba58:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110ba5c:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
8110ba60:	e0bfff17 	ldw	r2,-4(fp)
8110ba64:	1080004c 	andi	r2,r2,1
8110ba68:	10000326 	beq	r2,zero,8110ba78 <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8110ba6c:	00800044 	movi	r2,1
8110ba70:	e0bffe15 	stw	r2,-8(fp)
8110ba74:	00000106 	br	8110ba7c <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
8110ba78:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110ba7c:	e0bffe17 	ldw	r2,-8(fp)
}
8110ba80:	e037883a 	mov	sp,fp
8110ba84:	dfc00117 	ldw	ra,4(sp)
8110ba88:	df000017 	ldw	fp,0(sp)
8110ba8c:	dec00204 	addi	sp,sp,8
8110ba90:	f800283a 	ret

8110ba94 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
8110ba94:	defffd04 	addi	sp,sp,-12
8110ba98:	de00012e 	bgeu	sp,et,8110baa0 <uliSyncGetCtr+0xc>
8110ba9c:	003b68fa 	trap	3
8110baa0:	dfc00215 	stw	ra,8(sp)
8110baa4:	df000115 	stw	fp,4(sp)
8110baa8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110baac:	01000284 	movi	r4,10
8110bab0:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110bab4:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bab8:	e0bfff17 	ldw	r2,-4(fp)
}
8110babc:	e037883a 	mov	sp,fp
8110bac0:	dfc00117 	ldw	ra,4(sp)
8110bac4:	df000017 	ldw	fp,0(sp)
8110bac8:	dec00204 	addi	sp,sp,8
8110bacc:	f800283a 	ret

8110bad0 <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8110bad0:	defffd04 	addi	sp,sp,-12
8110bad4:	de00012e 	bgeu	sp,et,8110badc <uliSyncReadStatus+0xc>
8110bad8:	003b68fa 	trap	3
8110badc:	dfc00215 	stw	ra,8(sp)
8110bae0:	df000115 	stw	fp,4(sp)
8110bae4:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110bae8:	0009883a 	mov	r4,zero
8110baec:	110bb680 	call	8110bb68 <uliSyncReadReg>
8110baf0:	e0bfff15 	stw	r2,-4(fp)
	return aux;
8110baf4:	e0bfff17 	ldw	r2,-4(fp)
}
8110baf8:	e037883a 	mov	sp,fp
8110bafc:	dfc00117 	ldw	ra,4(sp)
8110bb00:	df000017 	ldw	fp,0(sp)
8110bb04:	dec00204 	addi	sp,sp,8
8110bb08:	f800283a 	ret

8110bb0c <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110bb0c:	defffc04 	addi	sp,sp,-16
8110bb10:	de00012e 	bgeu	sp,et,8110bb18 <bSyncWriteReg+0xc>
8110bb14:	003b68fa 	trap	3
8110bb18:	df000315 	stw	fp,12(sp)
8110bb1c:	df000304 	addi	fp,sp,12
8110bb20:	e13ffe15 	stw	r4,-8(fp)
8110bb24:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110bb28:	00a00034 	movhi	r2,32768
8110bb2c:	10810004 	addi	r2,r2,1024
8110bb30:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
8110bb34:	e0bffe17 	ldw	r2,-8(fp)
8110bb38:	1085883a 	add	r2,r2,r2
8110bb3c:	1085883a 	add	r2,r2,r2
8110bb40:	1007883a 	mov	r3,r2
8110bb44:	e0bffd17 	ldw	r2,-12(fp)
8110bb48:	10c5883a 	add	r2,r2,r3
8110bb4c:	e0ffff17 	ldw	r3,-4(fp)
8110bb50:	10c00015 	stw	r3,0(r2)
	return TRUE;
8110bb54:	00800044 	movi	r2,1
}
8110bb58:	e037883a 	mov	sp,fp
8110bb5c:	df000017 	ldw	fp,0(sp)
8110bb60:	dec00104 	addi	sp,sp,4
8110bb64:	f800283a 	ret

8110bb68 <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
8110bb68:	defffc04 	addi	sp,sp,-16
8110bb6c:	de00012e 	bgeu	sp,et,8110bb74 <uliSyncReadReg+0xc>
8110bb70:	003b68fa 	trap	3
8110bb74:	df000315 	stw	fp,12(sp)
8110bb78:	df000304 	addi	fp,sp,12
8110bb7c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110bb80:	00a00034 	movhi	r2,32768
8110bb84:	10810004 	addi	r2,r2,1024
8110bb88:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8110bb8c:	e0bfff17 	ldw	r2,-4(fp)
8110bb90:	1085883a 	add	r2,r2,r2
8110bb94:	1085883a 	add	r2,r2,r2
8110bb98:	1007883a 	mov	r3,r2
8110bb9c:	e0bffd17 	ldw	r2,-12(fp)
8110bba0:	10c5883a 	add	r2,r2,r3
8110bba4:	10800017 	ldw	r2,0(r2)
8110bba8:	e0bffe15 	stw	r2,-8(fp)
	return value;
8110bbac:	e0bffe17 	ldw	r2,-8(fp)
}
8110bbb0:	e037883a 	mov	sp,fp
8110bbb4:	df000017 	ldw	fp,0(sp)
8110bbb8:	dec00104 	addi	sp,sp,4
8110bbbc:	f800283a 	ret

8110bbc0 <uliPerCalcPeriodMs>:

/*
 * Return the necessary PER value for a
 * Sync Signal period in usiPeriodMs ms.
 */
alt_u32 uliPerCalcPeriodMs(alt_u16 usiPeriodMs) {
8110bbc0:	defffc04 	addi	sp,sp,-16
8110bbc4:	de00012e 	bgeu	sp,et,8110bbcc <uliPerCalcPeriodMs+0xc>
8110bbc8:	003b68fa 	trap	3
8110bbcc:	dfc00315 	stw	ra,12(sp)
8110bbd0:	df000215 	stw	fp,8(sp)
8110bbd4:	df000204 	addi	fp,sp,8
8110bbd8:	2005883a 	mov	r2,r4
8110bbdc:	e0bfff0d 	sth	r2,-4(fp)
	 * Period[ms] / 20e-6 = Period[ms] * 5e+4
	 * PER = Period[ms] * 5e+4
	 */

	alt_u32 uliPer;
	uliPer = usiPeriodMs * 5e+4;
8110bbe0:	e0bfff0b 	ldhu	r2,-4(fp)
8110bbe4:	1009883a 	mov	r4,r2
8110bbe8:	111a7740 	call	8111a774 <__floatsidf>
8110bbec:	1011883a 	mov	r8,r2
8110bbf0:	1813883a 	mov	r9,r3
8110bbf4:	000d883a 	mov	r6,zero
8110bbf8:	01d03a34 	movhi	r7,16616
8110bbfc:	39da8004 	addi	r7,r7,27136
8110bc00:	4009883a 	mov	r4,r8
8110bc04:	480b883a 	mov	r5,r9
8110bc08:	11196d00 	call	811196d0 <__muldf3>
8110bc0c:	1009883a 	mov	r4,r2
8110bc10:	180b883a 	mov	r5,r3
8110bc14:	2005883a 	mov	r2,r4
8110bc18:	2807883a 	mov	r3,r5
8110bc1c:	1009883a 	mov	r4,r2
8110bc20:	180b883a 	mov	r5,r3
8110bc24:	1118c340 	call	81118c34 <__fixunsdfsi>
8110bc28:	e0bffe15 	stw	r2,-8(fp)

	return uliPer;
8110bc2c:	e0bffe17 	ldw	r2,-8(fp)
}
8110bc30:	e037883a 	mov	sp,fp
8110bc34:	dfc00117 	ldw	ra,4(sp)
8110bc38:	df000017 	ldw	fp,0(sp)
8110bc3c:	dec00204 	addi	sp,sp,8
8110bc40:	f800283a 	ret

8110bc44 <vDataControlTask>:


#include "data_control_task.h"

/* 0% Ready! */
void vDataControlTask(void *task_data) {
8110bc44:	defff804 	addi	sp,sp,-32
8110bc48:	de00012e 	bgeu	sp,et,8110bc50 <vDataControlTask+0xc>
8110bc4c:	003b68fa 	trap	3
8110bc50:	dfc00715 	stw	ra,28(sp)
8110bc54:	df000615 	stw	fp,24(sp)
8110bc58:	df000604 	addi	fp,sp,24
8110bc5c:	e13ffd15 	stw	r4,-12(fp)
	tQMask uiCmdDTC;
	INT8U error_code;
	TNData_Control *pxDataC;


	pxDataC = (TNData_Control *) task_data;
8110bc60:	e0bffd17 	ldw	r2,-12(fp)
8110bc64:	e0bffa15 	stw	r2,-24(fp)

	#if DEBUG_ON
        debug(fp,"Data Controller Task. (Task on)\n");
    #endif

    pxDataC->bUpdateComplete = TRUE;
8110bc68:	e0bffa17 	ldw	r2,-24(fp)
8110bc6c:	00c00044 	movi	r3,1
8110bc70:	10c00515 	stw	r3,20(r2)

    error_code = OSQFlush(xQMaskDataCtrl);
8110bc74:	d0a05f17 	ldw	r2,-32388(gp)
8110bc78:	1009883a 	mov	r4,r2
8110bc7c:	11365c00 	call	811365c0 <OSQFlush>
8110bc80:	e0bffc05 	stb	r2,-16(fp)
	if ( error_code != OS_NO_ERR ) {
8110bc84:	e0bffc03 	ldbu	r2,-16(fp)
8110bc88:	10803fcc 	andi	r2,r2,255
8110bc8c:	10000126 	beq	r2,zero,8110bc94 <vDataControlTask+0x50>
		vFailFlushQueueData();
8110bc90:	11173640 	call	81117364 <vFailFlushQueueData>
	}

	for (;;) {

		uiCmdDTC.ulWord = (unsigned int)OSQPend(xQMaskDataCtrl, 0, &error_code); /* Blocking operation */
8110bc94:	d0a05f17 	ldw	r2,-32388(gp)
8110bc98:	e0fffc04 	addi	r3,fp,-16
8110bc9c:	180d883a 	mov	r6,r3
8110bca0:	000b883a 	mov	r5,zero
8110bca4:	1009883a 	mov	r4,r2
8110bca8:	11366800 	call	81136680 <OSQPend>
8110bcac:	e0bffb15 	stw	r2,-20(fp)
			} else {

				/* todo: For now, do nothing */
			}
		}
		OSTimeDlyHMSM(0, 0, 5, 0); /*todo:Tirar depois do debug*/
8110bcb0:	000f883a 	mov	r7,zero
8110bcb4:	01800144 	movi	r6,5
8110bcb8:	000b883a 	mov	r5,zero
8110bcbc:	0009883a 	mov	r4,zero
8110bcc0:	11395100 	call	81139510 <OSTimeDlyHMSM>
	}
8110bcc4:	003ff306 	br	8110bc94 <__reset+0xfb0ebc94>

8110bcc8 <vFeeTask>:

const char *cTemp[64];
unsigned char ucIterationSide;


void vFeeTask(void *task_data) {
8110bcc8:	defff304 	addi	sp,sp,-52
8110bccc:	de00012e 	bgeu	sp,et,8110bcd4 <vFeeTask+0xc>
8110bcd0:	003b68fa 	trap	3
8110bcd4:	dfc00c15 	stw	ra,48(sp)
8110bcd8:	df000b15 	stw	fp,44(sp)
8110bcdc:	df000b04 	addi	fp,sp,44
8110bce0:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = FALSE;
8110bce4:	e03ffa15 	stw	zero,-24(fp)
	alt_u16 *pusiHK;
	alt_u32 *pusiHK32;
	unsigned char ucIL;


	pxNFee = ( TNFee * ) task_data;
8110bce8:	e0bfff17 	ldw	r2,-4(fp)
8110bcec:	d0a05315 	stw	r2,-32436(gp)
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
8110bcf0:	d0a05317 	ldw	r2,-32436(gp)
8110bcf4:	10802c17 	ldw	r2,176(r2)
8110bcf8:	10c00368 	cmpgeui	r3,r2,13
8110bcfc:	1804391e 	bne	r3,zero,8110cde4 <vFeeTask+0x111c>
8110bd00:	100690ba 	slli	r3,r2,2
8110bd04:	00a04474 	movhi	r2,33041
8110bd08:	10af4604 	addi	r2,r2,-17128
8110bd0c:	1885883a 	add	r2,r3,r2
8110bd10:	10800017 	ldw	r2,0(r2)
8110bd14:	1000683a 	jmp	r2
8110bd18:	8110bd4c 	andi	r4,r16,17141
8110bd1c:	8110c3b4 	orhi	r4,r16,17166
8110bd20:	8110c410 	cmplti	r4,r16,17168
8110bd24:	8110c54c 	andi	r4,r16,17173
8110bd28:	8110ca40 	call	88110ca4 <__reset+0x20f0ca4>
8110bd2c:	8110c210 	cmplti	r4,r16,17160
8110bd30:	8110c420 	cmpeqi	r4,r16,17168
8110bd34:	8110c954 	ori	r4,r16,17189
8110bd38:	8110cde4 	muli	r4,r16,17207
8110bd3c:	8110cde4 	muli	r4,r16,17207
8110bd40:	8110c5a8 	cmpgeui	r4,r16,17174
8110bd44:	8110cd14 	ori	r4,r16,17204
8110bd48:	8110cd88 	cmpgei	r4,r16,17206
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110bd4c:	d0a05317 	ldw	r2,-32436(gp)
8110bd50:	10800003 	ldbu	r2,0(r2)
8110bd54:	10803fcc 	andi	r2,r2,255
8110bd58:	1085883a 	add	r2,r2,r2
8110bd5c:	1087883a 	add	r3,r2,r2
8110bd60:	d0a06904 	addi	r2,gp,-32348
8110bd64:	1885883a 	add	r2,r3,r2
8110bd68:	10800017 	ldw	r2,0(r2)
8110bd6c:	1009883a 	mov	r4,r2
8110bd70:	11365c00 	call	811365c0 <OSQFlush>
8110bd74:	e0bffd45 	stb	r2,-11(fp)
				if ( error_code != OS_NO_ERR ) {
8110bd78:	e0bffd43 	ldbu	r2,-11(fp)
8110bd7c:	10803fcc 	andi	r2,r2,255
8110bd80:	10000126 	beq	r2,zero,8110bd88 <vFeeTask+0xc0>
					vFailFlushNFEEQueue();
8110bd84:	11173b40 	call	811173b4 <vFailFlushNFEEQueue>
				}

				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110bd88:	d0a05317 	ldw	r2,-32436(gp)
8110bd8c:	10800003 	ldbu	r2,0(r2)
8110bd90:	10803fcc 	andi	r2,r2,255
8110bd94:	1085883a 	add	r2,r2,r2
8110bd98:	1087883a 	add	r3,r2,r2
8110bd9c:	d0a05c04 	addi	r2,gp,-32400
8110bda0:	1885883a 	add	r2,r3,r2
8110bda4:	10800017 	ldw	r2,0(r2)
8110bda8:	1009883a 	mov	r4,r2
8110bdac:	11365c00 	call	811365c0 <OSQFlush>
8110bdb0:	e0bffd45 	stb	r2,-11(fp)
				if ( error_code != OS_NO_ERR ) {
8110bdb4:	e0bffd43 	ldbu	r2,-11(fp)
8110bdb8:	10803fcc 	andi	r2,r2,255
8110bdbc:	10000126 	beq	r2,zero,8110bdc4 <vFeeTask+0xfc>
					vFailFlushNFEEQueue();
8110bdc0:	11173b40 	call	811173b4 <vFailFlushNFEEQueue>
				}				

				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110bdc4:	d0a05317 	ldw	r2,-32436(gp)
8110bdc8:	10803304 	addi	r2,r2,204
8110bdcc:	1009883a 	mov	r4,r2
8110bdd0:	1102d4c0 	call	81102d4c <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFee->xCcdInfo.usiHalfWidth + pxNFee->xCcdInfo.usiSPrescanN + pxNFee->xCcdInfo.usiSOverscanN;
8110bdd4:	d0a05317 	ldw	r2,-32436(gp)
8110bdd8:	d0e05317 	ldw	r3,-32436(gp)
8110bddc:	1900308b 	ldhu	r4,194(r3)
8110bde0:	d0e05317 	ldw	r3,-32436(gp)
8110bde4:	18c02f0b 	ldhu	r3,188(r3)
8110bde8:	20c7883a 	add	r3,r4,r3
8110bdec:	1809883a 	mov	r4,r3
8110bdf0:	d0e05317 	ldw	r3,-32436(gp)
8110bdf4:	18c02f8b 	ldhu	r3,190(r3)
8110bdf8:	20c7883a 	add	r3,r4,r3
8110bdfc:	10c0340d 	sth	r3,208(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFee->xCcdInfo.usiHeight + pxNFee->xCcdInfo.usiOLN;
8110be00:	d0a05317 	ldw	r2,-32436(gp)
8110be04:	d0e05317 	ldw	r3,-32436(gp)
8110be08:	1900310b 	ldhu	r4,196(r3)
8110be0c:	d0e05317 	ldw	r3,-32436(gp)
8110be10:	18c0300b 	ldhu	r3,192(r3)
8110be14:	20c7883a 	add	r3,r4,r3
8110be18:	10c0348d 	sth	r3,210(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFee->xCcdInfo.usiHeight;
8110be1c:	d0a05317 	ldw	r2,-32436(gp)
8110be20:	d0e05317 	ldw	r3,-32436(gp)
8110be24:	18c0310b 	ldhu	r3,196(r3)
8110be28:	10c0350d 	sth	r3,212(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFee->xCcdInfo.usiOLN;
8110be2c:	d0a05317 	ldw	r2,-32436(gp)
8110be30:	d0e05317 	ldw	r3,-32436(gp)
8110be34:	18c0300b 	ldhu	r3,192(r3)
8110be38:	10c0358d 	sth	r3,214(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = 32768;
8110be3c:	d0a05317 	ldw	r2,-32436(gp)
8110be40:	00e00004 	movi	r3,-32768
8110be44:	10c0360d 	sth	r3,216(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = 0; /* 32 KB */
8110be48:	d0a05317 	ldw	r2,-32436(gp)
8110be4c:	100036c5 	stb	zero,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110be50:	d0a05317 	ldw	r2,-32436(gp)
8110be54:	00c00044 	movi	r3,1
8110be58:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110be5c:	d0a05317 	ldw	r2,-32436(gp)
8110be60:	10803304 	addi	r2,r2,204
8110be64:	1009883a 	mov	r4,r2
8110be68:	1102b200 	call	81102b20 <bDpktSetPacketConfig>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110be6c:	d0a05317 	ldw	r2,-32436(gp)
8110be70:	10804304 	addi	r2,r2,268
8110be74:	1009883a 	mov	r4,r2
8110be78:	11077e80 	call	811077e8 <bRmapGetRmapMemHKArea>
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE = 0xFF00;
8110be7c:	d0a05317 	ldw	r2,-32436(gp)
8110be80:	00ffc004 	movi	r3,-256
8110be84:	10c0690d 	sth	r3,420(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodF = 0xFF01;
8110be88:	d0a05317 	ldw	r2,-32436(gp)
8110be8c:	00ffc044 	movi	r3,-255
8110be90:	10c0698d 	sth	r3,422(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VrdMon = 0xFF02;
8110be94:	d0a05317 	ldw	r2,-32436(gp)
8110be98:	00ffc084 	movi	r3,-254
8110be9c:	10c06a0d 	sth	r3,424(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodE = 0xFF03;
8110bea0:	d0a05317 	ldw	r2,-32436(gp)
8110bea4:	00ffc0c4 	movi	r3,-253
8110bea8:	10c06a8d 	sth	r3,426(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VodF = 0xFF04;
8110beac:	d0a05317 	ldw	r2,-32436(gp)
8110beb0:	00ffc104 	movi	r3,-252
8110beb4:	10c06b0d 	sth	r3,428(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2VrdMon = 0xFF05;
8110beb8:	d0a05317 	ldw	r2,-32436(gp)
8110bebc:	00ffc144 	movi	r3,-251
8110bec0:	10c06b8d 	sth	r3,430(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodE = 0xFF06;
8110bec4:	d0a05317 	ldw	r2,-32436(gp)
8110bec8:	00ffc184 	movi	r3,-250
8110becc:	10c06c0d 	sth	r3,432(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VodF = 0xFF07;
8110bed0:	d0a05317 	ldw	r2,-32436(gp)
8110bed4:	00ffc1c4 	movi	r3,-249
8110bed8:	10c06c8d 	sth	r3,434(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3VrdMon = 0xFF08;
8110bedc:	d0a05317 	ldw	r2,-32436(gp)
8110bee0:	00ffc204 	movi	r3,-248
8110bee4:	10c06d0d 	sth	r3,436(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodE  = 0xFF09;
8110bee8:	d0a05317 	ldw	r2,-32436(gp)
8110beec:	00ffc244 	movi	r3,-247
8110bef0:	10c06d8d 	sth	r3,438(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VodF = 0xFF0A;
8110bef4:	d0a05317 	ldw	r2,-32436(gp)
8110bef8:	00ffc284 	movi	r3,-246
8110befc:	10c06e0d 	sth	r3,440(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4VrdMon = 0xFF0B;
8110bf00:	d0a05317 	ldw	r2,-32436(gp)
8110bf04:	00ffc2c4 	movi	r3,-245
8110bf08:	10c06e8d 	sth	r3,442(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccd = 0xFF0C;
8110bf0c:	d0a05317 	ldw	r2,-32436(gp)
8110bf10:	00ffc304 	movi	r3,-244
8110bf14:	10c06f0d 	sth	r3,444(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclk = 0xFF0D;
8110bf18:	d0a05317 	ldw	r2,-32436(gp)
8110bf1c:	00ffc344 	movi	r3,-243
8110bf20:	10c06f8d 	sth	r3,446(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclk = 0xFF0E;
8110bf24:	d0a05317 	ldw	r2,-32436(gp)
8110bf28:	00ffc384 	movi	r3,-242
8110bf2c:	10c0700d 	sth	r3,448(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVrclkLow = 0xFF0F;
8110bf30:	d0a05317 	ldw	r2,-32436(gp)
8110bf34:	00ffc3c4 	movi	r3,-241
8110bf38:	10c0708d 	sth	r3,450(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbPos = 0xFF10;
8110bf3c:	d0a05317 	ldw	r2,-32436(gp)
8110bf40:	00ffc404 	movi	r3,-240
8110bf44:	10c0710d 	sth	r3,452(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vbNeg = 0xFF11;
8110bf48:	d0a05317 	ldw	r2,-32436(gp)
8110bf4c:	00ffc444 	movi	r3,-239
8110bf50:	10c0718d 	sth	r3,454(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vbPos = 0xFF12;
8110bf54:	d0a05317 	ldw	r2,-32436(gp)
8110bf58:	00ffc484 	movi	r3,-238
8110bf5c:	10c0720d 	sth	r3,456(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vaPos = 0xFF13;
8110bf60:	d0a05317 	ldw	r2,-32436(gp)
8110bf64:	00ffc4c4 	movi	r3,-237
8110bf68:	10c0728d 	sth	r3,458(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk33vdPos = 0xFF14;
8110bf6c:	d0a05317 	ldw	r2,-32436(gp)
8110bf70:	00ffc504 	movi	r3,-236
8110bf74:	10c0730d 	sth	r3,460(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk25vdPos = 0xFF15;
8110bf78:	d0a05317 	ldw	r2,-32436(gp)
8110bf7c:	00ffc544 	movi	r3,-235
8110bf80:	10c0738d 	sth	r3,462(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk15vdPos = 0xFF16;
8110bf84:	d0a05317 	ldw	r2,-32436(gp)
8110bf88:	00ffc584 	movi	r3,-234
8110bf8c:	10c0740d 	sth	r3,464(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHk5vref = 0xFF17;
8110bf90:	d0a05317 	ldw	r2,-32436(gp)
8110bf94:	00ffc5c4 	movi	r3,-233
8110bf98:	10c0748d 	sth	r3,466(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVccdPosRaw = 0xFF18;
8110bf9c:	d0a05317 	ldw	r2,-32436(gp)
8110bfa0:	00ffc604 	movi	r3,-232
8110bfa4:	10c0750d 	sth	r3,468(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVclkPosRaw = 0xFF19;
8110bfa8:	d0a05317 	ldw	r2,-32436(gp)
8110bfac:	00ffc644 	movi	r3,-231
8110bfb0:	10c0758d 	sth	r3,470(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan1PosRaw = 0xFF1A;
8110bfb4:	d0a05317 	ldw	r2,-32436(gp)
8110bfb8:	00ffc684 	movi	r3,-230
8110bfbc:	10c0760d 	sth	r3,472(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan3NegRaw = 0xFF1B;
8110bfc0:	d0a05317 	ldw	r2,-32436(gp)
8110bfc4:	00ffc6c4 	movi	r3,-229
8110bfc8:	10c0768d 	sth	r3,474(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVan2PosRaw = 0xFF1C;
8110bfcc:	d0a05317 	ldw	r2,-32436(gp)
8110bfd0:	00ffc704 	movi	r3,-228
8110bfd4:	10c0770d 	sth	r3,476(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigFpgaRaw = 0xFF1D;
8110bfd8:	d0a05317 	ldw	r2,-32436(gp)
8110bfdc:	00ffc744 	movi	r3,-227
8110bfe0:	10c0778d 	sth	r3,478(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkVdigSpwRaw = 0xFF1E;
8110bfe4:	d0a05317 	ldw	r2,-32436(gp)
8110bfe8:	00ffc784 	movi	r3,-226
8110bfec:	10c0780d 	sth	r3,480(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkViclkLow = 0xFF1F;
8110bff0:	d0a05317 	ldw	r2,-32436(gp)
8110bff4:	00ffc7c4 	movi	r3,-225
8110bff8:	10c0788d 	sth	r3,482(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAE = 0xFF20;
8110bffc:	d0a05317 	ldw	r2,-32436(gp)
8110c000:	00ffc804 	movi	r3,-224
8110c004:	10c0790d 	sth	r3,484(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkAdcTempAF = 0xFF21;
8110c008:	d0a05317 	ldw	r2,-32436(gp)
8110c00c:	00ffc844 	movi	r3,-223
8110c010:	10c0798d 	sth	r3,486(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1Temp = 0xFF22;
8110c014:	d0a05317 	ldw	r2,-32436(gp)
8110c018:	00ffc884 	movi	r3,-222
8110c01c:	10c07a0d 	sth	r3,488(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd2Temp = 0xFF23;
8110c020:	d0a05317 	ldw	r2,-32436(gp)
8110c024:	00ffc8c4 	movi	r3,-221
8110c028:	10c07a8d 	sth	r3,490(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd3Temp = 0xFF24;
8110c02c:	d0a05317 	ldw	r2,-32436(gp)
8110c030:	00ffc904 	movi	r3,-220
8110c034:	10c07b0d 	sth	r3,492(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd4Temp = 0xFF25;
8110c038:	d0a05317 	ldw	r2,-32436(gp)
8110c03c:	00ffc944 	movi	r3,-219
8110c040:	10c07b8d 	sth	r3,494(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkWp605Spare = 0xFF26;
8110c044:	d0a05317 	ldw	r2,-32436(gp)
8110c048:	00ffc984 	movi	r3,-218
8110c04c:	10c07c0d 	sth	r3,496(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA0 = 0xFF27;
8110c050:	d0a05317 	ldw	r2,-32436(gp)
8110c054:	00ffc9c4 	movi	r3,-217
8110c058:	10c07c8d 	sth	r3,498(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA1 = 0xFF28;
8110c05c:	d0a05317 	ldw	r2,-32436(gp)
8110c060:	00ffca04 	movi	r3,-216
8110c064:	10c07d0d 	sth	r3,500(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA2 = 0xFF29;
8110c068:	d0a05317 	ldw	r2,-32436(gp)
8110c06c:	00ffca44 	movi	r3,-215
8110c070:	10c07d8d 	sth	r3,502(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA3 = 0xFF2A;
8110c074:	d0a05317 	ldw	r2,-32436(gp)
8110c078:	00ffca84 	movi	r3,-214
8110c07c:	10c07e0d 	sth	r3,504(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA4 = 0xFF2B;
8110c080:	d0a05317 	ldw	r2,-32436(gp)
8110c084:	00ffcac4 	movi	r3,-213
8110c088:	10c07e8d 	sth	r3,506(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA5 = 0xFF2C;
8110c08c:	d0a05317 	ldw	r2,-32436(gp)
8110c090:	00ffcb04 	movi	r3,-212
8110c094:	10c07f0d 	sth	r3,508(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA6 = 0xFF2D;
8110c098:	d0a05317 	ldw	r2,-32436(gp)
8110c09c:	00ffcb44 	movi	r3,-211
8110c0a0:	10c07f8d 	sth	r3,510(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA7 = 0xFF2E;
8110c0a4:	d0a05317 	ldw	r2,-32436(gp)
8110c0a8:	00ffcb84 	movi	r3,-210
8110c0ac:	10c0800d 	sth	r3,512(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA8 = 0xFF2F;
8110c0b0:	d0a05317 	ldw	r2,-32436(gp)
8110c0b4:	00ffcbc4 	movi	r3,-209
8110c0b8:	10c0808d 	sth	r3,514(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA9 = 0xFF30;
8110c0bc:	d0a05317 	ldw	r2,-32436(gp)
8110c0c0:	00ffcc04 	movi	r3,-208
8110c0c4:	10c0810d 	sth	r3,516(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA10 = 0xFF31;
8110c0c8:	d0a05317 	ldw	r2,-32436(gp)
8110c0cc:	00ffcc44 	movi	r3,-207
8110c0d0:	10c0818d 	sth	r3,518(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA11 = 0xFF32;
8110c0d4:	d0a05317 	ldw	r2,-32436(gp)
8110c0d8:	00ffcc84 	movi	r3,-206
8110c0dc:	10c0820d 	sth	r3,520(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA12 = 0xFF33;
8110c0e0:	d0a05317 	ldw	r2,-32436(gp)
8110c0e4:	00ffccc4 	movi	r3,-205
8110c0e8:	10c0828d 	sth	r3,522(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA13 = 0xFF34;
8110c0ec:	d0a05317 	ldw	r2,-32436(gp)
8110c0f0:	00ffcd04 	movi	r3,-204
8110c0f4:	10c0830d 	sth	r3,524(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA14 = 0xFF35;
8110c0f8:	d0a05317 	ldw	r2,-32436(gp)
8110c0fc:	00ffcd44 	movi	r3,-203
8110c100:	10c0838d 	sth	r3,526(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiLowresPrtA15 = 0xFF36;
8110c104:	d0a05317 	ldw	r2,-32436(gp)
8110c108:	00ffcd84 	movi	r3,-202
8110c10c:	10c0840d 	sth	r3,528(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt0 = 0xFF37;
8110c110:	d0a05317 	ldw	r2,-32436(gp)
8110c114:	00ffcdc4 	movi	r3,-201
8110c118:	10c0848d 	sth	r3,530(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt1 = 0xFF38;
8110c11c:	d0a05317 	ldw	r2,-32436(gp)
8110c120:	00ffce04 	movi	r3,-200
8110c124:	10c0850d 	sth	r3,532(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt2 = 0xFF39;
8110c128:	d0a05317 	ldw	r2,-32436(gp)
8110c12c:	00ffce44 	movi	r3,-199
8110c130:	10c0858d 	sth	r3,534(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt3 = 0xFF3A;
8110c134:	d0a05317 	ldw	r2,-32436(gp)
8110c138:	00ffce84 	movi	r3,-198
8110c13c:	10c0860d 	sth	r3,536(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt4 = 0xFF3B;
8110c140:	d0a05317 	ldw	r2,-32436(gp)
8110c144:	00ffcec4 	movi	r3,-197
8110c148:	10c0868d 	sth	r3,538(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt5 = 0xFF3C;
8110c14c:	d0a05317 	ldw	r2,-32436(gp)
8110c150:	00ffcf04 	movi	r3,-196
8110c154:	10c0870d 	sth	r3,540(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt6 = 0xFF3D;
8110c158:	d0a05317 	ldw	r2,-32436(gp)
8110c15c:	00ffcf44 	movi	r3,-195
8110c160:	10c0878d 	sth	r3,542(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiSelHiresPrt7 = 0xFF3E;
8110c164:	d0a05317 	ldw	r2,-32436(gp)
8110c168:	00ffcf84 	movi	r3,-194
8110c16c:	10c0880d 	sth	r3,544(r2)
				pxNFee->xChannel.xRmap.xRmapMemHKArea.usiZeroHiresAmp = 0xFF3F;
8110c170:	d0a05317 	ldw	r2,-32436(gp)
8110c174:	00ffcfc4 	movi	r3,-193
8110c178:	10c0888d 	sth	r3,546(r2)
				bRmapSetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110c17c:	d0a05317 	ldw	r2,-32436(gp)
8110c180:	10804304 	addi	r2,r2,268
8110c184:	1009883a 	mov	r4,r2
8110c188:	110679c0 	call	8110679c <bRmapSetRmapMemHKArea>


				vLoadCtemp();
8110c18c:	110e44c0 	call	8110e44c <vLoadCtemp>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110c190:	d0a05317 	ldw	r2,-32436(gp)
8110c194:	10804304 	addi	r2,r2,268
8110c198:	1009883a 	mov	r4,r2
8110c19c:	11077e80 	call	811077e8 <bRmapGetRmapMemHKArea>
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;
8110c1a0:	d0a05317 	ldw	r2,-32436(gp)
8110c1a4:	10806904 	addi	r2,r2,420
8110c1a8:	e0bffb15 	stw	r2,-20(fp)
					}
					fprintf(fp,"\n================= H  K ==================\n\n");
				#endif

				/* Change the configuration */
				bRmapGetCodecConfig( &pxNFee->xChannel.xRmap );
8110c1ac:	d0a05317 	ldw	r2,-32436(gp)
8110c1b0:	10804304 	addi	r2,r2,268
8110c1b4:	1009883a 	mov	r4,r2
8110c1b8:	1105dfc0 	call	81105dfc <bRmapGetCodecConfig>
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char) xDefaults.ucRmapKey ;
8110c1bc:	d0e05317 	ldw	r3,-32436(gp)
8110c1c0:	00a045b4 	movhi	r2,33046
8110c1c4:	10acbf04 	addi	r2,r2,-19716
8110c1c8:	10800c0b 	ldhu	r2,48(r2)
8110c1cc:	18804405 	stb	r2,272(r3)
				pxNFee->xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char) xDefaults.ucLogicalAddr;
8110c1d0:	d0e05317 	ldw	r3,-32436(gp)
8110c1d4:	00a045b4 	movhi	r2,33046
8110c1d8:	10acbf04 	addi	r2,r2,-19716
8110c1dc:	10800c8b 	ldhu	r2,50(r2)
8110c1e0:	18804445 	stb	r2,273(r3)
				bRmapSetCodecConfig( &pxNFee->xChannel.xRmap );
8110c1e4:	d0a05317 	ldw	r2,-32436(gp)
8110c1e8:	10804304 	addi	r2,r2,268
8110c1ec:	1009883a 	mov	r4,r2
8110c1f0:	1105d240 	call	81105d24 <bRmapSetCodecConfig>
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task. RMAP KEY = %hu\n", xDefaults.ucRmapKey );
					fprintf(fp,"NFEE %hhu Task. Log. Addr. = %hu \n", xDefaults.ucLogicalAddr);
				#endif

				pxNFee->xControl.eMode = sToFeeConfig;
8110c1f4:	d0a05317 	ldw	r2,-32436(gp)
8110c1f8:	00c00144 	movi	r3,5
8110c1fc:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110c200:	d0a05317 	ldw	r2,-32436(gp)
8110c204:	10802e17 	ldw	r2,184(r2)
8110c208:	d0a05605 	stb	r2,-32424(gp)

				break;
8110c20c:	00030206 	br	8110ce18 <vFeeTask+0x1150>
			case sToFeeConfig: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110c210:	d0a05317 	ldw	r2,-32436(gp)
8110c214:	10804304 	addi	r2,r2,268
8110c218:	1009883a 	mov	r4,r2
8110c21c:	11064340 	call	81106434 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /*Off*/
8110c220:	d0a05317 	ldw	r2,-32436(gp)
8110c224:	00c00184 	movi	r3,6
8110c228:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110c22c:	d0a05317 	ldw	r2,-32436(gp)
8110c230:	10804304 	addi	r2,r2,268
8110c234:	1009883a 	mov	r4,r2
8110c238:	11061480 	call	81106148 <bRmapSetMemConfigArea>

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110c23c:	d0a05317 	ldw	r2,-32436(gp)
8110c240:	10808904 	addi	r2,r2,548
8110c244:	1009883a 	mov	r4,r2
8110c248:	110dd540 	call	8110dd54 <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
8110c24c:	d0a05317 	ldw	r2,-32436(gp)
8110c250:	10002615 	stw	zero,152(r2)

				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucSPWId);
8110c254:	d0a05317 	ldw	r2,-32436(gp)
8110c258:	10c04304 	addi	r3,r2,268
8110c25c:	d0a05317 	ldw	r2,-32436(gp)
8110c260:	10800043 	ldbu	r2,1(r2)
8110c264:	10803fcc 	andi	r2,r2,255
8110c268:	100b883a 	mov	r5,r2
8110c26c:	1809883a 	mov	r4,r3
8110c270:	110dca80 	call	8110dca8 <bDisableRmapIRQ>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110c274:	d0a05317 	ldw	r2,-32436(gp)
8110c278:	10803b04 	addi	r2,r2,236
8110c27c:	1009883a 	mov	r4,r2
8110c280:	110deac0 	call	8110deac <bDisAndClrDbBuffer>
				#if DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
8110c284:	d0a05317 	ldw	r2,-32436(gp)
8110c288:	10802217 	ldw	r2,136(r2)
8110c28c:	10800058 	cmpnei	r2,r2,1
8110c290:	10000a1e 	bne	r2,zero,8110c2bc <vFeeTask+0x5f4>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110c294:	e0fff503 	ldbu	r3,-44(fp)
8110c298:	00a045b4 	movhi	r2,33046
8110c29c:	10a00304 	addi	r2,r2,-32756
8110c2a0:	180690fa 	slli	r3,r3,3
8110c2a4:	10c5883a 	add	r2,r2,r3
8110c2a8:	10800017 	ldw	r2,0(r2)
8110c2ac:	1009883a 	mov	r4,r2
8110c2b0:	1135b100 	call	81135b10 <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
8110c2b4:	d0a05317 	ldw	r2,-32436(gp)
8110c2b8:	10002215 	stw	zero,136(r2)
				}

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110c2bc:	d0a05317 	ldw	r2,-32436(gp)
8110c2c0:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110c2c4:	d0a05317 	ldw	r2,-32436(gp)
8110c2c8:	10800003 	ldbu	r2,0(r2)
8110c2cc:	10803fcc 	andi	r2,r2,255
8110c2d0:	1085883a 	add	r2,r2,r2
8110c2d4:	1087883a 	add	r3,r2,r2
8110c2d8:	d0a05c04 	addi	r2,gp,-32400
8110c2dc:	1885883a 	add	r2,r3,r2
8110c2e0:	10800017 	ldw	r2,0(r2)
8110c2e4:	1009883a 	mov	r4,r2
8110c2e8:	11365c00 	call	811365c0 <OSQFlush>
8110c2ec:	e0bffd45 	stb	r2,-11(fp)
				if ( error_code != OS_NO_ERR ) {
8110c2f0:	e0bffd43 	ldbu	r2,-11(fp)
8110c2f4:	10803fcc 	andi	r2,r2,255
8110c2f8:	10000126 	beq	r2,zero,8110c300 <vFeeTask+0x638>
					vFailFlushNFEEQueue();
8110c2fc:	11173b40 	call	811173b4 <vFailFlushNFEEQueue>
				}

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110c300:	d0a05317 	ldw	r2,-32436(gp)
8110c304:	10800003 	ldbu	r2,0(r2)
8110c308:	10803fcc 	andi	r2,r2,255
8110c30c:	100d883a 	mov	r6,r2
8110c310:	000b883a 	mov	r5,zero
8110c314:	01002044 	movi	r4,129
8110c318:	110dfbc0 	call	8110dfbc <bSendGiveBackNFeeCtrl>

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
8110c31c:	d0a05317 	ldw	r2,-32436(gp)
8110c320:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
8110c324:	d0a05317 	ldw	r2,-32436(gp)
8110c328:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110c32c:	d0a05317 	ldw	r2,-32436(gp)
8110c330:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110c334:	d0a05317 	ldw	r2,-32436(gp)
8110c338:	00c00044 	movi	r3,1
8110c33c:	10c02115 	stw	r3,132(r2)

				vResetMemCCDFEE(pxNFee);
8110c340:	d0a05317 	ldw	r2,-32436(gp)
8110c344:	1009883a 	mov	r4,r2
8110c348:	11179ac0 	call	811179ac <vResetMemCCDFEE>

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110c34c:	d0a05317 	ldw	r2,-32436(gp)
8110c350:	10800003 	ldbu	r2,0(r2)
8110c354:	10803fcc 	andi	r2,r2,255
8110c358:	1085883a 	add	r2,r2,r2
8110c35c:	1087883a 	add	r3,r2,r2
8110c360:	d0a06904 	addi	r2,gp,-32348
8110c364:	1885883a 	add	r2,r3,r2
8110c368:	10800017 	ldw	r2,0(r2)
8110c36c:	1009883a 	mov	r4,r2
8110c370:	11365c00 	call	811365c0 <OSQFlush>
8110c374:	e0bffd45 	stb	r2,-11(fp)
				if ( error_code != OS_NO_ERR ) {
8110c378:	e0bffd43 	ldbu	r2,-11(fp)
8110c37c:	10803fcc 	andi	r2,r2,255
8110c380:	10000126 	beq	r2,zero,8110c388 <vFeeTask+0x6c0>
					vFailFlushNFEEQueue();
8110c384:	11173b40 	call	811173b4 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bWatingSync = TRUE;
8110c388:	d0a05317 	ldw	r2,-32436(gp)
8110c38c:	00c00044 	movi	r3,1
8110c390:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeConfig;
8110c394:	d0a05317 	ldw	r2,-32436(gp)
8110c398:	00c00044 	movi	r3,1
8110c39c:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110c3a0:	d0a05317 	ldw	r2,-32436(gp)
8110c3a4:	10802e17 	ldw	r2,184(r2)
8110c3a8:	d0a05605 	stb	r2,-32424(gp)
				bFinal = FALSE;
8110c3ac:	e03ff915 	stw	zero,-28(fp)
				break;
8110c3b0:	00029906 	br	8110ce18 <vFeeTask+0x1150>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110c3b4:	d0a05317 	ldw	r2,-32436(gp)
8110c3b8:	10800003 	ldbu	r2,0(r2)
8110c3bc:	10803fcc 	andi	r2,r2,255
8110c3c0:	1085883a 	add	r2,r2,r2
8110c3c4:	1087883a 	add	r3,r2,r2
8110c3c8:	d0a06904 	addi	r2,gp,-32348
8110c3cc:	1885883a 	add	r2,r3,r2
8110c3d0:	10800017 	ldw	r2,0(r2)
8110c3d4:	e0fffd44 	addi	r3,fp,-11
8110c3d8:	180d883a 	mov	r6,r3
8110c3dc:	000b883a 	mov	r5,zero
8110c3e0:	1009883a 	mov	r4,r2
8110c3e4:	11366800 	call	81136680 <OSQPend>
8110c3e8:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110c3ec:	e0bffd43 	ldbu	r2,-11(fp)
8110c3f0:	10803fcc 	andi	r2,r2,255
8110c3f4:	10027f1e 	bne	r2,zero,8110cdf4 <vFeeTask+0x112c>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8110c3f8:	d0a05317 	ldw	r2,-32436(gp)
8110c3fc:	e0fffe17 	ldw	r3,-8(fp)
8110c400:	180b883a 	mov	r5,r3
8110c404:	1009883a 	mov	r4,r2
8110c408:	110cfb80 	call	8110cfb8 <vQCmdFEEinConfig>
					#if DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110c40c:	00027906 	br	8110cdf4 <vFeeTask+0x112c>
			case sFeeOn: /* Not implemented yet */

				pxNFee->xControl.eMode = sToFeeStandBy;
8110c410:	d0a05317 	ldw	r2,-32436(gp)
8110c414:	00c00184 	movi	r3,6
8110c418:	10c02c15 	stw	r3,176(r2)
				break;
8110c41c:	00027e06 	br	8110ce18 <vFeeTask+0x1150>
			case sToFeeStandBy: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110c420:	d0a05317 	ldw	r2,-32436(gp)
8110c424:	10804304 	addi	r2,r2,268
8110c428:	1009883a 	mov	r4,r2
8110c42c:	11064340 	call	81106434 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00; /*sToFeeStandBy*/
8110c430:	d0a05317 	ldw	r2,-32436(gp)
8110c434:	10006615 	stw	zero,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110c438:	d0a05317 	ldw	r2,-32436(gp)
8110c43c:	10804304 	addi	r2,r2,268
8110c440:	1009883a 	mov	r4,r2
8110c444:	11061480 	call	81106148 <bRmapSetMemConfigArea>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110c448:	d0a05317 	ldw	r2,-32436(gp)
8110c44c:	10803b04 	addi	r2,r2,236
8110c450:	1009883a 	mov	r4,r2
8110c454:	110deac0 	call	8110deac <bDisAndClrDbBuffer>

				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
8110c458:	d0a05317 	ldw	r2,-32436(gp)
8110c45c:	10c04304 	addi	r3,r2,268
8110c460:	d0a05317 	ldw	r2,-32436(gp)
8110c464:	10800003 	ldbu	r2,0(r2)
8110c468:	10803fcc 	andi	r2,r2,255
8110c46c:	100b883a 	mov	r5,r2
8110c470:	1809883a 	mov	r4,r3
8110c474:	110dcfc0 	call	8110dcfc <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110c478:	d0a05317 	ldw	r2,-32436(gp)
8110c47c:	10808904 	addi	r2,r2,548
8110c480:	1009883a 	mov	r4,r2
8110c484:	110ddb40 	call	8110ddb4 <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
8110c488:	d0a05317 	ldw	r2,-32436(gp)
8110c48c:	00c00044 	movi	r3,1
8110c490:	10c02615 	stw	r3,152(r2)

				pxNFee->xControl.bSimulating = TRUE;
8110c494:	d0a05317 	ldw	r2,-32436(gp)
8110c498:	00c00044 	movi	r3,1
8110c49c:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110c4a0:	d0a05317 	ldw	r2,-32436(gp)
8110c4a4:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110c4a8:	d0a05317 	ldw	r2,-32436(gp)
8110c4ac:	00c00044 	movi	r3,1
8110c4b0:	10c02115 	stw	r3,132(r2)

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110c4b4:	d0a05317 	ldw	r2,-32436(gp)
8110c4b8:	10800003 	ldbu	r2,0(r2)
8110c4bc:	10803fcc 	andi	r2,r2,255
8110c4c0:	100d883a 	mov	r6,r2
8110c4c4:	000b883a 	mov	r5,zero
8110c4c8:	01002044 	movi	r4,129
8110c4cc:	110dfbc0 	call	8110dfbc <bSendGiveBackNFeeCtrl>

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110c4d0:	d0a05317 	ldw	r2,-32436(gp)
8110c4d4:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110c4d8:	d0a05317 	ldw	r2,-32436(gp)
8110c4dc:	10800003 	ldbu	r2,0(r2)
8110c4e0:	10803fcc 	andi	r2,r2,255
8110c4e4:	1085883a 	add	r2,r2,r2
8110c4e8:	1087883a 	add	r3,r2,r2
8110c4ec:	d0a05c04 	addi	r2,gp,-32400
8110c4f0:	1885883a 	add	r2,r3,r2
8110c4f4:	10800017 	ldw	r2,0(r2)
8110c4f8:	1009883a 	mov	r4,r2
8110c4fc:	11365c00 	call	811365c0 <OSQFlush>
8110c500:	e0bffd45 	stb	r2,-11(fp)
				if ( error_code != OS_NO_ERR ) {
8110c504:	e0bffd43 	ldbu	r2,-11(fp)
8110c508:	10803fcc 	andi	r2,r2,255
8110c50c:	10000126 	beq	r2,zero,8110c514 <vFeeTask+0x84c>
					vFailFlushNFEEQueue();
8110c510:	11173b40 	call	811173b4 <vFailFlushNFEEQueue>
				#if DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Standby Mode\n", pxNFee->ucId);
				#endif

				/* Reset the memory addr variables thats is used in the transmission*/
				vResetMemCCDFEE(pxNFee);
8110c514:	d0a05317 	ldw	r2,-32436(gp)
8110c518:	1009883a 	mov	r4,r2
8110c51c:	11179ac0 	call	811179ac <vResetMemCCDFEE>

				incrementador = 0;
8110c520:	d0205415 	stw	zero,-32432(gp)

				pxNFee->xControl.bWatingSync = TRUE;
8110c524:	d0a05317 	ldw	r2,-32436(gp)
8110c528:	00c00044 	movi	r3,1
8110c52c:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeStandBy;
8110c530:	d0a05317 	ldw	r2,-32436(gp)
8110c534:	00c000c4 	movi	r3,3
8110c538:	10c02c15 	stw	r3,176(r2)
				ucIterationSide = pxNFee->xControl.eSide;
8110c53c:	d0a05317 	ldw	r2,-32436(gp)
8110c540:	10802e17 	ldw	r2,184(r2)
8110c544:	d0a05605 	stb	r2,-32424(gp)
				break;
8110c548:	00023306 	br	8110ce18 <vFeeTask+0x1150>


			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110c54c:	d0a05317 	ldw	r2,-32436(gp)
8110c550:	10800003 	ldbu	r2,0(r2)
8110c554:	10803fcc 	andi	r2,r2,255
8110c558:	1085883a 	add	r2,r2,r2
8110c55c:	1087883a 	add	r3,r2,r2
8110c560:	d0a06904 	addi	r2,gp,-32348
8110c564:	1885883a 	add	r2,r3,r2
8110c568:	10800017 	ldw	r2,0(r2)
8110c56c:	e0fffd44 	addi	r3,fp,-11
8110c570:	180d883a 	mov	r6,r3
8110c574:	000b883a 	mov	r5,zero
8110c578:	1009883a 	mov	r4,r2
8110c57c:	11366800 	call	81136680 <OSQPend>
8110c580:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110c584:	e0bffd43 	ldbu	r2,-11(fp)
8110c588:	10803fcc 	andi	r2,r2,255
8110c58c:	10021b1e 	bne	r2,zero,8110cdfc <vFeeTask+0x1134>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
8110c590:	d0a05317 	ldw	r2,-32436(gp)
8110c594:	e0fffe17 	ldw	r3,-8(fp)
8110c598:	180b883a 	mov	r5,r3
8110c59c:	1009883a 	mov	r4,r2
8110c5a0:	110d0f40 	call	8110d0f4 <vQCmdFEEinStandBy>
					#if DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110c5a4:	00021506 	br	8110cdfc <vFeeTask+0x1134>


			case sNextPatternIteration:


				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110c5a8:	d0a05317 	ldw	r2,-32436(gp)
8110c5ac:	10800003 	ldbu	r2,0(r2)
8110c5b0:	10803fcc 	andi	r2,r2,255
8110c5b4:	1085883a 	add	r2,r2,r2
8110c5b8:	1087883a 	add	r3,r2,r2
8110c5bc:	d0a05c04 	addi	r2,gp,-32400
8110c5c0:	1885883a 	add	r2,r3,r2
8110c5c4:	10800017 	ldw	r2,0(r2)
8110c5c8:	1009883a 	mov	r4,r2
8110c5cc:	11365c00 	call	811365c0 <OSQFlush>
8110c5d0:	e0bffd45 	stb	r2,-11(fp)
				if ( error_code != OS_NO_ERR ) {
8110c5d4:	e0bffd43 	ldbu	r2,-11(fp)
8110c5d8:	10803fcc 	andi	r2,r2,255
8110c5dc:	10000126 	beq	r2,zero,8110c5e4 <vFeeTask+0x91c>
					vFailFlushNFEEQueue();
8110c5e0:	11173b40 	call	811173b4 <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bUsingDMA = TRUE;
8110c5e4:	d0a05317 	ldw	r2,-32436(gp)
8110c5e8:	00c00044 	movi	r3,1
8110c5ec:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110c5f0:	d0a05317 	ldw	r2,-32436(gp)
8110c5f4:	00c00044 	movi	r3,1
8110c5f8:	10c02715 	stw	r3,156(r2)

				vResetMemCCDFEE(pxNFee);
8110c5fc:	d0a05317 	ldw	r2,-32436(gp)
8110c600:	1009883a 	mov	r4,r2
8110c604:	11179ac0 	call	811179ac <vResetMemCCDFEE>

				//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,SDMA_MAX_BLOCKS,0);
				//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,SDMA_MAX_BLOCKS,1);


				while ( (bFeebGetCh1LeftBufferEmpty()== FALSE) || (bFeebGetCh1RightBufferEmpty()== FALSE)  ) {}
8110c608:	0001883a 	nop
8110c60c:	11048880 	call	81104888 <bFeebGetCh1LeftBufferEmpty>
8110c610:	103ffe26 	beq	r2,zero,8110c60c <__reset+0xfb0ec60c>
8110c614:	11048f00 	call	811048f0 <bFeebGetCh1RightBufferEmpty>
8110c618:	103ffc26 	beq	r2,zero,8110c60c <__reset+0xfb0ec60c>

				OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay);
8110c61c:	00a045b4 	movhi	r2,33046
8110c620:	10acbf04 	addi	r2,r2,-19716
8110c624:	1080070b 	ldhu	r2,28(r2)
8110c628:	10bfffcc 	andi	r2,r2,65535
8110c62c:	100f883a 	mov	r7,r2
8110c630:	000d883a 	mov	r6,zero
8110c634:	000b883a 	mov	r5,zero
8110c638:	0009883a 	mov	r4,zero
8110c63c:	11395100 	call	81139510 <OSTimeDlyHMSM>

				//bFeebCh2SetBufferSize(SDMA_MAX_BLOCKS,0);
				//bFeebCh2SetBufferSize(SDMA_MAX_BLOCKS,1);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				if (xDefaults.usiLinkNFEE0 == 0) {
8110c640:	00a045b4 	movhi	r2,33046
8110c644:	10acbf04 	addi	r2,r2,-19716
8110c648:	1080100b 	ldhu	r2,64(r2)
8110c64c:	10bfffcc 	andi	r2,r2,65535
8110c650:	1000071e 	bne	r2,zero,8110c670 <vFeeTask+0x9a8>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110c654:	000b883a 	mov	r5,zero
8110c658:	01000404 	movi	r4,16
8110c65c:	1103c680 	call	81103c68 <bFeebCh1SetBufferSize>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110c660:	01400044 	movi	r5,1
8110c664:	01000404 	movi	r4,16
8110c668:	1103c680 	call	81103c68 <bFeebCh1SetBufferSize>
8110c66c:	00000606 	br	8110c688 <vFeeTask+0x9c0>
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110c670:	000b883a 	mov	r5,zero
8110c674:	01000404 	movi	r4,16
8110c678:	1103d3c0 	call	81103d3c <bFeebCh2SetBufferSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110c67c:	01400044 	movi	r5,1
8110c680:	01000404 	movi	r4,16
8110c684:	1103d3c0 	call	81103d3c <bFeebCh2SetBufferSize>
				}


				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110c688:	d0a05317 	ldw	r2,-32436(gp)
8110c68c:	10803b04 	addi	r2,r2,236
8110c690:	1009883a 	mov	r4,r2
8110c694:	110de140 	call	8110de14 <bEnableDbBuffer>


				bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire);
8110c698:	d0a05317 	ldw	r2,-32436(gp)
8110c69c:	10808904 	addi	r2,r2,548
8110c6a0:	1009883a 	mov	r4,r2
8110c6a4:	11088400 	call	81108840 <bSpwcGetTimecode>
				tCodFeeTask = pxNFee->xChannel.xSpacewire.xTimecode.ucCounter;
8110c6a8:	d0a05317 	ldw	r2,-32436(gp)
8110c6ac:	10809543 	ldbu	r2,597(r2)
8110c6b0:	10803fcc 	andi	r2,r2,255
8110c6b4:	d0a05515 	stw	r2,-32428(gp)
				tCodeNext = ( tCodFeeTask + 1) % 4;
8110c6b8:	d0a05517 	ldw	r2,-32428(gp)
8110c6bc:	10800044 	addi	r2,r2,1
8110c6c0:	108000cc 	andi	r2,r2,3
8110c6c4:	e0bffc15 	stw	r2,-16(fp)
				if ( tCodeNext == 0 ) {
8110c6c8:	e0bffc17 	ldw	r2,-16(fp)
8110c6cc:	10000e1e 	bne	r2,zero,8110c708 <vFeeTask+0xa40>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
8110c6d0:	d0a05317 	ldw	r2,-32436(gp)
8110c6d4:	10802917 	ldw	r2,164(r2)
8110c6d8:	10800003 	ldbu	r2,0(r2)
8110c6dc:	10803fcc 	andi	r2,r2,255
8110c6e0:	10c00044 	addi	r3,r2,1
8110c6e4:	00a00034 	movhi	r2,32768
8110c6e8:	10800044 	addi	r2,r2,1
8110c6ec:	1884703a 	and	r2,r3,r2
8110c6f0:	1000040e 	bge	r2,zero,8110c704 <vFeeTask+0xa3c>
8110c6f4:	10bfffc4 	addi	r2,r2,-1
8110c6f8:	00ffff84 	movi	r3,-2
8110c6fc:	10c4b03a 	or	r2,r2,r3
8110c700:	10800044 	addi	r2,r2,1
8110c704:	e0bff505 	stb	r2,-44(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
8110c708:	d0e05317 	ldw	r3,-32436(gp)
8110c70c:	e0bffc17 	ldw	r2,-16(fp)
8110c710:	1885883a 	add	r2,r3,r2
8110c714:	10802a44 	addi	r2,r2,169
8110c718:	10800003 	ldbu	r2,0(r2)
8110c71c:	e0bffd05 	stb	r2,-12(fp)

				if ( pxNFee->xControl.eSide == sLeft )
8110c720:	d0a05317 	ldw	r2,-32436(gp)
8110c724:	10802e17 	ldw	r2,184(r2)
8110c728:	1000071e 	bne	r2,zero,8110c748 <vFeeTask+0xa80>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
8110c72c:	d0e05317 	ldw	r3,-32436(gp)
8110c730:	e0bffd03 	ldbu	r2,-12(fp)
8110c734:	10800624 	muli	r2,r2,24
8110c738:	10800904 	addi	r2,r2,36
8110c73c:	1885883a 	add	r2,r3,r2
8110c740:	e0bff615 	stw	r2,-40(fp)
8110c744:	00000606 	br	8110c760 <vFeeTask+0xa98>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
8110c748:	d0e05317 	ldw	r3,-32436(gp)
8110c74c:	e0bffd03 	ldbu	r2,-12(fp)
8110c750:	10800624 	muli	r2,r2,24
8110c754:	10800c04 	addi	r2,r2,48
8110c758:	1885883a 	add	r2,r3,r2
8110c75c:	e0bff615 	stw	r2,-40(fp)

				ucIterationSide = pxNFee->xControl.eSide;
8110c760:	d0a05317 	ldw	r2,-32436(gp)
8110c764:	10802e17 	ldw	r2,184(r2)
8110c768:	d0a05605 	stb	r2,-32424(gp)


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110c76c:	d0a05317 	ldw	r2,-32436(gp)
8110c770:	10803304 	addi	r2,r2,204
8110c774:	1009883a 	mov	r4,r2
8110c778:	1102d4c0 	call	81102d4c <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8110c77c:	d0a05317 	ldw	r2,-32436(gp)
8110c780:	e0fffd03 	ldbu	r3,-12(fp)
8110c784:	10c036c5 	stb	r3,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110c788:	d0a05317 	ldw	r2,-32436(gp)
8110c78c:	00c00044 	movi	r3,1
8110c790:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110c794:	d0a05317 	ldw	r2,-32436(gp)
8110c798:	10803304 	addi	r2,r2,204
8110c79c:	1009883a 	mov	r4,r2
8110c7a0:	1102b200 	call	81102b20 <bDpktSetPacketConfig>


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110c7a4:	d0a05317 	ldw	r2,-32436(gp)
8110c7a8:	10803304 	addi	r2,r2,204
8110c7ac:	1009883a 	mov	r4,r2
8110c7b0:	1102d4c0 	call	81102d4c <bDpktGetPacketConfig>
					fprintf(fp,"ucFeeMode %hu\n", pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode);
					fprintf(fp,"=========DATA PACKET=============\n");
				#endif

				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
8110c7b4:	d0a05317 	ldw	r2,-32436(gp)
8110c7b8:	10800003 	ldbu	r2,0(r2)
8110c7bc:	10803fcc 	andi	r2,r2,255
8110c7c0:	100d883a 	mov	r6,r2
8110c7c4:	000b883a 	mov	r5,zero
8110c7c8:	01002004 	movi	r4,128
8110c7cc:	110df180 	call	8110df18 <bSendRequestNFeeCtrl>
				bDmaReturn = FALSE;
8110c7d0:	e03ff815 	stw	zero,-32(fp)
				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110c7d4:	d0a05317 	ldw	r2,-32436(gp)
8110c7d8:	10800003 	ldbu	r2,0(r2)
8110c7dc:	10803fcc 	andi	r2,r2,255
8110c7e0:	1085883a 	add	r2,r2,r2
8110c7e4:	1087883a 	add	r3,r2,r2
8110c7e8:	d0a06904 	addi	r2,gp,-32348
8110c7ec:	1885883a 	add	r2,r3,r2
8110c7f0:	10800017 	ldw	r2,0(r2)
8110c7f4:	e0fffd44 	addi	r3,fp,-11
8110c7f8:	180d883a 	mov	r6,r3
8110c7fc:	000b883a 	mov	r5,zero
8110c800:	1009883a 	mov	r4,r2
8110c804:	11366800 	call	81136680 <OSQPend>
8110c808:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110c80c:	e0bffd43 	ldbu	r2,-11(fp)
8110c810:	10803fcc 	andi	r2,r2,255
8110c814:	10017b1e 	bne	r2,zero,8110ce04 <vFeeTask+0x113c>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110c818:	e0bffe83 	ldbu	r2,-6(fp)
8110c81c:	10803fcc 	andi	r2,r2,255
8110c820:	108023d8 	cmpnei	r2,r2,143
8110c824:	1000451e 	bne	r2,zero,8110c93c <vFeeTask+0xc74>

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110c828:	e0fff503 	ldbu	r3,-44(fp)
8110c82c:	00a045b4 	movhi	r2,33046
8110c830:	10a00304 	addi	r2,r2,-32756
8110c834:	180690fa 	slli	r3,r3,3
8110c838:	10c5883a 	add	r2,r2,r3
8110c83c:	10800017 	ldw	r2,0(r2)
8110c840:	e0fffd44 	addi	r3,fp,-11
8110c844:	180d883a 	mov	r6,r3
8110c848:	000b883a 	mov	r5,zero
8110c84c:	1009883a 	mov	r4,r2
8110c850:	113556c0 	call	8113556c <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
8110c854:	e0bffd43 	ldbu	r2,-11(fp)
8110c858:	10803fcc 	andi	r2,r2,255
8110c85c:	1000181e 	bne	r2,zero,8110c8c0 <vFeeTask+0xbf8>
	                    	pxNFee->xControl.bDMALocked = TRUE;
8110c860:	d0a05317 	ldw	r2,-32436(gp)
8110c864:	00c00044 	movi	r3,1
8110c868:	10c02215 	stw	r3,136(r2)

							bDmaReturn = bPrepareDoubleBuffer( xCcdMapLocal, ucMemUsing, pxNFee->ucId, pxNFee );
8110c86c:	e0fff503 	ldbu	r3,-44(fp)
8110c870:	d0a05317 	ldw	r2,-32436(gp)
8110c874:	10800003 	ldbu	r2,0(r2)
8110c878:	10803fcc 	andi	r2,r2,255
8110c87c:	d1205317 	ldw	r4,-32436(gp)
8110c880:	200f883a 	mov	r7,r4
8110c884:	100d883a 	mov	r6,r2
8110c888:	180b883a 	mov	r5,r3
8110c88c:	e13ff617 	ldw	r4,-40(fp)
8110c890:	110e0600 	call	8110e060 <bPrepareDoubleBuffer>
8110c894:	e0bff815 	stw	r2,-32(fp)
							OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110c898:	e0fff503 	ldbu	r3,-44(fp)
8110c89c:	00a045b4 	movhi	r2,33046
8110c8a0:	10a00304 	addi	r2,r2,-32756
8110c8a4:	180690fa 	slli	r3,r3,3
8110c8a8:	10c5883a 	add	r2,r2,r3
8110c8ac:	10800017 	ldw	r2,0(r2)
8110c8b0:	1009883a 	mov	r4,r2
8110c8b4:	1135b100 	call	81135b10 <OSMutexPost>
							pxNFee->xControl.bDMALocked = FALSE;
8110c8b8:	d0a05317 	ldw	r2,-32436(gp)
8110c8bc:	10002215 	stw	zero,136(r2)
		
						}
						/* Send message telling to controller that is not using the DMA any more */
						bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);							
8110c8c0:	d0a05317 	ldw	r2,-32436(gp)
8110c8c4:	10800003 	ldbu	r2,0(r2)
8110c8c8:	10803fcc 	andi	r2,r2,255
8110c8cc:	100d883a 	mov	r6,r2
8110c8d0:	000b883a 	mov	r5,zero
8110c8d4:	01002044 	movi	r4,129
8110c8d8:	110dfbc0 	call	8110dfbc <bSendGiveBackNFeeCtrl>

						if ( bDmaReturn == TRUE ) {
8110c8dc:	e0bff817 	ldw	r2,-32(fp)
8110c8e0:	10800058 	cmpnei	r2,r2,1
8110c8e4:	1001471e 	bne	r2,zero,8110ce04 <vFeeTask+0x113c>
							if (pxNFee->xControl.bWatingSync==TRUE) {
8110c8e8:	d0a05317 	ldw	r2,-32436(gp)
8110c8ec:	10802817 	ldw	r2,160(r2)
8110c8f0:	10800058 	cmpnei	r2,r2,1
8110c8f4:	1000071e 	bne	r2,zero,8110c914 <vFeeTask+0xc4c>
								pxNFee->xControl.eNextMode = sToTestFullPattern;
8110c8f8:	d0a05317 	ldw	r2,-32436(gp)
8110c8fc:	00c001c4 	movi	r3,7
8110c900:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sFeeWaitingSync;
8110c904:	d0a05317 	ldw	r2,-32436(gp)
8110c908:	00c00304 	movi	r3,12
8110c90c:	10c02c15 	stw	r3,176(r2)
8110c910:	00000606 	br	8110c92c <vFeeTask+0xc64>
							} else {
								pxNFee->xControl.eNextMode = sToTestFullPattern;
8110c914:	d0a05317 	ldw	r2,-32436(gp)
8110c918:	00c001c4 	movi	r3,7
8110c91c:	10c02d15 	stw	r3,180(r2)
								pxNFee->xControl.eMode = sToTestFullPattern;
8110c920:	d0a05317 	ldw	r2,-32436(gp)
8110c924:	00c001c4 	movi	r3,7
8110c928:	10c02c15 	stw	r3,176(r2)
							}
							incrementador++;
8110c92c:	d0a05417 	ldw	r2,-32432(gp)
8110c930:	10800044 	addi	r2,r2,1
8110c934:	d0a05415 	stw	r2,-32432(gp)
				} else {
					#if DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}	
				break;
8110c938:	00013206 	br	8110ce04 <vFeeTask+0x113c>
							#if DEBUG_ON
								fprintf(fp,"\nFEE TASK:  Double buffer prepared\n ");
							#endif							
					} else {

						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110c93c:	d0a05317 	ldw	r2,-32436(gp)
8110c940:	e0fffe17 	ldw	r3,-8(fp)
8110c944:	180b883a 	mov	r5,r3
8110c948:	1009883a 	mov	r4,r2
8110c94c:	110d2840 	call	8110d284 <vQCmdFEEinFullPattern>
				} else {
					#if DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}	
				break;
8110c950:	00012c06 	br	8110ce04 <vFeeTask+0x113c>


			case sToTestFullPattern: /* Transition */
				bFinal = FALSE;
8110c954:	e03ff915 	stw	zero,-28(fp)

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110c958:	d0a05317 	ldw	r2,-32436(gp)
8110c95c:	10804304 	addi	r2,r2,268
8110c960:	1009883a 	mov	r4,r2
8110c964:	11064340 	call	81106434 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02; /*Pattern Full Image*/
8110c968:	d0a05317 	ldw	r2,-32436(gp)
8110c96c:	00c00084 	movi	r3,2
8110c970:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110c974:	d0a05317 	ldw	r2,-32436(gp)
8110c978:	10804304 	addi	r2,r2,268
8110c97c:	1009883a 	mov	r4,r2
8110c980:	11061480 	call	81106148 <bRmapSetMemConfigArea>

				#if DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
				#endif

				ucIterationSide = pxNFee->xControl.eSide;
8110c984:	d0a05317 	ldw	r2,-32436(gp)
8110c988:	10802e17 	ldw	r2,184(r2)
8110c98c:	d0a05605 	stb	r2,-32424(gp)

				pxNFee->xControl.bUsingDMA = TRUE;
8110c990:	d0a05317 	ldw	r2,-32436(gp)
8110c994:	00c00044 	movi	r3,1
8110c998:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.eMode = sFeeTestFullPattern;
8110c99c:	d0a05317 	ldw	r2,-32436(gp)
8110c9a0:	00c00104 	movi	r3,4
8110c9a4:	10c02c15 	stw	r3,176(r2)
				pxNFee->xControl.eNextMode = sFeeTestFullPattern;
8110c9a8:	d0a05317 	ldw	r2,-32436(gp)
8110c9ac:	00c00104 	movi	r3,4
8110c9b0:	10c02d15 	stw	r3,180(r2)
				pxNFee->xControl.bWatingSync = TRUE;
8110c9b4:	d0a05317 	ldw	r2,-32436(gp)
8110c9b8:	00c00044 	movi	r3,1
8110c9bc:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110c9c0:	d0a05317 	ldw	r2,-32436(gp)
8110c9c4:	00c00044 	movi	r3,1
8110c9c8:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110c9cc:	d0a05317 	ldw	r2,-32436(gp)
8110c9d0:	00c00044 	movi	r3,1
8110c9d4:	10c02115 	stw	r3,132(r2)
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110c9d8:	d0a05317 	ldw	r2,-32436(gp)
8110c9dc:	10800003 	ldbu	r2,0(r2)
8110c9e0:	10803fcc 	andi	r2,r2,255
8110c9e4:	100d883a 	mov	r6,r2
8110c9e8:	000b883a 	mov	r5,zero
8110c9ec:	01002004 	movi	r4,128
8110c9f0:	110df180 	call	8110df18 <bSendRequestNFeeCtrl>



				if (xDefaults.usiLinkNFEE0 == 0) {
8110c9f4:	00a045b4 	movhi	r2,33046
8110c9f8:	10acbf04 	addi	r2,r2,-19716
8110c9fc:	1080100b 	ldhu	r2,64(r2)
8110ca00:	10bfffcc 	andi	r2,r2,65535
8110ca04:	1000071e 	bne	r2,zero,8110ca24 <vFeeTask+0xd5c>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110ca08:	000b883a 	mov	r5,zero
8110ca0c:	01000404 	movi	r4,16
8110ca10:	1103c680 	call	81103c68 <bFeebCh1SetBufferSize>
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110ca14:	01400044 	movi	r5,1
8110ca18:	01000404 	movi	r4,16
8110ca1c:	1103c680 	call	81103c68 <bFeebCh1SetBufferSize>
				//bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);


				break;
8110ca20:	0000fd06 	br	8110ce18 <vFeeTask+0x1150>

				if (xDefaults.usiLinkNFEE0 == 0) {
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
					bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				} else {
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
8110ca24:	000b883a 	mov	r5,zero
8110ca28:	01000404 	movi	r4,16
8110ca2c:	1103d3c0 	call	81103d3c <bFeebCh2SetBufferSize>
					bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
8110ca30:	01400044 	movi	r5,1
8110ca34:	01000404 	movi	r4,16
8110ca38:	1103d3c0 	call	81103d3c <bFeebCh2SetBufferSize>
				//bFeebCh2SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,0);
				//bFeebCh1SetBufferSize((unsigned char)SDMA_MAX_BLOCKS,1);


				break;
8110ca3c:	0000f606 	br	8110ce18 <vFeeTask+0x1150>


			case sFeeTestFullPattern: /* Real mode */
				bFinal = FALSE;
8110ca40:	e03ff915 	stw	zero,-28(fp)

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110ca44:	d0a05317 	ldw	r2,-32436(gp)
8110ca48:	10800003 	ldbu	r2,0(r2)
8110ca4c:	10803fcc 	andi	r2,r2,255
8110ca50:	1085883a 	add	r2,r2,r2
8110ca54:	1087883a 	add	r3,r2,r2
8110ca58:	d0a06904 	addi	r2,gp,-32348
8110ca5c:	1885883a 	add	r2,r3,r2
8110ca60:	10800017 	ldw	r2,0(r2)
8110ca64:	e0fffd44 	addi	r3,fp,-11
8110ca68:	180d883a 	mov	r6,r3
8110ca6c:	000b883a 	mov	r5,zero
8110ca70:	1009883a 	mov	r4,r2
8110ca74:	11366800 	call	81136680 <OSQPend>
8110ca78:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110ca7c:	e0bffd43 	ldbu	r2,-11(fp)
8110ca80:	10803fcc 	andi	r2,r2,255
8110ca84:	1000e11e 	bne	r2,zero,8110ce0c <vFeeTask+0x1144>

					/* First Check if is access to the DMA (priority) */
						if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110ca88:	e0bffe83 	ldbu	r2,-6(fp)
8110ca8c:	10803fcc 	andi	r2,r2,255
8110ca90:	108023d8 	cmpnei	r2,r2,143
8110ca94:	1000921e 	bne	r2,zero,8110cce0 <vFeeTask+0x1018>

							/* Try to get the Mutex */
		                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110ca98:	e0fff503 	ldbu	r3,-44(fp)
8110ca9c:	00a045b4 	movhi	r2,33046
8110caa0:	10a00304 	addi	r2,r2,-32756
8110caa4:	180690fa 	slli	r3,r3,3
8110caa8:	10c5883a 	add	r2,r2,r3
8110caac:	10800017 	ldw	r2,0(r2)
8110cab0:	e0fffd44 	addi	r3,fp,-11
8110cab4:	180d883a 	mov	r6,r3
8110cab8:	000b883a 	mov	r5,zero
8110cabc:	1009883a 	mov	r4,r2
8110cac0:	113556c0 	call	8113556c <OSMutexPend>
		                    if ( error_code == OS_ERR_NONE ) {
8110cac4:	e0bffd43 	ldbu	r2,-11(fp)
8110cac8:	10803fcc 	andi	r2,r2,255
8110cacc:	1000cf1e 	bne	r2,zero,8110ce0c <vFeeTask+0x1144>
		                    	pxNFee->xControl.bDMALocked = TRUE;
8110cad0:	d0a05317 	ldw	r2,-32436(gp)
8110cad4:	00c00044 	movi	r3,1
8110cad8:	10c02215 	stw	r3,136(r2)

		                    	/* Is this the last block? */
		                    	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8110cadc:	e0bff617 	ldw	r2,-40(fp)
8110cae0:	10800117 	ldw	r2,4(r2)
8110cae4:	10c00404 	addi	r3,r2,16
8110cae8:	d0a05317 	ldw	r2,-32436(gp)
8110caec:	10800417 	ldw	r2,16(r2)
8110caf0:	18802336 	bltu	r3,r2,8110cb80 <vFeeTask+0xeb8>
										fprintf(fp,"\nTotal blocks transmitted: %lu ",xCcdMapLocal->ulBlockI);
									#endif

		                    		/*Define the size of the data in the double buffer (need this to create the interrupt riht)*/

									usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8110caf4:	d0a05317 	ldw	r2,-32436(gp)
8110caf8:	10c00417 	ldw	r3,16(r2)
8110cafc:	e0bff617 	ldw	r2,-40(fp)
8110cb00:	10800117 	ldw	r2,4(r2)
8110cb04:	1885c83a 	sub	r2,r3,r2
8110cb08:	e0bff715 	stw	r2,-36(fp)

		                    		bFinal = TRUE;
8110cb0c:	00800044 	movi	r2,1
8110cb10:	e0bff915 	stw	r2,-28(fp)

		            				if (xDefaults.usiLinkNFEE0 == 0) {
8110cb14:	00a045b4 	movhi	r2,33046
8110cb18:	10acbf04 	addi	r2,r2,-19716
8110cb1c:	1080100b 	ldhu	r2,64(r2)
8110cb20:	10bfffcc 	andi	r2,r2,65535
8110cb24:	10000b1e 	bne	r2,zero,8110cb54 <vFeeTask+0xe8c>
		            					bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,0);
8110cb28:	e0bff717 	ldw	r2,-36(fp)
8110cb2c:	10803fcc 	andi	r2,r2,255
8110cb30:	000b883a 	mov	r5,zero
8110cb34:	1009883a 	mov	r4,r2
8110cb38:	1103c680 	call	81103c68 <bFeebCh1SetBufferSize>
		            					bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,1);
8110cb3c:	e0bff717 	ldw	r2,-36(fp)
8110cb40:	10803fcc 	andi	r2,r2,255
8110cb44:	01400044 	movi	r5,1
8110cb48:	1009883a 	mov	r4,r2
8110cb4c:	1103c680 	call	81103c68 <bFeebCh1SetBufferSize>
8110cb50:	00000e06 	br	8110cb8c <vFeeTask+0xec4>
		            				} else {
		            					bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,0);
8110cb54:	e0bff717 	ldw	r2,-36(fp)
8110cb58:	10803fcc 	andi	r2,r2,255
8110cb5c:	000b883a 	mov	r5,zero
8110cb60:	1009883a 	mov	r4,r2
8110cb64:	1103d3c0 	call	81103d3c <bFeebCh2SetBufferSize>
		            					bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,1);
8110cb68:	e0bff717 	ldw	r2,-36(fp)
8110cb6c:	10803fcc 	andi	r2,r2,255
8110cb70:	01400044 	movi	r5,1
8110cb74:	1009883a 	mov	r4,r2
8110cb78:	1103d3c0 	call	81103d3c <bFeebCh2SetBufferSize>
8110cb7c:	00000306 	br	8110cb8c <vFeeTask+0xec4>
									//bFeebCh2SetBufferSize((unsigned char)usiLengthBlocks,1);
									//bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,0);
									//bFeebCh1SetBufferSize((unsigned char)usiLengthBlocks,1);
		                    	} else {

		                    		bFinal = FALSE;
8110cb80:	e03ff915 	stw	zero,-28(fp)
		                    		usiLengthBlocks = SDMA_MAX_BLOCKS;
8110cb84:	00800404 	movi	r2,16
8110cb88:	e0bff715 	stw	r2,-36(fp)
		                    	}



		                    	if ( ucMemUsing == 0  ) {
8110cb8c:	e0bff503 	ldbu	r2,-44(fp)
8110cb90:	1000111e 	bne	r2,zero,8110cbd8 <vFeeTask+0xf10>
		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
									#if DEBUG_ON
										fprintf(fp,"\n-- bSdmaDmaM1Transfer \n ");
									#endif
		                    		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110cb94:	e0bff617 	ldw	r2,-40(fp)
8110cb98:	10800217 	ldw	r2,8(r2)
8110cb9c:	1011883a 	mov	r8,r2
8110cba0:	e0bff717 	ldw	r2,-36(fp)
8110cba4:	10ffffcc 	andi	r3,r2,65535
8110cba8:	d0a05603 	ldbu	r2,-32424(gp)
8110cbac:	11003fcc 	andi	r4,r2,255
8110cbb0:	d0a05317 	ldw	r2,-32436(gp)
8110cbb4:	10800043 	ldbu	r2,1(r2)
8110cbb8:	10803fcc 	andi	r2,r2,255
8110cbbc:	100f883a 	mov	r7,r2
8110cbc0:	200d883a 	mov	r6,r4
8110cbc4:	180b883a 	mov	r5,r3
8110cbc8:	4009883a 	mov	r4,r8
8110cbcc:	1101f880 	call	81101f88 <bSdmaDmaM1Transfer>
8110cbd0:	e0bff815 	stw	r2,-32(fp)
8110cbd4:	00001006 	br	8110cc18 <vFeeTask+0xf50>
		                    	} else {
									#if DEBUG_ON
										fprintf(fp,"\n-- bSdmaDmaM2Transfer \n ");
									#endif
		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
		                    		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)usiLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110cbd8:	e0bff617 	ldw	r2,-40(fp)
8110cbdc:	10800217 	ldw	r2,8(r2)
8110cbe0:	1011883a 	mov	r8,r2
8110cbe4:	e0bff717 	ldw	r2,-36(fp)
8110cbe8:	10ffffcc 	andi	r3,r2,65535
8110cbec:	d0a05603 	ldbu	r2,-32424(gp)
8110cbf0:	11003fcc 	andi	r4,r2,255
8110cbf4:	d0a05317 	ldw	r2,-32436(gp)
8110cbf8:	10800043 	ldbu	r2,1(r2)
8110cbfc:	10803fcc 	andi	r2,r2,255
8110cc00:	100f883a 	mov	r7,r2
8110cc04:	200d883a 	mov	r6,r4
8110cc08:	180b883a 	mov	r5,r3
8110cc0c:	4009883a 	mov	r4,r8
8110cc10:	11023e00 	call	811023e0 <bSdmaDmaM2Transfer>
8110cc14:	e0bff815 	stw	r2,-32(fp)
		                    	}

		                    	OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110cc18:	e0fff503 	ldbu	r3,-44(fp)
8110cc1c:	00a045b4 	movhi	r2,33046
8110cc20:	10a00304 	addi	r2,r2,-32756
8110cc24:	180690fa 	slli	r3,r3,3
8110cc28:	10c5883a 	add	r2,r2,r3
8110cc2c:	10800017 	ldw	r2,0(r2)
8110cc30:	1009883a 	mov	r4,r2
8110cc34:	1135b100 	call	81135b10 <OSMutexPost>
		                    	pxNFee->xControl.bDMALocked = FALSE;
8110cc38:	d0a05317 	ldw	r2,-32436(gp)
8110cc3c:	10002215 	stw	zero,136(r2)

								#if DEBUG_ON
									fprintf(fp,"\n-- verificacao bDmaReturn \n ");
								#endif
		                    	if ( bDmaReturn == TRUE ) {
8110cc40:	e0bff817 	ldw	r2,-32(fp)
8110cc44:	10800058 	cmpnei	r2,r2,1
8110cc48:	10000e1e 	bne	r2,zero,8110cc84 <vFeeTask+0xfbc>
									#if DEBUG_ON
										fprintf(fp,"\n-- xCcdMapLocal->ulBlockI = %lu \n ", xCcdMapLocal->ulBlockI);
									#endif

									/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */
									xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*usiLengthBlocks;
8110cc4c:	e0bff617 	ldw	r2,-40(fp)
8110cc50:	10c00217 	ldw	r3,8(r2)
8110cc54:	e0bff717 	ldw	r2,-36(fp)
8110cc58:	10802224 	muli	r2,r2,136
8110cc5c:	1887883a 	add	r3,r3,r2
8110cc60:	e0bff617 	ldw	r2,-40(fp)
8110cc64:	10c00215 	stw	r3,8(r2)
									xCcdMapLocal->ulBlockI += usiLengthBlocks;
8110cc68:	e0bff617 	ldw	r2,-40(fp)
8110cc6c:	10c00117 	ldw	r3,4(r2)
8110cc70:	e0bff717 	ldw	r2,-36(fp)
8110cc74:	1887883a 	add	r3,r3,r2
8110cc78:	e0bff617 	ldw	r2,-40(fp)
8110cc7c:	10c00115 	stw	r3,4(r2)
8110cc80:	00000106 	br	8110cc88 <vFeeTask+0xfc0>

		                    	} else {
									#if DEBUG_ON
										fprintf(fp,"\n-- Can't write in the DMA \n ");
									#endif
									bFinal = FALSE;
8110cc84:	e03ff915 	stw	zero,-28(fp)
		                    	}


		                        /* Send message telling to controller that is not using the DMA any more */
								bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110cc88:	d0a05317 	ldw	r2,-32436(gp)
8110cc8c:	10800003 	ldbu	r2,0(r2)
8110cc90:	10803fcc 	andi	r2,r2,255
8110cc94:	100d883a 	mov	r6,r2
8110cc98:	000b883a 	mov	r5,zero
8110cc9c:	01002044 	movi	r4,129
8110cca0:	110dfbc0 	call	8110dfbc <bSendGiveBackNFeeCtrl>
										fprintf(fp,"\nblock: %lu ", xCcdMapLocal->ulBlockI);
									#endif
								}
*/

								if ( bFinal == TRUE ) {
8110cca4:	e0bff917 	ldw	r2,-28(fp)
8110cca8:	10800058 	cmpnei	r2,r2,1
8110ccac:	1000041e 	bne	r2,zero,8110ccc0 <vFeeTask+0xff8>
									pxNFee->xControl.eMode = sEndTransmission;
8110ccb0:	d0a05317 	ldw	r2,-32436(gp)
8110ccb4:	00c002c4 	movi	r3,11
8110ccb8:	10c02c15 	stw	r3,176(r2)
					#if DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110ccbc:	00005306 	br	8110ce0c <vFeeTask+0x1144>
*/

								if ( bFinal == TRUE ) {
									pxNFee->xControl.eMode = sEndTransmission;
								} else {
									bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110ccc0:	d0a05317 	ldw	r2,-32436(gp)
8110ccc4:	10800003 	ldbu	r2,0(r2)
8110ccc8:	10803fcc 	andi	r2,r2,255
8110cccc:	100d883a 	mov	r6,r2
8110ccd0:	000b883a 	mov	r5,zero
8110ccd4:	01002004 	movi	r4,128
8110ccd8:	110df180 	call	8110df18 <bSendRequestNFeeCtrl>
					#if DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110ccdc:	00004b06 	br	8110ce0c <vFeeTask+0x1144>
									bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
								}

		                    }
						} else {
							vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110cce0:	d0a05317 	ldw	r2,-32436(gp)
8110cce4:	e0fffe17 	ldw	r3,-8(fp)
8110cce8:	180b883a 	mov	r5,r3
8110ccec:	1009883a 	mov	r4,r2
8110ccf0:	110d2840 	call	8110d284 <vQCmdFEEinFullPattern>

							if ( pxNFee->xControl.bWatingSync == FALSE ) {
8110ccf4:	d0a05317 	ldw	r2,-32436(gp)
8110ccf8:	10802817 	ldw	r2,160(r2)
8110ccfc:	1000431e 	bne	r2,zero,8110ce0c <vFeeTask+0x1144>
								pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8110cd00:	d0a05317 	ldw	r2,-32436(gp)
8110cd04:	d0e05317 	ldw	r3,-32436(gp)
8110cd08:	18c02d17 	ldw	r3,180(r3)
8110cd0c:	10c02c15 	stw	r3,176(r2)
					#if DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110cd10:	00003e06 	br	8110ce0c <vFeeTask+0x1144>

			case sEndTransmission:

				pxNFee->xControl.bWatingSync = TRUE;
8110cd14:	d0a05317 	ldw	r2,-32436(gp)
8110cd18:	00c00044 	movi	r3,1
8110cd1c:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110cd20:	d0a05317 	ldw	r2,-32436(gp)
8110cd24:	10002315 	stw	zero,140(r2)

				if ( xDefaults.bDataPacket == TRUE ) {
8110cd28:	00a045b4 	movhi	r2,33046
8110cd2c:	10acbf04 	addi	r2,r2,-19716
8110cd30:	10800817 	ldw	r2,32(r2)
8110cd34:	10800058 	cmpnei	r2,r2,1
8110cd38:	1000111e 	bne	r2,zero,8110cd80 <vFeeTask+0x10b8>

					if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
8110cd3c:	d0a05317 	ldw	r2,-32436(gp)
8110cd40:	10802d17 	ldw	r2,180(r2)
8110cd44:	10800198 	cmpnei	r2,r2,6
8110cd48:	1000071e 	bne	r2,zero,8110cd68 <vFeeTask+0x10a0>
						pxNFee->xControl.eMode =  sFeeWaitingSync;
8110cd4c:	d0a05317 	ldw	r2,-32436(gp)
8110cd50:	00c00304 	movi	r3,12
8110cd54:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sToFeeStandBy;
8110cd58:	d0a05317 	ldw	r2,-32436(gp)
8110cd5c:	00c00184 	movi	r3,6
8110cd60:	10c02d15 	stw	r3,180(r2)
8110cd64:	00000606 	br	8110cd80 <vFeeTask+0x10b8>
					} else {
						pxNFee->xControl.eMode =  sNextPatternIteration;
8110cd68:	d0a05317 	ldw	r2,-32436(gp)
8110cd6c:	00c00284 	movi	r3,10
8110cd70:	10c02c15 	stw	r3,176(r2)
						pxNFee->xControl.eNextMode =  sFeeWaitingSync;
8110cd74:	d0a05317 	ldw	r2,-32436(gp)
8110cd78:	00c00304 	movi	r3,12
8110cd7c:	10c02d15 	stw	r3,180(r2)

				//pxNFee->xControl.eMode =  sFeeWaitingSync;
				//pxNFee->xControl.eNextMode =  sToFeeStandBy;


				bFinal = FALSE;
8110cd80:	e03ff915 	stw	zero,-28(fp)
				break;
8110cd84:	00002406 	br	8110ce18 <vFeeTask+0x1150>

				#if DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: (sFeeWaitingSync)\n", pxNFee->ucId);
				#endif

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110cd88:	d0a05317 	ldw	r2,-32436(gp)
8110cd8c:	10800003 	ldbu	r2,0(r2)
8110cd90:	10803fcc 	andi	r2,r2,255
8110cd94:	1085883a 	add	r2,r2,r2
8110cd98:	1087883a 	add	r3,r2,r2
8110cd9c:	d0a06904 	addi	r2,gp,-32348
8110cda0:	1885883a 	add	r2,r3,r2
8110cda4:	10800017 	ldw	r2,0(r2)
8110cda8:	e0fffd44 	addi	r3,fp,-11
8110cdac:	180d883a 	mov	r6,r3
8110cdb0:	000b883a 	mov	r5,zero
8110cdb4:	1009883a 	mov	r4,r2
8110cdb8:	11366800 	call	81136680 <OSQPend>
8110cdbc:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code != OS_ERR_NONE ) {
8110cdc0:	e0bffd43 	ldbu	r2,-11(fp)
8110cdc4:	10803fcc 	andi	r2,r2,255
8110cdc8:	1000121e 	bne	r2,zero,8110ce14 <vFeeTask+0x114c>
					#if DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
8110cdcc:	d0a05317 	ldw	r2,-32436(gp)
8110cdd0:	e0fffe17 	ldw	r3,-8(fp)
8110cdd4:	180b883a 	mov	r5,r3
8110cdd8:	1009883a 	mov	r4,r2
8110cddc:	110ce1c0 	call	8110ce1c <vQCmdFEEinWaitingSync>
				}

				break;
8110cde0:	00000c06 	br	8110ce14 <vFeeTask+0x114c>


			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8110cde4:	d0a05317 	ldw	r2,-32436(gp)
8110cde8:	00c00144 	movi	r3,5
8110cdec:	10c02c15 	stw	r3,176(r2)
				#if DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				#endif
				break;
8110cdf0:	00000906 	br	8110ce18 <vFeeTask+0x1150>
					#if DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110cdf4:	0001883a 	nop
8110cdf8:	003bbd06 	br	8110bcf0 <__reset+0xfb0ebcf0>
					#if DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110cdfc:	0001883a 	nop
8110ce00:	003bbb06 	br	8110bcf0 <__reset+0xfb0ebcf0>
				} else {
					#if DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}	
				break;
8110ce04:	0001883a 	nop
8110ce08:	003bb906 	br	8110bcf0 <__reset+0xfb0ebcf0>
					#if DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110ce0c:	0001883a 	nop
8110ce10:	003bb706 	br	8110bcf0 <__reset+0xfb0ebcf0>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
8110ce14:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				#endif
				break;
		}

	}
8110ce18:	003bb506 	br	8110bcf0 <__reset+0xfb0ebcf0>

8110ce1c <vQCmdFEEinWaitingSync>:

}

void vQCmdFEEinWaitingSync( TNFee *pxNFeeP, unsigned int cmd ) {
8110ce1c:	defffb04 	addi	sp,sp,-20
8110ce20:	de00012e 	bgeu	sp,et,8110ce28 <vQCmdFEEinWaitingSync+0xc>
8110ce24:	003b68fa 	trap	3
8110ce28:	dfc00415 	stw	ra,16(sp)
8110ce2c:	df000315 	stw	fp,12(sp)
8110ce30:	df000304 	addi	fp,sp,12
8110ce34:	e13ffe15 	stw	r4,-8(fp)
8110ce38:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110ce3c:	e0bfff17 	ldw	r2,-4(fp)
8110ce40:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110ce44:	e0bffdc3 	ldbu	r2,-9(fp)
8110ce48:	10c03fcc 	andi	r3,r2,255
8110ce4c:	e0bffe17 	ldw	r2,-8(fp)
8110ce50:	10800003 	ldbu	r2,0(r2)
8110ce54:	10803fcc 	andi	r2,r2,255
8110ce58:	10800444 	addi	r2,r2,17
8110ce5c:	1880501e 	bne	r3,r2,8110cfa0 <vQCmdFEEinWaitingSync+0x184>

		switch (uiCmdFEEL.ucByte[2]) {
8110ce60:	e0bffd83 	ldbu	r2,-10(fp)
8110ce64:	10803fcc 	andi	r2,r2,255
8110ce68:	10c02860 	cmpeqi	r3,r2,161
8110ce6c:	18001a1e 	bne	r3,zero,8110ced8 <vQCmdFEEinWaitingSync+0xbc>
8110ce70:	10c02888 	cmpgei	r3,r2,162
8110ce74:	18000c1e 	bne	r3,zero,8110cea8 <vQCmdFEEinWaitingSync+0x8c>
8110ce78:	10c00120 	cmpeqi	r3,r2,4
8110ce7c:	18001f1e 	bne	r3,zero,8110cefc <vQCmdFEEinWaitingSync+0xe0>
8110ce80:	10c00148 	cmpgei	r3,r2,5
8110ce84:	1800031e 	bne	r3,zero,8110ce94 <vQCmdFEEinWaitingSync+0x78>
8110ce88:	10800060 	cmpeqi	r2,r2,1
8110ce8c:	1000121e 	bne	r2,zero,8110ced8 <vQCmdFEEinWaitingSync+0xbc>
				break;
			default:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
8110ce90:	00004306 	br	8110cfa0 <vQCmdFEEinWaitingSync+0x184>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8110ce94:	10c00220 	cmpeqi	r3,r2,8
8110ce98:	1800221e 	bne	r3,zero,8110cf24 <vQCmdFEEinWaitingSync+0x108>
8110ce9c:	108023e0 	cmpeqi	r2,r2,143
8110cea0:	1000351e 	bne	r2,zero,8110cf78 <vQCmdFEEinWaitingSync+0x15c>
				break;
			default:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
8110cea4:	00003e06 	br	8110cfa0 <vQCmdFEEinWaitingSync+0x184>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8110cea8:	10c03888 	cmpgei	r3,r2,226
8110ceac:	1800071e 	bne	r3,zero,8110cecc <vQCmdFEEinWaitingSync+0xb0>
8110ceb0:	10c03808 	cmpgei	r3,r2,224
8110ceb4:	1800291e 	bne	r3,zero,8110cf5c <vQCmdFEEinWaitingSync+0x140>
8110ceb8:	10c02920 	cmpeqi	r3,r2,164
8110cebc:	18000f1e 	bne	r3,zero,8110cefc <vQCmdFEEinWaitingSync+0xe0>
8110cec0:	10802a20 	cmpeqi	r2,r2,168
8110cec4:	1000171e 	bne	r2,zero,8110cf24 <vQCmdFEEinWaitingSync+0x108>
				break;
			default:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
8110cec8:	00003506 	br	8110cfa0 <vQCmdFEEinWaitingSync+0x184>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8110cecc:	10803c20 	cmpeqi	r2,r2,240
8110ced0:	10001e1e 	bne	r2,zero,8110cf4c <vQCmdFEEinWaitingSync+0x130>
				break;
			default:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
8110ced4:	00003206 	br	8110cfa0 <vQCmdFEEinWaitingSync+0x184>
	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110ced8:	e0bffe17 	ldw	r2,-8(fp)
8110cedc:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110cee0:	e0bffe17 	ldw	r2,-8(fp)
8110cee4:	00c00144 	movi	r3,5
8110cee8:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110ceec:	e0bffe17 	ldw	r2,-8(fp)
8110cef0:	00c00144 	movi	r3,5
8110cef4:	10c02d15 	stw	r3,180(r2)
				break;
8110cef8:	00002906 	br	8110cfa0 <vQCmdFEEinWaitingSync+0x184>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110cefc:	e0bffe17 	ldw	r2,-8(fp)
8110cf00:	00c00044 	movi	r3,1
8110cf04:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
8110cf08:	e0bffe17 	ldw	r2,-8(fp)
8110cf0c:	00c00304 	movi	r3,12
8110cf10:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110cf14:	e0bffe17 	ldw	r2,-8(fp)
8110cf18:	00c00184 	movi	r3,6
8110cf1c:	10c02d15 	stw	r3,180(r2)
				break;
8110cf20:	00001f06 	br	8110cfa0 <vQCmdFEEinWaitingSync+0x184>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110cf24:	e0bffe17 	ldw	r2,-8(fp)
8110cf28:	00c00044 	movi	r3,1
8110cf2c:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110cf30:	e0bffe17 	ldw	r2,-8(fp)
8110cf34:	00c00284 	movi	r3,10
8110cf38:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110cf3c:	e0bffe17 	ldw	r2,-8(fp)
8110cf40:	00c00304 	movi	r3,12
8110cf44:	10c02d15 	stw	r3,180(r2)
				break;
8110cf48:	00001506 	br	8110cfa0 <vQCmdFEEinWaitingSync+0x184>
			case M_FEE_RMAP:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPWaitingSync( pxNFeeP, cmd );
8110cf4c:	e17fff17 	ldw	r5,-4(fp)
8110cf50:	e13ffe17 	ldw	r4,-8(fp)
8110cf54:	110da3c0 	call	8110da3c <vQCmdFeeRMAPWaitingSync>
				break;
8110cf58:	00001106 	br	8110cfa0 <vQCmdFEEinWaitingSync+0x184>
			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110cf5c:	e0bffe17 	ldw	r2,-8(fp)
8110cf60:	10c02d17 	ldw	r3,180(r2)
8110cf64:	e0bffe17 	ldw	r2,-8(fp)
8110cf68:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110cf6c:	e0bffe17 	ldw	r2,-8(fp)
8110cf70:	10002815 	stw	zero,160(r2)

				break;
8110cf74:	00000a06 	br	8110cfa0 <vQCmdFEEinWaitingSync+0x184>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110cf78:	e0bffe17 	ldw	r2,-8(fp)
8110cf7c:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110cf80:	e0bffe17 	ldw	r2,-8(fp)
8110cf84:	10800003 	ldbu	r2,0(r2)
8110cf88:	10803fcc 	andi	r2,r2,255
8110cf8c:	100d883a 	mov	r6,r2
8110cf90:	000b883a 	mov	r5,zero
8110cf94:	01002044 	movi	r4,129
8110cf98:	110dfbc0 	call	8110dfbc <bSendGiveBackNFeeCtrl>
				break;
8110cf9c:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110cfa0:	0001883a 	nop
8110cfa4:	e037883a 	mov	sp,fp
8110cfa8:	dfc00117 	ldw	ra,4(sp)
8110cfac:	df000017 	ldw	fp,0(sp)
8110cfb0:	dec00204 	addi	sp,sp,8
8110cfb4:	f800283a 	ret

8110cfb8 <vQCmdFEEinConfig>:


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
8110cfb8:	defffb04 	addi	sp,sp,-20
8110cfbc:	de00012e 	bgeu	sp,et,8110cfc4 <vQCmdFEEinConfig+0xc>
8110cfc0:	003b68fa 	trap	3
8110cfc4:	dfc00415 	stw	ra,16(sp)
8110cfc8:	df000315 	stw	fp,12(sp)
8110cfcc:	df000304 	addi	fp,sp,12
8110cfd0:	e13ffe15 	stw	r4,-8(fp)
8110cfd4:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110cfd8:	e0bfff17 	ldw	r2,-4(fp)
8110cfdc:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110cfe0:	e0bffdc3 	ldbu	r2,-9(fp)
8110cfe4:	10c03fcc 	andi	r3,r2,255
8110cfe8:	e0bffe17 	ldw	r2,-8(fp)
8110cfec:	10800003 	ldbu	r2,0(r2)
8110cff0:	10803fcc 	andi	r2,r2,255
8110cff4:	10800444 	addi	r2,r2,17
8110cff8:	1880381e 	bne	r3,r2,8110d0dc <vQCmdFEEinConfig+0x124>

		switch (uiCmdFEEL.ucByte[2]) {
8110cffc:	e0bffd83 	ldbu	r2,-10(fp)
8110d000:	10803fcc 	andi	r2,r2,255
8110d004:	10c02860 	cmpeqi	r3,r2,161
8110d008:	18002d1e 	bne	r3,zero,8110d0c0 <vQCmdFEEinConfig+0x108>
8110d00c:	10c02888 	cmpgei	r3,r2,162
8110d010:	18000c1e 	bne	r3,zero,8110d044 <vQCmdFEEinConfig+0x8c>
8110d014:	10c00120 	cmpeqi	r3,r2,4
8110d018:	1800161e 	bne	r3,zero,8110d074 <vQCmdFEEinConfig+0xbc>
8110d01c:	10c00148 	cmpgei	r3,r2,5
8110d020:	1800031e 	bne	r3,zero,8110d030 <vQCmdFEEinConfig+0x78>
8110d024:	10800060 	cmpeqi	r2,r2,1
8110d028:	1000251e 	bne	r2,zero,8110d0c0 <vQCmdFEEinConfig+0x108>
				break;
			default:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
8110d02c:	00002b06 	br	8110d0dc <vQCmdFEEinConfig+0x124>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8110d030:	10c00220 	cmpeqi	r3,r2,8
8110d034:	1800241e 	bne	r3,zero,8110d0c8 <vQCmdFEEinConfig+0x110>
8110d038:	108023e0 	cmpeqi	r2,r2,143
8110d03c:	1000161e 	bne	r2,zero,8110d098 <vQCmdFEEinConfig+0xe0>
				break;
			default:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
8110d040:	00002606 	br	8110d0dc <vQCmdFEEinConfig+0x124>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8110d044:	10c03888 	cmpgei	r3,r2,226
8110d048:	1800071e 	bne	r3,zero,8110d068 <vQCmdFEEinConfig+0xb0>
8110d04c:	10c03808 	cmpgei	r3,r2,224
8110d050:	18001f1e 	bne	r3,zero,8110d0d0 <vQCmdFEEinConfig+0x118>
8110d054:	10c02920 	cmpeqi	r3,r2,164
8110d058:	1800061e 	bne	r3,zero,8110d074 <vQCmdFEEinConfig+0xbc>
8110d05c:	10802a20 	cmpeqi	r2,r2,168
8110d060:	1000191e 	bne	r2,zero,8110d0c8 <vQCmdFEEinConfig+0x110>
				break;
			default:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
8110d064:	00001d06 	br	8110d0dc <vQCmdFEEinConfig+0x124>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8110d068:	10803c20 	cmpeqi	r2,r2,240
8110d06c:	10001a1e 	bne	r2,zero,8110d0d8 <vQCmdFEEinConfig+0x120>
				break;
			default:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
8110d070:	00001a06 	br	8110d0dc <vQCmdFEEinConfig+0x124>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				break;*/
			case M_FEE_STANDBY: /* Config -> StandBy is always forced mode (don't need sync) */
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110d074:	e0bffe17 	ldw	r2,-8(fp)
8110d078:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110d07c:	e0bffe17 	ldw	r2,-8(fp)
8110d080:	00c00184 	movi	r3,6
8110d084:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110d088:	e0bffe17 	ldw	r2,-8(fp)
8110d08c:	00c00184 	movi	r3,6
8110d090:	10c02d15 	stw	r3,180(r2)
				break;				
8110d094:	00001106 	br	8110d0dc <vQCmdFEEinConfig+0x124>
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Shouldn't receive RMAP Messages in this mode (Config Mode)\n", pxNFeeP->ucId);
				#endif
				break;
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110d098:	e0bffe17 	ldw	r2,-8(fp)
8110d09c:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110d0a0:	e0bffe17 	ldw	r2,-8(fp)
8110d0a4:	10800003 	ldbu	r2,0(r2)
8110d0a8:	10803fcc 	andi	r2,r2,255
8110d0ac:	100d883a 	mov	r6,r2
8110d0b0:	000b883a 	mov	r5,zero
8110d0b4:	01002044 	movi	r4,129
8110d0b8:	110dfbc0 	call	8110dfbc <bSendGiveBackNFeeCtrl>
				break;
8110d0bc:	00000706 	br	8110d0dc <vQCmdFEEinConfig+0x124>
			case M_FEE_CONFIG_FORCED:
			case M_FEE_CONFIG:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
				#endif
				break;
8110d0c0:	0001883a 	nop
8110d0c4:	00000506 	br	8110d0dc <vQCmdFEEinConfig+0x124>
			case M_FEE_FULL_PATTERN_FORCED:
			case M_FEE_FULL_PATTERN:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
				#endif
				break;
8110d0c8:	0001883a 	nop
8110d0cc:	00000306 	br	8110d0dc <vQCmdFEEinConfig+0x124>
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
				break;
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
8110d0d0:	0001883a 	nop
8110d0d4:	00000106 	br	8110d0dc <vQCmdFEEinConfig+0x124>
				break;
			case M_FEE_RMAP:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Shouldn't receive RMAP Messages in this mode (Config Mode)\n", pxNFeeP->ucId);
				#endif
				break;
8110d0d8:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110d0dc:	0001883a 	nop
8110d0e0:	e037883a 	mov	sp,fp
8110d0e4:	dfc00117 	ldw	ra,4(sp)
8110d0e8:	df000017 	ldw	fp,0(sp)
8110d0ec:	dec00204 	addi	sp,sp,8
8110d0f0:	f800283a 	ret

8110d0f4 <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
8110d0f4:	defffb04 	addi	sp,sp,-20
8110d0f8:	de00012e 	bgeu	sp,et,8110d100 <vQCmdFEEinStandBy+0xc>
8110d0fc:	003b68fa 	trap	3
8110d100:	dfc00415 	stw	ra,16(sp)
8110d104:	df000315 	stw	fp,12(sp)
8110d108:	df000304 	addi	fp,sp,12
8110d10c:	e13ffe15 	stw	r4,-8(fp)
8110d110:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110d114:	e0bfff17 	ldw	r2,-4(fp)
8110d118:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110d11c:	e0bffdc3 	ldbu	r2,-9(fp)
8110d120:	10c03fcc 	andi	r3,r2,255
8110d124:	e0bffe17 	ldw	r2,-8(fp)
8110d128:	10800003 	ldbu	r2,0(r2)
8110d12c:	10803fcc 	andi	r2,r2,255
8110d130:	10800444 	addi	r2,r2,17
8110d134:	18804d1e 	bne	r3,r2,8110d26c <vQCmdFEEinStandBy+0x178>

		switch (uiCmdFEEL.ucByte[2]) {
8110d138:	e0bffd83 	ldbu	r2,-10(fp)
8110d13c:	10803fcc 	andi	r2,r2,255
8110d140:	10c02860 	cmpeqi	r3,r2,161
8110d144:	18001a1e 	bne	r3,zero,8110d1b0 <vQCmdFEEinStandBy+0xbc>
8110d148:	10c02888 	cmpgei	r3,r2,162
8110d14c:	18000c1e 	bne	r3,zero,8110d180 <vQCmdFEEinStandBy+0x8c>
8110d150:	10c00120 	cmpeqi	r3,r2,4
8110d154:	1800421e 	bne	r3,zero,8110d260 <vQCmdFEEinStandBy+0x16c>
8110d158:	10c00148 	cmpgei	r3,r2,5
8110d15c:	1800031e 	bne	r3,zero,8110d16c <vQCmdFEEinStandBy+0x78>
8110d160:	10800060 	cmpeqi	r2,r2,1
8110d164:	1000121e 	bne	r2,zero,8110d1b0 <vQCmdFEEinStandBy+0xbc>
				break;
			default:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
8110d168:	00004006 	br	8110d26c <vQCmdFEEinStandBy+0x178>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8110d16c:	10c00220 	cmpeqi	r3,r2,8
8110d170:	1800181e 	bne	r3,zero,8110d1d4 <vQCmdFEEinStandBy+0xe0>
8110d174:	108023e0 	cmpeqi	r2,r2,143
8110d178:	10002f1e 	bne	r2,zero,8110d238 <vQCmdFEEinStandBy+0x144>
				break;
			default:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
8110d17c:	00003b06 	br	8110d26c <vQCmdFEEinStandBy+0x178>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8110d180:	10c03888 	cmpgei	r3,r2,226
8110d184:	1800071e 	bne	r3,zero,8110d1a4 <vQCmdFEEinStandBy+0xb0>
8110d188:	10c03808 	cmpgei	r3,r2,224
8110d18c:	18001f1e 	bne	r3,zero,8110d20c <vQCmdFEEinStandBy+0x118>
8110d190:	10c02920 	cmpeqi	r3,r2,164
8110d194:	1800321e 	bne	r3,zero,8110d260 <vQCmdFEEinStandBy+0x16c>
8110d198:	10802a20 	cmpeqi	r2,r2,168
8110d19c:	10000d1e 	bne	r2,zero,8110d1d4 <vQCmdFEEinStandBy+0xe0>
				break;
			default:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
8110d1a0:	00003206 	br	8110d26c <vQCmdFEEinStandBy+0x178>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8110d1a4:	10803c20 	cmpeqi	r2,r2,240
8110d1a8:	1000141e 	bne	r2,zero,8110d1fc <vQCmdFEEinStandBy+0x108>
				break;
			default:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
8110d1ac:	00002f06 	br	8110d26c <vQCmdFEEinStandBy+0x178>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110d1b0:	e0bffe17 	ldw	r2,-8(fp)
8110d1b4:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110d1b8:	e0bffe17 	ldw	r2,-8(fp)
8110d1bc:	00c00144 	movi	r3,5
8110d1c0:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110d1c4:	e0bffe17 	ldw	r2,-8(fp)
8110d1c8:	00c00144 	movi	r3,5
8110d1cc:	10c02d15 	stw	r3,180(r2)
				break;				
8110d1d0:	00002606 	br	8110d26c <vQCmdFEEinStandBy+0x178>
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by mode\n", pxNFeeP->ucId);
				#endif
				break;
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110d1d4:	e0bffe17 	ldw	r2,-8(fp)
8110d1d8:	00c00044 	movi	r3,1
8110d1dc:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110d1e0:	e0bffe17 	ldw	r2,-8(fp)
8110d1e4:	00c00284 	movi	r3,10
8110d1e8:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110d1ec:	e0bffe17 	ldw	r2,-8(fp)
8110d1f0:	00c00304 	movi	r3,12
8110d1f4:	10c02d15 	stw	r3,180(r2)
				break;
8110d1f8:	00001c06 	br	8110d26c <vQCmdFEEinStandBy+0x178>

			case M_FEE_RMAP:
				vQCmdFeeRMAPinStandBy( pxNFeeP, cmd );
8110d1fc:	e17fff17 	ldw	r5,-4(fp)
8110d200:	e13ffe17 	ldw	r4,-8(fp)
8110d204:	110d4480 	call	8110d448 <vQCmdFeeRMAPinStandBy>
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */

				break;
8110d208:	00001806 	br	8110d26c <vQCmdFEEinStandBy+0x178>


			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8110d20c:	e0bffe17 	ldw	r2,-8(fp)
8110d210:	10802c17 	ldw	r2,176(r2)
8110d214:	10800318 	cmpnei	r2,r2,12
8110d218:	1000131e 	bne	r2,zero,8110d268 <vQCmdFEEinStandBy+0x174>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110d21c:	e0bffe17 	ldw	r2,-8(fp)
8110d220:	10c02d17 	ldw	r3,180(r2)
8110d224:	e0bffe17 	ldw	r2,-8(fp)
8110d228:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110d22c:	e0bffe17 	ldw	r2,-8(fp)
8110d230:	10002815 	stw	zero,160(r2)
				}
				break;
8110d234:	00000c06 	br	8110d268 <vQCmdFEEinStandBy+0x174>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110d238:	e0bffe17 	ldw	r2,-8(fp)
8110d23c:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110d240:	e0bffe17 	ldw	r2,-8(fp)
8110d244:	10800003 	ldbu	r2,0(r2)
8110d248:	10803fcc 	andi	r2,r2,255
8110d24c:	100d883a 	mov	r6,r2
8110d250:	000b883a 	mov	r5,zero
8110d254:	01002044 	movi	r4,129
8110d258:	110dfbc0 	call	8110dfbc <bSendGiveBackNFeeCtrl>
				break;
8110d25c:	00000306 	br	8110d26c <vQCmdFEEinStandBy+0x178>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by mode\n", pxNFeeP->ucId);
				#endif
				break;
8110d260:	0001883a 	nop
8110d264:	00000106 	br	8110d26c <vQCmdFEEinStandBy+0x178>
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}
				break;
8110d268:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110d26c:	0001883a 	nop
8110d270:	e037883a 	mov	sp,fp
8110d274:	dfc00117 	ldw	ra,4(sp)
8110d278:	df000017 	ldw	fp,0(sp)
8110d27c:	dec00204 	addi	sp,sp,8
8110d280:	f800283a 	ret

8110d284 <vQCmdFEEinFullPattern>:



void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
8110d284:	defffb04 	addi	sp,sp,-20
8110d288:	de00012e 	bgeu	sp,et,8110d290 <vQCmdFEEinFullPattern+0xc>
8110d28c:	003b68fa 	trap	3
8110d290:	dfc00415 	stw	ra,16(sp)
8110d294:	df000315 	stw	fp,12(sp)
8110d298:	df000304 	addi	fp,sp,12
8110d29c:	e13ffe15 	stw	r4,-8(fp)
8110d2a0:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110d2a4:	e0bfff17 	ldw	r2,-4(fp)
8110d2a8:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110d2ac:	e0bffdc3 	ldbu	r2,-9(fp)
8110d2b0:	10c03fcc 	andi	r3,r2,255
8110d2b4:	e0bffe17 	ldw	r2,-8(fp)
8110d2b8:	10800003 	ldbu	r2,0(r2)
8110d2bc:	10803fcc 	andi	r2,r2,255
8110d2c0:	10800444 	addi	r2,r2,17
8110d2c4:	18805a1e 	bne	r3,r2,8110d430 <vQCmdFEEinFullPattern+0x1ac>

		switch (uiCmdFEEL.ucByte[2]) {
8110d2c8:	e0bffd83 	ldbu	r2,-10(fp)
8110d2cc:	10803fcc 	andi	r2,r2,255
8110d2d0:	10c02860 	cmpeqi	r3,r2,161
8110d2d4:	1800181e 	bne	r3,zero,8110d338 <vQCmdFEEinFullPattern+0xb4>
8110d2d8:	10c02888 	cmpgei	r3,r2,162
8110d2dc:	18000c1e 	bne	r3,zero,8110d310 <vQCmdFEEinFullPattern+0x8c>
8110d2e0:	10c000a0 	cmpeqi	r3,r2,2
8110d2e4:	18004d1e 	bne	r3,zero,8110d41c <vQCmdFEEinFullPattern+0x198>
8110d2e8:	10c000c8 	cmpgei	r3,r2,3
8110d2ec:	1800031e 	bne	r3,zero,8110d2fc <vQCmdFEEinFullPattern+0x78>
8110d2f0:	10800060 	cmpeqi	r2,r2,1
8110d2f4:	1000101e 	bne	r2,zero,8110d338 <vQCmdFEEinFullPattern+0xb4>
				break;
			default:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
8110d2f8:	00004d06 	br	8110d430 <vQCmdFEEinFullPattern+0x1ac>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8110d2fc:	10c00120 	cmpeqi	r3,r2,4
8110d300:	1800161e 	bne	r3,zero,8110d35c <vQCmdFEEinFullPattern+0xd8>
8110d304:	10800220 	cmpeqi	r2,r2,8
8110d308:	1000461e 	bne	r2,zero,8110d424 <vQCmdFEEinFullPattern+0x1a0>
				break;
			default:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
8110d30c:	00004806 	br	8110d430 <vQCmdFEEinFullPattern+0x1ac>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8110d310:	10c03888 	cmpgei	r3,r2,226
8110d314:	1800051e 	bne	r3,zero,8110d32c <vQCmdFEEinFullPattern+0xa8>
8110d318:	10c03808 	cmpgei	r3,r2,224
8110d31c:	1800341e 	bne	r3,zero,8110d3f0 <vQCmdFEEinFullPattern+0x16c>
8110d320:	10802920 	cmpeqi	r2,r2,164
8110d324:	1000251e 	bne	r2,zero,8110d3bc <vQCmdFEEinFullPattern+0x138>
				break;
			default:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
8110d328:	00004106 	br	8110d430 <vQCmdFEEinFullPattern+0x1ac>

	uiCmdFEEL.ulWord = cmd;

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {

		switch (uiCmdFEEL.ucByte[2]) {
8110d32c:	10803c20 	cmpeqi	r2,r2,240
8110d330:	10002b1e 	bne	r2,zero,8110d3e0 <vQCmdFEEinFullPattern+0x15c>
				break;
			default:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
8110d334:	00003e06 	br	8110d430 <vQCmdFEEinFullPattern+0x1ac>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110d338:	e0bffe17 	ldw	r2,-8(fp)
8110d33c:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110d340:	e0bffe17 	ldw	r2,-8(fp)
8110d344:	00c00144 	movi	r3,5
8110d348:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110d34c:	e0bffe17 	ldw	r2,-8(fp)
8110d350:	00c00144 	movi	r3,5
8110d354:	10c02d15 	stw	r3,180(r2)
				break;				
8110d358:	00003506 	br	8110d430 <vQCmdFEEinFullPattern+0x1ac>
				break;
			case M_FEE_STANDBY:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;*/ /* To finish the actual transfer only when sync comes */
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
8110d35c:	e0bffe17 	ldw	r2,-8(fp)
8110d360:	10802c17 	ldw	r2,176(r2)
8110d364:	10800298 	cmpnei	r2,r2,10
8110d368:	10000a1e 	bne	r2,zero,8110d394 <vQCmdFEEinFullPattern+0x110>
					pxNFeeP->xControl.bWatingSync = TRUE;
8110d36c:	e0bffe17 	ldw	r2,-8(fp)
8110d370:	00c00044 	movi	r3,1
8110d374:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110d378:	e0bffe17 	ldw	r2,-8(fp)
8110d37c:	00c00304 	movi	r3,12
8110d380:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110d384:	e0bffe17 	ldw	r2,-8(fp)
8110d388:	00c00184 	movi	r3,6
8110d38c:	10c02d15 	stw	r3,180(r2)
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				}

				break;
8110d390:	00002706 	br	8110d430 <vQCmdFEEinFullPattern+0x1ac>
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				} else {
					pxNFeeP->xControl.bWatingSync = TRUE;
8110d394:	e0bffe17 	ldw	r2,-8(fp)
8110d398:	00c00044 	movi	r3,1
8110d39c:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8110d3a0:	e0bffe17 	ldw	r2,-8(fp)
8110d3a4:	00c00104 	movi	r3,4
8110d3a8:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110d3ac:	e0bffe17 	ldw	r2,-8(fp)
8110d3b0:	00c00184 	movi	r3,6
8110d3b4:	10c02d15 	stw	r3,180(r2)
				}

				break;
8110d3b8:	00001d06 	br	8110d430 <vQCmdFEEinFullPattern+0x1ac>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110d3bc:	e0bffe17 	ldw	r2,-8(fp)
8110d3c0:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110d3c4:	e0bffe17 	ldw	r2,-8(fp)
8110d3c8:	00c00184 	movi	r3,6
8110d3cc:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110d3d0:	e0bffe17 	ldw	r2,-8(fp)
8110d3d4:	00c00184 	movi	r3,6
8110d3d8:	10c02d15 	stw	r3,180(r2)
				break;				
8110d3dc:	00001406 	br	8110d430 <vQCmdFEEinFullPattern+0x1ac>
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
				#endif

				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPinFullPattern( pxNFeeP, cmd );
8110d3e0:	e17fff17 	ldw	r5,-4(fp)
8110d3e4:	e13ffe17 	ldw	r4,-8(fp)
8110d3e8:	110d7a40 	call	8110d7a4 <vQCmdFeeRMAPinFullPattern>

				break;
8110d3ec:	00001006 	br	8110d430 <vQCmdFEEinFullPattern+0x1ac>

			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8110d3f0:	e0bffe17 	ldw	r2,-8(fp)
8110d3f4:	10802c17 	ldw	r2,176(r2)
8110d3f8:	10800318 	cmpnei	r2,r2,12
8110d3fc:	10000b1e 	bne	r2,zero,8110d42c <vQCmdFEEinFullPattern+0x1a8>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110d400:	e0bffe17 	ldw	r2,-8(fp)
8110d404:	10c02d17 	ldw	r3,180(r2)
8110d408:	e0bffe17 	ldw	r2,-8(fp)
8110d40c:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110d410:	e0bffe17 	ldw	r2,-8(fp)
8110d414:	10002815 	stw	zero,160(r2)
				}

				break;
8110d418:	00000406 	br	8110d42c <vQCmdFEEinFullPattern+0x1a8>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110d41c:	0001883a 	nop
8110d420:	00000306 	br	8110d430 <vQCmdFEEinFullPattern+0x1ac>
				break;				
			case M_FEE_FULL_PATTERN:
				#if DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
				#endif
				break;
8110d424:	0001883a 	nop
8110d428:	00000106 	br	8110d430 <vQCmdFEEinFullPattern+0x1ac>
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}

				break;
8110d42c:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110d430:	0001883a 	nop
8110d434:	e037883a 	mov	sp,fp
8110d438:	dfc00117 	ldw	ra,4(sp)
8110d43c:	df000017 	ldw	fp,0(sp)
8110d440:	dec00204 	addi	sp,sp,8
8110d444:	f800283a 	ret

8110d448 <vQCmdFeeRMAPinStandBy>:



void vQCmdFeeRMAPinStandBy( TNFee *pxNFeeP, unsigned int cmd ){
8110d448:	defff704 	addi	sp,sp,-36
8110d44c:	de00012e 	bgeu	sp,et,8110d454 <vQCmdFeeRMAPinStandBy+0xc>
8110d450:	003b68fa 	trap	3
8110d454:	dfc00815 	stw	ra,32(sp)
8110d458:	df000715 	stw	fp,28(sp)
8110d45c:	df000704 	addi	fp,sp,28
8110d460:	e13ffe15 	stw	r4,-8(fp)
8110d464:	e17fff15 	stw	r5,-4(fp)
#if DEBUG_ON
	fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (StandBy)\n", pxNFeeP->ucId);
#endif


	uiCmdFEEL.ulWord = cmd;
8110d468:	e0bfff17 	ldw	r2,-4(fp)
8110d46c:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110d470:	e0bffd43 	ldbu	r2,-11(fp)
8110d474:	e0bff905 	stb	r2,-28(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110d478:	e0bffe17 	ldw	r2,-8(fp)
8110d47c:	10804317 	ldw	r2,268(r2)
8110d480:	e0fff903 	ldbu	r3,-28(fp)
8110d484:	180b883a 	mov	r5,r3
8110d488:	1009883a 	mov	r4,r2
8110d48c:	11081ac0 	call	811081ac <uliRmapReadReg>
8110d490:	e0bffa15 	stw	r2,-24(fp)

	switch (ucADDRReg) {
8110d494:	e0bff903 	ldbu	r2,-28(fp)
8110d498:	10bff004 	addi	r2,r2,-64
8110d49c:	10c003a8 	cmpgeui	r3,r2,14
8110d4a0:	1800b51e 	bne	r3,zero,8110d778 <vQCmdFeeRMAPinStandBy+0x330>
8110d4a4:	100690ba 	slli	r3,r2,2
8110d4a8:	00a04474 	movhi	r2,33041
8110d4ac:	10b52f04 	addi	r2,r2,-11076
8110d4b0:	1885883a 	add	r2,r3,r2
8110d4b4:	10800017 	ldw	r2,0(r2)
8110d4b8:	1000683a 	jmp	r2
8110d4bc:	8110d4f4 	orhi	r4,r16,17235
8110d4c0:	8110d780 	call	88110d78 <__reset+0x20f0d78>
8110d4c4:	8110d5e0 	cmpeqi	r4,r16,17239
8110d4c8:	8110d780 	call	88110d78 <__reset+0x20f0d78>
8110d4cc:	8110d780 	call	88110d78 <__reset+0x20f0d78>
8110d4d0:	8110d780 	call	88110d78 <__reset+0x20f0d78>
8110d4d4:	8110d780 	call	88110d78 <__reset+0x20f0d78>
8110d4d8:	8110d780 	call	88110d78 <__reset+0x20f0d78>
8110d4dc:	8110d780 	call	88110d78 <__reset+0x20f0d78>
8110d4e0:	8110d780 	call	88110d78 <__reset+0x20f0d78>
8110d4e4:	8110d780 	call	88110d78 <__reset+0x20f0d78>
8110d4e8:	8110d780 	call	88110d78 <__reset+0x20f0d78>
8110d4ec:	8110d6c0 	call	88110d6c <__reset+0x20f0d6c>
8110d4f0:	8110d724 	muli	r4,r16,17244
		case 0x40://0x00000000: ccd_seq_1_config
			ucValueMasked = (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 4; /* Number of rows */
8110d4f4:	e0fffa17 	ldw	r3,-24(fp)
8110d4f8:	00800434 	movhi	r2,16
8110d4fc:	10bffc04 	addi	r2,r2,-16
8110d500:	1884703a 	and	r2,r3,r2
8110d504:	1004d13a 	srli	r2,r2,4
8110d508:	e0bffb15 	stw	r2,-20(fp)
			ucValueMasked2 = (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 20; /* Number of columns */
8110d50c:	e0bffa17 	ldw	r2,-24(fp)
8110d510:	1004d53a 	srli	r2,r2,20
8110d514:	e0bffc15 	stw	r2,-16(fp)


			pxNFeeP->xCcdInfo.usiHeight = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
8110d518:	e0bffb17 	ldw	r2,-20(fp)
8110d51c:	1007883a 	mov	r3,r2
8110d520:	e0bffe17 	ldw	r2,-8(fp)
8110d524:	1080300b 	ldhu	r2,192(r2)
8110d528:	1885c83a 	sub	r2,r3,r2
8110d52c:	1007883a 	mov	r3,r2
8110d530:	e0bffe17 	ldw	r2,-8(fp)
8110d534:	10c0310d 	sth	r3,196(r2)
			pxNFeeP->xCcdInfo.usiHalfWidth = ucValueMasked2 - (pxNFeeP->xCcdInfo.usiSOverscanN + pxNFeeP->xCcdInfo.usiSPrescanN);
8110d538:	e0bffc17 	ldw	r2,-16(fp)
8110d53c:	1009883a 	mov	r4,r2
8110d540:	e0bffe17 	ldw	r2,-8(fp)
8110d544:	10c02f8b 	ldhu	r3,190(r2)
8110d548:	e0bffe17 	ldw	r2,-8(fp)
8110d54c:	10802f0b 	ldhu	r2,188(r2)
8110d550:	1885883a 	add	r2,r3,r2
8110d554:	2085c83a 	sub	r2,r4,r2
8110d558:	1007883a 	mov	r3,r2
8110d55c:	e0bffe17 	ldw	r2,-8(fp)
8110d560:	10c0308d 	sth	r3,194(r2)
			vUpdateMemMapFEE(pxNFeeP);
8110d564:	e13ffe17 	ldw	r4,-8(fp)
8110d568:	111766c0 	call	8111766c <vUpdateMemMapFEE>

			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110d56c:	e0bffe17 	ldw	r2,-8(fp)
8110d570:	10803304 	addi	r2,r2,204
8110d574:	1009883a 	mov	r4,r2
8110d578:	1102d4c0 	call	81102d4c <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFeeP->xCcdInfo.usiOLN;
8110d57c:	e0bffe17 	ldw	r2,-8(fp)
8110d580:	10c0300b 	ldhu	r3,192(r2)
8110d584:	e0bffe17 	ldw	r2,-8(fp)
8110d588:	10c0358d 	sth	r3,214(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = ucValueMasked2 ;
8110d58c:	e0bffc17 	ldw	r2,-16(fp)
8110d590:	1007883a 	mov	r3,r2
8110d594:	e0bffe17 	ldw	r2,-8(fp)
8110d598:	10c0340d 	sth	r3,208(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = ucValueMasked;
8110d59c:	e0bffb17 	ldw	r2,-20(fp)
8110d5a0:	1007883a 	mov	r3,r2
8110d5a4:	e0bffe17 	ldw	r2,-8(fp)
8110d5a8:	10c0348d 	sth	r3,210(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = ucValueMasked - pxNFeeP->xCcdInfo.usiOLN;
8110d5ac:	e0bffb17 	ldw	r2,-20(fp)
8110d5b0:	1007883a 	mov	r3,r2
8110d5b4:	e0bffe17 	ldw	r2,-8(fp)
8110d5b8:	1080300b 	ldhu	r2,192(r2)
8110d5bc:	1885c83a 	sub	r2,r3,r2
8110d5c0:	1007883a 	mov	r3,r2
8110d5c4:	e0bffe17 	ldw	r2,-8(fp)
8110d5c8:	10c0350d 	sth	r3,212(r2)
		
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110d5cc:	e0bffe17 	ldw	r2,-8(fp)
8110d5d0:	10803304 	addi	r2,r2,204
8110d5d4:	1009883a 	mov	r4,r2
8110d5d8:	1102b200 	call	81102b20 <bDpktSetPacketConfig>

			#if DEBUG_ON
				fprintf(fp,"- Rows: %u\n - Columns: %u\n", ucValueMasked, ucValueMasked2);
			#endif

			break;
8110d5dc:	00006b06 	br	8110d78c <vQCmdFeeRMAPinStandBy+0x344>
		case 0x041://0x00000004:ccd_seq_2_config
			break;
		case 0x042://0x00000008:spw_packet_1_config

			ucValueMasked = (ucValueReg & COMM_RMAP_PACKET_SIZE_CTRL_MSK) >> 4;
8110d5e0:	e0fffa17 	ldw	r3,-24(fp)
8110d5e4:	00800434 	movhi	r2,16
8110d5e8:	10bffc04 	addi	r2,r2,-16
8110d5ec:	1884703a 	and	r2,r3,r2
8110d5f0:	1004d13a 	srli	r2,r2,4
8110d5f4:	e0bffb15 	stw	r2,-20(fp)
			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110d5f8:	e0bffe17 	ldw	r2,-8(fp)
8110d5fc:	10803304 	addi	r2,r2,204
8110d600:	1009883a 	mov	r4,r2
8110d604:	1102d4c0 	call	81102d4c <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = ucValueMasked;
8110d608:	e0bffb17 	ldw	r2,-20(fp)
8110d60c:	1007883a 	mov	r3,r2
8110d610:	e0bffe17 	ldw	r2,-8(fp)
8110d614:	10c0360d 	sth	r3,216(r2)
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110d618:	e0bffe17 	ldw	r2,-8(fp)
8110d61c:	10803304 	addi	r2,r2,204
8110d620:	1009883a 	mov	r4,r2
8110d624:	1102b200 	call	81102b20 <bDpktSetPacketConfig>

			#if DEBUG_ON
				fprintf(fp,"- Pckt Length: %u\n", ucValueMasked);
			#endif

			ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8110d628:	e0bffa17 	ldw	r2,-24(fp)
8110d62c:	1080030c 	andi	r2,r2,12
8110d630:	1004d0ba 	srli	r2,r2,2
8110d634:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked2) {
8110d638:	e0bffc17 	ldw	r2,-16(fp)
8110d63c:	10c000a0 	cmpeqi	r3,r2,2
8110d640:	1800071e 	bne	r3,zero,8110d660 <vQCmdFeeRMAPinStandBy+0x218>
8110d644:	10c000e0 	cmpeqi	r3,r2,3
8110d648:	1800091e 	bne	r3,zero,8110d670 <vQCmdFeeRMAPinStandBy+0x228>
8110d64c:	10800060 	cmpeqi	r2,r2,1
8110d650:	10000926 	beq	r2,zero,8110d678 <vQCmdFeeRMAPinStandBy+0x230>
				case 0b01:
					pxNFeeP->xControl.eSide = sLeft;
8110d654:	e0bffe17 	ldw	r2,-8(fp)
8110d658:	10002e15 	stw	zero,184(r2)
					#if DEBUG_ON
						fprintf(fp," - Left side\n");
					#endif
					break;
8110d65c:	00001706 	br	8110d6bc <vQCmdFeeRMAPinStandBy+0x274>
				case 0b10:
					pxNFeeP->xControl.eSide = sRight;
8110d660:	e0bffe17 	ldw	r2,-8(fp)
8110d664:	00c00044 	movi	r3,1
8110d668:	10c02e15 	stw	r3,184(r2)
					#if DEBUG_ON
						fprintf(fp," - Right side\n");
					#endif
					break;
8110d66c:	00001306 	br	8110d6bc <vQCmdFeeRMAPinStandBy+0x274>
				case 0b11:
					pxNFeeP->xControl.eSide = sLeft;
8110d670:	e0bffe17 	ldw	r2,-8(fp)
8110d674:	10002e15 	stw	zero,184(r2)
					#if DEBUG_ON
						fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
					#endif
				default:
					pxNFeeP->xControl.eSide = sLeft;
8110d678:	e0bffe17 	ldw	r2,-8(fp)
8110d67c:	10002e15 	stw	zero,184(r2)

					bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110d680:	e0bffe17 	ldw	r2,-8(fp)
8110d684:	10804304 	addi	r2,r2,268
8110d688:	1009883a 	mov	r4,r2
8110d68c:	11064340 	call	81106434 <bRmapGetMemConfigArea>
					pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
8110d690:	e0bffe17 	ldw	r2,-8(fp)
8110d694:	10c05717 	ldw	r3,348(r2)
8110d698:	00bffdc4 	movi	r2,-9
8110d69c:	1886703a 	and	r3,r3,r2
8110d6a0:	e0bffe17 	ldw	r2,-8(fp)
8110d6a4:	10c05715 	stw	r3,348(r2)
					bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110d6a8:	e0bffe17 	ldw	r2,-8(fp)
8110d6ac:	10804304 	addi	r2,r2,268
8110d6b0:	1009883a 	mov	r4,r2
8110d6b4:	11061480 	call	81106148 <bRmapSetMemConfigArea>
					#if DEBUG_ON
						fprintf(fp," - Switching to Left side\n");
					#endif
					break;
8110d6b8:	0001883a 	nop
				}
			#if DEBUG_ON
				fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
			#endif
			break;
8110d6bc:	00003306 	br	8110d78c <vQCmdFeeRMAPinStandBy+0x344>
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
				break;
		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8110d6c0:	e0bffa17 	ldw	r2,-24(fp)
8110d6c4:	10803c0c 	andi	r2,r2,240
8110d6c8:	1004d13a 	srli	r2,r2,4
8110d6cc:	e0bffb15 	stw	r2,-20(fp)

			switch (ucValueMasked) {
8110d6d0:	e0bffb17 	ldw	r2,-20(fp)
8110d6d4:	10c000a0 	cmpeqi	r3,r2,2
8110d6d8:	1800041e 	bne	r3,zero,8110d6ec <vQCmdFeeRMAPinStandBy+0x2a4>
8110d6dc:	10c001a0 	cmpeqi	r3,r2,6
8110d6e0:	18000c1e 	bne	r3,zero,8110d714 <vQCmdFeeRMAPinStandBy+0x2cc>
8110d6e4:	10000d26 	beq	r2,zero,8110d71c <vQCmdFeeRMAPinStandBy+0x2d4>
				case 5:
				default:
					#if DEBUG_ON
						fprintf(fp,"- mode not allowed yet ( %hhu )\n", ucValueMasked);
					#endif
					break;
8110d6e8:	00000d06 	br	8110d720 <vQCmdFeeRMAPinStandBy+0x2d8>
				case 2: /* PAttern Full image */
				#if DEBUG_ON
					fprintf(fp,"- to Full-Image-Pattern\n");
				#endif

					pxNFeeP->xControl.bWatingSync = TRUE;
8110d6ec:	e0bffe17 	ldw	r2,-8(fp)
8110d6f0:	00c00044 	movi	r3,1
8110d6f4:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110d6f8:	e0bffe17 	ldw	r2,-8(fp)
8110d6fc:	00c00284 	movi	r3,10
8110d700:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110d704:	e0bffe17 	ldw	r2,-8(fp)
8110d708:	00c00304 	movi	r3,12
8110d70c:	10c02d15 	stw	r3,180(r2)

					break;
8110d710:	00000306 	br	8110d720 <vQCmdFeeRMAPinStandBy+0x2d8>
				case 6:
				#if DEBUG_ON
					fprintf(fp,"- Off-Mode not allowed.\n");
				#endif
					break;
8110d714:	0001883a 	nop
8110d718:	00001c06 	br	8110d78c <vQCmdFeeRMAPinStandBy+0x344>

				#if DEBUG_ON
					fprintf(fp,"- already in Stand by mode\n", pxNFeeP->ucId);
				#endif

					break;
8110d71c:	0001883a 	nop
						fprintf(fp,"- mode not allowed yet ( %hhu )\n", ucValueMasked);
					#endif
					break;
			}

			break;
8110d720:	00001a06 	br	8110d78c <vQCmdFeeRMAPinStandBy+0x344>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8110d724:	e0bffa17 	ldw	r2,-24(fp)
8110d728:	1080010c 	andi	r2,r2,4
8110d72c:	1004d0ba 	srli	r2,r2,2
8110d730:	e0bffb15 	stw	r2,-20(fp)

			/* Cannot perform this operation */
			if ( ucValueMasked ) {
8110d734:	e0bffb17 	ldw	r2,-20(fp)
8110d738:	10001326 	beq	r2,zero,8110d788 <vQCmdFeeRMAPinStandBy+0x340>
				#if DEBUG_ON
					fprintf(fp," - operation not allowed (StandBy-Mode)\n");
				#endif
				/* Clear the trigger */
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110d73c:	e0bffe17 	ldw	r2,-8(fp)
8110d740:	10804304 	addi	r2,r2,268
8110d744:	1009883a 	mov	r4,r2
8110d748:	11064340 	call	81106434 <bRmapGetMemConfigArea>
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
8110d74c:	e0bffe17 	ldw	r2,-8(fp)
8110d750:	10c06217 	ldw	r3,392(r2)
8110d754:	00bffec4 	movi	r2,-5
8110d758:	1886703a 	and	r3,r3,r2
8110d75c:	e0bffe17 	ldw	r2,-8(fp)
8110d760:	10c06215 	stw	r3,392(r2)
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110d764:	e0bffe17 	ldw	r2,-8(fp)
8110d768:	10804304 	addi	r2,r2,268
8110d76c:	1009883a 	mov	r4,r2
8110d770:	11061480 	call	81106148 <bRmapSetMemConfigArea>
			}

			break;
8110d774:	00000406 	br	8110d788 <vQCmdFeeRMAPinStandBy+0x340>
		case 0x00000051://0x0000004C:current_mode
		default:
			#if DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
8110d778:	0001883a 	nop
8110d77c:	00000306 	br	8110d78c <vQCmdFeeRMAPinStandBy+0x344>
				fprintf(fp,"- Rows: %u\n - Columns: %u\n", ucValueMasked, ucValueMasked2);
			#endif

			break;
		case 0x041://0x00000004:ccd_seq_2_config
			break;
8110d780:	0001883a 	nop
8110d784:	00000106 	br	8110d78c <vQCmdFeeRMAPinStandBy+0x344>
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
8110d788:	0001883a 	nop
			#if DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
8110d78c:	0001883a 	nop
8110d790:	e037883a 	mov	sp,fp
8110d794:	dfc00117 	ldw	ra,4(sp)
8110d798:	df000017 	ldw	fp,0(sp)
8110d79c:	dec00204 	addi	sp,sp,8
8110d7a0:	f800283a 	ret

8110d7a4 <vQCmdFeeRMAPinFullPattern>:

void vQCmdFeeRMAPinFullPattern( TNFee *pxNFeeP, unsigned int cmd ) {
8110d7a4:	defff804 	addi	sp,sp,-32
8110d7a8:	de00012e 	bgeu	sp,et,8110d7b0 <vQCmdFeeRMAPinFullPattern+0xc>
8110d7ac:	003b68fa 	trap	3
8110d7b0:	dfc00715 	stw	ra,28(sp)
8110d7b4:	df000615 	stw	fp,24(sp)
8110d7b8:	df000604 	addi	fp,sp,24
8110d7bc:	e13ffe15 	stw	r4,-8(fp)
8110d7c0:	e17fff15 	stw	r5,-4(fp)

	#if DEBUG_ON
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (FullPattern)\n", pxNFeeP->ucId);
	#endif

	uiCmdFEEL.ulWord = cmd;
8110d7c4:	e0bfff17 	ldw	r2,-4(fp)
8110d7c8:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110d7cc:	e0bffd43 	ldbu	r2,-11(fp)
8110d7d0:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110d7d4:	e0bffe17 	ldw	r2,-8(fp)
8110d7d8:	10804317 	ldw	r2,268(r2)
8110d7dc:	e0fffa03 	ldbu	r3,-24(fp)
8110d7e0:	180b883a 	mov	r5,r3
8110d7e4:	1009883a 	mov	r4,r2
8110d7e8:	11081ac0 	call	811081ac <uliRmapReadReg>
8110d7ec:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
8110d7f0:	e0bffa03 	ldbu	r2,-24(fp)
8110d7f4:	10bff004 	addi	r2,r2,-64
8110d7f8:	10c003a8 	cmpgeui	r3,r2,14
8110d7fc:	1800821e 	bne	r3,zero,8110da08 <vQCmdFeeRMAPinFullPattern+0x264>
8110d800:	100690ba 	slli	r3,r2,2
8110d804:	00a04474 	movhi	r2,33041
8110d808:	10b60604 	addi	r2,r2,-10216
8110d80c:	1885883a 	add	r2,r3,r2
8110d810:	10800017 	ldw	r2,0(r2)
8110d814:	1000683a 	jmp	r2
8110d818:	8110d850 	cmplti	r4,r16,17249
8110d81c:	8110d850 	cmplti	r4,r16,17249
8110d820:	8110d850 	cmplti	r4,r16,17249
8110d824:	8110da10 	cmplti	r4,r16,17256
8110d828:	8110da10 	cmplti	r4,r16,17256
8110d82c:	8110da10 	cmplti	r4,r16,17256
8110d830:	8110da10 	cmplti	r4,r16,17256
8110d834:	8110da10 	cmplti	r4,r16,17256
8110d838:	8110da10 	cmplti	r4,r16,17256
8110d83c:	8110da10 	cmplti	r4,r16,17256
8110d840:	8110da10 	cmplti	r4,r16,17256
8110d844:	8110da10 	cmplti	r4,r16,17256
8110d848:	8110d920 	cmpeqi	r4,r16,17252
8110d84c:	8110d9bc 	xorhi	r4,r16,17254
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config
			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
8110d850:	e0bffe17 	ldw	r2,-8(fp)
8110d854:	10802d17 	ldw	r2,180(r2)
8110d858:	108001e0 	cmpeqi	r2,r2,7
8110d85c:	1000041e 	bne	r2,zero,8110d870 <vQCmdFeeRMAPinFullPattern+0xcc>
8110d860:	e0bffe17 	ldw	r2,-8(fp)
8110d864:	10802d17 	ldw	r2,180(r2)
8110d868:	10800318 	cmpnei	r2,r2,12
8110d86c:	10006a1e 	bne	r2,zero,8110da18 <vQCmdFeeRMAPinFullPattern+0x274>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8110d870:	e0bffa43 	ldbu	r2,-23(fp)
8110d874:	1080030c 	andi	r2,r2,12
8110d878:	1005d0ba 	srai	r2,r2,2
8110d87c:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
8110d880:	e0bffb17 	ldw	r2,-20(fp)
8110d884:	10c000a0 	cmpeqi	r3,r2,2
8110d888:	1800071e 	bne	r3,zero,8110d8a8 <vQCmdFeeRMAPinFullPattern+0x104>
8110d88c:	10c000e0 	cmpeqi	r3,r2,3
8110d890:	1800091e 	bne	r3,zero,8110d8b8 <vQCmdFeeRMAPinFullPattern+0x114>
8110d894:	10800060 	cmpeqi	r2,r2,1
8110d898:	10000926 	beq	r2,zero,8110d8c0 <vQCmdFeeRMAPinFullPattern+0x11c>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
8110d89c:	e0bffe17 	ldw	r2,-8(fp)
8110d8a0:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
							fprintf(fp," - Left side\n");
						#endif
						break;
8110d8a4:	00001706 	br	8110d904 <vQCmdFeeRMAPinFullPattern+0x160>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
8110d8a8:	e0bffe17 	ldw	r2,-8(fp)
8110d8ac:	00c00044 	movi	r3,1
8110d8b0:	10c02e15 	stw	r3,184(r2)
						#if DEBUG_ON
							fprintf(fp," - Right side\n");
						#endif
						break;
8110d8b4:	00001306 	br	8110d904 <vQCmdFeeRMAPinFullPattern+0x160>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
8110d8b8:	e0bffe17 	ldw	r2,-8(fp)
8110d8bc:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
8110d8c0:	e0bffe17 	ldw	r2,-8(fp)
8110d8c4:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110d8c8:	e0bffe17 	ldw	r2,-8(fp)
8110d8cc:	10804304 	addi	r2,r2,268
8110d8d0:	1009883a 	mov	r4,r2
8110d8d4:	11064340 	call	81106434 <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
8110d8d8:	e0bffe17 	ldw	r2,-8(fp)
8110d8dc:	10c05717 	ldw	r3,348(r2)
8110d8e0:	00bffdc4 	movi	r2,-9
8110d8e4:	1886703a 	and	r3,r3,r2
8110d8e8:	e0bffe17 	ldw	r2,-8(fp)
8110d8ec:	10c05715 	stw	r3,348(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110d8f0:	e0bffe17 	ldw	r2,-8(fp)
8110d8f4:	10804304 	addi	r2,r2,268
8110d8f8:	1009883a 	mov	r4,r2
8110d8fc:	11061480 	call	81106148 <bRmapSetMemConfigArea>
						#if DEBUG_ON
							fprintf(fp," - Switching to Left side\n");
						#endif
					break;
8110d900:	0001883a 	nop
				#if DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
8110d904:	e0bffe17 	ldw	r2,-8(fp)
8110d908:	00c00284 	movi	r3,10
8110d90c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
8110d910:	e0bffe17 	ldw	r2,-8(fp)
8110d914:	00c00304 	movi	r3,12
8110d918:	10c02d15 	stw	r3,180(r2)
				}
			}



			break;
8110d91c:	00003e06 	br	8110da18 <vQCmdFeeRMAPinFullPattern+0x274>
			#endif
				break;

		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8110d920:	e0bffa43 	ldbu	r2,-23(fp)
8110d924:	1004d13a 	srli	r2,r2,4
8110d928:	10803fcc 	andi	r2,r2,255
8110d92c:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked) {
8110d930:	e0bffc17 	ldw	r2,-16(fp)
8110d934:	10c000a0 	cmpeqi	r3,r2,2
8110d938:	18001c1e 	bne	r3,zero,8110d9ac <vQCmdFeeRMAPinFullPattern+0x208>
8110d93c:	10c001a0 	cmpeqi	r3,r2,6
8110d940:	18001c1e 	bne	r3,zero,8110d9b4 <vQCmdFeeRMAPinFullPattern+0x210>
8110d944:	10000126 	beq	r2,zero,8110d94c <vQCmdFeeRMAPinFullPattern+0x1a8>
				case 5:
				default:
					#if DEBUG_ON
						fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
					#endif
					break;
8110d948:	00001b06 	br	8110d9b8 <vQCmdFeeRMAPinFullPattern+0x214>
				case 0: /* Standby */
				#if DEBUG_ON
					fprintf(fp,"- to Stand-By\n");
				#endif

					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
8110d94c:	e0bffe17 	ldw	r2,-8(fp)
8110d950:	10802c17 	ldw	r2,176(r2)
8110d954:	10800298 	cmpnei	r2,r2,10
8110d958:	10000a1e 	bne	r2,zero,8110d984 <vQCmdFeeRMAPinFullPattern+0x1e0>
						pxNFeeP->xControl.bWatingSync = TRUE;
8110d95c:	e0bffe17 	ldw	r2,-8(fp)
8110d960:	00c00044 	movi	r3,1
8110d964:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110d968:	e0bffe17 	ldw	r2,-8(fp)
8110d96c:	00c00304 	movi	r3,12
8110d970:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110d974:	e0bffe17 	ldw	r2,-8(fp)
8110d978:	00c00184 	movi	r3,6
8110d97c:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
8110d980:	00000d06 	br	8110d9b8 <vQCmdFeeRMAPinFullPattern+0x214>
					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
						pxNFeeP->xControl.bWatingSync = TRUE;
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
					} else {
						pxNFeeP->xControl.bWatingSync = TRUE;
8110d984:	e0bffe17 	ldw	r2,-8(fp)
8110d988:	00c00044 	movi	r3,1
8110d98c:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8110d990:	e0bffe17 	ldw	r2,-8(fp)
8110d994:	00c00104 	movi	r3,4
8110d998:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110d99c:	e0bffe17 	ldw	r2,-8(fp)
8110d9a0:	00c00184 	movi	r3,6
8110d9a4:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
8110d9a8:	00000306 	br	8110d9b8 <vQCmdFeeRMAPinFullPattern+0x214>
				case 2: /* PAttern Full image */
					#if DEBUG_ON
						fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
					#endif

					break;
8110d9ac:	0001883a 	nop
8110d9b0:	00001c06 	br	8110da24 <vQCmdFeeRMAPinFullPattern+0x280>
				case 6:
				#if DEBUG_ON
					fprintf(fp," Off-Mode not allowed.\n");
				#endif
					break;
8110d9b4:	0001883a 	nop
						fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
					#endif
					break;
			}

			break;
8110d9b8:	00001a06 	br	8110da24 <vQCmdFeeRMAPinFullPattern+0x280>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8110d9bc:	e0bffa43 	ldbu	r2,-23(fp)
8110d9c0:	1080010c 	andi	r2,r2,4
8110d9c4:	10803fcc 	andi	r2,r2,255
8110d9c8:	1004d0ba 	srli	r2,r2,2
8110d9cc:	10803fcc 	andi	r2,r2,255
8110d9d0:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
8110d9d4:	e0bffc17 	ldw	r2,-16(fp)
8110d9d8:	10001126 	beq	r2,zero,8110da20 <vQCmdFeeRMAPinFullPattern+0x27c>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
8110d9dc:	e0bffe17 	ldw	r2,-8(fp)
8110d9e0:	10802d17 	ldw	r2,180(r2)
8110d9e4:	10800198 	cmpnei	r2,r2,6
8110d9e8:	10000d1e 	bne	r2,zero,8110da20 <vQCmdFeeRMAPinFullPattern+0x27c>
					pxNFeeP->xControl.bWatingSync = FALSE;
8110d9ec:	e0bffe17 	ldw	r2,-8(fp)
8110d9f0:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110d9f4:	e0bffe17 	ldw	r2,-8(fp)
8110d9f8:	10c02d17 	ldw	r3,180(r2)
8110d9fc:	e0bffe17 	ldw	r2,-8(fp)
8110da00:	10c02c15 	stw	r3,176(r2)
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
8110da04:	00000606 	br	8110da20 <vQCmdFeeRMAPinFullPattern+0x27c>
		case 0x00000051://0x0000004C:current_mode
		default:
			#if DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
8110da08:	0001883a 	nop
8110da0c:	00000506 	br	8110da24 <vQCmdFeeRMAPinFullPattern+0x280>
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#if DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
				break;
8110da10:	0001883a 	nop
8110da14:	00000306 	br	8110da24 <vQCmdFeeRMAPinFullPattern+0x280>
				}
			}



			break;
8110da18:	0001883a 	nop
8110da1c:	00000106 	br	8110da24 <vQCmdFeeRMAPinFullPattern+0x280>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
8110da20:	0001883a 	nop
			#if DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
8110da24:	0001883a 	nop
8110da28:	e037883a 	mov	sp,fp
8110da2c:	dfc00117 	ldw	ra,4(sp)
8110da30:	df000017 	ldw	fp,0(sp)
8110da34:	dec00204 	addi	sp,sp,8
8110da38:	f800283a 	ret

8110da3c <vQCmdFeeRMAPWaitingSync>:


void vQCmdFeeRMAPWaitingSync( TNFee *pxNFeeP, unsigned int cmd ){
8110da3c:	defff804 	addi	sp,sp,-32
8110da40:	de00012e 	bgeu	sp,et,8110da48 <vQCmdFeeRMAPWaitingSync+0xc>
8110da44:	003b68fa 	trap	3
8110da48:	dfc00715 	stw	ra,28(sp)
8110da4c:	df000615 	stw	fp,24(sp)
8110da50:	df000604 	addi	fp,sp,24
8110da54:	e13ffe15 	stw	r4,-8(fp)
8110da58:	e17fff15 	stw	r5,-4(fp)

	#if DEBUG_ON
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (WaitingSync)\n", pxNFeeP->ucId);
	#endif

	uiCmdFEEL.ulWord = cmd;
8110da5c:	e0bfff17 	ldw	r2,-4(fp)
8110da60:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110da64:	e0bffd43 	ldbu	r2,-11(fp)
8110da68:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110da6c:	e0bffe17 	ldw	r2,-8(fp)
8110da70:	10804317 	ldw	r2,268(r2)
8110da74:	e0fffa03 	ldbu	r3,-24(fp)
8110da78:	180b883a 	mov	r5,r3
8110da7c:	1009883a 	mov	r4,r2
8110da80:	11081ac0 	call	811081ac <uliRmapReadReg>
8110da84:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
8110da88:	e0bffa03 	ldbu	r2,-24(fp)
8110da8c:	10c010c8 	cmpgei	r3,r2,67
8110da90:	1800051e 	bne	r3,zero,8110daa8 <vQCmdFeeRMAPWaitingSync+0x6c>
8110da94:	10c01008 	cmpgei	r3,r2,64
8110da98:	1800081e 	bne	r3,zero,8110dabc <vQCmdFeeRMAPWaitingSync+0x80>
8110da9c:	108000a0 	cmpeqi	r2,r2,2
8110daa0:	10005b1e 	bne	r2,zero,8110dc10 <vQCmdFeeRMAPWaitingSync+0x1d4>
		case 0x00000051://0x0000004C:current_mode
		default:
			#if DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
8110daa4:	00007a06 	br	8110dc90 <vQCmdFeeRMAPWaitingSync+0x254>

	ucADDRReg = uiCmdFEEL.ucByte[1];
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);


	switch (ucADDRReg) {
8110daa8:	10c01350 	cmplti	r3,r2,77
8110daac:	1800371e 	bne	r3,zero,8110db8c <vQCmdFeeRMAPWaitingSync+0x150>
8110dab0:	10801360 	cmpeqi	r2,r2,77
8110dab4:	1000601e 	bne	r2,zero,8110dc38 <vQCmdFeeRMAPWaitingSync+0x1fc>
		case 0x00000051://0x0000004C:current_mode
		default:
			#if DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
8110dab8:	00007506 	br	8110dc90 <vQCmdFeeRMAPWaitingSync+0x254>
	switch (ucADDRReg) {
		case 0x40://0x00000000: ccd_seq_1_config
		case 0x041://0x00000004:ccd_seq_2_config
		case 0x042://0x00000008:spw_packet_1_config

			if ( (pxNFeeP->xControl.eNextMode == sToTestFullPattern) || (pxNFeeP->xControl.eNextMode == sFeeWaitingSync) )
8110dabc:	e0bffe17 	ldw	r2,-8(fp)
8110dac0:	10802d17 	ldw	r2,180(r2)
8110dac4:	108001e0 	cmpeqi	r2,r2,7
8110dac8:	1000041e 	bne	r2,zero,8110dadc <vQCmdFeeRMAPWaitingSync+0xa0>
8110dacc:	e0bffe17 	ldw	r2,-8(fp)
8110dad0:	10802d17 	ldw	r2,180(r2)
8110dad4:	10800318 	cmpnei	r2,r2,12
8110dad8:	10006a1e 	bne	r2,zero,8110dc84 <vQCmdFeeRMAPWaitingSync+0x248>
			{

				ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8110dadc:	e0bffa43 	ldbu	r2,-23(fp)
8110dae0:	1080030c 	andi	r2,r2,12
8110dae4:	1005d0ba 	srai	r2,r2,2
8110dae8:	e0bffb15 	stw	r2,-20(fp)

				switch (ucValueMasked2) {
8110daec:	e0bffb17 	ldw	r2,-20(fp)
8110daf0:	10c000a0 	cmpeqi	r3,r2,2
8110daf4:	1800071e 	bne	r3,zero,8110db14 <vQCmdFeeRMAPWaitingSync+0xd8>
8110daf8:	10c000e0 	cmpeqi	r3,r2,3
8110dafc:	1800091e 	bne	r3,zero,8110db24 <vQCmdFeeRMAPWaitingSync+0xe8>
8110db00:	10800060 	cmpeqi	r2,r2,1
8110db04:	10000926 	beq	r2,zero,8110db2c <vQCmdFeeRMAPWaitingSync+0xf0>
					case 0b01:
						pxNFeeP->xControl.eSide = sLeft;
8110db08:	e0bffe17 	ldw	r2,-8(fp)
8110db0c:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
							fprintf(fp," - Left side\n");
						#endif
						break;
8110db10:	00001706 	br	8110db70 <vQCmdFeeRMAPWaitingSync+0x134>
					case 0b10:
						pxNFeeP->xControl.eSide = sRight;
8110db14:	e0bffe17 	ldw	r2,-8(fp)
8110db18:	00c00044 	movi	r3,1
8110db1c:	10c02e15 	stw	r3,184(r2)
						#if DEBUG_ON
							fprintf(fp," - Right side\n");
						#endif
						break;
8110db20:	00001306 	br	8110db70 <vQCmdFeeRMAPWaitingSync+0x134>
					case 0b11:
						pxNFeeP->xControl.eSide = sLeft;
8110db24:	e0bffe17 	ldw	r2,-8(fp)
8110db28:	10002e15 	stw	zero,184(r2)
						#if DEBUG_ON
							fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
						#endif
					default:
						pxNFeeP->xControl.eSide = sLeft;
8110db2c:	e0bffe17 	ldw	r2,-8(fp)
8110db30:	10002e15 	stw	zero,184(r2)

						bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110db34:	e0bffe17 	ldw	r2,-8(fp)
8110db38:	10804304 	addi	r2,r2,268
8110db3c:	1009883a 	mov	r4,r2
8110db40:	11064340 	call	81106434 <bRmapGetMemConfigArea>
						pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
8110db44:	e0bffe17 	ldw	r2,-8(fp)
8110db48:	10c05717 	ldw	r3,348(r2)
8110db4c:	00bffdc4 	movi	r2,-9
8110db50:	1886703a 	and	r3,r3,r2
8110db54:	e0bffe17 	ldw	r2,-8(fp)
8110db58:	10c05715 	stw	r3,348(r2)
						bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110db5c:	e0bffe17 	ldw	r2,-8(fp)
8110db60:	10804304 	addi	r2,r2,268
8110db64:	1009883a 	mov	r4,r2
8110db68:	11061480 	call	81106148 <bRmapSetMemConfigArea>
						#if DEBUG_ON
							fprintf(fp," - Switching to Left side\n");
						#endif
					break;
8110db6c:	0001883a 	nop
				#if DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Side changed (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
				#endif


				pxNFeeP->xControl.eMode =  sNextPatternIteration;
8110db70:	e0bffe17 	ldw	r2,-8(fp)
8110db74:	00c00284 	movi	r3,10
8110db78:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode =  sFeeWaitingSync;
8110db7c:	e0bffe17 	ldw	r2,-8(fp)
8110db80:	00c00304 	movi	r3,12
8110db84:	10c02d15 	stw	r3,180(r2)
					#if DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					#endif
				}
			}
			break;
8110db88:	00003e06 	br	8110dc84 <vQCmdFeeRMAPWaitingSync+0x248>
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
		case 0x0000004C://0x00000038:operation_mode_config

		ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8110db8c:	e0bffa43 	ldbu	r2,-23(fp)
8110db90:	1004d13a 	srli	r2,r2,4
8110db94:	10803fcc 	andi	r2,r2,255
8110db98:	e0bffc15 	stw	r2,-16(fp)

		switch (ucValueMasked) {
8110db9c:	e0bffc17 	ldw	r2,-16(fp)
8110dba0:	10c000a0 	cmpeqi	r3,r2,2
8110dba4:	18000e1e 	bne	r3,zero,8110dbe0 <vQCmdFeeRMAPWaitingSync+0x1a4>
8110dba8:	10c001a0 	cmpeqi	r3,r2,6
8110dbac:	1800161e 	bne	r3,zero,8110dc08 <vQCmdFeeRMAPWaitingSync+0x1cc>
8110dbb0:	10000126 	beq	r2,zero,8110dbb8 <vQCmdFeeRMAPWaitingSync+0x17c>
			case 5:
			default:
				#if DEBUG_ON
					fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
				#endif
				break;
8110dbb4:	00001506 	br	8110dc0c <vQCmdFeeRMAPWaitingSync+0x1d0>
			case 0: /* Standby */
			#if DEBUG_ON
				fprintf(fp,"- to Stand-By\n");
			#endif

				pxNFeeP->xControl.bWatingSync = TRUE;
8110dbb8:	e0bffe17 	ldw	r2,-8(fp)
8110dbbc:	00c00044 	movi	r3,1
8110dbc0:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110dbc4:	e0bffe17 	ldw	r2,-8(fp)
8110dbc8:	00c00304 	movi	r3,12
8110dbcc:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110dbd0:	e0bffe17 	ldw	r2,-8(fp)
8110dbd4:	00c00184 	movi	r3,6
8110dbd8:	10c02d15 	stw	r3,180(r2)


				break;
8110dbdc:	00000b06 	br	8110dc0c <vQCmdFeeRMAPWaitingSync+0x1d0>
			case 2: /* PAttern Full image */

				pxNFeeP->xControl.bWatingSync = TRUE;
8110dbe0:	e0bffe17 	ldw	r2,-8(fp)
8110dbe4:	00c00044 	movi	r3,1
8110dbe8:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
8110dbec:	e0bffe17 	ldw	r2,-8(fp)
8110dbf0:	00c00304 	movi	r3,12
8110dbf4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sNextPatternIteration;
8110dbf8:	e0bffe17 	ldw	r2,-8(fp)
8110dbfc:	00c00284 	movi	r3,10
8110dc00:	10c02d15 	stw	r3,180(r2)

				break;
8110dc04:	00000106 	br	8110dc0c <vQCmdFeeRMAPWaitingSync+0x1d0>
			case 6:
			#if DEBUG_ON
				fprintf(fp," Off-Mode not allowed.\n");
			#endif
				break;
8110dc08:	0001883a 	nop
					fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
				#endif
				break;
		}

			break;
8110dc0c:	00002006 	br	8110dc90 <vQCmdFeeRMAPWaitingSync+0x254>
		case 2: /* PAttern Full image */
			#if DEBUG_ON
				fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
			#endif

			pxNFeeP->xControl.bWatingSync = TRUE;
8110dc10:	e0bffe17 	ldw	r2,-8(fp)
8110dc14:	00c00044 	movi	r3,1
8110dc18:	10c02815 	stw	r3,160(r2)
			pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110dc1c:	e0bffe17 	ldw	r2,-8(fp)
8110dc20:	00c00284 	movi	r3,10
8110dc24:	10c02c15 	stw	r3,176(r2)
			pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110dc28:	e0bffe17 	ldw	r2,-8(fp)
8110dc2c:	00c00304 	movi	r3,12
8110dc30:	10c02d15 	stw	r3,180(r2)

			break;
8110dc34:	00001606 	br	8110dc90 <vQCmdFeeRMAPWaitingSync+0x254>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8110dc38:	e0bffa43 	ldbu	r2,-23(fp)
8110dc3c:	1080010c 	andi	r2,r2,4
8110dc40:	10803fcc 	andi	r2,r2,255
8110dc44:	1004d0ba 	srli	r2,r2,2
8110dc48:	10803fcc 	andi	r2,r2,255
8110dc4c:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
8110dc50:	e0bffc17 	ldw	r2,-16(fp)
8110dc54:	10000d26 	beq	r2,zero,8110dc8c <vQCmdFeeRMAPWaitingSync+0x250>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
8110dc58:	e0bffe17 	ldw	r2,-8(fp)
8110dc5c:	10802d17 	ldw	r2,180(r2)
8110dc60:	10800198 	cmpnei	r2,r2,6
8110dc64:	1000091e 	bne	r2,zero,8110dc8c <vQCmdFeeRMAPWaitingSync+0x250>
					pxNFeeP->xControl.bWatingSync = FALSE;
8110dc68:	e0bffe17 	ldw	r2,-8(fp)
8110dc6c:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110dc70:	e0bffe17 	ldw	r2,-8(fp)
8110dc74:	10c02d17 	ldw	r3,180(r2)
8110dc78:	e0bffe17 	ldw	r2,-8(fp)
8110dc7c:	10c02c15 	stw	r3,176(r2)
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
8110dc80:	00000206 	br	8110dc8c <vQCmdFeeRMAPWaitingSync+0x250>
					#if DEBUG_ON
						fprintf(fp,"\nNFEE %hhu Task: Can't change the CCD side while in transmission (FullPattern) side: %hhu\n", pxNFeeP->ucId, pxNFeeP->xControl.eSide);
					#endif
				}
			}
			break;
8110dc84:	0001883a 	nop
8110dc88:	00000106 	br	8110dc90 <vQCmdFeeRMAPWaitingSync+0x254>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
8110dc8c:	0001883a 	nop
			#if DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
8110dc90:	0001883a 	nop
8110dc94:	e037883a 	mov	sp,fp
8110dc98:	dfc00117 	ldw	ra,4(sp)
8110dc9c:	df000017 	ldw	fp,0(sp)
8110dca0:	dec00204 	addi	sp,sp,8
8110dca4:	f800283a 	ret

8110dca8 <bDisableRmapIRQ>:


bool bDisableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
8110dca8:	defffc04 	addi	sp,sp,-16
8110dcac:	de00012e 	bgeu	sp,et,8110dcb4 <bDisableRmapIRQ+0xc>
8110dcb0:	003b68fa 	trap	3
8110dcb4:	dfc00315 	stw	ra,12(sp)
8110dcb8:	df000215 	stw	fp,8(sp)
8110dcbc:	df000204 	addi	fp,sp,8
8110dcc0:	e13ffe15 	stw	r4,-8(fp)
8110dcc4:	2805883a 	mov	r2,r5
8110dcc8:	e0bfff05 	stb	r2,-4(fp)
	/* Disable RMAP channel */
	bRmapGetIrqControl(pxRmapCh);
8110dccc:	e13ffe17 	ldw	r4,-8(fp)
8110dcd0:	1105c140 	call	81105c14 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
8110dcd4:	e0bffe17 	ldw	r2,-8(fp)
8110dcd8:	10001015 	stw	zero,64(r2)
	bRmapSetIrqControl(pxRmapCh);
8110dcdc:	e13ffe17 	ldw	r4,-8(fp)
8110dce0:	1105b6c0 	call	81105b6c <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110dce4:	00800044 	movi	r2,1
}
8110dce8:	e037883a 	mov	sp,fp
8110dcec:	dfc00117 	ldw	ra,4(sp)
8110dcf0:	df000017 	ldw	fp,0(sp)
8110dcf4:	dec00204 	addi	sp,sp,8
8110dcf8:	f800283a 	ret

8110dcfc <bEnableRmapIRQ>:

bool bEnableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
8110dcfc:	defffc04 	addi	sp,sp,-16
8110dd00:	de00012e 	bgeu	sp,et,8110dd08 <bEnableRmapIRQ+0xc>
8110dd04:	003b68fa 	trap	3
8110dd08:	dfc00315 	stw	ra,12(sp)
8110dd0c:	df000215 	stw	fp,8(sp)
8110dd10:	df000204 	addi	fp,sp,8
8110dd14:	e13ffe15 	stw	r4,-8(fp)
8110dd18:	2805883a 	mov	r2,r5
8110dd1c:	e0bfff05 	stb	r2,-4(fp)
	/* Enable RMAP */
	/* Before Enable the IRQ for Rmap, make a copy for compare when some command arrive */
	//bRmapGetMemConfigArea(&xRmap[ucId]);

	bRmapGetIrqControl(pxRmapCh);
8110dd20:	e13ffe17 	ldw	r4,-8(fp)
8110dd24:	1105c140 	call	81105c14 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
8110dd28:	e0bffe17 	ldw	r2,-8(fp)
8110dd2c:	00c00044 	movi	r3,1
8110dd30:	10c01015 	stw	r3,64(r2)
	bRmapSetIrqControl(pxRmapCh);
8110dd34:	e13ffe17 	ldw	r4,-8(fp)
8110dd38:	1105b6c0 	call	81105b6c <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110dd3c:	00800044 	movi	r2,1
}
8110dd40:	e037883a 	mov	sp,fp
8110dd44:	dfc00117 	ldw	ra,4(sp)
8110dd48:	df000017 	ldw	fp,0(sp)
8110dd4c:	dec00204 	addi	sp,sp,8
8110dd50:	f800283a 	ret

8110dd54 <bDisableSPWChannel>:

bool bDisableSPWChannel( TSpwcChannel *xSPW ) {
8110dd54:	defffd04 	addi	sp,sp,-12
8110dd58:	de00012e 	bgeu	sp,et,8110dd60 <bDisableSPWChannel+0xc>
8110dd5c:	003b68fa 	trap	3
8110dd60:	dfc00215 	stw	ra,8(sp)
8110dd64:	df000115 	stw	fp,4(sp)
8110dd68:	df000104 	addi	fp,sp,4
8110dd6c:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bSpwcGetLink(xSPW);
8110dd70:	e13fff17 	ldw	r4,-4(fp)
8110dd74:	11085980 	call	81108598 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
8110dd78:	e0bfff17 	ldw	r2,-4(fp)
8110dd7c:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = FALSE;
8110dd80:	e0bfff17 	ldw	r2,-4(fp)
8110dd84:	10000115 	stw	zero,4(r2)
	xSPW->xLinkConfig.bDisconnect = TRUE;
8110dd88:	e0bfff17 	ldw	r2,-4(fp)
8110dd8c:	00c00044 	movi	r3,1
8110dd90:	10c00315 	stw	r3,12(r2)
	bSpwcSetLink(xSPW);
8110dd94:	e13fff17 	ldw	r4,-4(fp)
8110dd98:	11084640 	call	81108464 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
8110dd9c:	00800044 	movi	r2,1
}
8110dda0:	e037883a 	mov	sp,fp
8110dda4:	dfc00117 	ldw	ra,4(sp)
8110dda8:	df000017 	ldw	fp,0(sp)
8110ddac:	dec00204 	addi	sp,sp,8
8110ddb0:	f800283a 	ret

8110ddb4 <bEnableSPWChannel>:

bool bEnableSPWChannel( TSpwcChannel *xSPW ) {
8110ddb4:	defffd04 	addi	sp,sp,-12
8110ddb8:	de00012e 	bgeu	sp,et,8110ddc0 <bEnableSPWChannel+0xc>
8110ddbc:	003b68fa 	trap	3
8110ddc0:	dfc00215 	stw	ra,8(sp)
8110ddc4:	df000115 	stw	fp,4(sp)
8110ddc8:	df000104 	addi	fp,sp,4
8110ddcc:	e13fff15 	stw	r4,-4(fp)
	/* Enable SPW channel */
	bSpwcGetLink(xSPW);
8110ddd0:	e13fff17 	ldw	r4,-4(fp)
8110ddd4:	11085980 	call	81108598 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
8110ddd8:	e0bfff17 	ldw	r2,-4(fp)
8110dddc:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = TRUE;
8110dde0:	e0bfff17 	ldw	r2,-4(fp)
8110dde4:	00c00044 	movi	r3,1
8110dde8:	10c00115 	stw	r3,4(r2)
	xSPW->xLinkConfig.bDisconnect = FALSE;
8110ddec:	e0bfff17 	ldw	r2,-4(fp)
8110ddf0:	10000315 	stw	zero,12(r2)
	bSpwcSetLink(xSPW);
8110ddf4:	e13fff17 	ldw	r4,-4(fp)
8110ddf8:	11084640 	call	81108464 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
8110ddfc:	00800044 	movi	r2,1
}
8110de00:	e037883a 	mov	sp,fp
8110de04:	dfc00117 	ldw	ra,4(sp)
8110de08:	df000017 	ldw	fp,0(sp)
8110de0c:	dec00204 	addi	sp,sp,8
8110de10:	f800283a 	ret

8110de14 <bEnableDbBuffer>:

bool bEnableDbBuffer( TFeebChannel *pxFeebCh ) {
8110de14:	defffd04 	addi	sp,sp,-12
8110de18:	de00012e 	bgeu	sp,et,8110de20 <bEnableDbBuffer+0xc>
8110de1c:	003b68fa 	trap	3
8110de20:	dfc00215 	stw	ra,8(sp)
8110de24:	df000115 	stw	fp,4(sp)
8110de28:	df000104 	addi	fp,sp,4
8110de2c:	e13fff15 	stw	r4,-4(fp)
	// TODO: mudar [rfranca]
	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
8110de30:	e13fff17 	ldw	r4,-4(fp)
8110de34:	1104cc00 	call	81104cc0 <bFeebStopCh>
	// TODO: mudar [rfranca]
	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
8110de38:	e13fff17 	ldw	r4,-4(fp)
8110de3c:	1104d480 	call	81104d48 <bFeebClrCh>
	// TODO: mudar [rfranca]
	/* Start the module Double Buffer */
	bFeebStartCh(pxFeebCh);
8110de40:	e13fff17 	ldw	r4,-4(fp)
8110de44:	1104c380 	call	81104c38 <bFeebStartCh>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetWindowing(pxFeebCh);
8110de48:	e13fff17 	ldw	r4,-4(fp)
8110de4c:	1104bb00 	call	81104bb0 <bFeebGetWindowing>
	//pxFeebCh->xWindowingConfig.bMasking = DATA_PACKET;/* True= data packet;    FALSE= Transparent mode */
	pxFeebCh->xWindowingConfig.bMasking = xDefaults.bDataPacket;
8110de50:	00a045b4 	movhi	r2,33046
8110de54:	10acbf04 	addi	r2,r2,-19716
8110de58:	10c00817 	ldw	r3,32(r2)
8110de5c:	e0bfff17 	ldw	r2,-4(fp)
8110de60:	10c00115 	stw	r3,4(r2)
	bFeebSetWindowing(pxFeebCh);
8110de64:	e13fff17 	ldw	r4,-4(fp)
8110de68:	1104b080 	call	81104b08 <bFeebSetWindowing>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8110de6c:	e13fff17 	ldw	r4,-4(fp)
8110de70:	11045580 	call	81104558 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
8110de74:	e0bfff17 	ldw	r2,-4(fp)
8110de78:	00c00044 	movi	r3,1
8110de7c:	10c00215 	stw	r3,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
8110de80:	e0bfff17 	ldw	r2,-4(fp)
8110de84:	00c00044 	movi	r3,1
8110de88:	10c00315 	stw	r3,12(r2)
	bFeebSetIrqControl(pxFeebCh);
8110de8c:	e13fff17 	ldw	r4,-4(fp)
8110de90:	11044840 	call	81104484 <bFeebSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110de94:	00800044 	movi	r2,1
}
8110de98:	e037883a 	mov	sp,fp
8110de9c:	dfc00117 	ldw	ra,4(sp)
8110dea0:	df000017 	ldw	fp,0(sp)
8110dea4:	dec00204 	addi	sp,sp,8
8110dea8:	f800283a 	ret

8110deac <bDisAndClrDbBuffer>:


bool bDisAndClrDbBuffer( TFeebChannel *pxFeebCh ) {
8110deac:	defffd04 	addi	sp,sp,-12
8110deb0:	de00012e 	bgeu	sp,et,8110deb8 <bDisAndClrDbBuffer+0xc>
8110deb4:	003b68fa 	trap	3
8110deb8:	dfc00215 	stw	ra,8(sp)
8110debc:	df000115 	stw	fp,4(sp)
8110dec0:	df000104 	addi	fp,sp,4
8110dec4:	e13fff15 	stw	r4,-4(fp)

	/*Disable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8110dec8:	e13fff17 	ldw	r4,-4(fp)
8110decc:	11045580 	call	81104558 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
8110ded0:	e0bfff17 	ldw	r2,-4(fp)
8110ded4:	10000215 	stw	zero,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
8110ded8:	e0bfff17 	ldw	r2,-4(fp)
8110dedc:	10000315 	stw	zero,12(r2)
	bFeebSetIrqControl(pxFeebCh);
8110dee0:	e13fff17 	ldw	r4,-4(fp)
8110dee4:	11044840 	call	81104484 <bFeebSetIrqControl>

	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
8110dee8:	e13fff17 	ldw	r4,-4(fp)
8110deec:	1104cc00 	call	81104cc0 <bFeebStopCh>

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
8110def0:	e13fff17 	ldw	r4,-4(fp)
8110def4:	1104d480 	call	81104d48 <bFeebClrCh>
	// TODO: remover [rfranca]
	bFeebStartCh(pxFeebCh);
8110def8:	e13fff17 	ldw	r4,-4(fp)
8110defc:	1104c380 	call	81104c38 <bFeebStartCh>

	/*todo: No treatment for now  */
	return TRUE;
8110df00:	00800044 	movi	r2,1
}
8110df04:	e037883a 	mov	sp,fp
8110df08:	dfc00117 	ldw	ra,4(sp)
8110df0c:	df000017 	ldw	fp,0(sp)
8110df10:	dec00204 	addi	sp,sp,8
8110df14:	f800283a 	ret

8110df18 <bSendRequestNFeeCtrl>:

bool bSendRequestNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110df18:	defff804 	addi	sp,sp,-32
8110df1c:	de00012e 	bgeu	sp,et,8110df24 <bSendRequestNFeeCtrl+0xc>
8110df20:	003b68fa 	trap	3
8110df24:	dfc00715 	stw	ra,28(sp)
8110df28:	df000615 	stw	fp,24(sp)
8110df2c:	df000604 	addi	fp,sp,24
8110df30:	2807883a 	mov	r3,r5
8110df34:	3005883a 	mov	r2,r6
8110df38:	e13ffd05 	stb	r4,-12(fp)
8110df3c:	e0fffe05 	stb	r3,-8(fp)
8110df40:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110df44:	00800404 	movi	r2,16
8110df48:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110df4c:	e0bffd03 	ldbu	r2,-12(fp)
8110df50:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110df54:	e0bffe03 	ldbu	r2,-8(fp)
8110df58:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110df5c:	e0bfff03 	ldbu	r2,-4(fp)
8110df60:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110df64:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
8110df68:	d0a05d17 	ldw	r2,-32396(gp)
8110df6c:	e0fffc17 	ldw	r3,-16(fp)
8110df70:	180b883a 	mov	r5,r3
8110df74:	1009883a 	mov	r4,r2
8110df78:	1136a880 	call	81136a88 <OSQPost>
8110df7c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110df80:	e0bffb03 	ldbu	r2,-20(fp)
8110df84:	10000526 	beq	r2,zero,8110df9c <bSendRequestNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
8110df88:	e0bfff03 	ldbu	r2,-4(fp)
8110df8c:	1009883a 	mov	r4,r2
8110df90:	11171d40 	call	811171d4 <vFailRequestDMA>
		bSuccesL = FALSE;
8110df94:	e03ffa15 	stw	zero,-24(fp)
8110df98:	00000206 	br	8110dfa4 <bSendRequestNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
8110df9c:	00800044 	movi	r2,1
8110dfa0:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
8110dfa4:	e0bffa17 	ldw	r2,-24(fp)
}
8110dfa8:	e037883a 	mov	sp,fp
8110dfac:	dfc00117 	ldw	ra,4(sp)
8110dfb0:	df000017 	ldw	fp,0(sp)
8110dfb4:	dec00204 	addi	sp,sp,8
8110dfb8:	f800283a 	ret

8110dfbc <bSendGiveBackNFeeCtrl>:


bool bSendGiveBackNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110dfbc:	defff804 	addi	sp,sp,-32
8110dfc0:	de00012e 	bgeu	sp,et,8110dfc8 <bSendGiveBackNFeeCtrl+0xc>
8110dfc4:	003b68fa 	trap	3
8110dfc8:	dfc00715 	stw	ra,28(sp)
8110dfcc:	df000615 	stw	fp,24(sp)
8110dfd0:	df000604 	addi	fp,sp,24
8110dfd4:	2807883a 	mov	r3,r5
8110dfd8:	3005883a 	mov	r2,r6
8110dfdc:	e13ffd05 	stb	r4,-12(fp)
8110dfe0:	e0fffe05 	stb	r3,-8(fp)
8110dfe4:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110dfe8:	00800404 	movi	r2,16
8110dfec:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110dff0:	e0bffd03 	ldbu	r2,-12(fp)
8110dff4:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110dff8:	e0bffe03 	ldbu	r2,-8(fp)
8110dffc:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110e000:	e0bfff03 	ldbu	r2,-4(fp)
8110e004:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110e008:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
8110e00c:	d0a06f17 	ldw	r2,-32324(gp)
8110e010:	e0fffc17 	ldw	r3,-16(fp)
8110e014:	180b883a 	mov	r5,r3
8110e018:	1009883a 	mov	r4,r2
8110e01c:	1136a880 	call	81136a88 <OSQPost>
8110e020:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110e024:	e0bffb03 	ldbu	r2,-20(fp)
8110e028:	10000526 	beq	r2,zero,8110e040 <bSendGiveBackNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
8110e02c:	e0bfff03 	ldbu	r2,-4(fp)
8110e030:	1009883a 	mov	r4,r2
8110e034:	11171d40 	call	811171d4 <vFailRequestDMA>
		bSuccesL = FALSE;
8110e038:	e03ffa15 	stw	zero,-24(fp)
8110e03c:	00000206 	br	8110e048 <bSendGiveBackNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
8110e040:	00800044 	movi	r2,1
8110e044:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
8110e048:	e0bffa17 	ldw	r2,-24(fp)
}
8110e04c:	e037883a 	mov	sp,fp
8110e050:	dfc00117 	ldw	ra,4(sp)
8110e054:	df000017 	ldw	fp,0(sp)
8110e058:	dec00204 	addi	sp,sp,8
8110e05c:	f800283a 	ret

8110e060 <bPrepareDoubleBuffer>:

*/



bool bPrepareDoubleBuffer( TCcdMemMap *xCcdMapLocal, unsigned char ucMem, unsigned char ucID, TNFee *pxNFee ) {
8110e060:	defff804 	addi	sp,sp,-32
8110e064:	de00012e 	bgeu	sp,et,8110e06c <bPrepareDoubleBuffer+0xc>
8110e068:	003b68fa 	trap	3
8110e06c:	dfc00715 	stw	ra,28(sp)
8110e070:	df000615 	stw	fp,24(sp)
8110e074:	df000604 	addi	fp,sp,24
8110e078:	e13ffc15 	stw	r4,-16(fp)
8110e07c:	2807883a 	mov	r3,r5
8110e080:	3005883a 	mov	r2,r6
8110e084:	e1ffff15 	stw	r7,-4(fp)
8110e088:	e0fffd05 	stb	r3,-12(fp)
8110e08c:	e0bffe05 	stb	r2,-8(fp)
	bool  bDmaReturn;
	unsigned long ulLengthBlocks;

	bDmaReturn = FALSE;
8110e090:	e03ffa15 	stw	zero,-24(fp)
	xCcdMapLocal->ulBlockI = 0;
8110e094:	e0bffc17 	ldw	r2,-16(fp)
8110e098:	10000115 	stw	zero,4(r2)
	xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
8110e09c:	e0bffc17 	ldw	r2,-16(fp)
8110e0a0:	10c00017 	ldw	r3,0(r2)
8110e0a4:	e0bffc17 	ldw	r2,-16(fp)
8110e0a8:	10c00215 	stw	r3,8(r2)


	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8110e0ac:	e0bffc17 	ldw	r2,-16(fp)
8110e0b0:	10800117 	ldw	r2,4(r2)
8110e0b4:	10c00404 	addi	r3,r2,16
8110e0b8:	e0bfff17 	ldw	r2,-4(fp)
8110e0bc:	10800417 	ldw	r2,16(r2)
8110e0c0:	18800736 	bltu	r3,r2,8110e0e0 <bPrepareDoubleBuffer+0x80>
		ulLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8110e0c4:	e0bfff17 	ldw	r2,-4(fp)
8110e0c8:	10c00417 	ldw	r3,16(r2)
8110e0cc:	e0bffc17 	ldw	r2,-16(fp)
8110e0d0:	10800117 	ldw	r2,4(r2)
8110e0d4:	1885c83a 	sub	r2,r3,r2
8110e0d8:	e0bffb15 	stw	r2,-20(fp)
8110e0dc:	00000206 	br	8110e0e8 <bPrepareDoubleBuffer+0x88>

	} else {
		ulLengthBlocks = SDMA_MAX_BLOCKS;
8110e0e0:	00800404 	movi	r2,16
8110e0e4:	e0bffb15 	stw	r2,-20(fp)
	}

	if (xDefaults.usiLinkNFEE0 == 0) {
8110e0e8:	00a045b4 	movhi	r2,33046
8110e0ec:	10acbf04 	addi	r2,r2,-19716
8110e0f0:	1080100b 	ldhu	r2,64(r2)
8110e0f4:	10bfffcc 	andi	r2,r2,65535
8110e0f8:	10000b1e 	bne	r2,zero,8110e128 <bPrepareDoubleBuffer+0xc8>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,0);
8110e0fc:	e0bffb17 	ldw	r2,-20(fp)
8110e100:	10803fcc 	andi	r2,r2,255
8110e104:	000b883a 	mov	r5,zero
8110e108:	1009883a 	mov	r4,r2
8110e10c:	1103c680 	call	81103c68 <bFeebCh1SetBufferSize>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,1);
8110e110:	e0bffb17 	ldw	r2,-20(fp)
8110e114:	10803fcc 	andi	r2,r2,255
8110e118:	01400044 	movi	r5,1
8110e11c:	1009883a 	mov	r4,r2
8110e120:	1103c680 	call	81103c68 <bFeebCh1SetBufferSize>
8110e124:	00000a06 	br	8110e150 <bPrepareDoubleBuffer+0xf0>
	} else {
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,0);
8110e128:	e0bffb17 	ldw	r2,-20(fp)
8110e12c:	10803fcc 	andi	r2,r2,255
8110e130:	000b883a 	mov	r5,zero
8110e134:	1009883a 	mov	r4,r2
8110e138:	1103d3c0 	call	81103d3c <bFeebCh2SetBufferSize>
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,1);
8110e13c:	e0bffb17 	ldw	r2,-20(fp)
8110e140:	10803fcc 	andi	r2,r2,255
8110e144:	01400044 	movi	r5,1
8110e148:	1009883a 	mov	r4,r2
8110e14c:	1103d3c0 	call	81103d3c <bFeebCh2SetBufferSize>


	//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,ulLengthBlocks,0);
	//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,ulLengthBlocks,1);

	if (  ucMem == 0  ) {
8110e150:	e0bffd03 	ldbu	r2,-12(fp)
8110e154:	1000231e 	bne	r2,zero,8110e1e4 <bPrepareDoubleBuffer+0x184>
		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110e158:	e0bffc17 	ldw	r2,-16(fp)
8110e15c:	10800217 	ldw	r2,8(r2)
8110e160:	1011883a 	mov	r8,r2
8110e164:	e0bffb17 	ldw	r2,-20(fp)
8110e168:	10ffffcc 	andi	r3,r2,65535
8110e16c:	d0a05603 	ldbu	r2,-32424(gp)
8110e170:	11003fcc 	andi	r4,r2,255
8110e174:	e0bfff17 	ldw	r2,-4(fp)
8110e178:	10800043 	ldbu	r2,1(r2)
8110e17c:	10803fcc 	andi	r2,r2,255
8110e180:	100f883a 	mov	r7,r2
8110e184:	200d883a 	mov	r6,r4
8110e188:	180b883a 	mov	r5,r3
8110e18c:	4009883a 	mov	r4,r8
8110e190:	1101f880 	call	81101f88 <bSdmaDmaM1Transfer>
8110e194:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
8110e198:	e0bffa17 	ldw	r2,-24(fp)
8110e19c:	10800058 	cmpnei	r2,r2,1
8110e1a0:	10000e1e 	bne	r2,zero,8110e1dc <bPrepareDoubleBuffer+0x17c>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
8110e1a4:	e0bffc17 	ldw	r2,-16(fp)
8110e1a8:	10c00217 	ldw	r3,8(r2)
8110e1ac:	e0bffb17 	ldw	r2,-20(fp)
8110e1b0:	10802224 	muli	r2,r2,136
8110e1b4:	1887883a 	add	r3,r3,r2
8110e1b8:	e0bffc17 	ldw	r2,-16(fp)
8110e1bc:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
8110e1c0:	e0bffc17 	ldw	r2,-16(fp)
8110e1c4:	10c00117 	ldw	r3,4(r2)
8110e1c8:	e0bffb17 	ldw	r2,-20(fp)
8110e1cc:	1887883a 	add	r3,r3,r2
8110e1d0:	e0bffc17 	ldw	r2,-16(fp)
8110e1d4:	10c00115 	stw	r3,4(r2)
8110e1d8:	00002506 	br	8110e270 <bPrepareDoubleBuffer+0x210>
		} else
			return bDmaReturn;
8110e1dc:	e0bffa17 	ldw	r2,-24(fp)
8110e1e0:	00009506 	br	8110e438 <bPrepareDoubleBuffer+0x3d8>
	} else {
		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110e1e4:	e0bffc17 	ldw	r2,-16(fp)
8110e1e8:	10800217 	ldw	r2,8(r2)
8110e1ec:	1011883a 	mov	r8,r2
8110e1f0:	e0bffb17 	ldw	r2,-20(fp)
8110e1f4:	10ffffcc 	andi	r3,r2,65535
8110e1f8:	d0a05603 	ldbu	r2,-32424(gp)
8110e1fc:	11003fcc 	andi	r4,r2,255
8110e200:	e0bfff17 	ldw	r2,-4(fp)
8110e204:	10800043 	ldbu	r2,1(r2)
8110e208:	10803fcc 	andi	r2,r2,255
8110e20c:	100f883a 	mov	r7,r2
8110e210:	200d883a 	mov	r6,r4
8110e214:	180b883a 	mov	r5,r3
8110e218:	4009883a 	mov	r4,r8
8110e21c:	11023e00 	call	811023e0 <bSdmaDmaM2Transfer>
8110e220:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
8110e224:	e0bffa17 	ldw	r2,-24(fp)
8110e228:	10800058 	cmpnei	r2,r2,1
8110e22c:	10000e1e 	bne	r2,zero,8110e268 <bPrepareDoubleBuffer+0x208>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
8110e230:	e0bffc17 	ldw	r2,-16(fp)
8110e234:	10c00217 	ldw	r3,8(r2)
8110e238:	e0bffb17 	ldw	r2,-20(fp)
8110e23c:	10802224 	muli	r2,r2,136
8110e240:	1887883a 	add	r3,r3,r2
8110e244:	e0bffc17 	ldw	r2,-16(fp)
8110e248:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
8110e24c:	e0bffc17 	ldw	r2,-16(fp)
8110e250:	10c00117 	ldw	r3,4(r2)
8110e254:	e0bffb17 	ldw	r2,-20(fp)
8110e258:	1887883a 	add	r3,r3,r2
8110e25c:	e0bffc17 	ldw	r2,-16(fp)
8110e260:	10c00115 	stw	r3,4(r2)
8110e264:	00000206 	br	8110e270 <bPrepareDoubleBuffer+0x210>
		} else
			return bDmaReturn;
8110e268:	e0bffa17 	ldw	r2,-24(fp)
8110e26c:	00007206 	br	8110e438 <bPrepareDoubleBuffer+0x3d8>
	}


	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8110e270:	e0bffc17 	ldw	r2,-16(fp)
8110e274:	10800117 	ldw	r2,4(r2)
8110e278:	10c00404 	addi	r3,r2,16
8110e27c:	e0bfff17 	ldw	r2,-4(fp)
8110e280:	10800417 	ldw	r2,16(r2)
8110e284:	18800736 	bltu	r3,r2,8110e2a4 <bPrepareDoubleBuffer+0x244>
		ulLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8110e288:	e0bfff17 	ldw	r2,-4(fp)
8110e28c:	10c00417 	ldw	r3,16(r2)
8110e290:	e0bffc17 	ldw	r2,-16(fp)
8110e294:	10800117 	ldw	r2,4(r2)
8110e298:	1885c83a 	sub	r2,r3,r2
8110e29c:	e0bffb15 	stw	r2,-20(fp)
8110e2a0:	00000206 	br	8110e2ac <bPrepareDoubleBuffer+0x24c>
	} else {
		ulLengthBlocks = SDMA_MAX_BLOCKS;
8110e2a4:	00800404 	movi	r2,16
8110e2a8:	e0bffb15 	stw	r2,-20(fp)
	}

	if (xDefaults.usiLinkNFEE0 == 0) {
8110e2ac:	00a045b4 	movhi	r2,33046
8110e2b0:	10acbf04 	addi	r2,r2,-19716
8110e2b4:	1080100b 	ldhu	r2,64(r2)
8110e2b8:	10bfffcc 	andi	r2,r2,65535
8110e2bc:	10000b1e 	bne	r2,zero,8110e2ec <bPrepareDoubleBuffer+0x28c>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,0);
8110e2c0:	e0bffb17 	ldw	r2,-20(fp)
8110e2c4:	10803fcc 	andi	r2,r2,255
8110e2c8:	000b883a 	mov	r5,zero
8110e2cc:	1009883a 	mov	r4,r2
8110e2d0:	1103c680 	call	81103c68 <bFeebCh1SetBufferSize>
		bFeebCh1SetBufferSize((unsigned char)ulLengthBlocks,1);
8110e2d4:	e0bffb17 	ldw	r2,-20(fp)
8110e2d8:	10803fcc 	andi	r2,r2,255
8110e2dc:	01400044 	movi	r5,1
8110e2e0:	1009883a 	mov	r4,r2
8110e2e4:	1103c680 	call	81103c68 <bFeebCh1SetBufferSize>
8110e2e8:	00000a06 	br	8110e314 <bPrepareDoubleBuffer+0x2b4>
	} else {
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,0);
8110e2ec:	e0bffb17 	ldw	r2,-20(fp)
8110e2f0:	10803fcc 	andi	r2,r2,255
8110e2f4:	000b883a 	mov	r5,zero
8110e2f8:	1009883a 	mov	r4,r2
8110e2fc:	1103d3c0 	call	81103d3c <bFeebCh2SetBufferSize>
		bFeebCh2SetBufferSize((unsigned char)ulLengthBlocks,1);
8110e300:	e0bffb17 	ldw	r2,-20(fp)
8110e304:	10803fcc 	andi	r2,r2,255
8110e308:	01400044 	movi	r5,1
8110e30c:	1009883a 	mov	r4,r2
8110e310:	1103d3c0 	call	81103d3c <bFeebCh2SetBufferSize>

	//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,ulLengthBlocks,0);
	//bFeebSetBufferSize(&pxNFee->xChannel.xFeeBuffer,ulLengthBlocks,1);


	if (  ucMem == 0  ) {
8110e314:	e0bffd03 	ldbu	r2,-12(fp)
8110e318:	1000231e 	bne	r2,zero,8110e3a8 <bPrepareDoubleBuffer+0x348>
		bDmaReturn = bSdmaDmaM1Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110e31c:	e0bffc17 	ldw	r2,-16(fp)
8110e320:	10800217 	ldw	r2,8(r2)
8110e324:	1011883a 	mov	r8,r2
8110e328:	e0bffb17 	ldw	r2,-20(fp)
8110e32c:	10ffffcc 	andi	r3,r2,65535
8110e330:	d0a05603 	ldbu	r2,-32424(gp)
8110e334:	11003fcc 	andi	r4,r2,255
8110e338:	e0bfff17 	ldw	r2,-4(fp)
8110e33c:	10800043 	ldbu	r2,1(r2)
8110e340:	10803fcc 	andi	r2,r2,255
8110e344:	100f883a 	mov	r7,r2
8110e348:	200d883a 	mov	r6,r4
8110e34c:	180b883a 	mov	r5,r3
8110e350:	4009883a 	mov	r4,r8
8110e354:	1101f880 	call	81101f88 <bSdmaDmaM1Transfer>
8110e358:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
8110e35c:	e0bffa17 	ldw	r2,-24(fp)
8110e360:	10800058 	cmpnei	r2,r2,1
8110e364:	10000e1e 	bne	r2,zero,8110e3a0 <bPrepareDoubleBuffer+0x340>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
8110e368:	e0bffc17 	ldw	r2,-16(fp)
8110e36c:	10c00217 	ldw	r3,8(r2)
8110e370:	e0bffb17 	ldw	r2,-20(fp)
8110e374:	10802224 	muli	r2,r2,136
8110e378:	1887883a 	add	r3,r3,r2
8110e37c:	e0bffc17 	ldw	r2,-16(fp)
8110e380:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
8110e384:	e0bffc17 	ldw	r2,-16(fp)
8110e388:	10c00117 	ldw	r3,4(r2)
8110e38c:	e0bffb17 	ldw	r2,-20(fp)
8110e390:	1887883a 	add	r3,r3,r2
8110e394:	e0bffc17 	ldw	r2,-16(fp)
8110e398:	10c00115 	stw	r3,4(r2)
8110e39c:	00002506 	br	8110e434 <bPrepareDoubleBuffer+0x3d4>
		} else
			return bDmaReturn;
8110e3a0:	e0bffa17 	ldw	r2,-24(fp)
8110e3a4:	00002406 	br	8110e438 <bPrepareDoubleBuffer+0x3d8>
	} else {
		bDmaReturn = bSdmaDmaM2Transfer((alt_u32 *)xCcdMapLocal->ulAddrI, (alt_u16)ulLengthBlocks, ucIterationSide, pxNFee->ucSPWId);
8110e3a8:	e0bffc17 	ldw	r2,-16(fp)
8110e3ac:	10800217 	ldw	r2,8(r2)
8110e3b0:	1011883a 	mov	r8,r2
8110e3b4:	e0bffb17 	ldw	r2,-20(fp)
8110e3b8:	10ffffcc 	andi	r3,r2,65535
8110e3bc:	d0a05603 	ldbu	r2,-32424(gp)
8110e3c0:	11003fcc 	andi	r4,r2,255
8110e3c4:	e0bfff17 	ldw	r2,-4(fp)
8110e3c8:	10800043 	ldbu	r2,1(r2)
8110e3cc:	10803fcc 	andi	r2,r2,255
8110e3d0:	100f883a 	mov	r7,r2
8110e3d4:	200d883a 	mov	r6,r4
8110e3d8:	180b883a 	mov	r5,r3
8110e3dc:	4009883a 	mov	r4,r8
8110e3e0:	11023e00 	call	811023e0 <bSdmaDmaM2Transfer>
8110e3e4:	e0bffa15 	stw	r2,-24(fp)
		if ( bDmaReturn == TRUE ) {
8110e3e8:	e0bffa17 	ldw	r2,-24(fp)
8110e3ec:	10800058 	cmpnei	r2,r2,1
8110e3f0:	10000e1e 	bne	r2,zero,8110e42c <bPrepareDoubleBuffer+0x3cc>
			xCcdMapLocal->ulAddrI += SDMA_PIXEL_BLOCK_SIZE_BYTES*ulLengthBlocks;
8110e3f4:	e0bffc17 	ldw	r2,-16(fp)
8110e3f8:	10c00217 	ldw	r3,8(r2)
8110e3fc:	e0bffb17 	ldw	r2,-20(fp)
8110e400:	10802224 	muli	r2,r2,136
8110e404:	1887883a 	add	r3,r3,r2
8110e408:	e0bffc17 	ldw	r2,-16(fp)
8110e40c:	10c00215 	stw	r3,8(r2)
			xCcdMapLocal->ulBlockI += ulLengthBlocks;
8110e410:	e0bffc17 	ldw	r2,-16(fp)
8110e414:	10c00117 	ldw	r3,4(r2)
8110e418:	e0bffb17 	ldw	r2,-20(fp)
8110e41c:	1887883a 	add	r3,r3,r2
8110e420:	e0bffc17 	ldw	r2,-16(fp)
8110e424:	10c00115 	stw	r3,4(r2)
8110e428:	00000206 	br	8110e434 <bPrepareDoubleBuffer+0x3d4>
		} else
			return bDmaReturn;
8110e42c:	e0bffa17 	ldw	r2,-24(fp)
8110e430:	00000106 	br	8110e438 <bPrepareDoubleBuffer+0x3d8>
	}

	return bDmaReturn;
8110e434:	e0bffa17 	ldw	r2,-24(fp)

}
8110e438:	e037883a 	mov	sp,fp
8110e43c:	dfc00117 	ldw	ra,4(sp)
8110e440:	df000017 	ldw	fp,0(sp)
8110e444:	dec00204 	addi	sp,sp,8
8110e448:	f800283a 	ret

8110e44c <vLoadCtemp>:


void vLoadCtemp(void) {
8110e44c:	deffff04 	addi	sp,sp,-4
8110e450:	de00012e 	bgeu	sp,et,8110e458 <vLoadCtemp+0xc>
8110e454:	003b68fa 	trap	3
8110e458:	df000015 	stw	fp,0(sp)
8110e45c:	d839883a 	mov	fp,sp
	cTemp[0]="usiHkCcd1VodE";
8110e460:	00a04574 	movhi	r2,33045
8110e464:	10a06104 	addi	r2,r2,-32380
8110e468:	00e04534 	movhi	r3,33044
8110e46c:	18d19f04 	addi	r3,r3,18044
8110e470:	10c00015 	stw	r3,0(r2)
	cTemp[1]="usiHkCcd1VodF";
8110e474:	00a04574 	movhi	r2,33045
8110e478:	10a06104 	addi	r2,r2,-32380
8110e47c:	00e04534 	movhi	r3,33044
8110e480:	18d1a304 	addi	r3,r3,18060
8110e484:	10c00115 	stw	r3,4(r2)
	cTemp[2]="usiHkCcd1VrdMon";
8110e488:	00a04574 	movhi	r2,33045
8110e48c:	10a06104 	addi	r2,r2,-32380
8110e490:	00e04534 	movhi	r3,33044
8110e494:	18d1a704 	addi	r3,r3,18076
8110e498:	10c00215 	stw	r3,8(r2)
	cTemp[3]="usiHkCcd2VodE";
8110e49c:	00a04574 	movhi	r2,33045
8110e4a0:	10a06104 	addi	r2,r2,-32380
8110e4a4:	00e04534 	movhi	r3,33044
8110e4a8:	18d1ab04 	addi	r3,r3,18092
8110e4ac:	10c00315 	stw	r3,12(r2)
	cTemp[4]="usiHkCcd2VodF";
8110e4b0:	00a04574 	movhi	r2,33045
8110e4b4:	10a06104 	addi	r2,r2,-32380
8110e4b8:	00e04534 	movhi	r3,33044
8110e4bc:	18d1af04 	addi	r3,r3,18108
8110e4c0:	10c00415 	stw	r3,16(r2)
	cTemp[5]="usiHkCcd2VrdMon";
8110e4c4:	00a04574 	movhi	r2,33045
8110e4c8:	10a06104 	addi	r2,r2,-32380
8110e4cc:	00e04534 	movhi	r3,33044
8110e4d0:	18d1b304 	addi	r3,r3,18124
8110e4d4:	10c00515 	stw	r3,20(r2)
	cTemp[6]="usiHkCcd3VodE";
8110e4d8:	00a04574 	movhi	r2,33045
8110e4dc:	10a06104 	addi	r2,r2,-32380
8110e4e0:	00e04534 	movhi	r3,33044
8110e4e4:	18d1b704 	addi	r3,r3,18140
8110e4e8:	10c00615 	stw	r3,24(r2)
	cTemp[7]="usiHkCcd3VodF";
8110e4ec:	00a04574 	movhi	r2,33045
8110e4f0:	10a06104 	addi	r2,r2,-32380
8110e4f4:	00e04534 	movhi	r3,33044
8110e4f8:	18d1bb04 	addi	r3,r3,18156
8110e4fc:	10c00715 	stw	r3,28(r2)
	cTemp[8]="usiHkCcd3VrdMon";
8110e500:	00a04574 	movhi	r2,33045
8110e504:	10a06104 	addi	r2,r2,-32380
8110e508:	00e04534 	movhi	r3,33044
8110e50c:	18d1bf04 	addi	r3,r3,18172
8110e510:	10c00815 	stw	r3,32(r2)
	cTemp[9]="usiHkCcd4VodE";
8110e514:	00a04574 	movhi	r2,33045
8110e518:	10a06104 	addi	r2,r2,-32380
8110e51c:	00e04534 	movhi	r3,33044
8110e520:	18d1c304 	addi	r3,r3,18188
8110e524:	10c00915 	stw	r3,36(r2)
	cTemp[10]="usiHkCcd4VodF";
8110e528:	00a04574 	movhi	r2,33045
8110e52c:	10a06104 	addi	r2,r2,-32380
8110e530:	00e04534 	movhi	r3,33044
8110e534:	18d1c704 	addi	r3,r3,18204
8110e538:	10c00a15 	stw	r3,40(r2)
	cTemp[11]="usiHkCcd4VrdMon";
8110e53c:	00a04574 	movhi	r2,33045
8110e540:	10a06104 	addi	r2,r2,-32380
8110e544:	00e04534 	movhi	r3,33044
8110e548:	18d1cb04 	addi	r3,r3,18220
8110e54c:	10c00b15 	stw	r3,44(r2)
	cTemp[12]="usiHkVccd";
8110e550:	00a04574 	movhi	r2,33045
8110e554:	10a06104 	addi	r2,r2,-32380
8110e558:	00e04534 	movhi	r3,33044
8110e55c:	18d1cf04 	addi	r3,r3,18236
8110e560:	10c00c15 	stw	r3,48(r2)
	cTemp[13]="usiHkVrclk";
8110e564:	00a04574 	movhi	r2,33045
8110e568:	10a06104 	addi	r2,r2,-32380
8110e56c:	00e04534 	movhi	r3,33044
8110e570:	18d1d204 	addi	r3,r3,18248
8110e574:	10c00d15 	stw	r3,52(r2)
	cTemp[14]="usiHkViclk";
8110e578:	00a04574 	movhi	r2,33045
8110e57c:	10a06104 	addi	r2,r2,-32380
8110e580:	00e04534 	movhi	r3,33044
8110e584:	18d1d504 	addi	r3,r3,18260
8110e588:	10c00e15 	stw	r3,56(r2)
	cTemp[15]="usiHkVrclkLow";
8110e58c:	00a04574 	movhi	r2,33045
8110e590:	10a06104 	addi	r2,r2,-32380
8110e594:	00e04534 	movhi	r3,33044
8110e598:	18d1d804 	addi	r3,r3,18272
8110e59c:	10c00f15 	stw	r3,60(r2)
	cTemp[16]="usiHk5vbPos";
8110e5a0:	00a04574 	movhi	r2,33045
8110e5a4:	10a06104 	addi	r2,r2,-32380
8110e5a8:	00e04534 	movhi	r3,33044
8110e5ac:	18d1dc04 	addi	r3,r3,18288
8110e5b0:	10c01015 	stw	r3,64(r2)
	cTemp[17]="usiHk5vbNeg";
8110e5b4:	00a04574 	movhi	r2,33045
8110e5b8:	10a06104 	addi	r2,r2,-32380
8110e5bc:	00e04534 	movhi	r3,33044
8110e5c0:	18d1df04 	addi	r3,r3,18300
8110e5c4:	10c01115 	stw	r3,68(r2)
	cTemp[18]="usiHk33vbPos";
8110e5c8:	00a04574 	movhi	r2,33045
8110e5cc:	10a06104 	addi	r2,r2,-32380
8110e5d0:	00e04534 	movhi	r3,33044
8110e5d4:	18d1e204 	addi	r3,r3,18312
8110e5d8:	10c01215 	stw	r3,72(r2)
	cTemp[19]="usiHk25vaPos";
8110e5dc:	00a04574 	movhi	r2,33045
8110e5e0:	10a06104 	addi	r2,r2,-32380
8110e5e4:	00e04534 	movhi	r3,33044
8110e5e8:	18d1e604 	addi	r3,r3,18328
8110e5ec:	10c01315 	stw	r3,76(r2)
	cTemp[20]="usiHk33vdPos";
8110e5f0:	00a04574 	movhi	r2,33045
8110e5f4:	10a06104 	addi	r2,r2,-32380
8110e5f8:	00e04534 	movhi	r3,33044
8110e5fc:	18d1ea04 	addi	r3,r3,18344
8110e600:	10c01415 	stw	r3,80(r2)
	cTemp[21]="usiHk25vdPos";
8110e604:	00a04574 	movhi	r2,33045
8110e608:	10a06104 	addi	r2,r2,-32380
8110e60c:	00e04534 	movhi	r3,33044
8110e610:	18d1ee04 	addi	r3,r3,18360
8110e614:	10c01515 	stw	r3,84(r2)
	cTemp[22]="usiHk15vdPos";
8110e618:	00a04574 	movhi	r2,33045
8110e61c:	10a06104 	addi	r2,r2,-32380
8110e620:	00e04534 	movhi	r3,33044
8110e624:	18d1f204 	addi	r3,r3,18376
8110e628:	10c01615 	stw	r3,88(r2)
	cTemp[23]="usiHk5vref";
8110e62c:	00a04574 	movhi	r2,33045
8110e630:	10a06104 	addi	r2,r2,-32380
8110e634:	00e04534 	movhi	r3,33044
8110e638:	18d1f604 	addi	r3,r3,18392
8110e63c:	10c01715 	stw	r3,92(r2)
	cTemp[24]="usiHkVccdPosRaw";
8110e640:	00a04574 	movhi	r2,33045
8110e644:	10a06104 	addi	r2,r2,-32380
8110e648:	00e04534 	movhi	r3,33044
8110e64c:	18d1f904 	addi	r3,r3,18404
8110e650:	10c01815 	stw	r3,96(r2)
	cTemp[25]="usiHkVclkPosRaw";
8110e654:	00a04574 	movhi	r2,33045
8110e658:	10a06104 	addi	r2,r2,-32380
8110e65c:	00e04534 	movhi	r3,33044
8110e660:	18d1fd04 	addi	r3,r3,18420
8110e664:	10c01915 	stw	r3,100(r2)
	cTemp[26]="usiHkVan1PosRaw";
8110e668:	00a04574 	movhi	r2,33045
8110e66c:	10a06104 	addi	r2,r2,-32380
8110e670:	00e04534 	movhi	r3,33044
8110e674:	18d20104 	addi	r3,r3,18436
8110e678:	10c01a15 	stw	r3,104(r2)
	cTemp[27]="usiHkVan3NegRaw";
8110e67c:	00a04574 	movhi	r2,33045
8110e680:	10a06104 	addi	r2,r2,-32380
8110e684:	00e04534 	movhi	r3,33044
8110e688:	18d20504 	addi	r3,r3,18452
8110e68c:	10c01b15 	stw	r3,108(r2)
	cTemp[28]="usiHkVan2PosRaw";
8110e690:	00a04574 	movhi	r2,33045
8110e694:	10a06104 	addi	r2,r2,-32380
8110e698:	00e04534 	movhi	r3,33044
8110e69c:	18d20904 	addi	r3,r3,18468
8110e6a0:	10c01c15 	stw	r3,112(r2)
	cTemp[29]="usiHkVdigFpgaRaw";
8110e6a4:	00a04574 	movhi	r2,33045
8110e6a8:	10a06104 	addi	r2,r2,-32380
8110e6ac:	00e04534 	movhi	r3,33044
8110e6b0:	18d20d04 	addi	r3,r3,18484
8110e6b4:	10c01d15 	stw	r3,116(r2)
	cTemp[30]="usiHkVdigSpwRaw";
8110e6b8:	00a04574 	movhi	r2,33045
8110e6bc:	10a06104 	addi	r2,r2,-32380
8110e6c0:	00e04534 	movhi	r3,33044
8110e6c4:	18d21204 	addi	r3,r3,18504
8110e6c8:	10c01e15 	stw	r3,120(r2)
	cTemp[31]="usiHkViclkLow";
8110e6cc:	00a04574 	movhi	r2,33045
8110e6d0:	10a06104 	addi	r2,r2,-32380
8110e6d4:	00e04534 	movhi	r3,33044
8110e6d8:	18d21604 	addi	r3,r3,18520
8110e6dc:	10c01f15 	stw	r3,124(r2)
	cTemp[32]="usiHkAdcTempAE";
8110e6e0:	00a04574 	movhi	r2,33045
8110e6e4:	10a06104 	addi	r2,r2,-32380
8110e6e8:	00e04534 	movhi	r3,33044
8110e6ec:	18d21a04 	addi	r3,r3,18536
8110e6f0:	10c02015 	stw	r3,128(r2)
	cTemp[33]="usiHkAdcTempAF";
8110e6f4:	00a04574 	movhi	r2,33045
8110e6f8:	10a06104 	addi	r2,r2,-32380
8110e6fc:	00e04534 	movhi	r3,33044
8110e700:	18d21e04 	addi	r3,r3,18552
8110e704:	10c02115 	stw	r3,132(r2)
	cTemp[34]="usiHkCcd1Temp";
8110e708:	00a04574 	movhi	r2,33045
8110e70c:	10a06104 	addi	r2,r2,-32380
8110e710:	00e04534 	movhi	r3,33044
8110e714:	18d22204 	addi	r3,r3,18568
8110e718:	10c02215 	stw	r3,136(r2)
	cTemp[35]="usiHkCcd2Temp";
8110e71c:	00a04574 	movhi	r2,33045
8110e720:	10a06104 	addi	r2,r2,-32380
8110e724:	00e04534 	movhi	r3,33044
8110e728:	18d22604 	addi	r3,r3,18584
8110e72c:	10c02315 	stw	r3,140(r2)
	cTemp[36]="usiHkCcd3Temp";
8110e730:	00a04574 	movhi	r2,33045
8110e734:	10a06104 	addi	r2,r2,-32380
8110e738:	00e04534 	movhi	r3,33044
8110e73c:	18d22a04 	addi	r3,r3,18600
8110e740:	10c02415 	stw	r3,144(r2)
	cTemp[37]="usiHkCcd4Temp";
8110e744:	00a04574 	movhi	r2,33045
8110e748:	10a06104 	addi	r2,r2,-32380
8110e74c:	00e04534 	movhi	r3,33044
8110e750:	18d22e04 	addi	r3,r3,18616
8110e754:	10c02515 	stw	r3,148(r2)
	cTemp[38]="usiHkWp605Spare";
8110e758:	00a04574 	movhi	r2,33045
8110e75c:	10a06104 	addi	r2,r2,-32380
8110e760:	00e04534 	movhi	r3,33044
8110e764:	18d23204 	addi	r3,r3,18632
8110e768:	10c02615 	stw	r3,152(r2)
	cTemp[39]="usiLowresPrtA0";
8110e76c:	00a04574 	movhi	r2,33045
8110e770:	10a06104 	addi	r2,r2,-32380
8110e774:	00e04534 	movhi	r3,33044
8110e778:	18d23604 	addi	r3,r3,18648
8110e77c:	10c02715 	stw	r3,156(r2)
	cTemp[40]="usiLowresPrtA1";
8110e780:	00a04574 	movhi	r2,33045
8110e784:	10a06104 	addi	r2,r2,-32380
8110e788:	00e04534 	movhi	r3,33044
8110e78c:	18d23a04 	addi	r3,r3,18664
8110e790:	10c02815 	stw	r3,160(r2)
	cTemp[41]="usiLowresPrtA2";
8110e794:	00a04574 	movhi	r2,33045
8110e798:	10a06104 	addi	r2,r2,-32380
8110e79c:	00e04534 	movhi	r3,33044
8110e7a0:	18d23e04 	addi	r3,r3,18680
8110e7a4:	10c02915 	stw	r3,164(r2)
	cTemp[42]="usiLowresPrtA3";
8110e7a8:	00a04574 	movhi	r2,33045
8110e7ac:	10a06104 	addi	r2,r2,-32380
8110e7b0:	00e04534 	movhi	r3,33044
8110e7b4:	18d24204 	addi	r3,r3,18696
8110e7b8:	10c02a15 	stw	r3,168(r2)
	cTemp[43]="usiLowresPrtA4";
8110e7bc:	00a04574 	movhi	r2,33045
8110e7c0:	10a06104 	addi	r2,r2,-32380
8110e7c4:	00e04534 	movhi	r3,33044
8110e7c8:	18d24604 	addi	r3,r3,18712
8110e7cc:	10c02b15 	stw	r3,172(r2)
	cTemp[44]="usiLowresPrtA5";
8110e7d0:	00a04574 	movhi	r2,33045
8110e7d4:	10a06104 	addi	r2,r2,-32380
8110e7d8:	00e04534 	movhi	r3,33044
8110e7dc:	18d24a04 	addi	r3,r3,18728
8110e7e0:	10c02c15 	stw	r3,176(r2)
	cTemp[45]="usiLowresPrtA6";
8110e7e4:	00a04574 	movhi	r2,33045
8110e7e8:	10a06104 	addi	r2,r2,-32380
8110e7ec:	00e04534 	movhi	r3,33044
8110e7f0:	18d24e04 	addi	r3,r3,18744
8110e7f4:	10c02d15 	stw	r3,180(r2)
	cTemp[46]="usiLowresPrtA7";
8110e7f8:	00a04574 	movhi	r2,33045
8110e7fc:	10a06104 	addi	r2,r2,-32380
8110e800:	00e04534 	movhi	r3,33044
8110e804:	18d25204 	addi	r3,r3,18760
8110e808:	10c02e15 	stw	r3,184(r2)
	cTemp[47]="usiLowresPrtA8";
8110e80c:	00a04574 	movhi	r2,33045
8110e810:	10a06104 	addi	r2,r2,-32380
8110e814:	00e04534 	movhi	r3,33044
8110e818:	18d25604 	addi	r3,r3,18776
8110e81c:	10c02f15 	stw	r3,188(r2)
	cTemp[48]="usiLowresPrtA9";
8110e820:	00a04574 	movhi	r2,33045
8110e824:	10a06104 	addi	r2,r2,-32380
8110e828:	00e04534 	movhi	r3,33044
8110e82c:	18d25a04 	addi	r3,r3,18792
8110e830:	10c03015 	stw	r3,192(r2)
	cTemp[49]="usiLowresPrtA10";
8110e834:	00a04574 	movhi	r2,33045
8110e838:	10a06104 	addi	r2,r2,-32380
8110e83c:	00e04534 	movhi	r3,33044
8110e840:	18d25e04 	addi	r3,r3,18808
8110e844:	10c03115 	stw	r3,196(r2)
	cTemp[50]="usiLowresPrtA11";
8110e848:	00a04574 	movhi	r2,33045
8110e84c:	10a06104 	addi	r2,r2,-32380
8110e850:	00e04534 	movhi	r3,33044
8110e854:	18d26204 	addi	r3,r3,18824
8110e858:	10c03215 	stw	r3,200(r2)
	cTemp[51]="usiLowresPrtA12";
8110e85c:	00a04574 	movhi	r2,33045
8110e860:	10a06104 	addi	r2,r2,-32380
8110e864:	00e04534 	movhi	r3,33044
8110e868:	18d26604 	addi	r3,r3,18840
8110e86c:	10c03315 	stw	r3,204(r2)
	cTemp[52]="usiLowresPrtA13";
8110e870:	00a04574 	movhi	r2,33045
8110e874:	10a06104 	addi	r2,r2,-32380
8110e878:	00e04534 	movhi	r3,33044
8110e87c:	18d26a04 	addi	r3,r3,18856
8110e880:	10c03415 	stw	r3,208(r2)
	cTemp[53]="usiLowresPrtA14";
8110e884:	00a04574 	movhi	r2,33045
8110e888:	10a06104 	addi	r2,r2,-32380
8110e88c:	00e04534 	movhi	r3,33044
8110e890:	18d26e04 	addi	r3,r3,18872
8110e894:	10c03515 	stw	r3,212(r2)
	cTemp[54]="usiLowresPrtA15";
8110e898:	00a04574 	movhi	r2,33045
8110e89c:	10a06104 	addi	r2,r2,-32380
8110e8a0:	00e04534 	movhi	r3,33044
8110e8a4:	18d27204 	addi	r3,r3,18888
8110e8a8:	10c03615 	stw	r3,216(r2)
	cTemp[55]="usiSelHiresPrt0";
8110e8ac:	00a04574 	movhi	r2,33045
8110e8b0:	10a06104 	addi	r2,r2,-32380
8110e8b4:	00e04534 	movhi	r3,33044
8110e8b8:	18d27604 	addi	r3,r3,18904
8110e8bc:	10c03715 	stw	r3,220(r2)
	cTemp[56]="usiSelHiresPrt1";
8110e8c0:	00a04574 	movhi	r2,33045
8110e8c4:	10a06104 	addi	r2,r2,-32380
8110e8c8:	00e04534 	movhi	r3,33044
8110e8cc:	18d27a04 	addi	r3,r3,18920
8110e8d0:	10c03815 	stw	r3,224(r2)
	cTemp[57]="usiSelHiresPrt2";
8110e8d4:	00a04574 	movhi	r2,33045
8110e8d8:	10a06104 	addi	r2,r2,-32380
8110e8dc:	00e04534 	movhi	r3,33044
8110e8e0:	18d27e04 	addi	r3,r3,18936
8110e8e4:	10c03915 	stw	r3,228(r2)
	cTemp[58]="usiSelHiresPrt3";
8110e8e8:	00a04574 	movhi	r2,33045
8110e8ec:	10a06104 	addi	r2,r2,-32380
8110e8f0:	00e04534 	movhi	r3,33044
8110e8f4:	18d28204 	addi	r3,r3,18952
8110e8f8:	10c03a15 	stw	r3,232(r2)
	cTemp[59]="usiSelHiresPrt4";
8110e8fc:	00a04574 	movhi	r2,33045
8110e900:	10a06104 	addi	r2,r2,-32380
8110e904:	00e04534 	movhi	r3,33044
8110e908:	18d28604 	addi	r3,r3,18968
8110e90c:	10c03b15 	stw	r3,236(r2)
	cTemp[60]="usiSelHiresPrt5";
8110e910:	00a04574 	movhi	r2,33045
8110e914:	10a06104 	addi	r2,r2,-32380
8110e918:	00e04534 	movhi	r3,33044
8110e91c:	18d28a04 	addi	r3,r3,18984
8110e920:	10c03c15 	stw	r3,240(r2)
	cTemp[61]="usiSelHiresPrt6";
8110e924:	00a04574 	movhi	r2,33045
8110e928:	10a06104 	addi	r2,r2,-32380
8110e92c:	00e04534 	movhi	r3,33044
8110e930:	18d28e04 	addi	r3,r3,19000
8110e934:	10c03d15 	stw	r3,244(r2)
	cTemp[62]="usiSelHiresPrt7";
8110e938:	00a04574 	movhi	r2,33045
8110e93c:	10a06104 	addi	r2,r2,-32380
8110e940:	00e04534 	movhi	r3,33044
8110e944:	18d29204 	addi	r3,r3,19016
8110e948:	10c03e15 	stw	r3,248(r2)
	cTemp[63]="usiZeroHiresAmp";
8110e94c:	00a04574 	movhi	r2,33045
8110e950:	10a06104 	addi	r2,r2,-32380
8110e954:	00e04534 	movhi	r3,33044
8110e958:	18d29604 	addi	r3,r3,19032
8110e95c:	10c03f15 	stw	r3,252(r2)
}
8110e960:	0001883a 	nop
8110e964:	e037883a 	mov	sp,fp
8110e968:	df000017 	ldw	fp,0(sp)
8110e96c:	dec00104 	addi	sp,sp,4
8110e970:	f800283a 	ret

8110e974 <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
8110e974:	defff604 	addi	sp,sp,-40
8110e978:	de00012e 	bgeu	sp,et,8110e980 <vInAckHandlerTaskV2+0xc>
8110e97c:	003b68fa 	trap	3
8110e980:	dfc00915 	stw	ra,36(sp)
8110e984:	df000815 	stw	fp,32(sp)
8110e988:	df000804 	addi	fp,sp,32
8110e98c:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
8110e990:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
8110e994:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
8110e998:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
8110e99c:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
8110e9a0:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
8110e9a4:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
8110e9a8:	e03ffa45 	stb	zero,-23(fp)

    #if DEBUG_ON
        debug(fp,"In Ack Handler Task. (Task on)\n");
    #endif

	eReceiverAckState = sRAConfiguring;
8110e9ac:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
8110e9b0:	e0bff917 	ldw	r2,-28(fp)
8110e9b4:	10c00060 	cmpeqi	r3,r2,1
8110e9b8:	1800071e 	bne	r3,zero,8110e9d8 <vInAckHandlerTaskV2+0x64>
8110e9bc:	0080032e 	bgeu	zero,r2,8110e9cc <vInAckHandlerTaskV2+0x58>
8110e9c0:	108000a0 	cmpeqi	r2,r2,2
8110e9c4:	10004a1e 	bne	r2,zero,8110eaf0 <vInAckHandlerTaskV2+0x17c>
8110e9c8:	0000ac06 	br	8110ec7c <vInAckHandlerTaskV2+0x308>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
8110e9cc:	00800044 	movi	r2,1
8110e9d0:	e0bff915 	stw	r2,-28(fp)
				break;
8110e9d4:	0000ac06 	br	8110ec88 <vInAckHandlerTaskV2+0x314>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
8110e9d8:	00800044 	movi	r2,1
8110e9dc:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
8110e9e0:	d0a06517 	ldw	r2,-32364(gp)
8110e9e4:	e0fffe04 	addi	r3,fp,-8
8110e9e8:	180d883a 	mov	r6,r3
8110e9ec:	000b883a 	mov	r5,zero
8110e9f0:	1009883a 	mov	r4,r2
8110e9f4:	11375780 	call	81137578 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
8110e9f8:	e0bffe03 	ldbu	r2,-8(fp)
8110e9fc:	10803fcc 	andi	r2,r2,255
8110ea00:	1000391e 	bne	r2,zero,8110eae8 <vInAckHandlerTaskV2+0x174>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
8110ea04:	d0a06417 	ldw	r2,-32368(gp)
8110ea08:	e0fffe04 	addi	r3,fp,-8
8110ea0c:	180d883a 	mov	r6,r3
8110ea10:	000b883a 	mov	r5,zero
8110ea14:	1009883a 	mov	r4,r2
8110ea18:	113556c0 	call	8113556c <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8110ea1c:	e0bffe03 	ldbu	r2,-8(fp)
8110ea20:	10803fcc 	andi	r2,r2,255
8110ea24:	10002b1e 	bne	r2,zero,8110ead4 <vInAckHandlerTaskV2+0x160>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8110ea28:	e03ffa45 	stb	zero,-23(fp)
8110ea2c:	00002206 	br	8110eab8 <vInAckHandlerTaskV2+0x144>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
8110ea30:	e0fffa43 	ldbu	r3,-23(fp)
8110ea34:	00a04574 	movhi	r2,33045
8110ea38:	1095fd04 	addi	r2,r2,22516
8110ea3c:	18c7883a 	add	r3,r3,r3
8110ea40:	18c7883a 	add	r3,r3,r3
8110ea44:	10c5883a 	add	r2,r2,r3
8110ea48:	10800003 	ldbu	r2,0(r2)
8110ea4c:	10803fcc 	andi	r2,r2,255
8110ea50:	1080201c 	xori	r2,r2,128
8110ea54:	10bfe004 	addi	r2,r2,-128
8110ea58:	10001426 	beq	r2,zero,8110eaac <vInAckHandlerTaskV2+0x138>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
8110ea5c:	e0fffa43 	ldbu	r3,-23(fp)
8110ea60:	00a04574 	movhi	r2,33045
8110ea64:	1095fd04 	addi	r2,r2,22516
8110ea68:	18c7883a 	add	r3,r3,r3
8110ea6c:	18c7883a 	add	r3,r3,r3
8110ea70:	10c5883a 	add	r2,r2,r3
8110ea74:	10c0000b 	ldhu	r3,0(r2)
8110ea78:	d0e0568d 	sth	r3,-32422(gp)
8110ea7c:	1080008b 	ldhu	r2,2(r2)
8110ea80:	d0a0570d 	sth	r2,-32420(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
8110ea84:	e0fffa43 	ldbu	r3,-23(fp)
8110ea88:	00a04574 	movhi	r2,33045
8110ea8c:	1095fd04 	addi	r2,r2,22516
8110ea90:	18c7883a 	add	r3,r3,r3
8110ea94:	18c7883a 	add	r3,r3,r3
8110ea98:	10c5883a 	add	r2,r2,r3
8110ea9c:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
8110eaa0:	00800084 	movi	r2,2
8110eaa4:	e0bff915 	stw	r2,-28(fp)
                                break;                                
8110eaa8:	00000606 	br	8110eac4 <vInAckHandlerTaskV2+0x150>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8110eaac:	e0bffa43 	ldbu	r2,-23(fp)
8110eab0:	10800044 	addi	r2,r2,1
8110eab4:	e0bffa45 	stb	r2,-23(fp)
8110eab8:	e0bffa43 	ldbu	r2,-23(fp)
8110eabc:	108001b0 	cmpltui	r2,r2,6
8110eac0:	103fdb1e 	bne	r2,zero,8110ea30 <__reset+0xfb0eea30>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
8110eac4:	d0a06417 	ldw	r2,-32368(gp)
8110eac8:	1009883a 	mov	r4,r2
8110eacc:	1135b100 	call	81135b10 <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
8110ead0:	00006d06 	br	8110ec88 <vInAckHandlerTaskV2+0x314>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
8110ead4:	d0a06517 	ldw	r2,-32364(gp)
8110ead8:	1009883a 	mov	r4,r2
8110eadc:	11379000 	call	81137900 <OSSemPost>
                    	vFailGetMutexReceiverTask();
8110eae0:	11168280 	call	81116828 <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
8110eae4:	00006806 	br	8110ec88 <vInAckHandlerTaskV2+0x314>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
8110eae8:	11168000 	call	81116800 <vFailGetCountSemaphoreReceiverTask>
                }
                break;
8110eaec:	00006606 	br	8110ec88 <vInAckHandlerTaskV2+0x314>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
8110eaf0:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
8110eaf4:	d0a06783 	ldbu	r2,-32354(gp)
8110eaf8:	10803fcc 	andi	r2,r2,255
8110eafc:	10800218 	cmpnei	r2,r2,8
8110eb00:	1000021e 	bne	r2,zero,8110eb0c <vInAckHandlerTaskV2+0x198>
8110eb04:	00c00104 	movi	r3,4
8110eb08:	00000106 	br	8110eb10 <vInAckHandlerTaskV2+0x19c>
8110eb0c:	0007883a 	mov	r3,zero
8110eb10:	d0a07403 	ldbu	r2,-32304(gp)
8110eb14:	10803fcc 	andi	r2,r2,255
8110eb18:	10800218 	cmpnei	r2,r2,8
8110eb1c:	1000021e 	bne	r2,zero,8110eb28 <vInAckHandlerTaskV2+0x1b4>
8110eb20:	00800084 	movi	r2,2
8110eb24:	00000106 	br	8110eb2c <vInAckHandlerTaskV2+0x1b8>
8110eb28:	0005883a 	mov	r2,zero
8110eb2c:	1884b03a 	or	r2,r3,r2
8110eb30:	1007883a 	mov	r3,r2
8110eb34:	d0a07443 	ldbu	r2,-32303(gp)
8110eb38:	10803fcc 	andi	r2,r2,255
8110eb3c:	108001a0 	cmpeqi	r2,r2,6
8110eb40:	1884b03a 	or	r2,r3,r2
8110eb44:	1007883a 	mov	r3,r2
8110eb48:	e0bffa83 	ldbu	r2,-22(fp)
8110eb4c:	1884b03a 	or	r2,r3,r2
8110eb50:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
8110eb54:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
8110eb58:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
8110eb5c:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
8110eb60:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
8110eb64:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
8110eb68:	e0bffa03 	ldbu	r2,-24(fp)
8110eb6c:	10800044 	addi	r2,r2,1
8110eb70:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
8110eb74:	e0bffa83 	ldbu	r2,-22(fp)
8110eb78:	1080004c 	andi	r2,r2,1
8110eb7c:	10803fcc 	andi	r2,r2,255
8110eb80:	1000061e 	bne	r2,zero,8110eb9c <vInAckHandlerTaskV2+0x228>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
8110eb84:	e0bffd04 	addi	r2,fp,-12
8110eb88:	100b883a 	mov	r5,r2
8110eb8c:	d1205684 	addi	r4,gp,-32422
8110eb90:	110ec8c0 	call	8110ec8c <bCheckInAck128>
8110eb94:	e0bff815 	stw	r2,-32(fp)
8110eb98:	00000206 	br	8110eba4 <vInAckHandlerTaskV2+0x230>
                    else
                        bFinished128 = TRUE;
8110eb9c:	00800044 	movi	r2,1
8110eba0:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
8110eba4:	e0bffa83 	ldbu	r2,-22(fp)
8110eba8:	1080008c 	andi	r2,r2,2
8110ebac:	10803fcc 	andi	r2,r2,255
8110ebb0:	1000081e 	bne	r2,zero,8110ebd4 <vInAckHandlerTaskV2+0x260>
8110ebb4:	e0bff817 	ldw	r2,-32(fp)
8110ebb8:	1000061e 	bne	r2,zero,8110ebd4 <vInAckHandlerTaskV2+0x260>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
8110ebbc:	e0bffc04 	addi	r2,fp,-16
8110ebc0:	100b883a 	mov	r5,r2
8110ebc4:	d1205684 	addi	r4,gp,-32422
8110ebc8:	110edd40 	call	8110edd4 <bCheckInAck64>
8110ebcc:	e0bff815 	stw	r2,-32(fp)
8110ebd0:	00000206 	br	8110ebdc <vInAckHandlerTaskV2+0x268>
                    else
                        bFinished64 = TRUE;
8110ebd4:	00800044 	movi	r2,1
8110ebd8:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
8110ebdc:	e0bffa83 	ldbu	r2,-22(fp)
8110ebe0:	1080010c 	andi	r2,r2,4
8110ebe4:	10803fcc 	andi	r2,r2,255
8110ebe8:	1000081e 	bne	r2,zero,8110ec0c <vInAckHandlerTaskV2+0x298>
8110ebec:	e0bff817 	ldw	r2,-32(fp)
8110ebf0:	1000061e 	bne	r2,zero,8110ec0c <vInAckHandlerTaskV2+0x298>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
8110ebf4:	e0bffb04 	addi	r2,fp,-20
8110ebf8:	100b883a 	mov	r5,r2
8110ebfc:	d1205684 	addi	r4,gp,-32422
8110ec00:	110ef200 	call	8110ef20 <bCheckInAck32>
8110ec04:	e0bff815 	stw	r2,-32(fp)
8110ec08:	00000206 	br	8110ec14 <vInAckHandlerTaskV2+0x2a0>
                    else
                        bFinished32 = TRUE;
8110ec0c:	00800044 	movi	r2,1
8110ec10:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
8110ec14:	e0bffa03 	ldbu	r2,-24(fp)
8110ec18:	10c00044 	addi	r3,r2,1
8110ec1c:	e0fffa05 	stb	r3,-24(fp)
8110ec20:	10803fcc 	andi	r2,r2,255
8110ec24:	10800ca8 	cmpgeui	r2,r2,50
8110ec28:	10000e1e 	bne	r2,zero,8110ec64 <vInAckHandlerTaskV2+0x2f0>
8110ec2c:	e0bff817 	ldw	r2,-32(fp)
8110ec30:	10000c1e 	bne	r2,zero,8110ec64 <vInAckHandlerTaskV2+0x2f0>
8110ec34:	e0bffb17 	ldw	r2,-20(fp)
8110ec38:	1005003a 	cmpeq	r2,r2,zero
8110ec3c:	1007883a 	mov	r3,r2
8110ec40:	e0bffc17 	ldw	r2,-16(fp)
8110ec44:	1005003a 	cmpeq	r2,r2,zero
8110ec48:	1884b03a 	or	r2,r3,r2
8110ec4c:	10c03fcc 	andi	r3,r2,255
8110ec50:	e0bffd17 	ldw	r2,-12(fp)
8110ec54:	1005003a 	cmpeq	r2,r2,zero
8110ec58:	10803fcc 	andi	r2,r2,255
8110ec5c:	1884b03a 	or	r2,r3,r2
8110ec60:	103fc11e 	bne	r2,zero,8110eb68 <__reset+0xfb0eeb68>
                
                if (bFound == FALSE) {
8110ec64:	e0bff817 	ldw	r2,-32(fp)
8110ec68:	1000011e 	bne	r2,zero,8110ec70 <vInAckHandlerTaskV2+0x2fc>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
8110ec6c:	1116a300 	call	81116a30 <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
8110ec70:	00800044 	movi	r2,1
8110ec74:	e0bff915 	stw	r2,-28(fp)
				break;
8110ec78:	00000306 	br	8110ec88 <vInAckHandlerTaskV2+0x314>
			default:
                #if DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
	            #endif
                eReceiverAckState = sRAGettingACK;
8110ec7c:	00800044 	movi	r2,1
8110ec80:	e0bff915 	stw	r2,-28(fp)
				break;
8110ec84:	0001883a 	nop
		}
	}
8110ec88:	003f4906 	br	8110e9b0 <__reset+0xfb0ee9b0>

8110ec8c <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
8110ec8c:	defffa04 	addi	sp,sp,-24
8110ec90:	de00012e 	bgeu	sp,et,8110ec98 <bCheckInAck128+0xc>
8110ec94:	003b68fa 	trap	3
8110ec98:	dfc00515 	stw	ra,20(sp)
8110ec9c:	df000415 	stw	fp,16(sp)
8110eca0:	df000404 	addi	fp,sp,16
8110eca4:	e13ffe15 	stw	r4,-8(fp)
8110eca8:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110ecac:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110ecb0:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110ecb4:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110ecb8:	e0bfff17 	ldw	r2,-4(fp)
8110ecbc:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
8110ecc0:	d0a06d17 	ldw	r2,-32332(gp)
8110ecc4:	e0fffd44 	addi	r3,fp,-11
8110ecc8:	180d883a 	mov	r6,r3
8110eccc:	01400144 	movi	r5,5
8110ecd0:	1009883a 	mov	r4,r2
8110ecd4:	113556c0 	call	8113556c <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110ecd8:	e0bffd43 	ldbu	r2,-11(fp)
8110ecdc:	10803fcc 	andi	r2,r2,255
8110ece0:	10000226 	beq	r2,zero,8110ecec <bCheckInAck128+0x60>
        return bFound;
8110ece4:	e0bffc17 	ldw	r2,-16(fp)
8110ece8:	00003506 	br	8110edc0 <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
8110ecec:	e03ffd05 	stb	zero,-12(fp)
8110ecf0:	00002706 	br	8110ed90 <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
8110ecf4:	e0fffd03 	ldbu	r3,-12(fp)
8110ecf8:	00a04574 	movhi	r2,33045
8110ecfc:	108cfb04 	addi	r2,r2,13292
8110ed00:	18c02324 	muli	r3,r3,140
8110ed04:	10c5883a 	add	r2,r2,r3
8110ed08:	10802104 	addi	r2,r2,132
8110ed0c:	10c0000b 	ldhu	r3,0(r2)
8110ed10:	e0bffe17 	ldw	r2,-8(fp)
8110ed14:	1080008b 	ldhu	r2,2(r2)
8110ed18:	18ffffcc 	andi	r3,r3,65535
8110ed1c:	10bfffcc 	andi	r2,r2,65535
8110ed20:	1880181e 	bne	r3,r2,8110ed84 <bCheckInAck128+0xf8>
            bFound = TRUE;
8110ed24:	00800044 	movi	r2,1
8110ed28:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
8110ed2c:	e0fffd03 	ldbu	r3,-12(fp)
8110ed30:	00a04574 	movhi	r2,33045
8110ed34:	108cdd04 	addi	r2,r2,13172
8110ed38:	18c7883a 	add	r3,r3,r3
8110ed3c:	18c7883a 	add	r3,r3,r3
8110ed40:	10c5883a 	add	r2,r2,r3
8110ed44:	10000015 	stw	zero,0(r2)
            SemCount128++;
8110ed48:	d0a07443 	ldbu	r2,-32303(gp)
8110ed4c:	10800044 	addi	r2,r2,1
8110ed50:	d0a07445 	stb	r2,-32303(gp)
            error_code = OSSemPost(xSemCountBuffer128);
8110ed54:	d0a06217 	ldw	r2,-32376(gp)
8110ed58:	1009883a 	mov	r4,r2
8110ed5c:	11379000 	call	81137900 <OSSemPost>
8110ed60:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110ed64:	e0bffd43 	ldbu	r2,-11(fp)
8110ed68:	10803fcc 	andi	r2,r2,255
8110ed6c:	10000c26 	beq	r2,zero,8110eda0 <bCheckInAck128+0x114>
                SemCount128--;
8110ed70:	d0a07443 	ldbu	r2,-32303(gp)
8110ed74:	10bfffc4 	addi	r2,r2,-1
8110ed78:	d0a07445 	stb	r2,-32303(gp)
                vFailSetCountSemaphorexBuffer128();
8110ed7c:	11169900 	call	81116990 <vFailSetCountSemaphorexBuffer128>
            }
            break;
8110ed80:	00000706 	br	8110eda0 <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
8110ed84:	e0bffd03 	ldbu	r2,-12(fp)
8110ed88:	10800044 	addi	r2,r2,1
8110ed8c:	e0bffd05 	stb	r2,-12(fp)
8110ed90:	e0bffd03 	ldbu	r2,-12(fp)
8110ed94:	108001b0 	cmpltui	r2,r2,6
8110ed98:	103fd61e 	bne	r2,zero,8110ecf4 <__reset+0xfb0eecf4>
8110ed9c:	00000106 	br	8110eda4 <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
8110eda0:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
8110eda4:	d0a06d17 	ldw	r2,-32332(gp)
8110eda8:	1009883a 	mov	r4,r2
8110edac:	1135b100 	call	81135b10 <OSMutexPost>
    (*bFinished) = TRUE;
8110edb0:	e0bfff17 	ldw	r2,-4(fp)
8110edb4:	00c00044 	movi	r3,1
8110edb8:	10c00015 	stw	r3,0(r2)

    return bFound;
8110edbc:	e0bffc17 	ldw	r2,-16(fp)
}
8110edc0:	e037883a 	mov	sp,fp
8110edc4:	dfc00117 	ldw	ra,4(sp)
8110edc8:	df000017 	ldw	fp,0(sp)
8110edcc:	dec00204 	addi	sp,sp,8
8110edd0:	f800283a 	ret

8110edd4 <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
8110edd4:	defffa04 	addi	sp,sp,-24
8110edd8:	de00012e 	bgeu	sp,et,8110ede0 <bCheckInAck64+0xc>
8110eddc:	003b68fa 	trap	3
8110ede0:	dfc00515 	stw	ra,20(sp)
8110ede4:	df000415 	stw	fp,16(sp)
8110ede8:	df000404 	addi	fp,sp,16
8110edec:	e13ffe15 	stw	r4,-8(fp)
8110edf0:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110edf4:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110edf8:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110edfc:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110ee00:	e0bfff17 	ldw	r2,-4(fp)
8110ee04:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8110ee08:	d0a07017 	ldw	r2,-32320(gp)
8110ee0c:	e0fffd44 	addi	r3,fp,-11
8110ee10:	180d883a 	mov	r6,r3
8110ee14:	01400044 	movi	r5,1
8110ee18:	1009883a 	mov	r4,r2
8110ee1c:	113556c0 	call	8113556c <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110ee20:	e0bffd43 	ldbu	r2,-11(fp)
8110ee24:	10803fcc 	andi	r2,r2,255
8110ee28:	10000226 	beq	r2,zero,8110ee34 <bCheckInAck64+0x60>
        return bFound;
8110ee2c:	e0bffc17 	ldw	r2,-16(fp)
8110ee30:	00003606 	br	8110ef0c <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
8110ee34:	e03ffd05 	stb	zero,-12(fp)
8110ee38:	00002806 	br	8110eedc <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
8110ee3c:	e0fffd03 	ldbu	r3,-12(fp)
8110ee40:	00a04574 	movhi	r2,33045
8110ee44:	10a8a104 	addi	r2,r2,-23932
8110ee48:	18c01324 	muli	r3,r3,76
8110ee4c:	10c5883a 	add	r2,r2,r3
8110ee50:	10801104 	addi	r2,r2,68
8110ee54:	10c0000b 	ldhu	r3,0(r2)
8110ee58:	e0bffe17 	ldw	r2,-8(fp)
8110ee5c:	1080008b 	ldhu	r2,2(r2)
8110ee60:	18ffffcc 	andi	r3,r3,65535
8110ee64:	10bfffcc 	andi	r2,r2,65535
8110ee68:	1880191e 	bne	r3,r2,8110eed0 <bCheckInAck64+0xfc>
            bFound = TRUE;
8110ee6c:	00800044 	movi	r2,1
8110ee70:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
8110ee74:	e0fffd03 	ldbu	r3,-12(fp)
8110ee78:	00a04574 	movhi	r2,33045
8110ee7c:	108cdd04 	addi	r2,r2,13172
8110ee80:	18c00184 	addi	r3,r3,6
8110ee84:	18c7883a 	add	r3,r3,r3
8110ee88:	18c7883a 	add	r3,r3,r3
8110ee8c:	10c5883a 	add	r2,r2,r3
8110ee90:	10000015 	stw	zero,0(r2)
            SemCount64++;
8110ee94:	d0a07403 	ldbu	r2,-32304(gp)
8110ee98:	10800044 	addi	r2,r2,1
8110ee9c:	d0a07405 	stb	r2,-32304(gp)
            error_code = OSSemPost(xSemCountBuffer64);
8110eea0:	d0a05e17 	ldw	r2,-32392(gp)
8110eea4:	1009883a 	mov	r4,r2
8110eea8:	11379000 	call	81137900 <OSSemPost>
8110eeac:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110eeb0:	e0bffd43 	ldbu	r2,-11(fp)
8110eeb4:	10803fcc 	andi	r2,r2,255
8110eeb8:	10000c26 	beq	r2,zero,8110eeec <bCheckInAck64+0x118>
                SemCount64--;
8110eebc:	d0a07403 	ldbu	r2,-32304(gp)
8110eec0:	10bfffc4 	addi	r2,r2,-1
8110eec4:	d0a07405 	stb	r2,-32304(gp)
                vFailSetCountSemaphorexBuffer64();
8110eec8:	11169680 	call	81116968 <vFailSetCountSemaphorexBuffer64>
            }
            break;
8110eecc:	00000706 	br	8110eeec <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
8110eed0:	e0bffd03 	ldbu	r2,-12(fp)
8110eed4:	10800044 	addi	r2,r2,1
8110eed8:	e0bffd05 	stb	r2,-12(fp)
8110eedc:	e0bffd03 	ldbu	r2,-12(fp)
8110eee0:	10800230 	cmpltui	r2,r2,8
8110eee4:	103fd51e 	bne	r2,zero,8110ee3c <__reset+0xfb0eee3c>
8110eee8:	00000106 	br	8110eef0 <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
8110eeec:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
8110eef0:	d0a07017 	ldw	r2,-32320(gp)
8110eef4:	1009883a 	mov	r4,r2
8110eef8:	1135b100 	call	81135b10 <OSMutexPost>
    (*bFinished) = TRUE;
8110eefc:	e0bfff17 	ldw	r2,-4(fp)
8110ef00:	00c00044 	movi	r3,1
8110ef04:	10c00015 	stw	r3,0(r2)

    return bFound;
8110ef08:	e0bffc17 	ldw	r2,-16(fp)
}
8110ef0c:	e037883a 	mov	sp,fp
8110ef10:	dfc00117 	ldw	ra,4(sp)
8110ef14:	df000017 	ldw	fp,0(sp)
8110ef18:	dec00204 	addi	sp,sp,8
8110ef1c:	f800283a 	ret

8110ef20 <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
8110ef20:	defffa04 	addi	sp,sp,-24
8110ef24:	de00012e 	bgeu	sp,et,8110ef2c <bCheckInAck32+0xc>
8110ef28:	003b68fa 	trap	3
8110ef2c:	dfc00515 	stw	ra,20(sp)
8110ef30:	df000415 	stw	fp,16(sp)
8110ef34:	df000404 	addi	fp,sp,16
8110ef38:	e13ffe15 	stw	r4,-8(fp)
8110ef3c:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110ef40:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110ef44:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110ef48:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110ef4c:	e0bfff17 	ldw	r2,-4(fp)
8110ef50:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8110ef54:	d0a06b17 	ldw	r2,-32340(gp)
8110ef58:	e0fffd44 	addi	r3,fp,-11
8110ef5c:	180d883a 	mov	r6,r3
8110ef60:	01400044 	movi	r5,1
8110ef64:	1009883a 	mov	r4,r2
8110ef68:	113556c0 	call	8113556c <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110ef6c:	e0bffd43 	ldbu	r2,-11(fp)
8110ef70:	10803fcc 	andi	r2,r2,255
8110ef74:	10000226 	beq	r2,zero,8110ef80 <bCheckInAck32+0x60>
        return bFound;
8110ef78:	e0bffc17 	ldw	r2,-16(fp)
8110ef7c:	00003606 	br	8110f058 <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
8110ef80:	e03ffd05 	stb	zero,-12(fp)
8110ef84:	00002806 	br	8110f028 <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
8110ef88:	e0fffd03 	ldbu	r3,-12(fp)
8110ef8c:	00a04574 	movhi	r2,33045
8110ef90:	10ba5d04 	addi	r2,r2,-5772
8110ef94:	18c00b24 	muli	r3,r3,44
8110ef98:	10c5883a 	add	r2,r2,r3
8110ef9c:	10800904 	addi	r2,r2,36
8110efa0:	10c0000b 	ldhu	r3,0(r2)
8110efa4:	e0bffe17 	ldw	r2,-8(fp)
8110efa8:	1080008b 	ldhu	r2,2(r2)
8110efac:	18ffffcc 	andi	r3,r3,65535
8110efb0:	10bfffcc 	andi	r2,r2,65535
8110efb4:	1880191e 	bne	r3,r2,8110f01c <bCheckInAck32+0xfc>
            bFound = TRUE;
8110efb8:	00800044 	movi	r2,1
8110efbc:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
8110efc0:	e0fffd03 	ldbu	r3,-12(fp)
8110efc4:	00a04574 	movhi	r2,33045
8110efc8:	108cdd04 	addi	r2,r2,13172
8110efcc:	18c00384 	addi	r3,r3,14
8110efd0:	18c7883a 	add	r3,r3,r3
8110efd4:	18c7883a 	add	r3,r3,r3
8110efd8:	10c5883a 	add	r2,r2,r3
8110efdc:	10000015 	stw	zero,0(r2)
            SemCount32++;
8110efe0:	d0a06783 	ldbu	r2,-32354(gp)
8110efe4:	10800044 	addi	r2,r2,1
8110efe8:	d0a06785 	stb	r2,-32354(gp)
            error_code = OSSemPost(xSemCountBuffer32);
8110efec:	d0a06e17 	ldw	r2,-32328(gp)
8110eff0:	1009883a 	mov	r4,r2
8110eff4:	11379000 	call	81137900 <OSSemPost>
8110eff8:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110effc:	e0bffd43 	ldbu	r2,-11(fp)
8110f000:	10803fcc 	andi	r2,r2,255
8110f004:	10000c26 	beq	r2,zero,8110f038 <bCheckInAck32+0x118>
                SemCount32--;
8110f008:	d0a06783 	ldbu	r2,-32354(gp)
8110f00c:	10bfffc4 	addi	r2,r2,-1
8110f010:	d0a06785 	stb	r2,-32354(gp)
                vFailSetCountSemaphorexBuffer32();
8110f014:	11169400 	call	81116940 <vFailSetCountSemaphorexBuffer32>
            }
            break;
8110f018:	00000706 	br	8110f038 <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
8110f01c:	e0bffd03 	ldbu	r2,-12(fp)
8110f020:	10800044 	addi	r2,r2,1
8110f024:	e0bffd05 	stb	r2,-12(fp)
8110f028:	e0bffd03 	ldbu	r2,-12(fp)
8110f02c:	10800230 	cmpltui	r2,r2,8
8110f030:	103fd51e 	bne	r2,zero,8110ef88 <__reset+0xfb0eef88>
8110f034:	00000106 	br	8110f03c <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
8110f038:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
8110f03c:	d0a06b17 	ldw	r2,-32340(gp)
8110f040:	1009883a 	mov	r4,r2
8110f044:	1135b100 	call	81135b10 <OSMutexPost>
    (*bFinished) = TRUE;
8110f048:	e0bfff17 	ldw	r2,-4(fp)
8110f04c:	00c00044 	movi	r3,1
8110f050:	10c00015 	stw	r3,0(r2)

    return bFound;
8110f054:	e0bffc17 	ldw	r2,-16(fp)
}
8110f058:	e037883a 	mov	sp,fp
8110f05c:	dfc00117 	ldw	ra,4(sp)
8110f060:	df000017 	ldw	fp,0(sp)
8110f064:	dec00204 	addi	sp,sp,8
8110f068:	f800283a 	ret

8110f06c <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
8110f06c:	defff704 	addi	sp,sp,-36
8110f070:	de00012e 	bgeu	sp,et,8110f078 <vInitialTask+0xc>
8110f074:	003b68fa 	trap	3
8110f078:	dfc00815 	stw	ra,32(sp)
8110f07c:	df000715 	stw	fp,28(sp)
8110f080:	df000704 	addi	fp,sp,28
8110f084:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
8110f088:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
8110f08c:	d8000415 	stw	zero,16(sp)
8110f090:	d8000315 	stw	zero,12(sp)
8110f094:	00810004 	movi	r2,1024
8110f098:	d8800215 	stw	r2,8(sp)
8110f09c:	00a04574 	movhi	r2,33045
8110f0a0:	10a0a104 	addi	r2,r2,-32124
8110f0a4:	d8800115 	stw	r2,4(sp)
8110f0a8:	008002c4 	movi	r2,11
8110f0ac:	d8800015 	stw	r2,0(sp)
8110f0b0:	01c002c4 	movi	r7,11
8110f0b4:	01a04574 	movhi	r6,33045
8110f0b8:	31a4a004 	addi	r6,r6,-28032
8110f0bc:	01604574 	movhi	r5,33045
8110f0c0:	2975c104 	addi	r5,r5,-10492
8110f0c4:	01204474 	movhi	r4,33041
8110f0c8:	212f3204 	addi	r4,r4,-17208
8110f0cc:	11382e40 	call	811382e4 <OSTaskCreateExt>
8110f0d0:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f0d4:	e0bffe03 	ldbu	r2,-8(fp)
8110f0d8:	10803fcc 	andi	r2,r2,255
8110f0dc:	10000126 	beq	r2,zero,8110f0e4 <vInitialTask+0x78>
		/* Can't create Task */
		#if DEBUG_ON
			printErrorTask( error_code );
		#endif
			vCoudlNotCreateNFee0Task();
8110f0e0:	1116ef40 	call	81116ef4 <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110f0e4:	01c17704 	movi	r7,1500
8110f0e8:	000d883a 	mov	r6,zero
8110f0ec:	000b883a 	mov	r5,zero
8110f0f0:	0009883a 	mov	r4,zero
8110f0f4:	11395100 	call	81139510 <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
8110f0f8:	d8000415 	stw	zero,16(sp)
8110f0fc:	d8000315 	stw	zero,12(sp)
8110f100:	00810004 	movi	r2,1024
8110f104:	d8800215 	stw	r2,8(sp)
8110f108:	00a04574 	movhi	r2,33045
8110f10c:	10b1af04 	addi	r2,r2,-14660
8110f110:	d8800115 	stw	r2,4(sp)
8110f114:	00800284 	movi	r2,10
8110f118:	d8800015 	stw	r2,0(sp)
8110f11c:	01c00284 	movi	r7,10
8110f120:	01a04574 	movhi	r6,33045
8110f124:	31b5ae04 	addi	r6,r6,-10568
8110f128:	01604574 	movhi	r5,33045
8110f12c:	2975b904 	addi	r5,r5,-10524
8110f130:	01204474 	movhi	r4,33041
8110f134:	212f1104 	addi	r4,r4,-17340
8110f138:	11382e40 	call	811382e4 <OSTaskCreateExt>
8110f13c:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f140:	e0bffe03 	ldbu	r2,-8(fp)
8110f144:	10803fcc 	andi	r2,r2,255
8110f148:	10000126 	beq	r2,zero,8110f150 <vInitialTask+0xe4>
		/* Can't create Task */
		#if DEBUG_ON
			printErrorTask( error_code );
		#endif
			vCoudlNotCreateDataControllerTask();
8110f14c:	111700c0 	call	8111700c <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110f150:	01c17704 	movi	r7,1500
8110f154:	000d883a 	mov	r6,zero
8110f158:	000b883a 	mov	r5,zero
8110f15c:	0009883a 	mov	r4,zero
8110f160:	11395100 	call	81139510 <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
8110f164:	d8000415 	stw	zero,16(sp)
8110f168:	d8000315 	stw	zero,12(sp)
8110f16c:	00810004 	movi	r2,1024
8110f170:	d8800215 	stw	r2,8(sp)
8110f174:	00a04574 	movhi	r2,33045
8110f178:	108de504 	addi	r2,r2,14228
8110f17c:	d8800115 	stw	r2,4(sp)
8110f180:	00800244 	movi	r2,9
8110f184:	d8800015 	stw	r2,0(sp)
8110f188:	01c00244 	movi	r7,9
8110f18c:	01a04574 	movhi	r6,33045
8110f190:	3191e404 	addi	r6,r6,18320
8110f194:	01604574 	movhi	r5,33045
8110f198:	2975c104 	addi	r5,r5,-10492
8110f19c:	01204474 	movhi	r4,33041
8110f1a0:	213d5004 	addi	r4,r4,-2752
8110f1a4:	11382e40 	call	811382e4 <OSTaskCreateExt>
8110f1a8:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f1ac:	e0bffe03 	ldbu	r2,-8(fp)
8110f1b0:	10803fcc 	andi	r2,r2,255
8110f1b4:	10000126 	beq	r2,zero,8110f1bc <vInitialTask+0x150>
		/* Can't create Task */
		#if DEBUG_ON
			printErrorTask( error_code );
		#endif
			vCoudlNotCreateNFeeControllerTask();
8110f1b8:	1116fe40 	call	81116fe4 <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110f1bc:	01c17704 	movi	r7,1500
8110f1c0:	000d883a 	mov	r6,zero
8110f1c4:	000b883a 	mov	r5,zero
8110f1c8:	0009883a 	mov	r4,zero
8110f1cc:	11395100 	call	81139510 <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
8110f1d0:	d8000415 	stw	zero,16(sp)
8110f1d4:	d8000315 	stw	zero,12(sp)
8110f1d8:	00810004 	movi	r2,1024
8110f1dc:	d8800215 	stw	r2,8(sp)
8110f1e0:	00a045b4 	movhi	r2,33046
8110f1e4:	10a00704 	addi	r2,r2,-32740
8110f1e8:	d8800115 	stw	r2,4(sp)
8110f1ec:	00800204 	movi	r2,8
8110f1f0:	d8800015 	stw	r2,0(sp)
8110f1f4:	01c00204 	movi	r7,8
8110f1f8:	01a045b4 	movhi	r6,33046
8110f1fc:	31a40604 	addi	r6,r6,-28648
8110f200:	01604574 	movhi	r5,33045
8110f204:	2975af04 	addi	r5,r5,-10564
8110f208:	01204474 	movhi	r4,33041
8110f20c:	21049604 	addi	r4,r4,4696
8110f210:	11382e40 	call	811382e4 <OSTaskCreateExt>
8110f214:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f218:	e0bffe03 	ldbu	r2,-8(fp)
8110f21c:	10803fcc 	andi	r2,r2,255
8110f220:	10000126 	beq	r2,zero,8110f228 <vInitialTask+0x1bc>
		/* Can't create Task */
		#if DEBUG_ON
			printErrorTask( error_code );
		#endif
			vCoudlNotCreateMebTask();
8110f224:	11170340 	call	81117034 <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110f228:	01c17704 	movi	r7,1500
8110f22c:	000d883a 	mov	r6,zero
8110f230:	000b883a 	mov	r5,zero
8110f234:	0009883a 	mov	r4,zero
8110f238:	11395100 	call	81139510 <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
8110f23c:	d8000415 	stw	zero,16(sp)
8110f240:	d8000315 	stw	zero,12(sp)
8110f244:	00810004 	movi	r2,1024
8110f248:	d8800215 	stw	r2,8(sp)
8110f24c:	00a04574 	movhi	r2,33045
8110f250:	10adaf04 	addi	r2,r2,-18756
8110f254:	d8800115 	stw	r2,4(sp)
8110f258:	00800784 	movi	r2,30
8110f25c:	d8800015 	stw	r2,0(sp)
8110f260:	01c00784 	movi	r7,30
8110f264:	01a04574 	movhi	r6,33045
8110f268:	31b1ae04 	addi	r6,r6,-14664
8110f26c:	000b883a 	mov	r5,zero
8110f270:	01204474 	movhi	r4,33041
8110f274:	21088904 	addi	r4,r4,8740
8110f278:	11382e40 	call	811382e4 <OSTaskCreateExt>
8110f27c:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f280:	e0bffe03 	ldbu	r2,-8(fp)
8110f284:	10803fcc 	andi	r2,r2,255
8110f288:	10000126 	beq	r2,zero,8110f290 <vInitialTask+0x224>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
			printErrorTask( error_code );
		#endif
		vFailTimeoutCheckerTaskCreate();
8110f28c:	1116c600 	call	81116c60 <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110f290:	01c03204 	movi	r7,200
8110f294:	000d883a 	mov	r6,zero
8110f298:	000b883a 	mov	r5,zero
8110f29c:	0009883a 	mov	r4,zero
8110f2a0:	11395100 	call	81139510 <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
8110f2a4:	d8000415 	stw	zero,16(sp)
8110f2a8:	d8000315 	stw	zero,12(sp)
8110f2ac:	00810004 	movi	r2,1024
8110f2b0:	d8800215 	stw	r2,8(sp)
8110f2b4:	00a04574 	movhi	r2,33045
8110f2b8:	1080c504 	addi	r2,r2,788
8110f2bc:	d8800115 	stw	r2,4(sp)
8110f2c0:	008006c4 	movi	r2,27
8110f2c4:	d8800015 	stw	r2,0(sp)
8110f2c8:	01c006c4 	movi	r7,27
8110f2cc:	01a04574 	movhi	r6,33045
8110f2d0:	3184c404 	addi	r6,r6,4880
8110f2d4:	000b883a 	mov	r5,zero
8110f2d8:	01204474 	movhi	r4,33041
8110f2dc:	213ef104 	addi	r4,r4,-1084
8110f2e0:	11382e40 	call	811382e4 <OSTaskCreateExt>
8110f2e4:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f2e8:	e0bffe03 	ldbu	r2,-8(fp)
8110f2ec:	10803fcc 	andi	r2,r2,255
8110f2f0:	10000126 	beq	r2,zero,8110f2f8 <vInitialTask+0x28c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
			printErrorTask( error_code );
		#endif
		vFailOutAckHandlerTaskCreate();
8110f2f4:	1116be80 	call	81116be8 <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110f2f8:	01c03204 	movi	r7,200
8110f2fc:	000d883a 	mov	r6,zero
8110f300:	000b883a 	mov	r5,zero
8110f304:	0009883a 	mov	r4,zero
8110f308:	11395100 	call	81139510 <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
8110f30c:	d8000415 	stw	zero,16(sp)
8110f310:	d8000315 	stw	zero,12(sp)
8110f314:	00810004 	movi	r2,1024
8110f318:	d8800215 	stw	r2,8(sp)
8110f31c:	00a04574 	movhi	r2,33045
8110f320:	10a4a104 	addi	r2,r2,-28028
8110f324:	d8800115 	stw	r2,4(sp)
8110f328:	00800644 	movi	r2,25
8110f32c:	d8800015 	stw	r2,0(sp)
8110f330:	01c00644 	movi	r7,25
8110f334:	01a04574 	movhi	r6,33045
8110f338:	31a8a004 	addi	r6,r6,-23936
8110f33c:	000b883a 	mov	r5,zero
8110f340:	01204474 	movhi	r4,33041
8110f344:	213a5d04 	addi	r4,r4,-5772
8110f348:	11382e40 	call	811382e4 <OSTaskCreateExt>
8110f34c:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f350:	e0bffe03 	ldbu	r2,-8(fp)
8110f354:	10803fcc 	andi	r2,r2,255
8110f358:	10000126 	beq	r2,zero,8110f360 <vInitialTask+0x2f4>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
			printErrorTask( error_code );
		#endif
		vFailInAckHandlerTaskCreate();
8110f35c:	1116bc00 	call	81116bc0 <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110f360:	01c03204 	movi	r7,200
8110f364:	000d883a 	mov	r6,zero
8110f368:	000b883a 	mov	r5,zero
8110f36c:	0009883a 	mov	r4,zero
8110f370:	11395100 	call	81139510 <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
8110f374:	d8000415 	stw	zero,16(sp)
8110f378:	d8000315 	stw	zero,12(sp)
8110f37c:	00818004 	movi	r2,1536
8110f380:	d8800215 	stw	r2,8(sp)
8110f384:	00a04574 	movhi	r2,33045
8110f388:	109a0304 	addi	r2,r2,26636
8110f38c:	d8800115 	stw	r2,4(sp)
8110f390:	00800704 	movi	r2,28
8110f394:	d8800015 	stw	r2,0(sp)
8110f398:	01c00704 	movi	r7,28
8110f39c:	01a045b4 	movhi	r6,33046
8110f3a0:	31a00204 	addi	r6,r6,-32760
8110f3a4:	000b883a 	mov	r5,zero
8110f3a8:	01204474 	movhi	r4,33041
8110f3ac:	213fa104 	addi	r4,r4,-380
8110f3b0:	11382e40 	call	811382e4 <OSTaskCreateExt>
8110f3b4:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f3b8:	e0bffe03 	ldbu	r2,-8(fp)
8110f3bc:	10803fcc 	andi	r2,r2,255
8110f3c0:	10000126 	beq	r2,zero,8110f3c8 <vInitialTask+0x35c>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
			printErrorTask( error_code );
		#endif
		vFailParserCommTaskCreate();
8110f3c4:	1116b980 	call	81116b98 <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110f3c8:	01c03204 	movi	r7,200
8110f3cc:	000d883a 	mov	r6,zero
8110f3d0:	000b883a 	mov	r5,zero
8110f3d4:	0009883a 	mov	r4,zero
8110f3d8:	11395100 	call	81139510 <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
8110f3dc:	d8000415 	stw	zero,16(sp)
8110f3e0:	d8000315 	stw	zero,12(sp)
8110f3e4:	00818004 	movi	r2,1536
8110f3e8:	d8800215 	stw	r2,8(sp)
8110f3ec:	00a04574 	movhi	r2,33045
8110f3f0:	10bab504 	addi	r2,r2,-5420
8110f3f4:	d8800115 	stw	r2,4(sp)
8110f3f8:	00800804 	movi	r2,32
8110f3fc:	d8800015 	stw	r2,0(sp)
8110f400:	01c00804 	movi	r7,32
8110f404:	01a04574 	movhi	r6,33045
8110f408:	3180b404 	addi	r6,r6,720
8110f40c:	000b883a 	mov	r5,zero
8110f410:	01204474 	movhi	r4,33041
8110f414:	21020304 	addi	r4,r4,2060
8110f418:	11382e40 	call	811382e4 <OSTaskCreateExt>
8110f41c:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f420:	e0bffe03 	ldbu	r2,-8(fp)
8110f424:	10803fcc 	andi	r2,r2,255
8110f428:	10000126 	beq	r2,zero,8110f430 <vInitialTask+0x3c4>
		/* Can't create Task for receive comm packets */
		#if DEBUG_ON
			printErrorTask( error_code );		
		#endif
		vFailReceiverCreate();
8110f42c:	11168c80 	call	811168c8 <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110f430:	01c03204 	movi	r7,200
8110f434:	000d883a 	mov	r6,zero
8110f438:	000b883a 	mov	r5,zero
8110f43c:	0009883a 	mov	r4,zero
8110f440:	11395100 	call	81139510 <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
8110f444:	d8000415 	stw	zero,16(sp)
8110f448:	d8000315 	stw	zero,12(sp)
8110f44c:	00810004 	movi	r2,1024
8110f450:	d8800215 	stw	r2,8(sp)
8110f454:	00a04574 	movhi	r2,33045
8110f458:	10a99d04 	addi	r2,r2,-22924
8110f45c:	d8800115 	stw	r2,4(sp)
8110f460:	00800684 	movi	r2,26
8110f464:	d8800015 	stw	r2,0(sp)
8110f468:	01c00684 	movi	r7,26
8110f46c:	01a04574 	movhi	r6,33045
8110f470:	31ad9c04 	addi	r6,r6,-18832
8110f474:	000b883a 	mov	r5,zero
8110f478:	01204474 	movhi	r4,33041
8110f47c:	21046204 	addi	r4,r4,4488
8110f480:	11382e40 	call	811382e4 <OSTaskCreateExt>
8110f484:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
8110f488:	01c03204 	movi	r7,200
8110f48c:	000d883a 	mov	r6,zero
8110f490:	000b883a 	mov	r5,zero
8110f494:	0009883a 	mov	r4,zero
8110f498:	11395100 	call	81139510 <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
8110f49c:	e0bffe03 	ldbu	r2,-8(fp)
8110f4a0:	10803fcc 	andi	r2,r2,255
8110f4a4:	10000126 	beq	r2,zero,8110f4ac <vInitialTask+0x440>
		/* Can't create Task for sender comm packets */
		#if DEBUG_ON
			printErrorTask( error_code );		
		#endif
		vFailSenderCreate();
8110f4a8:	11168f00 	call	811168f0 <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
8110f4ac:	d0a06c17 	ldw	r2,-32336(gp)
8110f4b0:	e17ffe04 	addi	r5,fp,-8
8110f4b4:	1009883a 	mov	r4,r2
8110f4b8:	113a0040 	call	8113a004 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
8110f4bc:	e0bffe03 	ldbu	r2,-8(fp)
8110f4c0:	10803fcc 	andi	r2,r2,255
8110f4c4:	10000126 	beq	r2,zero,8110f4cc <vInitialTask+0x460>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
8110f4c8:	1116d780 	call	81116d78 <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
8110f4cc:	01c00084 	movi	r7,2
8110f4d0:	01800784 	movi	r6,30
8110f4d4:	000b883a 	mov	r5,zero
8110f4d8:	0009883a 	mov	r4,zero
8110f4dc:	11395100 	call	81139510 <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
8110f4e0:	01003fc4 	movi	r4,255
8110f4e4:	11384d00 	call	811384d0 <OSTaskDel>
8110f4e8:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
8110f4ec:	e0bffe03 	ldbu	r2,-8(fp)
8110f4f0:	10803fcc 	andi	r2,r2,255
8110f4f4:	10000c26 	beq	r2,zero,8110f528 <vInitialTask+0x4bc>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#if DEBUG_ON
			printErrorTask( error_code );		
		#endif
		vFailDeleteInitialization();
8110f4f8:	11169180 	call	81116918 <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
8110f4fc:	014009c4 	movi	r5,39
8110f500:	01000044 	movi	r4,1
8110f504:	1137c380 	call	81137c38 <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
8110f508:	01003fc4 	movi	r4,255
8110f50c:	11384d00 	call	811384d0 <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
8110f510:	000f883a 	mov	r7,zero
8110f514:	01800284 	movi	r6,10
8110f518:	000b883a 	mov	r5,zero
8110f51c:	0009883a 	mov	r4,zero
8110f520:	11395100 	call	81139510 <OSTimeDlyHMSM>
		}
8110f524:	003ff806 	br	8110f508 <__reset+0xfb0ef508>
	}

}
8110f528:	0001883a 	nop
8110f52c:	e037883a 	mov	sp,fp
8110f530:	dfc00117 	ldw	ra,4(sp)
8110f534:	df000017 	ldw	fp,0(sp)
8110f538:	dec00204 	addi	sp,sp,8
8110f53c:	f800283a 	ret

8110f540 <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
8110f540:	defff804 	addi	sp,sp,-32
8110f544:	de00012e 	bgeu	sp,et,8110f54c <vNFeeControlTask+0xc>
8110f548:	003b68fa 	trap	3
8110f54c:	dfc00715 	stw	ra,28(sp)
8110f550:	df000615 	stw	fp,24(sp)
8110f554:	df000604 	addi	fp,sp,24
8110f558:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucFeeInstL;
	static bool bDmaBack;
	static unsigned char ucWhoGetDMA;
	unsigned char ucIL;

	pxFeeC = (TNFee_Control *) task_data;
8110f55c:	e0bfff17 	ldw	r2,-4(fp)
8110f560:	e0bffb15 	stw	r2,-20(fp)
        debug(fp,"NFee Controller Task. (Task on)\n");
    #endif

	for (;;) {

		switch (pxFeeC->sMode)
8110f564:	e0bffb17 	ldw	r2,-20(fp)
8110f568:	10809a17 	ldw	r2,616(r2)
8110f56c:	10c00168 	cmpgeui	r3,r2,5
8110f570:	1800cc1e 	bne	r3,zero,8110f8a4 <vNFeeControlTask+0x364>
8110f574:	100690ba 	slli	r3,r2,2
8110f578:	00a04474 	movhi	r2,33041
8110f57c:	10bd6304 	addi	r2,r2,-2676
8110f580:	1885883a 	add	r2,r3,r2
8110f584:	10800017 	ldw	r2,0(r2)
8110f588:	1000683a 	jmp	r2
8110f58c:	8110f5a0 	cmpeqi	r4,r16,17366
8110f590:	8110f5d0 	cmplti	r4,r16,17367
8110f594:	8110f614 	ori	r4,r16,17368
8110f598:	8110f6ac 	andhi	r4,r16,17370
8110f59c:	8110f70c 	andi	r4,r16,17372
		{
			case sMebInit:
				/* Starting the NFEE Controller */

				/* Clear in CMD Queue  */
				error_codeCtrl = OSQFlush(xQMaskFeeCtrl);
8110f5a0:	d0a06f17 	ldw	r2,-32324(gp)
8110f5a4:	1009883a 	mov	r4,r2
8110f5a8:	11365c00 	call	811365c0 <OSQFlush>
8110f5ac:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8110f5b0:	e0bffe03 	ldbu	r2,-8(fp)
8110f5b4:	10803fcc 	andi	r2,r2,255
8110f5b8:	10000126 	beq	r2,zero,8110f5c0 <vNFeeControlTask+0x80>
					vFailFlushQueue();
8110f5bc:	111733c0 	call	8111733c <vFailFlushQueue>
				}

				pxFeeC->sMode = sMebToConfig;
8110f5c0:	e0bffb17 	ldw	r2,-20(fp)
8110f5c4:	00c00044 	movi	r3,1
8110f5c8:	10c09a15 	stw	r3,616(r2)
				break;
8110f5cc:	0000ba06 	br	8110f8b8 <vNFeeControlTask+0x378>
				#if DEBUG_ON
					debug(fp,"NFEE Controller Task:: Config Mode\n");
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
8110f5d0:	d0a05d17 	ldw	r2,-32396(gp)
8110f5d4:	1009883a 	mov	r4,r2
8110f5d8:	11365c00 	call	811365c0 <OSQFlush>
8110f5dc:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8110f5e0:	e0bffe03 	ldbu	r2,-8(fp)
8110f5e4:	10803fcc 	andi	r2,r2,255
8110f5e8:	10000126 	beq	r2,zero,8110f5f0 <vNFeeControlTask+0xb0>
					vFailFlushQueue();
8110f5ec:	111733c0 	call	8111733c <vFailFlushQueue>
				}

				bCmdSent = FALSE;
8110f5f0:	e03ffc15 	stw	zero,-16(fp)
				bDmaBack = TRUE;
8110f5f4:	00800044 	movi	r2,1
8110f5f8:	d0a05815 	stw	r2,-32416(gp)
				ucWhoGetDMA = 255;
8110f5fc:	00bfffc4 	movi	r2,-1
8110f600:	d0a05905 	stb	r2,-32412(gp)
				pxFeeC->sMode = sMebConfig;
8110f604:	e0bffb17 	ldw	r2,-20(fp)
8110f608:	00c000c4 	movi	r3,3
8110f60c:	10c09a15 	stw	r3,616(r2)
				break;
8110f610:	0000a906 	br	8110f8b8 <vNFeeControlTask+0x378>


			case sMebToRun:
				/* Transition state */
				vEvtChangeFeeControllerMode();
8110f614:	11174040 	call	81117404 <vEvtChangeFeeControllerMode>
				#if DEBUG_ON
					debug(fp,"NFEE Controller Task:: RUN Mode\n");
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
8110f618:	d0a05d17 	ldw	r2,-32396(gp)
8110f61c:	1009883a 	mov	r4,r2
8110f620:	11365c00 	call	811365c0 <OSQFlush>
8110f624:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8110f628:	e0bffe03 	ldbu	r2,-8(fp)
8110f62c:	10803fcc 	andi	r2,r2,255
8110f630:	10000126 	beq	r2,zero,8110f638 <vNFeeControlTask+0xf8>
					vFailFlushQueue();
8110f634:	111733c0 	call	8111733c <vFailFlushQueue>
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
8110f638:	e03ffa45 	stb	zero,-23(fp)
8110f63c:	00001006 	br	8110f680 <vNFeeControlTask+0x140>
				{
					error_codeCtrl = OSQFlush( xFeeQ[ ucIL ] );
8110f640:	e0bffa43 	ldbu	r2,-23(fp)
8110f644:	1085883a 	add	r2,r2,r2
8110f648:	1087883a 	add	r3,r2,r2
8110f64c:	d0a06904 	addi	r2,gp,-32348
8110f650:	1885883a 	add	r2,r3,r2
8110f654:	10800017 	ldw	r2,0(r2)
8110f658:	1009883a 	mov	r4,r2
8110f65c:	11365c00 	call	811365c0 <OSQFlush>
8110f660:	e0bffe05 	stb	r2,-8(fp)
					if ( error_codeCtrl != OS_NO_ERR ) {
8110f664:	e0bffe03 	ldbu	r2,-8(fp)
8110f668:	10803fcc 	andi	r2,r2,255
8110f66c:	10000126 	beq	r2,zero,8110f674 <vNFeeControlTask+0x134>
						vFailFlushQueue();
8110f670:	111733c0 	call	8111733c <vFailFlushQueue>
				if ( error_codeCtrl != OS_NO_ERR ) {
					vFailFlushQueue();
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
8110f674:	e0bffa43 	ldbu	r2,-23(fp)
8110f678:	10800044 	addi	r2,r2,1
8110f67c:	e0bffa45 	stb	r2,-23(fp)
8110f680:	e0bffa43 	ldbu	r2,-23(fp)
8110f684:	103fee26 	beq	r2,zero,8110f640 <__reset+0xfb0ef640>
					if ( error_codeCtrl != OS_NO_ERR ) {
						vFailFlushQueue();
					}
				}

				bCmdSent = FALSE;
8110f688:	e03ffc15 	stw	zero,-16(fp)
				bDmaBack = TRUE;
8110f68c:	00800044 	movi	r2,1
8110f690:	d0a05815 	stw	r2,-32416(gp)
				ucWhoGetDMA = 255;
8110f694:	00bfffc4 	movi	r2,-1
8110f698:	d0a05905 	stb	r2,-32412(gp)
				pxFeeC->sMode = sMebRun;
8110f69c:	e0bffb17 	ldw	r2,-20(fp)
8110f6a0:	00c00104 	movi	r3,4
8110f6a4:	10c09a15 	stw	r3,616(r2)
				break;
8110f6a8:	00008306 	br	8110f8b8 <vNFeeControlTask+0x378>


			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl); /* Blocking operation */
8110f6ac:	d0a06f17 	ldw	r2,-32324(gp)
8110f6b0:	e0fffe04 	addi	r3,fp,-8
8110f6b4:	180d883a 	mov	r6,r3
8110f6b8:	000b883a 	mov	r5,zero
8110f6bc:	1009883a 	mov	r4,r2
8110f6c0:	11366800 	call	81136680 <OSQPend>
8110f6c4:	e0bffd15 	stw	r2,-12(fp)
				if ( error_codeCtrl == OS_ERR_NONE ) {
8110f6c8:	e0bffe03 	ldbu	r2,-8(fp)
8110f6cc:	10803fcc 	andi	r2,r2,255
8110f6d0:	10000c1e 	bne	r2,zero,8110f704 <vNFeeControlTask+0x1c4>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
8110f6d4:	e0bffdc3 	ldbu	r2,-9(fp)
8110f6d8:	10803fcc 	andi	r2,r2,255
8110f6dc:	10800418 	cmpnei	r2,r2,16
8110f6e0:	1000041e 	bne	r2,zero,8110f6f4 <vNFeeControlTask+0x1b4>
						
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
8110f6e4:	e0bffd17 	ldw	r2,-12(fp)
8110f6e8:	e17ffb17 	ldw	r5,-20(fp)
8110f6ec:	1009883a 	mov	r4,r2
8110f6f0:	110f8bc0 	call	8110f8bc <vPerformActionNFCConfig>

					};
					bCmdSent = FALSE;
8110f6f4:	e03ffc15 	stw	zero,-16(fp)
					bDmaBack = TRUE;
8110f6f8:	00800044 	movi	r2,1
8110f6fc:	d0a05815 	stw	r2,-32416(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
8110f700:	00006d06 	br	8110f8b8 <vNFeeControlTask+0x378>
					};
					bCmdSent = FALSE;
					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
8110f704:	11171540 	call	81117154 <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
8110f708:	00006b06 	br	8110f8b8 <vNFeeControlTask+0x378>
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fat way and 
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				

				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
8110f70c:	d0a05817 	ldw	r2,-32416(gp)
8110f710:	10800058 	cmpnei	r2,r2,1
8110f714:	1000221e 	bne	r2,zero,8110f7a0 <vNFeeControlTask+0x260>

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 4, &error_codeCtrl);
8110f718:	d0a05d17 	ldw	r2,-32396(gp)
8110f71c:	e0fffe04 	addi	r3,fp,-8
8110f720:	180d883a 	mov	r6,r3
8110f724:	01400104 	movi	r5,4
8110f728:	1009883a 	mov	r4,r2
8110f72c:	11366800 	call	81136680 <OSQPend>
8110f730:	e0bffd15 	stw	r2,-12(fp)
					if ( error_codeCtrl == OS_ERR_NONE ) {
8110f734:	e0bffe03 	ldbu	r2,-8(fp)
8110f738:	10803fcc 	andi	r2,r2,255
8110f73c:	1000181e 	bne	r2,zero,8110f7a0 <vNFeeControlTask+0x260>
						ucFeeInstL = uiCmdNFC.ucByte[0];
8110f740:	e0bffd03 	ldbu	r2,-12(fp)
8110f744:	e0bffa05 	stb	r2,-24(fp)


						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
8110f748:	e0bffa03 	ldbu	r2,-24(fp)
8110f74c:	e0fffb17 	ldw	r3,-20(fp)
8110f750:	10809624 	muli	r2,r2,600
8110f754:	1885883a 	add	r2,r3,r2
8110f758:	10802304 	addi	r2,r2,140
8110f75c:	10800017 	ldw	r2,0(r2)
8110f760:	10800058 	cmpnei	r2,r2,1
8110f764:	10000e1e 	bne	r2,zero,8110f7a0 <vNFeeControlTask+0x260>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
8110f768:	e0bffa03 	ldbu	r2,-24(fp)
8110f76c:	e0fffa03 	ldbu	r3,-24(fp)
8110f770:	180f883a 	mov	r7,r3
8110f774:	000d883a 	mov	r6,zero
8110f778:	014023c4 	movi	r5,143
8110f77c:	1009883a 	mov	r4,r2
8110f780:	110fa340 	call	8110fa34 <bSendCmdQToNFeeInst>
8110f784:	e0bffc15 	stw	r2,-16(fp)
							if ( bCmdSent == TRUE ) {
8110f788:	e0bffc17 	ldw	r2,-16(fp)
8110f78c:	10800058 	cmpnei	r2,r2,1
8110f790:	1000031e 	bne	r2,zero,8110f7a0 <vNFeeControlTask+0x260>
								bDmaBack = FALSE;
8110f794:	d0205815 	stw	zero,-32416(gp)
								ucWhoGetDMA = ucFeeInstL;
8110f798:	e0bffa03 	ldbu	r2,-24(fp)
8110f79c:	d0a05905 	stb	r2,-32412(gp)
							}
						}
					}
				} 

				if ( bDmaBack == FALSE ) {
8110f7a0:	d0a05817 	ldw	r2,-32416(gp)
8110f7a4:	1000081e 	bne	r2,zero,8110f7c8 <vNFeeControlTask+0x288>

					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
8110f7a8:	d0a06f17 	ldw	r2,-32324(gp)
8110f7ac:	e0fffe04 	addi	r3,fp,-8
8110f7b0:	180d883a 	mov	r6,r3
8110f7b4:	000b883a 	mov	r5,zero
8110f7b8:	1009883a 	mov	r4,r2
8110f7bc:	11366800 	call	81136680 <OSQPend>
8110f7c0:	e0bffd15 	stw	r2,-12(fp)
8110f7c4:	00000706 	br	8110f7e4 <vNFeeControlTask+0x2a4>
				} else {
					/* If No FEE has the DMA */

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 4, &error_codeCtrl);
8110f7c8:	d0a06f17 	ldw	r2,-32324(gp)
8110f7cc:	e0fffe04 	addi	r3,fp,-8
8110f7d0:	180d883a 	mov	r6,r3
8110f7d4:	01400104 	movi	r5,4
8110f7d8:	1009883a 	mov	r4,r2
8110f7dc:	11366800 	call	81136680 <OSQPend>
8110f7e0:	e0bffd15 	stw	r2,-12(fp)
				}

				if ( error_codeCtrl == OS_ERR_NONE ){
8110f7e4:	e0bffe03 	ldbu	r2,-8(fp)
8110f7e8:	10803fcc 	andi	r2,r2,255
8110f7ec:	1000311e 	bne	r2,zero,8110f8b4 <vNFeeControlTask+0x374>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
8110f7f0:	e0bffd83 	ldbu	r2,-10(fp)
8110f7f4:	10803fcc 	andi	r2,r2,255
8110f7f8:	10802058 	cmpnei	r2,r2,129
8110f7fc:	1000091e 	bne	r2,zero,8110f824 <vNFeeControlTask+0x2e4>
						if ( uiCmdNFC.ucByte[0] == ucFeeInstL ){
8110f800:	e0bffd03 	ldbu	r2,-12(fp)
8110f804:	10c03fcc 	andi	r3,r2,255
8110f808:	e0bffa03 	ldbu	r2,-24(fp)
8110f80c:	1880291e 	bne	r3,r2,8110f8b4 <vNFeeControlTask+0x374>
							bDmaBack = TRUE;
8110f810:	00800044 	movi	r2,1
8110f814:	d0a05815 	stw	r2,-32416(gp)
							ucFeeInstL = 255;
8110f818:	00bfffc4 	movi	r2,-1
8110f81c:	e0bffa05 	stb	r2,-24(fp)
				}
				//if ( xDefaults.usiDelay == 0 ) {
				//	OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				//}
				
				break;		
8110f820:	00002406 	br	8110f8b4 <vNFeeControlTask+0x374>
						}

					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
8110f824:	e0bffdc3 	ldbu	r2,-9(fp)
8110f828:	10803fcc 	andi	r2,r2,255
8110f82c:	10800418 	cmpnei	r2,r2,16
8110f830:	1000051e 	bne	r2,zero,8110f848 <vNFeeControlTask+0x308>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
8110f834:	e0bffd17 	ldw	r2,-12(fp)
8110f838:	e17ffb17 	ldw	r5,-20(fp)
8110f83c:	1009883a 	mov	r4,r2
8110f840:	110f9400 	call	8110f940 <vPerformActionNFCRunning>
				}
				//if ( xDefaults.usiDelay == 0 ) {
				//	OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				//}
				
				break;		
8110f844:	00001b06 	br	8110f8b4 <vNFeeControlTask+0x374>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
8110f848:	e0bffdc3 	ldbu	r2,-9(fp)
8110f84c:	10803fcc 	andi	r2,r2,255
8110f850:	10800470 	cmpltui	r2,r2,17
8110f854:	1000171e 	bne	r2,zero,8110f8b4 <vNFeeControlTask+0x374>
8110f858:	e0bffdc3 	ldbu	r2,-9(fp)
8110f85c:	10803fcc 	andi	r2,r2,255
8110f860:	108004e8 	cmpgeui	r2,r2,19
8110f864:	1000131e 	bne	r2,zero,8110f8b4 <vNFeeControlTask+0x374>

								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
8110f868:	e0bffdc3 	ldbu	r2,-9(fp)
8110f86c:	10bffbc4 	addi	r2,r2,-17
8110f870:	10803fcc 	andi	r2,r2,255
8110f874:	e0fffd83 	ldbu	r3,-10(fp)
8110f878:	18c03fcc 	andi	r3,r3,255
8110f87c:	e13ffd43 	ldbu	r4,-11(fp)
8110f880:	21003fcc 	andi	r4,r4,255
8110f884:	e17ffd03 	ldbu	r5,-12(fp)
8110f888:	29403fcc 	andi	r5,r5,255
8110f88c:	280f883a 	mov	r7,r5
8110f890:	200d883a 	mov	r6,r4
8110f894:	180b883a 	mov	r5,r3
8110f898:	1009883a 	mov	r4,r2
8110f89c:	110fa340 	call	8110fa34 <bSendCmdQToNFeeInst>
				}
				//if ( xDefaults.usiDelay == 0 ) {
				//	OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				//}
				
				break;		
8110f8a0:	00000406 	br	8110f8b4 <vNFeeControlTask+0x374>
				#if DEBUG_ON
					debug(fp,"NFEE Controller Task: Unknown state, backing to Config Mode.\n");
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
8110f8a4:	e0bffb17 	ldw	r2,-20(fp)
8110f8a8:	00c000c4 	movi	r3,3
8110f8ac:	10c09a15 	stw	r3,616(r2)
				break;
8110f8b0:	00000106 	br	8110f8b8 <vNFeeControlTask+0x378>
				}
				//if ( xDefaults.usiDelay == 0 ) {
				//	OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				//}
				
				break;		
8110f8b4:	0001883a 	nop
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
				break;
		}
	}
8110f8b8:	003f2a06 	br	8110f564 <__reset+0xfb0ef564>

8110f8bc <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8110f8bc:	defffc04 	addi	sp,sp,-16
8110f8c0:	de00012e 	bgeu	sp,et,8110f8c8 <vPerformActionNFCConfig+0xc>
8110f8c4:	003b68fa 	trap	3
8110f8c8:	df000315 	stw	fp,12(sp)
8110f8cc:	df000304 	addi	fp,sp,12
8110f8d0:	e13ffe15 	stw	r4,-8(fp)
8110f8d4:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	INT8U errorCodeL;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
8110f8d8:	e0bffe17 	ldw	r2,-8(fp)
8110f8dc:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
8110f8e0:	e0bffd83 	ldbu	r2,-10(fp)
8110f8e4:	10803fcc 	andi	r2,r2,255
8110f8e8:	10c000a0 	cmpeqi	r3,r2,2
8110f8ec:	18000a1e 	bne	r3,zero,8110f918 <vPerformActionNFCConfig+0x5c>
8110f8f0:	10c000c8 	cmpgei	r3,r2,3
8110f8f4:	1800031e 	bne	r3,zero,8110f904 <vPerformActionNFCConfig+0x48>
8110f8f8:	10800060 	cmpeqi	r2,r2,1
8110f8fc:	10000a1e 	bne	r2,zero,8110f928 <vPerformActionNFCConfig+0x6c>

		default:
			#if DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			#endif	
			break;
8110f900:	00000a06 	br	8110f92c <vPerformActionNFCConfig+0x70>
	INT8U errorCodeL;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;

	switch (uiCmdLocal.ucByte[2]) {
8110f904:	10c02860 	cmpeqi	r3,r2,161
8110f908:	1800071e 	bne	r3,zero,8110f928 <vPerformActionNFCConfig+0x6c>
8110f90c:	108028a0 	cmpeqi	r2,r2,162
8110f910:	1000011e 	bne	r2,zero,8110f918 <vPerformActionNFCConfig+0x5c>

		default:
			#if DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			#endif	
			break;
8110f914:	00000506 	br	8110f92c <vPerformActionNFCConfig+0x70>
			/* Do nothing for now */
			break;

		case M_NFC_RUN_FORCED:
		case M_NFC_RUN:
			pxFeeCP->sMode = sMebToRun;
8110f918:	e0bfff17 	ldw	r2,-4(fp)
8110f91c:	00c00084 	movi	r3,2
8110f920:	10c09a15 	stw	r3,616(r2)
			break;
8110f924:	00000106 	br	8110f92c <vPerformActionNFCConfig+0x70>
		case M_NFC_CONFIG:
			#if DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
			#endif
			/* Do nothing for now */
			break;
8110f928:	0001883a 	nop
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			#endif	
			break;
	}

}
8110f92c:	0001883a 	nop
8110f930:	e037883a 	mov	sp,fp
8110f934:	df000017 	ldw	fp,0(sp)
8110f938:	dec00104 	addi	sp,sp,4
8110f93c:	f800283a 	ret

8110f940 <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8110f940:	defffa04 	addi	sp,sp,-24
8110f944:	de00012e 	bgeu	sp,et,8110f94c <vPerformActionNFCRunning+0xc>
8110f948:	003b68fa 	trap	3
8110f94c:	dfc00515 	stw	ra,20(sp)
8110f950:	df000415 	stw	fp,16(sp)
8110f954:	df000404 	addi	fp,sp,16
8110f958:	e13ffe15 	stw	r4,-8(fp)
8110f95c:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
8110f960:	e0bffe17 	ldw	r2,-8(fp)
8110f964:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
8110f968:	e0bffd83 	ldbu	r2,-10(fp)
8110f96c:	10803fcc 	andi	r2,r2,255
8110f970:	10c02088 	cmpgei	r3,r2,130
8110f974:	1800071e 	bne	r3,zero,8110f994 <vPerformActionNFCRunning+0x54>
8110f978:	10c02008 	cmpgei	r3,r2,128
8110f97c:	1800241e 	bne	r3,zero,8110fa10 <vPerformActionNFCRunning+0xd0>
8110f980:	10c00060 	cmpeqi	r3,r2,1
8110f984:	1800061e 	bne	r3,zero,8110f9a0 <vPerformActionNFCRunning+0x60>
8110f988:	108000a0 	cmpeqi	r2,r2,2
8110f98c:	1000221e 	bne	r2,zero,8110fa18 <vPerformActionNFCRunning+0xd8>
			break;
		default:
			#if DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			#endif	
			break;
8110f990:	00002206 	br	8110fa1c <vPerformActionNFCRunning+0xdc>
	tQMask uiCmdLocal;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;

	switch (uiCmdLocal.ucByte[2]) {
8110f994:	10802860 	cmpeqi	r2,r2,161
8110f998:	1000011e 	bne	r2,zero,8110f9a0 <vPerformActionNFCRunning+0x60>
			break;
		default:
			#if DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			#endif	
			break;
8110f99c:	00001f06 	br	8110fa1c <vPerformActionNFCRunning+0xdc>

	switch (uiCmdLocal.ucByte[2]) {
		case M_NFC_CONFIG:
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;
8110f9a0:	e0bfff17 	ldw	r2,-4(fp)
8110f9a4:	00c00044 	movi	r3,1
8110f9a8:	10c09a15 	stw	r3,616(r2)

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
8110f9ac:	e03ffc05 	stb	zero,-16(fp)
8110f9b0:	00001406 	br	8110fa04 <vPerformActionNFCRunning+0xc4>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
8110f9b4:	e0bffc03 	ldbu	r2,-16(fp)
8110f9b8:	e0ffff17 	ldw	r3,-4(fp)
8110f9bc:	108025c4 	addi	r2,r2,151
8110f9c0:	1085883a 	add	r2,r2,r2
8110f9c4:	1085883a 	add	r2,r2,r2
8110f9c8:	1885883a 	add	r2,r3,r2
8110f9cc:	10800017 	ldw	r2,0(r2)
8110f9d0:	10800017 	ldw	r2,0(r2)
8110f9d4:	10800058 	cmpnei	r2,r2,1
8110f9d8:	1000071e 	bne	r2,zero,8110f9f8 <vPerformActionNFCRunning+0xb8>
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
8110f9dc:	e0bffc03 	ldbu	r2,-16(fp)
8110f9e0:	e0fffc03 	ldbu	r3,-16(fp)
8110f9e4:	180f883a 	mov	r7,r3
8110f9e8:	000d883a 	mov	r6,zero
8110f9ec:	01402844 	movi	r5,161
8110f9f0:	1009883a 	mov	r4,r2
8110f9f4:	110fafc0 	call	8110fafc <bSendCmdQToNFeeInst_Prio>
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
8110f9f8:	e0bffc03 	ldbu	r2,-16(fp)
8110f9fc:	10800044 	addi	r2,r2,1
8110fa00:	e0bffc05 	stb	r2,-16(fp)
8110fa04:	e0bffc03 	ldbu	r2,-16(fp)
8110fa08:	103fea26 	beq	r2,zero,8110f9b4 <__reset+0xfb0ef9b4>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
				}
			}

			break;
8110fa0c:	00000306 	br	8110fa1c <vPerformActionNFCRunning+0xdc>
			/* Do nothing for now */

			break;
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
8110fa10:	0001883a 	nop
8110fa14:	00000106 	br	8110fa1c <vPerformActionNFCRunning+0xdc>
			#if DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
			#endif		
			/* Do nothing for now */

			break;
8110fa18:	0001883a 	nop
			#if DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			#endif	
			break;
	}
}
8110fa1c:	0001883a 	nop
8110fa20:	e037883a 	mov	sp,fp
8110fa24:	dfc00117 	ldw	ra,4(sp)
8110fa28:	df000017 	ldw	fp,0(sp)
8110fa2c:	dec00204 	addi	sp,sp,8
8110fa30:	f800283a 	ret

8110fa34 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110fa34:	defff704 	addi	sp,sp,-36
8110fa38:	de00012e 	bgeu	sp,et,8110fa40 <bSendCmdQToNFeeInst+0xc>
8110fa3c:	003b68fa 	trap	3
8110fa40:	dfc00815 	stw	ra,32(sp)
8110fa44:	df000715 	stw	fp,28(sp)
8110fa48:	df000704 	addi	fp,sp,28
8110fa4c:	2011883a 	mov	r8,r4
8110fa50:	2809883a 	mov	r4,r5
8110fa54:	3007883a 	mov	r3,r6
8110fa58:	3805883a 	mov	r2,r7
8110fa5c:	e23ffc05 	stb	r8,-16(fp)
8110fa60:	e13ffd05 	stb	r4,-12(fp)
8110fa64:	e0fffe05 	stb	r3,-8(fp)
8110fa68:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
8110fa6c:	e0bffc03 	ldbu	r2,-16(fp)
8110fa70:	10800444 	addi	r2,r2,17
8110fa74:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110fa78:	e0bffd03 	ldbu	r2,-12(fp)
8110fa7c:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110fa80:	e0bffe03 	ldbu	r2,-8(fp)
8110fa84:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110fa88:	e0bfff03 	ldbu	r2,-4(fp)
8110fa8c:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110fa90:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
8110fa94:	e0bffc03 	ldbu	r2,-16(fp)
8110fa98:	1085883a 	add	r2,r2,r2
8110fa9c:	1087883a 	add	r3,r2,r2
8110faa0:	d0a06904 	addi	r2,gp,-32348
8110faa4:	1885883a 	add	r2,r3,r2
8110faa8:	10800017 	ldw	r2,0(r2)
8110faac:	e0fffb17 	ldw	r3,-20(fp)
8110fab0:	180b883a 	mov	r5,r3
8110fab4:	1009883a 	mov	r4,r2
8110fab8:	1136a880 	call	81136a88 <OSQPost>
8110fabc:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110fac0:	e0bffa03 	ldbu	r2,-24(fp)
8110fac4:	10000526 	beq	r2,zero,8110fadc <bSendCmdQToNFeeInst+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
8110fac8:	e0bffc03 	ldbu	r2,-16(fp)
8110facc:	1009883a 	mov	r4,r2
8110fad0:	11171a40 	call	811171a4 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
8110fad4:	e03ff915 	stw	zero,-28(fp)
8110fad8:	00000206 	br	8110fae4 <bSendCmdQToNFeeInst+0xb0>
	} else {
		bSuccesL =  TRUE;
8110fadc:	00800044 	movi	r2,1
8110fae0:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
8110fae4:	e0bff917 	ldw	r2,-28(fp)
}
8110fae8:	e037883a 	mov	sp,fp
8110faec:	dfc00117 	ldw	ra,4(sp)
8110faf0:	df000017 	ldw	fp,0(sp)
8110faf4:	dec00204 	addi	sp,sp,8
8110faf8:	f800283a 	ret

8110fafc <bSendCmdQToNFeeInst_Prio>:


bool bSendCmdQToNFeeInst_Prio( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110fafc:	defff704 	addi	sp,sp,-36
8110fb00:	de00012e 	bgeu	sp,et,8110fb08 <bSendCmdQToNFeeInst_Prio+0xc>
8110fb04:	003b68fa 	trap	3
8110fb08:	dfc00815 	stw	ra,32(sp)
8110fb0c:	df000715 	stw	fp,28(sp)
8110fb10:	df000704 	addi	fp,sp,28
8110fb14:	2011883a 	mov	r8,r4
8110fb18:	2809883a 	mov	r4,r5
8110fb1c:	3007883a 	mov	r3,r6
8110fb20:	3805883a 	mov	r2,r7
8110fb24:	e23ffc05 	stb	r8,-16(fp)
8110fb28:	e13ffd05 	stb	r4,-12(fp)
8110fb2c:	e0fffe05 	stb	r3,-8(fp)
8110fb30:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
8110fb34:	e0bffc03 	ldbu	r2,-16(fp)
8110fb38:	10800444 	addi	r2,r2,17
8110fb3c:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110fb40:	e0bffd03 	ldbu	r2,-12(fp)
8110fb44:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110fb48:	e0bffe03 	ldbu	r2,-8(fp)
8110fb4c:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110fb50:	e0bfff03 	ldbu	r2,-4(fp)
8110fb54:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110fb58:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPostFront(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
8110fb5c:	e0bffc03 	ldbu	r2,-16(fp)
8110fb60:	1085883a 	add	r2,r2,r2
8110fb64:	1087883a 	add	r3,r2,r2
8110fb68:	d0a06904 	addi	r2,gp,-32348
8110fb6c:	1885883a 	add	r2,r3,r2
8110fb70:	10800017 	ldw	r2,0(r2)
8110fb74:	e0fffb17 	ldw	r3,-20(fp)
8110fb78:	180b883a 	mov	r5,r3
8110fb7c:	1009883a 	mov	r4,r2
8110fb80:	1136bf80 	call	81136bf8 <OSQPostFront>
8110fb84:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110fb88:	e0bffa03 	ldbu	r2,-24(fp)
8110fb8c:	10000526 	beq	r2,zero,8110fba4 <bSendCmdQToNFeeInst_Prio+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
8110fb90:	e0bffc03 	ldbu	r2,-16(fp)
8110fb94:	1009883a 	mov	r4,r2
8110fb98:	11171a40 	call	811171a4 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
8110fb9c:	e03ff915 	stw	zero,-28(fp)
8110fba0:	00000206 	br	8110fbac <bSendCmdQToNFeeInst_Prio+0xb0>
	} else {
		bSuccesL =  TRUE;
8110fba4:	00800044 	movi	r2,1
8110fba8:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
8110fbac:	e0bff917 	ldw	r2,-28(fp)
}
8110fbb0:	e037883a 	mov	sp,fp
8110fbb4:	dfc00117 	ldw	ra,4(sp)
8110fbb8:	df000017 	ldw	fp,0(sp)
8110fbbc:	dec00204 	addi	sp,sp,8
8110fbc0:	f800283a 	ret

8110fbc4 <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
8110fbc4:	defff704 	addi	sp,sp,-36
8110fbc8:	de00012e 	bgeu	sp,et,8110fbd0 <vOutAckHandlerTask+0xc>
8110fbcc:	003b68fa 	trap	3
8110fbd0:	dfc00815 	stw	ra,32(sp)
8110fbd4:	df000715 	stw	fp,28(sp)
8110fbd8:	df000704 	addi	fp,sp,28
8110fbdc:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
8110fbe0:	e03ffac5 	stb	zero,-21(fp)
8110fbe4:	e03ffb05 	stb	zero,-20(fp)
8110fbe8:	e03ffb45 	stb	zero,-19(fp)
8110fbec:	e03ffb85 	stb	zero,-18(fp)
8110fbf0:	e03ffbc5 	stb	zero,-17(fp)
8110fbf4:	e03ffc05 	stb	zero,-16(fp)
8110fbf8:	e03ffc45 	stb	zero,-15(fp)
8110fbfc:	e03ffc85 	stb	zero,-14(fp)
8110fc00:	e03ffcc5 	stb	zero,-13(fp)
8110fc04:	e03ffd05 	stb	zero,-12(fp)
8110fc08:	e03ffd45 	stb	zero,-11(fp)
8110fc0c:	e03ffd85 	stb	zero,-10(fp)
8110fc10:	e03ffdc5 	stb	zero,-9(fp)
8110fc14:	e03ffe05 	stb	zero,-8(fp)
8110fc18:	e03ffe45 	stb	zero,-7(fp)
8110fc1c:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
8110fc20:	e03ffa45 	stb	zero,-23(fp)

	#if DEBUG_ON
		debug(fp,"Out Ack Handler Task. (Task on)\n");
	#endif

	eSenderAckState = sSAConfiguring;
8110fc24:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
8110fc28:	e0bff917 	ldw	r2,-28(fp)
8110fc2c:	10c00060 	cmpeqi	r3,r2,1
8110fc30:	1800071e 	bne	r3,zero,8110fc50 <vOutAckHandlerTask+0x8c>
8110fc34:	0080032e 	bgeu	zero,r2,8110fc44 <vOutAckHandlerTask+0x80>
8110fc38:	108000a0 	cmpeqi	r2,r2,2
8110fc3c:	1000471e 	bne	r2,zero,8110fd5c <vOutAckHandlerTask+0x198>
8110fc40:	00008c06 	br	8110fe74 <vOutAckHandlerTask+0x2b0>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
8110fc44:	00800044 	movi	r2,1
8110fc48:	e0bff915 	stw	r2,-28(fp)
				break;
8110fc4c:	00008c06 	br	8110fe80 <vOutAckHandlerTask+0x2bc>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
8110fc50:	00800044 	movi	r2,1
8110fc54:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
8110fc58:	d0a06117 	ldw	r2,-32380(gp)
8110fc5c:	e0fffa84 	addi	r3,fp,-22
8110fc60:	180d883a 	mov	r6,r3
8110fc64:	000b883a 	mov	r5,zero
8110fc68:	1009883a 	mov	r4,r2
8110fc6c:	11375780 	call	81137578 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
8110fc70:	e0bffa83 	ldbu	r2,-22(fp)
8110fc74:	10803fcc 	andi	r2,r2,255
8110fc78:	1000361e 	bne	r2,zero,8110fd54 <vOutAckHandlerTask+0x190>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
8110fc7c:	d0a07117 	ldw	r2,-32316(gp)
8110fc80:	e0fffa84 	addi	r3,fp,-22
8110fc84:	180d883a 	mov	r6,r3
8110fc88:	000b883a 	mov	r5,zero
8110fc8c:	1009883a 	mov	r4,r2
8110fc90:	113556c0 	call	8113556c <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8110fc94:	e0bffa83 	ldbu	r2,-22(fp)
8110fc98:	10803fcc 	andi	r2,r2,255
8110fc9c:	10002b1e 	bne	r2,zero,8110fd4c <vOutAckHandlerTask+0x188>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8110fca0:	e03ffa05 	stb	zero,-24(fp)
8110fca4:	00002206 	br	8110fd30 <vOutAckHandlerTask+0x16c>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
8110fca8:	e0fffa03 	ldbu	r3,-24(fp)
8110fcac:	00a045b4 	movhi	r2,33046
8110fcb0:	10ac0f04 	addi	r2,r2,-20420
8110fcb4:	18c7883a 	add	r3,r3,r3
8110fcb8:	18c7883a 	add	r3,r3,r3
8110fcbc:	10c5883a 	add	r2,r2,r3
8110fcc0:	10800003 	ldbu	r2,0(r2)
8110fcc4:	10803fcc 	andi	r2,r2,255
8110fcc8:	1080201c 	xori	r2,r2,128
8110fccc:	10bfe004 	addi	r2,r2,-128
8110fcd0:	10001426 	beq	r2,zero,8110fd24 <vOutAckHandlerTask+0x160>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
8110fcd4:	e0fffa03 	ldbu	r3,-24(fp)
8110fcd8:	00a045b4 	movhi	r2,33046
8110fcdc:	10ac0f04 	addi	r2,r2,-20420
8110fce0:	18c7883a 	add	r3,r3,r3
8110fce4:	18c7883a 	add	r3,r3,r3
8110fce8:	10c5883a 	add	r2,r2,r3
8110fcec:	10c0000b 	ldhu	r3,0(r2)
8110fcf0:	d0e0598d 	sth	r3,-32410(gp)
8110fcf4:	1080008b 	ldhu	r2,2(r2)
8110fcf8:	d0a05a0d 	sth	r2,-32408(gp)
                                eSenderAckState = sSASending;
8110fcfc:	00800084 	movi	r2,2
8110fd00:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
8110fd04:	e0fffa03 	ldbu	r3,-24(fp)
8110fd08:	00a045b4 	movhi	r2,33046
8110fd0c:	10ac0f04 	addi	r2,r2,-20420
8110fd10:	18c7883a 	add	r3,r3,r3
8110fd14:	18c7883a 	add	r3,r3,r3
8110fd18:	10c5883a 	add	r2,r2,r3
8110fd1c:	10000005 	stb	zero,0(r2)
                                break;
8110fd20:	00000606 	br	8110fd3c <vOutAckHandlerTask+0x178>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8110fd24:	e0bffa03 	ldbu	r2,-24(fp)
8110fd28:	10800044 	addi	r2,r2,1
8110fd2c:	e0bffa05 	stb	r2,-24(fp)
8110fd30:	e0bffa03 	ldbu	r2,-24(fp)
8110fd34:	10800230 	cmpltui	r2,r2,8
8110fd38:	103fdb1e 	bne	r2,zero,8110fca8 <__reset+0xfb0efca8>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
8110fd3c:	d0a07117 	ldw	r2,-32316(gp)
8110fd40:	1009883a 	mov	r4,r2
8110fd44:	1135b100 	call	81135b10 <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
8110fd48:	00004d06 	br	8110fe80 <vOutAckHandlerTask+0x2bc>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
8110fd4c:	11167d80 	call	811167d8 <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
8110fd50:	00004b06 	br	8110fe80 <vOutAckHandlerTask+0x2bc>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
8110fd54:	11167b00 	call	811167b0 <vFailGetCountSemaphoreSenderTask>
                }

                break;
8110fd58:	00004906 	br	8110fe80 <vOutAckHandlerTask+0x2bc>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
8110fd5c:	d0a05983 	ldbu	r2,-32410(gp)
8110fd60:	10803fcc 	andi	r2,r2,255
8110fd64:	1080201c 	xori	r2,r2,128
8110fd68:	10bfe004 	addi	r2,r2,-128
8110fd6c:	108008e0 	cmpeqi	r2,r2,35
8110fd70:	1000201e 	bne	r2,zero,8110fdf4 <vOutAckHandlerTask+0x230>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
8110fd74:	d0a059c3 	ldbu	r2,-32409(gp)
8110fd78:	10c03fcc 	andi	r3,r2,255
8110fd7c:	18c0201c 	xori	r3,r3,128
8110fd80:	18ffe004 	addi	r3,r3,-128
8110fd84:	d0a05a0b 	ldhu	r2,-32408(gp)
8110fd88:	113fffcc 	andi	r4,r2,65535
8110fd8c:	e0bffac4 	addi	r2,fp,-21
8110fd90:	200f883a 	mov	r7,r4
8110fd94:	180d883a 	mov	r6,r3
8110fd98:	01604534 	movhi	r5,33044
8110fd9c:	29529a04 	addi	r5,r5,19048
8110fda0:	1009883a 	mov	r4,r2
8110fda4:	111b0580 	call	8111b058 <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
8110fda8:	e0bffac4 	addi	r2,fp,-21
8110fdac:	1009883a 	mov	r4,r2
8110fdb0:	111b1180 	call	8111b118 <strlen>
8110fdb4:	1007883a 	mov	r3,r2
8110fdb8:	e0bffac4 	addi	r2,fp,-21
8110fdbc:	180b883a 	mov	r5,r3
8110fdc0:	1009883a 	mov	r4,r2
8110fdc4:	111652c0 	call	8111652c <ucCrc8wInit>
8110fdc8:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
8110fdcc:	e13ffa43 	ldbu	r4,-23(fp)
8110fdd0:	e0fffac4 	addi	r3,fp,-21
8110fdd4:	e0bffac4 	addi	r2,fp,-21
8110fdd8:	200f883a 	mov	r7,r4
8110fddc:	180d883a 	mov	r6,r3
8110fde0:	01604534 	movhi	r5,33044
8110fde4:	29529c04 	addi	r5,r5,19056
8110fde8:	1009883a 	mov	r4,r2
8110fdec:	111b0580 	call	8111b058 <sprintf>
8110fdf0:	00000c06 	br	8110fe24 <vOutAckHandlerTask+0x260>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
8110fdf4:	e0bffac4 	addi	r2,fp,-21
8110fdf8:	00c008c4 	movi	r3,35
8110fdfc:	10c00005 	stb	r3,0(r2)
8110fe00:	00c01f04 	movi	r3,124
8110fe04:	10c00045 	stb	r3,1(r2)
8110fe08:	00c00d44 	movi	r3,53
8110fe0c:	10c00085 	stb	r3,2(r2)
8110fe10:	00c00d04 	movi	r3,52
8110fe14:	10c000c5 	stb	r3,3(r2)
8110fe18:	00c00ec4 	movi	r3,59
8110fe1c:	10c00105 	stb	r3,4(r2)
8110fe20:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
8110fe24:	d0a07317 	ldw	r2,-32308(gp)
8110fe28:	e0fffa84 	addi	r3,fp,-22
8110fe2c:	180d883a 	mov	r6,r3
8110fe30:	01401904 	movi	r5,100
8110fe34:	1009883a 	mov	r4,r2
8110fe38:	113556c0 	call	8113556c <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
8110fe3c:	e0bffa83 	ldbu	r2,-22(fp)
8110fe40:	10803fcc 	andi	r2,r2,255
8110fe44:	1000071e 	bne	r2,zero,8110fe64 <vOutAckHandlerTask+0x2a0>
                    puts(cBufferAck);
8110fe48:	e0bffac4 	addi	r2,fp,-21
8110fe4c:	1009883a 	mov	r4,r2
8110fe50:	111af680 	call	8111af68 <puts>
                    OSMutexPost(xTxUARTMutex);
8110fe54:	d0a07317 	ldw	r2,-32308(gp)
8110fe58:	1009883a 	mov	r4,r2
8110fe5c:	1135b100 	call	81135b10 <OSMutexPost>
8110fe60:	00000106 	br	8110fe68 <vOutAckHandlerTask+0x2a4>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
8110fe64:	11168500 	call	81116850 <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
8110fe68:	00800044 	movi	r2,1
8110fe6c:	e0bff915 	stw	r2,-28(fp)
                
				break;
8110fe70:	00000306 	br	8110fe80 <vOutAckHandlerTask+0x2bc>
			default:
            	#if DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
	            #endif
                eSenderAckState = sSAGettingACK;
8110fe74:	00800044 	movi	r2,1
8110fe78:	e0bff915 	stw	r2,-28(fp)
				break;
8110fe7c:	0001883a 	nop
		}
	}
8110fe80:	003f6906 	br	8110fc28 <__reset+0xfb0efc28>

8110fe84 <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
8110fe84:	defffa04 	addi	sp,sp,-24
8110fe88:	de00012e 	bgeu	sp,et,8110fe90 <vParserCommTask+0xc>
8110fe8c:	003b68fa 	trap	3
8110fe90:	dfc00515 	stw	ra,20(sp)
8110fe94:	df000415 	stw	fp,16(sp)
8110fe98:	df000404 	addi	fp,sp,16
8110fe9c:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
8110fea0:	e03ffd15 	stw	zero,-12(fp)

    #if DEBUG_ON
        debug(fp,"Parser Comm Task. (Task on)\n");
    #endif

	eParserMode = sConfiguring;
8110fea4:	e03ffc15 	stw	zero,-16(fp)

	for(;;){

		switch (eParserMode) {
8110fea8:	e0bffc17 	ldw	r2,-16(fp)
8110feac:	10800168 	cmpgeui	r2,r2,5
8110feb0:	1001b21e 	bne	r2,zero,8111057c <vParserCommTask+0x6f8>
8110feb4:	e0bffc17 	ldw	r2,-16(fp)
8110feb8:	100690ba 	slli	r3,r2,2
8110febc:	00a04474 	movhi	r2,33041
8110fec0:	10bfb404 	addi	r2,r2,-304
8110fec4:	1885883a 	add	r2,r3,r2
8110fec8:	10800017 	ldw	r2,0(r2)
8110fecc:	1000683a 	jmp	r2
8110fed0:	8110fee4 	muli	r4,r16,17403
8110fed4:	8110fef0 	cmpltui	r4,r16,17403
8110fed8:	8110ff84 	addi	r4,r16,17406
8110fedc:	81110048 	cmpgei	r4,r16,17409
8110fee0:	8111008c 	andi	r4,r16,17410
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
8110fee4:	00800044 	movi	r2,1
8110fee8:	e0bffc15 	stw	r2,-16(fp)
				break;
8110feec:	0001a606 	br	81110588 <vParserCommTask+0x704>
			case sWaitingMessage:

				bSuccess = FALSE;
8110fef0:	e03ffd15 	stw	zero,-12(fp)
				eParserMode = sWaitingMessage;
8110fef4:	00800044 	movi	r2,1
8110fef8:	e0bffc15 	stw	r2,-16(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
8110fefc:	d0a06317 	ldw	r2,-32372(gp)
8110ff00:	e0fffe84 	addi	r3,fp,-6
8110ff04:	180d883a 	mov	r6,r3
8110ff08:	000b883a 	mov	r5,zero
8110ff0c:	1009883a 	mov	r4,r2
8110ff10:	11375780 	call	81137578 <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
8110ff14:	e0bffe83 	ldbu	r2,-6(fp)
8110ff18:	10803fcc 	andi	r2,r2,255
8110ff1c:	1000171e 	bne	r2,zero,8110ff7c <vParserCommTask+0xf8>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
8110ff20:	01204534 	movhi	r4,33044
8110ff24:	211ec104 	addi	r4,r4,31492
8110ff28:	111058c0 	call	8111058c <getPreParsedPacket>
8110ff2c:	e0bffd15 	stw	r2,-12(fp)
					if (bSuccess == TRUE) {
8110ff30:	e0bffd17 	ldw	r2,-12(fp)
8110ff34:	10800058 	cmpnei	r2,r2,1
8110ff38:	10000e1e 	bne	r2,zero,8110ff74 <vParserCommTask+0xf0>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
8110ff3c:	00a04534 	movhi	r2,33044
8110ff40:	109ec104 	addi	r2,r2,31492
8110ff44:	10800103 	ldbu	r2,4(r2)
8110ff48:	10803fcc 	andi	r2,r2,255
8110ff4c:	1080201c 	xori	r2,r2,128
8110ff50:	10bfe004 	addi	r2,r2,-128
8110ff54:	10800858 	cmpnei	r2,r2,33
8110ff58:	1000031e 	bne	r2,zero,8110ff68 <vParserCommTask+0xe4>
							eParserMode = sReplyParsing;
8110ff5c:	008000c4 	movi	r2,3
8110ff60:	e0bffc15 	stw	r2,-16(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110ff64:	00018806 	br	81110588 <vParserCommTask+0x704>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
8110ff68:	00800084 	movi	r2,2
8110ff6c:	e0bffc15 	stw	r2,-16(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110ff70:	00018506 	br	81110588 <vParserCommTask+0x704>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
8110ff74:	1116aa80 	call	81116aa8 <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
8110ff78:	00018306 	br	81110588 <vParserCommTask+0x704>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
8110ff7c:	1116a580 	call	81116a58 <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
8110ff80:	00018106 	br	81110588 <vParserCommTask+0x704>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
8110ff84:	00a04534 	movhi	r2,33044
8110ff88:	109ec104 	addi	r2,r2,31492
8110ff8c:	10800143 	ldbu	r2,5(r2)
8110ff90:	10803fcc 	andi	r2,r2,255
8110ff94:	1080201c 	xori	r2,r2,128
8110ff98:	10bfe004 	addi	r2,r2,-128
8110ff9c:	10c010e0 	cmpeqi	r3,r2,67
8110ffa0:	1800031e 	bne	r3,zero,8110ffb0 <vParserCommTask+0x12c>
8110ffa4:	10801420 	cmpeqi	r2,r2,80
8110ffa8:	1000051e 	bne	r2,zero,8110ffc0 <vParserCommTask+0x13c>
8110ffac:	00002206 	br	81110038 <vParserCommTask+0x1b4>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
8110ffb0:	11141980 	call	81114198 <vSendEthConf>
						eParserMode = sWaitingMessage;
8110ffb4:	00800044 	movi	r2,1
8110ffb8:	e0bffc15 	stw	r2,-16(fp)
						break;
8110ffbc:	00002106 	br	81110044 <vParserCommTask+0x1c0>
							memset(cPUSDebug,0,128);
							sprintf(cPUSDebug, "\nParser Task: TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
							debug(fp, cPUSDebug );
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
8110ffc0:	00a04534 	movhi	r2,33044
8110ffc4:	109ec104 	addi	r2,r2,31492
8110ffc8:	10c0030b 	ldhu	r3,12(r2)
8110ffcc:	00a04534 	movhi	r2,33044
8110ffd0:	109ed404 	addi	r2,r2,31568
8110ffd4:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
8110ffd8:	00a04534 	movhi	r2,33044
8110ffdc:	109ec104 	addi	r2,r2,31492
8110ffe0:	10c0038b 	ldhu	r3,14(r2)
8110ffe4:	00a04534 	movhi	r2,33044
8110ffe8:	109ed404 	addi	r2,r2,31568
8110ffec:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
8110fff0:	00a04534 	movhi	r2,33044
8110fff4:	109ec104 	addi	r2,r2,31492
8110fff8:	10c0040b 	ldhu	r3,16(r2)
8110fffc:	00a04534 	movhi	r2,33044
81110000:	109ed404 	addi	r2,r2,31568
81110004:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
81110008:	00a04534 	movhi	r2,33044
8111000c:	109ec104 	addi	r2,r2,31492
81110010:	10c0048b 	ldhu	r3,18(r2)
81110014:	00a04534 	movhi	r2,33044
81110018:	109ed404 	addi	r2,r2,31568
8111001c:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
81110020:	00a04534 	movhi	r2,33044
81110024:	109ed404 	addi	r2,r2,31568
81110028:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
8111002c:	00800104 	movi	r2,4
81110030:	e0bffc15 	stw	r2,-16(fp)
                        break;						
81110034:	00000306 	br	81110044 <vParserCommTask+0x1c0>
					default:
						eParserMode = sWaitingMessage;
81110038:	00800044 	movi	r2,1
8111003c:	e0bffc15 	stw	r2,-16(fp)
						break;
81110040:	0001883a 	nop
				}
				break;
81110044:	00015006 	br	81110588 <vParserCommTask+0x704>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
81110048:	00800044 	movi	r2,1
8111004c:	e0bffc15 	stw	r2,-16(fp)
                switch ( xTcPusL.usiType )
81110050:	00a04534 	movhi	r2,33044
81110054:	109ed404 	addi	r2,r2,31568
81110058:	1080030b 	ldhu	r2,12(r2)
8111005c:	10bfffcc 	andi	r2,r2,65535
81110060:	10c01220 	cmpeqi	r3,r2,72
81110064:	1800051e 	bne	r3,zero,8111007c <vParserCommTask+0x1f8>
81110068:	108014e0 	cmpeqi	r2,r2,83
8111006c:	1000051e 	bne	r2,zero,81110084 <vParserCommTask+0x200>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
81110070:	00800044 	movi	r2,1
81110074:	e0bffc15 	stw	r2,-16(fp)
                        break;
81110078:	00000306 	br	81110088 <vParserCommTask+0x204>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
8111007c:	0001883a 	nop
81110080:	00014106 	br	81110588 <vParserCommTask+0x704>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
81110084:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
81110088:	00013f06 	br	81110588 <vParserCommTask+0x704>
			case sPusHandling:
				eParserMode = sWaitingMessage;
8111008c:	00800044 	movi	r2,1
81110090:	e0bffc15 	stw	r2,-16(fp)
				
                switch ( xTcPusL.usiType )
81110094:	00a04534 	movhi	r2,33044
81110098:	109ed404 	addi	r2,r2,31568
8111009c:	1080030b 	ldhu	r2,12(r2)
811100a0:	10bfffcc 	andi	r2,r2,65535
811100a4:	10c03ea0 	cmpeqi	r3,r2,250
811100a8:	18001b1e 	bne	r3,zero,81110118 <vParserCommTask+0x294>
811100ac:	10c03ec8 	cmpgei	r3,r2,251
811100b0:	1800031e 	bne	r3,zero,811100c0 <vParserCommTask+0x23c>
811100b4:	10800460 	cmpeqi	r2,r2,17
811100b8:	1000061e 	bne	r2,zero,811100d4 <vParserCommTask+0x250>
811100bc:	00012a06 	br	81110568 <vParserCommTask+0x6e4>
811100c0:	10c03ee0 	cmpeqi	r3,r2,251
811100c4:	18003e1e 	bne	r3,zero,811101c0 <vParserCommTask+0x33c>
811100c8:	10803f20 	cmpeqi	r2,r2,252
811100cc:	1000701e 	bne	r2,zero,81110290 <vParserCommTask+0x40c>
811100d0:	00012506 	br	81110568 <vParserCommTask+0x6e4>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
811100d4:	00a04534 	movhi	r2,33044
811100d8:	109ed404 	addi	r2,r2,31568
811100dc:	1080038b 	ldhu	r2,14(r2)
811100e0:	10bfffcc 	andi	r2,r2,65535
811100e4:	10800060 	cmpeqi	r2,r2,1
811100e8:	10000726 	beq	r2,zero,81110108 <vParserCommTask+0x284>
								#if DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TEST_CONNECTION\n");
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
811100ec:	00a04534 	movhi	r2,33044
811100f0:	109ed404 	addi	r2,r2,31568
811100f4:	1080040b 	ldhu	r2,16(r2)
811100f8:	10bfffcc 	andi	r2,r2,65535
811100fc:	1009883a 	mov	r4,r2
81110100:	1114b980 	call	81114b98 <vTMPusTestConnection>

								break;
81110104:	00000306 	br	81110114 <vParserCommTask+0x290>
								#if DEBUG_ON
									memset(cPUSDebug,0,128);
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
									debug(fp, cPUSDebug );
								#endif
								eParserMode = sWaitingMessage;
81110108:	00800044 	movi	r2,1
8111010c:	e0bffc15 	stw	r2,-16(fp)
								break;
81110110:	0001883a 	nop
						}
                        break;
81110114:	00011806 	br	81110578 <vParserCommTask+0x6f4>


                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
81110118:	00a04534 	movhi	r2,33044
8111011c:	109ed404 	addi	r2,r2,31568
81110120:	1080038b 	ldhu	r2,14(r2)
81110124:	10bfffcc 	andi	r2,r2,65535
81110128:	10c00f20 	cmpeqi	r3,r2,60
8111012c:	1800131e 	bne	r3,zero,8111017c <vParserCommTask+0x2f8>
81110130:	10c00f48 	cmpgei	r3,r2,61
81110134:	1800031e 	bne	r3,zero,81110144 <vParserCommTask+0x2c0>
81110138:	10800ee0 	cmpeqi	r2,r2,59
8111013c:	1000061e 	bne	r2,zero,81110158 <vParserCommTask+0x2d4>
81110140:	00001b06 	br	811101b0 <vParserCommTask+0x32c>
81110144:	10c00f60 	cmpeqi	r3,r2,61
81110148:	1800101e 	bne	r3,zero,8111018c <vParserCommTask+0x308>
8111014c:	10800fa0 	cmpeqi	r2,r2,62
81110150:	1000121e 	bne	r2,zero,8111019c <vParserCommTask+0x318>
81110154:	00001606 	br	811101b0 <vParserCommTask+0x32c>
						{
							case 59: /* TC_SCAM_RESET */
								#if DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RESET\n");
								#endif
								vSendReset();
81110158:	11145400 	call	81114540 <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,3,0);
8111015c:	000f883a 	mov	r7,zero
81110160:	018000c4 	movi	r6,3
81110164:	000b883a 	mov	r5,zero
81110168:	0009883a 	mov	r4,zero
8111016c:	11395100 	call	81139510 <OSTimeDlyHMSM>
								vRstcSimucamReset( 5000 );
81110170:	0104e204 	movi	r4,5000
81110174:	110a55c0 	call	8110a55c <vRstcSimucamReset>

								break;
81110178:	00001006 	br	811101bc <vParserCommTask+0x338>
							case 60: /* TC_SCAM_CONFIG */
								#if DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_CONFIG\n");
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8111017c:	01204534 	movhi	r4,33044
81110180:	211ed404 	addi	r4,r4,31568
81110184:	11106a40 	call	811106a4 <bSendMessagePUStoMebTask>

								break;
81110188:	00000c06 	br	811101bc <vParserCommTask+0x338>
							case 61: /* TC_SCAM_RUN */
								#if DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RUN\n");
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8111018c:	01204534 	movhi	r4,33044
81110190:	211ed404 	addi	r4,r4,31568
81110194:	11106a40 	call	811106a4 <bSendMessagePUStoMebTask>

								break;
81110198:	00000806 	br	811101bc <vParserCommTask+0x338>
							case 62: /* TC_SCAM_TURNOFF */
								#if DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TURNOFF\n");
								#endif
								vSendTurnOff();
8111019c:	11144280 	call	81114428 <vSendTurnOff>

								/* Send to Meb the shutdown command */
								bSendMessagePUStoMebTask(&xTcPusL);
811101a0:	01204534 	movhi	r4,33044
811101a4:	211ed404 	addi	r4,r4,31568
811101a8:	11106a40 	call	811106a4 <bSendMessagePUStoMebTask>

								break;
811101ac:	00000306 	br	811101bc <vParserCommTask+0x338>
								#if DEBUG_ON
									memset(cPUSDebug,0,128);
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
									debug(fp, cPUSDebug );
								#endif							
								eParserMode = sWaitingMessage;
811101b0:	00800044 	movi	r2,1
811101b4:	e0bffc15 	stw	r2,-16(fp)
								break;
811101b8:	0001883a 	nop
						}
                        break;
811101bc:	0000ee06 	br	81110578 <vParserCommTask+0x6f4>


                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
811101c0:	00a04534 	movhi	r2,33044
811101c4:	109ec104 	addi	r2,r2,31492
811101c8:	1080050b 	ldhu	r2,20(r2)
811101cc:	e0bffe0d 	sth	r2,-8(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
811101d0:	e0bffe0b 	ldhu	r2,-8(fp)
811101d4:	108000a8 	cmpgeui	r2,r2,2
811101d8:	1000e61e 	bne	r2,zero,81110574 <vParserCommTask+0x6f0>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
								debug(fp, cPUSDebug );
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
811101dc:	00a04534 	movhi	r2,33044
811101e0:	109ed404 	addi	r2,r2,31568
811101e4:	10800483 	ldbu	r2,18(r2)
811101e8:	10c03fcc 	andi	r3,r2,255
811101ec:	00a04534 	movhi	r2,33044
811101f0:	109ed404 	addi	r2,r2,31568
811101f4:	18c00284 	addi	r3,r3,10
811101f8:	18c7883a 	add	r3,r3,r3
811101fc:	10c5883a 	add	r2,r2,r3
81110200:	e0fffe0b 	ldhu	r3,-8(fp)
81110204:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
81110208:	00a04534 	movhi	r2,33044
8111020c:	109ed404 	addi	r2,r2,31568
81110210:	10800483 	ldbu	r2,18(r2)
81110214:	10800044 	addi	r2,r2,1
81110218:	1007883a 	mov	r3,r2
8111021c:	00a04534 	movhi	r2,33044
81110220:	109ed404 	addi	r2,r2,31568
81110224:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
81110228:	00a04534 	movhi	r2,33044
8111022c:	109ed404 	addi	r2,r2,31568
81110230:	1080038b 	ldhu	r2,14(r2)
81110234:	10bfffcc 	andi	r2,r2,65535
81110238:	10c000a0 	cmpeqi	r3,r2,2
8111023c:	1800081e 	bne	r3,zero,81110260 <vParserCommTask+0x3dc>
81110240:	10c00160 	cmpeqi	r3,r2,5
81110244:	18000a1e 	bne	r3,zero,81110270 <vParserCommTask+0x3ec>
81110248:	10800060 	cmpeqi	r2,r2,1
8111024c:	10000c26 	beq	r2,zero,81110280 <vParserCommTask+0x3fc>
									#if DEBUG_ON
										memset(cPUSDebug,0,128);
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CONFIG_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
										debug(fp, cPUSDebug );
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
81110250:	01204534 	movhi	r4,33044
81110254:	211ed404 	addi	r4,r4,31568
81110258:	11106a40 	call	811106a4 <bSendMessagePUStoMebTask>

									break;
8111025c:	00000b06 	br	8111028c <vParserCommTask+0x408>
									#if DEBUG_ON
										memset(cPUSDebug,0,128);
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_STANDBY_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
										debug(fp, cPUSDebug );
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
81110260:	01204534 	movhi	r4,33044
81110264:	211ed404 	addi	r4,r4,31568
81110268:	11106a40 	call	811106a4 <bSendMessagePUStoMebTask>

									break;
8111026c:	00000706 	br	8111028c <vParserCommTask+0x408>
									#if DEBUG_ON
										memset(cPUSDebug,0,128);
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CALIBRATION_TEST_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
										debug(fp, cPUSDebug );
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
81110270:	01204534 	movhi	r4,33044
81110274:	211ed404 	addi	r4,r4,31568
81110278:	11106a40 	call	811106a4 <bSendMessagePUStoMebTask>

									break;
8111027c:	00000306 	br	8111028c <vParserCommTask+0x408>
									#if DEBUG_ON
										memset(cPUSDebug,0,128);
										sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
										debug(fp, cPUSDebug );
									#endif							
									eParserMode = sWaitingMessage;
81110280:	00800044 	movi	r2,1
81110284:	e0bffc15 	stw	r2,-16(fp)
									break;
81110288:	0001883a 	nop
							}
						}
                        break;
8111028c:	0000b906 	br	81110574 <vParserCommTask+0x6f0>


					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81110290:	00a04534 	movhi	r2,33044
81110294:	109ec104 	addi	r2,r2,31492
81110298:	1080050b 	ldhu	r2,20(r2)
8111029c:	e0bffe0d 	sth	r2,-8(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
811102a0:	00a04534 	movhi	r2,33044
811102a4:	109ed404 	addi	r2,r2,31568
811102a8:	10800483 	ldbu	r2,18(r2)
811102ac:	10c03fcc 	andi	r3,r2,255
811102b0:	00a04534 	movhi	r2,33044
811102b4:	109ed404 	addi	r2,r2,31568
811102b8:	18c00284 	addi	r3,r3,10
811102bc:	18c7883a 	add	r3,r3,r3
811102c0:	10c5883a 	add	r2,r2,r3
811102c4:	e0fffe0b 	ldhu	r3,-8(fp)
811102c8:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
811102cc:	00a04534 	movhi	r2,33044
811102d0:	109ed404 	addi	r2,r2,31568
811102d4:	10800483 	ldbu	r2,18(r2)
811102d8:	10800044 	addi	r2,r2,1
811102dc:	1007883a 	mov	r3,r2
811102e0:	00a04534 	movhi	r2,33044
811102e4:	109ed404 	addi	r2,r2,31568
811102e8:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
811102ec:	00a04534 	movhi	r2,33044
811102f0:	109ed404 	addi	r2,r2,31568
811102f4:	1080038b 	ldhu	r2,14(r2)
811102f8:	10bfffcc 	andi	r2,r2,65535
811102fc:	10c000e0 	cmpeqi	r3,r2,3
81110300:	18000a1e 	bne	r3,zero,8111032c <vParserCommTask+0x4a8>
81110304:	10c00108 	cmpgei	r3,r2,4
81110308:	1800031e 	bne	r3,zero,81110318 <vParserCommTask+0x494>
8111030c:	108000a0 	cmpeqi	r2,r2,2
81110310:	1000121e 	bne	r2,zero,8111035c <vParserCommTask+0x4d8>
81110314:	00009006 	br	81110558 <vParserCommTask+0x6d4>
81110318:	10c00120 	cmpeqi	r3,r2,4
8111031c:	1800071e 	bne	r3,zero,8111033c <vParserCommTask+0x4b8>
81110320:	10800160 	cmpeqi	r2,r2,5
81110324:	1000091e 	bne	r2,zero,8111034c <vParserCommTask+0x4c8>
81110328:	00008b06 	br	81110558 <vParserCommTask+0x6d4>
								#if DEBUG_ON
									memset(cPUSDebug,0,128);
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_ENABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
									debug(fp, cPUSDebug );
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8111032c:	01204534 	movhi	r4,33044
81110330:	211ed404 	addi	r4,r4,31568
81110334:	11106a40 	call	811106a4 <bSendMessagePUStoMebTask>

								break;
81110338:	00008a06 	br	81110564 <vParserCommTask+0x6e0>
								#if DEBUG_ON
									memset(cPUSDebug,0,128);
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_DISABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
									debug(fp, cPUSDebug );
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8111033c:	01204534 	movhi	r4,33044
81110340:	211ed404 	addi	r4,r4,31568
81110344:	11106a40 	call	811106a4 <bSendMessagePUStoMebTask>

								break;
81110348:	00008606 	br	81110564 <vParserCommTask+0x6e0>
								#if DEBUG_ON
									memset(cPUSDebug,0,128);
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_RESET (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
									debug(fp, cPUSDebug );
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8111034c:	01204534 	movhi	r4,33044
81110350:	211ed404 	addi	r4,r4,31568
81110354:	11106a40 	call	811106a4 <bSendMessagePUStoMebTask>

								break;
81110358:	00008206 	br	81110564 <vParserCommTask+0x6e0>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
8111035c:	00a04534 	movhi	r2,33044
81110360:	109ed404 	addi	r2,r2,31568
81110364:	10800483 	ldbu	r2,18(r2)
81110368:	10c03fcc 	andi	r3,r2,255
8111036c:	00a04534 	movhi	r2,33044
81110370:	109ec104 	addi	r2,r2,31492
81110374:	1100058b 	ldhu	r4,22(r2)
81110378:	00a04534 	movhi	r2,33044
8111037c:	109ed404 	addi	r2,r2,31568
81110380:	18c00284 	addi	r3,r3,10
81110384:	18c7883a 	add	r3,r3,r3
81110388:	10c5883a 	add	r2,r2,r3
8111038c:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81110390:	00a04534 	movhi	r2,33044
81110394:	109ed404 	addi	r2,r2,31568
81110398:	10800483 	ldbu	r2,18(r2)
8111039c:	10800044 	addi	r2,r2,1
811103a0:	1007883a 	mov	r3,r2
811103a4:	00a04534 	movhi	r2,33044
811103a8:	109ed404 	addi	r2,r2,31568
811103ac:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
811103b0:	00a04534 	movhi	r2,33044
811103b4:	109ed404 	addi	r2,r2,31568
811103b8:	10800483 	ldbu	r2,18(r2)
811103bc:	10c03fcc 	andi	r3,r2,255
811103c0:	00a04534 	movhi	r2,33044
811103c4:	109ec104 	addi	r2,r2,31492
811103c8:	1100060b 	ldhu	r4,24(r2)
811103cc:	00a04534 	movhi	r2,33044
811103d0:	109ed404 	addi	r2,r2,31568
811103d4:	18c00284 	addi	r3,r3,10
811103d8:	18c7883a 	add	r3,r3,r3
811103dc:	10c5883a 	add	r2,r2,r3
811103e0:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811103e4:	00a04534 	movhi	r2,33044
811103e8:	109ed404 	addi	r2,r2,31568
811103ec:	10800483 	ldbu	r2,18(r2)
811103f0:	10800044 	addi	r2,r2,1
811103f4:	1007883a 	mov	r3,r2
811103f8:	00a04534 	movhi	r2,33044
811103fc:	109ed404 	addi	r2,r2,31568
81110400:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
81110404:	00a04534 	movhi	r2,33044
81110408:	109ed404 	addi	r2,r2,31568
8111040c:	10800483 	ldbu	r2,18(r2)
81110410:	10c03fcc 	andi	r3,r2,255
81110414:	00a04534 	movhi	r2,33044
81110418:	109ec104 	addi	r2,r2,31492
8111041c:	1100068b 	ldhu	r4,26(r2)
81110420:	00a04534 	movhi	r2,33044
81110424:	109ed404 	addi	r2,r2,31568
81110428:	18c00284 	addi	r3,r3,10
8111042c:	18c7883a 	add	r3,r3,r3
81110430:	10c5883a 	add	r2,r2,r3
81110434:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81110438:	00a04534 	movhi	r2,33044
8111043c:	109ed404 	addi	r2,r2,31568
81110440:	10800483 	ldbu	r2,18(r2)
81110444:	10800044 	addi	r2,r2,1
81110448:	1007883a 	mov	r3,r2
8111044c:	00a04534 	movhi	r2,33044
81110450:	109ed404 	addi	r2,r2,31568
81110454:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
81110458:	00a04534 	movhi	r2,33044
8111045c:	109ed404 	addi	r2,r2,31568
81110460:	10800483 	ldbu	r2,18(r2)
81110464:	10c03fcc 	andi	r3,r2,255
81110468:	00a04534 	movhi	r2,33044
8111046c:	109ec104 	addi	r2,r2,31492
81110470:	1100070b 	ldhu	r4,28(r2)
81110474:	00a04534 	movhi	r2,33044
81110478:	109ed404 	addi	r2,r2,31568
8111047c:	18c00284 	addi	r3,r3,10
81110480:	18c7883a 	add	r3,r3,r3
81110484:	10c5883a 	add	r2,r2,r3
81110488:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8111048c:	00a04534 	movhi	r2,33044
81110490:	109ed404 	addi	r2,r2,31568
81110494:	10800483 	ldbu	r2,18(r2)
81110498:	10800044 	addi	r2,r2,1
8111049c:	1007883a 	mov	r3,r2
811104a0:	00a04534 	movhi	r2,33044
811104a4:	109ed404 	addi	r2,r2,31568
811104a8:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
811104ac:	00a04534 	movhi	r2,33044
811104b0:	109ed404 	addi	r2,r2,31568
811104b4:	10800483 	ldbu	r2,18(r2)
811104b8:	10c03fcc 	andi	r3,r2,255
811104bc:	00a04534 	movhi	r2,33044
811104c0:	109ec104 	addi	r2,r2,31492
811104c4:	1100078b 	ldhu	r4,30(r2)
811104c8:	00a04534 	movhi	r2,33044
811104cc:	109ed404 	addi	r2,r2,31568
811104d0:	18c00284 	addi	r3,r3,10
811104d4:	18c7883a 	add	r3,r3,r3
811104d8:	10c5883a 	add	r2,r2,r3
811104dc:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811104e0:	00a04534 	movhi	r2,33044
811104e4:	109ed404 	addi	r2,r2,31568
811104e8:	10800483 	ldbu	r2,18(r2)
811104ec:	10800044 	addi	r2,r2,1
811104f0:	1007883a 	mov	r3,r2
811104f4:	00a04534 	movhi	r2,33044
811104f8:	109ed404 	addi	r2,r2,31568
811104fc:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
81110500:	00a04534 	movhi	r2,33044
81110504:	109ed404 	addi	r2,r2,31568
81110508:	10800483 	ldbu	r2,18(r2)
8111050c:	10c03fcc 	andi	r3,r2,255
81110510:	00a04534 	movhi	r2,33044
81110514:	109ec104 	addi	r2,r2,31492
81110518:	1100080b 	ldhu	r4,32(r2)
8111051c:	00a04534 	movhi	r2,33044
81110520:	109ed404 	addi	r2,r2,31568
81110524:	18c00284 	addi	r3,r3,10
81110528:	18c7883a 	add	r3,r3,r3
8111052c:	10c5883a 	add	r2,r2,r3
81110530:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81110534:	00a04534 	movhi	r2,33044
81110538:	109ed404 	addi	r2,r2,31568
8111053c:	10800483 	ldbu	r2,18(r2)
81110540:	10800044 	addi	r2,r2,1
81110544:	1007883a 	mov	r3,r2
81110548:	00a04534 	movhi	r2,33044
8111054c:	109ed404 	addi	r2,r2,31568
81110550:	10c00485 	stb	r3,18(r2)
									debug(fp, cPUSDebug );
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
									debug(fp, cPUSDebug );
								#endif

								break;
81110554:	00000306 	br	81110564 <vParserCommTask+0x6e0>
								#if DEBUG_ON
									memset(cPUSDebug,0,128);
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
									debug(fp, cPUSDebug );
								#endif							
								eParserMode = sWaitingMessage;
81110558:	00800044 	movi	r2,1
8111055c:	e0bffc15 	stw	r2,-16(fp)
								break;
81110560:	0001883a 	nop
						}
                        break;
81110564:	00000406 	br	81110578 <vParserCommTask+0x6f4>
                    default:
						eParserMode = sWaitingMessage;
81110568:	00800044 	movi	r2,1
8111056c:	e0bffc15 	stw	r2,-16(fp)
                        break;
81110570:	00000106 	br	81110578 <vParserCommTask+0x6f4>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
81110574:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;				
81110578:	00000306 	br	81110588 <vParserCommTask+0x704>
			default:
				eParserMode = sWaitingMessage;
8111057c:	00800044 	movi	r2,1
81110580:	e0bffc15 	stw	r2,-16(fp)
				break;
81110584:	0001883a 	nop
		}
	}
81110588:	003e4706 	br	8110fea8 <__reset+0xfb0efea8>

8111058c <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
8111058c:	defffb04 	addi	sp,sp,-20
81110590:	de00012e 	bgeu	sp,et,81110598 <getPreParsedPacket+0xc>
81110594:	003b68fa 	trap	3
81110598:	dfc00415 	stw	ra,16(sp)
8111059c:	df000315 	stw	fp,12(sp)
811105a0:	df000304 	addi	fp,sp,12
811105a4:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811105a8:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
811105ac:	d0a06a17 	ldw	r2,-32344(gp)
811105b0:	e0fffe44 	addi	r3,fp,-7
811105b4:	180d883a 	mov	r6,r3
811105b8:	000b883a 	mov	r5,zero
811105bc:	1009883a 	mov	r4,r2
811105c0:	113556c0 	call	8113556c <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
811105c4:	e0bffe43 	ldbu	r2,-7(fp)
811105c8:	10803fcc 	andi	r2,r2,255
811105cc:	10002e1e 	bne	r2,zero,81110688 <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
811105d0:	e03ffe05 	stb	zero,-8(fp)
811105d4:	00002506 	br	8111066c <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
811105d8:	e0fffe03 	ldbu	r3,-8(fp)
811105dc:	00a045b4 	movhi	r2,33046
811105e0:	10ac1704 	addi	r2,r2,-20388
811105e4:	18c01324 	muli	r3,r3,76
811105e8:	10c5883a 	add	r2,r2,r3
811105ec:	10800104 	addi	r2,r2,4
811105f0:	10800003 	ldbu	r2,0(r2)
811105f4:	10803fcc 	andi	r2,r2,255
811105f8:	1080201c 	xori	r2,r2,128
811105fc:	10bfe004 	addi	r2,r2,-128
81110600:	10001726 	beq	r2,zero,81110660 <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
81110604:	e0fffe03 	ldbu	r3,-8(fp)
81110608:	e13fff17 	ldw	r4,-4(fp)
8111060c:	00a045b4 	movhi	r2,33046
81110610:	10ac1704 	addi	r2,r2,-20388
81110614:	18c01324 	muli	r3,r3,76
81110618:	10c5883a 	add	r2,r2,r3
8111061c:	2007883a 	mov	r3,r4
81110620:	1009883a 	mov	r4,r2
81110624:	00801304 	movi	r2,76
81110628:	100d883a 	mov	r6,r2
8111062c:	200b883a 	mov	r5,r4
81110630:	1809883a 	mov	r4,r3
81110634:	111abac0 	call	8111abac <memcpy>
                bSuccess = TRUE;
81110638:	00800044 	movi	r2,1
8111063c:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
81110640:	e0fffe03 	ldbu	r3,-8(fp)
81110644:	00a045b4 	movhi	r2,33046
81110648:	10ac1704 	addi	r2,r2,-20388
8111064c:	18c01324 	muli	r3,r3,76
81110650:	10c5883a 	add	r2,r2,r3
81110654:	10800104 	addi	r2,r2,4
81110658:	10000005 	stb	zero,0(r2)
                break;
8111065c:	00000606 	br	81110678 <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
81110660:	e0bffe03 	ldbu	r2,-8(fp)
81110664:	10800044 	addi	r2,r2,1
81110668:	e0bffe05 	stb	r2,-8(fp)
8111066c:	e0bffe03 	ldbu	r2,-8(fp)
81110670:	10800230 	cmpltui	r2,r2,8
81110674:	103fd81e 	bne	r2,zero,811105d8 <__reset+0xfb0f05d8>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
81110678:	d0a06a17 	ldw	r2,-32344(gp)
8111067c:	1009883a 	mov	r4,r2
81110680:	1135b100 	call	81135b10 <OSMutexPost>
81110684:	00000106 	br	8111068c <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
81110688:	1116a800 	call	81116a80 <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
8111068c:	e0bffd17 	ldw	r2,-12(fp)
}
81110690:	e037883a 	mov	sp,fp
81110694:	dfc00117 	ldw	ra,4(sp)
81110698:	df000017 	ldw	fp,0(sp)
8111069c:	dec00204 	addi	sp,sp,8
811106a0:	f800283a 	ret

811106a4 <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
811106a4:	defffa04 	addi	sp,sp,-24
811106a8:	de00012e 	bgeu	sp,et,811106b0 <bSendMessagePUStoMebTask+0xc>
811106ac:	003b68fa 	trap	3
811106b0:	dfc00515 	stw	ra,20(sp)
811106b4:	df000415 	stw	fp,16(sp)
811106b8:	df000404 	addi	fp,sp,16
811106bc:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811106c0:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
811106c4:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
811106c8:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
811106cc:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
811106d0:	d0a07217 	ldw	r2,-32312(gp)
811106d4:	e0fffd44 	addi	r3,fp,-11
811106d8:	180d883a 	mov	r6,r3
811106dc:	01400284 	movi	r5,10
811106e0:	1009883a 	mov	r4,r2
811106e4:	113556c0 	call	8113556c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811106e8:	e0bffd43 	ldbu	r2,-11(fp)
811106ec:	10803fcc 	andi	r2,r2,255
811106f0:	1000401e 	bne	r2,zero,811107f4 <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
811106f4:	e03ffd05 	stb	zero,-12(fp)
811106f8:	00003806 	br	811107dc <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
811106fc:	e0fffd03 	ldbu	r3,-12(fp)
81110700:	00a04574 	movhi	r2,33045
81110704:	10a93904 	addi	r2,r2,-23324
81110708:	18c01524 	muli	r3,r3,84
8111070c:	10c5883a 	add	r2,r2,r3
81110710:	10800104 	addi	r2,r2,4
81110714:	10800017 	ldw	r2,0(r2)
81110718:	10002d1e 	bne	r2,zero,811107d0 <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
8111071c:	e0fffd03 	ldbu	r3,-12(fp)
81110720:	00a04574 	movhi	r2,33045
81110724:	10a93904 	addi	r2,r2,-23324
81110728:	18c01524 	muli	r3,r3,84
8111072c:	10c7883a 	add	r3,r2,r3
81110730:	e0bfff17 	ldw	r2,-4(fp)
81110734:	1009883a 	mov	r4,r2
81110738:	00801504 	movi	r2,84
8111073c:	100d883a 	mov	r6,r2
81110740:	200b883a 	mov	r5,r4
81110744:	1809883a 	mov	r4,r3
81110748:	111abac0 	call	8111abac <memcpy>
            	xPus[i].bInUse = TRUE;
8111074c:	e0fffd03 	ldbu	r3,-12(fp)
81110750:	00a04574 	movhi	r2,33045
81110754:	10a93904 	addi	r2,r2,-23324
81110758:	18c01524 	muli	r3,r3,84
8111075c:	10c5883a 	add	r2,r2,r3
81110760:	10800104 	addi	r2,r2,4
81110764:	00c00044 	movi	r3,1
81110768:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
8111076c:	00800044 	movi	r2,1
81110770:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
81110774:	00800044 	movi	r2,1
81110778:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
8111077c:	d0a06817 	ldw	r2,-32352(gp)
81110780:	e0fffe17 	ldw	r3,-8(fp)
81110784:	180b883a 	mov	r5,r3
81110788:	1009883a 	mov	r4,r2
8111078c:	1136a880 	call	81136a88 <OSQPost>
81110790:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
81110794:	e0bffd43 	ldbu	r2,-11(fp)
81110798:	10803fcc 	andi	r2,r2,255
8111079c:	10000926 	beq	r2,zero,811107c4 <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
811107a0:	111708c0 	call	8111708c <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
811107a4:	e0fffd03 	ldbu	r3,-12(fp)
811107a8:	00a04574 	movhi	r2,33045
811107ac:	10a93904 	addi	r2,r2,-23324
811107b0:	18c01524 	muli	r3,r3,84
811107b4:	10c5883a 	add	r2,r2,r3
811107b8:	10800104 	addi	r2,r2,4
811107bc:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
811107c0:	00000906 	br	811107e8 <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
811107c4:	00800044 	movi	r2,1
811107c8:	e0bffc15 	stw	r2,-16(fp)
                break;
811107cc:	00000606 	br	811107e8 <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
811107d0:	e0bffd03 	ldbu	r2,-12(fp)
811107d4:	10800044 	addi	r2,r2,1
811107d8:	e0bffd05 	stb	r2,-12(fp)
811107dc:	e0bffd03 	ldbu	r2,-12(fp)
811107e0:	10800130 	cmpltui	r2,r2,4
811107e4:	103fc51e 	bne	r2,zero,811106fc <__reset+0xfb0f06fc>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
811107e8:	d0a07217 	ldw	r2,-32312(gp)
811107ec:	1009883a 	mov	r4,r2
811107f0:	1135b100 	call	81135b10 <OSMutexPost>
    }

    return bSuccess;
811107f4:	e0bffc17 	ldw	r2,-16(fp)
}
811107f8:	e037883a 	mov	sp,fp
811107fc:	dfc00117 	ldw	ra,4(sp)
81110800:	df000017 	ldw	fp,0(sp)
81110804:	dec00204 	addi	sp,sp,8
81110808:	f800283a 	ret

8111080c <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
8111080c:	deffab04 	addi	sp,sp,-340
81110810:	de00012e 	bgeu	sp,et,81110818 <vReceiverUartTask+0xc>
81110814:	003b68fa 	trap	3
81110818:	dfc05415 	stw	ra,336(sp)
8111081c:	df005315 	stw	fp,332(sp)
81110820:	df005304 	addi	fp,sp,332
81110824:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81110828:	e03fae15 	stw	zero,-328(fp)

    #if DEBUG_ON
        debug(fp,"Receiver UART Task. (Task on)\n");
    #endif

    eReaderRXMode = sRConfiguring;
8111082c:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
81110830:	e0bfad17 	ldw	r2,-332(fp)
81110834:	10c00060 	cmpeqi	r3,r2,1
81110838:	1800091e 	bne	r3,zero,81110860 <vReceiverUartTask+0x54>
8111083c:	0080052e 	bgeu	zero,r2,81110854 <vReceiverUartTask+0x48>
81110840:	10c000a0 	cmpeqi	r3,r2,2
81110844:	1800561e 	bne	r3,zero,811109a0 <vReceiverUartTask+0x194>
81110848:	108000e0 	cmpeqi	r2,r2,3
8111084c:	1000671e 	bne	r2,zero,811109ec <vReceiverUartTask+0x1e0>
81110850:	00007006 	br	81110a14 <vReceiverUartTask+0x208>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
81110854:	00800044 	movi	r2,1
81110858:	e0bfad15 	stw	r2,-332(fp)
                break;
8111085c:	00007006 	br	81110a20 <vReceiverUartTask+0x214>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
81110860:	e0bfaf04 	addi	r2,fp,-324
81110864:	01802004 	movi	r6,128
81110868:	000b883a 	mov	r5,zero
8111086c:	1009883a 	mov	r4,r2
81110870:	111acfc0 	call	8111acfc <memset>
                scanf("%s", cReceive);
81110874:	e0bfcf04 	addi	r2,fp,-196
81110878:	100b883a 	mov	r5,r2
8111087c:	01204534 	movhi	r4,33044
81110880:	21129f04 	addi	r4,r4,19068
81110884:	111af7c0 	call	8111af7c <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
81110888:	e0ffcf04 	addi	r3,fp,-196
8111088c:	e0bfaf04 	addi	r2,fp,-324
81110890:	01801fc4 	movi	r6,127
81110894:	180b883a 	mov	r5,r3
81110898:	1009883a 	mov	r4,r2
8111089c:	111abac0 	call	8111abac <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
811108a0:	e0bfaf04 	addi	r2,fp,-324
811108a4:	01604534 	movhi	r5,33044
811108a8:	295ee904 	addi	r5,r5,31652
811108ac:	1009883a 	mov	r4,r2
811108b0:	1110e580 	call	81110e58 <bPreParserV2>
811108b4:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
811108b8:	e0bfae17 	ldw	r2,-328(fp)
811108bc:	10800058 	cmpnei	r2,r2,1
811108c0:	1000211e 	bne	r2,zero,81110948 <vReceiverUartTask+0x13c>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
811108c4:	00a04534 	movhi	r2,33044
811108c8:	109ee904 	addi	r2,r2,31652
811108cc:	10800103 	ldbu	r2,4(r2)
811108d0:	10803fcc 	andi	r2,r2,255
811108d4:	1080201c 	xori	r2,r2,128
811108d8:	10bfe004 	addi	r2,r2,-128
811108dc:	10800fe0 	cmpeqi	r2,r2,63
811108e0:	1000081e 	bne	r2,zero,81110904 <vReceiverUartTask+0xf8>
811108e4:	00a04534 	movhi	r2,33044
811108e8:	109ee904 	addi	r2,r2,31652
811108ec:	10800103 	ldbu	r2,4(r2)
811108f0:	10803fcc 	andi	r2,r2,255
811108f4:	1080201c 	xori	r2,r2,128
811108f8:	10bfe004 	addi	r2,r2,-128
811108fc:	10800858 	cmpnei	r2,r2,33
81110900:	1000031e 	bne	r2,zero,81110910 <vReceiverUartTask+0x104>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
81110904:	00800084 	movi	r2,2
81110908:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
8111090c:	00004406 	br	81110a20 <vReceiverUartTask+0x214>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
81110910:	00a04534 	movhi	r2,33044
81110914:	109ee904 	addi	r2,r2,31652
81110918:	10800103 	ldbu	r2,4(r2)
8111091c:	10803fcc 	andi	r2,r2,255
81110920:	1080201c 	xori	r2,r2,128
81110924:	10bfe004 	addi	r2,r2,-128
81110928:	108008d8 	cmpnei	r2,r2,35
8111092c:	1000031e 	bne	r2,zero,8111093c <vReceiverUartTask+0x130>
                            eReaderRXMode = sGetRxUart;
81110930:	00800044 	movi	r2,1
81110934:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81110938:	00003906 	br	81110a20 <vReceiverUartTask+0x214>
                            eReaderRXMode = sGetRxUart;
                            #if DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
8111093c:	008000c4 	movi	r2,3
81110940:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81110944:	00003606 	br	81110a20 <vReceiverUartTask+0x214>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
81110948:	00a04534 	movhi	r2,33044
8111094c:	109ee904 	addi	r2,r2,31652
81110950:	00c008c4 	movi	r3,35
81110954:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
81110958:	00a04534 	movhi	r2,33044
8111095c:	109ee904 	addi	r2,r2,31652
81110960:	00c00b84 	movi	r3,46
81110964:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
81110968:	00a04534 	movhi	r2,33044
8111096c:	109ee904 	addi	r2,r2,31652
81110970:	00c00044 	movi	r3,1
81110974:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81110978:	01204534 	movhi	r4,33044
8111097c:	211ee904 	addi	r4,r4,31652
81110980:	1110b600 	call	81110b60 <setPreAckSenderFreePos>
81110984:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81110988:	e0bfae17 	ldw	r2,-328(fp)
8111098c:	1000011e 	bne	r2,zero,81110994 <vReceiverUartTask+0x188>
                        vFailSendNack();
81110990:	1116af80 	call	81116af8 <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
81110994:	00800044 	movi	r2,1
81110998:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
8111099c:	00002006 	br	81110a20 <vReceiverUartTask+0x214>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
811109a0:	01204534 	movhi	r4,33044
811109a4:	211ee904 	addi	r4,r4,31652
811109a8:	1110b600 	call	81110b60 <setPreAckSenderFreePos>
811109ac:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
811109b0:	e0bfae17 	ldw	r2,-328(fp)
811109b4:	10800058 	cmpnei	r2,r2,1
811109b8:	1000081e 	bne	r2,zero,811109dc <vReceiverUartTask+0x1d0>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
811109bc:	01204534 	movhi	r4,33044
811109c0:	211ee904 	addi	r4,r4,31652
811109c4:	1110a240 	call	81110a24 <setPreParsedFreePos>
811109c8:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
811109cc:	e0bfae17 	ldw	r2,-328(fp)
811109d0:	1000031e 	bne	r2,zero,811109e0 <vReceiverUartTask+0x1d4>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
811109d4:	1116b480 	call	81116b48 <vFailSetPreParsedBuffer>
811109d8:	00000106 	br	811109e0 <vReceiverUartTask+0x1d4>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
811109dc:	1116b200 	call	81116b20 <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
811109e0:	00800044 	movi	r2,1
811109e4:	e0bfad15 	stw	r2,-332(fp)
                break;
811109e8:	00000d06 	br	81110a20 <vReceiverUartTask+0x214>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
811109ec:	01204534 	movhi	r4,33044
811109f0:	211ee904 	addi	r4,r4,31652
811109f4:	1110cdc0 	call	81110cdc <setPreAckReceiverFreePos>
811109f8:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
811109fc:	e0bfae17 	ldw	r2,-328(fp)
81110a00:	1000011e 	bne	r2,zero,81110a08 <vReceiverUartTask+0x1fc>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
81110a04:	1116b700 	call	81116b70 <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
81110a08:	00800044 	movi	r2,1
81110a0c:	e0bfad15 	stw	r2,-332(fp)
                break;
81110a10:	00000306 	br	81110a20 <vReceiverUartTask+0x214>
            default:
                eReaderRXMode = sGetRxUart;
81110a14:	00800044 	movi	r2,1
81110a18:	e0bfad15 	stw	r2,-332(fp)
                break;
81110a1c:	0001883a 	nop
        }

    }
81110a20:	003f8306 	br	81110830 <__reset+0xfb0f0830>

81110a24 <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
81110a24:	defffb04 	addi	sp,sp,-20
81110a28:	de00012e 	bgeu	sp,et,81110a30 <setPreParsedFreePos+0xc>
81110a2c:	003b68fa 	trap	3
81110a30:	dfc00415 	stw	ra,16(sp)
81110a34:	df000315 	stw	fp,12(sp)
81110a38:	df000304 	addi	fp,sp,12
81110a3c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81110a40:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81110a44:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81110a48:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81110a4c:	d0a06a17 	ldw	r2,-32344(gp)
81110a50:	e0fffe44 	addi	r3,fp,-7
81110a54:	180d883a 	mov	r6,r3
81110a58:	01400284 	movi	r5,10
81110a5c:	1009883a 	mov	r4,r2
81110a60:	113556c0 	call	8113556c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81110a64:	e0bffe43 	ldbu	r2,-7(fp)
81110a68:	10803fcc 	andi	r2,r2,255
81110a6c:	1000361e 	bne	r2,zero,81110b48 <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81110a70:	e03ffe05 	stb	zero,-8(fp)
81110a74:	00002e06 	br	81110b30 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
81110a78:	e0fffe03 	ldbu	r3,-8(fp)
81110a7c:	00a045b4 	movhi	r2,33046
81110a80:	10ac1704 	addi	r2,r2,-20388
81110a84:	18c01324 	muli	r3,r3,76
81110a88:	10c5883a 	add	r2,r2,r3
81110a8c:	10800104 	addi	r2,r2,4
81110a90:	10800003 	ldbu	r2,0(r2)
81110a94:	10803fcc 	andi	r2,r2,255
81110a98:	1080201c 	xori	r2,r2,128
81110a9c:	10bfe004 	addi	r2,r2,-128
81110aa0:	1000201e 	bne	r2,zero,81110b24 <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
81110aa4:	e0fffe03 	ldbu	r3,-8(fp)
81110aa8:	00a045b4 	movhi	r2,33046
81110aac:	10ac1704 	addi	r2,r2,-20388
81110ab0:	18c01324 	muli	r3,r3,76
81110ab4:	10c7883a 	add	r3,r2,r3
81110ab8:	e0bfff17 	ldw	r2,-4(fp)
81110abc:	1009883a 	mov	r4,r2
81110ac0:	00801304 	movi	r2,76
81110ac4:	100d883a 	mov	r6,r2
81110ac8:	200b883a 	mov	r5,r4
81110acc:	1809883a 	mov	r4,r3
81110ad0:	111abac0 	call	8111abac <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
81110ad4:	d0a06317 	ldw	r2,-32372(gp)
81110ad8:	1009883a 	mov	r4,r2
81110adc:	11379000 	call	81137900 <OSSemPost>
81110ae0:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81110ae4:	e0bffe43 	ldbu	r2,-7(fp)
81110ae8:	10803fcc 	andi	r2,r2,255
81110aec:	1000031e 	bne	r2,zero,81110afc <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
81110af0:	00800044 	movi	r2,1
81110af4:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
81110af8:	00001006 	br	81110b3c <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
81110afc:	11167380 	call	81116738 <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
81110b00:	e0fffe03 	ldbu	r3,-8(fp)
81110b04:	00a045b4 	movhi	r2,33046
81110b08:	10ac1704 	addi	r2,r2,-20388
81110b0c:	18c01324 	muli	r3,r3,76
81110b10:	10c5883a 	add	r2,r2,r3
81110b14:	10800104 	addi	r2,r2,4
81110b18:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
81110b1c:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
81110b20:	00000606 	br	81110b3c <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81110b24:	e0bffe03 	ldbu	r2,-8(fp)
81110b28:	10800044 	addi	r2,r2,1
81110b2c:	e0bffe05 	stb	r2,-8(fp)
81110b30:	e0bffe03 	ldbu	r2,-8(fp)
81110b34:	10800230 	cmpltui	r2,r2,8
81110b38:	103fcf1e 	bne	r2,zero,81110a78 <__reset+0xfb0f0a78>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
81110b3c:	d0a06a17 	ldw	r2,-32344(gp)
81110b40:	1009883a 	mov	r4,r2
81110b44:	1135b100 	call	81135b10 <OSMutexPost>
    }
    return bSuccess;
81110b48:	e0bffd17 	ldw	r2,-12(fp)
}
81110b4c:	e037883a 	mov	sp,fp
81110b50:	dfc00117 	ldw	ra,4(sp)
81110b54:	df000017 	ldw	fp,0(sp)
81110b58:	dec00204 	addi	sp,sp,8
81110b5c:	f800283a 	ret

81110b60 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
81110b60:	defffb04 	addi	sp,sp,-20
81110b64:	de00012e 	bgeu	sp,et,81110b6c <setPreAckSenderFreePos+0xc>
81110b68:	003b68fa 	trap	3
81110b6c:	dfc00415 	stw	ra,16(sp)
81110b70:	df000315 	stw	fp,12(sp)
81110b74:	df000304 	addi	fp,sp,12
81110b78:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81110b7c:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81110b80:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81110b84:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81110b88:	d0a07117 	ldw	r2,-32316(gp)
81110b8c:	e0fffe44 	addi	r3,fp,-7
81110b90:	180d883a 	mov	r6,r3
81110b94:	01400284 	movi	r5,10
81110b98:	1009883a 	mov	r4,r2
81110b9c:	113556c0 	call	8113556c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81110ba0:	e0bffe43 	ldbu	r2,-7(fp)
81110ba4:	10803fcc 	andi	r2,r2,255
81110ba8:	1000461e 	bne	r2,zero,81110cc4 <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81110bac:	e03ffe05 	stb	zero,-8(fp)
81110bb0:	00003e06 	br	81110cac <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
81110bb4:	e0fffe03 	ldbu	r3,-8(fp)
81110bb8:	00a045b4 	movhi	r2,33046
81110bbc:	10ac0f04 	addi	r2,r2,-20420
81110bc0:	18c7883a 	add	r3,r3,r3
81110bc4:	18c7883a 	add	r3,r3,r3
81110bc8:	10c5883a 	add	r2,r2,r3
81110bcc:	10800003 	ldbu	r2,0(r2)
81110bd0:	10803fcc 	andi	r2,r2,255
81110bd4:	1080201c 	xori	r2,r2,128
81110bd8:	10bfe004 	addi	r2,r2,-128
81110bdc:	1000301e 	bne	r2,zero,81110ca0 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
81110be0:	e0fffe03 	ldbu	r3,-8(fp)
81110be4:	e0bfff17 	ldw	r2,-4(fp)
81110be8:	11000103 	ldbu	r4,4(r2)
81110bec:	00a045b4 	movhi	r2,33046
81110bf0:	10ac0f04 	addi	r2,r2,-20420
81110bf4:	18c7883a 	add	r3,r3,r3
81110bf8:	18c7883a 	add	r3,r3,r3
81110bfc:	10c5883a 	add	r2,r2,r3
81110c00:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
81110c04:	e0fffe03 	ldbu	r3,-8(fp)
81110c08:	e0bfff17 	ldw	r2,-4(fp)
81110c0c:	11000143 	ldbu	r4,5(r2)
81110c10:	00a045b4 	movhi	r2,33046
81110c14:	10ac0f04 	addi	r2,r2,-20420
81110c18:	18c7883a 	add	r3,r3,r3
81110c1c:	18c7883a 	add	r3,r3,r3
81110c20:	10c5883a 	add	r2,r2,r3
81110c24:	10800044 	addi	r2,r2,1
81110c28:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
81110c2c:	e0fffe03 	ldbu	r3,-8(fp)
81110c30:	e0bfff17 	ldw	r2,-4(fp)
81110c34:	1100020b 	ldhu	r4,8(r2)
81110c38:	00a045b4 	movhi	r2,33046
81110c3c:	10ac0f04 	addi	r2,r2,-20420
81110c40:	18c7883a 	add	r3,r3,r3
81110c44:	18c7883a 	add	r3,r3,r3
81110c48:	10c5883a 	add	r2,r2,r3
81110c4c:	10800084 	addi	r2,r2,2
81110c50:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
81110c54:	d0a06117 	ldw	r2,-32380(gp)
81110c58:	1009883a 	mov	r4,r2
81110c5c:	11379000 	call	81137900 <OSSemPost>
81110c60:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
81110c64:	e0bffe43 	ldbu	r2,-7(fp)
81110c68:	10803fcc 	andi	r2,r2,255
81110c6c:	10000926 	beq	r2,zero,81110c94 <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
81110c70:	11167880 	call	81116788 <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
81110c74:	e0fffe03 	ldbu	r3,-8(fp)
81110c78:	00a045b4 	movhi	r2,33046
81110c7c:	10ac0f04 	addi	r2,r2,-20420
81110c80:	18c7883a 	add	r3,r3,r3
81110c84:	18c7883a 	add	r3,r3,r3
81110c88:	10c5883a 	add	r2,r2,r3
81110c8c:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81110c90:	00000906 	br	81110cb8 <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
81110c94:	00800044 	movi	r2,1
81110c98:	e0bffd15 	stw	r2,-12(fp)
                break;
81110c9c:	00000606 	br	81110cb8 <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81110ca0:	e0bffe03 	ldbu	r2,-8(fp)
81110ca4:	10800044 	addi	r2,r2,1
81110ca8:	e0bffe05 	stb	r2,-8(fp)
81110cac:	e0bffe03 	ldbu	r2,-8(fp)
81110cb0:	10800230 	cmpltui	r2,r2,8
81110cb4:	103fbf1e 	bne	r2,zero,81110bb4 <__reset+0xfb0f0bb4>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
81110cb8:	d0a07117 	ldw	r2,-32316(gp)
81110cbc:	1009883a 	mov	r4,r2
81110cc0:	1135b100 	call	81135b10 <OSMutexPost>
    }

    return bSuccess;
81110cc4:	e0bffd17 	ldw	r2,-12(fp)
}
81110cc8:	e037883a 	mov	sp,fp
81110ccc:	dfc00117 	ldw	ra,4(sp)
81110cd0:	df000017 	ldw	fp,0(sp)
81110cd4:	dec00204 	addi	sp,sp,8
81110cd8:	f800283a 	ret

81110cdc <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
81110cdc:	defffb04 	addi	sp,sp,-20
81110ce0:	de00012e 	bgeu	sp,et,81110ce8 <setPreAckReceiverFreePos+0xc>
81110ce4:	003b68fa 	trap	3
81110ce8:	dfc00415 	stw	ra,16(sp)
81110cec:	df000315 	stw	fp,12(sp)
81110cf0:	df000304 	addi	fp,sp,12
81110cf4:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81110cf8:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81110cfc:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81110d00:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
81110d04:	d0a06417 	ldw	r2,-32368(gp)
81110d08:	e0fffe44 	addi	r3,fp,-7
81110d0c:	180d883a 	mov	r6,r3
81110d10:	01400504 	movi	r5,20
81110d14:	1009883a 	mov	r4,r2
81110d18:	113556c0 	call	8113556c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81110d1c:	e0bffe43 	ldbu	r2,-7(fp)
81110d20:	10803fcc 	andi	r2,r2,255
81110d24:	1000461e 	bne	r2,zero,81110e40 <setPreAckReceiverFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81110d28:	e03ffe05 	stb	zero,-8(fp)
81110d2c:	00003e06 	br	81110e28 <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
81110d30:	e0fffe03 	ldbu	r3,-8(fp)
81110d34:	00a04574 	movhi	r2,33045
81110d38:	1095fd04 	addi	r2,r2,22516
81110d3c:	18c7883a 	add	r3,r3,r3
81110d40:	18c7883a 	add	r3,r3,r3
81110d44:	10c5883a 	add	r2,r2,r3
81110d48:	10800003 	ldbu	r2,0(r2)
81110d4c:	10803fcc 	andi	r2,r2,255
81110d50:	1080201c 	xori	r2,r2,128
81110d54:	10bfe004 	addi	r2,r2,-128
81110d58:	1000301e 	bne	r2,zero,81110e1c <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
81110d5c:	e0fffe03 	ldbu	r3,-8(fp)
81110d60:	e0bfff17 	ldw	r2,-4(fp)
81110d64:	11000103 	ldbu	r4,4(r2)
81110d68:	00a04574 	movhi	r2,33045
81110d6c:	1095fd04 	addi	r2,r2,22516
81110d70:	18c7883a 	add	r3,r3,r3
81110d74:	18c7883a 	add	r3,r3,r3
81110d78:	10c5883a 	add	r2,r2,r3
81110d7c:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
81110d80:	e0fffe03 	ldbu	r3,-8(fp)
81110d84:	e0bfff17 	ldw	r2,-4(fp)
81110d88:	11000143 	ldbu	r4,5(r2)
81110d8c:	00a04574 	movhi	r2,33045
81110d90:	1095fd04 	addi	r2,r2,22516
81110d94:	18c7883a 	add	r3,r3,r3
81110d98:	18c7883a 	add	r3,r3,r3
81110d9c:	10c5883a 	add	r2,r2,r3
81110da0:	10800044 	addi	r2,r2,1
81110da4:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
81110da8:	e0fffe03 	ldbu	r3,-8(fp)
81110dac:	e0bfff17 	ldw	r2,-4(fp)
81110db0:	1100020b 	ldhu	r4,8(r2)
81110db4:	00a04574 	movhi	r2,33045
81110db8:	1095fd04 	addi	r2,r2,22516
81110dbc:	18c7883a 	add	r3,r3,r3
81110dc0:	18c7883a 	add	r3,r3,r3
81110dc4:	10c5883a 	add	r2,r2,r3
81110dc8:	10800084 	addi	r2,r2,2
81110dcc:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
81110dd0:	d0a06517 	ldw	r2,-32364(gp)
81110dd4:	1009883a 	mov	r4,r2
81110dd8:	11379000 	call	81137900 <OSSemPost>
81110ddc:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81110de0:	e0bffe43 	ldbu	r2,-7(fp)
81110de4:	10803fcc 	andi	r2,r2,255
81110de8:	1000031e 	bne	r2,zero,81110df8 <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
81110dec:	00800044 	movi	r2,1
81110df0:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
81110df4:	00000f06 	br	81110e34 <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
81110df8:	11167600 	call	81116760 <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
81110dfc:	e0fffe03 	ldbu	r3,-8(fp)
81110e00:	00a04574 	movhi	r2,33045
81110e04:	1095fd04 	addi	r2,r2,22516
81110e08:	18c7883a 	add	r3,r3,r3
81110e0c:	18c7883a 	add	r3,r3,r3
81110e10:	10c5883a 	add	r2,r2,r3
81110e14:	10000005 	stb	zero,0(r2)
                }
                break;
81110e18:	00000606 	br	81110e34 <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81110e1c:	e0bffe03 	ldbu	r2,-8(fp)
81110e20:	10800044 	addi	r2,r2,1
81110e24:	e0bffe05 	stb	r2,-8(fp)
81110e28:	e0bffe03 	ldbu	r2,-8(fp)
81110e2c:	108001b0 	cmpltui	r2,r2,6
81110e30:	103fbf1e 	bne	r2,zero,81110d30 <__reset+0xfb0f0d30>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
81110e34:	d0a06417 	ldw	r2,-32368(gp)
81110e38:	1009883a 	mov	r4,r2
81110e3c:	1135b100 	call	81135b10 <OSMutexPost>
        #if DEBUG_ON
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
        #endif
    }

    return bSuccess;
81110e40:	e0bffd17 	ldw	r2,-12(fp)
}
81110e44:	e037883a 	mov	sp,fp
81110e48:	dfc00117 	ldw	ra,4(sp)
81110e4c:	df000017 	ldw	fp,0(sp)
81110e50:	dec00204 	addi	sp,sp,8
81110e54:	f800283a 	ret

81110e58 <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
81110e58:	defff404 	addi	sp,sp,-48
81110e5c:	de00012e 	bgeu	sp,et,81110e64 <bPreParserV2+0xc>
81110e60:	003b68fa 	trap	3
81110e64:	dfc00b15 	stw	ra,44(sp)
81110e68:	df000a15 	stw	fp,40(sp)
81110e6c:	dc000915 	stw	r16,36(sp)
81110e70:	df000a04 	addi	fp,sp,40
81110e74:	e13ffd15 	stw	r4,-12(fp)
81110e78:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
81110e7c:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
81110e80:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
81110e84:	01402004 	movi	r5,128
81110e88:	e13ffd17 	ldw	r4,-12(fp)
81110e8c:	111b1b00 	call	8111b1b0 <strnlen>
81110e90:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
81110e94:	01400ec4 	movi	r5,59
81110e98:	e13ffd17 	ldw	r4,-12(fp)
81110e9c:	11147a80 	call	811147a8 <siPosStr>
81110ea0:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
81110ea4:	e0fff98f 	ldh	r3,-26(fp)
81110ea8:	e0bff90f 	ldh	r2,-28(fp)
81110eac:	10bfffc4 	addi	r2,r2,-1
81110eb0:	18800226 	beq	r3,r2,81110ebc <bPreParserV2+0x64>
        return bSuccess;
81110eb4:	e0bff617 	ldw	r2,-40(fp)
81110eb8:	0000ad06 	br	81111170 <bPreParserV2+0x318>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
81110ebc:	01401f04 	movi	r5,124
81110ec0:	e13ffd17 	ldw	r4,-12(fp)
81110ec4:	11147a80 	call	811147a8 <siPosStr>
81110ec8:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
81110ecc:	e0bffa0f 	ldh	r2,-24(fp)
81110ed0:	e0fff98f 	ldh	r3,-26(fp)
81110ed4:	1880020e 	bge	r3,r2,81110ee0 <bPreParserV2+0x88>
        return bSuccess;
81110ed8:	e0bff617 	ldw	r2,-40(fp)
81110edc:	0000a406 	br	81111170 <bPreParserV2+0x318>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
81110ee0:	01604534 	movhi	r5,33044
81110ee4:	2952a004 	addi	r5,r5,19072
81110ee8:	e13ffd17 	ldw	r4,-12(fp)
81110eec:	111b0cc0 	call	8111b0cc <strcspn>
81110ef0:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
81110ef4:	e0bffa8f 	ldh	r2,-22(fp)
81110ef8:	e0fffa0f 	ldh	r3,-24(fp)
81110efc:	1880020e 	bge	r3,r2,81110f08 <bPreParserV2+0xb0>
        return bSuccess;
81110f00:	e0bff617 	ldw	r2,-40(fp)
81110f04:	00009a06 	br	81111170 <bPreParserV2+0x318>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
81110f08:	e0bffa8f 	ldh	r2,-22(fp)
81110f0c:	e0fffd17 	ldw	r3,-12(fp)
81110f10:	1885883a 	add	r2,r3,r2
81110f14:	10c00003 	ldbu	r3,0(r2)
81110f18:	e0bffe17 	ldw	r2,-8(fp)
81110f1c:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
81110f20:	e0bffe17 	ldw	r2,-8(fp)
81110f24:	10800103 	ldbu	r2,4(r2)
81110f28:	10803fcc 	andi	r2,r2,255
81110f2c:	1080201c 	xori	r2,r2,128
81110f30:	10bfe004 	addi	r2,r2,-128
81110f34:	108008d8 	cmpnei	r2,r2,35
81110f38:	1000041e 	bne	r2,zero,81110f4c <bPreParserV2+0xf4>
        bSuccess = TRUE;
81110f3c:	00800044 	movi	r2,1
81110f40:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
81110f44:	e0bff617 	ldw	r2,-40(fp)
81110f48:	00008906 	br	81111170 <bPreParserV2+0x318>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
81110f4c:	e0bffa8f 	ldh	r2,-22(fp)
81110f50:	e0fffd17 	ldw	r3,-12(fp)
81110f54:	1889883a 	add	r4,r3,r2
81110f58:	e0fffa0f 	ldh	r3,-24(fp)
81110f5c:	e0bffa8f 	ldh	r2,-22(fp)
81110f60:	1885c83a 	sub	r2,r3,r2
81110f64:	100b883a 	mov	r5,r2
81110f68:	111652c0 	call	8111652c <ucCrc8wInit>
81110f6c:	1007883a 	mov	r3,r2
81110f70:	e0bffe17 	ldw	r2,-8(fp)
81110f74:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
81110f78:	e0bffa8f 	ldh	r2,-22(fp)
81110f7c:	10800044 	addi	r2,r2,1
81110f80:	e0fffd17 	ldw	r3,-12(fp)
81110f84:	1885883a 	add	r2,r3,r2
81110f88:	10c00003 	ldbu	r3,0(r2)
81110f8c:	e0bffe17 	ldw	r2,-8(fp)
81110f90:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
81110f94:	e0bffe17 	ldw	r2,-8(fp)
81110f98:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
81110f9c:	e0bffe17 	ldw	r2,-8(fp)
81110fa0:	10800204 	addi	r2,r2,8
81110fa4:	01801004 	movi	r6,64
81110fa8:	000b883a 	mov	r5,zero
81110fac:	1009883a 	mov	r4,r2
81110fb0:	111acfc0 	call	8111acfc <memset>

    i = siIni + 3; /* "?C:i..." */
81110fb4:	e0bffa8b 	ldhu	r2,-22(fp)
81110fb8:	108000c4 	addi	r2,r2,3
81110fbc:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
81110fc0:	e0bffb44 	addi	r2,fp,-19
81110fc4:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
81110fc8:	e0bffb44 	addi	r2,fp,-19
81110fcc:	01800184 	movi	r6,6
81110fd0:	000b883a 	mov	r5,zero
81110fd4:	1009883a 	mov	r4,r2
81110fd8:	111acfc0 	call	8111acfc <memset>
        do {
            c = buffer[i];
81110fdc:	e0bff703 	ldbu	r2,-36(fp)
81110fe0:	e0fffd17 	ldw	r3,-12(fp)
81110fe4:	1885883a 	add	r2,r3,r2
81110fe8:	10800003 	ldbu	r2,0(r2)
81110fec:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
81110ff0:	d0e00317 	ldw	r3,-32756(gp)
81110ff4:	e0bffb07 	ldb	r2,-20(fp)
81110ff8:	10800044 	addi	r2,r2,1
81110ffc:	1885883a 	add	r2,r3,r2
81111000:	10800003 	ldbu	r2,0(r2)
81111004:	10803fcc 	andi	r2,r2,255
81111008:	1080010c 	andi	r2,r2,4
8111100c:	10000626 	beq	r2,zero,81111028 <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
81111010:	e0bff817 	ldw	r2,-32(fp)
81111014:	e0fffb03 	ldbu	r3,-20(fp)
81111018:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
8111101c:	e0bff817 	ldw	r2,-32(fp)
81111020:	10800044 	addi	r2,r2,1
81111024:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
81111028:	e0bff703 	ldbu	r2,-36(fp)
8111102c:	10800044 	addi	r2,r2,1
81111030:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
81111034:	e0bff90f 	ldh	r2,-28(fp)
81111038:	e0fff703 	ldbu	r3,-36(fp)
8111103c:	1880090e 	bge	r3,r2,81111064 <bPreParserV2+0x20c>
81111040:	e0bffb07 	ldb	r2,-20(fp)
81111044:	10800ea0 	cmpeqi	r2,r2,58
81111048:	1000061e 	bne	r2,zero,81111064 <bPreParserV2+0x20c>
8111104c:	e0bffb07 	ldb	r2,-20(fp)
81111050:	10800ee0 	cmpeqi	r2,r2,59
81111054:	1000031e 	bne	r2,zero,81111064 <bPreParserV2+0x20c>
81111058:	e0bffb07 	ldb	r2,-20(fp)
8111105c:	10801f18 	cmpnei	r2,r2,124
81111060:	103fde1e 	bne	r2,zero,81110fdc <__reset+0xfb0f0fdc>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81111064:	e0bff817 	ldw	r2,-32(fp)
81111068:	00c00284 	movi	r3,10
8111106c:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
81111070:	e0bffb07 	ldb	r2,-20(fp)
81111074:	10800ea0 	cmpeqi	r2,r2,58
81111078:	1000031e 	bne	r2,zero,81111088 <bPreParserV2+0x230>
8111107c:	e0bffb07 	ldb	r2,-20(fp)
81111080:	10801f18 	cmpnei	r2,r2,124
81111084:	10001a1e 	bne	r2,zero,811110f0 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
81111088:	e0bffe17 	ldw	r2,-8(fp)
8111108c:	10800183 	ldbu	r2,6(r2)
81111090:	10803fcc 	andi	r2,r2,255
81111094:	10800828 	cmpgeui	r2,r2,32
81111098:	1000041e 	bne	r2,zero,811110ac <bPreParserV2+0x254>
8111109c:	e0bffe17 	ldw	r2,-8(fp)
811110a0:	10800183 	ldbu	r2,6(r2)
811110a4:	14003fcc 	andi	r16,r2,255
811110a8:	00000106 	br	811110b0 <bPreParserV2+0x258>
811110ac:	04000804 	movi	r16,32
811110b0:	e0bffb44 	addi	r2,fp,-19
811110b4:	1009883a 	mov	r4,r2
811110b8:	111ab7c0 	call	8111ab7c <atoi>
811110bc:	1009883a 	mov	r4,r2
811110c0:	e0fffe17 	ldw	r3,-8(fp)
811110c4:	80800104 	addi	r2,r16,4
811110c8:	1085883a 	add	r2,r2,r2
811110cc:	1885883a 	add	r2,r3,r2
811110d0:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
811110d4:	e0bffe17 	ldw	r2,-8(fp)
811110d8:	10800183 	ldbu	r2,6(r2)
811110dc:	10800044 	addi	r2,r2,1
811110e0:	1007883a 	mov	r3,r2
811110e4:	e0bffe17 	ldw	r2,-8(fp)
811110e8:	10c00185 	stb	r3,6(r2)
811110ec:	00000906 	br	81111114 <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
811110f0:	e0bffb07 	ldb	r2,-20(fp)
811110f4:	10800ed8 	cmpnei	r2,r2,59
811110f8:	1000061e 	bne	r2,zero,81111114 <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
811110fc:	e0bffb44 	addi	r2,fp,-19
81111100:	1009883a 	mov	r4,r2
81111104:	111ab7c0 	call	8111ab7c <atoi>
81111108:	1007883a 	mov	r3,r2
8111110c:	e0bffe17 	ldw	r2,-8(fp)
81111110:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
81111114:	e0bffb07 	ldb	r2,-20(fp)
81111118:	10800ee0 	cmpeqi	r2,r2,59
8111111c:	1000031e 	bne	r2,zero,8111112c <bPreParserV2+0x2d4>
81111120:	e0bff90f 	ldh	r2,-28(fp)
81111124:	e0fff703 	ldbu	r3,-36(fp)
81111128:	18bfa516 	blt	r3,r2,81110fc0 <__reset+0xfb0f0fc0>


    if ( c == FINAL_CHAR )
8111112c:	e0bffb07 	ldb	r2,-20(fp)
81111130:	10800ed8 	cmpnei	r2,r2,59
81111134:	10000c1e 	bne	r2,zero,81111168 <bPreParserV2+0x310>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
81111138:	e0bffe17 	ldw	r2,-8(fp)
8111113c:	10c01243 	ldbu	r3,73(r2)
81111140:	e0bffe17 	ldw	r2,-8(fp)
81111144:	10801203 	ldbu	r2,72(r2)
81111148:	18c03fcc 	andi	r3,r3,255
8111114c:	10803fcc 	andi	r2,r2,255
81111150:	1880031e 	bne	r3,r2,81111160 <bPreParserV2+0x308>
            bSuccess = TRUE;
81111154:	00800044 	movi	r2,1
81111158:	e0bff615 	stw	r2,-40(fp)
8111115c:	00000306 	br	8111116c <bPreParserV2+0x314>
        } else {
            /* Wrong CRC */
            #if DEBUG_ON
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
            #endif
            bSuccess = FALSE;
81111160:	e03ff615 	stw	zero,-40(fp)
81111164:	00000106 	br	8111116c <bPreParserV2+0x314>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
81111168:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
8111116c:	e0bff617 	ldw	r2,-40(fp)
}
81111170:	e6ffff04 	addi	sp,fp,-4
81111174:	dfc00217 	ldw	ra,8(sp)
81111178:	df000117 	ldw	fp,4(sp)
8111117c:	dc000017 	ldw	r16,0(sp)
81111180:	dec00304 	addi	sp,sp,12
81111184:	f800283a 	ret

81111188 <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
81111188:	defffb04 	addi	sp,sp,-20
8111118c:	de00012e 	bgeu	sp,et,81111194 <vSenderComTask+0xc>
81111190:	003b68fa 	trap	3
81111194:	dfc00415 	stw	ra,16(sp)
81111198:	df000315 	stw	fp,12(sp)
8111119c:	df000304 	addi	fp,sp,12
811111a0:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
811111a4:	e03ffd15 	stw	zero,-12(fp)
        debug(fp,"Sender Comm Task. (Task on)\n");
    #endif

    for (;;){
        
        switch (eSenderMode)
811111a8:	e0bffd17 	ldw	r2,-12(fp)
811111ac:	10c00060 	cmpeqi	r3,r2,1
811111b0:	1800091e 	bne	r3,zero,811111d8 <vSenderComTask+0x50>
811111b4:	0080052e 	bgeu	zero,r2,811111cc <vSenderComTask+0x44>
811111b8:	10c000a0 	cmpeqi	r3,r2,2
811111bc:	1800241e 	bne	r3,zero,81111250 <vSenderComTask+0xc8>
811111c0:	10800160 	cmpeqi	r2,r2,5
811111c4:	1000171e 	bne	r2,zero,81111224 <vSenderComTask+0x9c>
811111c8:	00001e06 	br	81111244 <vSenderComTask+0xbc>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
811111cc:	00800044 	movi	r2,1
811111d0:	e0bffd15 	stw	r2,-12(fp)
                break;
811111d4:	00001f06 	br	81111254 <vSenderComTask+0xcc>
                #if DEBUG_ON
                    debug(fp,"Preparing the Start Sequence.\n");
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
811111d8:	01400044 	movi	r5,1
811111dc:	01204534 	movhi	r4,33044
811111e0:	2112a204 	addi	r4,r4,19080
811111e4:	1113ed80 	call	81113ed8 <bSendUART32v2>
811111e8:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
811111ec:	e0bffe17 	ldw	r2,-8(fp)
811111f0:	10800058 	cmpnei	r2,r2,1
811111f4:	1000031e 	bne	r2,zero,81111204 <vSenderComTask+0x7c>
                    eSenderMode = sDummySender;
811111f8:	00800144 	movi	r2,5
811111fc:	e0bffd15 	stw	r2,-12(fp)
                        debug(fp,"Fail, try again in 5 seconds.\n");
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
81111200:	00001406 	br	81111254 <vSenderComTask+0xcc>
                    #endif                    
                } else {
                    #if DEBUG_ON
                        debug(fp,"Fail, try again in 5 seconds.\n");
                    #endif 
                    eSenderMode = sStartingConnSender;
81111204:	00800044 	movi	r2,1
81111208:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
8111120c:	000f883a 	mov	r7,zero
81111210:	01800144 	movi	r6,5
81111214:	000b883a 	mov	r5,zero
81111218:	0009883a 	mov	r4,zero
8111121c:	11395100 	call	81139510 <OSTimeDlyHMSM>
                }
                break;
81111220:	00000c06 	br	81111254 <vSenderComTask+0xcc>
                

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
81111224:	00800144 	movi	r2,5
81111228:	e0bffd15 	stw	r2,-12(fp)

                #if DEBUG_ON
                    debug(fp,"Working...\n");
                #endif

				OSTimeDlyHMSM(0, 0, 25, 0); /*Sleeps for 3 second*/
8111122c:	000f883a 	mov	r7,zero
81111230:	01800644 	movi	r6,25
81111234:	000b883a 	mov	r5,zero
81111238:	0009883a 	mov	r4,zero
8111123c:	11395100 	call	81139510 <OSTimeDlyHMSM>

                break;
81111240:	00000406 	br	81111254 <vSenderComTask+0xcc>
            default:
                #if DEBUG_ON
                    debug(fp,"Sender default\n");
                #endif
                eSenderMode = sDummySender;
81111244:	00800144 	movi	r2,5
81111248:	e0bffd15 	stw	r2,-12(fp)
                break;
8111124c:	00000106 	br	81111254 <vSenderComTask+0xcc>

                //pPointer = OSQPend(xQSenderTask, 0, &error_code);

                

                break;
81111250:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
81111254:	003fd406 	br	811111a8 <__reset+0xfb0f11a8>

81111258 <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
81111258:	defff904 	addi	sp,sp,-28
8111125c:	de00012e 	bgeu	sp,et,81111264 <vSimMebTask+0xc>
81111260:	003b68fa 	trap	3
81111264:	dfc00615 	stw	ra,24(sp)
81111268:	df000515 	stw	fp,20(sp)
8111126c:	df000504 	addi	fp,sp,20
81111270:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	tQMask uiCmdMeb;
	INT8U error_code;
	INT8U ucFrameNumber;

	pxMebC = (TSimucam_MEB *) task_data;
81111274:	e0bfff17 	ldw	r2,-4(fp)
81111278:	e0bffc15 	stw	r2,-16(fp)
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
    #endif


	for (;;) {
		switch ( pxMebC->eMode ) {
8111127c:	e0bffc17 	ldw	r2,-16(fp)
81111280:	10800117 	ldw	r2,4(r2)
81111284:	10c00168 	cmpgeui	r3,r2,5
81111288:	1800931e 	bne	r3,zero,811114d8 <vSimMebTask+0x280>
8111128c:	100690ba 	slli	r3,r2,2
81111290:	00a04474 	movhi	r2,33041
81111294:	1084a904 	addi	r2,r2,4772
81111298:	1885883a 	add	r2,r3,r2
8111129c:	10800017 	ldw	r2,0(r2)
811112a0:	1000683a 	jmp	r2
811112a4:	811112b8 	rdprs	r4,r16,17482
811112a8:	811112d0 	cmplti	r4,r16,17483
811112ac:	81111334 	orhi	r4,r16,17484
811112b0:	811113e4 	muli	r4,r16,17487
811112b4:	81111454 	ori	r4,r16,17489
			case sMebInit:
				/* Turn on Meb */
				vMebInit( pxMebC );
811112b8:	e13ffc17 	ldw	r4,-16(fp)
811112bc:	11120780 	call	81112078 <vMebInit>
				pxMebC->eMode = sMebToConfig;
811112c0:	e0bffc17 	ldw	r2,-16(fp)
811112c4:	00c00044 	movi	r3,1
811112c8:	10c00115 	stw	r3,4(r2)
				break;
811112cc:	00008906 	br	811114f4 <vSimMebTask+0x29c>
				#if DEBUG_ON
					debug(fp,"MEB Task: Config Mode\n");
				#endif

				/* Stop the Sync (Stopping the simulation) */
				bStopSync();
811112d0:	11188d80 	call	811188d8 <bStopSync>
				vSyncClearCounter();
811112d4:	110acb40 	call	8110acb4 <vSyncClearCounter>

				/* If any Task is locked waiting Sync, should be released */
				vReleaseSyncMessages();
811112d8:	11121800 	call	81112180 <vReleaseSyncMessages>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 10);
811112dc:	01c00284 	movi	r7,10
811112e0:	000d883a 	mov	r6,zero
811112e4:	000b883a 	mov	r5,zero
811112e8:	0009883a 	mov	r4,zero
811112ec:	11395100 	call	81139510 <OSTimeDlyHMSM>

				/* Transition to Config Mode (Ending the simulation) */
				/* Send a message to the NFEE Controller forcing the mode */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_CONFIG_FORCED, 0, 0 );
811112f0:	000d883a 	mov	r6,zero
811112f4:	000b883a 	mov	r5,zero
811112f8:	01002844 	movi	r4,161
811112fc:	1111e4c0 	call	81111e4c <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_CONFIG_FORCED, 0, 0 );
81111300:	000d883a 	mov	r6,zero
81111304:	000b883a 	mov	r5,zero
81111308:	01002844 	movi	r4,161
8111130c:	1111ff00 	call	81111ff0 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 250);
81111310:	01c03e84 	movi	r7,250
81111314:	000d883a 	mov	r6,zero
81111318:	000b883a 	mov	r5,zero
8111131c:	0009883a 	mov	r4,zero
81111320:	11395100 	call	81139510 <OSTimeDlyHMSM>

				pxMebC->eMode = sMebConfig;
81111324:	e0bffc17 	ldw	r2,-16(fp)
81111328:	00c000c4 	movi	r3,3
8111132c:	10c00115 	stw	r3,4(r2)
				break;
81111330:	00007006 	br	811114f4 <vSimMebTask+0x29c>
			case sMebToRun:
				#if DEBUG_ON
					debug(fp,"MEB Task: Run Mode\n");
				#endif
				/* Transition to Run Mode (Starting the Simulation) */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_RUN_FORCED, 0, 0 );
81111334:	000d883a 	mov	r6,zero
81111338:	000b883a 	mov	r5,zero
8111133c:	01002884 	movi	r4,162
81111340:	1111e4c0 	call	81111e4c <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_RUN_FORCED, 0, 0 );
81111344:	000d883a 	mov	r6,zero
81111348:	000b883a 	mov	r5,zero
8111134c:	01002884 	movi	r4,162
81111350:	1111ff00 	call	81111ff0 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);
81111354:	e0bffc17 	ldw	r2,-16(fp)
81111358:	1080050b 	ldhu	r2,20(r2)
8111135c:	10bfffcc 	andi	r2,r2,65535
81111360:	100f883a 	mov	r7,r2
81111364:	000d883a 	mov	r6,zero
81111368:	000b883a 	mov	r5,zero
8111136c:	0009883a 	mov	r4,zero
81111370:	11395100 	call	81139510 <OSTimeDlyHMSM>


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
81111374:	e03ffb05 	stb	zero,-20(fp)
81111378:	00001006 	br	811113bc <vSimMebTask+0x164>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
8111137c:	e0bffb03 	ldbu	r2,-20(fp)
81111380:	10809624 	muli	r2,r2,600
81111384:	10809b04 	addi	r2,r2,620
81111388:	e0fffc17 	ldw	r3,-16(fp)
8111138c:	1885883a 	add	r2,r3,r2
81111390:	1009883a 	mov	r4,r2
81111394:	11088d00 	call	811088d0 <bSpwcClearTimecode>
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
81111398:	e0bffb03 	ldbu	r2,-20(fp)
8111139c:	e0fffc17 	ldw	r3,-16(fp)
811113a0:	10809624 	muli	r2,r2,600
811113a4:	1885883a 	add	r2,r3,r2
811113a8:	10803c04 	addi	r2,r2,240
811113ac:	10000005 	stb	zero,0(r2)
				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
811113b0:	e0bffb03 	ldbu	r2,-20(fp)
811113b4:	10800044 	addi	r2,r2,1
811113b8:	e0bffb05 	stb	r2,-20(fp)
811113bc:	e0bffb03 	ldbu	r2,-20(fp)
811113c0:	103fee26 	beq	r2,zero,8111137c <__reset+0xfb0f137c>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
				}

				bSyncCtrReset();
811113c4:	110b3040 	call	8110b304 <bSyncCtrReset>
				vSyncClearCounter();
811113c8:	110acb40 	call	8110acb4 <vSyncClearCounter>
				bStartSync();
811113cc:	111889c0 	call	8111889c <bStartSync>

				vEvtChangeMebMode();
811113d0:	11173dc0 	call	811173dc <vEvtChangeMebMode>
				pxMebC->eMode = sMebRun;
811113d4:	e0bffc17 	ldw	r2,-16(fp)
811113d8:	00c00104 	movi	r3,4
811113dc:	10c00115 	stw	r3,4(r2)
				break;
811113e0:	00004406 	br	811114f4 <vSimMebTask+0x29c>


			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
811113e4:	d0a06817 	ldw	r2,-32352(gp)
811113e8:	e0fffe04 	addi	r3,fp,-8
811113ec:	180d883a 	mov	r6,r3
811113f0:	000b883a 	mov	r5,zero
811113f4:	1009883a 	mov	r4,r2
811113f8:	11366800 	call	81136680 <OSQPend>
811113fc:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81111400:	e0bffe03 	ldbu	r2,-8(fp)
81111404:	10803fcc 	andi	r2,r2,255
81111408:	10000e1e 	bne	r2,zero,81111444 <vSimMebTask+0x1ec>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
8111140c:	e0bffdc3 	ldbu	r2,-9(fp)
81111410:	10803fcc 	andi	r2,r2,255
81111414:	10800058 	cmpnei	r2,r2,1
81111418:	1000331e 	bne	r2,zero,811114e8 <vSimMebTask+0x290>
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
8111141c:	e0bffd83 	ldbu	r2,-10(fp)
81111420:	10803fcc 	andi	r2,r2,255
81111424:	10c00060 	cmpeqi	r3,r2,1
81111428:	1800031e 	bne	r3,zero,81111438 <vSimMebTask+0x1e0>
8111142c:	10803820 	cmpeqi	r2,r2,224
81111430:	1000061e 	bne	r2,zero,8111144c <vSimMebTask+0x1f4>
								break;
							default:
								#if DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
								#endif
								break;
81111434:	00000606 	br	81111450 <vSimMebTask+0x1f8>
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81111438:	e13ffc17 	ldw	r4,-16(fp)
8111143c:	11114f80 	call	811114f8 <vPusMebTask>
								break;
81111440:	00000306 	br	81111450 <vSimMebTask+0x1f8>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
						#endif
					}
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81111444:	11170b40 	call	811170b4 <vCouldNotGetCmdQueueMeb>
				}

				break;
81111448:	00002706 	br	811114e8 <vSimMebTask+0x290>
								break;
							case M_MASTER_SYNC:
								#if DEBUG_ON
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
								#endif
								break;
8111144c:	0001883a 	nop
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
81111450:	00002506 	br	811114e8 <vSimMebTask+0x290>

			case sMebRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81111454:	d0a06817 	ldw	r2,-32352(gp)
81111458:	e0fffe04 	addi	r3,fp,-8
8111145c:	180d883a 	mov	r6,r3
81111460:	000b883a 	mov	r5,zero
81111464:	1009883a 	mov	r4,r2
81111468:	11366800 	call	81136680 <OSQPend>
8111146c:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81111470:	e0bffe03 	ldbu	r2,-8(fp)
81111474:	10803fcc 	andi	r2,r2,255
81111478:	1000131e 	bne	r2,zero,811114c8 <vSimMebTask+0x270>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
8111147c:	e0bffdc3 	ldbu	r2,-9(fp)
81111480:	10803fcc 	andi	r2,r2,255
81111484:	10800058 	cmpnei	r2,r2,1
81111488:	1000191e 	bne	r2,zero,811114f0 <vSimMebTask+0x298>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
8111148c:	e0bffd83 	ldbu	r2,-10(fp)
81111490:	10803fcc 	andi	r2,r2,255
81111494:	10c03820 	cmpeqi	r3,r2,224
81111498:	1800081e 	bne	r3,zero,811114bc <vSimMebTask+0x264>
8111149c:	10c03860 	cmpeqi	r3,r2,225
811114a0:	18000b1e 	bne	r3,zero,811114d0 <vSimMebTask+0x278>
811114a4:	10800060 	cmpeqi	r2,r2,1
811114a8:	1000011e 	bne	r2,zero,811114b0 <vSimMebTask+0x258>
								break;
							default:
								#if DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command (%hhu)\n", uiCmdMeb.ucByte[2]);
								#endif
								break;
811114ac:	00000906 	br	811114d4 <vSimMebTask+0x27c>
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
811114b0:	e13ffc17 	ldw	r4,-16(fp)
811114b4:	11114f80 	call	811114f8 <vPusMebTask>
								break;
811114b8:	00000606 	br	811114d4 <vSimMebTask+0x27c>
							case M_MASTER_SYNC:
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);
811114bc:	e13ffc17 	ldw	r4,-16(fp)
811114c0:	11120dc0 	call	811120dc <vSwapMemmory>

									fprintf(fp,"MEB TASK:  Frame Number: %hhu \n ", ucFrameNumber);

								#endif

								break;
811114c4:	00000206 	br	811114d0 <vSimMebTask+0x278>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
811114c8:	11170b40 	call	811170b4 <vCouldNotGetCmdQueueMeb>
				}			
				break;
811114cc:	00000806 	br	811114f0 <vSimMebTask+0x298>

									fprintf(fp,"MEB TASK:  Frame Number: %hhu \n ", ucFrameNumber);

								#endif

								break;
811114d0:	0001883a 	nop

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
811114d4:	00000606 	br	811114f0 <vSimMebTask+0x298>
				#if DEBUG_ON
					debug(fp,"MEB Task: Unknow state, backing to Config Mode\n");
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
811114d8:	e0bffc17 	ldw	r2,-16(fp)
811114dc:	00c00044 	movi	r3,1
811114e0:	10c00115 	stw	r3,4(r2)
				break;
811114e4:	00000306 	br	811114f4 <vSimMebTask+0x29c>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
811114e8:	0001883a 	nop
811114ec:	003f6306 	br	8111127c <__reset+0xfb0f127c>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
811114f0:	0001883a 	nop
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
				break;
		}
	}
811114f4:	003f6106 	br	8111127c <__reset+0xfb0f127c>

811114f8 <vPusMebTask>:
}

void vPusMebTask( TSimucam_MEB *pxMebCLocal ) {
811114f8:	defffb04 	addi	sp,sp,-20
811114fc:	de00012e 	bgeu	sp,et,81111504 <vPusMebTask+0xc>
81111500:	003b68fa 	trap	3
81111504:	dfc00415 	stw	ra,16(sp)
81111508:	df000315 	stw	fp,12(sp)
8111150c:	df000304 	addi	fp,sp,12
81111510:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess;
	INT8U error_code;
	unsigned char ucIL;
	static tTMPus xPusLocal;

	bSuccess = FALSE;
81111514:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 2, &error_code);
81111518:	d0a07217 	ldw	r2,-32312(gp)
8111151c:	e0fffe44 	addi	r3,fp,-7
81111520:	180d883a 	mov	r6,r3
81111524:	01400084 	movi	r5,2
81111528:	1009883a 	mov	r4,r2
8111152c:	113556c0 	call	8113556c <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
81111530:	e0bffe43 	ldbu	r2,-7(fp)
81111534:	10803fcc 	andi	r2,r2,255
81111538:	10002c1e 	bne	r2,zero,811115ec <vPusMebTask+0xf4>

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
8111153c:	e03ffe05 	stb	zero,-8(fp)
81111540:	00002306 	br	811115d0 <vPusMebTask+0xd8>
	    {
            if ( xPus[ucIL].bInUse == TRUE ) {
81111544:	e0fffe03 	ldbu	r3,-8(fp)
81111548:	00a04574 	movhi	r2,33045
8111154c:	10a93904 	addi	r2,r2,-23324
81111550:	18c01524 	muli	r3,r3,84
81111554:	10c5883a 	add	r2,r2,r3
81111558:	10800104 	addi	r2,r2,4
8111155c:	10800017 	ldw	r2,0(r2)
81111560:	10800058 	cmpnei	r2,r2,1
81111564:	1000171e 	bne	r2,zero,811115c4 <vPusMebTask+0xcc>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[ucIL];
81111568:	e13ffe03 	ldbu	r4,-8(fp)
8111156c:	00e04534 	movhi	r3,33044
81111570:	18defc04 	addi	r3,r3,31728
81111574:	00a04574 	movhi	r2,33045
81111578:	10a93904 	addi	r2,r2,-23324
8111157c:	21001524 	muli	r4,r4,84
81111580:	1105883a 	add	r2,r2,r4
81111584:	1009883a 	mov	r4,r2
81111588:	00801504 	movi	r2,84
8111158c:	100d883a 	mov	r6,r2
81111590:	200b883a 	mov	r5,r4
81111594:	1809883a 	mov	r4,r3
81111598:	111abac0 	call	8111abac <memcpy>
            	xPus[ucIL].bInUse = FALSE;
8111159c:	e0fffe03 	ldbu	r3,-8(fp)
811115a0:	00a04574 	movhi	r2,33045
811115a4:	10a93904 	addi	r2,r2,-23324
811115a8:	18c01524 	muli	r3,r3,84
811115ac:	10c5883a 	add	r2,r2,r3
811115b0:	10800104 	addi	r2,r2,4
811115b4:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
811115b8:	00800044 	movi	r2,1
811115bc:	e0bffd15 	stw	r2,-12(fp)
                break;
811115c0:	00000606 	br	811115dc <vPusMebTask+0xe4>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 2, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
811115c4:	e0bffe03 	ldbu	r2,-8(fp)
811115c8:	10800044 	addi	r2,r2,1
811115cc:	e0bffe05 	stb	r2,-8(fp)
811115d0:	e0bffe03 	ldbu	r2,-8(fp)
811115d4:	10800130 	cmpltui	r2,r2,4
811115d8:	103fda1e 	bne	r2,zero,81111544 <__reset+0xfb0f1544>
            	xPus[ucIL].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
811115dc:	d0a07217 	ldw	r2,-32312(gp)
811115e0:	1009883a 	mov	r4,r2
811115e4:	1135b100 	call	81135b10 <OSMutexPost>
811115e8:	00000106 	br	811115f0 <vPusMebTask+0xf8>
	} else {
		vCouldNotGetMutexMebPus();
811115ec:	11170dc0 	call	811170dc <vCouldNotGetMutexMebPus>
	}

	if ( bSuccess ) {
811115f0:	e0bffd17 	ldw	r2,-12(fp)
811115f4:	10001126 	beq	r2,zero,8111163c <vPusMebTask+0x144>

		switch (pxMebCLocal->eMode) {
811115f8:	e0bfff17 	ldw	r2,-4(fp)
811115fc:	10800117 	ldw	r2,4(r2)
81111600:	10c000e0 	cmpeqi	r3,r2,3
81111604:	1800031e 	bne	r3,zero,81111614 <vPusMebTask+0x11c>
81111608:	10800120 	cmpeqi	r2,r2,4
8111160c:	1000061e 	bne	r2,zero,81111628 <vPusMebTask+0x130>
				break;
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
				break;
			default:
				break;
81111610:	00000a06 	br	8111163c <vPusMebTask+0x144>

	if ( bSuccess ) {

		switch (pxMebCLocal->eMode) {
			case sMebConfig:
				vPusMebInTaskConfigMode(pxMebCLocal, &xPusLocal);
81111614:	01604534 	movhi	r5,33044
81111618:	295efc04 	addi	r5,r5,31728
8111161c:	e13fff17 	ldw	r4,-4(fp)
81111620:	11116540 	call	81111654 <vPusMebInTaskConfigMode>
				break;
81111624:	00000506 	br	8111163c <vPusMebTask+0x144>
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
81111628:	01604534 	movhi	r5,33044
8111162c:	295efc04 	addi	r5,r5,31728
81111630:	e13fff17 	ldw	r4,-4(fp)
81111634:	11118fc0 	call	811118fc <vPusMebInTaskRunningMode>
				break;
81111638:	0001883a 	nop
			default:
				break;
		}
	}
}
8111163c:	0001883a 	nop
81111640:	e037883a 	mov	sp,fp
81111644:	dfc00117 	ldw	ra,4(sp)
81111648:	df000017 	ldw	fp,0(sp)
8111164c:	dec00204 	addi	sp,sp,8
81111650:	f800283a 	ret

81111654 <vPusMebInTaskConfigMode>:


/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81111654:	defffc04 	addi	sp,sp,-16
81111658:	de00012e 	bgeu	sp,et,81111660 <vPusMebInTaskConfigMode+0xc>
8111165c:	003b68fa 	trap	3
81111660:	dfc00315 	stw	ra,12(sp)
81111664:	df000215 	stw	fp,8(sp)
81111668:	df000204 	addi	fp,sp,8
8111166c:	e13ffe15 	stw	r4,-8(fp)
81111670:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81111674:	e0bfff17 	ldw	r2,-4(fp)
81111678:	1080030b 	ldhu	r2,12(r2)
8111167c:	10bfffcc 	andi	r2,r2,65535
81111680:	10c03ee0 	cmpeqi	r3,r2,251
81111684:	1800091e 	bne	r3,zero,811116ac <vPusMebInTaskConfigMode+0x58>
81111688:	10c03f20 	cmpeqi	r3,r2,252
8111168c:	18000b1e 	bne	r3,zero,811116bc <vPusMebInTaskConfigMode+0x68>
81111690:	10803ea0 	cmpeqi	r2,r2,250
81111694:	1000011e 	bne	r2,zero,8111169c <vPusMebInTaskConfigMode+0x48>
			break;
		default:
			#if DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
			#endif
			break;
81111698:	00000c06 	br	811116cc <vPusMebInTaskConfigMode+0x78>
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {

	switch (xPusL->usiType) {
		/* srv-Type = 250 */
		case 250:
			vPusType250conf(pxMebCLocal, xPusL);
8111169c:	e17fff17 	ldw	r5,-4(fp)
811116a0:	e13ffe17 	ldw	r4,-8(fp)
811116a4:	11116e40 	call	811116e4 <vPusType250conf>
			break;
811116a8:	00000806 	br	811116cc <vPusMebInTaskConfigMode+0x78>
		/* srv-Type = 251 */
		case 251:
			vPusType251conf(pxMebCLocal, xPusL);
811116ac:	e17fff17 	ldw	r5,-4(fp)
811116b0:	e13ffe17 	ldw	r4,-8(fp)
811116b4:	11117480 	call	81111748 <vPusType251conf>
			break;
811116b8:	00000406 	br	811116cc <vPusMebInTaskConfigMode+0x78>
		/* srv-Type = 252 */
		case 252:
			vPusType252conf(pxMebCLocal, xPusL);
811116bc:	e17fff17 	ldw	r5,-4(fp)
811116c0:	e13ffe17 	ldw	r4,-8(fp)
811116c4:	11117780 	call	81111778 <vPusType252conf>
			break;
811116c8:	0001883a 	nop
			#if DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
			#endif
			break;
	}
}
811116cc:	0001883a 	nop
811116d0:	e037883a 	mov	sp,fp
811116d4:	dfc00117 	ldw	ra,4(sp)
811116d8:	df000017 	ldw	fp,0(sp)
811116dc:	dec00204 	addi	sp,sp,8
811116e0:	f800283a 	ret

811116e4 <vPusType250conf>:

void vPusType250conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811116e4:	defffd04 	addi	sp,sp,-12
811116e8:	de00012e 	bgeu	sp,et,811116f0 <vPusType250conf+0xc>
811116ec:	003b68fa 	trap	3
811116f0:	df000215 	stw	fp,8(sp)
811116f4:	df000204 	addi	fp,sp,8
811116f8:	e13ffe15 	stw	r4,-8(fp)
811116fc:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81111700:	e0bfff17 	ldw	r2,-4(fp)
81111704:	1080038b 	ldhu	r2,14(r2)
81111708:	10bfffcc 	andi	r2,r2,65535
8111170c:	10c00f60 	cmpeqi	r3,r2,61
81111710:	1800031e 	bne	r3,zero,81111720 <vPusType250conf+0x3c>
81111714:	10800fa0 	cmpeqi	r2,r2,62
81111718:	1000051e 	bne	r2,zero,81111730 <vPusType250conf+0x4c>
		case 60:
		default:
			#if DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			#endif
			break;
8111171c:	00000506 	br	81111734 <vPusType250conf+0x50>
void vPusType250conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {

	switch (xPusL->usiSubType) {
		/* TC_SCAM_RUN */
		case 61:
			pxMebCLocal->eMode = sMebToRun;
81111720:	e0bffe17 	ldw	r2,-8(fp)
81111724:	00c00084 	movi	r3,2
81111728:	10c00115 	stw	r3,4(r2)
			break;
8111172c:	00000106 	br	81111734 <vPusType250conf+0x50>
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81111730:	0001883a 	nop
			#if DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			#endif
			break;
	}
}
81111734:	0001883a 	nop
81111738:	e037883a 	mov	sp,fp
8111173c:	df000017 	ldw	fp,0(sp)
81111740:	dec00104 	addi	sp,sp,4
81111744:	f800283a 	ret

81111748 <vPusType251conf>:

void vPusType251conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81111748:	defffd04 	addi	sp,sp,-12
8111174c:	de00012e 	bgeu	sp,et,81111754 <vPusType251conf+0xc>
81111750:	003b68fa 	trap	3
81111754:	df000215 	stw	fp,8(sp)
81111758:	df000204 	addi	fp,sp,8
8111175c:	e13ffe15 	stw	r4,-8(fp)
81111760:	e17fff15 	stw	r5,-4(fp)
	#if DEBUG_ON
		fprintf(fp, "MEB Task: Can't change the mode of the NFEE while MEB is Config mode\n\n" );
	#endif
}
81111764:	0001883a 	nop
81111768:	e037883a 	mov	sp,fp
8111176c:	df000017 	ldw	fp,0(sp)
81111770:	dec00104 	addi	sp,sp,4
81111774:	f800283a 	ret

81111778 <vPusType252conf>:

void vPusType252conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81111778:	defffa04 	addi	sp,sp,-24
8111177c:	de00012e 	bgeu	sp,et,81111784 <vPusType252conf+0xc>
81111780:	003b68fa 	trap	3
81111784:	dfc00515 	stw	ra,20(sp)
81111788:	df000415 	stw	fp,16(sp)
8111178c:	df000404 	addi	fp,sp,16
81111790:	e13ffd15 	stw	r4,-12(fp)
81111794:	e17ffe15 	stw	r5,-8(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81111798:	e0bffe17 	ldw	r2,-8(fp)
8111179c:	1080050b 	ldhu	r2,20(r2)
811117a0:	e0bffc0d 	sth	r2,-16(fp)
	switch (xPusL->usiSubType) {
811117a4:	e0bffe17 	ldw	r2,-8(fp)
811117a8:	1080038b 	ldhu	r2,14(r2)
811117ac:	10bfffcc 	andi	r2,r2,65535
811117b0:	108000a0 	cmpeqi	r2,r2,2
811117b4:	1000011e 	bne	r2,zero,811117bc <vPusType252conf+0x44>
			break;
		default:
			#if DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			#endif
			break;
811117b8:	00004a06 	br	811118e4 <vPusType252conf+0x16c>
		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */

			/* Disable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811117bc:	e0bffc0b 	ldhu	r2,-16(fp)
811117c0:	10809624 	muli	r2,r2,600
811117c4:	10805504 	addi	r2,r2,340
811117c8:	e0fffd17 	ldw	r3,-12(fp)
811117cc:	1885883a 	add	r2,r3,r2
811117d0:	1009883a 	mov	r4,r2
811117d4:	1105c140 	call	81105c14 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
811117d8:	e0bffc0b 	ldhu	r2,-16(fp)
811117dc:	e0fffd17 	ldw	r3,-12(fp)
811117e0:	10809624 	muli	r2,r2,600
811117e4:	1885883a 	add	r2,r3,r2
811117e8:	10806504 	addi	r2,r2,404
811117ec:	10000015 	stw	zero,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811117f0:	e0bffc0b 	ldhu	r2,-16(fp)
811117f4:	10809624 	muli	r2,r2,600
811117f8:	10805504 	addi	r2,r2,340
811117fc:	e0fffd17 	ldw	r3,-12(fp)
81111800:	1885883a 	add	r2,r3,r2
81111804:	1009883a 	mov	r4,r2
81111808:	1105b6c0 	call	81105b6c <bRmapSetIrqControl>

			/* Change the configuration */
			bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
8111180c:	e0bffc0b 	ldhu	r2,-16(fp)
81111810:	10809624 	muli	r2,r2,600
81111814:	10805504 	addi	r2,r2,340
81111818:	e0fffd17 	ldw	r3,-12(fp)
8111181c:	1885883a 	add	r2,r3,r2
81111820:	1009883a 	mov	r4,r2
81111824:	1105dfc0 	call	81105dfc <bRmapGetCodecConfig>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
81111828:	e0bffc0b 	ldhu	r2,-16(fp)
8111182c:	e0fffe17 	ldw	r3,-8(fp)
81111830:	18c00b0b 	ldhu	r3,44(r3)
81111834:	1809883a 	mov	r4,r3
81111838:	e0fffd17 	ldw	r3,-12(fp)
8111183c:	10809624 	muli	r2,r2,600
81111840:	1885883a 	add	r2,r3,r2
81111844:	10805604 	addi	r2,r2,344
81111848:	11000005 	stb	r4,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
8111184c:	e0bffc0b 	ldhu	r2,-16(fp)
81111850:	e0fffe17 	ldw	r3,-8(fp)
81111854:	18c0098b 	ldhu	r3,38(r3)
81111858:	1809883a 	mov	r4,r3
8111185c:	e0fffd17 	ldw	r3,-12(fp)
81111860:	10809624 	muli	r2,r2,600
81111864:	1885883a 	add	r2,r3,r2
81111868:	10805644 	addi	r2,r2,345
8111186c:	11000005 	stb	r4,0(r2)
			bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81111870:	e0bffc0b 	ldhu	r2,-16(fp)
81111874:	10809624 	muli	r2,r2,600
81111878:	10805504 	addi	r2,r2,340
8111187c:	e0fffd17 	ldw	r3,-12(fp)
81111880:	1885883a 	add	r2,r3,r2
81111884:	1009883a 	mov	r4,r2
81111888:	1105d240 	call	81105d24 <bRmapSetCodecConfig>


			/* Enable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
8111188c:	e0bffc0b 	ldhu	r2,-16(fp)
81111890:	10809624 	muli	r2,r2,600
81111894:	10805504 	addi	r2,r2,340
81111898:	e0fffd17 	ldw	r3,-12(fp)
8111189c:	1885883a 	add	r2,r3,r2
811118a0:	1009883a 	mov	r4,r2
811118a4:	1105c140 	call	81105c14 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
811118a8:	e0bffc0b 	ldhu	r2,-16(fp)
811118ac:	e0fffd17 	ldw	r3,-12(fp)
811118b0:	10809624 	muli	r2,r2,600
811118b4:	1885883a 	add	r2,r3,r2
811118b8:	10806504 	addi	r2,r2,404
811118bc:	00c00044 	movi	r3,1
811118c0:	10c00015 	stw	r3,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811118c4:	e0bffc0b 	ldhu	r2,-16(fp)
811118c8:	10809624 	muli	r2,r2,600
811118cc:	10805504 	addi	r2,r2,340
811118d0:	e0fffd17 	ldw	r3,-12(fp)
811118d4:	1885883a 	add	r2,r3,r2
811118d8:	1009883a 	mov	r4,r2
811118dc:	1105b6c0 	call	81105b6c <bRmapSetIrqControl>
			/* todo: Need to treat all the returns */
			#if DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
			#endif

			break;
811118e0:	0001883a 	nop
			#if DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			#endif
			break;
	}
}
811118e4:	0001883a 	nop
811118e8:	e037883a 	mov	sp,fp
811118ec:	dfc00117 	ldw	ra,4(sp)
811118f0:	df000017 	ldw	fp,0(sp)
811118f4:	dec00204 	addi	sp,sp,8
811118f8:	f800283a 	ret

811118fc <vPusMebInTaskRunningMode>:




/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811118fc:	defffc04 	addi	sp,sp,-16
81111900:	de00012e 	bgeu	sp,et,81111908 <vPusMebInTaskRunningMode+0xc>
81111904:	003b68fa 	trap	3
81111908:	dfc00315 	stw	ra,12(sp)
8111190c:	df000215 	stw	fp,8(sp)
81111910:	df000204 	addi	fp,sp,8
81111914:	e13ffe15 	stw	r4,-8(fp)
81111918:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
8111191c:	e0bfff17 	ldw	r2,-4(fp)
81111920:	1080030b 	ldhu	r2,12(r2)
81111924:	10bfffcc 	andi	r2,r2,65535
81111928:	10c03ee0 	cmpeqi	r3,r2,251
8111192c:	1800091e 	bne	r3,zero,81111954 <vPusMebInTaskRunningMode+0x58>
81111930:	10c03f20 	cmpeqi	r3,r2,252
81111934:	18000b1e 	bne	r3,zero,81111964 <vPusMebInTaskRunningMode+0x68>
81111938:	10803ea0 	cmpeqi	r2,r2,250
8111193c:	1000011e 	bne	r2,zero,81111944 <vPusMebInTaskRunningMode+0x48>
			break;
		default:
			#if DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
			#endif
			break;
81111940:	00000c06 	br	81111974 <vPusMebInTaskRunningMode+0x78>
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {

	switch (xPusL->usiType) {
		/* srv-Type = 250 */
		case 250:
			vPusType250run(pxMebCLocal, xPusL);
81111944:	e17fff17 	ldw	r5,-4(fp)
81111948:	e13ffe17 	ldw	r4,-8(fp)
8111194c:	111198c0 	call	8111198c <vPusType250run>
			break;
81111950:	00000806 	br	81111974 <vPusMebInTaskRunningMode+0x78>
		/* srv-Type = 251 */
		case 251:
			vPusType251run(pxMebCLocal, xPusL);
81111954:	e17fff17 	ldw	r5,-4(fp)
81111958:	e13ffe17 	ldw	r4,-8(fp)
8111195c:	11119f00 	call	811119f0 <vPusType251run>
			break;
81111960:	00000406 	br	81111974 <vPusMebInTaskRunningMode+0x78>
		/* srv-Type = 252 */
		case 252:
			vPusType252run(pxMebCLocal, xPusL);
81111964:	e17fff17 	ldw	r5,-4(fp)
81111968:	e13ffe17 	ldw	r4,-8(fp)
8111196c:	1111ae00 	call	81111ae0 <vPusType252run>
			break;
81111970:	0001883a 	nop
			#if DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
81111974:	0001883a 	nop
81111978:	e037883a 	mov	sp,fp
8111197c:	dfc00117 	ldw	ra,4(sp)
81111980:	df000017 	ldw	fp,0(sp)
81111984:	dec00204 	addi	sp,sp,8
81111988:	f800283a 	ret

8111198c <vPusType250run>:


void vPusType250run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
8111198c:	defffd04 	addi	sp,sp,-12
81111990:	de00012e 	bgeu	sp,et,81111998 <vPusType250run+0xc>
81111994:	003b68fa 	trap	3
81111998:	df000215 	stw	fp,8(sp)
8111199c:	df000204 	addi	fp,sp,8
811119a0:	e13ffe15 	stw	r4,-8(fp)
811119a4:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
811119a8:	e0bfff17 	ldw	r2,-4(fp)
811119ac:	1080038b 	ldhu	r2,14(r2)
811119b0:	10bfffcc 	andi	r2,r2,65535
811119b4:	10c00f20 	cmpeqi	r3,r2,60
811119b8:	1800031e 	bne	r3,zero,811119c8 <vPusType250run+0x3c>
811119bc:	10800fa0 	cmpeqi	r2,r2,62
811119c0:	1000051e 	bne	r2,zero,811119d8 <vPusType250run+0x4c>
		case 61:
		default:
			#if DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
811119c4:	00000506 	br	811119dc <vPusType250run+0x50>
void vPusType250run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {

	switch (xPusL->usiSubType) {
		/* TC_SCAM_CONFIG */
		case 60:
			pxMebCLocal->eMode = sMebToConfig;
811119c8:	e0bffe17 	ldw	r2,-8(fp)
811119cc:	00c00044 	movi	r3,1
811119d0:	10c00115 	stw	r3,4(r2)
			break;
811119d4:	00000106 	br	811119dc <vPusType250run+0x50>
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
811119d8:	0001883a 	nop
			#if DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
811119dc:	0001883a 	nop
811119e0:	e037883a 	mov	sp,fp
811119e4:	df000017 	ldw	fp,0(sp)
811119e8:	dec00104 	addi	sp,sp,4
811119ec:	f800283a 	ret

811119f0 <vPusType251run>:

void vPusType251run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811119f0:	defffb04 	addi	sp,sp,-20
811119f4:	de00012e 	bgeu	sp,et,811119fc <vPusType251run+0xc>
811119f8:	003b68fa 	trap	3
811119fc:	dfc00415 	stw	ra,16(sp)
81111a00:	df000315 	stw	fp,12(sp)
81111a04:	df000304 	addi	fp,sp,12
81111a08:	e13ffe15 	stw	r4,-8(fp)
81111a0c:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81111a10:	e0bfff17 	ldw	r2,-4(fp)
81111a14:	1080050b 	ldhu	r2,20(r2)
81111a18:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81111a1c:	e0bfff17 	ldw	r2,-4(fp)
81111a20:	1080038b 	ldhu	r2,14(r2)
81111a24:	10bfffcc 	andi	r2,r2,65535
81111a28:	10c000a0 	cmpeqi	r3,r2,2
81111a2c:	1800101e 	bne	r3,zero,81111a70 <vPusType251run+0x80>
81111a30:	10c00160 	cmpeqi	r3,r2,5
81111a34:	1800191e 	bne	r3,zero,81111a9c <vPusType251run+0xac>
81111a38:	10800060 	cmpeqi	r2,r2,1
81111a3c:	1000011e 	bne	r2,zero,81111a44 <vPusType251run+0x54>
		case 6:
		default:
			#if DEBUG_ON
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
			#endif
			break;
81111a40:	00002106 	br	81111ac8 <vPusType251run+0xd8>
	usiFeeInstL = xPusL->usiValues[0];
	switch (xPusL->usiSubType) {
		/* TC_SCAM_FEE_CONFIG_ENTER */
		case 1:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
81111a44:	e0bffd0b 	ldhu	r2,-12(fp)
81111a48:	10800444 	addi	r2,r2,17
81111a4c:	10803fcc 	andi	r2,r2,255
81111a50:	e0fffd0b 	ldhu	r3,-12(fp)
81111a54:	18c03fcc 	andi	r3,r3,255
81111a58:	180f883a 	mov	r7,r3
81111a5c:	000d883a 	mov	r6,zero
81111a60:	01400044 	movi	r5,1
81111a64:	1009883a 	mov	r4,r2
81111a68:	1111ed40 	call	81111ed4 <vSendCmdQToNFeeCTRL_GEN>
			break;
81111a6c:	00001606 	br	81111ac8 <vPusType251run+0xd8>
		/* TC_SCAM_FEE_STANDBY_ENTER */
		case 2:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
81111a70:	e0bffd0b 	ldhu	r2,-12(fp)
81111a74:	10800444 	addi	r2,r2,17
81111a78:	10803fcc 	andi	r2,r2,255
81111a7c:	e0fffd0b 	ldhu	r3,-12(fp)
81111a80:	18c03fcc 	andi	r3,r3,255
81111a84:	180f883a 	mov	r7,r3
81111a88:	000d883a 	mov	r6,zero
81111a8c:	01400104 	movi	r5,4
81111a90:	1009883a 	mov	r4,r2
81111a94:	1111ed40 	call	81111ed4 <vSendCmdQToNFeeCTRL_GEN>
			break;
81111a98:	00000b06 	br	81111ac8 <vPusType251run+0xd8>
		/* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
		case 5:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
81111a9c:	e0bffd0b 	ldhu	r2,-12(fp)
81111aa0:	10800444 	addi	r2,r2,17
81111aa4:	10803fcc 	andi	r2,r2,255
81111aa8:	e0fffd0b 	ldhu	r3,-12(fp)
81111aac:	18c03fcc 	andi	r3,r3,255
81111ab0:	180f883a 	mov	r7,r3
81111ab4:	000d883a 	mov	r6,zero
81111ab8:	01400204 	movi	r5,8
81111abc:	1009883a 	mov	r4,r2
81111ac0:	1111ed40 	call	81111ed4 <vSendCmdQToNFeeCTRL_GEN>
			break;
81111ac4:	0001883a 	nop
			#if DEBUG_ON
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
			#endif
			break;
	}
}
81111ac8:	0001883a 	nop
81111acc:	e037883a 	mov	sp,fp
81111ad0:	dfc00117 	ldw	ra,4(sp)
81111ad4:	df000017 	ldw	fp,0(sp)
81111ad8:	dec00204 	addi	sp,sp,8
81111adc:	f800283a 	ret

81111ae0 <vPusType252run>:

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81111ae0:	defffb04 	addi	sp,sp,-20
81111ae4:	de00012e 	bgeu	sp,et,81111aec <vPusType252run+0xc>
81111ae8:	003b68fa 	trap	3
81111aec:	dfc00415 	stw	ra,16(sp)
81111af0:	df000315 	stw	fp,12(sp)
81111af4:	df000304 	addi	fp,sp,12
81111af8:	e13ffe15 	stw	r4,-8(fp)
81111afc:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81111b00:	e0bfff17 	ldw	r2,-4(fp)
81111b04:	1080050b 	ldhu	r2,20(r2)
81111b08:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81111b0c:	e0bfff17 	ldw	r2,-4(fp)
81111b10:	1080038b 	ldhu	r2,14(r2)
81111b14:	10bfffcc 	andi	r2,r2,65535
81111b18:	10c000e0 	cmpeqi	r3,r2,3
81111b1c:	18000a1e 	bne	r3,zero,81111b48 <vPusType252run+0x68>
81111b20:	10c00108 	cmpgei	r3,r2,4
81111b24:	1800031e 	bne	r3,zero,81111b34 <vPusType252run+0x54>
81111b28:	108000a0 	cmpeqi	r2,r2,2
81111b2c:	10004a1e 	bne	r2,zero,81111c58 <vPusType252run+0x178>
			break;
		default:
			#if DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
81111b30:	00009e06 	br	81111dac <vPusType252run+0x2cc>

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
	switch (xPusL->usiSubType) {
81111b34:	10c00120 	cmpeqi	r3,r2,4
81111b38:	1800251e 	bne	r3,zero,81111bd0 <vPusType252run+0xf0>
81111b3c:	10800160 	cmpeqi	r2,r2,5
81111b40:	1000971e 	bne	r2,zero,81111da0 <vPusType252run+0x2c0>
			break;
		default:
			#if DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
81111b44:	00009906 	br	81111dac <vPusType252run+0x2cc>
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
	switch (xPusL->usiSubType) {
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81111b48:	e0bffd0b 	ldhu	r2,-12(fp)
81111b4c:	10809624 	muli	r2,r2,600
81111b50:	10809b04 	addi	r2,r2,620
81111b54:	e0fffe17 	ldw	r3,-8(fp)
81111b58:	1885883a 	add	r2,r3,r2
81111b5c:	1009883a 	mov	r4,r2
81111b60:	11085980 	call	81108598 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81111b64:	e0bffd0b 	ldhu	r2,-12(fp)
81111b68:	e0fffe17 	ldw	r3,-8(fp)
81111b6c:	10809624 	muli	r2,r2,600
81111b70:	1885883a 	add	r2,r3,r2
81111b74:	10809d04 	addi	r2,r2,628
81111b78:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
81111b7c:	e0bffd0b 	ldhu	r2,-12(fp)
81111b80:	e0fffe17 	ldw	r3,-8(fp)
81111b84:	10809624 	muli	r2,r2,600
81111b88:	1885883a 	add	r2,r3,r2
81111b8c:	10809c04 	addi	r2,r2,624
81111b90:	00c00044 	movi	r3,1
81111b94:	10c00015 	stw	r3,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
81111b98:	e0bffd0b 	ldhu	r2,-12(fp)
81111b9c:	e0fffe17 	ldw	r3,-8(fp)
81111ba0:	10809624 	muli	r2,r2,600
81111ba4:	1885883a 	add	r2,r3,r2
81111ba8:	10809e04 	addi	r2,r2,632
81111bac:	10000015 	stw	zero,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81111bb0:	e0bffd0b 	ldhu	r2,-12(fp)
81111bb4:	10809624 	muli	r2,r2,600
81111bb8:	10809b04 	addi	r2,r2,620
81111bbc:	e0fffe17 	ldw	r3,-8(fp)
81111bc0:	1885883a 	add	r2,r3,r2
81111bc4:	1009883a 	mov	r4,r2
81111bc8:	11084640 	call	81108464 <bSpwcSetLink>
			#if DEBUG_ON
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
			#endif

			break;
81111bcc:	00007706 	br	81111dac <vPusType252run+0x2cc>

		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81111bd0:	e0bffd0b 	ldhu	r2,-12(fp)
81111bd4:	10809624 	muli	r2,r2,600
81111bd8:	10809b04 	addi	r2,r2,620
81111bdc:	e0fffe17 	ldw	r3,-8(fp)
81111be0:	1885883a 	add	r2,r3,r2
81111be4:	1009883a 	mov	r4,r2
81111be8:	11085980 	call	81108598 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81111bec:	e0bffd0b 	ldhu	r2,-12(fp)
81111bf0:	e0fffe17 	ldw	r3,-8(fp)
81111bf4:	10809624 	muli	r2,r2,600
81111bf8:	1885883a 	add	r2,r3,r2
81111bfc:	10809d04 	addi	r2,r2,628
81111c00:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
81111c04:	e0bffd0b 	ldhu	r2,-12(fp)
81111c08:	e0fffe17 	ldw	r3,-8(fp)
81111c0c:	10809624 	muli	r2,r2,600
81111c10:	1885883a 	add	r2,r3,r2
81111c14:	10809c04 	addi	r2,r2,624
81111c18:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
81111c1c:	e0bffd0b 	ldhu	r2,-12(fp)
81111c20:	e0fffe17 	ldw	r3,-8(fp)
81111c24:	10809624 	muli	r2,r2,600
81111c28:	1885883a 	add	r2,r3,r2
81111c2c:	10809e04 	addi	r2,r2,632
81111c30:	00c00044 	movi	r3,1
81111c34:	10c00015 	stw	r3,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81111c38:	e0bffd0b 	ldhu	r2,-12(fp)
81111c3c:	10809624 	muli	r2,r2,600
81111c40:	10809b04 	addi	r2,r2,620
81111c44:	e0fffe17 	ldw	r3,-8(fp)
81111c48:	1885883a 	add	r2,r3,r2
81111c4c:	1009883a 	mov	r4,r2
81111c50:	11084640 	call	81108464 <bSpwcSetLink>
			#if DEBUG_ON
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
			#endif

			break;
81111c54:	00005506 	br	81111dac <vPusType252run+0x2cc>
			break;

		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */
			if ( pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xControl.eMode == sFeeConfig ) {
81111c58:	e0bffd0b 	ldhu	r2,-12(fp)
81111c5c:	e0fffe17 	ldw	r3,-8(fp)
81111c60:	10809624 	muli	r2,r2,600
81111c64:	1885883a 	add	r2,r3,r2
81111c68:	10803e04 	addi	r2,r2,248
81111c6c:	10800017 	ldw	r2,0(r2)
81111c70:	10800058 	cmpnei	r2,r2,1
81111c74:	10004c1e 	bne	r2,zero,81111da8 <vPusType252run+0x2c8>
				/* Disable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81111c78:	e0bffd0b 	ldhu	r2,-12(fp)
81111c7c:	10809624 	muli	r2,r2,600
81111c80:	10805504 	addi	r2,r2,340
81111c84:	e0fffe17 	ldw	r3,-8(fp)
81111c88:	1885883a 	add	r2,r3,r2
81111c8c:	1009883a 	mov	r4,r2
81111c90:	1105c140 	call	81105c14 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81111c94:	e0bffd0b 	ldhu	r2,-12(fp)
81111c98:	e0fffe17 	ldw	r3,-8(fp)
81111c9c:	10809624 	muli	r2,r2,600
81111ca0:	1885883a 	add	r2,r3,r2
81111ca4:	10806504 	addi	r2,r2,404
81111ca8:	10000015 	stw	zero,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81111cac:	e0bffd0b 	ldhu	r2,-12(fp)
81111cb0:	10809624 	muli	r2,r2,600
81111cb4:	10805504 	addi	r2,r2,340
81111cb8:	e0fffe17 	ldw	r3,-8(fp)
81111cbc:	1885883a 	add	r2,r3,r2
81111cc0:	1009883a 	mov	r4,r2
81111cc4:	1105b6c0 	call	81105b6c <bRmapSetIrqControl>

				/* Change the configuration */
				bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81111cc8:	e0bffd0b 	ldhu	r2,-12(fp)
81111ccc:	10809624 	muli	r2,r2,600
81111cd0:	10805504 	addi	r2,r2,340
81111cd4:	e0fffe17 	ldw	r3,-8(fp)
81111cd8:	1885883a 	add	r2,r3,r2
81111cdc:	1009883a 	mov	r4,r2
81111ce0:	1105dfc0 	call	81105dfc <bRmapGetCodecConfig>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
81111ce4:	e0bffd0b 	ldhu	r2,-12(fp)
81111ce8:	e0ffff17 	ldw	r3,-4(fp)
81111cec:	18c00b0b 	ldhu	r3,44(r3)
81111cf0:	1809883a 	mov	r4,r3
81111cf4:	e0fffe17 	ldw	r3,-8(fp)
81111cf8:	10809624 	muli	r2,r2,600
81111cfc:	1885883a 	add	r2,r3,r2
81111d00:	10805604 	addi	r2,r2,344
81111d04:	11000005 	stb	r4,0(r2)
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81111d08:	e0bffd0b 	ldhu	r2,-12(fp)
81111d0c:	e0ffff17 	ldw	r3,-4(fp)
81111d10:	18c0098b 	ldhu	r3,38(r3)
81111d14:	1809883a 	mov	r4,r3
81111d18:	e0fffe17 	ldw	r3,-8(fp)
81111d1c:	10809624 	muli	r2,r2,600
81111d20:	1885883a 	add	r2,r3,r2
81111d24:	10805644 	addi	r2,r2,345
81111d28:	11000005 	stb	r4,0(r2)
				bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81111d2c:	e0bffd0b 	ldhu	r2,-12(fp)
81111d30:	10809624 	muli	r2,r2,600
81111d34:	10805504 	addi	r2,r2,340
81111d38:	e0fffe17 	ldw	r3,-8(fp)
81111d3c:	1885883a 	add	r2,r3,r2
81111d40:	1009883a 	mov	r4,r2
81111d44:	1105d240 	call	81105d24 <bRmapSetCodecConfig>


				/* Enable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81111d48:	e0bffd0b 	ldhu	r2,-12(fp)
81111d4c:	10809624 	muli	r2,r2,600
81111d50:	10805504 	addi	r2,r2,340
81111d54:	e0fffe17 	ldw	r3,-8(fp)
81111d58:	1885883a 	add	r2,r3,r2
81111d5c:	1009883a 	mov	r4,r2
81111d60:	1105c140 	call	81105c14 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81111d64:	e0bffd0b 	ldhu	r2,-12(fp)
81111d68:	e0fffe17 	ldw	r3,-8(fp)
81111d6c:	10809624 	muli	r2,r2,600
81111d70:	1885883a 	add	r2,r3,r2
81111d74:	10806504 	addi	r2,r2,404
81111d78:	00c00044 	movi	r3,1
81111d7c:	10c00015 	stw	r3,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81111d80:	e0bffd0b 	ldhu	r2,-12(fp)
81111d84:	10809624 	muli	r2,r2,600
81111d88:	10805504 	addi	r2,r2,340
81111d8c:	e0fffe17 	ldw	r3,-8(fp)
81111d90:	1885883a 	add	r2,r3,r2
81111d94:	1009883a 	mov	r4,r2
81111d98:	1105b6c0 	call	81105b6c <bRmapSetIrqControl>

			/* todo: Need to treat all the returns */
			#if DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
			#endif
			break;
81111d9c:	00000206 	br	81111da8 <vPusType252run+0x2c8>

			break;

		case 5: /* TC_SCAM_SPW_LINK_RESET */
			/* todo:Do nothing, don't know what is reset spw link */
			break;
81111da0:	0001883a 	nop
81111da4:	00000106 	br	81111dac <vPusType252run+0x2cc>

			/* todo: Need to treat all the returns */
			#if DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
			#endif
			break;
81111da8:	0001883a 	nop
			#if DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
81111dac:	0001883a 	nop
81111db0:	e037883a 	mov	sp,fp
81111db4:	dfc00117 	ldw	ra,4(sp)
81111db8:	df000017 	ldw	fp,0(sp)
81111dbc:	dec00204 	addi	sp,sp,8
81111dc0:	f800283a 	ret

81111dc4 <vSendCmdQToNFeeCTRL>:



void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81111dc4:	defff904 	addi	sp,sp,-28
81111dc8:	de00012e 	bgeu	sp,et,81111dd0 <vSendCmdQToNFeeCTRL+0xc>
81111dcc:	003b68fa 	trap	3
81111dd0:	dfc00615 	stw	ra,24(sp)
81111dd4:	df000515 	stw	fp,20(sp)
81111dd8:	df000504 	addi	fp,sp,20
81111ddc:	2807883a 	mov	r3,r5
81111de0:	3005883a 	mov	r2,r6
81111de4:	e13ffd05 	stb	r4,-12(fp)
81111de8:	e0fffe05 	stb	r3,-8(fp)
81111dec:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81111df0:	00800404 	movi	r2,16
81111df4:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81111df8:	e0bffd03 	ldbu	r2,-12(fp)
81111dfc:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81111e00:	e0bffe03 	ldbu	r2,-8(fp)
81111e04:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81111e08:	e0bfff03 	ldbu	r2,-4(fp)
81111e0c:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81111e10:	d0a06f17 	ldw	r2,-32324(gp)
81111e14:	e0fffc17 	ldw	r3,-16(fp)
81111e18:	180b883a 	mov	r5,r3
81111e1c:	1009883a 	mov	r4,r2
81111e20:	1136a880 	call	81136a88 <OSQPost>
81111e24:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81111e28:	e0bffb03 	ldbu	r2,-20(fp)
81111e2c:	10000126 	beq	r2,zero,81111e34 <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
81111e30:	11172ec0 	call	811172ec <vFailSendMsgFeeCTRL>
	}
}
81111e34:	0001883a 	nop
81111e38:	e037883a 	mov	sp,fp
81111e3c:	dfc00117 	ldw	ra,4(sp)
81111e40:	df000017 	ldw	fp,0(sp)
81111e44:	dec00204 	addi	sp,sp,8
81111e48:	f800283a 	ret

81111e4c <vSendCmdQToNFeeCTRL_PRIO>:

void vSendCmdQToNFeeCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81111e4c:	defff904 	addi	sp,sp,-28
81111e50:	de00012e 	bgeu	sp,et,81111e58 <vSendCmdQToNFeeCTRL_PRIO+0xc>
81111e54:	003b68fa 	trap	3
81111e58:	dfc00615 	stw	ra,24(sp)
81111e5c:	df000515 	stw	fp,20(sp)
81111e60:	df000504 	addi	fp,sp,20
81111e64:	2807883a 	mov	r3,r5
81111e68:	3005883a 	mov	r2,r6
81111e6c:	e13ffd05 	stb	r4,-12(fp)
81111e70:	e0fffe05 	stb	r3,-8(fp)
81111e74:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81111e78:	00800404 	movi	r2,16
81111e7c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81111e80:	e0bffd03 	ldbu	r2,-12(fp)
81111e84:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81111e88:	e0bffe03 	ldbu	r2,-8(fp)
81111e8c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81111e90:	e0bfff03 	ldbu	r2,-4(fp)
81111e94:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPostFront(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81111e98:	d0a06f17 	ldw	r2,-32324(gp)
81111e9c:	e0fffc17 	ldw	r3,-16(fp)
81111ea0:	180b883a 	mov	r5,r3
81111ea4:	1009883a 	mov	r4,r2
81111ea8:	1136bf80 	call	81136bf8 <OSQPostFront>
81111eac:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81111eb0:	e0bffb03 	ldbu	r2,-20(fp)
81111eb4:	10000126 	beq	r2,zero,81111ebc <vSendCmdQToNFeeCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81111eb8:	11172ec0 	call	811172ec <vFailSendMsgFeeCTRL>
	}
}
81111ebc:	0001883a 	nop
81111ec0:	e037883a 	mov	sp,fp
81111ec4:	dfc00117 	ldw	ra,4(sp)
81111ec8:	df000017 	ldw	fp,0(sp)
81111ecc:	dec00204 	addi	sp,sp,8
81111ed0:	f800283a 	ret

81111ed4 <vSendCmdQToNFeeCTRL_GEN>:


/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81111ed4:	defff804 	addi	sp,sp,-32
81111ed8:	de00012e 	bgeu	sp,et,81111ee0 <vSendCmdQToNFeeCTRL_GEN+0xc>
81111edc:	003b68fa 	trap	3
81111ee0:	dfc00715 	stw	ra,28(sp)
81111ee4:	df000615 	stw	fp,24(sp)
81111ee8:	df000604 	addi	fp,sp,24
81111eec:	2011883a 	mov	r8,r4
81111ef0:	2809883a 	mov	r4,r5
81111ef4:	3007883a 	mov	r3,r6
81111ef8:	3805883a 	mov	r2,r7
81111efc:	e23ffc05 	stb	r8,-16(fp)
81111f00:	e13ffd05 	stb	r4,-12(fp)
81111f04:	e0fffe05 	stb	r3,-8(fp)
81111f08:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
81111f0c:	e0bffc03 	ldbu	r2,-16(fp)
81111f10:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81111f14:	e0bffd03 	ldbu	r2,-12(fp)
81111f18:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81111f1c:	e0bffe03 	ldbu	r2,-8(fp)
81111f20:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81111f24:	e0bfff03 	ldbu	r2,-4(fp)
81111f28:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81111f2c:	d0a06f17 	ldw	r2,-32324(gp)
81111f30:	e0fffb17 	ldw	r3,-20(fp)
81111f34:	180b883a 	mov	r5,r3
81111f38:	1009883a 	mov	r4,r2
81111f3c:	1136a880 	call	81136a88 <OSQPost>
81111f40:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81111f44:	e0bffa03 	ldbu	r2,-24(fp)
81111f48:	10000126 	beq	r2,zero,81111f50 <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
81111f4c:	11172ec0 	call	811172ec <vFailSendMsgFeeCTRL>
	}
}
81111f50:	0001883a 	nop
81111f54:	e037883a 	mov	sp,fp
81111f58:	dfc00117 	ldw	ra,4(sp)
81111f5c:	df000017 	ldw	fp,0(sp)
81111f60:	dec00204 	addi	sp,sp,8
81111f64:	f800283a 	ret

81111f68 <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81111f68:	defff904 	addi	sp,sp,-28
81111f6c:	de00012e 	bgeu	sp,et,81111f74 <vSendCmdQToDataCTRL+0xc>
81111f70:	003b68fa 	trap	3
81111f74:	dfc00615 	stw	ra,24(sp)
81111f78:	df000515 	stw	fp,20(sp)
81111f7c:	df000504 	addi	fp,sp,20
81111f80:	2807883a 	mov	r3,r5
81111f84:	3005883a 	mov	r2,r6
81111f88:	e13ffd05 	stb	r4,-12(fp)
81111f8c:	e0fffe05 	stb	r3,-8(fp)
81111f90:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
81111f94:	00800804 	movi	r2,32
81111f98:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81111f9c:	e0bffd03 	ldbu	r2,-12(fp)
81111fa0:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81111fa4:	e0bffe03 	ldbu	r2,-8(fp)
81111fa8:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81111fac:	e0bfff03 	ldbu	r2,-4(fp)
81111fb0:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81111fb4:	d0a05f17 	ldw	r2,-32388(gp)
81111fb8:	e0fffc17 	ldw	r3,-16(fp)
81111fbc:	180b883a 	mov	r5,r3
81111fc0:	1009883a 	mov	r4,r2
81111fc4:	1136a880 	call	81136a88 <OSQPost>
81111fc8:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81111fcc:	e0bffb03 	ldbu	r2,-20(fp)
81111fd0:	10000126 	beq	r2,zero,81111fd8 <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgDataCTRL();
81111fd4:	11173140 	call	81117314 <vFailSendMsgDataCTRL>
	}
}
81111fd8:	0001883a 	nop
81111fdc:	e037883a 	mov	sp,fp
81111fe0:	dfc00117 	ldw	ra,4(sp)
81111fe4:	df000017 	ldw	fp,0(sp)
81111fe8:	dec00204 	addi	sp,sp,8
81111fec:	f800283a 	ret

81111ff0 <vSendCmdQToDataCTRL_PRIO>:

void vSendCmdQToDataCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81111ff0:	defff904 	addi	sp,sp,-28
81111ff4:	de00012e 	bgeu	sp,et,81111ffc <vSendCmdQToDataCTRL_PRIO+0xc>
81111ff8:	003b68fa 	trap	3
81111ffc:	dfc00615 	stw	ra,24(sp)
81112000:	df000515 	stw	fp,20(sp)
81112004:	df000504 	addi	fp,sp,20
81112008:	2807883a 	mov	r3,r5
8111200c:	3005883a 	mov	r2,r6
81112010:	e13ffd05 	stb	r4,-12(fp)
81112014:	e0fffe05 	stb	r3,-8(fp)
81112018:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8111201c:	00800404 	movi	r2,16
81112020:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81112024:	e0bffd03 	ldbu	r2,-12(fp)
81112028:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8111202c:	e0bffe03 	ldbu	r2,-8(fp)
81112030:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81112034:	e0bfff03 	ldbu	r2,-4(fp)
81112038:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPostFront(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
8111203c:	d0a05f17 	ldw	r2,-32388(gp)
81112040:	e0fffc17 	ldw	r3,-16(fp)
81112044:	180b883a 	mov	r5,r3
81112048:	1009883a 	mov	r4,r2
8111204c:	1136bf80 	call	81136bf8 <OSQPostFront>
81112050:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81112054:	e0bffb03 	ldbu	r2,-20(fp)
81112058:	10000126 	beq	r2,zero,81112060 <vSendCmdQToDataCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
8111205c:	11172ec0 	call	811172ec <vFailSendMsgFeeCTRL>
	}
}
81112060:	0001883a 	nop
81112064:	e037883a 	mov	sp,fp
81112068:	dfc00117 	ldw	ra,4(sp)
8111206c:	df000017 	ldw	fp,0(sp)
81112070:	dec00204 	addi	sp,sp,8
81112074:	f800283a 	ret

81112078 <vMebInit>:


void vMebInit(TSimucam_MEB *pxMebCLocal) {
81112078:	defffc04 	addi	sp,sp,-16
8111207c:	de00012e 	bgeu	sp,et,81112084 <vMebInit+0xc>
81112080:	003b68fa 	trap	3
81112084:	dfc00315 	stw	ra,12(sp)
81112088:	df000215 	stw	fp,8(sp)
8111208c:	df000204 	addi	fp,sp,8
81112090:	e13fff15 	stw	r4,-4(fp)
	INT8U errorCodeL;

	pxMebCLocal->ucActualDDR = 0;
81112094:	e0bfff17 	ldw	r2,-4(fp)
81112098:	10000205 	stb	zero,8(r2)
	pxMebCLocal->ucNextDDR = 1;
8111209c:	e0bfff17 	ldw	r2,-4(fp)
811120a0:	00c00044 	movi	r3,1
811120a4:	10c00245 	stb	r3,9(r2)
	/* Flush all communication Queues */
	errorCodeL = OSQFlush(xMebQ);
811120a8:	d0a06817 	ldw	r2,-32352(gp)
811120ac:	1009883a 	mov	r4,r2
811120b0:	11365c00 	call	811365c0 <OSQFlush>
811120b4:	e0bffe05 	stb	r2,-8(fp)
	if ( errorCodeL != OS_NO_ERR ) {
811120b8:	e0bffe03 	ldbu	r2,-8(fp)
811120bc:	10000126 	beq	r2,zero,811120c4 <vMebInit+0x4c>
		vFailFlushMEBQueue();
811120c0:	111738c0 	call	8111738c <vFailFlushMEBQueue>
	}
}
811120c4:	0001883a 	nop
811120c8:	e037883a 	mov	sp,fp
811120cc:	dfc00117 	ldw	ra,4(sp)
811120d0:	df000017 	ldw	fp,0(sp)
811120d4:	dec00204 	addi	sp,sp,8
811120d8:	f800283a 	ret

811120dc <vSwapMemmory>:

/* Swap memory reference */
void vSwapMemmory(TSimucam_MEB *pxMebCLocal) {
811120dc:	defffe04 	addi	sp,sp,-8
811120e0:	de00012e 	bgeu	sp,et,811120e8 <vSwapMemmory+0xc>
811120e4:	003b68fa 	trap	3
811120e8:	df000115 	stw	fp,4(sp)
811120ec:	df000104 	addi	fp,sp,4
811120f0:	e13fff15 	stw	r4,-4(fp)

	pxMebCLocal->ucActualDDR = (pxMebCLocal->ucActualDDR + 1) % 2 ;
811120f4:	e0bfff17 	ldw	r2,-4(fp)
811120f8:	10800203 	ldbu	r2,8(r2)
811120fc:	10803fcc 	andi	r2,r2,255
81112100:	10c00044 	addi	r3,r2,1
81112104:	00a00034 	movhi	r2,32768
81112108:	10800044 	addi	r2,r2,1
8111210c:	1884703a 	and	r2,r3,r2
81112110:	1000040e 	bge	r2,zero,81112124 <vSwapMemmory+0x48>
81112114:	10bfffc4 	addi	r2,r2,-1
81112118:	00ffff84 	movi	r3,-2
8111211c:	10c4b03a 	or	r2,r2,r3
81112120:	10800044 	addi	r2,r2,1
81112124:	1007883a 	mov	r3,r2
81112128:	e0bfff17 	ldw	r2,-4(fp)
8111212c:	10c00205 	stb	r3,8(r2)
	pxMebCLocal->ucNextDDR = (pxMebCLocal->ucNextDDR + 1) % 2 ;
81112130:	e0bfff17 	ldw	r2,-4(fp)
81112134:	10800243 	ldbu	r2,9(r2)
81112138:	10803fcc 	andi	r2,r2,255
8111213c:	10c00044 	addi	r3,r2,1
81112140:	00a00034 	movhi	r2,32768
81112144:	10800044 	addi	r2,r2,1
81112148:	1884703a 	and	r2,r3,r2
8111214c:	1000040e 	bge	r2,zero,81112160 <vSwapMemmory+0x84>
81112150:	10bfffc4 	addi	r2,r2,-1
81112154:	00ffff84 	movi	r3,-2
81112158:	10c4b03a 	or	r2,r2,r3
8111215c:	10800044 	addi	r2,r2,1
81112160:	1007883a 	mov	r3,r2
81112164:	e0bfff17 	ldw	r2,-4(fp)
81112168:	10c00245 	stb	r3,9(r2)

}
8111216c:	0001883a 	nop
81112170:	e037883a 	mov	sp,fp
81112174:	df000017 	ldw	fp,0(sp)
81112178:	dec00104 	addi	sp,sp,4
8111217c:	f800283a 	ret

81112180 <vReleaseSyncMessages>:

/* After stop the Sync signal generation, maybe some FEE task could be locked waiting for this signal. So we send to everyone, and after that they will flush the queue */
void vReleaseSyncMessages(void) {
81112180:	defffc04 	addi	sp,sp,-16
81112184:	de00012e 	bgeu	sp,et,8111218c <vReleaseSyncMessages+0xc>
81112188:	003b68fa 	trap	3
8111218c:	dfc00315 	stw	ra,12(sp)
81112190:	df000215 	stw	fp,8(sp)
81112194:	df000204 	addi	fp,sp,8
	unsigned char ucIL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ulWord = 0;
81112198:	e03fff15 	stw	zero,-4(fp)
	uiCmdtoSend.ucByte[2] = M_SYNC;
8111219c:	00bff844 	movi	r2,-31
811121a0:	e0bfff85 	stb	r2,-2(fp)
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
811121a4:	e03ffe05 	stb	zero,-8(fp)
811121a8:	00001606 	br	81112204 <vReleaseSyncMessages+0x84>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
811121ac:	e0bffe03 	ldbu	r2,-8(fp)
811121b0:	10800444 	addi	r2,r2,17
811121b4:	e0bfffc5 	stb	r2,-1(fp)
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
811121b8:	e0bffe03 	ldbu	r2,-8(fp)
811121bc:	1085883a 	add	r2,r2,r2
811121c0:	1087883a 	add	r3,r2,r2
811121c4:	d0a05c04 	addi	r2,gp,-32400
811121c8:	1885883a 	add	r2,r3,r2
811121cc:	10800017 	ldw	r2,0(r2)
811121d0:	e0ffff17 	ldw	r3,-4(fp)
811121d4:	180b883a 	mov	r5,r3
811121d8:	1009883a 	mov	r4,r2
811121dc:	1136a880 	call	81136a88 <OSQPost>
811121e0:	e0bffe45 	stb	r2,-7(fp)
		if ( error_codel != OS_ERR_NONE ) {
811121e4:	e0bffe43 	ldbu	r2,-7(fp)
811121e8:	10000326 	beq	r2,zero,811121f8 <vReleaseSyncMessages+0x78>
			vFailSendMsgSync( ucIL );
811121ec:	e0bffe03 	ldbu	r2,-8(fp)
811121f0:	1009883a 	mov	r4,r2
811121f4:	11172640 	call	81117264 <vFailSendMsgSync>

	uiCmdtoSend.ulWord = 0;
	uiCmdtoSend.ucByte[2] = M_SYNC;
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
811121f8:	e0bffe03 	ldbu	r2,-8(fp)
811121fc:	10800044 	addi	r2,r2,1
81112200:	e0bffe05 	stb	r2,-8(fp)
81112204:	e0bffe03 	ldbu	r2,-8(fp)
81112208:	103fe826 	beq	r2,zero,811121ac <__reset+0xfb0f21ac>
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}
}
8111220c:	0001883a 	nop
81112210:	e037883a 	mov	sp,fp
81112214:	dfc00117 	ldw	ra,4(sp)
81112218:	df000017 	ldw	fp,0(sp)
8111221c:	dec00204 	addi	sp,sp,8
81112220:	f800283a 	ret

81112224 <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
81112224:	defffc04 	addi	sp,sp,-16
81112228:	de00012e 	bgeu	sp,et,81112230 <vTimeoutCheckerTaskv2+0xc>
8111222c:	003b68fa 	trap	3
81112230:	dfc00315 	stw	ra,12(sp)
81112234:	df000215 	stw	fp,8(sp)
81112238:	df000204 	addi	fp,sp,8
8111223c:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81112240:	e03ffe05 	stb	zero,-8(fp)
    #if DEBUG_ON
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
81112244:	d0a06617 	ldw	r2,-32360(gp)
81112248:	e1bffe04 	addi	r6,fp,-8
8111224c:	000b883a 	mov	r5,zero
81112250:	1009883a 	mov	r4,r2
81112254:	11375780 	call	81137578 <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
81112258:	e0bffe03 	ldbu	r2,-8(fp)
8111225c:	10803fcc 	andi	r2,r2,255
81112260:	1000021e 	bne	r2,zero,8111226c <vTimeoutCheckerTaskv2+0x48>
            /* Just check the restransmission buffer */
            vCheck();
81112264:	11122740 	call	81112274 <vCheck>
81112268:	003ff606 	br	81112244 <__reset+0xfb0f2244>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
8111226c:	1116c880 	call	81116c88 <vFailGetBlockingSemTimeoutTask>
        }
    }
81112270:	003ff406 	br	81112244 <__reset+0xfb0f2244>

81112274 <vCheck>:
}


void vCheck( void ) {
81112274:	defffd04 	addi	sp,sp,-12
81112278:	de00012e 	bgeu	sp,et,81112280 <vCheck+0xc>
8111227c:	003b68fa 	trap	3
81112280:	dfc00215 	stw	ra,8(sp)
81112284:	df000115 	stw	fp,4(sp)
81112288:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
8111228c:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
81112290:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
81112294:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81112298:	d0a06783 	ldbu	r2,-32354(gp)
8111229c:	10803fcc 	andi	r2,r2,255
811122a0:	10800218 	cmpnei	r2,r2,8
811122a4:	1000021e 	bne	r2,zero,811122b0 <vCheck+0x3c>
811122a8:	00c00104 	movi	r3,4
811122ac:	00000106 	br	811122b4 <vCheck+0x40>
811122b0:	0007883a 	mov	r3,zero
811122b4:	d0a07403 	ldbu	r2,-32304(gp)
811122b8:	10803fcc 	andi	r2,r2,255
811122bc:	10800218 	cmpnei	r2,r2,8
811122c0:	1000021e 	bne	r2,zero,811122cc <vCheck+0x58>
811122c4:	00800084 	movi	r2,2
811122c8:	00000106 	br	811122d0 <vCheck+0x5c>
811122cc:	0005883a 	mov	r2,zero
811122d0:	1884b03a 	or	r2,r3,r2
811122d4:	1007883a 	mov	r3,r2
811122d8:	d0a07443 	ldbu	r2,-32303(gp)
811122dc:	10803fcc 	andi	r2,r2,255
811122e0:	108001a0 	cmpeqi	r2,r2,6
811122e4:	1884b03a 	or	r2,r3,r2
811122e8:	1007883a 	mov	r3,r2
811122ec:	e0bfff03 	ldbu	r2,-4(fp)
811122f0:	1884b03a 	or	r2,r3,r2
811122f4:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
811122f8:	e0bfff03 	ldbu	r2,-4(fp)
811122fc:	108001d8 	cmpnei	r2,r2,7
81112300:	10002f26 	beq	r2,zero,811123c0 <vCheck+0x14c>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
81112304:	d0a07317 	ldw	r2,-32308(gp)
81112308:	e0ffff44 	addi	r3,fp,-3
8111230c:	180d883a 	mov	r6,r3
81112310:	000b883a 	mov	r5,zero
81112314:	1009883a 	mov	r4,r2
81112318:	113556c0 	call	8113556c <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
8111231c:	e0bfff43 	ldbu	r2,-3(fp)
81112320:	10803fcc 	andi	r2,r2,255
81112324:	1000281e 	bne	r2,zero,811123c8 <vCheck+0x154>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81112328:	e0bfff03 	ldbu	r2,-4(fp)
8111232c:	1080004c 	andi	r2,r2,1
81112330:	10803fcc 	andi	r2,r2,255
81112334:	1000021e 	bne	r2,zero,81112340 <vCheck+0xcc>
        vCheckRetransmission128();
81112338:	11123e00 	call	811123e0 <vCheckRetransmission128>
8111233c:	00000506 	br	81112354 <vCheck+0xe0>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
81112340:	01800604 	movi	r6,24
81112344:	000b883a 	mov	r5,zero
81112348:	01204574 	movhi	r4,33045
8111234c:	210cdd04 	addi	r4,r4,13172
81112350:	111acfc0 	call	8111acfc <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
81112354:	e0bfff03 	ldbu	r2,-4(fp)
81112358:	1080008c 	andi	r2,r2,2
8111235c:	10803fcc 	andi	r2,r2,255
81112360:	1000021e 	bne	r2,zero,8111236c <vCheck+0xf8>
        vCheckRetransmission64();
81112364:	11126640 	call	81112664 <vCheckRetransmission64>
81112368:	00000506 	br	81112380 <vCheck+0x10c>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
8111236c:	01800804 	movi	r6,32
81112370:	000b883a 	mov	r5,zero
81112374:	01204574 	movhi	r4,33045
81112378:	210ce304 	addi	r4,r4,13196
8111237c:	111acfc0 	call	8111acfc <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
81112380:	e0bfff03 	ldbu	r2,-4(fp)
81112384:	1080010c 	andi	r2,r2,4
81112388:	10803fcc 	andi	r2,r2,255
8111238c:	1000021e 	bne	r2,zero,81112398 <vCheck+0x124>
        vCheckRetransmission32();
81112390:	11128f00 	call	811128f0 <vCheckRetransmission32>
81112394:	00000506 	br	811123ac <vCheck+0x138>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
81112398:	01800804 	movi	r6,32
8111239c:	000b883a 	mov	r5,zero
811123a0:	01204574 	movhi	r4,33045
811123a4:	210ceb04 	addi	r4,r4,13228
811123a8:	111acfc0 	call	8111acfc <memset>


    OSMutexPost(xTxUARTMutex);
811123ac:	d0a07317 	ldw	r2,-32308(gp)
811123b0:	1009883a 	mov	r4,r2
811123b4:	1135b100 	call	81135b10 <OSMutexPost>

    return;
811123b8:	0001883a 	nop
811123bc:	00000306 	br	811123cc <vCheck+0x158>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
811123c0:	0001883a 	nop
811123c4:	00000106 	br	811123cc <vCheck+0x158>
    if ( ucErrorCode != OS_NO_ERR ) {
        /* Should never get here, is a blocking operation */
		#if DEBUG_ON
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
		#endif
        return;
811123c8:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
811123cc:	e037883a 	mov	sp,fp
811123d0:	dfc00117 	ldw	ra,4(sp)
811123d4:	df000017 	ldw	fp,0(sp)
811123d8:	dec00204 	addi	sp,sp,8
811123dc:	f800283a 	ret

811123e0 <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
811123e0:	defffd04 	addi	sp,sp,-12
811123e4:	de00012e 	bgeu	sp,et,811123ec <vCheckRetransmission128+0xc>
811123e8:	003b68fa 	trap	3
811123ec:	dfc00215 	stw	ra,8(sp)
811123f0:	df000115 	stw	fp,4(sp)
811123f4:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
811123f8:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
811123fc:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81112400:	d0a06d17 	ldw	r2,-32332(gp)
81112404:	e0ffff44 	addi	r3,fp,-3
81112408:	180b883a 	mov	r5,r3
8111240c:	1009883a 	mov	r4,r2
81112410:	1134eec0 	call	81134eec <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81112414:	e0bfff43 	ldbu	r2,-3(fp)
81112418:	10803fcc 	andi	r2,r2,255
8111241c:	10008b1e 	bne	r2,zero,8111264c <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81112420:	e03fff05 	stb	zero,-4(fp)
81112424:	00008106 	br	8111262c <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
81112428:	e0ffff03 	ldbu	r3,-4(fp)
8111242c:	00a04574 	movhi	r2,33045
81112430:	108cdd04 	addi	r2,r2,13172
81112434:	18c7883a 	add	r3,r3,r3
81112438:	18c7883a 	add	r3,r3,r3
8111243c:	10c5883a 	add	r2,r2,r3
81112440:	10800017 	ldw	r2,0(r2)
81112444:	10800058 	cmpnei	r2,r2,1
81112448:	1000751e 	bne	r2,zero,81112620 <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
8111244c:	e0ffff03 	ldbu	r3,-4(fp)
81112450:	00a04574 	movhi	r2,33045
81112454:	108cfb04 	addi	r2,r2,13292
81112458:	18c02324 	muli	r3,r3,140
8111245c:	10c5883a 	add	r2,r2,r3
81112460:	10802004 	addi	r2,r2,128
81112464:	10800017 	ldw	r2,0(r2)
81112468:	10800058 	cmpnei	r2,r2,1
8111246c:	1000211e 	bne	r2,zero,811124f4 <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
81112470:	e0ffff03 	ldbu	r3,-4(fp)
81112474:	00a04574 	movhi	r2,33045
81112478:	108cfb04 	addi	r2,r2,13292
8111247c:	19002324 	muli	r4,r3,140
81112480:	1105883a 	add	r2,r2,r4
81112484:	10802184 	addi	r2,r2,134
81112488:	1080000b 	ldhu	r2,0(r2)
8111248c:	10800044 	addi	r2,r2,1
81112490:	100b883a 	mov	r5,r2
81112494:	00a04574 	movhi	r2,33045
81112498:	108cfb04 	addi	r2,r2,13292
8111249c:	19002324 	muli	r4,r3,140
811124a0:	1105883a 	add	r2,r2,r4
811124a4:	10802184 	addi	r2,r2,134
811124a8:	1140000d 	sth	r5,0(r2)
811124ac:	00a04574 	movhi	r2,33045
811124b0:	108cfb04 	addi	r2,r2,13292
811124b4:	18c02324 	muli	r3,r3,140
811124b8:	10c5883a 	add	r2,r2,r3
811124bc:	10802184 	addi	r2,r2,134
811124c0:	1080000b 	ldhu	r2,0(r2)
811124c4:	10bfffcc 	andi	r2,r2,65535
811124c8:	10a0001c 	xori	r2,r2,32768
811124cc:	10a00004 	addi	r2,r2,-32768
811124d0:	10800090 	cmplti	r2,r2,2
811124d4:	1000071e 	bne	r2,zero,811124f4 <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
811124d8:	e0ffff03 	ldbu	r3,-4(fp)
811124dc:	00a04574 	movhi	r2,33045
811124e0:	108cfb04 	addi	r2,r2,13292
811124e4:	18c02324 	muli	r3,r3,140
811124e8:	10c5883a 	add	r2,r2,r3
811124ec:	10802004 	addi	r2,r2,128
811124f0:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
811124f4:	e0ffff03 	ldbu	r3,-4(fp)
811124f8:	00a04574 	movhi	r2,33045
811124fc:	108cfb04 	addi	r2,r2,13292
81112500:	18c02324 	muli	r3,r3,140
81112504:	10c5883a 	add	r2,r2,r3
81112508:	10802004 	addi	r2,r2,128
8111250c:	10800017 	ldw	r2,0(r2)
81112510:	1000431e 	bne	r2,zero,81112620 <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
81112514:	e0bfff03 	ldbu	r2,-4(fp)
81112518:	10c02324 	muli	r3,r2,140
8111251c:	00a04574 	movhi	r2,33045
81112520:	108cfb04 	addi	r2,r2,13292
81112524:	1885883a 	add	r2,r3,r2
81112528:	1009883a 	mov	r4,r2
8111252c:	111af680 	call	8111af68 <puts>
                xBuffer128[ucIL].bSent = TRUE;
81112530:	e0ffff03 	ldbu	r3,-4(fp)
81112534:	00a04574 	movhi	r2,33045
81112538:	108cfb04 	addi	r2,r2,13292
8111253c:	18c02324 	muli	r3,r3,140
81112540:	10c5883a 	add	r2,r2,r3
81112544:	10802004 	addi	r2,r2,128
81112548:	00c00044 	movi	r3,1
8111254c:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
81112550:	e0ffff03 	ldbu	r3,-4(fp)
81112554:	00a04574 	movhi	r2,33045
81112558:	108cfb04 	addi	r2,r2,13292
8111255c:	18c02324 	muli	r3,r3,140
81112560:	10c5883a 	add	r2,r2,r3
81112564:	10802184 	addi	r2,r2,134
81112568:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
8111256c:	e0ffff03 	ldbu	r3,-4(fp)
81112570:	00a04574 	movhi	r2,33045
81112574:	108cfb04 	addi	r2,r2,13292
81112578:	19002324 	muli	r4,r3,140
8111257c:	1105883a 	add	r2,r2,r4
81112580:	10802204 	addi	r2,r2,136
81112584:	10800003 	ldbu	r2,0(r2)
81112588:	10800044 	addi	r2,r2,1
8111258c:	100b883a 	mov	r5,r2
81112590:	00a04574 	movhi	r2,33045
81112594:	108cfb04 	addi	r2,r2,13292
81112598:	19002324 	muli	r4,r3,140
8111259c:	1105883a 	add	r2,r2,r4
811125a0:	10802204 	addi	r2,r2,136
811125a4:	11400005 	stb	r5,0(r2)
811125a8:	00a04574 	movhi	r2,33045
811125ac:	108cfb04 	addi	r2,r2,13292
811125b0:	18c02324 	muli	r3,r3,140
811125b4:	10c5883a 	add	r2,r2,r3
811125b8:	10802204 	addi	r2,r2,136
811125bc:	10800003 	ldbu	r2,0(r2)
811125c0:	10803fcc 	andi	r2,r2,255
811125c4:	108000b0 	cmpltui	r2,r2,2
811125c8:	1000151e 	bne	r2,zero,81112620 <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
811125cc:	e0ffff03 	ldbu	r3,-4(fp)
811125d0:	00a04574 	movhi	r2,33045
811125d4:	108cdd04 	addi	r2,r2,13172
811125d8:	18c7883a 	add	r3,r3,r3
811125dc:	18c7883a 	add	r3,r3,r3
811125e0:	10c5883a 	add	r2,r2,r3
811125e4:	10000015 	stw	zero,0(r2)
                    SemCount128++;
811125e8:	d0a07443 	ldbu	r2,-32303(gp)
811125ec:	10800044 	addi	r2,r2,1
811125f0:	d0a07445 	stb	r2,-32303(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
811125f4:	d0a06217 	ldw	r2,-32376(gp)
811125f8:	1009883a 	mov	r4,r2
811125fc:	11379000 	call	81137900 <OSSemPost>
81112600:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81112604:	e0bfff43 	ldbu	r2,-3(fp)
81112608:	10803fcc 	andi	r2,r2,255
8111260c:	10000426 	beq	r2,zero,81112620 <vCheckRetransmission128+0x240>
                        SemCount128--;
81112610:	d0a07443 	ldbu	r2,-32303(gp)
81112614:	10bfffc4 	addi	r2,r2,-1
81112618:	d0a07445 	stb	r2,-32303(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
8111261c:	11169900 	call	81116990 <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81112620:	e0bfff03 	ldbu	r2,-4(fp)
81112624:	10800044 	addi	r2,r2,1
81112628:	e0bfff05 	stb	r2,-4(fp)
8111262c:	e0bfff03 	ldbu	r2,-4(fp)
81112630:	108001b0 	cmpltui	r2,r2,6
81112634:	103f7c1e 	bne	r2,zero,81112428 <__reset+0xfb0f2428>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
81112638:	d0a06d17 	ldw	r2,-32332(gp)
8111263c:	1009883a 	mov	r4,r2
81112640:	1135b100 	call	81135b10 <OSMutexPost>

    return;
81112644:	0001883a 	nop
81112648:	00000106 	br	81112650 <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
8111264c:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
81112650:	e037883a 	mov	sp,fp
81112654:	dfc00117 	ldw	ra,4(sp)
81112658:	df000017 	ldw	fp,0(sp)
8111265c:	dec00204 	addi	sp,sp,8
81112660:	f800283a 	ret

81112664 <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
81112664:	defffd04 	addi	sp,sp,-12
81112668:	de00012e 	bgeu	sp,et,81112670 <vCheckRetransmission64+0xc>
8111266c:	003b68fa 	trap	3
81112670:	dfc00215 	stw	ra,8(sp)
81112674:	df000115 	stw	fp,4(sp)
81112678:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
8111267c:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81112680:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81112684:	d0a07017 	ldw	r2,-32320(gp)
81112688:	e0ffff44 	addi	r3,fp,-3
8111268c:	180b883a 	mov	r5,r3
81112690:	1009883a 	mov	r4,r2
81112694:	1134eec0 	call	81134eec <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81112698:	e0bfff43 	ldbu	r2,-3(fp)
8111269c:	10803fcc 	andi	r2,r2,255
811126a0:	10008d1e 	bne	r2,zero,811128d8 <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
811126a4:	e03fff05 	stb	zero,-4(fp)
811126a8:	00008306 	br	811128b8 <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
811126ac:	e0ffff03 	ldbu	r3,-4(fp)
811126b0:	00a04574 	movhi	r2,33045
811126b4:	108cdd04 	addi	r2,r2,13172
811126b8:	18c00184 	addi	r3,r3,6
811126bc:	18c7883a 	add	r3,r3,r3
811126c0:	18c7883a 	add	r3,r3,r3
811126c4:	10c5883a 	add	r2,r2,r3
811126c8:	10800017 	ldw	r2,0(r2)
811126cc:	10800058 	cmpnei	r2,r2,1
811126d0:	1000761e 	bne	r2,zero,811128ac <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
811126d4:	e0ffff03 	ldbu	r3,-4(fp)
811126d8:	00a04574 	movhi	r2,33045
811126dc:	10a8a104 	addi	r2,r2,-23932
811126e0:	18c01324 	muli	r3,r3,76
811126e4:	10c5883a 	add	r2,r2,r3
811126e8:	10801004 	addi	r2,r2,64
811126ec:	10800017 	ldw	r2,0(r2)
811126f0:	10800058 	cmpnei	r2,r2,1
811126f4:	1000211e 	bne	r2,zero,8111277c <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
811126f8:	e0ffff03 	ldbu	r3,-4(fp)
811126fc:	00a04574 	movhi	r2,33045
81112700:	10a8a104 	addi	r2,r2,-23932
81112704:	19001324 	muli	r4,r3,76
81112708:	1105883a 	add	r2,r2,r4
8111270c:	10801184 	addi	r2,r2,70
81112710:	1080000b 	ldhu	r2,0(r2)
81112714:	10800044 	addi	r2,r2,1
81112718:	100b883a 	mov	r5,r2
8111271c:	00a04574 	movhi	r2,33045
81112720:	10a8a104 	addi	r2,r2,-23932
81112724:	19001324 	muli	r4,r3,76
81112728:	1105883a 	add	r2,r2,r4
8111272c:	10801184 	addi	r2,r2,70
81112730:	1140000d 	sth	r5,0(r2)
81112734:	00a04574 	movhi	r2,33045
81112738:	10a8a104 	addi	r2,r2,-23932
8111273c:	18c01324 	muli	r3,r3,76
81112740:	10c5883a 	add	r2,r2,r3
81112744:	10801184 	addi	r2,r2,70
81112748:	1080000b 	ldhu	r2,0(r2)
8111274c:	10bfffcc 	andi	r2,r2,65535
81112750:	10a0001c 	xori	r2,r2,32768
81112754:	10a00004 	addi	r2,r2,-32768
81112758:	10800090 	cmplti	r2,r2,2
8111275c:	1000071e 	bne	r2,zero,8111277c <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
81112760:	e0ffff03 	ldbu	r3,-4(fp)
81112764:	00a04574 	movhi	r2,33045
81112768:	10a8a104 	addi	r2,r2,-23932
8111276c:	18c01324 	muli	r3,r3,76
81112770:	10c5883a 	add	r2,r2,r3
81112774:	10801004 	addi	r2,r2,64
81112778:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
8111277c:	e0ffff03 	ldbu	r3,-4(fp)
81112780:	00a04574 	movhi	r2,33045
81112784:	10a8a104 	addi	r2,r2,-23932
81112788:	18c01324 	muli	r3,r3,76
8111278c:	10c5883a 	add	r2,r2,r3
81112790:	10801004 	addi	r2,r2,64
81112794:	10800017 	ldw	r2,0(r2)
81112798:	1000441e 	bne	r2,zero,811128ac <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
8111279c:	e0bfff03 	ldbu	r2,-4(fp)
811127a0:	10c01324 	muli	r3,r2,76
811127a4:	00a04574 	movhi	r2,33045
811127a8:	10a8a104 	addi	r2,r2,-23932
811127ac:	1885883a 	add	r2,r3,r2
811127b0:	1009883a 	mov	r4,r2
811127b4:	111af680 	call	8111af68 <puts>
                xBuffer64[ucIL].bSent = TRUE;
811127b8:	e0ffff03 	ldbu	r3,-4(fp)
811127bc:	00a04574 	movhi	r2,33045
811127c0:	10a8a104 	addi	r2,r2,-23932
811127c4:	18c01324 	muli	r3,r3,76
811127c8:	10c5883a 	add	r2,r2,r3
811127cc:	10801004 	addi	r2,r2,64
811127d0:	00c00044 	movi	r3,1
811127d4:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
811127d8:	e0ffff03 	ldbu	r3,-4(fp)
811127dc:	00a04574 	movhi	r2,33045
811127e0:	10a8a104 	addi	r2,r2,-23932
811127e4:	18c01324 	muli	r3,r3,76
811127e8:	10c5883a 	add	r2,r2,r3
811127ec:	10801184 	addi	r2,r2,70
811127f0:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
811127f4:	e0ffff03 	ldbu	r3,-4(fp)
811127f8:	00a04574 	movhi	r2,33045
811127fc:	10a8a104 	addi	r2,r2,-23932
81112800:	19001324 	muli	r4,r3,76
81112804:	1105883a 	add	r2,r2,r4
81112808:	10801204 	addi	r2,r2,72
8111280c:	10800003 	ldbu	r2,0(r2)
81112810:	10800044 	addi	r2,r2,1
81112814:	100b883a 	mov	r5,r2
81112818:	00a04574 	movhi	r2,33045
8111281c:	10a8a104 	addi	r2,r2,-23932
81112820:	19001324 	muli	r4,r3,76
81112824:	1105883a 	add	r2,r2,r4
81112828:	10801204 	addi	r2,r2,72
8111282c:	11400005 	stb	r5,0(r2)
81112830:	00a04574 	movhi	r2,33045
81112834:	10a8a104 	addi	r2,r2,-23932
81112838:	18c01324 	muli	r3,r3,76
8111283c:	10c5883a 	add	r2,r2,r3
81112840:	10801204 	addi	r2,r2,72
81112844:	10800003 	ldbu	r2,0(r2)
81112848:	10803fcc 	andi	r2,r2,255
8111284c:	108000b0 	cmpltui	r2,r2,2
81112850:	1000161e 	bne	r2,zero,811128ac <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
81112854:	e0ffff03 	ldbu	r3,-4(fp)
81112858:	00a04574 	movhi	r2,33045
8111285c:	108cdd04 	addi	r2,r2,13172
81112860:	18c00184 	addi	r3,r3,6
81112864:	18c7883a 	add	r3,r3,r3
81112868:	18c7883a 	add	r3,r3,r3
8111286c:	10c5883a 	add	r2,r2,r3
81112870:	10000015 	stw	zero,0(r2)
                    SemCount64++;
81112874:	d0a07403 	ldbu	r2,-32304(gp)
81112878:	10800044 	addi	r2,r2,1
8111287c:	d0a07405 	stb	r2,-32304(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
81112880:	d0a05e17 	ldw	r2,-32392(gp)
81112884:	1009883a 	mov	r4,r2
81112888:	11379000 	call	81137900 <OSSemPost>
8111288c:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81112890:	e0bfff43 	ldbu	r2,-3(fp)
81112894:	10803fcc 	andi	r2,r2,255
81112898:	10000426 	beq	r2,zero,811128ac <vCheckRetransmission64+0x248>
                        SemCount64--;
8111289c:	d0a07403 	ldbu	r2,-32304(gp)
811128a0:	10bfffc4 	addi	r2,r2,-1
811128a4:	d0a07405 	stb	r2,-32304(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
811128a8:	11169680 	call	81116968 <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
811128ac:	e0bfff03 	ldbu	r2,-4(fp)
811128b0:	10800044 	addi	r2,r2,1
811128b4:	e0bfff05 	stb	r2,-4(fp)
811128b8:	e0bfff03 	ldbu	r2,-4(fp)
811128bc:	10800230 	cmpltui	r2,r2,8
811128c0:	103f7a1e 	bne	r2,zero,811126ac <__reset+0xfb0f26ac>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
811128c4:	d0a07017 	ldw	r2,-32320(gp)
811128c8:	1009883a 	mov	r4,r2
811128cc:	1135b100 	call	81135b10 <OSMutexPost>

    return;
811128d0:	0001883a 	nop
811128d4:	00000106 	br	811128dc <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
811128d8:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
811128dc:	e037883a 	mov	sp,fp
811128e0:	dfc00117 	ldw	ra,4(sp)
811128e4:	df000017 	ldw	fp,0(sp)
811128e8:	dec00204 	addi	sp,sp,8
811128ec:	f800283a 	ret

811128f0 <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
811128f0:	defffd04 	addi	sp,sp,-12
811128f4:	de00012e 	bgeu	sp,et,811128fc <vCheckRetransmission32+0xc>
811128f8:	003b68fa 	trap	3
811128fc:	dfc00215 	stw	ra,8(sp)
81112900:	df000115 	stw	fp,4(sp)
81112904:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81112908:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
8111290c:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
81112910:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81112914:	d0a06b17 	ldw	r2,-32340(gp)
81112918:	e0ffff84 	addi	r3,fp,-2
8111291c:	180b883a 	mov	r5,r3
81112920:	1009883a 	mov	r4,r2
81112924:	1134eec0 	call	81134eec <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81112928:	e0bfff83 	ldbu	r2,-2(fp)
8111292c:	10803fcc 	andi	r2,r2,255
81112930:	10009b1e 	bne	r2,zero,81112ba0 <vCheckRetransmission32+0x2b0>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81112934:	e03fff05 	stb	zero,-4(fp)
81112938:	00009106 	br	81112b80 <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
8111293c:	e0ffff03 	ldbu	r3,-4(fp)
81112940:	00a04574 	movhi	r2,33045
81112944:	108cdd04 	addi	r2,r2,13172
81112948:	18c00384 	addi	r3,r3,14
8111294c:	18c7883a 	add	r3,r3,r3
81112950:	18c7883a 	add	r3,r3,r3
81112954:	10c5883a 	add	r2,r2,r3
81112958:	10800017 	ldw	r2,0(r2)
8111295c:	10800058 	cmpnei	r2,r2,1
81112960:	1000841e 	bne	r2,zero,81112b74 <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
81112964:	e0ffff03 	ldbu	r3,-4(fp)
81112968:	00a04574 	movhi	r2,33045
8111296c:	10ba5d04 	addi	r2,r2,-5772
81112970:	18c00b24 	muli	r3,r3,44
81112974:	10c5883a 	add	r2,r2,r3
81112978:	10800804 	addi	r2,r2,32
8111297c:	10800017 	ldw	r2,0(r2)
81112980:	10800058 	cmpnei	r2,r2,1
81112984:	1000211e 	bne	r2,zero,81112a0c <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
81112988:	e0ffff03 	ldbu	r3,-4(fp)
8111298c:	00a04574 	movhi	r2,33045
81112990:	10ba5d04 	addi	r2,r2,-5772
81112994:	19000b24 	muli	r4,r3,44
81112998:	1105883a 	add	r2,r2,r4
8111299c:	10800984 	addi	r2,r2,38
811129a0:	1080000b 	ldhu	r2,0(r2)
811129a4:	10800044 	addi	r2,r2,1
811129a8:	100b883a 	mov	r5,r2
811129ac:	00a04574 	movhi	r2,33045
811129b0:	10ba5d04 	addi	r2,r2,-5772
811129b4:	19000b24 	muli	r4,r3,44
811129b8:	1105883a 	add	r2,r2,r4
811129bc:	10800984 	addi	r2,r2,38
811129c0:	1140000d 	sth	r5,0(r2)
811129c4:	00a04574 	movhi	r2,33045
811129c8:	10ba5d04 	addi	r2,r2,-5772
811129cc:	18c00b24 	muli	r3,r3,44
811129d0:	10c5883a 	add	r2,r2,r3
811129d4:	10800984 	addi	r2,r2,38
811129d8:	1080000b 	ldhu	r2,0(r2)
811129dc:	10bfffcc 	andi	r2,r2,65535
811129e0:	10a0001c 	xori	r2,r2,32768
811129e4:	10a00004 	addi	r2,r2,-32768
811129e8:	10800090 	cmplti	r2,r2,2
811129ec:	1000071e 	bne	r2,zero,81112a0c <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
811129f0:	e0ffff03 	ldbu	r3,-4(fp)
811129f4:	00a04574 	movhi	r2,33045
811129f8:	10ba5d04 	addi	r2,r2,-5772
811129fc:	18c00b24 	muli	r3,r3,44
81112a00:	10c5883a 	add	r2,r2,r3
81112a04:	10800804 	addi	r2,r2,32
81112a08:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
81112a0c:	e0ffff03 	ldbu	r3,-4(fp)
81112a10:	00a04574 	movhi	r2,33045
81112a14:	10ba5d04 	addi	r2,r2,-5772
81112a18:	18c00b24 	muli	r3,r3,44
81112a1c:	10c5883a 	add	r2,r2,r3
81112a20:	10800804 	addi	r2,r2,32
81112a24:	10800017 	ldw	r2,0(r2)
81112a28:	1000521e 	bne	r2,zero,81112b74 <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
81112a2c:	e0bfff03 	ldbu	r2,-4(fp)
81112a30:	10c00b24 	muli	r3,r2,44
81112a34:	00a04574 	movhi	r2,33045
81112a38:	10ba5d04 	addi	r2,r2,-5772
81112a3c:	1885883a 	add	r2,r3,r2
81112a40:	1009883a 	mov	r4,r2
81112a44:	111af680 	call	8111af68 <puts>
                xBuffer32[ucIL].bSent = TRUE;
81112a48:	e0ffff03 	ldbu	r3,-4(fp)
81112a4c:	00a04574 	movhi	r2,33045
81112a50:	10ba5d04 	addi	r2,r2,-5772
81112a54:	18c00b24 	muli	r3,r3,44
81112a58:	10c5883a 	add	r2,r2,r3
81112a5c:	10800804 	addi	r2,r2,32
81112a60:	00c00044 	movi	r3,1
81112a64:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
81112a68:	e0ffff03 	ldbu	r3,-4(fp)
81112a6c:	00a04574 	movhi	r2,33045
81112a70:	10ba5d04 	addi	r2,r2,-5772
81112a74:	18c00b24 	muli	r3,r3,44
81112a78:	10c5883a 	add	r2,r2,r3
81112a7c:	10800984 	addi	r2,r2,38
81112a80:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
81112a84:	e0ffff03 	ldbu	r3,-4(fp)
81112a88:	00a04574 	movhi	r2,33045
81112a8c:	10ba5d04 	addi	r2,r2,-5772
81112a90:	18c00b24 	muli	r3,r3,44
81112a94:	10c5883a 	add	r2,r2,r3
81112a98:	10800904 	addi	r2,r2,36
81112a9c:	1080000b 	ldhu	r2,0(r2)
81112aa0:	10bfffcc 	andi	r2,r2,65535
81112aa4:	10800058 	cmpnei	r2,r2,1
81112aa8:	1000021e 	bne	r2,zero,81112ab4 <vCheckRetransmission32+0x1c4>
81112aac:	00bffe84 	movi	r2,-6
81112ab0:	00000106 	br	81112ab8 <vCheckRetransmission32+0x1c8>
81112ab4:	00800044 	movi	r2,1
81112ab8:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
81112abc:	e0ffff03 	ldbu	r3,-4(fp)
81112ac0:	00a04574 	movhi	r2,33045
81112ac4:	10ba5d04 	addi	r2,r2,-5772
81112ac8:	19000b24 	muli	r4,r3,44
81112acc:	1105883a 	add	r2,r2,r4
81112ad0:	10800a04 	addi	r2,r2,40
81112ad4:	10800003 	ldbu	r2,0(r2)
81112ad8:	10800044 	addi	r2,r2,1
81112adc:	100b883a 	mov	r5,r2
81112ae0:	00a04574 	movhi	r2,33045
81112ae4:	10ba5d04 	addi	r2,r2,-5772
81112ae8:	19000b24 	muli	r4,r3,44
81112aec:	1105883a 	add	r2,r2,r4
81112af0:	10800a04 	addi	r2,r2,40
81112af4:	11400005 	stb	r5,0(r2)
81112af8:	00a04574 	movhi	r2,33045
81112afc:	10ba5d04 	addi	r2,r2,-5772
81112b00:	18c00b24 	muli	r3,r3,44
81112b04:	10c5883a 	add	r2,r2,r3
81112b08:	10800a04 	addi	r2,r2,40
81112b0c:	10800003 	ldbu	r2,0(r2)
81112b10:	10803fcc 	andi	r2,r2,255
81112b14:	e0ffff43 	ldbu	r3,-3(fp)
81112b18:	1880162e 	bgeu	r3,r2,81112b74 <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
81112b1c:	e0ffff03 	ldbu	r3,-4(fp)
81112b20:	00a04574 	movhi	r2,33045
81112b24:	108cdd04 	addi	r2,r2,13172
81112b28:	18c00384 	addi	r3,r3,14
81112b2c:	18c7883a 	add	r3,r3,r3
81112b30:	18c7883a 	add	r3,r3,r3
81112b34:	10c5883a 	add	r2,r2,r3
81112b38:	10000015 	stw	zero,0(r2)
                    SemCount32++;
81112b3c:	d0a06783 	ldbu	r2,-32354(gp)
81112b40:	10800044 	addi	r2,r2,1
81112b44:	d0a06785 	stb	r2,-32354(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
81112b48:	d0a06e17 	ldw	r2,-32328(gp)
81112b4c:	1009883a 	mov	r4,r2
81112b50:	11379000 	call	81137900 <OSSemPost>
81112b54:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81112b58:	e0bfff83 	ldbu	r2,-2(fp)
81112b5c:	10803fcc 	andi	r2,r2,255
81112b60:	10000426 	beq	r2,zero,81112b74 <vCheckRetransmission32+0x284>
                        SemCount32--;
81112b64:	d0a06783 	ldbu	r2,-32354(gp)
81112b68:	10bfffc4 	addi	r2,r2,-1
81112b6c:	d0a06785 	stb	r2,-32354(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81112b70:	11169400 	call	81116940 <vFailSetCountSemaphorexBuffer32>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81112b74:	e0bfff03 	ldbu	r2,-4(fp)
81112b78:	10800044 	addi	r2,r2,1
81112b7c:	e0bfff05 	stb	r2,-4(fp)
81112b80:	e0bfff03 	ldbu	r2,-4(fp)
81112b84:	10800230 	cmpltui	r2,r2,8
81112b88:	103f6c1e 	bne	r2,zero,8111293c <__reset+0xfb0f293c>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
81112b8c:	d0a06b17 	ldw	r2,-32340(gp)
81112b90:	1009883a 	mov	r4,r2
81112b94:	1135b100 	call	81135b10 <OSMutexPost>

    return;
81112b98:	0001883a 	nop
81112b9c:	00000106 	br	81112ba4 <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81112ba0:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
81112ba4:	e037883a 	mov	sp,fp
81112ba8:	dfc00117 	ldw	ra,4(sp)
81112bac:	df000017 	ldw	fp,0(sp)
81112bb0:	dec00204 	addi	sp,sp,8
81112bb4:	f800283a 	ret

81112bb8 <bResourcesInitRTOS>:
 */
TSimucam_MEB xSimMeb; /* Struct */
tDmaSim xDma[2];		  /* Control of the DMA */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
81112bb8:	defff904 	addi	sp,sp,-28
81112bbc:	de00012e 	bgeu	sp,et,81112bc4 <bResourcesInitRTOS+0xc>
81112bc0:	003b68fa 	trap	3
81112bc4:	dfc00615 	stw	ra,24(sp)
81112bc8:	df000515 	stw	fp,20(sp)
81112bcc:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
81112bd0:	00800044 	movi	r2,1
81112bd4:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
81112bd8:	0009883a 	mov	r4,zero
81112bdc:	11372500 	call	81137250 <OSSemCreate>
81112be0:	d0a06015 	stw	r2,-32384(gp)
	if (!xSemCommInit) {
81112be4:	d0a06017 	ldw	r2,-32384(gp)
81112be8:	1000021e 	bne	r2,zero,81112bf4 <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
81112bec:	11166c00 	call	811166c0 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81112bf0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
81112bf4:	e0bfff04 	addi	r2,fp,-4
81112bf8:	100b883a 	mov	r5,r2
81112bfc:	01000444 	movi	r4,17
81112c00:	11350980 	call	81135098 <OSMutexCreate>
81112c04:	d0a07315 	stw	r2,-32308(gp)
	if ( err != OS_ERR_NONE ) {
81112c08:	e0bfff03 	ldbu	r2,-4(fp)
81112c0c:	10803fcc 	andi	r2,r2,255
81112c10:	10000526 	beq	r2,zero,81112c28 <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
81112c14:	e0bfff03 	ldbu	r2,-4(fp)
81112c18:	10803fcc 	andi	r2,r2,255
81112c1c:	1009883a 	mov	r4,r2
81112c20:	11166680 	call	81116668 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81112c24:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
81112c28:	e0bfff04 	addi	r2,fp,-4
81112c2c:	100b883a 	mov	r5,r2
81112c30:	01000504 	movi	r4,20
81112c34:	11350980 	call	81135098 <OSMutexCreate>
81112c38:	d0a06d15 	stw	r2,-32332(gp)
	if ( err != OS_ERR_NONE ) {
81112c3c:	e0bfff03 	ldbu	r2,-4(fp)
81112c40:	10803fcc 	andi	r2,r2,255
81112c44:	10000526 	beq	r2,zero,81112c5c <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
81112c48:	e0bfff03 	ldbu	r2,-4(fp)
81112c4c:	10803fcc 	andi	r2,r2,255
81112c50:	1009883a 	mov	r4,r2
81112c54:	11166680 	call	81116668 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81112c58:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
81112c5c:	e0bfff04 	addi	r2,fp,-4
81112c60:	100b883a 	mov	r5,r2
81112c64:	01000544 	movi	r4,21
81112c68:	11350980 	call	81135098 <OSMutexCreate>
81112c6c:	d0a07015 	stw	r2,-32320(gp)
	if ( err != OS_ERR_NONE ) {
81112c70:	e0bfff03 	ldbu	r2,-4(fp)
81112c74:	10803fcc 	andi	r2,r2,255
81112c78:	10000526 	beq	r2,zero,81112c90 <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
81112c7c:	e0bfff03 	ldbu	r2,-4(fp)
81112c80:	10803fcc 	andi	r2,r2,255
81112c84:	1009883a 	mov	r4,r2
81112c88:	11166680 	call	81116668 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81112c8c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
81112c90:	e0bfff04 	addi	r2,fp,-4
81112c94:	100b883a 	mov	r5,r2
81112c98:	01000584 	movi	r4,22
81112c9c:	11350980 	call	81135098 <OSMutexCreate>
81112ca0:	d0a06b15 	stw	r2,-32340(gp)
	if ( err != OS_ERR_NONE ) {
81112ca4:	e0bfff03 	ldbu	r2,-4(fp)
81112ca8:	10803fcc 	andi	r2,r2,255
81112cac:	10000526 	beq	r2,zero,81112cc4 <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
81112cb0:	e0bfff03 	ldbu	r2,-4(fp)
81112cb4:	10803fcc 	andi	r2,r2,255
81112cb8:	1009883a 	mov	r4,r2
81112cbc:	11166680 	call	81116668 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81112cc0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
81112cc4:	00800184 	movi	r2,6
81112cc8:	d0a07445 	stb	r2,-32303(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
81112ccc:	01000184 	movi	r4,6
81112cd0:	11372500 	call	81137250 <OSSemCreate>
81112cd4:	d0a06215 	stw	r2,-32376(gp)
	if (!xSemCountBuffer128) {
81112cd8:	d0a06217 	ldw	r2,-32376(gp)
81112cdc:	1000031e 	bne	r2,zero,81112cec <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
81112ce0:	d0207445 	stb	zero,-32303(gp)
		vFailCreateSemaphoreResources();
81112ce4:	11166c00 	call	811166c0 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81112ce8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
81112cec:	00800204 	movi	r2,8
81112cf0:	d0a07405 	stb	r2,-32304(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
81112cf4:	01000204 	movi	r4,8
81112cf8:	11372500 	call	81137250 <OSSemCreate>
81112cfc:	d0a05e15 	stw	r2,-32392(gp)
	if (!xSemCountBuffer64) {
81112d00:	d0a05e17 	ldw	r2,-32392(gp)
81112d04:	1000031e 	bne	r2,zero,81112d14 <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
81112d08:	d0207405 	stb	zero,-32304(gp)
		vFailCreateSemaphoreResources();
81112d0c:	11166c00 	call	811166c0 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81112d10:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
81112d14:	00800204 	movi	r2,8
81112d18:	d0a06785 	stb	r2,-32354(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
81112d1c:	01000204 	movi	r4,8
81112d20:	11372500 	call	81137250 <OSSemCreate>
81112d24:	d0a06e15 	stw	r2,-32328(gp)
	if (!xSemCountBuffer32) {
81112d28:	d0a06e17 	ldw	r2,-32328(gp)
81112d2c:	1000031e 	bne	r2,zero,81112d3c <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
81112d30:	d0206785 	stb	zero,-32354(gp)
		vFailCreateSemaphoreResources();
81112d34:	11166c00 	call	811166c0 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81112d38:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
81112d3c:	e0bfff04 	addi	r2,fp,-4
81112d40:	100b883a 	mov	r5,r2
81112d44:	010004c4 	movi	r4,19
81112d48:	11350980 	call	81135098 <OSMutexCreate>
81112d4c:	d0a06415 	stw	r2,-32368(gp)
	if ( err != OS_ERR_NONE ) {
81112d50:	e0bfff03 	ldbu	r2,-4(fp)
81112d54:	10803fcc 	andi	r2,r2,255
81112d58:	10000526 	beq	r2,zero,81112d70 <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
81112d5c:	e0bfff03 	ldbu	r2,-4(fp)
81112d60:	10803fcc 	andi	r2,r2,255
81112d64:	1009883a 	mov	r4,r2
81112d68:	11166680 	call	81116668 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81112d6c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
81112d70:	e0bfff04 	addi	r2,fp,-4
81112d74:	100b883a 	mov	r5,r2
81112d78:	010005c4 	movi	r4,23
81112d7c:	11350980 	call	81135098 <OSMutexCreate>
81112d80:	d0a06a15 	stw	r2,-32344(gp)
	if ( err != OS_ERR_NONE ) {
81112d84:	e0bfff03 	ldbu	r2,-4(fp)
81112d88:	10803fcc 	andi	r2,r2,255
81112d8c:	10000526 	beq	r2,zero,81112da4 <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
81112d90:	e0bfff03 	ldbu	r2,-4(fp)
81112d94:	10803fcc 	andi	r2,r2,255
81112d98:	1009883a 	mov	r4,r2
81112d9c:	11166680 	call	81116668 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81112da0:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
81112da4:	0009883a 	mov	r4,zero
81112da8:	11372500 	call	81137250 <OSSemCreate>
81112dac:	d0a06515 	stw	r2,-32364(gp)
	if (!xSemCountReceivedACK) {
81112db0:	d0a06517 	ldw	r2,-32364(gp)
81112db4:	1000021e 	bne	r2,zero,81112dc0 <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
81112db8:	11166c00 	call	811166c0 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81112dbc:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
81112dc0:	0009883a 	mov	r4,zero
81112dc4:	11372500 	call	81137250 <OSSemCreate>
81112dc8:	d0a06315 	stw	r2,-32372(gp)
	if (!xSemCountPreParsed) {
81112dcc:	d0a06317 	ldw	r2,-32372(gp)
81112dd0:	1000021e 	bne	r2,zero,81112ddc <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
81112dd4:	11166c00 	call	811166c0 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81112dd8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
81112ddc:	0009883a 	mov	r4,zero
81112de0:	11372500 	call	81137250 <OSSemCreate>
81112de4:	d0a06115 	stw	r2,-32380(gp)
	if (!xSemCountSenderACK) {
81112de8:	d0a06117 	ldw	r2,-32380(gp)
81112dec:	1000021e 	bne	r2,zero,81112df8 <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
81112df0:	11166c00 	call	811166c0 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81112df4:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
81112df8:	e0bfff04 	addi	r2,fp,-4
81112dfc:	100b883a 	mov	r5,r2
81112e00:	01000484 	movi	r4,18
81112e04:	11350980 	call	81135098 <OSMutexCreate>
81112e08:	d0a07115 	stw	r2,-32316(gp)
	if ( err != OS_ERR_NONE ) {
81112e0c:	e0bfff03 	ldbu	r2,-4(fp)
81112e10:	10803fcc 	andi	r2,r2,255
81112e14:	10000526 	beq	r2,zero,81112e2c <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
81112e18:	e0bfff03 	ldbu	r2,-4(fp)
81112e1c:	10803fcc 	andi	r2,r2,255
81112e20:	1009883a 	mov	r4,r2
81112e24:	11166680 	call	81116668 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81112e28:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
81112e2c:	0009883a 	mov	r4,zero
81112e30:	11372500 	call	81137250 <OSSemCreate>
81112e34:	d0a06615 	stw	r2,-32360(gp)
	if (!xSemTimeoutChecker) {
81112e38:	d0a06617 	ldw	r2,-32360(gp)
81112e3c:	1000021e 	bne	r2,zero,81112e48 <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
81112e40:	11166c00 	call	811166c0 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81112e44:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
81112e48:	e0bfff04 	addi	r2,fp,-4
81112e4c:	d8800215 	stw	r2,8(sp)
81112e50:	00a04534 	movhi	r2,33044
81112e54:	1092a504 	addi	r2,r2,19092
81112e58:	d8800115 	stw	r2,4(sp)
81112e5c:	d8000015 	stw	zero,0(sp)
81112e60:	01e04474 	movhi	r7,33041
81112e64:	39d1fe04 	addi	r7,r7,18424
81112e68:	01800084 	movi	r6,2
81112e6c:	01400104 	movi	r5,4
81112e70:	01000284 	movi	r4,10
81112e74:	113991c0 	call	8113991c <OSTmrCreate>
81112e78:	d0a06c15 	stw	r2,-32336(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
81112e7c:	e0bfff03 	ldbu	r2,-4(fp)
81112e80:	10803fcc 	andi	r2,r2,255
81112e84:	10000226 	beq	r2,zero,81112e90 <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
81112e88:	1116c100 	call	81116c10 <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
81112e8c:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
81112e90:	01400484 	movi	r5,18
81112e94:	01204574 	movhi	r4,33045
81112e98:	212d9d04 	addi	r4,r4,-18828
81112e9c:	11361840 	call	81136184 <OSQCreate>
81112ea0:	d0a05d15 	stw	r2,-32396(gp)
	if ( xNfeeSchedule == NULL ) {
81112ea4:	d0a05d17 	ldw	r2,-32396(gp)
81112ea8:	1000021e 	bne	r2,zero,81112eb4 <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
81112eac:	1116e6c0 	call	81116e6c <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
81112eb0:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
81112eb4:	01400204 	movi	r5,8
81112eb8:	012045b4 	movhi	r4,33046
81112ebc:	212caf04 	addi	r4,r4,-19780
81112ec0:	11361840 	call	81136184 <OSQCreate>
81112ec4:	d0a06915 	stw	r2,-32348(gp)
	if ( xFeeQ[0] == NULL ) {
81112ec8:	d0a06917 	ldw	r2,-32348(gp)
81112ecc:	1000031e 	bne	r2,zero,81112edc <bResourcesInitRTOS+0x324>
		vFailCreateNFEEQueue( 0 );
81112ed0:	0009883a 	mov	r4,zero
81112ed4:	1116e940 	call	81116e94 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81112ed8:	e03ffe15 	stw	zero,-8(fp)
		bSuccess = FALSE;		
	}
*/


	xWaitSyncQFee[0] = OSQCreate(&SyncTBL0[0], N_MSG_SYNC);
81112edc:	01400204 	movi	r5,8
81112ee0:	01204574 	movhi	r4,33045
81112ee4:	2111f504 	addi	r4,r4,18388
81112ee8:	11361840 	call	81136184 <OSQCreate>
81112eec:	d0a05c15 	stw	r2,-32400(gp)
	if ( xWaitSyncQFee[0] == NULL ) {
81112ef0:	d0a05c17 	ldw	r2,-32400(gp)
81112ef4:	1000031e 	bne	r2,zero,81112f04 <bResourcesInitRTOS+0x34c>
		vFailCreateNFEESyncQueue( 0 );
81112ef8:	0009883a 	mov	r4,zero
81112efc:	1116ec40 	call	81116ec4 <vFailCreateNFEESyncQueue>
		bSuccess = FALSE;
81112f00:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
81112f04:	01400204 	movi	r5,8
81112f08:	01204574 	movhi	r4,33045
81112f0c:	210cf304 	addi	r4,r4,13260
81112f10:	11361840 	call	81136184 <OSQCreate>
81112f14:	d0a06815 	stw	r2,-32352(gp)
	if ( xMebQ == NULL ) {
81112f18:	d0a06817 	ldw	r2,-32352(gp)
81112f1c:	1000031e 	bne	r2,zero,81112f2c <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 5 );
81112f20:	01000144 	movi	r4,5
81112f24:	1116e940 	call	81116e94 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81112f28:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
81112f2c:	e0bfff04 	addi	r2,fp,-4
81112f30:	100b883a 	mov	r5,r2
81112f34:	010001c4 	movi	r4,7
81112f38:	11350980 	call	81135098 <OSMutexCreate>
81112f3c:	d0a07215 	stw	r2,-32312(gp)
	if ( err != OS_ERR_NONE ) {
81112f40:	e0bfff03 	ldbu	r2,-4(fp)
81112f44:	10803fcc 	andi	r2,r2,255
81112f48:	10000526 	beq	r2,zero,81112f60 <bResourcesInitRTOS+0x3a8>
		vFailCreateMutexSPUSQueueMeb(err);
81112f4c:	e0bfff03 	ldbu	r2,-4(fp)
81112f50:	10803fcc 	andi	r2,r2,255
81112f54:	1009883a 	mov	r4,r2
81112f58:	111705c0 	call	8111705c <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
81112f5c:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81112f60:	01400404 	movi	r5,16
81112f64:	01204574 	movhi	r4,33045
81112f68:	210dcd04 	addi	r4,r4,14132
81112f6c:	11361840 	call	81136184 <OSQCreate>
81112f70:	d0a06f15 	stw	r2,-32324(gp)
	if ( xQMaskFeeCtrl == NULL ) {
81112f74:	d0a06f17 	ldw	r2,-32324(gp)
81112f78:	1000021e 	bne	r2,zero,81112f84 <bResourcesInitRTOS+0x3cc>
		vCouldNotCreateQueueMaskNfeeCtrl( );
81112f7c:	11171040 	call	81117104 <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
81112f80:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskDataCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81112f84:	01400404 	movi	r5,16
81112f88:	01204574 	movhi	r4,33045
81112f8c:	2100b504 	addi	r4,r4,724
81112f90:	11361840 	call	81136184 <OSQCreate>
81112f94:	d0a05f15 	stw	r2,-32388(gp)
	if ( xQMaskDataCtrl == NULL ) {
81112f98:	d0a05f17 	ldw	r2,-32388(gp)
81112f9c:	1000021e 	bne	r2,zero,81112fa8 <bResourcesInitRTOS+0x3f0>
		vCouldNotCreateQueueMaskDataCtrl( );
81112fa0:	111712c0 	call	8111712c <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
81112fa4:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[0].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_0, &err);
81112fa8:	e0bfff04 	addi	r2,fp,-4
81112fac:	100b883a 	mov	r5,r2
81112fb0:	01000104 	movi	r4,4
81112fb4:	11350980 	call	81135098 <OSMutexCreate>
81112fb8:	1007883a 	mov	r3,r2
81112fbc:	00a045b4 	movhi	r2,33046
81112fc0:	10a00304 	addi	r2,r2,-32756
81112fc4:	10c00015 	stw	r3,0(r2)
	if ( err != OS_ERR_NONE ) {
81112fc8:	e0bfff03 	ldbu	r2,-4(fp)
81112fcc:	10803fcc 	andi	r2,r2,255
81112fd0:	10000226 	beq	r2,zero,81112fdc <bResourcesInitRTOS+0x424>
		vFailCreateMutexDMA();
81112fd4:	11166980 	call	81116698 <vFailCreateMutexDMA>
		bSuccess = FALSE;
81112fd8:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[1].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_1, &err);
81112fdc:	e0bfff04 	addi	r2,fp,-4
81112fe0:	100b883a 	mov	r5,r2
81112fe4:	01000184 	movi	r4,6
81112fe8:	11350980 	call	81135098 <OSMutexCreate>
81112fec:	1007883a 	mov	r3,r2
81112ff0:	00a045b4 	movhi	r2,33046
81112ff4:	10a00304 	addi	r2,r2,-32756
81112ff8:	10c00215 	stw	r3,8(r2)
	if ( err != OS_ERR_NONE ) {
81112ffc:	e0bfff03 	ldbu	r2,-4(fp)
81113000:	10803fcc 	andi	r2,r2,255
81113004:	10000226 	beq	r2,zero,81113010 <bResourcesInitRTOS+0x458>
		vFailCreateMutexDMA();
81113008:	11166980 	call	81116698 <vFailCreateMutexDMA>
		bSuccess = FALSE;
8111300c:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
81113010:	e0bffe17 	ldw	r2,-8(fp)
}
81113014:	e037883a 	mov	sp,fp
81113018:	dfc00117 	ldw	ra,4(sp)
8111301c:	df000017 	ldw	fp,0(sp)
81113020:	dec00204 	addi	sp,sp,8
81113024:	f800283a 	ret

81113028 <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
81113028:	defffd04 	addi	sp,sp,-12
8111302c:	de00012e 	bgeu	sp,et,81113034 <vVariablesInitialization+0xc>
81113030:	003b68fa 	trap	3
81113034:	dfc00215 	stw	ra,8(sp)
81113038:	df000115 	stw	fp,4(sp)
8111303c:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
81113040:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
81113044:	00800084 	movi	r2,2
81113048:	d0a0670d 	sth	r2,-32356(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
8111304c:	01800604 	movi	r6,24
81113050:	000b883a 	mov	r5,zero
81113054:	01204574 	movhi	r4,33045
81113058:	210cdd04 	addi	r4,r4,13172
8111305c:	111acfc0 	call	8111acfc <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
81113060:	01800804 	movi	r6,32
81113064:	000b883a 	mov	r5,zero
81113068:	01204574 	movhi	r4,33045
8111306c:	210ce304 	addi	r4,r4,13196
81113070:	111acfc0 	call	8111acfc <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
81113074:	01800804 	movi	r6,32
81113078:	000b883a 	mov	r5,zero
8111307c:	01204574 	movhi	r4,33045
81113080:	210ceb04 	addi	r4,r4,13228
81113084:	111acfc0 	call	8111acfc <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81113088:	e03fff05 	stb	zero,-4(fp)
8111308c:	00002806 	br	81113130 <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
81113090:	e0bfff03 	ldbu	r2,-4(fp)
81113094:	10c02324 	muli	r3,r2,140
81113098:	00a04574 	movhi	r2,33045
8111309c:	108cfb04 	addi	r2,r2,13292
811130a0:	1885883a 	add	r2,r3,r2
811130a4:	01802004 	movi	r6,128
811130a8:	000b883a 	mov	r5,zero
811130ac:	1009883a 	mov	r4,r2
811130b0:	111acfc0 	call	8111acfc <memset>
		xBuffer128[ucIL].bSent = FALSE;
811130b4:	e0ffff03 	ldbu	r3,-4(fp)
811130b8:	00a04574 	movhi	r2,33045
811130bc:	108cfb04 	addi	r2,r2,13292
811130c0:	18c02324 	muli	r3,r3,140
811130c4:	10c5883a 	add	r2,r2,r3
811130c8:	10802004 	addi	r2,r2,128
811130cc:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
811130d0:	e0ffff03 	ldbu	r3,-4(fp)
811130d4:	00a04574 	movhi	r2,33045
811130d8:	108cfb04 	addi	r2,r2,13292
811130dc:	18c02324 	muli	r3,r3,140
811130e0:	10c5883a 	add	r2,r2,r3
811130e4:	10802104 	addi	r2,r2,132
811130e8:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
811130ec:	e0ffff03 	ldbu	r3,-4(fp)
811130f0:	00a04574 	movhi	r2,33045
811130f4:	108cfb04 	addi	r2,r2,13292
811130f8:	18c02324 	muli	r3,r3,140
811130fc:	10c5883a 	add	r2,r2,r3
81113100:	10802184 	addi	r2,r2,134
81113104:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
81113108:	e0ffff03 	ldbu	r3,-4(fp)
8111310c:	00a04574 	movhi	r2,33045
81113110:	108cfb04 	addi	r2,r2,13292
81113114:	18c02324 	muli	r3,r3,140
81113118:	10c5883a 	add	r2,r2,r3
8111311c:	10802204 	addi	r2,r2,136
81113120:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81113124:	e0bfff03 	ldbu	r2,-4(fp)
81113128:	10800044 	addi	r2,r2,1
8111312c:	e0bfff05 	stb	r2,-4(fp)
81113130:	e0bfff03 	ldbu	r2,-4(fp)
81113134:	108001b0 	cmpltui	r2,r2,6
81113138:	103fd51e 	bne	r2,zero,81113090 <__reset+0xfb0f3090>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
8111313c:	e03fff05 	stb	zero,-4(fp)
81113140:	00002806 	br	811131e4 <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
81113144:	e0bfff03 	ldbu	r2,-4(fp)
81113148:	10c01324 	muli	r3,r2,76
8111314c:	00a04574 	movhi	r2,33045
81113150:	10a8a104 	addi	r2,r2,-23932
81113154:	1885883a 	add	r2,r3,r2
81113158:	01801004 	movi	r6,64
8111315c:	000b883a 	mov	r5,zero
81113160:	1009883a 	mov	r4,r2
81113164:	111acfc0 	call	8111acfc <memset>
		xBuffer64[ucIL].bSent = FALSE;
81113168:	e0ffff03 	ldbu	r3,-4(fp)
8111316c:	00a04574 	movhi	r2,33045
81113170:	10a8a104 	addi	r2,r2,-23932
81113174:	18c01324 	muli	r3,r3,76
81113178:	10c5883a 	add	r2,r2,r3
8111317c:	10801004 	addi	r2,r2,64
81113180:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
81113184:	e0ffff03 	ldbu	r3,-4(fp)
81113188:	00a04574 	movhi	r2,33045
8111318c:	10a8a104 	addi	r2,r2,-23932
81113190:	18c01324 	muli	r3,r3,76
81113194:	10c5883a 	add	r2,r2,r3
81113198:	10801104 	addi	r2,r2,68
8111319c:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
811131a0:	e0ffff03 	ldbu	r3,-4(fp)
811131a4:	00a04574 	movhi	r2,33045
811131a8:	10a8a104 	addi	r2,r2,-23932
811131ac:	18c01324 	muli	r3,r3,76
811131b0:	10c5883a 	add	r2,r2,r3
811131b4:	10801184 	addi	r2,r2,70
811131b8:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
811131bc:	e0ffff03 	ldbu	r3,-4(fp)
811131c0:	00a04574 	movhi	r2,33045
811131c4:	10a8a104 	addi	r2,r2,-23932
811131c8:	18c01324 	muli	r3,r3,76
811131cc:	10c5883a 	add	r2,r2,r3
811131d0:	10801204 	addi	r2,r2,72
811131d4:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
811131d8:	e0bfff03 	ldbu	r2,-4(fp)
811131dc:	10800044 	addi	r2,r2,1
811131e0:	e0bfff05 	stb	r2,-4(fp)
811131e4:	e0bfff03 	ldbu	r2,-4(fp)
811131e8:	10800230 	cmpltui	r2,r2,8
811131ec:	103fd51e 	bne	r2,zero,81113144 <__reset+0xfb0f3144>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
811131f0:	e03fff05 	stb	zero,-4(fp)
811131f4:	00002806 	br	81113298 <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
811131f8:	e0bfff03 	ldbu	r2,-4(fp)
811131fc:	10c00b24 	muli	r3,r2,44
81113200:	00a04574 	movhi	r2,33045
81113204:	10ba5d04 	addi	r2,r2,-5772
81113208:	1885883a 	add	r2,r3,r2
8111320c:	01800804 	movi	r6,32
81113210:	000b883a 	mov	r5,zero
81113214:	1009883a 	mov	r4,r2
81113218:	111acfc0 	call	8111acfc <memset>
		xBuffer32[ucIL].bSent = FALSE;
8111321c:	e0ffff03 	ldbu	r3,-4(fp)
81113220:	00a04574 	movhi	r2,33045
81113224:	10ba5d04 	addi	r2,r2,-5772
81113228:	18c00b24 	muli	r3,r3,44
8111322c:	10c5883a 	add	r2,r2,r3
81113230:	10800804 	addi	r2,r2,32
81113234:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
81113238:	e0ffff03 	ldbu	r3,-4(fp)
8111323c:	00a04574 	movhi	r2,33045
81113240:	10ba5d04 	addi	r2,r2,-5772
81113244:	18c00b24 	muli	r3,r3,44
81113248:	10c5883a 	add	r2,r2,r3
8111324c:	10800904 	addi	r2,r2,36
81113250:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
81113254:	e0ffff03 	ldbu	r3,-4(fp)
81113258:	00a04574 	movhi	r2,33045
8111325c:	10ba5d04 	addi	r2,r2,-5772
81113260:	18c00b24 	muli	r3,r3,44
81113264:	10c5883a 	add	r2,r2,r3
81113268:	10800984 	addi	r2,r2,38
8111326c:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
81113270:	e0ffff03 	ldbu	r3,-4(fp)
81113274:	00a04574 	movhi	r2,33045
81113278:	10ba5d04 	addi	r2,r2,-5772
8111327c:	18c00b24 	muli	r3,r3,44
81113280:	10c5883a 	add	r2,r2,r3
81113284:	10800a04 	addi	r2,r2,40
81113288:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
8111328c:	e0bfff03 	ldbu	r2,-4(fp)
81113290:	10800044 	addi	r2,r2,1
81113294:	e0bfff05 	stb	r2,-4(fp)
81113298:	e0bfff03 	ldbu	r2,-4(fp)
8111329c:	10800230 	cmpltui	r2,r2,8
811132a0:	103fd51e 	bne	r2,zero,811131f8 <__reset+0xfb0f31f8>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
811132a4:	e03fff05 	stb	zero,-4(fp)
811132a8:	00001b06 	br	81113318 <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
811132ac:	e0ffff03 	ldbu	r3,-4(fp)
811132b0:	00a04574 	movhi	r2,33045
811132b4:	10a93904 	addi	r2,r2,-23324
811132b8:	18c01524 	muli	r3,r3,84
811132bc:	10c5883a 	add	r2,r2,r3
811132c0:	10800104 	addi	r2,r2,4
811132c4:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
811132c8:	e0ffff03 	ldbu	r3,-4(fp)
811132cc:	00a04574 	movhi	r2,33045
811132d0:	10a93904 	addi	r2,r2,-23324
811132d4:	18c01524 	muli	r3,r3,84
811132d8:	10c5883a 	add	r2,r2,r3
811132dc:	10800484 	addi	r2,r2,18
811132e0:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
811132e4:	e0bfff03 	ldbu	r2,-4(fp)
811132e8:	10801524 	muli	r2,r2,84
811132ec:	10c00504 	addi	r3,r2,20
811132f0:	00a04574 	movhi	r2,33045
811132f4:	10a93904 	addi	r2,r2,-23324
811132f8:	1885883a 	add	r2,r3,r2
811132fc:	01801004 	movi	r6,64
81113300:	000b883a 	mov	r5,zero
81113304:	1009883a 	mov	r4,r2
81113308:	111acfc0 	call	8111acfc <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
8111330c:	e0bfff03 	ldbu	r2,-4(fp)
81113310:	10800044 	addi	r2,r2,1
81113314:	e0bfff05 	stb	r2,-4(fp)
81113318:	e0bfff03 	ldbu	r2,-4(fp)
8111331c:	10800130 	cmpltui	r2,r2,4
81113320:	103fe21e 	bne	r2,zero,811132ac <__reset+0xfb0f32ac>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
81113324:	0001883a 	nop
81113328:	e037883a 	mov	sp,fp
8111332c:	dfc00117 	ldw	ra,4(sp)
81113330:	df000017 	ldw	fp,0(sp)
81113334:	dec00204 	addi	sp,sp,8
81113338:	f800283a 	ret

8111333c <main>:
void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
8111333c:	defff704 	addi	sp,sp,-36
81113340:	de00012e 	bgeu	sp,et,81113348 <main+0xc>
81113344:	003b68fa 	trap	3
81113348:	dfc00815 	stw	ra,32(sp)
8111334c:	df000715 	stw	fp,28(sp)
81113350:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
81113354:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
81113358:	11315340 	call	81131534 <OSInit>
	#if DEBUG_ON
		debug(fp, "Main entry point.\n");
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
8111335c:	1117e640 	call	81117e64 <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
81113360:	111893c0 	call	8111893c <bTestSimucamCriticalHW>
81113364:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81113368:	e0bffe17 	ldw	r2,-8(fp)
8111336c:	1000031e 	bne	r2,zero,8111337c <main+0x40>
		vFailTestCriticasParts();
81113370:	11166e80 	call	811166e8 <vFailTestCriticasParts>
		return -1;
81113374:	00bfffc4 	movi	r2,-1
81113378:	00003806 	br	8111345c <main+0x120>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
8111337c:	11185d80 	call	811185d8 <bInitializeSDCard>
81113380:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81113384:	e0bffe17 	ldw	r2,-8(fp)
81113388:	1000031e 	bne	r2,zero,81113398 <main+0x5c>
		vFailTestCriticasParts();
8111338c:	11166e80 	call	811166e8 <vFailTestCriticasParts>
		return -1;
81113390:	00bfffc4 	movi	r2,-1
81113394:	00003106 	br	8111345c <main+0x120>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
81113398:	1114c200 	call	81114c20 <vLoadDefaultETHConf>
8111339c:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811133a0:	e0bffe17 	ldw	r2,-8(fp)
811133a4:	1000021e 	bne	r2,zero,811133b0 <main+0x74>
		/* Default configuration for eth connection loaded */
		#if DEBUG_ON
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. \n");
		#endif
		return -1;
811133a8:	00bfffc4 	movi	r2,-1
811133ac:	00002b06 	br	8111345c <main+0x120>
	}

	bIniSimucamStatus = vLoadDebugConfs();
811133b0:	11155580 	call	81115558 <vLoadDebugConfs>
811133b4:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811133b8:	e0bffe17 	ldw	r2,-8(fp)
811133bc:	1000021e 	bne	r2,zero,811133c8 <main+0x8c>
		/* Default configuration for eth connection loaded */
		#if DEBUG_ON
			debug(fp, "Didn't load DEBUG configuration from SDCard. Default configuration will be loaded. \n");
		#endif
		return -1;
811133c0:	00bfffc4 	movi	r2,-1
811133c4:	00002506 	br	8111345c <main+0x120>
		vShowEthConfig();
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
811133c8:	1112bb80 	call	81112bb8 <bResourcesInitRTOS>
811133cc:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811133d0:	e0bffe17 	ldw	r2,-8(fp)
811133d4:	1000021e 	bne	r2,zero,811133e0 <main+0xa4>
		/* Default configuration for eth connection loaded */
#if DEBUG_ON
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
#endif
		return -1;
811133d8:	00bfffc4 	movi	r2,-1
811133dc:	00001f06 	br	8111345c <main+0x120>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
811133e0:	01204574 	movhi	r4,33045
811133e4:	2135af04 	addi	r4,r4,-10564
811133e8:	1117fa40 	call	81117fa4 <vSimucamStructureInit>

	vVariablesInitialization();
811133ec:	11130280 	call	81113028 <vVariablesInitialization>

	bInitSync();
811133f0:	11187140 	call	81118714 <bInitSync>

	vFillMemmoryPattern( &xSimMeb );
811133f4:	01204574 	movhi	r4,33045
811133f8:	2135af04 	addi	r4,r4,-10564
811133fc:	11134700 	call	81113470 <vFillMemmoryPattern>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
81113400:	d8000415 	stw	zero,16(sp)
81113404:	d8000315 	stw	zero,12(sp)
81113408:	00810004 	movi	r2,1024
8111340c:	d8800215 	stw	r2,8(sp)
81113410:	00a04574 	movhi	r2,33045
81113414:	1084d504 	addi	r2,r2,4948
81113418:	d8800115 	stw	r2,4(sp)
8111341c:	00800044 	movi	r2,1
81113420:	d8800015 	stw	r2,0(sp)
81113424:	01c00044 	movi	r7,1
81113428:	01a04574 	movhi	r6,33045
8111342c:	3188d404 	addi	r6,r6,9040
81113430:	000b883a 	mov	r5,zero
81113434:	01204474 	movhi	r4,33041
81113438:	213c1b04 	addi	r4,r4,-3988
8111343c:	11382e40 	call	811382e4 <OSTaskCreateExt>
81113440:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
81113444:	e0bfff03 	ldbu	r2,-4(fp)
81113448:	1000021e 	bne	r2,zero,81113454 <main+0x118>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
8111344c:	11318640 	call	81131864 <OSStart>
81113450:	00000106 	br	81113458 <main+0x11c>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
81113454:	11168a00 	call	811168a0 <vFailInitialization>
	}
  
	return 0;
81113458:	0005883a 	mov	r2,zero
}
8111345c:	e037883a 	mov	sp,fp
81113460:	dfc00117 	ldw	ra,4(sp)
81113464:	df000017 	ldw	fp,0(sp)
81113468:	dec00204 	addi	sp,sp,8
8111346c:	f800283a 	ret

81113470 <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81113470:	defff604 	addi	sp,sp,-40
81113474:	de00012e 	bgeu	sp,et,8111347c <vFillMemmoryPattern+0xc>
81113478:	003b68fa 	trap	3
8111347c:	dfc00915 	stw	ra,36(sp)
81113480:	df000815 	stw	fp,32(sp)
81113484:	df000804 	addi	fp,sp,32
81113488:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
8111348c:	00800044 	movi	r2,1
81113490:	e0bffcc5 	stb	r2,-13(fp)
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81113494:	e03ffa05 	stb	zero,-24(fp)
81113498:	00006606 	br	81113634 <vFillMemmoryPattern+0x1c4>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
8111349c:	e03ffc85 	stb	zero,-14(fp)
811134a0:	00005e06 	br	8111361c <vFillMemmoryPattern+0x1ac>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
811134a4:	e0bffc83 	ldbu	r2,-14(fp)
811134a8:	e0ffff17 	ldw	r3,-4(fp)
811134ac:	10809624 	muli	r2,r2,600
811134b0:	1885883a 	add	r2,r3,r2
811134b4:	10804304 	addi	r2,r2,268
811134b8:	1080000b 	ldhu	r2,0(r2)
811134bc:	10ffffcc 	andi	r3,r2,65535
811134c0:	e0bffc83 	ldbu	r2,-14(fp)
811134c4:	e13fff17 	ldw	r4,-4(fp)
811134c8:	10809624 	muli	r2,r2,600
811134cc:	2085883a 	add	r2,r4,r2
811134d0:	10804204 	addi	r2,r2,264
811134d4:	1080000b 	ldhu	r2,0(r2)
811134d8:	10bfffcc 	andi	r2,r2,65535
811134dc:	1885883a 	add	r2,r3,r2
811134e0:	e0bffd15 	stw	r2,-12(fp)
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
811134e4:	e0bffc83 	ldbu	r2,-14(fp)
811134e8:	e0ffff17 	ldw	r3,-4(fp)
811134ec:	10809624 	muli	r2,r2,600
811134f0:	1885883a 	add	r2,r3,r2
811134f4:	10804284 	addi	r2,r2,266
811134f8:	1080000b 	ldhu	r2,0(r2)
811134fc:	10ffffcc 	andi	r3,r2,65535
81113500:	e0bffc83 	ldbu	r2,-14(fp)
81113504:	e13fff17 	ldw	r4,-4(fp)
81113508:	10809624 	muli	r2,r2,600
8111350c:	2085883a 	add	r2,r4,r2
81113510:	10804184 	addi	r2,r2,262
81113514:	1080000b 	ldhu	r2,0(r2)
81113518:	10bfffcc 	andi	r2,r2,65535
8111351c:	1887883a 	add	r3,r3,r2
81113520:	e0bffc83 	ldbu	r2,-14(fp)
81113524:	e13fff17 	ldw	r4,-4(fp)
81113528:	10809624 	muli	r2,r2,600
8111352c:	2085883a 	add	r2,r4,r2
81113530:	10804104 	addi	r2,r2,260
81113534:	1080000b 	ldhu	r2,0(r2)
81113538:	10bfffcc 	andi	r2,r2,65535
8111353c:	1885883a 	add	r2,r3,r2
81113540:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81113544:	e03ffc05 	stb	zero,-16(fp)
81113548:	00002e06 	br	81113604 <vFillMemmoryPattern+0x194>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
8111354c:	e03ffc45 	stb	zero,-15(fp)
81113550:	00002606 	br	811135ec <vFillMemmoryPattern+0x17c>
					if (ccd_side == 0){
81113554:	e0bffc43 	ldbu	r2,-15(fp)
81113558:	10000b1e 	bne	r2,zero,81113588 <vFillMemmoryPattern+0x118>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
8111355c:	e0bffc83 	ldbu	r2,-14(fp)
81113560:	e13ffc03 	ldbu	r4,-16(fp)
81113564:	e0ffff17 	ldw	r3,-4(fp)
81113568:	21000624 	muli	r4,r4,24
8111356c:	10809624 	muli	r2,r2,600
81113570:	2085883a 	add	r2,r4,r2
81113574:	1885883a 	add	r2,r3,r2
81113578:	10801b04 	addi	r2,r2,108
8111357c:	10800017 	ldw	r2,0(r2)
81113580:	e0bffb15 	stw	r2,-20(fp)
81113584:	00000a06 	br	811135b0 <vFillMemmoryPattern+0x140>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
81113588:	e0bffc83 	ldbu	r2,-14(fp)
8111358c:	e13ffc03 	ldbu	r4,-16(fp)
81113590:	e0ffff17 	ldw	r3,-4(fp)
81113594:	21000624 	muli	r4,r4,24
81113598:	10809624 	muli	r2,r2,600
8111359c:	2085883a 	add	r2,r4,r2
811135a0:	1885883a 	add	r2,r3,r2
811135a4:	10801e04 	addi	r2,r2,120
811135a8:	10800017 	ldw	r2,0(r2)
811135ac:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
811135b0:	e0fffa03 	ldbu	r3,-24(fp)
811135b4:	e13ffc03 	ldbu	r4,-16(fp)
811135b8:	e17ffc43 	ldbu	r5,-15(fp)
811135bc:	e0bffd17 	ldw	r2,-12(fp)
811135c0:	d8800115 	stw	r2,4(sp)
811135c4:	e0bffe17 	ldw	r2,-8(fp)
811135c8:	d8800015 	stw	r2,0(sp)
811135cc:	280f883a 	mov	r7,r5
811135d0:	200d883a 	mov	r6,r4
811135d4:	e17ffb17 	ldw	r5,-20(fp)
811135d8:	1809883a 	mov	r4,r3
811135dc:	11183680 	call	81118368 <pattern_createPattern>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
811135e0:	e0bffc43 	ldbu	r2,-15(fp)
811135e4:	10800044 	addi	r2,r2,1
811135e8:	e0bffc45 	stb	r2,-15(fp)
811135ec:	e0bffc43 	ldbu	r2,-15(fp)
811135f0:	108000b0 	cmpltui	r2,r2,2
811135f4:	103fd71e 	bne	r2,zero,81113554 <__reset+0xfb0f3554>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
811135f8:	e0bffc03 	ldbu	r2,-16(fp)
811135fc:	10800044 	addi	r2,r2,1
81113600:	e0bffc05 	stb	r2,-16(fp)
81113604:	e0bffc03 	ldbu	r2,-16(fp)
81113608:	10800130 	cmpltui	r2,r2,4
8111360c:	103fcf1e 	bne	r2,zero,8111354c <__reset+0xfb0f354c>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81113610:	e0bffc83 	ldbu	r2,-14(fp)
81113614:	10800044 	addi	r2,r2,1
81113618:	e0bffc85 	stb	r2,-14(fp)
8111361c:	e0fffc83 	ldbu	r3,-14(fp)
81113620:	e0bffcc3 	ldbu	r2,-13(fp)
81113624:	18bf9f36 	bltu	r3,r2,811134a4 <__reset+0xfb0f34a4>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81113628:	e0bffa03 	ldbu	r2,-24(fp)
8111362c:	10800044 	addi	r2,r2,1
81113630:	e0bffa05 	stb	r2,-24(fp)
81113634:	e0bffa03 	ldbu	r2,-24(fp)
81113638:	108000b0 	cmpltui	r2,r2,2
8111363c:	103f971e 	bne	r2,zero,8111349c <__reset+0xfb0f349c>
#if DEBUG_ON
	debug(fp, "Memory Filled. \n");
#endif


}
81113640:	0001883a 	nop
81113644:	e037883a 	mov	sp,fp
81113648:	dfc00117 	ldw	ra,4(sp)
8111364c:	df000017 	ldw	fp,0(sp)
81113650:	dec00204 	addi	sp,sp,8
81113654:	f800283a 	ret

81113658 <vPrintMemmoryPattern>:

void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81113658:	defff604 	addi	sp,sp,-40
8111365c:	de00012e 	bgeu	sp,et,81113664 <vPrintMemmoryPattern+0xc>
81113660:	003b68fa 	trap	3
81113664:	dfc00915 	stw	ra,36(sp)
81113668:	df000815 	stw	fp,32(sp)
8111366c:	df000804 	addi	fp,sp,32
81113670:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
81113674:	00800044 	movi	r2,1
81113678:	e0bffcc5 	stb	r2,-13(fp)
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
8111367c:	e03ffa05 	stb	zero,-24(fp)
81113680:	00006606 	br	8111381c <vPrintMemmoryPattern+0x1c4>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81113684:	e03ffc85 	stb	zero,-14(fp)
81113688:	00005e06 	br	81113804 <vPrintMemmoryPattern+0x1ac>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
8111368c:	e0bffc83 	ldbu	r2,-14(fp)
81113690:	e0ffff17 	ldw	r3,-4(fp)
81113694:	10809624 	muli	r2,r2,600
81113698:	1885883a 	add	r2,r3,r2
8111369c:	10804304 	addi	r2,r2,268
811136a0:	1080000b 	ldhu	r2,0(r2)
811136a4:	10ffffcc 	andi	r3,r2,65535
811136a8:	e0bffc83 	ldbu	r2,-14(fp)
811136ac:	e13fff17 	ldw	r4,-4(fp)
811136b0:	10809624 	muli	r2,r2,600
811136b4:	2085883a 	add	r2,r4,r2
811136b8:	10804204 	addi	r2,r2,264
811136bc:	1080000b 	ldhu	r2,0(r2)
811136c0:	10bfffcc 	andi	r2,r2,65535
811136c4:	1885883a 	add	r2,r3,r2
811136c8:	e0bffd15 	stw	r2,-12(fp)
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
811136cc:	e0bffc83 	ldbu	r2,-14(fp)
811136d0:	e0ffff17 	ldw	r3,-4(fp)
811136d4:	10809624 	muli	r2,r2,600
811136d8:	1885883a 	add	r2,r3,r2
811136dc:	10804284 	addi	r2,r2,266
811136e0:	1080000b 	ldhu	r2,0(r2)
811136e4:	10ffffcc 	andi	r3,r2,65535
811136e8:	e0bffc83 	ldbu	r2,-14(fp)
811136ec:	e13fff17 	ldw	r4,-4(fp)
811136f0:	10809624 	muli	r2,r2,600
811136f4:	2085883a 	add	r2,r4,r2
811136f8:	10804184 	addi	r2,r2,262
811136fc:	1080000b 	ldhu	r2,0(r2)
81113700:	10bfffcc 	andi	r2,r2,65535
81113704:	1887883a 	add	r3,r3,r2
81113708:	e0bffc83 	ldbu	r2,-14(fp)
8111370c:	e13fff17 	ldw	r4,-4(fp)
81113710:	10809624 	muli	r2,r2,600
81113714:	2085883a 	add	r2,r4,r2
81113718:	10804104 	addi	r2,r2,260
8111371c:	1080000b 	ldhu	r2,0(r2)
81113720:	10bfffcc 	andi	r2,r2,65535
81113724:	1885883a 	add	r2,r3,r2
81113728:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
8111372c:	e03ffc05 	stb	zero,-16(fp)
81113730:	00002e06 	br	811137ec <vPrintMemmoryPattern+0x194>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81113734:	e03ffc45 	stb	zero,-15(fp)
81113738:	00002606 	br	811137d4 <vPrintMemmoryPattern+0x17c>
					if (ccd_side == 0){
8111373c:	e0bffc43 	ldbu	r2,-15(fp)
81113740:	10000b1e 	bne	r2,zero,81113770 <vPrintMemmoryPattern+0x118>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81113744:	e0bffc83 	ldbu	r2,-14(fp)
81113748:	e13ffc03 	ldbu	r4,-16(fp)
8111374c:	e0ffff17 	ldw	r3,-4(fp)
81113750:	21000624 	muli	r4,r4,24
81113754:	10809624 	muli	r2,r2,600
81113758:	2085883a 	add	r2,r4,r2
8111375c:	1885883a 	add	r2,r3,r2
81113760:	10801b04 	addi	r2,r2,108
81113764:	10800017 	ldw	r2,0(r2)
81113768:	e0bffb15 	stw	r2,-20(fp)
8111376c:	00000a06 	br	81113798 <vPrintMemmoryPattern+0x140>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
81113770:	e0bffc83 	ldbu	r2,-14(fp)
81113774:	e13ffc03 	ldbu	r4,-16(fp)
81113778:	e0ffff17 	ldw	r3,-4(fp)
8111377c:	21000624 	muli	r4,r4,24
81113780:	10809624 	muli	r2,r2,600
81113784:	2085883a 	add	r2,r4,r2
81113788:	1885883a 	add	r2,r3,r2
8111378c:	10801e04 	addi	r2,r2,120
81113790:	10800017 	ldw	r2,0(r2)
81113794:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
81113798:	e0fffa03 	ldbu	r3,-24(fp)
8111379c:	e13ffc03 	ldbu	r4,-16(fp)
811137a0:	e17ffc43 	ldbu	r5,-15(fp)
811137a4:	e0bffe17 	ldw	r2,-8(fp)
811137a8:	d8800115 	stw	r2,4(sp)
811137ac:	e0bffd17 	ldw	r2,-12(fp)
811137b0:	d8800015 	stw	r2,0(sp)
811137b4:	280f883a 	mov	r7,r5
811137b8:	200d883a 	mov	r6,r4
811137bc:	e17ffb17 	ldw	r5,-20(fp)
811137c0:	1809883a 	mov	r4,r3
811137c4:	11183680 	call	81118368 <pattern_createPattern>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
811137c8:	e0bffc43 	ldbu	r2,-15(fp)
811137cc:	10800044 	addi	r2,r2,1
811137d0:	e0bffc45 	stb	r2,-15(fp)
811137d4:	e0bffc43 	ldbu	r2,-15(fp)
811137d8:	108000b0 	cmpltui	r2,r2,2
811137dc:	103fd71e 	bne	r2,zero,8111373c <__reset+0xfb0f373c>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
811137e0:	e0bffc03 	ldbu	r2,-16(fp)
811137e4:	10800044 	addi	r2,r2,1
811137e8:	e0bffc05 	stb	r2,-16(fp)
811137ec:	e0bffc03 	ldbu	r2,-16(fp)
811137f0:	10800130 	cmpltui	r2,r2,4
811137f4:	103fcf1e 	bne	r2,zero,81113734 <__reset+0xfb0f3734>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
811137f8:	e0bffc83 	ldbu	r2,-14(fp)
811137fc:	10800044 	addi	r2,r2,1
81113800:	e0bffc85 	stb	r2,-14(fp)
81113804:	e0fffc83 	ldbu	r3,-14(fp)
81113808:	e0bffcc3 	ldbu	r2,-13(fp)
8111380c:	18bf9f36 	bltu	r3,r2,8111368c <__reset+0xfb0f368c>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81113810:	e0bffa03 	ldbu	r2,-24(fp)
81113814:	10800044 	addi	r2,r2,1
81113818:	e0bffa05 	stb	r2,-24(fp)
8111381c:	e0bffa03 	ldbu	r2,-24(fp)
81113820:	108000b0 	cmpltui	r2,r2,2
81113824:	103f971e 	bne	r2,zero,81113684 <__reset+0xfb0f3684>
#if DEBUG_ON
	debug(fp, "Memory Filled. \n");
#endif


}
81113828:	0001883a 	nop
8111382c:	e037883a 	mov	sp,fp
81113830:	dfc00117 	ldw	ra,4(sp)
81113834:	df000017 	ldw	fp,0(sp)
81113838:	dec00204 	addi	sp,sp,8
8111383c:	f800283a 	ret

81113840 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
81113840:	defffe04 	addi	sp,sp,-8
81113844:	de00012e 	bgeu	sp,et,8111384c <vCCDLoadDefaultValues+0xc>
81113848:	003b68fa 	trap	3
8111384c:	df000115 	stw	fp,4(sp)
81113850:	df000104 	addi	fp,sp,4
81113854:	e13fff15 	stw	r4,-4(fp)
	ccdDef->usiOLN = 30;
	ccdDef->usiHalfWidth = 2255;
	ccdDef->usiSOverscanN = 15;
	ccdDef->usiSPrescanN = 25;
*/
	ccdDef->usiHeight = xDefaults.usiRows;
81113858:	00a045b4 	movhi	r2,33046
8111385c:	10acbf04 	addi	r2,r2,-19716
81113860:	10c0060b 	ldhu	r3,24(r2)
81113864:	e0bfff17 	ldw	r2,-4(fp)
81113868:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = xDefaults.usiOLN;
8111386c:	00a045b4 	movhi	r2,33046
81113870:	10acbf04 	addi	r2,r2,-19716
81113874:	10c0050b 	ldhu	r3,20(r2)
81113878:	e0bfff17 	ldw	r2,-4(fp)
8111387c:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = xDefaults.usiCols;
81113880:	00a045b4 	movhi	r2,33046
81113884:	10acbf04 	addi	r2,r2,-19716
81113888:	10c0058b 	ldhu	r3,22(r2)
8111388c:	e0bfff17 	ldw	r2,-4(fp)
81113890:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = xDefaults.usiOverScanSerial;
81113894:	00a045b4 	movhi	r2,33046
81113898:	10acbf04 	addi	r2,r2,-19716
8111389c:	10c0040b 	ldhu	r3,16(r2)
811138a0:	e0bfff17 	ldw	r2,-4(fp)
811138a4:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = xDefaults.usiPreScanSerial;
811138a8:	00a045b4 	movhi	r2,33046
811138ac:	10acbf04 	addi	r2,r2,-19716
811138b0:	10c0048b 	ldhu	r3,18(r2)
811138b4:	e0bfff17 	ldw	r2,-4(fp)
811138b8:	10c0000d 	sth	r3,0(r2)
	fprintf(fp,"usiHalfWidth %hu\n", ccdDef->usiHalfWidth);
	fprintf(fp,"usiSOverscanN %hu\n", ccdDef->usiSOverscanN);
	fprintf(fp,"usiSPrescanN %hu\n",  ccdDef->usiSPrescanN);
#endif

}
811138bc:	0001883a 	nop
811138c0:	e037883a 	mov	sp,fp
811138c4:	df000017 	ldw	fp,0(sp)
811138c8:	dec00104 	addi	sp,sp,4
811138cc:	f800283a 	ret

811138d0 <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
811138d0:	defff904 	addi	sp,sp,-28
811138d4:	de00012e 	bgeu	sp,et,811138dc <vCCDChangeValues+0xc>
811138d8:	003b68fa 	trap	3
811138dc:	df000615 	stw	fp,24(sp)
811138e0:	df000604 	addi	fp,sp,24
811138e4:	e13ffa15 	stw	r4,-24(fp)
811138e8:	2811883a 	mov	r8,r5
811138ec:	300b883a 	mov	r5,r6
811138f0:	3809883a 	mov	r4,r7
811138f4:	e0c00117 	ldw	r3,4(fp)
811138f8:	e0800217 	ldw	r2,8(fp)
811138fc:	e23ffb0d 	sth	r8,-20(fp)
81113900:	e17ffc0d 	sth	r5,-16(fp)
81113904:	e13ffd0d 	sth	r4,-12(fp)
81113908:	e0fffe0d 	sth	r3,-8(fp)
8111390c:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
81113910:	e0bffa17 	ldw	r2,-24(fp)
81113914:	e0fffb0b 	ldhu	r3,-20(fp)
81113918:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
8111391c:	e0bffa17 	ldw	r2,-24(fp)
81113920:	e0fffc0b 	ldhu	r3,-16(fp)
81113924:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
81113928:	e0bffa17 	ldw	r2,-24(fp)
8111392c:	e0fffd0b 	ldhu	r3,-12(fp)
81113930:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
81113934:	e0bffa17 	ldw	r2,-24(fp)
81113938:	e0fffe0b 	ldhu	r3,-8(fp)
8111393c:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
81113940:	e0bffa17 	ldw	r2,-24(fp)
81113944:	e0ffff0b 	ldhu	r3,-4(fp)
81113948:	10c0000d 	sth	r3,0(r2)
}
8111394c:	0001883a 	nop
81113950:	e037883a 	mov	sp,fp
81113954:	df000017 	ldw	fp,0(sp)
81113958:	dec00104 	addi	sp,sp,4
8111395c:	f800283a 	ret

81113960 <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
81113960:	defff904 	addi	sp,sp,-28
81113964:	de00012e 	bgeu	sp,et,8111396c <bSendUART128v2+0xc>
81113968:	003b68fa 	trap	3
8111396c:	dfc00615 	stw	ra,24(sp)
81113970:	df000515 	stw	fp,20(sp)
81113974:	df000504 	addi	fp,sp,20
81113978:	e13ffe15 	stw	r4,-8(fp)
8111397c:	2805883a 	mov	r2,r5
81113980:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
81113984:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81113988:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
8111398c:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81113990:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81113994:	d0a06217 	ldw	r2,-32376(gp)
81113998:	e0fffd04 	addi	r3,fp,-12
8111399c:	180d883a 	mov	r6,r3
811139a0:	01400504 	movi	r5,20
811139a4:	1009883a 	mov	r4,r2
811139a8:	11375780 	call	81137578 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
811139ac:	e0bffd03 	ldbu	r2,-12(fp)
811139b0:	10803fcc 	andi	r2,r2,255
811139b4:	10000326 	beq	r2,zero,811139c4 <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
811139b8:	11169b80 	call	811169b8 <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
811139bc:	e0bffc17 	ldw	r2,-16(fp)
811139c0:	00009006 	br	81113c04 <bSendUART128v2+0x2a4>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
811139c4:	d0a06d17 	ldw	r2,-32332(gp)
811139c8:	e0fffd04 	addi	r3,fp,-12
811139cc:	180d883a 	mov	r6,r3
811139d0:	01400104 	movi	r5,4
811139d4:	1009883a 	mov	r4,r2
811139d8:	113556c0 	call	8113556c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811139dc:	e0bffd03 	ldbu	r2,-12(fp)
811139e0:	10803fcc 	andi	r2,r2,255
811139e4:	10000a26 	beq	r2,zero,81113a10 <bSendUART128v2+0xb0>
		/* Could not get the mutex, so we need to give the semaphore back */
		#if DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
811139e8:	d0a06217 	ldw	r2,-32376(gp)
811139ec:	1009883a 	mov	r4,r2
811139f0:	11379000 	call	81137900 <OSSemPost>
811139f4:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
811139f8:	e0bffd03 	ldbu	r2,-12(fp)
811139fc:	10803fcc 	andi	r2,r2,255
81113a00:	10000126 	beq	r2,zero,81113a08 <bSendUART128v2+0xa8>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81113a04:	11169900 	call	81116990 <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
81113a08:	e0bffc17 	ldw	r2,-16(fp)
81113a0c:	00007d06 	br	81113c04 <bSendUART128v2+0x2a4>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81113a10:	e03ffb05 	stb	zero,-20(fp)
81113a14:	00004306 	br	81113b24 <bSendUART128v2+0x1c4>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
81113a18:	e0fffb03 	ldbu	r3,-20(fp)
81113a1c:	00a04574 	movhi	r2,33045
81113a20:	108cdd04 	addi	r2,r2,13172
81113a24:	18c7883a 	add	r3,r3,r3
81113a28:	18c7883a 	add	r3,r3,r3
81113a2c:	10c5883a 	add	r2,r2,r3
81113a30:	10800017 	ldw	r2,0(r2)
81113a34:	1000381e 	bne	r2,zero,81113b18 <bSendUART128v2+0x1b8>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
81113a38:	e0bffb03 	ldbu	r2,-20(fp)
81113a3c:	10c02324 	muli	r3,r2,140
81113a40:	00a04574 	movhi	r2,33045
81113a44:	108cfb04 	addi	r2,r2,13292
81113a48:	1885883a 	add	r2,r3,r2
81113a4c:	01802004 	movi	r6,128
81113a50:	000b883a 	mov	r5,zero
81113a54:	1009883a 	mov	r4,r2
81113a58:	111acfc0 	call	8111acfc <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
81113a5c:	e0bffb03 	ldbu	r2,-20(fp)
81113a60:	10c02324 	muli	r3,r2,140
81113a64:	00a04574 	movhi	r2,33045
81113a68:	108cfb04 	addi	r2,r2,13292
81113a6c:	1885883a 	add	r2,r3,r2
81113a70:	01801fc4 	movi	r6,127
81113a74:	e17ffe17 	ldw	r5,-8(fp)
81113a78:	1009883a 	mov	r4,r2
81113a7c:	111abac0 	call	8111abac <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
81113a80:	e13ffb03 	ldbu	r4,-20(fp)
81113a84:	e0ffff0b 	ldhu	r3,-4(fp)
81113a88:	00a04574 	movhi	r2,33045
81113a8c:	108cfb04 	addi	r2,r2,13292
81113a90:	21002324 	muli	r4,r4,140
81113a94:	1105883a 	add	r2,r2,r4
81113a98:	10802104 	addi	r2,r2,132
81113a9c:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
81113aa0:	e0fffb03 	ldbu	r3,-20(fp)
81113aa4:	00a04574 	movhi	r2,33045
81113aa8:	108cfb04 	addi	r2,r2,13292
81113aac:	18c02324 	muli	r3,r3,140
81113ab0:	10c5883a 	add	r2,r2,r3
81113ab4:	10802204 	addi	r2,r2,136
81113ab8:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
81113abc:	e0fffb03 	ldbu	r3,-20(fp)
81113ac0:	00a04574 	movhi	r2,33045
81113ac4:	108cfb04 	addi	r2,r2,13292
81113ac8:	18c02324 	muli	r3,r3,140
81113acc:	10c5883a 	add	r2,r2,r3
81113ad0:	10802184 	addi	r2,r2,134
81113ad4:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
81113ad8:	e0fffb03 	ldbu	r3,-20(fp)
81113adc:	00a04574 	movhi	r2,33045
81113ae0:	108cfb04 	addi	r2,r2,13292
81113ae4:	18c02324 	muli	r3,r3,140
81113ae8:	10c5883a 	add	r2,r2,r3
81113aec:	10802004 	addi	r2,r2,128
81113af0:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
81113af4:	e0fffb03 	ldbu	r3,-20(fp)
81113af8:	00a04574 	movhi	r2,33045
81113afc:	108cdd04 	addi	r2,r2,13172
81113b00:	18c7883a 	add	r3,r3,r3
81113b04:	18c7883a 	add	r3,r3,r3
81113b08:	10c5883a 	add	r2,r2,r3
81113b0c:	00c00044 	movi	r3,1
81113b10:	10c00015 	stw	r3,0(r2)
			break;
81113b14:	00000606 	br	81113b30 <bSendUART128v2+0x1d0>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81113b18:	e0bffb03 	ldbu	r2,-20(fp)
81113b1c:	10800044 	addi	r2,r2,1
81113b20:	e0bffb05 	stb	r2,-20(fp)
81113b24:	e0bffb03 	ldbu	r2,-20(fp)
81113b28:	108001b0 	cmpltui	r2,r2,6
81113b2c:	103fba1e 	bne	r2,zero,81113a18 <__reset+0xfb0f3a18>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
81113b30:	e0bffb03 	ldbu	r2,-20(fp)
81113b34:	108001b0 	cmpltui	r2,r2,6
81113b38:	1000091e 	bne	r2,zero,81113b60 <bSendUART128v2+0x200>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81113b3c:	d0a06217 	ldw	r2,-32376(gp)
81113b40:	1009883a 	mov	r4,r2
81113b44:	11379000 	call	81137900 <OSSemPost>
81113b48:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
81113b4c:	d0a06d17 	ldw	r2,-32332(gp)
81113b50:	1009883a 	mov	r4,r2
81113b54:	1135b100 	call	81135b10 <OSMutexPost>
		return bSuccessL;
81113b58:	e0bffc17 	ldw	r2,-16(fp)
81113b5c:	00002906 	br	81113c04 <bSendUART128v2+0x2a4>
	}

	bSuccessL = TRUE;
81113b60:	00800044 	movi	r2,1
81113b64:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
81113b68:	d0a07443 	ldbu	r2,-32303(gp)
81113b6c:	10bfffc4 	addi	r2,r2,-1
81113b70:	d0a07445 	stb	r2,-32303(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81113b74:	d0a07317 	ldw	r2,-32308(gp)
81113b78:	e0fffd04 	addi	r3,fp,-12
81113b7c:	180d883a 	mov	r6,r3
81113b80:	01400084 	movi	r5,2
81113b84:	1009883a 	mov	r4,r2
81113b88:	113556c0 	call	8113556c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81113b8c:	e0bffd03 	ldbu	r2,-12(fp)
81113b90:	10803fcc 	andi	r2,r2,255
81113b94:	10000526 	beq	r2,zero,81113bac <bSendUART128v2+0x24c>
		#if DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81113b98:	d0a06d17 	ldw	r2,-32332(gp)
81113b9c:	1009883a 	mov	r4,r2
81113ba0:	1135b100 	call	81135b10 <OSMutexPost>
		return bSuccessL;
81113ba4:	e0bffc17 	ldw	r2,-16(fp)
81113ba8:	00001606 	br	81113c04 <bSendUART128v2+0x2a4>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
81113bac:	e0bffb03 	ldbu	r2,-20(fp)
81113bb0:	10c02324 	muli	r3,r2,140
81113bb4:	00a04574 	movhi	r2,33045
81113bb8:	108cfb04 	addi	r2,r2,13292
81113bbc:	1885883a 	add	r2,r3,r2
81113bc0:	1009883a 	mov	r4,r2
81113bc4:	111af680 	call	8111af68 <puts>
	xBuffer128[ucIL].bSent = TRUE;
81113bc8:	e0fffb03 	ldbu	r3,-20(fp)
81113bcc:	00a04574 	movhi	r2,33045
81113bd0:	108cfb04 	addi	r2,r2,13292
81113bd4:	18c02324 	muli	r3,r3,140
81113bd8:	10c5883a 	add	r2,r2,r3
81113bdc:	10802004 	addi	r2,r2,128
81113be0:	00c00044 	movi	r3,1
81113be4:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
81113be8:	d0a07317 	ldw	r2,-32308(gp)
81113bec:	1009883a 	mov	r4,r2
81113bf0:	1135b100 	call	81135b10 <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
81113bf4:	d0a06d17 	ldw	r2,-32332(gp)
81113bf8:	1009883a 	mov	r4,r2
81113bfc:	1135b100 	call	81135b10 <OSMutexPost>

	return bSuccessL;
81113c00:	e0bffc17 	ldw	r2,-16(fp)
}
81113c04:	e037883a 	mov	sp,fp
81113c08:	dfc00117 	ldw	ra,4(sp)
81113c0c:	df000017 	ldw	fp,0(sp)
81113c10:	dec00204 	addi	sp,sp,8
81113c14:	f800283a 	ret

81113c18 <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
81113c18:	defff904 	addi	sp,sp,-28
81113c1c:	de00012e 	bgeu	sp,et,81113c24 <bSendUART64v2+0xc>
81113c20:	003b68fa 	trap	3
81113c24:	dfc00615 	stw	ra,24(sp)
81113c28:	df000515 	stw	fp,20(sp)
81113c2c:	df000504 	addi	fp,sp,20
81113c30:	e13ffe15 	stw	r4,-8(fp)
81113c34:	2805883a 	mov	r2,r5
81113c38:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81113c3c:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81113c40:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81113c44:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81113c48:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81113c4c:	d0a05e17 	ldw	r2,-32392(gp)
81113c50:	e0fffd04 	addi	r3,fp,-12
81113c54:	180d883a 	mov	r6,r3
81113c58:	01400504 	movi	r5,20
81113c5c:	1009883a 	mov	r4,r2
81113c60:	11375780 	call	81137578 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81113c64:	e0bffd03 	ldbu	r2,-12(fp)
81113c68:	10803fcc 	andi	r2,r2,255
81113c6c:	10000326 	beq	r2,zero,81113c7c <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81113c70:	11169e00 	call	811169e0 <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
81113c74:	e0bffc17 	ldw	r2,-16(fp)
81113c78:	00009206 	br	81113ec4 <bSendUART64v2+0x2ac>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81113c7c:	d0a07017 	ldw	r2,-32320(gp)
81113c80:	e0fffd04 	addi	r3,fp,-12
81113c84:	180d883a 	mov	r6,r3
81113c88:	01400104 	movi	r5,4
81113c8c:	1009883a 	mov	r4,r2
81113c90:	113556c0 	call	8113556c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81113c94:	e0bffd03 	ldbu	r2,-12(fp)
81113c98:	10803fcc 	andi	r2,r2,255
81113c9c:	10000a26 	beq	r2,zero,81113cc8 <bSendUART64v2+0xb0>
		/* Could not get the mutex, so we need to give the semaphore back */
		#if DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81113ca0:	d0a05e17 	ldw	r2,-32392(gp)
81113ca4:	1009883a 	mov	r4,r2
81113ca8:	11379000 	call	81137900 <OSSemPost>
81113cac:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81113cb0:	e0bffd03 	ldbu	r2,-12(fp)
81113cb4:	10803fcc 	andi	r2,r2,255
81113cb8:	10000126 	beq	r2,zero,81113cc0 <bSendUART64v2+0xa8>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81113cbc:	11169680 	call	81116968 <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
81113cc0:	e0bffc17 	ldw	r2,-16(fp)
81113cc4:	00007f06 	br	81113ec4 <bSendUART64v2+0x2ac>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81113cc8:	e03ffb05 	stb	zero,-20(fp)
81113ccc:	00004506 	br	81113de4 <bSendUART64v2+0x1cc>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
81113cd0:	e0fffb03 	ldbu	r3,-20(fp)
81113cd4:	00a04574 	movhi	r2,33045
81113cd8:	108cdd04 	addi	r2,r2,13172
81113cdc:	18c00184 	addi	r3,r3,6
81113ce0:	18c7883a 	add	r3,r3,r3
81113ce4:	18c7883a 	add	r3,r3,r3
81113ce8:	10c5883a 	add	r2,r2,r3
81113cec:	10800017 	ldw	r2,0(r2)
81113cf0:	1000391e 	bne	r2,zero,81113dd8 <bSendUART64v2+0x1c0>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
81113cf4:	e0bffb03 	ldbu	r2,-20(fp)
81113cf8:	10c01324 	muli	r3,r2,76
81113cfc:	00a04574 	movhi	r2,33045
81113d00:	10a8a104 	addi	r2,r2,-23932
81113d04:	1885883a 	add	r2,r3,r2
81113d08:	01801004 	movi	r6,64
81113d0c:	000b883a 	mov	r5,zero
81113d10:	1009883a 	mov	r4,r2
81113d14:	111acfc0 	call	8111acfc <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
81113d18:	e0bffb03 	ldbu	r2,-20(fp)
81113d1c:	10c01324 	muli	r3,r2,76
81113d20:	00a04574 	movhi	r2,33045
81113d24:	10a8a104 	addi	r2,r2,-23932
81113d28:	1885883a 	add	r2,r3,r2
81113d2c:	01800fc4 	movi	r6,63
81113d30:	e17ffe17 	ldw	r5,-8(fp)
81113d34:	1009883a 	mov	r4,r2
81113d38:	111abac0 	call	8111abac <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
81113d3c:	e13ffb03 	ldbu	r4,-20(fp)
81113d40:	e0ffff0b 	ldhu	r3,-4(fp)
81113d44:	00a04574 	movhi	r2,33045
81113d48:	10a8a104 	addi	r2,r2,-23932
81113d4c:	21001324 	muli	r4,r4,76
81113d50:	1105883a 	add	r2,r2,r4
81113d54:	10801104 	addi	r2,r2,68
81113d58:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
81113d5c:	e0fffb03 	ldbu	r3,-20(fp)
81113d60:	00a04574 	movhi	r2,33045
81113d64:	10a8a104 	addi	r2,r2,-23932
81113d68:	18c01324 	muli	r3,r3,76
81113d6c:	10c5883a 	add	r2,r2,r3
81113d70:	10801204 	addi	r2,r2,72
81113d74:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
81113d78:	e0fffb03 	ldbu	r3,-20(fp)
81113d7c:	00a04574 	movhi	r2,33045
81113d80:	10a8a104 	addi	r2,r2,-23932
81113d84:	18c01324 	muli	r3,r3,76
81113d88:	10c5883a 	add	r2,r2,r3
81113d8c:	10801184 	addi	r2,r2,70
81113d90:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
81113d94:	e0fffb03 	ldbu	r3,-20(fp)
81113d98:	00a04574 	movhi	r2,33045
81113d9c:	10a8a104 	addi	r2,r2,-23932
81113da0:	18c01324 	muli	r3,r3,76
81113da4:	10c5883a 	add	r2,r2,r3
81113da8:	10801004 	addi	r2,r2,64
81113dac:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
81113db0:	e0fffb03 	ldbu	r3,-20(fp)
81113db4:	00a04574 	movhi	r2,33045
81113db8:	108cdd04 	addi	r2,r2,13172
81113dbc:	18c00184 	addi	r3,r3,6
81113dc0:	18c7883a 	add	r3,r3,r3
81113dc4:	18c7883a 	add	r3,r3,r3
81113dc8:	10c5883a 	add	r2,r2,r3
81113dcc:	00c00044 	movi	r3,1
81113dd0:	10c00015 	stw	r3,0(r2)
			break;
81113dd4:	00000606 	br	81113df0 <bSendUART64v2+0x1d8>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81113dd8:	e0bffb03 	ldbu	r2,-20(fp)
81113ddc:	10800044 	addi	r2,r2,1
81113de0:	e0bffb05 	stb	r2,-20(fp)
81113de4:	e0bffb03 	ldbu	r2,-20(fp)
81113de8:	10800230 	cmpltui	r2,r2,8
81113dec:	103fb81e 	bne	r2,zero,81113cd0 <__reset+0xfb0f3cd0>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
81113df0:	e0bffb03 	ldbu	r2,-20(fp)
81113df4:	10800230 	cmpltui	r2,r2,8
81113df8:	1000091e 	bne	r2,zero,81113e20 <bSendUART64v2+0x208>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81113dfc:	d0a05e17 	ldw	r2,-32392(gp)
81113e00:	1009883a 	mov	r4,r2
81113e04:	11379000 	call	81137900 <OSSemPost>
81113e08:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
81113e0c:	d0a07017 	ldw	r2,-32320(gp)
81113e10:	1009883a 	mov	r4,r2
81113e14:	1135b100 	call	81135b10 <OSMutexPost>
		return bSuccessL;
81113e18:	e0bffc17 	ldw	r2,-16(fp)
81113e1c:	00002906 	br	81113ec4 <bSendUART64v2+0x2ac>
	}

	bSuccessL = TRUE;
81113e20:	00800044 	movi	r2,1
81113e24:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
81113e28:	d0a07403 	ldbu	r2,-32304(gp)
81113e2c:	10bfffc4 	addi	r2,r2,-1
81113e30:	d0a07405 	stb	r2,-32304(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81113e34:	d0a07317 	ldw	r2,-32308(gp)
81113e38:	e0fffd04 	addi	r3,fp,-12
81113e3c:	180d883a 	mov	r6,r3
81113e40:	01400084 	movi	r5,2
81113e44:	1009883a 	mov	r4,r2
81113e48:	113556c0 	call	8113556c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81113e4c:	e0bffd03 	ldbu	r2,-12(fp)
81113e50:	10803fcc 	andi	r2,r2,255
81113e54:	10000526 	beq	r2,zero,81113e6c <bSendUART64v2+0x254>
		#if DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
81113e58:	d0a07017 	ldw	r2,-32320(gp)
81113e5c:	1009883a 	mov	r4,r2
81113e60:	1135b100 	call	81135b10 <OSMutexPost>
		return bSuccessL;
81113e64:	e0bffc17 	ldw	r2,-16(fp)
81113e68:	00001606 	br	81113ec4 <bSendUART64v2+0x2ac>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
81113e6c:	e0bffb03 	ldbu	r2,-20(fp)
81113e70:	10c01324 	muli	r3,r2,76
81113e74:	00a04574 	movhi	r2,33045
81113e78:	10a8a104 	addi	r2,r2,-23932
81113e7c:	1885883a 	add	r2,r3,r2
81113e80:	1009883a 	mov	r4,r2
81113e84:	111af680 	call	8111af68 <puts>
	xBuffer64[ucIL].bSent = TRUE;
81113e88:	e0fffb03 	ldbu	r3,-20(fp)
81113e8c:	00a04574 	movhi	r2,33045
81113e90:	10a8a104 	addi	r2,r2,-23932
81113e94:	18c01324 	muli	r3,r3,76
81113e98:	10c5883a 	add	r2,r2,r3
81113e9c:	10801004 	addi	r2,r2,64
81113ea0:	00c00044 	movi	r3,1
81113ea4:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
81113ea8:	d0a07317 	ldw	r2,-32308(gp)
81113eac:	1009883a 	mov	r4,r2
81113eb0:	1135b100 	call	81135b10 <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
81113eb4:	d0a07017 	ldw	r2,-32320(gp)
81113eb8:	1009883a 	mov	r4,r2
81113ebc:	1135b100 	call	81135b10 <OSMutexPost>

	return bSuccessL;
81113ec0:	e0bffc17 	ldw	r2,-16(fp)
}
81113ec4:	e037883a 	mov	sp,fp
81113ec8:	dfc00117 	ldw	ra,4(sp)
81113ecc:	df000017 	ldw	fp,0(sp)
81113ed0:	dec00204 	addi	sp,sp,8
81113ed4:	f800283a 	ret

81113ed8 <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
81113ed8:	defff904 	addi	sp,sp,-28
81113edc:	de00012e 	bgeu	sp,et,81113ee4 <bSendUART32v2+0xc>
81113ee0:	003b68fa 	trap	3
81113ee4:	dfc00615 	stw	ra,24(sp)
81113ee8:	df000515 	stw	fp,20(sp)
81113eec:	df000504 	addi	fp,sp,20
81113ef0:	e13ffe15 	stw	r4,-8(fp)
81113ef4:	2805883a 	mov	r2,r5
81113ef8:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81113efc:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81113f00:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81113f04:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81113f08:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81113f0c:	d0a06e17 	ldw	r2,-32328(gp)
81113f10:	e0fffd04 	addi	r3,fp,-12
81113f14:	180d883a 	mov	r6,r3
81113f18:	01400504 	movi	r5,20
81113f1c:	1009883a 	mov	r4,r2
81113f20:	11375780 	call	81137578 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81113f24:	e0bffd03 	ldbu	r2,-12(fp)
81113f28:	10803fcc 	andi	r2,r2,255
81113f2c:	10000326 	beq	r2,zero,81113f3c <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81113f30:	1116a080 	call	81116a08 <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
81113f34:	e0bffc17 	ldw	r2,-16(fp)
81113f38:	00009206 	br	81114184 <bSendUART32v2+0x2ac>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81113f3c:	d0a06b17 	ldw	r2,-32340(gp)
81113f40:	e0fffd04 	addi	r3,fp,-12
81113f44:	180d883a 	mov	r6,r3
81113f48:	01400104 	movi	r5,4
81113f4c:	1009883a 	mov	r4,r2
81113f50:	113556c0 	call	8113556c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81113f54:	e0bffd03 	ldbu	r2,-12(fp)
81113f58:	10803fcc 	andi	r2,r2,255
81113f5c:	10000a26 	beq	r2,zero,81113f88 <bSendUART32v2+0xb0>
		/* Could not get the mutex, so we need to give the semaphore back */
		#if DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81113f60:	d0a06e17 	ldw	r2,-32328(gp)
81113f64:	1009883a 	mov	r4,r2
81113f68:	11379000 	call	81137900 <OSSemPost>
81113f6c:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81113f70:	e0bffd03 	ldbu	r2,-12(fp)
81113f74:	10803fcc 	andi	r2,r2,255
81113f78:	10000126 	beq	r2,zero,81113f80 <bSendUART32v2+0xa8>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81113f7c:	11169400 	call	81116940 <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
81113f80:	e0bffc17 	ldw	r2,-16(fp)
81113f84:	00007f06 	br	81114184 <bSendUART32v2+0x2ac>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81113f88:	e03ffb05 	stb	zero,-20(fp)
81113f8c:	00004506 	br	811140a4 <bSendUART32v2+0x1cc>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
81113f90:	e0fffb03 	ldbu	r3,-20(fp)
81113f94:	00a04574 	movhi	r2,33045
81113f98:	108cdd04 	addi	r2,r2,13172
81113f9c:	18c00384 	addi	r3,r3,14
81113fa0:	18c7883a 	add	r3,r3,r3
81113fa4:	18c7883a 	add	r3,r3,r3
81113fa8:	10c5883a 	add	r2,r2,r3
81113fac:	10800017 	ldw	r2,0(r2)
81113fb0:	1000391e 	bne	r2,zero,81114098 <bSendUART32v2+0x1c0>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
81113fb4:	e0bffb03 	ldbu	r2,-20(fp)
81113fb8:	10c00b24 	muli	r3,r2,44
81113fbc:	00a04574 	movhi	r2,33045
81113fc0:	10ba5d04 	addi	r2,r2,-5772
81113fc4:	1885883a 	add	r2,r3,r2
81113fc8:	01800804 	movi	r6,32
81113fcc:	000b883a 	mov	r5,zero
81113fd0:	1009883a 	mov	r4,r2
81113fd4:	111acfc0 	call	8111acfc <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
81113fd8:	e0bffb03 	ldbu	r2,-20(fp)
81113fdc:	10c00b24 	muli	r3,r2,44
81113fe0:	00a04574 	movhi	r2,33045
81113fe4:	10ba5d04 	addi	r2,r2,-5772
81113fe8:	1885883a 	add	r2,r3,r2
81113fec:	018007c4 	movi	r6,31
81113ff0:	e17ffe17 	ldw	r5,-8(fp)
81113ff4:	1009883a 	mov	r4,r2
81113ff8:	111abac0 	call	8111abac <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
81113ffc:	e13ffb03 	ldbu	r4,-20(fp)
81114000:	e0ffff0b 	ldhu	r3,-4(fp)
81114004:	00a04574 	movhi	r2,33045
81114008:	10ba5d04 	addi	r2,r2,-5772
8111400c:	21000b24 	muli	r4,r4,44
81114010:	1105883a 	add	r2,r2,r4
81114014:	10800904 	addi	r2,r2,36
81114018:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
8111401c:	e0fffb03 	ldbu	r3,-20(fp)
81114020:	00a04574 	movhi	r2,33045
81114024:	10ba5d04 	addi	r2,r2,-5772
81114028:	18c00b24 	muli	r3,r3,44
8111402c:	10c5883a 	add	r2,r2,r3
81114030:	10800a04 	addi	r2,r2,40
81114034:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
81114038:	e0fffb03 	ldbu	r3,-20(fp)
8111403c:	00a04574 	movhi	r2,33045
81114040:	10ba5d04 	addi	r2,r2,-5772
81114044:	18c00b24 	muli	r3,r3,44
81114048:	10c5883a 	add	r2,r2,r3
8111404c:	10800984 	addi	r2,r2,38
81114050:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
81114054:	e0fffb03 	ldbu	r3,-20(fp)
81114058:	00a04574 	movhi	r2,33045
8111405c:	10ba5d04 	addi	r2,r2,-5772
81114060:	18c00b24 	muli	r3,r3,44
81114064:	10c5883a 	add	r2,r2,r3
81114068:	10800804 	addi	r2,r2,32
8111406c:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
81114070:	e0fffb03 	ldbu	r3,-20(fp)
81114074:	00a04574 	movhi	r2,33045
81114078:	108cdd04 	addi	r2,r2,13172
8111407c:	18c00384 	addi	r3,r3,14
81114080:	18c7883a 	add	r3,r3,r3
81114084:	18c7883a 	add	r3,r3,r3
81114088:	10c5883a 	add	r2,r2,r3
8111408c:	00c00044 	movi	r3,1
81114090:	10c00015 	stw	r3,0(r2)
			break;
81114094:	00000606 	br	811140b0 <bSendUART32v2+0x1d8>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81114098:	e0bffb03 	ldbu	r2,-20(fp)
8111409c:	10800044 	addi	r2,r2,1
811140a0:	e0bffb05 	stb	r2,-20(fp)
811140a4:	e0bffb03 	ldbu	r2,-20(fp)
811140a8:	10800230 	cmpltui	r2,r2,8
811140ac:	103fb81e 	bne	r2,zero,81113f90 <__reset+0xfb0f3f90>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
811140b0:	e0bffb03 	ldbu	r2,-20(fp)
811140b4:	10800230 	cmpltui	r2,r2,8
811140b8:	1000091e 	bne	r2,zero,811140e0 <bSendUART32v2+0x208>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
811140bc:	d0a06e17 	ldw	r2,-32328(gp)
811140c0:	1009883a 	mov	r4,r2
811140c4:	11379000 	call	81137900 <OSSemPost>
811140c8:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
811140cc:	d0a06b17 	ldw	r2,-32340(gp)
811140d0:	1009883a 	mov	r4,r2
811140d4:	1135b100 	call	81135b10 <OSMutexPost>
		return bSuccessL;
811140d8:	e0bffc17 	ldw	r2,-16(fp)
811140dc:	00002906 	br	81114184 <bSendUART32v2+0x2ac>
	}
	
	bSuccessL = TRUE;
811140e0:	00800044 	movi	r2,1
811140e4:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
811140e8:	d0a06783 	ldbu	r2,-32354(gp)
811140ec:	10bfffc4 	addi	r2,r2,-1
811140f0:	d0a06785 	stb	r2,-32354(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
811140f4:	d0a07317 	ldw	r2,-32308(gp)
811140f8:	e0fffd04 	addi	r3,fp,-12
811140fc:	180d883a 	mov	r6,r3
81114100:	01400084 	movi	r5,2
81114104:	1009883a 	mov	r4,r2
81114108:	113556c0 	call	8113556c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111410c:	e0bffd03 	ldbu	r2,-12(fp)
81114110:	10803fcc 	andi	r2,r2,255
81114114:	10000526 	beq	r2,zero,8111412c <bSendUART32v2+0x254>
		#if DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
81114118:	d0a06b17 	ldw	r2,-32340(gp)
8111411c:	1009883a 	mov	r4,r2
81114120:	1135b100 	call	81135b10 <OSMutexPost>
		return bSuccessL;
81114124:	e0bffc17 	ldw	r2,-16(fp)
81114128:	00001606 	br	81114184 <bSendUART32v2+0x2ac>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
8111412c:	e0bffb03 	ldbu	r2,-20(fp)
81114130:	10c00b24 	muli	r3,r2,44
81114134:	00a04574 	movhi	r2,33045
81114138:	10ba5d04 	addi	r2,r2,-5772
8111413c:	1885883a 	add	r2,r3,r2
81114140:	1009883a 	mov	r4,r2
81114144:	111af680 	call	8111af68 <puts>
	xBuffer32[ucIL].bSent = TRUE;
81114148:	e0fffb03 	ldbu	r3,-20(fp)
8111414c:	00a04574 	movhi	r2,33045
81114150:	10ba5d04 	addi	r2,r2,-5772
81114154:	18c00b24 	muli	r3,r3,44
81114158:	10c5883a 	add	r2,r2,r3
8111415c:	10800804 	addi	r2,r2,32
81114160:	00c00044 	movi	r3,1
81114164:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
81114168:	d0a07317 	ldw	r2,-32308(gp)
8111416c:	1009883a 	mov	r4,r2
81114170:	1135b100 	call	81135b10 <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
81114174:	d0a06b17 	ldw	r2,-32340(gp)
81114178:	1009883a 	mov	r4,r2
8111417c:	1135b100 	call	81135b10 <OSMutexPost>

	return bSuccessL;
81114180:	e0bffc17 	ldw	r2,-16(fp)
}
81114184:	e037883a 	mov	sp,fp
81114188:	dfc00117 	ldw	ra,4(sp)
8111418c:	df000017 	ldw	fp,0(sp)
81114190:	dec00204 	addi	sp,sp,8
81114194:	f800283a 	ret

81114198 <vSendEthConf>:


void vSendEthConf ( void ) {
81114198:	deffc304 	addi	sp,sp,-244
8111419c:	de00012e 	bgeu	sp,et,811141a4 <vSendEthConf+0xc>
811141a0:	003b68fa 	trap	3
811141a4:	dfc03c15 	stw	ra,240(sp)
811141a8:	df003b15 	stw	fp,236(sp)
811141ac:	dd403a15 	stw	r21,232(sp)
811141b0:	dd003915 	stw	r20,228(sp)
811141b4:	dcc03815 	stw	r19,224(sp)
811141b8:	dc803715 	stw	r18,220(sp)
811141bc:	dc403615 	stw	r17,216(sp)
811141c0:	dc003515 	stw	r16,212(sp)
811141c4:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
811141c8:	e03fd98d 	sth	zero,-154(fp)
811141cc:	e03fda0d 	sth	zero,-152(fp)
811141d0:	e0bfda84 	addi	r2,fp,-150
811141d4:	00c01f04 	movi	r3,124
811141d8:	180d883a 	mov	r6,r3
811141dc:	000b883a 	mov	r5,zero
811141e0:	1009883a 	mov	r4,r2
811141e4:	111acfc0 	call	8111acfc <memset>
    unsigned char crc = 0;
811141e8:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
811141ec:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
811141f0:	11147580 	call	81114758 <usiGetIdCMD>
811141f4:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811141f8:	e57fd90b 	ldhu	r21,-156(fp)
811141fc:	00a045b4 	movhi	r2,33046
81114200:	10acd004 	addi	r2,r2,-19648
81114204:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81114208:	00a045b4 	movhi	r2,33046
8111420c:	10acd004 	addi	r2,r2,-19648
81114210:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114214:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81114218:	00a045b4 	movhi	r2,33046
8111421c:	10acd004 	addi	r2,r2,-19648
81114220:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114224:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81114228:	00a045b4 	movhi	r2,33046
8111422c:	10acd004 	addi	r2,r2,-19648
81114230:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114234:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81114238:	00a045b4 	movhi	r2,33046
8111423c:	10acd004 	addi	r2,r2,-19648
81114240:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114244:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81114248:	00a045b4 	movhi	r2,33046
8111424c:	10acd004 	addi	r2,r2,-19648
81114250:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114254:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81114258:	00a045b4 	movhi	r2,33046
8111425c:	10acd004 	addi	r2,r2,-19648
81114260:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114264:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81114268:	00a045b4 	movhi	r2,33046
8111426c:	10acd004 	addi	r2,r2,-19648
81114270:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114274:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81114278:	00a045b4 	movhi	r2,33046
8111427c:	10acd004 	addi	r2,r2,-19648
81114280:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114284:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81114288:	00a045b4 	movhi	r2,33046
8111428c:	10acd004 	addi	r2,r2,-19648
81114290:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114294:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81114298:	00a045b4 	movhi	r2,33046
8111429c:	10acd004 	addi	r2,r2,-19648
811142a0:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811142a4:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
811142a8:	00a045b4 	movhi	r2,33046
811142ac:	10acd004 	addi	r2,r2,-19648
811142b0:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811142b4:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
811142b8:	00a045b4 	movhi	r2,33046
811142bc:	10acd004 	addi	r2,r2,-19648
811142c0:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811142c4:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
811142c8:	00a045b4 	movhi	r2,33046
811142cc:	10acd004 	addi	r2,r2,-19648
811142d0:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811142d4:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
811142d8:	00a045b4 	movhi	r2,33046
811142dc:	10acd004 	addi	r2,r2,-19648
811142e0:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811142e4:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
811142e8:	00a045b4 	movhi	r2,33046
811142ec:	10acd004 	addi	r2,r2,-19648
811142f0:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811142f4:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
811142f8:	00a045b4 	movhi	r2,33046
811142fc:	10acd004 	addi	r2,r2,-19648
81114300:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114304:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
81114308:	00a045b4 	movhi	r2,33046
8111430c:	10acd004 	addi	r2,r2,-19648
81114310:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
81114314:	10bfffcc 	andi	r2,r2,65535
81114318:	e53fd984 	addi	r20,fp,-154
8111431c:	d8801115 	stw	r2,68(sp)
81114320:	dcc01015 	stw	r19,64(sp)
81114324:	dc800f15 	stw	r18,60(sp)
81114328:	dc400e15 	stw	r17,56(sp)
8111432c:	dc000d15 	stw	r16,52(sp)
81114330:	dbc00c15 	stw	r15,48(sp)
81114334:	db800b15 	stw	r14,44(sp)
81114338:	db400a15 	stw	r13,40(sp)
8111433c:	db000915 	stw	r12,36(sp)
81114340:	dac00815 	stw	r11,32(sp)
81114344:	da800715 	stw	r10,28(sp)
81114348:	da400615 	stw	r9,24(sp)
8111434c:	da000515 	stw	r8,20(sp)
81114350:	d9c00415 	stw	r7,16(sp)
81114354:	d9800315 	stw	r6,12(sp)
81114358:	d9400215 	stw	r5,8(sp)
8111435c:	d9000115 	stw	r4,4(sp)
81114360:	d8c00015 	stw	r3,0(sp)
81114364:	a80f883a 	mov	r7,r21
81114368:	018010c4 	movi	r6,67
8111436c:	01604534 	movhi	r5,33044
81114370:	2952a904 	addi	r5,r5,19108
81114374:	a009883a 	mov	r4,r20
81114378:	111b0580 	call	8111b058 <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
8111437c:	e0bfd984 	addi	r2,fp,-154
81114380:	1009883a 	mov	r4,r2
81114384:	111b1180 	call	8111b118 <strlen>
81114388:	1007883a 	mov	r3,r2
8111438c:	e0bfd984 	addi	r2,fp,-154
81114390:	180b883a 	mov	r5,r3
81114394:	1009883a 	mov	r4,r2
81114398:	111652c0 	call	8111652c <ucCrc8wInit>
8111439c:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
811143a0:	e13fd703 	ldbu	r4,-164(fp)
811143a4:	e0ffd984 	addi	r3,fp,-154
811143a8:	e0bfd984 	addi	r2,fp,-154
811143ac:	200f883a 	mov	r7,r4
811143b0:	180d883a 	mov	r6,r3
811143b4:	01604534 	movhi	r5,33044
811143b8:	2952c104 	addi	r5,r5,19204
811143bc:	1009883a 	mov	r4,r2
811143c0:	111b0580 	call	8111b058 <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
811143c4:	e0bfd90b 	ldhu	r2,-156(fp)
811143c8:	10ffffcc 	andi	r3,r2,65535
811143cc:	18e0001c 	xori	r3,r3,32768
811143d0:	18e00004 	addi	r3,r3,-32768
811143d4:	e0bfd984 	addi	r2,fp,-154
811143d8:	180b883a 	mov	r5,r3
811143dc:	1009883a 	mov	r4,r2
811143e0:	11139600 	call	81113960 <bSendUART128v2>
811143e4:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
811143e8:	e0bfd817 	ldw	r2,-160(fp)
811143ec:	10800060 	cmpeqi	r2,r2,1
811143f0:	1000011e 	bne	r2,zero,811143f8 <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
811143f4:	1116ad00 	call	81116ad0 <vCouldNotSendEthConfUART>
	}
}
811143f8:	0001883a 	nop
811143fc:	e6fffa04 	addi	sp,fp,-24
81114400:	dfc00717 	ldw	ra,28(sp)
81114404:	df000617 	ldw	fp,24(sp)
81114408:	dd400517 	ldw	r21,20(sp)
8111440c:	dd000417 	ldw	r20,16(sp)
81114410:	dcc00317 	ldw	r19,12(sp)
81114414:	dc800217 	ldw	r18,8(sp)
81114418:	dc400117 	ldw	r17,4(sp)
8111441c:	dc000017 	ldw	r16,0(sp)
81114420:	dec00804 	addi	sp,sp,32
81114424:	f800283a 	ret

81114428 <vSendTurnOff>:


void vSendTurnOff ( void ) {
81114428:	defff304 	addi	sp,sp,-52
8111442c:	de00012e 	bgeu	sp,et,81114434 <vSendTurnOff+0xc>
81114430:	003b68fa 	trap	3
81114434:	dfc00c15 	stw	ra,48(sp)
81114438:	df000b15 	stw	fp,44(sp)
8111443c:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81114440:	e03ff78d 	sth	zero,-34(fp)
81114444:	e03ff80d 	sth	zero,-32(fp)
81114448:	e03ff88d 	sth	zero,-30(fp)
8111444c:	e03ff90d 	sth	zero,-28(fp)
81114450:	e03ff98d 	sth	zero,-26(fp)
81114454:	e03ffa0d 	sth	zero,-24(fp)
81114458:	e03ffa8d 	sth	zero,-22(fp)
8111445c:	e03ffb0d 	sth	zero,-20(fp)
81114460:	e03ffb8d 	sth	zero,-18(fp)
81114464:	e03ffc0d 	sth	zero,-16(fp)
81114468:	e03ffc8d 	sth	zero,-14(fp)
8111446c:	e03ffd0d 	sth	zero,-12(fp)
81114470:	e03ffd8d 	sth	zero,-10(fp)
81114474:	e03ffe0d 	sth	zero,-8(fp)
81114478:	e03ffe8d 	sth	zero,-6(fp)
8111447c:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81114480:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81114484:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81114488:	11147580 	call	81114758 <usiGetIdCMD>
8111448c:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
81114490:	e0fff70b 	ldhu	r3,-36(fp)
81114494:	e0bff784 	addi	r2,fp,-34
81114498:	180d883a 	mov	r6,r3
8111449c:	01604534 	movhi	r5,33044
811144a0:	2952c404 	addi	r5,r5,19216
811144a4:	1009883a 	mov	r4,r2
811144a8:	111b0580 	call	8111b058 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
811144ac:	e0bff784 	addi	r2,fp,-34
811144b0:	1009883a 	mov	r4,r2
811144b4:	111b1180 	call	8111b118 <strlen>
811144b8:	1007883a 	mov	r3,r2
811144bc:	e0bff784 	addi	r2,fp,-34
811144c0:	180b883a 	mov	r5,r3
811144c4:	1009883a 	mov	r4,r2
811144c8:	111652c0 	call	8111652c <ucCrc8wInit>
811144cc:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
811144d0:	e13ff503 	ldbu	r4,-44(fp)
811144d4:	e0fff784 	addi	r3,fp,-34
811144d8:	e0bff784 	addi	r2,fp,-34
811144dc:	200f883a 	mov	r7,r4
811144e0:	180d883a 	mov	r6,r3
811144e4:	01604534 	movhi	r5,33044
811144e8:	2952c104 	addi	r5,r5,19204
811144ec:	1009883a 	mov	r4,r2
811144f0:	111b0580 	call	8111b058 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
811144f4:	e0bff70b 	ldhu	r2,-36(fp)
811144f8:	10ffffcc 	andi	r3,r2,65535
811144fc:	18e0001c 	xori	r3,r3,32768
81114500:	18e00004 	addi	r3,r3,-32768
81114504:	e0bff784 	addi	r2,fp,-34
81114508:	180b883a 	mov	r5,r3
8111450c:	1009883a 	mov	r4,r2
81114510:	1113ed80 	call	81113ed8 <bSendUART32v2>
81114514:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81114518:	e0bff617 	ldw	r2,-40(fp)
8111451c:	10800060 	cmpeqi	r2,r2,1
81114520:	1000011e 	bne	r2,zero,81114528 <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
81114524:	1116da00 	call	81116da0 <vCouldNotSendTurnOff>
	}
}
81114528:	0001883a 	nop
8111452c:	e037883a 	mov	sp,fp
81114530:	dfc00117 	ldw	ra,4(sp)
81114534:	df000017 	ldw	fp,0(sp)
81114538:	dec00204 	addi	sp,sp,8
8111453c:	f800283a 	ret

81114540 <vSendReset>:

void vSendReset ( void ) {
81114540:	defff304 	addi	sp,sp,-52
81114544:	de00012e 	bgeu	sp,et,8111454c <vSendReset+0xc>
81114548:	003b68fa 	trap	3
8111454c:	dfc00c15 	stw	ra,48(sp)
81114550:	df000b15 	stw	fp,44(sp)
81114554:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81114558:	e03ff78d 	sth	zero,-34(fp)
8111455c:	e03ff80d 	sth	zero,-32(fp)
81114560:	e03ff88d 	sth	zero,-30(fp)
81114564:	e03ff90d 	sth	zero,-28(fp)
81114568:	e03ff98d 	sth	zero,-26(fp)
8111456c:	e03ffa0d 	sth	zero,-24(fp)
81114570:	e03ffa8d 	sth	zero,-22(fp)
81114574:	e03ffb0d 	sth	zero,-20(fp)
81114578:	e03ffb8d 	sth	zero,-18(fp)
8111457c:	e03ffc0d 	sth	zero,-16(fp)
81114580:	e03ffc8d 	sth	zero,-14(fp)
81114584:	e03ffd0d 	sth	zero,-12(fp)
81114588:	e03ffd8d 	sth	zero,-10(fp)
8111458c:	e03ffe0d 	sth	zero,-8(fp)
81114590:	e03ffe8d 	sth	zero,-6(fp)
81114594:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81114598:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111459c:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
811145a0:	11147580 	call	81114758 <usiGetIdCMD>
811145a4:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
811145a8:	e0fff70b 	ldhu	r3,-36(fp)
811145ac:	e0bff784 	addi	r2,fp,-34
811145b0:	180d883a 	mov	r6,r3
811145b4:	01604534 	movhi	r5,33044
811145b8:	2952c604 	addi	r5,r5,19224
811145bc:	1009883a 	mov	r4,r2
811145c0:	111b0580 	call	8111b058 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
811145c4:	e0bff784 	addi	r2,fp,-34
811145c8:	1009883a 	mov	r4,r2
811145cc:	111b1180 	call	8111b118 <strlen>
811145d0:	1007883a 	mov	r3,r2
811145d4:	e0bff784 	addi	r2,fp,-34
811145d8:	180b883a 	mov	r5,r3
811145dc:	1009883a 	mov	r4,r2
811145e0:	111652c0 	call	8111652c <ucCrc8wInit>
811145e4:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
811145e8:	e13ff503 	ldbu	r4,-44(fp)
811145ec:	e0fff784 	addi	r3,fp,-34
811145f0:	e0bff784 	addi	r2,fp,-34
811145f4:	200f883a 	mov	r7,r4
811145f8:	180d883a 	mov	r6,r3
811145fc:	01604534 	movhi	r5,33044
81114600:	2952c104 	addi	r5,r5,19204
81114604:	1009883a 	mov	r4,r2
81114608:	111b0580 	call	8111b058 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
8111460c:	e0bff70b 	ldhu	r2,-36(fp)
81114610:	10ffffcc 	andi	r3,r2,65535
81114614:	18e0001c 	xori	r3,r3,32768
81114618:	18e00004 	addi	r3,r3,-32768
8111461c:	e0bff784 	addi	r2,fp,-34
81114620:	180b883a 	mov	r5,r3
81114624:	1009883a 	mov	r4,r2
81114628:	1113ed80 	call	81113ed8 <bSendUART32v2>
8111462c:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81114630:	e0bff617 	ldw	r2,-40(fp)
81114634:	10800060 	cmpeqi	r2,r2,1
81114638:	1000011e 	bne	r2,zero,81114640 <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8111463c:	1116da00 	call	81116da0 <vCouldNotSendTurnOff>
	}
}
81114640:	0001883a 	nop
81114644:	e037883a 	mov	sp,fp
81114648:	dfc00117 	ldw	ra,4(sp)
8111464c:	df000017 	ldw	fp,0(sp)
81114650:	dec00204 	addi	sp,sp,8
81114654:	f800283a 	ret

81114658 <vSendLog>:

void vSendLog ( const char * cDataIn ) {
81114658:	deffda04 	addi	sp,sp,-152
8111465c:	de00012e 	bgeu	sp,et,81114664 <vSendLog+0xc>
81114660:	003b68fa 	trap	3
81114664:	dfc02515 	stw	ra,148(sp)
81114668:	df002415 	stw	fp,144(sp)
8111466c:	df002404 	addi	fp,sp,144
81114670:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
81114674:	e03fde8d 	sth	zero,-134(fp)
81114678:	e03fdf0d 	sth	zero,-132(fp)
8111467c:	e0bfdf84 	addi	r2,fp,-130
81114680:	00c01f04 	movi	r3,124
81114684:	180d883a 	mov	r6,r3
81114688:	000b883a 	mov	r5,zero
8111468c:	1009883a 	mov	r4,r2
81114690:	111acfc0 	call	8111acfc <memset>
    unsigned char crc = 0;
81114694:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81114698:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111469c:	11147580 	call	81114758 <usiGetIdCMD>
811146a0:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
811146a4:	e0ffde0b 	ldhu	r3,-136(fp)
811146a8:	e0bfde84 	addi	r2,fp,-134
811146ac:	e1ffff17 	ldw	r7,-4(fp)
811146b0:	180d883a 	mov	r6,r3
811146b4:	01604534 	movhi	r5,33044
811146b8:	2952c804 	addi	r5,r5,19232
811146bc:	1009883a 	mov	r4,r2
811146c0:	111b0580 	call	8111b058 <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
811146c4:	e0bfde84 	addi	r2,fp,-134
811146c8:	1009883a 	mov	r4,r2
811146cc:	111b1180 	call	8111b118 <strlen>
811146d0:	1007883a 	mov	r3,r2
811146d4:	e0bfde84 	addi	r2,fp,-134
811146d8:	180b883a 	mov	r5,r3
811146dc:	1009883a 	mov	r4,r2
811146e0:	111652c0 	call	8111652c <ucCrc8wInit>
811146e4:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
811146e8:	e13fdc03 	ldbu	r4,-144(fp)
811146ec:	e0ffde84 	addi	r3,fp,-134
811146f0:	e0bfde84 	addi	r2,fp,-134
811146f4:	200f883a 	mov	r7,r4
811146f8:	180d883a 	mov	r6,r3
811146fc:	01604534 	movhi	r5,33044
81114700:	2952c104 	addi	r5,r5,19204
81114704:	1009883a 	mov	r4,r2
81114708:	111b0580 	call	8111b058 <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
8111470c:	e0bfde0b 	ldhu	r2,-136(fp)
81114710:	10ffffcc 	andi	r3,r2,65535
81114714:	18e0001c 	xori	r3,r3,32768
81114718:	18e00004 	addi	r3,r3,-32768
8111471c:	e0bfde84 	addi	r2,fp,-134
81114720:	180b883a 	mov	r5,r3
81114724:	1009883a 	mov	r4,r2
81114728:	11139600 	call	81113960 <bSendUART128v2>
8111472c:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
81114730:	e0bfdd17 	ldw	r2,-140(fp)
81114734:	10800060 	cmpeqi	r2,r2,1
81114738:	1000011e 	bne	r2,zero,81114740 <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
8111473c:	1116df00 	call	81116df0 <vCouldNotSendLog>
	}
}
81114740:	0001883a 	nop
81114744:	e037883a 	mov	sp,fp
81114748:	dfc00117 	ldw	ra,4(sp)
8111474c:	df000017 	ldw	fp,0(sp)
81114750:	dec00204 	addi	sp,sp,8
81114754:	f800283a 	ret

81114758 <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
81114758:	deffff04 	addi	sp,sp,-4
8111475c:	de00012e 	bgeu	sp,et,81114764 <usiGetIdCMD+0xc>
81114760:	003b68fa 	trap	3
81114764:	df000015 	stw	fp,0(sp)
81114768:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
8111476c:	d0a0670b 	ldhu	r2,-32356(gp)
81114770:	10ffffcc 	andi	r3,r2,65535
81114774:	00bfffd4 	movui	r2,65535
81114778:	1880031e 	bne	r3,r2,81114788 <usiGetIdCMD+0x30>
        usiIdCMD = 2;
8111477c:	00800084 	movi	r2,2
81114780:	d0a0670d 	sth	r2,-32356(gp)
81114784:	00000306 	br	81114794 <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
81114788:	d0a0670b 	ldhu	r2,-32356(gp)
8111478c:	10800044 	addi	r2,r2,1
81114790:	d0a0670d 	sth	r2,-32356(gp)

    return usiIdCMD;
81114794:	d0a0670b 	ldhu	r2,-32356(gp)
}
81114798:	e037883a 	mov	sp,fp
8111479c:	df000017 	ldw	fp,0(sp)
811147a0:	dec00104 	addi	sp,sp,4
811147a4:	f800283a 	ret

811147a8 <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
811147a8:	defffb04 	addi	sp,sp,-20
811147ac:	de00012e 	bgeu	sp,et,811147b4 <siPosStr+0xc>
811147b0:	003b68fa 	trap	3
811147b4:	dfc00415 	stw	ra,16(sp)
811147b8:	df000315 	stw	fp,12(sp)
811147bc:	df000304 	addi	fp,sp,12
811147c0:	e13ffe15 	stw	r4,-8(fp)
811147c4:	2805883a 	mov	r2,r5
811147c8:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
811147cc:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
811147d0:	e0bfff03 	ldbu	r2,-4(fp)
811147d4:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
811147d8:	e17ffd04 	addi	r5,fp,-12
811147dc:	e13ffe17 	ldw	r4,-8(fp)
811147e0:	111b0cc0 	call	8111b0cc <strcspn>
}
811147e4:	e037883a 	mov	sp,fp
811147e8:	dfc00117 	ldw	ra,4(sp)
811147ec:	df000017 	ldw	fp,0(sp)
811147f0:	dec00204 	addi	sp,sp,8
811147f4:	f800283a 	ret

811147f8 <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
811147f8:	defffc04 	addi	sp,sp,-16
811147fc:	de00012e 	bgeu	sp,et,81114804 <vTimeoutCheck+0xc>
81114800:	003b68fa 	trap	3
81114804:	dfc00315 	stw	ra,12(sp)
81114808:	df000215 	stw	fp,8(sp)
8111480c:	df000204 	addi	fp,sp,8
81114810:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
81114814:	d0a06617 	ldw	r2,-32360(gp)
81114818:	1009883a 	mov	r4,r2
8111481c:	11379000 	call	81137900 <OSSemPost>
81114820:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
81114824:	e0bffe03 	ldbu	r2,-8(fp)
81114828:	10000126 	beq	r2,zero,81114830 <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
8111482c:	1116cb00 	call	81116cb0 <vFailPostBlockingSemTimeoutTask>
	}
}
81114830:	0001883a 	nop
81114834:	e037883a 	mov	sp,fp
81114838:	dfc00117 	ldw	ra,4(sp)
8111483c:	df000017 	ldw	fp,0(sp)
81114840:	dec00204 	addi	sp,sp,8
81114844:	f800283a 	ret

81114848 <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
81114848:	deffe304 	addi	sp,sp,-116
8111484c:	de00012e 	bgeu	sp,et,81114854 <vSendPusTM64+0xc>
81114850:	003b68fa 	trap	3
81114854:	dfc01815 	stw	ra,96(sp)
81114858:	df001715 	stw	fp,92(sp)
8111485c:	df001704 	addi	fp,sp,92
81114860:	e1000215 	stw	r4,8(fp)
81114864:	e1400315 	stw	r5,12(fp)
81114868:	e1800415 	stw	r6,16(fp)
8111486c:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
81114870:	e03fef8d 	sth	zero,-66(fp)
81114874:	e03ff00d 	sth	zero,-64(fp)
81114878:	e0bff084 	addi	r2,fp,-62
8111487c:	00c00f04 	movi	r3,60
81114880:	180d883a 	mov	r6,r3
81114884:	000b883a 	mov	r5,zero
81114888:	1009883a 	mov	r4,r2
8111488c:	111acfc0 	call	8111acfc <memset>
    unsigned char crc = 0;
81114890:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
81114894:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81114898:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111489c:	11147580 	call	81114758 <usiGetIdCMD>
811148a0:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
811148a4:	e1bfef0b 	ldhu	r6,-68(fp)
811148a8:	e080040b 	ldhu	r2,16(fp)
811148ac:	11ffffcc 	andi	r7,r2,65535
811148b0:	e080048b 	ldhu	r2,18(fp)
811148b4:	10bfffcc 	andi	r2,r2,65535
811148b8:	e0c0050b 	ldhu	r3,20(fp)
811148bc:	18ffffcc 	andi	r3,r3,65535
811148c0:	e100058b 	ldhu	r4,22(fp)
811148c4:	213fffcc 	andi	r4,r4,65535
811148c8:	e140060b 	ldhu	r5,24(fp)
811148cc:	297fffcc 	andi	r5,r5,65535
811148d0:	e23fef84 	addi	r8,fp,-66
811148d4:	d9400315 	stw	r5,12(sp)
811148d8:	d9000215 	stw	r4,8(sp)
811148dc:	d8c00115 	stw	r3,4(sp)
811148e0:	d8800015 	stw	r2,0(sp)
811148e4:	01604534 	movhi	r5,33044
811148e8:	2952cb04 	addi	r5,r5,19244
811148ec:	4009883a 	mov	r4,r8
811148f0:	111b0580 	call	8111b058 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
811148f4:	e03fed05 	stb	zero,-76(fp)
811148f8:	00001206 	br	81114944 <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
811148fc:	e0bfed03 	ldbu	r2,-76(fp)
81114900:	10800284 	addi	r2,r2,10
81114904:	1085883a 	add	r2,r2,r2
81114908:	e0c00204 	addi	r3,fp,8
8111490c:	1885883a 	add	r2,r3,r2
81114910:	1080000b 	ldhu	r2,0(r2)
81114914:	113fffcc 	andi	r4,r2,65535
81114918:	e0ffef84 	addi	r3,fp,-66
8111491c:	e0bfef84 	addi	r2,fp,-66
81114920:	200f883a 	mov	r7,r4
81114924:	180d883a 	mov	r6,r3
81114928:	01604534 	movhi	r5,33044
8111492c:	2952d204 	addi	r5,r5,19272
81114930:	1009883a 	mov	r4,r2
81114934:	111b0580 	call	8111b058 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81114938:	e0bfed03 	ldbu	r2,-76(fp)
8111493c:	10800044 	addi	r2,r2,1
81114940:	e0bfed05 	stb	r2,-76(fp)
81114944:	e0800683 	ldbu	r2,26(fp)
81114948:	10803fcc 	andi	r2,r2,255
8111494c:	e0ffed03 	ldbu	r3,-76(fp)
81114950:	18bfea36 	bltu	r3,r2,811148fc <__reset+0xfb0f48fc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
81114954:	e0bfef84 	addi	r2,fp,-66
81114958:	1009883a 	mov	r4,r2
8111495c:	111b1180 	call	8111b118 <strlen>
81114960:	1007883a 	mov	r3,r2
81114964:	e0bfef84 	addi	r2,fp,-66
81114968:	180b883a 	mov	r5,r3
8111496c:	1009883a 	mov	r4,r2
81114970:	111652c0 	call	8111652c <ucCrc8wInit>
81114974:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81114978:	e13fed43 	ldbu	r4,-75(fp)
8111497c:	e0ffef84 	addi	r3,fp,-66
81114980:	e0bfef84 	addi	r2,fp,-66
81114984:	200f883a 	mov	r7,r4
81114988:	180d883a 	mov	r6,r3
8111498c:	01604534 	movhi	r5,33044
81114990:	2952c104 	addi	r5,r5,19204
81114994:	1009883a 	mov	r4,r2
81114998:	111b0580 	call	8111b058 <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
8111499c:	e0bfef0b 	ldhu	r2,-68(fp)
811149a0:	10ffffcc 	andi	r3,r2,65535
811149a4:	18e0001c 	xori	r3,r3,32768
811149a8:	18e00004 	addi	r3,r3,-32768
811149ac:	e0bfef84 	addi	r2,fp,-66
811149b0:	180b883a 	mov	r5,r3
811149b4:	1009883a 	mov	r4,r2
811149b8:	1113c180 	call	81113c18 <bSendUART64v2>
811149bc:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
811149c0:	e0bfee17 	ldw	r2,-72(fp)
811149c4:	10800060 	cmpeqi	r2,r2,1
811149c8:	1000031e 	bne	r2,zero,811149d8 <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
811149cc:	e0bfef84 	addi	r2,fp,-66
811149d0:	1009883a 	mov	r4,r2
811149d4:	1116e180 	call	81116e18 <vCouldNotSendTMPusCommand>
	}
}
811149d8:	0001883a 	nop
811149dc:	e037883a 	mov	sp,fp
811149e0:	dfc00117 	ldw	ra,4(sp)
811149e4:	df000017 	ldw	fp,0(sp)
811149e8:	dec00604 	addi	sp,sp,24
811149ec:	f800283a 	ret

811149f0 <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
811149f0:	deffd304 	addi	sp,sp,-180
811149f4:	de00012e 	bgeu	sp,et,811149fc <vSendPusTM128+0xc>
811149f8:	003b68fa 	trap	3
811149fc:	dfc02815 	stw	ra,160(sp)
81114a00:	df002715 	stw	fp,156(sp)
81114a04:	df002704 	addi	fp,sp,156
81114a08:	e1000215 	stw	r4,8(fp)
81114a0c:	e1400315 	stw	r5,12(fp)
81114a10:	e1800415 	stw	r6,16(fp)
81114a14:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
81114a18:	e03fdf8d 	sth	zero,-130(fp)
81114a1c:	e03fe00d 	sth	zero,-128(fp)
81114a20:	e0bfe084 	addi	r2,fp,-126
81114a24:	00c01f04 	movi	r3,124
81114a28:	180d883a 	mov	r6,r3
81114a2c:	000b883a 	mov	r5,zero
81114a30:	1009883a 	mov	r4,r2
81114a34:	111acfc0 	call	8111acfc <memset>
    unsigned char crc = 0;
81114a38:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
81114a3c:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
81114a40:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
81114a44:	11147580 	call	81114758 <usiGetIdCMD>
81114a48:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
81114a4c:	e1bfdf0b 	ldhu	r6,-132(fp)
81114a50:	e080040b 	ldhu	r2,16(fp)
81114a54:	11ffffcc 	andi	r7,r2,65535
81114a58:	e080048b 	ldhu	r2,18(fp)
81114a5c:	10bfffcc 	andi	r2,r2,65535
81114a60:	e0c0050b 	ldhu	r3,20(fp)
81114a64:	18ffffcc 	andi	r3,r3,65535
81114a68:	e100058b 	ldhu	r4,22(fp)
81114a6c:	213fffcc 	andi	r4,r4,65535
81114a70:	e140060b 	ldhu	r5,24(fp)
81114a74:	297fffcc 	andi	r5,r5,65535
81114a78:	e23fdf84 	addi	r8,fp,-130
81114a7c:	d9400315 	stw	r5,12(sp)
81114a80:	d9000215 	stw	r4,8(sp)
81114a84:	d8c00115 	stw	r3,4(sp)
81114a88:	d8800015 	stw	r2,0(sp)
81114a8c:	01604534 	movhi	r5,33044
81114a90:	2952cb04 	addi	r5,r5,19244
81114a94:	4009883a 	mov	r4,r8
81114a98:	111b0580 	call	8111b058 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81114a9c:	e03fdd05 	stb	zero,-140(fp)
81114aa0:	00001206 	br	81114aec <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
81114aa4:	e0bfdd03 	ldbu	r2,-140(fp)
81114aa8:	10800284 	addi	r2,r2,10
81114aac:	1085883a 	add	r2,r2,r2
81114ab0:	e0c00204 	addi	r3,fp,8
81114ab4:	1885883a 	add	r2,r3,r2
81114ab8:	1080000b 	ldhu	r2,0(r2)
81114abc:	113fffcc 	andi	r4,r2,65535
81114ac0:	e0ffdf84 	addi	r3,fp,-130
81114ac4:	e0bfdf84 	addi	r2,fp,-130
81114ac8:	200f883a 	mov	r7,r4
81114acc:	180d883a 	mov	r6,r3
81114ad0:	01604534 	movhi	r5,33044
81114ad4:	2952d204 	addi	r5,r5,19272
81114ad8:	1009883a 	mov	r4,r2
81114adc:	111b0580 	call	8111b058 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81114ae0:	e0bfdd03 	ldbu	r2,-140(fp)
81114ae4:	10800044 	addi	r2,r2,1
81114ae8:	e0bfdd05 	stb	r2,-140(fp)
81114aec:	e0800683 	ldbu	r2,26(fp)
81114af0:	10803fcc 	andi	r2,r2,255
81114af4:	e0ffdd03 	ldbu	r3,-140(fp)
81114af8:	18bfea36 	bltu	r3,r2,81114aa4 <__reset+0xfb0f4aa4>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
81114afc:	e0bfdf84 	addi	r2,fp,-130
81114b00:	1009883a 	mov	r4,r2
81114b04:	111b1180 	call	8111b118 <strlen>
81114b08:	1007883a 	mov	r3,r2
81114b0c:	e0bfdf84 	addi	r2,fp,-130
81114b10:	180b883a 	mov	r5,r3
81114b14:	1009883a 	mov	r4,r2
81114b18:	111652c0 	call	8111652c <ucCrc8wInit>
81114b1c:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81114b20:	e13fdd43 	ldbu	r4,-139(fp)
81114b24:	e0ffdf84 	addi	r3,fp,-130
81114b28:	e0bfdf84 	addi	r2,fp,-130
81114b2c:	200f883a 	mov	r7,r4
81114b30:	180d883a 	mov	r6,r3
81114b34:	01604534 	movhi	r5,33044
81114b38:	2952c104 	addi	r5,r5,19204
81114b3c:	1009883a 	mov	r4,r2
81114b40:	111b0580 	call	8111b058 <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
81114b44:	e0bfdf0b 	ldhu	r2,-132(fp)
81114b48:	10ffffcc 	andi	r3,r2,65535
81114b4c:	18e0001c 	xori	r3,r3,32768
81114b50:	18e00004 	addi	r3,r3,-32768
81114b54:	e0bfdf84 	addi	r2,fp,-130
81114b58:	180b883a 	mov	r5,r3
81114b5c:	1009883a 	mov	r4,r2
81114b60:	11139600 	call	81113960 <bSendUART128v2>
81114b64:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
81114b68:	e0bfde17 	ldw	r2,-136(fp)
81114b6c:	10800060 	cmpeqi	r2,r2,1
81114b70:	1000031e 	bne	r2,zero,81114b80 <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
81114b74:	e0bfdf84 	addi	r2,fp,-130
81114b78:	1009883a 	mov	r4,r2
81114b7c:	1116e180 	call	81116e18 <vCouldNotSendTMPusCommand>
	}
}
81114b80:	0001883a 	nop
81114b84:	e037883a 	mov	sp,fp
81114b88:	dfc00117 	ldw	ra,4(sp)
81114b8c:	df000017 	ldw	fp,0(sp)
81114b90:	dec00604 	addi	sp,sp,24
81114b94:	f800283a 	ret

81114b98 <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
81114b98:	deffd704 	addi	sp,sp,-164
81114b9c:	de00012e 	bgeu	sp,et,81114ba4 <vTMPusTestConnection+0xc>
81114ba0:	003b68fa 	trap	3
81114ba4:	dfc02815 	stw	ra,160(sp)
81114ba8:	df002715 	stw	fp,156(sp)
81114bac:	df002704 	addi	fp,sp,156
81114bb0:	2005883a 	mov	r2,r4
81114bb4:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
81114bb8:	e0bfff0b 	ldhu	r2,-4(fp)
81114bbc:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
81114bc0:	00801c04 	movi	r2,112
81114bc4:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
81114bc8:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
81114bcc:	00800444 	movi	r2,17
81114bd0:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
81114bd4:	00800084 	movi	r2,2
81114bd8:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
81114bdc:	d809883a 	mov	r4,sp
81114be0:	e0bfee04 	addi	r2,fp,-72
81114be4:	00c01104 	movi	r3,68
81114be8:	180d883a 	mov	r6,r3
81114bec:	100b883a 	mov	r5,r2
81114bf0:	111abac0 	call	8111abac <memcpy>
81114bf4:	e13fea17 	ldw	r4,-88(fp)
81114bf8:	e17feb17 	ldw	r5,-84(fp)
81114bfc:	e1bfec17 	ldw	r6,-80(fp)
81114c00:	e1ffed17 	ldw	r7,-76(fp)
81114c04:	11148480 	call	81114848 <vSendPusTM64>
}
81114c08:	0001883a 	nop
81114c0c:	e037883a 	mov	sp,fp
81114c10:	dfc00117 	ldw	ra,4(sp)
81114c14:	df000017 	ldw	fp,0(sp)
81114c18:	dec00204 	addi	sp,sp,8
81114c1c:	f800283a 	ret

81114c20 <vLoadDefaultETHConf>:
/*Configuration related to the eth connection*/
TConfEth xConfEth;
TDefaults xDefaults;


bool vLoadDefaultETHConf( void ){
81114c20:	defff504 	addi	sp,sp,-44
81114c24:	de00012e 	bgeu	sp,et,81114c2c <vLoadDefaultETHConf+0xc>
81114c28:	003b68fa 	trap	3
81114c2c:	dfc00a15 	stw	ra,40(sp)
81114c30:	df000915 	stw	fp,36(sp)
81114c34:	dc000815 	stw	r16,32(sp)
81114c38:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
81114c3c:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
81114c40:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
81114c44:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
81114c48:	d0a07517 	ldw	r2,-32300(gp)
81114c4c:	10800058 	cmpnei	r2,r2,1
81114c50:	1001e41e 	bne	r2,zero,811153e4 <vLoadDefaultETHConf+0x7c4>
81114c54:	11185780 	call	81118578 <bSDcardIsPresent>
81114c58:	1001e226 	beq	r2,zero,811153e4 <vLoadDefaultETHConf+0x7c4>
81114c5c:	11185a80 	call	811185a8 <bSDcardFAT16Check>
81114c60:	1001e026 	beq	r2,zero,811153e4 <vLoadDefaultETHConf+0x7c4>

		siFile = siOpenFile( ETH_FILE_NAME );
81114c64:	01204534 	movhi	r4,33044
81114c68:	2112d404 	addi	r4,r4,19280
81114c6c:	11186580 	call	81118658 <siOpenFile>
81114c70:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
81114c74:	e0bffc0f 	ldh	r2,-16(fp)
81114c78:	1001da16 	blt	r2,zero,811153e4 <vLoadDefaultETHConf+0x7c4>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
81114c7c:	e0bffd04 	addi	r2,fp,-12
81114c80:	01800204 	movi	r6,8
81114c84:	01400284 	movi	r5,10
81114c88:	1009883a 	mov	r4,r2
81114c8c:	111acfc0 	call	8111acfc <memset>
			p_inteiro = inteiro;
81114c90:	e0bffd04 	addi	r2,fp,-12
81114c94:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
81114c98:	e0bffc0f 	ldh	r2,-16(fp)
81114c9c:	1009883a 	mov	r4,r2
81114ca0:	11186d40 	call	811186d4 <cGetNextChar>
81114ca4:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
81114ca8:	e0bff947 	ldb	r2,-27(fp)
81114cac:	10800084 	addi	r2,r2,2
81114cb0:	10c015a8 	cmpgeui	r3,r2,86
81114cb4:	1801c81e 	bne	r3,zero,811153d8 <vLoadDefaultETHConf+0x7b8>
81114cb8:	100690ba 	slli	r3,r2,2
81114cbc:	00a04474 	movhi	r2,33041
81114cc0:	10933404 	addi	r2,r2,19664
81114cc4:	1885883a 	add	r2,r3,r2
81114cc8:	10800017 	ldw	r2,0(r2)
81114ccc:	1000683a 	jmp	r2
81114cd0:	81114e68 	cmpgeui	r4,r16,17721
81114cd4:	81114e5c 	xori	r4,r16,17721
81114cd8:	811153d8 	cmpnei	r4,r16,17743
81114cdc:	811153d8 	cmpnei	r4,r16,17743
81114ce0:	811153d8 	cmpnei	r4,r16,17743
81114ce4:	811153d8 	cmpnei	r4,r16,17743
81114ce8:	811153d8 	cmpnei	r4,r16,17743
81114cec:	811153d8 	cmpnei	r4,r16,17743
81114cf0:	811153d8 	cmpnei	r4,r16,17743
81114cf4:	811153d8 	cmpnei	r4,r16,17743
81114cf8:	811153d8 	cmpnei	r4,r16,17743
81114cfc:	811153d8 	cmpnei	r4,r16,17743
81114d00:	811153d8 	cmpnei	r4,r16,17743
81114d04:	811153d8 	cmpnei	r4,r16,17743
81114d08:	811153d8 	cmpnei	r4,r16,17743
81114d0c:	811153d8 	cmpnei	r4,r16,17743
81114d10:	811153d8 	cmpnei	r4,r16,17743
81114d14:	811153d8 	cmpnei	r4,r16,17743
81114d18:	811153d8 	cmpnei	r4,r16,17743
81114d1c:	811153d8 	cmpnei	r4,r16,17743
81114d20:	811153d8 	cmpnei	r4,r16,17743
81114d24:	811153d8 	cmpnei	r4,r16,17743
81114d28:	811153d8 	cmpnei	r4,r16,17743
81114d2c:	811153d8 	cmpnei	r4,r16,17743
81114d30:	811153d8 	cmpnei	r4,r16,17743
81114d34:	811153d8 	cmpnei	r4,r16,17743
81114d38:	811153d8 	cmpnei	r4,r16,17743
81114d3c:	811153d8 	cmpnei	r4,r16,17743
81114d40:	811153d8 	cmpnei	r4,r16,17743
81114d44:	811153d8 	cmpnei	r4,r16,17743
81114d48:	811153d8 	cmpnei	r4,r16,17743
81114d4c:	811153d8 	cmpnei	r4,r16,17743
81114d50:	811153d8 	cmpnei	r4,r16,17743
81114d54:	811153d8 	cmpnei	r4,r16,17743
81114d58:	811153d8 	cmpnei	r4,r16,17743
81114d5c:	811153d8 	cmpnei	r4,r16,17743
81114d60:	811153d8 	cmpnei	r4,r16,17743
81114d64:	811153d8 	cmpnei	r4,r16,17743
81114d68:	811153d8 	cmpnei	r4,r16,17743
81114d6c:	811153d8 	cmpnei	r4,r16,17743
81114d70:	811153d8 	cmpnei	r4,r16,17743
81114d74:	81114e28 	cmpgeui	r4,r16,17720
81114d78:	811153d8 	cmpnei	r4,r16,17743
81114d7c:	811153d8 	cmpnei	r4,r16,17743
81114d80:	811153d8 	cmpnei	r4,r16,17743
81114d84:	811153d8 	cmpnei	r4,r16,17743
81114d88:	811153d8 	cmpnei	r4,r16,17743
81114d8c:	811153d8 	cmpnei	r4,r16,17743
81114d90:	811153d8 	cmpnei	r4,r16,17743
81114d94:	811153d8 	cmpnei	r4,r16,17743
81114d98:	811153d8 	cmpnei	r4,r16,17743
81114d9c:	811153d8 	cmpnei	r4,r16,17743
81114da0:	811153d8 	cmpnei	r4,r16,17743
81114da4:	811153d8 	cmpnei	r4,r16,17743
81114da8:	811153d8 	cmpnei	r4,r16,17743
81114dac:	811153d8 	cmpnei	r4,r16,17743
81114db0:	811153d8 	cmpnei	r4,r16,17743
81114db4:	811153d8 	cmpnei	r4,r16,17743
81114db8:	811153d8 	cmpnei	r4,r16,17743
81114dbc:	811153d8 	cmpnei	r4,r16,17743
81114dc0:	811153d8 	cmpnei	r4,r16,17743
81114dc4:	811153d8 	cmpnei	r4,r16,17743
81114dc8:	811153b4 	orhi	r4,r16,17742
81114dcc:	811153d8 	cmpnei	r4,r16,17743
81114dd0:	811153d8 	cmpnei	r4,r16,17743
81114dd4:	811153d8 	cmpnei	r4,r16,17743
81114dd8:	811153d8 	cmpnei	r4,r16,17743
81114ddc:	811153d8 	cmpnei	r4,r16,17743
81114de0:	811153d8 	cmpnei	r4,r16,17743
81114de4:	811153d8 	cmpnei	r4,r16,17743
81114de8:	811152e4 	muli	r4,r16,17739
81114dec:	811153d8 	cmpnei	r4,r16,17743
81114df0:	811153d8 	cmpnei	r4,r16,17743
81114df4:	81115010 	cmplti	r4,r16,17728
81114df8:	8111516c 	andhi	r4,r16,17733
81114dfc:	81114f44 	addi	r4,r16,17725
81114e00:	811153d8 	cmpnei	r4,r16,17743
81114e04:	811153d8 	cmpnei	r4,r16,17743
81114e08:	811153d8 	cmpnei	r4,r16,17743
81114e0c:	81114e74 	orhi	r4,r16,17721
81114e10:	811153d8 	cmpnei	r4,r16,17743
81114e14:	811153d8 	cmpnei	r4,r16,17743
81114e18:	811150e0 	cmpeqi	r4,r16,17731
81114e1c:	811153d8 	cmpnei	r4,r16,17743
81114e20:	811153d8 	cmpnei	r4,r16,17743
81114e24:	81115214 	ori	r4,r16,17736
					case 39:// single quote '
						c = cGetNextChar(siFile);
81114e28:	e0bffc0f 	ldh	r2,-16(fp)
81114e2c:	1009883a 	mov	r4,r2
81114e30:	11186d40 	call	811186d4 <cGetNextChar>
81114e34:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
81114e38:	00000406 	br	81114e4c <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
81114e3c:	e0bffc0f 	ldh	r2,-16(fp)
81114e40:	1009883a 	mov	r4,r2
81114e44:	11186d40 	call	811186d4 <cGetNextChar>
81114e48:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
81114e4c:	e0bff947 	ldb	r2,-27(fp)
81114e50:	108009d8 	cmpnei	r2,r2,39
81114e54:	103ff91e 	bne	r2,zero,81114e3c <__reset+0xfb0f4e3c>
							c = cGetNextChar(siFile);
						}
						break;
81114e58:	00016006 	br	811153dc <vLoadDefaultETHConf+0x7bc>
					case -1: 	//EOF
						bEOF = TRUE;
81114e5c:	00800044 	movi	r2,1
81114e60:	e0bff815 	stw	r2,-32(fp)
						break;
81114e64:	00015d06 	br	811153dc <vLoadDefaultETHConf+0x7bc>
					case -2: 	//EOF
						#if DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
						#endif
						bEOF = TRUE;
81114e68:	00800044 	movi	r2,1
81114e6c:	e0bff815 	stw	r2,-32(fp)
						break;
81114e70:	00015a06 	br	811153dc <vLoadDefaultETHConf+0x7bc>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
81114e74:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81114e78:	e0bffc0f 	ldh	r2,-16(fp)
81114e7c:	1009883a 	mov	r4,r2
81114e80:	11186d40 	call	811186d4 <cGetNextChar>
81114e84:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81114e88:	d0e00317 	ldw	r3,-32756(gp)
81114e8c:	e0bff947 	ldb	r2,-27(fp)
81114e90:	10800044 	addi	r2,r2,1
81114e94:	1885883a 	add	r2,r3,r2
81114e98:	10800003 	ldbu	r2,0(r2)
81114e9c:	10803fcc 	andi	r2,r2,255
81114ea0:	1080010c 	andi	r2,r2,4
81114ea4:	10000626 	beq	r2,zero,81114ec0 <vLoadDefaultETHConf+0x2a0>
									(*p_inteiro) = c;
81114ea8:	e0bffa17 	ldw	r2,-24(fp)
81114eac:	e0fff943 	ldbu	r3,-27(fp)
81114eb0:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81114eb4:	e0bffa17 	ldw	r2,-24(fp)
81114eb8:	10800044 	addi	r2,r2,1
81114ebc:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
81114ec0:	e0bff947 	ldb	r2,-27(fp)
81114ec4:	10800ea0 	cmpeqi	r2,r2,58
81114ec8:	1000031e 	bne	r2,zero,81114ed8 <vLoadDefaultETHConf+0x2b8>
81114ecc:	e0bff947 	ldb	r2,-27(fp)
81114ed0:	10800ed8 	cmpnei	r2,r2,59
81114ed4:	103fe81e 	bne	r2,zero,81114e78 <__reset+0xfb0f4e78>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81114ed8:	e0bffa17 	ldw	r2,-24(fp)
81114edc:	00c00284 	movi	r3,10
81114ee0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = atoi( inteiro );
81114ee4:	e0bff903 	ldbu	r2,-28(fp)
81114ee8:	10800168 	cmpgeui	r2,r2,5
81114eec:	1000021e 	bne	r2,zero,81114ef8 <vLoadDefaultETHConf+0x2d8>
81114ef0:	e43ff903 	ldbu	r16,-28(fp)
81114ef4:	00000106 	br	81114efc <vLoadDefaultETHConf+0x2dc>
81114ef8:	04000144 	movi	r16,5
81114efc:	e0bffd04 	addi	r2,fp,-12
81114f00:	1009883a 	mov	r4,r2
81114f04:	111ab7c0 	call	8111ab7c <atoi>
81114f08:	1007883a 	mov	r3,r2
81114f0c:	00a045b4 	movhi	r2,33046
81114f10:	10acd004 	addi	r2,r2,-19648
81114f14:	1405883a 	add	r2,r2,r16
81114f18:	10800404 	addi	r2,r2,16
81114f1c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81114f20:	e0bffd04 	addi	r2,fp,-12
81114f24:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81114f28:	e0bff903 	ldbu	r2,-28(fp)
81114f2c:	10800044 	addi	r2,r2,1
81114f30:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81114f34:	e0bff947 	ldb	r2,-27(fp)
81114f38:	10800ed8 	cmpnei	r2,r2,59
81114f3c:	103fce1e 	bne	r2,zero,81114e78 <__reset+0xfb0f4e78>

						break;
81114f40:	00012606 	br	811153dc <vLoadDefaultETHConf+0x7bc>
					case 'I':

						ucParser = 0;
81114f44:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81114f48:	e0bffc0f 	ldh	r2,-16(fp)
81114f4c:	1009883a 	mov	r4,r2
81114f50:	11186d40 	call	811186d4 <cGetNextChar>
81114f54:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81114f58:	d0e00317 	ldw	r3,-32756(gp)
81114f5c:	e0bff947 	ldb	r2,-27(fp)
81114f60:	10800044 	addi	r2,r2,1
81114f64:	1885883a 	add	r2,r3,r2
81114f68:	10800003 	ldbu	r2,0(r2)
81114f6c:	10803fcc 	andi	r2,r2,255
81114f70:	1080010c 	andi	r2,r2,4
81114f74:	10000626 	beq	r2,zero,81114f90 <vLoadDefaultETHConf+0x370>
									(*p_inteiro) = c;
81114f78:	e0bffa17 	ldw	r2,-24(fp)
81114f7c:	e0fff943 	ldbu	r3,-27(fp)
81114f80:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81114f84:	e0bffa17 	ldw	r2,-24(fp)
81114f88:	10800044 	addi	r2,r2,1
81114f8c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81114f90:	e0bff947 	ldb	r2,-27(fp)
81114f94:	10800ba0 	cmpeqi	r2,r2,46
81114f98:	1000031e 	bne	r2,zero,81114fa8 <vLoadDefaultETHConf+0x388>
81114f9c:	e0bff947 	ldb	r2,-27(fp)
81114fa0:	10800ed8 	cmpnei	r2,r2,59
81114fa4:	103fe81e 	bne	r2,zero,81114f48 <__reset+0xfb0f4f48>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81114fa8:	e0bffa17 	ldw	r2,-24(fp)
81114fac:	00c00284 	movi	r3,10
81114fb0:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = atoi( inteiro );
81114fb4:	e0bff903 	ldbu	r2,-28(fp)
81114fb8:	108000e8 	cmpgeui	r2,r2,3
81114fbc:	1000021e 	bne	r2,zero,81114fc8 <vLoadDefaultETHConf+0x3a8>
81114fc0:	e43ff903 	ldbu	r16,-28(fp)
81114fc4:	00000106 	br	81114fcc <vLoadDefaultETHConf+0x3ac>
81114fc8:	040000c4 	movi	r16,3
81114fcc:	e0bffd04 	addi	r2,fp,-12
81114fd0:	1009883a 	mov	r4,r2
81114fd4:	111ab7c0 	call	8111ab7c <atoi>
81114fd8:	1007883a 	mov	r3,r2
81114fdc:	00a045b4 	movhi	r2,33046
81114fe0:	10acd004 	addi	r2,r2,-19648
81114fe4:	1405883a 	add	r2,r2,r16
81114fe8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81114fec:	e0bffd04 	addi	r2,fp,-12
81114ff0:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81114ff4:	e0bff903 	ldbu	r2,-28(fp)
81114ff8:	10800044 	addi	r2,r2,1
81114ffc:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81115000:	e0bff947 	ldb	r2,-27(fp)
81115004:	10800ed8 	cmpnei	r2,r2,59
81115008:	103fcf1e 	bne	r2,zero,81114f48 <__reset+0xfb0f4f48>

						break;
8111500c:	0000f306 	br	811153dc <vLoadDefaultETHConf+0x7bc>
					case 'G':

						ucParser = 0;
81115010:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115014:	e0bffc0f 	ldh	r2,-16(fp)
81115018:	1009883a 	mov	r4,r2
8111501c:	11186d40 	call	811186d4 <cGetNextChar>
81115020:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81115024:	d0e00317 	ldw	r3,-32756(gp)
81115028:	e0bff947 	ldb	r2,-27(fp)
8111502c:	10800044 	addi	r2,r2,1
81115030:	1885883a 	add	r2,r3,r2
81115034:	10800003 	ldbu	r2,0(r2)
81115038:	10803fcc 	andi	r2,r2,255
8111503c:	1080010c 	andi	r2,r2,4
81115040:	10000626 	beq	r2,zero,8111505c <vLoadDefaultETHConf+0x43c>
									(*p_inteiro) = c;
81115044:	e0bffa17 	ldw	r2,-24(fp)
81115048:	e0fff943 	ldbu	r3,-27(fp)
8111504c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81115050:	e0bffa17 	ldw	r2,-24(fp)
81115054:	10800044 	addi	r2,r2,1
81115058:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111505c:	e0bff947 	ldb	r2,-27(fp)
81115060:	10800ba0 	cmpeqi	r2,r2,46
81115064:	1000031e 	bne	r2,zero,81115074 <vLoadDefaultETHConf+0x454>
81115068:	e0bff947 	ldb	r2,-27(fp)
8111506c:	10800ed8 	cmpnei	r2,r2,59
81115070:	103fe81e 	bne	r2,zero,81115014 <__reset+0xfb0f5014>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115074:	e0bffa17 	ldw	r2,-24(fp)
81115078:	00c00284 	movi	r3,10
8111507c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = atoi( inteiro );
81115080:	e0bff903 	ldbu	r2,-28(fp)
81115084:	108000e8 	cmpgeui	r2,r2,3
81115088:	1000021e 	bne	r2,zero,81115094 <vLoadDefaultETHConf+0x474>
8111508c:	e43ff903 	ldbu	r16,-28(fp)
81115090:	00000106 	br	81115098 <vLoadDefaultETHConf+0x478>
81115094:	040000c4 	movi	r16,3
81115098:	e0bffd04 	addi	r2,fp,-12
8111509c:	1009883a 	mov	r4,r2
811150a0:	111ab7c0 	call	8111ab7c <atoi>
811150a4:	1007883a 	mov	r3,r2
811150a8:	00a045b4 	movhi	r2,33046
811150ac:	10acd004 	addi	r2,r2,-19648
811150b0:	1405883a 	add	r2,r2,r16
811150b4:	10800104 	addi	r2,r2,4
811150b8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
811150bc:	e0bffd04 	addi	r2,fp,-12
811150c0:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811150c4:	e0bff903 	ldbu	r2,-28(fp)
811150c8:	10800044 	addi	r2,r2,1
811150cc:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811150d0:	e0bff947 	ldb	r2,-27(fp)
811150d4:	10800ed8 	cmpnei	r2,r2,59
811150d8:	103fce1e 	bne	r2,zero,81115014 <__reset+0xfb0f5014>

						break;
811150dc:	0000bf06 	br	811153dc <vLoadDefaultETHConf+0x7bc>
					case 'P':
						ucParser = 0;
811150e0:	e03ff905 	stb	zero,-28(fp)
						do {
							c = cGetNextChar(siFile);
811150e4:	e0bffc0f 	ldh	r2,-16(fp)
811150e8:	1009883a 	mov	r4,r2
811150ec:	11186d40 	call	811186d4 <cGetNextChar>
811150f0:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
811150f4:	d0e00317 	ldw	r3,-32756(gp)
811150f8:	e0bff947 	ldb	r2,-27(fp)
811150fc:	10800044 	addi	r2,r2,1
81115100:	1885883a 	add	r2,r3,r2
81115104:	10800003 	ldbu	r2,0(r2)
81115108:	10803fcc 	andi	r2,r2,255
8111510c:	1080010c 	andi	r2,r2,4
81115110:	10000626 	beq	r2,zero,8111512c <vLoadDefaultETHConf+0x50c>
								(*p_inteiro) = c;
81115114:	e0bffa17 	ldw	r2,-24(fp)
81115118:	e0fff943 	ldbu	r3,-27(fp)
8111511c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81115120:	e0bffa17 	ldw	r2,-24(fp)
81115124:	10800044 	addi	r2,r2,1
81115128:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111512c:	e0bff947 	ldb	r2,-27(fp)
81115130:	10800ed8 	cmpnei	r2,r2,59
81115134:	103feb1e 	bne	r2,zero,811150e4 <__reset+0xfb0f50e4>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115138:	e0bffa17 	ldw	r2,-24(fp)
8111513c:	00c00284 	movi	r3,10
81115140:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = atoi( inteiro );
81115144:	e0bffd04 	addi	r2,fp,-12
81115148:	1009883a 	mov	r4,r2
8111514c:	111ab7c0 	call	8111ab7c <atoi>
81115150:	1007883a 	mov	r3,r2
81115154:	00a045b4 	movhi	r2,33046
81115158:	10acd004 	addi	r2,r2,-19648
8111515c:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81115160:	e0bffd04 	addi	r2,fp,-12
81115164:	e0bffa15 	stw	r2,-24(fp)

						break;
81115168:	00009c06 	br	811153dc <vLoadDefaultETHConf+0x7bc>
					case 'H':

						do {
							c = cGetNextChar(siFile);
8111516c:	e0bffc0f 	ldh	r2,-16(fp)
81115170:	1009883a 	mov	r4,r2
81115174:	11186d40 	call	811186d4 <cGetNextChar>
81115178:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111517c:	d0e00317 	ldw	r3,-32756(gp)
81115180:	e0bff947 	ldb	r2,-27(fp)
81115184:	10800044 	addi	r2,r2,1
81115188:	1885883a 	add	r2,r3,r2
8111518c:	10800003 	ldbu	r2,0(r2)
81115190:	10803fcc 	andi	r2,r2,255
81115194:	1080010c 	andi	r2,r2,4
81115198:	10000626 	beq	r2,zero,811151b4 <vLoadDefaultETHConf+0x594>
								(*p_inteiro) = c;
8111519c:	e0bffa17 	ldw	r2,-24(fp)
811151a0:	e0fff943 	ldbu	r3,-27(fp)
811151a4:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
811151a8:	e0bffa17 	ldw	r2,-24(fp)
811151ac:	10800044 	addi	r2,r2,1
811151b0:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
811151b4:	e0bff947 	ldb	r2,-27(fp)
811151b8:	10800ed8 	cmpnei	r2,r2,59
811151bc:	103feb1e 	bne	r2,zero,8111516c <__reset+0xfb0f516c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811151c0:	e0bffa17 	ldw	r2,-24(fp)
811151c4:	00c00284 	movi	r3,10
811151c8:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
811151cc:	e0bffd04 	addi	r2,fp,-12
811151d0:	1009883a 	mov	r4,r2
811151d4:	111ab7c0 	call	8111ab7c <atoi>
811151d8:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
811151dc:	e0bffc8f 	ldh	r2,-14(fp)
811151e0:	10800058 	cmpnei	r2,r2,1
811151e4:	1000051e 	bne	r2,zero,811151fc <vLoadDefaultETHConf+0x5dc>
							xConfEth.bDHCP = TRUE;
811151e8:	00a045b4 	movhi	r2,33046
811151ec:	10acd004 	addi	r2,r2,-19648
811151f0:	00c00044 	movi	r3,1
811151f4:	10c00615 	stw	r3,24(r2)
811151f8:	00000306 	br	81115208 <vLoadDefaultETHConf+0x5e8>
						else
							xConfEth.bDHCP = FALSE;
811151fc:	00a045b4 	movhi	r2,33046
81115200:	10acd004 	addi	r2,r2,-19648
81115204:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81115208:	e0bffd04 	addi	r2,fp,-12
8111520c:	e0bffa15 	stw	r2,-24(fp)

						break;
81115210:	00007206 	br	811153dc <vLoadDefaultETHConf+0x7bc>

					case 'S':

						ucParser = 0;
81115214:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115218:	e0bffc0f 	ldh	r2,-16(fp)
8111521c:	1009883a 	mov	r4,r2
81115220:	11186d40 	call	811186d4 <cGetNextChar>
81115224:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81115228:	d0e00317 	ldw	r3,-32756(gp)
8111522c:	e0bff947 	ldb	r2,-27(fp)
81115230:	10800044 	addi	r2,r2,1
81115234:	1885883a 	add	r2,r3,r2
81115238:	10800003 	ldbu	r2,0(r2)
8111523c:	10803fcc 	andi	r2,r2,255
81115240:	1080010c 	andi	r2,r2,4
81115244:	10000626 	beq	r2,zero,81115260 <vLoadDefaultETHConf+0x640>
									(*p_inteiro) = c;
81115248:	e0bffa17 	ldw	r2,-24(fp)
8111524c:	e0fff943 	ldbu	r3,-27(fp)
81115250:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81115254:	e0bffa17 	ldw	r2,-24(fp)
81115258:	10800044 	addi	r2,r2,1
8111525c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81115260:	e0bff947 	ldb	r2,-27(fp)
81115264:	10800ba0 	cmpeqi	r2,r2,46
81115268:	1000031e 	bne	r2,zero,81115278 <vLoadDefaultETHConf+0x658>
8111526c:	e0bff947 	ldb	r2,-27(fp)
81115270:	10800ed8 	cmpnei	r2,r2,59
81115274:	103fe81e 	bne	r2,zero,81115218 <__reset+0xfb0f5218>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115278:	e0bffa17 	ldw	r2,-24(fp)
8111527c:	00c00284 	movi	r3,10
81115280:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = atoi( inteiro );
81115284:	e0bff903 	ldbu	r2,-28(fp)
81115288:	108000e8 	cmpgeui	r2,r2,3
8111528c:	1000021e 	bne	r2,zero,81115298 <vLoadDefaultETHConf+0x678>
81115290:	e43ff903 	ldbu	r16,-28(fp)
81115294:	00000106 	br	8111529c <vLoadDefaultETHConf+0x67c>
81115298:	040000c4 	movi	r16,3
8111529c:	e0bffd04 	addi	r2,fp,-12
811152a0:	1009883a 	mov	r4,r2
811152a4:	111ab7c0 	call	8111ab7c <atoi>
811152a8:	1007883a 	mov	r3,r2
811152ac:	00a045b4 	movhi	r2,33046
811152b0:	10acd004 	addi	r2,r2,-19648
811152b4:	1405883a 	add	r2,r2,r16
811152b8:	10800204 	addi	r2,r2,8
811152bc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
811152c0:	e0bffd04 	addi	r2,fp,-12
811152c4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811152c8:	e0bff903 	ldbu	r2,-28(fp)
811152cc:	10800044 	addi	r2,r2,1
811152d0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811152d4:	e0bff947 	ldb	r2,-27(fp)
811152d8:	10800ed8 	cmpnei	r2,r2,59
811152dc:	103fce1e 	bne	r2,zero,81115218 <__reset+0xfb0f5218>

						break;
811152e0:	00003e06 	br	811153dc <vLoadDefaultETHConf+0x7bc>
					case 'D':

						ucParser = 0;
811152e4:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811152e8:	e0bffc0f 	ldh	r2,-16(fp)
811152ec:	1009883a 	mov	r4,r2
811152f0:	11186d40 	call	811186d4 <cGetNextChar>
811152f4:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811152f8:	d0e00317 	ldw	r3,-32756(gp)
811152fc:	e0bff947 	ldb	r2,-27(fp)
81115300:	10800044 	addi	r2,r2,1
81115304:	1885883a 	add	r2,r3,r2
81115308:	10800003 	ldbu	r2,0(r2)
8111530c:	10803fcc 	andi	r2,r2,255
81115310:	1080010c 	andi	r2,r2,4
81115314:	10000626 	beq	r2,zero,81115330 <vLoadDefaultETHConf+0x710>
									(*p_inteiro) = c;
81115318:	e0bffa17 	ldw	r2,-24(fp)
8111531c:	e0fff943 	ldbu	r3,-27(fp)
81115320:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81115324:	e0bffa17 	ldw	r2,-24(fp)
81115328:	10800044 	addi	r2,r2,1
8111532c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81115330:	e0bff947 	ldb	r2,-27(fp)
81115334:	10800ba0 	cmpeqi	r2,r2,46
81115338:	1000031e 	bne	r2,zero,81115348 <vLoadDefaultETHConf+0x728>
8111533c:	e0bff947 	ldb	r2,-27(fp)
81115340:	10800ed8 	cmpnei	r2,r2,59
81115344:	103fe81e 	bne	r2,zero,811152e8 <__reset+0xfb0f52e8>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115348:	e0bffa17 	ldw	r2,-24(fp)
8111534c:	00c00284 	movi	r3,10
81115350:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = atoi( inteiro );
81115354:	e0bff903 	ldbu	r2,-28(fp)
81115358:	108000e8 	cmpgeui	r2,r2,3
8111535c:	1000021e 	bne	r2,zero,81115368 <vLoadDefaultETHConf+0x748>
81115360:	e43ff903 	ldbu	r16,-28(fp)
81115364:	00000106 	br	8111536c <vLoadDefaultETHConf+0x74c>
81115368:	040000c4 	movi	r16,3
8111536c:	e0bffd04 	addi	r2,fp,-12
81115370:	1009883a 	mov	r4,r2
81115374:	111ab7c0 	call	8111ab7c <atoi>
81115378:	1007883a 	mov	r3,r2
8111537c:	00a045b4 	movhi	r2,33046
81115380:	10acd004 	addi	r2,r2,-19648
81115384:	1405883a 	add	r2,r2,r16
81115388:	10800304 	addi	r2,r2,12
8111538c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81115390:	e0bffd04 	addi	r2,fp,-12
81115394:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81115398:	e0bff903 	ldbu	r2,-28(fp)
8111539c:	10800044 	addi	r2,r2,1
811153a0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811153a4:	e0bff947 	ldb	r2,-27(fp)
811153a8:	10800ed8 	cmpnei	r2,r2,59
811153ac:	103fce1e 	bne	r2,zero,811152e8 <__reset+0xfb0f52e8>

						break;						
811153b0:	00000a06 	br	811153dc <vLoadDefaultETHConf+0x7bc>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
811153b4:	e0bffc0f 	ldh	r2,-16(fp)
811153b8:	1009883a 	mov	r4,r2
811153bc:	11186940 	call	81118694 <siCloseFile>
811153c0:	e0bffb15 	stw	r2,-20(fp)
							#if DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
811153c4:	00800044 	movi	r2,1
811153c8:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
811153cc:	00800044 	movi	r2,1
811153d0:	e0bff715 	stw	r2,-36(fp)
						break;
811153d4:	00000106 	br	811153dc <vLoadDefaultETHConf+0x7bc>
					default:
						#if DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
811153d8:	0001883a 	nop
				}
			} while ( bEOF == FALSE );
811153dc:	e0bff817 	ldw	r2,-32(fp)
811153e0:	103e2d26 	beq	r2,zero,81114c98 <__reset+0xfb0f4c98>
		#if DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
811153e4:	e0bff717 	ldw	r2,-36(fp)
811153e8:	1000541e 	bne	r2,zero,8111553c <vLoadDefaultETHConf+0x91c>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Ateno: Arquivo de conexo no foi encontrado. Carregando conf padrao\n");
811153ec:	01204534 	movhi	r4,33044
811153f0:	2112d604 	addi	r4,r4,19288
811153f4:	111af680 	call	8111af68 <puts>
		printf("No encontrou:'%s'.\n", ETH_FILE_NAME);
811153f8:	01604534 	movhi	r5,33044
811153fc:	2952d404 	addi	r5,r5,19280
81115400:	01204534 	movhi	r4,33044
81115404:	2112ea04 	addi	r4,r4,19368
81115408:	111ae5c0 	call	8111ae5c <printf>


		xConfEth.siPortPUS = 17000;
8111540c:	00a045b4 	movhi	r2,33046
81115410:	10acd004 	addi	r2,r2,-19648
81115414:	00d09a04 	movi	r3,17000
81115418:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
8111541c:	00a045b4 	movhi	r2,33046
81115420:	10acd004 	addi	r2,r2,-19648
81115424:	00fff004 	movi	r3,-64
81115428:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
8111542c:	00a045b4 	movhi	r2,33046
81115430:	10acd004 	addi	r2,r2,-19648
81115434:	00ffea04 	movi	r3,-88
81115438:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
8111543c:	00a045b4 	movhi	r2,33046
81115440:	10acd004 	addi	r2,r2,-19648
81115444:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
81115448:	00a045b4 	movhi	r2,33046
8111544c:	10acd004 	addi	r2,r2,-19648
81115450:	00c00144 	movi	r3,5
81115454:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
81115458:	00a045b4 	movhi	r2,33046
8111545c:	10acd004 	addi	r2,r2,-19648
81115460:	00fff004 	movi	r3,-64
81115464:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
81115468:	00a045b4 	movhi	r2,33046
8111546c:	10acd004 	addi	r2,r2,-19648
81115470:	00ffea04 	movi	r3,-88
81115474:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
81115478:	00a045b4 	movhi	r2,33046
8111547c:	10acd004 	addi	r2,r2,-19648
81115480:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
81115484:	00a045b4 	movhi	r2,33046
81115488:	10acd004 	addi	r2,r2,-19648
8111548c:	00c00044 	movi	r3,1
81115490:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
81115494:	00a045b4 	movhi	r2,33046
81115498:	10acd004 	addi	r2,r2,-19648
8111549c:	00ffffc4 	movi	r3,-1
811154a0:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
811154a4:	00a045b4 	movhi	r2,33046
811154a8:	10acd004 	addi	r2,r2,-19648
811154ac:	00ffffc4 	movi	r3,-1
811154b0:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
811154b4:	00a045b4 	movhi	r2,33046
811154b8:	10acd004 	addi	r2,r2,-19648
811154bc:	00ffffc4 	movi	r3,-1
811154c0:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
811154c4:	00a045b4 	movhi	r2,33046
811154c8:	10acd004 	addi	r2,r2,-19648
811154cc:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
811154d0:	00a045b4 	movhi	r2,33046
811154d4:	10acd004 	addi	r2,r2,-19648
811154d8:	00ffff04 	movi	r3,-4
811154dc:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
811154e0:	00a045b4 	movhi	r2,33046
811154e4:	10acd004 	addi	r2,r2,-19648
811154e8:	00fffdc4 	movi	r3,-9
811154ec:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
811154f0:	00a045b4 	movhi	r2,33046
811154f4:	10acd004 	addi	r2,r2,-19648
811154f8:	00c018c4 	movi	r3,99
811154fc:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
81115500:	00a045b4 	movhi	r2,33046
81115504:	10acd004 	addi	r2,r2,-19648
81115508:	00c01344 	movi	r3,77
8111550c:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
81115510:	00a045b4 	movhi	r2,33046
81115514:	10acd004 	addi	r2,r2,-19648
81115518:	00c007c4 	movi	r3,31
8111551c:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
81115520:	00a045b4 	movhi	r2,33046
81115524:	10acd004 	addi	r2,r2,-19648
81115528:	00c01084 	movi	r3,66
8111552c:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
81115530:	00a045b4 	movhi	r2,33046
81115534:	10acd004 	addi	r2,r2,-19648
81115538:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
8111553c:	e0bff717 	ldw	r2,-36(fp)
}
81115540:	e6ffff04 	addi	sp,fp,-4
81115544:	dfc00217 	ldw	ra,8(sp)
81115548:	df000117 	ldw	fp,4(sp)
8111554c:	dc000017 	ldw	r16,0(sp)
81115550:	dec00304 	addi	sp,sp,12
81115554:	f800283a 	ret

81115558 <vLoadDebugConfs>:
#endif




bool vLoadDebugConfs( void ){
81115558:	deffef04 	addi	sp,sp,-68
8111555c:	de00012e 	bgeu	sp,et,81115564 <vLoadDebugConfs+0xc>
81115560:	003b68fa 	trap	3
81115564:	dfc01015 	stw	ra,64(sp)
81115568:	df000f15 	stw	fp,60(sp)
8111556c:	dc000e15 	stw	r16,56(sp)
81115570:	df000f04 	addi	fp,sp,60
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
81115574:	e03ff115 	stw	zero,-60(fp)
	bool bEOF = FALSE;
81115578:	e03ff215 	stw	zero,-56(fp)
	bool close = FALSE;
8111557c:	e03ff515 	stw	zero,-44(fp)
	char c, *p_inteiro;
	char inteiro[8];
	char inteiroll[24];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
81115580:	d0a07517 	ldw	r2,-32300(gp)
81115584:	10800058 	cmpnei	r2,r2,1
81115588:	10037d1e 	bne	r2,zero,81116380 <vLoadDebugConfs+0xe28>
8111558c:	11185780 	call	81118578 <bSDcardIsPresent>
81115590:	10037b26 	beq	r2,zero,81116380 <vLoadDebugConfs+0xe28>
81115594:	11185a80 	call	811185a8 <bSDcardFAT16Check>
81115598:	10037926 	beq	r2,zero,81116380 <vLoadDebugConfs+0xe28>

		siFile = siOpenFile( DEBUG_FILE_NAME );
8111559c:	01204534 	movhi	r4,33044
811155a0:	2112f004 	addi	r4,r4,19392
811155a4:	11186580 	call	81118658 <siOpenFile>
811155a8:	e0bff60d 	sth	r2,-40(fp)

		if ( siFile >= 0 ){
811155ac:	e0bff60f 	ldh	r2,-40(fp)
811155b0:	10037316 	blt	r2,zero,81116380 <vLoadDebugConfs+0xe28>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
811155b4:	e0bff704 	addi	r2,fp,-36
811155b8:	01800204 	movi	r6,8
811155bc:	01400284 	movi	r5,10
811155c0:	1009883a 	mov	r4,r2
811155c4:	111acfc0 	call	8111acfc <memset>
			memset( &(inteiroll) , 10 , sizeof( inteiroll ) );
811155c8:	e0bff904 	addi	r2,fp,-28
811155cc:	01800604 	movi	r6,24
811155d0:	01400284 	movi	r5,10
811155d4:	1009883a 	mov	r4,r2
811155d8:	111acfc0 	call	8111acfc <memset>
			p_inteiro = inteiro;
811155dc:	e0bff704 	addi	r2,fp,-36
811155e0:	e0bff415 	stw	r2,-48(fp)

			do {
				c = cGetNextChar(siFile);
811155e4:	e0bff60f 	ldh	r2,-40(fp)
811155e8:	1009883a 	mov	r4,r2
811155ec:	11186d40 	call	811186d4 <cGetNextChar>
811155f0:	e0bff345 	stb	r2,-51(fp)
				//printf("%c \n", c);
				switch (c) {
811155f4:	e0bff347 	ldb	r2,-51(fp)
811155f8:	10800084 	addi	r2,r2,2
811155fc:	10c01768 	cmpgeui	r3,r2,93
81115600:	18035c1e 	bne	r3,zero,81116374 <vLoadDebugConfs+0xe1c>
81115604:	100690ba 	slli	r3,r2,2
81115608:	00a04474 	movhi	r2,33041
8111560c:	10958704 	addi	r2,r2,22044
81115610:	1885883a 	add	r2,r3,r2
81115614:	10800017 	ldw	r2,0(r2)
81115618:	1000683a 	jmp	r2
8111561c:	811157d0 	cmplti	r4,r16,17759
81115620:	811157c4 	addi	r4,r16,17759
81115624:	81116374 	orhi	r4,r16,17805
81115628:	81116374 	orhi	r4,r16,17805
8111562c:	81116374 	orhi	r4,r16,17805
81115630:	81116374 	orhi	r4,r16,17805
81115634:	81116374 	orhi	r4,r16,17805
81115638:	81116374 	orhi	r4,r16,17805
8111563c:	81116374 	orhi	r4,r16,17805
81115640:	81116374 	orhi	r4,r16,17805
81115644:	81116374 	orhi	r4,r16,17805
81115648:	81116374 	orhi	r4,r16,17805
8111564c:	81116374 	orhi	r4,r16,17805
81115650:	81116374 	orhi	r4,r16,17805
81115654:	81116374 	orhi	r4,r16,17805
81115658:	81116374 	orhi	r4,r16,17805
8111565c:	81116374 	orhi	r4,r16,17805
81115660:	81116374 	orhi	r4,r16,17805
81115664:	81116374 	orhi	r4,r16,17805
81115668:	81116374 	orhi	r4,r16,17805
8111566c:	81116374 	orhi	r4,r16,17805
81115670:	81116374 	orhi	r4,r16,17805
81115674:	81116374 	orhi	r4,r16,17805
81115678:	81116374 	orhi	r4,r16,17805
8111567c:	81116374 	orhi	r4,r16,17805
81115680:	81116374 	orhi	r4,r16,17805
81115684:	81116374 	orhi	r4,r16,17805
81115688:	81116374 	orhi	r4,r16,17805
8111568c:	81116374 	orhi	r4,r16,17805
81115690:	81116374 	orhi	r4,r16,17805
81115694:	81116374 	orhi	r4,r16,17805
81115698:	81116374 	orhi	r4,r16,17805
8111569c:	81116374 	orhi	r4,r16,17805
811156a0:	81116374 	orhi	r4,r16,17805
811156a4:	81116374 	orhi	r4,r16,17805
811156a8:	81116374 	orhi	r4,r16,17805
811156ac:	81116374 	orhi	r4,r16,17805
811156b0:	81116374 	orhi	r4,r16,17805
811156b4:	81116374 	orhi	r4,r16,17805
811156b8:	81116374 	orhi	r4,r16,17805
811156bc:	81116374 	orhi	r4,r16,17805
811156c0:	81115790 	cmplti	r4,r16,17758
811156c4:	81116374 	orhi	r4,r16,17805
811156c8:	81116374 	orhi	r4,r16,17805
811156cc:	81116374 	orhi	r4,r16,17805
811156d0:	81116374 	orhi	r4,r16,17805
811156d4:	81116374 	orhi	r4,r16,17805
811156d8:	81116374 	orhi	r4,r16,17805
811156dc:	81116374 	orhi	r4,r16,17805
811156e0:	81116374 	orhi	r4,r16,17805
811156e4:	81116374 	orhi	r4,r16,17805
811156e8:	81116374 	orhi	r4,r16,17805
811156ec:	81116374 	orhi	r4,r16,17805
811156f0:	81116374 	orhi	r4,r16,17805
811156f4:	81116374 	orhi	r4,r16,17805
811156f8:	81116374 	orhi	r4,r16,17805
811156fc:	81116374 	orhi	r4,r16,17805
81115700:	81116374 	orhi	r4,r16,17805
81115704:	81116374 	orhi	r4,r16,17805
81115708:	81116374 	orhi	r4,r16,17805
8111570c:	81116374 	orhi	r4,r16,17805
81115710:	81116374 	orhi	r4,r16,17805
81115714:	81116350 	cmplti	r4,r16,17805
81115718:	81116374 	orhi	r4,r16,17805
8111571c:	81116374 	orhi	r4,r16,17805
81115720:	81116374 	orhi	r4,r16,17805
81115724:	81116374 	orhi	r4,r16,17805
81115728:	81115a9c 	xori	r4,r16,17770
8111572c:	81116048 	cmpgei	r4,r16,17793
81115730:	81115cac 	andhi	r4,r16,17778
81115734:	81115e28 	cmpgeui	r4,r16,17784
81115738:	81116374 	orhi	r4,r16,17805
8111573c:	81116374 	orhi	r4,r16,17805
81115740:	81116374 	orhi	r4,r16,17805
81115744:	81115d5c 	xori	r4,r16,17781
81115748:	81116374 	orhi	r4,r16,17805
8111574c:	81115fc0 	call	881115fc <__reset+0x20f15fc>
81115750:	81115eb0 	cmpltui	r4,r16,17786
81115754:	81115b4c 	andi	r4,r16,17773
81115758:	81115f38 	rdprs	r4,r16,17788
8111575c:	8111593c 	xorhi	r4,r16,17764
81115760:	81115bfc 	xorhi	r4,r16,17775
81115764:	8111588c 	andi	r4,r16,17762
81115768:	81116374 	orhi	r4,r16,17805
8111576c:	811159ec 	andhi	r4,r16,17767
81115770:	811157dc 	xori	r4,r16,17759
81115774:	81116200 	call	88111620 <__reset+0x20f1620>
81115778:	81116168 	cmpgeui	r4,r16,17797
8111577c:	81116374 	orhi	r4,r16,17805
81115780:	811160d0 	cmplti	r4,r16,17795
81115784:	81116374 	orhi	r4,r16,17805
81115788:	81116374 	orhi	r4,r16,17805
8111578c:	811162a8 	cmpgeui	r4,r16,17802
					case 39:// single quote '
						c = cGetNextChar(siFile);
81115790:	e0bff60f 	ldh	r2,-40(fp)
81115794:	1009883a 	mov	r4,r2
81115798:	11186d40 	call	811186d4 <cGetNextChar>
8111579c:	e0bff345 	stb	r2,-51(fp)
						while ( c != 39 ){
811157a0:	00000406 	br	811157b4 <vLoadDebugConfs+0x25c>
							c = cGetNextChar(siFile);
811157a4:	e0bff60f 	ldh	r2,-40(fp)
811157a8:	1009883a 	mov	r4,r2
811157ac:	11186d40 	call	811186d4 <cGetNextChar>
811157b0:	e0bff345 	stb	r2,-51(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
811157b4:	e0bff347 	ldb	r2,-51(fp)
811157b8:	108009d8 	cmpnei	r2,r2,39
811157bc:	103ff91e 	bne	r2,zero,811157a4 <__reset+0xfb0f57a4>
							c = cGetNextChar(siFile);
						}
						break;
811157c0:	0002ed06 	br	81116378 <vLoadDebugConfs+0xe20>
					case -1: 	//EOF
						bEOF = TRUE;
811157c4:	00800044 	movi	r2,1
811157c8:	e0bff215 	stw	r2,-56(fp)
						break;
811157cc:	0002ea06 	br	81116378 <vLoadDebugConfs+0xe20>
					case -2: 	//EOF
						#if DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
						#endif
						bEOF = TRUE;
811157d0:	00800044 	movi	r2,1
811157d4:	e0bff215 	stw	r2,-56(fp)
						break;
811157d8:	0002e706 	br	81116378 <vLoadDebugConfs+0xe20>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;

					case 'S':
						ucParser = 0;
811157dc:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811157e0:	e0bff60f 	ldh	r2,-40(fp)
811157e4:	1009883a 	mov	r4,r2
811157e8:	11186d40 	call	811186d4 <cGetNextChar>
811157ec:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
811157f0:	d0e00317 	ldw	r3,-32756(gp)
811157f4:	e0bff347 	ldb	r2,-51(fp)
811157f8:	10800044 	addi	r2,r2,1
811157fc:	1885883a 	add	r2,r3,r2
81115800:	10800003 	ldbu	r2,0(r2)
81115804:	10803fcc 	andi	r2,r2,255
81115808:	1080010c 	andi	r2,r2,4
8111580c:	10000626 	beq	r2,zero,81115828 <vLoadDebugConfs+0x2d0>
									(*p_inteiro) = c;
81115810:	e0bff417 	ldw	r2,-48(fp)
81115814:	e0fff343 	ldbu	r3,-51(fp)
81115818:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111581c:	e0bff417 	ldw	r2,-48(fp)
81115820:	10800044 	addi	r2,r2,1
81115824:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81115828:	e0bff347 	ldb	r2,-51(fp)
8111582c:	10800ba0 	cmpeqi	r2,r2,46
81115830:	1000031e 	bne	r2,zero,81115840 <vLoadDebugConfs+0x2e8>
81115834:	e0bff347 	ldb	r2,-51(fp)
81115838:	10800ed8 	cmpnei	r2,r2,59
8111583c:	103fe81e 	bne	r2,zero,811157e0 <__reset+0xfb0f57e0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115840:	e0bff417 	ldw	r2,-48(fp)
81115844:	00c00284 	movi	r3,10
81115848:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiSyncPeriod = atoi( inteiro );
8111584c:	e0bff704 	addi	r2,fp,-36
81115850:	1009883a 	mov	r4,r2
81115854:	111ab7c0 	call	8111ab7c <atoi>
81115858:	1007883a 	mov	r3,r2
8111585c:	00a045b4 	movhi	r2,33046
81115860:	10acbf04 	addi	r2,r2,-19716
81115864:	10c0068d 	sth	r3,26(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81115868:	e0bff704 	addi	r2,fp,-36
8111586c:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
81115870:	e0bff303 	ldbu	r2,-52(fp)
81115874:	10800044 	addi	r2,r2,1
81115878:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111587c:	e0bff347 	ldb	r2,-51(fp)
81115880:	10800ed8 	cmpnei	r2,r2,59
81115884:	103fd61e 	bne	r2,zero,811157e0 <__reset+0xfb0f57e0>

						break;
81115888:	0002bb06 	br	81116378 <vLoadDebugConfs+0xe20>
					case 'P':
						ucParser = 0;
8111588c:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115890:	e0bff60f 	ldh	r2,-40(fp)
81115894:	1009883a 	mov	r4,r2
81115898:	11186d40 	call	811186d4 <cGetNextChar>
8111589c:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
811158a0:	d0e00317 	ldw	r3,-32756(gp)
811158a4:	e0bff347 	ldb	r2,-51(fp)
811158a8:	10800044 	addi	r2,r2,1
811158ac:	1885883a 	add	r2,r3,r2
811158b0:	10800003 	ldbu	r2,0(r2)
811158b4:	10803fcc 	andi	r2,r2,255
811158b8:	1080010c 	andi	r2,r2,4
811158bc:	10000626 	beq	r2,zero,811158d8 <vLoadDebugConfs+0x380>
									(*p_inteiro) = c;
811158c0:	e0bff417 	ldw	r2,-48(fp)
811158c4:	e0fff343 	ldbu	r3,-51(fp)
811158c8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811158cc:	e0bff417 	ldw	r2,-48(fp)
811158d0:	10800044 	addi	r2,r2,1
811158d4:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
811158d8:	e0bff347 	ldb	r2,-51(fp)
811158dc:	10800ba0 	cmpeqi	r2,r2,46
811158e0:	1000031e 	bne	r2,zero,811158f0 <vLoadDebugConfs+0x398>
811158e4:	e0bff347 	ldb	r2,-51(fp)
811158e8:	10800ed8 	cmpnei	r2,r2,59
811158ec:	103fe81e 	bne	r2,zero,81115890 <__reset+0xfb0f5890>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811158f0:	e0bff417 	ldw	r2,-48(fp)
811158f4:	00c00284 	movi	r3,10
811158f8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiPreScanSerial = atoi( inteiro );
811158fc:	e0bff704 	addi	r2,fp,-36
81115900:	1009883a 	mov	r4,r2
81115904:	111ab7c0 	call	8111ab7c <atoi>
81115908:	1007883a 	mov	r3,r2
8111590c:	00a045b4 	movhi	r2,33046
81115910:	10acbf04 	addi	r2,r2,-19716
81115914:	10c0048d 	sth	r3,18(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81115918:	e0bff704 	addi	r2,fp,-36
8111591c:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
81115920:	e0bff303 	ldbu	r2,-52(fp)
81115924:	10800044 	addi	r2,r2,1
81115928:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
8111592c:	e0bff347 	ldb	r2,-51(fp)
81115930:	10800ed8 	cmpnei	r2,r2,59
81115934:	103fd61e 	bne	r2,zero,81115890 <__reset+0xfb0f5890>

						break;
81115938:	00028f06 	br	81116378 <vLoadDebugConfs+0xe20>
					case 'N':
						ucParser = 0;
8111593c:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115940:	e0bff60f 	ldh	r2,-40(fp)
81115944:	1009883a 	mov	r4,r2
81115948:	11186d40 	call	811186d4 <cGetNextChar>
8111594c:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
81115950:	d0e00317 	ldw	r3,-32756(gp)
81115954:	e0bff347 	ldb	r2,-51(fp)
81115958:	10800044 	addi	r2,r2,1
8111595c:	1885883a 	add	r2,r3,r2
81115960:	10800003 	ldbu	r2,0(r2)
81115964:	10803fcc 	andi	r2,r2,255
81115968:	1080010c 	andi	r2,r2,4
8111596c:	10000626 	beq	r2,zero,81115988 <vLoadDebugConfs+0x430>
									(*p_inteiro) = c;
81115970:	e0bff417 	ldw	r2,-48(fp)
81115974:	e0fff343 	ldbu	r3,-51(fp)
81115978:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111597c:	e0bff417 	ldw	r2,-48(fp)
81115980:	10800044 	addi	r2,r2,1
81115984:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81115988:	e0bff347 	ldb	r2,-51(fp)
8111598c:	10800ba0 	cmpeqi	r2,r2,46
81115990:	1000031e 	bne	r2,zero,811159a0 <vLoadDebugConfs+0x448>
81115994:	e0bff347 	ldb	r2,-51(fp)
81115998:	10800ed8 	cmpnei	r2,r2,59
8111599c:	103fe81e 	bne	r2,zero,81115940 <__reset+0xfb0f5940>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811159a0:	e0bff417 	ldw	r2,-48(fp)
811159a4:	00c00284 	movi	r3,10
811159a8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOverScanSerial = atoi( inteiro );
811159ac:	e0bff704 	addi	r2,fp,-36
811159b0:	1009883a 	mov	r4,r2
811159b4:	111ab7c0 	call	8111ab7c <atoi>
811159b8:	1007883a 	mov	r3,r2
811159bc:	00a045b4 	movhi	r2,33046
811159c0:	10acbf04 	addi	r2,r2,-19716
811159c4:	10c0040d 	sth	r3,16(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
811159c8:	e0bff704 	addi	r2,fp,-36
811159cc:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
811159d0:	e0bff303 	ldbu	r2,-52(fp)
811159d4:	10800044 	addi	r2,r2,1
811159d8:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
811159dc:	e0bff347 	ldb	r2,-51(fp)
811159e0:	10800ed8 	cmpnei	r2,r2,59
811159e4:	103fd61e 	bne	r2,zero,81115940 <__reset+0xfb0f5940>

						break;
811159e8:	00026306 	br	81116378 <vLoadDebugConfs+0xe20>
					case 'R':
						ucParser = 0;
811159ec:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811159f0:	e0bff60f 	ldh	r2,-40(fp)
811159f4:	1009883a 	mov	r4,r2
811159f8:	11186d40 	call	811186d4 <cGetNextChar>
811159fc:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
81115a00:	d0e00317 	ldw	r3,-32756(gp)
81115a04:	e0bff347 	ldb	r2,-51(fp)
81115a08:	10800044 	addi	r2,r2,1
81115a0c:	1885883a 	add	r2,r3,r2
81115a10:	10800003 	ldbu	r2,0(r2)
81115a14:	10803fcc 	andi	r2,r2,255
81115a18:	1080010c 	andi	r2,r2,4
81115a1c:	10000626 	beq	r2,zero,81115a38 <vLoadDebugConfs+0x4e0>
									(*p_inteiro) = c;
81115a20:	e0bff417 	ldw	r2,-48(fp)
81115a24:	e0fff343 	ldbu	r3,-51(fp)
81115a28:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81115a2c:	e0bff417 	ldw	r2,-48(fp)
81115a30:	10800044 	addi	r2,r2,1
81115a34:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81115a38:	e0bff347 	ldb	r2,-51(fp)
81115a3c:	10800ba0 	cmpeqi	r2,r2,46
81115a40:	1000031e 	bne	r2,zero,81115a50 <vLoadDebugConfs+0x4f8>
81115a44:	e0bff347 	ldb	r2,-51(fp)
81115a48:	10800ed8 	cmpnei	r2,r2,59
81115a4c:	103fe81e 	bne	r2,zero,811159f0 <__reset+0xfb0f59f0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115a50:	e0bff417 	ldw	r2,-48(fp)
81115a54:	00c00284 	movi	r3,10
81115a58:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucRmapKey = atoi( inteiro );
81115a5c:	e0bff704 	addi	r2,fp,-36
81115a60:	1009883a 	mov	r4,r2
81115a64:	111ab7c0 	call	8111ab7c <atoi>
81115a68:	1007883a 	mov	r3,r2
81115a6c:	00a045b4 	movhi	r2,33046
81115a70:	10acbf04 	addi	r2,r2,-19716
81115a74:	10c00c0d 	sth	r3,48(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81115a78:	e0bff704 	addi	r2,fp,-36
81115a7c:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
81115a80:	e0bff303 	ldbu	r2,-52(fp)
81115a84:	10800044 	addi	r2,r2,1
81115a88:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
81115a8c:	e0bff347 	ldb	r2,-51(fp)
81115a90:	10800ed8 	cmpnei	r2,r2,59
81115a94:	103fd61e 	bne	r2,zero,811159f0 <__reset+0xfb0f59f0>

						break;
81115a98:	00023706 	br	81116378 <vLoadDebugConfs+0xe20>
					case 'A':
						ucParser = 0;
81115a9c:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115aa0:	e0bff60f 	ldh	r2,-40(fp)
81115aa4:	1009883a 	mov	r4,r2
81115aa8:	11186d40 	call	811186d4 <cGetNextChar>
81115aac:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
81115ab0:	d0e00317 	ldw	r3,-32756(gp)
81115ab4:	e0bff347 	ldb	r2,-51(fp)
81115ab8:	10800044 	addi	r2,r2,1
81115abc:	1885883a 	add	r2,r3,r2
81115ac0:	10800003 	ldbu	r2,0(r2)
81115ac4:	10803fcc 	andi	r2,r2,255
81115ac8:	1080010c 	andi	r2,r2,4
81115acc:	10000626 	beq	r2,zero,81115ae8 <vLoadDebugConfs+0x590>
									(*p_inteiro) = c;
81115ad0:	e0bff417 	ldw	r2,-48(fp)
81115ad4:	e0fff343 	ldbu	r3,-51(fp)
81115ad8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81115adc:	e0bff417 	ldw	r2,-48(fp)
81115ae0:	10800044 	addi	r2,r2,1
81115ae4:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81115ae8:	e0bff347 	ldb	r2,-51(fp)
81115aec:	10800ba0 	cmpeqi	r2,r2,46
81115af0:	1000031e 	bne	r2,zero,81115b00 <vLoadDebugConfs+0x5a8>
81115af4:	e0bff347 	ldb	r2,-51(fp)
81115af8:	10800ed8 	cmpnei	r2,r2,59
81115afc:	103fe81e 	bne	r2,zero,81115aa0 <__reset+0xfb0f5aa0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115b00:	e0bff417 	ldw	r2,-48(fp)
81115b04:	00c00284 	movi	r3,10
81115b08:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.ucLogicalAddr = atoi( inteiro );
81115b0c:	e0bff704 	addi	r2,fp,-36
81115b10:	1009883a 	mov	r4,r2
81115b14:	111ab7c0 	call	8111ab7c <atoi>
81115b18:	1007883a 	mov	r3,r2
81115b1c:	00a045b4 	movhi	r2,33046
81115b20:	10acbf04 	addi	r2,r2,-19716
81115b24:	10c00c8d 	sth	r3,50(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81115b28:	e0bff704 	addi	r2,fp,-36
81115b2c:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
81115b30:	e0bff303 	ldbu	r2,-52(fp)
81115b34:	10800044 	addi	r2,r2,1
81115b38:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
81115b3c:	e0bff347 	ldb	r2,-51(fp)
81115b40:	10800ed8 	cmpnei	r2,r2,59
81115b44:	103fd61e 	bne	r2,zero,81115aa0 <__reset+0xfb0f5aa0>

						break;
81115b48:	00020b06 	br	81116378 <vLoadDebugConfs+0xe20>
					case 'L':
						ucParser = 0;
81115b4c:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115b50:	e0bff60f 	ldh	r2,-40(fp)
81115b54:	1009883a 	mov	r4,r2
81115b58:	11186d40 	call	811186d4 <cGetNextChar>
81115b5c:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
81115b60:	d0e00317 	ldw	r3,-32756(gp)
81115b64:	e0bff347 	ldb	r2,-51(fp)
81115b68:	10800044 	addi	r2,r2,1
81115b6c:	1885883a 	add	r2,r3,r2
81115b70:	10800003 	ldbu	r2,0(r2)
81115b74:	10803fcc 	andi	r2,r2,255
81115b78:	1080010c 	andi	r2,r2,4
81115b7c:	10000626 	beq	r2,zero,81115b98 <vLoadDebugConfs+0x640>
									(*p_inteiro) = c;
81115b80:	e0bff417 	ldw	r2,-48(fp)
81115b84:	e0fff343 	ldbu	r3,-51(fp)
81115b88:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81115b8c:	e0bff417 	ldw	r2,-48(fp)
81115b90:	10800044 	addi	r2,r2,1
81115b94:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81115b98:	e0bff347 	ldb	r2,-51(fp)
81115b9c:	10800ba0 	cmpeqi	r2,r2,46
81115ba0:	1000031e 	bne	r2,zero,81115bb0 <vLoadDebugConfs+0x658>
81115ba4:	e0bff347 	ldb	r2,-51(fp)
81115ba8:	10800ed8 	cmpnei	r2,r2,59
81115bac:	103fe81e 	bne	r2,zero,81115b50 <__reset+0xfb0f5b50>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115bb0:	e0bff417 	ldw	r2,-48(fp)
81115bb4:	00c00284 	movi	r3,10
81115bb8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiRows = atoi( inteiro );
81115bbc:	e0bff704 	addi	r2,fp,-36
81115bc0:	1009883a 	mov	r4,r2
81115bc4:	111ab7c0 	call	8111ab7c <atoi>
81115bc8:	1007883a 	mov	r3,r2
81115bcc:	00a045b4 	movhi	r2,33046
81115bd0:	10acbf04 	addi	r2,r2,-19716
81115bd4:	10c0060d 	sth	r3,24(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81115bd8:	e0bff704 	addi	r2,fp,-36
81115bdc:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
81115be0:	e0bff303 	ldbu	r2,-52(fp)
81115be4:	10800044 	addi	r2,r2,1
81115be8:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
81115bec:	e0bff347 	ldb	r2,-51(fp)
81115bf0:	10800ed8 	cmpnei	r2,r2,59
81115bf4:	103fd61e 	bne	r2,zero,81115b50 <__reset+0xfb0f5b50>

						break;
81115bf8:	0001df06 	br	81116378 <vLoadDebugConfs+0xe20>

					case 'O':
						ucParser = 0;
81115bfc:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115c00:	e0bff60f 	ldh	r2,-40(fp)
81115c04:	1009883a 	mov	r4,r2
81115c08:	11186d40 	call	811186d4 <cGetNextChar>
81115c0c:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
81115c10:	d0e00317 	ldw	r3,-32756(gp)
81115c14:	e0bff347 	ldb	r2,-51(fp)
81115c18:	10800044 	addi	r2,r2,1
81115c1c:	1885883a 	add	r2,r3,r2
81115c20:	10800003 	ldbu	r2,0(r2)
81115c24:	10803fcc 	andi	r2,r2,255
81115c28:	1080010c 	andi	r2,r2,4
81115c2c:	10000626 	beq	r2,zero,81115c48 <vLoadDebugConfs+0x6f0>
									(*p_inteiro) = c;
81115c30:	e0bff417 	ldw	r2,-48(fp)
81115c34:	e0fff343 	ldbu	r3,-51(fp)
81115c38:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81115c3c:	e0bff417 	ldw	r2,-48(fp)
81115c40:	10800044 	addi	r2,r2,1
81115c44:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81115c48:	e0bff347 	ldb	r2,-51(fp)
81115c4c:	10800ba0 	cmpeqi	r2,r2,46
81115c50:	1000031e 	bne	r2,zero,81115c60 <vLoadDebugConfs+0x708>
81115c54:	e0bff347 	ldb	r2,-51(fp)
81115c58:	10800ed8 	cmpnei	r2,r2,59
81115c5c:	103fe81e 	bne	r2,zero,81115c00 <__reset+0xfb0f5c00>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115c60:	e0bff417 	ldw	r2,-48(fp)
81115c64:	00c00284 	movi	r3,10
81115c68:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOLN = atoi( inteiro );
81115c6c:	e0bff704 	addi	r2,fp,-36
81115c70:	1009883a 	mov	r4,r2
81115c74:	111ab7c0 	call	8111ab7c <atoi>
81115c78:	1007883a 	mov	r3,r2
81115c7c:	00a045b4 	movhi	r2,33046
81115c80:	10acbf04 	addi	r2,r2,-19716
81115c84:	10c0050d 	sth	r3,20(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81115c88:	e0bff704 	addi	r2,fp,-36
81115c8c:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
81115c90:	e0bff303 	ldbu	r2,-52(fp)
81115c94:	10800044 	addi	r2,r2,1
81115c98:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
81115c9c:	e0bff347 	ldb	r2,-51(fp)
81115ca0:	10800ed8 	cmpnei	r2,r2,59
81115ca4:	103fd61e 	bne	r2,zero,81115c00 <__reset+0xfb0f5c00>

						break;
81115ca8:	0001b306 	br	81116378 <vLoadDebugConfs+0xe20>
					case 'C':
						ucParser = 0;
81115cac:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115cb0:	e0bff60f 	ldh	r2,-40(fp)
81115cb4:	1009883a 	mov	r4,r2
81115cb8:	11186d40 	call	811186d4 <cGetNextChar>
81115cbc:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
81115cc0:	d0e00317 	ldw	r3,-32756(gp)
81115cc4:	e0bff347 	ldb	r2,-51(fp)
81115cc8:	10800044 	addi	r2,r2,1
81115ccc:	1885883a 	add	r2,r3,r2
81115cd0:	10800003 	ldbu	r2,0(r2)
81115cd4:	10803fcc 	andi	r2,r2,255
81115cd8:	1080010c 	andi	r2,r2,4
81115cdc:	10000626 	beq	r2,zero,81115cf8 <vLoadDebugConfs+0x7a0>
									(*p_inteiro) = c;
81115ce0:	e0bff417 	ldw	r2,-48(fp)
81115ce4:	e0fff343 	ldbu	r3,-51(fp)
81115ce8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81115cec:	e0bff417 	ldw	r2,-48(fp)
81115cf0:	10800044 	addi	r2,r2,1
81115cf4:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81115cf8:	e0bff347 	ldb	r2,-51(fp)
81115cfc:	10800ba0 	cmpeqi	r2,r2,46
81115d00:	1000031e 	bne	r2,zero,81115d10 <vLoadDebugConfs+0x7b8>
81115d04:	e0bff347 	ldb	r2,-51(fp)
81115d08:	10800ed8 	cmpnei	r2,r2,59
81115d0c:	103fe81e 	bne	r2,zero,81115cb0 <__reset+0xfb0f5cb0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115d10:	e0bff417 	ldw	r2,-48(fp)
81115d14:	00c00284 	movi	r3,10
81115d18:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiCols = atoi( inteiro );
81115d1c:	e0bff704 	addi	r2,fp,-36
81115d20:	1009883a 	mov	r4,r2
81115d24:	111ab7c0 	call	8111ab7c <atoi>
81115d28:	1007883a 	mov	r3,r2
81115d2c:	00a045b4 	movhi	r2,33046
81115d30:	10acbf04 	addi	r2,r2,-19716
81115d34:	10c0058d 	sth	r3,22(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81115d38:	e0bff704 	addi	r2,fp,-36
81115d3c:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
81115d40:	e0bff303 	ldbu	r2,-52(fp)
81115d44:	10800044 	addi	r2,r2,1
81115d48:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
81115d4c:	e0bff347 	ldb	r2,-51(fp)
81115d50:	10800ed8 	cmpnei	r2,r2,59
81115d54:	103fd61e 	bne	r2,zero,81115cb0 <__reset+0xfb0f5cb0>

						break;
81115d58:	00018706 	br	81116378 <vLoadDebugConfs+0xe20>
					case 'H':

						ucParser = 0;
81115d5c:	e03ff305 	stb	zero,-52(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81115d60:	e0bff60f 	ldh	r2,-40(fp)
81115d64:	1009883a 	mov	r4,r2
81115d68:	11186d40 	call	811186d4 <cGetNextChar>
81115d6c:	e0bff345 	stb	r2,-51(fp)
								if ( isdigit( c ) ) {
81115d70:	d0e00317 	ldw	r3,-32756(gp)
81115d74:	e0bff347 	ldb	r2,-51(fp)
81115d78:	10800044 	addi	r2,r2,1
81115d7c:	1885883a 	add	r2,r3,r2
81115d80:	10800003 	ldbu	r2,0(r2)
81115d84:	10803fcc 	andi	r2,r2,255
81115d88:	1080010c 	andi	r2,r2,4
81115d8c:	10000626 	beq	r2,zero,81115da8 <vLoadDebugConfs+0x850>
									(*p_inteiro) = c;
81115d90:	e0bff417 	ldw	r2,-48(fp)
81115d94:	e0fff343 	ldbu	r3,-51(fp)
81115d98:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81115d9c:	e0bff417 	ldw	r2,-48(fp)
81115da0:	10800044 	addi	r2,r2,1
81115da4:	e0bff415 	stw	r2,-48(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81115da8:	e0bff347 	ldb	r2,-51(fp)
81115dac:	10800ba0 	cmpeqi	r2,r2,46
81115db0:	1000031e 	bne	r2,zero,81115dc0 <vLoadDebugConfs+0x868>
81115db4:	e0bff347 	ldb	r2,-51(fp)
81115db8:	10800ed8 	cmpnei	r2,r2,59
81115dbc:	103fe81e 	bne	r2,zero,81115d60 <__reset+0xfb0f5d60>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115dc0:	e0bff417 	ldw	r2,-48(fp)
81115dc4:	00c00284 	movi	r3,10
81115dc8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.HK[min_sim(ucParser,15)] = atoi( inteiro );
81115dcc:	e0bff303 	ldbu	r2,-52(fp)
81115dd0:	108003e8 	cmpgeui	r2,r2,15
81115dd4:	1000021e 	bne	r2,zero,81115de0 <vLoadDebugConfs+0x888>
81115dd8:	e43ff303 	ldbu	r16,-52(fp)
81115ddc:	00000106 	br	81115de4 <vLoadDebugConfs+0x88c>
81115de0:	040003c4 	movi	r16,15
81115de4:	e0bff704 	addi	r2,fp,-36
81115de8:	1009883a 	mov	r4,r2
81115dec:	111ab7c0 	call	8111ab7c <atoi>
81115df0:	1007883a 	mov	r3,r2
81115df4:	00a045b4 	movhi	r2,33046
81115df8:	10acbf04 	addi	r2,r2,-19716
81115dfc:	1405883a 	add	r2,r2,r16
81115e00:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81115e04:	e0bff704 	addi	r2,fp,-36
81115e08:	e0bff415 	stw	r2,-48(fp)
							ucParser++;
81115e0c:	e0bff303 	ldbu	r2,-52(fp)
81115e10:	10800044 	addi	r2,r2,1
81115e14:	e0bff305 	stb	r2,-52(fp)
						} while ( (c !=59) );
81115e18:	e0bff347 	ldb	r2,-51(fp)
81115e1c:	10800ed8 	cmpnei	r2,r2,59
81115e20:	103fcf1e 	bne	r2,zero,81115d60 <__reset+0xfb0f5d60>

						break;
81115e24:	00015406 	br	81116378 <vLoadDebugConfs+0xe20>
					case 'D':

						do {
							c = cGetNextChar(siFile);
81115e28:	e0bff60f 	ldh	r2,-40(fp)
81115e2c:	1009883a 	mov	r4,r2
81115e30:	11186d40 	call	811186d4 <cGetNextChar>
81115e34:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
81115e38:	d0e00317 	ldw	r3,-32756(gp)
81115e3c:	e0bff347 	ldb	r2,-51(fp)
81115e40:	10800044 	addi	r2,r2,1
81115e44:	1885883a 	add	r2,r3,r2
81115e48:	10800003 	ldbu	r2,0(r2)
81115e4c:	10803fcc 	andi	r2,r2,255
81115e50:	1080010c 	andi	r2,r2,4
81115e54:	10000626 	beq	r2,zero,81115e70 <vLoadDebugConfs+0x918>
								(*p_inteiro) = c;
81115e58:	e0bff417 	ldw	r2,-48(fp)
81115e5c:	e0fff343 	ldbu	r3,-51(fp)
81115e60:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81115e64:	e0bff417 	ldw	r2,-48(fp)
81115e68:	10800044 	addi	r2,r2,1
81115e6c:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81115e70:	e0bff347 	ldb	r2,-51(fp)
81115e74:	10800ed8 	cmpnei	r2,r2,59
81115e78:	103feb1e 	bne	r2,zero,81115e28 <__reset+0xfb0f5e28>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115e7c:	e0bff417 	ldw	r2,-48(fp)
81115e80:	00c00284 	movi	r3,10
81115e84:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDelay = atoi( inteiro );
81115e88:	e0bff704 	addi	r2,fp,-36
81115e8c:	1009883a 	mov	r4,r2
81115e90:	111ab7c0 	call	8111ab7c <atoi>
81115e94:	1007883a 	mov	r3,r2
81115e98:	00a045b4 	movhi	r2,33046
81115e9c:	10acbf04 	addi	r2,r2,-19716
81115ea0:	10c0070d 	sth	r3,28(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81115ea4:	e0bff704 	addi	r2,fp,-36
81115ea8:	e0bff415 	stw	r2,-48(fp)

						break;
81115eac:	00013206 	br	81116378 <vLoadDebugConfs+0xe20>
					case 'K':

						do {
							c = cGetNextChar(siFile);
81115eb0:	e0bff60f 	ldh	r2,-40(fp)
81115eb4:	1009883a 	mov	r4,r2
81115eb8:	11186d40 	call	811186d4 <cGetNextChar>
81115ebc:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
81115ec0:	d0e00317 	ldw	r3,-32756(gp)
81115ec4:	e0bff347 	ldb	r2,-51(fp)
81115ec8:	10800044 	addi	r2,r2,1
81115ecc:	1885883a 	add	r2,r3,r2
81115ed0:	10800003 	ldbu	r2,0(r2)
81115ed4:	10803fcc 	andi	r2,r2,255
81115ed8:	1080010c 	andi	r2,r2,4
81115edc:	10000626 	beq	r2,zero,81115ef8 <vLoadDebugConfs+0x9a0>
								(*p_inteiro) = c;
81115ee0:	e0bff417 	ldw	r2,-48(fp)
81115ee4:	e0fff343 	ldbu	r3,-51(fp)
81115ee8:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81115eec:	e0bff417 	ldw	r2,-48(fp)
81115ef0:	10800044 	addi	r2,r2,1
81115ef4:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81115ef8:	e0bff347 	ldb	r2,-51(fp)
81115efc:	10800ed8 	cmpnei	r2,r2,59
81115f00:	103feb1e 	bne	r2,zero,81115eb0 <__reset+0xfb0f5eb0>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115f04:	e0bff417 	ldw	r2,-48(fp)
81115f08:	00c00284 	movi	r3,10
81115f0c:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulColDelay = atoi( inteiro );
81115f10:	e0bff704 	addi	r2,fp,-36
81115f14:	1009883a 	mov	r4,r2
81115f18:	111ab7c0 	call	8111ab7c <atoi>
81115f1c:	1007883a 	mov	r3,r2
81115f20:	00a045b4 	movhi	r2,33046
81115f24:	10acbf04 	addi	r2,r2,-19716
81115f28:	10c00a15 	stw	r3,40(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81115f2c:	e0bff704 	addi	r2,fp,-36
81115f30:	e0bff415 	stw	r2,-48(fp)

						break;
81115f34:	00011006 	br	81116378 <vLoadDebugConfs+0xe20>
					case 'M':

						do {
							c = cGetNextChar(siFile);
81115f38:	e0bff60f 	ldh	r2,-40(fp)
81115f3c:	1009883a 	mov	r4,r2
81115f40:	11186d40 	call	811186d4 <cGetNextChar>
81115f44:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
81115f48:	d0e00317 	ldw	r3,-32756(gp)
81115f4c:	e0bff347 	ldb	r2,-51(fp)
81115f50:	10800044 	addi	r2,r2,1
81115f54:	1885883a 	add	r2,r3,r2
81115f58:	10800003 	ldbu	r2,0(r2)
81115f5c:	10803fcc 	andi	r2,r2,255
81115f60:	1080010c 	andi	r2,r2,4
81115f64:	10000626 	beq	r2,zero,81115f80 <vLoadDebugConfs+0xa28>
								(*p_inteiro) = c;
81115f68:	e0bff417 	ldw	r2,-48(fp)
81115f6c:	e0fff343 	ldbu	r3,-51(fp)
81115f70:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81115f74:	e0bff417 	ldw	r2,-48(fp)
81115f78:	10800044 	addi	r2,r2,1
81115f7c:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81115f80:	e0bff347 	ldb	r2,-51(fp)
81115f84:	10800ed8 	cmpnei	r2,r2,59
81115f88:	103feb1e 	bne	r2,zero,81115f38 <__reset+0xfb0f5f38>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81115f8c:	e0bff417 	ldw	r2,-48(fp)
81115f90:	00c00284 	movi	r3,10
81115f94:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulADCPixelDelay = atoi( inteiro );
81115f98:	e0bff704 	addi	r2,fp,-36
81115f9c:	1009883a 	mov	r4,r2
81115fa0:	111ab7c0 	call	8111ab7c <atoi>
81115fa4:	1007883a 	mov	r3,r2
81115fa8:	00a045b4 	movhi	r2,33046
81115fac:	10acbf04 	addi	r2,r2,-19716
81115fb0:	10c00b15 	stw	r3,44(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81115fb4:	e0bff704 	addi	r2,fp,-36
81115fb8:	e0bff415 	stw	r2,-48(fp)

						break;
81115fbc:	0000ee06 	br	81116378 <vLoadDebugConfs+0xe20>
					case 'J':

						do {
							c = cGetNextChar(siFile);
81115fc0:	e0bff60f 	ldh	r2,-40(fp)
81115fc4:	1009883a 	mov	r4,r2
81115fc8:	11186d40 	call	811186d4 <cGetNextChar>
81115fcc:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
81115fd0:	d0e00317 	ldw	r3,-32756(gp)
81115fd4:	e0bff347 	ldb	r2,-51(fp)
81115fd8:	10800044 	addi	r2,r2,1
81115fdc:	1885883a 	add	r2,r3,r2
81115fe0:	10800003 	ldbu	r2,0(r2)
81115fe4:	10803fcc 	andi	r2,r2,255
81115fe8:	1080010c 	andi	r2,r2,4
81115fec:	10000626 	beq	r2,zero,81116008 <vLoadDebugConfs+0xab0>
								(*p_inteiro) = c;
81115ff0:	e0bff417 	ldw	r2,-48(fp)
81115ff4:	e0fff343 	ldbu	r3,-51(fp)
81115ff8:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81115ffc:	e0bff417 	ldw	r2,-48(fp)
81116000:	10800044 	addi	r2,r2,1
81116004:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81116008:	e0bff347 	ldb	r2,-51(fp)
8111600c:	10800ed8 	cmpnei	r2,r2,59
81116010:	103feb1e 	bne	r2,zero,81115fc0 <__reset+0xfb0f5fc0>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81116014:	e0bff417 	ldw	r2,-48(fp)
81116018:	00c00284 	movi	r3,10
8111601c:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulLineDelay = atoi( inteiro );
81116020:	e0bff704 	addi	r2,fp,-36
81116024:	1009883a 	mov	r4,r2
81116028:	111ab7c0 	call	8111ab7c <atoi>
8111602c:	1007883a 	mov	r3,r2
81116030:	00a045b4 	movhi	r2,33046
81116034:	10acbf04 	addi	r2,r2,-19716
81116038:	10c00915 	stw	r3,36(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111603c:	e0bff704 	addi	r2,fp,-36
81116040:	e0bff415 	stw	r2,-48(fp)

						break;
81116044:	0000cc06 	br	81116378 <vLoadDebugConfs+0xe20>
					case 'B':

						do {
							c = cGetNextChar(siFile);
81116048:	e0bff60f 	ldh	r2,-40(fp)
8111604c:	1009883a 	mov	r4,r2
81116050:	11186d40 	call	811186d4 <cGetNextChar>
81116054:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
81116058:	d0e00317 	ldw	r3,-32756(gp)
8111605c:	e0bff347 	ldb	r2,-51(fp)
81116060:	10800044 	addi	r2,r2,1
81116064:	1885883a 	add	r2,r3,r2
81116068:	10800003 	ldbu	r2,0(r2)
8111606c:	10803fcc 	andi	r2,r2,255
81116070:	1080010c 	andi	r2,r2,4
81116074:	10000626 	beq	r2,zero,81116090 <vLoadDebugConfs+0xb38>
								(*p_inteiro) = c;
81116078:	e0bff417 	ldw	r2,-48(fp)
8111607c:	e0fff343 	ldbu	r3,-51(fp)
81116080:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81116084:	e0bff417 	ldw	r2,-48(fp)
81116088:	10800044 	addi	r2,r2,1
8111608c:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81116090:	e0bff347 	ldb	r2,-51(fp)
81116094:	10800ed8 	cmpnei	r2,r2,59
81116098:	103feb1e 	bne	r2,zero,81116048 <__reset+0xfb0f6048>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111609c:	e0bff417 	ldw	r2,-48(fp)
811160a0:	00c00284 	movi	r3,10
811160a4:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiLinkNFEE0 = atoi( inteiro );
811160a8:	e0bff704 	addi	r2,fp,-36
811160ac:	1009883a 	mov	r4,r2
811160b0:	111ab7c0 	call	8111ab7c <atoi>
811160b4:	1007883a 	mov	r3,r2
811160b8:	00a045b4 	movhi	r2,33046
811160bc:	10acbf04 	addi	r2,r2,-19716
811160c0:	10c0100d 	sth	r3,64(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
811160c4:	e0bff704 	addi	r2,fp,-36
811160c8:	e0bff415 	stw	r2,-48(fp)

						break;
811160cc:	0000aa06 	br	81116378 <vLoadDebugConfs+0xe20>
					case 'W':

						p_inteiro = inteiroll;
811160d0:	e0bff904 	addi	r2,fp,-28
811160d4:	e0bff415 	stw	r2,-48(fp)
						do {
							c = cGetNextChar(siFile);
811160d8:	e0bff60f 	ldh	r2,-40(fp)
811160dc:	1009883a 	mov	r4,r2
811160e0:	11186d40 	call	811186d4 <cGetNextChar>
811160e4:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
811160e8:	d0e00317 	ldw	r3,-32756(gp)
811160ec:	e0bff347 	ldb	r2,-51(fp)
811160f0:	10800044 	addi	r2,r2,1
811160f4:	1885883a 	add	r2,r3,r2
811160f8:	10800003 	ldbu	r2,0(r2)
811160fc:	10803fcc 	andi	r2,r2,255
81116100:	1080010c 	andi	r2,r2,4
81116104:	10000626 	beq	r2,zero,81116120 <vLoadDebugConfs+0xbc8>
								(*p_inteiro) = c;
81116108:	e0bff417 	ldw	r2,-48(fp)
8111610c:	e0fff343 	ldbu	r3,-51(fp)
81116110:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81116114:	e0bff417 	ldw	r2,-48(fp)
81116118:	10800044 	addi	r2,r2,1
8111611c:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81116120:	e0bff347 	ldb	r2,-51(fp)
81116124:	10800ed8 	cmpnei	r2,r2,59
81116128:	103feb1e 	bne	r2,zero,811160d8 <__reset+0xfb0f60d8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111612c:	e0bff417 	ldw	r2,-48(fp)
81116130:	00c00284 	movi	r3,10
81116134:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ullMaskMSB = (unsigned long)atoll( inteiroll );
81116138:	e0bff904 	addi	r2,fp,-28
8111613c:	1009883a 	mov	r4,r2
81116140:	111ab940 	call	8111ab94 <atoll>
81116144:	1009883a 	mov	r4,r2
81116148:	180b883a 	mov	r5,r3
8111614c:	2007883a 	mov	r3,r4
81116150:	00a045b4 	movhi	r2,33046
81116154:	10acbf04 	addi	r2,r2,-19716
81116158:	10c00e15 	stw	r3,56(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111615c:	e0bff704 	addi	r2,fp,-36
81116160:	e0bff415 	stw	r2,-48(fp)

						break;
81116164:	00008406 	br	81116378 <vLoadDebugConfs+0xe20>
					case 'U':

						p_inteiro = inteiroll;
81116168:	e0bff904 	addi	r2,fp,-28
8111616c:	e0bff415 	stw	r2,-48(fp)
						do {
							c = cGetNextChar(siFile);
81116170:	e0bff60f 	ldh	r2,-40(fp)
81116174:	1009883a 	mov	r4,r2
81116178:	11186d40 	call	811186d4 <cGetNextChar>
8111617c:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
81116180:	d0e00317 	ldw	r3,-32756(gp)
81116184:	e0bff347 	ldb	r2,-51(fp)
81116188:	10800044 	addi	r2,r2,1
8111618c:	1885883a 	add	r2,r3,r2
81116190:	10800003 	ldbu	r2,0(r2)
81116194:	10803fcc 	andi	r2,r2,255
81116198:	1080010c 	andi	r2,r2,4
8111619c:	10000626 	beq	r2,zero,811161b8 <vLoadDebugConfs+0xc60>
								(*p_inteiro) = c;
811161a0:	e0bff417 	ldw	r2,-48(fp)
811161a4:	e0fff343 	ldbu	r3,-51(fp)
811161a8:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
811161ac:	e0bff417 	ldw	r2,-48(fp)
811161b0:	10800044 	addi	r2,r2,1
811161b4:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
811161b8:	e0bff347 	ldb	r2,-51(fp)
811161bc:	10800ed8 	cmpnei	r2,r2,59
811161c0:	103feb1e 	bne	r2,zero,81116170 <__reset+0xfb0f6170>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811161c4:	e0bff417 	ldw	r2,-48(fp)
811161c8:	00c00284 	movi	r3,10
811161cc:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ullMaskLSB = (unsigned long)atoll( inteiroll );
811161d0:	e0bff904 	addi	r2,fp,-28
811161d4:	1009883a 	mov	r4,r2
811161d8:	111ab940 	call	8111ab94 <atoll>
811161dc:	1009883a 	mov	r4,r2
811161e0:	180b883a 	mov	r5,r3
811161e4:	2007883a 	mov	r3,r4
811161e8:	00a045b4 	movhi	r2,33046
811161ec:	10acbf04 	addi	r2,r2,-19716
811161f0:	10c00d15 	stw	r3,52(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
811161f4:	e0bff704 	addi	r2,fp,-36
811161f8:	e0bff415 	stw	r2,-48(fp)

						break;
811161fc:	00005e06 	br	81116378 <vLoadDebugConfs+0xe20>
					case 'T':

						do {
							c = cGetNextChar(siFile);
81116200:	e0bff60f 	ldh	r2,-40(fp)
81116204:	1009883a 	mov	r4,r2
81116208:	11186d40 	call	811186d4 <cGetNextChar>
8111620c:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
81116210:	d0e00317 	ldw	r3,-32756(gp)
81116214:	e0bff347 	ldb	r2,-51(fp)
81116218:	10800044 	addi	r2,r2,1
8111621c:	1885883a 	add	r2,r3,r2
81116220:	10800003 	ldbu	r2,0(r2)
81116224:	10803fcc 	andi	r2,r2,255
81116228:	1080010c 	andi	r2,r2,4
8111622c:	10000626 	beq	r2,zero,81116248 <vLoadDebugConfs+0xcf0>
								(*p_inteiro) = c;
81116230:	e0bff417 	ldw	r2,-48(fp)
81116234:	e0fff343 	ldbu	r3,-51(fp)
81116238:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
8111623c:	e0bff417 	ldw	r2,-48(fp)
81116240:	10800044 	addi	r2,r2,1
81116244:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81116248:	e0bff347 	ldb	r2,-51(fp)
8111624c:	10800ed8 	cmpnei	r2,r2,59
81116250:	103feb1e 	bne	r2,zero,81116200 <__reset+0xfb0f6200>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81116254:	e0bff417 	ldw	r2,-48(fp)
81116258:	00c00284 	movi	r3,10
8111625c:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
81116260:	e0bff704 	addi	r2,fp,-36
81116264:	1009883a 	mov	r4,r2
81116268:	111ab7c0 	call	8111ab7c <atoi>
8111626c:	e0bff68d 	sth	r2,-38(fp)
						if (sidhcpTemp == 1)
81116270:	e0bff68f 	ldh	r2,-38(fp)
81116274:	10800058 	cmpnei	r2,r2,1
81116278:	1000051e 	bne	r2,zero,81116290 <vLoadDebugConfs+0xd38>
							xDefaults.bDataPacket = TRUE;
8111627c:	00a045b4 	movhi	r2,33046
81116280:	10acbf04 	addi	r2,r2,-19716
81116284:	00c00044 	movi	r3,1
81116288:	10c00815 	stw	r3,32(r2)
8111628c:	00000306 	br	8111629c <vLoadDebugConfs+0xd44>
						else
							xDefaults.bDataPacket = FALSE;
81116290:	00a045b4 	movhi	r2,33046
81116294:	10acbf04 	addi	r2,r2,-19716
81116298:	10000815 	stw	zero,32(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
8111629c:	e0bff704 	addi	r2,fp,-36
811162a0:	e0bff415 	stw	r2,-48(fp)

						break;
811162a4:	00003406 	br	81116378 <vLoadDebugConfs+0xe20>
					case 'Z':

						do {
							c = cGetNextChar(siFile);
811162a8:	e0bff60f 	ldh	r2,-40(fp)
811162ac:	1009883a 	mov	r4,r2
811162b0:	11186d40 	call	811186d4 <cGetNextChar>
811162b4:	e0bff345 	stb	r2,-51(fp)
							if ( isdigit( c ) ) {
811162b8:	d0e00317 	ldw	r3,-32756(gp)
811162bc:	e0bff347 	ldb	r2,-51(fp)
811162c0:	10800044 	addi	r2,r2,1
811162c4:	1885883a 	add	r2,r3,r2
811162c8:	10800003 	ldbu	r2,0(r2)
811162cc:	10803fcc 	andi	r2,r2,255
811162d0:	1080010c 	andi	r2,r2,4
811162d4:	10000626 	beq	r2,zero,811162f0 <vLoadDebugConfs+0xd98>
								(*p_inteiro) = c;
811162d8:	e0bff417 	ldw	r2,-48(fp)
811162dc:	e0fff343 	ldbu	r3,-51(fp)
811162e0:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
811162e4:	e0bff417 	ldw	r2,-48(fp)
811162e8:	10800044 	addi	r2,r2,1
811162ec:	e0bff415 	stw	r2,-48(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
811162f0:	e0bff347 	ldb	r2,-51(fp)
811162f4:	10800ed8 	cmpnei	r2,r2,59
811162f8:	103feb1e 	bne	r2,zero,811162a8 <__reset+0xfb0f62a8>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811162fc:	e0bff417 	ldw	r2,-48(fp)
81116300:	00c00284 	movi	r3,10
81116304:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
81116308:	e0bff704 	addi	r2,fp,-36
8111630c:	1009883a 	mov	r4,r2
81116310:	111ab7c0 	call	8111ab7c <atoi>
81116314:	e0bff68d 	sth	r2,-38(fp)
						if (sidhcpTemp == 1)
81116318:	e0bff68f 	ldh	r2,-38(fp)
8111631c:	10800058 	cmpnei	r2,r2,1
81116320:	1000051e 	bne	r2,zero,81116338 <vLoadDebugConfs+0xde0>
							xDefaults.bMaskSD = TRUE;
81116324:	00a045b4 	movhi	r2,33046
81116328:	10acbf04 	addi	r2,r2,-19716
8111632c:	00c00044 	movi	r3,1
81116330:	10c00f15 	stw	r3,60(r2)
81116334:	00000306 	br	81116344 <vLoadDebugConfs+0xdec>
						else
							xDefaults.bMaskSD = FALSE;
81116338:	00a045b4 	movhi	r2,33046
8111633c:	10acbf04 	addi	r2,r2,-19716
81116340:	10000f15 	stw	zero,60(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81116344:	e0bff704 	addi	r2,fp,-36
81116348:	e0bff415 	stw	r2,-48(fp)

						break;
8111634c:	00000a06 	br	81116378 <vLoadDebugConfs+0xe20>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
81116350:	e0bff60f 	ldh	r2,-40(fp)
81116354:	1009883a 	mov	r4,r2
81116358:	11186940 	call	81118694 <siCloseFile>
8111635c:	e0bff515 	stw	r2,-44(fp)
							#if DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
81116360:	00800044 	movi	r2,1
81116364:	e0bff215 	stw	r2,-56(fp)
						bSuccess = TRUE; //pensar melhor
81116368:	00800044 	movi	r2,1
8111636c:	e0bff115 	stw	r2,-60(fp)
						break;
81116370:	00000106 	br	81116378 <vLoadDebugConfs+0xe20>
					default:
						#if DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
81116374:	0001883a 	nop
				}
			} while ( bEOF == FALSE );
81116378:	e0bff217 	ldw	r2,-56(fp)
8111637c:	103c9926 	beq	r2,zero,811155e4 <__reset+0xfb0f55e4>
		#if DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
81116380:	e0bff117 	ldw	r2,-60(fp)
81116384:	1000391e 	bne	r2,zero,8111646c <vLoadDebugConfs+0xf14>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Debug Configs: Could not load the default values from SDCard\n");
81116388:	01204534 	movhi	r4,33044
8111638c:	2112f304 	addi	r4,r4,19404
81116390:	111af680 	call	8111af68 <puts>
		printf("Can't find the file:'%s'.\n", ETH_FILE_NAME);
81116394:	01604534 	movhi	r5,33044
81116398:	2952d404 	addi	r5,r5,19280
8111639c:	01204534 	movhi	r4,33044
811163a0:	21130304 	addi	r4,r4,19468
811163a4:	111ae5c0 	call	8111ae5c <printf>



		xDefaults.usiRows = 4510;
811163a8:	00a045b4 	movhi	r2,33046
811163ac:	10acbf04 	addi	r2,r2,-19716
811163b0:	00c46784 	movi	r3,4510
811163b4:	10c0060d 	sth	r3,24(r2)
		xDefaults.usiCols = 2255;
811163b8:	00a045b4 	movhi	r2,33046
811163bc:	10acbf04 	addi	r2,r2,-19716
811163c0:	00c233c4 	movi	r3,2255
811163c4:	10c0058d 	sth	r3,22(r2)
		xDefaults.usiOLN = 30;
811163c8:	00a045b4 	movhi	r2,33046
811163cc:	10acbf04 	addi	r2,r2,-19716
811163d0:	00c00784 	movi	r3,30
811163d4:	10c0050d 	sth	r3,20(r2)
		xDefaults.usiPreScanSerial = 25;
811163d8:	00a045b4 	movhi	r2,33046
811163dc:	10acbf04 	addi	r2,r2,-19716
811163e0:	00c00644 	movi	r3,25
811163e4:	10c0048d 	sth	r3,18(r2)
		xDefaults.usiOverScanSerial = 15;
811163e8:	00a045b4 	movhi	r2,33046
811163ec:	10acbf04 	addi	r2,r2,-19716
811163f0:	00c003c4 	movi	r3,15
811163f4:	10c0040d 	sth	r3,16(r2)
		xDefaults.usiSyncPeriod = 6250;
811163f8:	00a045b4 	movhi	r2,33046
811163fc:	10acbf04 	addi	r2,r2,-19716
81116400:	00c61a84 	movi	r3,6250
81116404:	10c0068d 	sth	r3,26(r2)
		xDefaults.usiDelay = 20;
81116408:	00a045b4 	movhi	r2,33046
8111640c:	10acbf04 	addi	r2,r2,-19716
81116410:	00c00504 	movi	r3,20
81116414:	10c0070d 	sth	r3,28(r2)
		xDefaults.bDataPacket = TRUE;
81116418:	00a045b4 	movhi	r2,33046
8111641c:	10acbf04 	addi	r2,r2,-19716
81116420:	00c00044 	movi	r3,1
81116424:	10c00815 	stw	r3,32(r2)
		xDefaults.ulLineDelay = 0;
81116428:	00a045b4 	movhi	r2,33046
8111642c:	10acbf04 	addi	r2,r2,-19716
81116430:	10000915 	stw	zero,36(r2)
		xDefaults.ulColDelay = 0;
81116434:	00a045b4 	movhi	r2,33046
81116438:	10acbf04 	addi	r2,r2,-19716
8111643c:	10000a15 	stw	zero,40(r2)
		xDefaults.ulADCPixelDelay = 0;
81116440:	00a045b4 	movhi	r2,33046
81116444:	10acbf04 	addi	r2,r2,-19716
81116448:	10000b15 	stw	zero,44(r2)
		xDefaults.ucLogicalAddr = 0x51;
8111644c:	00a045b4 	movhi	r2,33046
81116450:	10acbf04 	addi	r2,r2,-19716
81116454:	00c01444 	movi	r3,81
81116458:	10c00c8d 	sth	r3,50(r2)
		xDefaults.ucRmapKey = 0xD1;
8111645c:	00a045b4 	movhi	r2,33046
81116460:	10acbf04 	addi	r2,r2,-19716
81116464:	00c03444 	movi	r3,209
81116468:	10c00c0d 	sth	r3,48(r2)

	}

	return bSuccess;
8111646c:	e0bff117 	ldw	r2,-60(fp)
}
81116470:	e6ffff04 	addi	sp,fp,-4
81116474:	dfc00217 	ldw	ra,8(sp)
81116478:	df000117 	ldw	fp,4(sp)
8111647c:	dc000017 	ldw	r16,0(sp)
81116480:	dec00304 	addi	sp,sp,12
81116484:	f800283a 	ret

81116488 <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
81116488:	defffb04 	addi	sp,sp,-20
8111648c:	de00012e 	bgeu	sp,et,81116494 <ucCrc8+0xc>
81116490:	003b68fa 	trap	3
81116494:	df000415 	stw	fp,16(sp)
81116498:	df000404 	addi	fp,sp,16
8111649c:	e13ffd15 	stw	r4,-12(fp)
811164a0:	e17ffe15 	stw	r5,-8(fp)
811164a4:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
811164a8:	e0bffe17 	ldw	r2,-8(fp)
811164ac:	1000021e 	bne	r2,zero,811164b8 <ucCrc8+0x30>
        return 0;
811164b0:	0005883a 	mov	r2,zero
811164b4:	00001906 	br	8111651c <ucCrc8+0x94>
    crc &= 0xff;
811164b8:	e0bffd17 	ldw	r2,-12(fp)
811164bc:	10803fcc 	andi	r2,r2,255
811164c0:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
811164c4:	e0fffe17 	ldw	r3,-8(fp)
811164c8:	e0bfff17 	ldw	r2,-4(fp)
811164cc:	1885883a 	add	r2,r3,r2
811164d0:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
811164d4:	00000d06 	br	8111650c <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
811164d8:	e0bffe17 	ldw	r2,-8(fp)
811164dc:	10c00044 	addi	r3,r2,1
811164e0:	e0fffe15 	stw	r3,-8(fp)
811164e4:	10800003 	ldbu	r2,0(r2)
811164e8:	10c03fcc 	andi	r3,r2,255
811164ec:	e0bffd17 	ldw	r2,-12(fp)
811164f0:	1886f03a 	xor	r3,r3,r2
811164f4:	00a04534 	movhi	r2,33044
811164f8:	109309c4 	addi	r2,r2,19495
811164fc:	10c5883a 	add	r2,r2,r3
81116500:	10800003 	ldbu	r2,0(r2)
81116504:	10803fcc 	andi	r2,r2,255
81116508:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
8111650c:	e0fffe17 	ldw	r3,-8(fp)
81116510:	e0bffc17 	ldw	r2,-16(fp)
81116514:	18bff036 	bltu	r3,r2,811164d8 <__reset+0xfb0f64d8>
        crc = crc8_table[crc ^ *data++];
    return crc;
81116518:	e0bffd17 	ldw	r2,-12(fp)
}
8111651c:	e037883a 	mov	sp,fp
81116520:	df000017 	ldw	fp,0(sp)
81116524:	dec00104 	addi	sp,sp,4
81116528:	f800283a 	ret

8111652c <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
8111652c:	defffb04 	addi	sp,sp,-20
81116530:	de00012e 	bgeu	sp,et,81116538 <ucCrc8wInit+0xc>
81116534:	003b68fa 	trap	3
81116538:	dfc00415 	stw	ra,16(sp)
8111653c:	df000315 	stw	fp,12(sp)
81116540:	df000304 	addi	fp,sp,12
81116544:	e13ffe15 	stw	r4,-8(fp)
81116548:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
8111654c:	000d883a 	mov	r6,zero
81116550:	000b883a 	mov	r5,zero
81116554:	0009883a 	mov	r4,zero
81116558:	11164880 	call	81116488 <ucCrc8>
8111655c:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
81116560:	e0bffd03 	ldbu	r2,-12(fp)
81116564:	e1bfff17 	ldw	r6,-4(fp)
81116568:	e17ffe17 	ldw	r5,-8(fp)
8111656c:	1009883a 	mov	r4,r2
81116570:	11164880 	call	81116488 <ucCrc8>
}
81116574:	e037883a 	mov	sp,fp
81116578:	dfc00117 	ldw	ra,4(sp)
8111657c:	df000017 	ldw	fp,0(sp)
81116580:	dec00204 	addi	sp,sp,8
81116584:	f800283a 	ret

81116588 <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
81116588:	defffc04 	addi	sp,sp,-16
8111658c:	de00012e 	bgeu	sp,et,81116594 <vDataControllerInit+0xc>
81116590:	003b68fa 	trap	3
81116594:	df000315 	stw	fp,12(sp)
81116598:	df000304 	addi	fp,sp,12
8111659c:	e13ffe15 	stw	r4,-8(fp)
811165a0:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;
811165a4:	e0bffe17 	ldw	r2,-8(fp)
811165a8:	10000615 	stw	zero,24(r2)

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
811165ac:	e03ffd05 	stb	zero,-12(fp)
811165b0:	00001c06 	br	81116624 <vDataControllerInit+0x9c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
811165b4:	e0bffd03 	ldbu	r2,-12(fp)
811165b8:	e0fffd03 	ldbu	r3,-12(fp)
811165bc:	18c09624 	muli	r3,r3,600
811165c0:	e13fff17 	ldw	r4,-4(fp)
811165c4:	20c7883a 	add	r3,r4,r3
811165c8:	e13ffe17 	ldw	r4,-8(fp)
811165cc:	10800084 	addi	r2,r2,2
811165d0:	1085883a 	add	r2,r2,r2
811165d4:	1085883a 	add	r2,r2,r2
811165d8:	2085883a 	add	r2,r4,r2
811165dc:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
811165e0:	e17ffd03 	ldbu	r5,-12(fp)
811165e4:	e0bffd03 	ldbu	r2,-12(fp)
811165e8:	e0ffff17 	ldw	r3,-4(fp)
811165ec:	108025c4 	addi	r2,r2,151
811165f0:	1085883a 	add	r2,r2,r2
811165f4:	1085883a 	add	r2,r2,r2
811165f8:	1885883a 	add	r2,r3,r2
811165fc:	10c00017 	ldw	r3,0(r2)
81116600:	e13ffe17 	ldw	r4,-8(fp)
81116604:	288000c4 	addi	r2,r5,3
81116608:	1085883a 	add	r2,r2,r2
8111660c:	1085883a 	add	r2,r2,r2
81116610:	2085883a 	add	r2,r4,r2
81116614:	10c00015 	stw	r3,0(r2)
void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
81116618:	e0bffd03 	ldbu	r2,-12(fp)
8111661c:	10800044 	addi	r2,r2,1
81116620:	e0bffd05 	stb	r2,-12(fp)
81116624:	e0bffd03 	ldbu	r2,-12(fp)
81116628:	103fe226 	beq	r2,zero,811165b4 <__reset+0xfb0f65b4>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
8111662c:	e0bfff17 	ldw	r2,-4(fp)
81116630:	10c09904 	addi	r3,r2,612
81116634:	e0bffe17 	ldw	r2,-8(fp)
81116638:	10c00415 	stw	r3,16(r2)
	xDataControlL->bUpdateComplete = FALSE;
8111663c:	e0bffe17 	ldw	r2,-8(fp)
81116640:	10000515 	stw	zero,20(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
81116644:	e0bffe17 	ldw	r2,-8(fp)
81116648:	10c00504 	addi	r3,r2,20
8111664c:	e0bfff17 	ldw	r2,-4(fp)
81116650:	10c09b15 	stw	r3,620(r2)
}
81116654:	0001883a 	nop
81116658:	e037883a 	mov	sp,fp
8111665c:	df000017 	ldw	fp,0(sp)
81116660:	dec00104 	addi	sp,sp,4
81116664:	f800283a 	ret

81116668 <vFailCreateMutexSResources>:
		debug(fp, buffer);
	}
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
81116668:	defffe04 	addi	sp,sp,-8
8111666c:	de00012e 	bgeu	sp,et,81116674 <vFailCreateMutexSResources+0xc>
81116670:	003b68fa 	trap	3
81116674:	df000115 	stw	fp,4(sp)
81116678:	df000104 	addi	fp,sp,4
8111667c:	2005883a 	mov	r2,r4
81116680:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116684:	0001883a 	nop
81116688:	e037883a 	mov	sp,fp
8111668c:	df000017 	ldw	fp,0(sp)
81116690:	dec00104 	addi	sp,sp,4
81116694:	f800283a 	ret

81116698 <vFailCreateMutexDMA>:

void vFailCreateMutexDMA( void )
{
81116698:	deffff04 	addi	sp,sp,-4
8111669c:	de00012e 	bgeu	sp,et,811166a4 <vFailCreateMutexDMA+0xc>
811166a0:	003b68fa 	trap	3
811166a4:	df000015 	stw	fp,0(sp)
811166a8:	d839883a 	mov	fp,sp

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811166ac:	0001883a 	nop
811166b0:	e037883a 	mov	sp,fp
811166b4:	df000017 	ldw	fp,0(sp)
811166b8:	dec00104 	addi	sp,sp,4
811166bc:	f800283a 	ret

811166c0 <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
811166c0:	deffff04 	addi	sp,sp,-4
811166c4:	de00012e 	bgeu	sp,et,811166cc <vFailCreateSemaphoreResources+0xc>
811166c8:	003b68fa 	trap	3
811166cc:	df000015 	stw	fp,0(sp)
811166d0:	d839883a 	mov	fp,sp

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811166d4:	0001883a 	nop
811166d8:	e037883a 	mov	sp,fp
811166dc:	df000017 	ldw	fp,0(sp)
811166e0:	dec00104 	addi	sp,sp,4
811166e4:	f800283a 	ret

811166e8 <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
811166e8:	deffff04 	addi	sp,sp,-4
811166ec:	de00012e 	bgeu	sp,et,811166f4 <vFailTestCriticasParts+0xc>
811166f0:	003b68fa 	trap	3
811166f4:	df000015 	stw	fp,0(sp)
811166f8:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811166fc:	0001883a 	nop
81116700:	e037883a 	mov	sp,fp
81116704:	df000017 	ldw	fp,0(sp)
81116708:	dec00104 	addi	sp,sp,4
8111670c:	f800283a 	ret

81116710 <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
81116710:	deffff04 	addi	sp,sp,-4
81116714:	de00012e 	bgeu	sp,et,8111671c <vFailSendxSemCommInit+0xc>
81116718:	003b68fa 	trap	3
8111671c:	df000015 	stw	fp,0(sp)
81116720:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116724:	0001883a 	nop
81116728:	e037883a 	mov	sp,fp
8111672c:	df000017 	ldw	fp,0(sp)
81116730:	dec00104 	addi	sp,sp,4
81116734:	f800283a 	ret

81116738 <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
81116738:	deffff04 	addi	sp,sp,-4
8111673c:	de00012e 	bgeu	sp,et,81116744 <vFailSendPreParsedSemaphore+0xc>
81116740:	003b68fa 	trap	3
81116744:	df000015 	stw	fp,0(sp)
81116748:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111674c:	0001883a 	nop
81116750:	e037883a 	mov	sp,fp
81116754:	df000017 	ldw	fp,0(sp)
81116758:	dec00104 	addi	sp,sp,4
8111675c:	f800283a 	ret

81116760 <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
81116760:	deffff04 	addi	sp,sp,-4
81116764:	de00012e 	bgeu	sp,et,8111676c <vFailSendPreAckReceiverSemaphore+0xc>
81116768:	003b68fa 	trap	3
8111676c:	df000015 	stw	fp,0(sp)
81116770:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116774:	0001883a 	nop
81116778:	e037883a 	mov	sp,fp
8111677c:	df000017 	ldw	fp,0(sp)
81116780:	dec00104 	addi	sp,sp,4
81116784:	f800283a 	ret

81116788 <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
81116788:	deffff04 	addi	sp,sp,-4
8111678c:	de00012e 	bgeu	sp,et,81116794 <vFailSendPreAckSenderSemaphore+0xc>
81116790:	003b68fa 	trap	3
81116794:	df000015 	stw	fp,0(sp)
81116798:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111679c:	0001883a 	nop
811167a0:	e037883a 	mov	sp,fp
811167a4:	df000017 	ldw	fp,0(sp)
811167a8:	dec00104 	addi	sp,sp,4
811167ac:	f800283a 	ret

811167b0 <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
811167b0:	deffff04 	addi	sp,sp,-4
811167b4:	de00012e 	bgeu	sp,et,811167bc <vFailGetCountSemaphoreSenderTask+0xc>
811167b8:	003b68fa 	trap	3
811167bc:	df000015 	stw	fp,0(sp)
811167c0:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811167c4:	0001883a 	nop
811167c8:	e037883a 	mov	sp,fp
811167cc:	df000017 	ldw	fp,0(sp)
811167d0:	dec00104 	addi	sp,sp,4
811167d4:	f800283a 	ret

811167d8 <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
811167d8:	deffff04 	addi	sp,sp,-4
811167dc:	de00012e 	bgeu	sp,et,811167e4 <vFailGetMutexSenderTask+0xc>
811167e0:	003b68fa 	trap	3
811167e4:	df000015 	stw	fp,0(sp)
811167e8:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811167ec:	0001883a 	nop
811167f0:	e037883a 	mov	sp,fp
811167f4:	df000017 	ldw	fp,0(sp)
811167f8:	dec00104 	addi	sp,sp,4
811167fc:	f800283a 	ret

81116800 <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
81116800:	deffff04 	addi	sp,sp,-4
81116804:	de00012e 	bgeu	sp,et,8111680c <vFailGetCountSemaphoreReceiverTask+0xc>
81116808:	003b68fa 	trap	3
8111680c:	df000015 	stw	fp,0(sp)
81116810:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116814:	0001883a 	nop
81116818:	e037883a 	mov	sp,fp
8111681c:	df000017 	ldw	fp,0(sp)
81116820:	dec00104 	addi	sp,sp,4
81116824:	f800283a 	ret

81116828 <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
81116828:	deffff04 	addi	sp,sp,-4
8111682c:	de00012e 	bgeu	sp,et,81116834 <vFailGetMutexReceiverTask+0xc>
81116830:	003b68fa 	trap	3
81116834:	df000015 	stw	fp,0(sp)
81116838:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111683c:	0001883a 	nop
81116840:	e037883a 	mov	sp,fp
81116844:	df000017 	ldw	fp,0(sp)
81116848:	dec00104 	addi	sp,sp,4
8111684c:	f800283a 	ret

81116850 <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
81116850:	deffff04 	addi	sp,sp,-4
81116854:	de00012e 	bgeu	sp,et,8111685c <vFailGetMutexTxUARTSenderTask+0xc>
81116858:	003b68fa 	trap	3
8111685c:	df000015 	stw	fp,0(sp)
81116860:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116864:	0001883a 	nop
81116868:	e037883a 	mov	sp,fp
8111686c:	df000017 	ldw	fp,0(sp)
81116870:	dec00104 	addi	sp,sp,4
81116874:	f800283a 	ret

81116878 <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
81116878:	deffff04 	addi	sp,sp,-4
8111687c:	de00012e 	bgeu	sp,et,81116884 <vFailGetMacRTC+0xc>
81116880:	003b68fa 	trap	3
81116884:	df000015 	stw	fp,0(sp)
81116888:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111688c:	0001883a 	nop
81116890:	e037883a 	mov	sp,fp
81116894:	df000017 	ldw	fp,0(sp)
81116898:	dec00104 	addi	sp,sp,4
8111689c:	f800283a 	ret

811168a0 <vFailInitialization>:


void vFailInitialization( void )
{
811168a0:	deffff04 	addi	sp,sp,-4
811168a4:	de00012e 	bgeu	sp,et,811168ac <vFailInitialization+0xc>
811168a8:	003b68fa 	trap	3
811168ac:	df000015 	stw	fp,0(sp)
811168b0:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811168b4:	0001883a 	nop
811168b8:	e037883a 	mov	sp,fp
811168bc:	df000017 	ldw	fp,0(sp)
811168c0:	dec00104 	addi	sp,sp,4
811168c4:	f800283a 	ret

811168c8 <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
811168c8:	deffff04 	addi	sp,sp,-4
811168cc:	de00012e 	bgeu	sp,et,811168d4 <vFailReceiverCreate+0xc>
811168d0:	003b68fa 	trap	3
811168d4:	df000015 	stw	fp,0(sp)
811168d8:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811168dc:	0001883a 	nop
811168e0:	e037883a 	mov	sp,fp
811168e4:	df000017 	ldw	fp,0(sp)
811168e8:	dec00104 	addi	sp,sp,4
811168ec:	f800283a 	ret

811168f0 <vFailSenderCreate>:


void vFailSenderCreate( void )
{
811168f0:	deffff04 	addi	sp,sp,-4
811168f4:	de00012e 	bgeu	sp,et,811168fc <vFailSenderCreate+0xc>
811168f8:	003b68fa 	trap	3
811168fc:	df000015 	stw	fp,0(sp)
81116900:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116904:	0001883a 	nop
81116908:	e037883a 	mov	sp,fp
8111690c:	df000017 	ldw	fp,0(sp)
81116910:	dec00104 	addi	sp,sp,4
81116914:	f800283a 	ret

81116918 <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
81116918:	deffff04 	addi	sp,sp,-4
8111691c:	de00012e 	bgeu	sp,et,81116924 <vFailDeleteInitialization+0xc>
81116920:	003b68fa 	trap	3
81116924:	df000015 	stw	fp,0(sp)
81116928:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111692c:	0001883a 	nop
81116930:	e037883a 	mov	sp,fp
81116934:	df000017 	ldw	fp,0(sp)
81116938:	dec00104 	addi	sp,sp,4
8111693c:	f800283a 	ret

81116940 <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
81116940:	deffff04 	addi	sp,sp,-4
81116944:	de00012e 	bgeu	sp,et,8111694c <vFailSetCountSemaphorexBuffer32+0xc>
81116948:	003b68fa 	trap	3
8111694c:	df000015 	stw	fp,0(sp)
81116950:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116954:	0001883a 	nop
81116958:	e037883a 	mov	sp,fp
8111695c:	df000017 	ldw	fp,0(sp)
81116960:	dec00104 	addi	sp,sp,4
81116964:	f800283a 	ret

81116968 <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
81116968:	deffff04 	addi	sp,sp,-4
8111696c:	de00012e 	bgeu	sp,et,81116974 <vFailSetCountSemaphorexBuffer64+0xc>
81116970:	003b68fa 	trap	3
81116974:	df000015 	stw	fp,0(sp)
81116978:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111697c:	0001883a 	nop
81116980:	e037883a 	mov	sp,fp
81116984:	df000017 	ldw	fp,0(sp)
81116988:	dec00104 	addi	sp,sp,4
8111698c:	f800283a 	ret

81116990 <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
81116990:	deffff04 	addi	sp,sp,-4
81116994:	de00012e 	bgeu	sp,et,8111699c <vFailSetCountSemaphorexBuffer128+0xc>
81116998:	003b68fa 	trap	3
8111699c:	df000015 	stw	fp,0(sp)
811169a0:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811169a4:	0001883a 	nop
811169a8:	e037883a 	mov	sp,fp
811169ac:	df000017 	ldw	fp,0(sp)
811169b0:	dec00104 	addi	sp,sp,4
811169b4:	f800283a 	ret

811169b8 <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
811169b8:	deffff04 	addi	sp,sp,-4
811169bc:	de00012e 	bgeu	sp,et,811169c4 <vFailGetCountSemaphorexBuffer128+0xc>
811169c0:	003b68fa 	trap	3
811169c4:	df000015 	stw	fp,0(sp)
811169c8:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811169cc:	0001883a 	nop
811169d0:	e037883a 	mov	sp,fp
811169d4:	df000017 	ldw	fp,0(sp)
811169d8:	dec00104 	addi	sp,sp,4
811169dc:	f800283a 	ret

811169e0 <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
811169e0:	deffff04 	addi	sp,sp,-4
811169e4:	de00012e 	bgeu	sp,et,811169ec <vFailGetCountSemaphorexBuffer64+0xc>
811169e8:	003b68fa 	trap	3
811169ec:	df000015 	stw	fp,0(sp)
811169f0:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811169f4:	0001883a 	nop
811169f8:	e037883a 	mov	sp,fp
811169fc:	df000017 	ldw	fp,0(sp)
81116a00:	dec00104 	addi	sp,sp,4
81116a04:	f800283a 	ret

81116a08 <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
81116a08:	deffff04 	addi	sp,sp,-4
81116a0c:	de00012e 	bgeu	sp,et,81116a14 <vFailGetCountSemaphorexBuffer32+0xc>
81116a10:	003b68fa 	trap	3
81116a14:	df000015 	stw	fp,0(sp)
81116a18:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116a1c:	0001883a 	nop
81116a20:	e037883a 	mov	sp,fp
81116a24:	df000017 	ldw	fp,0(sp)
81116a28:	dec00104 	addi	sp,sp,4
81116a2c:	f800283a 	ret

81116a30 <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
81116a30:	deffff04 	addi	sp,sp,-4
81116a34:	de00012e 	bgeu	sp,et,81116a3c <vFailFoundBufferRetransmission+0xc>
81116a38:	003b68fa 	trap	3
81116a3c:	df000015 	stw	fp,0(sp)
81116a40:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116a44:	0001883a 	nop
81116a48:	e037883a 	mov	sp,fp
81116a4c:	df000017 	ldw	fp,0(sp)
81116a50:	dec00104 	addi	sp,sp,4
81116a54:	f800283a 	ret

81116a58 <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
81116a58:	deffff04 	addi	sp,sp,-4
81116a5c:	de00012e 	bgeu	sp,et,81116a64 <vFailGetCountSemaphorePreParsedBuffer+0xc>
81116a60:	003b68fa 	trap	3
81116a64:	df000015 	stw	fp,0(sp)
81116a68:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116a6c:	0001883a 	nop
81116a70:	e037883a 	mov	sp,fp
81116a74:	df000017 	ldw	fp,0(sp)
81116a78:	dec00104 	addi	sp,sp,4
81116a7c:	f800283a 	ret

81116a80 <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
81116a80:	deffff04 	addi	sp,sp,-4
81116a84:	de00012e 	bgeu	sp,et,81116a8c <vFailGetxMutexPreParsedParserRxTask+0xc>
81116a88:	003b68fa 	trap	3
81116a8c:	df000015 	stw	fp,0(sp)
81116a90:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116a94:	0001883a 	nop
81116a98:	e037883a 	mov	sp,fp
81116a9c:	df000017 	ldw	fp,0(sp)
81116aa0:	dec00104 	addi	sp,sp,4
81116aa4:	f800283a 	ret

81116aa8 <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
81116aa8:	deffff04 	addi	sp,sp,-4
81116aac:	de00012e 	bgeu	sp,et,81116ab4 <vNoContentInPreParsedBuffer+0xc>
81116ab0:	003b68fa 	trap	3
81116ab4:	df000015 	stw	fp,0(sp)
81116ab8:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116abc:	0001883a 	nop
81116ac0:	e037883a 	mov	sp,fp
81116ac4:	df000017 	ldw	fp,0(sp)
81116ac8:	dec00104 	addi	sp,sp,4
81116acc:	f800283a 	ret

81116ad0 <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
81116ad0:	deffff04 	addi	sp,sp,-4
81116ad4:	de00012e 	bgeu	sp,et,81116adc <vCouldNotSendEthConfUART+0xc>
81116ad8:	003b68fa 	trap	3
81116adc:	df000015 	stw	fp,0(sp)
81116ae0:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116ae4:	0001883a 	nop
81116ae8:	e037883a 	mov	sp,fp
81116aec:	df000017 	ldw	fp,0(sp)
81116af0:	dec00104 	addi	sp,sp,4
81116af4:	f800283a 	ret

81116af8 <vFailSendNack>:

void vFailSendNack( void )
{
81116af8:	deffff04 	addi	sp,sp,-4
81116afc:	de00012e 	bgeu	sp,et,81116b04 <vFailSendNack+0xc>
81116b00:	003b68fa 	trap	3
81116b04:	df000015 	stw	fp,0(sp)
81116b08:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116b0c:	0001883a 	nop
81116b10:	e037883a 	mov	sp,fp
81116b14:	df000017 	ldw	fp,0(sp)
81116b18:	dec00104 	addi	sp,sp,4
81116b1c:	f800283a 	ret

81116b20 <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
81116b20:	deffff04 	addi	sp,sp,-4
81116b24:	de00012e 	bgeu	sp,et,81116b2c <vFailSetPreAckSenderBuffer+0xc>
81116b28:	003b68fa 	trap	3
81116b2c:	df000015 	stw	fp,0(sp)
81116b30:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116b34:	0001883a 	nop
81116b38:	e037883a 	mov	sp,fp
81116b3c:	df000017 	ldw	fp,0(sp)
81116b40:	dec00104 	addi	sp,sp,4
81116b44:	f800283a 	ret

81116b48 <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
81116b48:	deffff04 	addi	sp,sp,-4
81116b4c:	de00012e 	bgeu	sp,et,81116b54 <vFailSetPreParsedBuffer+0xc>
81116b50:	003b68fa 	trap	3
81116b54:	df000015 	stw	fp,0(sp)
81116b58:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116b5c:	0001883a 	nop
81116b60:	e037883a 	mov	sp,fp
81116b64:	df000017 	ldw	fp,0(sp)
81116b68:	dec00104 	addi	sp,sp,4
81116b6c:	f800283a 	ret

81116b70 <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
81116b70:	deffff04 	addi	sp,sp,-4
81116b74:	de00012e 	bgeu	sp,et,81116b7c <vFailSetPreAckReceiverBuffer+0xc>
81116b78:	003b68fa 	trap	3
81116b7c:	df000015 	stw	fp,0(sp)
81116b80:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116b84:	0001883a 	nop
81116b88:	e037883a 	mov	sp,fp
81116b8c:	df000017 	ldw	fp,0(sp)
81116b90:	dec00104 	addi	sp,sp,4
81116b94:	f800283a 	ret

81116b98 <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
81116b98:	deffff04 	addi	sp,sp,-4
81116b9c:	de00012e 	bgeu	sp,et,81116ba4 <vFailParserCommTaskCreate+0xc>
81116ba0:	003b68fa 	trap	3
81116ba4:	df000015 	stw	fp,0(sp)
81116ba8:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116bac:	0001883a 	nop
81116bb0:	e037883a 	mov	sp,fp
81116bb4:	df000017 	ldw	fp,0(sp)
81116bb8:	dec00104 	addi	sp,sp,4
81116bbc:	f800283a 	ret

81116bc0 <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
81116bc0:	deffff04 	addi	sp,sp,-4
81116bc4:	de00012e 	bgeu	sp,et,81116bcc <vFailInAckHandlerTaskCreate+0xc>
81116bc8:	003b68fa 	trap	3
81116bcc:	df000015 	stw	fp,0(sp)
81116bd0:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116bd4:	0001883a 	nop
81116bd8:	e037883a 	mov	sp,fp
81116bdc:	df000017 	ldw	fp,0(sp)
81116be0:	dec00104 	addi	sp,sp,4
81116be4:	f800283a 	ret

81116be8 <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
81116be8:	deffff04 	addi	sp,sp,-4
81116bec:	de00012e 	bgeu	sp,et,81116bf4 <vFailOutAckHandlerTaskCreate+0xc>
81116bf0:	003b68fa 	trap	3
81116bf4:	df000015 	stw	fp,0(sp)
81116bf8:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116bfc:	0001883a 	nop
81116c00:	e037883a 	mov	sp,fp
81116c04:	df000017 	ldw	fp,0(sp)
81116c08:	dec00104 	addi	sp,sp,4
81116c0c:	f800283a 	ret

81116c10 <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
81116c10:	deffff04 	addi	sp,sp,-4
81116c14:	de00012e 	bgeu	sp,et,81116c1c <vFailCreateTimerRetransmisison+0xc>
81116c18:	003b68fa 	trap	3
81116c1c:	df000015 	stw	fp,0(sp)
81116c20:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116c24:	0001883a 	nop
81116c28:	e037883a 	mov	sp,fp
81116c2c:	df000017 	ldw	fp,0(sp)
81116c30:	dec00104 	addi	sp,sp,4
81116c34:	f800283a 	ret

81116c38 <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
81116c38:	deffff04 	addi	sp,sp,-4
81116c3c:	de00012e 	bgeu	sp,et,81116c44 <vCouldNotCheckBufferTimeOutFunction+0xc>
81116c40:	003b68fa 	trap	3
81116c44:	df000015 	stw	fp,0(sp)
81116c48:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116c4c:	0001883a 	nop
81116c50:	e037883a 	mov	sp,fp
81116c54:	df000017 	ldw	fp,0(sp)
81116c58:	dec00104 	addi	sp,sp,4
81116c5c:	f800283a 	ret

81116c60 <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
81116c60:	deffff04 	addi	sp,sp,-4
81116c64:	de00012e 	bgeu	sp,et,81116c6c <vFailTimeoutCheckerTaskCreate+0xc>
81116c68:	003b68fa 	trap	3
81116c6c:	df000015 	stw	fp,0(sp)
81116c70:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116c74:	0001883a 	nop
81116c78:	e037883a 	mov	sp,fp
81116c7c:	df000017 	ldw	fp,0(sp)
81116c80:	dec00104 	addi	sp,sp,4
81116c84:	f800283a 	ret

81116c88 <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
81116c88:	deffff04 	addi	sp,sp,-4
81116c8c:	de00012e 	bgeu	sp,et,81116c94 <vFailGetBlockingSemTimeoutTask+0xc>
81116c90:	003b68fa 	trap	3
81116c94:	df000015 	stw	fp,0(sp)
81116c98:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116c9c:	0001883a 	nop
81116ca0:	e037883a 	mov	sp,fp
81116ca4:	df000017 	ldw	fp,0(sp)
81116ca8:	dec00104 	addi	sp,sp,4
81116cac:	f800283a 	ret

81116cb0 <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
81116cb0:	deffff04 	addi	sp,sp,-4
81116cb4:	de00012e 	bgeu	sp,et,81116cbc <vFailPostBlockingSemTimeoutTask+0xc>
81116cb8:	003b68fa 	trap	3
81116cbc:	df000015 	stw	fp,0(sp)
81116cc0:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116cc4:	0001883a 	nop
81116cc8:	e037883a 	mov	sp,fp
81116ccc:	df000017 	ldw	fp,0(sp)
81116cd0:	dec00104 	addi	sp,sp,4
81116cd4:	f800283a 	ret

81116cd8 <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
81116cd8:	deffff04 	addi	sp,sp,-4
81116cdc:	de00012e 	bgeu	sp,et,81116ce4 <vFailCouldNotRetransmitTimeoutTask+0xc>
81116ce0:	003b68fa 	trap	3
81116ce4:	df000015 	stw	fp,0(sp)
81116ce8:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116cec:	0001883a 	nop
81116cf0:	e037883a 	mov	sp,fp
81116cf4:	df000017 	ldw	fp,0(sp)
81116cf8:	dec00104 	addi	sp,sp,4
81116cfc:	f800283a 	ret

81116d00 <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
81116d00:	deffff04 	addi	sp,sp,-4
81116d04:	de00012e 	bgeu	sp,et,81116d0c <vCouldNotRetransmitB32TimeoutTask+0xc>
81116d08:	003b68fa 	trap	3
81116d0c:	df000015 	stw	fp,0(sp)
81116d10:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116d14:	0001883a 	nop
81116d18:	e037883a 	mov	sp,fp
81116d1c:	df000017 	ldw	fp,0(sp)
81116d20:	dec00104 	addi	sp,sp,4
81116d24:	f800283a 	ret

81116d28 <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
81116d28:	deffff04 	addi	sp,sp,-4
81116d2c:	de00012e 	bgeu	sp,et,81116d34 <vCouldNotRetransmitB64TimeoutTask+0xc>
81116d30:	003b68fa 	trap	3
81116d34:	df000015 	stw	fp,0(sp)
81116d38:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116d3c:	0001883a 	nop
81116d40:	e037883a 	mov	sp,fp
81116d44:	df000017 	ldw	fp,0(sp)
81116d48:	dec00104 	addi	sp,sp,4
81116d4c:	f800283a 	ret

81116d50 <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
81116d50:	deffff04 	addi	sp,sp,-4
81116d54:	de00012e 	bgeu	sp,et,81116d5c <vCouldNotRetransmitB128TimeoutTask+0xc>
81116d58:	003b68fa 	trap	3
81116d5c:	df000015 	stw	fp,0(sp)
81116d60:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116d64:	0001883a 	nop
81116d68:	e037883a 	mov	sp,fp
81116d6c:	df000017 	ldw	fp,0(sp)
81116d70:	dec00104 	addi	sp,sp,4
81116d74:	f800283a 	ret

81116d78 <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
81116d78:	deffff04 	addi	sp,sp,-4
81116d7c:	de00012e 	bgeu	sp,et,81116d84 <vFailStartTimerRetransmission+0xc>
81116d80:	003b68fa 	trap	3
81116d84:	df000015 	stw	fp,0(sp)
81116d88:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116d8c:	0001883a 	nop
81116d90:	e037883a 	mov	sp,fp
81116d94:	df000017 	ldw	fp,0(sp)
81116d98:	dec00104 	addi	sp,sp,4
81116d9c:	f800283a 	ret

81116da0 <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
81116da0:	deffff04 	addi	sp,sp,-4
81116da4:	de00012e 	bgeu	sp,et,81116dac <vCouldNotSendTurnOff+0xc>
81116da8:	003b68fa 	trap	3
81116dac:	df000015 	stw	fp,0(sp)
81116db0:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116db4:	0001883a 	nop
81116db8:	e037883a 	mov	sp,fp
81116dbc:	df000017 	ldw	fp,0(sp)
81116dc0:	dec00104 	addi	sp,sp,4
81116dc4:	f800283a 	ret

81116dc8 <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
81116dc8:	deffff04 	addi	sp,sp,-4
81116dcc:	de00012e 	bgeu	sp,et,81116dd4 <vCouldNotSendReset+0xc>
81116dd0:	003b68fa 	trap	3
81116dd4:	df000015 	stw	fp,0(sp)
81116dd8:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116ddc:	0001883a 	nop
81116de0:	e037883a 	mov	sp,fp
81116de4:	df000017 	ldw	fp,0(sp)
81116de8:	dec00104 	addi	sp,sp,4
81116dec:	f800283a 	ret

81116df0 <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
81116df0:	deffff04 	addi	sp,sp,-4
81116df4:	de00012e 	bgeu	sp,et,81116dfc <vCouldNotSendLog+0xc>
81116df8:	003b68fa 	trap	3
81116dfc:	df000015 	stw	fp,0(sp)
81116e00:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116e04:	0001883a 	nop
81116e08:	e037883a 	mov	sp,fp
81116e0c:	df000017 	ldw	fp,0(sp)
81116e10:	dec00104 	addi	sp,sp,4
81116e14:	f800283a 	ret

81116e18 <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
81116e18:	defffe04 	addi	sp,sp,-8
81116e1c:	de00012e 	bgeu	sp,et,81116e24 <vCouldNotSendTMPusCommand+0xc>
81116e20:	003b68fa 	trap	3
81116e24:	df000115 	stw	fp,4(sp)
81116e28:	df000104 	addi	fp,sp,4
81116e2c:	e13fff15 	stw	r4,-4(fp)
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116e30:	0001883a 	nop
81116e34:	e037883a 	mov	sp,fp
81116e38:	df000017 	ldw	fp,0(sp)
81116e3c:	dec00104 	addi	sp,sp,4
81116e40:	f800283a 	ret

81116e44 <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
81116e44:	deffff04 	addi	sp,sp,-4
81116e48:	de00012e 	bgeu	sp,et,81116e50 <vWarnCouldNotgetMutexRetrans128+0xc>
81116e4c:	003b68fa 	trap	3
81116e50:	df000015 	stw	fp,0(sp)
81116e54:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116e58:	0001883a 	nop
81116e5c:	e037883a 	mov	sp,fp
81116e60:	df000017 	ldw	fp,0(sp)
81116e64:	dec00104 	addi	sp,sp,4
81116e68:	f800283a 	ret

81116e6c <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
81116e6c:	deffff04 	addi	sp,sp,-4
81116e70:	de00012e 	bgeu	sp,et,81116e78 <vFailCreateScheduleQueue+0xc>
81116e74:	003b68fa 	trap	3
81116e78:	df000015 	stw	fp,0(sp)
81116e7c:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116e80:	0001883a 	nop
81116e84:	e037883a 	mov	sp,fp
81116e88:	df000017 	ldw	fp,0(sp)
81116e8c:	dec00104 	addi	sp,sp,4
81116e90:	f800283a 	ret

81116e94 <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
81116e94:	defffe04 	addi	sp,sp,-8
81116e98:	de00012e 	bgeu	sp,et,81116ea0 <vFailCreateNFEEQueue+0xc>
81116e9c:	003b68fa 	trap	3
81116ea0:	df000115 	stw	fp,4(sp)
81116ea4:	df000104 	addi	fp,sp,4
81116ea8:	2005883a 	mov	r2,r4
81116eac:	e0bfff05 	stb	r2,-4(fp)
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116eb0:	0001883a 	nop
81116eb4:	e037883a 	mov	sp,fp
81116eb8:	df000017 	ldw	fp,0(sp)
81116ebc:	dec00104 	addi	sp,sp,4
81116ec0:	f800283a 	ret

81116ec4 <vFailCreateNFEESyncQueue>:

/* CRITICAL. */
void vFailCreateNFEESyncQueue( unsigned char ucID )
{
81116ec4:	defffe04 	addi	sp,sp,-8
81116ec8:	de00012e 	bgeu	sp,et,81116ed0 <vFailCreateNFEESyncQueue+0xc>
81116ecc:	003b68fa 	trap	3
81116ed0:	df000115 	stw	fp,4(sp)
81116ed4:	df000104 	addi	fp,sp,4
81116ed8:	2005883a 	mov	r2,r4
81116edc:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116ee0:	0001883a 	nop
81116ee4:	e037883a 	mov	sp,fp
81116ee8:	df000017 	ldw	fp,0(sp)
81116eec:	dec00104 	addi	sp,sp,4
81116ef0:	f800283a 	ret

81116ef4 <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
81116ef4:	deffff04 	addi	sp,sp,-4
81116ef8:	de00012e 	bgeu	sp,et,81116f00 <vCoudlNotCreateNFee0Task+0xc>
81116efc:	003b68fa 	trap	3
81116f00:	df000015 	stw	fp,0(sp)
81116f04:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116f08:	0001883a 	nop
81116f0c:	e037883a 	mov	sp,fp
81116f10:	df000017 	ldw	fp,0(sp)
81116f14:	dec00104 	addi	sp,sp,4
81116f18:	f800283a 	ret

81116f1c <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
81116f1c:	deffff04 	addi	sp,sp,-4
81116f20:	de00012e 	bgeu	sp,et,81116f28 <vCoudlNotCreateNFee1Task+0xc>
81116f24:	003b68fa 	trap	3
81116f28:	df000015 	stw	fp,0(sp)
81116f2c:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116f30:	0001883a 	nop
81116f34:	e037883a 	mov	sp,fp
81116f38:	df000017 	ldw	fp,0(sp)
81116f3c:	dec00104 	addi	sp,sp,4
81116f40:	f800283a 	ret

81116f44 <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
81116f44:	deffff04 	addi	sp,sp,-4
81116f48:	de00012e 	bgeu	sp,et,81116f50 <vCoudlNotCreateNFee2Task+0xc>
81116f4c:	003b68fa 	trap	3
81116f50:	df000015 	stw	fp,0(sp)
81116f54:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116f58:	0001883a 	nop
81116f5c:	e037883a 	mov	sp,fp
81116f60:	df000017 	ldw	fp,0(sp)
81116f64:	dec00104 	addi	sp,sp,4
81116f68:	f800283a 	ret

81116f6c <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
81116f6c:	deffff04 	addi	sp,sp,-4
81116f70:	de00012e 	bgeu	sp,et,81116f78 <vCoudlNotCreateNFee3Task+0xc>
81116f74:	003b68fa 	trap	3
81116f78:	df000015 	stw	fp,0(sp)
81116f7c:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116f80:	0001883a 	nop
81116f84:	e037883a 	mov	sp,fp
81116f88:	df000017 	ldw	fp,0(sp)
81116f8c:	dec00104 	addi	sp,sp,4
81116f90:	f800283a 	ret

81116f94 <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
81116f94:	deffff04 	addi	sp,sp,-4
81116f98:	de00012e 	bgeu	sp,et,81116fa0 <vCoudlNotCreateNFee4Task+0xc>
81116f9c:	003b68fa 	trap	3
81116fa0:	df000015 	stw	fp,0(sp)
81116fa4:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116fa8:	0001883a 	nop
81116fac:	e037883a 	mov	sp,fp
81116fb0:	df000017 	ldw	fp,0(sp)
81116fb4:	dec00104 	addi	sp,sp,4
81116fb8:	f800283a 	ret

81116fbc <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
81116fbc:	deffff04 	addi	sp,sp,-4
81116fc0:	de00012e 	bgeu	sp,et,81116fc8 <vCoudlNotCreateNFee5Task+0xc>
81116fc4:	003b68fa 	trap	3
81116fc8:	df000015 	stw	fp,0(sp)
81116fcc:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116fd0:	0001883a 	nop
81116fd4:	e037883a 	mov	sp,fp
81116fd8:	df000017 	ldw	fp,0(sp)
81116fdc:	dec00104 	addi	sp,sp,4
81116fe0:	f800283a 	ret

81116fe4 <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
81116fe4:	deffff04 	addi	sp,sp,-4
81116fe8:	de00012e 	bgeu	sp,et,81116ff0 <vCoudlNotCreateNFeeControllerTask+0xc>
81116fec:	003b68fa 	trap	3
81116ff0:	df000015 	stw	fp,0(sp)
81116ff4:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81116ff8:	0001883a 	nop
81116ffc:	e037883a 	mov	sp,fp
81117000:	df000017 	ldw	fp,0(sp)
81117004:	dec00104 	addi	sp,sp,4
81117008:	f800283a 	ret

8111700c <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
8111700c:	deffff04 	addi	sp,sp,-4
81117010:	de00012e 	bgeu	sp,et,81117018 <vCoudlNotCreateDataControllerTask+0xc>
81117014:	003b68fa 	trap	3
81117018:	df000015 	stw	fp,0(sp)
8111701c:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117020:	0001883a 	nop
81117024:	e037883a 	mov	sp,fp
81117028:	df000017 	ldw	fp,0(sp)
8111702c:	dec00104 	addi	sp,sp,4
81117030:	f800283a 	ret

81117034 <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
81117034:	deffff04 	addi	sp,sp,-4
81117038:	de00012e 	bgeu	sp,et,81117040 <vCoudlNotCreateMebTask+0xc>
8111703c:	003b68fa 	trap	3
81117040:	df000015 	stw	fp,0(sp)
81117044:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117048:	0001883a 	nop
8111704c:	e037883a 	mov	sp,fp
81117050:	df000017 	ldw	fp,0(sp)
81117054:	dec00104 	addi	sp,sp,4
81117058:	f800283a 	ret

8111705c <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
8111705c:	defffe04 	addi	sp,sp,-8
81117060:	de00012e 	bgeu	sp,et,81117068 <vFailCreateMutexSPUSQueueMeb+0xc>
81117064:	003b68fa 	trap	3
81117068:	df000115 	stw	fp,4(sp)
8111706c:	df000104 	addi	fp,sp,4
81117070:	2005883a 	mov	r2,r4
81117074:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117078:	0001883a 	nop
8111707c:	e037883a 	mov	sp,fp
81117080:	df000017 	ldw	fp,0(sp)
81117084:	dec00104 	addi	sp,sp,4
81117088:	f800283a 	ret

8111708c <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
8111708c:	deffff04 	addi	sp,sp,-4
81117090:	de00012e 	bgeu	sp,et,81117098 <vFailSendPUStoMebTask+0xc>
81117094:	003b68fa 	trap	3
81117098:	df000015 	stw	fp,0(sp)
8111709c:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811170a0:	0001883a 	nop
811170a4:	e037883a 	mov	sp,fp
811170a8:	df000017 	ldw	fp,0(sp)
811170ac:	dec00104 	addi	sp,sp,4
811170b0:	f800283a 	ret

811170b4 <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
811170b4:	deffff04 	addi	sp,sp,-4
811170b8:	de00012e 	bgeu	sp,et,811170c0 <vCouldNotGetCmdQueueMeb+0xc>
811170bc:	003b68fa 	trap	3
811170c0:	df000015 	stw	fp,0(sp)
811170c4:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811170c8:	0001883a 	nop
811170cc:	e037883a 	mov	sp,fp
811170d0:	df000017 	ldw	fp,0(sp)
811170d4:	dec00104 	addi	sp,sp,4
811170d8:	f800283a 	ret

811170dc <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
811170dc:	deffff04 	addi	sp,sp,-4
811170e0:	de00012e 	bgeu	sp,et,811170e8 <vCouldNotGetMutexMebPus+0xc>
811170e4:	003b68fa 	trap	3
811170e8:	df000015 	stw	fp,0(sp)
811170ec:	d839883a 	mov	fp,sp
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811170f0:	0001883a 	nop
811170f4:	e037883a 	mov	sp,fp
811170f8:	df000017 	ldw	fp,0(sp)
811170fc:	dec00104 	addi	sp,sp,4
81117100:	f800283a 	ret

81117104 <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
81117104:	deffff04 	addi	sp,sp,-4
81117108:	de00012e 	bgeu	sp,et,81117110 <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
8111710c:	003b68fa 	trap	3
81117110:	df000015 	stw	fp,0(sp)
81117114:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117118:	0001883a 	nop
8111711c:	e037883a 	mov	sp,fp
81117120:	df000017 	ldw	fp,0(sp)
81117124:	dec00104 	addi	sp,sp,4
81117128:	f800283a 	ret

8111712c <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
8111712c:	deffff04 	addi	sp,sp,-4
81117130:	de00012e 	bgeu	sp,et,81117138 <vCouldNotCreateQueueMaskDataCtrl+0xc>
81117134:	003b68fa 	trap	3
81117138:	df000015 	stw	fp,0(sp)
8111713c:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117140:	0001883a 	nop
81117144:	e037883a 	mov	sp,fp
81117148:	df000017 	ldw	fp,0(sp)
8111714c:	dec00104 	addi	sp,sp,4
81117150:	f800283a 	ret

81117154 <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
81117154:	deffff04 	addi	sp,sp,-4
81117158:	de00012e 	bgeu	sp,et,81117160 <vCouldNotGetQueueMaskNfeeCtrl+0xc>
8111715c:	003b68fa 	trap	3
81117160:	df000015 	stw	fp,0(sp)
81117164:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117168:	0001883a 	nop
8111716c:	e037883a 	mov	sp,fp
81117170:	df000017 	ldw	fp,0(sp)
81117174:	dec00104 	addi	sp,sp,4
81117178:	f800283a 	ret

8111717c <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
8111717c:	deffff04 	addi	sp,sp,-4
81117180:	de00012e 	bgeu	sp,et,81117188 <vCouldNotGetQueueMaskDataCtrl+0xc>
81117184:	003b68fa 	trap	3
81117188:	df000015 	stw	fp,0(sp)
8111718c:	d839883a 	mov	fp,sp
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117190:	0001883a 	nop
81117194:	e037883a 	mov	sp,fp
81117198:	df000017 	ldw	fp,0(sp)
8111719c:	dec00104 	addi	sp,sp,4
811171a0:	f800283a 	ret

811171a4 <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
811171a4:	defffe04 	addi	sp,sp,-8
811171a8:	de00012e 	bgeu	sp,et,811171b0 <vFailSendMsgAccessDMA+0xc>
811171ac:	003b68fa 	trap	3
811171b0:	df000115 	stw	fp,4(sp)
811171b4:	df000104 	addi	fp,sp,4
811171b8:	2005883a 	mov	r2,r4
811171bc:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811171c0:	0001883a 	nop
811171c4:	e037883a 	mov	sp,fp
811171c8:	df000017 	ldw	fp,0(sp)
811171cc:	dec00104 	addi	sp,sp,4
811171d0:	f800283a 	ret

811171d4 <vFailRequestDMA>:

void vFailRequestDMA( unsigned char ucTemp)
{
811171d4:	defffe04 	addi	sp,sp,-8
811171d8:	de00012e 	bgeu	sp,et,811171e0 <vFailRequestDMA+0xc>
811171dc:	003b68fa 	trap	3
811171e0:	df000115 	stw	fp,4(sp)
811171e4:	df000104 	addi	fp,sp,4
811171e8:	2005883a 	mov	r2,r4
811171ec:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811171f0:	0001883a 	nop
811171f4:	e037883a 	mov	sp,fp
811171f8:	df000017 	ldw	fp,0(sp)
811171fc:	dec00104 	addi	sp,sp,4
81117200:	f800283a 	ret

81117204 <vFailRequestDMAFromIRQ>:

void vFailRequestDMAFromIRQ( unsigned char ucTemp)
{
81117204:	defffe04 	addi	sp,sp,-8
81117208:	de00012e 	bgeu	sp,et,81117210 <vFailRequestDMAFromIRQ+0xc>
8111720c:	003b68fa 	trap	3
81117210:	df000115 	stw	fp,4(sp)
81117214:	df000104 	addi	fp,sp,4
81117218:	2005883a 	mov	r2,r4
8111721c:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117220:	0001883a 	nop
81117224:	e037883a 	mov	sp,fp
81117228:	df000017 	ldw	fp,0(sp)
8111722c:	dec00104 	addi	sp,sp,4
81117230:	f800283a 	ret

81117234 <vFailSendRMAPFromIRQ>:


void vFailSendRMAPFromIRQ( unsigned char ucTemp)
{
81117234:	defffe04 	addi	sp,sp,-8
81117238:	de00012e 	bgeu	sp,et,81117240 <vFailSendRMAPFromIRQ+0xc>
8111723c:	003b68fa 	trap	3
81117240:	df000115 	stw	fp,4(sp)
81117244:	df000104 	addi	fp,sp,4
81117248:	2005883a 	mov	r2,r4
8111724c:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117250:	0001883a 	nop
81117254:	e037883a 	mov	sp,fp
81117258:	df000017 	ldw	fp,0(sp)
8111725c:	dec00104 	addi	sp,sp,4
81117260:	f800283a 	ret

81117264 <vFailSendMsgSync>:


void vFailSendMsgSync( unsigned char ucTemp)
{
81117264:	defffe04 	addi	sp,sp,-8
81117268:	de00012e 	bgeu	sp,et,81117270 <vFailSendMsgSync+0xc>
8111726c:	003b68fa 	trap	3
81117270:	df000115 	stw	fp,4(sp)
81117274:	df000104 	addi	fp,sp,4
81117278:	2005883a 	mov	r2,r4
8111727c:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117280:	0001883a 	nop
81117284:	e037883a 	mov	sp,fp
81117288:	df000017 	ldw	fp,0(sp)
8111728c:	dec00104 	addi	sp,sp,4
81117290:	f800283a 	ret

81117294 <vFailSendMsgSyncRMAPTRIGGER>:

void vFailSendMsgSyncRMAPTRIGGER( unsigned char ucTemp)
{
81117294:	defffe04 	addi	sp,sp,-8
81117298:	de00012e 	bgeu	sp,et,811172a0 <vFailSendMsgSyncRMAPTRIGGER+0xc>
8111729c:	003b68fa 	trap	3
811172a0:	df000115 	stw	fp,4(sp)
811172a4:	df000104 	addi	fp,sp,4
811172a8:	2005883a 	mov	r2,r4
811172ac:	e0bfff05 	stb	r2,-4(fp)
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811172b0:	0001883a 	nop
811172b4:	e037883a 	mov	sp,fp
811172b8:	df000017 	ldw	fp,0(sp)
811172bc:	dec00104 	addi	sp,sp,4
811172c0:	f800283a 	ret

811172c4 <vFailSendMsgMasterSyncMeb>:

void vFailSendMsgMasterSyncMeb( void )
{
811172c4:	deffff04 	addi	sp,sp,-4
811172c8:	de00012e 	bgeu	sp,et,811172d0 <vFailSendMsgMasterSyncMeb+0xc>
811172cc:	003b68fa 	trap	3
811172d0:	df000015 	stw	fp,0(sp)
811172d4:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811172d8:	0001883a 	nop
811172dc:	e037883a 	mov	sp,fp
811172e0:	df000017 	ldw	fp,0(sp)
811172e4:	dec00104 	addi	sp,sp,4
811172e8:	f800283a 	ret

811172ec <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
811172ec:	deffff04 	addi	sp,sp,-4
811172f0:	de00012e 	bgeu	sp,et,811172f8 <vFailSendMsgFeeCTRL+0xc>
811172f4:	003b68fa 	trap	3
811172f8:	df000015 	stw	fp,0(sp)
811172fc:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117300:	0001883a 	nop
81117304:	e037883a 	mov	sp,fp
81117308:	df000017 	ldw	fp,0(sp)
8111730c:	dec00104 	addi	sp,sp,4
81117310:	f800283a 	ret

81117314 <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
81117314:	deffff04 	addi	sp,sp,-4
81117318:	de00012e 	bgeu	sp,et,81117320 <vFailSendMsgDataCTRL+0xc>
8111731c:	003b68fa 	trap	3
81117320:	df000015 	stw	fp,0(sp)
81117324:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117328:	0001883a 	nop
8111732c:	e037883a 	mov	sp,fp
81117330:	df000017 	ldw	fp,0(sp)
81117334:	dec00104 	addi	sp,sp,4
81117338:	f800283a 	ret

8111733c <vFailFlushQueue>:

void vFailFlushQueue( void )
{
8111733c:	deffff04 	addi	sp,sp,-4
81117340:	de00012e 	bgeu	sp,et,81117348 <vFailFlushQueue+0xc>
81117344:	003b68fa 	trap	3
81117348:	df000015 	stw	fp,0(sp)
8111734c:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117350:	0001883a 	nop
81117354:	e037883a 	mov	sp,fp
81117358:	df000017 	ldw	fp,0(sp)
8111735c:	dec00104 	addi	sp,sp,4
81117360:	f800283a 	ret

81117364 <vFailFlushQueueData>:

void vFailFlushQueueData( void )
{
81117364:	deffff04 	addi	sp,sp,-4
81117368:	de00012e 	bgeu	sp,et,81117370 <vFailFlushQueueData+0xc>
8111736c:	003b68fa 	trap	3
81117370:	df000015 	stw	fp,0(sp)
81117374:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117378:	0001883a 	nop
8111737c:	e037883a 	mov	sp,fp
81117380:	df000017 	ldw	fp,0(sp)
81117384:	dec00104 	addi	sp,sp,4
81117388:	f800283a 	ret

8111738c <vFailFlushMEBQueue>:


void vFailFlushMEBQueue( void )
{
8111738c:	deffff04 	addi	sp,sp,-4
81117390:	de00012e 	bgeu	sp,et,81117398 <vFailFlushMEBQueue+0xc>
81117394:	003b68fa 	trap	3
81117398:	df000015 	stw	fp,0(sp)
8111739c:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811173a0:	0001883a 	nop
811173a4:	e037883a 	mov	sp,fp
811173a8:	df000017 	ldw	fp,0(sp)
811173ac:	dec00104 	addi	sp,sp,4
811173b0:	f800283a 	ret

811173b4 <vFailFlushNFEEQueue>:

void vFailFlushNFEEQueue( void )
{
811173b4:	deffff04 	addi	sp,sp,-4
811173b8:	de00012e 	bgeu	sp,et,811173c0 <vFailFlushNFEEQueue+0xc>
811173bc:	003b68fa 	trap	3
811173c0:	df000015 	stw	fp,0(sp)
811173c4:	d839883a 	mov	fp,sp
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811173c8:	0001883a 	nop
811173cc:	e037883a 	mov	sp,fp
811173d0:	df000017 	ldw	fp,0(sp)
811173d4:	dec00104 	addi	sp,sp,4
811173d8:	f800283a 	ret

811173dc <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( void ) {
811173dc:	deffff04 	addi	sp,sp,-4
811173e0:	de00012e 	bgeu	sp,et,811173e8 <vEvtChangeMebMode+0xc>
811173e4:	003b68fa 	trap	3
811173e8:	df000015 	stw	fp,0(sp)
811173ec:	d839883a 	mov	fp,sp

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
811173f0:	0001883a 	nop
811173f4:	e037883a 	mov	sp,fp
811173f8:	df000017 	ldw	fp,0(sp)
811173fc:	dec00104 	addi	sp,sp,4
81117400:	f800283a 	ret

81117404 <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( void ) {
81117404:	deffff04 	addi	sp,sp,-4
81117408:	de00012e 	bgeu	sp,et,81117410 <vEvtChangeFeeControllerMode+0xc>
8111740c:	003b68fa 	trap	3
81117410:	df000015 	stw	fp,0(sp)
81117414:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
81117418:	0001883a 	nop
8111741c:	e037883a 	mov	sp,fp
81117420:	df000017 	ldw	fp,0(sp)
81117424:	dec00104 	addi	sp,sp,4
81117428:	f800283a 	ret

8111742c <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( void ) {
8111742c:	deffff04 	addi	sp,sp,-4
81117430:	de00012e 	bgeu	sp,et,81117438 <vEvtChangeDataControllerMode+0xc>
81117434:	003b68fa 	trap	3
81117438:	df000015 	stw	fp,0(sp)
8111743c:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
81117440:	0001883a 	nop
81117444:	e037883a 	mov	sp,fp
81117448:	df000017 	ldw	fp,0(sp)
8111744c:	dec00104 	addi	sp,sp,4
81117450:	f800283a 	ret

81117454 <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
81117454:	defffd04 	addi	sp,sp,-12
81117458:	de00012e 	bgeu	sp,et,81117460 <vNFeeNotInUse+0xc>
8111745c:	003b68fa 	trap	3
81117460:	df000215 	stw	fp,8(sp)
81117464:	df000204 	addi	fp,sp,8
81117468:	e13ffe15 	stw	r4,-8(fp)
8111746c:	2805883a 	mov	r2,r5
81117470:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
81117474:	e0bffe17 	ldw	r2,-8(fp)
81117478:	e0ffff03 	ldbu	r3,-4(fp)
8111747c:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
81117480:	e0bffe17 	ldw	r2,-8(fp)
81117484:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
81117488:	e0bffe17 	ldw	r2,-8(fp)
8111748c:	10002315 	stw	zero,140(r2)
}
81117490:	0001883a 	nop
81117494:	e037883a 	mov	sp,fp
81117498:	df000017 	ldw	fp,0(sp)
8111749c:	dec00104 	addi	sp,sp,4
811174a0:	f800283a 	ret

811174a4 <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
811174a4:	defffb04 	addi	sp,sp,-20
811174a8:	de00012e 	bgeu	sp,et,811174b0 <vNFeeStructureInit+0xc>
811174ac:	003b68fa 	trap	3
811174b0:	dfc00415 	stw	ra,16(sp)
811174b4:	df000315 	stw	fp,12(sp)
811174b8:	df000304 	addi	fp,sp,12
811174bc:	e13ffe15 	stw	r4,-8(fp)
811174c0:	2805883a 	mov	r2,r5
811174c4:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
811174c8:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
811174cc:	e0bffe17 	ldw	r2,-8(fp)
811174d0:	e0ffff03 	ldbu	r3,-4(fp)
811174d4:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
811174d8:	e0bffe17 	ldw	r2,-8(fp)
811174dc:	10802f04 	addi	r2,r2,188
811174e0:	1009883a 	mov	r4,r2
811174e4:	11138400 	call	81113840 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
811174e8:	e13ffe17 	ldw	r4,-8(fp)
811174ec:	111766c0 	call	8111766c <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
811174f0:	e0bffe17 	ldw	r2,-8(fp)
811174f4:	00c00044 	movi	r3,1
811174f8:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
811174fc:	e0bffe17 	ldw	r2,-8(fp)
81117500:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
81117504:	e0bffe17 	ldw	r2,-8(fp)
81117508:	10002615 	stw	zero,152(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
8111750c:	e0bffe17 	ldw	r2,-8(fp)
81117510:	10002715 	stw	zero,156(r2)
    pxNfeeL->xControl.bWatingSync = FALSE;
81117514:	e0bffe17 	ldw	r2,-8(fp)
81117518:	10002815 	stw	zero,160(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
8111751c:	e0bffe17 	ldw	r2,-8(fp)
81117520:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bLogging = FALSE;
81117524:	e0bffe17 	ldw	r2,-8(fp)
81117528:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bDMALocked = FALSE;
8111752c:	e0bffe17 	ldw	r2,-8(fp)
81117530:	10002215 	stw	zero,136(r2)
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
81117534:	e0bffe17 	ldw	r2,-8(fp)
81117538:	10002e15 	stw	zero,184(r2)
    pxNfeeL->xControl.ucTimeCode = 0;
8111753c:	e0bffe17 	ldw	r2,-8(fp)
81117540:	10002a05 	stb	zero,168(r2)
    

    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
81117544:	e0bffe17 	ldw	r2,-8(fp)
81117548:	10002c15 	stw	zero,176(r2)
    pxNfeeL->xControl.eNextMode = sFeeInit;
8111754c:	e0bffe17 	ldw	r2,-8(fp)
81117550:	10002d15 	stw	zero,180(r2)

    switch (ucIdNFEE) {
81117554:	e0bfff03 	ldbu	r2,-4(fp)
81117558:	10000126 	beq	r2,zero,81117560 <vNFeeStructureInit+0xbc>
			break;
		default:
			#if DEBUG_ON
				fprintf(fp, "\n CRITICAL! Can't bind the SPQ channel with the NFEE %i \n", pxNfeeL->ucId);
			#endif
			break;
8111755c:	00000706 	br	8111757c <vNFeeStructureInit+0xd8>
    pxNfeeL->xControl.eMode = sFeeInit;
    pxNfeeL->xControl.eNextMode = sFeeInit;

    switch (ucIdNFEE) {
		case 0:
			pxNfeeL->ucSPWId = (unsigned char)xDefaults.usiLinkNFEE0;
81117560:	00a045b4 	movhi	r2,33046
81117564:	10acbf04 	addi	r2,r2,-19716
81117568:	1080100b 	ldhu	r2,64(r2)
8111756c:	1007883a 	mov	r3,r2
81117570:	e0bffe17 	ldw	r2,-8(fp)
81117574:	10c00045 	stb	r3,1(r2)
			break;
81117578:	0001883a 	nop

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111757c:	e03ffd05 	stb	zero,-12(fp)
81117580:	00000906 	br	811175a8 <vNFeeStructureInit+0x104>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
81117584:	e0bffd03 	ldbu	r2,-12(fp)
81117588:	e0fffe17 	ldw	r3,-8(fp)
8111758c:	1885883a 	add	r2,r3,r2
81117590:	10802a44 	addi	r2,r2,169
81117594:	e0fffd03 	ldbu	r3,-12(fp)
81117598:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111759c:	e0bffd03 	ldbu	r2,-12(fp)
811175a0:	10800044 	addi	r2,r2,1
811175a4:	e0bffd05 	stb	r2,-12(fp)
811175a8:	e0bffd03 	ldbu	r2,-12(fp)
811175ac:	10800130 	cmpltui	r2,r2,4
811175b0:	103ff41e 	bne	r2,zero,81117584 <__reset+0xfb0f7584>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;

    /* Initialize the structs of the Channel, Double Buffer, RMAP and Data packet */
    if ( bCommInitCh(&pxNfeeL->xChannel, pxNfeeL->ucSPWId ) == FALSE ) {
811175b4:	e0bffe17 	ldw	r2,-8(fp)
811175b8:	10c03204 	addi	r3,r2,200
811175bc:	e0bffe17 	ldw	r2,-8(fp)
811175c0:	10800043 	ldbu	r2,1(r2)
811175c4:	10803fcc 	andi	r2,r2,255
811175c8:	100b883a 	mov	r5,r2
811175cc:	1809883a 	mov	r4,r3
811175d0:	11029ac0 	call	811029ac <bCommInitCh>
		#if DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Initialized SPW Channel %i \n", pxNfeeL->ucId);
		#endif
    }

    if ( bCommSetGlobalIrqEn( TRUE, pxNfeeL->ucSPWId ) == FALSE ) {
811175d4:	e0bffe17 	ldw	r2,-8(fp)
811175d8:	10800043 	ldbu	r2,1(r2)
811175dc:	10803fcc 	andi	r2,r2,255
811175e0:	100b883a 	mov	r5,r2
811175e4:	01000044 	movi	r4,1
811175e8:	11028400 	call	81102840 <bCommSetGlobalIrqEn>
		#if DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Enable global interrupt for the channel %i \n", pxNfeeL->ucId);
		#endif
    }

    bDpktGetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
811175ec:	e0bffe17 	ldw	r2,-8(fp)
811175f0:	10803304 	addi	r2,r2,204
811175f4:	1009883a 	mov	r4,r2
811175f8:	11030840 	call	81103084 <bDpktGetPixelDelay>
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiAdcDelay = usiAdcPxDelayCalcPeriodNs(xDefaults.ulADCPixelDelay);
811175fc:	00a045b4 	movhi	r2,33046
81117600:	10acbf04 	addi	r2,r2,-19716
81117604:	10800b17 	ldw	r2,44(r2)
81117608:	1009883a 	mov	r4,r2
8111760c:	11033600 	call	81103360 <usiAdcPxDelayCalcPeriodNs>
81117610:	1007883a 	mov	r3,r2
81117614:	e0bffe17 	ldw	r2,-8(fp)
81117618:	10c03a0d 	sth	r3,232(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiColumnDelay = 0 ;
8111761c:	e0bffe17 	ldw	r2,-8(fp)
81117620:	1000398d 	sth	zero,230(r2)
    pxNfeeL->xChannel.xDataPacket.xDpktPixelDelay.usiLineDelay = usiLineTrDelayCalcPeriodNs(xDefaults.ulLineDelay);
81117624:	00a045b4 	movhi	r2,33046
81117628:	10acbf04 	addi	r2,r2,-19716
8111762c:	10800917 	ldw	r2,36(r2)
81117630:	1009883a 	mov	r4,r2
81117634:	11033ec0 	call	811033ec <usiLineTrDelayCalcPeriodNs>
81117638:	1007883a 	mov	r3,r2
8111763c:	e0bffe17 	ldw	r2,-8(fp)
81117640:	10c0390d 	sth	r3,228(r2)
    bDpktSetPixelDelay(&pxNfeeL->xChannel.xDataPacket);
81117644:	e0bffe17 	ldw	r2,-8(fp)
81117648:	10803304 	addi	r2,r2,204
8111764c:	1009883a 	mov	r4,r2
81117650:	1102f3c0 	call	81102f3c <bDpktSetPixelDelay>


}
81117654:	0001883a 	nop
81117658:	e037883a 	mov	sp,fp
8111765c:	dfc00117 	ldw	ra,4(sp)
81117660:	df000017 	ldw	fp,0(sp)
81117664:	dec00204 	addi	sp,sp,8
81117668:	f800283a 	ret

8111766c <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
8111766c:	defff404 	addi	sp,sp,-48
81117670:	de00012e 	bgeu	sp,et,81117678 <vUpdateMemMapFEE+0xc>
81117674:	003b68fa 	trap	3
81117678:	df000b15 	stw	fp,44(sp)
8111767c:	df000b04 	addi	fp,sp,44
81117680:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
81117684:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
81117688:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
8111768c:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
81117690:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
81117694:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
81117698:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
8111769c:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
811176a0:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
811176a4:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
811176a8:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
811176ac:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
811176b0:	e17fff17 	ldw	r5,-4(fp)
811176b4:	01035a34 	movhi	r4,3432
811176b8:	21348c04 	addi	r4,r4,-11728
811176bc:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
811176c0:	e13fff17 	ldw	r4,-4(fp)
811176c4:	21000003 	ldbu	r4,0(r4)
811176c8:	21403fcc 	andi	r5,r4,255
811176cc:	01035a34 	movhi	r4,3432
811176d0:	21348c04 	addi	r4,r4,-11728
811176d4:	2909383a 	mul	r4,r5,r4
811176d8:	200b883a 	mov	r5,r4
811176dc:	e13fff17 	ldw	r4,-4(fp)
811176e0:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
811176e4:	e13fff17 	ldw	r4,-4(fp)
811176e8:	21400117 	ldw	r5,4(r4)
811176ec:	01033234 	movhi	r4,3272
811176f0:	21348c04 	addi	r4,r4,-11728
811176f4:	290b883a 	add	r5,r5,r4
811176f8:	e13fff17 	ldw	r4,-4(fp)
811176fc:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
81117700:	e13fff17 	ldw	r4,-4(fp)
81117704:	2100310b 	ldhu	r4,196(r4)
81117708:	217fffcc 	andi	r5,r4,65535
8111770c:	e13fff17 	ldw	r4,-4(fp)
81117710:	2100300b 	ldhu	r4,192(r4)
81117714:	213fffcc 	andi	r4,r4,65535
81117718:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
8111771c:	e13fff17 	ldw	r4,-4(fp)
81117720:	2100308b 	ldhu	r4,194(r4)
81117724:	21bfffcc 	andi	r6,r4,65535
81117728:	e13fff17 	ldw	r4,-4(fp)
8111772c:	21002f8b 	ldhu	r4,190(r4)
81117730:	213fffcc 	andi	r4,r4,65535
81117734:	310d883a 	add	r6,r6,r4
81117738:	e13fff17 	ldw	r4,-4(fp)
8111773c:	21002f0b 	ldhu	r4,188(r4)
81117740:	213fffcc 	andi	r4,r4,65535
81117744:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
81117748:	2909383a 	mul	r4,r5,r4
8111774c:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
81117750:	e13ffa17 	ldw	r4,-24(fp)
81117754:	2109883a 	add	r4,r4,r4
81117758:	200b883a 	mov	r5,r4
8111775c:	e13fff17 	ldw	r4,-4(fp)
81117760:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
81117764:	e13fff17 	ldw	r4,-4(fp)
81117768:	21000517 	ldw	r4,20(r4)
8111776c:	2008d0fa 	srli	r4,r4,3
81117770:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
81117774:	e13fff17 	ldw	r4,-4(fp)
81117778:	21000517 	ldw	r4,20(r4)
8111777c:	210001cc 	andi	r4,r4,7
81117780:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
81117784:	e13ffb17 	ldw	r4,-20(fp)
81117788:	20001226 	beq	r4,zero,811177d4 <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
8111778c:	e13ff517 	ldw	r4,-44(fp)
81117790:	21000044 	addi	r4,r4,1
81117794:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
81117798:	e13fff17 	ldw	r4,-4(fp)
8111779c:	21400517 	ldw	r5,20(r4)
811177a0:	e13ffb17 	ldw	r4,-20(fp)
811177a4:	2909c83a 	sub	r4,r5,r4
811177a8:	21400204 	addi	r5,r4,8
811177ac:	e13fff17 	ldw	r4,-4(fp)
811177b0:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
811177b4:	e13ffb17 	ldw	r4,-20(fp)
811177b8:	200b883a 	mov	r5,r4
811177bc:	01000204 	movi	r4,8
811177c0:	2149c83a 	sub	r4,r4,r5
811177c4:	200b883a 	mov	r5,r4
811177c8:	e13fff17 	ldw	r4,-4(fp)
811177cc:	21400605 	stb	r5,24(r4)
811177d0:	00000206 	br	811177dc <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
811177d4:	e13fff17 	ldw	r4,-4(fp)
811177d8:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
811177dc:	e13ff517 	ldw	r4,-44(fp)
811177e0:	2008d13a 	srli	r4,r4,4
811177e4:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
811177e8:	e13ff517 	ldw	r4,-44(fp)
811177ec:	210003cc 	andi	r4,r4,15
811177f0:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
811177f4:	e13ffc17 	ldw	r4,-16(fp)
811177f8:	20000b26 	beq	r4,zero,81117828 <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
811177fc:	e13ff717 	ldw	r4,-36(fp)
81117800:	21000044 	addi	r4,r4,1
81117804:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
81117808:	e17ff517 	ldw	r5,-44(fp)
8111780c:	e13ffc17 	ldw	r4,-16(fp)
81117810:	290bc83a 	sub	r5,r5,r4
81117814:	e13ff717 	ldw	r4,-36(fp)
81117818:	2909883a 	add	r4,r5,r4
8111781c:	21000404 	addi	r4,r4,16
81117820:	e13ff615 	stw	r4,-40(fp)
81117824:	00000406 	br	81117838 <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
81117828:	e17ff517 	ldw	r5,-44(fp)
8111782c:	e13ff717 	ldw	r4,-36(fp)
81117830:	2909883a 	add	r4,r5,r4
81117834:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
81117838:	e13ff617 	ldw	r4,-40(fp)
8111783c:	200a90fa 	slli	r5,r4,3
81117840:	e13fff17 	ldw	r4,-4(fp)
81117844:	21400515 	stw	r5,20(r4)


    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
81117848:	e13ffb17 	ldw	r4,-20(fp)
8111784c:	20000926 	beq	r4,zero,81117874 <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
81117850:	e13ffc17 	ldw	r4,-16(fp)
81117854:	2109883a 	add	r4,r4,r4
81117858:	2109883a 	add	r4,r4,r4
8111785c:	200b883a 	mov	r5,r4
81117860:	e13ffb17 	ldw	r4,-20(fp)
81117864:	2008d07a 	srli	r4,r4,1
81117868:	2909883a 	add	r4,r5,r4
8111786c:	e13ff805 	stb	r4,-32(fp)
81117870:	00000406 	br	81117884 <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
81117874:	e13ffc17 	ldw	r4,-16(fp)
81117878:	2109883a 	add	r4,r4,r4
8111787c:	2109883a 	add	r4,r4,r4
81117880:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
81117884:	e13ff803 	ldbu	r4,-32(fp)
81117888:	01401004 	movi	r5,64
8111788c:	2909c83a 	sub	r4,r5,r4
81117890:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    //pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF << ucShiftsL);
81117894:	e13ffd03 	ldbu	r4,-12(fp)
81117898:	217ff804 	addi	r5,r4,-32
8111789c:	28000416 	blt	r5,zero,811178b0 <vUpdateMemMapFEE+0x244>
811178a0:	013fffc4 	movi	r4,-1
811178a4:	2146983a 	sll	r3,r4,r5
811178a8:	0005883a 	mov	r2,zero
811178ac:	00000a06 	br	811178d8 <vUpdateMemMapFEE+0x26c>
811178b0:	017fffc4 	movi	r5,-1
811178b4:	280cd07a 	srli	r6,r5,1
811178b8:	014007c4 	movi	r5,31
811178bc:	290bc83a 	sub	r5,r5,r4
811178c0:	314ad83a 	srl	r5,r6,r5
811178c4:	01bfffc4 	movi	r6,-1
811178c8:	3106983a 	sll	r3,r6,r4
811178cc:	28c6b03a 	or	r3,r5,r3
811178d0:	017fffc4 	movi	r5,-1
811178d4:	2904983a 	sll	r2,r5,r4
811178d8:	e13fff17 	ldw	r4,-4(fp)
811178dc:	20800715 	stw	r2,28(r4)
811178e0:	20c00815 	stw	r3,32(r4)
    //pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF);


    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
811178e4:	e0bfff17 	ldw	r2,-4(fp)
811178e8:	e0fff717 	ldw	r3,-36(fp)
811178ec:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
811178f0:	e0bfff17 	ldw	r2,-4(fp)
811178f4:	10c00117 	ldw	r3,4(r2)
811178f8:	008004b4 	movhi	r2,18
811178fc:	10a40004 	addi	r2,r2,-28672
81117900:	1885883a 	add	r2,r3,r2
81117904:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
81117908:	e0bfff17 	ldw	r2,-4(fp)
8111790c:	10c00517 	ldw	r3,20(r2)
81117910:	008000b4 	movhi	r2,2
81117914:	10a40004 	addi	r2,r2,-28672
81117918:	1885883a 	add	r2,r3,r2
8111791c:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
81117920:	e03ff845 	stb	zero,-31(fp)
81117924:	00001906 	br	8111798c <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
81117928:	e0bff843 	ldbu	r2,-31(fp)
8111792c:	e0ffff17 	ldw	r3,-4(fp)
81117930:	10800624 	muli	r2,r2,24
81117934:	1885883a 	add	r2,r3,r2
81117938:	10800904 	addi	r2,r2,36
8111793c:	e0fff917 	ldw	r3,-28(fp)
81117940:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
81117944:	e0fff917 	ldw	r3,-28(fp)
81117948:	e0bffe17 	ldw	r2,-8(fp)
8111794c:	1885883a 	add	r2,r3,r2
81117950:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
81117954:	e0bff843 	ldbu	r2,-31(fp)
81117958:	e0ffff17 	ldw	r3,-4(fp)
8111795c:	10800624 	muli	r2,r2,24
81117960:	1885883a 	add	r2,r3,r2
81117964:	10800c04 	addi	r2,r2,48
81117968:	e0fff917 	ldw	r3,-28(fp)
8111796c:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
81117970:	e0fff917 	ldw	r3,-28(fp)
81117974:	e0bffe17 	ldw	r2,-8(fp)
81117978:	1885883a 	add	r2,r3,r2
8111797c:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
81117980:	e0bff843 	ldbu	r2,-31(fp)
81117984:	10800044 	addi	r2,r2,1
81117988:	e0bff845 	stb	r2,-31(fp)
8111798c:	e0bff843 	ldbu	r2,-31(fp)
81117990:	10800130 	cmpltui	r2,r2,4
81117994:	103fe41e 	bne	r2,zero,81117928 <__reset+0xfb0f7928>
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }

}
81117998:	0001883a 	nop
8111799c:	e037883a 	mov	sp,fp
811179a0:	df000017 	ldw	fp,0(sp)
811179a4:	dec00104 	addi	sp,sp,4
811179a8:	f800283a 	ret

811179ac <vResetMemCCDFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
811179ac:	defffd04 	addi	sp,sp,-12
811179b0:	de00012e 	bgeu	sp,et,811179b8 <vResetMemCCDFEE+0xc>
811179b4:	003b68fa 	trap	3
811179b8:	df000215 	stw	fp,8(sp)
811179bc:	df000204 	addi	fp,sp,8
811179c0:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL = 0;
811179c4:	e03ffe05 	stb	zero,-8(fp)

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
811179c8:	e03ffe05 	stb	zero,-8(fp)
811179cc:	00001b06 	br	81117a3c <vResetMemCCDFEE+0x90>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
811179d0:	e0bffe03 	ldbu	r2,-8(fp)
811179d4:	e0ffff17 	ldw	r3,-4(fp)
811179d8:	10800624 	muli	r2,r2,24
811179dc:	1885883a 	add	r2,r3,r2
811179e0:	10800b04 	addi	r2,r2,44
811179e4:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
811179e8:	e0bffe03 	ldbu	r2,-8(fp)
811179ec:	e0ffff17 	ldw	r3,-4(fp)
811179f0:	10800624 	muli	r2,r2,24
811179f4:	1885883a 	add	r2,r3,r2
811179f8:	10800a04 	addi	r2,r2,40
811179fc:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
81117a00:	e0bffe03 	ldbu	r2,-8(fp)
81117a04:	e0ffff17 	ldw	r3,-4(fp)
81117a08:	10800624 	muli	r2,r2,24
81117a0c:	1885883a 	add	r2,r3,r2
81117a10:	10800e04 	addi	r2,r2,56
81117a14:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
81117a18:	e0bffe03 	ldbu	r2,-8(fp)
81117a1c:	e0ffff17 	ldw	r3,-4(fp)
81117a20:	10800624 	muli	r2,r2,24
81117a24:	1885883a 	add	r2,r3,r2
81117a28:	10800d04 	addi	r2,r2,52
81117a2c:	10000015 	stw	zero,0(r2)

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
	unsigned char ucIL = 0;

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
81117a30:	e0bffe03 	ldbu	r2,-8(fp)
81117a34:	10800044 	addi	r2,r2,1
81117a38:	e0bffe05 	stb	r2,-8(fp)
81117a3c:	e0bffe03 	ldbu	r2,-8(fp)
81117a40:	10800130 	cmpltui	r2,r2,4
81117a44:	103fe21e 	bne	r2,zero,811179d0 <__reset+0xfb0f79d0>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
    }
}
81117a48:	0001883a 	nop
81117a4c:	e037883a 	mov	sp,fp
81117a50:	df000017 	ldw	fp,0(sp)
81117a54:	dec00104 	addi	sp,sp,4
81117a58:	f800283a 	ret

81117a5c <vFeeSpwRMAPLoadDefault>:



/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
81117a5c:	defffe04 	addi	sp,sp,-8
81117a60:	de00012e 	bgeu	sp,et,81117a68 <vFeeSpwRMAPLoadDefault+0xc>
81117a64:	003b68fa 	trap	3
81117a68:	df000115 	stw	fp,4(sp)
81117a6c:	df000104 	addi	fp,sp,4
81117a70:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
81117a74:	0001883a 	nop
81117a78:	e037883a 	mov	sp,fp
81117a7c:	df000017 	ldw	fp,0(sp)
81117a80:	dec00104 	addi	sp,sp,4
81117a84:	f800283a 	ret

81117a88 <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
81117a88:	defffe04 	addi	sp,sp,-8
81117a8c:	de00012e 	bgeu	sp,et,81117a94 <vFeeSpwRMAPChangeConfig+0xc>
81117a90:	003b68fa 	trap	3
81117a94:	df000115 	stw	fp,4(sp)
81117a98:	df000104 	addi	fp,sp,4
81117a9c:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
81117aa0:	0001883a 	nop
81117aa4:	e037883a 	mov	sp,fp
81117aa8:	df000017 	ldw	fp,0(sp)
81117aac:	dec00104 	addi	sp,sp,4
81117ab0:	f800283a 	ret

81117ab4 <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
81117ab4:	defffe04 	addi	sp,sp,-8
81117ab8:	de00012e 	bgeu	sp,et,81117ac0 <vFeeSpwRMAPChangeDefault+0xc>
81117abc:	003b68fa 	trap	3
81117ac0:	df000115 	stw	fp,4(sp)
81117ac4:	df000104 	addi	fp,sp,4
81117ac8:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
81117acc:	0001883a 	nop
81117ad0:	e037883a 	mov	sp,fp
81117ad4:	df000017 	ldw	fp,0(sp)
81117ad8:	dec00104 	addi	sp,sp,4
81117adc:	f800283a 	ret

81117ae0 <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
81117ae0:	defffe04 	addi	sp,sp,-8
81117ae4:	de00012e 	bgeu	sp,et,81117aec <cFeeSpwChannelEnable+0xc>
81117ae8:	003b68fa 	trap	3
81117aec:	df000115 	stw	fp,4(sp)
81117af0:	df000104 	addi	fp,sp,4
81117af4:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
81117af8:	0001883a 	nop
81117afc:	e037883a 	mov	sp,fp
81117b00:	df000017 	ldw	fp,0(sp)
81117b04:	dec00104 	addi	sp,sp,4
81117b08:	f800283a 	ret

81117b0c <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
81117b0c:	defffe04 	addi	sp,sp,-8
81117b10:	de00012e 	bgeu	sp,et,81117b18 <cFeeSpwChannelDisable+0xc>
81117b14:	003b68fa 	trap	3
81117b18:	df000115 	stw	fp,4(sp)
81117b1c:	df000104 	addi	fp,sp,4
81117b20:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
81117b24:	0001883a 	nop
81117b28:	e037883a 	mov	sp,fp
81117b2c:	df000017 	ldw	fp,0(sp)
81117b30:	dec00104 	addi	sp,sp,4
81117b34:	f800283a 	ret

81117b38 <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
81117b38:	defffe04 	addi	sp,sp,-8
81117b3c:	de00012e 	bgeu	sp,et,81117b44 <cFeeRMAPDump+0xc>
81117b40:	003b68fa 	trap	3
81117b44:	df000115 	stw	fp,4(sp)
81117b48:	df000104 	addi	fp,sp,4
81117b4c:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
81117b50:	0001883a 	nop
81117b54:	e037883a 	mov	sp,fp
81117b58:	df000017 	ldw	fp,0(sp)
81117b5c:	dec00104 	addi	sp,sp,4
81117b60:	f800283a 	ret

81117b64 <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
81117b64:	defffe04 	addi	sp,sp,-8
81117b68:	de00012e 	bgeu	sp,et,81117b70 <cFeeRMAPEchoingEnable+0xc>
81117b6c:	003b68fa 	trap	3
81117b70:	df000115 	stw	fp,4(sp)
81117b74:	df000104 	addi	fp,sp,4
81117b78:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
81117b7c:	e0bfff17 	ldw	r2,-4(fp)
81117b80:	00c00044 	movi	r3,1
81117b84:	10c02515 	stw	r3,148(r2)
}
81117b88:	0001883a 	nop
81117b8c:	e037883a 	mov	sp,fp
81117b90:	df000017 	ldw	fp,0(sp)
81117b94:	dec00104 	addi	sp,sp,4
81117b98:	f800283a 	ret

81117b9c <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
81117b9c:	defffe04 	addi	sp,sp,-8
81117ba0:	de00012e 	bgeu	sp,et,81117ba8 <cFeeRMAPEchoingDisable+0xc>
81117ba4:	003b68fa 	trap	3
81117ba8:	df000115 	stw	fp,4(sp)
81117bac:	df000104 	addi	fp,sp,4
81117bb0:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
81117bb4:	e0bfff17 	ldw	r2,-4(fp)
81117bb8:	10002515 	stw	zero,148(r2)
}
81117bbc:	0001883a 	nop
81117bc0:	e037883a 	mov	sp,fp
81117bc4:	df000017 	ldw	fp,0(sp)
81117bc8:	dec00104 	addi	sp,sp,4
81117bcc:	f800283a 	ret

81117bd0 <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
81117bd0:	defffe04 	addi	sp,sp,-8
81117bd4:	de00012e 	bgeu	sp,et,81117bdc <cFeeRMAPLogEnable+0xc>
81117bd8:	003b68fa 	trap	3
81117bdc:	df000115 	stw	fp,4(sp)
81117be0:	df000104 	addi	fp,sp,4
81117be4:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
81117be8:	e0bfff17 	ldw	r2,-4(fp)
81117bec:	00c00044 	movi	r3,1
81117bf0:	10c02415 	stw	r3,144(r2)
}
81117bf4:	0001883a 	nop
81117bf8:	e037883a 	mov	sp,fp
81117bfc:	df000017 	ldw	fp,0(sp)
81117c00:	dec00104 	addi	sp,sp,4
81117c04:	f800283a 	ret

81117c08 <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
81117c08:	defffe04 	addi	sp,sp,-8
81117c0c:	de00012e 	bgeu	sp,et,81117c14 <cFeeRMAPLogDisable+0xc>
81117c10:	003b68fa 	trap	3
81117c14:	df000115 	stw	fp,4(sp)
81117c18:	df000104 	addi	fp,sp,4
81117c1c:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
81117c20:	e0bfff17 	ldw	r2,-4(fp)
81117c24:	10002415 	stw	zero,144(r2)
}
81117c28:	0001883a 	nop
81117c2c:	e037883a 	mov	sp,fp
81117c30:	df000017 	ldw	fp,0(sp)
81117c34:	dec00104 	addi	sp,sp,4
81117c38:	f800283a 	ret

81117c3c <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
81117c3c:	defffc04 	addi	sp,sp,-16
81117c40:	de00012e 	bgeu	sp,et,81117c48 <vNFeeControlInit+0xc>
81117c44:	003b68fa 	trap	3
81117c48:	dfc00315 	stw	ra,12(sp)
81117c4c:	df000215 	stw	fp,8(sp)
81117c50:	df000204 	addi	fp,sp,8
81117c54:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
81117c58:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
81117c5c:	e13fff17 	ldw	r4,-4(fp)
81117c60:	1117d880 	call	81117d88 <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
81117c64:	e13fff17 	ldw	r4,-4(fp)
81117c68:	1117dbc0 	call	81117dbc <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebInit;
81117c6c:	e0bfff17 	ldw	r2,-4(fp)
81117c70:	10009a15 	stw	zero,616(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
81117c74:	e03ffe05 	stb	zero,-8(fp)
81117c78:	00002b06 	br	81117d28 <vNFeeControlInit+0xec>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
81117c7c:	e0bffe03 	ldbu	r2,-8(fp)
81117c80:	10809624 	muli	r2,r2,600
81117c84:	e0ffff17 	ldw	r3,-4(fp)
81117c88:	1885883a 	add	r2,r3,r2
81117c8c:	e0fffe03 	ldbu	r3,-8(fp)
81117c90:	180b883a 	mov	r5,r3
81117c94:	1009883a 	mov	r4,r2
81117c98:	11174a40 	call	811174a4 <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
81117c9c:	e0bffe03 	ldbu	r2,-8(fp)
81117ca0:	e0fffe03 	ldbu	r3,-8(fp)
81117ca4:	18c09624 	muli	r3,r3,600
81117ca8:	18c02104 	addi	r3,r3,132
81117cac:	e13fff17 	ldw	r4,-4(fp)
81117cb0:	20c7883a 	add	r3,r4,r3
81117cb4:	e13fff17 	ldw	r4,-4(fp)
81117cb8:	108025c4 	addi	r2,r2,151
81117cbc:	1085883a 	add	r2,r2,r2
81117cc0:	1085883a 	add	r2,r2,r2
81117cc4:	2085883a 	add	r2,r4,r2
81117cc8:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
81117ccc:	e0bffe03 	ldbu	r2,-8(fp)
81117cd0:	e0fffe03 	ldbu	r3,-8(fp)
81117cd4:	18c09624 	muli	r3,r3,600
81117cd8:	18c02704 	addi	r3,r3,156
81117cdc:	e13fff17 	ldw	r4,-4(fp)
81117ce0:	20c7883a 	add	r3,r4,r3
81117ce4:	e13fff17 	ldw	r4,-4(fp)
81117ce8:	10802604 	addi	r2,r2,152
81117cec:	1085883a 	add	r2,r2,r2
81117cf0:	1085883a 	add	r2,r2,r2
81117cf4:	2085883a 	add	r2,r4,r2
81117cf8:	10c00015 	stw	r3,0(r2)
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
81117cfc:	e0bffe03 	ldbu	r2,-8(fp)
81117d00:	e0ffff17 	ldw	r3,-4(fp)
81117d04:	18c09617 	ldw	r3,600(r3)
81117d08:	e13fff17 	ldw	r4,-4(fp)
81117d0c:	10809624 	muli	r2,r2,600
81117d10:	2085883a 	add	r2,r4,r2
81117d14:	10802904 	addi	r2,r2,164
81117d18:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebInit;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
81117d1c:	e0bffe03 	ldbu	r2,-8(fp)
81117d20:	10800044 	addi	r2,r2,1
81117d24:	e0bffe05 	stb	r2,-8(fp)
81117d28:	e0bffe03 	ldbu	r2,-8(fp)
81117d2c:	103fd326 	beq	r2,zero,81117c7c <__reset+0xfb0f7c7c>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
    }

}
81117d30:	0001883a 	nop
81117d34:	e037883a 	mov	sp,fp
81117d38:	dfc00117 	ldw	ra,4(sp)
81117d3c:	df000017 	ldw	fp,0(sp)
81117d40:	dec00204 	addi	sp,sp,8
81117d44:	f800283a 	ret

81117d48 <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
81117d48:	defffd04 	addi	sp,sp,-12
81117d4c:	de00012e 	bgeu	sp,et,81117d54 <vSetTimeCode+0xc>
81117d50:	003b68fa 	trap	3
81117d54:	df000215 	stw	fp,8(sp)
81117d58:	df000204 	addi	fp,sp,8
81117d5c:	e13ffe15 	stw	r4,-8(fp)
81117d60:	2805883a 	mov	r2,r5
81117d64:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
81117d68:	e0bffe17 	ldw	r2,-8(fp)
81117d6c:	e0ffff03 	ldbu	r3,-4(fp)
81117d70:	10c09905 	stb	r3,612(r2)
}
81117d74:	0001883a 	nop
81117d78:	e037883a 	mov	sp,fp
81117d7c:	df000017 	ldw	fp,0(sp)
81117d80:	dec00104 	addi	sp,sp,4
81117d84:	f800283a 	ret

81117d88 <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
81117d88:	defffe04 	addi	sp,sp,-8
81117d8c:	de00012e 	bgeu	sp,et,81117d94 <vResetTimeCode+0xc>
81117d90:	003b68fa 	trap	3
81117d94:	df000115 	stw	fp,4(sp)
81117d98:	df000104 	addi	fp,sp,4
81117d9c:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
81117da0:	e0bfff17 	ldw	r2,-4(fp)
81117da4:	10009905 	stb	zero,612(r2)
}
81117da8:	0001883a 	nop
81117dac:	e037883a 	mov	sp,fp
81117db0:	df000017 	ldw	fp,0(sp)
81117db4:	dec00104 	addi	sp,sp,4
81117db8:	f800283a 	ret

81117dbc <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
81117dbc:	defffe04 	addi	sp,sp,-8
81117dc0:	de00012e 	bgeu	sp,et,81117dc8 <vLoadDefaultIdNFEEMaster+0xc>
81117dc4:	003b68fa 	trap	3
81117dc8:	df000115 	stw	fp,4(sp)
81117dcc:	df000104 	addi	fp,sp,4
81117dd0:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
81117dd4:	e0bfff17 	ldw	r2,-4(fp)
81117dd8:	10009945 	stb	zero,613(r2)
}
81117ddc:	0001883a 	nop
81117de0:	e037883a 	mov	sp,fp
81117de4:	df000017 	ldw	fp,0(sp)
81117de8:	dec00104 	addi	sp,sp,4
81117dec:	f800283a 	ret

81117df0 <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
81117df0:	defffd04 	addi	sp,sp,-12
81117df4:	de00012e 	bgeu	sp,et,81117dfc <vChangeIdNFEEMaster+0xc>
81117df8:	003b68fa 	trap	3
81117dfc:	df000215 	stw	fp,8(sp)
81117e00:	df000204 	addi	fp,sp,8
81117e04:	e13ffe15 	stw	r4,-8(fp)
81117e08:	2805883a 	mov	r2,r5
81117e0c:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
81117e10:	e0bffe17 	ldw	r2,-8(fp)
81117e14:	e0ffff03 	ldbu	r3,-4(fp)
81117e18:	10c09945 	stb	r3,613(r2)
}
81117e1c:	0001883a 	nop
81117e20:	e037883a 	mov	sp,fp
81117e24:	df000017 	ldw	fp,0(sp)
81117e28:	dec00104 	addi	sp,sp,4
81117e2c:	f800283a 	ret

81117e30 <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
81117e30:	defffd04 	addi	sp,sp,-12
81117e34:	de00012e 	bgeu	sp,et,81117e3c <vChangeDefaultIdNFEEMaster+0xc>
81117e38:	003b68fa 	trap	3
81117e3c:	df000215 	stw	fp,8(sp)
81117e40:	df000204 	addi	fp,sp,8
81117e44:	e13ffe15 	stw	r4,-8(fp)
81117e48:	2805883a 	mov	r2,r5
81117e4c:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
81117e50:	0001883a 	nop
81117e54:	e037883a 	mov	sp,fp
81117e58:	df000017 	ldw	fp,0(sp)
81117e5c:	dec00104 	addi	sp,sp,4
81117e60:	f800283a 	ret

81117e64 <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
81117e64:	defffe04 	addi	sp,sp,-8
81117e68:	de00012e 	bgeu	sp,et,81117e70 <vInitSimucamBasicHW+0xc>
81117e6c:	003b68fa 	trap	3
81117e70:	dfc00115 	stw	ra,4(sp)
81117e74:	df000015 	stw	fp,0(sp)
81117e78:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
81117e7c:	01403fc4 	movi	r5,255
81117e80:	0009883a 	mov	r4,zero
81117e84:	11095280 	call	81109528 <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
81117e88:	01400834 	movhi	r5,32
81117e8c:	297fffc4 	addi	r5,r5,-1
81117e90:	0009883a 	mov	r4,zero
81117e94:	11095a80 	call	811095a8 <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
81117e98:	01400074 	movhi	r5,1
81117e9c:	01000044 	movi	r4,1
81117ea0:	11095a80 	call	811095a8 <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
81117ea4:	0009883a 	mov	r4,zero
81117ea8:	110aa8c0 	call	8110aa8c <bSSDisplayConfig>
	bSSDisplayUpdate(0);
81117eac:	0009883a 	mov	r4,zero
81117eb0:	110ab5c0 	call	8110ab5c <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
81117eb4:	01008004 	movi	r4,512
81117eb8:	110a63c0 	call	8110a63c <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
81117ebc:	01008004 	movi	r4,512
81117ec0:	110a5c80 	call	8110a5c8 <vRstcReleaseDeviceReset>

}
81117ec4:	0001883a 	nop
81117ec8:	e037883a 	mov	sp,fp
81117ecc:	dfc00117 	ldw	ra,4(sp)
81117ed0:	df000017 	ldw	fp,0(sp)
81117ed4:	dec00204 	addi	sp,sp,8
81117ed8:	f800283a 	ret

81117edc <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
81117edc:	defffd04 	addi	sp,sp,-12
81117ee0:	de00012e 	bgeu	sp,et,81117ee8 <bLogWriteSDCard+0xc>
81117ee4:	003b68fa 	trap	3
81117ee8:	df000215 	stw	fp,8(sp)
81117eec:	df000204 	addi	fp,sp,8
81117ef0:	e13ffe15 	stw	r4,-8(fp)
81117ef4:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
81117ef8:	00800044 	movi	r2,1
}
81117efc:	e037883a 	mov	sp,fp
81117f00:	df000017 	ldw	fp,0(sp)
81117f04:	dec00104 	addi	sp,sp,4
81117f08:	f800283a 	ret

81117f0c <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
81117f0c:	deffe004 	addi	sp,sp,-128
81117f10:	de00012e 	bgeu	sp,et,81117f18 <vLogWriteNUC+0xc>
81117f14:	003b68fa 	trap	3
81117f18:	dfc01f15 	stw	ra,124(sp)
81117f1c:	df001e15 	stw	fp,120(sp)
81117f20:	df001e04 	addi	fp,sp,120
81117f24:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
81117f28:	e03fe215 	stw	zero,-120(fp)
81117f2c:	e0bfe304 	addi	r2,fp,-116
81117f30:	00c01b84 	movi	r3,110
81117f34:	180d883a 	mov	r6,r3
81117f38:	000b883a 	mov	r5,zero
81117f3c:	1009883a 	mov	r4,r2
81117f40:	111acfc0 	call	8111acfc <memset>
	memset(cTemp,0,114);
81117f44:	01801c84 	movi	r6,114
81117f48:	000b883a 	mov	r5,zero
81117f4c:	e13fe204 	addi	r4,fp,-120
81117f50:	111acfc0 	call	8111acfc <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
81117f54:	e13fff17 	ldw	r4,-4(fp)
81117f58:	111b1180 	call	8111b118 <strlen>
81117f5c:	10801c68 	cmpgeui	r2,r2,113
81117f60:	1000031e 	bne	r2,zero,81117f70 <vLogWriteNUC+0x64>
81117f64:	e13fff17 	ldw	r4,-4(fp)
81117f68:	111b1180 	call	8111b118 <strlen>
81117f6c:	00000106 	br	81117f74 <vLogWriteNUC+0x68>
81117f70:	00801c44 	movi	r2,113
81117f74:	100d883a 	mov	r6,r2
81117f78:	e17fff17 	ldw	r5,-4(fp)
81117f7c:	e13fe204 	addi	r4,fp,-120
81117f80:	111abac0 	call	8111abac <memcpy>
	vSendLog ( cDataIn );
81117f84:	e13fff17 	ldw	r4,-4(fp)
81117f88:	11146580 	call	81114658 <vSendLog>
}
81117f8c:	0001883a 	nop
81117f90:	e037883a 	mov	sp,fp
81117f94:	dfc00117 	ldw	ra,4(sp)
81117f98:	df000017 	ldw	fp,0(sp)
81117f9c:	dec00204 	addi	sp,sp,8
81117fa0:	f800283a 	ret

81117fa4 <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
81117fa4:	defffd04 	addi	sp,sp,-12
81117fa8:	de00012e 	bgeu	sp,et,81117fb0 <vSimucamStructureInit+0xc>
81117fac:	003b68fa 	trap	3
81117fb0:	dfc00215 	stw	ra,8(sp)
81117fb4:	df000115 	stw	fp,4(sp)
81117fb8:	df000104 	addi	fp,sp,4
81117fbc:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
81117fc0:	e0bfff17 	ldw	r2,-4(fp)
81117fc4:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebInit;
81117fc8:	e0bfff17 	ldw	r2,-4(fp)
81117fcc:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
81117fd0:	e13fff17 	ldw	r4,-4(fp)
81117fd4:	11180900 	call	81118090 <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
81117fd8:	e13fff17 	ldw	r4,-4(fp)
81117fdc:	11181340 	call	81118134 <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
81117fe0:	e13fff17 	ldw	r4,-4(fp)
81117fe4:	11181dc0 	call	811181dc <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
81117fe8:	e13fff17 	ldw	r4,-4(fp)
81117fec:	111827c0 	call	8111827c <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
81117ff0:	e0bfff17 	ldw	r2,-4(fp)
81117ff4:	10000615 	stw	zero,24(r2)
    xMeb->fPixelTransferTime = 0;
81117ff8:	e0bfff17 	ldw	r2,-4(fp)
81117ffc:	10000715 	stw	zero,28(r2)
    xMeb->usiDelaySyncReset = 500; /* milliseconds */
81118000:	e0bfff17 	ldw	r2,-4(fp)
81118004:	00c07d04 	movi	r3,500
81118008:	10c0050d 	sth	r3,20(r2)

    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
8111800c:	e0bfff17 	ldw	r2,-4(fp)
81118010:	10000205 	stb	zero,8(r2)
    xMeb->ucNextDDR = 1;
81118014:	e0bfff17 	ldw	r2,-4(fp)
81118018:	00c00044 	movi	r3,1
8111801c:	10c00245 	stb	r3,9(r2)

    xMeb->xFeeControl.pActualMem = &xMeb->ucActualDDR;
81118020:	e0bfff17 	ldw	r2,-4(fp)
81118024:	10c00204 	addi	r3,r2,8
81118028:	e0bfff17 	ldw	r2,-4(fp)
8111802c:	10c0a815 	stw	r3,672(r2)
    xMeb->xDataControl.pNextMem = &xMeb->ucNextDDR;
81118030:	e0bfff17 	ldw	r2,-4(fp)
81118034:	10c00244 	addi	r3,r2,9
81118038:	e0bfff17 	ldw	r2,-4(fp)
8111803c:	10c01115 	stw	r3,68(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
81118040:	e0bfff17 	ldw	r2,-4(fp)
81118044:	10800017 	ldw	r2,0(r2)
81118048:	10000b1e 	bne	r2,zero,81118078 <vSimucamStructureInit+0xd4>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
8111804c:	e0bfff17 	ldw	r2,-4(fp)
81118050:	10801204 	addi	r2,r2,72
81118054:	1009883a 	mov	r4,r2
81118058:	1117c3c0 	call	81117c3c <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
8111805c:	e0bfff17 	ldw	r2,-4(fp)
81118060:	10c00a04 	addi	r3,r2,40
81118064:	e0bfff17 	ldw	r2,-4(fp)
81118068:	10801204 	addi	r2,r2,72
8111806c:	100b883a 	mov	r5,r2
81118070:	1809883a 	mov	r4,r3
81118074:	11165880 	call	81116588 <vDataControllerInit>


    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */


}
81118078:	0001883a 	nop
8111807c:	e037883a 	mov	sp,fp
81118080:	dfc00117 	ldw	ra,4(sp)
81118084:	df000017 	ldw	fp,0(sp)
81118088:	dec00204 	addi	sp,sp,8
8111808c:	f800283a 	ret

81118090 <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
81118090:	defffe04 	addi	sp,sp,-8
81118094:	de00012e 	bgeu	sp,et,8111809c <vLoadDefaultEPValue+0xc>
81118098:	003b68fa 	trap	3
8111809c:	df000115 	stw	fp,4(sp)
811180a0:	df000104 	addi	fp,sp,4
811180a4:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
811180a8:	e0bfff17 	ldw	r2,-4(fp)
811180ac:	00d07234 	movhi	r3,16840
811180b0:	10c00315 	stw	r3,12(r2)
}
811180b4:	0001883a 	nop
811180b8:	e037883a 	mov	sp,fp
811180bc:	df000017 	ldw	fp,0(sp)
811180c0:	dec00104 	addi	sp,sp,4
811180c4:	f800283a 	ret

811180c8 <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
811180c8:	defffd04 	addi	sp,sp,-12
811180cc:	de00012e 	bgeu	sp,et,811180d4 <vChangeEPValue+0xc>
811180d0:	003b68fa 	trap	3
811180d4:	df000215 	stw	fp,8(sp)
811180d8:	df000204 	addi	fp,sp,8
811180dc:	e13ffe15 	stw	r4,-8(fp)
811180e0:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
811180e4:	e0bffe17 	ldw	r2,-8(fp)
811180e8:	e0ffff17 	ldw	r3,-4(fp)
811180ec:	10c00315 	stw	r3,12(r2)
}
811180f0:	0001883a 	nop
811180f4:	e037883a 	mov	sp,fp
811180f8:	df000017 	ldw	fp,0(sp)
811180fc:	dec00104 	addi	sp,sp,4
81118100:	f800283a 	ret

81118104 <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
81118104:	defffd04 	addi	sp,sp,-12
81118108:	de00012e 	bgeu	sp,et,81118110 <vChangeDefaultEPValue+0xc>
8111810c:	003b68fa 	trap	3
81118110:	df000215 	stw	fp,8(sp)
81118114:	df000204 	addi	fp,sp,8
81118118:	e13ffe15 	stw	r4,-8(fp)
8111811c:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
81118120:	0001883a 	nop
81118124:	e037883a 	mov	sp,fp
81118128:	df000017 	ldw	fp,0(sp)
8111812c:	dec00104 	addi	sp,sp,4
81118130:	f800283a 	ret

81118134 <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
81118134:	defffe04 	addi	sp,sp,-8
81118138:	de00012e 	bgeu	sp,et,81118140 <vLoadDefaultRTValue+0xc>
8111813c:	003b68fa 	trap	3
81118140:	df000115 	stw	fp,4(sp)
81118144:	df000104 	addi	fp,sp,4
81118148:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
8111814c:	e0ffff17 	ldw	r3,-4(fp)
81118150:	00901eb4 	movhi	r2,16506
81118154:	10a66684 	addi	r2,r2,-26214
81118158:	18800415 	stw	r2,16(r3)
}
8111815c:	0001883a 	nop
81118160:	e037883a 	mov	sp,fp
81118164:	df000017 	ldw	fp,0(sp)
81118168:	dec00104 	addi	sp,sp,4
8111816c:	f800283a 	ret

81118170 <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
81118170:	defffd04 	addi	sp,sp,-12
81118174:	de00012e 	bgeu	sp,et,8111817c <vChangeRTValue+0xc>
81118178:	003b68fa 	trap	3
8111817c:	df000215 	stw	fp,8(sp)
81118180:	df000204 	addi	fp,sp,8
81118184:	e13ffe15 	stw	r4,-8(fp)
81118188:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
8111818c:	e0bffe17 	ldw	r2,-8(fp)
81118190:	e0ffff17 	ldw	r3,-4(fp)
81118194:	10c00415 	stw	r3,16(r2)
}
81118198:	0001883a 	nop
8111819c:	e037883a 	mov	sp,fp
811181a0:	df000017 	ldw	fp,0(sp)
811181a4:	dec00104 	addi	sp,sp,4
811181a8:	f800283a 	ret

811181ac <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
811181ac:	defffd04 	addi	sp,sp,-12
811181b0:	de00012e 	bgeu	sp,et,811181b8 <vChangeDefaultRTValue+0xc>
811181b4:	003b68fa 	trap	3
811181b8:	df000215 	stw	fp,8(sp)
811181bc:	df000204 	addi	fp,sp,8
811181c0:	e13ffe15 	stw	r4,-8(fp)
811181c4:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
811181c8:	0001883a 	nop
811181cc:	e037883a 	mov	sp,fp
811181d0:	df000017 	ldw	fp,0(sp)
811181d4:	dec00104 	addi	sp,sp,4
811181d8:	f800283a 	ret

811181dc <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
811181dc:	defffe04 	addi	sp,sp,-8
811181e0:	de00012e 	bgeu	sp,et,811181e8 <vLoadDefaultSyncSource+0xc>
811181e4:	003b68fa 	trap	3
811181e8:	df000115 	stw	fp,4(sp)
811181ec:	df000104 	addi	fp,sp,4
811181f0:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
811181f4:	e0bfff17 	ldw	r2,-4(fp)
811181f8:	10000815 	stw	zero,32(r2)
}
811181fc:	0001883a 	nop
81118200:	e037883a 	mov	sp,fp
81118204:	df000017 	ldw	fp,0(sp)
81118208:	dec00104 	addi	sp,sp,4
8111820c:	f800283a 	ret

81118210 <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
81118210:	defffd04 	addi	sp,sp,-12
81118214:	de00012e 	bgeu	sp,et,8111821c <vChangeSyncSource+0xc>
81118218:	003b68fa 	trap	3
8111821c:	df000215 	stw	fp,8(sp)
81118220:	df000204 	addi	fp,sp,8
81118224:	e13ffe15 	stw	r4,-8(fp)
81118228:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
8111822c:	e0bffe17 	ldw	r2,-8(fp)
81118230:	e0ffff17 	ldw	r3,-4(fp)
81118234:	10c00815 	stw	r3,32(r2)
}
81118238:	0001883a 	nop
8111823c:	e037883a 	mov	sp,fp
81118240:	df000017 	ldw	fp,0(sp)
81118244:	dec00104 	addi	sp,sp,4
81118248:	f800283a 	ret

8111824c <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111824c:	defffd04 	addi	sp,sp,-12
81118250:	de00012e 	bgeu	sp,et,81118258 <vChangeDefaultSyncSource+0xc>
81118254:	003b68fa 	trap	3
81118258:	df000215 	stw	fp,8(sp)
8111825c:	df000204 	addi	fp,sp,8
81118260:	e13ffe15 	stw	r4,-8(fp)
81118264:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
81118268:	0001883a 	nop
8111826c:	e037883a 	mov	sp,fp
81118270:	df000017 	ldw	fp,0(sp)
81118274:	dec00104 	addi	sp,sp,4
81118278:	f800283a 	ret

8111827c <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
8111827c:	defffe04 	addi	sp,sp,-8
81118280:	de00012e 	bgeu	sp,et,81118288 <vLoadDefaultAutoResetSync+0xc>
81118284:	003b68fa 	trap	3
81118288:	df000115 	stw	fp,4(sp)
8111828c:	df000104 	addi	fp,sp,4
81118290:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoResetSyncMode = TRUE;
81118294:	e0bfff17 	ldw	r2,-4(fp)
81118298:	00c00044 	movi	r3,1
8111829c:	10c00915 	stw	r3,36(r2)
}
811182a0:	0001883a 	nop
811182a4:	e037883a 	mov	sp,fp
811182a8:	df000017 	ldw	fp,0(sp)
811182ac:	dec00104 	addi	sp,sp,4
811182b0:	f800283a 	ret

811182b4 <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
811182b4:	defffd04 	addi	sp,sp,-12
811182b8:	de00012e 	bgeu	sp,et,811182c0 <vChangeAutoResetSync+0xc>
811182bc:	003b68fa 	trap	3
811182c0:	df000215 	stw	fp,8(sp)
811182c4:	df000204 	addi	fp,sp,8
811182c8:	e13ffe15 	stw	r4,-8(fp)
811182cc:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoResetSyncMode = bAutoReset;
811182d0:	e0bffe17 	ldw	r2,-8(fp)
811182d4:	e0ffff17 	ldw	r3,-4(fp)
811182d8:	10c00915 	stw	r3,36(r2)
}
811182dc:	0001883a 	nop
811182e0:	e037883a 	mov	sp,fp
811182e4:	df000017 	ldw	fp,0(sp)
811182e8:	dec00104 	addi	sp,sp,4
811182ec:	f800283a 	ret

811182f0 <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
811182f0:	defffd04 	addi	sp,sp,-12
811182f4:	de00012e 	bgeu	sp,et,811182fc <vChangeDefaultAutoResetSync+0xc>
811182f8:	003b68fa 	trap	3
811182fc:	df000215 	stw	fp,8(sp)
81118300:	df000204 	addi	fp,sp,8
81118304:	e13ffe15 	stw	r4,-8(fp)
81118308:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
8111830c:	0001883a 	nop
81118310:	e037883a 	mov	sp,fp
81118314:	df000017 	ldw	fp,0(sp)
81118318:	dec00104 	addi	sp,sp,4
8111831c:	f800283a 	ret

81118320 <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
81118320:	defffc04 	addi	sp,sp,-16
81118324:	de00012e 	bgeu	sp,et,8111832c <vSyncReset+0xc>
81118328:	003b68fa 	trap	3
8111832c:	dfc00315 	stw	ra,12(sp)
81118330:	df000215 	stw	fp,8(sp)
81118334:	df000204 	addi	fp,sp,8
81118338:	e13ffe15 	stw	r4,-8(fp)
8111833c:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
81118340:	e0bffe17 	ldw	r2,-8(fp)
81118344:	10801204 	addi	r2,r2,72
81118348:	1009883a 	mov	r4,r2
8111834c:	1117d880 	call	81117d88 <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
81118350:	0001883a 	nop
81118354:	e037883a 	mov	sp,fp
81118358:	dfc00117 	ldw	ra,4(sp)
8111835c:	df000017 	ldw	fp,0(sp)
81118360:	dec00204 	addi	sp,sp,8
81118364:	f800283a 	ret

81118368 <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
81118368:	defff004 	addi	sp,sp,-64
8111836c:	de00012e 	bgeu	sp,et,81118374 <pattern_createPattern+0xc>
81118370:	003b68fa 	trap	3
81118374:	dfc00f15 	stw	ra,60(sp)
81118378:	df000e15 	stw	fp,56(sp)
8111837c:	dcc00d15 	stw	r19,52(sp)
81118380:	dc800c15 	stw	r18,48(sp)
81118384:	dc400b15 	stw	r17,44(sp)
81118388:	dc000a15 	stw	r16,40(sp)
8111838c:	df000e04 	addi	fp,sp,56
81118390:	e17ff915 	stw	r5,-28(fp)
81118394:	3007883a 	mov	r3,r6
81118398:	3805883a 	mov	r2,r7
8111839c:	e13ff805 	stb	r4,-32(fp)
811183a0:	e0fffa05 	stb	r3,-24(fp)
811183a4:	e0bffb05 	stb	r2,-20(fp)
	unsigned long long a0;
	unsigned long long a1;

	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
811183a8:	e0bff803 	ldbu	r2,-32(fp)
811183ac:	1009883a 	mov	r4,r2
811183b0:	11005bc0 	call	811005bc <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
811183b4:	e0bff917 	ldw	r2,-28(fp)
811183b8:	e0bff215 	stw	r2,-56(fp)
	alt_u8 i = 0;
811183bc:	e03ff305 	stb	zero,-52(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
811183c0:	e0bff217 	ldw	r2,-56(fp)
811183c4:	e0bff415 	stw	r2,-48(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
811183c8:	e03ff515 	stw	zero,-44(fp)
811183cc:	00003606 	br	811184a8 <pattern_createPattern+0x140>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
811183d0:	e03ff615 	stw	zero,-40(fp)
811183d4:	00002e06 	br	81118490 <pattern_createPattern+0x128>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
811183d8:	e0bff303 	ldbu	r2,-52(fp)
811183dc:	10801018 	cmpnei	r2,r2,64
811183e0:	10000b1e 	bne	r2,zero,81118410 <pattern_createPattern+0xa8>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
811183e4:	e0bff417 	ldw	r2,-48(fp)
811183e8:	00ffffc4 	movi	r3,-1
811183ec:	10c02015 	stw	r3,128(r2)
811183f0:	00ffffc4 	movi	r3,-1
811183f4:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
811183f8:	e0bff217 	ldw	r2,-56(fp)
811183fc:	10802204 	addi	r2,r2,136
81118400:	e0bff215 	stw	r2,-56(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
81118404:	e0bff217 	ldw	r2,-56(fp)
81118408:	e0bff415 	stw	r2,-48(fp)
				i = 0;
8111840c:	e03ff305 	stb	zero,-52(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
81118410:	e0bff303 	ldbu	r2,-52(fp)
81118414:	10c00044 	addi	r3,r2,1
81118418:	e0fff305 	stb	r3,-52(fp)
8111841c:	10803fcc 	andi	r2,r2,255
81118420:	e0fffa03 	ldbu	r3,-24(fp)
81118424:	18c000cc 	andi	r3,r3,3
81118428:	180692fa 	slli	r3,r3,11
8111842c:	1809883a 	mov	r4,r3
81118430:	00f80004 	movi	r3,-8192
81118434:	20c6b03a 	or	r3,r4,r3
81118438:	1809883a 	mov	r4,r3
8111843c:	e0fffb03 	ldbu	r3,-20(fp)
81118440:	18c0004c 	andi	r3,r3,1
81118444:	180692ba 	slli	r3,r3,10
81118448:	20c6b03a 	or	r3,r4,r3
8111844c:	1809883a 	mov	r4,r3
81118450:	e0fff517 	ldw	r3,-44(fp)
81118454:	18c007cc 	andi	r3,r3,31
81118458:	1806917a 	slli	r3,r3,5
8111845c:	20c6b03a 	or	r3,r4,r3
81118460:	1809883a 	mov	r4,r3
81118464:	e0fff617 	ldw	r3,-40(fp)
81118468:	18c007cc 	andi	r3,r3,31
8111846c:	20c6b03a 	or	r3,r4,r3
81118470:	1809883a 	mov	r4,r3
81118474:	e0fff417 	ldw	r3,-48(fp)
81118478:	1085883a 	add	r2,r2,r2
8111847c:	1885883a 	add	r2,r3,r2
81118480:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
81118484:	e0bff617 	ldw	r2,-40(fp)
81118488:	10800044 	addi	r2,r2,1
8111848c:	e0bff615 	stw	r2,-40(fp)
81118490:	e0fff617 	ldw	r3,-40(fp)
81118494:	e0800217 	ldw	r2,8(fp)
81118498:	18bfcf36 	bltu	r3,r2,811183d8 <__reset+0xfb0f83d8>

	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111849c:	e0bff517 	ldw	r2,-44(fp)
811184a0:	10800044 	addi	r2,r2,1
811184a4:	e0bff515 	stw	r2,-44(fp)
811184a8:	e0fff517 	ldw	r3,-44(fp)
811184ac:	e0800317 	ldw	r2,12(fp)
811184b0:	18bfc736 	bltu	r3,r2,811183d0 <__reset+0xfb0f83d0>
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
			//pxPixelData->usiPixel[i++] = 0xFFFF;
		}
	}
	//pxPixelData->ulliMask = xSimMeb.xFeeControl.xNfee[0].xMemMap.xCommon.ucPaddingMask.ullWord;
	pxPixelData->ulliMask = 0;
811184b4:	e0bff417 	ldw	r2,-48(fp)
811184b8:	10002015 	stw	zero,128(r2)
811184bc:	10002115 	stw	zero,132(r2)
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
811184c0:	e03ff705 	stb	zero,-36(fp)
811184c4:	00001c06 	br	81118538 <pattern_createPattern+0x1d0>
	{
		pxPixelData->ulliMask |= 0x8000000000000000 >> j;
811184c8:	e13ff417 	ldw	r4,-48(fp)
811184cc:	20802017 	ldw	r2,128(r4)
811184d0:	20c02117 	ldw	r3,132(r4)
811184d4:	e13ff703 	ldbu	r4,-36(fp)
811184d8:	217ff804 	addi	r5,r4,-32
811184dc:	28000416 	blt	r5,zero,811184f0 <pattern_createPattern+0x188>
811184e0:	01200034 	movhi	r4,32768
811184e4:	2160d83a 	srl	r16,r4,r5
811184e8:	0023883a 	mov	r17,zero
811184ec:	00000a06 	br	81118518 <pattern_createPattern+0x1b0>
811184f0:	01600034 	movhi	r5,32768
811184f4:	280c907a 	slli	r6,r5,1
811184f8:	014007c4 	movi	r5,31
811184fc:	290bc83a 	sub	r5,r5,r4
81118500:	314a983a 	sll	r5,r6,r5
81118504:	000d883a 	mov	r6,zero
81118508:	3120d83a 	srl	r16,r6,r4
8111850c:	2c20b03a 	or	r16,r5,r16
81118510:	01600034 	movhi	r5,32768
81118514:	2922d83a 	srl	r17,r5,r4
81118518:	1424b03a 	or	r18,r2,r16
8111851c:	1c66b03a 	or	r19,r3,r17
81118520:	e0bff417 	ldw	r2,-48(fp)
81118524:	14802015 	stw	r18,128(r2)
81118528:	14c02115 	stw	r19,132(r2)
			//pxPixelData->usiPixel[i++] = 0xFFFF;
		}
	}
	//pxPixelData->ulliMask = xSimMeb.xFeeControl.xNfee[0].xMemMap.xCommon.ucPaddingMask.ullWord;
	pxPixelData->ulliMask = 0;
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111852c:	e0bff703 	ldbu	r2,-36(fp)
81118530:	10800044 	addi	r2,r2,1
81118534:	e0bff705 	stb	r2,-36(fp)
81118538:	e0fff703 	ldbu	r3,-36(fp)
8111853c:	e0bff303 	ldbu	r2,-52(fp)
81118540:	18bfe136 	bltu	r3,r2,811184c8 <__reset+0xfb0f84c8>
		pxPixelData->ulliMask |= 0x8000000000000000 >> j;
	}



	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
81118544:	e0bff217 	ldw	r2,-56(fp)
81118548:	10802204 	addi	r2,r2,136
8111854c:	e0bff215 	stw	r2,-56(fp)
	return offset;
81118550:	e0bff217 	ldw	r2,-56(fp)
}
81118554:	e6fffc04 	addi	sp,fp,-16
81118558:	dfc00517 	ldw	ra,20(sp)
8111855c:	df000417 	ldw	fp,16(sp)
81118560:	dcc00317 	ldw	r19,12(sp)
81118564:	dc800217 	ldw	r18,8(sp)
81118568:	dc400117 	ldw	r17,4(sp)
8111856c:	dc000017 	ldw	r16,0(sp)
81118570:	dec00604 	addi	sp,sp,24
81118574:	f800283a 	ret

81118578 <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
81118578:	defffe04 	addi	sp,sp,-8
8111857c:	de00012e 	bgeu	sp,et,81118584 <bSDcardIsPresent+0xc>
81118580:	003b68fa 	trap	3
81118584:	dfc00115 	stw	ra,4(sp)
81118588:	df000015 	stw	fp,0(sp)
8111858c:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
81118590:	113d9b80 	call	8113d9b8 <alt_up_sd_card_is_Present>
}
81118594:	e037883a 	mov	sp,fp
81118598:	dfc00117 	ldw	ra,4(sp)
8111859c:	df000017 	ldw	fp,0(sp)
811185a0:	dec00204 	addi	sp,sp,8
811185a4:	f800283a 	ret

811185a8 <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
811185a8:	defffe04 	addi	sp,sp,-8
811185ac:	de00012e 	bgeu	sp,et,811185b4 <bSDcardFAT16Check+0xc>
811185b0:	003b68fa 	trap	3
811185b4:	dfc00115 	stw	ra,4(sp)
811185b8:	df000015 	stw	fp,0(sp)
811185bc:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
811185c0:	113da840 	call	8113da84 <alt_up_sd_card_is_FAT16>
}
811185c4:	e037883a 	mov	sp,fp
811185c8:	dfc00117 	ldw	ra,4(sp)
811185cc:	df000017 	ldw	fp,0(sp)
811185d0:	dec00204 	addi	sp,sp,8
811185d4:	f800283a 	ret

811185d8 <bInitializeSDCard>:

bool bInitializeSDCard( void ){
811185d8:	defffd04 	addi	sp,sp,-12
811185dc:	de00012e 	bgeu	sp,et,811185e4 <bInitializeSDCard+0xc>
811185e0:	003b68fa 	trap	3
811185e4:	dfc00215 	stw	ra,8(sp)
811185e8:	df000115 	stw	fp,4(sp)
811185ec:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
811185f0:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
811185f4:	d0207615 	stw	zero,-32296(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
811185f8:	01204534 	movhi	r4,33044
811185fc:	21134a04 	addi	r4,r4,19752
81118600:	113d8f40 	call	8113d8f4 <alt_up_sd_card_open_dev>
81118604:	d0a07615 	stw	r2,-32296(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
81118608:	d0a07617 	ldw	r2,-32296(gp)
8111860c:	10000b26 	beq	r2,zero,8111863c <bInitializeSDCard+0x64>

		bSucess = bSDcardIsPresent();
81118610:	11185780 	call	81118578 <bSDcardIsPresent>
81118614:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
81118618:	e0bfff17 	ldw	r2,-4(fp)
8111861c:	10000826 	beq	r2,zero,81118640 <bInitializeSDCard+0x68>
			bSucess = bSDcardFAT16Check();
81118620:	11185a80 	call	811185a8 <bSDcardFAT16Check>
81118624:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
81118628:	e0bfff17 	ldw	r2,-4(fp)
8111862c:	10000426 	beq	r2,zero,81118640 <bInitializeSDCard+0x68>
				xSdHandle.connected = TRUE;
81118630:	00800044 	movi	r2,1
81118634:	d0a07515 	stw	r2,-32300(gp)
81118638:	00000106 	br	81118640 <bInitializeSDCard+0x68>
#endif
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
8111863c:	e03fff15 	stw	zero,-4(fp)
#if DEBUG_ON
		debug(fp, "Unable to open the SDCard device.\r\n");
#endif
	}

	return bSucess;
81118640:	e0bfff17 	ldw	r2,-4(fp)
}
81118644:	e037883a 	mov	sp,fp
81118648:	dfc00117 	ldw	ra,4(sp)
8111864c:	df000017 	ldw	fp,0(sp)
81118650:	dec00204 	addi	sp,sp,8
81118654:	f800283a 	ret

81118658 <siOpenFile>:
	}
	return (char)readCharacter;
}
*/

short int siOpenFile( char *filename ) {
81118658:	defffd04 	addi	sp,sp,-12
8111865c:	de00012e 	bgeu	sp,et,81118664 <siOpenFile+0xc>
81118660:	003b68fa 	trap	3
81118664:	dfc00215 	stw	ra,8(sp)
81118668:	df000115 	stw	fp,4(sp)
8111866c:	df000104 	addi	fp,sp,4
81118670:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
81118674:	000b883a 	mov	r5,zero
81118678:	e13fff17 	ldw	r4,-4(fp)
8111867c:	113df900 	call	8113df90 <alt_up_sd_card_fopen>
}
81118680:	e037883a 	mov	sp,fp
81118684:	dfc00117 	ldw	ra,4(sp)
81118688:	df000017 	ldw	fp,0(sp)
8111868c:	dec00204 	addi	sp,sp,8
81118690:	f800283a 	ret

81118694 <siCloseFile>:

bool siCloseFile( short int file_handle ) {
81118694:	defffd04 	addi	sp,sp,-12
81118698:	de00012e 	bgeu	sp,et,811186a0 <siCloseFile+0xc>
8111869c:	003b68fa 	trap	3
811186a0:	dfc00215 	stw	ra,8(sp)
811186a4:	df000115 	stw	fp,4(sp)
811186a8:	df000104 	addi	fp,sp,4
811186ac:	2005883a 	mov	r2,r4
811186b0:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
811186b4:	e0bfff0f 	ldh	r2,-4(fp)
811186b8:	1009883a 	mov	r4,r2
811186bc:	113eddc0 	call	8113eddc <alt_up_sd_card_fclose>
}
811186c0:	e037883a 	mov	sp,fp
811186c4:	dfc00117 	ldw	ra,4(sp)
811186c8:	df000017 	ldw	fp,0(sp)
811186cc:	dec00204 	addi	sp,sp,8
811186d0:	f800283a 	ret

811186d4 <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
811186d4:	defffd04 	addi	sp,sp,-12
811186d8:	de00012e 	bgeu	sp,et,811186e0 <cGetNextChar+0xc>
811186dc:	003b68fa 	trap	3
811186e0:	dfc00215 	stw	ra,8(sp)
811186e4:	df000115 	stw	fp,4(sp)
811186e8:	df000104 	addi	fp,sp,4
811186ec:	2005883a 	mov	r2,r4
811186f0:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
811186f4:	e0bfff0f 	ldh	r2,-4(fp)
811186f8:	1009883a 	mov	r4,r2
811186fc:	113e4340 	call	8113e434 <alt_up_sd_card_read>
}
81118700:	e037883a 	mov	sp,fp
81118704:	dfc00117 	ldw	ra,4(sp)
81118708:	df000017 	ldw	fp,0(sp)
8111870c:	dec00204 	addi	sp,sp,8
81118710:	f800283a 	ret

81118714 <bInitSync>:

#include "sync_handler.h"

/* todo: Create a struct that will contain all config, and pass as parameter to the functions */

bool bInitSync( void ) {
81118714:	defffc04 	addi	sp,sp,-16
81118718:	de00012e 	bgeu	sp,et,81118720 <bInitSync+0xc>
8111871c:	003b68fa 	trap	3
81118720:	dfc00315 	stw	ra,12(sp)
81118724:	df000215 	stw	fp,8(sp)
81118728:	df000204 	addi	fp,sp,8
	bool	bSuccess;
	alt_u32	aux_32;

	vSyncInitIrq();
8111872c:	110ace00 	call	8110ace0 <vSyncInitIrq>
		debug(fp, "Initializing Sync Module.\n");
	#endif

	// Configura um padro de sync interno
	// MBT => 400 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetMbt(MBT);
81118730:	01004c74 	movhi	r4,305
81118734:	210b4004 	addi	r4,r4,11520
81118738:	110aee80 	call	8110aee8 <bSyncSetMbt>
8111873c:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81118740:	e0bffe17 	ldw	r2,-8(fp)
81118744:	1000021e 	bne	r2,zero,81118750 <bInitSync+0x3c>
		#if DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
		#endif
		return bSuccess;
81118748:	e0bffe17 	ldw	r2,-8(fp)
8111874c:	00004e06 	br	81118888 <bInitSync+0x174>
	}

	// BT => 200 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetBt(BT);
81118750:	01002674 	movhi	r4,153
81118754:	2125a004 	addi	r4,r4,-27008
81118758:	110af280 	call	8110af28 <bSyncSetBt>
8111875c:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81118760:	e0bffe17 	ldw	r2,-8(fp)
81118764:	1000021e 	bne	r2,zero,81118770 <bInitSync+0x5c>
		#if DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
		#endif
		return bSuccess;
81118768:	e0bffe17 	ldw	r2,-8(fp)
8111876c:	00004606 	br	81118888 <bInitSync+0x174>
	}

	// PER => 6,25s @ 20 ns (50 MHz)
	bSuccess = bSyncSetPer(  uliPerCalcPeriodMs( xDefaults.usiSyncPeriod ) );
81118770:	00a045b4 	movhi	r2,33046
81118774:	10acbf04 	addi	r2,r2,-19716
81118778:	1080068b 	ldhu	r2,26(r2)
8111877c:	10bfffcc 	andi	r2,r2,65535
81118780:	1009883a 	mov	r4,r2
81118784:	110bbc00 	call	8110bbc0 <uliPerCalcPeriodMs>
81118788:	1009883a 	mov	r4,r2
8111878c:	110af680 	call	8110af68 <bSyncSetPer>
81118790:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81118794:	e0bffe17 	ldw	r2,-8(fp)
81118798:	1000021e 	bne	r2,zero,811187a4 <bInitSync+0x90>
		#if DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
		#endif
		return bSuccess;
8111879c:	e0bffe17 	ldw	r2,-8(fp)
811187a0:	00003906 	br	81118888 <bInitSync+0x174>
	}

	// OST => 500 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetOst(OST);
811187a4:	01005f74 	movhi	r4,381
811187a8:	211e1004 	addi	r4,r4,30784
811187ac:	110afa80 	call	8110afa8 <bSyncSetOst>
811187b0:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
811187b4:	e0bffe17 	ldw	r2,-8(fp)
811187b8:	1000021e 	bne	r2,zero,811187c4 <bInitSync+0xb0>
		#if DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
		#endif
		return bSuccess;
811187bc:	e0bffe17 	ldw	r2,-8(fp)
811187c0:	00003106 	br	81118888 <bInitSync+0x174>
	}


	// Polaridade
	bSuccess = bSyncSetPolarity(POL);
811187c4:	0009883a 	mov	r4,zero
811187c8:	110afe80 	call	8110afe8 <bSyncSetPolarity>
811187cc:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
811187d0:	e0bffe17 	ldw	r2,-8(fp)
811187d4:	1000021e 	bne	r2,zero,811187e0 <bInitSync+0xcc>
		#if DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
		#endif
		return bSuccess;
811187d8:	e0bffe17 	ldw	r2,-8(fp)
811187dc:	00002a06 	br	81118888 <bInitSync+0x174>
	}

	// N. de ciclos
	bSuccess = bSyncSetNCycles(N_CICLOS);
811187e0:	01000104 	movi	r4,4
811187e4:	110b05c0 	call	8110b05c <bSyncSetNCycles>
811187e8:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
811187ec:	e0bffe17 	ldw	r2,-8(fp)
811187f0:	1000021e 	bne	r2,zero,811187fc <bInitSync+0xe8>
		#if DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
		#endif
		return bSuccess;
811187f4:	e0bffe17 	ldw	r2,-8(fp)
811187f8:	00002306 	br	81118888 <bInitSync+0x174>
	}

	// Altera mux para sync interno
	bSuccess = bSyncCtrExtnIrq(TRUE);
811187fc:	01000044 	movi	r4,1
81118800:	110b2380 	call	8110b238 <bSyncCtrExtnIrq>
81118804:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81118808:	e0bffe17 	ldw	r2,-8(fp)
8111880c:	1000021e 	bne	r2,zero,81118818 <bInitSync+0x104>
		#if DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
		#endif
		return bSuccess;
81118810:	e0bffe17 	ldw	r2,-8(fp)
81118814:	00001c06 	br	81118888 <bInitSync+0x174>
	}

	// Habilita sync_out enable (deve aparecer na sada o sync int.)
	bSuccess = bSyncCtrSyncOutEnable(TRUE);
81118818:	01000044 	movi	r4,1
8111881c:	110b4000 	call	8110b400 <bSyncCtrSyncOutEnable>
81118820:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81118824:	e0bffe17 	ldw	r2,-8(fp)
81118828:	1000021e 	bne	r2,zero,81118834 <bInitSync+0x120>
		#if DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
		#endif
		return bSuccess;
8111882c:	e0bffe17 	ldw	r2,-8(fp)
81118830:	00001506 	br	81118888 <bInitSync+0x174>
	}


	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh1OutEnable(TRUE);
81118834:	01000044 	movi	r4,1
81118838:	110b4740 	call	8110b474 <bSyncCtrCh1OutEnable>
8111883c:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
81118840:	e0bffe17 	ldw	r2,-8(fp)
81118844:	1000021e 	bne	r2,zero,81118850 <bInitSync+0x13c>
		#if DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
		#endif
		return bSuccess;
81118848:	e0bffe17 	ldw	r2,-8(fp)
8111884c:	00000e06 	br	81118888 <bInitSync+0x174>
	}

	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh2OutEnable(TRUE);
81118850:	01000044 	movi	r4,1
81118854:	110b4e80 	call	8110b4e8 <bSyncCtrCh2OutEnable>
81118858:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111885c:	e0bffe17 	ldw	r2,-8(fp)
81118860:	1000021e 	bne	r2,zero,8111886c <bInitSync+0x158>
		#if DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
		#endif
		return bSuccess;
81118864:	e0bffe17 	ldw	r2,-8(fp)
81118868:	00000706 	br	81118888 <bInitSync+0x174>
	}

	bSuccess = bSyncCtrStart();
8111886c:	110b2b00 	call	8110b2b0 <bSyncCtrStart>
81118870:	e0bffe15 	stw	r2,-8(fp)
	bSyncCtrReset();
81118874:	110b3040 	call	8110b304 <bSyncCtrReset>
	aux_32 = bSyncIrqEnableBlank(TRUE);
81118878:	01000044 	movi	r4,1
8111887c:	110b8880 	call	8110b888 <bSyncIrqEnableBlank>
81118880:	e0bfff15 	stw	r2,-4(fp)


	return bSuccess;
81118884:	e0bffe17 	ldw	r2,-8(fp)
}
81118888:	e037883a 	mov	sp,fp
8111888c:	dfc00117 	ldw	ra,4(sp)
81118890:	df000017 	ldw	fp,0(sp)
81118894:	dec00204 	addi	sp,sp,8
81118898:	f800283a 	ret

8111889c <bStartSync>:


bool bStartSync(void) {
8111889c:	defffd04 	addi	sp,sp,-12
811188a0:	de00012e 	bgeu	sp,et,811188a8 <bStartSync+0xc>
811188a4:	003b68fa 	trap	3
811188a8:	dfc00215 	stw	ra,8(sp)
811188ac:	df000115 	stw	fp,4(sp)
811188b0:	df000104 	addi	fp,sp,4

	bool bSuccess;
	bSyncCtrReset();
811188b4:	110b3040 	call	8110b304 <bSyncCtrReset>
	bSuccess = bSyncCtrStart();
811188b8:	110b2b00 	call	8110b2b0 <bSyncCtrStart>
811188bc:	e0bfff15 	stw	r2,-4(fp)

	return bSuccess;
811188c0:	e0bfff17 	ldw	r2,-4(fp)
}
811188c4:	e037883a 	mov	sp,fp
811188c8:	dfc00117 	ldw	ra,4(sp)
811188cc:	df000017 	ldw	fp,0(sp)
811188d0:	dec00204 	addi	sp,sp,8
811188d4:	f800283a 	ret

811188d8 <bStopSync>:

bool bStopSync(void) {
811188d8:	defffe04 	addi	sp,sp,-8
811188dc:	de00012e 	bgeu	sp,et,811188e4 <bStopSync+0xc>
811188e0:	003b68fa 	trap	3
811188e4:	dfc00115 	stw	ra,4(sp)
811188e8:	df000015 	stw	fp,0(sp)
811188ec:	d839883a 	mov	fp,sp
	return bSyncCtrReset();
811188f0:	110b3040 	call	8110b304 <bSyncCtrReset>
}
811188f4:	e037883a 	mov	sp,fp
811188f8:	dfc00117 	ldw	ra,4(sp)
811188fc:	df000017 	ldw	fp,0(sp)
81118900:	dec00204 	addi	sp,sp,8
81118904:	f800283a 	ret

81118908 <bClearCounterSync>:

void bClearCounterSync(void) {
81118908:	defffe04 	addi	sp,sp,-8
8111890c:	de00012e 	bgeu	sp,et,81118914 <bClearCounterSync+0xc>
81118910:	003b68fa 	trap	3
81118914:	dfc00115 	stw	ra,4(sp)
81118918:	df000015 	stw	fp,0(sp)
8111891c:	d839883a 	mov	fp,sp

	vSyncClearCounter();
81118920:	110acb40 	call	8110acb4 <vSyncClearCounter>
}
81118924:	0001883a 	nop
81118928:	e037883a 	mov	sp,fp
8111892c:	dfc00117 	ldw	ra,4(sp)
81118930:	df000017 	ldw	fp,0(sp)
81118934:	dec00204 	addi	sp,sp,8
81118938:	f800283a 	ret

8111893c <bTestSimucamCriticalHW>:
 */


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void ) {
8111893c:	defffd04 	addi	sp,sp,-12
81118940:	de00012e 	bgeu	sp,et,81118948 <bTestSimucamCriticalHW+0xc>
81118944:	003b68fa 	trap	3
81118948:	dfc00215 	stw	ra,8(sp)
8111894c:	df000115 	stw	fp,4(sp)
81118950:	df000104 	addi	fp,sp,4
	/*
	 * Verificar com Frana quais testes podemos realizar aqui
	 * SDcard para criar logs e pegar defaults
	 */

	bSuccess = bSdmaInitM1Dma();
81118954:	1101e080 	call	81101e08 <bSdmaInitM1Dma>
81118958:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8111895c:	e0bfff17 	ldw	r2,-4(fp)
81118960:	1000021e 	bne	r2,zero,8111896c <bTestSimucamCriticalHW+0x30>
		return bSuccess;
81118964:	e0bfff17 	ldw	r2,-4(fp)
81118968:	00000706 	br	81118988 <bTestSimucamCriticalHW+0x4c>
	}

	bSuccess = bSdmaInitM2Dma();
8111896c:	1101ec40 	call	81101ec4 <bSdmaInitM2Dma>
81118970:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
81118974:	e0bfff17 	ldw	r2,-4(fp)
81118978:	1000021e 	bne	r2,zero,81118984 <bTestSimucamCriticalHW+0x48>
		return bSuccess;
8111897c:	e0bfff17 	ldw	r2,-4(fp)
81118980:	00000106 	br	81118988 <bTestSimucamCriticalHW+0x4c>

	//xDma[0].pDmaTranfer = bSdmaDmaM1Transfer;
	//xDma[0].pDmaTranfer = bSdmaDmaM2Transfer;


	return TRUE;
81118984:	00800044 	movi	r2,1
}
81118988:	e037883a 	mov	sp,fp
8111898c:	dfc00117 	ldw	ra,4(sp)
81118990:	df000017 	ldw	fp,0(sp)
81118994:	dec00204 	addi	sp,sp,8
81118998:	f800283a 	ret

8111899c <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
8111899c:	defffc04 	addi	sp,sp,-16
811189a0:	de00012e 	bgeu	sp,et,811189a8 <_reg_write+0xc>
811189a4:	003b68fa 	trap	3
811189a8:	df000315 	stw	fp,12(sp)
811189ac:	df000304 	addi	fp,sp,12
811189b0:	e13ffd15 	stw	r4,-12(fp)
811189b4:	e17ffe15 	stw	r5,-8(fp)
811189b8:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
811189bc:	e0bffe17 	ldw	r2,-8(fp)
811189c0:	1085883a 	add	r2,r2,r2
811189c4:	1085883a 	add	r2,r2,r2
811189c8:	1007883a 	mov	r3,r2
811189cc:	e0bffd17 	ldw	r2,-12(fp)
811189d0:	1885883a 	add	r2,r3,r2
811189d4:	1007883a 	mov	r3,r2
811189d8:	e0bfff17 	ldw	r2,-4(fp)
811189dc:	18800035 	stwio	r2,0(r3)
	return 1;
811189e0:	00800044 	movi	r2,1

}
811189e4:	e037883a 	mov	sp,fp
811189e8:	df000017 	ldw	fp,0(sp)
811189ec:	dec00104 	addi	sp,sp,4
811189f0:	f800283a 	ret

811189f4 <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
811189f4:	defffc04 	addi	sp,sp,-16
811189f8:	de00012e 	bgeu	sp,et,81118a00 <_reg_read+0xc>
811189fc:	003b68fa 	trap	3
81118a00:	df000315 	stw	fp,12(sp)
81118a04:	df000304 	addi	fp,sp,12
81118a08:	e13ffd15 	stw	r4,-12(fp)
81118a0c:	e17ffe15 	stw	r5,-8(fp)
81118a10:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
81118a14:	e0bffe17 	ldw	r2,-8(fp)
81118a18:	1085883a 	add	r2,r2,r2
81118a1c:	1085883a 	add	r2,r2,r2
81118a20:	1007883a 	mov	r3,r2
81118a24:	e0bffd17 	ldw	r2,-12(fp)
81118a28:	1885883a 	add	r2,r3,r2
81118a2c:	10c00037 	ldwio	r3,0(r2)
81118a30:	e0bfff17 	ldw	r2,-4(fp)
81118a34:	10c00015 	stw	r3,0(r2)
	return 1;
81118a38:	00800044 	movi	r2,1

}
81118a3c:	e037883a 	mov	sp,fp
81118a40:	df000017 	ldw	fp,0(sp)
81118a44:	dec00104 	addi	sp,sp,4
81118a48:	f800283a 	ret

81118a4c <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
81118a4c:	defffb04 	addi	sp,sp,-20
81118a50:	de00012e 	bgeu	sp,et,81118a58 <_print_codec_status+0xc>
81118a54:	003b68fa 	trap	3
81118a58:	df000415 	stw	fp,16(sp)
81118a5c:	df000404 	addi	fp,sp,16
81118a60:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
81118a64:	e0bfff17 	ldw	r2,-4(fp)
81118a68:	1005d1ba 	srai	r2,r2,6
81118a6c:	1080004c 	andi	r2,r2,1
81118a70:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
81118a74:	e0bfff17 	ldw	r2,-4(fp)
81118a78:	1005d17a 	srai	r2,r2,5
81118a7c:	1080004c 	andi	r2,r2,1
81118a80:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
81118a84:	e0bfff17 	ldw	r2,-4(fp)
81118a88:	1005d13a 	srai	r2,r2,4
81118a8c:	1080004c 	andi	r2,r2,1
81118a90:	e0bffe15 	stw	r2,-8(fp)
	sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
	debug(fp, cDebugBuffer);
	sprintf(cDebugBuffer, "--------  \n");
	debug(fp, cDebugBuffer);
#endif
}
81118a94:	0001883a 	nop
81118a98:	e037883a 	mov	sp,fp
81118a9c:	df000017 	ldw	fp,0(sp)
81118aa0:	dec00104 	addi	sp,sp,4
81118aa4:	f800283a 	ret

81118aa8 <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
81118aa8:	defffb04 	addi	sp,sp,-20
81118aac:	de00012e 	bgeu	sp,et,81118ab4 <_split_codec_status+0xc>
81118ab0:	003b68fa 	trap	3
81118ab4:	df000415 	stw	fp,16(sp)
81118ab8:	df000404 	addi	fp,sp,16
81118abc:	e13ffc15 	stw	r4,-16(fp)
81118ac0:	e17ffd15 	stw	r5,-12(fp)
81118ac4:	e1bffe15 	stw	r6,-8(fp)
81118ac8:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
81118acc:	e0bffc17 	ldw	r2,-16(fp)
81118ad0:	1005d1ba 	srai	r2,r2,6
81118ad4:	10c0004c 	andi	r3,r2,1
81118ad8:	e0bffd17 	ldw	r2,-12(fp)
81118adc:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
81118ae0:	e0bffc17 	ldw	r2,-16(fp)
81118ae4:	1005d17a 	srai	r2,r2,5
81118ae8:	10c0004c 	andi	r3,r2,1
81118aec:	e0bffe17 	ldw	r2,-8(fp)
81118af0:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
81118af4:	e0bffc17 	ldw	r2,-16(fp)
81118af8:	1005d13a 	srai	r2,r2,4
81118afc:	10c0004c 	andi	r3,r2,1
81118b00:	e0bfff17 	ldw	r2,-4(fp)
81118b04:	10c00015 	stw	r3,0(r2)
}
81118b08:	0001883a 	nop
81118b0c:	e037883a 	mov	sp,fp
81118b10:	df000017 	ldw	fp,0(sp)
81118b14:	dec00104 	addi	sp,sp,4
81118b18:	f800283a 	ret

81118b1c <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
81118b1c:	defffc04 	addi	sp,sp,-16
81118b20:	de00012e 	bgeu	sp,et,81118b28 <aatoh+0xc>
81118b24:	003b68fa 	trap	3
81118b28:	df000315 	stw	fp,12(sp)
81118b2c:	df000304 	addi	fp,sp,12
81118b30:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
81118b34:	e0bfff17 	ldw	r2,-4(fp)
81118b38:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
81118b3c:	e0bffd17 	ldw	r2,-12(fp)
81118b40:	10c00003 	ldbu	r3,0(r2)
81118b44:	e0bffd17 	ldw	r2,-12(fp)
81118b48:	10800003 	ldbu	r2,0(r2)
81118b4c:	10803fcc 	andi	r2,r2,255
81118b50:	10800eb0 	cmpltui	r2,r2,58
81118b54:	1000021e 	bne	r2,zero,81118b60 <aatoh+0x44>
81118b58:	00800dc4 	movi	r2,55
81118b5c:	00000106 	br	81118b64 <aatoh+0x48>
81118b60:	00800c04 	movi	r2,48
81118b64:	1885c83a 	sub	r2,r3,r2
81118b68:	1004913a 	slli	r2,r2,4
81118b6c:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
81118b70:	e0bffd17 	ldw	r2,-12(fp)
81118b74:	10800044 	addi	r2,r2,1
81118b78:	10c00003 	ldbu	r3,0(r2)
81118b7c:	e0bffd17 	ldw	r2,-12(fp)
81118b80:	10800044 	addi	r2,r2,1
81118b84:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
81118b88:	10803fcc 	andi	r2,r2,255
81118b8c:	10800eb0 	cmpltui	r2,r2,58
81118b90:	1000021e 	bne	r2,zero,81118b9c <aatoh+0x80>
81118b94:	00800dc4 	movi	r2,55
81118b98:	00000106 	br	81118ba0 <aatoh+0x84>
81118b9c:	00800c04 	movi	r2,48
81118ba0:	1885c83a 	sub	r2,r3,r2
81118ba4:	2085883a 	add	r2,r4,r2
81118ba8:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
81118bac:	e0bffe03 	ldbu	r2,-8(fp)
}
81118bb0:	e037883a 	mov	sp,fp
81118bb4:	df000017 	ldw	fp,0(sp)
81118bb8:	dec00104 	addi	sp,sp,4
81118bbc:	f800283a 	ret

81118bc0 <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
81118bc0:	defffe04 	addi	sp,sp,-8
81118bc4:	de00012e 	bgeu	sp,et,81118bcc <Verif_Error+0xc>
81118bc8:	003b68fa 	trap	3
81118bcc:	df000115 	stw	fp,4(sp)
81118bd0:	df000104 	addi	fp,sp,4
81118bd4:	2005883a 	mov	r2,r4
81118bd8:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
81118bdc:	e0bfff03 	ldbu	r2,-4(fp)
81118be0:	1000021e 	bne	r2,zero,81118bec <Verif_Error+0x2c>
#if DEBUG_ON
	debug(fp, "ERROR\n\r");
#endif
		return 0;
81118be4:	0005883a 	mov	r2,zero
81118be8:	00000106 	br	81118bf0 <Verif_Error+0x30>
	} else
		return 1;
81118bec:	00800044 	movi	r2,1
}
81118bf0:	e037883a 	mov	sp,fp
81118bf4:	df000017 	ldw	fp,0(sp)
81118bf8:	dec00104 	addi	sp,sp,4
81118bfc:	f800283a 	ret

81118c00 <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
81118c00:	defffe04 	addi	sp,sp,-8
81118c04:	de00012e 	bgeu	sp,et,81118c0c <toInt+0xc>
81118c08:	003b68fa 	trap	3
81118c0c:	df000115 	stw	fp,4(sp)
81118c10:	df000104 	addi	fp,sp,4
81118c14:	2005883a 	mov	r2,r4
81118c18:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
81118c1c:	e0bfff03 	ldbu	r2,-4(fp)
81118c20:	10bff404 	addi	r2,r2,-48
}
81118c24:	e037883a 	mov	sp,fp
81118c28:	df000017 	ldw	fp,0(sp)
81118c2c:	dec00104 	addi	sp,sp,4
81118c30:	f800283a 	ret

81118c34 <__fixunsdfsi>:
81118c34:	defffd04 	addi	sp,sp,-12
81118c38:	000d883a 	mov	r6,zero
81118c3c:	01d07834 	movhi	r7,16864
81118c40:	de00012e 	bgeu	sp,et,81118c48 <__fixunsdfsi+0x14>
81118c44:	003b68fa 	trap	3
81118c48:	dc400115 	stw	r17,4(sp)
81118c4c:	dc000015 	stw	r16,0(sp)
81118c50:	dfc00215 	stw	ra,8(sp)
81118c54:	2023883a 	mov	r17,r4
81118c58:	2821883a 	mov	r16,r5
81118c5c:	11195f40 	call	811195f4 <__gedf2>
81118c60:	1000080e 	bge	r2,zero,81118c84 <__fixunsdfsi+0x50>
81118c64:	8809883a 	mov	r4,r17
81118c68:	800b883a 	mov	r5,r16
81118c6c:	111a6f40 	call	8111a6f4 <__fixdfsi>
81118c70:	dfc00217 	ldw	ra,8(sp)
81118c74:	dc400117 	ldw	r17,4(sp)
81118c78:	dc000017 	ldw	r16,0(sp)
81118c7c:	dec00304 	addi	sp,sp,12
81118c80:	f800283a 	ret
81118c84:	000d883a 	mov	r6,zero
81118c88:	01d07834 	movhi	r7,16864
81118c8c:	8809883a 	mov	r4,r17
81118c90:	800b883a 	mov	r5,r16
81118c94:	1119df00 	call	81119df0 <__subdf3>
81118c98:	180b883a 	mov	r5,r3
81118c9c:	1009883a 	mov	r4,r2
81118ca0:	111a6f40 	call	8111a6f4 <__fixdfsi>
81118ca4:	00e00034 	movhi	r3,32768
81118ca8:	10c5883a 	add	r2,r2,r3
81118cac:	003ff006 	br	81118c70 <__reset+0xfb0f8c70>

81118cb0 <__divsf3>:
81118cb0:	defff504 	addi	sp,sp,-44
81118cb4:	200cd5fa 	srli	r6,r4,23
81118cb8:	de00012e 	bgeu	sp,et,81118cc0 <__divsf3+0x10>
81118cbc:	003b68fa 	trap	3
81118cc0:	dcc00415 	stw	r19,16(sp)
81118cc4:	2026d7fa 	srli	r19,r4,31
81118cc8:	00c02034 	movhi	r3,128
81118ccc:	dd800715 	stw	r22,28(sp)
81118cd0:	dd000515 	stw	r20,20(sp)
81118cd4:	dc800315 	stw	r18,12(sp)
81118cd8:	18ffffc4 	addi	r3,r3,-1
81118cdc:	dfc00a15 	stw	ra,40(sp)
81118ce0:	df000915 	stw	fp,36(sp)
81118ce4:	ddc00815 	stw	r23,32(sp)
81118ce8:	dd400615 	stw	r21,24(sp)
81118cec:	dc400215 	stw	r17,8(sp)
81118cf0:	dc000115 	stw	r16,4(sp)
81118cf4:	35003fcc 	andi	r20,r6,255
81118cf8:	1924703a 	and	r18,r3,r4
81118cfc:	9d803fcc 	andi	r22,r19,255
81118d00:	a0005226 	beq	r20,zero,81118e4c <__divsf3+0x19c>
81118d04:	00803fc4 	movi	r2,255
81118d08:	a0802e26 	beq	r20,r2,81118dc4 <__divsf3+0x114>
81118d0c:	91002034 	orhi	r4,r18,128
81118d10:	202490fa 	slli	r18,r4,3
81118d14:	a53fe044 	addi	r20,r20,-127
81118d18:	0021883a 	mov	r16,zero
81118d1c:	002f883a 	mov	r23,zero
81118d20:	280cd5fa 	srli	r6,r5,23
81118d24:	282ad7fa 	srli	r21,r5,31
81118d28:	00c02034 	movhi	r3,128
81118d2c:	18ffffc4 	addi	r3,r3,-1
81118d30:	31803fcc 	andi	r6,r6,255
81118d34:	1962703a 	and	r17,r3,r5
81118d38:	af003fcc 	andi	fp,r21,255
81118d3c:	30004a26 	beq	r6,zero,81118e68 <__divsf3+0x1b8>
81118d40:	00803fc4 	movi	r2,255
81118d44:	30804526 	beq	r6,r2,81118e5c <__divsf3+0x1ac>
81118d48:	89402034 	orhi	r5,r17,128
81118d4c:	282290fa 	slli	r17,r5,3
81118d50:	31bfe044 	addi	r6,r6,-127
81118d54:	000b883a 	mov	r5,zero
81118d58:	2c20b03a 	or	r16,r5,r16
81118d5c:	802090ba 	slli	r16,r16,2
81118d60:	00a044b4 	movhi	r2,33042
81118d64:	10a36104 	addi	r2,r2,-29308
81118d68:	80a1883a 	add	r16,r16,r2
81118d6c:	81000017 	ldw	r4,0(r16)
81118d70:	9d46f03a 	xor	r3,r19,r21
81118d74:	180f883a 	mov	r7,r3
81118d78:	18803fcc 	andi	r2,r3,255
81118d7c:	a18dc83a 	sub	r6,r20,r6
81118d80:	2000683a 	jmp	r4
81118d84:	81118f68 	cmpgeui	r4,r16,17981
81118d88:	81118dec 	andhi	r4,r16,17975
81118d8c:	81118f5c 	xori	r4,r16,17981
81118d90:	81118dd8 	cmpnei	r4,r16,17975
81118d94:	81118f5c 	xori	r4,r16,17981
81118d98:	81118f34 	orhi	r4,r16,17980
81118d9c:	81118f5c 	xori	r4,r16,17981
81118da0:	81118dd8 	cmpnei	r4,r16,17975
81118da4:	81118dec 	andhi	r4,r16,17975
81118da8:	81118dec 	andhi	r4,r16,17975
81118dac:	81118f34 	orhi	r4,r16,17980
81118db0:	81118dd8 	cmpnei	r4,r16,17975
81118db4:	81119048 	cmpgei	r4,r16,17985
81118db8:	81119048 	cmpgei	r4,r16,17985
81118dbc:	81119048 	cmpgei	r4,r16,17985
81118dc0:	81118ffc 	xorhi	r4,r16,17983
81118dc4:	9000581e 	bne	r18,zero,81118f28 <__divsf3+0x278>
81118dc8:	04000204 	movi	r16,8
81118dcc:	05c00084 	movi	r23,2
81118dd0:	003fd306 	br	81118d20 <__reset+0xfb0f8d20>
81118dd4:	0023883a 	mov	r17,zero
81118dd8:	e02d883a 	mov	r22,fp
81118ddc:	282f883a 	mov	r23,r5
81118de0:	00800084 	movi	r2,2
81118de4:	b8808f1e 	bne	r23,r2,81119024 <__divsf3+0x374>
81118de8:	b005883a 	mov	r2,r22
81118dec:	11c0004c 	andi	r7,r2,1
81118df0:	013fffc4 	movi	r4,-1
81118df4:	000d883a 	mov	r6,zero
81118df8:	21003fcc 	andi	r4,r4,255
81118dfc:	200895fa 	slli	r4,r4,23
81118e00:	38803fcc 	andi	r2,r7,255
81118e04:	00c02034 	movhi	r3,128
81118e08:	100497fa 	slli	r2,r2,31
81118e0c:	18ffffc4 	addi	r3,r3,-1
81118e10:	30c6703a 	and	r3,r6,r3
81118e14:	1906b03a 	or	r3,r3,r4
81118e18:	1884b03a 	or	r2,r3,r2
81118e1c:	dfc00a17 	ldw	ra,40(sp)
81118e20:	df000917 	ldw	fp,36(sp)
81118e24:	ddc00817 	ldw	r23,32(sp)
81118e28:	dd800717 	ldw	r22,28(sp)
81118e2c:	dd400617 	ldw	r21,24(sp)
81118e30:	dd000517 	ldw	r20,20(sp)
81118e34:	dcc00417 	ldw	r19,16(sp)
81118e38:	dc800317 	ldw	r18,12(sp)
81118e3c:	dc400217 	ldw	r17,8(sp)
81118e40:	dc000117 	ldw	r16,4(sp)
81118e44:	dec00b04 	addi	sp,sp,44
81118e48:	f800283a 	ret
81118e4c:	90002b1e 	bne	r18,zero,81118efc <__divsf3+0x24c>
81118e50:	04000104 	movi	r16,4
81118e54:	05c00044 	movi	r23,1
81118e58:	003fb106 	br	81118d20 <__reset+0xfb0f8d20>
81118e5c:	8800251e 	bne	r17,zero,81118ef4 <__divsf3+0x244>
81118e60:	01400084 	movi	r5,2
81118e64:	00000206 	br	81118e70 <__divsf3+0x1c0>
81118e68:	88001a1e 	bne	r17,zero,81118ed4 <__divsf3+0x224>
81118e6c:	01400044 	movi	r5,1
81118e70:	8160b03a 	or	r16,r16,r5
81118e74:	802090ba 	slli	r16,r16,2
81118e78:	00e044b4 	movhi	r3,33042
81118e7c:	18e3a504 	addi	r3,r3,-29036
81118e80:	80e1883a 	add	r16,r16,r3
81118e84:	80c00017 	ldw	r3,0(r16)
81118e88:	9d44f03a 	xor	r2,r19,r21
81118e8c:	a18dc83a 	sub	r6,r20,r6
81118e90:	1800683a 	jmp	r3
81118e94:	81118dec 	andhi	r4,r16,17975
81118e98:	81118dec 	andhi	r4,r16,17975
81118e9c:	81119038 	rdprs	r4,r16,17984
81118ea0:	81118dd4 	ori	r4,r16,17975
81118ea4:	81119038 	rdprs	r4,r16,17984
81118ea8:	81118f34 	orhi	r4,r16,17980
81118eac:	81119038 	rdprs	r4,r16,17984
81118eb0:	81118dd4 	ori	r4,r16,17975
81118eb4:	81118dec 	andhi	r4,r16,17975
81118eb8:	81118dec 	andhi	r4,r16,17975
81118ebc:	81118f34 	orhi	r4,r16,17980
81118ec0:	81118dd4 	ori	r4,r16,17975
81118ec4:	81119048 	cmpgei	r4,r16,17985
81118ec8:	81119048 	cmpgei	r4,r16,17985
81118ecc:	81119048 	cmpgei	r4,r16,17985
81118ed0:	81119060 	cmpeqi	r4,r16,17985
81118ed4:	8809883a 	mov	r4,r17
81118ed8:	111ab180 	call	8111ab18 <__clzsi2>
81118edc:	10fffec4 	addi	r3,r2,-5
81118ee0:	10801d84 	addi	r2,r2,118
81118ee4:	88e2983a 	sll	r17,r17,r3
81118ee8:	008dc83a 	sub	r6,zero,r2
81118eec:	000b883a 	mov	r5,zero
81118ef0:	003f9906 	br	81118d58 <__reset+0xfb0f8d58>
81118ef4:	014000c4 	movi	r5,3
81118ef8:	003f9706 	br	81118d58 <__reset+0xfb0f8d58>
81118efc:	9009883a 	mov	r4,r18
81118f00:	d9400015 	stw	r5,0(sp)
81118f04:	111ab180 	call	8111ab18 <__clzsi2>
81118f08:	10fffec4 	addi	r3,r2,-5
81118f0c:	11801d84 	addi	r6,r2,118
81118f10:	90e4983a 	sll	r18,r18,r3
81118f14:	01a9c83a 	sub	r20,zero,r6
81118f18:	0021883a 	mov	r16,zero
81118f1c:	002f883a 	mov	r23,zero
81118f20:	d9400017 	ldw	r5,0(sp)
81118f24:	003f7e06 	br	81118d20 <__reset+0xfb0f8d20>
81118f28:	04000304 	movi	r16,12
81118f2c:	05c000c4 	movi	r23,3
81118f30:	003f7b06 	br	81118d20 <__reset+0xfb0f8d20>
81118f34:	01802034 	movhi	r6,128
81118f38:	000f883a 	mov	r7,zero
81118f3c:	31bfffc4 	addi	r6,r6,-1
81118f40:	013fffc4 	movi	r4,-1
81118f44:	003fac06 	br	81118df8 <__reset+0xfb0f8df8>
81118f48:	01400044 	movi	r5,1
81118f4c:	2909c83a 	sub	r4,r5,r4
81118f50:	00c006c4 	movi	r3,27
81118f54:	19004b0e 	bge	r3,r4,81119084 <__divsf3+0x3d4>
81118f58:	114e703a 	and	r7,r2,r5
81118f5c:	0009883a 	mov	r4,zero
81118f60:	000d883a 	mov	r6,zero
81118f64:	003fa406 	br	81118df8 <__reset+0xfb0f8df8>
81118f68:	9006917a 	slli	r3,r18,5
81118f6c:	8822917a 	slli	r17,r17,5
81118f70:	1c40372e 	bgeu	r3,r17,81119050 <__divsf3+0x3a0>
81118f74:	31bfffc4 	addi	r6,r6,-1
81118f78:	010006c4 	movi	r4,27
81118f7c:	000b883a 	mov	r5,zero
81118f80:	180f883a 	mov	r7,r3
81118f84:	294b883a 	add	r5,r5,r5
81118f88:	18c7883a 	add	r3,r3,r3
81118f8c:	38000116 	blt	r7,zero,81118f94 <__divsf3+0x2e4>
81118f90:	1c400236 	bltu	r3,r17,81118f9c <__divsf3+0x2ec>
81118f94:	1c47c83a 	sub	r3,r3,r17
81118f98:	29400054 	ori	r5,r5,1
81118f9c:	213fffc4 	addi	r4,r4,-1
81118fa0:	203ff71e 	bne	r4,zero,81118f80 <__reset+0xfb0f8f80>
81118fa4:	1806c03a 	cmpne	r3,r3,zero
81118fa8:	1962b03a 	or	r17,r3,r5
81118fac:	31001fc4 	addi	r4,r6,127
81118fb0:	013fe50e 	bge	zero,r4,81118f48 <__reset+0xfb0f8f48>
81118fb4:	88c001cc 	andi	r3,r17,7
81118fb8:	18000426 	beq	r3,zero,81118fcc <__divsf3+0x31c>
81118fbc:	88c003cc 	andi	r3,r17,15
81118fc0:	01400104 	movi	r5,4
81118fc4:	19400126 	beq	r3,r5,81118fcc <__divsf3+0x31c>
81118fc8:	8963883a 	add	r17,r17,r5
81118fcc:	88c2002c 	andhi	r3,r17,2048
81118fd0:	18000426 	beq	r3,zero,81118fe4 <__divsf3+0x334>
81118fd4:	00fe0034 	movhi	r3,63488
81118fd8:	18ffffc4 	addi	r3,r3,-1
81118fdc:	31002004 	addi	r4,r6,128
81118fe0:	88e2703a 	and	r17,r17,r3
81118fe4:	00c03f84 	movi	r3,254
81118fe8:	193f8016 	blt	r3,r4,81118dec <__reset+0xfb0f8dec>
81118fec:	880c91ba 	slli	r6,r17,6
81118ff0:	11c0004c 	andi	r7,r2,1
81118ff4:	300cd27a 	srli	r6,r6,9
81118ff8:	003f7f06 	br	81118df8 <__reset+0xfb0f8df8>
81118ffc:	9080102c 	andhi	r2,r18,64
81119000:	10000226 	beq	r2,zero,8111900c <__divsf3+0x35c>
81119004:	8880102c 	andhi	r2,r17,64
81119008:	10001826 	beq	r2,zero,8111906c <__divsf3+0x3bc>
8111900c:	00802034 	movhi	r2,128
81119010:	91801034 	orhi	r6,r18,64
81119014:	10bfffc4 	addi	r2,r2,-1
81119018:	980f883a 	mov	r7,r19
8111901c:	308c703a 	and	r6,r6,r2
81119020:	003fc706 	br	81118f40 <__reset+0xfb0f8f40>
81119024:	008000c4 	movi	r2,3
81119028:	b8802d26 	beq	r23,r2,811190e0 <__divsf3+0x430>
8111902c:	00c00044 	movi	r3,1
81119030:	b005883a 	mov	r2,r22
81119034:	b8ffdd1e 	bne	r23,r3,81118fac <__reset+0xfb0f8fac>
81119038:	11c0004c 	andi	r7,r2,1
8111903c:	0009883a 	mov	r4,zero
81119040:	000d883a 	mov	r6,zero
81119044:	003f6c06 	br	81118df8 <__reset+0xfb0f8df8>
81119048:	9023883a 	mov	r17,r18
8111904c:	003f6406 	br	81118de0 <__reset+0xfb0f8de0>
81119050:	1c47c83a 	sub	r3,r3,r17
81119054:	01000684 	movi	r4,26
81119058:	01400044 	movi	r5,1
8111905c:	003fc806 	br	81118f80 <__reset+0xfb0f8f80>
81119060:	9080102c 	andhi	r2,r18,64
81119064:	103fe926 	beq	r2,zero,8111900c <__reset+0xfb0f900c>
81119068:	0023883a 	mov	r17,zero
8111906c:	00802034 	movhi	r2,128
81119070:	89801034 	orhi	r6,r17,64
81119074:	10bfffc4 	addi	r2,r2,-1
81119078:	a80f883a 	mov	r7,r21
8111907c:	308c703a 	and	r6,r6,r2
81119080:	003faf06 	br	81118f40 <__reset+0xfb0f8f40>
81119084:	01c00804 	movi	r7,32
81119088:	390fc83a 	sub	r7,r7,r4
8111908c:	89ce983a 	sll	r7,r17,r7
81119090:	890ad83a 	srl	r5,r17,r4
81119094:	380ec03a 	cmpne	r7,r7,zero
81119098:	29cab03a 	or	r5,r5,r7
8111909c:	28c001cc 	andi	r3,r5,7
811190a0:	18000426 	beq	r3,zero,811190b4 <__divsf3+0x404>
811190a4:	28c003cc 	andi	r3,r5,15
811190a8:	01000104 	movi	r4,4
811190ac:	19000126 	beq	r3,r4,811190b4 <__divsf3+0x404>
811190b0:	290b883a 	add	r5,r5,r4
811190b4:	28c1002c 	andhi	r3,r5,1024
811190b8:	18000426 	beq	r3,zero,811190cc <__divsf3+0x41c>
811190bc:	11c0004c 	andi	r7,r2,1
811190c0:	01000044 	movi	r4,1
811190c4:	000d883a 	mov	r6,zero
811190c8:	003f4b06 	br	81118df8 <__reset+0xfb0f8df8>
811190cc:	280a91ba 	slli	r5,r5,6
811190d0:	11c0004c 	andi	r7,r2,1
811190d4:	0009883a 	mov	r4,zero
811190d8:	280cd27a 	srli	r6,r5,9
811190dc:	003f4606 	br	81118df8 <__reset+0xfb0f8df8>
811190e0:	00802034 	movhi	r2,128
811190e4:	89801034 	orhi	r6,r17,64
811190e8:	10bfffc4 	addi	r2,r2,-1
811190ec:	b00f883a 	mov	r7,r22
811190f0:	308c703a 	and	r6,r6,r2
811190f4:	003f9206 	br	81118f40 <__reset+0xfb0f8f40>

811190f8 <__mulsf3>:
811190f8:	defff504 	addi	sp,sp,-44
811190fc:	de00012e 	bgeu	sp,et,81119104 <__mulsf3+0xc>
81119100:	003b68fa 	trap	3
81119104:	dc000115 	stw	r16,4(sp)
81119108:	2020d5fa 	srli	r16,r4,23
8111910c:	dd400615 	stw	r21,24(sp)
81119110:	202ad7fa 	srli	r21,r4,31
81119114:	dc800315 	stw	r18,12(sp)
81119118:	04802034 	movhi	r18,128
8111911c:	df000915 	stw	fp,36(sp)
81119120:	dd000515 	stw	r20,20(sp)
81119124:	94bfffc4 	addi	r18,r18,-1
81119128:	dfc00a15 	stw	ra,40(sp)
8111912c:	ddc00815 	stw	r23,32(sp)
81119130:	dd800715 	stw	r22,28(sp)
81119134:	dcc00415 	stw	r19,16(sp)
81119138:	dc400215 	stw	r17,8(sp)
8111913c:	84003fcc 	andi	r16,r16,255
81119140:	9124703a 	and	r18,r18,r4
81119144:	a829883a 	mov	r20,r21
81119148:	af003fcc 	andi	fp,r21,255
8111914c:	80005426 	beq	r16,zero,811192a0 <__mulsf3+0x1a8>
81119150:	00803fc4 	movi	r2,255
81119154:	80802f26 	beq	r16,r2,81119214 <__mulsf3+0x11c>
81119158:	91002034 	orhi	r4,r18,128
8111915c:	202490fa 	slli	r18,r4,3
81119160:	843fe044 	addi	r16,r16,-127
81119164:	0023883a 	mov	r17,zero
81119168:	002f883a 	mov	r23,zero
8111916c:	2804d5fa 	srli	r2,r5,23
81119170:	282cd7fa 	srli	r22,r5,31
81119174:	01002034 	movhi	r4,128
81119178:	213fffc4 	addi	r4,r4,-1
8111917c:	10803fcc 	andi	r2,r2,255
81119180:	2166703a 	and	r19,r4,r5
81119184:	b1803fcc 	andi	r6,r22,255
81119188:	10004c26 	beq	r2,zero,811192bc <__mulsf3+0x1c4>
8111918c:	00c03fc4 	movi	r3,255
81119190:	10c04726 	beq	r2,r3,811192b0 <__mulsf3+0x1b8>
81119194:	99002034 	orhi	r4,r19,128
81119198:	202690fa 	slli	r19,r4,3
8111919c:	10bfe044 	addi	r2,r2,-127
811191a0:	0007883a 	mov	r3,zero
811191a4:	80a1883a 	add	r16,r16,r2
811191a8:	010003c4 	movi	r4,15
811191ac:	1c44b03a 	or	r2,r3,r17
811191b0:	b56af03a 	xor	r21,r22,r21
811191b4:	81c00044 	addi	r7,r16,1
811191b8:	20806b36 	bltu	r4,r2,81119368 <__mulsf3+0x270>
811191bc:	100490ba 	slli	r2,r2,2
811191c0:	012044b4 	movhi	r4,33042
811191c4:	21247504 	addi	r4,r4,-28204
811191c8:	1105883a 	add	r2,r2,r4
811191cc:	10800017 	ldw	r2,0(r2)
811191d0:	1000683a 	jmp	r2
811191d4:	81119368 	cmpgeui	r4,r16,17997
811191d8:	81119228 	cmpgeui	r4,r16,17992
811191dc:	81119228 	cmpgeui	r4,r16,17992
811191e0:	81119224 	muli	r4,r16,17992
811191e4:	8111934c 	andi	r4,r16,17997
811191e8:	8111934c 	andi	r4,r16,17997
811191ec:	81119338 	rdprs	r4,r16,17996
811191f0:	81119224 	muli	r4,r16,17992
811191f4:	8111934c 	andi	r4,r16,17997
811191f8:	81119338 	rdprs	r4,r16,17996
811191fc:	8111934c 	andi	r4,r16,17997
81119200:	81119224 	muli	r4,r16,17992
81119204:	81119358 	cmpnei	r4,r16,17997
81119208:	81119358 	cmpnei	r4,r16,17997
8111920c:	81119358 	cmpnei	r4,r16,17997
81119210:	81119434 	orhi	r4,r16,18000
81119214:	90003b1e 	bne	r18,zero,81119304 <__mulsf3+0x20c>
81119218:	04400204 	movi	r17,8
8111921c:	05c00084 	movi	r23,2
81119220:	003fd206 	br	8111916c <__reset+0xfb0f916c>
81119224:	302b883a 	mov	r21,r6
81119228:	00800084 	movi	r2,2
8111922c:	18802626 	beq	r3,r2,811192c8 <__mulsf3+0x1d0>
81119230:	008000c4 	movi	r2,3
81119234:	1880ab26 	beq	r3,r2,811194e4 <__mulsf3+0x3ec>
81119238:	00800044 	movi	r2,1
8111923c:	1880a21e 	bne	r3,r2,811194c8 <__mulsf3+0x3d0>
81119240:	a829883a 	mov	r20,r21
81119244:	0007883a 	mov	r3,zero
81119248:	0009883a 	mov	r4,zero
8111924c:	18803fcc 	andi	r2,r3,255
81119250:	100695fa 	slli	r3,r2,23
81119254:	a0803fcc 	andi	r2,r20,255
81119258:	100a97fa 	slli	r5,r2,31
8111925c:	00802034 	movhi	r2,128
81119260:	10bfffc4 	addi	r2,r2,-1
81119264:	2084703a 	and	r2,r4,r2
81119268:	10c4b03a 	or	r2,r2,r3
8111926c:	1144b03a 	or	r2,r2,r5
81119270:	dfc00a17 	ldw	ra,40(sp)
81119274:	df000917 	ldw	fp,36(sp)
81119278:	ddc00817 	ldw	r23,32(sp)
8111927c:	dd800717 	ldw	r22,28(sp)
81119280:	dd400617 	ldw	r21,24(sp)
81119284:	dd000517 	ldw	r20,20(sp)
81119288:	dcc00417 	ldw	r19,16(sp)
8111928c:	dc800317 	ldw	r18,12(sp)
81119290:	dc400217 	ldw	r17,8(sp)
81119294:	dc000117 	ldw	r16,4(sp)
81119298:	dec00b04 	addi	sp,sp,44
8111929c:	f800283a 	ret
811192a0:	90000d1e 	bne	r18,zero,811192d8 <__mulsf3+0x1e0>
811192a4:	04400104 	movi	r17,4
811192a8:	05c00044 	movi	r23,1
811192ac:	003faf06 	br	8111916c <__reset+0xfb0f916c>
811192b0:	9806c03a 	cmpne	r3,r19,zero
811192b4:	18c00084 	addi	r3,r3,2
811192b8:	003fba06 	br	811191a4 <__reset+0xfb0f91a4>
811192bc:	9800141e 	bne	r19,zero,81119310 <__mulsf3+0x218>
811192c0:	00c00044 	movi	r3,1
811192c4:	003fb706 	br	811191a4 <__reset+0xfb0f91a4>
811192c8:	a829883a 	mov	r20,r21
811192cc:	00ffffc4 	movi	r3,-1
811192d0:	0009883a 	mov	r4,zero
811192d4:	003fdd06 	br	8111924c <__reset+0xfb0f924c>
811192d8:	9009883a 	mov	r4,r18
811192dc:	d9400015 	stw	r5,0(sp)
811192e0:	111ab180 	call	8111ab18 <__clzsi2>
811192e4:	10fffec4 	addi	r3,r2,-5
811192e8:	10801d84 	addi	r2,r2,118
811192ec:	90e4983a 	sll	r18,r18,r3
811192f0:	00a1c83a 	sub	r16,zero,r2
811192f4:	0023883a 	mov	r17,zero
811192f8:	002f883a 	mov	r23,zero
811192fc:	d9400017 	ldw	r5,0(sp)
81119300:	003f9a06 	br	8111916c <__reset+0xfb0f916c>
81119304:	04400304 	movi	r17,12
81119308:	05c000c4 	movi	r23,3
8111930c:	003f9706 	br	8111916c <__reset+0xfb0f916c>
81119310:	9809883a 	mov	r4,r19
81119314:	d9800015 	stw	r6,0(sp)
81119318:	111ab180 	call	8111ab18 <__clzsi2>
8111931c:	10fffec4 	addi	r3,r2,-5
81119320:	10801d84 	addi	r2,r2,118
81119324:	98e6983a 	sll	r19,r19,r3
81119328:	0085c83a 	sub	r2,zero,r2
8111932c:	0007883a 	mov	r3,zero
81119330:	d9800017 	ldw	r6,0(sp)
81119334:	003f9b06 	br	811191a4 <__reset+0xfb0f91a4>
81119338:	01002034 	movhi	r4,128
8111933c:	0029883a 	mov	r20,zero
81119340:	213fffc4 	addi	r4,r4,-1
81119344:	00ffffc4 	movi	r3,-1
81119348:	003fc006 	br	8111924c <__reset+0xfb0f924c>
8111934c:	9027883a 	mov	r19,r18
81119350:	b807883a 	mov	r3,r23
81119354:	003fb406 	br	81119228 <__reset+0xfb0f9228>
81119358:	9027883a 	mov	r19,r18
8111935c:	e02b883a 	mov	r21,fp
81119360:	b807883a 	mov	r3,r23
81119364:	003fb006 	br	81119228 <__reset+0xfb0f9228>
81119368:	9004d43a 	srli	r2,r18,16
8111936c:	9810d43a 	srli	r8,r19,16
81119370:	94bfffcc 	andi	r18,r18,65535
81119374:	993fffcc 	andi	r4,r19,65535
81119378:	910d383a 	mul	r6,r18,r4
8111937c:	20a7383a 	mul	r19,r4,r2
81119380:	9225383a 	mul	r18,r18,r8
81119384:	3006d43a 	srli	r3,r6,16
81119388:	1211383a 	mul	r8,r2,r8
8111938c:	94e5883a 	add	r18,r18,r19
81119390:	1c87883a 	add	r3,r3,r18
81119394:	1cc0022e 	bgeu	r3,r19,811193a0 <__mulsf3+0x2a8>
81119398:	00800074 	movhi	r2,1
8111939c:	4091883a 	add	r8,r8,r2
811193a0:	1804943a 	slli	r2,r3,16
811193a4:	31bfffcc 	andi	r6,r6,65535
811193a8:	1806d43a 	srli	r3,r3,16
811193ac:	1185883a 	add	r2,r2,r6
811193b0:	102691ba 	slli	r19,r2,6
811193b4:	1a07883a 	add	r3,r3,r8
811193b8:	1004d6ba 	srli	r2,r2,26
811193bc:	180891ba 	slli	r4,r3,6
811193c0:	9826c03a 	cmpne	r19,r19,zero
811193c4:	9884b03a 	or	r2,r19,r2
811193c8:	1126b03a 	or	r19,r2,r4
811193cc:	9882002c 	andhi	r2,r19,2048
811193d0:	10000426 	beq	r2,zero,811193e4 <__mulsf3+0x2ec>
811193d4:	9804d07a 	srli	r2,r19,1
811193d8:	9900004c 	andi	r4,r19,1
811193dc:	3821883a 	mov	r16,r7
811193e0:	1126b03a 	or	r19,r2,r4
811193e4:	80c01fc4 	addi	r3,r16,127
811193e8:	00c0210e 	bge	zero,r3,81119470 <__mulsf3+0x378>
811193ec:	988001cc 	andi	r2,r19,7
811193f0:	10000426 	beq	r2,zero,81119404 <__mulsf3+0x30c>
811193f4:	988003cc 	andi	r2,r19,15
811193f8:	01000104 	movi	r4,4
811193fc:	11000126 	beq	r2,r4,81119404 <__mulsf3+0x30c>
81119400:	9927883a 	add	r19,r19,r4
81119404:	9882002c 	andhi	r2,r19,2048
81119408:	10000426 	beq	r2,zero,8111941c <__mulsf3+0x324>
8111940c:	00be0034 	movhi	r2,63488
81119410:	10bfffc4 	addi	r2,r2,-1
81119414:	80c02004 	addi	r3,r16,128
81119418:	98a6703a 	and	r19,r19,r2
8111941c:	00803f84 	movi	r2,254
81119420:	10ffa916 	blt	r2,r3,811192c8 <__reset+0xfb0f92c8>
81119424:	980891ba 	slli	r4,r19,6
81119428:	a829883a 	mov	r20,r21
8111942c:	2008d27a 	srli	r4,r4,9
81119430:	003f8606 	br	8111924c <__reset+0xfb0f924c>
81119434:	9080102c 	andhi	r2,r18,64
81119438:	10000826 	beq	r2,zero,8111945c <__mulsf3+0x364>
8111943c:	9880102c 	andhi	r2,r19,64
81119440:	1000061e 	bne	r2,zero,8111945c <__mulsf3+0x364>
81119444:	00802034 	movhi	r2,128
81119448:	99001034 	orhi	r4,r19,64
8111944c:	10bfffc4 	addi	r2,r2,-1
81119450:	b029883a 	mov	r20,r22
81119454:	2088703a 	and	r4,r4,r2
81119458:	003fba06 	br	81119344 <__reset+0xfb0f9344>
8111945c:	00802034 	movhi	r2,128
81119460:	91001034 	orhi	r4,r18,64
81119464:	10bfffc4 	addi	r2,r2,-1
81119468:	2088703a 	and	r4,r4,r2
8111946c:	003fb506 	br	81119344 <__reset+0xfb0f9344>
81119470:	00800044 	movi	r2,1
81119474:	10c7c83a 	sub	r3,r2,r3
81119478:	008006c4 	movi	r2,27
8111947c:	10ff7016 	blt	r2,r3,81119240 <__reset+0xfb0f9240>
81119480:	00800804 	movi	r2,32
81119484:	10c5c83a 	sub	r2,r2,r3
81119488:	9884983a 	sll	r2,r19,r2
8111948c:	98c6d83a 	srl	r3,r19,r3
81119490:	1004c03a 	cmpne	r2,r2,zero
81119494:	1884b03a 	or	r2,r3,r2
81119498:	10c001cc 	andi	r3,r2,7
8111949c:	18000426 	beq	r3,zero,811194b0 <__mulsf3+0x3b8>
811194a0:	10c003cc 	andi	r3,r2,15
811194a4:	01000104 	movi	r4,4
811194a8:	19000126 	beq	r3,r4,811194b0 <__mulsf3+0x3b8>
811194ac:	1105883a 	add	r2,r2,r4
811194b0:	10c1002c 	andhi	r3,r2,1024
811194b4:	18000626 	beq	r3,zero,811194d0 <__mulsf3+0x3d8>
811194b8:	a829883a 	mov	r20,r21
811194bc:	00c00044 	movi	r3,1
811194c0:	0009883a 	mov	r4,zero
811194c4:	003f6106 	br	8111924c <__reset+0xfb0f924c>
811194c8:	3821883a 	mov	r16,r7
811194cc:	003fc506 	br	811193e4 <__reset+0xfb0f93e4>
811194d0:	100491ba 	slli	r2,r2,6
811194d4:	a829883a 	mov	r20,r21
811194d8:	0007883a 	mov	r3,zero
811194dc:	1008d27a 	srli	r4,r2,9
811194e0:	003f5a06 	br	8111924c <__reset+0xfb0f924c>
811194e4:	00802034 	movhi	r2,128
811194e8:	99001034 	orhi	r4,r19,64
811194ec:	10bfffc4 	addi	r2,r2,-1
811194f0:	a829883a 	mov	r20,r21
811194f4:	2088703a 	and	r4,r4,r2
811194f8:	003f9206 	br	81119344 <__reset+0xfb0f9344>

811194fc <__floatunsisf>:
811194fc:	defffe04 	addi	sp,sp,-8
81119500:	de00012e 	bgeu	sp,et,81119508 <__floatunsisf+0xc>
81119504:	003b68fa 	trap	3
81119508:	dfc00115 	stw	ra,4(sp)
8111950c:	dc000015 	stw	r16,0(sp)
81119510:	20002c26 	beq	r4,zero,811195c4 <__floatunsisf+0xc8>
81119514:	2021883a 	mov	r16,r4
81119518:	111ab180 	call	8111ab18 <__clzsi2>
8111951c:	00c02784 	movi	r3,158
81119520:	1887c83a 	sub	r3,r3,r2
81119524:	01002584 	movi	r4,150
81119528:	20c00f16 	blt	r4,r3,81119568 <__floatunsisf+0x6c>
8111952c:	20c9c83a 	sub	r4,r4,r3
81119530:	8108983a 	sll	r4,r16,r4
81119534:	00802034 	movhi	r2,128
81119538:	10bfffc4 	addi	r2,r2,-1
8111953c:	2088703a 	and	r4,r4,r2
81119540:	18803fcc 	andi	r2,r3,255
81119544:	100695fa 	slli	r3,r2,23
81119548:	00802034 	movhi	r2,128
8111954c:	10bfffc4 	addi	r2,r2,-1
81119550:	2084703a 	and	r2,r4,r2
81119554:	10c4b03a 	or	r2,r2,r3
81119558:	dfc00117 	ldw	ra,4(sp)
8111955c:	dc000017 	ldw	r16,0(sp)
81119560:	dec00204 	addi	sp,sp,8
81119564:	f800283a 	ret
81119568:	01002644 	movi	r4,153
8111956c:	20c01816 	blt	r4,r3,811195d0 <__floatunsisf+0xd4>
81119570:	20c9c83a 	sub	r4,r4,r3
81119574:	8108983a 	sll	r4,r16,r4
81119578:	017f0034 	movhi	r5,64512
8111957c:	297fffc4 	addi	r5,r5,-1
81119580:	218001cc 	andi	r6,r4,7
81119584:	214a703a 	and	r5,r4,r5
81119588:	30000426 	beq	r6,zero,8111959c <__floatunsisf+0xa0>
8111958c:	210003cc 	andi	r4,r4,15
81119590:	01800104 	movi	r6,4
81119594:	21800126 	beq	r4,r6,8111959c <__floatunsisf+0xa0>
81119598:	298b883a 	add	r5,r5,r6
8111959c:	2901002c 	andhi	r4,r5,1024
811195a0:	20000526 	beq	r4,zero,811195b8 <__floatunsisf+0xbc>
811195a4:	00c027c4 	movi	r3,159
811195a8:	1887c83a 	sub	r3,r3,r2
811195ac:	00bf0034 	movhi	r2,64512
811195b0:	10bfffc4 	addi	r2,r2,-1
811195b4:	288a703a 	and	r5,r5,r2
811195b8:	280891ba 	slli	r4,r5,6
811195bc:	2008d27a 	srli	r4,r4,9
811195c0:	003fdf06 	br	81119540 <__reset+0xfb0f9540>
811195c4:	0007883a 	mov	r3,zero
811195c8:	0009883a 	mov	r4,zero
811195cc:	003fdc06 	br	81119540 <__reset+0xfb0f9540>
811195d0:	01402e44 	movi	r5,185
811195d4:	28cbc83a 	sub	r5,r5,r3
811195d8:	01000144 	movi	r4,5
811195dc:	2089c83a 	sub	r4,r4,r2
811195e0:	814a983a 	sll	r5,r16,r5
811195e4:	8108d83a 	srl	r4,r16,r4
811195e8:	2820c03a 	cmpne	r16,r5,zero
811195ec:	2408b03a 	or	r4,r4,r16
811195f0:	003fe106 	br	81119578 <__reset+0xfb0f9578>

811195f4 <__gedf2>:
811195f4:	2804d53a 	srli	r2,r5,20
811195f8:	3806d53a 	srli	r3,r7,20
811195fc:	02000434 	movhi	r8,16
81119600:	423fffc4 	addi	r8,r8,-1
81119604:	1081ffcc 	andi	r2,r2,2047
81119608:	0241ffc4 	movi	r9,2047
8111960c:	2a14703a 	and	r10,r5,r8
81119610:	18c1ffcc 	andi	r3,r3,2047
81119614:	3a10703a 	and	r8,r7,r8
81119618:	280ad7fa 	srli	r5,r5,31
8111961c:	380ed7fa 	srli	r7,r7,31
81119620:	12401d26 	beq	r2,r9,81119698 <__gedf2+0xa4>
81119624:	0241ffc4 	movi	r9,2047
81119628:	1a401226 	beq	r3,r9,81119674 <__gedf2+0x80>
8111962c:	1000081e 	bne	r2,zero,81119650 <__gedf2+0x5c>
81119630:	2296b03a 	or	r11,r4,r10
81119634:	5813003a 	cmpeq	r9,r11,zero
81119638:	1800091e 	bne	r3,zero,81119660 <__gedf2+0x6c>
8111963c:	3218b03a 	or	r12,r6,r8
81119640:	6000071e 	bne	r12,zero,81119660 <__gedf2+0x6c>
81119644:	0005883a 	mov	r2,zero
81119648:	5800101e 	bne	r11,zero,8111968c <__gedf2+0x98>
8111964c:	f800283a 	ret
81119650:	18000c1e 	bne	r3,zero,81119684 <__gedf2+0x90>
81119654:	3212b03a 	or	r9,r6,r8
81119658:	48000c26 	beq	r9,zero,8111968c <__gedf2+0x98>
8111965c:	0013883a 	mov	r9,zero
81119660:	39c03fcc 	andi	r7,r7,255
81119664:	48000826 	beq	r9,zero,81119688 <__gedf2+0x94>
81119668:	38000926 	beq	r7,zero,81119690 <__gedf2+0x9c>
8111966c:	00800044 	movi	r2,1
81119670:	f800283a 	ret
81119674:	3212b03a 	or	r9,r6,r8
81119678:	483fec26 	beq	r9,zero,8111962c <__reset+0xfb0f962c>
8111967c:	00bfff84 	movi	r2,-2
81119680:	f800283a 	ret
81119684:	39c03fcc 	andi	r7,r7,255
81119688:	29c00626 	beq	r5,r7,811196a4 <__gedf2+0xb0>
8111968c:	283ff726 	beq	r5,zero,8111966c <__reset+0xfb0f966c>
81119690:	00bfffc4 	movi	r2,-1
81119694:	f800283a 	ret
81119698:	2292b03a 	or	r9,r4,r10
8111969c:	483fe126 	beq	r9,zero,81119624 <__reset+0xfb0f9624>
811196a0:	003ff606 	br	8111967c <__reset+0xfb0f967c>
811196a4:	18bff916 	blt	r3,r2,8111968c <__reset+0xfb0f968c>
811196a8:	10c00316 	blt	r2,r3,811196b8 <__gedf2+0xc4>
811196ac:	42bff736 	bltu	r8,r10,8111968c <__reset+0xfb0f968c>
811196b0:	52000326 	beq	r10,r8,811196c0 <__gedf2+0xcc>
811196b4:	5200042e 	bgeu	r10,r8,811196c8 <__gedf2+0xd4>
811196b8:	283fec1e 	bne	r5,zero,8111966c <__reset+0xfb0f966c>
811196bc:	003ff406 	br	81119690 <__reset+0xfb0f9690>
811196c0:	313ff236 	bltu	r6,r4,8111968c <__reset+0xfb0f968c>
811196c4:	21bffc36 	bltu	r4,r6,811196b8 <__reset+0xfb0f96b8>
811196c8:	0005883a 	mov	r2,zero
811196cc:	f800283a 	ret

811196d0 <__muldf3>:
811196d0:	defff304 	addi	sp,sp,-52
811196d4:	2804d53a 	srli	r2,r5,20
811196d8:	de00012e 	bgeu	sp,et,811196e0 <__muldf3+0x10>
811196dc:	003b68fa 	trap	3
811196e0:	dd800915 	stw	r22,36(sp)
811196e4:	282cd7fa 	srli	r22,r5,31
811196e8:	dc000315 	stw	r16,12(sp)
811196ec:	04000434 	movhi	r16,16
811196f0:	dd400815 	stw	r21,32(sp)
811196f4:	dc800515 	stw	r18,20(sp)
811196f8:	843fffc4 	addi	r16,r16,-1
811196fc:	dfc00c15 	stw	ra,48(sp)
81119700:	df000b15 	stw	fp,44(sp)
81119704:	ddc00a15 	stw	r23,40(sp)
81119708:	dd000715 	stw	r20,28(sp)
8111970c:	dcc00615 	stw	r19,24(sp)
81119710:	dc400415 	stw	r17,16(sp)
81119714:	1481ffcc 	andi	r18,r2,2047
81119718:	2c20703a 	and	r16,r5,r16
8111971c:	b02b883a 	mov	r21,r22
81119720:	b2403fcc 	andi	r9,r22,255
81119724:	90006026 	beq	r18,zero,811198a8 <__muldf3+0x1d8>
81119728:	0081ffc4 	movi	r2,2047
8111972c:	2029883a 	mov	r20,r4
81119730:	90803626 	beq	r18,r2,8111980c <__muldf3+0x13c>
81119734:	80800434 	orhi	r2,r16,16
81119738:	100490fa 	slli	r2,r2,3
8111973c:	2020d77a 	srli	r16,r4,29
81119740:	202890fa 	slli	r20,r4,3
81119744:	94bf0044 	addi	r18,r18,-1023
81119748:	80a0b03a 	or	r16,r16,r2
8111974c:	0027883a 	mov	r19,zero
81119750:	0039883a 	mov	fp,zero
81119754:	3804d53a 	srli	r2,r7,20
81119758:	382ed7fa 	srli	r23,r7,31
8111975c:	04400434 	movhi	r17,16
81119760:	8c7fffc4 	addi	r17,r17,-1
81119764:	1081ffcc 	andi	r2,r2,2047
81119768:	3011883a 	mov	r8,r6
8111976c:	3c62703a 	and	r17,r7,r17
81119770:	ba803fcc 	andi	r10,r23,255
81119774:	10006d26 	beq	r2,zero,8111992c <__muldf3+0x25c>
81119778:	00c1ffc4 	movi	r3,2047
8111977c:	10c06526 	beq	r2,r3,81119914 <__muldf3+0x244>
81119780:	88c00434 	orhi	r3,r17,16
81119784:	180690fa 	slli	r3,r3,3
81119788:	3022d77a 	srli	r17,r6,29
8111978c:	301090fa 	slli	r8,r6,3
81119790:	10bf0044 	addi	r2,r2,-1023
81119794:	88e2b03a 	or	r17,r17,r3
81119798:	000b883a 	mov	r5,zero
8111979c:	9085883a 	add	r2,r18,r2
811197a0:	2cc8b03a 	or	r4,r5,r19
811197a4:	00c003c4 	movi	r3,15
811197a8:	bdacf03a 	xor	r22,r23,r22
811197ac:	12c00044 	addi	r11,r2,1
811197b0:	19009936 	bltu	r3,r4,81119a18 <__muldf3+0x348>
811197b4:	200890ba 	slli	r4,r4,2
811197b8:	00e044b4 	movhi	r3,33042
811197bc:	18e5f304 	addi	r3,r3,-26676
811197c0:	20c9883a 	add	r4,r4,r3
811197c4:	20c00017 	ldw	r3,0(r4)
811197c8:	1800683a 	jmp	r3
811197cc:	81119a18 	cmpnei	r4,r16,18024
811197d0:	8111982c 	andhi	r4,r16,18016
811197d4:	8111982c 	andhi	r4,r16,18016
811197d8:	81119828 	cmpgeui	r4,r16,18016
811197dc:	811199f4 	orhi	r4,r16,18023
811197e0:	811199f4 	orhi	r4,r16,18023
811197e4:	811199dc 	xori	r4,r16,18023
811197e8:	81119828 	cmpgeui	r4,r16,18016
811197ec:	811199f4 	orhi	r4,r16,18023
811197f0:	811199dc 	xori	r4,r16,18023
811197f4:	811199f4 	orhi	r4,r16,18023
811197f8:	81119828 	cmpgeui	r4,r16,18016
811197fc:	81119a04 	addi	r4,r16,18024
81119800:	81119a04 	addi	r4,r16,18024
81119804:	81119a04 	addi	r4,r16,18024
81119808:	81119c20 	cmpeqi	r4,r16,18032
8111980c:	2404b03a 	or	r2,r4,r16
81119810:	10006f1e 	bne	r2,zero,811199d0 <__muldf3+0x300>
81119814:	04c00204 	movi	r19,8
81119818:	0021883a 	mov	r16,zero
8111981c:	0029883a 	mov	r20,zero
81119820:	07000084 	movi	fp,2
81119824:	003fcb06 	br	81119754 <__reset+0xfb0f9754>
81119828:	502d883a 	mov	r22,r10
8111982c:	00800084 	movi	r2,2
81119830:	28805726 	beq	r5,r2,81119990 <__muldf3+0x2c0>
81119834:	008000c4 	movi	r2,3
81119838:	28816626 	beq	r5,r2,81119dd4 <__muldf3+0x704>
8111983c:	00800044 	movi	r2,1
81119840:	2881411e 	bne	r5,r2,81119d48 <__muldf3+0x678>
81119844:	b02b883a 	mov	r21,r22
81119848:	0005883a 	mov	r2,zero
8111984c:	000b883a 	mov	r5,zero
81119850:	0029883a 	mov	r20,zero
81119854:	1004953a 	slli	r2,r2,20
81119858:	a8c03fcc 	andi	r3,r21,255
8111985c:	04400434 	movhi	r17,16
81119860:	8c7fffc4 	addi	r17,r17,-1
81119864:	180697fa 	slli	r3,r3,31
81119868:	2c4a703a 	and	r5,r5,r17
8111986c:	288ab03a 	or	r5,r5,r2
81119870:	28c6b03a 	or	r3,r5,r3
81119874:	a005883a 	mov	r2,r20
81119878:	dfc00c17 	ldw	ra,48(sp)
8111987c:	df000b17 	ldw	fp,44(sp)
81119880:	ddc00a17 	ldw	r23,40(sp)
81119884:	dd800917 	ldw	r22,36(sp)
81119888:	dd400817 	ldw	r21,32(sp)
8111988c:	dd000717 	ldw	r20,28(sp)
81119890:	dcc00617 	ldw	r19,24(sp)
81119894:	dc800517 	ldw	r18,20(sp)
81119898:	dc400417 	ldw	r17,16(sp)
8111989c:	dc000317 	ldw	r16,12(sp)
811198a0:	dec00d04 	addi	sp,sp,52
811198a4:	f800283a 	ret
811198a8:	2404b03a 	or	r2,r4,r16
811198ac:	2027883a 	mov	r19,r4
811198b0:	10004226 	beq	r2,zero,811199bc <__muldf3+0x2ec>
811198b4:	8000fc26 	beq	r16,zero,81119ca8 <__muldf3+0x5d8>
811198b8:	8009883a 	mov	r4,r16
811198bc:	d9800215 	stw	r6,8(sp)
811198c0:	d9c00015 	stw	r7,0(sp)
811198c4:	da400115 	stw	r9,4(sp)
811198c8:	111ab180 	call	8111ab18 <__clzsi2>
811198cc:	d9800217 	ldw	r6,8(sp)
811198d0:	d9c00017 	ldw	r7,0(sp)
811198d4:	da400117 	ldw	r9,4(sp)
811198d8:	113ffd44 	addi	r4,r2,-11
811198dc:	00c00704 	movi	r3,28
811198e0:	1900ed16 	blt	r3,r4,81119c98 <__muldf3+0x5c8>
811198e4:	00c00744 	movi	r3,29
811198e8:	147ffe04 	addi	r17,r2,-8
811198ec:	1907c83a 	sub	r3,r3,r4
811198f0:	8460983a 	sll	r16,r16,r17
811198f4:	98c6d83a 	srl	r3,r19,r3
811198f8:	9c68983a 	sll	r20,r19,r17
811198fc:	1c20b03a 	or	r16,r3,r16
81119900:	1080fcc4 	addi	r2,r2,1011
81119904:	00a5c83a 	sub	r18,zero,r2
81119908:	0027883a 	mov	r19,zero
8111990c:	0039883a 	mov	fp,zero
81119910:	003f9006 	br	81119754 <__reset+0xfb0f9754>
81119914:	3446b03a 	or	r3,r6,r17
81119918:	1800261e 	bne	r3,zero,811199b4 <__muldf3+0x2e4>
8111991c:	0023883a 	mov	r17,zero
81119920:	0011883a 	mov	r8,zero
81119924:	01400084 	movi	r5,2
81119928:	003f9c06 	br	8111979c <__reset+0xfb0f979c>
8111992c:	3446b03a 	or	r3,r6,r17
81119930:	18001c26 	beq	r3,zero,811199a4 <__muldf3+0x2d4>
81119934:	8800ce26 	beq	r17,zero,81119c70 <__muldf3+0x5a0>
81119938:	8809883a 	mov	r4,r17
8111993c:	d9800215 	stw	r6,8(sp)
81119940:	da400115 	stw	r9,4(sp)
81119944:	da800015 	stw	r10,0(sp)
81119948:	111ab180 	call	8111ab18 <__clzsi2>
8111994c:	d9800217 	ldw	r6,8(sp)
81119950:	da400117 	ldw	r9,4(sp)
81119954:	da800017 	ldw	r10,0(sp)
81119958:	113ffd44 	addi	r4,r2,-11
8111995c:	00c00704 	movi	r3,28
81119960:	1900bf16 	blt	r3,r4,81119c60 <__muldf3+0x590>
81119964:	00c00744 	movi	r3,29
81119968:	123ffe04 	addi	r8,r2,-8
8111996c:	1907c83a 	sub	r3,r3,r4
81119970:	8a22983a 	sll	r17,r17,r8
81119974:	30c6d83a 	srl	r3,r6,r3
81119978:	3210983a 	sll	r8,r6,r8
8111997c:	1c62b03a 	or	r17,r3,r17
81119980:	1080fcc4 	addi	r2,r2,1011
81119984:	0085c83a 	sub	r2,zero,r2
81119988:	000b883a 	mov	r5,zero
8111998c:	003f8306 	br	8111979c <__reset+0xfb0f979c>
81119990:	b02b883a 	mov	r21,r22
81119994:	0081ffc4 	movi	r2,2047
81119998:	000b883a 	mov	r5,zero
8111999c:	0029883a 	mov	r20,zero
811199a0:	003fac06 	br	81119854 <__reset+0xfb0f9854>
811199a4:	0023883a 	mov	r17,zero
811199a8:	0011883a 	mov	r8,zero
811199ac:	01400044 	movi	r5,1
811199b0:	003f7a06 	br	8111979c <__reset+0xfb0f979c>
811199b4:	014000c4 	movi	r5,3
811199b8:	003f7806 	br	8111979c <__reset+0xfb0f979c>
811199bc:	04c00104 	movi	r19,4
811199c0:	0021883a 	mov	r16,zero
811199c4:	0029883a 	mov	r20,zero
811199c8:	07000044 	movi	fp,1
811199cc:	003f6106 	br	81119754 <__reset+0xfb0f9754>
811199d0:	04c00304 	movi	r19,12
811199d4:	070000c4 	movi	fp,3
811199d8:	003f5e06 	br	81119754 <__reset+0xfb0f9754>
811199dc:	01400434 	movhi	r5,16
811199e0:	002b883a 	mov	r21,zero
811199e4:	297fffc4 	addi	r5,r5,-1
811199e8:	053fffc4 	movi	r20,-1
811199ec:	0081ffc4 	movi	r2,2047
811199f0:	003f9806 	br	81119854 <__reset+0xfb0f9854>
811199f4:	8023883a 	mov	r17,r16
811199f8:	a011883a 	mov	r8,r20
811199fc:	e00b883a 	mov	r5,fp
81119a00:	003f8a06 	br	8111982c <__reset+0xfb0f982c>
81119a04:	8023883a 	mov	r17,r16
81119a08:	a011883a 	mov	r8,r20
81119a0c:	482d883a 	mov	r22,r9
81119a10:	e00b883a 	mov	r5,fp
81119a14:	003f8506 	br	8111982c <__reset+0xfb0f982c>
81119a18:	a00ad43a 	srli	r5,r20,16
81119a1c:	401ad43a 	srli	r13,r8,16
81119a20:	a53fffcc 	andi	r20,r20,65535
81119a24:	423fffcc 	andi	r8,r8,65535
81119a28:	4519383a 	mul	r12,r8,r20
81119a2c:	4147383a 	mul	r3,r8,r5
81119a30:	6d09383a 	mul	r4,r13,r20
81119a34:	600cd43a 	srli	r6,r12,16
81119a38:	2b5d383a 	mul	r14,r5,r13
81119a3c:	20c9883a 	add	r4,r4,r3
81119a40:	310d883a 	add	r6,r6,r4
81119a44:	30c0022e 	bgeu	r6,r3,81119a50 <__muldf3+0x380>
81119a48:	00c00074 	movhi	r3,1
81119a4c:	70dd883a 	add	r14,r14,r3
81119a50:	8826d43a 	srli	r19,r17,16
81119a54:	8bffffcc 	andi	r15,r17,65535
81119a58:	7d23383a 	mul	r17,r15,r20
81119a5c:	7949383a 	mul	r4,r15,r5
81119a60:	9d29383a 	mul	r20,r19,r20
81119a64:	8814d43a 	srli	r10,r17,16
81119a68:	3012943a 	slli	r9,r6,16
81119a6c:	a129883a 	add	r20,r20,r4
81119a70:	633fffcc 	andi	r12,r12,65535
81119a74:	5515883a 	add	r10,r10,r20
81119a78:	3006d43a 	srli	r3,r6,16
81119a7c:	4b13883a 	add	r9,r9,r12
81119a80:	2ccb383a 	mul	r5,r5,r19
81119a84:	5100022e 	bgeu	r10,r4,81119a90 <__muldf3+0x3c0>
81119a88:	01000074 	movhi	r4,1
81119a8c:	290b883a 	add	r5,r5,r4
81119a90:	802ad43a 	srli	r21,r16,16
81119a94:	843fffcc 	andi	r16,r16,65535
81119a98:	440d383a 	mul	r6,r8,r16
81119a9c:	4565383a 	mul	r18,r8,r21
81119aa0:	8349383a 	mul	r4,r16,r13
81119aa4:	500e943a 	slli	r7,r10,16
81119aa8:	3010d43a 	srli	r8,r6,16
81119aac:	5028d43a 	srli	r20,r10,16
81119ab0:	2489883a 	add	r4,r4,r18
81119ab4:	8abfffcc 	andi	r10,r17,65535
81119ab8:	3a95883a 	add	r10,r7,r10
81119abc:	4119883a 	add	r12,r8,r4
81119ac0:	a169883a 	add	r20,r20,r5
81119ac4:	1a87883a 	add	r3,r3,r10
81119ac8:	6d5b383a 	mul	r13,r13,r21
81119acc:	6480022e 	bgeu	r12,r18,81119ad8 <__muldf3+0x408>
81119ad0:	01000074 	movhi	r4,1
81119ad4:	691b883a 	add	r13,r13,r4
81119ad8:	7c25383a 	mul	r18,r15,r16
81119adc:	7d4b383a 	mul	r5,r15,r21
81119ae0:	84cf383a 	mul	r7,r16,r19
81119ae4:	901ed43a 	srli	r15,r18,16
81119ae8:	6008d43a 	srli	r4,r12,16
81119aec:	6010943a 	slli	r8,r12,16
81119af0:	394f883a 	add	r7,r7,r5
81119af4:	333fffcc 	andi	r12,r6,65535
81119af8:	79df883a 	add	r15,r15,r7
81119afc:	235b883a 	add	r13,r4,r13
81119b00:	9d63383a 	mul	r17,r19,r21
81119b04:	4309883a 	add	r4,r8,r12
81119b08:	7940022e 	bgeu	r15,r5,81119b14 <__muldf3+0x444>
81119b0c:	01400074 	movhi	r5,1
81119b10:	8963883a 	add	r17,r17,r5
81119b14:	780a943a 	slli	r5,r15,16
81119b18:	91bfffcc 	andi	r6,r18,65535
81119b1c:	70c7883a 	add	r3,r14,r3
81119b20:	298d883a 	add	r6,r5,r6
81119b24:	1a8f803a 	cmpltu	r7,r3,r10
81119b28:	350b883a 	add	r5,r6,r20
81119b2c:	20c7883a 	add	r3,r4,r3
81119b30:	3955883a 	add	r10,r7,r5
81119b34:	1909803a 	cmpltu	r4,r3,r4
81119b38:	6a91883a 	add	r8,r13,r10
81119b3c:	780cd43a 	srli	r6,r15,16
81119b40:	2219883a 	add	r12,r4,r8
81119b44:	2d0b803a 	cmpltu	r5,r5,r20
81119b48:	51cf803a 	cmpltu	r7,r10,r7
81119b4c:	29ceb03a 	or	r7,r5,r7
81119b50:	4351803a 	cmpltu	r8,r8,r13
81119b54:	610b803a 	cmpltu	r5,r12,r4
81119b58:	4148b03a 	or	r4,r8,r5
81119b5c:	398f883a 	add	r7,r7,r6
81119b60:	3909883a 	add	r4,r7,r4
81119b64:	1810927a 	slli	r8,r3,9
81119b68:	2449883a 	add	r4,r4,r17
81119b6c:	2008927a 	slli	r4,r4,9
81119b70:	6022d5fa 	srli	r17,r12,23
81119b74:	1806d5fa 	srli	r3,r3,23
81119b78:	4252b03a 	or	r9,r8,r9
81119b7c:	600a927a 	slli	r5,r12,9
81119b80:	4810c03a 	cmpne	r8,r9,zero
81119b84:	2462b03a 	or	r17,r4,r17
81119b88:	40c6b03a 	or	r3,r8,r3
81119b8c:	8900402c 	andhi	r4,r17,256
81119b90:	1950b03a 	or	r8,r3,r5
81119b94:	20000726 	beq	r4,zero,81119bb4 <__muldf3+0x4e4>
81119b98:	4006d07a 	srli	r3,r8,1
81119b9c:	880497fa 	slli	r2,r17,31
81119ba0:	4200004c 	andi	r8,r8,1
81119ba4:	8822d07a 	srli	r17,r17,1
81119ba8:	1a10b03a 	or	r8,r3,r8
81119bac:	1210b03a 	or	r8,r2,r8
81119bb0:	5805883a 	mov	r2,r11
81119bb4:	1140ffc4 	addi	r5,r2,1023
81119bb8:	0140440e 	bge	zero,r5,81119ccc <__muldf3+0x5fc>
81119bbc:	40c001cc 	andi	r3,r8,7
81119bc0:	18000726 	beq	r3,zero,81119be0 <__muldf3+0x510>
81119bc4:	40c003cc 	andi	r3,r8,15
81119bc8:	01000104 	movi	r4,4
81119bcc:	19000426 	beq	r3,r4,81119be0 <__muldf3+0x510>
81119bd0:	4107883a 	add	r3,r8,r4
81119bd4:	1a11803a 	cmpltu	r8,r3,r8
81119bd8:	8a23883a 	add	r17,r17,r8
81119bdc:	1811883a 	mov	r8,r3
81119be0:	88c0402c 	andhi	r3,r17,256
81119be4:	18000426 	beq	r3,zero,81119bf8 <__muldf3+0x528>
81119be8:	11410004 	addi	r5,r2,1024
81119bec:	00bfc034 	movhi	r2,65280
81119bf0:	10bfffc4 	addi	r2,r2,-1
81119bf4:	88a2703a 	and	r17,r17,r2
81119bf8:	0081ff84 	movi	r2,2046
81119bfc:	117f6416 	blt	r2,r5,81119990 <__reset+0xfb0f9990>
81119c00:	8828977a 	slli	r20,r17,29
81119c04:	4010d0fa 	srli	r8,r8,3
81119c08:	8822927a 	slli	r17,r17,9
81119c0c:	2881ffcc 	andi	r2,r5,2047
81119c10:	a228b03a 	or	r20,r20,r8
81119c14:	880ad33a 	srli	r5,r17,12
81119c18:	b02b883a 	mov	r21,r22
81119c1c:	003f0d06 	br	81119854 <__reset+0xfb0f9854>
81119c20:	8080022c 	andhi	r2,r16,8
81119c24:	10000926 	beq	r2,zero,81119c4c <__muldf3+0x57c>
81119c28:	8880022c 	andhi	r2,r17,8
81119c2c:	1000071e 	bne	r2,zero,81119c4c <__muldf3+0x57c>
81119c30:	00800434 	movhi	r2,16
81119c34:	89400234 	orhi	r5,r17,8
81119c38:	10bfffc4 	addi	r2,r2,-1
81119c3c:	b82b883a 	mov	r21,r23
81119c40:	288a703a 	and	r5,r5,r2
81119c44:	4029883a 	mov	r20,r8
81119c48:	003f6806 	br	811199ec <__reset+0xfb0f99ec>
81119c4c:	00800434 	movhi	r2,16
81119c50:	81400234 	orhi	r5,r16,8
81119c54:	10bfffc4 	addi	r2,r2,-1
81119c58:	288a703a 	and	r5,r5,r2
81119c5c:	003f6306 	br	811199ec <__reset+0xfb0f99ec>
81119c60:	147ff604 	addi	r17,r2,-40
81119c64:	3462983a 	sll	r17,r6,r17
81119c68:	0011883a 	mov	r8,zero
81119c6c:	003f4406 	br	81119980 <__reset+0xfb0f9980>
81119c70:	3009883a 	mov	r4,r6
81119c74:	d9800215 	stw	r6,8(sp)
81119c78:	da400115 	stw	r9,4(sp)
81119c7c:	da800015 	stw	r10,0(sp)
81119c80:	111ab180 	call	8111ab18 <__clzsi2>
81119c84:	10800804 	addi	r2,r2,32
81119c88:	da800017 	ldw	r10,0(sp)
81119c8c:	da400117 	ldw	r9,4(sp)
81119c90:	d9800217 	ldw	r6,8(sp)
81119c94:	003f3006 	br	81119958 <__reset+0xfb0f9958>
81119c98:	143ff604 	addi	r16,r2,-40
81119c9c:	9c20983a 	sll	r16,r19,r16
81119ca0:	0029883a 	mov	r20,zero
81119ca4:	003f1606 	br	81119900 <__reset+0xfb0f9900>
81119ca8:	d9800215 	stw	r6,8(sp)
81119cac:	d9c00015 	stw	r7,0(sp)
81119cb0:	da400115 	stw	r9,4(sp)
81119cb4:	111ab180 	call	8111ab18 <__clzsi2>
81119cb8:	10800804 	addi	r2,r2,32
81119cbc:	da400117 	ldw	r9,4(sp)
81119cc0:	d9c00017 	ldw	r7,0(sp)
81119cc4:	d9800217 	ldw	r6,8(sp)
81119cc8:	003f0306 	br	811198d8 <__reset+0xfb0f98d8>
81119ccc:	00c00044 	movi	r3,1
81119cd0:	1947c83a 	sub	r3,r3,r5
81119cd4:	00800e04 	movi	r2,56
81119cd8:	10feda16 	blt	r2,r3,81119844 <__reset+0xfb0f9844>
81119cdc:	008007c4 	movi	r2,31
81119ce0:	10c01b16 	blt	r2,r3,81119d50 <__muldf3+0x680>
81119ce4:	00800804 	movi	r2,32
81119ce8:	10c5c83a 	sub	r2,r2,r3
81119cec:	888a983a 	sll	r5,r17,r2
81119cf0:	40c8d83a 	srl	r4,r8,r3
81119cf4:	4084983a 	sll	r2,r8,r2
81119cf8:	88e2d83a 	srl	r17,r17,r3
81119cfc:	2906b03a 	or	r3,r5,r4
81119d00:	1004c03a 	cmpne	r2,r2,zero
81119d04:	1886b03a 	or	r3,r3,r2
81119d08:	188001cc 	andi	r2,r3,7
81119d0c:	10000726 	beq	r2,zero,81119d2c <__muldf3+0x65c>
81119d10:	188003cc 	andi	r2,r3,15
81119d14:	01000104 	movi	r4,4
81119d18:	11000426 	beq	r2,r4,81119d2c <__muldf3+0x65c>
81119d1c:	1805883a 	mov	r2,r3
81119d20:	10c00104 	addi	r3,r2,4
81119d24:	1885803a 	cmpltu	r2,r3,r2
81119d28:	88a3883a 	add	r17,r17,r2
81119d2c:	8880202c 	andhi	r2,r17,128
81119d30:	10001c26 	beq	r2,zero,81119da4 <__muldf3+0x6d4>
81119d34:	b02b883a 	mov	r21,r22
81119d38:	00800044 	movi	r2,1
81119d3c:	000b883a 	mov	r5,zero
81119d40:	0029883a 	mov	r20,zero
81119d44:	003ec306 	br	81119854 <__reset+0xfb0f9854>
81119d48:	5805883a 	mov	r2,r11
81119d4c:	003f9906 	br	81119bb4 <__reset+0xfb0f9bb4>
81119d50:	00bff844 	movi	r2,-31
81119d54:	1145c83a 	sub	r2,r2,r5
81119d58:	8888d83a 	srl	r4,r17,r2
81119d5c:	00800804 	movi	r2,32
81119d60:	18801a26 	beq	r3,r2,81119dcc <__muldf3+0x6fc>
81119d64:	00801004 	movi	r2,64
81119d68:	10c5c83a 	sub	r2,r2,r3
81119d6c:	8884983a 	sll	r2,r17,r2
81119d70:	1204b03a 	or	r2,r2,r8
81119d74:	1004c03a 	cmpne	r2,r2,zero
81119d78:	2084b03a 	or	r2,r4,r2
81119d7c:	144001cc 	andi	r17,r2,7
81119d80:	88000d1e 	bne	r17,zero,81119db8 <__muldf3+0x6e8>
81119d84:	000b883a 	mov	r5,zero
81119d88:	1028d0fa 	srli	r20,r2,3
81119d8c:	b02b883a 	mov	r21,r22
81119d90:	0005883a 	mov	r2,zero
81119d94:	a468b03a 	or	r20,r20,r17
81119d98:	003eae06 	br	81119854 <__reset+0xfb0f9854>
81119d9c:	1007883a 	mov	r3,r2
81119da0:	0023883a 	mov	r17,zero
81119da4:	880a927a 	slli	r5,r17,9
81119da8:	1805883a 	mov	r2,r3
81119dac:	8822977a 	slli	r17,r17,29
81119db0:	280ad33a 	srli	r5,r5,12
81119db4:	003ff406 	br	81119d88 <__reset+0xfb0f9d88>
81119db8:	10c003cc 	andi	r3,r2,15
81119dbc:	01000104 	movi	r4,4
81119dc0:	193ff626 	beq	r3,r4,81119d9c <__reset+0xfb0f9d9c>
81119dc4:	0023883a 	mov	r17,zero
81119dc8:	003fd506 	br	81119d20 <__reset+0xfb0f9d20>
81119dcc:	0005883a 	mov	r2,zero
81119dd0:	003fe706 	br	81119d70 <__reset+0xfb0f9d70>
81119dd4:	00800434 	movhi	r2,16
81119dd8:	89400234 	orhi	r5,r17,8
81119ddc:	10bfffc4 	addi	r2,r2,-1
81119de0:	b02b883a 	mov	r21,r22
81119de4:	288a703a 	and	r5,r5,r2
81119de8:	4029883a 	mov	r20,r8
81119dec:	003eff06 	br	811199ec <__reset+0xfb0f99ec>

81119df0 <__subdf3>:
81119df0:	02000434 	movhi	r8,16
81119df4:	423fffc4 	addi	r8,r8,-1
81119df8:	defffb04 	addi	sp,sp,-20
81119dfc:	2a14703a 	and	r10,r5,r8
81119e00:	3812d53a 	srli	r9,r7,20
81119e04:	3a10703a 	and	r8,r7,r8
81119e08:	de00012e 	bgeu	sp,et,81119e10 <__subdf3+0x20>
81119e0c:	003b68fa 	trap	3
81119e10:	2006d77a 	srli	r3,r4,29
81119e14:	3004d77a 	srli	r2,r6,29
81119e18:	dc000015 	stw	r16,0(sp)
81119e1c:	501490fa 	slli	r10,r10,3
81119e20:	2820d53a 	srli	r16,r5,20
81119e24:	401090fa 	slli	r8,r8,3
81119e28:	dc800215 	stw	r18,8(sp)
81119e2c:	dc400115 	stw	r17,4(sp)
81119e30:	dfc00415 	stw	ra,16(sp)
81119e34:	202290fa 	slli	r17,r4,3
81119e38:	dcc00315 	stw	r19,12(sp)
81119e3c:	4a41ffcc 	andi	r9,r9,2047
81119e40:	0101ffc4 	movi	r4,2047
81119e44:	2824d7fa 	srli	r18,r5,31
81119e48:	8401ffcc 	andi	r16,r16,2047
81119e4c:	50c6b03a 	or	r3,r10,r3
81119e50:	380ed7fa 	srli	r7,r7,31
81119e54:	408ab03a 	or	r5,r8,r2
81119e58:	300c90fa 	slli	r6,r6,3
81119e5c:	49009626 	beq	r9,r4,8111a0b8 <__subdf3+0x2c8>
81119e60:	39c0005c 	xori	r7,r7,1
81119e64:	8245c83a 	sub	r2,r16,r9
81119e68:	3c807426 	beq	r7,r18,8111a03c <__subdf3+0x24c>
81119e6c:	0080af0e 	bge	zero,r2,8111a12c <__subdf3+0x33c>
81119e70:	48002a1e 	bne	r9,zero,81119f1c <__subdf3+0x12c>
81119e74:	2988b03a 	or	r4,r5,r6
81119e78:	20009a1e 	bne	r4,zero,8111a0e4 <__subdf3+0x2f4>
81119e7c:	888001cc 	andi	r2,r17,7
81119e80:	10000726 	beq	r2,zero,81119ea0 <__subdf3+0xb0>
81119e84:	888003cc 	andi	r2,r17,15
81119e88:	01000104 	movi	r4,4
81119e8c:	11000426 	beq	r2,r4,81119ea0 <__subdf3+0xb0>
81119e90:	890b883a 	add	r5,r17,r4
81119e94:	2c63803a 	cmpltu	r17,r5,r17
81119e98:	1c47883a 	add	r3,r3,r17
81119e9c:	2823883a 	mov	r17,r5
81119ea0:	1880202c 	andhi	r2,r3,128
81119ea4:	10005926 	beq	r2,zero,8111a00c <__subdf3+0x21c>
81119ea8:	84000044 	addi	r16,r16,1
81119eac:	0081ffc4 	movi	r2,2047
81119eb0:	8080be26 	beq	r16,r2,8111a1ac <__subdf3+0x3bc>
81119eb4:	017fe034 	movhi	r5,65408
81119eb8:	297fffc4 	addi	r5,r5,-1
81119ebc:	1946703a 	and	r3,r3,r5
81119ec0:	1804977a 	slli	r2,r3,29
81119ec4:	1806927a 	slli	r3,r3,9
81119ec8:	8822d0fa 	srli	r17,r17,3
81119ecc:	8401ffcc 	andi	r16,r16,2047
81119ed0:	180ad33a 	srli	r5,r3,12
81119ed4:	9100004c 	andi	r4,r18,1
81119ed8:	1444b03a 	or	r2,r2,r17
81119edc:	80c1ffcc 	andi	r3,r16,2047
81119ee0:	1820953a 	slli	r16,r3,20
81119ee4:	20c03fcc 	andi	r3,r4,255
81119ee8:	180897fa 	slli	r4,r3,31
81119eec:	00c00434 	movhi	r3,16
81119ef0:	18ffffc4 	addi	r3,r3,-1
81119ef4:	28c6703a 	and	r3,r5,r3
81119ef8:	1c06b03a 	or	r3,r3,r16
81119efc:	1906b03a 	or	r3,r3,r4
81119f00:	dfc00417 	ldw	ra,16(sp)
81119f04:	dcc00317 	ldw	r19,12(sp)
81119f08:	dc800217 	ldw	r18,8(sp)
81119f0c:	dc400117 	ldw	r17,4(sp)
81119f10:	dc000017 	ldw	r16,0(sp)
81119f14:	dec00504 	addi	sp,sp,20
81119f18:	f800283a 	ret
81119f1c:	0101ffc4 	movi	r4,2047
81119f20:	813fd626 	beq	r16,r4,81119e7c <__reset+0xfb0f9e7c>
81119f24:	29402034 	orhi	r5,r5,128
81119f28:	01000e04 	movi	r4,56
81119f2c:	2080a316 	blt	r4,r2,8111a1bc <__subdf3+0x3cc>
81119f30:	010007c4 	movi	r4,31
81119f34:	2080c616 	blt	r4,r2,8111a250 <__subdf3+0x460>
81119f38:	01000804 	movi	r4,32
81119f3c:	2089c83a 	sub	r4,r4,r2
81119f40:	2910983a 	sll	r8,r5,r4
81119f44:	308ed83a 	srl	r7,r6,r2
81119f48:	3108983a 	sll	r4,r6,r4
81119f4c:	2884d83a 	srl	r2,r5,r2
81119f50:	41ccb03a 	or	r6,r8,r7
81119f54:	2008c03a 	cmpne	r4,r4,zero
81119f58:	310cb03a 	or	r6,r6,r4
81119f5c:	898dc83a 	sub	r6,r17,r6
81119f60:	89a3803a 	cmpltu	r17,r17,r6
81119f64:	1887c83a 	sub	r3,r3,r2
81119f68:	1c47c83a 	sub	r3,r3,r17
81119f6c:	3023883a 	mov	r17,r6
81119f70:	1880202c 	andhi	r2,r3,128
81119f74:	10002326 	beq	r2,zero,8111a004 <__subdf3+0x214>
81119f78:	04c02034 	movhi	r19,128
81119f7c:	9cffffc4 	addi	r19,r19,-1
81119f80:	1ce6703a 	and	r19,r3,r19
81119f84:	98007a26 	beq	r19,zero,8111a170 <__subdf3+0x380>
81119f88:	9809883a 	mov	r4,r19
81119f8c:	111ab180 	call	8111ab18 <__clzsi2>
81119f90:	113ffe04 	addi	r4,r2,-8
81119f94:	00c007c4 	movi	r3,31
81119f98:	19007b16 	blt	r3,r4,8111a188 <__subdf3+0x398>
81119f9c:	00800804 	movi	r2,32
81119fa0:	1105c83a 	sub	r2,r2,r4
81119fa4:	8884d83a 	srl	r2,r17,r2
81119fa8:	9906983a 	sll	r3,r19,r4
81119fac:	8922983a 	sll	r17,r17,r4
81119fb0:	10c4b03a 	or	r2,r2,r3
81119fb4:	24007816 	blt	r4,r16,8111a198 <__subdf3+0x3a8>
81119fb8:	2421c83a 	sub	r16,r4,r16
81119fbc:	80c00044 	addi	r3,r16,1
81119fc0:	010007c4 	movi	r4,31
81119fc4:	20c09516 	blt	r4,r3,8111a21c <__subdf3+0x42c>
81119fc8:	01400804 	movi	r5,32
81119fcc:	28cbc83a 	sub	r5,r5,r3
81119fd0:	88c8d83a 	srl	r4,r17,r3
81119fd4:	8962983a 	sll	r17,r17,r5
81119fd8:	114a983a 	sll	r5,r2,r5
81119fdc:	10c6d83a 	srl	r3,r2,r3
81119fe0:	8804c03a 	cmpne	r2,r17,zero
81119fe4:	290ab03a 	or	r5,r5,r4
81119fe8:	28a2b03a 	or	r17,r5,r2
81119fec:	0021883a 	mov	r16,zero
81119ff0:	003fa206 	br	81119e7c <__reset+0xfb0f9e7c>
81119ff4:	2090b03a 	or	r8,r4,r2
81119ff8:	40018e26 	beq	r8,zero,8111a634 <__subdf3+0x844>
81119ffc:	1007883a 	mov	r3,r2
8111a000:	2023883a 	mov	r17,r4
8111a004:	888001cc 	andi	r2,r17,7
8111a008:	103f9e1e 	bne	r2,zero,81119e84 <__reset+0xfb0f9e84>
8111a00c:	1804977a 	slli	r2,r3,29
8111a010:	8822d0fa 	srli	r17,r17,3
8111a014:	1810d0fa 	srli	r8,r3,3
8111a018:	9100004c 	andi	r4,r18,1
8111a01c:	1444b03a 	or	r2,r2,r17
8111a020:	00c1ffc4 	movi	r3,2047
8111a024:	80c02826 	beq	r16,r3,8111a0c8 <__subdf3+0x2d8>
8111a028:	01400434 	movhi	r5,16
8111a02c:	297fffc4 	addi	r5,r5,-1
8111a030:	80e0703a 	and	r16,r16,r3
8111a034:	414a703a 	and	r5,r8,r5
8111a038:	003fa806 	br	81119edc <__reset+0xfb0f9edc>
8111a03c:	0080630e 	bge	zero,r2,8111a1cc <__subdf3+0x3dc>
8111a040:	48003026 	beq	r9,zero,8111a104 <__subdf3+0x314>
8111a044:	0101ffc4 	movi	r4,2047
8111a048:	813f8c26 	beq	r16,r4,81119e7c <__reset+0xfb0f9e7c>
8111a04c:	29402034 	orhi	r5,r5,128
8111a050:	01000e04 	movi	r4,56
8111a054:	2080a90e 	bge	r4,r2,8111a2fc <__subdf3+0x50c>
8111a058:	298cb03a 	or	r6,r5,r6
8111a05c:	3012c03a 	cmpne	r9,r6,zero
8111a060:	0005883a 	mov	r2,zero
8111a064:	4c53883a 	add	r9,r9,r17
8111a068:	4c63803a 	cmpltu	r17,r9,r17
8111a06c:	10c7883a 	add	r3,r2,r3
8111a070:	88c7883a 	add	r3,r17,r3
8111a074:	4823883a 	mov	r17,r9
8111a078:	1880202c 	andhi	r2,r3,128
8111a07c:	1000d026 	beq	r2,zero,8111a3c0 <__subdf3+0x5d0>
8111a080:	84000044 	addi	r16,r16,1
8111a084:	0081ffc4 	movi	r2,2047
8111a088:	8080fe26 	beq	r16,r2,8111a484 <__subdf3+0x694>
8111a08c:	00bfe034 	movhi	r2,65408
8111a090:	10bfffc4 	addi	r2,r2,-1
8111a094:	1886703a 	and	r3,r3,r2
8111a098:	880ad07a 	srli	r5,r17,1
8111a09c:	180497fa 	slli	r2,r3,31
8111a0a0:	8900004c 	andi	r4,r17,1
8111a0a4:	2922b03a 	or	r17,r5,r4
8111a0a8:	1806d07a 	srli	r3,r3,1
8111a0ac:	1462b03a 	or	r17,r2,r17
8111a0b0:	3825883a 	mov	r18,r7
8111a0b4:	003f7106 	br	81119e7c <__reset+0xfb0f9e7c>
8111a0b8:	2984b03a 	or	r2,r5,r6
8111a0bc:	103f6826 	beq	r2,zero,81119e60 <__reset+0xfb0f9e60>
8111a0c0:	39c03fcc 	andi	r7,r7,255
8111a0c4:	003f6706 	br	81119e64 <__reset+0xfb0f9e64>
8111a0c8:	4086b03a 	or	r3,r8,r2
8111a0cc:	18015226 	beq	r3,zero,8111a618 <__subdf3+0x828>
8111a0d0:	00c00434 	movhi	r3,16
8111a0d4:	41400234 	orhi	r5,r8,8
8111a0d8:	18ffffc4 	addi	r3,r3,-1
8111a0dc:	28ca703a 	and	r5,r5,r3
8111a0e0:	003f7e06 	br	81119edc <__reset+0xfb0f9edc>
8111a0e4:	10bfffc4 	addi	r2,r2,-1
8111a0e8:	1000491e 	bne	r2,zero,8111a210 <__subdf3+0x420>
8111a0ec:	898fc83a 	sub	r7,r17,r6
8111a0f0:	89e3803a 	cmpltu	r17,r17,r7
8111a0f4:	1947c83a 	sub	r3,r3,r5
8111a0f8:	1c47c83a 	sub	r3,r3,r17
8111a0fc:	3823883a 	mov	r17,r7
8111a100:	003f9b06 	br	81119f70 <__reset+0xfb0f9f70>
8111a104:	2988b03a 	or	r4,r5,r6
8111a108:	203f5c26 	beq	r4,zero,81119e7c <__reset+0xfb0f9e7c>
8111a10c:	10bfffc4 	addi	r2,r2,-1
8111a110:	1000931e 	bne	r2,zero,8111a360 <__subdf3+0x570>
8111a114:	898d883a 	add	r6,r17,r6
8111a118:	3463803a 	cmpltu	r17,r6,r17
8111a11c:	1947883a 	add	r3,r3,r5
8111a120:	88c7883a 	add	r3,r17,r3
8111a124:	3023883a 	mov	r17,r6
8111a128:	003fd306 	br	8111a078 <__reset+0xfb0fa078>
8111a12c:	1000541e 	bne	r2,zero,8111a280 <__subdf3+0x490>
8111a130:	80800044 	addi	r2,r16,1
8111a134:	1081ffcc 	andi	r2,r2,2047
8111a138:	01000044 	movi	r4,1
8111a13c:	2080a20e 	bge	r4,r2,8111a3c8 <__subdf3+0x5d8>
8111a140:	8989c83a 	sub	r4,r17,r6
8111a144:	8905803a 	cmpltu	r2,r17,r4
8111a148:	1967c83a 	sub	r19,r3,r5
8111a14c:	98a7c83a 	sub	r19,r19,r2
8111a150:	9880202c 	andhi	r2,r19,128
8111a154:	10006326 	beq	r2,zero,8111a2e4 <__subdf3+0x4f4>
8111a158:	3463c83a 	sub	r17,r6,r17
8111a15c:	28c7c83a 	sub	r3,r5,r3
8111a160:	344d803a 	cmpltu	r6,r6,r17
8111a164:	19a7c83a 	sub	r19,r3,r6
8111a168:	3825883a 	mov	r18,r7
8111a16c:	983f861e 	bne	r19,zero,81119f88 <__reset+0xfb0f9f88>
8111a170:	8809883a 	mov	r4,r17
8111a174:	111ab180 	call	8111ab18 <__clzsi2>
8111a178:	10800804 	addi	r2,r2,32
8111a17c:	113ffe04 	addi	r4,r2,-8
8111a180:	00c007c4 	movi	r3,31
8111a184:	193f850e 	bge	r3,r4,81119f9c <__reset+0xfb0f9f9c>
8111a188:	10bff604 	addi	r2,r2,-40
8111a18c:	8884983a 	sll	r2,r17,r2
8111a190:	0023883a 	mov	r17,zero
8111a194:	243f880e 	bge	r4,r16,81119fb8 <__reset+0xfb0f9fb8>
8111a198:	00ffe034 	movhi	r3,65408
8111a19c:	18ffffc4 	addi	r3,r3,-1
8111a1a0:	8121c83a 	sub	r16,r16,r4
8111a1a4:	10c6703a 	and	r3,r2,r3
8111a1a8:	003f3406 	br	81119e7c <__reset+0xfb0f9e7c>
8111a1ac:	9100004c 	andi	r4,r18,1
8111a1b0:	000b883a 	mov	r5,zero
8111a1b4:	0005883a 	mov	r2,zero
8111a1b8:	003f4806 	br	81119edc <__reset+0xfb0f9edc>
8111a1bc:	298cb03a 	or	r6,r5,r6
8111a1c0:	300cc03a 	cmpne	r6,r6,zero
8111a1c4:	0005883a 	mov	r2,zero
8111a1c8:	003f6406 	br	81119f5c <__reset+0xfb0f9f5c>
8111a1cc:	10009a1e 	bne	r2,zero,8111a438 <__subdf3+0x648>
8111a1d0:	82400044 	addi	r9,r16,1
8111a1d4:	4881ffcc 	andi	r2,r9,2047
8111a1d8:	02800044 	movi	r10,1
8111a1dc:	5080670e 	bge	r10,r2,8111a37c <__subdf3+0x58c>
8111a1e0:	0081ffc4 	movi	r2,2047
8111a1e4:	4880af26 	beq	r9,r2,8111a4a4 <__subdf3+0x6b4>
8111a1e8:	898d883a 	add	r6,r17,r6
8111a1ec:	1945883a 	add	r2,r3,r5
8111a1f0:	3447803a 	cmpltu	r3,r6,r17
8111a1f4:	1887883a 	add	r3,r3,r2
8111a1f8:	182297fa 	slli	r17,r3,31
8111a1fc:	300cd07a 	srli	r6,r6,1
8111a200:	1806d07a 	srli	r3,r3,1
8111a204:	4821883a 	mov	r16,r9
8111a208:	89a2b03a 	or	r17,r17,r6
8111a20c:	003f1b06 	br	81119e7c <__reset+0xfb0f9e7c>
8111a210:	0101ffc4 	movi	r4,2047
8111a214:	813f441e 	bne	r16,r4,81119f28 <__reset+0xfb0f9f28>
8111a218:	003f1806 	br	81119e7c <__reset+0xfb0f9e7c>
8111a21c:	843ff844 	addi	r16,r16,-31
8111a220:	01400804 	movi	r5,32
8111a224:	1408d83a 	srl	r4,r2,r16
8111a228:	19405026 	beq	r3,r5,8111a36c <__subdf3+0x57c>
8111a22c:	01401004 	movi	r5,64
8111a230:	28c7c83a 	sub	r3,r5,r3
8111a234:	10c4983a 	sll	r2,r2,r3
8111a238:	88a2b03a 	or	r17,r17,r2
8111a23c:	8822c03a 	cmpne	r17,r17,zero
8111a240:	2462b03a 	or	r17,r4,r17
8111a244:	0007883a 	mov	r3,zero
8111a248:	0021883a 	mov	r16,zero
8111a24c:	003f6d06 	br	8111a004 <__reset+0xfb0fa004>
8111a250:	11fff804 	addi	r7,r2,-32
8111a254:	01000804 	movi	r4,32
8111a258:	29ced83a 	srl	r7,r5,r7
8111a25c:	11004526 	beq	r2,r4,8111a374 <__subdf3+0x584>
8111a260:	01001004 	movi	r4,64
8111a264:	2089c83a 	sub	r4,r4,r2
8111a268:	2904983a 	sll	r2,r5,r4
8111a26c:	118cb03a 	or	r6,r2,r6
8111a270:	300cc03a 	cmpne	r6,r6,zero
8111a274:	398cb03a 	or	r6,r7,r6
8111a278:	0005883a 	mov	r2,zero
8111a27c:	003f3706 	br	81119f5c <__reset+0xfb0f9f5c>
8111a280:	80002a26 	beq	r16,zero,8111a32c <__subdf3+0x53c>
8111a284:	0101ffc4 	movi	r4,2047
8111a288:	49006626 	beq	r9,r4,8111a424 <__subdf3+0x634>
8111a28c:	0085c83a 	sub	r2,zero,r2
8111a290:	18c02034 	orhi	r3,r3,128
8111a294:	01000e04 	movi	r4,56
8111a298:	20807e16 	blt	r4,r2,8111a494 <__subdf3+0x6a4>
8111a29c:	010007c4 	movi	r4,31
8111a2a0:	2080e716 	blt	r4,r2,8111a640 <__subdf3+0x850>
8111a2a4:	01000804 	movi	r4,32
8111a2a8:	2089c83a 	sub	r4,r4,r2
8111a2ac:	1914983a 	sll	r10,r3,r4
8111a2b0:	8890d83a 	srl	r8,r17,r2
8111a2b4:	8908983a 	sll	r4,r17,r4
8111a2b8:	1884d83a 	srl	r2,r3,r2
8111a2bc:	5222b03a 	or	r17,r10,r8
8111a2c0:	2006c03a 	cmpne	r3,r4,zero
8111a2c4:	88e2b03a 	or	r17,r17,r3
8111a2c8:	3463c83a 	sub	r17,r6,r17
8111a2cc:	2885c83a 	sub	r2,r5,r2
8111a2d0:	344d803a 	cmpltu	r6,r6,r17
8111a2d4:	1187c83a 	sub	r3,r2,r6
8111a2d8:	4821883a 	mov	r16,r9
8111a2dc:	3825883a 	mov	r18,r7
8111a2e0:	003f2306 	br	81119f70 <__reset+0xfb0f9f70>
8111a2e4:	24d0b03a 	or	r8,r4,r19
8111a2e8:	40001b1e 	bne	r8,zero,8111a358 <__subdf3+0x568>
8111a2ec:	0005883a 	mov	r2,zero
8111a2f0:	0009883a 	mov	r4,zero
8111a2f4:	0021883a 	mov	r16,zero
8111a2f8:	003f4906 	br	8111a020 <__reset+0xfb0fa020>
8111a2fc:	010007c4 	movi	r4,31
8111a300:	20803a16 	blt	r4,r2,8111a3ec <__subdf3+0x5fc>
8111a304:	01000804 	movi	r4,32
8111a308:	2089c83a 	sub	r4,r4,r2
8111a30c:	2912983a 	sll	r9,r5,r4
8111a310:	3090d83a 	srl	r8,r6,r2
8111a314:	3108983a 	sll	r4,r6,r4
8111a318:	2884d83a 	srl	r2,r5,r2
8111a31c:	4a12b03a 	or	r9,r9,r8
8111a320:	2008c03a 	cmpne	r4,r4,zero
8111a324:	4912b03a 	or	r9,r9,r4
8111a328:	003f4e06 	br	8111a064 <__reset+0xfb0fa064>
8111a32c:	1c48b03a 	or	r4,r3,r17
8111a330:	20003c26 	beq	r4,zero,8111a424 <__subdf3+0x634>
8111a334:	0084303a 	nor	r2,zero,r2
8111a338:	1000381e 	bne	r2,zero,8111a41c <__subdf3+0x62c>
8111a33c:	3463c83a 	sub	r17,r6,r17
8111a340:	28c5c83a 	sub	r2,r5,r3
8111a344:	344d803a 	cmpltu	r6,r6,r17
8111a348:	1187c83a 	sub	r3,r2,r6
8111a34c:	4821883a 	mov	r16,r9
8111a350:	3825883a 	mov	r18,r7
8111a354:	003f0606 	br	81119f70 <__reset+0xfb0f9f70>
8111a358:	2023883a 	mov	r17,r4
8111a35c:	003f0906 	br	81119f84 <__reset+0xfb0f9f84>
8111a360:	0101ffc4 	movi	r4,2047
8111a364:	813f3a1e 	bne	r16,r4,8111a050 <__reset+0xfb0fa050>
8111a368:	003ec406 	br	81119e7c <__reset+0xfb0f9e7c>
8111a36c:	0005883a 	mov	r2,zero
8111a370:	003fb106 	br	8111a238 <__reset+0xfb0fa238>
8111a374:	0005883a 	mov	r2,zero
8111a378:	003fbc06 	br	8111a26c <__reset+0xfb0fa26c>
8111a37c:	1c44b03a 	or	r2,r3,r17
8111a380:	80008e1e 	bne	r16,zero,8111a5bc <__subdf3+0x7cc>
8111a384:	1000c826 	beq	r2,zero,8111a6a8 <__subdf3+0x8b8>
8111a388:	2984b03a 	or	r2,r5,r6
8111a38c:	103ebb26 	beq	r2,zero,81119e7c <__reset+0xfb0f9e7c>
8111a390:	8989883a 	add	r4,r17,r6
8111a394:	1945883a 	add	r2,r3,r5
8111a398:	2447803a 	cmpltu	r3,r4,r17
8111a39c:	1887883a 	add	r3,r3,r2
8111a3a0:	1880202c 	andhi	r2,r3,128
8111a3a4:	2023883a 	mov	r17,r4
8111a3a8:	103f1626 	beq	r2,zero,8111a004 <__reset+0xfb0fa004>
8111a3ac:	00bfe034 	movhi	r2,65408
8111a3b0:	10bfffc4 	addi	r2,r2,-1
8111a3b4:	5021883a 	mov	r16,r10
8111a3b8:	1886703a 	and	r3,r3,r2
8111a3bc:	003eaf06 	br	81119e7c <__reset+0xfb0f9e7c>
8111a3c0:	3825883a 	mov	r18,r7
8111a3c4:	003f0f06 	br	8111a004 <__reset+0xfb0fa004>
8111a3c8:	1c44b03a 	or	r2,r3,r17
8111a3cc:	8000251e 	bne	r16,zero,8111a464 <__subdf3+0x674>
8111a3d0:	1000661e 	bne	r2,zero,8111a56c <__subdf3+0x77c>
8111a3d4:	2990b03a 	or	r8,r5,r6
8111a3d8:	40009626 	beq	r8,zero,8111a634 <__subdf3+0x844>
8111a3dc:	2807883a 	mov	r3,r5
8111a3e0:	3023883a 	mov	r17,r6
8111a3e4:	3825883a 	mov	r18,r7
8111a3e8:	003ea406 	br	81119e7c <__reset+0xfb0f9e7c>
8111a3ec:	127ff804 	addi	r9,r2,-32
8111a3f0:	01000804 	movi	r4,32
8111a3f4:	2a52d83a 	srl	r9,r5,r9
8111a3f8:	11008c26 	beq	r2,r4,8111a62c <__subdf3+0x83c>
8111a3fc:	01001004 	movi	r4,64
8111a400:	2085c83a 	sub	r2,r4,r2
8111a404:	2884983a 	sll	r2,r5,r2
8111a408:	118cb03a 	or	r6,r2,r6
8111a40c:	300cc03a 	cmpne	r6,r6,zero
8111a410:	4992b03a 	or	r9,r9,r6
8111a414:	0005883a 	mov	r2,zero
8111a418:	003f1206 	br	8111a064 <__reset+0xfb0fa064>
8111a41c:	0101ffc4 	movi	r4,2047
8111a420:	493f9c1e 	bne	r9,r4,8111a294 <__reset+0xfb0fa294>
8111a424:	2807883a 	mov	r3,r5
8111a428:	3023883a 	mov	r17,r6
8111a42c:	4821883a 	mov	r16,r9
8111a430:	3825883a 	mov	r18,r7
8111a434:	003e9106 	br	81119e7c <__reset+0xfb0f9e7c>
8111a438:	80001f1e 	bne	r16,zero,8111a4b8 <__subdf3+0x6c8>
8111a43c:	1c48b03a 	or	r4,r3,r17
8111a440:	20005a26 	beq	r4,zero,8111a5ac <__subdf3+0x7bc>
8111a444:	0084303a 	nor	r2,zero,r2
8111a448:	1000561e 	bne	r2,zero,8111a5a4 <__subdf3+0x7b4>
8111a44c:	89a3883a 	add	r17,r17,r6
8111a450:	1945883a 	add	r2,r3,r5
8111a454:	898d803a 	cmpltu	r6,r17,r6
8111a458:	3087883a 	add	r3,r6,r2
8111a45c:	4821883a 	mov	r16,r9
8111a460:	003f0506 	br	8111a078 <__reset+0xfb0fa078>
8111a464:	10002b1e 	bne	r2,zero,8111a514 <__subdf3+0x724>
8111a468:	2984b03a 	or	r2,r5,r6
8111a46c:	10008026 	beq	r2,zero,8111a670 <__subdf3+0x880>
8111a470:	2807883a 	mov	r3,r5
8111a474:	3023883a 	mov	r17,r6
8111a478:	3825883a 	mov	r18,r7
8111a47c:	0401ffc4 	movi	r16,2047
8111a480:	003e7e06 	br	81119e7c <__reset+0xfb0f9e7c>
8111a484:	3809883a 	mov	r4,r7
8111a488:	0011883a 	mov	r8,zero
8111a48c:	0005883a 	mov	r2,zero
8111a490:	003ee306 	br	8111a020 <__reset+0xfb0fa020>
8111a494:	1c62b03a 	or	r17,r3,r17
8111a498:	8822c03a 	cmpne	r17,r17,zero
8111a49c:	0005883a 	mov	r2,zero
8111a4a0:	003f8906 	br	8111a2c8 <__reset+0xfb0fa2c8>
8111a4a4:	3809883a 	mov	r4,r7
8111a4a8:	4821883a 	mov	r16,r9
8111a4ac:	0011883a 	mov	r8,zero
8111a4b0:	0005883a 	mov	r2,zero
8111a4b4:	003eda06 	br	8111a020 <__reset+0xfb0fa020>
8111a4b8:	0101ffc4 	movi	r4,2047
8111a4bc:	49003b26 	beq	r9,r4,8111a5ac <__subdf3+0x7bc>
8111a4c0:	0085c83a 	sub	r2,zero,r2
8111a4c4:	18c02034 	orhi	r3,r3,128
8111a4c8:	01000e04 	movi	r4,56
8111a4cc:	20806e16 	blt	r4,r2,8111a688 <__subdf3+0x898>
8111a4d0:	010007c4 	movi	r4,31
8111a4d4:	20807716 	blt	r4,r2,8111a6b4 <__subdf3+0x8c4>
8111a4d8:	01000804 	movi	r4,32
8111a4dc:	2089c83a 	sub	r4,r4,r2
8111a4e0:	1914983a 	sll	r10,r3,r4
8111a4e4:	8890d83a 	srl	r8,r17,r2
8111a4e8:	8908983a 	sll	r4,r17,r4
8111a4ec:	1884d83a 	srl	r2,r3,r2
8111a4f0:	5222b03a 	or	r17,r10,r8
8111a4f4:	2006c03a 	cmpne	r3,r4,zero
8111a4f8:	88e2b03a 	or	r17,r17,r3
8111a4fc:	89a3883a 	add	r17,r17,r6
8111a500:	1145883a 	add	r2,r2,r5
8111a504:	898d803a 	cmpltu	r6,r17,r6
8111a508:	3087883a 	add	r3,r6,r2
8111a50c:	4821883a 	mov	r16,r9
8111a510:	003ed906 	br	8111a078 <__reset+0xfb0fa078>
8111a514:	2984b03a 	or	r2,r5,r6
8111a518:	10004226 	beq	r2,zero,8111a624 <__subdf3+0x834>
8111a51c:	1808d0fa 	srli	r4,r3,3
8111a520:	8822d0fa 	srli	r17,r17,3
8111a524:	1806977a 	slli	r3,r3,29
8111a528:	2080022c 	andhi	r2,r4,8
8111a52c:	1c62b03a 	or	r17,r3,r17
8111a530:	10000826 	beq	r2,zero,8111a554 <__subdf3+0x764>
8111a534:	2812d0fa 	srli	r9,r5,3
8111a538:	4880022c 	andhi	r2,r9,8
8111a53c:	1000051e 	bne	r2,zero,8111a554 <__subdf3+0x764>
8111a540:	300cd0fa 	srli	r6,r6,3
8111a544:	2804977a 	slli	r2,r5,29
8111a548:	4809883a 	mov	r4,r9
8111a54c:	3825883a 	mov	r18,r7
8111a550:	11a2b03a 	or	r17,r2,r6
8111a554:	8806d77a 	srli	r3,r17,29
8111a558:	200890fa 	slli	r4,r4,3
8111a55c:	882290fa 	slli	r17,r17,3
8111a560:	0401ffc4 	movi	r16,2047
8111a564:	1906b03a 	or	r3,r3,r4
8111a568:	003e4406 	br	81119e7c <__reset+0xfb0f9e7c>
8111a56c:	2984b03a 	or	r2,r5,r6
8111a570:	103e4226 	beq	r2,zero,81119e7c <__reset+0xfb0f9e7c>
8111a574:	8989c83a 	sub	r4,r17,r6
8111a578:	8911803a 	cmpltu	r8,r17,r4
8111a57c:	1945c83a 	sub	r2,r3,r5
8111a580:	1205c83a 	sub	r2,r2,r8
8111a584:	1200202c 	andhi	r8,r2,128
8111a588:	403e9a26 	beq	r8,zero,81119ff4 <__reset+0xfb0f9ff4>
8111a58c:	3463c83a 	sub	r17,r6,r17
8111a590:	28c5c83a 	sub	r2,r5,r3
8111a594:	344d803a 	cmpltu	r6,r6,r17
8111a598:	1187c83a 	sub	r3,r2,r6
8111a59c:	3825883a 	mov	r18,r7
8111a5a0:	003e3606 	br	81119e7c <__reset+0xfb0f9e7c>
8111a5a4:	0101ffc4 	movi	r4,2047
8111a5a8:	493fc71e 	bne	r9,r4,8111a4c8 <__reset+0xfb0fa4c8>
8111a5ac:	2807883a 	mov	r3,r5
8111a5b0:	3023883a 	mov	r17,r6
8111a5b4:	4821883a 	mov	r16,r9
8111a5b8:	003e3006 	br	81119e7c <__reset+0xfb0f9e7c>
8111a5bc:	10003626 	beq	r2,zero,8111a698 <__subdf3+0x8a8>
8111a5c0:	2984b03a 	or	r2,r5,r6
8111a5c4:	10001726 	beq	r2,zero,8111a624 <__subdf3+0x834>
8111a5c8:	1808d0fa 	srli	r4,r3,3
8111a5cc:	8822d0fa 	srli	r17,r17,3
8111a5d0:	1806977a 	slli	r3,r3,29
8111a5d4:	2080022c 	andhi	r2,r4,8
8111a5d8:	1c62b03a 	or	r17,r3,r17
8111a5dc:	10000726 	beq	r2,zero,8111a5fc <__subdf3+0x80c>
8111a5e0:	2812d0fa 	srli	r9,r5,3
8111a5e4:	4880022c 	andhi	r2,r9,8
8111a5e8:	1000041e 	bne	r2,zero,8111a5fc <__subdf3+0x80c>
8111a5ec:	300cd0fa 	srli	r6,r6,3
8111a5f0:	2804977a 	slli	r2,r5,29
8111a5f4:	4809883a 	mov	r4,r9
8111a5f8:	11a2b03a 	or	r17,r2,r6
8111a5fc:	8806d77a 	srli	r3,r17,29
8111a600:	200890fa 	slli	r4,r4,3
8111a604:	882290fa 	slli	r17,r17,3
8111a608:	3825883a 	mov	r18,r7
8111a60c:	1906b03a 	or	r3,r3,r4
8111a610:	0401ffc4 	movi	r16,2047
8111a614:	003e1906 	br	81119e7c <__reset+0xfb0f9e7c>
8111a618:	000b883a 	mov	r5,zero
8111a61c:	0005883a 	mov	r2,zero
8111a620:	003e2e06 	br	81119edc <__reset+0xfb0f9edc>
8111a624:	0401ffc4 	movi	r16,2047
8111a628:	003e1406 	br	81119e7c <__reset+0xfb0f9e7c>
8111a62c:	0005883a 	mov	r2,zero
8111a630:	003f7506 	br	8111a408 <__reset+0xfb0fa408>
8111a634:	0005883a 	mov	r2,zero
8111a638:	0009883a 	mov	r4,zero
8111a63c:	003e7806 	br	8111a020 <__reset+0xfb0fa020>
8111a640:	123ff804 	addi	r8,r2,-32
8111a644:	01000804 	movi	r4,32
8111a648:	1a10d83a 	srl	r8,r3,r8
8111a64c:	11002526 	beq	r2,r4,8111a6e4 <__subdf3+0x8f4>
8111a650:	01001004 	movi	r4,64
8111a654:	2085c83a 	sub	r2,r4,r2
8111a658:	1884983a 	sll	r2,r3,r2
8111a65c:	1444b03a 	or	r2,r2,r17
8111a660:	1004c03a 	cmpne	r2,r2,zero
8111a664:	40a2b03a 	or	r17,r8,r2
8111a668:	0005883a 	mov	r2,zero
8111a66c:	003f1606 	br	8111a2c8 <__reset+0xfb0fa2c8>
8111a670:	02000434 	movhi	r8,16
8111a674:	0009883a 	mov	r4,zero
8111a678:	423fffc4 	addi	r8,r8,-1
8111a67c:	00bfffc4 	movi	r2,-1
8111a680:	0401ffc4 	movi	r16,2047
8111a684:	003e6606 	br	8111a020 <__reset+0xfb0fa020>
8111a688:	1c62b03a 	or	r17,r3,r17
8111a68c:	8822c03a 	cmpne	r17,r17,zero
8111a690:	0005883a 	mov	r2,zero
8111a694:	003f9906 	br	8111a4fc <__reset+0xfb0fa4fc>
8111a698:	2807883a 	mov	r3,r5
8111a69c:	3023883a 	mov	r17,r6
8111a6a0:	0401ffc4 	movi	r16,2047
8111a6a4:	003df506 	br	81119e7c <__reset+0xfb0f9e7c>
8111a6a8:	2807883a 	mov	r3,r5
8111a6ac:	3023883a 	mov	r17,r6
8111a6b0:	003df206 	br	81119e7c <__reset+0xfb0f9e7c>
8111a6b4:	123ff804 	addi	r8,r2,-32
8111a6b8:	01000804 	movi	r4,32
8111a6bc:	1a10d83a 	srl	r8,r3,r8
8111a6c0:	11000a26 	beq	r2,r4,8111a6ec <__subdf3+0x8fc>
8111a6c4:	01001004 	movi	r4,64
8111a6c8:	2085c83a 	sub	r2,r4,r2
8111a6cc:	1884983a 	sll	r2,r3,r2
8111a6d0:	1444b03a 	or	r2,r2,r17
8111a6d4:	1004c03a 	cmpne	r2,r2,zero
8111a6d8:	40a2b03a 	or	r17,r8,r2
8111a6dc:	0005883a 	mov	r2,zero
8111a6e0:	003f8606 	br	8111a4fc <__reset+0xfb0fa4fc>
8111a6e4:	0005883a 	mov	r2,zero
8111a6e8:	003fdc06 	br	8111a65c <__reset+0xfb0fa65c>
8111a6ec:	0005883a 	mov	r2,zero
8111a6f0:	003ff706 	br	8111a6d0 <__reset+0xfb0fa6d0>

8111a6f4 <__fixdfsi>:
8111a6f4:	280cd53a 	srli	r6,r5,20
8111a6f8:	00c00434 	movhi	r3,16
8111a6fc:	18ffffc4 	addi	r3,r3,-1
8111a700:	3181ffcc 	andi	r6,r6,2047
8111a704:	01c0ff84 	movi	r7,1022
8111a708:	28c6703a 	and	r3,r5,r3
8111a70c:	280ad7fa 	srli	r5,r5,31
8111a710:	3980120e 	bge	r7,r6,8111a75c <__fixdfsi+0x68>
8111a714:	00810744 	movi	r2,1053
8111a718:	11800c16 	blt	r2,r6,8111a74c <__fixdfsi+0x58>
8111a71c:	00810cc4 	movi	r2,1075
8111a720:	1185c83a 	sub	r2,r2,r6
8111a724:	01c007c4 	movi	r7,31
8111a728:	18c00434 	orhi	r3,r3,16
8111a72c:	38800d16 	blt	r7,r2,8111a764 <__fixdfsi+0x70>
8111a730:	31befb44 	addi	r6,r6,-1043
8111a734:	2084d83a 	srl	r2,r4,r2
8111a738:	1986983a 	sll	r3,r3,r6
8111a73c:	1884b03a 	or	r2,r3,r2
8111a740:	28000726 	beq	r5,zero,8111a760 <__fixdfsi+0x6c>
8111a744:	0085c83a 	sub	r2,zero,r2
8111a748:	f800283a 	ret
8111a74c:	00a00034 	movhi	r2,32768
8111a750:	10bfffc4 	addi	r2,r2,-1
8111a754:	2885883a 	add	r2,r5,r2
8111a758:	f800283a 	ret
8111a75c:	0005883a 	mov	r2,zero
8111a760:	f800283a 	ret
8111a764:	008104c4 	movi	r2,1043
8111a768:	1185c83a 	sub	r2,r2,r6
8111a76c:	1884d83a 	srl	r2,r3,r2
8111a770:	003ff306 	br	8111a740 <__reset+0xfb0fa740>

8111a774 <__floatsidf>:
8111a774:	defffd04 	addi	sp,sp,-12
8111a778:	de00012e 	bgeu	sp,et,8111a780 <__floatsidf+0xc>
8111a77c:	003b68fa 	trap	3
8111a780:	dfc00215 	stw	ra,8(sp)
8111a784:	dc400115 	stw	r17,4(sp)
8111a788:	dc000015 	stw	r16,0(sp)
8111a78c:	20002b26 	beq	r4,zero,8111a83c <__floatsidf+0xc8>
8111a790:	2023883a 	mov	r17,r4
8111a794:	2020d7fa 	srli	r16,r4,31
8111a798:	20002d16 	blt	r4,zero,8111a850 <__floatsidf+0xdc>
8111a79c:	8809883a 	mov	r4,r17
8111a7a0:	111ab180 	call	8111ab18 <__clzsi2>
8111a7a4:	01410784 	movi	r5,1054
8111a7a8:	288bc83a 	sub	r5,r5,r2
8111a7ac:	01010cc4 	movi	r4,1075
8111a7b0:	2149c83a 	sub	r4,r4,r5
8111a7b4:	00c007c4 	movi	r3,31
8111a7b8:	1900160e 	bge	r3,r4,8111a814 <__floatsidf+0xa0>
8111a7bc:	00c104c4 	movi	r3,1043
8111a7c0:	1947c83a 	sub	r3,r3,r5
8111a7c4:	88c6983a 	sll	r3,r17,r3
8111a7c8:	00800434 	movhi	r2,16
8111a7cc:	10bfffc4 	addi	r2,r2,-1
8111a7d0:	1886703a 	and	r3,r3,r2
8111a7d4:	2941ffcc 	andi	r5,r5,2047
8111a7d8:	800d883a 	mov	r6,r16
8111a7dc:	0005883a 	mov	r2,zero
8111a7e0:	280a953a 	slli	r5,r5,20
8111a7e4:	31803fcc 	andi	r6,r6,255
8111a7e8:	01000434 	movhi	r4,16
8111a7ec:	300c97fa 	slli	r6,r6,31
8111a7f0:	213fffc4 	addi	r4,r4,-1
8111a7f4:	1906703a 	and	r3,r3,r4
8111a7f8:	1946b03a 	or	r3,r3,r5
8111a7fc:	1986b03a 	or	r3,r3,r6
8111a800:	dfc00217 	ldw	ra,8(sp)
8111a804:	dc400117 	ldw	r17,4(sp)
8111a808:	dc000017 	ldw	r16,0(sp)
8111a80c:	dec00304 	addi	sp,sp,12
8111a810:	f800283a 	ret
8111a814:	00c002c4 	movi	r3,11
8111a818:	1887c83a 	sub	r3,r3,r2
8111a81c:	88c6d83a 	srl	r3,r17,r3
8111a820:	8904983a 	sll	r2,r17,r4
8111a824:	01000434 	movhi	r4,16
8111a828:	213fffc4 	addi	r4,r4,-1
8111a82c:	2941ffcc 	andi	r5,r5,2047
8111a830:	1906703a 	and	r3,r3,r4
8111a834:	800d883a 	mov	r6,r16
8111a838:	003fe906 	br	8111a7e0 <__reset+0xfb0fa7e0>
8111a83c:	000d883a 	mov	r6,zero
8111a840:	000b883a 	mov	r5,zero
8111a844:	0007883a 	mov	r3,zero
8111a848:	0005883a 	mov	r2,zero
8111a84c:	003fe406 	br	8111a7e0 <__reset+0xfb0fa7e0>
8111a850:	0123c83a 	sub	r17,zero,r4
8111a854:	003fd106 	br	8111a79c <__reset+0xfb0fa79c>

8111a858 <__extendsfdf2>:
8111a858:	200ad5fa 	srli	r5,r4,23
8111a85c:	defffd04 	addi	sp,sp,-12
8111a860:	de00012e 	bgeu	sp,et,8111a868 <__extendsfdf2+0x10>
8111a864:	003b68fa 	trap	3
8111a868:	29403fcc 	andi	r5,r5,255
8111a86c:	dc400115 	stw	r17,4(sp)
8111a870:	29800044 	addi	r6,r5,1
8111a874:	04402034 	movhi	r17,128
8111a878:	dc000015 	stw	r16,0(sp)
8111a87c:	8c7fffc4 	addi	r17,r17,-1
8111a880:	dfc00215 	stw	ra,8(sp)
8111a884:	31803fcc 	andi	r6,r6,255
8111a888:	00800044 	movi	r2,1
8111a88c:	8922703a 	and	r17,r17,r4
8111a890:	2020d7fa 	srli	r16,r4,31
8111a894:	1180110e 	bge	r2,r6,8111a8dc <__extendsfdf2+0x84>
8111a898:	880cd0fa 	srli	r6,r17,3
8111a89c:	8822977a 	slli	r17,r17,29
8111a8a0:	2940e004 	addi	r5,r5,896
8111a8a4:	2941ffcc 	andi	r5,r5,2047
8111a8a8:	2804953a 	slli	r2,r5,20
8111a8ac:	01400434 	movhi	r5,16
8111a8b0:	800697fa 	slli	r3,r16,31
8111a8b4:	297fffc4 	addi	r5,r5,-1
8111a8b8:	314a703a 	and	r5,r6,r5
8111a8bc:	288ab03a 	or	r5,r5,r2
8111a8c0:	28c6b03a 	or	r3,r5,r3
8111a8c4:	8805883a 	mov	r2,r17
8111a8c8:	dfc00217 	ldw	ra,8(sp)
8111a8cc:	dc400117 	ldw	r17,4(sp)
8111a8d0:	dc000017 	ldw	r16,0(sp)
8111a8d4:	dec00304 	addi	sp,sp,12
8111a8d8:	f800283a 	ret
8111a8dc:	2800111e 	bne	r5,zero,8111a924 <__extendsfdf2+0xcc>
8111a8e0:	88001c26 	beq	r17,zero,8111a954 <__extendsfdf2+0xfc>
8111a8e4:	8809883a 	mov	r4,r17
8111a8e8:	111ab180 	call	8111ab18 <__clzsi2>
8111a8ec:	00c00284 	movi	r3,10
8111a8f0:	18801b16 	blt	r3,r2,8111a960 <__extendsfdf2+0x108>
8111a8f4:	018002c4 	movi	r6,11
8111a8f8:	308dc83a 	sub	r6,r6,r2
8111a8fc:	11000544 	addi	r4,r2,21
8111a900:	8986d83a 	srl	r3,r17,r6
8111a904:	8922983a 	sll	r17,r17,r4
8111a908:	0180e244 	movi	r6,905
8111a90c:	01400434 	movhi	r5,16
8111a910:	3085c83a 	sub	r2,r6,r2
8111a914:	297fffc4 	addi	r5,r5,-1
8111a918:	194c703a 	and	r6,r3,r5
8111a91c:	1141ffcc 	andi	r5,r2,2047
8111a920:	003fe006 	br	8111a8a4 <__reset+0xfb0fa8a4>
8111a924:	88000826 	beq	r17,zero,8111a948 <__extendsfdf2+0xf0>
8111a928:	880cd0fa 	srli	r6,r17,3
8111a92c:	00800434 	movhi	r2,16
8111a930:	10bfffc4 	addi	r2,r2,-1
8111a934:	31800234 	orhi	r6,r6,8
8111a938:	8822977a 	slli	r17,r17,29
8111a93c:	308c703a 	and	r6,r6,r2
8111a940:	0141ffc4 	movi	r5,2047
8111a944:	003fd706 	br	8111a8a4 <__reset+0xfb0fa8a4>
8111a948:	0141ffc4 	movi	r5,2047
8111a94c:	000d883a 	mov	r6,zero
8111a950:	003fd406 	br	8111a8a4 <__reset+0xfb0fa8a4>
8111a954:	000b883a 	mov	r5,zero
8111a958:	000d883a 	mov	r6,zero
8111a95c:	003fd106 	br	8111a8a4 <__reset+0xfb0fa8a4>
8111a960:	11bffd44 	addi	r6,r2,-11
8111a964:	8986983a 	sll	r3,r17,r6
8111a968:	0023883a 	mov	r17,zero
8111a96c:	003fe606 	br	8111a908 <__reset+0xfb0fa908>

8111a970 <__truncdfsf2>:
8111a970:	2810d53a 	srli	r8,r5,20
8111a974:	01c00434 	movhi	r7,16
8111a978:	39ffffc4 	addi	r7,r7,-1
8111a97c:	29ce703a 	and	r7,r5,r7
8111a980:	4201ffcc 	andi	r8,r8,2047
8111a984:	380e90fa 	slli	r7,r7,3
8111a988:	200cd77a 	srli	r6,r4,29
8111a98c:	42400044 	addi	r9,r8,1
8111a990:	4a41ffcc 	andi	r9,r9,2047
8111a994:	00c00044 	movi	r3,1
8111a998:	280ad7fa 	srli	r5,r5,31
8111a99c:	31ceb03a 	or	r7,r6,r7
8111a9a0:	200490fa 	slli	r2,r4,3
8111a9a4:	1a40230e 	bge	r3,r9,8111aa34 <__truncdfsf2+0xc4>
8111a9a8:	40ff2004 	addi	r3,r8,-896
8111a9ac:	01803f84 	movi	r6,254
8111a9b0:	30c01516 	blt	r6,r3,8111aa08 <__truncdfsf2+0x98>
8111a9b4:	00c0380e 	bge	zero,r3,8111aa98 <__truncdfsf2+0x128>
8111a9b8:	200c91ba 	slli	r6,r4,6
8111a9bc:	380e90fa 	slli	r7,r7,3
8111a9c0:	1004d77a 	srli	r2,r2,29
8111a9c4:	300cc03a 	cmpne	r6,r6,zero
8111a9c8:	31ccb03a 	or	r6,r6,r7
8111a9cc:	308cb03a 	or	r6,r6,r2
8111a9d0:	308001cc 	andi	r2,r6,7
8111a9d4:	10000426 	beq	r2,zero,8111a9e8 <__truncdfsf2+0x78>
8111a9d8:	308003cc 	andi	r2,r6,15
8111a9dc:	01000104 	movi	r4,4
8111a9e0:	11000126 	beq	r2,r4,8111a9e8 <__truncdfsf2+0x78>
8111a9e4:	31800104 	addi	r6,r6,4
8111a9e8:	3081002c 	andhi	r2,r6,1024
8111a9ec:	10001626 	beq	r2,zero,8111aa48 <__truncdfsf2+0xd8>
8111a9f0:	18c00044 	addi	r3,r3,1
8111a9f4:	00803fc4 	movi	r2,255
8111a9f8:	18800326 	beq	r3,r2,8111aa08 <__truncdfsf2+0x98>
8111a9fc:	300c91ba 	slli	r6,r6,6
8111aa00:	300cd27a 	srli	r6,r6,9
8111aa04:	00000206 	br	8111aa10 <__truncdfsf2+0xa0>
8111aa08:	00ffffc4 	movi	r3,-1
8111aa0c:	000d883a 	mov	r6,zero
8111aa10:	18c03fcc 	andi	r3,r3,255
8111aa14:	180895fa 	slli	r4,r3,23
8111aa18:	00c02034 	movhi	r3,128
8111aa1c:	280a97fa 	slli	r5,r5,31
8111aa20:	18ffffc4 	addi	r3,r3,-1
8111aa24:	30c6703a 	and	r3,r6,r3
8111aa28:	1906b03a 	or	r3,r3,r4
8111aa2c:	1944b03a 	or	r2,r3,r5
8111aa30:	f800283a 	ret
8111aa34:	40000b1e 	bne	r8,zero,8111aa64 <__truncdfsf2+0xf4>
8111aa38:	388cb03a 	or	r6,r7,r2
8111aa3c:	0007883a 	mov	r3,zero
8111aa40:	30000426 	beq	r6,zero,8111aa54 <__truncdfsf2+0xe4>
8111aa44:	01800144 	movi	r6,5
8111aa48:	00803fc4 	movi	r2,255
8111aa4c:	300cd0fa 	srli	r6,r6,3
8111aa50:	18800a26 	beq	r3,r2,8111aa7c <__truncdfsf2+0x10c>
8111aa54:	00802034 	movhi	r2,128
8111aa58:	10bfffc4 	addi	r2,r2,-1
8111aa5c:	308c703a 	and	r6,r6,r2
8111aa60:	003feb06 	br	8111aa10 <__reset+0xfb0faa10>
8111aa64:	3888b03a 	or	r4,r7,r2
8111aa68:	203fe726 	beq	r4,zero,8111aa08 <__reset+0xfb0faa08>
8111aa6c:	380c90fa 	slli	r6,r7,3
8111aa70:	00c03fc4 	movi	r3,255
8111aa74:	31808034 	orhi	r6,r6,512
8111aa78:	003fd506 	br	8111a9d0 <__reset+0xfb0fa9d0>
8111aa7c:	303fe226 	beq	r6,zero,8111aa08 <__reset+0xfb0faa08>
8111aa80:	00802034 	movhi	r2,128
8111aa84:	31801034 	orhi	r6,r6,64
8111aa88:	10bfffc4 	addi	r2,r2,-1
8111aa8c:	00ffffc4 	movi	r3,-1
8111aa90:	308c703a 	and	r6,r6,r2
8111aa94:	003fde06 	br	8111aa10 <__reset+0xfb0faa10>
8111aa98:	013ffa44 	movi	r4,-23
8111aa9c:	19000e16 	blt	r3,r4,8111aad8 <__truncdfsf2+0x168>
8111aaa0:	01000784 	movi	r4,30
8111aaa4:	20c9c83a 	sub	r4,r4,r3
8111aaa8:	018007c4 	movi	r6,31
8111aaac:	39c02034 	orhi	r7,r7,128
8111aab0:	31000b16 	blt	r6,r4,8111aae0 <__truncdfsf2+0x170>
8111aab4:	423f2084 	addi	r8,r8,-894
8111aab8:	120c983a 	sll	r6,r2,r8
8111aabc:	3a0e983a 	sll	r7,r7,r8
8111aac0:	1104d83a 	srl	r2,r2,r4
8111aac4:	300cc03a 	cmpne	r6,r6,zero
8111aac8:	31ceb03a 	or	r7,r6,r7
8111aacc:	388cb03a 	or	r6,r7,r2
8111aad0:	0007883a 	mov	r3,zero
8111aad4:	003fbe06 	br	8111a9d0 <__reset+0xfb0fa9d0>
8111aad8:	0007883a 	mov	r3,zero
8111aadc:	003fd906 	br	8111aa44 <__reset+0xfb0faa44>
8111aae0:	01bfff84 	movi	r6,-2
8111aae4:	30cdc83a 	sub	r6,r6,r3
8111aae8:	00c00804 	movi	r3,32
8111aaec:	398cd83a 	srl	r6,r7,r6
8111aaf0:	20c00726 	beq	r4,r3,8111ab10 <__truncdfsf2+0x1a0>
8111aaf4:	423f2884 	addi	r8,r8,-862
8111aaf8:	3a0e983a 	sll	r7,r7,r8
8111aafc:	3884b03a 	or	r2,r7,r2
8111ab00:	1004c03a 	cmpne	r2,r2,zero
8111ab04:	118cb03a 	or	r6,r2,r6
8111ab08:	0007883a 	mov	r3,zero
8111ab0c:	003fb006 	br	8111a9d0 <__reset+0xfb0fa9d0>
8111ab10:	000f883a 	mov	r7,zero
8111ab14:	003ff906 	br	8111aafc <__reset+0xfb0faafc>

8111ab18 <__clzsi2>:
8111ab18:	00bfffd4 	movui	r2,65535
8111ab1c:	11000536 	bltu	r2,r4,8111ab34 <__clzsi2+0x1c>
8111ab20:	00803fc4 	movi	r2,255
8111ab24:	11000f36 	bltu	r2,r4,8111ab64 <__clzsi2+0x4c>
8111ab28:	00800804 	movi	r2,32
8111ab2c:	0007883a 	mov	r3,zero
8111ab30:	00000506 	br	8111ab48 <__clzsi2+0x30>
8111ab34:	00804034 	movhi	r2,256
8111ab38:	10bfffc4 	addi	r2,r2,-1
8111ab3c:	11000c2e 	bgeu	r2,r4,8111ab70 <__clzsi2+0x58>
8111ab40:	00800204 	movi	r2,8
8111ab44:	00c00604 	movi	r3,24
8111ab48:	20c8d83a 	srl	r4,r4,r3
8111ab4c:	00e04534 	movhi	r3,33044
8111ab50:	18d35484 	addi	r3,r3,19794
8111ab54:	1909883a 	add	r4,r3,r4
8111ab58:	20c00003 	ldbu	r3,0(r4)
8111ab5c:	10c5c83a 	sub	r2,r2,r3
8111ab60:	f800283a 	ret
8111ab64:	00800604 	movi	r2,24
8111ab68:	00c00204 	movi	r3,8
8111ab6c:	003ff606 	br	8111ab48 <__reset+0xfb0fab48>
8111ab70:	00800404 	movi	r2,16
8111ab74:	1007883a 	mov	r3,r2
8111ab78:	003ff306 	br	8111ab48 <__reset+0xfb0fab48>

8111ab7c <atoi>:
8111ab7c:	01800284 	movi	r6,10
8111ab80:	000b883a 	mov	r5,zero
8111ab84:	111b4341 	jmpi	8111b434 <strtol>

8111ab88 <_atoi_r>:
8111ab88:	01c00284 	movi	r7,10
8111ab8c:	000d883a 	mov	r6,zero
8111ab90:	111b1f41 	jmpi	8111b1f4 <_strtol_r>

8111ab94 <atoll>:
8111ab94:	01800284 	movi	r6,10
8111ab98:	000b883a 	mov	r5,zero
8111ab9c:	111b4501 	jmpi	8111b450 <strtoll>

8111aba0 <_atoll_r>:
8111aba0:	01c00284 	movi	r7,10
8111aba4:	000d883a 	mov	r6,zero
8111aba8:	111b46c1 	jmpi	8111b46c <_strtoll_r>

8111abac <memcpy>:
8111abac:	defffd04 	addi	sp,sp,-12
8111abb0:	de00012e 	bgeu	sp,et,8111abb8 <memcpy+0xc>
8111abb4:	003b68fa 	trap	3
8111abb8:	00c003c4 	movi	r3,15
8111abbc:	dfc00215 	stw	ra,8(sp)
8111abc0:	dc400115 	stw	r17,4(sp)
8111abc4:	dc000015 	stw	r16,0(sp)
8111abc8:	2005883a 	mov	r2,r4
8111abcc:	1980452e 	bgeu	r3,r6,8111ace4 <memcpy+0x138>
8111abd0:	2906b03a 	or	r3,r5,r4
8111abd4:	18c000cc 	andi	r3,r3,3
8111abd8:	1800441e 	bne	r3,zero,8111acec <memcpy+0x140>
8111abdc:	347ffc04 	addi	r17,r6,-16
8111abe0:	8822d13a 	srli	r17,r17,4
8111abe4:	28c00104 	addi	r3,r5,4
8111abe8:	23400104 	addi	r13,r4,4
8111abec:	8820913a 	slli	r16,r17,4
8111abf0:	2b000204 	addi	r12,r5,8
8111abf4:	22c00204 	addi	r11,r4,8
8111abf8:	84000504 	addi	r16,r16,20
8111abfc:	2a800304 	addi	r10,r5,12
8111ac00:	22400304 	addi	r9,r4,12
8111ac04:	2c21883a 	add	r16,r5,r16
8111ac08:	2811883a 	mov	r8,r5
8111ac0c:	200f883a 	mov	r7,r4
8111ac10:	41000017 	ldw	r4,0(r8)
8111ac14:	1fc00017 	ldw	ra,0(r3)
8111ac18:	63c00017 	ldw	r15,0(r12)
8111ac1c:	39000015 	stw	r4,0(r7)
8111ac20:	53800017 	ldw	r14,0(r10)
8111ac24:	6fc00015 	stw	ra,0(r13)
8111ac28:	5bc00015 	stw	r15,0(r11)
8111ac2c:	4b800015 	stw	r14,0(r9)
8111ac30:	18c00404 	addi	r3,r3,16
8111ac34:	39c00404 	addi	r7,r7,16
8111ac38:	42000404 	addi	r8,r8,16
8111ac3c:	6b400404 	addi	r13,r13,16
8111ac40:	63000404 	addi	r12,r12,16
8111ac44:	5ac00404 	addi	r11,r11,16
8111ac48:	52800404 	addi	r10,r10,16
8111ac4c:	4a400404 	addi	r9,r9,16
8111ac50:	1c3fef1e 	bne	r3,r16,8111ac10 <__reset+0xfb0fac10>
8111ac54:	89c00044 	addi	r7,r17,1
8111ac58:	380e913a 	slli	r7,r7,4
8111ac5c:	310003cc 	andi	r4,r6,15
8111ac60:	02c000c4 	movi	r11,3
8111ac64:	11c7883a 	add	r3,r2,r7
8111ac68:	29cb883a 	add	r5,r5,r7
8111ac6c:	5900212e 	bgeu	r11,r4,8111acf4 <memcpy+0x148>
8111ac70:	1813883a 	mov	r9,r3
8111ac74:	2811883a 	mov	r8,r5
8111ac78:	200f883a 	mov	r7,r4
8111ac7c:	42800017 	ldw	r10,0(r8)
8111ac80:	4a400104 	addi	r9,r9,4
8111ac84:	39ffff04 	addi	r7,r7,-4
8111ac88:	4abfff15 	stw	r10,-4(r9)
8111ac8c:	42000104 	addi	r8,r8,4
8111ac90:	59fffa36 	bltu	r11,r7,8111ac7c <__reset+0xfb0fac7c>
8111ac94:	213fff04 	addi	r4,r4,-4
8111ac98:	2008d0ba 	srli	r4,r4,2
8111ac9c:	318000cc 	andi	r6,r6,3
8111aca0:	21000044 	addi	r4,r4,1
8111aca4:	2109883a 	add	r4,r4,r4
8111aca8:	2109883a 	add	r4,r4,r4
8111acac:	1907883a 	add	r3,r3,r4
8111acb0:	290b883a 	add	r5,r5,r4
8111acb4:	30000626 	beq	r6,zero,8111acd0 <memcpy+0x124>
8111acb8:	198d883a 	add	r6,r3,r6
8111acbc:	29c00003 	ldbu	r7,0(r5)
8111acc0:	18c00044 	addi	r3,r3,1
8111acc4:	29400044 	addi	r5,r5,1
8111acc8:	19ffffc5 	stb	r7,-1(r3)
8111accc:	19bffb1e 	bne	r3,r6,8111acbc <__reset+0xfb0facbc>
8111acd0:	dfc00217 	ldw	ra,8(sp)
8111acd4:	dc400117 	ldw	r17,4(sp)
8111acd8:	dc000017 	ldw	r16,0(sp)
8111acdc:	dec00304 	addi	sp,sp,12
8111ace0:	f800283a 	ret
8111ace4:	2007883a 	mov	r3,r4
8111ace8:	003ff206 	br	8111acb4 <__reset+0xfb0facb4>
8111acec:	2007883a 	mov	r3,r4
8111acf0:	003ff106 	br	8111acb8 <__reset+0xfb0facb8>
8111acf4:	200d883a 	mov	r6,r4
8111acf8:	003fee06 	br	8111acb4 <__reset+0xfb0facb4>

8111acfc <memset>:
8111acfc:	20c000cc 	andi	r3,r4,3
8111ad00:	2005883a 	mov	r2,r4
8111ad04:	18004426 	beq	r3,zero,8111ae18 <memset+0x11c>
8111ad08:	31ffffc4 	addi	r7,r6,-1
8111ad0c:	30004026 	beq	r6,zero,8111ae10 <memset+0x114>
8111ad10:	2813883a 	mov	r9,r5
8111ad14:	200d883a 	mov	r6,r4
8111ad18:	2007883a 	mov	r3,r4
8111ad1c:	00000406 	br	8111ad30 <memset+0x34>
8111ad20:	3a3fffc4 	addi	r8,r7,-1
8111ad24:	31800044 	addi	r6,r6,1
8111ad28:	38003926 	beq	r7,zero,8111ae10 <memset+0x114>
8111ad2c:	400f883a 	mov	r7,r8
8111ad30:	18c00044 	addi	r3,r3,1
8111ad34:	32400005 	stb	r9,0(r6)
8111ad38:	1a0000cc 	andi	r8,r3,3
8111ad3c:	403ff81e 	bne	r8,zero,8111ad20 <__reset+0xfb0fad20>
8111ad40:	010000c4 	movi	r4,3
8111ad44:	21c02d2e 	bgeu	r4,r7,8111adfc <memset+0x100>
8111ad48:	29003fcc 	andi	r4,r5,255
8111ad4c:	200c923a 	slli	r6,r4,8
8111ad50:	3108b03a 	or	r4,r6,r4
8111ad54:	200c943a 	slli	r6,r4,16
8111ad58:	218cb03a 	or	r6,r4,r6
8111ad5c:	010003c4 	movi	r4,15
8111ad60:	21c0182e 	bgeu	r4,r7,8111adc4 <memset+0xc8>
8111ad64:	3b3ffc04 	addi	r12,r7,-16
8111ad68:	6018d13a 	srli	r12,r12,4
8111ad6c:	1a000104 	addi	r8,r3,4
8111ad70:	1ac00204 	addi	r11,r3,8
8111ad74:	6008913a 	slli	r4,r12,4
8111ad78:	1a800304 	addi	r10,r3,12
8111ad7c:	1813883a 	mov	r9,r3
8111ad80:	21000504 	addi	r4,r4,20
8111ad84:	1909883a 	add	r4,r3,r4
8111ad88:	49800015 	stw	r6,0(r9)
8111ad8c:	41800015 	stw	r6,0(r8)
8111ad90:	59800015 	stw	r6,0(r11)
8111ad94:	51800015 	stw	r6,0(r10)
8111ad98:	42000404 	addi	r8,r8,16
8111ad9c:	4a400404 	addi	r9,r9,16
8111ada0:	5ac00404 	addi	r11,r11,16
8111ada4:	52800404 	addi	r10,r10,16
8111ada8:	413ff71e 	bne	r8,r4,8111ad88 <__reset+0xfb0fad88>
8111adac:	63000044 	addi	r12,r12,1
8111adb0:	6018913a 	slli	r12,r12,4
8111adb4:	39c003cc 	andi	r7,r7,15
8111adb8:	010000c4 	movi	r4,3
8111adbc:	1b07883a 	add	r3,r3,r12
8111adc0:	21c00e2e 	bgeu	r4,r7,8111adfc <memset+0x100>
8111adc4:	1813883a 	mov	r9,r3
8111adc8:	3811883a 	mov	r8,r7
8111adcc:	010000c4 	movi	r4,3
8111add0:	49800015 	stw	r6,0(r9)
8111add4:	423fff04 	addi	r8,r8,-4
8111add8:	4a400104 	addi	r9,r9,4
8111addc:	223ffc36 	bltu	r4,r8,8111add0 <__reset+0xfb0fadd0>
8111ade0:	393fff04 	addi	r4,r7,-4
8111ade4:	2008d0ba 	srli	r4,r4,2
8111ade8:	39c000cc 	andi	r7,r7,3
8111adec:	21000044 	addi	r4,r4,1
8111adf0:	2109883a 	add	r4,r4,r4
8111adf4:	2109883a 	add	r4,r4,r4
8111adf8:	1907883a 	add	r3,r3,r4
8111adfc:	38000526 	beq	r7,zero,8111ae14 <memset+0x118>
8111ae00:	19cf883a 	add	r7,r3,r7
8111ae04:	19400005 	stb	r5,0(r3)
8111ae08:	18c00044 	addi	r3,r3,1
8111ae0c:	38fffd1e 	bne	r7,r3,8111ae04 <__reset+0xfb0fae04>
8111ae10:	f800283a 	ret
8111ae14:	f800283a 	ret
8111ae18:	2007883a 	mov	r3,r4
8111ae1c:	300f883a 	mov	r7,r6
8111ae20:	003fc706 	br	8111ad40 <__reset+0xfb0fad40>

8111ae24 <_printf_r>:
8111ae24:	defffd04 	addi	sp,sp,-12
8111ae28:	2805883a 	mov	r2,r5
8111ae2c:	de00012e 	bgeu	sp,et,8111ae34 <_printf_r+0x10>
8111ae30:	003b68fa 	trap	3
8111ae34:	dfc00015 	stw	ra,0(sp)
8111ae38:	d9800115 	stw	r6,4(sp)
8111ae3c:	d9c00215 	stw	r7,8(sp)
8111ae40:	21400217 	ldw	r5,8(r4)
8111ae44:	d9c00104 	addi	r7,sp,4
8111ae48:	100d883a 	mov	r6,r2
8111ae4c:	111d9340 	call	8111d934 <___vfprintf_internal_r>
8111ae50:	dfc00017 	ldw	ra,0(sp)
8111ae54:	dec00304 	addi	sp,sp,12
8111ae58:	f800283a 	ret

8111ae5c <printf>:
8111ae5c:	defffc04 	addi	sp,sp,-16
8111ae60:	de00012e 	bgeu	sp,et,8111ae68 <printf+0xc>
8111ae64:	003b68fa 	trap	3
8111ae68:	dfc00015 	stw	ra,0(sp)
8111ae6c:	d9400115 	stw	r5,4(sp)
8111ae70:	d9800215 	stw	r6,8(sp)
8111ae74:	d9c00315 	stw	r7,12(sp)
8111ae78:	00a04534 	movhi	r2,33044
8111ae7c:	109e0f04 	addi	r2,r2,30780
8111ae80:	10800017 	ldw	r2,0(r2)
8111ae84:	200b883a 	mov	r5,r4
8111ae88:	d9800104 	addi	r6,sp,4
8111ae8c:	11000217 	ldw	r4,8(r2)
8111ae90:	111fb340 	call	8111fb34 <__vfprintf_internal>
8111ae94:	dfc00017 	ldw	ra,0(sp)
8111ae98:	dec00404 	addi	sp,sp,16
8111ae9c:	f800283a 	ret

8111aea0 <_puts_r>:
8111aea0:	defff604 	addi	sp,sp,-40
8111aea4:	de00012e 	bgeu	sp,et,8111aeac <_puts_r+0xc>
8111aea8:	003b68fa 	trap	3
8111aeac:	dc000715 	stw	r16,28(sp)
8111aeb0:	2021883a 	mov	r16,r4
8111aeb4:	2809883a 	mov	r4,r5
8111aeb8:	dc400815 	stw	r17,32(sp)
8111aebc:	dfc00915 	stw	ra,36(sp)
8111aec0:	2823883a 	mov	r17,r5
8111aec4:	111b1180 	call	8111b118 <strlen>
8111aec8:	10c00044 	addi	r3,r2,1
8111aecc:	d8800115 	stw	r2,4(sp)
8111aed0:	00a04534 	movhi	r2,33044
8111aed4:	10943504 	addi	r2,r2,20692
8111aed8:	d8800215 	stw	r2,8(sp)
8111aedc:	00800044 	movi	r2,1
8111aee0:	d8800315 	stw	r2,12(sp)
8111aee4:	00800084 	movi	r2,2
8111aee8:	dc400015 	stw	r17,0(sp)
8111aeec:	d8c00615 	stw	r3,24(sp)
8111aef0:	dec00415 	stw	sp,16(sp)
8111aef4:	d8800515 	stw	r2,20(sp)
8111aef8:	80000226 	beq	r16,zero,8111af04 <_puts_r+0x64>
8111aefc:	80800e17 	ldw	r2,56(r16)
8111af00:	10001426 	beq	r2,zero,8111af54 <_puts_r+0xb4>
8111af04:	81400217 	ldw	r5,8(r16)
8111af08:	2880030b 	ldhu	r2,12(r5)
8111af0c:	10c8000c 	andi	r3,r2,8192
8111af10:	1800061e 	bne	r3,zero,8111af2c <_puts_r+0x8c>
8111af14:	29001917 	ldw	r4,100(r5)
8111af18:	00f7ffc4 	movi	r3,-8193
8111af1c:	10880014 	ori	r2,r2,8192
8111af20:	20c6703a 	and	r3,r4,r3
8111af24:	2880030d 	sth	r2,12(r5)
8111af28:	28c01915 	stw	r3,100(r5)
8111af2c:	d9800404 	addi	r6,sp,16
8111af30:	8009883a 	mov	r4,r16
8111af34:	1123bd00 	call	81123bd0 <__sfvwrite_r>
8111af38:	1000091e 	bne	r2,zero,8111af60 <_puts_r+0xc0>
8111af3c:	00800284 	movi	r2,10
8111af40:	dfc00917 	ldw	ra,36(sp)
8111af44:	dc400817 	ldw	r17,32(sp)
8111af48:	dc000717 	ldw	r16,28(sp)
8111af4c:	dec00a04 	addi	sp,sp,40
8111af50:	f800283a 	ret
8111af54:	8009883a 	mov	r4,r16
8111af58:	11234cc0 	call	811234cc <__sinit>
8111af5c:	003fe906 	br	8111af04 <__reset+0xfb0faf04>
8111af60:	00bfffc4 	movi	r2,-1
8111af64:	003ff606 	br	8111af40 <__reset+0xfb0faf40>

8111af68 <puts>:
8111af68:	00a04534 	movhi	r2,33044
8111af6c:	109e0f04 	addi	r2,r2,30780
8111af70:	200b883a 	mov	r5,r4
8111af74:	11000017 	ldw	r4,0(r2)
8111af78:	111aea01 	jmpi	8111aea0 <_puts_r>

8111af7c <scanf>:
8111af7c:	defffc04 	addi	sp,sp,-16
8111af80:	de00012e 	bgeu	sp,et,8111af88 <scanf+0xc>
8111af84:	003b68fa 	trap	3
8111af88:	dfc00015 	stw	ra,0(sp)
8111af8c:	d9400115 	stw	r5,4(sp)
8111af90:	d9800215 	stw	r6,8(sp)
8111af94:	d9c00315 	stw	r7,12(sp)
8111af98:	00a04534 	movhi	r2,33044
8111af9c:	109e0f04 	addi	r2,r2,30780
8111afa0:	200d883a 	mov	r6,r4
8111afa4:	11000017 	ldw	r4,0(r2)
8111afa8:	d9c00104 	addi	r7,sp,4
8111afac:	21400117 	ldw	r5,4(r4)
8111afb0:	11214640 	call	81121464 <_vfscanf_r>
8111afb4:	dfc00017 	ldw	ra,0(sp)
8111afb8:	dec00404 	addi	sp,sp,16
8111afbc:	f800283a 	ret

8111afc0 <_scanf_r>:
8111afc0:	defffd04 	addi	sp,sp,-12
8111afc4:	2805883a 	mov	r2,r5
8111afc8:	de00012e 	bgeu	sp,et,8111afd0 <_scanf_r+0x10>
8111afcc:	003b68fa 	trap	3
8111afd0:	dfc00015 	stw	ra,0(sp)
8111afd4:	d9800115 	stw	r6,4(sp)
8111afd8:	d9c00215 	stw	r7,8(sp)
8111afdc:	21400117 	ldw	r5,4(r4)
8111afe0:	d9c00104 	addi	r7,sp,4
8111afe4:	100d883a 	mov	r6,r2
8111afe8:	11214640 	call	81121464 <_vfscanf_r>
8111afec:	dfc00017 	ldw	ra,0(sp)
8111aff0:	dec00304 	addi	sp,sp,12
8111aff4:	f800283a 	ret

8111aff8 <_sprintf_r>:
8111aff8:	deffe404 	addi	sp,sp,-112
8111affc:	2807883a 	mov	r3,r5
8111b000:	de00012e 	bgeu	sp,et,8111b008 <_sprintf_r+0x10>
8111b004:	003b68fa 	trap	3
8111b008:	dfc01a15 	stw	ra,104(sp)
8111b00c:	d9c01b15 	stw	r7,108(sp)
8111b010:	00a00034 	movhi	r2,32768
8111b014:	10bfffc4 	addi	r2,r2,-1
8111b018:	02008204 	movi	r8,520
8111b01c:	d8800215 	stw	r2,8(sp)
8111b020:	d8800515 	stw	r2,20(sp)
8111b024:	d9c01b04 	addi	r7,sp,108
8111b028:	d80b883a 	mov	r5,sp
8111b02c:	00bfffc4 	movi	r2,-1
8111b030:	d8c00015 	stw	r3,0(sp)
8111b034:	d8c00415 	stw	r3,16(sp)
8111b038:	da00030d 	sth	r8,12(sp)
8111b03c:	d880038d 	sth	r2,14(sp)
8111b040:	111b7540 	call	8111b754 <___svfprintf_internal_r>
8111b044:	d8c00017 	ldw	r3,0(sp)
8111b048:	18000005 	stb	zero,0(r3)
8111b04c:	dfc01a17 	ldw	ra,104(sp)
8111b050:	dec01c04 	addi	sp,sp,112
8111b054:	f800283a 	ret

8111b058 <sprintf>:
8111b058:	deffe304 	addi	sp,sp,-116
8111b05c:	2007883a 	mov	r3,r4
8111b060:	de00012e 	bgeu	sp,et,8111b068 <sprintf+0x10>
8111b064:	003b68fa 	trap	3
8111b068:	dfc01a15 	stw	ra,104(sp)
8111b06c:	d9801b15 	stw	r6,108(sp)
8111b070:	d9c01c15 	stw	r7,112(sp)
8111b074:	01204534 	movhi	r4,33044
8111b078:	211e0f04 	addi	r4,r4,30780
8111b07c:	21000017 	ldw	r4,0(r4)
8111b080:	00a00034 	movhi	r2,32768
8111b084:	10bfffc4 	addi	r2,r2,-1
8111b088:	280d883a 	mov	r6,r5
8111b08c:	02008204 	movi	r8,520
8111b090:	d8800215 	stw	r2,8(sp)
8111b094:	d8800515 	stw	r2,20(sp)
8111b098:	d9c01b04 	addi	r7,sp,108
8111b09c:	d80b883a 	mov	r5,sp
8111b0a0:	00bfffc4 	movi	r2,-1
8111b0a4:	d8c00015 	stw	r3,0(sp)
8111b0a8:	d8c00415 	stw	r3,16(sp)
8111b0ac:	da00030d 	sth	r8,12(sp)
8111b0b0:	d880038d 	sth	r2,14(sp)
8111b0b4:	111b7540 	call	8111b754 <___svfprintf_internal_r>
8111b0b8:	d8c00017 	ldw	r3,0(sp)
8111b0bc:	18000005 	stb	zero,0(r3)
8111b0c0:	dfc01a17 	ldw	ra,104(sp)
8111b0c4:	dec01d04 	addi	sp,sp,116
8111b0c8:	f800283a 	ret

8111b0cc <strcspn>:
8111b0cc:	21c00007 	ldb	r7,0(r4)
8111b0d0:	38000f26 	beq	r7,zero,8111b110 <strcspn+0x44>
8111b0d4:	2a000007 	ldb	r8,0(r5)
8111b0d8:	2005883a 	mov	r2,r4
8111b0dc:	40000726 	beq	r8,zero,8111b0fc <strcspn+0x30>
8111b0e0:	3a000926 	beq	r7,r8,8111b108 <strcspn+0x3c>
8111b0e4:	2807883a 	mov	r3,r5
8111b0e8:	00000106 	br	8111b0f0 <strcspn+0x24>
8111b0ec:	31c00626 	beq	r6,r7,8111b108 <strcspn+0x3c>
8111b0f0:	18c00044 	addi	r3,r3,1
8111b0f4:	19800007 	ldb	r6,0(r3)
8111b0f8:	303ffc1e 	bne	r6,zero,8111b0ec <__reset+0xfb0fb0ec>
8111b0fc:	10800044 	addi	r2,r2,1
8111b100:	11c00007 	ldb	r7,0(r2)
8111b104:	383ff51e 	bne	r7,zero,8111b0dc <__reset+0xfb0fb0dc>
8111b108:	1105c83a 	sub	r2,r2,r4
8111b10c:	f800283a 	ret
8111b110:	0005883a 	mov	r2,zero
8111b114:	f800283a 	ret

8111b118 <strlen>:
8111b118:	208000cc 	andi	r2,r4,3
8111b11c:	10002026 	beq	r2,zero,8111b1a0 <strlen+0x88>
8111b120:	20800007 	ldb	r2,0(r4)
8111b124:	10002026 	beq	r2,zero,8111b1a8 <strlen+0x90>
8111b128:	2005883a 	mov	r2,r4
8111b12c:	00000206 	br	8111b138 <strlen+0x20>
8111b130:	10c00007 	ldb	r3,0(r2)
8111b134:	18001826 	beq	r3,zero,8111b198 <strlen+0x80>
8111b138:	10800044 	addi	r2,r2,1
8111b13c:	10c000cc 	andi	r3,r2,3
8111b140:	183ffb1e 	bne	r3,zero,8111b130 <__reset+0xfb0fb130>
8111b144:	10c00017 	ldw	r3,0(r2)
8111b148:	01ffbff4 	movhi	r7,65279
8111b14c:	39ffbfc4 	addi	r7,r7,-257
8111b150:	00ca303a 	nor	r5,zero,r3
8111b154:	01a02074 	movhi	r6,32897
8111b158:	19c7883a 	add	r3,r3,r7
8111b15c:	31a02004 	addi	r6,r6,-32640
8111b160:	1946703a 	and	r3,r3,r5
8111b164:	1986703a 	and	r3,r3,r6
8111b168:	1800091e 	bne	r3,zero,8111b190 <strlen+0x78>
8111b16c:	10800104 	addi	r2,r2,4
8111b170:	10c00017 	ldw	r3,0(r2)
8111b174:	19cb883a 	add	r5,r3,r7
8111b178:	00c6303a 	nor	r3,zero,r3
8111b17c:	28c6703a 	and	r3,r5,r3
8111b180:	1986703a 	and	r3,r3,r6
8111b184:	183ff926 	beq	r3,zero,8111b16c <__reset+0xfb0fb16c>
8111b188:	00000106 	br	8111b190 <strlen+0x78>
8111b18c:	10800044 	addi	r2,r2,1
8111b190:	10c00007 	ldb	r3,0(r2)
8111b194:	183ffd1e 	bne	r3,zero,8111b18c <__reset+0xfb0fb18c>
8111b198:	1105c83a 	sub	r2,r2,r4
8111b19c:	f800283a 	ret
8111b1a0:	2005883a 	mov	r2,r4
8111b1a4:	003fe706 	br	8111b144 <__reset+0xfb0fb144>
8111b1a8:	0005883a 	mov	r2,zero
8111b1ac:	f800283a 	ret

8111b1b0 <strnlen>:
8111b1b0:	28000e26 	beq	r5,zero,8111b1ec <strnlen+0x3c>
8111b1b4:	20800007 	ldb	r2,0(r4)
8111b1b8:	10000c26 	beq	r2,zero,8111b1ec <strnlen+0x3c>
8111b1bc:	20c00044 	addi	r3,r4,1
8111b1c0:	214b883a 	add	r5,r4,r5
8111b1c4:	28c00526 	beq	r5,r3,8111b1dc <strnlen+0x2c>
8111b1c8:	19800007 	ldb	r6,0(r3)
8111b1cc:	19c00044 	addi	r7,r3,1
8111b1d0:	30000426 	beq	r6,zero,8111b1e4 <strnlen+0x34>
8111b1d4:	3807883a 	mov	r3,r7
8111b1d8:	28fffb1e 	bne	r5,r3,8111b1c8 <__reset+0xfb0fb1c8>
8111b1dc:	2905c83a 	sub	r2,r5,r4
8111b1e0:	f800283a 	ret
8111b1e4:	1905c83a 	sub	r2,r3,r4
8111b1e8:	f800283a 	ret
8111b1ec:	0005883a 	mov	r2,zero
8111b1f0:	f800283a 	ret

8111b1f4 <_strtol_r>:
8111b1f4:	00a04534 	movhi	r2,33044
8111b1f8:	defff404 	addi	sp,sp,-48
8111b1fc:	109e0d04 	addi	r2,r2,30772
8111b200:	de00012e 	bgeu	sp,et,8111b208 <_strtol_r+0x14>
8111b204:	003b68fa 	trap	3
8111b208:	dd400715 	stw	r21,28(sp)
8111b20c:	15400017 	ldw	r21,0(r2)
8111b210:	dd800815 	stw	r22,32(sp)
8111b214:	dd000615 	stw	r20,24(sp)
8111b218:	dcc00515 	stw	r19,20(sp)
8111b21c:	d9000015 	stw	r4,0(sp)
8111b220:	dfc00b15 	stw	ra,44(sp)
8111b224:	df000a15 	stw	fp,40(sp)
8111b228:	ddc00915 	stw	r23,36(sp)
8111b22c:	dc800415 	stw	r18,16(sp)
8111b230:	dc400315 	stw	r17,12(sp)
8111b234:	dc000215 	stw	r16,8(sp)
8111b238:	2829883a 	mov	r20,r5
8111b23c:	3027883a 	mov	r19,r6
8111b240:	382d883a 	mov	r22,r7
8111b244:	2809883a 	mov	r4,r5
8111b248:	24000003 	ldbu	r16,0(r4)
8111b24c:	24400044 	addi	r17,r4,1
8111b250:	2007883a 	mov	r3,r4
8111b254:	ac05883a 	add	r2,r21,r16
8111b258:	10800043 	ldbu	r2,1(r2)
8111b25c:	8809883a 	mov	r4,r17
8111b260:	1080020c 	andi	r2,r2,8
8111b264:	103ff81e 	bne	r2,zero,8111b248 <__reset+0xfb0fb248>
8111b268:	00800b44 	movi	r2,45
8111b26c:	80805826 	beq	r16,r2,8111b3d0 <_strtol_r+0x1dc>
8111b270:	00800ac4 	movi	r2,43
8111b274:	80805a26 	beq	r16,r2,8111b3e0 <_strtol_r+0x1ec>
8111b278:	0039883a 	mov	fp,zero
8111b27c:	b0004426 	beq	r22,zero,8111b390 <_strtol_r+0x19c>
8111b280:	00800404 	movi	r2,16
8111b284:	b0806026 	beq	r22,r2,8111b408 <_strtol_r+0x214>
8111b288:	b02f883a 	mov	r23,r22
8111b28c:	00a00034 	movhi	r2,32768
8111b290:	e025003a 	cmpeq	r18,fp,zero
8111b294:	14a5c83a 	sub	r18,r2,r18
8111b298:	b80b883a 	mov	r5,r23
8111b29c:	9009883a 	mov	r4,r18
8111b2a0:	112d9480 	call	8112d948 <__umodsi3>
8111b2a4:	b80b883a 	mov	r5,r23
8111b2a8:	9009883a 	mov	r4,r18
8111b2ac:	d8800115 	stw	r2,4(sp)
8111b2b0:	112d8e40 	call	8112d8e4 <__udivsi3>
8111b2b4:	ac07883a 	add	r3,r21,r16
8111b2b8:	18c00043 	ldbu	r3,1(r3)
8111b2bc:	880b883a 	mov	r5,r17
8111b2c0:	000d883a 	mov	r6,zero
8111b2c4:	1a00010c 	andi	r8,r3,4
8111b2c8:	0009883a 	mov	r4,zero
8111b2cc:	02800044 	movi	r10,1
8111b2d0:	027fffc4 	movi	r9,-1
8111b2d4:	d9c00117 	ldw	r7,4(sp)
8111b2d8:	40000e26 	beq	r8,zero,8111b314 <_strtol_r+0x120>
8111b2dc:	843ff404 	addi	r16,r16,-48
8111b2e0:	8580120e 	bge	r16,r22,8111b32c <_strtol_r+0x138>
8111b2e4:	32400526 	beq	r6,r9,8111b2fc <_strtol_r+0x108>
8111b2e8:	11002536 	bltu	r2,r4,8111b380 <_strtol_r+0x18c>
8111b2ec:	20802326 	beq	r4,r2,8111b37c <_strtol_r+0x188>
8111b2f0:	25c9383a 	mul	r4,r4,r23
8111b2f4:	01800044 	movi	r6,1
8111b2f8:	8109883a 	add	r4,r16,r4
8111b2fc:	2c000003 	ldbu	r16,0(r5)
8111b300:	29400044 	addi	r5,r5,1
8111b304:	ac07883a 	add	r3,r21,r16
8111b308:	18c00043 	ldbu	r3,1(r3)
8111b30c:	1a00010c 	andi	r8,r3,4
8111b310:	403ff21e 	bne	r8,zero,8111b2dc <__reset+0xfb0fb2dc>
8111b314:	18c000cc 	andi	r3,r3,3
8111b318:	18000426 	beq	r3,zero,8111b32c <_strtol_r+0x138>
8111b31c:	1a801a26 	beq	r3,r10,8111b388 <_strtol_r+0x194>
8111b320:	00c015c4 	movi	r3,87
8111b324:	80e1c83a 	sub	r16,r16,r3
8111b328:	85bfee16 	blt	r16,r22,8111b2e4 <__reset+0xfb0fb2e4>
8111b32c:	00bfffc4 	movi	r2,-1
8111b330:	30801e26 	beq	r6,r2,8111b3ac <_strtol_r+0x1b8>
8111b334:	e0001b1e 	bne	fp,zero,8111b3a4 <_strtol_r+0x1b0>
8111b338:	2005883a 	mov	r2,r4
8111b33c:	98000326 	beq	r19,zero,8111b34c <_strtol_r+0x158>
8111b340:	3000211e 	bne	r6,zero,8111b3c8 <_strtol_r+0x1d4>
8111b344:	a00b883a 	mov	r5,r20
8111b348:	99400015 	stw	r5,0(r19)
8111b34c:	dfc00b17 	ldw	ra,44(sp)
8111b350:	df000a17 	ldw	fp,40(sp)
8111b354:	ddc00917 	ldw	r23,36(sp)
8111b358:	dd800817 	ldw	r22,32(sp)
8111b35c:	dd400717 	ldw	r21,28(sp)
8111b360:	dd000617 	ldw	r20,24(sp)
8111b364:	dcc00517 	ldw	r19,20(sp)
8111b368:	dc800417 	ldw	r18,16(sp)
8111b36c:	dc400317 	ldw	r17,12(sp)
8111b370:	dc000217 	ldw	r16,8(sp)
8111b374:	dec00c04 	addi	sp,sp,48
8111b378:	f800283a 	ret
8111b37c:	3c3fdc0e 	bge	r7,r16,8111b2f0 <__reset+0xfb0fb2f0>
8111b380:	01bfffc4 	movi	r6,-1
8111b384:	003fdd06 	br	8111b2fc <__reset+0xfb0fb2fc>
8111b388:	00c00dc4 	movi	r3,55
8111b38c:	003fe506 	br	8111b324 <__reset+0xfb0fb324>
8111b390:	00800c04 	movi	r2,48
8111b394:	80801626 	beq	r16,r2,8111b3f0 <_strtol_r+0x1fc>
8111b398:	05800284 	movi	r22,10
8111b39c:	b02f883a 	mov	r23,r22
8111b3a0:	003fba06 	br	8111b28c <__reset+0xfb0fb28c>
8111b3a4:	0109c83a 	sub	r4,zero,r4
8111b3a8:	003fe306 	br	8111b338 <__reset+0xfb0fb338>
8111b3ac:	d9000017 	ldw	r4,0(sp)
8111b3b0:	00c00884 	movi	r3,34
8111b3b4:	e005003a 	cmpeq	r2,fp,zero
8111b3b8:	20c00015 	stw	r3,0(r4)
8111b3bc:	00e00034 	movhi	r3,32768
8111b3c0:	1885c83a 	sub	r2,r3,r2
8111b3c4:	983fe126 	beq	r19,zero,8111b34c <__reset+0xfb0fb34c>
8111b3c8:	297fffc4 	addi	r5,r5,-1
8111b3cc:	003fde06 	br	8111b348 <__reset+0xfb0fb348>
8111b3d0:	1c400084 	addi	r17,r3,2
8111b3d4:	1c000043 	ldbu	r16,1(r3)
8111b3d8:	07000044 	movi	fp,1
8111b3dc:	003fa706 	br	8111b27c <__reset+0xfb0fb27c>
8111b3e0:	1c400084 	addi	r17,r3,2
8111b3e4:	1c000043 	ldbu	r16,1(r3)
8111b3e8:	0039883a 	mov	fp,zero
8111b3ec:	003fa306 	br	8111b27c <__reset+0xfb0fb27c>
8111b3f0:	88800003 	ldbu	r2,0(r17)
8111b3f4:	00c01604 	movi	r3,88
8111b3f8:	108037cc 	andi	r2,r2,223
8111b3fc:	10c00826 	beq	r2,r3,8111b420 <_strtol_r+0x22c>
8111b400:	05800204 	movi	r22,8
8111b404:	003fa006 	br	8111b288 <__reset+0xfb0fb288>
8111b408:	00800c04 	movi	r2,48
8111b40c:	80bf9e1e 	bne	r16,r2,8111b288 <__reset+0xfb0fb288>
8111b410:	88800003 	ldbu	r2,0(r17)
8111b414:	00c01604 	movi	r3,88
8111b418:	108037cc 	andi	r2,r2,223
8111b41c:	10ff9a1e 	bne	r2,r3,8111b288 <__reset+0xfb0fb288>
8111b420:	05c00404 	movi	r23,16
8111b424:	8c000043 	ldbu	r16,1(r17)
8111b428:	b82d883a 	mov	r22,r23
8111b42c:	8c400084 	addi	r17,r17,2
8111b430:	003f9606 	br	8111b28c <__reset+0xfb0fb28c>

8111b434 <strtol>:
8111b434:	00a04534 	movhi	r2,33044
8111b438:	109e0f04 	addi	r2,r2,30780
8111b43c:	300f883a 	mov	r7,r6
8111b440:	280d883a 	mov	r6,r5
8111b444:	200b883a 	mov	r5,r4
8111b448:	11000017 	ldw	r4,0(r2)
8111b44c:	111b1f41 	jmpi	8111b1f4 <_strtol_r>

8111b450 <strtoll>:
8111b450:	00a04534 	movhi	r2,33044
8111b454:	109e0f04 	addi	r2,r2,30780
8111b458:	300f883a 	mov	r7,r6
8111b45c:	280d883a 	mov	r6,r5
8111b460:	200b883a 	mov	r5,r4
8111b464:	11000017 	ldw	r4,0(r2)
8111b468:	111b46c1 	jmpi	8111b46c <_strtoll_r>

8111b46c <_strtoll_r>:
8111b46c:	00a04534 	movhi	r2,33044
8111b470:	defff304 	addi	sp,sp,-52
8111b474:	109e0d04 	addi	r2,r2,30772
8111b478:	de00012e 	bgeu	sp,et,8111b480 <_strtoll_r+0x14>
8111b47c:	003b68fa 	trap	3
8111b480:	dc800515 	stw	r18,20(sp)
8111b484:	14800017 	ldw	r18,0(r2)
8111b488:	dd800915 	stw	r22,36(sp)
8111b48c:	dd400815 	stw	r21,32(sp)
8111b490:	dcc00615 	stw	r19,24(sp)
8111b494:	d9000015 	stw	r4,0(sp)
8111b498:	dfc00c15 	stw	ra,48(sp)
8111b49c:	df000b15 	stw	fp,44(sp)
8111b4a0:	ddc00a15 	stw	r23,40(sp)
8111b4a4:	dd000715 	stw	r20,28(sp)
8111b4a8:	dc400415 	stw	r17,16(sp)
8111b4ac:	dc000315 	stw	r16,12(sp)
8111b4b0:	282d883a 	mov	r22,r5
8111b4b4:	302b883a 	mov	r21,r6
8111b4b8:	3827883a 	mov	r19,r7
8111b4bc:	2809883a 	mov	r4,r5
8111b4c0:	24000003 	ldbu	r16,0(r4)
8111b4c4:	24400044 	addi	r17,r4,1
8111b4c8:	2007883a 	mov	r3,r4
8111b4cc:	9405883a 	add	r2,r18,r16
8111b4d0:	10800043 	ldbu	r2,1(r2)
8111b4d4:	8809883a 	mov	r4,r17
8111b4d8:	1080020c 	andi	r2,r2,8
8111b4dc:	103ff81e 	bne	r2,zero,8111b4c0 <__reset+0xfb0fb4c0>
8111b4e0:	00800b44 	movi	r2,45
8111b4e4:	80807826 	beq	r16,r2,8111b6c8 <_strtoll_r+0x25c>
8111b4e8:	00800ac4 	movi	r2,43
8111b4ec:	80807a26 	beq	r16,r2,8111b6d8 <_strtoll_r+0x26c>
8111b4f0:	0039883a 	mov	fp,zero
8111b4f4:	98004e26 	beq	r19,zero,8111b630 <_strtoll_r+0x1c4>
8111b4f8:	00800404 	movi	r2,16
8111b4fc:	98808226 	beq	r19,r2,8111b708 <_strtoll_r+0x29c>
8111b500:	982fd7fa 	srai	r23,r19,31
8111b504:	9829883a 	mov	r20,r19
8111b508:	e0004f26 	beq	fp,zero,8111b648 <_strtoll_r+0x1dc>
8111b50c:	0017883a 	mov	r11,zero
8111b510:	02a00034 	movhi	r10,32768
8111b514:	5809883a 	mov	r4,r11
8111b518:	500b883a 	mov	r5,r10
8111b51c:	a00d883a 	mov	r6,r20
8111b520:	b80f883a 	mov	r7,r23
8111b524:	da800215 	stw	r10,8(sp)
8111b528:	dac00115 	stw	r11,4(sp)
8111b52c:	112d2ac0 	call	8112d2ac <__umoddi3>
8111b530:	dac00117 	ldw	r11,4(sp)
8111b534:	da800217 	ldw	r10,8(sp)
8111b538:	a00d883a 	mov	r6,r20
8111b53c:	5809883a 	mov	r4,r11
8111b540:	500b883a 	mov	r5,r10
8111b544:	b80f883a 	mov	r7,r23
8111b548:	d8800115 	stw	r2,4(sp)
8111b54c:	112cd2c0 	call	8112cd2c <__udivdi3>
8111b550:	9409883a 	add	r4,r18,r16
8111b554:	21000043 	ldbu	r4,1(r4)
8111b558:	1019883a 	mov	r12,r2
8111b55c:	880b883a 	mov	r5,r17
8111b560:	2240010c 	andi	r9,r4,4
8111b564:	0015883a 	mov	r10,zero
8111b568:	000d883a 	mov	r6,zero
8111b56c:	000f883a 	mov	r7,zero
8111b570:	03400044 	movi	r13,1
8111b574:	02ffffc4 	movi	r11,-1
8111b578:	da000117 	ldw	r8,4(sp)
8111b57c:	48000d26 	beq	r9,zero,8111b5b4 <_strtoll_r+0x148>
8111b580:	843ff404 	addi	r16,r16,-48
8111b584:	84c0110e 	bge	r16,r19,8111b5cc <_strtoll_r+0x160>
8111b588:	52c00426 	beq	r10,r11,8111b59c <_strtoll_r+0x130>
8111b58c:	19c00236 	bltu	r3,r7,8111b598 <_strtoll_r+0x12c>
8111b590:	38c0311e 	bne	r7,r3,8111b658 <_strtoll_r+0x1ec>
8111b594:	6180302e 	bgeu	r12,r6,8111b658 <_strtoll_r+0x1ec>
8111b598:	02bfffc4 	movi	r10,-1
8111b59c:	2c000003 	ldbu	r16,0(r5)
8111b5a0:	29400044 	addi	r5,r5,1
8111b5a4:	9409883a 	add	r4,r18,r16
8111b5a8:	21000043 	ldbu	r4,1(r4)
8111b5ac:	2240010c 	andi	r9,r4,4
8111b5b0:	483ff31e 	bne	r9,zero,8111b580 <__reset+0xfb0fb580>
8111b5b4:	210000cc 	andi	r4,r4,3
8111b5b8:	20000426 	beq	r4,zero,8111b5cc <_strtoll_r+0x160>
8111b5bc:	23403426 	beq	r4,r13,8111b690 <_strtoll_r+0x224>
8111b5c0:	008015c4 	movi	r2,87
8111b5c4:	80a1c83a 	sub	r16,r16,r2
8111b5c8:	84ffef16 	blt	r16,r19,8111b588 <__reset+0xfb0fb588>
8111b5cc:	00bfffc4 	movi	r2,-1
8111b5d0:	50803426 	beq	r10,r2,8111b6a4 <_strtoll_r+0x238>
8111b5d4:	e0000426 	beq	fp,zero,8111b5e8 <_strtoll_r+0x17c>
8111b5d8:	018dc83a 	sub	r6,zero,r6
8111b5dc:	3004c03a 	cmpne	r2,r6,zero
8111b5e0:	01e1c83a 	sub	r16,zero,r7
8111b5e4:	808fc83a 	sub	r7,r16,r2
8111b5e8:	3005883a 	mov	r2,r6
8111b5ec:	3807883a 	mov	r3,r7
8111b5f0:	a8000326 	beq	r21,zero,8111b600 <_strtoll_r+0x194>
8111b5f4:	5000321e 	bne	r10,zero,8111b6c0 <_strtoll_r+0x254>
8111b5f8:	b00b883a 	mov	r5,r22
8111b5fc:	a9400015 	stw	r5,0(r21)
8111b600:	dfc00c17 	ldw	ra,48(sp)
8111b604:	df000b17 	ldw	fp,44(sp)
8111b608:	ddc00a17 	ldw	r23,40(sp)
8111b60c:	dd800917 	ldw	r22,36(sp)
8111b610:	dd400817 	ldw	r21,32(sp)
8111b614:	dd000717 	ldw	r20,28(sp)
8111b618:	dcc00617 	ldw	r19,24(sp)
8111b61c:	dc800517 	ldw	r18,20(sp)
8111b620:	dc400417 	ldw	r17,16(sp)
8111b624:	dc000317 	ldw	r16,12(sp)
8111b628:	dec00d04 	addi	sp,sp,52
8111b62c:	f800283a 	ret
8111b630:	00800c04 	movi	r2,48
8111b634:	80802c26 	beq	r16,r2,8111b6e8 <_strtoll_r+0x27c>
8111b638:	05000284 	movi	r20,10
8111b63c:	002f883a 	mov	r23,zero
8111b640:	a027883a 	mov	r19,r20
8111b644:	e03fb11e 	bne	fp,zero,8111b50c <__reset+0xfb0fb50c>
8111b648:	02a00034 	movhi	r10,32768
8111b64c:	52bfffc4 	addi	r10,r10,-1
8111b650:	02ffffc4 	movi	r11,-1
8111b654:	003faf06 	br	8111b514 <__reset+0xfb0fb514>
8111b658:	33000f26 	beq	r6,r12,8111b698 <_strtoll_r+0x22c>
8111b65c:	b985383a 	mul	r2,r23,r6
8111b660:	3d0f383a 	mul	r7,r7,r20
8111b664:	3508383a 	mulxuu	r4,r6,r20
8111b668:	350d383a 	mul	r6,r6,r20
8111b66c:	8013d7fa 	srai	r9,r16,31
8111b670:	388f883a 	add	r7,r7,r2
8111b674:	818d883a 	add	r6,r16,r6
8111b678:	390f883a 	add	r7,r7,r4
8111b67c:	3421803a 	cmpltu	r16,r6,r16
8111b680:	49cf883a 	add	r7,r9,r7
8111b684:	81cf883a 	add	r7,r16,r7
8111b688:	02800044 	movi	r10,1
8111b68c:	003fc306 	br	8111b59c <__reset+0xfb0fb59c>
8111b690:	00800dc4 	movi	r2,55
8111b694:	003fcb06 	br	8111b5c4 <__reset+0xfb0fb5c4>
8111b698:	38fff01e 	bne	r7,r3,8111b65c <__reset+0xfb0fb65c>
8111b69c:	443fbe16 	blt	r8,r16,8111b598 <__reset+0xfb0fb598>
8111b6a0:	003fee06 	br	8111b65c <__reset+0xfb0fb65c>
8111b6a4:	e0002426 	beq	fp,zero,8111b738 <_strtoll_r+0x2cc>
8111b6a8:	0005883a 	mov	r2,zero
8111b6ac:	00e00034 	movhi	r3,32768
8111b6b0:	d9800017 	ldw	r6,0(sp)
8111b6b4:	01000884 	movi	r4,34
8111b6b8:	31000015 	stw	r4,0(r6)
8111b6bc:	a83fd026 	beq	r21,zero,8111b600 <__reset+0xfb0fb600>
8111b6c0:	297fffc4 	addi	r5,r5,-1
8111b6c4:	003fcd06 	br	8111b5fc <__reset+0xfb0fb5fc>
8111b6c8:	1c400084 	addi	r17,r3,2
8111b6cc:	1c000043 	ldbu	r16,1(r3)
8111b6d0:	07000044 	movi	fp,1
8111b6d4:	003f8706 	br	8111b4f4 <__reset+0xfb0fb4f4>
8111b6d8:	1c400084 	addi	r17,r3,2
8111b6dc:	1c000043 	ldbu	r16,1(r3)
8111b6e0:	0039883a 	mov	fp,zero
8111b6e4:	003f8306 	br	8111b4f4 <__reset+0xfb0fb4f4>
8111b6e8:	88800003 	ldbu	r2,0(r17)
8111b6ec:	00c01604 	movi	r3,88
8111b6f0:	108037cc 	andi	r2,r2,223
8111b6f4:	10c00a26 	beq	r2,r3,8111b720 <_strtoll_r+0x2b4>
8111b6f8:	05000204 	movi	r20,8
8111b6fc:	002f883a 	mov	r23,zero
8111b700:	a027883a 	mov	r19,r20
8111b704:	003f8006 	br	8111b508 <__reset+0xfb0fb508>
8111b708:	00800c04 	movi	r2,48
8111b70c:	80800e1e 	bne	r16,r2,8111b748 <_strtoll_r+0x2dc>
8111b710:	88800003 	ldbu	r2,0(r17)
8111b714:	00c01604 	movi	r3,88
8111b718:	108037cc 	andi	r2,r2,223
8111b71c:	10c00a1e 	bne	r2,r3,8111b748 <_strtoll_r+0x2dc>
8111b720:	05000404 	movi	r20,16
8111b724:	8c000043 	ldbu	r16,1(r17)
8111b728:	002f883a 	mov	r23,zero
8111b72c:	8c400084 	addi	r17,r17,2
8111b730:	a027883a 	mov	r19,r20
8111b734:	003f7406 	br	8111b508 <__reset+0xfb0fb508>
8111b738:	00e00034 	movhi	r3,32768
8111b73c:	18ffffc4 	addi	r3,r3,-1
8111b740:	5005883a 	mov	r2,r10
8111b744:	003fda06 	br	8111b6b0 <__reset+0xfb0fb6b0>
8111b748:	9829883a 	mov	r20,r19
8111b74c:	002f883a 	mov	r23,zero
8111b750:	003f6d06 	br	8111b508 <__reset+0xfb0fb508>

8111b754 <___svfprintf_internal_r>:
8111b754:	deffb704 	addi	sp,sp,-292
8111b758:	de00012e 	bgeu	sp,et,8111b760 <___svfprintf_internal_r+0xc>
8111b75c:	003b68fa 	trap	3
8111b760:	dfc04815 	stw	ra,288(sp)
8111b764:	ddc04615 	stw	r23,280(sp)
8111b768:	d9402c15 	stw	r5,176(sp)
8111b76c:	d9003915 	stw	r4,228(sp)
8111b770:	302f883a 	mov	r23,r6
8111b774:	d9c02d15 	stw	r7,180(sp)
8111b778:	df004715 	stw	fp,284(sp)
8111b77c:	dd804515 	stw	r22,276(sp)
8111b780:	dd404415 	stw	r21,272(sp)
8111b784:	dd004315 	stw	r20,268(sp)
8111b788:	dcc04215 	stw	r19,264(sp)
8111b78c:	dc804115 	stw	r18,260(sp)
8111b790:	dc404015 	stw	r17,256(sp)
8111b794:	dc003f15 	stw	r16,252(sp)
8111b798:	11243100 	call	81124310 <_localeconv_r>
8111b79c:	10800017 	ldw	r2,0(r2)
8111b7a0:	1009883a 	mov	r4,r2
8111b7a4:	d8803415 	stw	r2,208(sp)
8111b7a8:	111b1180 	call	8111b118 <strlen>
8111b7ac:	d8c02c17 	ldw	r3,176(sp)
8111b7b0:	d8803815 	stw	r2,224(sp)
8111b7b4:	1880030b 	ldhu	r2,12(r3)
8111b7b8:	1080200c 	andi	r2,r2,128
8111b7bc:	10000226 	beq	r2,zero,8111b7c8 <___svfprintf_internal_r+0x74>
8111b7c0:	18800417 	ldw	r2,16(r3)
8111b7c4:	10067f26 	beq	r2,zero,8111d1c4 <___svfprintf_internal_r+0x1a70>
8111b7c8:	dcc03917 	ldw	r19,228(sp)
8111b7cc:	d8c00404 	addi	r3,sp,16
8111b7d0:	05604534 	movhi	r21,33044
8111b7d4:	d9001e04 	addi	r4,sp,120
8111b7d8:	ad544684 	addi	r21,r21,20762
8111b7dc:	d8c01e15 	stw	r3,120(sp)
8111b7e0:	d8002015 	stw	zero,128(sp)
8111b7e4:	d8001f15 	stw	zero,124(sp)
8111b7e8:	d8003315 	stw	zero,204(sp)
8111b7ec:	d8003615 	stw	zero,216(sp)
8111b7f0:	d8003715 	stw	zero,220(sp)
8111b7f4:	1811883a 	mov	r8,r3
8111b7f8:	d8003a15 	stw	zero,232(sp)
8111b7fc:	d8003b15 	stw	zero,236(sp)
8111b800:	d8002f15 	stw	zero,188(sp)
8111b804:	d9002815 	stw	r4,160(sp)
8111b808:	b8800007 	ldb	r2,0(r23)
8111b80c:	10026726 	beq	r2,zero,8111c1ac <___svfprintf_internal_r+0xa58>
8111b810:	00c00944 	movi	r3,37
8111b814:	b821883a 	mov	r16,r23
8111b818:	10c0021e 	bne	r2,r3,8111b824 <___svfprintf_internal_r+0xd0>
8111b81c:	00001406 	br	8111b870 <___svfprintf_internal_r+0x11c>
8111b820:	10c00326 	beq	r2,r3,8111b830 <___svfprintf_internal_r+0xdc>
8111b824:	84000044 	addi	r16,r16,1
8111b828:	80800007 	ldb	r2,0(r16)
8111b82c:	103ffc1e 	bne	r2,zero,8111b820 <__reset+0xfb0fb820>
8111b830:	85e3c83a 	sub	r17,r16,r23
8111b834:	88000e26 	beq	r17,zero,8111b870 <___svfprintf_internal_r+0x11c>
8111b838:	d8c02017 	ldw	r3,128(sp)
8111b83c:	d8801f17 	ldw	r2,124(sp)
8111b840:	45c00015 	stw	r23,0(r8)
8111b844:	1c47883a 	add	r3,r3,r17
8111b848:	10800044 	addi	r2,r2,1
8111b84c:	d8c02015 	stw	r3,128(sp)
8111b850:	44400115 	stw	r17,4(r8)
8111b854:	d8801f15 	stw	r2,124(sp)
8111b858:	00c001c4 	movi	r3,7
8111b85c:	18809716 	blt	r3,r2,8111babc <___svfprintf_internal_r+0x368>
8111b860:	42000204 	addi	r8,r8,8
8111b864:	d9402f17 	ldw	r5,188(sp)
8111b868:	2c4b883a 	add	r5,r5,r17
8111b86c:	d9402f15 	stw	r5,188(sp)
8111b870:	80800007 	ldb	r2,0(r16)
8111b874:	10009826 	beq	r2,zero,8111bad8 <___svfprintf_internal_r+0x384>
8111b878:	84400047 	ldb	r17,1(r16)
8111b87c:	00bfffc4 	movi	r2,-1
8111b880:	85c00044 	addi	r23,r16,1
8111b884:	d8002785 	stb	zero,158(sp)
8111b888:	0007883a 	mov	r3,zero
8111b88c:	000f883a 	mov	r7,zero
8111b890:	d8802915 	stw	r2,164(sp)
8111b894:	d8003115 	stw	zero,196(sp)
8111b898:	0025883a 	mov	r18,zero
8111b89c:	01401604 	movi	r5,88
8111b8a0:	01800244 	movi	r6,9
8111b8a4:	02800a84 	movi	r10,42
8111b8a8:	02401b04 	movi	r9,108
8111b8ac:	bdc00044 	addi	r23,r23,1
8111b8b0:	88bff804 	addi	r2,r17,-32
8111b8b4:	2882f036 	bltu	r5,r2,8111c478 <___svfprintf_internal_r+0xd24>
8111b8b8:	100490ba 	slli	r2,r2,2
8111b8bc:	012044b4 	movhi	r4,33042
8111b8c0:	212e3404 	addi	r4,r4,-18224
8111b8c4:	1105883a 	add	r2,r2,r4
8111b8c8:	10800017 	ldw	r2,0(r2)
8111b8cc:	1000683a 	jmp	r2
8111b8d0:	8111c3e0 	cmpeqi	r4,r16,18191
8111b8d4:	8111c478 	rdprs	r4,r16,18193
8111b8d8:	8111c478 	rdprs	r4,r16,18193
8111b8dc:	8111c3d4 	ori	r4,r16,18191
8111b8e0:	8111c478 	rdprs	r4,r16,18193
8111b8e4:	8111c478 	rdprs	r4,r16,18193
8111b8e8:	8111c478 	rdprs	r4,r16,18193
8111b8ec:	8111c478 	rdprs	r4,r16,18193
8111b8f0:	8111c478 	rdprs	r4,r16,18193
8111b8f4:	8111c478 	rdprs	r4,r16,18193
8111b8f8:	8111bb34 	orhi	r4,r16,18156
8111b8fc:	8111c310 	cmplti	r4,r16,18188
8111b900:	8111c478 	rdprs	r4,r16,18193
8111b904:	8111ba44 	addi	r4,r16,18153
8111b908:	8111bb5c 	xori	r4,r16,18157
8111b90c:	8111c478 	rdprs	r4,r16,18193
8111b910:	8111bbd0 	cmplti	r4,r16,18159
8111b914:	8111bb9c 	xori	r4,r16,18158
8111b918:	8111bb9c 	xori	r4,r16,18158
8111b91c:	8111bb9c 	xori	r4,r16,18158
8111b920:	8111bb9c 	xori	r4,r16,18158
8111b924:	8111bb9c 	xori	r4,r16,18158
8111b928:	8111bb9c 	xori	r4,r16,18158
8111b92c:	8111bb9c 	xori	r4,r16,18158
8111b930:	8111bb9c 	xori	r4,r16,18158
8111b934:	8111bb9c 	xori	r4,r16,18158
8111b938:	8111c478 	rdprs	r4,r16,18193
8111b93c:	8111c478 	rdprs	r4,r16,18193
8111b940:	8111c478 	rdprs	r4,r16,18193
8111b944:	8111c478 	rdprs	r4,r16,18193
8111b948:	8111c478 	rdprs	r4,r16,18193
8111b94c:	8111c478 	rdprs	r4,r16,18193
8111b950:	8111c478 	rdprs	r4,r16,18193
8111b954:	8111c478 	rdprs	r4,r16,18193
8111b958:	8111c478 	rdprs	r4,r16,18193
8111b95c:	8111c478 	rdprs	r4,r16,18193
8111b960:	8111bc88 	cmpgei	r4,r16,18162
8111b964:	8111bbdc 	xori	r4,r16,18159
8111b968:	8111c478 	rdprs	r4,r16,18193
8111b96c:	8111bbdc 	xori	r4,r16,18159
8111b970:	8111c478 	rdprs	r4,r16,18193
8111b974:	8111c478 	rdprs	r4,r16,18193
8111b978:	8111c478 	rdprs	r4,r16,18193
8111b97c:	8111c478 	rdprs	r4,r16,18193
8111b980:	8111bc7c 	xorhi	r4,r16,18161
8111b984:	8111c478 	rdprs	r4,r16,18193
8111b988:	8111c478 	rdprs	r4,r16,18193
8111b98c:	8111bd44 	addi	r4,r16,18165
8111b990:	8111c478 	rdprs	r4,r16,18193
8111b994:	8111c478 	rdprs	r4,r16,18193
8111b998:	8111c478 	rdprs	r4,r16,18193
8111b99c:	8111c478 	rdprs	r4,r16,18193
8111b9a0:	8111c478 	rdprs	r4,r16,18193
8111b9a4:	8111c1b4 	orhi	r4,r16,18182
8111b9a8:	8111c478 	rdprs	r4,r16,18193
8111b9ac:	8111c478 	rdprs	r4,r16,18193
8111b9b0:	8111c214 	ori	r4,r16,18184
8111b9b4:	8111c478 	rdprs	r4,r16,18193
8111b9b8:	8111c478 	rdprs	r4,r16,18193
8111b9bc:	8111c478 	rdprs	r4,r16,18193
8111b9c0:	8111c478 	rdprs	r4,r16,18193
8111b9c4:	8111c478 	rdprs	r4,r16,18193
8111b9c8:	8111c478 	rdprs	r4,r16,18193
8111b9cc:	8111c478 	rdprs	r4,r16,18193
8111b9d0:	8111c478 	rdprs	r4,r16,18193
8111b9d4:	8111c478 	rdprs	r4,r16,18193
8111b9d8:	8111c478 	rdprs	r4,r16,18193
8111b9dc:	8111c2c4 	addi	r4,r16,18187
8111b9e0:	8111c400 	call	88111c40 <__reset+0x20f1c40>
8111b9e4:	8111bbdc 	xori	r4,r16,18159
8111b9e8:	8111bbdc 	xori	r4,r16,18159
8111b9ec:	8111bbdc 	xori	r4,r16,18159
8111b9f0:	8111c454 	ori	r4,r16,18193
8111b9f4:	8111c400 	call	88111c40 <__reset+0x20f1c40>
8111b9f8:	8111c478 	rdprs	r4,r16,18193
8111b9fc:	8111c478 	rdprs	r4,r16,18193
8111ba00:	8111c410 	cmplti	r4,r16,18192
8111ba04:	8111c478 	rdprs	r4,r16,18193
8111ba08:	8111c420 	cmpeqi	r4,r16,18192
8111ba0c:	8111c300 	call	88111c30 <__reset+0x20f1c30>
8111ba10:	8111ba50 	cmplti	r4,r16,18153
8111ba14:	8111c320 	cmpeqi	r4,r16,18188
8111ba18:	8111c478 	rdprs	r4,r16,18193
8111ba1c:	8111c32c 	andhi	r4,r16,18188
8111ba20:	8111c478 	rdprs	r4,r16,18193
8111ba24:	8111c388 	cmpgei	r4,r16,18190
8111ba28:	8111c478 	rdprs	r4,r16,18193
8111ba2c:	8111c478 	rdprs	r4,r16,18193
8111ba30:	8111c398 	cmpnei	r4,r16,18190
8111ba34:	d9003117 	ldw	r4,196(sp)
8111ba38:	d8802d15 	stw	r2,180(sp)
8111ba3c:	0109c83a 	sub	r4,zero,r4
8111ba40:	d9003115 	stw	r4,196(sp)
8111ba44:	94800114 	ori	r18,r18,4
8111ba48:	bc400007 	ldb	r17,0(r23)
8111ba4c:	003f9706 	br	8111b8ac <__reset+0xfb0fb8ac>
8111ba50:	00800c04 	movi	r2,48
8111ba54:	d9002d17 	ldw	r4,180(sp)
8111ba58:	d9402917 	ldw	r5,164(sp)
8111ba5c:	d8802705 	stb	r2,156(sp)
8111ba60:	00801e04 	movi	r2,120
8111ba64:	d8802745 	stb	r2,157(sp)
8111ba68:	d8002785 	stb	zero,158(sp)
8111ba6c:	20c00104 	addi	r3,r4,4
8111ba70:	25000017 	ldw	r20,0(r4)
8111ba74:	002d883a 	mov	r22,zero
8111ba78:	90800094 	ori	r2,r18,2
8111ba7c:	28028616 	blt	r5,zero,8111c498 <___svfprintf_internal_r+0xd44>
8111ba80:	00bfdfc4 	movi	r2,-129
8111ba84:	90a4703a 	and	r18,r18,r2
8111ba88:	d8c02d15 	stw	r3,180(sp)
8111ba8c:	94800094 	ori	r18,r18,2
8111ba90:	a002731e 	bne	r20,zero,8111c460 <___svfprintf_internal_r+0xd0c>
8111ba94:	00a04534 	movhi	r2,33044
8111ba98:	10943f04 	addi	r2,r2,20732
8111ba9c:	d8803a15 	stw	r2,232(sp)
8111baa0:	04401e04 	movi	r17,120
8111baa4:	d8c02917 	ldw	r3,164(sp)
8111baa8:	0039883a 	mov	fp,zero
8111baac:	1801d526 	beq	r3,zero,8111c204 <___svfprintf_internal_r+0xab0>
8111bab0:	0029883a 	mov	r20,zero
8111bab4:	002d883a 	mov	r22,zero
8111bab8:	0001f106 	br	8111c280 <___svfprintf_internal_r+0xb2c>
8111babc:	d9402c17 	ldw	r5,176(sp)
8111bac0:	d9801e04 	addi	r6,sp,120
8111bac4:	9809883a 	mov	r4,r19
8111bac8:	1128a100 	call	81128a10 <__ssprint_r>
8111bacc:	1000081e 	bne	r2,zero,8111baf0 <___svfprintf_internal_r+0x39c>
8111bad0:	da000404 	addi	r8,sp,16
8111bad4:	003f6306 	br	8111b864 <__reset+0xfb0fb864>
8111bad8:	d8802017 	ldw	r2,128(sp)
8111badc:	10000426 	beq	r2,zero,8111baf0 <___svfprintf_internal_r+0x39c>
8111bae0:	d9402c17 	ldw	r5,176(sp)
8111bae4:	d9003917 	ldw	r4,228(sp)
8111bae8:	d9801e04 	addi	r6,sp,120
8111baec:	1128a100 	call	81128a10 <__ssprint_r>
8111baf0:	d8802c17 	ldw	r2,176(sp)
8111baf4:	10c0030b 	ldhu	r3,12(r2)
8111baf8:	d8802f17 	ldw	r2,188(sp)
8111bafc:	18c0100c 	andi	r3,r3,64
8111bb00:	1805f51e 	bne	r3,zero,8111d2d8 <___svfprintf_internal_r+0x1b84>
8111bb04:	dfc04817 	ldw	ra,288(sp)
8111bb08:	df004717 	ldw	fp,284(sp)
8111bb0c:	ddc04617 	ldw	r23,280(sp)
8111bb10:	dd804517 	ldw	r22,276(sp)
8111bb14:	dd404417 	ldw	r21,272(sp)
8111bb18:	dd004317 	ldw	r20,268(sp)
8111bb1c:	dcc04217 	ldw	r19,264(sp)
8111bb20:	dc804117 	ldw	r18,260(sp)
8111bb24:	dc404017 	ldw	r17,256(sp)
8111bb28:	dc003f17 	ldw	r16,252(sp)
8111bb2c:	dec04904 	addi	sp,sp,292
8111bb30:	f800283a 	ret
8111bb34:	d8802d17 	ldw	r2,180(sp)
8111bb38:	d9002d17 	ldw	r4,180(sp)
8111bb3c:	10800017 	ldw	r2,0(r2)
8111bb40:	d8803115 	stw	r2,196(sp)
8111bb44:	20800104 	addi	r2,r4,4
8111bb48:	d9003117 	ldw	r4,196(sp)
8111bb4c:	203fb916 	blt	r4,zero,8111ba34 <__reset+0xfb0fba34>
8111bb50:	d8802d15 	stw	r2,180(sp)
8111bb54:	bc400007 	ldb	r17,0(r23)
8111bb58:	003f5406 	br	8111b8ac <__reset+0xfb0fb8ac>
8111bb5c:	bc400007 	ldb	r17,0(r23)
8111bb60:	bac00044 	addi	r11,r23,1
8111bb64:	8a873926 	beq	r17,r10,8111d84c <___svfprintf_internal_r+0x20f8>
8111bb68:	88bff404 	addi	r2,r17,-48
8111bb6c:	0009883a 	mov	r4,zero
8111bb70:	30868836 	bltu	r6,r2,8111d594 <___svfprintf_internal_r+0x1e40>
8111bb74:	5c400007 	ldb	r17,0(r11)
8111bb78:	210002a4 	muli	r4,r4,10
8111bb7c:	5dc00044 	addi	r23,r11,1
8111bb80:	b817883a 	mov	r11,r23
8111bb84:	2089883a 	add	r4,r4,r2
8111bb88:	88bff404 	addi	r2,r17,-48
8111bb8c:	30bff92e 	bgeu	r6,r2,8111bb74 <__reset+0xfb0fbb74>
8111bb90:	2005d716 	blt	r4,zero,8111d2f0 <___svfprintf_internal_r+0x1b9c>
8111bb94:	d9002915 	stw	r4,164(sp)
8111bb98:	003f4506 	br	8111b8b0 <__reset+0xfb0fb8b0>
8111bb9c:	b809883a 	mov	r4,r23
8111bba0:	d8003115 	stw	zero,196(sp)
8111bba4:	88bff404 	addi	r2,r17,-48
8111bba8:	0017883a 	mov	r11,zero
8111bbac:	24400007 	ldb	r17,0(r4)
8111bbb0:	5ac002a4 	muli	r11,r11,10
8111bbb4:	bdc00044 	addi	r23,r23,1
8111bbb8:	b809883a 	mov	r4,r23
8111bbbc:	12d7883a 	add	r11,r2,r11
8111bbc0:	88bff404 	addi	r2,r17,-48
8111bbc4:	30bff92e 	bgeu	r6,r2,8111bbac <__reset+0xfb0fbbac>
8111bbc8:	dac03115 	stw	r11,196(sp)
8111bbcc:	003f3806 	br	8111b8b0 <__reset+0xfb0fb8b0>
8111bbd0:	94802014 	ori	r18,r18,128
8111bbd4:	bc400007 	ldb	r17,0(r23)
8111bbd8:	003f3406 	br	8111b8ac <__reset+0xfb0fb8ac>
8111bbdc:	18c03fcc 	andi	r3,r3,255
8111bbe0:	1807471e 	bne	r3,zero,8111d900 <___svfprintf_internal_r+0x21ac>
8111bbe4:	9080020c 	andi	r2,r18,8
8111bbe8:	10047d26 	beq	r2,zero,8111cde0 <___svfprintf_internal_r+0x168c>
8111bbec:	d8c02d17 	ldw	r3,180(sp)
8111bbf0:	d9002d17 	ldw	r4,180(sp)
8111bbf4:	d9402d17 	ldw	r5,180(sp)
8111bbf8:	18c00017 	ldw	r3,0(r3)
8111bbfc:	21000117 	ldw	r4,4(r4)
8111bc00:	29400204 	addi	r5,r5,8
8111bc04:	d8c03615 	stw	r3,216(sp)
8111bc08:	d9003715 	stw	r4,220(sp)
8111bc0c:	d9402d15 	stw	r5,180(sp)
8111bc10:	d9003617 	ldw	r4,216(sp)
8111bc14:	d9403717 	ldw	r5,220(sp)
8111bc18:	da003e15 	stw	r8,248(sp)
8111bc1c:	04000044 	movi	r16,1
8111bc20:	112695c0 	call	8112695c <__fpclassifyd>
8111bc24:	da003e17 	ldw	r8,248(sp)
8111bc28:	14044b1e 	bne	r2,r16,8111cd58 <___svfprintf_internal_r+0x1604>
8111bc2c:	d9003617 	ldw	r4,216(sp)
8111bc30:	d9403717 	ldw	r5,220(sp)
8111bc34:	000d883a 	mov	r6,zero
8111bc38:	000f883a 	mov	r7,zero
8111bc3c:	112edc80 	call	8112edc8 <__ledf2>
8111bc40:	da003e17 	ldw	r8,248(sp)
8111bc44:	1005f316 	blt	r2,zero,8111d414 <___svfprintf_internal_r+0x1cc0>
8111bc48:	df002783 	ldbu	fp,158(sp)
8111bc4c:	008011c4 	movi	r2,71
8111bc50:	1445590e 	bge	r2,r17,8111d1b8 <___svfprintf_internal_r+0x1a64>
8111bc54:	04204534 	movhi	r16,33044
8111bc58:	84143704 	addi	r16,r16,20700
8111bc5c:	00c000c4 	movi	r3,3
8111bc60:	00bfdfc4 	movi	r2,-129
8111bc64:	d8c02a15 	stw	r3,168(sp)
8111bc68:	90a4703a 	and	r18,r18,r2
8111bc6c:	d8c02e15 	stw	r3,184(sp)
8111bc70:	d8002915 	stw	zero,164(sp)
8111bc74:	d8003215 	stw	zero,200(sp)
8111bc78:	00006606 	br	8111be14 <___svfprintf_internal_r+0x6c0>
8111bc7c:	94800214 	ori	r18,r18,8
8111bc80:	bc400007 	ldb	r17,0(r23)
8111bc84:	003f0906 	br	8111b8ac <__reset+0xfb0fb8ac>
8111bc88:	18c03fcc 	andi	r3,r3,255
8111bc8c:	1807181e 	bne	r3,zero,8111d8f0 <___svfprintf_internal_r+0x219c>
8111bc90:	94800414 	ori	r18,r18,16
8111bc94:	9080080c 	andi	r2,r18,32
8111bc98:	10039626 	beq	r2,zero,8111caf4 <___svfprintf_internal_r+0x13a0>
8111bc9c:	d9402d17 	ldw	r5,180(sp)
8111bca0:	28800117 	ldw	r2,4(r5)
8111bca4:	2d000017 	ldw	r20,0(r5)
8111bca8:	29400204 	addi	r5,r5,8
8111bcac:	d9402d15 	stw	r5,180(sp)
8111bcb0:	102d883a 	mov	r22,r2
8111bcb4:	10039816 	blt	r2,zero,8111cb18 <___svfprintf_internal_r+0x13c4>
8111bcb8:	d9402917 	ldw	r5,164(sp)
8111bcbc:	df002783 	ldbu	fp,158(sp)
8111bcc0:	2803ab16 	blt	r5,zero,8111cb70 <___svfprintf_internal_r+0x141c>
8111bcc4:	00ffdfc4 	movi	r3,-129
8111bcc8:	a584b03a 	or	r2,r20,r22
8111bccc:	90e4703a 	and	r18,r18,r3
8111bcd0:	10014a26 	beq	r2,zero,8111c1fc <___svfprintf_internal_r+0xaa8>
8111bcd4:	b0034b26 	beq	r22,zero,8111ca04 <___svfprintf_internal_r+0x12b0>
8111bcd8:	dc402a15 	stw	r17,168(sp)
8111bcdc:	dc001e04 	addi	r16,sp,120
8111bce0:	b023883a 	mov	r17,r22
8111bce4:	402d883a 	mov	r22,r8
8111bce8:	a009883a 	mov	r4,r20
8111bcec:	880b883a 	mov	r5,r17
8111bcf0:	01800284 	movi	r6,10
8111bcf4:	000f883a 	mov	r7,zero
8111bcf8:	112d2ac0 	call	8112d2ac <__umoddi3>
8111bcfc:	10800c04 	addi	r2,r2,48
8111bd00:	843fffc4 	addi	r16,r16,-1
8111bd04:	a009883a 	mov	r4,r20
8111bd08:	880b883a 	mov	r5,r17
8111bd0c:	80800005 	stb	r2,0(r16)
8111bd10:	01800284 	movi	r6,10
8111bd14:	000f883a 	mov	r7,zero
8111bd18:	112cd2c0 	call	8112cd2c <__udivdi3>
8111bd1c:	1029883a 	mov	r20,r2
8111bd20:	10c4b03a 	or	r2,r2,r3
8111bd24:	1823883a 	mov	r17,r3
8111bd28:	103fef1e 	bne	r2,zero,8111bce8 <__reset+0xfb0fbce8>
8111bd2c:	d8c02817 	ldw	r3,160(sp)
8111bd30:	dc402a17 	ldw	r17,168(sp)
8111bd34:	b011883a 	mov	r8,r22
8111bd38:	1c07c83a 	sub	r3,r3,r16
8111bd3c:	d8c02e15 	stw	r3,184(sp)
8111bd40:	00002e06 	br	8111bdfc <___svfprintf_internal_r+0x6a8>
8111bd44:	18c03fcc 	andi	r3,r3,255
8111bd48:	1806e71e 	bne	r3,zero,8111d8e8 <___svfprintf_internal_r+0x2194>
8111bd4c:	94800414 	ori	r18,r18,16
8111bd50:	9080080c 	andi	r2,r18,32
8111bd54:	1002d426 	beq	r2,zero,8111c8a8 <___svfprintf_internal_r+0x1154>
8111bd58:	d9402d17 	ldw	r5,180(sp)
8111bd5c:	d8c02917 	ldw	r3,164(sp)
8111bd60:	d8002785 	stb	zero,158(sp)
8111bd64:	28800204 	addi	r2,r5,8
8111bd68:	2d000017 	ldw	r20,0(r5)
8111bd6c:	2d800117 	ldw	r22,4(r5)
8111bd70:	18041516 	blt	r3,zero,8111cdc8 <___svfprintf_internal_r+0x1674>
8111bd74:	013fdfc4 	movi	r4,-129
8111bd78:	a586b03a 	or	r3,r20,r22
8111bd7c:	d8802d15 	stw	r2,180(sp)
8111bd80:	9124703a 	and	r18,r18,r4
8111bd84:	1802d51e 	bne	r3,zero,8111c8dc <___svfprintf_internal_r+0x1188>
8111bd88:	d9402917 	ldw	r5,164(sp)
8111bd8c:	0039883a 	mov	fp,zero
8111bd90:	2806be26 	beq	r5,zero,8111d88c <___svfprintf_internal_r+0x2138>
8111bd94:	0029883a 	mov	r20,zero
8111bd98:	002d883a 	mov	r22,zero
8111bd9c:	dc001e04 	addi	r16,sp,120
8111bda0:	a006d0fa 	srli	r3,r20,3
8111bda4:	b008977a 	slli	r4,r22,29
8111bda8:	b02cd0fa 	srli	r22,r22,3
8111bdac:	a50001cc 	andi	r20,r20,7
8111bdb0:	a0800c04 	addi	r2,r20,48
8111bdb4:	843fffc4 	addi	r16,r16,-1
8111bdb8:	20e8b03a 	or	r20,r4,r3
8111bdbc:	80800005 	stb	r2,0(r16)
8111bdc0:	a586b03a 	or	r3,r20,r22
8111bdc4:	183ff61e 	bne	r3,zero,8111bda0 <__reset+0xfb0fbda0>
8111bdc8:	90c0004c 	andi	r3,r18,1
8111bdcc:	18013926 	beq	r3,zero,8111c2b4 <___svfprintf_internal_r+0xb60>
8111bdd0:	10803fcc 	andi	r2,r2,255
8111bdd4:	1080201c 	xori	r2,r2,128
8111bdd8:	10bfe004 	addi	r2,r2,-128
8111bddc:	00c00c04 	movi	r3,48
8111bde0:	10c13426 	beq	r2,r3,8111c2b4 <___svfprintf_internal_r+0xb60>
8111bde4:	80ffffc5 	stb	r3,-1(r16)
8111bde8:	d8c02817 	ldw	r3,160(sp)
8111bdec:	80bfffc4 	addi	r2,r16,-1
8111bdf0:	1021883a 	mov	r16,r2
8111bdf4:	1887c83a 	sub	r3,r3,r2
8111bdf8:	d8c02e15 	stw	r3,184(sp)
8111bdfc:	d8802e17 	ldw	r2,184(sp)
8111be00:	d9002917 	ldw	r4,164(sp)
8111be04:	1100010e 	bge	r2,r4,8111be0c <___svfprintf_internal_r+0x6b8>
8111be08:	2005883a 	mov	r2,r4
8111be0c:	d8802a15 	stw	r2,168(sp)
8111be10:	d8003215 	stw	zero,200(sp)
8111be14:	e7003fcc 	andi	fp,fp,255
8111be18:	e700201c 	xori	fp,fp,128
8111be1c:	e73fe004 	addi	fp,fp,-128
8111be20:	e0000326 	beq	fp,zero,8111be30 <___svfprintf_internal_r+0x6dc>
8111be24:	d8c02a17 	ldw	r3,168(sp)
8111be28:	18c00044 	addi	r3,r3,1
8111be2c:	d8c02a15 	stw	r3,168(sp)
8111be30:	90c0008c 	andi	r3,r18,2
8111be34:	d8c02b15 	stw	r3,172(sp)
8111be38:	18000326 	beq	r3,zero,8111be48 <___svfprintf_internal_r+0x6f4>
8111be3c:	d8c02a17 	ldw	r3,168(sp)
8111be40:	18c00084 	addi	r3,r3,2
8111be44:	d8c02a15 	stw	r3,168(sp)
8111be48:	90c0210c 	andi	r3,r18,132
8111be4c:	d8c03015 	stw	r3,192(sp)
8111be50:	1801a11e 	bne	r3,zero,8111c4d8 <___svfprintf_internal_r+0xd84>
8111be54:	d9003117 	ldw	r4,196(sp)
8111be58:	d8c02a17 	ldw	r3,168(sp)
8111be5c:	20e9c83a 	sub	r20,r4,r3
8111be60:	05019d0e 	bge	zero,r20,8111c4d8 <___svfprintf_internal_r+0xd84>
8111be64:	02400404 	movi	r9,16
8111be68:	d8c02017 	ldw	r3,128(sp)
8111be6c:	d8801f17 	ldw	r2,124(sp)
8111be70:	4d051b0e 	bge	r9,r20,8111d2e0 <___svfprintf_internal_r+0x1b8c>
8111be74:	01604534 	movhi	r5,33044
8111be78:	29544a84 	addi	r5,r5,20778
8111be7c:	dc403c15 	stw	r17,240(sp)
8111be80:	d9403515 	stw	r5,212(sp)
8111be84:	a023883a 	mov	r17,r20
8111be88:	482d883a 	mov	r22,r9
8111be8c:	9029883a 	mov	r20,r18
8111be90:	070001c4 	movi	fp,7
8111be94:	8025883a 	mov	r18,r16
8111be98:	dc002c17 	ldw	r16,176(sp)
8111be9c:	00000306 	br	8111beac <___svfprintf_internal_r+0x758>
8111bea0:	8c7ffc04 	addi	r17,r17,-16
8111bea4:	42000204 	addi	r8,r8,8
8111bea8:	b440130e 	bge	r22,r17,8111bef8 <___svfprintf_internal_r+0x7a4>
8111beac:	01204534 	movhi	r4,33044
8111beb0:	18c00404 	addi	r3,r3,16
8111beb4:	10800044 	addi	r2,r2,1
8111beb8:	21144a84 	addi	r4,r4,20778
8111bebc:	41000015 	stw	r4,0(r8)
8111bec0:	45800115 	stw	r22,4(r8)
8111bec4:	d8c02015 	stw	r3,128(sp)
8111bec8:	d8801f15 	stw	r2,124(sp)
8111becc:	e0bff40e 	bge	fp,r2,8111bea0 <__reset+0xfb0fbea0>
8111bed0:	d9801e04 	addi	r6,sp,120
8111bed4:	800b883a 	mov	r5,r16
8111bed8:	9809883a 	mov	r4,r19
8111bedc:	1128a100 	call	81128a10 <__ssprint_r>
8111bee0:	103f031e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111bee4:	8c7ffc04 	addi	r17,r17,-16
8111bee8:	d8c02017 	ldw	r3,128(sp)
8111beec:	d8801f17 	ldw	r2,124(sp)
8111bef0:	da000404 	addi	r8,sp,16
8111bef4:	b47fed16 	blt	r22,r17,8111beac <__reset+0xfb0fbeac>
8111bef8:	9021883a 	mov	r16,r18
8111befc:	a025883a 	mov	r18,r20
8111bf00:	8829883a 	mov	r20,r17
8111bf04:	dc403c17 	ldw	r17,240(sp)
8111bf08:	d9403517 	ldw	r5,212(sp)
8111bf0c:	a0c7883a 	add	r3,r20,r3
8111bf10:	10800044 	addi	r2,r2,1
8111bf14:	41400015 	stw	r5,0(r8)
8111bf18:	45000115 	stw	r20,4(r8)
8111bf1c:	d8c02015 	stw	r3,128(sp)
8111bf20:	d8801f15 	stw	r2,124(sp)
8111bf24:	010001c4 	movi	r4,7
8111bf28:	20829f16 	blt	r4,r2,8111c9a8 <___svfprintf_internal_r+0x1254>
8111bf2c:	df002787 	ldb	fp,158(sp)
8111bf30:	42000204 	addi	r8,r8,8
8111bf34:	e0000c26 	beq	fp,zero,8111bf68 <___svfprintf_internal_r+0x814>
8111bf38:	d8801f17 	ldw	r2,124(sp)
8111bf3c:	d9002784 	addi	r4,sp,158
8111bf40:	18c00044 	addi	r3,r3,1
8111bf44:	10800044 	addi	r2,r2,1
8111bf48:	41000015 	stw	r4,0(r8)
8111bf4c:	01000044 	movi	r4,1
8111bf50:	41000115 	stw	r4,4(r8)
8111bf54:	d8c02015 	stw	r3,128(sp)
8111bf58:	d8801f15 	stw	r2,124(sp)
8111bf5c:	010001c4 	movi	r4,7
8111bf60:	20823816 	blt	r4,r2,8111c844 <___svfprintf_internal_r+0x10f0>
8111bf64:	42000204 	addi	r8,r8,8
8111bf68:	d8802b17 	ldw	r2,172(sp)
8111bf6c:	10000c26 	beq	r2,zero,8111bfa0 <___svfprintf_internal_r+0x84c>
8111bf70:	d8801f17 	ldw	r2,124(sp)
8111bf74:	d9002704 	addi	r4,sp,156
8111bf78:	18c00084 	addi	r3,r3,2
8111bf7c:	10800044 	addi	r2,r2,1
8111bf80:	41000015 	stw	r4,0(r8)
8111bf84:	01000084 	movi	r4,2
8111bf88:	41000115 	stw	r4,4(r8)
8111bf8c:	d8c02015 	stw	r3,128(sp)
8111bf90:	d8801f15 	stw	r2,124(sp)
8111bf94:	010001c4 	movi	r4,7
8111bf98:	20823216 	blt	r4,r2,8111c864 <___svfprintf_internal_r+0x1110>
8111bf9c:	42000204 	addi	r8,r8,8
8111bfa0:	d9003017 	ldw	r4,192(sp)
8111bfa4:	00802004 	movi	r2,128
8111bfa8:	20819726 	beq	r4,r2,8111c608 <___svfprintf_internal_r+0xeb4>
8111bfac:	d9402917 	ldw	r5,164(sp)
8111bfb0:	d8802e17 	ldw	r2,184(sp)
8111bfb4:	28adc83a 	sub	r22,r5,r2
8111bfb8:	05802f0e 	bge	zero,r22,8111c078 <___svfprintf_internal_r+0x924>
8111bfbc:	07000404 	movi	fp,16
8111bfc0:	d8801f17 	ldw	r2,124(sp)
8111bfc4:	e583c00e 	bge	fp,r22,8111cec8 <___svfprintf_internal_r+0x1774>
8111bfc8:	01604534 	movhi	r5,33044
8111bfcc:	29544684 	addi	r5,r5,20762
8111bfd0:	dc402915 	stw	r17,164(sp)
8111bfd4:	d9402b15 	stw	r5,172(sp)
8111bfd8:	b023883a 	mov	r17,r22
8111bfdc:	050001c4 	movi	r20,7
8111bfe0:	902d883a 	mov	r22,r18
8111bfe4:	8025883a 	mov	r18,r16
8111bfe8:	dc002c17 	ldw	r16,176(sp)
8111bfec:	00000306 	br	8111bffc <___svfprintf_internal_r+0x8a8>
8111bff0:	8c7ffc04 	addi	r17,r17,-16
8111bff4:	42000204 	addi	r8,r8,8
8111bff8:	e440110e 	bge	fp,r17,8111c040 <___svfprintf_internal_r+0x8ec>
8111bffc:	18c00404 	addi	r3,r3,16
8111c000:	10800044 	addi	r2,r2,1
8111c004:	45400015 	stw	r21,0(r8)
8111c008:	47000115 	stw	fp,4(r8)
8111c00c:	d8c02015 	stw	r3,128(sp)
8111c010:	d8801f15 	stw	r2,124(sp)
8111c014:	a0bff60e 	bge	r20,r2,8111bff0 <__reset+0xfb0fbff0>
8111c018:	d9801e04 	addi	r6,sp,120
8111c01c:	800b883a 	mov	r5,r16
8111c020:	9809883a 	mov	r4,r19
8111c024:	1128a100 	call	81128a10 <__ssprint_r>
8111c028:	103eb11e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111c02c:	8c7ffc04 	addi	r17,r17,-16
8111c030:	d8c02017 	ldw	r3,128(sp)
8111c034:	d8801f17 	ldw	r2,124(sp)
8111c038:	da000404 	addi	r8,sp,16
8111c03c:	e47fef16 	blt	fp,r17,8111bffc <__reset+0xfb0fbffc>
8111c040:	9021883a 	mov	r16,r18
8111c044:	b025883a 	mov	r18,r22
8111c048:	882d883a 	mov	r22,r17
8111c04c:	dc402917 	ldw	r17,164(sp)
8111c050:	d9002b17 	ldw	r4,172(sp)
8111c054:	1d87883a 	add	r3,r3,r22
8111c058:	10800044 	addi	r2,r2,1
8111c05c:	41000015 	stw	r4,0(r8)
8111c060:	45800115 	stw	r22,4(r8)
8111c064:	d8c02015 	stw	r3,128(sp)
8111c068:	d8801f15 	stw	r2,124(sp)
8111c06c:	010001c4 	movi	r4,7
8111c070:	2081ec16 	blt	r4,r2,8111c824 <___svfprintf_internal_r+0x10d0>
8111c074:	42000204 	addi	r8,r8,8
8111c078:	9080400c 	andi	r2,r18,256
8111c07c:	1001181e 	bne	r2,zero,8111c4e0 <___svfprintf_internal_r+0xd8c>
8111c080:	d9402e17 	ldw	r5,184(sp)
8111c084:	d8801f17 	ldw	r2,124(sp)
8111c088:	44000015 	stw	r16,0(r8)
8111c08c:	1947883a 	add	r3,r3,r5
8111c090:	10800044 	addi	r2,r2,1
8111c094:	41400115 	stw	r5,4(r8)
8111c098:	d8c02015 	stw	r3,128(sp)
8111c09c:	d8801f15 	stw	r2,124(sp)
8111c0a0:	010001c4 	movi	r4,7
8111c0a4:	2081d116 	blt	r4,r2,8111c7ec <___svfprintf_internal_r+0x1098>
8111c0a8:	42000204 	addi	r8,r8,8
8111c0ac:	9480010c 	andi	r18,r18,4
8111c0b0:	90003226 	beq	r18,zero,8111c17c <___svfprintf_internal_r+0xa28>
8111c0b4:	d9403117 	ldw	r5,196(sp)
8111c0b8:	d8802a17 	ldw	r2,168(sp)
8111c0bc:	28a1c83a 	sub	r16,r5,r2
8111c0c0:	04002e0e 	bge	zero,r16,8111c17c <___svfprintf_internal_r+0xa28>
8111c0c4:	04400404 	movi	r17,16
8111c0c8:	d8801f17 	ldw	r2,124(sp)
8111c0cc:	8c04b90e 	bge	r17,r16,8111d3b4 <___svfprintf_internal_r+0x1c60>
8111c0d0:	01604534 	movhi	r5,33044
8111c0d4:	29544a84 	addi	r5,r5,20778
8111c0d8:	d9403515 	stw	r5,212(sp)
8111c0dc:	048001c4 	movi	r18,7
8111c0e0:	dd002c17 	ldw	r20,176(sp)
8111c0e4:	00000306 	br	8111c0f4 <___svfprintf_internal_r+0x9a0>
8111c0e8:	843ffc04 	addi	r16,r16,-16
8111c0ec:	42000204 	addi	r8,r8,8
8111c0f0:	8c00130e 	bge	r17,r16,8111c140 <___svfprintf_internal_r+0x9ec>
8111c0f4:	01204534 	movhi	r4,33044
8111c0f8:	18c00404 	addi	r3,r3,16
8111c0fc:	10800044 	addi	r2,r2,1
8111c100:	21144a84 	addi	r4,r4,20778
8111c104:	41000015 	stw	r4,0(r8)
8111c108:	44400115 	stw	r17,4(r8)
8111c10c:	d8c02015 	stw	r3,128(sp)
8111c110:	d8801f15 	stw	r2,124(sp)
8111c114:	90bff40e 	bge	r18,r2,8111c0e8 <__reset+0xfb0fc0e8>
8111c118:	d9801e04 	addi	r6,sp,120
8111c11c:	a00b883a 	mov	r5,r20
8111c120:	9809883a 	mov	r4,r19
8111c124:	1128a100 	call	81128a10 <__ssprint_r>
8111c128:	103e711e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111c12c:	843ffc04 	addi	r16,r16,-16
8111c130:	d8c02017 	ldw	r3,128(sp)
8111c134:	d8801f17 	ldw	r2,124(sp)
8111c138:	da000404 	addi	r8,sp,16
8111c13c:	8c3fed16 	blt	r17,r16,8111c0f4 <__reset+0xfb0fc0f4>
8111c140:	d9403517 	ldw	r5,212(sp)
8111c144:	1c07883a 	add	r3,r3,r16
8111c148:	10800044 	addi	r2,r2,1
8111c14c:	41400015 	stw	r5,0(r8)
8111c150:	44000115 	stw	r16,4(r8)
8111c154:	d8c02015 	stw	r3,128(sp)
8111c158:	d8801f15 	stw	r2,124(sp)
8111c15c:	010001c4 	movi	r4,7
8111c160:	2080060e 	bge	r4,r2,8111c17c <___svfprintf_internal_r+0xa28>
8111c164:	d9402c17 	ldw	r5,176(sp)
8111c168:	d9801e04 	addi	r6,sp,120
8111c16c:	9809883a 	mov	r4,r19
8111c170:	1128a100 	call	81128a10 <__ssprint_r>
8111c174:	103e5e1e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111c178:	d8c02017 	ldw	r3,128(sp)
8111c17c:	d8803117 	ldw	r2,196(sp)
8111c180:	d9002a17 	ldw	r4,168(sp)
8111c184:	1100010e 	bge	r2,r4,8111c18c <___svfprintf_internal_r+0xa38>
8111c188:	2005883a 	mov	r2,r4
8111c18c:	d9402f17 	ldw	r5,188(sp)
8111c190:	288b883a 	add	r5,r5,r2
8111c194:	d9402f15 	stw	r5,188(sp)
8111c198:	18019c1e 	bne	r3,zero,8111c80c <___svfprintf_internal_r+0x10b8>
8111c19c:	b8800007 	ldb	r2,0(r23)
8111c1a0:	d8001f15 	stw	zero,124(sp)
8111c1a4:	da000404 	addi	r8,sp,16
8111c1a8:	103d991e 	bne	r2,zero,8111b810 <__reset+0xfb0fb810>
8111c1ac:	b821883a 	mov	r16,r23
8111c1b0:	003daf06 	br	8111b870 <__reset+0xfb0fb870>
8111c1b4:	18c03fcc 	andi	r3,r3,255
8111c1b8:	1805c71e 	bne	r3,zero,8111d8d8 <___svfprintf_internal_r+0x2184>
8111c1bc:	94800414 	ori	r18,r18,16
8111c1c0:	9080080c 	andi	r2,r18,32
8111c1c4:	10020126 	beq	r2,zero,8111c9cc <___svfprintf_internal_r+0x1278>
8111c1c8:	d8802d17 	ldw	r2,180(sp)
8111c1cc:	d9002917 	ldw	r4,164(sp)
8111c1d0:	d8002785 	stb	zero,158(sp)
8111c1d4:	10c00204 	addi	r3,r2,8
8111c1d8:	15000017 	ldw	r20,0(r2)
8111c1dc:	15800117 	ldw	r22,4(r2)
8111c1e0:	20038e16 	blt	r4,zero,8111d01c <___svfprintf_internal_r+0x18c8>
8111c1e4:	013fdfc4 	movi	r4,-129
8111c1e8:	a584b03a 	or	r2,r20,r22
8111c1ec:	d8c02d15 	stw	r3,180(sp)
8111c1f0:	9124703a 	and	r18,r18,r4
8111c1f4:	0039883a 	mov	fp,zero
8111c1f8:	103eb61e 	bne	r2,zero,8111bcd4 <__reset+0xfb0fbcd4>
8111c1fc:	d8802917 	ldw	r2,164(sp)
8111c200:	1002c81e 	bne	r2,zero,8111cd24 <___svfprintf_internal_r+0x15d0>
8111c204:	d8002915 	stw	zero,164(sp)
8111c208:	d8002e15 	stw	zero,184(sp)
8111c20c:	dc001e04 	addi	r16,sp,120
8111c210:	003efa06 	br	8111bdfc <__reset+0xfb0fbdfc>
8111c214:	18c03fcc 	andi	r3,r3,255
8111c218:	1805ad1e 	bne	r3,zero,8111d8d0 <___svfprintf_internal_r+0x217c>
8111c21c:	01604534 	movhi	r5,33044
8111c220:	29543a04 	addi	r5,r5,20712
8111c224:	d9403a15 	stw	r5,232(sp)
8111c228:	9080080c 	andi	r2,r18,32
8111c22c:	10006126 	beq	r2,zero,8111c3b4 <___svfprintf_internal_r+0xc60>
8111c230:	d8802d17 	ldw	r2,180(sp)
8111c234:	15000017 	ldw	r20,0(r2)
8111c238:	15800117 	ldw	r22,4(r2)
8111c23c:	10800204 	addi	r2,r2,8
8111c240:	d8802d15 	stw	r2,180(sp)
8111c244:	9080004c 	andi	r2,r18,1
8111c248:	10018e26 	beq	r2,zero,8111c884 <___svfprintf_internal_r+0x1130>
8111c24c:	a584b03a 	or	r2,r20,r22
8111c250:	10030926 	beq	r2,zero,8111ce78 <___svfprintf_internal_r+0x1724>
8111c254:	d8c02917 	ldw	r3,164(sp)
8111c258:	00800c04 	movi	r2,48
8111c25c:	d8802705 	stb	r2,156(sp)
8111c260:	dc402745 	stb	r17,157(sp)
8111c264:	d8002785 	stb	zero,158(sp)
8111c268:	90800094 	ori	r2,r18,2
8111c26c:	18048716 	blt	r3,zero,8111d48c <___svfprintf_internal_r+0x1d38>
8111c270:	00bfdfc4 	movi	r2,-129
8111c274:	90a4703a 	and	r18,r18,r2
8111c278:	94800094 	ori	r18,r18,2
8111c27c:	0039883a 	mov	fp,zero
8111c280:	d9003a17 	ldw	r4,232(sp)
8111c284:	dc001e04 	addi	r16,sp,120
8111c288:	a08003cc 	andi	r2,r20,15
8111c28c:	b006973a 	slli	r3,r22,28
8111c290:	2085883a 	add	r2,r4,r2
8111c294:	a028d13a 	srli	r20,r20,4
8111c298:	10800003 	ldbu	r2,0(r2)
8111c29c:	b02cd13a 	srli	r22,r22,4
8111c2a0:	843fffc4 	addi	r16,r16,-1
8111c2a4:	1d28b03a 	or	r20,r3,r20
8111c2a8:	80800005 	stb	r2,0(r16)
8111c2ac:	a584b03a 	or	r2,r20,r22
8111c2b0:	103ff51e 	bne	r2,zero,8111c288 <__reset+0xfb0fc288>
8111c2b4:	d8c02817 	ldw	r3,160(sp)
8111c2b8:	1c07c83a 	sub	r3,r3,r16
8111c2bc:	d8c02e15 	stw	r3,184(sp)
8111c2c0:	003ece06 	br	8111bdfc <__reset+0xfb0fbdfc>
8111c2c4:	d8c02d17 	ldw	r3,180(sp)
8111c2c8:	d9002d17 	ldw	r4,180(sp)
8111c2cc:	d8002785 	stb	zero,158(sp)
8111c2d0:	18800017 	ldw	r2,0(r3)
8111c2d4:	21000104 	addi	r4,r4,4
8111c2d8:	00c00044 	movi	r3,1
8111c2dc:	d8c02a15 	stw	r3,168(sp)
8111c2e0:	d8801405 	stb	r2,80(sp)
8111c2e4:	d9002d15 	stw	r4,180(sp)
8111c2e8:	d8c02e15 	stw	r3,184(sp)
8111c2ec:	d8002915 	stw	zero,164(sp)
8111c2f0:	d8003215 	stw	zero,200(sp)
8111c2f4:	dc001404 	addi	r16,sp,80
8111c2f8:	0039883a 	mov	fp,zero
8111c2fc:	003ecc06 	br	8111be30 <__reset+0xfb0fbe30>
8111c300:	18c03fcc 	andi	r3,r3,255
8111c304:	183e9226 	beq	r3,zero,8111bd50 <__reset+0xfb0fbd50>
8111c308:	d9c02785 	stb	r7,158(sp)
8111c30c:	003e9006 	br	8111bd50 <__reset+0xfb0fbd50>
8111c310:	00c00044 	movi	r3,1
8111c314:	01c00ac4 	movi	r7,43
8111c318:	bc400007 	ldb	r17,0(r23)
8111c31c:	003d6306 	br	8111b8ac <__reset+0xfb0fb8ac>
8111c320:	94800814 	ori	r18,r18,32
8111c324:	bc400007 	ldb	r17,0(r23)
8111c328:	003d6006 	br	8111b8ac <__reset+0xfb0fb8ac>
8111c32c:	d8c02d17 	ldw	r3,180(sp)
8111c330:	d8002785 	stb	zero,158(sp)
8111c334:	1c000017 	ldw	r16,0(r3)
8111c338:	1d000104 	addi	r20,r3,4
8111c33c:	80040f26 	beq	r16,zero,8111d37c <___svfprintf_internal_r+0x1c28>
8111c340:	d9002917 	ldw	r4,164(sp)
8111c344:	2003dc16 	blt	r4,zero,8111d2b8 <___svfprintf_internal_r+0x1b64>
8111c348:	200d883a 	mov	r6,r4
8111c34c:	000b883a 	mov	r5,zero
8111c350:	8009883a 	mov	r4,r16
8111c354:	da003e15 	stw	r8,248(sp)
8111c358:	1124f5c0 	call	81124f5c <memchr>
8111c35c:	da003e17 	ldw	r8,248(sp)
8111c360:	10045826 	beq	r2,zero,8111d4c4 <___svfprintf_internal_r+0x1d70>
8111c364:	1405c83a 	sub	r2,r2,r16
8111c368:	d8802e15 	stw	r2,184(sp)
8111c36c:	1003d816 	blt	r2,zero,8111d2d0 <___svfprintf_internal_r+0x1b7c>
8111c370:	df002783 	ldbu	fp,158(sp)
8111c374:	d8802a15 	stw	r2,168(sp)
8111c378:	dd002d15 	stw	r20,180(sp)
8111c37c:	d8002915 	stw	zero,164(sp)
8111c380:	d8003215 	stw	zero,200(sp)
8111c384:	003ea306 	br	8111be14 <__reset+0xfb0fbe14>
8111c388:	18c03fcc 	andi	r3,r3,255
8111c38c:	183f8c26 	beq	r3,zero,8111c1c0 <__reset+0xfb0fc1c0>
8111c390:	d9c02785 	stb	r7,158(sp)
8111c394:	003f8a06 	br	8111c1c0 <__reset+0xfb0fc1c0>
8111c398:	18c03fcc 	andi	r3,r3,255
8111c39c:	1805631e 	bne	r3,zero,8111d92c <___svfprintf_internal_r+0x21d8>
8111c3a0:	01604534 	movhi	r5,33044
8111c3a4:	29543f04 	addi	r5,r5,20732
8111c3a8:	d9403a15 	stw	r5,232(sp)
8111c3ac:	9080080c 	andi	r2,r18,32
8111c3b0:	103f9f1e 	bne	r2,zero,8111c230 <__reset+0xfb0fc230>
8111c3b4:	9080040c 	andi	r2,r18,16
8111c3b8:	10029c26 	beq	r2,zero,8111ce2c <___svfprintf_internal_r+0x16d8>
8111c3bc:	d8c02d17 	ldw	r3,180(sp)
8111c3c0:	002d883a 	mov	r22,zero
8111c3c4:	1d000017 	ldw	r20,0(r3)
8111c3c8:	18c00104 	addi	r3,r3,4
8111c3cc:	d8c02d15 	stw	r3,180(sp)
8111c3d0:	003f9c06 	br	8111c244 <__reset+0xfb0fc244>
8111c3d4:	94800054 	ori	r18,r18,1
8111c3d8:	bc400007 	ldb	r17,0(r23)
8111c3dc:	003d3306 	br	8111b8ac <__reset+0xfb0fb8ac>
8111c3e0:	38803fcc 	andi	r2,r7,255
8111c3e4:	1080201c 	xori	r2,r2,128
8111c3e8:	10bfe004 	addi	r2,r2,-128
8111c3ec:	1002971e 	bne	r2,zero,8111ce4c <___svfprintf_internal_r+0x16f8>
8111c3f0:	00c00044 	movi	r3,1
8111c3f4:	01c00804 	movi	r7,32
8111c3f8:	bc400007 	ldb	r17,0(r23)
8111c3fc:	003d2b06 	br	8111b8ac <__reset+0xfb0fb8ac>
8111c400:	18c03fcc 	andi	r3,r3,255
8111c404:	183e2326 	beq	r3,zero,8111bc94 <__reset+0xfb0fbc94>
8111c408:	d9c02785 	stb	r7,158(sp)
8111c40c:	003e2106 	br	8111bc94 <__reset+0xfb0fbc94>
8111c410:	bc400007 	ldb	r17,0(r23)
8111c414:	8a430426 	beq	r17,r9,8111d028 <___svfprintf_internal_r+0x18d4>
8111c418:	94800414 	ori	r18,r18,16
8111c41c:	003d2306 	br	8111b8ac <__reset+0xfb0fb8ac>
8111c420:	18c03fcc 	andi	r3,r3,255
8111c424:	18053f1e 	bne	r3,zero,8111d924 <___svfprintf_internal_r+0x21d0>
8111c428:	9080080c 	andi	r2,r18,32
8111c42c:	10028926 	beq	r2,zero,8111ce54 <___svfprintf_internal_r+0x1700>
8111c430:	d9402d17 	ldw	r5,180(sp)
8111c434:	d9002f17 	ldw	r4,188(sp)
8111c438:	28800017 	ldw	r2,0(r5)
8111c43c:	2007d7fa 	srai	r3,r4,31
8111c440:	29400104 	addi	r5,r5,4
8111c444:	d9402d15 	stw	r5,180(sp)
8111c448:	11000015 	stw	r4,0(r2)
8111c44c:	10c00115 	stw	r3,4(r2)
8111c450:	003ced06 	br	8111b808 <__reset+0xfb0fb808>
8111c454:	94801014 	ori	r18,r18,64
8111c458:	bc400007 	ldb	r17,0(r23)
8111c45c:	003d1306 	br	8111b8ac <__reset+0xfb0fb8ac>
8111c460:	01204534 	movhi	r4,33044
8111c464:	21143f04 	addi	r4,r4,20732
8111c468:	0039883a 	mov	fp,zero
8111c46c:	d9003a15 	stw	r4,232(sp)
8111c470:	04401e04 	movi	r17,120
8111c474:	003f8206 	br	8111c280 <__reset+0xfb0fc280>
8111c478:	18c03fcc 	andi	r3,r3,255
8111c47c:	1805221e 	bne	r3,zero,8111d908 <___svfprintf_internal_r+0x21b4>
8111c480:	883d9526 	beq	r17,zero,8111bad8 <__reset+0xfb0fbad8>
8111c484:	00c00044 	movi	r3,1
8111c488:	d8c02a15 	stw	r3,168(sp)
8111c48c:	dc401405 	stb	r17,80(sp)
8111c490:	d8002785 	stb	zero,158(sp)
8111c494:	003f9406 	br	8111c2e8 <__reset+0xfb0fc2e8>
8111c498:	01204534 	movhi	r4,33044
8111c49c:	21143f04 	addi	r4,r4,20732
8111c4a0:	d9003a15 	stw	r4,232(sp)
8111c4a4:	d8c02d15 	stw	r3,180(sp)
8111c4a8:	1025883a 	mov	r18,r2
8111c4ac:	04401e04 	movi	r17,120
8111c4b0:	a584b03a 	or	r2,r20,r22
8111c4b4:	1000fa1e 	bne	r2,zero,8111c8a0 <___svfprintf_internal_r+0x114c>
8111c4b8:	0039883a 	mov	fp,zero
8111c4bc:	00800084 	movi	r2,2
8111c4c0:	10803fcc 	andi	r2,r2,255
8111c4c4:	00c00044 	movi	r3,1
8111c4c8:	10c21626 	beq	r2,r3,8111cd24 <___svfprintf_internal_r+0x15d0>
8111c4cc:	00c00084 	movi	r3,2
8111c4d0:	10fe301e 	bne	r2,r3,8111bd94 <__reset+0xfb0fbd94>
8111c4d4:	003d7606 	br	8111bab0 <__reset+0xfb0fbab0>
8111c4d8:	d8c02017 	ldw	r3,128(sp)
8111c4dc:	003e9506 	br	8111bf34 <__reset+0xfb0fbf34>
8111c4e0:	00801944 	movi	r2,101
8111c4e4:	14407c0e 	bge	r2,r17,8111c6d8 <___svfprintf_internal_r+0xf84>
8111c4e8:	d9003617 	ldw	r4,216(sp)
8111c4ec:	d9403717 	ldw	r5,220(sp)
8111c4f0:	000d883a 	mov	r6,zero
8111c4f4:	000f883a 	mov	r7,zero
8111c4f8:	d8c03d15 	stw	r3,244(sp)
8111c4fc:	da003e15 	stw	r8,248(sp)
8111c500:	112ed400 	call	8112ed40 <__eqdf2>
8111c504:	d8c03d17 	ldw	r3,244(sp)
8111c508:	da003e17 	ldw	r8,248(sp)
8111c50c:	1000f51e 	bne	r2,zero,8111c8e4 <___svfprintf_internal_r+0x1190>
8111c510:	d8801f17 	ldw	r2,124(sp)
8111c514:	01204534 	movhi	r4,33044
8111c518:	21144604 	addi	r4,r4,20760
8111c51c:	18c00044 	addi	r3,r3,1
8111c520:	10800044 	addi	r2,r2,1
8111c524:	41000015 	stw	r4,0(r8)
8111c528:	01000044 	movi	r4,1
8111c52c:	41000115 	stw	r4,4(r8)
8111c530:	d8c02015 	stw	r3,128(sp)
8111c534:	d8801f15 	stw	r2,124(sp)
8111c538:	010001c4 	movi	r4,7
8111c53c:	20826616 	blt	r4,r2,8111ced8 <___svfprintf_internal_r+0x1784>
8111c540:	42000204 	addi	r8,r8,8
8111c544:	d8802617 	ldw	r2,152(sp)
8111c548:	d9403317 	ldw	r5,204(sp)
8111c54c:	11400216 	blt	r2,r5,8111c558 <___svfprintf_internal_r+0xe04>
8111c550:	9080004c 	andi	r2,r18,1
8111c554:	103ed526 	beq	r2,zero,8111c0ac <__reset+0xfb0fc0ac>
8111c558:	d8803817 	ldw	r2,224(sp)
8111c55c:	d9003417 	ldw	r4,208(sp)
8111c560:	d9403817 	ldw	r5,224(sp)
8111c564:	1887883a 	add	r3,r3,r2
8111c568:	d8801f17 	ldw	r2,124(sp)
8111c56c:	41000015 	stw	r4,0(r8)
8111c570:	41400115 	stw	r5,4(r8)
8111c574:	10800044 	addi	r2,r2,1
8111c578:	d8c02015 	stw	r3,128(sp)
8111c57c:	d8801f15 	stw	r2,124(sp)
8111c580:	010001c4 	movi	r4,7
8111c584:	2082af16 	blt	r4,r2,8111d044 <___svfprintf_internal_r+0x18f0>
8111c588:	42000204 	addi	r8,r8,8
8111c58c:	d8803317 	ldw	r2,204(sp)
8111c590:	143fffc4 	addi	r16,r2,-1
8111c594:	043ec50e 	bge	zero,r16,8111c0ac <__reset+0xfb0fc0ac>
8111c598:	04400404 	movi	r17,16
8111c59c:	d8801f17 	ldw	r2,124(sp)
8111c5a0:	8c00860e 	bge	r17,r16,8111c7bc <___svfprintf_internal_r+0x1068>
8111c5a4:	01604534 	movhi	r5,33044
8111c5a8:	29544684 	addi	r5,r5,20762
8111c5ac:	d9402b15 	stw	r5,172(sp)
8111c5b0:	058001c4 	movi	r22,7
8111c5b4:	dd002c17 	ldw	r20,176(sp)
8111c5b8:	00000306 	br	8111c5c8 <___svfprintf_internal_r+0xe74>
8111c5bc:	42000204 	addi	r8,r8,8
8111c5c0:	843ffc04 	addi	r16,r16,-16
8111c5c4:	8c00800e 	bge	r17,r16,8111c7c8 <___svfprintf_internal_r+0x1074>
8111c5c8:	18c00404 	addi	r3,r3,16
8111c5cc:	10800044 	addi	r2,r2,1
8111c5d0:	45400015 	stw	r21,0(r8)
8111c5d4:	44400115 	stw	r17,4(r8)
8111c5d8:	d8c02015 	stw	r3,128(sp)
8111c5dc:	d8801f15 	stw	r2,124(sp)
8111c5e0:	b0bff60e 	bge	r22,r2,8111c5bc <__reset+0xfb0fc5bc>
8111c5e4:	d9801e04 	addi	r6,sp,120
8111c5e8:	a00b883a 	mov	r5,r20
8111c5ec:	9809883a 	mov	r4,r19
8111c5f0:	1128a100 	call	81128a10 <__ssprint_r>
8111c5f4:	103d3e1e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111c5f8:	d8c02017 	ldw	r3,128(sp)
8111c5fc:	d8801f17 	ldw	r2,124(sp)
8111c600:	da000404 	addi	r8,sp,16
8111c604:	003fee06 	br	8111c5c0 <__reset+0xfb0fc5c0>
8111c608:	d9403117 	ldw	r5,196(sp)
8111c60c:	d8802a17 	ldw	r2,168(sp)
8111c610:	28adc83a 	sub	r22,r5,r2
8111c614:	05be650e 	bge	zero,r22,8111bfac <__reset+0xfb0fbfac>
8111c618:	07000404 	movi	fp,16
8111c61c:	d8801f17 	ldw	r2,124(sp)
8111c620:	e583a20e 	bge	fp,r22,8111d4ac <___svfprintf_internal_r+0x1d58>
8111c624:	01604534 	movhi	r5,33044
8111c628:	29544684 	addi	r5,r5,20762
8111c62c:	dc403015 	stw	r17,192(sp)
8111c630:	d9402b15 	stw	r5,172(sp)
8111c634:	b023883a 	mov	r17,r22
8111c638:	050001c4 	movi	r20,7
8111c63c:	902d883a 	mov	r22,r18
8111c640:	8025883a 	mov	r18,r16
8111c644:	dc002c17 	ldw	r16,176(sp)
8111c648:	00000306 	br	8111c658 <___svfprintf_internal_r+0xf04>
8111c64c:	8c7ffc04 	addi	r17,r17,-16
8111c650:	42000204 	addi	r8,r8,8
8111c654:	e440110e 	bge	fp,r17,8111c69c <___svfprintf_internal_r+0xf48>
8111c658:	18c00404 	addi	r3,r3,16
8111c65c:	10800044 	addi	r2,r2,1
8111c660:	45400015 	stw	r21,0(r8)
8111c664:	47000115 	stw	fp,4(r8)
8111c668:	d8c02015 	stw	r3,128(sp)
8111c66c:	d8801f15 	stw	r2,124(sp)
8111c670:	a0bff60e 	bge	r20,r2,8111c64c <__reset+0xfb0fc64c>
8111c674:	d9801e04 	addi	r6,sp,120
8111c678:	800b883a 	mov	r5,r16
8111c67c:	9809883a 	mov	r4,r19
8111c680:	1128a100 	call	81128a10 <__ssprint_r>
8111c684:	103d1a1e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111c688:	8c7ffc04 	addi	r17,r17,-16
8111c68c:	d8c02017 	ldw	r3,128(sp)
8111c690:	d8801f17 	ldw	r2,124(sp)
8111c694:	da000404 	addi	r8,sp,16
8111c698:	e47fef16 	blt	fp,r17,8111c658 <__reset+0xfb0fc658>
8111c69c:	9021883a 	mov	r16,r18
8111c6a0:	b025883a 	mov	r18,r22
8111c6a4:	882d883a 	mov	r22,r17
8111c6a8:	dc403017 	ldw	r17,192(sp)
8111c6ac:	d9002b17 	ldw	r4,172(sp)
8111c6b0:	1d87883a 	add	r3,r3,r22
8111c6b4:	10800044 	addi	r2,r2,1
8111c6b8:	41000015 	stw	r4,0(r8)
8111c6bc:	45800115 	stw	r22,4(r8)
8111c6c0:	d8c02015 	stw	r3,128(sp)
8111c6c4:	d8801f15 	stw	r2,124(sp)
8111c6c8:	010001c4 	movi	r4,7
8111c6cc:	20819a16 	blt	r4,r2,8111cd38 <___svfprintf_internal_r+0x15e4>
8111c6d0:	42000204 	addi	r8,r8,8
8111c6d4:	003e3506 	br	8111bfac <__reset+0xfb0fbfac>
8111c6d8:	d9403317 	ldw	r5,204(sp)
8111c6dc:	00800044 	movi	r2,1
8111c6e0:	18c00044 	addi	r3,r3,1
8111c6e4:	1141710e 	bge	r2,r5,8111ccac <___svfprintf_internal_r+0x1558>
8111c6e8:	dc401f17 	ldw	r17,124(sp)
8111c6ec:	00800044 	movi	r2,1
8111c6f0:	40800115 	stw	r2,4(r8)
8111c6f4:	8c400044 	addi	r17,r17,1
8111c6f8:	44000015 	stw	r16,0(r8)
8111c6fc:	d8c02015 	stw	r3,128(sp)
8111c700:	dc401f15 	stw	r17,124(sp)
8111c704:	008001c4 	movi	r2,7
8111c708:	14417416 	blt	r2,r17,8111ccdc <___svfprintf_internal_r+0x1588>
8111c70c:	42000204 	addi	r8,r8,8
8111c710:	d8803817 	ldw	r2,224(sp)
8111c714:	d9003417 	ldw	r4,208(sp)
8111c718:	8c400044 	addi	r17,r17,1
8111c71c:	10c7883a 	add	r3,r2,r3
8111c720:	40800115 	stw	r2,4(r8)
8111c724:	41000015 	stw	r4,0(r8)
8111c728:	d8c02015 	stw	r3,128(sp)
8111c72c:	dc401f15 	stw	r17,124(sp)
8111c730:	008001c4 	movi	r2,7
8111c734:	14417216 	blt	r2,r17,8111cd00 <___svfprintf_internal_r+0x15ac>
8111c738:	45800204 	addi	r22,r8,8
8111c73c:	d9003617 	ldw	r4,216(sp)
8111c740:	d9403717 	ldw	r5,220(sp)
8111c744:	000d883a 	mov	r6,zero
8111c748:	000f883a 	mov	r7,zero
8111c74c:	d8c03d15 	stw	r3,244(sp)
8111c750:	112ed400 	call	8112ed40 <__eqdf2>
8111c754:	d8c03d17 	ldw	r3,244(sp)
8111c758:	1000b326 	beq	r2,zero,8111ca28 <___svfprintf_internal_r+0x12d4>
8111c75c:	d9403317 	ldw	r5,204(sp)
8111c760:	84000044 	addi	r16,r16,1
8111c764:	8c400044 	addi	r17,r17,1
8111c768:	28bfffc4 	addi	r2,r5,-1
8111c76c:	1887883a 	add	r3,r3,r2
8111c770:	b0800115 	stw	r2,4(r22)
8111c774:	b4000015 	stw	r16,0(r22)
8111c778:	d8c02015 	stw	r3,128(sp)
8111c77c:	dc401f15 	stw	r17,124(sp)
8111c780:	008001c4 	movi	r2,7
8111c784:	1440d216 	blt	r2,r17,8111cad0 <___svfprintf_internal_r+0x137c>
8111c788:	b5800204 	addi	r22,r22,8
8111c78c:	d9003b17 	ldw	r4,236(sp)
8111c790:	df0022c4 	addi	fp,sp,139
8111c794:	8c400044 	addi	r17,r17,1
8111c798:	20c7883a 	add	r3,r4,r3
8111c79c:	b7000015 	stw	fp,0(r22)
8111c7a0:	b1000115 	stw	r4,4(r22)
8111c7a4:	d8c02015 	stw	r3,128(sp)
8111c7a8:	dc401f15 	stw	r17,124(sp)
8111c7ac:	008001c4 	movi	r2,7
8111c7b0:	14400e16 	blt	r2,r17,8111c7ec <___svfprintf_internal_r+0x1098>
8111c7b4:	b2000204 	addi	r8,r22,8
8111c7b8:	003e3c06 	br	8111c0ac <__reset+0xfb0fc0ac>
8111c7bc:	01204534 	movhi	r4,33044
8111c7c0:	21144684 	addi	r4,r4,20762
8111c7c4:	d9002b15 	stw	r4,172(sp)
8111c7c8:	d9002b17 	ldw	r4,172(sp)
8111c7cc:	1c07883a 	add	r3,r3,r16
8111c7d0:	44000115 	stw	r16,4(r8)
8111c7d4:	41000015 	stw	r4,0(r8)
8111c7d8:	10800044 	addi	r2,r2,1
8111c7dc:	d8c02015 	stw	r3,128(sp)
8111c7e0:	d8801f15 	stw	r2,124(sp)
8111c7e4:	010001c4 	movi	r4,7
8111c7e8:	20be2f0e 	bge	r4,r2,8111c0a8 <__reset+0xfb0fc0a8>
8111c7ec:	d9402c17 	ldw	r5,176(sp)
8111c7f0:	d9801e04 	addi	r6,sp,120
8111c7f4:	9809883a 	mov	r4,r19
8111c7f8:	1128a100 	call	81128a10 <__ssprint_r>
8111c7fc:	103cbc1e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111c800:	d8c02017 	ldw	r3,128(sp)
8111c804:	da000404 	addi	r8,sp,16
8111c808:	003e2806 	br	8111c0ac <__reset+0xfb0fc0ac>
8111c80c:	d9402c17 	ldw	r5,176(sp)
8111c810:	d9801e04 	addi	r6,sp,120
8111c814:	9809883a 	mov	r4,r19
8111c818:	1128a100 	call	81128a10 <__ssprint_r>
8111c81c:	103e5f26 	beq	r2,zero,8111c19c <__reset+0xfb0fc19c>
8111c820:	003cb306 	br	8111baf0 <__reset+0xfb0fbaf0>
8111c824:	d9402c17 	ldw	r5,176(sp)
8111c828:	d9801e04 	addi	r6,sp,120
8111c82c:	9809883a 	mov	r4,r19
8111c830:	1128a100 	call	81128a10 <__ssprint_r>
8111c834:	103cae1e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111c838:	d8c02017 	ldw	r3,128(sp)
8111c83c:	da000404 	addi	r8,sp,16
8111c840:	003e0d06 	br	8111c078 <__reset+0xfb0fc078>
8111c844:	d9402c17 	ldw	r5,176(sp)
8111c848:	d9801e04 	addi	r6,sp,120
8111c84c:	9809883a 	mov	r4,r19
8111c850:	1128a100 	call	81128a10 <__ssprint_r>
8111c854:	103ca61e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111c858:	d8c02017 	ldw	r3,128(sp)
8111c85c:	da000404 	addi	r8,sp,16
8111c860:	003dc106 	br	8111bf68 <__reset+0xfb0fbf68>
8111c864:	d9402c17 	ldw	r5,176(sp)
8111c868:	d9801e04 	addi	r6,sp,120
8111c86c:	9809883a 	mov	r4,r19
8111c870:	1128a100 	call	81128a10 <__ssprint_r>
8111c874:	103c9e1e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111c878:	d8c02017 	ldw	r3,128(sp)
8111c87c:	da000404 	addi	r8,sp,16
8111c880:	003dc706 	br	8111bfa0 <__reset+0xfb0fbfa0>
8111c884:	d8802917 	ldw	r2,164(sp)
8111c888:	d8002785 	stb	zero,158(sp)
8111c88c:	103f0816 	blt	r2,zero,8111c4b0 <__reset+0xfb0fc4b0>
8111c890:	00ffdfc4 	movi	r3,-129
8111c894:	a584b03a 	or	r2,r20,r22
8111c898:	90e4703a 	and	r18,r18,r3
8111c89c:	103c8126 	beq	r2,zero,8111baa4 <__reset+0xfb0fbaa4>
8111c8a0:	0039883a 	mov	fp,zero
8111c8a4:	003e7606 	br	8111c280 <__reset+0xfb0fc280>
8111c8a8:	9080040c 	andi	r2,r18,16
8111c8ac:	10013d26 	beq	r2,zero,8111cda4 <___svfprintf_internal_r+0x1650>
8111c8b0:	d9002d17 	ldw	r4,180(sp)
8111c8b4:	d9402917 	ldw	r5,164(sp)
8111c8b8:	d8002785 	stb	zero,158(sp)
8111c8bc:	20800104 	addi	r2,r4,4
8111c8c0:	25000017 	ldw	r20,0(r4)
8111c8c4:	002d883a 	mov	r22,zero
8111c8c8:	28013f16 	blt	r5,zero,8111cdc8 <___svfprintf_internal_r+0x1674>
8111c8cc:	00ffdfc4 	movi	r3,-129
8111c8d0:	d8802d15 	stw	r2,180(sp)
8111c8d4:	90e4703a 	and	r18,r18,r3
8111c8d8:	a03d2b26 	beq	r20,zero,8111bd88 <__reset+0xfb0fbd88>
8111c8dc:	0039883a 	mov	fp,zero
8111c8e0:	003d2e06 	br	8111bd9c <__reset+0xfb0fbd9c>
8111c8e4:	dc402617 	ldw	r17,152(sp)
8111c8e8:	0441830e 	bge	zero,r17,8111cef8 <___svfprintf_internal_r+0x17a4>
8111c8ec:	dc403217 	ldw	r17,200(sp)
8111c8f0:	d8803317 	ldw	r2,204(sp)
8111c8f4:	1440010e 	bge	r2,r17,8111c8fc <___svfprintf_internal_r+0x11a8>
8111c8f8:	1023883a 	mov	r17,r2
8111c8fc:	04400a0e 	bge	zero,r17,8111c928 <___svfprintf_internal_r+0x11d4>
8111c900:	d8801f17 	ldw	r2,124(sp)
8111c904:	1c47883a 	add	r3,r3,r17
8111c908:	44000015 	stw	r16,0(r8)
8111c90c:	10800044 	addi	r2,r2,1
8111c910:	44400115 	stw	r17,4(r8)
8111c914:	d8c02015 	stw	r3,128(sp)
8111c918:	d8801f15 	stw	r2,124(sp)
8111c91c:	010001c4 	movi	r4,7
8111c920:	20827516 	blt	r4,r2,8111d2f8 <___svfprintf_internal_r+0x1ba4>
8111c924:	42000204 	addi	r8,r8,8
8111c928:	88027b16 	blt	r17,zero,8111d318 <___svfprintf_internal_r+0x1bc4>
8111c92c:	d9003217 	ldw	r4,200(sp)
8111c930:	2463c83a 	sub	r17,r4,r17
8111c934:	0440990e 	bge	zero,r17,8111cb9c <___svfprintf_internal_r+0x1448>
8111c938:	05800404 	movi	r22,16
8111c93c:	d8801f17 	ldw	r2,124(sp)
8111c940:	b441530e 	bge	r22,r17,8111ce90 <___svfprintf_internal_r+0x173c>
8111c944:	01204534 	movhi	r4,33044
8111c948:	21144684 	addi	r4,r4,20762
8111c94c:	d9002b15 	stw	r4,172(sp)
8111c950:	070001c4 	movi	fp,7
8111c954:	dd002c17 	ldw	r20,176(sp)
8111c958:	00000306 	br	8111c968 <___svfprintf_internal_r+0x1214>
8111c95c:	42000204 	addi	r8,r8,8
8111c960:	8c7ffc04 	addi	r17,r17,-16
8111c964:	b4414d0e 	bge	r22,r17,8111ce9c <___svfprintf_internal_r+0x1748>
8111c968:	18c00404 	addi	r3,r3,16
8111c96c:	10800044 	addi	r2,r2,1
8111c970:	45400015 	stw	r21,0(r8)
8111c974:	45800115 	stw	r22,4(r8)
8111c978:	d8c02015 	stw	r3,128(sp)
8111c97c:	d8801f15 	stw	r2,124(sp)
8111c980:	e0bff60e 	bge	fp,r2,8111c95c <__reset+0xfb0fc95c>
8111c984:	d9801e04 	addi	r6,sp,120
8111c988:	a00b883a 	mov	r5,r20
8111c98c:	9809883a 	mov	r4,r19
8111c990:	1128a100 	call	81128a10 <__ssprint_r>
8111c994:	103c561e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111c998:	d8c02017 	ldw	r3,128(sp)
8111c99c:	d8801f17 	ldw	r2,124(sp)
8111c9a0:	da000404 	addi	r8,sp,16
8111c9a4:	003fee06 	br	8111c960 <__reset+0xfb0fc960>
8111c9a8:	d9402c17 	ldw	r5,176(sp)
8111c9ac:	d9801e04 	addi	r6,sp,120
8111c9b0:	9809883a 	mov	r4,r19
8111c9b4:	1128a100 	call	81128a10 <__ssprint_r>
8111c9b8:	103c4d1e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111c9bc:	d8c02017 	ldw	r3,128(sp)
8111c9c0:	df002787 	ldb	fp,158(sp)
8111c9c4:	da000404 	addi	r8,sp,16
8111c9c8:	003d5a06 	br	8111bf34 <__reset+0xfb0fbf34>
8111c9cc:	9080040c 	andi	r2,r18,16
8111c9d0:	10005c26 	beq	r2,zero,8111cb44 <___svfprintf_internal_r+0x13f0>
8111c9d4:	d9402d17 	ldw	r5,180(sp)
8111c9d8:	d8c02917 	ldw	r3,164(sp)
8111c9dc:	d8002785 	stb	zero,158(sp)
8111c9e0:	28800104 	addi	r2,r5,4
8111c9e4:	2d000017 	ldw	r20,0(r5)
8111c9e8:	002d883a 	mov	r22,zero
8111c9ec:	18005e16 	blt	r3,zero,8111cb68 <___svfprintf_internal_r+0x1414>
8111c9f0:	00ffdfc4 	movi	r3,-129
8111c9f4:	d8802d15 	stw	r2,180(sp)
8111c9f8:	90e4703a 	and	r18,r18,r3
8111c9fc:	0039883a 	mov	fp,zero
8111ca00:	a03dfe26 	beq	r20,zero,8111c1fc <__reset+0xfb0fc1fc>
8111ca04:	00800244 	movi	r2,9
8111ca08:	153cb336 	bltu	r2,r20,8111bcd8 <__reset+0xfb0fbcd8>
8111ca0c:	a5000c04 	addi	r20,r20,48
8111ca10:	dc001dc4 	addi	r16,sp,119
8111ca14:	dd001dc5 	stb	r20,119(sp)
8111ca18:	d8c02817 	ldw	r3,160(sp)
8111ca1c:	1c07c83a 	sub	r3,r3,r16
8111ca20:	d8c02e15 	stw	r3,184(sp)
8111ca24:	003cf506 	br	8111bdfc <__reset+0xfb0fbdfc>
8111ca28:	d8803317 	ldw	r2,204(sp)
8111ca2c:	143fffc4 	addi	r16,r2,-1
8111ca30:	043f560e 	bge	zero,r16,8111c78c <__reset+0xfb0fc78c>
8111ca34:	07000404 	movi	fp,16
8111ca38:	e403530e 	bge	fp,r16,8111d788 <___svfprintf_internal_r+0x2034>
8111ca3c:	01604534 	movhi	r5,33044
8111ca40:	29544684 	addi	r5,r5,20762
8111ca44:	d9402b15 	stw	r5,172(sp)
8111ca48:	01c001c4 	movi	r7,7
8111ca4c:	dd002c17 	ldw	r20,176(sp)
8111ca50:	00000306 	br	8111ca60 <___svfprintf_internal_r+0x130c>
8111ca54:	843ffc04 	addi	r16,r16,-16
8111ca58:	b5800204 	addi	r22,r22,8
8111ca5c:	e400130e 	bge	fp,r16,8111caac <___svfprintf_internal_r+0x1358>
8111ca60:	18c00404 	addi	r3,r3,16
8111ca64:	8c400044 	addi	r17,r17,1
8111ca68:	b5400015 	stw	r21,0(r22)
8111ca6c:	b7000115 	stw	fp,4(r22)
8111ca70:	d8c02015 	stw	r3,128(sp)
8111ca74:	dc401f15 	stw	r17,124(sp)
8111ca78:	3c7ff60e 	bge	r7,r17,8111ca54 <__reset+0xfb0fca54>
8111ca7c:	d9801e04 	addi	r6,sp,120
8111ca80:	a00b883a 	mov	r5,r20
8111ca84:	9809883a 	mov	r4,r19
8111ca88:	d9c03d15 	stw	r7,244(sp)
8111ca8c:	1128a100 	call	81128a10 <__ssprint_r>
8111ca90:	d9c03d17 	ldw	r7,244(sp)
8111ca94:	103c161e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111ca98:	843ffc04 	addi	r16,r16,-16
8111ca9c:	d8c02017 	ldw	r3,128(sp)
8111caa0:	dc401f17 	ldw	r17,124(sp)
8111caa4:	dd800404 	addi	r22,sp,16
8111caa8:	e43fed16 	blt	fp,r16,8111ca60 <__reset+0xfb0fca60>
8111caac:	d8802b17 	ldw	r2,172(sp)
8111cab0:	1c07883a 	add	r3,r3,r16
8111cab4:	8c400044 	addi	r17,r17,1
8111cab8:	b0800015 	stw	r2,0(r22)
8111cabc:	b4000115 	stw	r16,4(r22)
8111cac0:	d8c02015 	stw	r3,128(sp)
8111cac4:	dc401f15 	stw	r17,124(sp)
8111cac8:	008001c4 	movi	r2,7
8111cacc:	147f2e0e 	bge	r2,r17,8111c788 <__reset+0xfb0fc788>
8111cad0:	d9402c17 	ldw	r5,176(sp)
8111cad4:	d9801e04 	addi	r6,sp,120
8111cad8:	9809883a 	mov	r4,r19
8111cadc:	1128a100 	call	81128a10 <__ssprint_r>
8111cae0:	103c031e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111cae4:	d8c02017 	ldw	r3,128(sp)
8111cae8:	dc401f17 	ldw	r17,124(sp)
8111caec:	dd800404 	addi	r22,sp,16
8111caf0:	003f2606 	br	8111c78c <__reset+0xfb0fc78c>
8111caf4:	9080040c 	andi	r2,r18,16
8111caf8:	1000c326 	beq	r2,zero,8111ce08 <___svfprintf_internal_r+0x16b4>
8111cafc:	d8802d17 	ldw	r2,180(sp)
8111cb00:	15000017 	ldw	r20,0(r2)
8111cb04:	10800104 	addi	r2,r2,4
8111cb08:	d8802d15 	stw	r2,180(sp)
8111cb0c:	a02dd7fa 	srai	r22,r20,31
8111cb10:	b005883a 	mov	r2,r22
8111cb14:	103c680e 	bge	r2,zero,8111bcb8 <__reset+0xfb0fbcb8>
8111cb18:	0529c83a 	sub	r20,zero,r20
8111cb1c:	a004c03a 	cmpne	r2,r20,zero
8111cb20:	05adc83a 	sub	r22,zero,r22
8111cb24:	b0adc83a 	sub	r22,r22,r2
8111cb28:	d8802917 	ldw	r2,164(sp)
8111cb2c:	07000b44 	movi	fp,45
8111cb30:	df002785 	stb	fp,158(sp)
8111cb34:	10022e16 	blt	r2,zero,8111d3f0 <___svfprintf_internal_r+0x1c9c>
8111cb38:	00bfdfc4 	movi	r2,-129
8111cb3c:	90a4703a 	and	r18,r18,r2
8111cb40:	003c6406 	br	8111bcd4 <__reset+0xfb0fbcd4>
8111cb44:	9080100c 	andi	r2,r18,64
8111cb48:	d8002785 	stb	zero,158(sp)
8111cb4c:	10012526 	beq	r2,zero,8111cfe4 <___svfprintf_internal_r+0x1890>
8111cb50:	d9002d17 	ldw	r4,180(sp)
8111cb54:	d9402917 	ldw	r5,164(sp)
8111cb58:	002d883a 	mov	r22,zero
8111cb5c:	20800104 	addi	r2,r4,4
8111cb60:	2500000b 	ldhu	r20,0(r4)
8111cb64:	283fa20e 	bge	r5,zero,8111c9f0 <__reset+0xfb0fc9f0>
8111cb68:	d8802d15 	stw	r2,180(sp)
8111cb6c:	0039883a 	mov	fp,zero
8111cb70:	a584b03a 	or	r2,r20,r22
8111cb74:	103c571e 	bne	r2,zero,8111bcd4 <__reset+0xfb0fbcd4>
8111cb78:	00800044 	movi	r2,1
8111cb7c:	003e5006 	br	8111c4c0 <__reset+0xfb0fc4c0>
8111cb80:	d9402c17 	ldw	r5,176(sp)
8111cb84:	d9801e04 	addi	r6,sp,120
8111cb88:	9809883a 	mov	r4,r19
8111cb8c:	1128a100 	call	81128a10 <__ssprint_r>
8111cb90:	103bd71e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111cb94:	d8c02017 	ldw	r3,128(sp)
8111cb98:	da000404 	addi	r8,sp,16
8111cb9c:	d9003217 	ldw	r4,200(sp)
8111cba0:	d8802617 	ldw	r2,152(sp)
8111cba4:	d9403317 	ldw	r5,204(sp)
8111cba8:	8123883a 	add	r17,r16,r4
8111cbac:	11400216 	blt	r2,r5,8111cbb8 <___svfprintf_internal_r+0x1464>
8111cbb0:	9100004c 	andi	r4,r18,1
8111cbb4:	20000d26 	beq	r4,zero,8111cbec <___svfprintf_internal_r+0x1498>
8111cbb8:	d9003817 	ldw	r4,224(sp)
8111cbbc:	d9403417 	ldw	r5,208(sp)
8111cbc0:	1907883a 	add	r3,r3,r4
8111cbc4:	d9001f17 	ldw	r4,124(sp)
8111cbc8:	41400015 	stw	r5,0(r8)
8111cbcc:	d9403817 	ldw	r5,224(sp)
8111cbd0:	21000044 	addi	r4,r4,1
8111cbd4:	d8c02015 	stw	r3,128(sp)
8111cbd8:	41400115 	stw	r5,4(r8)
8111cbdc:	d9001f15 	stw	r4,124(sp)
8111cbe0:	014001c4 	movi	r5,7
8111cbe4:	2901dc16 	blt	r5,r4,8111d358 <___svfprintf_internal_r+0x1c04>
8111cbe8:	42000204 	addi	r8,r8,8
8111cbec:	d9003317 	ldw	r4,204(sp)
8111cbf0:	8121883a 	add	r16,r16,r4
8111cbf4:	2085c83a 	sub	r2,r4,r2
8111cbf8:	8461c83a 	sub	r16,r16,r17
8111cbfc:	1400010e 	bge	r2,r16,8111cc04 <___svfprintf_internal_r+0x14b0>
8111cc00:	1021883a 	mov	r16,r2
8111cc04:	04000a0e 	bge	zero,r16,8111cc30 <___svfprintf_internal_r+0x14dc>
8111cc08:	d9001f17 	ldw	r4,124(sp)
8111cc0c:	1c07883a 	add	r3,r3,r16
8111cc10:	44400015 	stw	r17,0(r8)
8111cc14:	21000044 	addi	r4,r4,1
8111cc18:	44000115 	stw	r16,4(r8)
8111cc1c:	d8c02015 	stw	r3,128(sp)
8111cc20:	d9001f15 	stw	r4,124(sp)
8111cc24:	014001c4 	movi	r5,7
8111cc28:	2901e616 	blt	r5,r4,8111d3c4 <___svfprintf_internal_r+0x1c70>
8111cc2c:	42000204 	addi	r8,r8,8
8111cc30:	8001f616 	blt	r16,zero,8111d40c <___svfprintf_internal_r+0x1cb8>
8111cc34:	1421c83a 	sub	r16,r2,r16
8111cc38:	043d1c0e 	bge	zero,r16,8111c0ac <__reset+0xfb0fc0ac>
8111cc3c:	04400404 	movi	r17,16
8111cc40:	d8801f17 	ldw	r2,124(sp)
8111cc44:	8c3edd0e 	bge	r17,r16,8111c7bc <__reset+0xfb0fc7bc>
8111cc48:	01604534 	movhi	r5,33044
8111cc4c:	29544684 	addi	r5,r5,20762
8111cc50:	d9402b15 	stw	r5,172(sp)
8111cc54:	058001c4 	movi	r22,7
8111cc58:	dd002c17 	ldw	r20,176(sp)
8111cc5c:	00000306 	br	8111cc6c <___svfprintf_internal_r+0x1518>
8111cc60:	42000204 	addi	r8,r8,8
8111cc64:	843ffc04 	addi	r16,r16,-16
8111cc68:	8c3ed70e 	bge	r17,r16,8111c7c8 <__reset+0xfb0fc7c8>
8111cc6c:	18c00404 	addi	r3,r3,16
8111cc70:	10800044 	addi	r2,r2,1
8111cc74:	45400015 	stw	r21,0(r8)
8111cc78:	44400115 	stw	r17,4(r8)
8111cc7c:	d8c02015 	stw	r3,128(sp)
8111cc80:	d8801f15 	stw	r2,124(sp)
8111cc84:	b0bff60e 	bge	r22,r2,8111cc60 <__reset+0xfb0fcc60>
8111cc88:	d9801e04 	addi	r6,sp,120
8111cc8c:	a00b883a 	mov	r5,r20
8111cc90:	9809883a 	mov	r4,r19
8111cc94:	1128a100 	call	81128a10 <__ssprint_r>
8111cc98:	103b951e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111cc9c:	d8c02017 	ldw	r3,128(sp)
8111cca0:	d8801f17 	ldw	r2,124(sp)
8111cca4:	da000404 	addi	r8,sp,16
8111cca8:	003fee06 	br	8111cc64 <__reset+0xfb0fcc64>
8111ccac:	9088703a 	and	r4,r18,r2
8111ccb0:	203e8d1e 	bne	r4,zero,8111c6e8 <__reset+0xfb0fc6e8>
8111ccb4:	dc401f17 	ldw	r17,124(sp)
8111ccb8:	40800115 	stw	r2,4(r8)
8111ccbc:	44000015 	stw	r16,0(r8)
8111ccc0:	8c400044 	addi	r17,r17,1
8111ccc4:	d8c02015 	stw	r3,128(sp)
8111ccc8:	dc401f15 	stw	r17,124(sp)
8111cccc:	008001c4 	movi	r2,7
8111ccd0:	147f7f16 	blt	r2,r17,8111cad0 <__reset+0xfb0fcad0>
8111ccd4:	45800204 	addi	r22,r8,8
8111ccd8:	003eac06 	br	8111c78c <__reset+0xfb0fc78c>
8111ccdc:	d9402c17 	ldw	r5,176(sp)
8111cce0:	d9801e04 	addi	r6,sp,120
8111cce4:	9809883a 	mov	r4,r19
8111cce8:	1128a100 	call	81128a10 <__ssprint_r>
8111ccec:	103b801e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111ccf0:	d8c02017 	ldw	r3,128(sp)
8111ccf4:	dc401f17 	ldw	r17,124(sp)
8111ccf8:	da000404 	addi	r8,sp,16
8111ccfc:	003e8406 	br	8111c710 <__reset+0xfb0fc710>
8111cd00:	d9402c17 	ldw	r5,176(sp)
8111cd04:	d9801e04 	addi	r6,sp,120
8111cd08:	9809883a 	mov	r4,r19
8111cd0c:	1128a100 	call	81128a10 <__ssprint_r>
8111cd10:	103b771e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111cd14:	d8c02017 	ldw	r3,128(sp)
8111cd18:	dc401f17 	ldw	r17,124(sp)
8111cd1c:	dd800404 	addi	r22,sp,16
8111cd20:	003e8606 	br	8111c73c <__reset+0xfb0fc73c>
8111cd24:	0029883a 	mov	r20,zero
8111cd28:	a5000c04 	addi	r20,r20,48
8111cd2c:	dc001dc4 	addi	r16,sp,119
8111cd30:	dd001dc5 	stb	r20,119(sp)
8111cd34:	003f3806 	br	8111ca18 <__reset+0xfb0fca18>
8111cd38:	d9402c17 	ldw	r5,176(sp)
8111cd3c:	d9801e04 	addi	r6,sp,120
8111cd40:	9809883a 	mov	r4,r19
8111cd44:	1128a100 	call	81128a10 <__ssprint_r>
8111cd48:	103b691e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111cd4c:	d8c02017 	ldw	r3,128(sp)
8111cd50:	da000404 	addi	r8,sp,16
8111cd54:	003c9506 	br	8111bfac <__reset+0xfb0fbfac>
8111cd58:	d9003617 	ldw	r4,216(sp)
8111cd5c:	d9403717 	ldw	r5,220(sp)
8111cd60:	da003e15 	stw	r8,248(sp)
8111cd64:	112695c0 	call	8112695c <__fpclassifyd>
8111cd68:	da003e17 	ldw	r8,248(sp)
8111cd6c:	1000bd1e 	bne	r2,zero,8111d064 <___svfprintf_internal_r+0x1910>
8111cd70:	008011c4 	movi	r2,71
8111cd74:	14411e0e 	bge	r2,r17,8111d1f0 <___svfprintf_internal_r+0x1a9c>
8111cd78:	04204534 	movhi	r16,33044
8111cd7c:	84143904 	addi	r16,r16,20708
8111cd80:	00c000c4 	movi	r3,3
8111cd84:	00bfdfc4 	movi	r2,-129
8111cd88:	d8c02a15 	stw	r3,168(sp)
8111cd8c:	90a4703a 	and	r18,r18,r2
8111cd90:	df002783 	ldbu	fp,158(sp)
8111cd94:	d8c02e15 	stw	r3,184(sp)
8111cd98:	d8002915 	stw	zero,164(sp)
8111cd9c:	d8003215 	stw	zero,200(sp)
8111cda0:	003c1c06 	br	8111be14 <__reset+0xfb0fbe14>
8111cda4:	9080100c 	andi	r2,r18,64
8111cda8:	d8002785 	stb	zero,158(sp)
8111cdac:	10009426 	beq	r2,zero,8111d000 <___svfprintf_internal_r+0x18ac>
8111cdb0:	d8c02d17 	ldw	r3,180(sp)
8111cdb4:	d9002917 	ldw	r4,164(sp)
8111cdb8:	002d883a 	mov	r22,zero
8111cdbc:	18800104 	addi	r2,r3,4
8111cdc0:	1d00000b 	ldhu	r20,0(r3)
8111cdc4:	203ec10e 	bge	r4,zero,8111c8cc <__reset+0xfb0fc8cc>
8111cdc8:	a586b03a 	or	r3,r20,r22
8111cdcc:	d8802d15 	stw	r2,180(sp)
8111cdd0:	183ec21e 	bne	r3,zero,8111c8dc <__reset+0xfb0fc8dc>
8111cdd4:	0039883a 	mov	fp,zero
8111cdd8:	0005883a 	mov	r2,zero
8111cddc:	003db806 	br	8111c4c0 <__reset+0xfb0fc4c0>
8111cde0:	d8802d17 	ldw	r2,180(sp)
8111cde4:	d8c02d17 	ldw	r3,180(sp)
8111cde8:	d9002d17 	ldw	r4,180(sp)
8111cdec:	10800017 	ldw	r2,0(r2)
8111cdf0:	18c00117 	ldw	r3,4(r3)
8111cdf4:	21000204 	addi	r4,r4,8
8111cdf8:	d8803615 	stw	r2,216(sp)
8111cdfc:	d8c03715 	stw	r3,220(sp)
8111ce00:	d9002d15 	stw	r4,180(sp)
8111ce04:	003b8206 	br	8111bc10 <__reset+0xfb0fbc10>
8111ce08:	9080100c 	andi	r2,r18,64
8111ce0c:	10010726 	beq	r2,zero,8111d22c <___svfprintf_internal_r+0x1ad8>
8111ce10:	d8c02d17 	ldw	r3,180(sp)
8111ce14:	1d00000f 	ldh	r20,0(r3)
8111ce18:	18c00104 	addi	r3,r3,4
8111ce1c:	d8c02d15 	stw	r3,180(sp)
8111ce20:	a02dd7fa 	srai	r22,r20,31
8111ce24:	b005883a 	mov	r2,r22
8111ce28:	003ba206 	br	8111bcb4 <__reset+0xfb0fbcb4>
8111ce2c:	9080100c 	andi	r2,r18,64
8111ce30:	10010526 	beq	r2,zero,8111d248 <___svfprintf_internal_r+0x1af4>
8111ce34:	d9002d17 	ldw	r4,180(sp)
8111ce38:	002d883a 	mov	r22,zero
8111ce3c:	2500000b 	ldhu	r20,0(r4)
8111ce40:	21000104 	addi	r4,r4,4
8111ce44:	d9002d15 	stw	r4,180(sp)
8111ce48:	003cfe06 	br	8111c244 <__reset+0xfb0fc244>
8111ce4c:	bc400007 	ldb	r17,0(r23)
8111ce50:	003a9606 	br	8111b8ac <__reset+0xfb0fb8ac>
8111ce54:	9080040c 	andi	r2,r18,16
8111ce58:	10010126 	beq	r2,zero,8111d260 <___svfprintf_internal_r+0x1b0c>
8111ce5c:	d9402d17 	ldw	r5,180(sp)
8111ce60:	d8c02f17 	ldw	r3,188(sp)
8111ce64:	28800017 	ldw	r2,0(r5)
8111ce68:	29400104 	addi	r5,r5,4
8111ce6c:	d9402d15 	stw	r5,180(sp)
8111ce70:	10c00015 	stw	r3,0(r2)
8111ce74:	003a6406 	br	8111b808 <__reset+0xfb0fb808>
8111ce78:	d9002917 	ldw	r4,164(sp)
8111ce7c:	d8002785 	stb	zero,158(sp)
8111ce80:	203d8d16 	blt	r4,zero,8111c4b8 <__reset+0xfb0fc4b8>
8111ce84:	00bfdfc4 	movi	r2,-129
8111ce88:	90a4703a 	and	r18,r18,r2
8111ce8c:	003b0506 	br	8111baa4 <__reset+0xfb0fbaa4>
8111ce90:	01604534 	movhi	r5,33044
8111ce94:	29544684 	addi	r5,r5,20762
8111ce98:	d9402b15 	stw	r5,172(sp)
8111ce9c:	d9402b17 	ldw	r5,172(sp)
8111cea0:	1c47883a 	add	r3,r3,r17
8111cea4:	10800044 	addi	r2,r2,1
8111cea8:	41400015 	stw	r5,0(r8)
8111ceac:	44400115 	stw	r17,4(r8)
8111ceb0:	d8c02015 	stw	r3,128(sp)
8111ceb4:	d8801f15 	stw	r2,124(sp)
8111ceb8:	010001c4 	movi	r4,7
8111cebc:	20bf3016 	blt	r4,r2,8111cb80 <__reset+0xfb0fcb80>
8111cec0:	42000204 	addi	r8,r8,8
8111cec4:	003f3506 	br	8111cb9c <__reset+0xfb0fcb9c>
8111cec8:	01204534 	movhi	r4,33044
8111cecc:	21144684 	addi	r4,r4,20762
8111ced0:	d9002b15 	stw	r4,172(sp)
8111ced4:	003c5e06 	br	8111c050 <__reset+0xfb0fc050>
8111ced8:	d9402c17 	ldw	r5,176(sp)
8111cedc:	d9801e04 	addi	r6,sp,120
8111cee0:	9809883a 	mov	r4,r19
8111cee4:	1128a100 	call	81128a10 <__ssprint_r>
8111cee8:	103b011e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111ceec:	d8c02017 	ldw	r3,128(sp)
8111cef0:	da000404 	addi	r8,sp,16
8111cef4:	003d9306 	br	8111c544 <__reset+0xfb0fc544>
8111cef8:	d8801f17 	ldw	r2,124(sp)
8111cefc:	01604534 	movhi	r5,33044
8111cf00:	01000044 	movi	r4,1
8111cf04:	18c00044 	addi	r3,r3,1
8111cf08:	10800044 	addi	r2,r2,1
8111cf0c:	29544604 	addi	r5,r5,20760
8111cf10:	41000115 	stw	r4,4(r8)
8111cf14:	41400015 	stw	r5,0(r8)
8111cf18:	d8c02015 	stw	r3,128(sp)
8111cf1c:	d8801f15 	stw	r2,124(sp)
8111cf20:	010001c4 	movi	r4,7
8111cf24:	2080b516 	blt	r4,r2,8111d1fc <___svfprintf_internal_r+0x1aa8>
8111cf28:	42000204 	addi	r8,r8,8
8111cf2c:	8800041e 	bne	r17,zero,8111cf40 <___svfprintf_internal_r+0x17ec>
8111cf30:	d8803317 	ldw	r2,204(sp)
8111cf34:	1000021e 	bne	r2,zero,8111cf40 <___svfprintf_internal_r+0x17ec>
8111cf38:	9080004c 	andi	r2,r18,1
8111cf3c:	103c5b26 	beq	r2,zero,8111c0ac <__reset+0xfb0fc0ac>
8111cf40:	d9003817 	ldw	r4,224(sp)
8111cf44:	d8801f17 	ldw	r2,124(sp)
8111cf48:	d9403417 	ldw	r5,208(sp)
8111cf4c:	20c7883a 	add	r3,r4,r3
8111cf50:	10800044 	addi	r2,r2,1
8111cf54:	41000115 	stw	r4,4(r8)
8111cf58:	41400015 	stw	r5,0(r8)
8111cf5c:	d8c02015 	stw	r3,128(sp)
8111cf60:	d8801f15 	stw	r2,124(sp)
8111cf64:	010001c4 	movi	r4,7
8111cf68:	20818016 	blt	r4,r2,8111d56c <___svfprintf_internal_r+0x1e18>
8111cf6c:	42000204 	addi	r8,r8,8
8111cf70:	0463c83a 	sub	r17,zero,r17
8111cf74:	0440cb0e 	bge	zero,r17,8111d2a4 <___svfprintf_internal_r+0x1b50>
8111cf78:	05800404 	movi	r22,16
8111cf7c:	b440e80e 	bge	r22,r17,8111d320 <___svfprintf_internal_r+0x1bcc>
8111cf80:	01604534 	movhi	r5,33044
8111cf84:	29544684 	addi	r5,r5,20762
8111cf88:	d9402b15 	stw	r5,172(sp)
8111cf8c:	070001c4 	movi	fp,7
8111cf90:	dd002c17 	ldw	r20,176(sp)
8111cf94:	00000306 	br	8111cfa4 <___svfprintf_internal_r+0x1850>
8111cf98:	42000204 	addi	r8,r8,8
8111cf9c:	8c7ffc04 	addi	r17,r17,-16
8111cfa0:	b440e20e 	bge	r22,r17,8111d32c <___svfprintf_internal_r+0x1bd8>
8111cfa4:	18c00404 	addi	r3,r3,16
8111cfa8:	10800044 	addi	r2,r2,1
8111cfac:	45400015 	stw	r21,0(r8)
8111cfb0:	45800115 	stw	r22,4(r8)
8111cfb4:	d8c02015 	stw	r3,128(sp)
8111cfb8:	d8801f15 	stw	r2,124(sp)
8111cfbc:	e0bff60e 	bge	fp,r2,8111cf98 <__reset+0xfb0fcf98>
8111cfc0:	d9801e04 	addi	r6,sp,120
8111cfc4:	a00b883a 	mov	r5,r20
8111cfc8:	9809883a 	mov	r4,r19
8111cfcc:	1128a100 	call	81128a10 <__ssprint_r>
8111cfd0:	103ac71e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111cfd4:	d8c02017 	ldw	r3,128(sp)
8111cfd8:	d8801f17 	ldw	r2,124(sp)
8111cfdc:	da000404 	addi	r8,sp,16
8111cfe0:	003fee06 	br	8111cf9c <__reset+0xfb0fcf9c>
8111cfe4:	d8c02d17 	ldw	r3,180(sp)
8111cfe8:	d9002917 	ldw	r4,164(sp)
8111cfec:	002d883a 	mov	r22,zero
8111cff0:	18800104 	addi	r2,r3,4
8111cff4:	1d000017 	ldw	r20,0(r3)
8111cff8:	203e7d0e 	bge	r4,zero,8111c9f0 <__reset+0xfb0fc9f0>
8111cffc:	003eda06 	br	8111cb68 <__reset+0xfb0fcb68>
8111d000:	d9402d17 	ldw	r5,180(sp)
8111d004:	d8c02917 	ldw	r3,164(sp)
8111d008:	002d883a 	mov	r22,zero
8111d00c:	28800104 	addi	r2,r5,4
8111d010:	2d000017 	ldw	r20,0(r5)
8111d014:	183e2d0e 	bge	r3,zero,8111c8cc <__reset+0xfb0fc8cc>
8111d018:	003f6b06 	br	8111cdc8 <__reset+0xfb0fcdc8>
8111d01c:	d8c02d15 	stw	r3,180(sp)
8111d020:	0039883a 	mov	fp,zero
8111d024:	003ed206 	br	8111cb70 <__reset+0xfb0fcb70>
8111d028:	bc400043 	ldbu	r17,1(r23)
8111d02c:	94800814 	ori	r18,r18,32
8111d030:	bdc00044 	addi	r23,r23,1
8111d034:	8c403fcc 	andi	r17,r17,255
8111d038:	8c40201c 	xori	r17,r17,128
8111d03c:	8c7fe004 	addi	r17,r17,-128
8111d040:	003a1a06 	br	8111b8ac <__reset+0xfb0fb8ac>
8111d044:	d9402c17 	ldw	r5,176(sp)
8111d048:	d9801e04 	addi	r6,sp,120
8111d04c:	9809883a 	mov	r4,r19
8111d050:	1128a100 	call	81128a10 <__ssprint_r>
8111d054:	103aa61e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111d058:	d8c02017 	ldw	r3,128(sp)
8111d05c:	da000404 	addi	r8,sp,16
8111d060:	003d4a06 	br	8111c58c <__reset+0xfb0fc58c>
8111d064:	d9002917 	ldw	r4,164(sp)
8111d068:	05bff7c4 	movi	r22,-33
8111d06c:	00bfffc4 	movi	r2,-1
8111d070:	8dac703a 	and	r22,r17,r22
8111d074:	20806a26 	beq	r4,r2,8111d220 <___svfprintf_internal_r+0x1acc>
8111d078:	008011c4 	movi	r2,71
8111d07c:	b0813726 	beq	r22,r2,8111d55c <___svfprintf_internal_r+0x1e08>
8111d080:	d9003717 	ldw	r4,220(sp)
8111d084:	90c04014 	ori	r3,r18,256
8111d088:	d8c02b15 	stw	r3,172(sp)
8111d08c:	20015d16 	blt	r4,zero,8111d604 <___svfprintf_internal_r+0x1eb0>
8111d090:	dd003717 	ldw	r20,220(sp)
8111d094:	d8002a05 	stb	zero,168(sp)
8111d098:	00801984 	movi	r2,102
8111d09c:	88814026 	beq	r17,r2,8111d5a0 <___svfprintf_internal_r+0x1e4c>
8111d0a0:	00801184 	movi	r2,70
8111d0a4:	88817126 	beq	r17,r2,8111d66c <___svfprintf_internal_r+0x1f18>
8111d0a8:	00801144 	movi	r2,69
8111d0ac:	b0816226 	beq	r22,r2,8111d638 <___svfprintf_internal_r+0x1ee4>
8111d0b0:	d8c02917 	ldw	r3,164(sp)
8111d0b4:	d8802104 	addi	r2,sp,132
8111d0b8:	d8800315 	stw	r2,12(sp)
8111d0bc:	d9403617 	ldw	r5,216(sp)
8111d0c0:	d8802504 	addi	r2,sp,148
8111d0c4:	d8800215 	stw	r2,8(sp)
8111d0c8:	d8802604 	addi	r2,sp,152
8111d0cc:	d8c00015 	stw	r3,0(sp)
8111d0d0:	d8800115 	stw	r2,4(sp)
8111d0d4:	01c00084 	movi	r7,2
8111d0d8:	a00d883a 	mov	r6,r20
8111d0dc:	9809883a 	mov	r4,r19
8111d0e0:	d8c03d15 	stw	r3,244(sp)
8111d0e4:	da003e15 	stw	r8,248(sp)
8111d0e8:	112181c0 	call	8112181c <_dtoa_r>
8111d0ec:	1021883a 	mov	r16,r2
8111d0f0:	008019c4 	movi	r2,103
8111d0f4:	d8c03d17 	ldw	r3,244(sp)
8111d0f8:	da003e17 	ldw	r8,248(sp)
8111d0fc:	8880e726 	beq	r17,r2,8111d49c <___svfprintf_internal_r+0x1d48>
8111d100:	008011c4 	movi	r2,71
8111d104:	8880d426 	beq	r17,r2,8111d458 <___svfprintf_internal_r+0x1d04>
8111d108:	80f9883a 	add	fp,r16,r3
8111d10c:	d9003617 	ldw	r4,216(sp)
8111d110:	000d883a 	mov	r6,zero
8111d114:	000f883a 	mov	r7,zero
8111d118:	a00b883a 	mov	r5,r20
8111d11c:	da003e15 	stw	r8,248(sp)
8111d120:	112ed400 	call	8112ed40 <__eqdf2>
8111d124:	da003e17 	ldw	r8,248(sp)
8111d128:	1000e426 	beq	r2,zero,8111d4bc <___svfprintf_internal_r+0x1d68>
8111d12c:	d8802117 	ldw	r2,132(sp)
8111d130:	1700062e 	bgeu	r2,fp,8111d14c <___svfprintf_internal_r+0x19f8>
8111d134:	01000c04 	movi	r4,48
8111d138:	10c00044 	addi	r3,r2,1
8111d13c:	d8c02115 	stw	r3,132(sp)
8111d140:	11000005 	stb	r4,0(r2)
8111d144:	d8802117 	ldw	r2,132(sp)
8111d148:	173ffb36 	bltu	r2,fp,8111d138 <__reset+0xfb0fd138>
8111d14c:	1405c83a 	sub	r2,r2,r16
8111d150:	d8803315 	stw	r2,204(sp)
8111d154:	008011c4 	movi	r2,71
8111d158:	b080c526 	beq	r22,r2,8111d470 <___svfprintf_internal_r+0x1d1c>
8111d15c:	00801944 	movi	r2,101
8111d160:	1441d90e 	bge	r2,r17,8111d8c8 <___svfprintf_internal_r+0x2174>
8111d164:	d8c02617 	ldw	r3,152(sp)
8111d168:	00801984 	movi	r2,102
8111d16c:	d8c03215 	stw	r3,200(sp)
8111d170:	88813426 	beq	r17,r2,8111d644 <___svfprintf_internal_r+0x1ef0>
8111d174:	d8c03217 	ldw	r3,200(sp)
8111d178:	d9003317 	ldw	r4,204(sp)
8111d17c:	19012516 	blt	r3,r4,8111d614 <___svfprintf_internal_r+0x1ec0>
8111d180:	9480004c 	andi	r18,r18,1
8111d184:	9001841e 	bne	r18,zero,8111d798 <___svfprintf_internal_r+0x2044>
8111d188:	1805883a 	mov	r2,r3
8111d18c:	1801cc16 	blt	r3,zero,8111d8c0 <___svfprintf_internal_r+0x216c>
8111d190:	d8c03217 	ldw	r3,200(sp)
8111d194:	044019c4 	movi	r17,103
8111d198:	d8c02e15 	stw	r3,184(sp)
8111d19c:	df002a07 	ldb	fp,168(sp)
8111d1a0:	e000a61e 	bne	fp,zero,8111d43c <___svfprintf_internal_r+0x1ce8>
8111d1a4:	df002783 	ldbu	fp,158(sp)
8111d1a8:	d8802a15 	stw	r2,168(sp)
8111d1ac:	dc802b17 	ldw	r18,172(sp)
8111d1b0:	d8002915 	stw	zero,164(sp)
8111d1b4:	003b1706 	br	8111be14 <__reset+0xfb0fbe14>
8111d1b8:	04204534 	movhi	r16,33044
8111d1bc:	84143604 	addi	r16,r16,20696
8111d1c0:	003aa606 	br	8111bc5c <__reset+0xfb0fbc5c>
8111d1c4:	d9003917 	ldw	r4,228(sp)
8111d1c8:	04001004 	movi	r16,64
8111d1cc:	800b883a 	mov	r5,r16
8111d1d0:	11245040 	call	81124504 <_malloc_r>
8111d1d4:	d9002c17 	ldw	r4,176(sp)
8111d1d8:	20800015 	stw	r2,0(r4)
8111d1dc:	20800415 	stw	r2,16(r4)
8111d1e0:	1001cb26 	beq	r2,zero,8111d910 <___svfprintf_internal_r+0x21bc>
8111d1e4:	d8802c17 	ldw	r2,176(sp)
8111d1e8:	14000515 	stw	r16,20(r2)
8111d1ec:	00397606 	br	8111b7c8 <__reset+0xfb0fb7c8>
8111d1f0:	04204534 	movhi	r16,33044
8111d1f4:	84143804 	addi	r16,r16,20704
8111d1f8:	003ee106 	br	8111cd80 <__reset+0xfb0fcd80>
8111d1fc:	d9402c17 	ldw	r5,176(sp)
8111d200:	d9801e04 	addi	r6,sp,120
8111d204:	9809883a 	mov	r4,r19
8111d208:	1128a100 	call	81128a10 <__ssprint_r>
8111d20c:	103a381e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111d210:	dc402617 	ldw	r17,152(sp)
8111d214:	d8c02017 	ldw	r3,128(sp)
8111d218:	da000404 	addi	r8,sp,16
8111d21c:	003f4306 	br	8111cf2c <__reset+0xfb0fcf2c>
8111d220:	01400184 	movi	r5,6
8111d224:	d9402915 	stw	r5,164(sp)
8111d228:	003f9506 	br	8111d080 <__reset+0xfb0fd080>
8111d22c:	d9002d17 	ldw	r4,180(sp)
8111d230:	25000017 	ldw	r20,0(r4)
8111d234:	21000104 	addi	r4,r4,4
8111d238:	d9002d15 	stw	r4,180(sp)
8111d23c:	a02dd7fa 	srai	r22,r20,31
8111d240:	b005883a 	mov	r2,r22
8111d244:	003a9b06 	br	8111bcb4 <__reset+0xfb0fbcb4>
8111d248:	d9402d17 	ldw	r5,180(sp)
8111d24c:	002d883a 	mov	r22,zero
8111d250:	2d000017 	ldw	r20,0(r5)
8111d254:	29400104 	addi	r5,r5,4
8111d258:	d9402d15 	stw	r5,180(sp)
8111d25c:	003bf906 	br	8111c244 <__reset+0xfb0fc244>
8111d260:	9480100c 	andi	r18,r18,64
8111d264:	90006e26 	beq	r18,zero,8111d420 <___svfprintf_internal_r+0x1ccc>
8111d268:	d9002d17 	ldw	r4,180(sp)
8111d26c:	d9402f17 	ldw	r5,188(sp)
8111d270:	20800017 	ldw	r2,0(r4)
8111d274:	21000104 	addi	r4,r4,4
8111d278:	d9002d15 	stw	r4,180(sp)
8111d27c:	1140000d 	sth	r5,0(r2)
8111d280:	00396106 	br	8111b808 <__reset+0xfb0fb808>
8111d284:	d9402c17 	ldw	r5,176(sp)
8111d288:	d9801e04 	addi	r6,sp,120
8111d28c:	9809883a 	mov	r4,r19
8111d290:	1128a100 	call	81128a10 <__ssprint_r>
8111d294:	103a161e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111d298:	d8c02017 	ldw	r3,128(sp)
8111d29c:	d8801f17 	ldw	r2,124(sp)
8111d2a0:	da000404 	addi	r8,sp,16
8111d2a4:	d9403317 	ldw	r5,204(sp)
8111d2a8:	10800044 	addi	r2,r2,1
8111d2ac:	44000015 	stw	r16,0(r8)
8111d2b0:	28c7883a 	add	r3,r5,r3
8111d2b4:	003b7706 	br	8111c094 <__reset+0xfb0fc094>
8111d2b8:	8009883a 	mov	r4,r16
8111d2bc:	da003e15 	stw	r8,248(sp)
8111d2c0:	111b1180 	call	8111b118 <strlen>
8111d2c4:	d8802e15 	stw	r2,184(sp)
8111d2c8:	da003e17 	ldw	r8,248(sp)
8111d2cc:	103c280e 	bge	r2,zero,8111c370 <__reset+0xfb0fc370>
8111d2d0:	0005883a 	mov	r2,zero
8111d2d4:	003c2606 	br	8111c370 <__reset+0xfb0fc370>
8111d2d8:	00bfffc4 	movi	r2,-1
8111d2dc:	003a0906 	br	8111bb04 <__reset+0xfb0fbb04>
8111d2e0:	01204534 	movhi	r4,33044
8111d2e4:	21144a84 	addi	r4,r4,20778
8111d2e8:	d9003515 	stw	r4,212(sp)
8111d2ec:	003b0606 	br	8111bf08 <__reset+0xfb0fbf08>
8111d2f0:	013fffc4 	movi	r4,-1
8111d2f4:	003a2706 	br	8111bb94 <__reset+0xfb0fbb94>
8111d2f8:	d9402c17 	ldw	r5,176(sp)
8111d2fc:	d9801e04 	addi	r6,sp,120
8111d300:	9809883a 	mov	r4,r19
8111d304:	1128a100 	call	81128a10 <__ssprint_r>
8111d308:	1039f91e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111d30c:	d8c02017 	ldw	r3,128(sp)
8111d310:	da000404 	addi	r8,sp,16
8111d314:	003d8406 	br	8111c928 <__reset+0xfb0fc928>
8111d318:	0023883a 	mov	r17,zero
8111d31c:	003d8306 	br	8111c92c <__reset+0xfb0fc92c>
8111d320:	01204534 	movhi	r4,33044
8111d324:	21144684 	addi	r4,r4,20762
8111d328:	d9002b15 	stw	r4,172(sp)
8111d32c:	d9002b17 	ldw	r4,172(sp)
8111d330:	1c47883a 	add	r3,r3,r17
8111d334:	10800044 	addi	r2,r2,1
8111d338:	41000015 	stw	r4,0(r8)
8111d33c:	44400115 	stw	r17,4(r8)
8111d340:	d8c02015 	stw	r3,128(sp)
8111d344:	d8801f15 	stw	r2,124(sp)
8111d348:	010001c4 	movi	r4,7
8111d34c:	20bfcd16 	blt	r4,r2,8111d284 <__reset+0xfb0fd284>
8111d350:	42000204 	addi	r8,r8,8
8111d354:	003fd306 	br	8111d2a4 <__reset+0xfb0fd2a4>
8111d358:	d9402c17 	ldw	r5,176(sp)
8111d35c:	d9801e04 	addi	r6,sp,120
8111d360:	9809883a 	mov	r4,r19
8111d364:	1128a100 	call	81128a10 <__ssprint_r>
8111d368:	1039e11e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111d36c:	d8802617 	ldw	r2,152(sp)
8111d370:	d8c02017 	ldw	r3,128(sp)
8111d374:	da000404 	addi	r8,sp,16
8111d378:	003e1c06 	br	8111cbec <__reset+0xfb0fcbec>
8111d37c:	d8802917 	ldw	r2,164(sp)
8111d380:	00c00184 	movi	r3,6
8111d384:	1880012e 	bgeu	r3,r2,8111d38c <___svfprintf_internal_r+0x1c38>
8111d388:	1805883a 	mov	r2,r3
8111d38c:	d8802e15 	stw	r2,184(sp)
8111d390:	1000f316 	blt	r2,zero,8111d760 <___svfprintf_internal_r+0x200c>
8111d394:	04204534 	movhi	r16,33044
8111d398:	d8802a15 	stw	r2,168(sp)
8111d39c:	dd002d15 	stw	r20,180(sp)
8111d3a0:	d8002915 	stw	zero,164(sp)
8111d3a4:	d8003215 	stw	zero,200(sp)
8111d3a8:	84144404 	addi	r16,r16,20752
8111d3ac:	0039883a 	mov	fp,zero
8111d3b0:	003a9f06 	br	8111be30 <__reset+0xfb0fbe30>
8111d3b4:	01204534 	movhi	r4,33044
8111d3b8:	21144a84 	addi	r4,r4,20778
8111d3bc:	d9003515 	stw	r4,212(sp)
8111d3c0:	003b5f06 	br	8111c140 <__reset+0xfb0fc140>
8111d3c4:	d9402c17 	ldw	r5,176(sp)
8111d3c8:	d9801e04 	addi	r6,sp,120
8111d3cc:	9809883a 	mov	r4,r19
8111d3d0:	1128a100 	call	81128a10 <__ssprint_r>
8111d3d4:	1039c61e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111d3d8:	d8802617 	ldw	r2,152(sp)
8111d3dc:	d9403317 	ldw	r5,204(sp)
8111d3e0:	d8c02017 	ldw	r3,128(sp)
8111d3e4:	da000404 	addi	r8,sp,16
8111d3e8:	2885c83a 	sub	r2,r5,r2
8111d3ec:	003e1006 	br	8111cc30 <__reset+0xfb0fcc30>
8111d3f0:	00800044 	movi	r2,1
8111d3f4:	10803fcc 	andi	r2,r2,255
8111d3f8:	00c00044 	movi	r3,1
8111d3fc:	10fa3526 	beq	r2,r3,8111bcd4 <__reset+0xfb0fbcd4>
8111d400:	00c00084 	movi	r3,2
8111d404:	10fb9e26 	beq	r2,r3,8111c280 <__reset+0xfb0fc280>
8111d408:	003a6406 	br	8111bd9c <__reset+0xfb0fbd9c>
8111d40c:	0021883a 	mov	r16,zero
8111d410:	003e0806 	br	8111cc34 <__reset+0xfb0fcc34>
8111d414:	07000b44 	movi	fp,45
8111d418:	df002785 	stb	fp,158(sp)
8111d41c:	003a0b06 	br	8111bc4c <__reset+0xfb0fbc4c>
8111d420:	d8c02d17 	ldw	r3,180(sp)
8111d424:	d9002f17 	ldw	r4,188(sp)
8111d428:	18800017 	ldw	r2,0(r3)
8111d42c:	18c00104 	addi	r3,r3,4
8111d430:	d8c02d15 	stw	r3,180(sp)
8111d434:	11000015 	stw	r4,0(r2)
8111d438:	0038f306 	br	8111b808 <__reset+0xfb0fb808>
8111d43c:	00c00b44 	movi	r3,45
8111d440:	d8c02785 	stb	r3,158(sp)
8111d444:	d8802a15 	stw	r2,168(sp)
8111d448:	dc802b17 	ldw	r18,172(sp)
8111d44c:	d8002915 	stw	zero,164(sp)
8111d450:	07000b44 	movi	fp,45
8111d454:	003a7306 	br	8111be24 <__reset+0xfb0fbe24>
8111d458:	9080004c 	andi	r2,r18,1
8111d45c:	1000941e 	bne	r2,zero,8111d6b0 <___svfprintf_internal_r+0x1f5c>
8111d460:	d8802117 	ldw	r2,132(sp)
8111d464:	1405c83a 	sub	r2,r2,r16
8111d468:	d8803315 	stw	r2,204(sp)
8111d46c:	b441161e 	bne	r22,r17,8111d8c8 <___svfprintf_internal_r+0x2174>
8111d470:	dd802617 	ldw	r22,152(sp)
8111d474:	00bfff44 	movi	r2,-3
8111d478:	b0801a16 	blt	r22,r2,8111d4e4 <___svfprintf_internal_r+0x1d90>
8111d47c:	d9402917 	ldw	r5,164(sp)
8111d480:	2d801816 	blt	r5,r22,8111d4e4 <___svfprintf_internal_r+0x1d90>
8111d484:	dd803215 	stw	r22,200(sp)
8111d488:	003f3a06 	br	8111d174 <__reset+0xfb0fd174>
8111d48c:	1025883a 	mov	r18,r2
8111d490:	0039883a 	mov	fp,zero
8111d494:	00800084 	movi	r2,2
8111d498:	003fd606 	br	8111d3f4 <__reset+0xfb0fd3f4>
8111d49c:	9080004c 	andi	r2,r18,1
8111d4a0:	103f191e 	bne	r2,zero,8111d108 <__reset+0xfb0fd108>
8111d4a4:	d8802117 	ldw	r2,132(sp)
8111d4a8:	003f2806 	br	8111d14c <__reset+0xfb0fd14c>
8111d4ac:	01204534 	movhi	r4,33044
8111d4b0:	21144684 	addi	r4,r4,20762
8111d4b4:	d9002b15 	stw	r4,172(sp)
8111d4b8:	003c7c06 	br	8111c6ac <__reset+0xfb0fc6ac>
8111d4bc:	e005883a 	mov	r2,fp
8111d4c0:	003f2206 	br	8111d14c <__reset+0xfb0fd14c>
8111d4c4:	d9402917 	ldw	r5,164(sp)
8111d4c8:	df002783 	ldbu	fp,158(sp)
8111d4cc:	dd002d15 	stw	r20,180(sp)
8111d4d0:	d9402a15 	stw	r5,168(sp)
8111d4d4:	d9402e15 	stw	r5,184(sp)
8111d4d8:	d8002915 	stw	zero,164(sp)
8111d4dc:	d8003215 	stw	zero,200(sp)
8111d4e0:	003a4c06 	br	8111be14 <__reset+0xfb0fbe14>
8111d4e4:	8c7fff84 	addi	r17,r17,-2
8111d4e8:	b5bfffc4 	addi	r22,r22,-1
8111d4ec:	dd802615 	stw	r22,152(sp)
8111d4f0:	dc4022c5 	stb	r17,139(sp)
8111d4f4:	b000c316 	blt	r22,zero,8111d804 <___svfprintf_internal_r+0x20b0>
8111d4f8:	00800ac4 	movi	r2,43
8111d4fc:	d8802305 	stb	r2,140(sp)
8111d500:	00800244 	movi	r2,9
8111d504:	15806e16 	blt	r2,r22,8111d6c0 <___svfprintf_internal_r+0x1f6c>
8111d508:	00800c04 	movi	r2,48
8111d50c:	b5800c04 	addi	r22,r22,48
8111d510:	d8802345 	stb	r2,141(sp)
8111d514:	dd802385 	stb	r22,142(sp)
8111d518:	d88023c4 	addi	r2,sp,143
8111d51c:	df0022c4 	addi	fp,sp,139
8111d520:	d8c03317 	ldw	r3,204(sp)
8111d524:	1739c83a 	sub	fp,r2,fp
8111d528:	d9003317 	ldw	r4,204(sp)
8111d52c:	e0c7883a 	add	r3,fp,r3
8111d530:	df003b15 	stw	fp,236(sp)
8111d534:	d8c02e15 	stw	r3,184(sp)
8111d538:	00800044 	movi	r2,1
8111d53c:	1100b70e 	bge	r2,r4,8111d81c <___svfprintf_internal_r+0x20c8>
8111d540:	d8c02e17 	ldw	r3,184(sp)
8111d544:	18c00044 	addi	r3,r3,1
8111d548:	d8c02e15 	stw	r3,184(sp)
8111d54c:	1805883a 	mov	r2,r3
8111d550:	1800b016 	blt	r3,zero,8111d814 <___svfprintf_internal_r+0x20c0>
8111d554:	d8003215 	stw	zero,200(sp)
8111d558:	003f1006 	br	8111d19c <__reset+0xfb0fd19c>
8111d55c:	d8802917 	ldw	r2,164(sp)
8111d560:	103ec71e 	bne	r2,zero,8111d080 <__reset+0xfb0fd080>
8111d564:	dc002915 	stw	r16,164(sp)
8111d568:	003ec506 	br	8111d080 <__reset+0xfb0fd080>
8111d56c:	d9402c17 	ldw	r5,176(sp)
8111d570:	d9801e04 	addi	r6,sp,120
8111d574:	9809883a 	mov	r4,r19
8111d578:	1128a100 	call	81128a10 <__ssprint_r>
8111d57c:	10395c1e 	bne	r2,zero,8111baf0 <__reset+0xfb0fbaf0>
8111d580:	dc402617 	ldw	r17,152(sp)
8111d584:	d8c02017 	ldw	r3,128(sp)
8111d588:	d8801f17 	ldw	r2,124(sp)
8111d58c:	da000404 	addi	r8,sp,16
8111d590:	003e7706 	br	8111cf70 <__reset+0xfb0fcf70>
8111d594:	582f883a 	mov	r23,r11
8111d598:	d8002915 	stw	zero,164(sp)
8111d59c:	0038c406 	br	8111b8b0 <__reset+0xfb0fb8b0>
8111d5a0:	d8c02917 	ldw	r3,164(sp)
8111d5a4:	d8802104 	addi	r2,sp,132
8111d5a8:	d8800315 	stw	r2,12(sp)
8111d5ac:	d9403617 	ldw	r5,216(sp)
8111d5b0:	d8802504 	addi	r2,sp,148
8111d5b4:	d8800215 	stw	r2,8(sp)
8111d5b8:	d8802604 	addi	r2,sp,152
8111d5bc:	d8c00015 	stw	r3,0(sp)
8111d5c0:	9809883a 	mov	r4,r19
8111d5c4:	d8800115 	stw	r2,4(sp)
8111d5c8:	01c000c4 	movi	r7,3
8111d5cc:	a00d883a 	mov	r6,r20
8111d5d0:	da003e15 	stw	r8,248(sp)
8111d5d4:	112181c0 	call	8112181c <_dtoa_r>
8111d5d8:	d9002917 	ldw	r4,164(sp)
8111d5dc:	da003e17 	ldw	r8,248(sp)
8111d5e0:	1021883a 	mov	r16,r2
8111d5e4:	1139883a 	add	fp,r2,r4
8111d5e8:	2007883a 	mov	r3,r4
8111d5ec:	81000007 	ldb	r4,0(r16)
8111d5f0:	00800c04 	movi	r2,48
8111d5f4:	20806f26 	beq	r4,r2,8111d7b4 <___svfprintf_internal_r+0x2060>
8111d5f8:	d8c02617 	ldw	r3,152(sp)
8111d5fc:	e0f9883a 	add	fp,fp,r3
8111d600:	003ec206 	br	8111d10c <__reset+0xfb0fd10c>
8111d604:	00c00b44 	movi	r3,45
8111d608:	2520003c 	xorhi	r20,r4,32768
8111d60c:	d8c02a05 	stb	r3,168(sp)
8111d610:	003ea106 	br	8111d098 <__reset+0xfb0fd098>
8111d614:	d8c03217 	ldw	r3,200(sp)
8111d618:	00c0890e 	bge	zero,r3,8111d840 <___svfprintf_internal_r+0x20ec>
8111d61c:	00800044 	movi	r2,1
8111d620:	d9003317 	ldw	r4,204(sp)
8111d624:	1105883a 	add	r2,r2,r4
8111d628:	d8802e15 	stw	r2,184(sp)
8111d62c:	10005f16 	blt	r2,zero,8111d7ac <___svfprintf_internal_r+0x2058>
8111d630:	044019c4 	movi	r17,103
8111d634:	003ed906 	br	8111d19c <__reset+0xfb0fd19c>
8111d638:	d9002917 	ldw	r4,164(sp)
8111d63c:	20c00044 	addi	r3,r4,1
8111d640:	003e9c06 	br	8111d0b4 <__reset+0xfb0fd0b4>
8111d644:	d9002917 	ldw	r4,164(sp)
8111d648:	00c0680e 	bge	zero,r3,8111d7ec <___svfprintf_internal_r+0x2098>
8111d64c:	2000461e 	bne	r4,zero,8111d768 <___svfprintf_internal_r+0x2014>
8111d650:	9480004c 	andi	r18,r18,1
8111d654:	9000441e 	bne	r18,zero,8111d768 <___svfprintf_internal_r+0x2014>
8111d658:	1805883a 	mov	r2,r3
8111d65c:	1800a016 	blt	r3,zero,8111d8e0 <___svfprintf_internal_r+0x218c>
8111d660:	d8c03217 	ldw	r3,200(sp)
8111d664:	d8c02e15 	stw	r3,184(sp)
8111d668:	003ecc06 	br	8111d19c <__reset+0xfb0fd19c>
8111d66c:	d9402917 	ldw	r5,164(sp)
8111d670:	d8802104 	addi	r2,sp,132
8111d674:	d8800315 	stw	r2,12(sp)
8111d678:	d9400015 	stw	r5,0(sp)
8111d67c:	d8802504 	addi	r2,sp,148
8111d680:	d9403617 	ldw	r5,216(sp)
8111d684:	d8800215 	stw	r2,8(sp)
8111d688:	d8802604 	addi	r2,sp,152
8111d68c:	d8800115 	stw	r2,4(sp)
8111d690:	01c000c4 	movi	r7,3
8111d694:	a00d883a 	mov	r6,r20
8111d698:	9809883a 	mov	r4,r19
8111d69c:	da003e15 	stw	r8,248(sp)
8111d6a0:	112181c0 	call	8112181c <_dtoa_r>
8111d6a4:	d8c02917 	ldw	r3,164(sp)
8111d6a8:	da003e17 	ldw	r8,248(sp)
8111d6ac:	1021883a 	mov	r16,r2
8111d6b0:	00801184 	movi	r2,70
8111d6b4:	80f9883a 	add	fp,r16,r3
8111d6b8:	88bfcc26 	beq	r17,r2,8111d5ec <__reset+0xfb0fd5ec>
8111d6bc:	003e9306 	br	8111d10c <__reset+0xfb0fd10c>
8111d6c0:	df0022c4 	addi	fp,sp,139
8111d6c4:	dc002915 	stw	r16,164(sp)
8111d6c8:	9829883a 	mov	r20,r19
8111d6cc:	e021883a 	mov	r16,fp
8111d6d0:	4027883a 	mov	r19,r8
8111d6d4:	b009883a 	mov	r4,r22
8111d6d8:	01400284 	movi	r5,10
8111d6dc:	112d8700 	call	8112d870 <__modsi3>
8111d6e0:	10800c04 	addi	r2,r2,48
8111d6e4:	843fffc4 	addi	r16,r16,-1
8111d6e8:	b009883a 	mov	r4,r22
8111d6ec:	01400284 	movi	r5,10
8111d6f0:	80800005 	stb	r2,0(r16)
8111d6f4:	112d7ec0 	call	8112d7ec <__divsi3>
8111d6f8:	102d883a 	mov	r22,r2
8111d6fc:	00800244 	movi	r2,9
8111d700:	15bff416 	blt	r2,r22,8111d6d4 <__reset+0xfb0fd6d4>
8111d704:	9811883a 	mov	r8,r19
8111d708:	b0800c04 	addi	r2,r22,48
8111d70c:	a027883a 	mov	r19,r20
8111d710:	8029883a 	mov	r20,r16
8111d714:	a17fffc4 	addi	r5,r20,-1
8111d718:	a0bfffc5 	stb	r2,-1(r20)
8111d71c:	dc002917 	ldw	r16,164(sp)
8111d720:	2f00752e 	bgeu	r5,fp,8111d8f8 <___svfprintf_internal_r+0x21a4>
8111d724:	d9c02384 	addi	r7,sp,142
8111d728:	3d0fc83a 	sub	r7,r7,r20
8111d72c:	d9002344 	addi	r4,sp,141
8111d730:	e1cf883a 	add	r7,fp,r7
8111d734:	00000106 	br	8111d73c <___svfprintf_internal_r+0x1fe8>
8111d738:	28800003 	ldbu	r2,0(r5)
8111d73c:	20800005 	stb	r2,0(r4)
8111d740:	21000044 	addi	r4,r4,1
8111d744:	29400044 	addi	r5,r5,1
8111d748:	21fffb1e 	bne	r4,r7,8111d738 <__reset+0xfb0fd738>
8111d74c:	d8802304 	addi	r2,sp,140
8111d750:	1505c83a 	sub	r2,r2,r20
8111d754:	d8c02344 	addi	r3,sp,141
8111d758:	1885883a 	add	r2,r3,r2
8111d75c:	003f7006 	br	8111d520 <__reset+0xfb0fd520>
8111d760:	0005883a 	mov	r2,zero
8111d764:	003f0b06 	br	8111d394 <__reset+0xfb0fd394>
8111d768:	d9002917 	ldw	r4,164(sp)
8111d76c:	d8c03217 	ldw	r3,200(sp)
8111d770:	20800044 	addi	r2,r4,1
8111d774:	1885883a 	add	r2,r3,r2
8111d778:	d8802e15 	stw	r2,184(sp)
8111d77c:	103e870e 	bge	r2,zero,8111d19c <__reset+0xfb0fd19c>
8111d780:	0005883a 	mov	r2,zero
8111d784:	003e8506 	br	8111d19c <__reset+0xfb0fd19c>
8111d788:	01204534 	movhi	r4,33044
8111d78c:	21144684 	addi	r4,r4,20762
8111d790:	d9002b15 	stw	r4,172(sp)
8111d794:	003cc506 	br	8111caac <__reset+0xfb0fcaac>
8111d798:	d8c03217 	ldw	r3,200(sp)
8111d79c:	18c00044 	addi	r3,r3,1
8111d7a0:	d8c02e15 	stw	r3,184(sp)
8111d7a4:	1805883a 	mov	r2,r3
8111d7a8:	183fa10e 	bge	r3,zero,8111d630 <__reset+0xfb0fd630>
8111d7ac:	0005883a 	mov	r2,zero
8111d7b0:	003f9f06 	br	8111d630 <__reset+0xfb0fd630>
8111d7b4:	d9003617 	ldw	r4,216(sp)
8111d7b8:	000d883a 	mov	r6,zero
8111d7bc:	000f883a 	mov	r7,zero
8111d7c0:	a00b883a 	mov	r5,r20
8111d7c4:	d8c03d15 	stw	r3,244(sp)
8111d7c8:	da003e15 	stw	r8,248(sp)
8111d7cc:	112ed400 	call	8112ed40 <__eqdf2>
8111d7d0:	d8c03d17 	ldw	r3,244(sp)
8111d7d4:	da003e17 	ldw	r8,248(sp)
8111d7d8:	103f8726 	beq	r2,zero,8111d5f8 <__reset+0xfb0fd5f8>
8111d7dc:	00800044 	movi	r2,1
8111d7e0:	10c7c83a 	sub	r3,r2,r3
8111d7e4:	d8c02615 	stw	r3,152(sp)
8111d7e8:	003f8406 	br	8111d5fc <__reset+0xfb0fd5fc>
8111d7ec:	20000e1e 	bne	r4,zero,8111d828 <___svfprintf_internal_r+0x20d4>
8111d7f0:	9480004c 	andi	r18,r18,1
8111d7f4:	90000c1e 	bne	r18,zero,8111d828 <___svfprintf_internal_r+0x20d4>
8111d7f8:	00800044 	movi	r2,1
8111d7fc:	d8802e15 	stw	r2,184(sp)
8111d800:	003e6606 	br	8111d19c <__reset+0xfb0fd19c>
8111d804:	00800b44 	movi	r2,45
8111d808:	05adc83a 	sub	r22,zero,r22
8111d80c:	d8802305 	stb	r2,140(sp)
8111d810:	003f3b06 	br	8111d500 <__reset+0xfb0fd500>
8111d814:	0005883a 	mov	r2,zero
8111d818:	003f4e06 	br	8111d554 <__reset+0xfb0fd554>
8111d81c:	90a4703a 	and	r18,r18,r2
8111d820:	903f4a26 	beq	r18,zero,8111d54c <__reset+0xfb0fd54c>
8111d824:	003f4606 	br	8111d540 <__reset+0xfb0fd540>
8111d828:	d8c02917 	ldw	r3,164(sp)
8111d82c:	18c00084 	addi	r3,r3,2
8111d830:	d8c02e15 	stw	r3,184(sp)
8111d834:	1805883a 	mov	r2,r3
8111d838:	183e580e 	bge	r3,zero,8111d19c <__reset+0xfb0fd19c>
8111d83c:	003fd006 	br	8111d780 <__reset+0xfb0fd780>
8111d840:	00800084 	movi	r2,2
8111d844:	10c5c83a 	sub	r2,r2,r3
8111d848:	003f7506 	br	8111d620 <__reset+0xfb0fd620>
8111d84c:	d8802d17 	ldw	r2,180(sp)
8111d850:	d9002d17 	ldw	r4,180(sp)
8111d854:	bc400043 	ldbu	r17,1(r23)
8111d858:	10800017 	ldw	r2,0(r2)
8111d85c:	582f883a 	mov	r23,r11
8111d860:	d8802915 	stw	r2,164(sp)
8111d864:	20800104 	addi	r2,r4,4
8111d868:	d9002917 	ldw	r4,164(sp)
8111d86c:	d8802d15 	stw	r2,180(sp)
8111d870:	203df00e 	bge	r4,zero,8111d034 <__reset+0xfb0fd034>
8111d874:	8c403fcc 	andi	r17,r17,255
8111d878:	00bfffc4 	movi	r2,-1
8111d87c:	8c40201c 	xori	r17,r17,128
8111d880:	d8802915 	stw	r2,164(sp)
8111d884:	8c7fe004 	addi	r17,r17,-128
8111d888:	00380806 	br	8111b8ac <__reset+0xfb0fb8ac>
8111d88c:	9080004c 	andi	r2,r18,1
8111d890:	0039883a 	mov	fp,zero
8111d894:	10000726 	beq	r2,zero,8111d8b4 <___svfprintf_internal_r+0x2160>
8111d898:	d8c02817 	ldw	r3,160(sp)
8111d89c:	dc001dc4 	addi	r16,sp,119
8111d8a0:	00800c04 	movi	r2,48
8111d8a4:	1c07c83a 	sub	r3,r3,r16
8111d8a8:	d8801dc5 	stb	r2,119(sp)
8111d8ac:	d8c02e15 	stw	r3,184(sp)
8111d8b0:	00395206 	br	8111bdfc <__reset+0xfb0fbdfc>
8111d8b4:	d8002e15 	stw	zero,184(sp)
8111d8b8:	dc001e04 	addi	r16,sp,120
8111d8bc:	00394f06 	br	8111bdfc <__reset+0xfb0fbdfc>
8111d8c0:	0005883a 	mov	r2,zero
8111d8c4:	003e3206 	br	8111d190 <__reset+0xfb0fd190>
8111d8c8:	dd802617 	ldw	r22,152(sp)
8111d8cc:	003f0606 	br	8111d4e8 <__reset+0xfb0fd4e8>
8111d8d0:	d9c02785 	stb	r7,158(sp)
8111d8d4:	003a5106 	br	8111c21c <__reset+0xfb0fc21c>
8111d8d8:	d9c02785 	stb	r7,158(sp)
8111d8dc:	003a3706 	br	8111c1bc <__reset+0xfb0fc1bc>
8111d8e0:	0005883a 	mov	r2,zero
8111d8e4:	003f5e06 	br	8111d660 <__reset+0xfb0fd660>
8111d8e8:	d9c02785 	stb	r7,158(sp)
8111d8ec:	00391706 	br	8111bd4c <__reset+0xfb0fbd4c>
8111d8f0:	d9c02785 	stb	r7,158(sp)
8111d8f4:	0038e606 	br	8111bc90 <__reset+0xfb0fbc90>
8111d8f8:	d8802344 	addi	r2,sp,141
8111d8fc:	003f0806 	br	8111d520 <__reset+0xfb0fd520>
8111d900:	d9c02785 	stb	r7,158(sp)
8111d904:	0038b706 	br	8111bbe4 <__reset+0xfb0fbbe4>
8111d908:	d9c02785 	stb	r7,158(sp)
8111d90c:	003adc06 	br	8111c480 <__reset+0xfb0fc480>
8111d910:	d9403917 	ldw	r5,228(sp)
8111d914:	00800304 	movi	r2,12
8111d918:	28800015 	stw	r2,0(r5)
8111d91c:	00bfffc4 	movi	r2,-1
8111d920:	00387806 	br	8111bb04 <__reset+0xfb0fbb04>
8111d924:	d9c02785 	stb	r7,158(sp)
8111d928:	003abf06 	br	8111c428 <__reset+0xfb0fc428>
8111d92c:	d9c02785 	stb	r7,158(sp)
8111d930:	003a9b06 	br	8111c3a0 <__reset+0xfb0fc3a0>

8111d934 <___vfprintf_internal_r>:
8111d934:	deffb804 	addi	sp,sp,-288
8111d938:	de00012e 	bgeu	sp,et,8111d940 <___vfprintf_internal_r+0xc>
8111d93c:	003b68fa 	trap	3
8111d940:	dfc04715 	stw	ra,284(sp)
8111d944:	ddc04515 	stw	r23,276(sp)
8111d948:	dd404315 	stw	r21,268(sp)
8111d94c:	d9002c15 	stw	r4,176(sp)
8111d950:	282f883a 	mov	r23,r5
8111d954:	302b883a 	mov	r21,r6
8111d958:	d9c02d15 	stw	r7,180(sp)
8111d95c:	df004615 	stw	fp,280(sp)
8111d960:	dd804415 	stw	r22,272(sp)
8111d964:	dd004215 	stw	r20,264(sp)
8111d968:	dcc04115 	stw	r19,260(sp)
8111d96c:	dc804015 	stw	r18,256(sp)
8111d970:	dc403f15 	stw	r17,252(sp)
8111d974:	dc003e15 	stw	r16,248(sp)
8111d978:	11243100 	call	81124310 <_localeconv_r>
8111d97c:	10800017 	ldw	r2,0(r2)
8111d980:	1009883a 	mov	r4,r2
8111d984:	d8803415 	stw	r2,208(sp)
8111d988:	111b1180 	call	8111b118 <strlen>
8111d98c:	d8803715 	stw	r2,220(sp)
8111d990:	d8802c17 	ldw	r2,176(sp)
8111d994:	10000226 	beq	r2,zero,8111d9a0 <___vfprintf_internal_r+0x6c>
8111d998:	10800e17 	ldw	r2,56(r2)
8111d99c:	1000f926 	beq	r2,zero,8111dd84 <___vfprintf_internal_r+0x450>
8111d9a0:	b880030b 	ldhu	r2,12(r23)
8111d9a4:	10c8000c 	andi	r3,r2,8192
8111d9a8:	1800061e 	bne	r3,zero,8111d9c4 <___vfprintf_internal_r+0x90>
8111d9ac:	b9001917 	ldw	r4,100(r23)
8111d9b0:	00f7ffc4 	movi	r3,-8193
8111d9b4:	10880014 	ori	r2,r2,8192
8111d9b8:	20c6703a 	and	r3,r4,r3
8111d9bc:	b880030d 	sth	r2,12(r23)
8111d9c0:	b8c01915 	stw	r3,100(r23)
8111d9c4:	10c0020c 	andi	r3,r2,8
8111d9c8:	1800c126 	beq	r3,zero,8111dcd0 <___vfprintf_internal_r+0x39c>
8111d9cc:	b8c00417 	ldw	r3,16(r23)
8111d9d0:	1800bf26 	beq	r3,zero,8111dcd0 <___vfprintf_internal_r+0x39c>
8111d9d4:	1080068c 	andi	r2,r2,26
8111d9d8:	00c00284 	movi	r3,10
8111d9dc:	10c0c426 	beq	r2,r3,8111dcf0 <___vfprintf_internal_r+0x3bc>
8111d9e0:	d8c00404 	addi	r3,sp,16
8111d9e4:	05204534 	movhi	r20,33044
8111d9e8:	d9001e04 	addi	r4,sp,120
8111d9ec:	a5144e84 	addi	r20,r20,20794
8111d9f0:	d8c01e15 	stw	r3,120(sp)
8111d9f4:	d8002015 	stw	zero,128(sp)
8111d9f8:	d8001f15 	stw	zero,124(sp)
8111d9fc:	d8003315 	stw	zero,204(sp)
8111da00:	d8003615 	stw	zero,216(sp)
8111da04:	d8003815 	stw	zero,224(sp)
8111da08:	1811883a 	mov	r8,r3
8111da0c:	d8003915 	stw	zero,228(sp)
8111da10:	d8003a15 	stw	zero,232(sp)
8111da14:	d8002f15 	stw	zero,188(sp)
8111da18:	d9002815 	stw	r4,160(sp)
8111da1c:	a8800007 	ldb	r2,0(r21)
8111da20:	10027b26 	beq	r2,zero,8111e410 <___vfprintf_internal_r+0xadc>
8111da24:	00c00944 	movi	r3,37
8111da28:	a821883a 	mov	r16,r21
8111da2c:	10c0021e 	bne	r2,r3,8111da38 <___vfprintf_internal_r+0x104>
8111da30:	00001406 	br	8111da84 <___vfprintf_internal_r+0x150>
8111da34:	10c00326 	beq	r2,r3,8111da44 <___vfprintf_internal_r+0x110>
8111da38:	84000044 	addi	r16,r16,1
8111da3c:	80800007 	ldb	r2,0(r16)
8111da40:	103ffc1e 	bne	r2,zero,8111da34 <__reset+0xfb0fda34>
8111da44:	8563c83a 	sub	r17,r16,r21
8111da48:	88000e26 	beq	r17,zero,8111da84 <___vfprintf_internal_r+0x150>
8111da4c:	d8c02017 	ldw	r3,128(sp)
8111da50:	d8801f17 	ldw	r2,124(sp)
8111da54:	45400015 	stw	r21,0(r8)
8111da58:	1c47883a 	add	r3,r3,r17
8111da5c:	10800044 	addi	r2,r2,1
8111da60:	d8c02015 	stw	r3,128(sp)
8111da64:	44400115 	stw	r17,4(r8)
8111da68:	d8801f15 	stw	r2,124(sp)
8111da6c:	00c001c4 	movi	r3,7
8111da70:	1880a716 	blt	r3,r2,8111dd10 <___vfprintf_internal_r+0x3dc>
8111da74:	42000204 	addi	r8,r8,8
8111da78:	d9402f17 	ldw	r5,188(sp)
8111da7c:	2c4b883a 	add	r5,r5,r17
8111da80:	d9402f15 	stw	r5,188(sp)
8111da84:	80800007 	ldb	r2,0(r16)
8111da88:	1000a826 	beq	r2,zero,8111dd2c <___vfprintf_internal_r+0x3f8>
8111da8c:	84400047 	ldb	r17,1(r16)
8111da90:	00bfffc4 	movi	r2,-1
8111da94:	85400044 	addi	r21,r16,1
8111da98:	d8002785 	stb	zero,158(sp)
8111da9c:	0007883a 	mov	r3,zero
8111daa0:	000f883a 	mov	r7,zero
8111daa4:	d8802915 	stw	r2,164(sp)
8111daa8:	d8003115 	stw	zero,196(sp)
8111daac:	0025883a 	mov	r18,zero
8111dab0:	01401604 	movi	r5,88
8111dab4:	01800244 	movi	r6,9
8111dab8:	02800a84 	movi	r10,42
8111dabc:	02401b04 	movi	r9,108
8111dac0:	ad400044 	addi	r21,r21,1
8111dac4:	88bff804 	addi	r2,r17,-32
8111dac8:	28830436 	bltu	r5,r2,8111e6dc <___vfprintf_internal_r+0xda8>
8111dacc:	100490ba 	slli	r2,r2,2
8111dad0:	012044b4 	movhi	r4,33042
8111dad4:	2136b904 	addi	r4,r4,-9500
8111dad8:	1105883a 	add	r2,r2,r4
8111dadc:	10800017 	ldw	r2,0(r2)
8111dae0:	1000683a 	jmp	r2
8111dae4:	8111e5fc 	xorhi	r4,r16,18327
8111dae8:	8111e6dc 	xori	r4,r16,18331
8111daec:	8111e6dc 	xori	r4,r16,18331
8111daf0:	8111e61c 	xori	r4,r16,18328
8111daf4:	8111e6dc 	xori	r4,r16,18331
8111daf8:	8111e6dc 	xori	r4,r16,18331
8111dafc:	8111e6dc 	xori	r4,r16,18331
8111db00:	8111e6dc 	xori	r4,r16,18331
8111db04:	8111e6dc 	xori	r4,r16,18331
8111db08:	8111e6dc 	xori	r4,r16,18331
8111db0c:	8111dd90 	cmplti	r4,r16,18294
8111db10:	8111e538 	rdprs	r4,r16,18324
8111db14:	8111e6dc 	xori	r4,r16,18331
8111db18:	8111dc58 	cmpnei	r4,r16,18289
8111db1c:	8111ddb8 	rdprs	r4,r16,18294
8111db20:	8111e6dc 	xori	r4,r16,18331
8111db24:	8111ddf8 	rdprs	r4,r16,18295
8111db28:	8111de04 	addi	r4,r16,18296
8111db2c:	8111de04 	addi	r4,r16,18296
8111db30:	8111de04 	addi	r4,r16,18296
8111db34:	8111de04 	addi	r4,r16,18296
8111db38:	8111de04 	addi	r4,r16,18296
8111db3c:	8111de04 	addi	r4,r16,18296
8111db40:	8111de04 	addi	r4,r16,18296
8111db44:	8111de04 	addi	r4,r16,18296
8111db48:	8111de04 	addi	r4,r16,18296
8111db4c:	8111e6dc 	xori	r4,r16,18331
8111db50:	8111e6dc 	xori	r4,r16,18331
8111db54:	8111e6dc 	xori	r4,r16,18331
8111db58:	8111e6dc 	xori	r4,r16,18331
8111db5c:	8111e6dc 	xori	r4,r16,18331
8111db60:	8111e6dc 	xori	r4,r16,18331
8111db64:	8111e6dc 	xori	r4,r16,18331
8111db68:	8111e6dc 	xori	r4,r16,18331
8111db6c:	8111e6dc 	xori	r4,r16,18331
8111db70:	8111e6dc 	xori	r4,r16,18331
8111db74:	8111de38 	rdprs	r4,r16,18296
8111db78:	8111def4 	orhi	r4,r16,18299
8111db7c:	8111e6dc 	xori	r4,r16,18331
8111db80:	8111def4 	orhi	r4,r16,18299
8111db84:	8111e6dc 	xori	r4,r16,18331
8111db88:	8111e6dc 	xori	r4,r16,18331
8111db8c:	8111e6dc 	xori	r4,r16,18331
8111db90:	8111e6dc 	xori	r4,r16,18331
8111db94:	8111df94 	ori	r4,r16,18302
8111db98:	8111e6dc 	xori	r4,r16,18331
8111db9c:	8111e6dc 	xori	r4,r16,18331
8111dba0:	8111dfa0 	cmpeqi	r4,r16,18302
8111dba4:	8111e6dc 	xori	r4,r16,18331
8111dba8:	8111e6dc 	xori	r4,r16,18331
8111dbac:	8111e6dc 	xori	r4,r16,18331
8111dbb0:	8111e6dc 	xori	r4,r16,18331
8111dbb4:	8111e6dc 	xori	r4,r16,18331
8111dbb8:	8111e418 	cmpnei	r4,r16,18320
8111dbbc:	8111e6dc 	xori	r4,r16,18331
8111dbc0:	8111e6dc 	xori	r4,r16,18331
8111dbc4:	8111e478 	rdprs	r4,r16,18321
8111dbc8:	8111e6dc 	xori	r4,r16,18331
8111dbcc:	8111e6dc 	xori	r4,r16,18331
8111dbd0:	8111e6dc 	xori	r4,r16,18331
8111dbd4:	8111e6dc 	xori	r4,r16,18331
8111dbd8:	8111e6dc 	xori	r4,r16,18331
8111dbdc:	8111e6dc 	xori	r4,r16,18331
8111dbe0:	8111e6dc 	xori	r4,r16,18331
8111dbe4:	8111e6dc 	xori	r4,r16,18331
8111dbe8:	8111e6dc 	xori	r4,r16,18331
8111dbec:	8111e6dc 	xori	r4,r16,18331
8111dbf0:	8111e688 	cmpgei	r4,r16,18330
8111dbf4:	8111e628 	cmpgeui	r4,r16,18328
8111dbf8:	8111def4 	orhi	r4,r16,18299
8111dbfc:	8111def4 	orhi	r4,r16,18299
8111dc00:	8111def4 	orhi	r4,r16,18299
8111dc04:	8111e638 	rdprs	r4,r16,18328
8111dc08:	8111e628 	cmpgeui	r4,r16,18328
8111dc0c:	8111e6dc 	xori	r4,r16,18331
8111dc10:	8111e6dc 	xori	r4,r16,18331
8111dc14:	8111e644 	addi	r4,r16,18329
8111dc18:	8111e6dc 	xori	r4,r16,18331
8111dc1c:	8111e654 	ori	r4,r16,18329
8111dc20:	8111e528 	cmpgeui	r4,r16,18324
8111dc24:	8111dc64 	muli	r4,r16,18289
8111dc28:	8111e548 	cmpgei	r4,r16,18325
8111dc2c:	8111e6dc 	xori	r4,r16,18331
8111dc30:	8111e554 	ori	r4,r16,18325
8111dc34:	8111e6dc 	xori	r4,r16,18331
8111dc38:	8111e5b0 	cmpltui	r4,r16,18326
8111dc3c:	8111e6dc 	xori	r4,r16,18331
8111dc40:	8111e6dc 	xori	r4,r16,18331
8111dc44:	8111e5c0 	call	88111e5c <__reset+0x20f1e5c>
8111dc48:	d9003117 	ldw	r4,196(sp)
8111dc4c:	d8802d15 	stw	r2,180(sp)
8111dc50:	0109c83a 	sub	r4,zero,r4
8111dc54:	d9003115 	stw	r4,196(sp)
8111dc58:	94800114 	ori	r18,r18,4
8111dc5c:	ac400007 	ldb	r17,0(r21)
8111dc60:	003f9706 	br	8111dac0 <__reset+0xfb0fdac0>
8111dc64:	00800c04 	movi	r2,48
8111dc68:	d9002d17 	ldw	r4,180(sp)
8111dc6c:	d9402917 	ldw	r5,164(sp)
8111dc70:	d8802705 	stb	r2,156(sp)
8111dc74:	00801e04 	movi	r2,120
8111dc78:	d8802745 	stb	r2,157(sp)
8111dc7c:	d8002785 	stb	zero,158(sp)
8111dc80:	20c00104 	addi	r3,r4,4
8111dc84:	24c00017 	ldw	r19,0(r4)
8111dc88:	002d883a 	mov	r22,zero
8111dc8c:	90800094 	ori	r2,r18,2
8111dc90:	28029a16 	blt	r5,zero,8111e6fc <___vfprintf_internal_r+0xdc8>
8111dc94:	00bfdfc4 	movi	r2,-129
8111dc98:	90a4703a 	and	r18,r18,r2
8111dc9c:	d8c02d15 	stw	r3,180(sp)
8111dca0:	94800094 	ori	r18,r18,2
8111dca4:	9802871e 	bne	r19,zero,8111e6c4 <___vfprintf_internal_r+0xd90>
8111dca8:	00a04534 	movhi	r2,33044
8111dcac:	10943f04 	addi	r2,r2,20732
8111dcb0:	d8803915 	stw	r2,228(sp)
8111dcb4:	04401e04 	movi	r17,120
8111dcb8:	d8802917 	ldw	r2,164(sp)
8111dcbc:	0039883a 	mov	fp,zero
8111dcc0:	1001e926 	beq	r2,zero,8111e468 <___vfprintf_internal_r+0xb34>
8111dcc4:	0027883a 	mov	r19,zero
8111dcc8:	002d883a 	mov	r22,zero
8111dccc:	00020506 	br	8111e4e4 <___vfprintf_internal_r+0xbb0>
8111dcd0:	d9002c17 	ldw	r4,176(sp)
8111dcd4:	b80b883a 	mov	r5,r23
8111dcd8:	11214b80 	call	811214b8 <__swsetup_r>
8111dcdc:	1005ac1e 	bne	r2,zero,8111f390 <___vfprintf_internal_r+0x1a5c>
8111dce0:	b880030b 	ldhu	r2,12(r23)
8111dce4:	00c00284 	movi	r3,10
8111dce8:	1080068c 	andi	r2,r2,26
8111dcec:	10ff3c1e 	bne	r2,r3,8111d9e0 <__reset+0xfb0fd9e0>
8111dcf0:	b880038f 	ldh	r2,14(r23)
8111dcf4:	103f3a16 	blt	r2,zero,8111d9e0 <__reset+0xfb0fd9e0>
8111dcf8:	d9c02d17 	ldw	r7,180(sp)
8111dcfc:	d9002c17 	ldw	r4,176(sp)
8111dd00:	a80d883a 	mov	r6,r21
8111dd04:	b80b883a 	mov	r5,r23
8111dd08:	111fb500 	call	8111fb50 <__sbprintf>
8111dd0c:	00001106 	br	8111dd54 <___vfprintf_internal_r+0x420>
8111dd10:	d9002c17 	ldw	r4,176(sp)
8111dd14:	d9801e04 	addi	r6,sp,120
8111dd18:	b80b883a 	mov	r5,r23
8111dd1c:	112a1c00 	call	8112a1c0 <__sprint_r>
8111dd20:	1000081e 	bne	r2,zero,8111dd44 <___vfprintf_internal_r+0x410>
8111dd24:	da000404 	addi	r8,sp,16
8111dd28:	003f5306 	br	8111da78 <__reset+0xfb0fda78>
8111dd2c:	d8802017 	ldw	r2,128(sp)
8111dd30:	10000426 	beq	r2,zero,8111dd44 <___vfprintf_internal_r+0x410>
8111dd34:	d9002c17 	ldw	r4,176(sp)
8111dd38:	d9801e04 	addi	r6,sp,120
8111dd3c:	b80b883a 	mov	r5,r23
8111dd40:	112a1c00 	call	8112a1c0 <__sprint_r>
8111dd44:	b880030b 	ldhu	r2,12(r23)
8111dd48:	1080100c 	andi	r2,r2,64
8111dd4c:	1005901e 	bne	r2,zero,8111f390 <___vfprintf_internal_r+0x1a5c>
8111dd50:	d8802f17 	ldw	r2,188(sp)
8111dd54:	dfc04717 	ldw	ra,284(sp)
8111dd58:	df004617 	ldw	fp,280(sp)
8111dd5c:	ddc04517 	ldw	r23,276(sp)
8111dd60:	dd804417 	ldw	r22,272(sp)
8111dd64:	dd404317 	ldw	r21,268(sp)
8111dd68:	dd004217 	ldw	r20,264(sp)
8111dd6c:	dcc04117 	ldw	r19,260(sp)
8111dd70:	dc804017 	ldw	r18,256(sp)
8111dd74:	dc403f17 	ldw	r17,252(sp)
8111dd78:	dc003e17 	ldw	r16,248(sp)
8111dd7c:	dec04804 	addi	sp,sp,288
8111dd80:	f800283a 	ret
8111dd84:	d9002c17 	ldw	r4,176(sp)
8111dd88:	11234cc0 	call	811234cc <__sinit>
8111dd8c:	003f0406 	br	8111d9a0 <__reset+0xfb0fd9a0>
8111dd90:	d8802d17 	ldw	r2,180(sp)
8111dd94:	d9002d17 	ldw	r4,180(sp)
8111dd98:	10800017 	ldw	r2,0(r2)
8111dd9c:	d8803115 	stw	r2,196(sp)
8111dda0:	20800104 	addi	r2,r4,4
8111dda4:	d9003117 	ldw	r4,196(sp)
8111dda8:	203fa716 	blt	r4,zero,8111dc48 <__reset+0xfb0fdc48>
8111ddac:	d8802d15 	stw	r2,180(sp)
8111ddb0:	ac400007 	ldb	r17,0(r21)
8111ddb4:	003f4206 	br	8111dac0 <__reset+0xfb0fdac0>
8111ddb8:	ac400007 	ldb	r17,0(r21)
8111ddbc:	aac00044 	addi	r11,r21,1
8111ddc0:	8a872826 	beq	r17,r10,8111fa64 <___vfprintf_internal_r+0x2130>
8111ddc4:	88bff404 	addi	r2,r17,-48
8111ddc8:	0009883a 	mov	r4,zero
8111ddcc:	30867d36 	bltu	r6,r2,8111f7c4 <___vfprintf_internal_r+0x1e90>
8111ddd0:	5c400007 	ldb	r17,0(r11)
8111ddd4:	210002a4 	muli	r4,r4,10
8111ddd8:	5d400044 	addi	r21,r11,1
8111dddc:	a817883a 	mov	r11,r21
8111dde0:	2089883a 	add	r4,r4,r2
8111dde4:	88bff404 	addi	r2,r17,-48
8111dde8:	30bff92e 	bgeu	r6,r2,8111ddd0 <__reset+0xfb0fddd0>
8111ddec:	2005c916 	blt	r4,zero,8111f514 <___vfprintf_internal_r+0x1be0>
8111ddf0:	d9002915 	stw	r4,164(sp)
8111ddf4:	003f3306 	br	8111dac4 <__reset+0xfb0fdac4>
8111ddf8:	94802014 	ori	r18,r18,128
8111ddfc:	ac400007 	ldb	r17,0(r21)
8111de00:	003f2f06 	br	8111dac0 <__reset+0xfb0fdac0>
8111de04:	a809883a 	mov	r4,r21
8111de08:	d8003115 	stw	zero,196(sp)
8111de0c:	88bff404 	addi	r2,r17,-48
8111de10:	0017883a 	mov	r11,zero
8111de14:	24400007 	ldb	r17,0(r4)
8111de18:	5ac002a4 	muli	r11,r11,10
8111de1c:	ad400044 	addi	r21,r21,1
8111de20:	a809883a 	mov	r4,r21
8111de24:	12d7883a 	add	r11,r2,r11
8111de28:	88bff404 	addi	r2,r17,-48
8111de2c:	30bff92e 	bgeu	r6,r2,8111de14 <__reset+0xfb0fde14>
8111de30:	dac03115 	stw	r11,196(sp)
8111de34:	003f2306 	br	8111dac4 <__reset+0xfb0fdac4>
8111de38:	18c03fcc 	andi	r3,r3,255
8111de3c:	18072b1e 	bne	r3,zero,8111faec <___vfprintf_internal_r+0x21b8>
8111de40:	94800414 	ori	r18,r18,16
8111de44:	9080080c 	andi	r2,r18,32
8111de48:	10037b26 	beq	r2,zero,8111ec38 <___vfprintf_internal_r+0x1304>
8111de4c:	d9402d17 	ldw	r5,180(sp)
8111de50:	28800117 	ldw	r2,4(r5)
8111de54:	2cc00017 	ldw	r19,0(r5)
8111de58:	29400204 	addi	r5,r5,8
8111de5c:	d9402d15 	stw	r5,180(sp)
8111de60:	102d883a 	mov	r22,r2
8111de64:	10044b16 	blt	r2,zero,8111ef94 <___vfprintf_internal_r+0x1660>
8111de68:	d9402917 	ldw	r5,164(sp)
8111de6c:	df002783 	ldbu	fp,158(sp)
8111de70:	2803bc16 	blt	r5,zero,8111ed64 <___vfprintf_internal_r+0x1430>
8111de74:	00ffdfc4 	movi	r3,-129
8111de78:	9d84b03a 	or	r2,r19,r22
8111de7c:	90e4703a 	and	r18,r18,r3
8111de80:	10017726 	beq	r2,zero,8111e460 <___vfprintf_internal_r+0xb2c>
8111de84:	b0038326 	beq	r22,zero,8111ec94 <___vfprintf_internal_r+0x1360>
8111de88:	dc402a15 	stw	r17,168(sp)
8111de8c:	dc001e04 	addi	r16,sp,120
8111de90:	b023883a 	mov	r17,r22
8111de94:	402d883a 	mov	r22,r8
8111de98:	9809883a 	mov	r4,r19
8111de9c:	880b883a 	mov	r5,r17
8111dea0:	01800284 	movi	r6,10
8111dea4:	000f883a 	mov	r7,zero
8111dea8:	112d2ac0 	call	8112d2ac <__umoddi3>
8111deac:	10800c04 	addi	r2,r2,48
8111deb0:	843fffc4 	addi	r16,r16,-1
8111deb4:	9809883a 	mov	r4,r19
8111deb8:	880b883a 	mov	r5,r17
8111debc:	80800005 	stb	r2,0(r16)
8111dec0:	01800284 	movi	r6,10
8111dec4:	000f883a 	mov	r7,zero
8111dec8:	112cd2c0 	call	8112cd2c <__udivdi3>
8111decc:	1027883a 	mov	r19,r2
8111ded0:	10c4b03a 	or	r2,r2,r3
8111ded4:	1823883a 	mov	r17,r3
8111ded8:	103fef1e 	bne	r2,zero,8111de98 <__reset+0xfb0fde98>
8111dedc:	d8c02817 	ldw	r3,160(sp)
8111dee0:	dc402a17 	ldw	r17,168(sp)
8111dee4:	b011883a 	mov	r8,r22
8111dee8:	1c07c83a 	sub	r3,r3,r16
8111deec:	d8c02e15 	stw	r3,184(sp)
8111def0:	00005906 	br	8111e058 <___vfprintf_internal_r+0x724>
8111def4:	18c03fcc 	andi	r3,r3,255
8111def8:	1806fa1e 	bne	r3,zero,8111fae4 <___vfprintf_internal_r+0x21b0>
8111defc:	9080020c 	andi	r2,r18,8
8111df00:	10048a26 	beq	r2,zero,8111f12c <___vfprintf_internal_r+0x17f8>
8111df04:	d8c02d17 	ldw	r3,180(sp)
8111df08:	d9002d17 	ldw	r4,180(sp)
8111df0c:	d9402d17 	ldw	r5,180(sp)
8111df10:	18c00017 	ldw	r3,0(r3)
8111df14:	21000117 	ldw	r4,4(r4)
8111df18:	29400204 	addi	r5,r5,8
8111df1c:	d8c03615 	stw	r3,216(sp)
8111df20:	d9003815 	stw	r4,224(sp)
8111df24:	d9402d15 	stw	r5,180(sp)
8111df28:	d9003617 	ldw	r4,216(sp)
8111df2c:	d9403817 	ldw	r5,224(sp)
8111df30:	da003d15 	stw	r8,244(sp)
8111df34:	04000044 	movi	r16,1
8111df38:	112695c0 	call	8112695c <__fpclassifyd>
8111df3c:	da003d17 	ldw	r8,244(sp)
8111df40:	14041f1e 	bne	r2,r16,8111efc0 <___vfprintf_internal_r+0x168c>
8111df44:	d9003617 	ldw	r4,216(sp)
8111df48:	d9403817 	ldw	r5,224(sp)
8111df4c:	000d883a 	mov	r6,zero
8111df50:	000f883a 	mov	r7,zero
8111df54:	112edc80 	call	8112edc8 <__ledf2>
8111df58:	da003d17 	ldw	r8,244(sp)
8111df5c:	1005be16 	blt	r2,zero,8111f658 <___vfprintf_internal_r+0x1d24>
8111df60:	df002783 	ldbu	fp,158(sp)
8111df64:	008011c4 	movi	r2,71
8111df68:	1445330e 	bge	r2,r17,8111f438 <___vfprintf_internal_r+0x1b04>
8111df6c:	04204534 	movhi	r16,33044
8111df70:	84143704 	addi	r16,r16,20700
8111df74:	00c000c4 	movi	r3,3
8111df78:	00bfdfc4 	movi	r2,-129
8111df7c:	d8c02a15 	stw	r3,168(sp)
8111df80:	90a4703a 	and	r18,r18,r2
8111df84:	d8c02e15 	stw	r3,184(sp)
8111df88:	d8002915 	stw	zero,164(sp)
8111df8c:	d8003215 	stw	zero,200(sp)
8111df90:	00003706 	br	8111e070 <___vfprintf_internal_r+0x73c>
8111df94:	94800214 	ori	r18,r18,8
8111df98:	ac400007 	ldb	r17,0(r21)
8111df9c:	003ec806 	br	8111dac0 <__reset+0xfb0fdac0>
8111dfa0:	18c03fcc 	andi	r3,r3,255
8111dfa4:	1806db1e 	bne	r3,zero,8111fb14 <___vfprintf_internal_r+0x21e0>
8111dfa8:	94800414 	ori	r18,r18,16
8111dfac:	9080080c 	andi	r2,r18,32
8111dfb0:	1002d826 	beq	r2,zero,8111eb14 <___vfprintf_internal_r+0x11e0>
8111dfb4:	d9402d17 	ldw	r5,180(sp)
8111dfb8:	d8c02917 	ldw	r3,164(sp)
8111dfbc:	d8002785 	stb	zero,158(sp)
8111dfc0:	28800204 	addi	r2,r5,8
8111dfc4:	2cc00017 	ldw	r19,0(r5)
8111dfc8:	2d800117 	ldw	r22,4(r5)
8111dfcc:	18048f16 	blt	r3,zero,8111f20c <___vfprintf_internal_r+0x18d8>
8111dfd0:	013fdfc4 	movi	r4,-129
8111dfd4:	9d86b03a 	or	r3,r19,r22
8111dfd8:	d8802d15 	stw	r2,180(sp)
8111dfdc:	9124703a 	and	r18,r18,r4
8111dfe0:	1802d91e 	bne	r3,zero,8111eb48 <___vfprintf_internal_r+0x1214>
8111dfe4:	d8c02917 	ldw	r3,164(sp)
8111dfe8:	0039883a 	mov	fp,zero
8111dfec:	1805c326 	beq	r3,zero,8111f6fc <___vfprintf_internal_r+0x1dc8>
8111dff0:	0027883a 	mov	r19,zero
8111dff4:	002d883a 	mov	r22,zero
8111dff8:	dc001e04 	addi	r16,sp,120
8111dffc:	9806d0fa 	srli	r3,r19,3
8111e000:	b008977a 	slli	r4,r22,29
8111e004:	b02cd0fa 	srli	r22,r22,3
8111e008:	9cc001cc 	andi	r19,r19,7
8111e00c:	98800c04 	addi	r2,r19,48
8111e010:	843fffc4 	addi	r16,r16,-1
8111e014:	20e6b03a 	or	r19,r4,r3
8111e018:	80800005 	stb	r2,0(r16)
8111e01c:	9d86b03a 	or	r3,r19,r22
8111e020:	183ff61e 	bne	r3,zero,8111dffc <__reset+0xfb0fdffc>
8111e024:	90c0004c 	andi	r3,r18,1
8111e028:	18013b26 	beq	r3,zero,8111e518 <___vfprintf_internal_r+0xbe4>
8111e02c:	10803fcc 	andi	r2,r2,255
8111e030:	1080201c 	xori	r2,r2,128
8111e034:	10bfe004 	addi	r2,r2,-128
8111e038:	00c00c04 	movi	r3,48
8111e03c:	10c13626 	beq	r2,r3,8111e518 <___vfprintf_internal_r+0xbe4>
8111e040:	80ffffc5 	stb	r3,-1(r16)
8111e044:	d8c02817 	ldw	r3,160(sp)
8111e048:	80bfffc4 	addi	r2,r16,-1
8111e04c:	1021883a 	mov	r16,r2
8111e050:	1887c83a 	sub	r3,r3,r2
8111e054:	d8c02e15 	stw	r3,184(sp)
8111e058:	d8802e17 	ldw	r2,184(sp)
8111e05c:	d9002917 	ldw	r4,164(sp)
8111e060:	1100010e 	bge	r2,r4,8111e068 <___vfprintf_internal_r+0x734>
8111e064:	2005883a 	mov	r2,r4
8111e068:	d8802a15 	stw	r2,168(sp)
8111e06c:	d8003215 	stw	zero,200(sp)
8111e070:	e7003fcc 	andi	fp,fp,255
8111e074:	e700201c 	xori	fp,fp,128
8111e078:	e73fe004 	addi	fp,fp,-128
8111e07c:	e0000326 	beq	fp,zero,8111e08c <___vfprintf_internal_r+0x758>
8111e080:	d8c02a17 	ldw	r3,168(sp)
8111e084:	18c00044 	addi	r3,r3,1
8111e088:	d8c02a15 	stw	r3,168(sp)
8111e08c:	90c0008c 	andi	r3,r18,2
8111e090:	d8c02b15 	stw	r3,172(sp)
8111e094:	18000326 	beq	r3,zero,8111e0a4 <___vfprintf_internal_r+0x770>
8111e098:	d8c02a17 	ldw	r3,168(sp)
8111e09c:	18c00084 	addi	r3,r3,2
8111e0a0:	d8c02a15 	stw	r3,168(sp)
8111e0a4:	90c0210c 	andi	r3,r18,132
8111e0a8:	d8c03015 	stw	r3,192(sp)
8111e0ac:	1801a31e 	bne	r3,zero,8111e73c <___vfprintf_internal_r+0xe08>
8111e0b0:	d9003117 	ldw	r4,196(sp)
8111e0b4:	d8c02a17 	ldw	r3,168(sp)
8111e0b8:	20e7c83a 	sub	r19,r4,r3
8111e0bc:	04c19f0e 	bge	zero,r19,8111e73c <___vfprintf_internal_r+0xe08>
8111e0c0:	02400404 	movi	r9,16
8111e0c4:	d8c02017 	ldw	r3,128(sp)
8111e0c8:	d8801f17 	ldw	r2,124(sp)
8111e0cc:	4cc50d0e 	bge	r9,r19,8111f504 <___vfprintf_internal_r+0x1bd0>
8111e0d0:	01604534 	movhi	r5,33044
8111e0d4:	29545284 	addi	r5,r5,20810
8111e0d8:	dc403b15 	stw	r17,236(sp)
8111e0dc:	d9403515 	stw	r5,212(sp)
8111e0e0:	9823883a 	mov	r17,r19
8111e0e4:	482d883a 	mov	r22,r9
8111e0e8:	9027883a 	mov	r19,r18
8111e0ec:	070001c4 	movi	fp,7
8111e0f0:	8025883a 	mov	r18,r16
8111e0f4:	dc002c17 	ldw	r16,176(sp)
8111e0f8:	00000306 	br	8111e108 <___vfprintf_internal_r+0x7d4>
8111e0fc:	8c7ffc04 	addi	r17,r17,-16
8111e100:	42000204 	addi	r8,r8,8
8111e104:	b440130e 	bge	r22,r17,8111e154 <___vfprintf_internal_r+0x820>
8111e108:	01204534 	movhi	r4,33044
8111e10c:	18c00404 	addi	r3,r3,16
8111e110:	10800044 	addi	r2,r2,1
8111e114:	21145284 	addi	r4,r4,20810
8111e118:	41000015 	stw	r4,0(r8)
8111e11c:	45800115 	stw	r22,4(r8)
8111e120:	d8c02015 	stw	r3,128(sp)
8111e124:	d8801f15 	stw	r2,124(sp)
8111e128:	e0bff40e 	bge	fp,r2,8111e0fc <__reset+0xfb0fe0fc>
8111e12c:	d9801e04 	addi	r6,sp,120
8111e130:	b80b883a 	mov	r5,r23
8111e134:	8009883a 	mov	r4,r16
8111e138:	112a1c00 	call	8112a1c0 <__sprint_r>
8111e13c:	103f011e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111e140:	8c7ffc04 	addi	r17,r17,-16
8111e144:	d8c02017 	ldw	r3,128(sp)
8111e148:	d8801f17 	ldw	r2,124(sp)
8111e14c:	da000404 	addi	r8,sp,16
8111e150:	b47fed16 	blt	r22,r17,8111e108 <__reset+0xfb0fe108>
8111e154:	9021883a 	mov	r16,r18
8111e158:	9825883a 	mov	r18,r19
8111e15c:	8827883a 	mov	r19,r17
8111e160:	dc403b17 	ldw	r17,236(sp)
8111e164:	d9403517 	ldw	r5,212(sp)
8111e168:	98c7883a 	add	r3,r19,r3
8111e16c:	10800044 	addi	r2,r2,1
8111e170:	41400015 	stw	r5,0(r8)
8111e174:	44c00115 	stw	r19,4(r8)
8111e178:	d8c02015 	stw	r3,128(sp)
8111e17c:	d8801f15 	stw	r2,124(sp)
8111e180:	010001c4 	movi	r4,7
8111e184:	2082a316 	blt	r4,r2,8111ec14 <___vfprintf_internal_r+0x12e0>
8111e188:	df002787 	ldb	fp,158(sp)
8111e18c:	42000204 	addi	r8,r8,8
8111e190:	e0000c26 	beq	fp,zero,8111e1c4 <___vfprintf_internal_r+0x890>
8111e194:	d8801f17 	ldw	r2,124(sp)
8111e198:	d9002784 	addi	r4,sp,158
8111e19c:	18c00044 	addi	r3,r3,1
8111e1a0:	10800044 	addi	r2,r2,1
8111e1a4:	41000015 	stw	r4,0(r8)
8111e1a8:	01000044 	movi	r4,1
8111e1ac:	41000115 	stw	r4,4(r8)
8111e1b0:	d8c02015 	stw	r3,128(sp)
8111e1b4:	d8801f15 	stw	r2,124(sp)
8111e1b8:	010001c4 	movi	r4,7
8111e1bc:	20823c16 	blt	r4,r2,8111eab0 <___vfprintf_internal_r+0x117c>
8111e1c0:	42000204 	addi	r8,r8,8
8111e1c4:	d8802b17 	ldw	r2,172(sp)
8111e1c8:	10000c26 	beq	r2,zero,8111e1fc <___vfprintf_internal_r+0x8c8>
8111e1cc:	d8801f17 	ldw	r2,124(sp)
8111e1d0:	d9002704 	addi	r4,sp,156
8111e1d4:	18c00084 	addi	r3,r3,2
8111e1d8:	10800044 	addi	r2,r2,1
8111e1dc:	41000015 	stw	r4,0(r8)
8111e1e0:	01000084 	movi	r4,2
8111e1e4:	41000115 	stw	r4,4(r8)
8111e1e8:	d8c02015 	stw	r3,128(sp)
8111e1ec:	d8801f15 	stw	r2,124(sp)
8111e1f0:	010001c4 	movi	r4,7
8111e1f4:	20823616 	blt	r4,r2,8111ead0 <___vfprintf_internal_r+0x119c>
8111e1f8:	42000204 	addi	r8,r8,8
8111e1fc:	d9003017 	ldw	r4,192(sp)
8111e200:	00802004 	movi	r2,128
8111e204:	20819926 	beq	r4,r2,8111e86c <___vfprintf_internal_r+0xf38>
8111e208:	d9402917 	ldw	r5,164(sp)
8111e20c:	d8802e17 	ldw	r2,184(sp)
8111e210:	28adc83a 	sub	r22,r5,r2
8111e214:	0580310e 	bge	zero,r22,8111e2dc <___vfprintf_internal_r+0x9a8>
8111e218:	07000404 	movi	fp,16
8111e21c:	d8801f17 	ldw	r2,124(sp)
8111e220:	e584140e 	bge	fp,r22,8111f274 <___vfprintf_internal_r+0x1940>
8111e224:	01604534 	movhi	r5,33044
8111e228:	29544e84 	addi	r5,r5,20794
8111e22c:	dc402915 	stw	r17,164(sp)
8111e230:	d9402b15 	stw	r5,172(sp)
8111e234:	b023883a 	mov	r17,r22
8111e238:	04c001c4 	movi	r19,7
8111e23c:	a82d883a 	mov	r22,r21
8111e240:	902b883a 	mov	r21,r18
8111e244:	8025883a 	mov	r18,r16
8111e248:	dc002c17 	ldw	r16,176(sp)
8111e24c:	00000306 	br	8111e25c <___vfprintf_internal_r+0x928>
8111e250:	8c7ffc04 	addi	r17,r17,-16
8111e254:	42000204 	addi	r8,r8,8
8111e258:	e440110e 	bge	fp,r17,8111e2a0 <___vfprintf_internal_r+0x96c>
8111e25c:	18c00404 	addi	r3,r3,16
8111e260:	10800044 	addi	r2,r2,1
8111e264:	45000015 	stw	r20,0(r8)
8111e268:	47000115 	stw	fp,4(r8)
8111e26c:	d8c02015 	stw	r3,128(sp)
8111e270:	d8801f15 	stw	r2,124(sp)
8111e274:	98bff60e 	bge	r19,r2,8111e250 <__reset+0xfb0fe250>
8111e278:	d9801e04 	addi	r6,sp,120
8111e27c:	b80b883a 	mov	r5,r23
8111e280:	8009883a 	mov	r4,r16
8111e284:	112a1c00 	call	8112a1c0 <__sprint_r>
8111e288:	103eae1e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111e28c:	8c7ffc04 	addi	r17,r17,-16
8111e290:	d8c02017 	ldw	r3,128(sp)
8111e294:	d8801f17 	ldw	r2,124(sp)
8111e298:	da000404 	addi	r8,sp,16
8111e29c:	e47fef16 	blt	fp,r17,8111e25c <__reset+0xfb0fe25c>
8111e2a0:	9021883a 	mov	r16,r18
8111e2a4:	a825883a 	mov	r18,r21
8111e2a8:	b02b883a 	mov	r21,r22
8111e2ac:	882d883a 	mov	r22,r17
8111e2b0:	dc402917 	ldw	r17,164(sp)
8111e2b4:	d9002b17 	ldw	r4,172(sp)
8111e2b8:	1d87883a 	add	r3,r3,r22
8111e2bc:	10800044 	addi	r2,r2,1
8111e2c0:	41000015 	stw	r4,0(r8)
8111e2c4:	45800115 	stw	r22,4(r8)
8111e2c8:	d8c02015 	stw	r3,128(sp)
8111e2cc:	d8801f15 	stw	r2,124(sp)
8111e2d0:	010001c4 	movi	r4,7
8111e2d4:	2081ee16 	blt	r4,r2,8111ea90 <___vfprintf_internal_r+0x115c>
8111e2d8:	42000204 	addi	r8,r8,8
8111e2dc:	9080400c 	andi	r2,r18,256
8111e2e0:	1001181e 	bne	r2,zero,8111e744 <___vfprintf_internal_r+0xe10>
8111e2e4:	d9402e17 	ldw	r5,184(sp)
8111e2e8:	d8801f17 	ldw	r2,124(sp)
8111e2ec:	44000015 	stw	r16,0(r8)
8111e2f0:	1947883a 	add	r3,r3,r5
8111e2f4:	10800044 	addi	r2,r2,1
8111e2f8:	41400115 	stw	r5,4(r8)
8111e2fc:	d8c02015 	stw	r3,128(sp)
8111e300:	d8801f15 	stw	r2,124(sp)
8111e304:	010001c4 	movi	r4,7
8111e308:	2081d316 	blt	r4,r2,8111ea58 <___vfprintf_internal_r+0x1124>
8111e30c:	42000204 	addi	r8,r8,8
8111e310:	9480010c 	andi	r18,r18,4
8111e314:	90003226 	beq	r18,zero,8111e3e0 <___vfprintf_internal_r+0xaac>
8111e318:	d9403117 	ldw	r5,196(sp)
8111e31c:	d8802a17 	ldw	r2,168(sp)
8111e320:	28a1c83a 	sub	r16,r5,r2
8111e324:	04002e0e 	bge	zero,r16,8111e3e0 <___vfprintf_internal_r+0xaac>
8111e328:	04400404 	movi	r17,16
8111e32c:	d8801f17 	ldw	r2,124(sp)
8111e330:	8c04a20e 	bge	r17,r16,8111f5bc <___vfprintf_internal_r+0x1c88>
8111e334:	01604534 	movhi	r5,33044
8111e338:	29545284 	addi	r5,r5,20810
8111e33c:	d9403515 	stw	r5,212(sp)
8111e340:	048001c4 	movi	r18,7
8111e344:	dcc02c17 	ldw	r19,176(sp)
8111e348:	00000306 	br	8111e358 <___vfprintf_internal_r+0xa24>
8111e34c:	843ffc04 	addi	r16,r16,-16
8111e350:	42000204 	addi	r8,r8,8
8111e354:	8c00130e 	bge	r17,r16,8111e3a4 <___vfprintf_internal_r+0xa70>
8111e358:	01204534 	movhi	r4,33044
8111e35c:	18c00404 	addi	r3,r3,16
8111e360:	10800044 	addi	r2,r2,1
8111e364:	21145284 	addi	r4,r4,20810
8111e368:	41000015 	stw	r4,0(r8)
8111e36c:	44400115 	stw	r17,4(r8)
8111e370:	d8c02015 	stw	r3,128(sp)
8111e374:	d8801f15 	stw	r2,124(sp)
8111e378:	90bff40e 	bge	r18,r2,8111e34c <__reset+0xfb0fe34c>
8111e37c:	d9801e04 	addi	r6,sp,120
8111e380:	b80b883a 	mov	r5,r23
8111e384:	9809883a 	mov	r4,r19
8111e388:	112a1c00 	call	8112a1c0 <__sprint_r>
8111e38c:	103e6d1e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111e390:	843ffc04 	addi	r16,r16,-16
8111e394:	d8c02017 	ldw	r3,128(sp)
8111e398:	d8801f17 	ldw	r2,124(sp)
8111e39c:	da000404 	addi	r8,sp,16
8111e3a0:	8c3fed16 	blt	r17,r16,8111e358 <__reset+0xfb0fe358>
8111e3a4:	d9403517 	ldw	r5,212(sp)
8111e3a8:	1c07883a 	add	r3,r3,r16
8111e3ac:	10800044 	addi	r2,r2,1
8111e3b0:	41400015 	stw	r5,0(r8)
8111e3b4:	44000115 	stw	r16,4(r8)
8111e3b8:	d8c02015 	stw	r3,128(sp)
8111e3bc:	d8801f15 	stw	r2,124(sp)
8111e3c0:	010001c4 	movi	r4,7
8111e3c4:	2080060e 	bge	r4,r2,8111e3e0 <___vfprintf_internal_r+0xaac>
8111e3c8:	d9002c17 	ldw	r4,176(sp)
8111e3cc:	d9801e04 	addi	r6,sp,120
8111e3d0:	b80b883a 	mov	r5,r23
8111e3d4:	112a1c00 	call	8112a1c0 <__sprint_r>
8111e3d8:	103e5a1e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111e3dc:	d8c02017 	ldw	r3,128(sp)
8111e3e0:	d8803117 	ldw	r2,196(sp)
8111e3e4:	d9002a17 	ldw	r4,168(sp)
8111e3e8:	1100010e 	bge	r2,r4,8111e3f0 <___vfprintf_internal_r+0xabc>
8111e3ec:	2005883a 	mov	r2,r4
8111e3f0:	d9402f17 	ldw	r5,188(sp)
8111e3f4:	288b883a 	add	r5,r5,r2
8111e3f8:	d9402f15 	stw	r5,188(sp)
8111e3fc:	18019e1e 	bne	r3,zero,8111ea78 <___vfprintf_internal_r+0x1144>
8111e400:	a8800007 	ldb	r2,0(r21)
8111e404:	d8001f15 	stw	zero,124(sp)
8111e408:	da000404 	addi	r8,sp,16
8111e40c:	103d851e 	bne	r2,zero,8111da24 <__reset+0xfb0fda24>
8111e410:	a821883a 	mov	r16,r21
8111e414:	003d9b06 	br	8111da84 <__reset+0xfb0fda84>
8111e418:	18c03fcc 	andi	r3,r3,255
8111e41c:	1805c11e 	bne	r3,zero,8111fb24 <___vfprintf_internal_r+0x21f0>
8111e420:	94800414 	ori	r18,r18,16
8111e424:	9080080c 	andi	r2,r18,32
8111e428:	10020c26 	beq	r2,zero,8111ec5c <___vfprintf_internal_r+0x1328>
8111e42c:	d8802d17 	ldw	r2,180(sp)
8111e430:	d9002917 	ldw	r4,164(sp)
8111e434:	d8002785 	stb	zero,158(sp)
8111e438:	10c00204 	addi	r3,r2,8
8111e43c:	14c00017 	ldw	r19,0(r2)
8111e440:	15800117 	ldw	r22,4(r2)
8111e444:	20040f16 	blt	r4,zero,8111f484 <___vfprintf_internal_r+0x1b50>
8111e448:	013fdfc4 	movi	r4,-129
8111e44c:	9d84b03a 	or	r2,r19,r22
8111e450:	d8c02d15 	stw	r3,180(sp)
8111e454:	9124703a 	and	r18,r18,r4
8111e458:	0039883a 	mov	fp,zero
8111e45c:	103e891e 	bne	r2,zero,8111de84 <__reset+0xfb0fde84>
8111e460:	d9002917 	ldw	r4,164(sp)
8111e464:	2002c11e 	bne	r4,zero,8111ef6c <___vfprintf_internal_r+0x1638>
8111e468:	d8002915 	stw	zero,164(sp)
8111e46c:	d8002e15 	stw	zero,184(sp)
8111e470:	dc001e04 	addi	r16,sp,120
8111e474:	003ef806 	br	8111e058 <__reset+0xfb0fe058>
8111e478:	18c03fcc 	andi	r3,r3,255
8111e47c:	18059d1e 	bne	r3,zero,8111faf4 <___vfprintf_internal_r+0x21c0>
8111e480:	01604534 	movhi	r5,33044
8111e484:	29543a04 	addi	r5,r5,20712
8111e488:	d9403915 	stw	r5,228(sp)
8111e48c:	9080080c 	andi	r2,r18,32
8111e490:	10005226 	beq	r2,zero,8111e5dc <___vfprintf_internal_r+0xca8>
8111e494:	d8802d17 	ldw	r2,180(sp)
8111e498:	14c00017 	ldw	r19,0(r2)
8111e49c:	15800117 	ldw	r22,4(r2)
8111e4a0:	10800204 	addi	r2,r2,8
8111e4a4:	d8802d15 	stw	r2,180(sp)
8111e4a8:	9080004c 	andi	r2,r18,1
8111e4ac:	10019026 	beq	r2,zero,8111eaf0 <___vfprintf_internal_r+0x11bc>
8111e4b0:	9d84b03a 	or	r2,r19,r22
8111e4b4:	10036926 	beq	r2,zero,8111f25c <___vfprintf_internal_r+0x1928>
8111e4b8:	d8c02917 	ldw	r3,164(sp)
8111e4bc:	00800c04 	movi	r2,48
8111e4c0:	d8802705 	stb	r2,156(sp)
8111e4c4:	dc402745 	stb	r17,157(sp)
8111e4c8:	d8002785 	stb	zero,158(sp)
8111e4cc:	90800094 	ori	r2,r18,2
8111e4d0:	18045d16 	blt	r3,zero,8111f648 <___vfprintf_internal_r+0x1d14>
8111e4d4:	00bfdfc4 	movi	r2,-129
8111e4d8:	90a4703a 	and	r18,r18,r2
8111e4dc:	94800094 	ori	r18,r18,2
8111e4e0:	0039883a 	mov	fp,zero
8111e4e4:	d9003917 	ldw	r4,228(sp)
8111e4e8:	dc001e04 	addi	r16,sp,120
8111e4ec:	988003cc 	andi	r2,r19,15
8111e4f0:	b006973a 	slli	r3,r22,28
8111e4f4:	2085883a 	add	r2,r4,r2
8111e4f8:	9826d13a 	srli	r19,r19,4
8111e4fc:	10800003 	ldbu	r2,0(r2)
8111e500:	b02cd13a 	srli	r22,r22,4
8111e504:	843fffc4 	addi	r16,r16,-1
8111e508:	1ce6b03a 	or	r19,r3,r19
8111e50c:	80800005 	stb	r2,0(r16)
8111e510:	9d84b03a 	or	r2,r19,r22
8111e514:	103ff51e 	bne	r2,zero,8111e4ec <__reset+0xfb0fe4ec>
8111e518:	d8c02817 	ldw	r3,160(sp)
8111e51c:	1c07c83a 	sub	r3,r3,r16
8111e520:	d8c02e15 	stw	r3,184(sp)
8111e524:	003ecc06 	br	8111e058 <__reset+0xfb0fe058>
8111e528:	18c03fcc 	andi	r3,r3,255
8111e52c:	183e9f26 	beq	r3,zero,8111dfac <__reset+0xfb0fdfac>
8111e530:	d9c02785 	stb	r7,158(sp)
8111e534:	003e9d06 	br	8111dfac <__reset+0xfb0fdfac>
8111e538:	00c00044 	movi	r3,1
8111e53c:	01c00ac4 	movi	r7,43
8111e540:	ac400007 	ldb	r17,0(r21)
8111e544:	003d5e06 	br	8111dac0 <__reset+0xfb0fdac0>
8111e548:	94800814 	ori	r18,r18,32
8111e54c:	ac400007 	ldb	r17,0(r21)
8111e550:	003d5b06 	br	8111dac0 <__reset+0xfb0fdac0>
8111e554:	d8c02d17 	ldw	r3,180(sp)
8111e558:	d8002785 	stb	zero,158(sp)
8111e55c:	1c000017 	ldw	r16,0(r3)
8111e560:	1cc00104 	addi	r19,r3,4
8111e564:	80041926 	beq	r16,zero,8111f5cc <___vfprintf_internal_r+0x1c98>
8111e568:	d9002917 	ldw	r4,164(sp)
8111e56c:	2003d016 	blt	r4,zero,8111f4b0 <___vfprintf_internal_r+0x1b7c>
8111e570:	200d883a 	mov	r6,r4
8111e574:	000b883a 	mov	r5,zero
8111e578:	8009883a 	mov	r4,r16
8111e57c:	da003d15 	stw	r8,244(sp)
8111e580:	1124f5c0 	call	81124f5c <memchr>
8111e584:	da003d17 	ldw	r8,244(sp)
8111e588:	10045426 	beq	r2,zero,8111f6dc <___vfprintf_internal_r+0x1da8>
8111e58c:	1405c83a 	sub	r2,r2,r16
8111e590:	d8802e15 	stw	r2,184(sp)
8111e594:	1003cc16 	blt	r2,zero,8111f4c8 <___vfprintf_internal_r+0x1b94>
8111e598:	df002783 	ldbu	fp,158(sp)
8111e59c:	d8802a15 	stw	r2,168(sp)
8111e5a0:	dcc02d15 	stw	r19,180(sp)
8111e5a4:	d8002915 	stw	zero,164(sp)
8111e5a8:	d8003215 	stw	zero,200(sp)
8111e5ac:	003eb006 	br	8111e070 <__reset+0xfb0fe070>
8111e5b0:	18c03fcc 	andi	r3,r3,255
8111e5b4:	183f9b26 	beq	r3,zero,8111e424 <__reset+0xfb0fe424>
8111e5b8:	d9c02785 	stb	r7,158(sp)
8111e5bc:	003f9906 	br	8111e424 <__reset+0xfb0fe424>
8111e5c0:	18c03fcc 	andi	r3,r3,255
8111e5c4:	1805551e 	bne	r3,zero,8111fb1c <___vfprintf_internal_r+0x21e8>
8111e5c8:	01604534 	movhi	r5,33044
8111e5cc:	29543f04 	addi	r5,r5,20732
8111e5d0:	d9403915 	stw	r5,228(sp)
8111e5d4:	9080080c 	andi	r2,r18,32
8111e5d8:	103fae1e 	bne	r2,zero,8111e494 <__reset+0xfb0fe494>
8111e5dc:	9080040c 	andi	r2,r18,16
8111e5e0:	1002de26 	beq	r2,zero,8111f15c <___vfprintf_internal_r+0x1828>
8111e5e4:	d8c02d17 	ldw	r3,180(sp)
8111e5e8:	002d883a 	mov	r22,zero
8111e5ec:	1cc00017 	ldw	r19,0(r3)
8111e5f0:	18c00104 	addi	r3,r3,4
8111e5f4:	d8c02d15 	stw	r3,180(sp)
8111e5f8:	003fab06 	br	8111e4a8 <__reset+0xfb0fe4a8>
8111e5fc:	38803fcc 	andi	r2,r7,255
8111e600:	1080201c 	xori	r2,r2,128
8111e604:	10bfe004 	addi	r2,r2,-128
8111e608:	1002d21e 	bne	r2,zero,8111f154 <___vfprintf_internal_r+0x1820>
8111e60c:	00c00044 	movi	r3,1
8111e610:	01c00804 	movi	r7,32
8111e614:	ac400007 	ldb	r17,0(r21)
8111e618:	003d2906 	br	8111dac0 <__reset+0xfb0fdac0>
8111e61c:	94800054 	ori	r18,r18,1
8111e620:	ac400007 	ldb	r17,0(r21)
8111e624:	003d2606 	br	8111dac0 <__reset+0xfb0fdac0>
8111e628:	18c03fcc 	andi	r3,r3,255
8111e62c:	183e0526 	beq	r3,zero,8111de44 <__reset+0xfb0fde44>
8111e630:	d9c02785 	stb	r7,158(sp)
8111e634:	003e0306 	br	8111de44 <__reset+0xfb0fde44>
8111e638:	94801014 	ori	r18,r18,64
8111e63c:	ac400007 	ldb	r17,0(r21)
8111e640:	003d1f06 	br	8111dac0 <__reset+0xfb0fdac0>
8111e644:	ac400007 	ldb	r17,0(r21)
8111e648:	8a438726 	beq	r17,r9,8111f468 <___vfprintf_internal_r+0x1b34>
8111e64c:	94800414 	ori	r18,r18,16
8111e650:	003d1b06 	br	8111dac0 <__reset+0xfb0fdac0>
8111e654:	18c03fcc 	andi	r3,r3,255
8111e658:	1805341e 	bne	r3,zero,8111fb2c <___vfprintf_internal_r+0x21f8>
8111e65c:	9080080c 	andi	r2,r18,32
8111e660:	1002cd26 	beq	r2,zero,8111f198 <___vfprintf_internal_r+0x1864>
8111e664:	d9402d17 	ldw	r5,180(sp)
8111e668:	d9002f17 	ldw	r4,188(sp)
8111e66c:	28800017 	ldw	r2,0(r5)
8111e670:	2007d7fa 	srai	r3,r4,31
8111e674:	29400104 	addi	r5,r5,4
8111e678:	d9402d15 	stw	r5,180(sp)
8111e67c:	11000015 	stw	r4,0(r2)
8111e680:	10c00115 	stw	r3,4(r2)
8111e684:	003ce506 	br	8111da1c <__reset+0xfb0fda1c>
8111e688:	d8c02d17 	ldw	r3,180(sp)
8111e68c:	d9002d17 	ldw	r4,180(sp)
8111e690:	d8002785 	stb	zero,158(sp)
8111e694:	18800017 	ldw	r2,0(r3)
8111e698:	21000104 	addi	r4,r4,4
8111e69c:	00c00044 	movi	r3,1
8111e6a0:	d8c02a15 	stw	r3,168(sp)
8111e6a4:	d8801405 	stb	r2,80(sp)
8111e6a8:	d9002d15 	stw	r4,180(sp)
8111e6ac:	d8c02e15 	stw	r3,184(sp)
8111e6b0:	d8002915 	stw	zero,164(sp)
8111e6b4:	d8003215 	stw	zero,200(sp)
8111e6b8:	dc001404 	addi	r16,sp,80
8111e6bc:	0039883a 	mov	fp,zero
8111e6c0:	003e7206 	br	8111e08c <__reset+0xfb0fe08c>
8111e6c4:	01204534 	movhi	r4,33044
8111e6c8:	21143f04 	addi	r4,r4,20732
8111e6cc:	0039883a 	mov	fp,zero
8111e6d0:	d9003915 	stw	r4,228(sp)
8111e6d4:	04401e04 	movi	r17,120
8111e6d8:	003f8206 	br	8111e4e4 <__reset+0xfb0fe4e4>
8111e6dc:	18c03fcc 	andi	r3,r3,255
8111e6e0:	1805061e 	bne	r3,zero,8111fafc <___vfprintf_internal_r+0x21c8>
8111e6e4:	883d9126 	beq	r17,zero,8111dd2c <__reset+0xfb0fdd2c>
8111e6e8:	00c00044 	movi	r3,1
8111e6ec:	d8c02a15 	stw	r3,168(sp)
8111e6f0:	dc401405 	stb	r17,80(sp)
8111e6f4:	d8002785 	stb	zero,158(sp)
8111e6f8:	003fec06 	br	8111e6ac <__reset+0xfb0fe6ac>
8111e6fc:	01604534 	movhi	r5,33044
8111e700:	29543f04 	addi	r5,r5,20732
8111e704:	d9403915 	stw	r5,228(sp)
8111e708:	d8c02d15 	stw	r3,180(sp)
8111e70c:	1025883a 	mov	r18,r2
8111e710:	04401e04 	movi	r17,120
8111e714:	9d84b03a 	or	r2,r19,r22
8111e718:	1000fc1e 	bne	r2,zero,8111eb0c <___vfprintf_internal_r+0x11d8>
8111e71c:	0039883a 	mov	fp,zero
8111e720:	00800084 	movi	r2,2
8111e724:	10803fcc 	andi	r2,r2,255
8111e728:	00c00044 	movi	r3,1
8111e72c:	10c20f26 	beq	r2,r3,8111ef6c <___vfprintf_internal_r+0x1638>
8111e730:	00c00084 	movi	r3,2
8111e734:	10fd6326 	beq	r2,r3,8111dcc4 <__reset+0xfb0fdcc4>
8111e738:	003e2d06 	br	8111dff0 <__reset+0xfb0fdff0>
8111e73c:	d8c02017 	ldw	r3,128(sp)
8111e740:	003e9306 	br	8111e190 <__reset+0xfb0fe190>
8111e744:	00801944 	movi	r2,101
8111e748:	14407e0e 	bge	r2,r17,8111e944 <___vfprintf_internal_r+0x1010>
8111e74c:	d9003617 	ldw	r4,216(sp)
8111e750:	d9403817 	ldw	r5,224(sp)
8111e754:	000d883a 	mov	r6,zero
8111e758:	000f883a 	mov	r7,zero
8111e75c:	d8c03c15 	stw	r3,240(sp)
8111e760:	da003d15 	stw	r8,244(sp)
8111e764:	112ed400 	call	8112ed40 <__eqdf2>
8111e768:	d8c03c17 	ldw	r3,240(sp)
8111e76c:	da003d17 	ldw	r8,244(sp)
8111e770:	1000f71e 	bne	r2,zero,8111eb50 <___vfprintf_internal_r+0x121c>
8111e774:	d8801f17 	ldw	r2,124(sp)
8111e778:	01204534 	movhi	r4,33044
8111e77c:	21144604 	addi	r4,r4,20760
8111e780:	18c00044 	addi	r3,r3,1
8111e784:	10800044 	addi	r2,r2,1
8111e788:	41000015 	stw	r4,0(r8)
8111e78c:	01000044 	movi	r4,1
8111e790:	41000115 	stw	r4,4(r8)
8111e794:	d8c02015 	stw	r3,128(sp)
8111e798:	d8801f15 	stw	r2,124(sp)
8111e79c:	010001c4 	movi	r4,7
8111e7a0:	2082b816 	blt	r4,r2,8111f284 <___vfprintf_internal_r+0x1950>
8111e7a4:	42000204 	addi	r8,r8,8
8111e7a8:	d8802617 	ldw	r2,152(sp)
8111e7ac:	d9403317 	ldw	r5,204(sp)
8111e7b0:	11400216 	blt	r2,r5,8111e7bc <___vfprintf_internal_r+0xe88>
8111e7b4:	9080004c 	andi	r2,r18,1
8111e7b8:	103ed526 	beq	r2,zero,8111e310 <__reset+0xfb0fe310>
8111e7bc:	d8803717 	ldw	r2,220(sp)
8111e7c0:	d9003417 	ldw	r4,208(sp)
8111e7c4:	d9403717 	ldw	r5,220(sp)
8111e7c8:	1887883a 	add	r3,r3,r2
8111e7cc:	d8801f17 	ldw	r2,124(sp)
8111e7d0:	41000015 	stw	r4,0(r8)
8111e7d4:	41400115 	stw	r5,4(r8)
8111e7d8:	10800044 	addi	r2,r2,1
8111e7dc:	d8c02015 	stw	r3,128(sp)
8111e7e0:	d8801f15 	stw	r2,124(sp)
8111e7e4:	010001c4 	movi	r4,7
8111e7e8:	20832916 	blt	r4,r2,8111f490 <___vfprintf_internal_r+0x1b5c>
8111e7ec:	42000204 	addi	r8,r8,8
8111e7f0:	d8803317 	ldw	r2,204(sp)
8111e7f4:	143fffc4 	addi	r16,r2,-1
8111e7f8:	043ec50e 	bge	zero,r16,8111e310 <__reset+0xfb0fe310>
8111e7fc:	04400404 	movi	r17,16
8111e800:	d8801f17 	ldw	r2,124(sp)
8111e804:	8c00880e 	bge	r17,r16,8111ea28 <___vfprintf_internal_r+0x10f4>
8111e808:	01604534 	movhi	r5,33044
8111e80c:	29544e84 	addi	r5,r5,20794
8111e810:	d9402b15 	stw	r5,172(sp)
8111e814:	058001c4 	movi	r22,7
8111e818:	dcc02c17 	ldw	r19,176(sp)
8111e81c:	00000306 	br	8111e82c <___vfprintf_internal_r+0xef8>
8111e820:	42000204 	addi	r8,r8,8
8111e824:	843ffc04 	addi	r16,r16,-16
8111e828:	8c00820e 	bge	r17,r16,8111ea34 <___vfprintf_internal_r+0x1100>
8111e82c:	18c00404 	addi	r3,r3,16
8111e830:	10800044 	addi	r2,r2,1
8111e834:	45000015 	stw	r20,0(r8)
8111e838:	44400115 	stw	r17,4(r8)
8111e83c:	d8c02015 	stw	r3,128(sp)
8111e840:	d8801f15 	stw	r2,124(sp)
8111e844:	b0bff60e 	bge	r22,r2,8111e820 <__reset+0xfb0fe820>
8111e848:	d9801e04 	addi	r6,sp,120
8111e84c:	b80b883a 	mov	r5,r23
8111e850:	9809883a 	mov	r4,r19
8111e854:	112a1c00 	call	8112a1c0 <__sprint_r>
8111e858:	103d3a1e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111e85c:	d8c02017 	ldw	r3,128(sp)
8111e860:	d8801f17 	ldw	r2,124(sp)
8111e864:	da000404 	addi	r8,sp,16
8111e868:	003fee06 	br	8111e824 <__reset+0xfb0fe824>
8111e86c:	d9403117 	ldw	r5,196(sp)
8111e870:	d8802a17 	ldw	r2,168(sp)
8111e874:	28adc83a 	sub	r22,r5,r2
8111e878:	05be630e 	bge	zero,r22,8111e208 <__reset+0xfb0fe208>
8111e87c:	07000404 	movi	fp,16
8111e880:	d8801f17 	ldw	r2,124(sp)
8111e884:	e5838f0e 	bge	fp,r22,8111f6c4 <___vfprintf_internal_r+0x1d90>
8111e888:	01604534 	movhi	r5,33044
8111e88c:	29544e84 	addi	r5,r5,20794
8111e890:	dc403015 	stw	r17,192(sp)
8111e894:	d9402b15 	stw	r5,172(sp)
8111e898:	b023883a 	mov	r17,r22
8111e89c:	04c001c4 	movi	r19,7
8111e8a0:	a82d883a 	mov	r22,r21
8111e8a4:	902b883a 	mov	r21,r18
8111e8a8:	8025883a 	mov	r18,r16
8111e8ac:	dc002c17 	ldw	r16,176(sp)
8111e8b0:	00000306 	br	8111e8c0 <___vfprintf_internal_r+0xf8c>
8111e8b4:	8c7ffc04 	addi	r17,r17,-16
8111e8b8:	42000204 	addi	r8,r8,8
8111e8bc:	e440110e 	bge	fp,r17,8111e904 <___vfprintf_internal_r+0xfd0>
8111e8c0:	18c00404 	addi	r3,r3,16
8111e8c4:	10800044 	addi	r2,r2,1
8111e8c8:	45000015 	stw	r20,0(r8)
8111e8cc:	47000115 	stw	fp,4(r8)
8111e8d0:	d8c02015 	stw	r3,128(sp)
8111e8d4:	d8801f15 	stw	r2,124(sp)
8111e8d8:	98bff60e 	bge	r19,r2,8111e8b4 <__reset+0xfb0fe8b4>
8111e8dc:	d9801e04 	addi	r6,sp,120
8111e8e0:	b80b883a 	mov	r5,r23
8111e8e4:	8009883a 	mov	r4,r16
8111e8e8:	112a1c00 	call	8112a1c0 <__sprint_r>
8111e8ec:	103d151e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111e8f0:	8c7ffc04 	addi	r17,r17,-16
8111e8f4:	d8c02017 	ldw	r3,128(sp)
8111e8f8:	d8801f17 	ldw	r2,124(sp)
8111e8fc:	da000404 	addi	r8,sp,16
8111e900:	e47fef16 	blt	fp,r17,8111e8c0 <__reset+0xfb0fe8c0>
8111e904:	9021883a 	mov	r16,r18
8111e908:	a825883a 	mov	r18,r21
8111e90c:	b02b883a 	mov	r21,r22
8111e910:	882d883a 	mov	r22,r17
8111e914:	dc403017 	ldw	r17,192(sp)
8111e918:	d9002b17 	ldw	r4,172(sp)
8111e91c:	1d87883a 	add	r3,r3,r22
8111e920:	10800044 	addi	r2,r2,1
8111e924:	41000015 	stw	r4,0(r8)
8111e928:	45800115 	stw	r22,4(r8)
8111e92c:	d8c02015 	stw	r3,128(sp)
8111e930:	d8801f15 	stw	r2,124(sp)
8111e934:	010001c4 	movi	r4,7
8111e938:	20818e16 	blt	r4,r2,8111ef74 <___vfprintf_internal_r+0x1640>
8111e93c:	42000204 	addi	r8,r8,8
8111e940:	003e3106 	br	8111e208 <__reset+0xfb0fe208>
8111e944:	d9403317 	ldw	r5,204(sp)
8111e948:	00800044 	movi	r2,1
8111e94c:	18c00044 	addi	r3,r3,1
8111e950:	1141530e 	bge	r2,r5,8111eea0 <___vfprintf_internal_r+0x156c>
8111e954:	dc401f17 	ldw	r17,124(sp)
8111e958:	00800044 	movi	r2,1
8111e95c:	40800115 	stw	r2,4(r8)
8111e960:	8c400044 	addi	r17,r17,1
8111e964:	44000015 	stw	r16,0(r8)
8111e968:	d8c02015 	stw	r3,128(sp)
8111e96c:	dc401f15 	stw	r17,124(sp)
8111e970:	008001c4 	movi	r2,7
8111e974:	14416b16 	blt	r2,r17,8111ef24 <___vfprintf_internal_r+0x15f0>
8111e978:	42000204 	addi	r8,r8,8
8111e97c:	d8803717 	ldw	r2,220(sp)
8111e980:	d9003417 	ldw	r4,208(sp)
8111e984:	8c400044 	addi	r17,r17,1
8111e988:	10c7883a 	add	r3,r2,r3
8111e98c:	40800115 	stw	r2,4(r8)
8111e990:	41000015 	stw	r4,0(r8)
8111e994:	d8c02015 	stw	r3,128(sp)
8111e998:	dc401f15 	stw	r17,124(sp)
8111e99c:	008001c4 	movi	r2,7
8111e9a0:	14416916 	blt	r2,r17,8111ef48 <___vfprintf_internal_r+0x1614>
8111e9a4:	45800204 	addi	r22,r8,8
8111e9a8:	d9003617 	ldw	r4,216(sp)
8111e9ac:	d9403817 	ldw	r5,224(sp)
8111e9b0:	000d883a 	mov	r6,zero
8111e9b4:	000f883a 	mov	r7,zero
8111e9b8:	d8c03c15 	stw	r3,240(sp)
8111e9bc:	112ed400 	call	8112ed40 <__eqdf2>
8111e9c0:	d8c03c17 	ldw	r3,240(sp)
8111e9c4:	1000bc26 	beq	r2,zero,8111ecb8 <___vfprintf_internal_r+0x1384>
8111e9c8:	d9403317 	ldw	r5,204(sp)
8111e9cc:	84000044 	addi	r16,r16,1
8111e9d0:	8c400044 	addi	r17,r17,1
8111e9d4:	28bfffc4 	addi	r2,r5,-1
8111e9d8:	1887883a 	add	r3,r3,r2
8111e9dc:	b0800115 	stw	r2,4(r22)
8111e9e0:	b4000015 	stw	r16,0(r22)
8111e9e4:	d8c02015 	stw	r3,128(sp)
8111e9e8:	dc401f15 	stw	r17,124(sp)
8111e9ec:	008001c4 	movi	r2,7
8111e9f0:	14414316 	blt	r2,r17,8111ef00 <___vfprintf_internal_r+0x15cc>
8111e9f4:	b5800204 	addi	r22,r22,8
8111e9f8:	d9003a17 	ldw	r4,232(sp)
8111e9fc:	df0022c4 	addi	fp,sp,139
8111ea00:	8c400044 	addi	r17,r17,1
8111ea04:	20c7883a 	add	r3,r4,r3
8111ea08:	b7000015 	stw	fp,0(r22)
8111ea0c:	b1000115 	stw	r4,4(r22)
8111ea10:	d8c02015 	stw	r3,128(sp)
8111ea14:	dc401f15 	stw	r17,124(sp)
8111ea18:	008001c4 	movi	r2,7
8111ea1c:	14400e16 	blt	r2,r17,8111ea58 <___vfprintf_internal_r+0x1124>
8111ea20:	b2000204 	addi	r8,r22,8
8111ea24:	003e3a06 	br	8111e310 <__reset+0xfb0fe310>
8111ea28:	01204534 	movhi	r4,33044
8111ea2c:	21144e84 	addi	r4,r4,20794
8111ea30:	d9002b15 	stw	r4,172(sp)
8111ea34:	d9002b17 	ldw	r4,172(sp)
8111ea38:	1c07883a 	add	r3,r3,r16
8111ea3c:	44000115 	stw	r16,4(r8)
8111ea40:	41000015 	stw	r4,0(r8)
8111ea44:	10800044 	addi	r2,r2,1
8111ea48:	d8c02015 	stw	r3,128(sp)
8111ea4c:	d8801f15 	stw	r2,124(sp)
8111ea50:	010001c4 	movi	r4,7
8111ea54:	20be2d0e 	bge	r4,r2,8111e30c <__reset+0xfb0fe30c>
8111ea58:	d9002c17 	ldw	r4,176(sp)
8111ea5c:	d9801e04 	addi	r6,sp,120
8111ea60:	b80b883a 	mov	r5,r23
8111ea64:	112a1c00 	call	8112a1c0 <__sprint_r>
8111ea68:	103cb61e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111ea6c:	d8c02017 	ldw	r3,128(sp)
8111ea70:	da000404 	addi	r8,sp,16
8111ea74:	003e2606 	br	8111e310 <__reset+0xfb0fe310>
8111ea78:	d9002c17 	ldw	r4,176(sp)
8111ea7c:	d9801e04 	addi	r6,sp,120
8111ea80:	b80b883a 	mov	r5,r23
8111ea84:	112a1c00 	call	8112a1c0 <__sprint_r>
8111ea88:	103e5d26 	beq	r2,zero,8111e400 <__reset+0xfb0fe400>
8111ea8c:	003cad06 	br	8111dd44 <__reset+0xfb0fdd44>
8111ea90:	d9002c17 	ldw	r4,176(sp)
8111ea94:	d9801e04 	addi	r6,sp,120
8111ea98:	b80b883a 	mov	r5,r23
8111ea9c:	112a1c00 	call	8112a1c0 <__sprint_r>
8111eaa0:	103ca81e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111eaa4:	d8c02017 	ldw	r3,128(sp)
8111eaa8:	da000404 	addi	r8,sp,16
8111eaac:	003e0b06 	br	8111e2dc <__reset+0xfb0fe2dc>
8111eab0:	d9002c17 	ldw	r4,176(sp)
8111eab4:	d9801e04 	addi	r6,sp,120
8111eab8:	b80b883a 	mov	r5,r23
8111eabc:	112a1c00 	call	8112a1c0 <__sprint_r>
8111eac0:	103ca01e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111eac4:	d8c02017 	ldw	r3,128(sp)
8111eac8:	da000404 	addi	r8,sp,16
8111eacc:	003dbd06 	br	8111e1c4 <__reset+0xfb0fe1c4>
8111ead0:	d9002c17 	ldw	r4,176(sp)
8111ead4:	d9801e04 	addi	r6,sp,120
8111ead8:	b80b883a 	mov	r5,r23
8111eadc:	112a1c00 	call	8112a1c0 <__sprint_r>
8111eae0:	103c981e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111eae4:	d8c02017 	ldw	r3,128(sp)
8111eae8:	da000404 	addi	r8,sp,16
8111eaec:	003dc306 	br	8111e1fc <__reset+0xfb0fe1fc>
8111eaf0:	d8802917 	ldw	r2,164(sp)
8111eaf4:	d8002785 	stb	zero,158(sp)
8111eaf8:	103f0616 	blt	r2,zero,8111e714 <__reset+0xfb0fe714>
8111eafc:	00ffdfc4 	movi	r3,-129
8111eb00:	9d84b03a 	or	r2,r19,r22
8111eb04:	90e4703a 	and	r18,r18,r3
8111eb08:	103c6b26 	beq	r2,zero,8111dcb8 <__reset+0xfb0fdcb8>
8111eb0c:	0039883a 	mov	fp,zero
8111eb10:	003e7406 	br	8111e4e4 <__reset+0xfb0fe4e4>
8111eb14:	9080040c 	andi	r2,r18,16
8111eb18:	1001b326 	beq	r2,zero,8111f1e8 <___vfprintf_internal_r+0x18b4>
8111eb1c:	d9002d17 	ldw	r4,180(sp)
8111eb20:	d9402917 	ldw	r5,164(sp)
8111eb24:	d8002785 	stb	zero,158(sp)
8111eb28:	20800104 	addi	r2,r4,4
8111eb2c:	24c00017 	ldw	r19,0(r4)
8111eb30:	002d883a 	mov	r22,zero
8111eb34:	2801b516 	blt	r5,zero,8111f20c <___vfprintf_internal_r+0x18d8>
8111eb38:	00ffdfc4 	movi	r3,-129
8111eb3c:	d8802d15 	stw	r2,180(sp)
8111eb40:	90e4703a 	and	r18,r18,r3
8111eb44:	983d2726 	beq	r19,zero,8111dfe4 <__reset+0xfb0fdfe4>
8111eb48:	0039883a 	mov	fp,zero
8111eb4c:	003d2a06 	br	8111dff8 <__reset+0xfb0fdff8>
8111eb50:	dc402617 	ldw	r17,152(sp)
8111eb54:	0441d30e 	bge	zero,r17,8111f2a4 <___vfprintf_internal_r+0x1970>
8111eb58:	dc403217 	ldw	r17,200(sp)
8111eb5c:	d8803317 	ldw	r2,204(sp)
8111eb60:	1440010e 	bge	r2,r17,8111eb68 <___vfprintf_internal_r+0x1234>
8111eb64:	1023883a 	mov	r17,r2
8111eb68:	04400a0e 	bge	zero,r17,8111eb94 <___vfprintf_internal_r+0x1260>
8111eb6c:	d8801f17 	ldw	r2,124(sp)
8111eb70:	1c47883a 	add	r3,r3,r17
8111eb74:	44000015 	stw	r16,0(r8)
8111eb78:	10800044 	addi	r2,r2,1
8111eb7c:	44400115 	stw	r17,4(r8)
8111eb80:	d8c02015 	stw	r3,128(sp)
8111eb84:	d8801f15 	stw	r2,124(sp)
8111eb88:	010001c4 	movi	r4,7
8111eb8c:	20826516 	blt	r4,r2,8111f524 <___vfprintf_internal_r+0x1bf0>
8111eb90:	42000204 	addi	r8,r8,8
8111eb94:	88026116 	blt	r17,zero,8111f51c <___vfprintf_internal_r+0x1be8>
8111eb98:	d9003217 	ldw	r4,200(sp)
8111eb9c:	2463c83a 	sub	r17,r4,r17
8111eba0:	04407b0e 	bge	zero,r17,8111ed90 <___vfprintf_internal_r+0x145c>
8111eba4:	05800404 	movi	r22,16
8111eba8:	d8801f17 	ldw	r2,124(sp)
8111ebac:	b4419d0e 	bge	r22,r17,8111f224 <___vfprintf_internal_r+0x18f0>
8111ebb0:	01204534 	movhi	r4,33044
8111ebb4:	21144e84 	addi	r4,r4,20794
8111ebb8:	d9002b15 	stw	r4,172(sp)
8111ebbc:	070001c4 	movi	fp,7
8111ebc0:	dcc02c17 	ldw	r19,176(sp)
8111ebc4:	00000306 	br	8111ebd4 <___vfprintf_internal_r+0x12a0>
8111ebc8:	42000204 	addi	r8,r8,8
8111ebcc:	8c7ffc04 	addi	r17,r17,-16
8111ebd0:	b441970e 	bge	r22,r17,8111f230 <___vfprintf_internal_r+0x18fc>
8111ebd4:	18c00404 	addi	r3,r3,16
8111ebd8:	10800044 	addi	r2,r2,1
8111ebdc:	45000015 	stw	r20,0(r8)
8111ebe0:	45800115 	stw	r22,4(r8)
8111ebe4:	d8c02015 	stw	r3,128(sp)
8111ebe8:	d8801f15 	stw	r2,124(sp)
8111ebec:	e0bff60e 	bge	fp,r2,8111ebc8 <__reset+0xfb0febc8>
8111ebf0:	d9801e04 	addi	r6,sp,120
8111ebf4:	b80b883a 	mov	r5,r23
8111ebf8:	9809883a 	mov	r4,r19
8111ebfc:	112a1c00 	call	8112a1c0 <__sprint_r>
8111ec00:	103c501e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111ec04:	d8c02017 	ldw	r3,128(sp)
8111ec08:	d8801f17 	ldw	r2,124(sp)
8111ec0c:	da000404 	addi	r8,sp,16
8111ec10:	003fee06 	br	8111ebcc <__reset+0xfb0febcc>
8111ec14:	d9002c17 	ldw	r4,176(sp)
8111ec18:	d9801e04 	addi	r6,sp,120
8111ec1c:	b80b883a 	mov	r5,r23
8111ec20:	112a1c00 	call	8112a1c0 <__sprint_r>
8111ec24:	103c471e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111ec28:	d8c02017 	ldw	r3,128(sp)
8111ec2c:	df002787 	ldb	fp,158(sp)
8111ec30:	da000404 	addi	r8,sp,16
8111ec34:	003d5606 	br	8111e190 <__reset+0xfb0fe190>
8111ec38:	9080040c 	andi	r2,r18,16
8111ec3c:	10016126 	beq	r2,zero,8111f1c4 <___vfprintf_internal_r+0x1890>
8111ec40:	d8802d17 	ldw	r2,180(sp)
8111ec44:	14c00017 	ldw	r19,0(r2)
8111ec48:	10800104 	addi	r2,r2,4
8111ec4c:	d8802d15 	stw	r2,180(sp)
8111ec50:	982dd7fa 	srai	r22,r19,31
8111ec54:	b005883a 	mov	r2,r22
8111ec58:	003c8206 	br	8111de64 <__reset+0xfb0fde64>
8111ec5c:	9080040c 	andi	r2,r18,16
8111ec60:	10003526 	beq	r2,zero,8111ed38 <___vfprintf_internal_r+0x1404>
8111ec64:	d9402d17 	ldw	r5,180(sp)
8111ec68:	d8c02917 	ldw	r3,164(sp)
8111ec6c:	d8002785 	stb	zero,158(sp)
8111ec70:	28800104 	addi	r2,r5,4
8111ec74:	2cc00017 	ldw	r19,0(r5)
8111ec78:	002d883a 	mov	r22,zero
8111ec7c:	18003716 	blt	r3,zero,8111ed5c <___vfprintf_internal_r+0x1428>
8111ec80:	00ffdfc4 	movi	r3,-129
8111ec84:	d8802d15 	stw	r2,180(sp)
8111ec88:	90e4703a 	and	r18,r18,r3
8111ec8c:	0039883a 	mov	fp,zero
8111ec90:	983df326 	beq	r19,zero,8111e460 <__reset+0xfb0fe460>
8111ec94:	00800244 	movi	r2,9
8111ec98:	14fc7b36 	bltu	r2,r19,8111de88 <__reset+0xfb0fde88>
8111ec9c:	d8c02817 	ldw	r3,160(sp)
8111eca0:	dc001dc4 	addi	r16,sp,119
8111eca4:	9cc00c04 	addi	r19,r19,48
8111eca8:	1c07c83a 	sub	r3,r3,r16
8111ecac:	dcc01dc5 	stb	r19,119(sp)
8111ecb0:	d8c02e15 	stw	r3,184(sp)
8111ecb4:	003ce806 	br	8111e058 <__reset+0xfb0fe058>
8111ecb8:	d8803317 	ldw	r2,204(sp)
8111ecbc:	143fffc4 	addi	r16,r2,-1
8111ecc0:	043f4d0e 	bge	zero,r16,8111e9f8 <__reset+0xfb0fe9f8>
8111ecc4:	07000404 	movi	fp,16
8111ecc8:	e400810e 	bge	fp,r16,8111eed0 <___vfprintf_internal_r+0x159c>
8111eccc:	01604534 	movhi	r5,33044
8111ecd0:	29544e84 	addi	r5,r5,20794
8111ecd4:	d9402b15 	stw	r5,172(sp)
8111ecd8:	01c001c4 	movi	r7,7
8111ecdc:	dcc02c17 	ldw	r19,176(sp)
8111ece0:	00000306 	br	8111ecf0 <___vfprintf_internal_r+0x13bc>
8111ece4:	b5800204 	addi	r22,r22,8
8111ece8:	843ffc04 	addi	r16,r16,-16
8111ecec:	e4007b0e 	bge	fp,r16,8111eedc <___vfprintf_internal_r+0x15a8>
8111ecf0:	18c00404 	addi	r3,r3,16
8111ecf4:	8c400044 	addi	r17,r17,1
8111ecf8:	b5000015 	stw	r20,0(r22)
8111ecfc:	b7000115 	stw	fp,4(r22)
8111ed00:	d8c02015 	stw	r3,128(sp)
8111ed04:	dc401f15 	stw	r17,124(sp)
8111ed08:	3c7ff60e 	bge	r7,r17,8111ece4 <__reset+0xfb0fece4>
8111ed0c:	d9801e04 	addi	r6,sp,120
8111ed10:	b80b883a 	mov	r5,r23
8111ed14:	9809883a 	mov	r4,r19
8111ed18:	d9c03c15 	stw	r7,240(sp)
8111ed1c:	112a1c00 	call	8112a1c0 <__sprint_r>
8111ed20:	d9c03c17 	ldw	r7,240(sp)
8111ed24:	103c071e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111ed28:	d8c02017 	ldw	r3,128(sp)
8111ed2c:	dc401f17 	ldw	r17,124(sp)
8111ed30:	dd800404 	addi	r22,sp,16
8111ed34:	003fec06 	br	8111ece8 <__reset+0xfb0fece8>
8111ed38:	9080100c 	andi	r2,r18,64
8111ed3c:	d8002785 	stb	zero,158(sp)
8111ed40:	10010e26 	beq	r2,zero,8111f17c <___vfprintf_internal_r+0x1848>
8111ed44:	d9002d17 	ldw	r4,180(sp)
8111ed48:	d9402917 	ldw	r5,164(sp)
8111ed4c:	002d883a 	mov	r22,zero
8111ed50:	20800104 	addi	r2,r4,4
8111ed54:	24c0000b 	ldhu	r19,0(r4)
8111ed58:	283fc90e 	bge	r5,zero,8111ec80 <__reset+0xfb0fec80>
8111ed5c:	d8802d15 	stw	r2,180(sp)
8111ed60:	0039883a 	mov	fp,zero
8111ed64:	9d84b03a 	or	r2,r19,r22
8111ed68:	103c461e 	bne	r2,zero,8111de84 <__reset+0xfb0fde84>
8111ed6c:	00800044 	movi	r2,1
8111ed70:	003e6c06 	br	8111e724 <__reset+0xfb0fe724>
8111ed74:	d9002c17 	ldw	r4,176(sp)
8111ed78:	d9801e04 	addi	r6,sp,120
8111ed7c:	b80b883a 	mov	r5,r23
8111ed80:	112a1c00 	call	8112a1c0 <__sprint_r>
8111ed84:	103bef1e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111ed88:	d8c02017 	ldw	r3,128(sp)
8111ed8c:	da000404 	addi	r8,sp,16
8111ed90:	d9003217 	ldw	r4,200(sp)
8111ed94:	d8802617 	ldw	r2,152(sp)
8111ed98:	d9403317 	ldw	r5,204(sp)
8111ed9c:	8123883a 	add	r17,r16,r4
8111eda0:	11400216 	blt	r2,r5,8111edac <___vfprintf_internal_r+0x1478>
8111eda4:	9100004c 	andi	r4,r18,1
8111eda8:	20000d26 	beq	r4,zero,8111ede0 <___vfprintf_internal_r+0x14ac>
8111edac:	d9003717 	ldw	r4,220(sp)
8111edb0:	d9403417 	ldw	r5,208(sp)
8111edb4:	1907883a 	add	r3,r3,r4
8111edb8:	d9001f17 	ldw	r4,124(sp)
8111edbc:	41400015 	stw	r5,0(r8)
8111edc0:	d9403717 	ldw	r5,220(sp)
8111edc4:	21000044 	addi	r4,r4,1
8111edc8:	d8c02015 	stw	r3,128(sp)
8111edcc:	41400115 	stw	r5,4(r8)
8111edd0:	d9001f15 	stw	r4,124(sp)
8111edd4:	014001c4 	movi	r5,7
8111edd8:	2901e816 	blt	r5,r4,8111f57c <___vfprintf_internal_r+0x1c48>
8111eddc:	42000204 	addi	r8,r8,8
8111ede0:	d9003317 	ldw	r4,204(sp)
8111ede4:	8121883a 	add	r16,r16,r4
8111ede8:	2085c83a 	sub	r2,r4,r2
8111edec:	8461c83a 	sub	r16,r16,r17
8111edf0:	1400010e 	bge	r2,r16,8111edf8 <___vfprintf_internal_r+0x14c4>
8111edf4:	1021883a 	mov	r16,r2
8111edf8:	04000a0e 	bge	zero,r16,8111ee24 <___vfprintf_internal_r+0x14f0>
8111edfc:	d9001f17 	ldw	r4,124(sp)
8111ee00:	1c07883a 	add	r3,r3,r16
8111ee04:	44400015 	stw	r17,0(r8)
8111ee08:	21000044 	addi	r4,r4,1
8111ee0c:	44000115 	stw	r16,4(r8)
8111ee10:	d8c02015 	stw	r3,128(sp)
8111ee14:	d9001f15 	stw	r4,124(sp)
8111ee18:	014001c4 	movi	r5,7
8111ee1c:	2901fb16 	blt	r5,r4,8111f60c <___vfprintf_internal_r+0x1cd8>
8111ee20:	42000204 	addi	r8,r8,8
8111ee24:	8001f716 	blt	r16,zero,8111f604 <___vfprintf_internal_r+0x1cd0>
8111ee28:	1421c83a 	sub	r16,r2,r16
8111ee2c:	043d380e 	bge	zero,r16,8111e310 <__reset+0xfb0fe310>
8111ee30:	04400404 	movi	r17,16
8111ee34:	d8801f17 	ldw	r2,124(sp)
8111ee38:	8c3efb0e 	bge	r17,r16,8111ea28 <__reset+0xfb0fea28>
8111ee3c:	01604534 	movhi	r5,33044
8111ee40:	29544e84 	addi	r5,r5,20794
8111ee44:	d9402b15 	stw	r5,172(sp)
8111ee48:	058001c4 	movi	r22,7
8111ee4c:	dcc02c17 	ldw	r19,176(sp)
8111ee50:	00000306 	br	8111ee60 <___vfprintf_internal_r+0x152c>
8111ee54:	42000204 	addi	r8,r8,8
8111ee58:	843ffc04 	addi	r16,r16,-16
8111ee5c:	8c3ef50e 	bge	r17,r16,8111ea34 <__reset+0xfb0fea34>
8111ee60:	18c00404 	addi	r3,r3,16
8111ee64:	10800044 	addi	r2,r2,1
8111ee68:	45000015 	stw	r20,0(r8)
8111ee6c:	44400115 	stw	r17,4(r8)
8111ee70:	d8c02015 	stw	r3,128(sp)
8111ee74:	d8801f15 	stw	r2,124(sp)
8111ee78:	b0bff60e 	bge	r22,r2,8111ee54 <__reset+0xfb0fee54>
8111ee7c:	d9801e04 	addi	r6,sp,120
8111ee80:	b80b883a 	mov	r5,r23
8111ee84:	9809883a 	mov	r4,r19
8111ee88:	112a1c00 	call	8112a1c0 <__sprint_r>
8111ee8c:	103bad1e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111ee90:	d8c02017 	ldw	r3,128(sp)
8111ee94:	d8801f17 	ldw	r2,124(sp)
8111ee98:	da000404 	addi	r8,sp,16
8111ee9c:	003fee06 	br	8111ee58 <__reset+0xfb0fee58>
8111eea0:	9088703a 	and	r4,r18,r2
8111eea4:	203eab1e 	bne	r4,zero,8111e954 <__reset+0xfb0fe954>
8111eea8:	dc401f17 	ldw	r17,124(sp)
8111eeac:	40800115 	stw	r2,4(r8)
8111eeb0:	44000015 	stw	r16,0(r8)
8111eeb4:	8c400044 	addi	r17,r17,1
8111eeb8:	d8c02015 	stw	r3,128(sp)
8111eebc:	dc401f15 	stw	r17,124(sp)
8111eec0:	008001c4 	movi	r2,7
8111eec4:	14400e16 	blt	r2,r17,8111ef00 <___vfprintf_internal_r+0x15cc>
8111eec8:	45800204 	addi	r22,r8,8
8111eecc:	003eca06 	br	8111e9f8 <__reset+0xfb0fe9f8>
8111eed0:	01204534 	movhi	r4,33044
8111eed4:	21144e84 	addi	r4,r4,20794
8111eed8:	d9002b15 	stw	r4,172(sp)
8111eedc:	d8802b17 	ldw	r2,172(sp)
8111eee0:	1c07883a 	add	r3,r3,r16
8111eee4:	8c400044 	addi	r17,r17,1
8111eee8:	b0800015 	stw	r2,0(r22)
8111eeec:	b4000115 	stw	r16,4(r22)
8111eef0:	d8c02015 	stw	r3,128(sp)
8111eef4:	dc401f15 	stw	r17,124(sp)
8111eef8:	008001c4 	movi	r2,7
8111eefc:	147ebd0e 	bge	r2,r17,8111e9f4 <__reset+0xfb0fe9f4>
8111ef00:	d9002c17 	ldw	r4,176(sp)
8111ef04:	d9801e04 	addi	r6,sp,120
8111ef08:	b80b883a 	mov	r5,r23
8111ef0c:	112a1c00 	call	8112a1c0 <__sprint_r>
8111ef10:	103b8c1e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111ef14:	d8c02017 	ldw	r3,128(sp)
8111ef18:	dc401f17 	ldw	r17,124(sp)
8111ef1c:	dd800404 	addi	r22,sp,16
8111ef20:	003eb506 	br	8111e9f8 <__reset+0xfb0fe9f8>
8111ef24:	d9002c17 	ldw	r4,176(sp)
8111ef28:	d9801e04 	addi	r6,sp,120
8111ef2c:	b80b883a 	mov	r5,r23
8111ef30:	112a1c00 	call	8112a1c0 <__sprint_r>
8111ef34:	103b831e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111ef38:	d8c02017 	ldw	r3,128(sp)
8111ef3c:	dc401f17 	ldw	r17,124(sp)
8111ef40:	da000404 	addi	r8,sp,16
8111ef44:	003e8d06 	br	8111e97c <__reset+0xfb0fe97c>
8111ef48:	d9002c17 	ldw	r4,176(sp)
8111ef4c:	d9801e04 	addi	r6,sp,120
8111ef50:	b80b883a 	mov	r5,r23
8111ef54:	112a1c00 	call	8112a1c0 <__sprint_r>
8111ef58:	103b7a1e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111ef5c:	d8c02017 	ldw	r3,128(sp)
8111ef60:	dc401f17 	ldw	r17,124(sp)
8111ef64:	dd800404 	addi	r22,sp,16
8111ef68:	003e8f06 	br	8111e9a8 <__reset+0xfb0fe9a8>
8111ef6c:	0027883a 	mov	r19,zero
8111ef70:	003f4a06 	br	8111ec9c <__reset+0xfb0fec9c>
8111ef74:	d9002c17 	ldw	r4,176(sp)
8111ef78:	d9801e04 	addi	r6,sp,120
8111ef7c:	b80b883a 	mov	r5,r23
8111ef80:	112a1c00 	call	8112a1c0 <__sprint_r>
8111ef84:	103b6f1e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111ef88:	d8c02017 	ldw	r3,128(sp)
8111ef8c:	da000404 	addi	r8,sp,16
8111ef90:	003c9d06 	br	8111e208 <__reset+0xfb0fe208>
8111ef94:	04e7c83a 	sub	r19,zero,r19
8111ef98:	9804c03a 	cmpne	r2,r19,zero
8111ef9c:	05adc83a 	sub	r22,zero,r22
8111efa0:	b0adc83a 	sub	r22,r22,r2
8111efa4:	d8802917 	ldw	r2,164(sp)
8111efa8:	07000b44 	movi	fp,45
8111efac:	df002785 	stb	fp,158(sp)
8111efb0:	10017b16 	blt	r2,zero,8111f5a0 <___vfprintf_internal_r+0x1c6c>
8111efb4:	00bfdfc4 	movi	r2,-129
8111efb8:	90a4703a 	and	r18,r18,r2
8111efbc:	003bb106 	br	8111de84 <__reset+0xfb0fde84>
8111efc0:	d9003617 	ldw	r4,216(sp)
8111efc4:	d9403817 	ldw	r5,224(sp)
8111efc8:	da003d15 	stw	r8,244(sp)
8111efcc:	112695c0 	call	8112695c <__fpclassifyd>
8111efd0:	da003d17 	ldw	r8,244(sp)
8111efd4:	1000f026 	beq	r2,zero,8111f398 <___vfprintf_internal_r+0x1a64>
8111efd8:	d9002917 	ldw	r4,164(sp)
8111efdc:	05bff7c4 	movi	r22,-33
8111efe0:	00bfffc4 	movi	r2,-1
8111efe4:	8dac703a 	and	r22,r17,r22
8111efe8:	20820026 	beq	r4,r2,8111f7ec <___vfprintf_internal_r+0x1eb8>
8111efec:	008011c4 	movi	r2,71
8111eff0:	b081f726 	beq	r22,r2,8111f7d0 <___vfprintf_internal_r+0x1e9c>
8111eff4:	d9003817 	ldw	r4,224(sp)
8111eff8:	90c04014 	ori	r3,r18,256
8111effc:	d8c02b15 	stw	r3,172(sp)
8111f000:	20021516 	blt	r4,zero,8111f858 <___vfprintf_internal_r+0x1f24>
8111f004:	dcc03817 	ldw	r19,224(sp)
8111f008:	d8002a05 	stb	zero,168(sp)
8111f00c:	00801984 	movi	r2,102
8111f010:	8881f926 	beq	r17,r2,8111f7f8 <___vfprintf_internal_r+0x1ec4>
8111f014:	00801184 	movi	r2,70
8111f018:	88821c26 	beq	r17,r2,8111f88c <___vfprintf_internal_r+0x1f58>
8111f01c:	00801144 	movi	r2,69
8111f020:	b081ef26 	beq	r22,r2,8111f7e0 <___vfprintf_internal_r+0x1eac>
8111f024:	d8c02917 	ldw	r3,164(sp)
8111f028:	d8802104 	addi	r2,sp,132
8111f02c:	d8800315 	stw	r2,12(sp)
8111f030:	d9403617 	ldw	r5,216(sp)
8111f034:	d8802504 	addi	r2,sp,148
8111f038:	d9002c17 	ldw	r4,176(sp)
8111f03c:	d8800215 	stw	r2,8(sp)
8111f040:	d8802604 	addi	r2,sp,152
8111f044:	d8c00015 	stw	r3,0(sp)
8111f048:	d8800115 	stw	r2,4(sp)
8111f04c:	01c00084 	movi	r7,2
8111f050:	980d883a 	mov	r6,r19
8111f054:	d8c03c15 	stw	r3,240(sp)
8111f058:	da003d15 	stw	r8,244(sp)
8111f05c:	112181c0 	call	8112181c <_dtoa_r>
8111f060:	1021883a 	mov	r16,r2
8111f064:	008019c4 	movi	r2,103
8111f068:	d8c03c17 	ldw	r3,240(sp)
8111f06c:	da003d17 	ldw	r8,244(sp)
8111f070:	88817126 	beq	r17,r2,8111f638 <___vfprintf_internal_r+0x1d04>
8111f074:	008011c4 	movi	r2,71
8111f078:	88829226 	beq	r17,r2,8111fac4 <___vfprintf_internal_r+0x2190>
8111f07c:	80f9883a 	add	fp,r16,r3
8111f080:	d9003617 	ldw	r4,216(sp)
8111f084:	000d883a 	mov	r6,zero
8111f088:	000f883a 	mov	r7,zero
8111f08c:	980b883a 	mov	r5,r19
8111f090:	da003d15 	stw	r8,244(sp)
8111f094:	112ed400 	call	8112ed40 <__eqdf2>
8111f098:	da003d17 	ldw	r8,244(sp)
8111f09c:	10018d26 	beq	r2,zero,8111f6d4 <___vfprintf_internal_r+0x1da0>
8111f0a0:	d8802117 	ldw	r2,132(sp)
8111f0a4:	1700062e 	bgeu	r2,fp,8111f0c0 <___vfprintf_internal_r+0x178c>
8111f0a8:	01000c04 	movi	r4,48
8111f0ac:	10c00044 	addi	r3,r2,1
8111f0b0:	d8c02115 	stw	r3,132(sp)
8111f0b4:	11000005 	stb	r4,0(r2)
8111f0b8:	d8802117 	ldw	r2,132(sp)
8111f0bc:	173ffb36 	bltu	r2,fp,8111f0ac <__reset+0xfb0ff0ac>
8111f0c0:	1405c83a 	sub	r2,r2,r16
8111f0c4:	d8803315 	stw	r2,204(sp)
8111f0c8:	008011c4 	movi	r2,71
8111f0cc:	b0817626 	beq	r22,r2,8111f6a8 <___vfprintf_internal_r+0x1d74>
8111f0d0:	00801944 	movi	r2,101
8111f0d4:	1442810e 	bge	r2,r17,8111fadc <___vfprintf_internal_r+0x21a8>
8111f0d8:	d8c02617 	ldw	r3,152(sp)
8111f0dc:	00801984 	movi	r2,102
8111f0e0:	d8c03215 	stw	r3,200(sp)
8111f0e4:	8881fe26 	beq	r17,r2,8111f8e0 <___vfprintf_internal_r+0x1fac>
8111f0e8:	d8c03217 	ldw	r3,200(sp)
8111f0ec:	d9003317 	ldw	r4,204(sp)
8111f0f0:	1901dd16 	blt	r3,r4,8111f868 <___vfprintf_internal_r+0x1f34>
8111f0f4:	9480004c 	andi	r18,r18,1
8111f0f8:	90022b1e 	bne	r18,zero,8111f9a8 <___vfprintf_internal_r+0x2074>
8111f0fc:	1805883a 	mov	r2,r3
8111f100:	18028016 	blt	r3,zero,8111fb04 <___vfprintf_internal_r+0x21d0>
8111f104:	d8c03217 	ldw	r3,200(sp)
8111f108:	044019c4 	movi	r17,103
8111f10c:	d8c02e15 	stw	r3,184(sp)
8111f110:	df002a07 	ldb	fp,168(sp)
8111f114:	e001531e 	bne	fp,zero,8111f664 <___vfprintf_internal_r+0x1d30>
8111f118:	df002783 	ldbu	fp,158(sp)
8111f11c:	d8802a15 	stw	r2,168(sp)
8111f120:	dc802b17 	ldw	r18,172(sp)
8111f124:	d8002915 	stw	zero,164(sp)
8111f128:	003bd106 	br	8111e070 <__reset+0xfb0fe070>
8111f12c:	d8802d17 	ldw	r2,180(sp)
8111f130:	d8c02d17 	ldw	r3,180(sp)
8111f134:	d9002d17 	ldw	r4,180(sp)
8111f138:	10800017 	ldw	r2,0(r2)
8111f13c:	18c00117 	ldw	r3,4(r3)
8111f140:	21000204 	addi	r4,r4,8
8111f144:	d8803615 	stw	r2,216(sp)
8111f148:	d8c03815 	stw	r3,224(sp)
8111f14c:	d9002d15 	stw	r4,180(sp)
8111f150:	003b7506 	br	8111df28 <__reset+0xfb0fdf28>
8111f154:	ac400007 	ldb	r17,0(r21)
8111f158:	003a5906 	br	8111dac0 <__reset+0xfb0fdac0>
8111f15c:	9080100c 	andi	r2,r18,64
8111f160:	1000a826 	beq	r2,zero,8111f404 <___vfprintf_internal_r+0x1ad0>
8111f164:	d9002d17 	ldw	r4,180(sp)
8111f168:	002d883a 	mov	r22,zero
8111f16c:	24c0000b 	ldhu	r19,0(r4)
8111f170:	21000104 	addi	r4,r4,4
8111f174:	d9002d15 	stw	r4,180(sp)
8111f178:	003ccb06 	br	8111e4a8 <__reset+0xfb0fe4a8>
8111f17c:	d8c02d17 	ldw	r3,180(sp)
8111f180:	d9002917 	ldw	r4,164(sp)
8111f184:	002d883a 	mov	r22,zero
8111f188:	18800104 	addi	r2,r3,4
8111f18c:	1cc00017 	ldw	r19,0(r3)
8111f190:	203ebb0e 	bge	r4,zero,8111ec80 <__reset+0xfb0fec80>
8111f194:	003ef106 	br	8111ed5c <__reset+0xfb0fed5c>
8111f198:	9080040c 	andi	r2,r18,16
8111f19c:	1000921e 	bne	r2,zero,8111f3e8 <___vfprintf_internal_r+0x1ab4>
8111f1a0:	9480100c 	andi	r18,r18,64
8111f1a4:	90013926 	beq	r18,zero,8111f68c <___vfprintf_internal_r+0x1d58>
8111f1a8:	d9002d17 	ldw	r4,180(sp)
8111f1ac:	d9402f17 	ldw	r5,188(sp)
8111f1b0:	20800017 	ldw	r2,0(r4)
8111f1b4:	21000104 	addi	r4,r4,4
8111f1b8:	d9002d15 	stw	r4,180(sp)
8111f1bc:	1140000d 	sth	r5,0(r2)
8111f1c0:	003a1606 	br	8111da1c <__reset+0xfb0fda1c>
8111f1c4:	9080100c 	andi	r2,r18,64
8111f1c8:	10008026 	beq	r2,zero,8111f3cc <___vfprintf_internal_r+0x1a98>
8111f1cc:	d8c02d17 	ldw	r3,180(sp)
8111f1d0:	1cc0000f 	ldh	r19,0(r3)
8111f1d4:	18c00104 	addi	r3,r3,4
8111f1d8:	d8c02d15 	stw	r3,180(sp)
8111f1dc:	982dd7fa 	srai	r22,r19,31
8111f1e0:	b005883a 	mov	r2,r22
8111f1e4:	003b1f06 	br	8111de64 <__reset+0xfb0fde64>
8111f1e8:	9080100c 	andi	r2,r18,64
8111f1ec:	d8002785 	stb	zero,158(sp)
8111f1f0:	10008a1e 	bne	r2,zero,8111f41c <___vfprintf_internal_r+0x1ae8>
8111f1f4:	d9402d17 	ldw	r5,180(sp)
8111f1f8:	d8c02917 	ldw	r3,164(sp)
8111f1fc:	002d883a 	mov	r22,zero
8111f200:	28800104 	addi	r2,r5,4
8111f204:	2cc00017 	ldw	r19,0(r5)
8111f208:	183e4b0e 	bge	r3,zero,8111eb38 <__reset+0xfb0feb38>
8111f20c:	9d86b03a 	or	r3,r19,r22
8111f210:	d8802d15 	stw	r2,180(sp)
8111f214:	183e4c1e 	bne	r3,zero,8111eb48 <__reset+0xfb0feb48>
8111f218:	0039883a 	mov	fp,zero
8111f21c:	0005883a 	mov	r2,zero
8111f220:	003d4006 	br	8111e724 <__reset+0xfb0fe724>
8111f224:	01604534 	movhi	r5,33044
8111f228:	29544e84 	addi	r5,r5,20794
8111f22c:	d9402b15 	stw	r5,172(sp)
8111f230:	d9402b17 	ldw	r5,172(sp)
8111f234:	1c47883a 	add	r3,r3,r17
8111f238:	10800044 	addi	r2,r2,1
8111f23c:	41400015 	stw	r5,0(r8)
8111f240:	44400115 	stw	r17,4(r8)
8111f244:	d8c02015 	stw	r3,128(sp)
8111f248:	d8801f15 	stw	r2,124(sp)
8111f24c:	010001c4 	movi	r4,7
8111f250:	20bec816 	blt	r4,r2,8111ed74 <__reset+0xfb0fed74>
8111f254:	42000204 	addi	r8,r8,8
8111f258:	003ecd06 	br	8111ed90 <__reset+0xfb0fed90>
8111f25c:	d9002917 	ldw	r4,164(sp)
8111f260:	d8002785 	stb	zero,158(sp)
8111f264:	203d2d16 	blt	r4,zero,8111e71c <__reset+0xfb0fe71c>
8111f268:	00bfdfc4 	movi	r2,-129
8111f26c:	90a4703a 	and	r18,r18,r2
8111f270:	003a9106 	br	8111dcb8 <__reset+0xfb0fdcb8>
8111f274:	01204534 	movhi	r4,33044
8111f278:	21144e84 	addi	r4,r4,20794
8111f27c:	d9002b15 	stw	r4,172(sp)
8111f280:	003c0c06 	br	8111e2b4 <__reset+0xfb0fe2b4>
8111f284:	d9002c17 	ldw	r4,176(sp)
8111f288:	d9801e04 	addi	r6,sp,120
8111f28c:	b80b883a 	mov	r5,r23
8111f290:	112a1c00 	call	8112a1c0 <__sprint_r>
8111f294:	103aab1e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111f298:	d8c02017 	ldw	r3,128(sp)
8111f29c:	da000404 	addi	r8,sp,16
8111f2a0:	003d4106 	br	8111e7a8 <__reset+0xfb0fe7a8>
8111f2a4:	d8801f17 	ldw	r2,124(sp)
8111f2a8:	01604534 	movhi	r5,33044
8111f2ac:	01000044 	movi	r4,1
8111f2b0:	18c00044 	addi	r3,r3,1
8111f2b4:	10800044 	addi	r2,r2,1
8111f2b8:	29544604 	addi	r5,r5,20760
8111f2bc:	41000115 	stw	r4,4(r8)
8111f2c0:	41400015 	stw	r5,0(r8)
8111f2c4:	d8c02015 	stw	r3,128(sp)
8111f2c8:	d8801f15 	stw	r2,124(sp)
8111f2cc:	010001c4 	movi	r4,7
8111f2d0:	20805c16 	blt	r4,r2,8111f444 <___vfprintf_internal_r+0x1b10>
8111f2d4:	42000204 	addi	r8,r8,8
8111f2d8:	8800041e 	bne	r17,zero,8111f2ec <___vfprintf_internal_r+0x19b8>
8111f2dc:	d8803317 	ldw	r2,204(sp)
8111f2e0:	1000021e 	bne	r2,zero,8111f2ec <___vfprintf_internal_r+0x19b8>
8111f2e4:	9080004c 	andi	r2,r18,1
8111f2e8:	103c0926 	beq	r2,zero,8111e310 <__reset+0xfb0fe310>
8111f2ec:	d9003717 	ldw	r4,220(sp)
8111f2f0:	d8801f17 	ldw	r2,124(sp)
8111f2f4:	d9403417 	ldw	r5,208(sp)
8111f2f8:	20c7883a 	add	r3,r4,r3
8111f2fc:	10800044 	addi	r2,r2,1
8111f300:	41000115 	stw	r4,4(r8)
8111f304:	41400015 	stw	r5,0(r8)
8111f308:	d8c02015 	stw	r3,128(sp)
8111f30c:	d8801f15 	stw	r2,124(sp)
8111f310:	010001c4 	movi	r4,7
8111f314:	20812116 	blt	r4,r2,8111f79c <___vfprintf_internal_r+0x1e68>
8111f318:	42000204 	addi	r8,r8,8
8111f31c:	0463c83a 	sub	r17,zero,r17
8111f320:	0440730e 	bge	zero,r17,8111f4f0 <___vfprintf_internal_r+0x1bbc>
8111f324:	05800404 	movi	r22,16
8111f328:	b440860e 	bge	r22,r17,8111f544 <___vfprintf_internal_r+0x1c10>
8111f32c:	01604534 	movhi	r5,33044
8111f330:	29544e84 	addi	r5,r5,20794
8111f334:	d9402b15 	stw	r5,172(sp)
8111f338:	070001c4 	movi	fp,7
8111f33c:	dcc02c17 	ldw	r19,176(sp)
8111f340:	00000306 	br	8111f350 <___vfprintf_internal_r+0x1a1c>
8111f344:	42000204 	addi	r8,r8,8
8111f348:	8c7ffc04 	addi	r17,r17,-16
8111f34c:	b440800e 	bge	r22,r17,8111f550 <___vfprintf_internal_r+0x1c1c>
8111f350:	18c00404 	addi	r3,r3,16
8111f354:	10800044 	addi	r2,r2,1
8111f358:	45000015 	stw	r20,0(r8)
8111f35c:	45800115 	stw	r22,4(r8)
8111f360:	d8c02015 	stw	r3,128(sp)
8111f364:	d8801f15 	stw	r2,124(sp)
8111f368:	e0bff60e 	bge	fp,r2,8111f344 <__reset+0xfb0ff344>
8111f36c:	d9801e04 	addi	r6,sp,120
8111f370:	b80b883a 	mov	r5,r23
8111f374:	9809883a 	mov	r4,r19
8111f378:	112a1c00 	call	8112a1c0 <__sprint_r>
8111f37c:	103a711e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111f380:	d8c02017 	ldw	r3,128(sp)
8111f384:	d8801f17 	ldw	r2,124(sp)
8111f388:	da000404 	addi	r8,sp,16
8111f38c:	003fee06 	br	8111f348 <__reset+0xfb0ff348>
8111f390:	00bfffc4 	movi	r2,-1
8111f394:	003a6f06 	br	8111dd54 <__reset+0xfb0fdd54>
8111f398:	008011c4 	movi	r2,71
8111f39c:	1440b816 	blt	r2,r17,8111f680 <___vfprintf_internal_r+0x1d4c>
8111f3a0:	04204534 	movhi	r16,33044
8111f3a4:	84143804 	addi	r16,r16,20704
8111f3a8:	00c000c4 	movi	r3,3
8111f3ac:	00bfdfc4 	movi	r2,-129
8111f3b0:	d8c02a15 	stw	r3,168(sp)
8111f3b4:	90a4703a 	and	r18,r18,r2
8111f3b8:	df002783 	ldbu	fp,158(sp)
8111f3bc:	d8c02e15 	stw	r3,184(sp)
8111f3c0:	d8002915 	stw	zero,164(sp)
8111f3c4:	d8003215 	stw	zero,200(sp)
8111f3c8:	003b2906 	br	8111e070 <__reset+0xfb0fe070>
8111f3cc:	d9002d17 	ldw	r4,180(sp)
8111f3d0:	24c00017 	ldw	r19,0(r4)
8111f3d4:	21000104 	addi	r4,r4,4
8111f3d8:	d9002d15 	stw	r4,180(sp)
8111f3dc:	982dd7fa 	srai	r22,r19,31
8111f3e0:	b005883a 	mov	r2,r22
8111f3e4:	003a9f06 	br	8111de64 <__reset+0xfb0fde64>
8111f3e8:	d9402d17 	ldw	r5,180(sp)
8111f3ec:	d8c02f17 	ldw	r3,188(sp)
8111f3f0:	28800017 	ldw	r2,0(r5)
8111f3f4:	29400104 	addi	r5,r5,4
8111f3f8:	d9402d15 	stw	r5,180(sp)
8111f3fc:	10c00015 	stw	r3,0(r2)
8111f400:	00398606 	br	8111da1c <__reset+0xfb0fda1c>
8111f404:	d9402d17 	ldw	r5,180(sp)
8111f408:	002d883a 	mov	r22,zero
8111f40c:	2cc00017 	ldw	r19,0(r5)
8111f410:	29400104 	addi	r5,r5,4
8111f414:	d9402d15 	stw	r5,180(sp)
8111f418:	003c2306 	br	8111e4a8 <__reset+0xfb0fe4a8>
8111f41c:	d8c02d17 	ldw	r3,180(sp)
8111f420:	d9002917 	ldw	r4,164(sp)
8111f424:	002d883a 	mov	r22,zero
8111f428:	18800104 	addi	r2,r3,4
8111f42c:	1cc0000b 	ldhu	r19,0(r3)
8111f430:	203dc10e 	bge	r4,zero,8111eb38 <__reset+0xfb0feb38>
8111f434:	003f7506 	br	8111f20c <__reset+0xfb0ff20c>
8111f438:	04204534 	movhi	r16,33044
8111f43c:	84143604 	addi	r16,r16,20696
8111f440:	003acc06 	br	8111df74 <__reset+0xfb0fdf74>
8111f444:	d9002c17 	ldw	r4,176(sp)
8111f448:	d9801e04 	addi	r6,sp,120
8111f44c:	b80b883a 	mov	r5,r23
8111f450:	112a1c00 	call	8112a1c0 <__sprint_r>
8111f454:	103a3b1e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111f458:	dc402617 	ldw	r17,152(sp)
8111f45c:	d8c02017 	ldw	r3,128(sp)
8111f460:	da000404 	addi	r8,sp,16
8111f464:	003f9c06 	br	8111f2d8 <__reset+0xfb0ff2d8>
8111f468:	ac400043 	ldbu	r17,1(r21)
8111f46c:	94800814 	ori	r18,r18,32
8111f470:	ad400044 	addi	r21,r21,1
8111f474:	8c403fcc 	andi	r17,r17,255
8111f478:	8c40201c 	xori	r17,r17,128
8111f47c:	8c7fe004 	addi	r17,r17,-128
8111f480:	00398f06 	br	8111dac0 <__reset+0xfb0fdac0>
8111f484:	d8c02d15 	stw	r3,180(sp)
8111f488:	0039883a 	mov	fp,zero
8111f48c:	003e3506 	br	8111ed64 <__reset+0xfb0fed64>
8111f490:	d9002c17 	ldw	r4,176(sp)
8111f494:	d9801e04 	addi	r6,sp,120
8111f498:	b80b883a 	mov	r5,r23
8111f49c:	112a1c00 	call	8112a1c0 <__sprint_r>
8111f4a0:	103a281e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111f4a4:	d8c02017 	ldw	r3,128(sp)
8111f4a8:	da000404 	addi	r8,sp,16
8111f4ac:	003cd006 	br	8111e7f0 <__reset+0xfb0fe7f0>
8111f4b0:	8009883a 	mov	r4,r16
8111f4b4:	da003d15 	stw	r8,244(sp)
8111f4b8:	111b1180 	call	8111b118 <strlen>
8111f4bc:	d8802e15 	stw	r2,184(sp)
8111f4c0:	da003d17 	ldw	r8,244(sp)
8111f4c4:	103c340e 	bge	r2,zero,8111e598 <__reset+0xfb0fe598>
8111f4c8:	0005883a 	mov	r2,zero
8111f4cc:	003c3206 	br	8111e598 <__reset+0xfb0fe598>
8111f4d0:	d9002c17 	ldw	r4,176(sp)
8111f4d4:	d9801e04 	addi	r6,sp,120
8111f4d8:	b80b883a 	mov	r5,r23
8111f4dc:	112a1c00 	call	8112a1c0 <__sprint_r>
8111f4e0:	103a181e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111f4e4:	d8c02017 	ldw	r3,128(sp)
8111f4e8:	d8801f17 	ldw	r2,124(sp)
8111f4ec:	da000404 	addi	r8,sp,16
8111f4f0:	d9403317 	ldw	r5,204(sp)
8111f4f4:	10800044 	addi	r2,r2,1
8111f4f8:	44000015 	stw	r16,0(r8)
8111f4fc:	28c7883a 	add	r3,r5,r3
8111f500:	003b7d06 	br	8111e2f8 <__reset+0xfb0fe2f8>
8111f504:	01204534 	movhi	r4,33044
8111f508:	21145284 	addi	r4,r4,20810
8111f50c:	d9003515 	stw	r4,212(sp)
8111f510:	003b1406 	br	8111e164 <__reset+0xfb0fe164>
8111f514:	013fffc4 	movi	r4,-1
8111f518:	003a3506 	br	8111ddf0 <__reset+0xfb0fddf0>
8111f51c:	0023883a 	mov	r17,zero
8111f520:	003d9d06 	br	8111eb98 <__reset+0xfb0feb98>
8111f524:	d9002c17 	ldw	r4,176(sp)
8111f528:	d9801e04 	addi	r6,sp,120
8111f52c:	b80b883a 	mov	r5,r23
8111f530:	112a1c00 	call	8112a1c0 <__sprint_r>
8111f534:	103a031e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111f538:	d8c02017 	ldw	r3,128(sp)
8111f53c:	da000404 	addi	r8,sp,16
8111f540:	003d9406 	br	8111eb94 <__reset+0xfb0feb94>
8111f544:	01204534 	movhi	r4,33044
8111f548:	21144e84 	addi	r4,r4,20794
8111f54c:	d9002b15 	stw	r4,172(sp)
8111f550:	d9002b17 	ldw	r4,172(sp)
8111f554:	1c47883a 	add	r3,r3,r17
8111f558:	10800044 	addi	r2,r2,1
8111f55c:	41000015 	stw	r4,0(r8)
8111f560:	44400115 	stw	r17,4(r8)
8111f564:	d8c02015 	stw	r3,128(sp)
8111f568:	d8801f15 	stw	r2,124(sp)
8111f56c:	010001c4 	movi	r4,7
8111f570:	20bfd716 	blt	r4,r2,8111f4d0 <__reset+0xfb0ff4d0>
8111f574:	42000204 	addi	r8,r8,8
8111f578:	003fdd06 	br	8111f4f0 <__reset+0xfb0ff4f0>
8111f57c:	d9002c17 	ldw	r4,176(sp)
8111f580:	d9801e04 	addi	r6,sp,120
8111f584:	b80b883a 	mov	r5,r23
8111f588:	112a1c00 	call	8112a1c0 <__sprint_r>
8111f58c:	1039ed1e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111f590:	d8802617 	ldw	r2,152(sp)
8111f594:	d8c02017 	ldw	r3,128(sp)
8111f598:	da000404 	addi	r8,sp,16
8111f59c:	003e1006 	br	8111ede0 <__reset+0xfb0fede0>
8111f5a0:	00800044 	movi	r2,1
8111f5a4:	10803fcc 	andi	r2,r2,255
8111f5a8:	00c00044 	movi	r3,1
8111f5ac:	10fa3526 	beq	r2,r3,8111de84 <__reset+0xfb0fde84>
8111f5b0:	00c00084 	movi	r3,2
8111f5b4:	10fbcb26 	beq	r2,r3,8111e4e4 <__reset+0xfb0fe4e4>
8111f5b8:	003a8f06 	br	8111dff8 <__reset+0xfb0fdff8>
8111f5bc:	01204534 	movhi	r4,33044
8111f5c0:	21145284 	addi	r4,r4,20810
8111f5c4:	d9003515 	stw	r4,212(sp)
8111f5c8:	003b7606 	br	8111e3a4 <__reset+0xfb0fe3a4>
8111f5cc:	d8802917 	ldw	r2,164(sp)
8111f5d0:	00c00184 	movi	r3,6
8111f5d4:	1880012e 	bgeu	r3,r2,8111f5dc <___vfprintf_internal_r+0x1ca8>
8111f5d8:	1805883a 	mov	r2,r3
8111f5dc:	d8802e15 	stw	r2,184(sp)
8111f5e0:	1000ef16 	blt	r2,zero,8111f9a0 <___vfprintf_internal_r+0x206c>
8111f5e4:	04204534 	movhi	r16,33044
8111f5e8:	d8802a15 	stw	r2,168(sp)
8111f5ec:	dcc02d15 	stw	r19,180(sp)
8111f5f0:	d8002915 	stw	zero,164(sp)
8111f5f4:	d8003215 	stw	zero,200(sp)
8111f5f8:	84144404 	addi	r16,r16,20752
8111f5fc:	0039883a 	mov	fp,zero
8111f600:	003aa206 	br	8111e08c <__reset+0xfb0fe08c>
8111f604:	0021883a 	mov	r16,zero
8111f608:	003e0706 	br	8111ee28 <__reset+0xfb0fee28>
8111f60c:	d9002c17 	ldw	r4,176(sp)
8111f610:	d9801e04 	addi	r6,sp,120
8111f614:	b80b883a 	mov	r5,r23
8111f618:	112a1c00 	call	8112a1c0 <__sprint_r>
8111f61c:	1039c91e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111f620:	d8802617 	ldw	r2,152(sp)
8111f624:	d9403317 	ldw	r5,204(sp)
8111f628:	d8c02017 	ldw	r3,128(sp)
8111f62c:	da000404 	addi	r8,sp,16
8111f630:	2885c83a 	sub	r2,r5,r2
8111f634:	003dfb06 	br	8111ee24 <__reset+0xfb0fee24>
8111f638:	9080004c 	andi	r2,r18,1
8111f63c:	103e8f1e 	bne	r2,zero,8111f07c <__reset+0xfb0ff07c>
8111f640:	d8802117 	ldw	r2,132(sp)
8111f644:	003e9e06 	br	8111f0c0 <__reset+0xfb0ff0c0>
8111f648:	1025883a 	mov	r18,r2
8111f64c:	0039883a 	mov	fp,zero
8111f650:	00800084 	movi	r2,2
8111f654:	003fd306 	br	8111f5a4 <__reset+0xfb0ff5a4>
8111f658:	07000b44 	movi	fp,45
8111f65c:	df002785 	stb	fp,158(sp)
8111f660:	003a4006 	br	8111df64 <__reset+0xfb0fdf64>
8111f664:	00c00b44 	movi	r3,45
8111f668:	d8c02785 	stb	r3,158(sp)
8111f66c:	d8802a15 	stw	r2,168(sp)
8111f670:	dc802b17 	ldw	r18,172(sp)
8111f674:	d8002915 	stw	zero,164(sp)
8111f678:	07000b44 	movi	fp,45
8111f67c:	003a8006 	br	8111e080 <__reset+0xfb0fe080>
8111f680:	04204534 	movhi	r16,33044
8111f684:	84143904 	addi	r16,r16,20708
8111f688:	003f4706 	br	8111f3a8 <__reset+0xfb0ff3a8>
8111f68c:	d8c02d17 	ldw	r3,180(sp)
8111f690:	d9002f17 	ldw	r4,188(sp)
8111f694:	18800017 	ldw	r2,0(r3)
8111f698:	18c00104 	addi	r3,r3,4
8111f69c:	d8c02d15 	stw	r3,180(sp)
8111f6a0:	11000015 	stw	r4,0(r2)
8111f6a4:	0038dd06 	br	8111da1c <__reset+0xfb0fda1c>
8111f6a8:	dd802617 	ldw	r22,152(sp)
8111f6ac:	00bfff44 	movi	r2,-3
8111f6b0:	b0801c16 	blt	r22,r2,8111f724 <___vfprintf_internal_r+0x1df0>
8111f6b4:	d9402917 	ldw	r5,164(sp)
8111f6b8:	2d801a16 	blt	r5,r22,8111f724 <___vfprintf_internal_r+0x1df0>
8111f6bc:	dd803215 	stw	r22,200(sp)
8111f6c0:	003e8906 	br	8111f0e8 <__reset+0xfb0ff0e8>
8111f6c4:	01204534 	movhi	r4,33044
8111f6c8:	21144e84 	addi	r4,r4,20794
8111f6cc:	d9002b15 	stw	r4,172(sp)
8111f6d0:	003c9106 	br	8111e918 <__reset+0xfb0fe918>
8111f6d4:	e005883a 	mov	r2,fp
8111f6d8:	003e7906 	br	8111f0c0 <__reset+0xfb0ff0c0>
8111f6dc:	d9402917 	ldw	r5,164(sp)
8111f6e0:	df002783 	ldbu	fp,158(sp)
8111f6e4:	dcc02d15 	stw	r19,180(sp)
8111f6e8:	d9402a15 	stw	r5,168(sp)
8111f6ec:	d9402e15 	stw	r5,184(sp)
8111f6f0:	d8002915 	stw	zero,164(sp)
8111f6f4:	d8003215 	stw	zero,200(sp)
8111f6f8:	003a5d06 	br	8111e070 <__reset+0xfb0fe070>
8111f6fc:	9080004c 	andi	r2,r18,1
8111f700:	0039883a 	mov	fp,zero
8111f704:	10000426 	beq	r2,zero,8111f718 <___vfprintf_internal_r+0x1de4>
8111f708:	00800c04 	movi	r2,48
8111f70c:	dc001dc4 	addi	r16,sp,119
8111f710:	d8801dc5 	stb	r2,119(sp)
8111f714:	003b8006 	br	8111e518 <__reset+0xfb0fe518>
8111f718:	d8002e15 	stw	zero,184(sp)
8111f71c:	dc001e04 	addi	r16,sp,120
8111f720:	003a4d06 	br	8111e058 <__reset+0xfb0fe058>
8111f724:	8c7fff84 	addi	r17,r17,-2
8111f728:	b5bfffc4 	addi	r22,r22,-1
8111f72c:	dd802615 	stw	r22,152(sp)
8111f730:	dc4022c5 	stb	r17,139(sp)
8111f734:	b000bf16 	blt	r22,zero,8111fa34 <___vfprintf_internal_r+0x2100>
8111f738:	00800ac4 	movi	r2,43
8111f73c:	d8802305 	stb	r2,140(sp)
8111f740:	00800244 	movi	r2,9
8111f744:	15807016 	blt	r2,r22,8111f908 <___vfprintf_internal_r+0x1fd4>
8111f748:	00800c04 	movi	r2,48
8111f74c:	b5800c04 	addi	r22,r22,48
8111f750:	d8802345 	stb	r2,141(sp)
8111f754:	dd802385 	stb	r22,142(sp)
8111f758:	d88023c4 	addi	r2,sp,143
8111f75c:	df0022c4 	addi	fp,sp,139
8111f760:	d8c03317 	ldw	r3,204(sp)
8111f764:	1739c83a 	sub	fp,r2,fp
8111f768:	d9003317 	ldw	r4,204(sp)
8111f76c:	e0c7883a 	add	r3,fp,r3
8111f770:	df003a15 	stw	fp,232(sp)
8111f774:	d8c02e15 	stw	r3,184(sp)
8111f778:	00800044 	movi	r2,1
8111f77c:	1100b30e 	bge	r2,r4,8111fa4c <___vfprintf_internal_r+0x2118>
8111f780:	d8c02e17 	ldw	r3,184(sp)
8111f784:	18c00044 	addi	r3,r3,1
8111f788:	d8c02e15 	stw	r3,184(sp)
8111f78c:	1805883a 	mov	r2,r3
8111f790:	1800ac16 	blt	r3,zero,8111fa44 <___vfprintf_internal_r+0x2110>
8111f794:	d8003215 	stw	zero,200(sp)
8111f798:	003e5d06 	br	8111f110 <__reset+0xfb0ff110>
8111f79c:	d9002c17 	ldw	r4,176(sp)
8111f7a0:	d9801e04 	addi	r6,sp,120
8111f7a4:	b80b883a 	mov	r5,r23
8111f7a8:	112a1c00 	call	8112a1c0 <__sprint_r>
8111f7ac:	1039651e 	bne	r2,zero,8111dd44 <__reset+0xfb0fdd44>
8111f7b0:	dc402617 	ldw	r17,152(sp)
8111f7b4:	d8c02017 	ldw	r3,128(sp)
8111f7b8:	d8801f17 	ldw	r2,124(sp)
8111f7bc:	da000404 	addi	r8,sp,16
8111f7c0:	003ed606 	br	8111f31c <__reset+0xfb0ff31c>
8111f7c4:	582b883a 	mov	r21,r11
8111f7c8:	d8002915 	stw	zero,164(sp)
8111f7cc:	0038bd06 	br	8111dac4 <__reset+0xfb0fdac4>
8111f7d0:	d8802917 	ldw	r2,164(sp)
8111f7d4:	103e071e 	bne	r2,zero,8111eff4 <__reset+0xfb0feff4>
8111f7d8:	dc002915 	stw	r16,164(sp)
8111f7dc:	003e0506 	br	8111eff4 <__reset+0xfb0feff4>
8111f7e0:	d9002917 	ldw	r4,164(sp)
8111f7e4:	20c00044 	addi	r3,r4,1
8111f7e8:	003e0f06 	br	8111f028 <__reset+0xfb0ff028>
8111f7ec:	01400184 	movi	r5,6
8111f7f0:	d9402915 	stw	r5,164(sp)
8111f7f4:	003dff06 	br	8111eff4 <__reset+0xfb0feff4>
8111f7f8:	d8802104 	addi	r2,sp,132
8111f7fc:	d8800315 	stw	r2,12(sp)
8111f800:	d8802504 	addi	r2,sp,148
8111f804:	d8800215 	stw	r2,8(sp)
8111f808:	d8802604 	addi	r2,sp,152
8111f80c:	d8800115 	stw	r2,4(sp)
8111f810:	d8802917 	ldw	r2,164(sp)
8111f814:	d9403617 	ldw	r5,216(sp)
8111f818:	d9002c17 	ldw	r4,176(sp)
8111f81c:	d8800015 	stw	r2,0(sp)
8111f820:	01c000c4 	movi	r7,3
8111f824:	980d883a 	mov	r6,r19
8111f828:	da003d15 	stw	r8,244(sp)
8111f82c:	112181c0 	call	8112181c <_dtoa_r>
8111f830:	d8c02917 	ldw	r3,164(sp)
8111f834:	da003d17 	ldw	r8,244(sp)
8111f838:	1021883a 	mov	r16,r2
8111f83c:	10f9883a 	add	fp,r2,r3
8111f840:	81000007 	ldb	r4,0(r16)
8111f844:	00800c04 	movi	r2,48
8111f848:	20805e26 	beq	r4,r2,8111f9c4 <___vfprintf_internal_r+0x2090>
8111f84c:	d8c02617 	ldw	r3,152(sp)
8111f850:	e0f9883a 	add	fp,fp,r3
8111f854:	003e0a06 	br	8111f080 <__reset+0xfb0ff080>
8111f858:	00c00b44 	movi	r3,45
8111f85c:	24e0003c 	xorhi	r19,r4,32768
8111f860:	d8c02a05 	stb	r3,168(sp)
8111f864:	003de906 	br	8111f00c <__reset+0xfb0ff00c>
8111f868:	d8c03217 	ldw	r3,200(sp)
8111f86c:	00c07a0e 	bge	zero,r3,8111fa58 <___vfprintf_internal_r+0x2124>
8111f870:	00800044 	movi	r2,1
8111f874:	d9003317 	ldw	r4,204(sp)
8111f878:	1105883a 	add	r2,r2,r4
8111f87c:	d8802e15 	stw	r2,184(sp)
8111f880:	10004e16 	blt	r2,zero,8111f9bc <___vfprintf_internal_r+0x2088>
8111f884:	044019c4 	movi	r17,103
8111f888:	003e2106 	br	8111f110 <__reset+0xfb0ff110>
8111f88c:	d9002917 	ldw	r4,164(sp)
8111f890:	d8802104 	addi	r2,sp,132
8111f894:	d8800315 	stw	r2,12(sp)
8111f898:	d9000015 	stw	r4,0(sp)
8111f89c:	d8802504 	addi	r2,sp,148
8111f8a0:	d9403617 	ldw	r5,216(sp)
8111f8a4:	d9002c17 	ldw	r4,176(sp)
8111f8a8:	d8800215 	stw	r2,8(sp)
8111f8ac:	d8802604 	addi	r2,sp,152
8111f8b0:	d8800115 	stw	r2,4(sp)
8111f8b4:	01c000c4 	movi	r7,3
8111f8b8:	980d883a 	mov	r6,r19
8111f8bc:	da003d15 	stw	r8,244(sp)
8111f8c0:	112181c0 	call	8112181c <_dtoa_r>
8111f8c4:	d8c02917 	ldw	r3,164(sp)
8111f8c8:	da003d17 	ldw	r8,244(sp)
8111f8cc:	1021883a 	mov	r16,r2
8111f8d0:	00801184 	movi	r2,70
8111f8d4:	80f9883a 	add	fp,r16,r3
8111f8d8:	88bfd926 	beq	r17,r2,8111f840 <__reset+0xfb0ff840>
8111f8dc:	003de806 	br	8111f080 <__reset+0xfb0ff080>
8111f8e0:	d9002917 	ldw	r4,164(sp)
8111f8e4:	00c04d0e 	bge	zero,r3,8111fa1c <___vfprintf_internal_r+0x20e8>
8111f8e8:	2000441e 	bne	r4,zero,8111f9fc <___vfprintf_internal_r+0x20c8>
8111f8ec:	9480004c 	andi	r18,r18,1
8111f8f0:	9000421e 	bne	r18,zero,8111f9fc <___vfprintf_internal_r+0x20c8>
8111f8f4:	1805883a 	mov	r2,r3
8111f8f8:	18007016 	blt	r3,zero,8111fabc <___vfprintf_internal_r+0x2188>
8111f8fc:	d8c03217 	ldw	r3,200(sp)
8111f900:	d8c02e15 	stw	r3,184(sp)
8111f904:	003e0206 	br	8111f110 <__reset+0xfb0ff110>
8111f908:	df0022c4 	addi	fp,sp,139
8111f90c:	dc002915 	stw	r16,164(sp)
8111f910:	4027883a 	mov	r19,r8
8111f914:	e021883a 	mov	r16,fp
8111f918:	b009883a 	mov	r4,r22
8111f91c:	01400284 	movi	r5,10
8111f920:	112d8700 	call	8112d870 <__modsi3>
8111f924:	10800c04 	addi	r2,r2,48
8111f928:	843fffc4 	addi	r16,r16,-1
8111f92c:	b009883a 	mov	r4,r22
8111f930:	01400284 	movi	r5,10
8111f934:	80800005 	stb	r2,0(r16)
8111f938:	112d7ec0 	call	8112d7ec <__divsi3>
8111f93c:	102d883a 	mov	r22,r2
8111f940:	00800244 	movi	r2,9
8111f944:	15bff416 	blt	r2,r22,8111f918 <__reset+0xfb0ff918>
8111f948:	9811883a 	mov	r8,r19
8111f94c:	b0800c04 	addi	r2,r22,48
8111f950:	8027883a 	mov	r19,r16
8111f954:	997fffc4 	addi	r5,r19,-1
8111f958:	98bfffc5 	stb	r2,-1(r19)
8111f95c:	dc002917 	ldw	r16,164(sp)
8111f960:	2f006a2e 	bgeu	r5,fp,8111fb0c <___vfprintf_internal_r+0x21d8>
8111f964:	d9c02384 	addi	r7,sp,142
8111f968:	3ccfc83a 	sub	r7,r7,r19
8111f96c:	d9002344 	addi	r4,sp,141
8111f970:	e1cf883a 	add	r7,fp,r7
8111f974:	00000106 	br	8111f97c <___vfprintf_internal_r+0x2048>
8111f978:	28800003 	ldbu	r2,0(r5)
8111f97c:	20800005 	stb	r2,0(r4)
8111f980:	21000044 	addi	r4,r4,1
8111f984:	29400044 	addi	r5,r5,1
8111f988:	393ffb1e 	bne	r7,r4,8111f978 <__reset+0xfb0ff978>
8111f98c:	d8802304 	addi	r2,sp,140
8111f990:	14c5c83a 	sub	r2,r2,r19
8111f994:	d8c02344 	addi	r3,sp,141
8111f998:	1885883a 	add	r2,r3,r2
8111f99c:	003f7006 	br	8111f760 <__reset+0xfb0ff760>
8111f9a0:	0005883a 	mov	r2,zero
8111f9a4:	003f0f06 	br	8111f5e4 <__reset+0xfb0ff5e4>
8111f9a8:	d8c03217 	ldw	r3,200(sp)
8111f9ac:	18c00044 	addi	r3,r3,1
8111f9b0:	d8c02e15 	stw	r3,184(sp)
8111f9b4:	1805883a 	mov	r2,r3
8111f9b8:	183fb20e 	bge	r3,zero,8111f884 <__reset+0xfb0ff884>
8111f9bc:	0005883a 	mov	r2,zero
8111f9c0:	003fb006 	br	8111f884 <__reset+0xfb0ff884>
8111f9c4:	d9003617 	ldw	r4,216(sp)
8111f9c8:	000d883a 	mov	r6,zero
8111f9cc:	000f883a 	mov	r7,zero
8111f9d0:	980b883a 	mov	r5,r19
8111f9d4:	d8c03c15 	stw	r3,240(sp)
8111f9d8:	da003d15 	stw	r8,244(sp)
8111f9dc:	112ed400 	call	8112ed40 <__eqdf2>
8111f9e0:	d8c03c17 	ldw	r3,240(sp)
8111f9e4:	da003d17 	ldw	r8,244(sp)
8111f9e8:	103f9826 	beq	r2,zero,8111f84c <__reset+0xfb0ff84c>
8111f9ec:	00800044 	movi	r2,1
8111f9f0:	10c7c83a 	sub	r3,r2,r3
8111f9f4:	d8c02615 	stw	r3,152(sp)
8111f9f8:	003f9506 	br	8111f850 <__reset+0xfb0ff850>
8111f9fc:	d9002917 	ldw	r4,164(sp)
8111fa00:	d8c03217 	ldw	r3,200(sp)
8111fa04:	20800044 	addi	r2,r4,1
8111fa08:	1885883a 	add	r2,r3,r2
8111fa0c:	d8802e15 	stw	r2,184(sp)
8111fa10:	103dbf0e 	bge	r2,zero,8111f110 <__reset+0xfb0ff110>
8111fa14:	0005883a 	mov	r2,zero
8111fa18:	003dbd06 	br	8111f110 <__reset+0xfb0ff110>
8111fa1c:	2000211e 	bne	r4,zero,8111faa4 <___vfprintf_internal_r+0x2170>
8111fa20:	9480004c 	andi	r18,r18,1
8111fa24:	90001f1e 	bne	r18,zero,8111faa4 <___vfprintf_internal_r+0x2170>
8111fa28:	00800044 	movi	r2,1
8111fa2c:	d8802e15 	stw	r2,184(sp)
8111fa30:	003db706 	br	8111f110 <__reset+0xfb0ff110>
8111fa34:	00800b44 	movi	r2,45
8111fa38:	05adc83a 	sub	r22,zero,r22
8111fa3c:	d8802305 	stb	r2,140(sp)
8111fa40:	003f3f06 	br	8111f740 <__reset+0xfb0ff740>
8111fa44:	0005883a 	mov	r2,zero
8111fa48:	003f5206 	br	8111f794 <__reset+0xfb0ff794>
8111fa4c:	90a4703a 	and	r18,r18,r2
8111fa50:	903f4e26 	beq	r18,zero,8111f78c <__reset+0xfb0ff78c>
8111fa54:	003f4a06 	br	8111f780 <__reset+0xfb0ff780>
8111fa58:	00800084 	movi	r2,2
8111fa5c:	10c5c83a 	sub	r2,r2,r3
8111fa60:	003f8406 	br	8111f874 <__reset+0xfb0ff874>
8111fa64:	d8802d17 	ldw	r2,180(sp)
8111fa68:	d9002d17 	ldw	r4,180(sp)
8111fa6c:	ac400043 	ldbu	r17,1(r21)
8111fa70:	10800017 	ldw	r2,0(r2)
8111fa74:	582b883a 	mov	r21,r11
8111fa78:	d8802915 	stw	r2,164(sp)
8111fa7c:	20800104 	addi	r2,r4,4
8111fa80:	d9002917 	ldw	r4,164(sp)
8111fa84:	d8802d15 	stw	r2,180(sp)
8111fa88:	203e7a0e 	bge	r4,zero,8111f474 <__reset+0xfb0ff474>
8111fa8c:	8c403fcc 	andi	r17,r17,255
8111fa90:	00bfffc4 	movi	r2,-1
8111fa94:	8c40201c 	xori	r17,r17,128
8111fa98:	d8802915 	stw	r2,164(sp)
8111fa9c:	8c7fe004 	addi	r17,r17,-128
8111faa0:	00380706 	br	8111dac0 <__reset+0xfb0fdac0>
8111faa4:	d8c02917 	ldw	r3,164(sp)
8111faa8:	18c00084 	addi	r3,r3,2
8111faac:	d8c02e15 	stw	r3,184(sp)
8111fab0:	1805883a 	mov	r2,r3
8111fab4:	183d960e 	bge	r3,zero,8111f110 <__reset+0xfb0ff110>
8111fab8:	003fd606 	br	8111fa14 <__reset+0xfb0ffa14>
8111fabc:	0005883a 	mov	r2,zero
8111fac0:	003f8e06 	br	8111f8fc <__reset+0xfb0ff8fc>
8111fac4:	9080004c 	andi	r2,r18,1
8111fac8:	103f811e 	bne	r2,zero,8111f8d0 <__reset+0xfb0ff8d0>
8111facc:	d8802117 	ldw	r2,132(sp)
8111fad0:	1405c83a 	sub	r2,r2,r16
8111fad4:	d8803315 	stw	r2,204(sp)
8111fad8:	b47ef326 	beq	r22,r17,8111f6a8 <__reset+0xfb0ff6a8>
8111fadc:	dd802617 	ldw	r22,152(sp)
8111fae0:	003f1106 	br	8111f728 <__reset+0xfb0ff728>
8111fae4:	d9c02785 	stb	r7,158(sp)
8111fae8:	00390406 	br	8111defc <__reset+0xfb0fdefc>
8111faec:	d9c02785 	stb	r7,158(sp)
8111faf0:	0038d306 	br	8111de40 <__reset+0xfb0fde40>
8111faf4:	d9c02785 	stb	r7,158(sp)
8111faf8:	003a6106 	br	8111e480 <__reset+0xfb0fe480>
8111fafc:	d9c02785 	stb	r7,158(sp)
8111fb00:	003af806 	br	8111e6e4 <__reset+0xfb0fe6e4>
8111fb04:	0005883a 	mov	r2,zero
8111fb08:	003d7e06 	br	8111f104 <__reset+0xfb0ff104>
8111fb0c:	d8802344 	addi	r2,sp,141
8111fb10:	003f1306 	br	8111f760 <__reset+0xfb0ff760>
8111fb14:	d9c02785 	stb	r7,158(sp)
8111fb18:	00392306 	br	8111dfa8 <__reset+0xfb0fdfa8>
8111fb1c:	d9c02785 	stb	r7,158(sp)
8111fb20:	003aa906 	br	8111e5c8 <__reset+0xfb0fe5c8>
8111fb24:	d9c02785 	stb	r7,158(sp)
8111fb28:	003a3d06 	br	8111e420 <__reset+0xfb0fe420>
8111fb2c:	d9c02785 	stb	r7,158(sp)
8111fb30:	003aca06 	br	8111e65c <__reset+0xfb0fe65c>

8111fb34 <__vfprintf_internal>:
8111fb34:	00a04534 	movhi	r2,33044
8111fb38:	109e0f04 	addi	r2,r2,30780
8111fb3c:	300f883a 	mov	r7,r6
8111fb40:	280d883a 	mov	r6,r5
8111fb44:	200b883a 	mov	r5,r4
8111fb48:	11000017 	ldw	r4,0(r2)
8111fb4c:	111d9341 	jmpi	8111d934 <___vfprintf_internal_r>

8111fb50 <__sbprintf>:
8111fb50:	defee204 	addi	sp,sp,-1144
8111fb54:	de00012e 	bgeu	sp,et,8111fb5c <__sbprintf+0xc>
8111fb58:	003b68fa 	trap	3
8111fb5c:	2880030b 	ldhu	r2,12(r5)
8111fb60:	2ac01917 	ldw	r11,100(r5)
8111fb64:	2a80038b 	ldhu	r10,14(r5)
8111fb68:	2a400717 	ldw	r9,28(r5)
8111fb6c:	2a000917 	ldw	r8,36(r5)
8111fb70:	00c10004 	movi	r3,1024
8111fb74:	dc011a15 	stw	r16,1128(sp)
8111fb78:	10bfff4c 	andi	r2,r2,65533
8111fb7c:	2821883a 	mov	r16,r5
8111fb80:	d8cb883a 	add	r5,sp,r3
8111fb84:	dc811c15 	stw	r18,1136(sp)
8111fb88:	dc411b15 	stw	r17,1132(sp)
8111fb8c:	dfc11d15 	stw	ra,1140(sp)
8111fb90:	2025883a 	mov	r18,r4
8111fb94:	d881030d 	sth	r2,1036(sp)
8111fb98:	dac11915 	stw	r11,1124(sp)
8111fb9c:	da81038d 	sth	r10,1038(sp)
8111fba0:	da410715 	stw	r9,1052(sp)
8111fba4:	da010915 	stw	r8,1060(sp)
8111fba8:	dec10015 	stw	sp,1024(sp)
8111fbac:	dec10415 	stw	sp,1040(sp)
8111fbb0:	d8c10215 	stw	r3,1032(sp)
8111fbb4:	d8c10515 	stw	r3,1044(sp)
8111fbb8:	d8010615 	stw	zero,1048(sp)
8111fbbc:	111d9340 	call	8111d934 <___vfprintf_internal_r>
8111fbc0:	1023883a 	mov	r17,r2
8111fbc4:	10000416 	blt	r2,zero,8111fbd8 <__sbprintf+0x88>
8111fbc8:	d9410004 	addi	r5,sp,1024
8111fbcc:	9009883a 	mov	r4,r18
8111fbd0:	11230d00 	call	811230d0 <_fflush_r>
8111fbd4:	10000d1e 	bne	r2,zero,8111fc0c <__sbprintf+0xbc>
8111fbd8:	d881030b 	ldhu	r2,1036(sp)
8111fbdc:	1080100c 	andi	r2,r2,64
8111fbe0:	10000326 	beq	r2,zero,8111fbf0 <__sbprintf+0xa0>
8111fbe4:	8080030b 	ldhu	r2,12(r16)
8111fbe8:	10801014 	ori	r2,r2,64
8111fbec:	8080030d 	sth	r2,12(r16)
8111fbf0:	8805883a 	mov	r2,r17
8111fbf4:	dfc11d17 	ldw	ra,1140(sp)
8111fbf8:	dc811c17 	ldw	r18,1136(sp)
8111fbfc:	dc411b17 	ldw	r17,1132(sp)
8111fc00:	dc011a17 	ldw	r16,1128(sp)
8111fc04:	dec11e04 	addi	sp,sp,1144
8111fc08:	f800283a 	ret
8111fc0c:	047fffc4 	movi	r17,-1
8111fc10:	003ff106 	br	8111fbd8 <__reset+0xfb0ffbd8>

8111fc14 <__svfscanf_r>:
8111fc14:	deff4b04 	addi	sp,sp,-724
8111fc18:	de00012e 	bgeu	sp,et,8111fc20 <__svfscanf_r+0xc>
8111fc1c:	003b68fa 	trap	3
8111fc20:	2880030b 	ldhu	r2,12(r5)
8111fc24:	df00b315 	stw	fp,716(sp)
8111fc28:	dd80b115 	stw	r22,708(sp)
8111fc2c:	dfc0b415 	stw	ra,720(sp)
8111fc30:	ddc0b215 	stw	r23,712(sp)
8111fc34:	dd40b015 	stw	r21,704(sp)
8111fc38:	dd00af15 	stw	r20,700(sp)
8111fc3c:	dcc0ae15 	stw	r19,696(sp)
8111fc40:	dc80ad15 	stw	r18,692(sp)
8111fc44:	dc40ac15 	stw	r17,688(sp)
8111fc48:	dc00ab15 	stw	r16,684(sp)
8111fc4c:	10c8000c 	andi	r3,r2,8192
8111fc50:	d9c09c15 	stw	r7,624(sp)
8111fc54:	2839883a 	mov	fp,r5
8111fc58:	202d883a 	mov	r22,r4
8111fc5c:	1800061e 	bne	r3,zero,8111fc78 <__svfscanf_r+0x64>
8111fc60:	29001917 	ldw	r4,100(r5)
8111fc64:	00f7ffc4 	movi	r3,-8193
8111fc68:	10880014 	ori	r2,r2,8192
8111fc6c:	20c6703a 	and	r3,r4,r3
8111fc70:	2880030d 	sth	r2,12(r5)
8111fc74:	28c01915 	stw	r3,100(r5)
8111fc78:	30800003 	ldbu	r2,0(r6)
8111fc7c:	0021883a 	mov	r16,zero
8111fc80:	05e04534 	movhi	r23,33044
8111fc84:	d800a115 	stw	zero,644(sp)
8111fc88:	d8009e15 	stw	zero,632(sp)
8111fc8c:	d800a015 	stw	zero,640(sp)
8111fc90:	d8809b15 	stw	r2,620(sp)
8111fc94:	bdde0d04 	addi	r23,r23,30772
8111fc98:	8025883a 	mov	r18,r16
8111fc9c:	35000044 	addi	r20,r6,1
8111fca0:	10001e26 	beq	r2,zero,8111fd1c <__svfscanf_r+0x108>
8111fca4:	b9c00017 	ldw	r7,0(r23)
8111fca8:	3887883a 	add	r3,r7,r2
8111fcac:	18c00043 	ldbu	r3,1(r3)
8111fcb0:	18c0020c 	andi	r3,r3,8
8111fcb4:	18001b26 	beq	r3,zero,8111fd24 <__svfscanf_r+0x110>
8111fcb8:	e0800117 	ldw	r2,4(fp)
8111fcbc:	00800e0e 	bge	zero,r2,8111fcf8 <__svfscanf_r+0xe4>
8111fcc0:	e0c00017 	ldw	r3,0(fp)
8111fcc4:	b9000017 	ldw	r4,0(r23)
8111fcc8:	18800003 	ldbu	r2,0(r3)
8111fccc:	2085883a 	add	r2,r4,r2
8111fcd0:	10800043 	ldbu	r2,1(r2)
8111fcd4:	1080020c 	andi	r2,r2,8
8111fcd8:	10000b26 	beq	r2,zero,8111fd08 <__svfscanf_r+0xf4>
8111fcdc:	e0800117 	ldw	r2,4(fp)
8111fce0:	18c00044 	addi	r3,r3,1
8111fce4:	e0c00015 	stw	r3,0(fp)
8111fce8:	10bfffc4 	addi	r2,r2,-1
8111fcec:	e0800115 	stw	r2,4(fp)
8111fcf0:	94800044 	addi	r18,r18,1
8111fcf4:	00bff216 	blt	zero,r2,8111fcc0 <__reset+0xfb0ffcc0>
8111fcf8:	e00b883a 	mov	r5,fp
8111fcfc:	b009883a 	mov	r4,r22
8111fd00:	11267800 	call	81126780 <__srefill_r>
8111fd04:	103fee26 	beq	r2,zero,8111fcc0 <__reset+0xfb0ffcc0>
8111fd08:	a00d883a 	mov	r6,r20
8111fd0c:	30800003 	ldbu	r2,0(r6)
8111fd10:	35000044 	addi	r20,r6,1
8111fd14:	d8809b15 	stw	r2,620(sp)
8111fd18:	103fe21e 	bne	r2,zero,8111fca4 <__reset+0xfb0ffca4>
8111fd1c:	d880a017 	ldw	r2,640(sp)
8111fd20:	00009906 	br	8111ff88 <__svfscanf_r+0x374>
8111fd24:	00c00944 	movi	r3,37
8111fd28:	10c0881e 	bne	r2,r3,8111ff4c <__svfscanf_r+0x338>
8111fd2c:	30c00043 	ldbu	r3,1(r6)
8111fd30:	0023883a 	mov	r17,zero
8111fd34:	0027883a 	mov	r19,zero
8111fd38:	01001e04 	movi	r4,120
8111fd3c:	01401b04 	movi	r5,108
8111fd40:	a1800044 	addi	r6,r20,1
8111fd44:	20c0a236 	bltu	r4,r3,8111ffd0 <__svfscanf_r+0x3bc>
8111fd48:	180490ba 	slli	r2,r3,2
8111fd4c:	022044b4 	movhi	r8,33042
8111fd50:	423f5804 	addi	r8,r8,-672
8111fd54:	1205883a 	add	r2,r2,r8
8111fd58:	10800017 	ldw	r2,0(r2)
8111fd5c:	1000683a 	jmp	r2
8111fd60:	8111ff84 	addi	r4,r16,18430
8111fd64:	8111ffd0 	cmplti	r4,r16,18431
8111fd68:	8111ffd0 	cmplti	r4,r16,18431
8111fd6c:	8111ffd0 	cmplti	r4,r16,18431
8111fd70:	8111ffd0 	cmplti	r4,r16,18431
8111fd74:	8111ffd0 	cmplti	r4,r16,18431
8111fd78:	8111ffd0 	cmplti	r4,r16,18431
8111fd7c:	8111ffd0 	cmplti	r4,r16,18431
8111fd80:	8111ffd0 	cmplti	r4,r16,18431
8111fd84:	8111ffd0 	cmplti	r4,r16,18431
8111fd88:	8111ffd0 	cmplti	r4,r16,18431
8111fd8c:	8111ffd0 	cmplti	r4,r16,18431
8111fd90:	8111ffd0 	cmplti	r4,r16,18431
8111fd94:	8111ffd0 	cmplti	r4,r16,18431
8111fd98:	8111ffd0 	cmplti	r4,r16,18431
8111fd9c:	8111ffd0 	cmplti	r4,r16,18431
8111fda0:	8111ffd0 	cmplti	r4,r16,18431
8111fda4:	8111ffd0 	cmplti	r4,r16,18431
8111fda8:	8111ffd0 	cmplti	r4,r16,18431
8111fdac:	8111ffd0 	cmplti	r4,r16,18431
8111fdb0:	8111ffd0 	cmplti	r4,r16,18431
8111fdb4:	8111ffd0 	cmplti	r4,r16,18431
8111fdb8:	8111ffd0 	cmplti	r4,r16,18431
8111fdbc:	8111ffd0 	cmplti	r4,r16,18431
8111fdc0:	8111ffd0 	cmplti	r4,r16,18431
8111fdc4:	8111ffd0 	cmplti	r4,r16,18431
8111fdc8:	8111ffd0 	cmplti	r4,r16,18431
8111fdcc:	8111ffd0 	cmplti	r4,r16,18431
8111fdd0:	8111ffd0 	cmplti	r4,r16,18431
8111fdd4:	8111ffd0 	cmplti	r4,r16,18431
8111fdd8:	8111ffd0 	cmplti	r4,r16,18431
8111fddc:	8111ffd0 	cmplti	r4,r16,18431
8111fde0:	8111ffd0 	cmplti	r4,r16,18431
8111fde4:	8111ffd0 	cmplti	r4,r16,18431
8111fde8:	8111ffd0 	cmplti	r4,r16,18431
8111fdec:	8111ffd0 	cmplti	r4,r16,18431
8111fdf0:	8111ffd0 	cmplti	r4,r16,18431
8111fdf4:	8111ff44 	addi	r4,r16,18429
8111fdf8:	8111ffd0 	cmplti	r4,r16,18431
8111fdfc:	8111ffd0 	cmplti	r4,r16,18431
8111fe00:	8111ffd0 	cmplti	r4,r16,18431
8111fe04:	8111ffd0 	cmplti	r4,r16,18431
8111fe08:	8111ffb8 	rdprs	r4,r16,18430
8111fe0c:	8111ffd0 	cmplti	r4,r16,18431
8111fe10:	8111ffd0 	cmplti	r4,r16,18431
8111fe14:	8111ffd0 	cmplti	r4,r16,18431
8111fe18:	8111ffd0 	cmplti	r4,r16,18431
8111fe1c:	8111ffd0 	cmplti	r4,r16,18431
8111fe20:	811200ec 	andhi	r4,r16,18435
8111fe24:	811200ec 	andhi	r4,r16,18435
8111fe28:	811200ec 	andhi	r4,r16,18435
8111fe2c:	811200ec 	andhi	r4,r16,18435
8111fe30:	811200ec 	andhi	r4,r16,18435
8111fe34:	811200ec 	andhi	r4,r16,18435
8111fe38:	811200ec 	andhi	r4,r16,18435
8111fe3c:	811200ec 	andhi	r4,r16,18435
8111fe40:	811200ec 	andhi	r4,r16,18435
8111fe44:	811200ec 	andhi	r4,r16,18435
8111fe48:	8111ffd0 	cmplti	r4,r16,18431
8111fe4c:	8111ffd0 	cmplti	r4,r16,18431
8111fe50:	8111ffd0 	cmplti	r4,r16,18431
8111fe54:	8111ffd0 	cmplti	r4,r16,18431
8111fe58:	8111ffd0 	cmplti	r4,r16,18431
8111fe5c:	8111ffd0 	cmplti	r4,r16,18431
8111fe60:	8111ffd0 	cmplti	r4,r16,18431
8111fe64:	8111ffd0 	cmplti	r4,r16,18431
8111fe68:	8111ffd0 	cmplti	r4,r16,18431
8111fe6c:	8111ffd0 	cmplti	r4,r16,18431
8111fe70:	811200c0 	call	8811200c <__reset+0x20f200c>
8111fe74:	81120170 	cmpltui	r4,r16,18437
8111fe78:	8111ffd0 	cmplti	r4,r16,18431
8111fe7c:	81120170 	cmpltui	r4,r16,18437
8111fe80:	8111ffd0 	cmplti	r4,r16,18431
8111fe84:	8111ffd0 	cmplti	r4,r16,18431
8111fe88:	8111ffd0 	cmplti	r4,r16,18431
8111fe8c:	8111ffd0 	cmplti	r4,r16,18431
8111fe90:	8112015c 	xori	r4,r16,18437
8111fe94:	8111ffd0 	cmplti	r4,r16,18431
8111fe98:	8111ffd0 	cmplti	r4,r16,18431
8111fe9c:	81120130 	cmpltui	r4,r16,18436
8111fea0:	8111ffd0 	cmplti	r4,r16,18431
8111fea4:	8111ffd0 	cmplti	r4,r16,18431
8111fea8:	8111ffd0 	cmplti	r4,r16,18431
8111feac:	8111ffd0 	cmplti	r4,r16,18431
8111feb0:	8111ffd0 	cmplti	r4,r16,18431
8111feb4:	8111ffd0 	cmplti	r4,r16,18431
8111feb8:	8111ffd0 	cmplti	r4,r16,18431
8111febc:	8111ffd0 	cmplti	r4,r16,18431
8111fec0:	81120108 	cmpgei	r4,r16,18436
8111fec4:	8111ffd0 	cmplti	r4,r16,18431
8111fec8:	8111ffd0 	cmplti	r4,r16,18431
8111fecc:	811202a4 	muli	r4,r16,18442
8111fed0:	8111ffd0 	cmplti	r4,r16,18431
8111fed4:	8111ffd0 	cmplti	r4,r16,18431
8111fed8:	8111ffd0 	cmplti	r4,r16,18431
8111fedc:	8111ffd0 	cmplti	r4,r16,18431
8111fee0:	8111ffd0 	cmplti	r4,r16,18431
8111fee4:	8111ffd0 	cmplti	r4,r16,18431
8111fee8:	8111ffd0 	cmplti	r4,r16,18431
8111feec:	81120228 	cmpgeui	r4,r16,18440
8111fef0:	81120200 	call	88112020 <__reset+0x20f2020>
8111fef4:	81120170 	cmpltui	r4,r16,18437
8111fef8:	81120170 	cmpltui	r4,r16,18437
8111fefc:	81120170 	cmpltui	r4,r16,18437
8111ff00:	811201ec 	andhi	r4,r16,18439
8111ff04:	81120330 	cmpltui	r4,r16,18444
8111ff08:	8111ffd0 	cmplti	r4,r16,18431
8111ff0c:	8111ffd0 	cmplti	r4,r16,18431
8111ff10:	811201d8 	cmpnei	r4,r16,18439
8111ff14:	8111ffd0 	cmplti	r4,r16,18431
8111ff18:	811201a8 	cmpgeui	r4,r16,18438
8111ff1c:	81120184 	addi	r4,r16,18438
8111ff20:	81120094 	ori	r4,r16,18434
8111ff24:	8111ffd0 	cmplti	r4,r16,18431
8111ff28:	8111ffd0 	cmplti	r4,r16,18431
8111ff2c:	81120080 	call	88112008 <__reset+0x20f2008>
8111ff30:	8111ffd0 	cmplti	r4,r16,18431
8111ff34:	81120008 	cmpgei	r4,r16,18432
8111ff38:	8111ffd0 	cmplti	r4,r16,18431
8111ff3c:	8111ffd0 	cmplti	r4,r16,18431
8111ff40:	81120108 	cmpgei	r4,r16,18436
8111ff44:	d9809d15 	stw	r6,628(sp)
8111ff48:	3029883a 	mov	r20,r6
8111ff4c:	e0800117 	ldw	r2,4(fp)
8111ff50:	0081aa0e 	bge	zero,r2,811205fc <__svfscanf_r+0x9e8>
8111ff54:	e0800017 	ldw	r2,0(fp)
8111ff58:	a0ffffc3 	ldbu	r3,-1(r20)
8111ff5c:	11000003 	ldbu	r4,0(r2)
8111ff60:	20ff6e1e 	bne	r4,r3,8111fd1c <__reset+0xfb0ffd1c>
8111ff64:	e0c00117 	ldw	r3,4(fp)
8111ff68:	10800044 	addi	r2,r2,1
8111ff6c:	e0800015 	stw	r2,0(fp)
8111ff70:	18bfffc4 	addi	r2,r3,-1
8111ff74:	e0800115 	stw	r2,4(fp)
8111ff78:	94800044 	addi	r18,r18,1
8111ff7c:	a00d883a 	mov	r6,r20
8111ff80:	003f6206 	br	8111fd0c <__reset+0xfb0ffd0c>
8111ff84:	00bfffc4 	movi	r2,-1
8111ff88:	dfc0b417 	ldw	ra,720(sp)
8111ff8c:	df00b317 	ldw	fp,716(sp)
8111ff90:	ddc0b217 	ldw	r23,712(sp)
8111ff94:	dd80b117 	ldw	r22,708(sp)
8111ff98:	dd40b017 	ldw	r21,704(sp)
8111ff9c:	dd00af17 	ldw	r20,700(sp)
8111ffa0:	dcc0ae17 	ldw	r19,696(sp)
8111ffa4:	dc80ad17 	ldw	r18,692(sp)
8111ffa8:	dc40ac17 	ldw	r17,688(sp)
8111ffac:	dc00ab17 	ldw	r16,684(sp)
8111ffb0:	dec0b504 	addi	sp,sp,724
8111ffb4:	f800283a 	ret
8111ffb8:	a0800043 	ldbu	r2,1(r20)
8111ffbc:	3029883a 	mov	r20,r6
8111ffc0:	8c400414 	ori	r17,r17,16
8111ffc4:	10c03fcc 	andi	r3,r2,255
8111ffc8:	a1800044 	addi	r6,r20,1
8111ffcc:	20ff5e2e 	bgeu	r4,r3,8111fd48 <__reset+0xfb0ffd48>
8111ffd0:	38c7883a 	add	r3,r7,r3
8111ffd4:	18800043 	ldbu	r2,1(r3)
8111ffd8:	d9809d15 	stw	r6,628(sp)
8111ffdc:	00c00044 	movi	r3,1
8111ffe0:	108000cc 	andi	r2,r2,3
8111ffe4:	10c18f26 	beq	r2,r3,81120624 <__svfscanf_r+0xa10>
8111ffe8:	e0800117 	ldw	r2,4(fp)
8111ffec:	00808716 	blt	zero,r2,8112020c <__svfscanf_r+0x5f8>
8111fff0:	e00b883a 	mov	r5,fp
8111fff4:	b009883a 	mov	r4,r22
8111fff8:	11267800 	call	81126780 <__srefill_r>
8111fffc:	1001431e 	bne	r2,zero,8112050c <__svfscanf_r+0x8f8>
81120000:	b9c00017 	ldw	r7,0(r23)
81120004:	00008106 	br	8112020c <__svfscanf_r+0x5f8>
81120008:	e0800117 	ldw	r2,4(fp)
8112000c:	d9809d15 	stw	r6,628(sp)
81120010:	0081a30e 	bge	zero,r2,811206a0 <__svfscanf_r+0xa8c>
81120014:	00a044f4 	movhi	r2,33043
81120018:	10a13004 	addi	r2,r2,-31552
8112001c:	02000284 	movi	r8,10
81120020:	d880a115 	stw	r2,644(sp)
81120024:	da009e15 	stw	r8,632(sp)
81120028:	050000c4 	movi	r20,3
8112002c:	e0c00017 	ldw	r3,0(fp)
81120030:	00000206 	br	8112003c <__svfscanf_r+0x428>
81120034:	18c00044 	addi	r3,r3,1
81120038:	e0c00015 	stw	r3,0(fp)
8112003c:	19000003 	ldbu	r4,0(r3)
81120040:	20803fcc 	andi	r2,r4,255
81120044:	3885883a 	add	r2,r7,r2
81120048:	10800043 	ldbu	r2,1(r2)
8112004c:	1140020c 	andi	r5,r2,8
81120050:	2801ab26 	beq	r5,zero,81120700 <__svfscanf_r+0xaec>
81120054:	e0800117 	ldw	r2,4(fp)
81120058:	94800044 	addi	r18,r18,1
8112005c:	10bfffc4 	addi	r2,r2,-1
81120060:	e0800115 	stw	r2,4(fp)
81120064:	00bff316 	blt	zero,r2,81120034 <__reset+0xfb100034>
81120068:	e00b883a 	mov	r5,fp
8112006c:	b009883a 	mov	r4,r22
81120070:	11267800 	call	81126780 <__srefill_r>
81120074:	1001251e 	bne	r2,zero,8112050c <__svfscanf_r+0x8f8>
81120078:	b9c00017 	ldw	r7,0(r23)
8112007c:	003feb06 	br	8112002c <__reset+0xfb10002c>
81120080:	e0800117 	ldw	r2,4(fp)
81120084:	d9809d15 	stw	r6,628(sp)
81120088:	00818b0e 	bge	zero,r2,811206b8 <__svfscanf_r+0xaa4>
8112008c:	05000084 	movi	r20,2
81120090:	003fe606 	br	8112002c <__reset+0xfb10002c>
81120094:	e0800117 	ldw	r2,4(fp)
81120098:	d9809d15 	stw	r6,628(sp)
8112009c:	8c408814 	ori	r17,r17,544
811200a0:	00801d0e 	bge	zero,r2,81120118 <__svfscanf_r+0x504>
811200a4:	00a044f4 	movhi	r2,33043
811200a8:	10a13004 	addi	r2,r2,-31552
811200ac:	02000404 	movi	r8,16
811200b0:	d880a115 	stw	r2,644(sp)
811200b4:	da009e15 	stw	r8,632(sp)
811200b8:	050000c4 	movi	r20,3
811200bc:	003fdb06 	br	8112002c <__reset+0xfb10002c>
811200c0:	e0800117 	ldw	r2,4(fp)
811200c4:	d9809d15 	stw	r6,628(sp)
811200c8:	8c400054 	ori	r17,r17,1
811200cc:	00bfc80e 	bge	zero,r2,8111fff0 <__reset+0xfb0ffff0>
811200d0:	00e044b4 	movhi	r3,33042
811200d4:	18ec7d04 	addi	r3,r3,-19980
811200d8:	02000284 	movi	r8,10
811200dc:	d8c0a115 	stw	r3,644(sp)
811200e0:	da009e15 	stw	r8,632(sp)
811200e4:	050000c4 	movi	r20,3
811200e8:	003fd006 	br	8112002c <__reset+0xfb10002c>
811200ec:	9cc002a4 	muli	r19,r19,10
811200f0:	a0800043 	ldbu	r2,1(r20)
811200f4:	3029883a 	mov	r20,r6
811200f8:	98e7883a 	add	r19,r19,r3
811200fc:	9cfff404 	addi	r19,r19,-48
81120100:	10c03fcc 	andi	r3,r2,255
81120104:	003f0e06 	br	8111fd40 <__reset+0xfb0ffd40>
81120108:	e0800117 	ldw	r2,4(fp)
8112010c:	d9809d15 	stw	r6,628(sp)
81120110:	8c408014 	ori	r17,r17,512
81120114:	00bfe316 	blt	zero,r2,811200a4 <__reset+0xfb1000a4>
81120118:	e00b883a 	mov	r5,fp
8112011c:	b009883a 	mov	r4,r22
81120120:	11267800 	call	81126780 <__srefill_r>
81120124:	1000f91e 	bne	r2,zero,8112050c <__svfscanf_r+0x8f8>
81120128:	b9c00017 	ldw	r7,0(r23)
8112012c:	003fdd06 	br	811200a4 <__reset+0xfb1000a4>
81120130:	e0800117 	ldw	r2,4(fp)
81120134:	d9809d15 	stw	r6,628(sp)
81120138:	8c400054 	ori	r17,r17,1
8112013c:	0080140e 	bge	zero,r2,81120190 <__svfscanf_r+0x57c>
81120140:	00a044f4 	movhi	r2,33043
81120144:	10a13004 	addi	r2,r2,-31552
81120148:	02000204 	movi	r8,8
8112014c:	d880a115 	stw	r2,644(sp)
81120150:	da009e15 	stw	r8,632(sp)
81120154:	050000c4 	movi	r20,3
81120158:	003fb406 	br	8112002c <__reset+0xfb10002c>
8112015c:	a0800043 	ldbu	r2,1(r20)
81120160:	8c400094 	ori	r17,r17,2
81120164:	3029883a 	mov	r20,r6
81120168:	10c03fcc 	andi	r3,r2,255
8112016c:	003ef406 	br	8111fd40 <__reset+0xfb0ffd40>
81120170:	e0800117 	ldw	r2,4(fp)
81120174:	d9809d15 	stw	r6,628(sp)
81120178:	0081420e 	bge	zero,r2,81120684 <__svfscanf_r+0xa70>
8112017c:	05000104 	movi	r20,4
81120180:	003faa06 	br	8112002c <__reset+0xfb10002c>
81120184:	e0800117 	ldw	r2,4(fp)
81120188:	d9809d15 	stw	r6,628(sp)
8112018c:	00bfec16 	blt	zero,r2,81120140 <__reset+0xfb100140>
81120190:	e00b883a 	mov	r5,fp
81120194:	b009883a 	mov	r4,r22
81120198:	11267800 	call	81126780 <__srefill_r>
8112019c:	1000db1e 	bne	r2,zero,8112050c <__svfscanf_r+0x8f8>
811201a0:	b9c00017 	ldw	r7,0(r23)
811201a4:	003fe606 	br	81120140 <__reset+0xfb100140>
811201a8:	d9809d15 	stw	r6,628(sp)
811201ac:	8880040c 	andi	r2,r17,16
811201b0:	10009c1e 	bne	r2,zero,81120424 <__svfscanf_r+0x810>
811201b4:	8880010c 	andi	r2,r17,4
811201b8:	10011e26 	beq	r2,zero,81120634 <__svfscanf_r+0xa20>
811201bc:	da009c17 	ldw	r8,624(sp)
811201c0:	3029883a 	mov	r20,r6
811201c4:	40800017 	ldw	r2,0(r8)
811201c8:	42000104 	addi	r8,r8,4
811201cc:	da009c15 	stw	r8,624(sp)
811201d0:	1480000d 	sth	r18,0(r2)
811201d4:	003ecc06 	br	8111fd08 <__reset+0xfb0ffd08>
811201d8:	a0c00043 	ldbu	r3,1(r20)
811201dc:	19410c26 	beq	r3,r5,81120610 <__svfscanf_r+0x9fc>
811201e0:	8c400054 	ori	r17,r17,1
811201e4:	3029883a 	mov	r20,r6
811201e8:	003ed506 	br	8111fd40 <__reset+0xfb0ffd40>
811201ec:	a0800043 	ldbu	r2,1(r20)
811201f0:	8c400114 	ori	r17,r17,4
811201f4:	3029883a 	mov	r20,r6
811201f8:	10c03fcc 	andi	r3,r2,255
811201fc:	003ed006 	br	8111fd40 <__reset+0xfb0ffd40>
81120200:	e0800117 	ldw	r2,4(fp)
81120204:	d9809d15 	stw	r6,628(sp)
81120208:	00bf790e 	bge	zero,r2,8111fff0 <__reset+0xfb0ffff0>
8112020c:	00a044b4 	movhi	r2,33042
81120210:	10ac7d04 	addi	r2,r2,-19980
81120214:	02000284 	movi	r8,10
81120218:	d880a115 	stw	r2,644(sp)
8112021c:	da009e15 	stw	r8,632(sp)
81120220:	050000c4 	movi	r20,3
81120224:	003f8106 	br	8112002c <__reset+0xfb10002c>
81120228:	e0800117 	ldw	r2,4(fp)
8112022c:	d9809d15 	stw	r6,628(sp)
81120230:	0080c40e 	bge	zero,r2,81120544 <__svfscanf_r+0x930>
81120234:	9800011e 	bne	r19,zero,8112023c <__svfscanf_r+0x628>
81120238:	04c00044 	movi	r19,1
8112023c:	8880004c 	andi	r2,r17,1
81120240:	1000441e 	bne	r2,zero,81120354 <__svfscanf_r+0x740>
81120244:	8c40040c 	andi	r17,r17,16
81120248:	8800da26 	beq	r17,zero,811205b4 <__svfscanf_r+0x9a0>
8112024c:	0021883a 	mov	r16,zero
81120250:	00000806 	br	81120274 <__svfscanf_r+0x660>
81120254:	1887883a 	add	r3,r3,r2
81120258:	e00b883a 	mov	r5,fp
8112025c:	b009883a 	mov	r4,r22
81120260:	e0c00015 	stw	r3,0(fp)
81120264:	80a1883a 	add	r16,r16,r2
81120268:	98a7c83a 	sub	r19,r19,r2
8112026c:	11267800 	call	81126780 <__srefill_r>
81120270:	1000ca1e 	bne	r2,zero,8112059c <__svfscanf_r+0x988>
81120274:	e0800117 	ldw	r2,4(fp)
81120278:	e0c00017 	ldw	r3,0(fp)
8112027c:	14fff516 	blt	r2,r19,81120254 <__reset+0xfb100254>
81120280:	14c5c83a 	sub	r2,r2,r19
81120284:	1cd5883a 	add	r10,r3,r19
81120288:	84e1883a 	add	r16,r16,r19
8112028c:	e0800115 	stw	r2,4(fp)
81120290:	e2800015 	stw	r10,0(fp)
81120294:	dd009d17 	ldw	r20,628(sp)
81120298:	9425883a 	add	r18,r18,r16
8112029c:	a00d883a 	mov	r6,r20
811202a0:	003e9a06 	br	8111fd0c <__reset+0xfb0ffd0c>
811202a4:	300b883a 	mov	r5,r6
811202a8:	d9005884 	addi	r4,sp,354
811202ac:	d9809d15 	stw	r6,628(sp)
811202b0:	1126a2c0 	call	81126a2c <__sccl>
811202b4:	1029883a 	mov	r20,r2
811202b8:	e0800117 	ldw	r2,4(fp)
811202bc:	0081050e 	bge	zero,r2,811206d4 <__svfscanf_r+0xac0>
811202c0:	e1000017 	ldw	r4,0(fp)
811202c4:	20800003 	ldbu	r2,0(r4)
811202c8:	98005926 	beq	r19,zero,81120430 <__svfscanf_r+0x81c>
811202cc:	8c40040c 	andi	r17,r17,16
811202d0:	88005a26 	beq	r17,zero,8112043c <__svfscanf_r+0x828>
811202d4:	9823883a 	mov	r17,r19
811202d8:	0021883a 	mov	r16,zero
811202dc:	00000106 	br	811202e4 <__svfscanf_r+0x6d0>
811202e0:	20800003 	ldbu	r2,0(r4)
811202e4:	10803fcc 	andi	r2,r2,255
811202e8:	d8c05884 	addi	r3,sp,354
811202ec:	1885883a 	add	r2,r3,r2
811202f0:	10800007 	ldb	r2,0(r2)
811202f4:	1000ad26 	beq	r2,zero,811205ac <__svfscanf_r+0x998>
811202f8:	e0800117 	ldw	r2,4(fp)
811202fc:	21000044 	addi	r4,r4,1
81120300:	84000044 	addi	r16,r16,1
81120304:	10bfffc4 	addi	r2,r2,-1
81120308:	e0800115 	stw	r2,4(fp)
8112030c:	e1000015 	stw	r4,0(fp)
81120310:	84c0a026 	beq	r16,r19,81120594 <__svfscanf_r+0x980>
81120314:	00bff216 	blt	zero,r2,811202e0 <__reset+0xfb1002e0>
81120318:	e00b883a 	mov	r5,fp
8112031c:	b009883a 	mov	r4,r22
81120320:	11267800 	call	81126780 <__srefill_r>
81120324:	10009a1e 	bne	r2,zero,81120590 <__svfscanf_r+0x97c>
81120328:	e1000017 	ldw	r4,0(fp)
8112032c:	003fec06 	br	811202e0 <__reset+0xfb1002e0>
81120330:	e0800117 	ldw	r2,4(fp)
81120334:	d9809d15 	stw	r6,628(sp)
81120338:	0080eb0e 	bge	zero,r2,811206e8 <__svfscanf_r+0xad4>
8112033c:	00a044b4 	movhi	r2,33042
81120340:	10ac7d04 	addi	r2,r2,-19980
81120344:	d880a115 	stw	r2,644(sp)
81120348:	d8009e15 	stw	zero,632(sp)
8112034c:	050000c4 	movi	r20,3
81120350:	003f3606 	br	8112002c <__reset+0xfb10002c>
81120354:	dd409904 	addi	r21,sp,612
81120358:	8c40040c 	andi	r17,r17,16
8112035c:	01800204 	movi	r6,8
81120360:	000b883a 	mov	r5,zero
81120364:	a809883a 	mov	r4,r21
81120368:	dc409f15 	stw	r17,636(sp)
8112036c:	111acfc0 	call	8111acfc <memset>
81120370:	dc409f17 	ldw	r17,636(sp)
81120374:	88006e26 	beq	r17,zero,81120530 <__svfscanf_r+0x91c>
81120378:	0029883a 	mov	r20,zero
8112037c:	0023883a 	mov	r17,zero
81120380:	11242ec0 	call	811242ec <__locale_mb_cur_max>
81120384:	14406126 	beq	r2,r17,8112050c <__svfscanf_r+0x8f8>
81120388:	e0800017 	ldw	r2,0(fp)
8112038c:	e0c00117 	ldw	r3,4(fp)
81120390:	d9000104 	addi	r4,sp,4
81120394:	12000003 	ldbu	r8,0(r2)
81120398:	18ffffc4 	addi	r3,r3,-1
8112039c:	10800044 	addi	r2,r2,1
811203a0:	e0c00115 	stw	r3,4(fp)
811203a4:	e0800015 	stw	r2,0(fp)
811203a8:	8c000044 	addi	r16,r17,1
811203ac:	dd400015 	stw	r21,0(sp)
811203b0:	2463883a 	add	r17,r4,r17
811203b4:	200d883a 	mov	r6,r4
811203b8:	a00b883a 	mov	r5,r20
811203bc:	800f883a 	mov	r7,r16
811203c0:	b009883a 	mov	r4,r22
811203c4:	8a000005 	stb	r8,0(r17)
811203c8:	1124d180 	call	81124d18 <_mbrtowc_r>
811203cc:	017fffc4 	movi	r5,-1
811203d0:	11404e26 	beq	r2,r5,8112050c <__svfscanf_r+0x8f8>
811203d4:	1000601e 	bne	r2,zero,81120558 <__svfscanf_r+0x944>
811203d8:	da009f17 	ldw	r8,636(sp)
811203dc:	4000641e 	bne	r8,zero,81120570 <__svfscanf_r+0x95c>
811203e0:	a0000015 	stw	zero,0(r20)
811203e4:	9425883a 	add	r18,r18,r16
811203e8:	9967883a 	add	r19,r19,r5
811203ec:	a5000104 	addi	r20,r20,4
811203f0:	e0800117 	ldw	r2,4(fp)
811203f4:	0023883a 	mov	r17,zero
811203f8:	00804b16 	blt	zero,r2,81120528 <__svfscanf_r+0x914>
811203fc:	e00b883a 	mov	r5,fp
81120400:	b009883a 	mov	r4,r22
81120404:	11267800 	call	81126780 <__srefill_r>
81120408:	10004726 	beq	r2,zero,81120528 <__svfscanf_r+0x914>
8112040c:	88003f1e 	bne	r17,zero,8112050c <__svfscanf_r+0x8f8>
81120410:	d8c09f17 	ldw	r3,636(sp)
81120414:	1800031e 	bne	r3,zero,81120424 <__svfscanf_r+0x810>
81120418:	da00a017 	ldw	r8,640(sp)
8112041c:	42000044 	addi	r8,r8,1
81120420:	da00a015 	stw	r8,640(sp)
81120424:	dd009d17 	ldw	r20,628(sp)
81120428:	a00d883a 	mov	r6,r20
8112042c:	003e3706 	br	8111fd0c <__reset+0xfb0ffd0c>
81120430:	8c40040c 	andi	r17,r17,16
81120434:	04ffffc4 	movi	r19,-1
81120438:	883fa61e 	bne	r17,zero,811202d4 <__reset+0xfb1002d4>
8112043c:	da009c17 	ldw	r8,624(sp)
81120440:	9abfffc4 	addi	r10,r19,-1
81120444:	44000017 	ldw	r16,0(r8)
81120448:	44400104 	addi	r17,r8,4
8112044c:	8007883a 	mov	r3,r16
81120450:	82ab883a 	add	r21,r16,r10
81120454:	00000306 	br	81120464 <__svfscanf_r+0x850>
81120458:	e1000017 	ldw	r4,0(fp)
8112045c:	9807883a 	mov	r3,r19
81120460:	20800003 	ldbu	r2,0(r4)
81120464:	10803fcc 	andi	r2,r2,255
81120468:	d9405884 	addi	r5,sp,354
8112046c:	2885883a 	add	r2,r5,r2
81120470:	10800007 	ldb	r2,0(r2)
81120474:	10004b26 	beq	r2,zero,811205a4 <__svfscanf_r+0x990>
81120478:	e0800117 	ldw	r2,4(fp)
8112047c:	21400044 	addi	r5,r4,1
81120480:	e1400015 	stw	r5,0(fp)
81120484:	10bfffc4 	addi	r2,r2,-1
81120488:	e0800115 	stw	r2,4(fp)
8112048c:	20800003 	ldbu	r2,0(r4)
81120490:	1cc00044 	addi	r19,r3,1
81120494:	18800005 	stb	r2,0(r3)
81120498:	1d400726 	beq	r3,r21,811204b8 <__svfscanf_r+0x8a4>
8112049c:	e0800117 	ldw	r2,4(fp)
811204a0:	00bfed16 	blt	zero,r2,81120458 <__reset+0xfb100458>
811204a4:	e00b883a 	mov	r5,fp
811204a8:	b009883a 	mov	r4,r22
811204ac:	11267800 	call	81126780 <__srefill_r>
811204b0:	103fe926 	beq	r2,zero,81120458 <__reset+0xfb100458>
811204b4:	84c01526 	beq	r16,r19,8112050c <__svfscanf_r+0x8f8>
811204b8:	9c21c83a 	sub	r16,r19,r16
811204bc:	803e1726 	beq	r16,zero,8111fd1c <__reset+0xfb0ffd1c>
811204c0:	da00a017 	ldw	r8,640(sp)
811204c4:	98000005 	stb	zero,0(r19)
811204c8:	dc409c15 	stw	r17,624(sp)
811204cc:	42000044 	addi	r8,r8,1
811204d0:	da00a015 	stw	r8,640(sp)
811204d4:	9425883a 	add	r18,r18,r16
811204d8:	a00d883a 	mov	r6,r20
811204dc:	003e0b06 	br	8111fd0c <__reset+0xfb0ffd0c>
811204e0:	017fff84 	movi	r5,-2
811204e4:	11439b1e 	bne	r2,r5,81121354 <__svfscanf_r+0x1740>
811204e8:	8821883a 	mov	r16,r17
811204ec:	e0800117 	ldw	r2,4(fp)
811204f0:	0082e516 	blt	zero,r2,81121088 <__svfscanf_r+0x1474>
811204f4:	e00b883a 	mov	r5,fp
811204f8:	b009883a 	mov	r4,r22
811204fc:	11267800 	call	81126780 <__srefill_r>
81120500:	1002e126 	beq	r2,zero,81121088 <__svfscanf_r+0x1474>
81120504:	dc409f17 	ldw	r17,636(sp)
81120508:	8002e826 	beq	r16,zero,811210ac <__svfscanf_r+0x1498>
8112050c:	da00a017 	ldw	r8,640(sp)
81120510:	403e9c26 	beq	r8,zero,8111ff84 <__reset+0xfb0fff84>
81120514:	e080030b 	ldhu	r2,12(fp)
81120518:	1080100c 	andi	r2,r2,64
8112051c:	103e991e 	bne	r2,zero,8111ff84 <__reset+0xfb0fff84>
81120520:	4005883a 	mov	r2,r8
81120524:	003e9806 	br	8111ff88 <__reset+0xfb0fff88>
81120528:	983f951e 	bne	r19,zero,81120380 <__reset+0xfb100380>
8112052c:	003fb806 	br	81120410 <__reset+0xfb100410>
81120530:	da009c17 	ldw	r8,624(sp)
81120534:	45000017 	ldw	r20,0(r8)
81120538:	42000104 	addi	r8,r8,4
8112053c:	da009c15 	stw	r8,624(sp)
81120540:	003f8e06 	br	8112037c <__reset+0xfb10037c>
81120544:	e00b883a 	mov	r5,fp
81120548:	b009883a 	mov	r4,r22
8112054c:	11267800 	call	81126780 <__srefill_r>
81120550:	103f3826 	beq	r2,zero,81120234 <__reset+0xfb100234>
81120554:	003fed06 	br	8112050c <__reset+0xfb10050c>
81120558:	00ffff84 	movi	r3,-2
8112055c:	10c0071e 	bne	r2,r3,8112057c <__svfscanf_r+0x968>
81120560:	e0800117 	ldw	r2,4(fp)
81120564:	8023883a 	mov	r17,r16
81120568:	00bf8516 	blt	zero,r2,81120380 <__reset+0xfb100380>
8112056c:	003fa306 	br	811203fc <__reset+0xfb1003fc>
81120570:	9425883a 	add	r18,r18,r16
81120574:	9cffffc4 	addi	r19,r19,-1
81120578:	003f9d06 	br	811203f0 <__reset+0xfb1003f0>
8112057c:	da009f17 	ldw	r8,636(sp)
81120580:	9425883a 	add	r18,r18,r16
81120584:	9cffffc4 	addi	r19,r19,-1
81120588:	403f9826 	beq	r8,zero,811203ec <__reset+0xfb1003ec>
8112058c:	003f9806 	br	811203f0 <__reset+0xfb1003f0>
81120590:	8023883a 	mov	r17,r16
81120594:	8821883a 	mov	r16,r17
81120598:	003fce06 	br	811204d4 <__reset+0xfb1004d4>
8112059c:	803f3d1e 	bne	r16,zero,81120294 <__reset+0xfb100294>
811205a0:	003fda06 	br	8112050c <__reset+0xfb10050c>
811205a4:	1827883a 	mov	r19,r3
811205a8:	003fc306 	br	811204b8 <__reset+0xfb1004b8>
811205ac:	803fc91e 	bne	r16,zero,811204d4 <__reset+0xfb1004d4>
811205b0:	003dda06 	br	8111fd1c <__reset+0xfb0ffd1c>
811205b4:	da009c17 	ldw	r8,624(sp)
811205b8:	df000015 	stw	fp,0(sp)
811205bc:	980f883a 	mov	r7,r19
811205c0:	41400017 	ldw	r5,0(r8)
811205c4:	01800044 	movi	r6,1
811205c8:	b009883a 	mov	r4,r22
811205cc:	112351c0 	call	8112351c <_fread_r>
811205d0:	da009c17 	ldw	r8,624(sp)
811205d4:	40c00104 	addi	r3,r8,4
811205d8:	103fcc26 	beq	r2,zero,8112050c <__reset+0xfb10050c>
811205dc:	da00a017 	ldw	r8,640(sp)
811205e0:	dd009d17 	ldw	r20,628(sp)
811205e4:	90a5883a 	add	r18,r18,r2
811205e8:	42000044 	addi	r8,r8,1
811205ec:	da00a015 	stw	r8,640(sp)
811205f0:	d8c09c15 	stw	r3,624(sp)
811205f4:	a00d883a 	mov	r6,r20
811205f8:	003dc406 	br	8111fd0c <__reset+0xfb0ffd0c>
811205fc:	e00b883a 	mov	r5,fp
81120600:	b009883a 	mov	r4,r22
81120604:	11267800 	call	81126780 <__srefill_r>
81120608:	103e5226 	beq	r2,zero,8111ff54 <__reset+0xfb0fff54>
8112060c:	003fbf06 	br	8112050c <__reset+0xfb10050c>
81120610:	a0800083 	ldbu	r2,2(r20)
81120614:	8c400094 	ori	r17,r17,2
81120618:	a5000084 	addi	r20,r20,2
8112061c:	10c03fcc 	andi	r3,r2,255
81120620:	003dc706 	br	8111fd40 <__reset+0xfb0ffd40>
81120624:	e0800117 	ldw	r2,4(fp)
81120628:	88e2b03a 	or	r17,r17,r3
8112062c:	00bef716 	blt	zero,r2,8112020c <__reset+0xfb10020c>
81120630:	003e6f06 	br	8111fff0 <__reset+0xfb0ffff0>
81120634:	8880004c 	andi	r2,r17,1
81120638:	10000b1e 	bne	r2,zero,81120668 <__svfscanf_r+0xa54>
8112063c:	8c40008c 	andi	r17,r17,2
81120640:	88000926 	beq	r17,zero,81120668 <__svfscanf_r+0xa54>
81120644:	da009c17 	ldw	r8,624(sp)
81120648:	9007d7fa 	srai	r3,r18,31
8112064c:	dd009d17 	ldw	r20,628(sp)
81120650:	40800017 	ldw	r2,0(r8)
81120654:	42000104 	addi	r8,r8,4
81120658:	da009c15 	stw	r8,624(sp)
8112065c:	14800015 	stw	r18,0(r2)
81120660:	10c00115 	stw	r3,4(r2)
81120664:	003da806 	br	8111fd08 <__reset+0xfb0ffd08>
81120668:	da009c17 	ldw	r8,624(sp)
8112066c:	dd009d17 	ldw	r20,628(sp)
81120670:	40800017 	ldw	r2,0(r8)
81120674:	42000104 	addi	r8,r8,4
81120678:	da009c15 	stw	r8,624(sp)
8112067c:	14800015 	stw	r18,0(r2)
81120680:	003da106 	br	8111fd08 <__reset+0xfb0ffd08>
81120684:	e00b883a 	mov	r5,fp
81120688:	b009883a 	mov	r4,r22
8112068c:	11267800 	call	81126780 <__srefill_r>
81120690:	103f9e1e 	bne	r2,zero,8112050c <__reset+0xfb10050c>
81120694:	b9c00017 	ldw	r7,0(r23)
81120698:	05000104 	movi	r20,4
8112069c:	003e6306 	br	8112002c <__reset+0xfb10002c>
811206a0:	e00b883a 	mov	r5,fp
811206a4:	b009883a 	mov	r4,r22
811206a8:	11267800 	call	81126780 <__srefill_r>
811206ac:	103f971e 	bne	r2,zero,8112050c <__reset+0xfb10050c>
811206b0:	b9c00017 	ldw	r7,0(r23)
811206b4:	003e5706 	br	81120014 <__reset+0xfb100014>
811206b8:	e00b883a 	mov	r5,fp
811206bc:	b009883a 	mov	r4,r22
811206c0:	11267800 	call	81126780 <__srefill_r>
811206c4:	103f911e 	bne	r2,zero,8112050c <__reset+0xfb10050c>
811206c8:	b9c00017 	ldw	r7,0(r23)
811206cc:	05000084 	movi	r20,2
811206d0:	003e5606 	br	8112002c <__reset+0xfb10002c>
811206d4:	e00b883a 	mov	r5,fp
811206d8:	b009883a 	mov	r4,r22
811206dc:	11267800 	call	81126780 <__srefill_r>
811206e0:	103ef726 	beq	r2,zero,811202c0 <__reset+0xfb1002c0>
811206e4:	003f8906 	br	8112050c <__reset+0xfb10050c>
811206e8:	e00b883a 	mov	r5,fp
811206ec:	b009883a 	mov	r4,r22
811206f0:	11267800 	call	81126780 <__srefill_r>
811206f4:	103f851e 	bne	r2,zero,8112050c <__reset+0xfb10050c>
811206f8:	b9c00017 	ldw	r7,0(r23)
811206fc:	003f0f06 	br	8112033c <__reset+0xfb10033c>
81120700:	014000c4 	movi	r5,3
81120704:	a1414a26 	beq	r20,r5,81120c30 <__svfscanf_r+0x101c>
81120708:	01000104 	movi	r4,4
8112070c:	a101f11e 	bne	r20,r4,81120ed4 <__svfscanf_r+0x12c0>
81120710:	b009883a 	mov	r4,r22
81120714:	11243100 	call	81124310 <_localeconv_r>
81120718:	10800017 	ldw	r2,0(r2)
8112071c:	98ffffc4 	addi	r3,r19,-1
81120720:	d880a315 	stw	r2,652(sp)
81120724:	00805704 	movi	r2,348
81120728:	10c21e2e 	bgeu	r2,r3,81120fa4 <__svfscanf_r+0x1390>
8112072c:	9cffa8c4 	addi	r19,r19,-349
81120730:	dcc0a215 	stw	r19,648(sp)
81120734:	04c05744 	movi	r19,349
81120738:	8d01e014 	ori	r20,r17,1920
8112073c:	0023883a 	mov	r17,zero
81120740:	dc000104 	addi	r16,sp,4
81120744:	8805883a 	mov	r2,r17
81120748:	0019883a 	mov	r12,zero
8112074c:	8023883a 	mov	r17,r16
81120750:	b007883a 	mov	r3,r22
81120754:	9821883a 	mov	r16,r19
81120758:	002b883a 	mov	r21,zero
8112075c:	d800a515 	stw	zero,660(sp)
81120760:	d800a415 	stw	zero,656(sp)
81120764:	d8009f15 	stw	zero,636(sp)
81120768:	01c01384 	movi	r7,78
8112076c:	602d883a 	mov	r22,r12
81120770:	1027883a 	mov	r19,r2
81120774:	e1000017 	ldw	r4,0(fp)
81120778:	21400003 	ldbu	r5,0(r4)
8112077c:	28bff544 	addi	r2,r5,-43
81120780:	10803fcc 	andi	r2,r2,255
81120784:	38810e36 	bltu	r7,r2,81120bc0 <__svfscanf_r+0xfac>
81120788:	100490ba 	slli	r2,r2,2
8112078c:	01a044b4 	movhi	r6,33042
81120790:	3181e804 	addi	r6,r6,1952
81120794:	1185883a 	add	r2,r2,r6
81120798:	10800017 	ldw	r2,0(r2)
8112079c:	1000683a 	jmp	r2
811207a0:	81120a98 	cmpnei	r4,r16,18474
811207a4:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811207a8:	81120a98 	cmpnei	r4,r16,18474
811207ac:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811207b0:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811207b4:	81120a6c 	andhi	r4,r16,18473
811207b8:	811208dc 	xori	r4,r16,18467
811207bc:	811208dc 	xori	r4,r16,18467
811207c0:	811208dc 	xori	r4,r16,18467
811207c4:	811208dc 	xori	r4,r16,18467
811207c8:	811208dc 	xori	r4,r16,18467
811207cc:	811208dc 	xori	r4,r16,18467
811207d0:	811208dc 	xori	r4,r16,18467
811207d4:	811208dc 	xori	r4,r16,18467
811207d8:	811208dc 	xori	r4,r16,18467
811207dc:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811207e0:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811207e4:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811207e8:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811207ec:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811207f0:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811207f4:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811207f8:	81120bb0 	cmpltui	r4,r16,18478
811207fc:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120800:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120804:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120808:	81120b6c 	andhi	r4,r16,18477
8112080c:	81120b50 	cmplti	r4,r16,18477
81120810:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120814:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120818:	81120b1c 	xori	r4,r16,18476
8112081c:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120820:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120824:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120828:	81120bc0 	call	881120bc <__reset+0x20f20bc>
8112082c:	81120ae4 	muli	r4,r16,18475
81120830:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120834:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120838:	81120bc0 	call	881120bc <__reset+0x20f20bc>
8112083c:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120840:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120844:	81120ac8 	cmpgei	r4,r16,18475
81120848:	81120bc0 	call	881120bc <__reset+0x20f20bc>
8112084c:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120850:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120854:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120858:	81120aac 	andhi	r4,r16,18474
8112085c:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120860:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120864:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120868:	81120bc0 	call	881120bc <__reset+0x20f20bc>
8112086c:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120870:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120874:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120878:	81120bb0 	cmpltui	r4,r16,18478
8112087c:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120880:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120884:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120888:	81120b6c 	andhi	r4,r16,18477
8112088c:	81120b50 	cmplti	r4,r16,18477
81120890:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120894:	81120bc0 	call	881120bc <__reset+0x20f20bc>
81120898:	81120b1c 	xori	r4,r16,18476
8112089c:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811208a0:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811208a4:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811208a8:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811208ac:	81120ae4 	muli	r4,r16,18475
811208b0:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811208b4:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811208b8:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811208bc:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811208c0:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811208c4:	81120ac8 	cmpgei	r4,r16,18475
811208c8:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811208cc:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811208d0:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811208d4:	81120bc0 	call	881120bc <__reset+0x20f20bc>
811208d8:	81120aac 	andhi	r4,r16,18474
811208dc:	a8803fcc 	andi	r2,r21,255
811208e0:	1080201c 	xori	r2,r2,128
811208e4:	10bfe004 	addi	r2,r2,-128
811208e8:	b085883a 	add	r2,r22,r2
811208ec:	10000d1e 	bne	r2,zero,81120924 <__svfscanf_r+0xd10>
811208f0:	00bf9fc4 	movi	r2,-385
811208f4:	a0a8703a 	and	r20,r20,r2
811208f8:	89400005 	stb	r5,0(r17)
811208fc:	8c400044 	addi	r17,r17,1
81120900:	e0800117 	ldw	r2,4(fp)
81120904:	843fffc4 	addi	r16,r16,-1
81120908:	94800044 	addi	r18,r18,1
8112090c:	10bfffc4 	addi	r2,r2,-1
81120910:	e0800115 	stw	r2,4(fp)
81120914:	0080b40e 	bge	zero,r2,81120be8 <__svfscanf_r+0xfd4>
81120918:	21000044 	addi	r4,r4,1
8112091c:	e1000015 	stw	r4,0(fp)
81120920:	803f941e 	bne	r16,zero,81120774 <__reset+0xfb100774>
81120924:	8821883a 	mov	r16,r17
81120928:	b019883a 	mov	r12,r22
8112092c:	9823883a 	mov	r17,r19
81120930:	182d883a 	mov	r22,r3
81120934:	9801961e 	bne	r19,zero,81120f90 <__svfscanf_r+0x137c>
81120938:	633fffc4 	addi	r12,r12,-1
8112093c:	00800044 	movi	r2,1
81120940:	1302882e 	bgeu	r2,r12,81121364 <__svfscanf_r+0x1750>
81120944:	a8803fcc 	andi	r2,r21,255
81120948:	1080201c 	xori	r2,r2,128
8112094c:	10bfe004 	addi	r2,r2,-128
81120950:	113fffc4 	addi	r4,r2,-1
81120954:	01400184 	movi	r5,6
81120958:	29001136 	bltu	r5,r4,811209a0 <__svfscanf_r+0xd8c>
8112095c:	01000084 	movi	r4,2
81120960:	2082900e 	bge	r4,r2,811213a4 <__svfscanf_r+0x1790>
81120964:	00c000c4 	movi	r3,3
81120968:	10c00d26 	beq	r2,r3,811209a0 <__svfscanf_r+0xd8c>
8112096c:	9425c83a 	sub	r18,r18,r16
81120970:	1827883a 	mov	r19,r3
81120974:	843fffc4 	addi	r16,r16,-1
81120978:	81400007 	ldb	r5,0(r16)
8112097c:	e00d883a 	mov	r6,fp
81120980:	b009883a 	mov	r4,r22
81120984:	1129f080 	call	81129f08 <_ungetc_r>
81120988:	a8bfffc4 	addi	r2,r21,-1
8112098c:	10c03fcc 	andi	r3,r2,255
81120990:	8493883a 	add	r9,r16,r18
81120994:	102b883a 	mov	r21,r2
81120998:	98fff636 	bltu	r19,r3,81120974 <__reset+0xfb100974>
8112099c:	4825883a 	mov	r18,r9
811209a0:	a080400c 	andi	r2,r20,256
811209a4:	10001426 	beq	r2,zero,811209f8 <__svfscanf_r+0xde4>
811209a8:	a081000c 	andi	r2,r20,1024
811209ac:	1002571e 	bne	r2,zero,8112130c <__svfscanf_r+0x16f8>
811209b0:	817fffc7 	ldb	r5,-1(r16)
811209b4:	00801944 	movi	r2,101
811209b8:	84ffffc4 	addi	r19,r16,-1
811209bc:	957fffc4 	addi	r21,r18,-1
811209c0:	28800826 	beq	r5,r2,811209e4 <__svfscanf_r+0xdd0>
811209c4:	00801144 	movi	r2,69
811209c8:	28800626 	beq	r5,r2,811209e4 <__svfscanf_r+0xdd0>
811209cc:	e00d883a 	mov	r6,fp
811209d0:	b009883a 	mov	r4,r22
811209d4:	1129f080 	call	81129f08 <_ungetc_r>
811209d8:	817fff87 	ldb	r5,-2(r16)
811209dc:	84ffff84 	addi	r19,r16,-2
811209e0:	957fff84 	addi	r21,r18,-2
811209e4:	e00d883a 	mov	r6,fp
811209e8:	b009883a 	mov	r4,r22
811209ec:	1129f080 	call	81129f08 <_ungetc_r>
811209f0:	a825883a 	mov	r18,r21
811209f4:	9821883a 	mov	r16,r19
811209f8:	a080040c 	andi	r2,r20,16
811209fc:	103e891e 	bne	r2,zero,81120424 <__reset+0xfb100424>
81120a00:	80000005 	stb	zero,0(r16)
81120a04:	a081800c 	andi	r2,r20,1536
81120a08:	01010004 	movi	r4,1024
81120a0c:	1101dd26 	beq	r2,r4,81121184 <__svfscanf_r+0x1570>
81120a10:	da00a417 	ldw	r8,656(sp)
81120a14:	4001e71e 	bne	r8,zero,811211b4 <__svfscanf_r+0x15a0>
81120a18:	000d883a 	mov	r6,zero
81120a1c:	d9400104 	addi	r5,sp,4
81120a20:	b009883a 	mov	r4,r22
81120a24:	1126da00 	call	81126da0 <_strtod_r>
81120a28:	1021883a 	mov	r16,r2
81120a2c:	a080004c 	andi	r2,r20,1
81120a30:	1000021e 	bne	r2,zero,81120a3c <__svfscanf_r+0xe28>
81120a34:	a2c0008c 	andi	r11,r20,2
81120a38:	5801e826 	beq	r11,zero,811211dc <__svfscanf_r+0x15c8>
81120a3c:	da009c17 	ldw	r8,624(sp)
81120a40:	40800017 	ldw	r2,0(r8)
81120a44:	42000104 	addi	r8,r8,4
81120a48:	da009c15 	stw	r8,624(sp)
81120a4c:	14000015 	stw	r16,0(r2)
81120a50:	10c00115 	stw	r3,4(r2)
81120a54:	da00a017 	ldw	r8,640(sp)
81120a58:	dd009d17 	ldw	r20,628(sp)
81120a5c:	42000044 	addi	r8,r8,1
81120a60:	da00a015 	stw	r8,640(sp)
81120a64:	a00d883a 	mov	r6,r20
81120a68:	003ca806 	br	8111fd0c <__reset+0xfb0ffd0c>
81120a6c:	a080400c 	andi	r2,r20,256
81120a70:	103f9a26 	beq	r2,zero,811208dc <__reset+0xfb1008dc>
81120a74:	da00a217 	ldw	r8,648(sp)
81120a78:	00bfdfc4 	movi	r2,-129
81120a7c:	a0a8703a 	and	r20,r20,r2
81120a80:	9cc00044 	addi	r19,r19,1
81120a84:	403f9e26 	beq	r8,zero,81120900 <__reset+0xfb100900>
81120a88:	423fffc4 	addi	r8,r8,-1
81120a8c:	da00a215 	stw	r8,648(sp)
81120a90:	84000044 	addi	r16,r16,1
81120a94:	003f9a06 	br	81120900 <__reset+0xfb100900>
81120a98:	a080200c 	andi	r2,r20,128
81120a9c:	103fa126 	beq	r2,zero,81120924 <__reset+0xfb100924>
81120aa0:	00bfdfc4 	movi	r2,-129
81120aa4:	a0a8703a 	and	r20,r20,r2
81120aa8:	003f9306 	br	811208f8 <__reset+0xfb1008f8>
81120aac:	a8803fcc 	andi	r2,r21,255
81120ab0:	1080201c 	xori	r2,r2,128
81120ab4:	10bfe004 	addi	r2,r2,-128
81120ab8:	020001c4 	movi	r8,7
81120abc:	123f991e 	bne	r2,r8,81120924 <__reset+0xfb100924>
81120ac0:	05400204 	movi	r21,8
81120ac4:	003f8c06 	br	811208f8 <__reset+0xfb1008f8>
81120ac8:	a8803fcc 	andi	r2,r21,255
81120acc:	1080201c 	xori	r2,r2,128
81120ad0:	10bfe004 	addi	r2,r2,-128
81120ad4:	01800184 	movi	r6,6
81120ad8:	11bf921e 	bne	r2,r6,81120924 <__reset+0xfb100924>
81120adc:	054001c4 	movi	r21,7
81120ae0:	003f8506 	br	811208f8 <__reset+0xfb1008f8>
81120ae4:	b000491e 	bne	r22,zero,81120c0c <__svfscanf_r+0xff8>
81120ae8:	9800031e 	bne	r19,zero,81120af8 <__svfscanf_r+0xee4>
81120aec:	a081c00c 	andi	r2,r20,1792
81120af0:	0181c004 	movi	r6,1792
81120af4:	11819f26 	beq	r2,r6,81121174 <__svfscanf_r+0x1560>
81120af8:	a8803fcc 	andi	r2,r21,255
81120afc:	1080201c 	xori	r2,r2,128
81120b00:	10bfe004 	addi	r2,r2,-128
81120b04:	01800044 	movi	r6,1
81120b08:	11800226 	beq	r2,r6,81120b14 <__svfscanf_r+0xf00>
81120b0c:	01800104 	movi	r6,4
81120b10:	11bf841e 	bne	r2,r6,81120924 <__reset+0xfb100924>
81120b14:	ad400044 	addi	r21,r21,1
81120b18:	003f7706 	br	811208f8 <__reset+0xfb1008f8>
81120b1c:	a8803fcc 	andi	r2,r21,255
81120b20:	1080201c 	xori	r2,r2,128
81120b24:	10bfe004 	addi	r2,r2,-128
81120b28:	10003c1e 	bne	r2,zero,81120c1c <__svfscanf_r+0x1008>
81120b2c:	9801141e 	bne	r19,zero,81120f80 <__svfscanf_r+0x136c>
81120b30:	a081c00c 	andi	r2,r20,1792
81120b34:	0181c004 	movi	r6,1792
81120b38:	11818226 	beq	r2,r6,81121144 <__svfscanf_r+0x1530>
81120b3c:	8821883a 	mov	r16,r17
81120b40:	b019883a 	mov	r12,r22
81120b44:	9823883a 	mov	r17,r19
81120b48:	182d883a 	mov	r22,r3
81120b4c:	003f7a06 	br	81120938 <__reset+0xfb100938>
81120b50:	a8803fcc 	andi	r2,r21,255
81120b54:	1080201c 	xori	r2,r2,128
81120b58:	10bfe004 	addi	r2,r2,-128
81120b5c:	01800084 	movi	r6,2
81120b60:	11bf701e 	bne	r2,r6,81120924 <__reset+0xfb100924>
81120b64:	054000c4 	movi	r21,3
81120b68:	003f6306 	br	811208f8 <__reset+0xfb1008f8>
81120b6c:	a081400c 	andi	r2,r20,1280
81120b70:	01810004 	movi	r6,1024
81120b74:	11800326 	beq	r2,r6,81120b84 <__svfscanf_r+0xf70>
81120b78:	a184703a 	and	r2,r20,r6
81120b7c:	103f6926 	beq	r2,zero,81120924 <__reset+0xfb100924>
81120b80:	983fee26 	beq	r19,zero,81120b3c <__reset+0xfb100b3c>
81120b84:	a080800c 	andi	r2,r20,512
81120b88:	1000041e 	bne	r2,zero,81120b9c <__svfscanf_r+0xf88>
81120b8c:	da009f17 	ldw	r8,636(sp)
81120b90:	dc40a515 	stw	r17,660(sp)
81120b94:	9a27c83a 	sub	r19,r19,r8
81120b98:	dcc0a415 	stw	r19,656(sp)
81120b9c:	00be1fc4 	movi	r2,-1921
81120ba0:	a0a8703a 	and	r20,r20,r2
81120ba4:	a5006014 	ori	r20,r20,384
81120ba8:	0027883a 	mov	r19,zero
81120bac:	003f5206 	br	811208f8 <__reset+0xfb1008f8>
81120bb0:	00800044 	movi	r2,1
81120bb4:	b0bf5b1e 	bne	r22,r2,81120924 <__reset+0xfb100924>
81120bb8:	05800084 	movi	r22,2
81120bbc:	003f4e06 	br	811208f8 <__reset+0xfb1008f8>
81120bc0:	d980a317 	ldw	r6,652(sp)
81120bc4:	30800003 	ldbu	r2,0(r6)
81120bc8:	29803fcc 	andi	r6,r5,255
81120bcc:	30bf551e 	bne	r6,r2,81120924 <__reset+0xfb100924>
81120bd0:	a080800c 	andi	r2,r20,512
81120bd4:	103f5326 	beq	r2,zero,81120924 <__reset+0xfb100924>
81120bd8:	023f5fc4 	movi	r8,-641
81120bdc:	a228703a 	and	r20,r20,r8
81120be0:	dcc09f15 	stw	r19,636(sp)
81120be4:	003f4406 	br	811208f8 <__reset+0xfb1008f8>
81120be8:	1809883a 	mov	r4,r3
81120bec:	e00b883a 	mov	r5,fp
81120bf0:	d8c0a615 	stw	r3,664(sp)
81120bf4:	d9c0aa15 	stw	r7,680(sp)
81120bf8:	11267800 	call	81126780 <__srefill_r>
81120bfc:	d8c0a617 	ldw	r3,664(sp)
81120c00:	d9c0aa17 	ldw	r7,680(sp)
81120c04:	103f4626 	beq	r2,zero,81120920 <__reset+0xfb100920>
81120c08:	003f4606 	br	81120924 <__reset+0xfb100924>
81120c0c:	00800084 	movi	r2,2
81120c10:	b0bfb91e 	bne	r22,r2,81120af8 <__reset+0xfb100af8>
81120c14:	058000c4 	movi	r22,3
81120c18:	003f3706 	br	811208f8 <__reset+0xfb1008f8>
81120c1c:	018000c4 	movi	r6,3
81120c20:	11bfbc26 	beq	r2,r6,81120b14 <__reset+0xfb100b14>
81120c24:	01800144 	movi	r6,5
81120c28:	11bfba26 	beq	r2,r6,81120b14 <__reset+0xfb100b14>
81120c2c:	003f3d06 	br	81120924 <__reset+0xfb100924>
81120c30:	98bfffc4 	addi	r2,r19,-1
81120c34:	01405704 	movi	r5,348
81120c38:	2880d82e 	bgeu	r5,r2,81120f9c <__svfscanf_r+0x1388>
81120c3c:	99ffa8c4 	addi	r7,r19,-349
81120c40:	04c05744 	movi	r19,349
81120c44:	8c436014 	ori	r17,r17,3456
81120c48:	9013883a 	mov	r9,r18
81120c4c:	8825883a 	mov	r18,r17
81120c50:	dc409e17 	ldw	r17,632(sp)
81120c54:	0029883a 	mov	r20,zero
81120c58:	dc000104 	addi	r16,sp,4
81120c5c:	05401344 	movi	r21,77
81120c60:	02c08004 	movi	r11,512
81120c64:	01bf7fc4 	movi	r6,-513
81120c68:	023fdfc4 	movi	r8,-129
81120c6c:	20bff544 	addi	r2,r4,-43
81120c70:	10803fcc 	andi	r2,r2,255
81120c74:	a8807236 	bltu	r21,r2,81120e40 <__svfscanf_r+0x122c>
81120c78:	100490ba 	slli	r2,r2,2
81120c7c:	016044b4 	movhi	r5,33042
81120c80:	29432404 	addi	r5,r5,3216
81120c84:	1145883a 	add	r2,r2,r5
81120c88:	10800017 	ldw	r2,0(r2)
81120c8c:	1000683a 	jmp	r2
81120c90:	81120ec4 	addi	r4,r16,18491
81120c94:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120c98:	81120ec4 	addi	r4,r16,18491
81120c9c:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120ca0:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120ca4:	81120e9c 	xori	r4,r16,18490
81120ca8:	81120e7c 	xorhi	r4,r16,18489
81120cac:	81120e7c 	xorhi	r4,r16,18489
81120cb0:	81120e7c 	xorhi	r4,r16,18489
81120cb4:	81120e7c 	xorhi	r4,r16,18489
81120cb8:	81120e7c 	xorhi	r4,r16,18489
81120cbc:	81120e7c 	xorhi	r4,r16,18489
81120cc0:	81120e7c 	xorhi	r4,r16,18489
81120cc4:	81120e24 	muli	r4,r16,18488
81120cc8:	81120e24 	muli	r4,r16,18488
81120ccc:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120cd0:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120cd4:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120cd8:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120cdc:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120ce0:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120ce4:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120ce8:	81120e10 	cmplti	r4,r16,18488
81120cec:	81120e10 	cmplti	r4,r16,18488
81120cf0:	81120e10 	cmplti	r4,r16,18488
81120cf4:	81120e10 	cmplti	r4,r16,18488
81120cf8:	81120e10 	cmplti	r4,r16,18488
81120cfc:	81120e10 	cmplti	r4,r16,18488
81120d00:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d04:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d08:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d0c:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d10:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d14:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d18:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d1c:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d20:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d24:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d28:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d2c:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d30:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d34:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d38:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d3c:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d40:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d44:	81120dc8 	cmpgei	r4,r16,18487
81120d48:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d4c:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d50:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d54:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d58:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d5c:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d60:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d64:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d68:	81120e10 	cmplti	r4,r16,18488
81120d6c:	81120e10 	cmplti	r4,r16,18488
81120d70:	81120e10 	cmplti	r4,r16,18488
81120d74:	81120e10 	cmplti	r4,r16,18488
81120d78:	81120e10 	cmplti	r4,r16,18488
81120d7c:	81120e10 	cmplti	r4,r16,18488
81120d80:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d84:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d88:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d8c:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d90:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d94:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d98:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120d9c:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120da0:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120da4:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120da8:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120dac:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120db0:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120db4:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120db8:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120dbc:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120dc0:	81120e40 	call	881120e4 <__reset+0x20f20e4>
81120dc4:	81120dc8 	cmpgei	r4,r16,18487
81120dc8:	9081800c 	andi	r2,r18,1536
81120dcc:	12c01c1e 	bne	r2,r11,81120e40 <__svfscanf_r+0x122c>
81120dd0:	91a4703a 	and	r18,r18,r6
81120dd4:	94814014 	ori	r18,r18,1280
81120dd8:	04400404 	movi	r17,16
81120ddc:	81000005 	stb	r4,0(r16)
81120de0:	84000044 	addi	r16,r16,1
81120de4:	e0800117 	ldw	r2,4(fp)
81120de8:	10bfffc4 	addi	r2,r2,-1
81120dec:	e0800115 	stw	r2,4(fp)
81120df0:	0080540e 	bge	zero,r2,81120f44 <__svfscanf_r+0x1330>
81120df4:	18c00044 	addi	r3,r3,1
81120df8:	e0c00015 	stw	r3,0(fp)
81120dfc:	9cffffc4 	addi	r19,r19,-1
81120e00:	98000f26 	beq	r19,zero,81120e40 <__svfscanf_r+0x122c>
81120e04:	e0c00017 	ldw	r3,0(fp)
81120e08:	19000003 	ldbu	r4,0(r3)
81120e0c:	003f9706 	br	81120c6c <__reset+0xfb100c6c>
81120e10:	00800284 	movi	r2,10
81120e14:	14400a0e 	bge	r2,r17,81120e40 <__svfscanf_r+0x122c>
81120e18:	00bd1fc4 	movi	r2,-2945
81120e1c:	90a4703a 	and	r18,r18,r2
81120e20:	003fee06 	br	81120ddc <__reset+0xfb100ddc>
81120e24:	01604534 	movhi	r5,33044
81120e28:	8c63883a 	add	r17,r17,r17
81120e2c:	29545884 	addi	r5,r5,20834
81120e30:	2c45883a 	add	r2,r5,r17
81120e34:	1440000f 	ldh	r17,0(r2)
81120e38:	00800204 	movi	r2,8
81120e3c:	147ff616 	blt	r2,r17,81120e18 <__reset+0xfb100e18>
81120e40:	dc409e15 	stw	r17,632(sp)
81120e44:	9023883a 	mov	r17,r18
81120e48:	8880400c 	andi	r2,r17,256
81120e4c:	4825883a 	mov	r18,r9
81120e50:	10000426 	beq	r2,zero,81120e64 <__svfscanf_r+0x1250>
81120e54:	d9800104 	addi	r6,sp,4
81120e58:	3400be36 	bltu	r6,r16,81121154 <__svfscanf_r+0x1540>
81120e5c:	da000104 	addi	r8,sp,4
81120e60:	443bae26 	beq	r8,r16,8111fd1c <__reset+0xfb0ffd1c>
81120e64:	8880040c 	andi	r2,r17,16
81120e68:	10009326 	beq	r2,zero,811210b8 <__svfscanf_r+0x14a4>
81120e6c:	d8800104 	addi	r2,sp,4
81120e70:	80a1c83a 	sub	r16,r16,r2
81120e74:	8521883a 	add	r16,r16,r20
81120e78:	003d0606 	br	81120294 <__reset+0xfb100294>
81120e7c:	01604534 	movhi	r5,33044
81120e80:	8c63883a 	add	r17,r17,r17
81120e84:	29545884 	addi	r5,r5,20834
81120e88:	2c45883a 	add	r2,r5,r17
81120e8c:	1440000f 	ldh	r17,0(r2)
81120e90:	00bd1fc4 	movi	r2,-2945
81120e94:	90a4703a 	and	r18,r18,r2
81120e98:	003fd006 	br	81120ddc <__reset+0xfb100ddc>
81120e9c:	9082000c 	andi	r2,r18,2048
81120ea0:	103fce26 	beq	r2,zero,81120ddc <__reset+0xfb100ddc>
81120ea4:	8800021e 	bne	r17,zero,81120eb0 <__svfscanf_r+0x129c>
81120ea8:	94808014 	ori	r18,r18,512
81120eac:	04400204 	movi	r17,8
81120eb0:	9081000c 	andi	r2,r18,1024
81120eb4:	10009426 	beq	r2,zero,81121108 <__svfscanf_r+0x14f4>
81120eb8:	00be9fc4 	movi	r2,-1409
81120ebc:	90a4703a 	and	r18,r18,r2
81120ec0:	003fc606 	br	81120ddc <__reset+0xfb100ddc>
81120ec4:	9080200c 	andi	r2,r18,128
81120ec8:	103fdd26 	beq	r2,zero,81120e40 <__reset+0xfb100e40>
81120ecc:	9224703a 	and	r18,r18,r8
81120ed0:	003fc206 	br	81120ddc <__reset+0xfb100ddc>
81120ed4:	9800011e 	bne	r19,zero,81120edc <__svfscanf_r+0x12c8>
81120ed8:	04ffffc4 	movi	r19,-1
81120edc:	8900004c 	andi	r4,r17,1
81120ee0:	20005b1e 	bne	r4,zero,81121050 <__svfscanf_r+0x143c>
81120ee4:	8c40040c 	andi	r17,r17,16
81120ee8:	88003026 	beq	r17,zero,81120fac <__svfscanf_r+0x1398>
81120eec:	0021883a 	mov	r16,zero
81120ef0:	00000306 	br	81120f00 <__svfscanf_r+0x12ec>
81120ef4:	18800003 	ldbu	r2,0(r3)
81120ef8:	3885883a 	add	r2,r7,r2
81120efc:	10800043 	ldbu	r2,1(r2)
81120f00:	1080020c 	andi	r2,r2,8
81120f04:	103ce31e 	bne	r2,zero,81120294 <__reset+0xfb100294>
81120f08:	e0800117 	ldw	r2,4(fp)
81120f0c:	18c00044 	addi	r3,r3,1
81120f10:	84000044 	addi	r16,r16,1
81120f14:	10bfffc4 	addi	r2,r2,-1
81120f18:	e0800115 	stw	r2,4(fp)
81120f1c:	e0c00015 	stw	r3,0(fp)
81120f20:	84fcdc26 	beq	r16,r19,81120294 <__reset+0xfb100294>
81120f24:	00bff316 	blt	zero,r2,81120ef4 <__reset+0xfb100ef4>
81120f28:	e00b883a 	mov	r5,fp
81120f2c:	b009883a 	mov	r4,r22
81120f30:	11267800 	call	81126780 <__srefill_r>
81120f34:	103cd71e 	bne	r2,zero,81120294 <__reset+0xfb100294>
81120f38:	b9c00017 	ldw	r7,0(r23)
81120f3c:	e0c00017 	ldw	r3,0(fp)
81120f40:	003fec06 	br	81120ef4 <__reset+0xfb100ef4>
81120f44:	e00b883a 	mov	r5,fp
81120f48:	b009883a 	mov	r4,r22
81120f4c:	d980a715 	stw	r6,668(sp)
81120f50:	d9c0aa15 	stw	r7,680(sp)
81120f54:	da00a815 	stw	r8,672(sp)
81120f58:	da40a915 	stw	r9,676(sp)
81120f5c:	dac0a615 	stw	r11,664(sp)
81120f60:	11267800 	call	81126780 <__srefill_r>
81120f64:	d980a717 	ldw	r6,668(sp)
81120f68:	d9c0aa17 	ldw	r7,680(sp)
81120f6c:	da00a817 	ldw	r8,672(sp)
81120f70:	da40a917 	ldw	r9,676(sp)
81120f74:	dac0a617 	ldw	r11,664(sp)
81120f78:	103fa026 	beq	r2,zero,81120dfc <__reset+0xfb100dfc>
81120f7c:	003fb006 	br	81120e40 <__reset+0xfb100e40>
81120f80:	8821883a 	mov	r16,r17
81120f84:	b019883a 	mov	r12,r22
81120f88:	9823883a 	mov	r17,r19
81120f8c:	182d883a 	mov	r22,r3
81120f90:	00bfbfc4 	movi	r2,-257
81120f94:	a0a8703a 	and	r20,r20,r2
81120f98:	003e6706 	br	81120938 <__reset+0xfb100938>
81120f9c:	000f883a 	mov	r7,zero
81120fa0:	003f2806 	br	81120c44 <__reset+0xfb100c44>
81120fa4:	d800a215 	stw	zero,648(sp)
81120fa8:	003de306 	br	81120738 <__reset+0xfb100738>
81120fac:	da009c17 	ldw	r8,624(sp)
81120fb0:	9abfffc4 	addi	r10,r19,-1
81120fb4:	44400017 	ldw	r17,0(r8)
81120fb8:	44000104 	addi	r16,r8,4
81120fbc:	880b883a 	mov	r5,r17
81120fc0:	8aa9883a 	add	r20,r17,r10
81120fc4:	00000606 	br	81120fe0 <__svfscanf_r+0x13cc>
81120fc8:	e0c00017 	ldw	r3,0(fp)
81120fcc:	b9000017 	ldw	r4,0(r23)
81120fd0:	a80b883a 	mov	r5,r21
81120fd4:	18800003 	ldbu	r2,0(r3)
81120fd8:	2085883a 	add	r2,r4,r2
81120fdc:	10800043 	ldbu	r2,1(r2)
81120fe0:	1080020c 	andi	r2,r2,8
81120fe4:	1000551e 	bne	r2,zero,8112113c <__svfscanf_r+0x1528>
81120fe8:	e0800117 	ldw	r2,4(fp)
81120fec:	19000044 	addi	r4,r3,1
81120ff0:	e1000015 	stw	r4,0(fp)
81120ff4:	10bfffc4 	addi	r2,r2,-1
81120ff8:	e0800115 	stw	r2,4(fp)
81120ffc:	18800003 	ldbu	r2,0(r3)
81121000:	2d400044 	addi	r21,r5,1
81121004:	a827883a 	mov	r19,r21
81121008:	28800005 	stb	r2,0(r5)
8112100c:	2d000626 	beq	r5,r20,81121028 <__svfscanf_r+0x1414>
81121010:	e0800117 	ldw	r2,4(fp)
81121014:	00bfec16 	blt	zero,r2,81120fc8 <__reset+0xfb100fc8>
81121018:	e00b883a 	mov	r5,fp
8112101c:	b009883a 	mov	r4,r22
81121020:	11267800 	call	81126780 <__srefill_r>
81121024:	103fe826 	beq	r2,zero,81120fc8 <__reset+0xfb100fc8>
81121028:	da00a017 	ldw	r8,640(sp)
8112102c:	dd009d17 	ldw	r20,628(sp)
81121030:	9c63c83a 	sub	r17,r19,r17
81121034:	42000044 	addi	r8,r8,1
81121038:	98000005 	stb	zero,0(r19)
8112103c:	9465883a 	add	r18,r18,r17
81121040:	da00a015 	stw	r8,640(sp)
81121044:	dc009c15 	stw	r16,624(sp)
81121048:	a00d883a 	mov	r6,r20
8112104c:	003b2f06 	br	8111fd0c <__reset+0xfb0ffd0c>
81121050:	dd409904 	addi	r21,sp,612
81121054:	8c40040c 	andi	r17,r17,16
81121058:	01800204 	movi	r6,8
8112105c:	000b883a 	mov	r5,zero
81121060:	a809883a 	mov	r4,r21
81121064:	111acfc0 	call	8111acfc <memset>
81121068:	8800401e 	bne	r17,zero,8112116c <__svfscanf_r+0x1558>
8112106c:	da009c17 	ldw	r8,624(sp)
81121070:	45000017 	ldw	r20,0(r8)
81121074:	42000104 	addi	r8,r8,4
81121078:	da009c15 	stw	r8,624(sp)
8112107c:	000d883a 	mov	r6,zero
81121080:	3021883a 	mov	r16,r6
81121084:	dc409f15 	stw	r17,636(sp)
81121088:	e0800017 	ldw	r2,0(fp)
8112108c:	b8c00017 	ldw	r3,0(r23)
81121090:	10800003 	ldbu	r2,0(r2)
81121094:	1885883a 	add	r2,r3,r2
81121098:	10800043 	ldbu	r2,1(r2)
8112109c:	1080020c 	andi	r2,r2,8
811210a0:	1000011e 	bne	r2,zero,811210a8 <__svfscanf_r+0x1494>
811210a4:	9800701e 	bne	r19,zero,81121268 <__svfscanf_r+0x1654>
811210a8:	dc409f17 	ldw	r17,636(sp)
811210ac:	883cdd1e 	bne	r17,zero,81120424 <__reset+0xfb100424>
811210b0:	a0000015 	stw	zero,0(r20)
811210b4:	003cd806 	br	81120418 <__reset+0xfb100418>
811210b8:	d9c09e17 	ldw	r7,632(sp)
811210bc:	da00a117 	ldw	r8,644(sp)
811210c0:	000d883a 	mov	r6,zero
811210c4:	d9400104 	addi	r5,sp,4
811210c8:	b009883a 	mov	r4,r22
811210cc:	80000005 	stb	zero,0(r16)
811210d0:	403ee83a 	callr	r8
811210d4:	88c0080c 	andi	r3,r17,32
811210d8:	1800121e 	bne	r3,zero,81121124 <__svfscanf_r+0x1510>
811210dc:	88c0010c 	andi	r3,r17,4
811210e0:	18004d26 	beq	r3,zero,81121218 <__svfscanf_r+0x1604>
811210e4:	da009c17 	ldw	r8,624(sp)
811210e8:	40c00017 	ldw	r3,0(r8)
811210ec:	42000104 	addi	r8,r8,4
811210f0:	da009c15 	stw	r8,624(sp)
811210f4:	1880000d 	sth	r2,0(r3)
811210f8:	da00a017 	ldw	r8,640(sp)
811210fc:	42000044 	addi	r8,r8,1
81121100:	da00a015 	stw	r8,640(sp)
81121104:	003f5906 	br	81120e6c <__reset+0xfb100e6c>
81121108:	00bf1fc4 	movi	r2,-897
8112110c:	90a4703a 	and	r18,r18,r2
81121110:	38000226 	beq	r7,zero,8112111c <__svfscanf_r+0x1508>
81121114:	39ffffc4 	addi	r7,r7,-1
81121118:	9cc00044 	addi	r19,r19,1
8112111c:	a5000044 	addi	r20,r20,1
81121120:	003f3006 	br	81120de4 <__reset+0xfb100de4>
81121124:	da009c17 	ldw	r8,624(sp)
81121128:	40c00017 	ldw	r3,0(r8)
8112112c:	42000104 	addi	r8,r8,4
81121130:	da009c15 	stw	r8,624(sp)
81121134:	18800015 	stw	r2,0(r3)
81121138:	003fef06 	br	811210f8 <__reset+0xfb1010f8>
8112113c:	2827883a 	mov	r19,r5
81121140:	003fb906 	br	81121028 <__reset+0xfb101028>
81121144:	01be1fc4 	movi	r6,-1921
81121148:	a1a8703a 	and	r20,r20,r6
8112114c:	05400044 	movi	r21,1
81121150:	003de906 	br	811208f8 <__reset+0xfb1008f8>
81121154:	817fffc7 	ldb	r5,-1(r16)
81121158:	e00d883a 	mov	r6,fp
8112115c:	b009883a 	mov	r4,r22
81121160:	843fffc4 	addi	r16,r16,-1
81121164:	1129f080 	call	81129f08 <_ungetc_r>
81121168:	003f3c06 	br	81120e5c <__reset+0xfb100e5c>
8112116c:	dd009b04 	addi	r20,sp,620
81121170:	003fc206 	br	8112107c <__reset+0xfb10107c>
81121174:	00be1fc4 	movi	r2,-1921
81121178:	a0a8703a 	and	r20,r20,r2
8112117c:	05800044 	movi	r22,1
81121180:	003ddd06 	br	811208f8 <__reset+0xfb1008f8>
81121184:	d8c09f17 	ldw	r3,636(sp)
81121188:	88e3c83a 	sub	r17,r17,r3
8112118c:	044dc83a 	sub	r6,zero,r17
81121190:	883e2126 	beq	r17,zero,81120a18 <__reset+0xfb100a18>
81121194:	d88055c4 	addi	r2,sp,343
81121198:	80800136 	bltu	r16,r2,811211a0 <__svfscanf_r+0x158c>
8112119c:	dc005584 	addi	r16,sp,342
811211a0:	01604534 	movhi	r5,33044
811211a4:	29545704 	addi	r5,r5,20828
811211a8:	8009883a 	mov	r4,r16
811211ac:	111b0580 	call	8111b058 <sprintf>
811211b0:	003e1906 	br	81120a18 <__reset+0xfb100a18>
811211b4:	d8c0a517 	ldw	r3,660(sp)
811211b8:	000d883a 	mov	r6,zero
811211bc:	01c00284 	movi	r7,10
811211c0:	19400044 	addi	r5,r3,1
811211c4:	b009883a 	mov	r4,r22
811211c8:	111b1f40 	call	8111b1f4 <_strtol_r>
811211cc:	da00a417 	ldw	r8,656(sp)
811211d0:	dc00a517 	ldw	r16,660(sp)
811211d4:	120dc83a 	sub	r6,r2,r8
811211d8:	003fee06 	br	81121194 <__reset+0xfb101194>
811211dc:	da009c17 	ldw	r8,624(sp)
811211e0:	180b883a 	mov	r5,r3
811211e4:	8009883a 	mov	r4,r16
811211e8:	45000017 	ldw	r20,0(r8)
811211ec:	44400104 	addi	r17,r8,4
811211f0:	d8c0a615 	stw	r3,664(sp)
811211f4:	112695c0 	call	8112695c <__fpclassifyd>
811211f8:	d8c0a617 	ldw	r3,664(sp)
811211fc:	10006426 	beq	r2,zero,81121390 <__svfscanf_r+0x177c>
81121200:	8009883a 	mov	r4,r16
81121204:	180b883a 	mov	r5,r3
81121208:	111a9700 	call	8111a970 <__truncdfsf2>
8112120c:	a0800015 	stw	r2,0(r20)
81121210:	dc409c15 	stw	r17,624(sp)
81121214:	003e0f06 	br	81120a54 <__reset+0xfb100a54>
81121218:	88c0004c 	andi	r3,r17,1
8112121c:	183fc11e 	bne	r3,zero,81121124 <__reset+0xfb101124>
81121220:	8c40008c 	andi	r17,r17,2
81121224:	883fbf26 	beq	r17,zero,81121124 <__reset+0xfb101124>
81121228:	da00a117 	ldw	r8,644(sp)
8112122c:	00a044f4 	movhi	r2,33043
81121230:	10a13004 	addi	r2,r2,-31552
81121234:	d9c09e17 	ldw	r7,632(sp)
81121238:	000d883a 	mov	r6,zero
8112123c:	d9400104 	addi	r5,sp,4
81121240:	b009883a 	mov	r4,r22
81121244:	40806226 	beq	r8,r2,811213d0 <__svfscanf_r+0x17bc>
81121248:	111b46c0 	call	8111b46c <_strtoll_r>
8112124c:	da009c17 	ldw	r8,624(sp)
81121250:	41000017 	ldw	r4,0(r8)
81121254:	42000104 	addi	r8,r8,4
81121258:	da009c15 	stw	r8,624(sp)
8112125c:	20800015 	stw	r2,0(r4)
81121260:	20c00115 	stw	r3,4(r4)
81121264:	003fa406 	br	811210f8 <__reset+0xfb1010f8>
81121268:	11242ec0 	call	811242ec <__locale_mb_cur_max>
8112126c:	80bca726 	beq	r16,r2,8112050c <__reset+0xfb10050c>
81121270:	e0800017 	ldw	r2,0(fp)
81121274:	e1000117 	ldw	r4,4(fp)
81121278:	d8c00104 	addi	r3,sp,4
8112127c:	12000003 	ldbu	r8,0(r2)
81121280:	213fffc4 	addi	r4,r4,-1
81121284:	10800044 	addi	r2,r2,1
81121288:	e1000115 	stw	r4,4(fp)
8112128c:	e0800015 	stw	r2,0(fp)
81121290:	84400044 	addi	r17,r16,1
81121294:	dd400015 	stw	r21,0(sp)
81121298:	1c21883a 	add	r16,r3,r16
8112129c:	b009883a 	mov	r4,r22
811212a0:	880f883a 	mov	r7,r17
811212a4:	180d883a 	mov	r6,r3
811212a8:	a00b883a 	mov	r5,r20
811212ac:	82000005 	stb	r8,0(r16)
811212b0:	1124d180 	call	81124d18 <_mbrtowc_r>
811212b4:	013fffc4 	movi	r4,-1
811212b8:	113c9426 	beq	r2,r4,8112050c <__reset+0xfb10050c>
811212bc:	103c881e 	bne	r2,zero,811204e0 <__reset+0xfb1004e0>
811212c0:	a0000015 	stw	zero,0(r20)
811212c4:	0009883a 	mov	r4,zero
811212c8:	112422c0 	call	8112422c <iswspace>
811212cc:	10001a26 	beq	r2,zero,81121338 <__svfscanf_r+0x1724>
811212d0:	8821883a 	mov	r16,r17
811212d4:	dc409f17 	ldw	r17,636(sp)
811212d8:	803f7426 	beq	r16,zero,811210ac <__reset+0xfb1010ac>
811212dc:	843fffc4 	addi	r16,r16,-1
811212e0:	d9800104 	addi	r6,sp,4
811212e4:	342b883a 	add	r21,r6,r16
811212e8:	00000106 	br	811212f0 <__svfscanf_r+0x16dc>
811212ec:	843fffc4 	addi	r16,r16,-1
811212f0:	a9400003 	ldbu	r5,0(r21)
811212f4:	e00d883a 	mov	r6,fp
811212f8:	b009883a 	mov	r4,r22
811212fc:	1129f080 	call	81129f08 <_ungetc_r>
81121300:	ad7fffc4 	addi	r21,r21,-1
81121304:	803ff91e 	bne	r16,zero,811212ec <__reset+0xfb1012ec>
81121308:	003f6806 	br	811210ac <__reset+0xfb1010ac>
8112130c:	d9800104 	addi	r6,sp,4
81121310:	802b883a 	mov	r21,r16
81121314:	343a812e 	bgeu	r6,r16,8111fd1c <__reset+0xfb0ffd1c>
81121318:	ad7fffc4 	addi	r21,r21,-1
8112131c:	a9400007 	ldb	r5,0(r21)
81121320:	e00d883a 	mov	r6,fp
81121324:	b009883a 	mov	r4,r22
81121328:	1129f080 	call	81129f08 <_ungetc_r>
8112132c:	da000104 	addi	r8,sp,4
81121330:	457ff91e 	bne	r8,r21,81121318 <__reset+0xfb101318>
81121334:	003a7906 	br	8111fd1c <__reset+0xfb0ffd1c>
81121338:	da009f17 	ldw	r8,636(sp)
8112133c:	9465883a 	add	r18,r18,r17
81121340:	9cffffc4 	addi	r19,r19,-1
81121344:	4000051e 	bne	r8,zero,8112135c <__svfscanf_r+0x1748>
81121348:	a5000104 	addi	r20,r20,4
8112134c:	0021883a 	mov	r16,zero
81121350:	003c6606 	br	811204ec <__reset+0xfb1004ec>
81121354:	a1000017 	ldw	r4,0(r20)
81121358:	003fdb06 	br	811212c8 <__reset+0xfb1012c8>
8112135c:	0021883a 	mov	r16,zero
81121360:	003c6206 	br	811204ec <__reset+0xfb1004ec>
81121364:	d8800104 	addi	r2,sp,4
81121368:	802b883a 	mov	r21,r16
8112136c:	143a6b2e 	bgeu	r2,r16,8111fd1c <__reset+0xfb0ffd1c>
81121370:	ad7fffc4 	addi	r21,r21,-1
81121374:	a9400007 	ldb	r5,0(r21)
81121378:	e00d883a 	mov	r6,fp
8112137c:	b009883a 	mov	r4,r22
81121380:	1129f080 	call	81129f08 <_ungetc_r>
81121384:	d8c00104 	addi	r3,sp,4
81121388:	1d7ff91e 	bne	r3,r21,81121370 <__reset+0xfb101370>
8112138c:	003a6306 	br	8111fd1c <__reset+0xfb0ffd1c>
81121390:	0009883a 	mov	r4,zero
81121394:	1126afc0 	call	81126afc <nanf>
81121398:	a0800015 	stw	r2,0(r20)
8112139c:	dc409c15 	stw	r17,624(sp)
811213a0:	003dac06 	br	81120a54 <__reset+0xfb100a54>
811213a4:	d9000104 	addi	r4,sp,4
811213a8:	802b883a 	mov	r21,r16
811213ac:	243a5b2e 	bgeu	r4,r16,8111fd1c <__reset+0xfb0ffd1c>
811213b0:	ad7fffc4 	addi	r21,r21,-1
811213b4:	a9400007 	ldb	r5,0(r21)
811213b8:	e00d883a 	mov	r6,fp
811213bc:	b009883a 	mov	r4,r22
811213c0:	1129f080 	call	81129f08 <_ungetc_r>
811213c4:	d9400104 	addi	r5,sp,4
811213c8:	2d7ff91e 	bne	r5,r21,811213b0 <__reset+0xfb1013b0>
811213cc:	003a5306 	br	8111fd1c <__reset+0xfb0ffd1c>
811213d0:	11287300 	call	81128730 <_strtoull_r>
811213d4:	003f9d06 	br	8112124c <__reset+0xfb10124c>

811213d8 <vfscanf>:
811213d8:	00a04534 	movhi	r2,33044
811213dc:	defffb04 	addi	sp,sp,-20
811213e0:	109e0f04 	addi	r2,r2,30780
811213e4:	de00012e 	bgeu	sp,et,811213ec <vfscanf+0x14>
811213e8:	003b68fa 	trap	3
811213ec:	dc000215 	stw	r16,8(sp)
811213f0:	14000017 	ldw	r16,0(r2)
811213f4:	dc400315 	stw	r17,12(sp)
811213f8:	dfc00415 	stw	ra,16(sp)
811213fc:	2023883a 	mov	r17,r4
81121400:	80000826 	beq	r16,zero,81121424 <vfscanf+0x4c>
81121404:	80800e17 	ldw	r2,56(r16)
81121408:	1000061e 	bne	r2,zero,81121424 <vfscanf+0x4c>
8112140c:	8009883a 	mov	r4,r16
81121410:	d9400015 	stw	r5,0(sp)
81121414:	d9800115 	stw	r6,4(sp)
81121418:	11234cc0 	call	811234cc <__sinit>
8112141c:	d9800117 	ldw	r6,4(sp)
81121420:	d9400017 	ldw	r5,0(sp)
81121424:	300f883a 	mov	r7,r6
81121428:	8009883a 	mov	r4,r16
8112142c:	280d883a 	mov	r6,r5
81121430:	880b883a 	mov	r5,r17
81121434:	dfc00417 	ldw	ra,16(sp)
81121438:	dc400317 	ldw	r17,12(sp)
8112143c:	dc000217 	ldw	r16,8(sp)
81121440:	dec00504 	addi	sp,sp,20
81121444:	111fc141 	jmpi	8111fc14 <__svfscanf_r>

81121448 <__svfscanf>:
81121448:	00a04534 	movhi	r2,33044
8112144c:	109e0f04 	addi	r2,r2,30780
81121450:	300f883a 	mov	r7,r6
81121454:	280d883a 	mov	r6,r5
81121458:	200b883a 	mov	r5,r4
8112145c:	11000017 	ldw	r4,0(r2)
81121460:	111fc141 	jmpi	8111fc14 <__svfscanf_r>

81121464 <_vfscanf_r>:
81121464:	defffb04 	addi	sp,sp,-20
81121468:	de00012e 	bgeu	sp,et,81121470 <_vfscanf_r+0xc>
8112146c:	003b68fa 	trap	3
81121470:	dc000315 	stw	r16,12(sp)
81121474:	dfc00415 	stw	ra,16(sp)
81121478:	2021883a 	mov	r16,r4
8112147c:	20000926 	beq	r4,zero,811214a4 <_vfscanf_r+0x40>
81121480:	20800e17 	ldw	r2,56(r4)
81121484:	1000071e 	bne	r2,zero,811214a4 <_vfscanf_r+0x40>
81121488:	d9400015 	stw	r5,0(sp)
8112148c:	d9800115 	stw	r6,4(sp)
81121490:	d9c00215 	stw	r7,8(sp)
81121494:	11234cc0 	call	811234cc <__sinit>
81121498:	d9c00217 	ldw	r7,8(sp)
8112149c:	d9800117 	ldw	r6,4(sp)
811214a0:	d9400017 	ldw	r5,0(sp)
811214a4:	8009883a 	mov	r4,r16
811214a8:	dfc00417 	ldw	ra,16(sp)
811214ac:	dc000317 	ldw	r16,12(sp)
811214b0:	dec00504 	addi	sp,sp,20
811214b4:	111fc141 	jmpi	8111fc14 <__svfscanf_r>

811214b8 <__swsetup_r>:
811214b8:	00a04534 	movhi	r2,33044
811214bc:	defffd04 	addi	sp,sp,-12
811214c0:	109e0f04 	addi	r2,r2,30780
811214c4:	de00012e 	bgeu	sp,et,811214cc <__swsetup_r+0x14>
811214c8:	003b68fa 	trap	3
811214cc:	dc400115 	stw	r17,4(sp)
811214d0:	2023883a 	mov	r17,r4
811214d4:	11000017 	ldw	r4,0(r2)
811214d8:	dc000015 	stw	r16,0(sp)
811214dc:	dfc00215 	stw	ra,8(sp)
811214e0:	2821883a 	mov	r16,r5
811214e4:	20000226 	beq	r4,zero,811214f0 <__swsetup_r+0x38>
811214e8:	20800e17 	ldw	r2,56(r4)
811214ec:	10003126 	beq	r2,zero,811215b4 <__swsetup_r+0xfc>
811214f0:	8080030b 	ldhu	r2,12(r16)
811214f4:	10c0020c 	andi	r3,r2,8
811214f8:	1009883a 	mov	r4,r2
811214fc:	18000f26 	beq	r3,zero,8112153c <__swsetup_r+0x84>
81121500:	80c00417 	ldw	r3,16(r16)
81121504:	18001526 	beq	r3,zero,8112155c <__swsetup_r+0xa4>
81121508:	1100004c 	andi	r4,r2,1
8112150c:	20001c1e 	bne	r4,zero,81121580 <__swsetup_r+0xc8>
81121510:	1080008c 	andi	r2,r2,2
81121514:	1000291e 	bne	r2,zero,811215bc <__swsetup_r+0x104>
81121518:	80800517 	ldw	r2,20(r16)
8112151c:	80800215 	stw	r2,8(r16)
81121520:	18001c26 	beq	r3,zero,81121594 <__swsetup_r+0xdc>
81121524:	0005883a 	mov	r2,zero
81121528:	dfc00217 	ldw	ra,8(sp)
8112152c:	dc400117 	ldw	r17,4(sp)
81121530:	dc000017 	ldw	r16,0(sp)
81121534:	dec00304 	addi	sp,sp,12
81121538:	f800283a 	ret
8112153c:	2080040c 	andi	r2,r4,16
81121540:	10002e26 	beq	r2,zero,811215fc <__swsetup_r+0x144>
81121544:	2080010c 	andi	r2,r4,4
81121548:	10001e1e 	bne	r2,zero,811215c4 <__swsetup_r+0x10c>
8112154c:	80c00417 	ldw	r3,16(r16)
81121550:	20800214 	ori	r2,r4,8
81121554:	8080030d 	sth	r2,12(r16)
81121558:	183feb1e 	bne	r3,zero,81121508 <__reset+0xfb101508>
8112155c:	1100a00c 	andi	r4,r2,640
81121560:	01408004 	movi	r5,512
81121564:	217fe826 	beq	r4,r5,81121508 <__reset+0xfb101508>
81121568:	800b883a 	mov	r5,r16
8112156c:	8809883a 	mov	r4,r17
81121570:	11243400 	call	81124340 <__smakebuf_r>
81121574:	8080030b 	ldhu	r2,12(r16)
81121578:	80c00417 	ldw	r3,16(r16)
8112157c:	003fe206 	br	81121508 <__reset+0xfb101508>
81121580:	80800517 	ldw	r2,20(r16)
81121584:	80000215 	stw	zero,8(r16)
81121588:	0085c83a 	sub	r2,zero,r2
8112158c:	80800615 	stw	r2,24(r16)
81121590:	183fe41e 	bne	r3,zero,81121524 <__reset+0xfb101524>
81121594:	80c0030b 	ldhu	r3,12(r16)
81121598:	0005883a 	mov	r2,zero
8112159c:	1900200c 	andi	r4,r3,128
811215a0:	203fe126 	beq	r4,zero,81121528 <__reset+0xfb101528>
811215a4:	18c01014 	ori	r3,r3,64
811215a8:	80c0030d 	sth	r3,12(r16)
811215ac:	00bfffc4 	movi	r2,-1
811215b0:	003fdd06 	br	81121528 <__reset+0xfb101528>
811215b4:	11234cc0 	call	811234cc <__sinit>
811215b8:	003fcd06 	br	811214f0 <__reset+0xfb1014f0>
811215bc:	0005883a 	mov	r2,zero
811215c0:	003fd606 	br	8112151c <__reset+0xfb10151c>
811215c4:	81400c17 	ldw	r5,48(r16)
811215c8:	28000626 	beq	r5,zero,811215e4 <__swsetup_r+0x12c>
811215cc:	80801004 	addi	r2,r16,64
811215d0:	28800326 	beq	r5,r2,811215e0 <__swsetup_r+0x128>
811215d4:	8809883a 	mov	r4,r17
811215d8:	11238b80 	call	811238b8 <_free_r>
811215dc:	8100030b 	ldhu	r4,12(r16)
811215e0:	80000c15 	stw	zero,48(r16)
811215e4:	80c00417 	ldw	r3,16(r16)
811215e8:	00bff6c4 	movi	r2,-37
811215ec:	1108703a 	and	r4,r2,r4
811215f0:	80000115 	stw	zero,4(r16)
811215f4:	80c00015 	stw	r3,0(r16)
811215f8:	003fd506 	br	81121550 <__reset+0xfb101550>
811215fc:	00800244 	movi	r2,9
81121600:	88800015 	stw	r2,0(r17)
81121604:	20801014 	ori	r2,r4,64
81121608:	8080030d 	sth	r2,12(r16)
8112160c:	00bfffc4 	movi	r2,-1
81121610:	003fc506 	br	81121528 <__reset+0xfb101528>

81121614 <quorem>:
81121614:	defff704 	addi	sp,sp,-36
81121618:	de00012e 	bgeu	sp,et,81121620 <quorem+0xc>
8112161c:	003b68fa 	trap	3
81121620:	dc800215 	stw	r18,8(sp)
81121624:	20800417 	ldw	r2,16(r4)
81121628:	2c800417 	ldw	r18,16(r5)
8112162c:	dfc00815 	stw	ra,32(sp)
81121630:	ddc00715 	stw	r23,28(sp)
81121634:	dd800615 	stw	r22,24(sp)
81121638:	dd400515 	stw	r21,20(sp)
8112163c:	dd000415 	stw	r20,16(sp)
81121640:	dcc00315 	stw	r19,12(sp)
81121644:	dc400115 	stw	r17,4(sp)
81121648:	dc000015 	stw	r16,0(sp)
8112164c:	14807116 	blt	r2,r18,81121814 <quorem+0x200>
81121650:	94bfffc4 	addi	r18,r18,-1
81121654:	94ad883a 	add	r22,r18,r18
81121658:	b5ad883a 	add	r22,r22,r22
8112165c:	2c400504 	addi	r17,r5,20
81121660:	8da9883a 	add	r20,r17,r22
81121664:	25400504 	addi	r21,r4,20
81121668:	282f883a 	mov	r23,r5
8112166c:	adad883a 	add	r22,r21,r22
81121670:	a1400017 	ldw	r5,0(r20)
81121674:	2021883a 	mov	r16,r4
81121678:	b1000017 	ldw	r4,0(r22)
8112167c:	29400044 	addi	r5,r5,1
81121680:	112d8e40 	call	8112d8e4 <__udivsi3>
81121684:	1027883a 	mov	r19,r2
81121688:	10002c26 	beq	r2,zero,8112173c <quorem+0x128>
8112168c:	a813883a 	mov	r9,r21
81121690:	880b883a 	mov	r5,r17
81121694:	0009883a 	mov	r4,zero
81121698:	000d883a 	mov	r6,zero
8112169c:	2a000017 	ldw	r8,0(r5)
811216a0:	49c00017 	ldw	r7,0(r9)
811216a4:	29400104 	addi	r5,r5,4
811216a8:	40bfffcc 	andi	r2,r8,65535
811216ac:	14c5383a 	mul	r2,r2,r19
811216b0:	4010d43a 	srli	r8,r8,16
811216b4:	38ffffcc 	andi	r3,r7,65535
811216b8:	1105883a 	add	r2,r2,r4
811216bc:	1008d43a 	srli	r4,r2,16
811216c0:	44d1383a 	mul	r8,r8,r19
811216c4:	198d883a 	add	r6,r3,r6
811216c8:	10ffffcc 	andi	r3,r2,65535
811216cc:	30c7c83a 	sub	r3,r6,r3
811216d0:	380ed43a 	srli	r7,r7,16
811216d4:	4105883a 	add	r2,r8,r4
811216d8:	180dd43a 	srai	r6,r3,16
811216dc:	113fffcc 	andi	r4,r2,65535
811216e0:	390fc83a 	sub	r7,r7,r4
811216e4:	398d883a 	add	r6,r7,r6
811216e8:	300e943a 	slli	r7,r6,16
811216ec:	18ffffcc 	andi	r3,r3,65535
811216f0:	1008d43a 	srli	r4,r2,16
811216f4:	38ceb03a 	or	r7,r7,r3
811216f8:	49c00015 	stw	r7,0(r9)
811216fc:	300dd43a 	srai	r6,r6,16
81121700:	4a400104 	addi	r9,r9,4
81121704:	a17fe52e 	bgeu	r20,r5,8112169c <__reset+0xfb10169c>
81121708:	b0800017 	ldw	r2,0(r22)
8112170c:	10000b1e 	bne	r2,zero,8112173c <quorem+0x128>
81121710:	b0bfff04 	addi	r2,r22,-4
81121714:	a880082e 	bgeu	r21,r2,81121738 <quorem+0x124>
81121718:	b0ffff17 	ldw	r3,-4(r22)
8112171c:	18000326 	beq	r3,zero,8112172c <quorem+0x118>
81121720:	00000506 	br	81121738 <quorem+0x124>
81121724:	10c00017 	ldw	r3,0(r2)
81121728:	1800031e 	bne	r3,zero,81121738 <quorem+0x124>
8112172c:	10bfff04 	addi	r2,r2,-4
81121730:	94bfffc4 	addi	r18,r18,-1
81121734:	a8bffb36 	bltu	r21,r2,81121724 <__reset+0xfb101724>
81121738:	84800415 	stw	r18,16(r16)
8112173c:	b80b883a 	mov	r5,r23
81121740:	8009883a 	mov	r4,r16
81121744:	1125a9c0 	call	81125a9c <__mcmp>
81121748:	10002616 	blt	r2,zero,811217e4 <quorem+0x1d0>
8112174c:	9cc00044 	addi	r19,r19,1
81121750:	a805883a 	mov	r2,r21
81121754:	000b883a 	mov	r5,zero
81121758:	11000017 	ldw	r4,0(r2)
8112175c:	89800017 	ldw	r6,0(r17)
81121760:	10800104 	addi	r2,r2,4
81121764:	20ffffcc 	andi	r3,r4,65535
81121768:	194b883a 	add	r5,r3,r5
8112176c:	30ffffcc 	andi	r3,r6,65535
81121770:	28c7c83a 	sub	r3,r5,r3
81121774:	300cd43a 	srli	r6,r6,16
81121778:	2008d43a 	srli	r4,r4,16
8112177c:	180bd43a 	srai	r5,r3,16
81121780:	18ffffcc 	andi	r3,r3,65535
81121784:	2189c83a 	sub	r4,r4,r6
81121788:	2149883a 	add	r4,r4,r5
8112178c:	200c943a 	slli	r6,r4,16
81121790:	8c400104 	addi	r17,r17,4
81121794:	200bd43a 	srai	r5,r4,16
81121798:	30c6b03a 	or	r3,r6,r3
8112179c:	10ffff15 	stw	r3,-4(r2)
811217a0:	a47fed2e 	bgeu	r20,r17,81121758 <__reset+0xfb101758>
811217a4:	9485883a 	add	r2,r18,r18
811217a8:	1085883a 	add	r2,r2,r2
811217ac:	a887883a 	add	r3,r21,r2
811217b0:	18800017 	ldw	r2,0(r3)
811217b4:	10000b1e 	bne	r2,zero,811217e4 <quorem+0x1d0>
811217b8:	18bfff04 	addi	r2,r3,-4
811217bc:	a880082e 	bgeu	r21,r2,811217e0 <quorem+0x1cc>
811217c0:	18ffff17 	ldw	r3,-4(r3)
811217c4:	18000326 	beq	r3,zero,811217d4 <quorem+0x1c0>
811217c8:	00000506 	br	811217e0 <quorem+0x1cc>
811217cc:	10c00017 	ldw	r3,0(r2)
811217d0:	1800031e 	bne	r3,zero,811217e0 <quorem+0x1cc>
811217d4:	10bfff04 	addi	r2,r2,-4
811217d8:	94bfffc4 	addi	r18,r18,-1
811217dc:	a8bffb36 	bltu	r21,r2,811217cc <__reset+0xfb1017cc>
811217e0:	84800415 	stw	r18,16(r16)
811217e4:	9805883a 	mov	r2,r19
811217e8:	dfc00817 	ldw	ra,32(sp)
811217ec:	ddc00717 	ldw	r23,28(sp)
811217f0:	dd800617 	ldw	r22,24(sp)
811217f4:	dd400517 	ldw	r21,20(sp)
811217f8:	dd000417 	ldw	r20,16(sp)
811217fc:	dcc00317 	ldw	r19,12(sp)
81121800:	dc800217 	ldw	r18,8(sp)
81121804:	dc400117 	ldw	r17,4(sp)
81121808:	dc000017 	ldw	r16,0(sp)
8112180c:	dec00904 	addi	sp,sp,36
81121810:	f800283a 	ret
81121814:	0005883a 	mov	r2,zero
81121818:	003ff306 	br	811217e8 <__reset+0xfb1017e8>

8112181c <_dtoa_r>:
8112181c:	deffde04 	addi	sp,sp,-136
81121820:	de00012e 	bgeu	sp,et,81121828 <_dtoa_r+0xc>
81121824:	003b68fa 	trap	3
81121828:	20801017 	ldw	r2,64(r4)
8112182c:	df002015 	stw	fp,128(sp)
81121830:	dcc01b15 	stw	r19,108(sp)
81121834:	dc801a15 	stw	r18,104(sp)
81121838:	dc401915 	stw	r17,100(sp)
8112183c:	dc001815 	stw	r16,96(sp)
81121840:	dfc02115 	stw	ra,132(sp)
81121844:	ddc01f15 	stw	r23,124(sp)
81121848:	dd801e15 	stw	r22,120(sp)
8112184c:	dd401d15 	stw	r21,116(sp)
81121850:	dd001c15 	stw	r20,112(sp)
81121854:	d9c00315 	stw	r7,12(sp)
81121858:	2039883a 	mov	fp,r4
8112185c:	3023883a 	mov	r17,r6
81121860:	2825883a 	mov	r18,r5
81121864:	dc002417 	ldw	r16,144(sp)
81121868:	3027883a 	mov	r19,r6
8112186c:	10000826 	beq	r2,zero,81121890 <_dtoa_r+0x74>
81121870:	21801117 	ldw	r6,68(r4)
81121874:	00c00044 	movi	r3,1
81121878:	100b883a 	mov	r5,r2
8112187c:	1986983a 	sll	r3,r3,r6
81121880:	11800115 	stw	r6,4(r2)
81121884:	10c00215 	stw	r3,8(r2)
81121888:	112524c0 	call	8112524c <_Bfree>
8112188c:	e0001015 	stw	zero,64(fp)
81121890:	88002e16 	blt	r17,zero,8112194c <_dtoa_r+0x130>
81121894:	80000015 	stw	zero,0(r16)
81121898:	889ffc2c 	andhi	r2,r17,32752
8112189c:	00dffc34 	movhi	r3,32752
811218a0:	10c01c26 	beq	r2,r3,81121914 <_dtoa_r+0xf8>
811218a4:	000d883a 	mov	r6,zero
811218a8:	000f883a 	mov	r7,zero
811218ac:	9009883a 	mov	r4,r18
811218b0:	980b883a 	mov	r5,r19
811218b4:	112ed400 	call	8112ed40 <__eqdf2>
811218b8:	10002b1e 	bne	r2,zero,81121968 <_dtoa_r+0x14c>
811218bc:	d9c02317 	ldw	r7,140(sp)
811218c0:	00800044 	movi	r2,1
811218c4:	38800015 	stw	r2,0(r7)
811218c8:	d8802517 	ldw	r2,148(sp)
811218cc:	10019e26 	beq	r2,zero,81121f48 <_dtoa_r+0x72c>
811218d0:	d8c02517 	ldw	r3,148(sp)
811218d4:	00a04534 	movhi	r2,33044
811218d8:	10944644 	addi	r2,r2,20761
811218dc:	18800015 	stw	r2,0(r3)
811218e0:	10bfffc4 	addi	r2,r2,-1
811218e4:	dfc02117 	ldw	ra,132(sp)
811218e8:	df002017 	ldw	fp,128(sp)
811218ec:	ddc01f17 	ldw	r23,124(sp)
811218f0:	dd801e17 	ldw	r22,120(sp)
811218f4:	dd401d17 	ldw	r21,116(sp)
811218f8:	dd001c17 	ldw	r20,112(sp)
811218fc:	dcc01b17 	ldw	r19,108(sp)
81121900:	dc801a17 	ldw	r18,104(sp)
81121904:	dc401917 	ldw	r17,100(sp)
81121908:	dc001817 	ldw	r16,96(sp)
8112190c:	dec02204 	addi	sp,sp,136
81121910:	f800283a 	ret
81121914:	d8c02317 	ldw	r3,140(sp)
81121918:	0089c3c4 	movi	r2,9999
8112191c:	18800015 	stw	r2,0(r3)
81121920:	90017726 	beq	r18,zero,81121f00 <_dtoa_r+0x6e4>
81121924:	00a04534 	movhi	r2,33044
81121928:	10946404 	addi	r2,r2,20880
8112192c:	d9002517 	ldw	r4,148(sp)
81121930:	203fec26 	beq	r4,zero,811218e4 <__reset+0xfb1018e4>
81121934:	10c000c7 	ldb	r3,3(r2)
81121938:	1801781e 	bne	r3,zero,81121f1c <_dtoa_r+0x700>
8112193c:	10c000c4 	addi	r3,r2,3
81121940:	d9802517 	ldw	r6,148(sp)
81121944:	30c00015 	stw	r3,0(r6)
81121948:	003fe606 	br	811218e4 <__reset+0xfb1018e4>
8112194c:	04e00034 	movhi	r19,32768
81121950:	9cffffc4 	addi	r19,r19,-1
81121954:	00800044 	movi	r2,1
81121958:	8ce6703a 	and	r19,r17,r19
8112195c:	80800015 	stw	r2,0(r16)
81121960:	9823883a 	mov	r17,r19
81121964:	003fcc06 	br	81121898 <__reset+0xfb101898>
81121968:	d8800204 	addi	r2,sp,8
8112196c:	d8800015 	stw	r2,0(sp)
81121970:	d9c00104 	addi	r7,sp,4
81121974:	900b883a 	mov	r5,r18
81121978:	980d883a 	mov	r6,r19
8112197c:	e009883a 	mov	r4,fp
81121980:	8820d53a 	srli	r16,r17,20
81121984:	1125e780 	call	81125e78 <__d2b>
81121988:	d8800915 	stw	r2,36(sp)
8112198c:	8001651e 	bne	r16,zero,81121f24 <_dtoa_r+0x708>
81121990:	dd800217 	ldw	r22,8(sp)
81121994:	dc000117 	ldw	r16,4(sp)
81121998:	00800804 	movi	r2,32
8112199c:	b421883a 	add	r16,r22,r16
811219a0:	80c10c84 	addi	r3,r16,1074
811219a4:	10c2d10e 	bge	r2,r3,811224ec <_dtoa_r+0xcd0>
811219a8:	00801004 	movi	r2,64
811219ac:	81010484 	addi	r4,r16,1042
811219b0:	10c7c83a 	sub	r3,r2,r3
811219b4:	9108d83a 	srl	r4,r18,r4
811219b8:	88e2983a 	sll	r17,r17,r3
811219bc:	2448b03a 	or	r4,r4,r17
811219c0:	112eebc0 	call	8112eebc <__floatunsidf>
811219c4:	017f8434 	movhi	r5,65040
811219c8:	01800044 	movi	r6,1
811219cc:	1009883a 	mov	r4,r2
811219d0:	194b883a 	add	r5,r3,r5
811219d4:	843fffc4 	addi	r16,r16,-1
811219d8:	d9801115 	stw	r6,68(sp)
811219dc:	000d883a 	mov	r6,zero
811219e0:	01cffe34 	movhi	r7,16376
811219e4:	1119df00 	call	81119df0 <__subdf3>
811219e8:	0198dbf4 	movhi	r6,25455
811219ec:	01cff4f4 	movhi	r7,16339
811219f0:	3190d844 	addi	r6,r6,17249
811219f4:	39e1e9c4 	addi	r7,r7,-30809
811219f8:	1009883a 	mov	r4,r2
811219fc:	180b883a 	mov	r5,r3
81121a00:	11196d00 	call	811196d0 <__muldf3>
81121a04:	01a2d874 	movhi	r6,35681
81121a08:	01cff1f4 	movhi	r7,16327
81121a0c:	31b22cc4 	addi	r6,r6,-14157
81121a10:	39e28a04 	addi	r7,r7,-30168
81121a14:	180b883a 	mov	r5,r3
81121a18:	1009883a 	mov	r4,r2
81121a1c:	112db9c0 	call	8112db9c <__adddf3>
81121a20:	8009883a 	mov	r4,r16
81121a24:	1029883a 	mov	r20,r2
81121a28:	1823883a 	mov	r17,r3
81121a2c:	111a7740 	call	8111a774 <__floatsidf>
81121a30:	019427f4 	movhi	r6,20639
81121a34:	01cff4f4 	movhi	r7,16339
81121a38:	319e7ec4 	addi	r6,r6,31227
81121a3c:	39d104c4 	addi	r7,r7,17427
81121a40:	1009883a 	mov	r4,r2
81121a44:	180b883a 	mov	r5,r3
81121a48:	11196d00 	call	811196d0 <__muldf3>
81121a4c:	100d883a 	mov	r6,r2
81121a50:	180f883a 	mov	r7,r3
81121a54:	a009883a 	mov	r4,r20
81121a58:	880b883a 	mov	r5,r17
81121a5c:	112db9c0 	call	8112db9c <__adddf3>
81121a60:	1009883a 	mov	r4,r2
81121a64:	180b883a 	mov	r5,r3
81121a68:	1029883a 	mov	r20,r2
81121a6c:	1823883a 	mov	r17,r3
81121a70:	111a6f40 	call	8111a6f4 <__fixdfsi>
81121a74:	000d883a 	mov	r6,zero
81121a78:	000f883a 	mov	r7,zero
81121a7c:	a009883a 	mov	r4,r20
81121a80:	880b883a 	mov	r5,r17
81121a84:	d8800515 	stw	r2,20(sp)
81121a88:	112edc80 	call	8112edc8 <__ledf2>
81121a8c:	10028716 	blt	r2,zero,811224ac <_dtoa_r+0xc90>
81121a90:	d8c00517 	ldw	r3,20(sp)
81121a94:	00800584 	movi	r2,22
81121a98:	10c27536 	bltu	r2,r3,81122470 <_dtoa_r+0xc54>
81121a9c:	180490fa 	slli	r2,r3,3
81121aa0:	00e04534 	movhi	r3,33044
81121aa4:	18d48004 	addi	r3,r3,20992
81121aa8:	1885883a 	add	r2,r3,r2
81121aac:	11000017 	ldw	r4,0(r2)
81121ab0:	11400117 	ldw	r5,4(r2)
81121ab4:	900d883a 	mov	r6,r18
81121ab8:	980f883a 	mov	r7,r19
81121abc:	11195f40 	call	811195f4 <__gedf2>
81121ac0:	00828d0e 	bge	zero,r2,811224f8 <_dtoa_r+0xcdc>
81121ac4:	d9000517 	ldw	r4,20(sp)
81121ac8:	d8000e15 	stw	zero,56(sp)
81121acc:	213fffc4 	addi	r4,r4,-1
81121ad0:	d9000515 	stw	r4,20(sp)
81121ad4:	b42dc83a 	sub	r22,r22,r16
81121ad8:	b5bfffc4 	addi	r22,r22,-1
81121adc:	b0026f16 	blt	r22,zero,8112249c <_dtoa_r+0xc80>
81121ae0:	d8000815 	stw	zero,32(sp)
81121ae4:	d9c00517 	ldw	r7,20(sp)
81121ae8:	38026416 	blt	r7,zero,8112247c <_dtoa_r+0xc60>
81121aec:	b1ed883a 	add	r22,r22,r7
81121af0:	d9c00d15 	stw	r7,52(sp)
81121af4:	d8000a15 	stw	zero,40(sp)
81121af8:	d9800317 	ldw	r6,12(sp)
81121afc:	00800244 	movi	r2,9
81121b00:	11811436 	bltu	r2,r6,81121f54 <_dtoa_r+0x738>
81121b04:	00800144 	movi	r2,5
81121b08:	1184e10e 	bge	r2,r6,81122e90 <_dtoa_r+0x1674>
81121b0c:	31bfff04 	addi	r6,r6,-4
81121b10:	d9800315 	stw	r6,12(sp)
81121b14:	0023883a 	mov	r17,zero
81121b18:	d9800317 	ldw	r6,12(sp)
81121b1c:	008000c4 	movi	r2,3
81121b20:	30836726 	beq	r6,r2,811228c0 <_dtoa_r+0x10a4>
81121b24:	1183410e 	bge	r2,r6,8112282c <_dtoa_r+0x1010>
81121b28:	d9c00317 	ldw	r7,12(sp)
81121b2c:	00800104 	movi	r2,4
81121b30:	38827c26 	beq	r7,r2,81122524 <_dtoa_r+0xd08>
81121b34:	00800144 	movi	r2,5
81121b38:	3884c41e 	bne	r7,r2,81122e4c <_dtoa_r+0x1630>
81121b3c:	00800044 	movi	r2,1
81121b40:	d8800b15 	stw	r2,44(sp)
81121b44:	d8c00517 	ldw	r3,20(sp)
81121b48:	d9002217 	ldw	r4,136(sp)
81121b4c:	1907883a 	add	r3,r3,r4
81121b50:	19800044 	addi	r6,r3,1
81121b54:	d8c00c15 	stw	r3,48(sp)
81121b58:	d9800615 	stw	r6,24(sp)
81121b5c:	0183a40e 	bge	zero,r6,811229f0 <_dtoa_r+0x11d4>
81121b60:	d9800617 	ldw	r6,24(sp)
81121b64:	3021883a 	mov	r16,r6
81121b68:	e0001115 	stw	zero,68(fp)
81121b6c:	008005c4 	movi	r2,23
81121b70:	1184c92e 	bgeu	r2,r6,81122e98 <_dtoa_r+0x167c>
81121b74:	00c00044 	movi	r3,1
81121b78:	00800104 	movi	r2,4
81121b7c:	1085883a 	add	r2,r2,r2
81121b80:	11000504 	addi	r4,r2,20
81121b84:	180b883a 	mov	r5,r3
81121b88:	18c00044 	addi	r3,r3,1
81121b8c:	313ffb2e 	bgeu	r6,r4,81121b7c <__reset+0xfb101b7c>
81121b90:	e1401115 	stw	r5,68(fp)
81121b94:	e009883a 	mov	r4,fp
81121b98:	112519c0 	call	8112519c <_Balloc>
81121b9c:	d8800715 	stw	r2,28(sp)
81121ba0:	e0801015 	stw	r2,64(fp)
81121ba4:	00800384 	movi	r2,14
81121ba8:	1400f736 	bltu	r2,r16,81121f88 <_dtoa_r+0x76c>
81121bac:	8800f626 	beq	r17,zero,81121f88 <_dtoa_r+0x76c>
81121bb0:	d9c00517 	ldw	r7,20(sp)
81121bb4:	01c39a0e 	bge	zero,r7,81122a20 <_dtoa_r+0x1204>
81121bb8:	388003cc 	andi	r2,r7,15
81121bbc:	100490fa 	slli	r2,r2,3
81121bc0:	382bd13a 	srai	r21,r7,4
81121bc4:	00e04534 	movhi	r3,33044
81121bc8:	18d48004 	addi	r3,r3,20992
81121bcc:	1885883a 	add	r2,r3,r2
81121bd0:	a8c0040c 	andi	r3,r21,16
81121bd4:	12400017 	ldw	r9,0(r2)
81121bd8:	12000117 	ldw	r8,4(r2)
81121bdc:	18037926 	beq	r3,zero,811229c4 <_dtoa_r+0x11a8>
81121be0:	00a04534 	movhi	r2,33044
81121be4:	10947604 	addi	r2,r2,20952
81121be8:	11800817 	ldw	r6,32(r2)
81121bec:	11c00917 	ldw	r7,36(r2)
81121bf0:	9009883a 	mov	r4,r18
81121bf4:	980b883a 	mov	r5,r19
81121bf8:	da001715 	stw	r8,92(sp)
81121bfc:	da401615 	stw	r9,88(sp)
81121c00:	112e4500 	call	8112e450 <__divdf3>
81121c04:	da001717 	ldw	r8,92(sp)
81121c08:	da401617 	ldw	r9,88(sp)
81121c0c:	ad4003cc 	andi	r21,r21,15
81121c10:	040000c4 	movi	r16,3
81121c14:	1023883a 	mov	r17,r2
81121c18:	1829883a 	mov	r20,r3
81121c1c:	a8001126 	beq	r21,zero,81121c64 <_dtoa_r+0x448>
81121c20:	05e04534 	movhi	r23,33044
81121c24:	bdd47604 	addi	r23,r23,20952
81121c28:	4805883a 	mov	r2,r9
81121c2c:	4007883a 	mov	r3,r8
81121c30:	a980004c 	andi	r6,r21,1
81121c34:	1009883a 	mov	r4,r2
81121c38:	a82bd07a 	srai	r21,r21,1
81121c3c:	180b883a 	mov	r5,r3
81121c40:	30000426 	beq	r6,zero,81121c54 <_dtoa_r+0x438>
81121c44:	b9800017 	ldw	r6,0(r23)
81121c48:	b9c00117 	ldw	r7,4(r23)
81121c4c:	84000044 	addi	r16,r16,1
81121c50:	11196d00 	call	811196d0 <__muldf3>
81121c54:	bdc00204 	addi	r23,r23,8
81121c58:	a83ff51e 	bne	r21,zero,81121c30 <__reset+0xfb101c30>
81121c5c:	1013883a 	mov	r9,r2
81121c60:	1811883a 	mov	r8,r3
81121c64:	480d883a 	mov	r6,r9
81121c68:	400f883a 	mov	r7,r8
81121c6c:	8809883a 	mov	r4,r17
81121c70:	a00b883a 	mov	r5,r20
81121c74:	112e4500 	call	8112e450 <__divdf3>
81121c78:	d8800f15 	stw	r2,60(sp)
81121c7c:	d8c01015 	stw	r3,64(sp)
81121c80:	d8c00e17 	ldw	r3,56(sp)
81121c84:	18000626 	beq	r3,zero,81121ca0 <_dtoa_r+0x484>
81121c88:	d9000f17 	ldw	r4,60(sp)
81121c8c:	d9401017 	ldw	r5,64(sp)
81121c90:	000d883a 	mov	r6,zero
81121c94:	01cffc34 	movhi	r7,16368
81121c98:	112edc80 	call	8112edc8 <__ledf2>
81121c9c:	10040b16 	blt	r2,zero,81122ccc <_dtoa_r+0x14b0>
81121ca0:	8009883a 	mov	r4,r16
81121ca4:	111a7740 	call	8111a774 <__floatsidf>
81121ca8:	d9800f17 	ldw	r6,60(sp)
81121cac:	d9c01017 	ldw	r7,64(sp)
81121cb0:	1009883a 	mov	r4,r2
81121cb4:	180b883a 	mov	r5,r3
81121cb8:	11196d00 	call	811196d0 <__muldf3>
81121cbc:	000d883a 	mov	r6,zero
81121cc0:	01d00734 	movhi	r7,16412
81121cc4:	1009883a 	mov	r4,r2
81121cc8:	180b883a 	mov	r5,r3
81121ccc:	112db9c0 	call	8112db9c <__adddf3>
81121cd0:	1021883a 	mov	r16,r2
81121cd4:	d8800617 	ldw	r2,24(sp)
81121cd8:	047f3034 	movhi	r17,64704
81121cdc:	1c63883a 	add	r17,r3,r17
81121ce0:	10031826 	beq	r2,zero,81122944 <_dtoa_r+0x1128>
81121ce4:	d8c00517 	ldw	r3,20(sp)
81121ce8:	db000617 	ldw	r12,24(sp)
81121cec:	d8c01315 	stw	r3,76(sp)
81121cf0:	d9000b17 	ldw	r4,44(sp)
81121cf4:	20038f26 	beq	r4,zero,81122b34 <_dtoa_r+0x1318>
81121cf8:	60bfffc4 	addi	r2,r12,-1
81121cfc:	100490fa 	slli	r2,r2,3
81121d00:	00e04534 	movhi	r3,33044
81121d04:	18d48004 	addi	r3,r3,20992
81121d08:	1885883a 	add	r2,r3,r2
81121d0c:	11800017 	ldw	r6,0(r2)
81121d10:	11c00117 	ldw	r7,4(r2)
81121d14:	d8800717 	ldw	r2,28(sp)
81121d18:	0009883a 	mov	r4,zero
81121d1c:	014ff834 	movhi	r5,16352
81121d20:	db001615 	stw	r12,88(sp)
81121d24:	15c00044 	addi	r23,r2,1
81121d28:	112e4500 	call	8112e450 <__divdf3>
81121d2c:	800d883a 	mov	r6,r16
81121d30:	880f883a 	mov	r7,r17
81121d34:	1009883a 	mov	r4,r2
81121d38:	180b883a 	mov	r5,r3
81121d3c:	1119df00 	call	81119df0 <__subdf3>
81121d40:	d9401017 	ldw	r5,64(sp)
81121d44:	d9000f17 	ldw	r4,60(sp)
81121d48:	102b883a 	mov	r21,r2
81121d4c:	d8c01215 	stw	r3,72(sp)
81121d50:	111a6f40 	call	8111a6f4 <__fixdfsi>
81121d54:	1009883a 	mov	r4,r2
81121d58:	1029883a 	mov	r20,r2
81121d5c:	111a7740 	call	8111a774 <__floatsidf>
81121d60:	d9000f17 	ldw	r4,60(sp)
81121d64:	d9401017 	ldw	r5,64(sp)
81121d68:	100d883a 	mov	r6,r2
81121d6c:	180f883a 	mov	r7,r3
81121d70:	1119df00 	call	81119df0 <__subdf3>
81121d74:	1823883a 	mov	r17,r3
81121d78:	d8c00717 	ldw	r3,28(sp)
81121d7c:	d9401217 	ldw	r5,72(sp)
81121d80:	a2000c04 	addi	r8,r20,48
81121d84:	1021883a 	mov	r16,r2
81121d88:	1a000005 	stb	r8,0(r3)
81121d8c:	800d883a 	mov	r6,r16
81121d90:	880f883a 	mov	r7,r17
81121d94:	a809883a 	mov	r4,r21
81121d98:	4029883a 	mov	r20,r8
81121d9c:	11195f40 	call	811195f4 <__gedf2>
81121da0:	00841d16 	blt	zero,r2,81122e18 <_dtoa_r+0x15fc>
81121da4:	800d883a 	mov	r6,r16
81121da8:	880f883a 	mov	r7,r17
81121dac:	0009883a 	mov	r4,zero
81121db0:	014ffc34 	movhi	r5,16368
81121db4:	1119df00 	call	81119df0 <__subdf3>
81121db8:	d9401217 	ldw	r5,72(sp)
81121dbc:	100d883a 	mov	r6,r2
81121dc0:	180f883a 	mov	r7,r3
81121dc4:	a809883a 	mov	r4,r21
81121dc8:	11195f40 	call	811195f4 <__gedf2>
81121dcc:	db001617 	ldw	r12,88(sp)
81121dd0:	00840e16 	blt	zero,r2,81122e0c <_dtoa_r+0x15f0>
81121dd4:	00800044 	movi	r2,1
81121dd8:	13006b0e 	bge	r2,r12,81121f88 <_dtoa_r+0x76c>
81121ddc:	d9000717 	ldw	r4,28(sp)
81121de0:	dd800f15 	stw	r22,60(sp)
81121de4:	dcc01015 	stw	r19,64(sp)
81121de8:	2319883a 	add	r12,r4,r12
81121dec:	dcc01217 	ldw	r19,72(sp)
81121df0:	602d883a 	mov	r22,r12
81121df4:	dc801215 	stw	r18,72(sp)
81121df8:	b825883a 	mov	r18,r23
81121dfc:	00000906 	br	81121e24 <_dtoa_r+0x608>
81121e00:	1119df00 	call	81119df0 <__subdf3>
81121e04:	a80d883a 	mov	r6,r21
81121e08:	980f883a 	mov	r7,r19
81121e0c:	1009883a 	mov	r4,r2
81121e10:	180b883a 	mov	r5,r3
81121e14:	112edc80 	call	8112edc8 <__ledf2>
81121e18:	1003e816 	blt	r2,zero,81122dbc <_dtoa_r+0x15a0>
81121e1c:	b825883a 	mov	r18,r23
81121e20:	bd83e926 	beq	r23,r22,81122dc8 <_dtoa_r+0x15ac>
81121e24:	a809883a 	mov	r4,r21
81121e28:	980b883a 	mov	r5,r19
81121e2c:	000d883a 	mov	r6,zero
81121e30:	01d00934 	movhi	r7,16420
81121e34:	11196d00 	call	811196d0 <__muldf3>
81121e38:	000d883a 	mov	r6,zero
81121e3c:	01d00934 	movhi	r7,16420
81121e40:	8009883a 	mov	r4,r16
81121e44:	880b883a 	mov	r5,r17
81121e48:	102b883a 	mov	r21,r2
81121e4c:	1827883a 	mov	r19,r3
81121e50:	11196d00 	call	811196d0 <__muldf3>
81121e54:	180b883a 	mov	r5,r3
81121e58:	1009883a 	mov	r4,r2
81121e5c:	1821883a 	mov	r16,r3
81121e60:	1023883a 	mov	r17,r2
81121e64:	111a6f40 	call	8111a6f4 <__fixdfsi>
81121e68:	1009883a 	mov	r4,r2
81121e6c:	1029883a 	mov	r20,r2
81121e70:	111a7740 	call	8111a774 <__floatsidf>
81121e74:	8809883a 	mov	r4,r17
81121e78:	800b883a 	mov	r5,r16
81121e7c:	100d883a 	mov	r6,r2
81121e80:	180f883a 	mov	r7,r3
81121e84:	1119df00 	call	81119df0 <__subdf3>
81121e88:	a5000c04 	addi	r20,r20,48
81121e8c:	a80d883a 	mov	r6,r21
81121e90:	980f883a 	mov	r7,r19
81121e94:	1009883a 	mov	r4,r2
81121e98:	180b883a 	mov	r5,r3
81121e9c:	95000005 	stb	r20,0(r18)
81121ea0:	1021883a 	mov	r16,r2
81121ea4:	1823883a 	mov	r17,r3
81121ea8:	112edc80 	call	8112edc8 <__ledf2>
81121eac:	bdc00044 	addi	r23,r23,1
81121eb0:	800d883a 	mov	r6,r16
81121eb4:	880f883a 	mov	r7,r17
81121eb8:	0009883a 	mov	r4,zero
81121ebc:	014ffc34 	movhi	r5,16368
81121ec0:	103fcf0e 	bge	r2,zero,81121e00 <__reset+0xfb101e00>
81121ec4:	d8c01317 	ldw	r3,76(sp)
81121ec8:	d8c00515 	stw	r3,20(sp)
81121ecc:	d9400917 	ldw	r5,36(sp)
81121ed0:	e009883a 	mov	r4,fp
81121ed4:	112524c0 	call	8112524c <_Bfree>
81121ed8:	d9000517 	ldw	r4,20(sp)
81121edc:	d9802317 	ldw	r6,140(sp)
81121ee0:	d9c02517 	ldw	r7,148(sp)
81121ee4:	b8000005 	stb	zero,0(r23)
81121ee8:	20800044 	addi	r2,r4,1
81121eec:	30800015 	stw	r2,0(r6)
81121ef0:	3802aa26 	beq	r7,zero,8112299c <_dtoa_r+0x1180>
81121ef4:	3dc00015 	stw	r23,0(r7)
81121ef8:	d8800717 	ldw	r2,28(sp)
81121efc:	003e7906 	br	811218e4 <__reset+0xfb1018e4>
81121f00:	00800434 	movhi	r2,16
81121f04:	10bfffc4 	addi	r2,r2,-1
81121f08:	88a2703a 	and	r17,r17,r2
81121f0c:	883e851e 	bne	r17,zero,81121924 <__reset+0xfb101924>
81121f10:	00a04534 	movhi	r2,33044
81121f14:	10946104 	addi	r2,r2,20868
81121f18:	003e8406 	br	8112192c <__reset+0xfb10192c>
81121f1c:	10c00204 	addi	r3,r2,8
81121f20:	003e8706 	br	81121940 <__reset+0xfb101940>
81121f24:	01400434 	movhi	r5,16
81121f28:	297fffc4 	addi	r5,r5,-1
81121f2c:	994a703a 	and	r5,r19,r5
81121f30:	9009883a 	mov	r4,r18
81121f34:	843f0044 	addi	r16,r16,-1023
81121f38:	294ffc34 	orhi	r5,r5,16368
81121f3c:	dd800217 	ldw	r22,8(sp)
81121f40:	d8001115 	stw	zero,68(sp)
81121f44:	003ea506 	br	811219dc <__reset+0xfb1019dc>
81121f48:	00a04534 	movhi	r2,33044
81121f4c:	10944604 	addi	r2,r2,20760
81121f50:	003e6406 	br	811218e4 <__reset+0xfb1018e4>
81121f54:	e0001115 	stw	zero,68(fp)
81121f58:	000b883a 	mov	r5,zero
81121f5c:	e009883a 	mov	r4,fp
81121f60:	112519c0 	call	8112519c <_Balloc>
81121f64:	01bfffc4 	movi	r6,-1
81121f68:	01c00044 	movi	r7,1
81121f6c:	d8800715 	stw	r2,28(sp)
81121f70:	d9800c15 	stw	r6,48(sp)
81121f74:	e0801015 	stw	r2,64(fp)
81121f78:	d8000315 	stw	zero,12(sp)
81121f7c:	d9c00b15 	stw	r7,44(sp)
81121f80:	d9800615 	stw	r6,24(sp)
81121f84:	d8002215 	stw	zero,136(sp)
81121f88:	d8800117 	ldw	r2,4(sp)
81121f8c:	10008916 	blt	r2,zero,811221b4 <_dtoa_r+0x998>
81121f90:	d9000517 	ldw	r4,20(sp)
81121f94:	00c00384 	movi	r3,14
81121f98:	19008616 	blt	r3,r4,811221b4 <_dtoa_r+0x998>
81121f9c:	200490fa 	slli	r2,r4,3
81121fa0:	00e04534 	movhi	r3,33044
81121fa4:	d9802217 	ldw	r6,136(sp)
81121fa8:	18d48004 	addi	r3,r3,20992
81121fac:	1885883a 	add	r2,r3,r2
81121fb0:	14000017 	ldw	r16,0(r2)
81121fb4:	14400117 	ldw	r17,4(r2)
81121fb8:	30016316 	blt	r6,zero,81122548 <_dtoa_r+0xd2c>
81121fbc:	800d883a 	mov	r6,r16
81121fc0:	880f883a 	mov	r7,r17
81121fc4:	9009883a 	mov	r4,r18
81121fc8:	980b883a 	mov	r5,r19
81121fcc:	112e4500 	call	8112e450 <__divdf3>
81121fd0:	180b883a 	mov	r5,r3
81121fd4:	1009883a 	mov	r4,r2
81121fd8:	111a6f40 	call	8111a6f4 <__fixdfsi>
81121fdc:	1009883a 	mov	r4,r2
81121fe0:	102b883a 	mov	r21,r2
81121fe4:	111a7740 	call	8111a774 <__floatsidf>
81121fe8:	800d883a 	mov	r6,r16
81121fec:	880f883a 	mov	r7,r17
81121ff0:	1009883a 	mov	r4,r2
81121ff4:	180b883a 	mov	r5,r3
81121ff8:	11196d00 	call	811196d0 <__muldf3>
81121ffc:	100d883a 	mov	r6,r2
81122000:	180f883a 	mov	r7,r3
81122004:	9009883a 	mov	r4,r18
81122008:	980b883a 	mov	r5,r19
8112200c:	1119df00 	call	81119df0 <__subdf3>
81122010:	d9c00717 	ldw	r7,28(sp)
81122014:	1009883a 	mov	r4,r2
81122018:	a8800c04 	addi	r2,r21,48
8112201c:	38800005 	stb	r2,0(r7)
81122020:	3dc00044 	addi	r23,r7,1
81122024:	d9c00617 	ldw	r7,24(sp)
81122028:	01800044 	movi	r6,1
8112202c:	180b883a 	mov	r5,r3
81122030:	2005883a 	mov	r2,r4
81122034:	39803826 	beq	r7,r6,81122118 <_dtoa_r+0x8fc>
81122038:	000d883a 	mov	r6,zero
8112203c:	01d00934 	movhi	r7,16420
81122040:	11196d00 	call	811196d0 <__muldf3>
81122044:	000d883a 	mov	r6,zero
81122048:	000f883a 	mov	r7,zero
8112204c:	1009883a 	mov	r4,r2
81122050:	180b883a 	mov	r5,r3
81122054:	1025883a 	mov	r18,r2
81122058:	1827883a 	mov	r19,r3
8112205c:	112ed400 	call	8112ed40 <__eqdf2>
81122060:	103f9a26 	beq	r2,zero,81121ecc <__reset+0xfb101ecc>
81122064:	d9c00617 	ldw	r7,24(sp)
81122068:	d8c00717 	ldw	r3,28(sp)
8112206c:	b829883a 	mov	r20,r23
81122070:	38bfffc4 	addi	r2,r7,-1
81122074:	18ad883a 	add	r22,r3,r2
81122078:	00000a06 	br	811220a4 <_dtoa_r+0x888>
8112207c:	11196d00 	call	811196d0 <__muldf3>
81122080:	000d883a 	mov	r6,zero
81122084:	000f883a 	mov	r7,zero
81122088:	1009883a 	mov	r4,r2
8112208c:	180b883a 	mov	r5,r3
81122090:	1025883a 	mov	r18,r2
81122094:	1827883a 	mov	r19,r3
81122098:	b829883a 	mov	r20,r23
8112209c:	112ed400 	call	8112ed40 <__eqdf2>
811220a0:	103f8a26 	beq	r2,zero,81121ecc <__reset+0xfb101ecc>
811220a4:	800d883a 	mov	r6,r16
811220a8:	880f883a 	mov	r7,r17
811220ac:	9009883a 	mov	r4,r18
811220b0:	980b883a 	mov	r5,r19
811220b4:	112e4500 	call	8112e450 <__divdf3>
811220b8:	180b883a 	mov	r5,r3
811220bc:	1009883a 	mov	r4,r2
811220c0:	111a6f40 	call	8111a6f4 <__fixdfsi>
811220c4:	1009883a 	mov	r4,r2
811220c8:	102b883a 	mov	r21,r2
811220cc:	111a7740 	call	8111a774 <__floatsidf>
811220d0:	800d883a 	mov	r6,r16
811220d4:	880f883a 	mov	r7,r17
811220d8:	1009883a 	mov	r4,r2
811220dc:	180b883a 	mov	r5,r3
811220e0:	11196d00 	call	811196d0 <__muldf3>
811220e4:	100d883a 	mov	r6,r2
811220e8:	180f883a 	mov	r7,r3
811220ec:	9009883a 	mov	r4,r18
811220f0:	980b883a 	mov	r5,r19
811220f4:	1119df00 	call	81119df0 <__subdf3>
811220f8:	aa000c04 	addi	r8,r21,48
811220fc:	a2000005 	stb	r8,0(r20)
81122100:	000d883a 	mov	r6,zero
81122104:	01d00934 	movhi	r7,16420
81122108:	1009883a 	mov	r4,r2
8112210c:	180b883a 	mov	r5,r3
81122110:	a5c00044 	addi	r23,r20,1
81122114:	b53fd91e 	bne	r22,r20,8112207c <__reset+0xfb10207c>
81122118:	100d883a 	mov	r6,r2
8112211c:	180f883a 	mov	r7,r3
81122120:	1009883a 	mov	r4,r2
81122124:	180b883a 	mov	r5,r3
81122128:	112db9c0 	call	8112db9c <__adddf3>
8112212c:	100d883a 	mov	r6,r2
81122130:	180f883a 	mov	r7,r3
81122134:	8009883a 	mov	r4,r16
81122138:	880b883a 	mov	r5,r17
8112213c:	1027883a 	mov	r19,r2
81122140:	1825883a 	mov	r18,r3
81122144:	112edc80 	call	8112edc8 <__ledf2>
81122148:	10000816 	blt	r2,zero,8112216c <_dtoa_r+0x950>
8112214c:	980d883a 	mov	r6,r19
81122150:	900f883a 	mov	r7,r18
81122154:	8009883a 	mov	r4,r16
81122158:	880b883a 	mov	r5,r17
8112215c:	112ed400 	call	8112ed40 <__eqdf2>
81122160:	103f5a1e 	bne	r2,zero,81121ecc <__reset+0xfb101ecc>
81122164:	ad40004c 	andi	r21,r21,1
81122168:	a83f5826 	beq	r21,zero,81121ecc <__reset+0xfb101ecc>
8112216c:	bd3fffc3 	ldbu	r20,-1(r23)
81122170:	b8bfffc4 	addi	r2,r23,-1
81122174:	1007883a 	mov	r3,r2
81122178:	01400e44 	movi	r5,57
8112217c:	d9800717 	ldw	r6,28(sp)
81122180:	00000506 	br	81122198 <_dtoa_r+0x97c>
81122184:	18ffffc4 	addi	r3,r3,-1
81122188:	11824726 	beq	r2,r6,81122aa8 <_dtoa_r+0x128c>
8112218c:	1d000003 	ldbu	r20,0(r3)
81122190:	102f883a 	mov	r23,r2
81122194:	10bfffc4 	addi	r2,r2,-1
81122198:	a1003fcc 	andi	r4,r20,255
8112219c:	2100201c 	xori	r4,r4,128
811221a0:	213fe004 	addi	r4,r4,-128
811221a4:	217ff726 	beq	r4,r5,81122184 <__reset+0xfb102184>
811221a8:	a2000044 	addi	r8,r20,1
811221ac:	12000005 	stb	r8,0(r2)
811221b0:	003f4606 	br	81121ecc <__reset+0xfb101ecc>
811221b4:	d9000b17 	ldw	r4,44(sp)
811221b8:	2000c826 	beq	r4,zero,811224dc <_dtoa_r+0xcc0>
811221bc:	d9800317 	ldw	r6,12(sp)
811221c0:	00c00044 	movi	r3,1
811221c4:	1980f90e 	bge	r3,r6,811225ac <_dtoa_r+0xd90>
811221c8:	d8800617 	ldw	r2,24(sp)
811221cc:	d8c00a17 	ldw	r3,40(sp)
811221d0:	157fffc4 	addi	r21,r2,-1
811221d4:	1d41f316 	blt	r3,r21,811229a4 <_dtoa_r+0x1188>
811221d8:	1d6bc83a 	sub	r21,r3,r21
811221dc:	d9c00617 	ldw	r7,24(sp)
811221e0:	3802aa16 	blt	r7,zero,81122c8c <_dtoa_r+0x1470>
811221e4:	dd000817 	ldw	r20,32(sp)
811221e8:	d8800617 	ldw	r2,24(sp)
811221ec:	d8c00817 	ldw	r3,32(sp)
811221f0:	01400044 	movi	r5,1
811221f4:	e009883a 	mov	r4,fp
811221f8:	1887883a 	add	r3,r3,r2
811221fc:	d8c00815 	stw	r3,32(sp)
81122200:	b0ad883a 	add	r22,r22,r2
81122204:	11255c00 	call	811255c0 <__i2b>
81122208:	1023883a 	mov	r17,r2
8112220c:	a0000826 	beq	r20,zero,81122230 <_dtoa_r+0xa14>
81122210:	0580070e 	bge	zero,r22,81122230 <_dtoa_r+0xa14>
81122214:	a005883a 	mov	r2,r20
81122218:	b500b916 	blt	r22,r20,81122500 <_dtoa_r+0xce4>
8112221c:	d9000817 	ldw	r4,32(sp)
81122220:	a0a9c83a 	sub	r20,r20,r2
81122224:	b0adc83a 	sub	r22,r22,r2
81122228:	2089c83a 	sub	r4,r4,r2
8112222c:	d9000815 	stw	r4,32(sp)
81122230:	d9800a17 	ldw	r6,40(sp)
81122234:	0181810e 	bge	zero,r6,8112283c <_dtoa_r+0x1020>
81122238:	d9c00b17 	ldw	r7,44(sp)
8112223c:	3800b326 	beq	r7,zero,8112250c <_dtoa_r+0xcf0>
81122240:	a800b226 	beq	r21,zero,8112250c <_dtoa_r+0xcf0>
81122244:	880b883a 	mov	r5,r17
81122248:	a80d883a 	mov	r6,r21
8112224c:	e009883a 	mov	r4,fp
81122250:	11258040 	call	81125804 <__pow5mult>
81122254:	d9800917 	ldw	r6,36(sp)
81122258:	100b883a 	mov	r5,r2
8112225c:	e009883a 	mov	r4,fp
81122260:	1023883a 	mov	r17,r2
81122264:	11256040 	call	81125604 <__multiply>
81122268:	1021883a 	mov	r16,r2
8112226c:	d8800a17 	ldw	r2,40(sp)
81122270:	d9400917 	ldw	r5,36(sp)
81122274:	e009883a 	mov	r4,fp
81122278:	1545c83a 	sub	r2,r2,r21
8112227c:	d8800a15 	stw	r2,40(sp)
81122280:	112524c0 	call	8112524c <_Bfree>
81122284:	d8c00a17 	ldw	r3,40(sp)
81122288:	18009f1e 	bne	r3,zero,81122508 <_dtoa_r+0xcec>
8112228c:	05c00044 	movi	r23,1
81122290:	e009883a 	mov	r4,fp
81122294:	b80b883a 	mov	r5,r23
81122298:	11255c00 	call	811255c0 <__i2b>
8112229c:	d9000d17 	ldw	r4,52(sp)
811222a0:	102b883a 	mov	r21,r2
811222a4:	2000ce26 	beq	r4,zero,811225e0 <_dtoa_r+0xdc4>
811222a8:	200d883a 	mov	r6,r4
811222ac:	100b883a 	mov	r5,r2
811222b0:	e009883a 	mov	r4,fp
811222b4:	11258040 	call	81125804 <__pow5mult>
811222b8:	d9800317 	ldw	r6,12(sp)
811222bc:	102b883a 	mov	r21,r2
811222c0:	b981810e 	bge	r23,r6,811228c8 <_dtoa_r+0x10ac>
811222c4:	0027883a 	mov	r19,zero
811222c8:	a8800417 	ldw	r2,16(r21)
811222cc:	05c00804 	movi	r23,32
811222d0:	10800104 	addi	r2,r2,4
811222d4:	1085883a 	add	r2,r2,r2
811222d8:	1085883a 	add	r2,r2,r2
811222dc:	a885883a 	add	r2,r21,r2
811222e0:	11000017 	ldw	r4,0(r2)
811222e4:	11254a80 	call	811254a8 <__hi0bits>
811222e8:	b885c83a 	sub	r2,r23,r2
811222ec:	1585883a 	add	r2,r2,r22
811222f0:	108007cc 	andi	r2,r2,31
811222f4:	1000b326 	beq	r2,zero,811225c4 <_dtoa_r+0xda8>
811222f8:	00c00804 	movi	r3,32
811222fc:	1887c83a 	sub	r3,r3,r2
81122300:	01000104 	movi	r4,4
81122304:	20c2cd0e 	bge	r4,r3,81122e3c <_dtoa_r+0x1620>
81122308:	00c00704 	movi	r3,28
8112230c:	1885c83a 	sub	r2,r3,r2
81122310:	d8c00817 	ldw	r3,32(sp)
81122314:	a0a9883a 	add	r20,r20,r2
81122318:	b0ad883a 	add	r22,r22,r2
8112231c:	1887883a 	add	r3,r3,r2
81122320:	d8c00815 	stw	r3,32(sp)
81122324:	d9800817 	ldw	r6,32(sp)
81122328:	0180040e 	bge	zero,r6,8112233c <_dtoa_r+0xb20>
8112232c:	800b883a 	mov	r5,r16
81122330:	e009883a 	mov	r4,fp
81122334:	112594c0 	call	8112594c <__lshift>
81122338:	1021883a 	mov	r16,r2
8112233c:	0580050e 	bge	zero,r22,81122354 <_dtoa_r+0xb38>
81122340:	a80b883a 	mov	r5,r21
81122344:	b00d883a 	mov	r6,r22
81122348:	e009883a 	mov	r4,fp
8112234c:	112594c0 	call	8112594c <__lshift>
81122350:	102b883a 	mov	r21,r2
81122354:	d9c00e17 	ldw	r7,56(sp)
81122358:	3801211e 	bne	r7,zero,811227e0 <_dtoa_r+0xfc4>
8112235c:	d9800617 	ldw	r6,24(sp)
81122360:	0181380e 	bge	zero,r6,81122844 <_dtoa_r+0x1028>
81122364:	d8c00b17 	ldw	r3,44(sp)
81122368:	1800ab1e 	bne	r3,zero,81122618 <_dtoa_r+0xdfc>
8112236c:	dc800717 	ldw	r18,28(sp)
81122370:	dcc00617 	ldw	r19,24(sp)
81122374:	9029883a 	mov	r20,r18
81122378:	00000206 	br	81122384 <_dtoa_r+0xb68>
8112237c:	11252740 	call	81125274 <__multadd>
81122380:	1021883a 	mov	r16,r2
81122384:	a80b883a 	mov	r5,r21
81122388:	8009883a 	mov	r4,r16
8112238c:	11216140 	call	81121614 <quorem>
81122390:	10800c04 	addi	r2,r2,48
81122394:	90800005 	stb	r2,0(r18)
81122398:	94800044 	addi	r18,r18,1
8112239c:	9507c83a 	sub	r3,r18,r20
811223a0:	000f883a 	mov	r7,zero
811223a4:	01800284 	movi	r6,10
811223a8:	800b883a 	mov	r5,r16
811223ac:	e009883a 	mov	r4,fp
811223b0:	1cfff216 	blt	r3,r19,8112237c <__reset+0xfb10237c>
811223b4:	1011883a 	mov	r8,r2
811223b8:	d8800617 	ldw	r2,24(sp)
811223bc:	0082370e 	bge	zero,r2,81122c9c <_dtoa_r+0x1480>
811223c0:	d9000717 	ldw	r4,28(sp)
811223c4:	0025883a 	mov	r18,zero
811223c8:	20af883a 	add	r23,r4,r2
811223cc:	01800044 	movi	r6,1
811223d0:	800b883a 	mov	r5,r16
811223d4:	e009883a 	mov	r4,fp
811223d8:	da001715 	stw	r8,92(sp)
811223dc:	112594c0 	call	8112594c <__lshift>
811223e0:	a80b883a 	mov	r5,r21
811223e4:	1009883a 	mov	r4,r2
811223e8:	d8800915 	stw	r2,36(sp)
811223ec:	1125a9c0 	call	81125a9c <__mcmp>
811223f0:	da001717 	ldw	r8,92(sp)
811223f4:	0081800e 	bge	zero,r2,811229f8 <_dtoa_r+0x11dc>
811223f8:	b93fffc3 	ldbu	r4,-1(r23)
811223fc:	b8bfffc4 	addi	r2,r23,-1
81122400:	1007883a 	mov	r3,r2
81122404:	01800e44 	movi	r6,57
81122408:	d9c00717 	ldw	r7,28(sp)
8112240c:	00000506 	br	81122424 <_dtoa_r+0xc08>
81122410:	18ffffc4 	addi	r3,r3,-1
81122414:	11c12326 	beq	r2,r7,811228a4 <_dtoa_r+0x1088>
81122418:	19000003 	ldbu	r4,0(r3)
8112241c:	102f883a 	mov	r23,r2
81122420:	10bfffc4 	addi	r2,r2,-1
81122424:	21403fcc 	andi	r5,r4,255
81122428:	2940201c 	xori	r5,r5,128
8112242c:	297fe004 	addi	r5,r5,-128
81122430:	29bff726 	beq	r5,r6,81122410 <__reset+0xfb102410>
81122434:	21000044 	addi	r4,r4,1
81122438:	11000005 	stb	r4,0(r2)
8112243c:	a80b883a 	mov	r5,r21
81122440:	e009883a 	mov	r4,fp
81122444:	112524c0 	call	8112524c <_Bfree>
81122448:	883ea026 	beq	r17,zero,81121ecc <__reset+0xfb101ecc>
8112244c:	90000426 	beq	r18,zero,81122460 <_dtoa_r+0xc44>
81122450:	94400326 	beq	r18,r17,81122460 <_dtoa_r+0xc44>
81122454:	900b883a 	mov	r5,r18
81122458:	e009883a 	mov	r4,fp
8112245c:	112524c0 	call	8112524c <_Bfree>
81122460:	880b883a 	mov	r5,r17
81122464:	e009883a 	mov	r4,fp
81122468:	112524c0 	call	8112524c <_Bfree>
8112246c:	003e9706 	br	81121ecc <__reset+0xfb101ecc>
81122470:	01800044 	movi	r6,1
81122474:	d9800e15 	stw	r6,56(sp)
81122478:	003d9606 	br	81121ad4 <__reset+0xfb101ad4>
8112247c:	d8800817 	ldw	r2,32(sp)
81122480:	d8c00517 	ldw	r3,20(sp)
81122484:	d8000d15 	stw	zero,52(sp)
81122488:	10c5c83a 	sub	r2,r2,r3
8112248c:	00c9c83a 	sub	r4,zero,r3
81122490:	d8800815 	stw	r2,32(sp)
81122494:	d9000a15 	stw	r4,40(sp)
81122498:	003d9706 	br	81121af8 <__reset+0xfb101af8>
8112249c:	05adc83a 	sub	r22,zero,r22
811224a0:	dd800815 	stw	r22,32(sp)
811224a4:	002d883a 	mov	r22,zero
811224a8:	003d8e06 	br	81121ae4 <__reset+0xfb101ae4>
811224ac:	d9000517 	ldw	r4,20(sp)
811224b0:	111a7740 	call	8111a774 <__floatsidf>
811224b4:	100d883a 	mov	r6,r2
811224b8:	180f883a 	mov	r7,r3
811224bc:	a009883a 	mov	r4,r20
811224c0:	880b883a 	mov	r5,r17
811224c4:	112ed400 	call	8112ed40 <__eqdf2>
811224c8:	103d7126 	beq	r2,zero,81121a90 <__reset+0xfb101a90>
811224cc:	d9c00517 	ldw	r7,20(sp)
811224d0:	39ffffc4 	addi	r7,r7,-1
811224d4:	d9c00515 	stw	r7,20(sp)
811224d8:	003d6d06 	br	81121a90 <__reset+0xfb101a90>
811224dc:	dd400a17 	ldw	r21,40(sp)
811224e0:	dd000817 	ldw	r20,32(sp)
811224e4:	0023883a 	mov	r17,zero
811224e8:	003f4806 	br	8112220c <__reset+0xfb10220c>
811224ec:	10e3c83a 	sub	r17,r2,r3
811224f0:	9448983a 	sll	r4,r18,r17
811224f4:	003d3206 	br	811219c0 <__reset+0xfb1019c0>
811224f8:	d8000e15 	stw	zero,56(sp)
811224fc:	003d7506 	br	81121ad4 <__reset+0xfb101ad4>
81122500:	b005883a 	mov	r2,r22
81122504:	003f4506 	br	8112221c <__reset+0xfb10221c>
81122508:	dc000915 	stw	r16,36(sp)
8112250c:	d9800a17 	ldw	r6,40(sp)
81122510:	d9400917 	ldw	r5,36(sp)
81122514:	e009883a 	mov	r4,fp
81122518:	11258040 	call	81125804 <__pow5mult>
8112251c:	1021883a 	mov	r16,r2
81122520:	003f5a06 	br	8112228c <__reset+0xfb10228c>
81122524:	01c00044 	movi	r7,1
81122528:	d9c00b15 	stw	r7,44(sp)
8112252c:	d8802217 	ldw	r2,136(sp)
81122530:	0081280e 	bge	zero,r2,811229d4 <_dtoa_r+0x11b8>
81122534:	100d883a 	mov	r6,r2
81122538:	1021883a 	mov	r16,r2
8112253c:	d8800c15 	stw	r2,48(sp)
81122540:	d8800615 	stw	r2,24(sp)
81122544:	003d8806 	br	81121b68 <__reset+0xfb101b68>
81122548:	d8800617 	ldw	r2,24(sp)
8112254c:	00be9b16 	blt	zero,r2,81121fbc <__reset+0xfb101fbc>
81122550:	10010f1e 	bne	r2,zero,81122990 <_dtoa_r+0x1174>
81122554:	880b883a 	mov	r5,r17
81122558:	000d883a 	mov	r6,zero
8112255c:	01d00534 	movhi	r7,16404
81122560:	8009883a 	mov	r4,r16
81122564:	11196d00 	call	811196d0 <__muldf3>
81122568:	900d883a 	mov	r6,r18
8112256c:	980f883a 	mov	r7,r19
81122570:	1009883a 	mov	r4,r2
81122574:	180b883a 	mov	r5,r3
81122578:	11195f40 	call	811195f4 <__gedf2>
8112257c:	002b883a 	mov	r21,zero
81122580:	0023883a 	mov	r17,zero
81122584:	1000bf16 	blt	r2,zero,81122884 <_dtoa_r+0x1068>
81122588:	d9802217 	ldw	r6,136(sp)
8112258c:	ddc00717 	ldw	r23,28(sp)
81122590:	018c303a 	nor	r6,zero,r6
81122594:	d9800515 	stw	r6,20(sp)
81122598:	a80b883a 	mov	r5,r21
8112259c:	e009883a 	mov	r4,fp
811225a0:	112524c0 	call	8112524c <_Bfree>
811225a4:	883e4926 	beq	r17,zero,81121ecc <__reset+0xfb101ecc>
811225a8:	003fad06 	br	81122460 <__reset+0xfb102460>
811225ac:	d9c01117 	ldw	r7,68(sp)
811225b0:	3801bc26 	beq	r7,zero,81122ca4 <_dtoa_r+0x1488>
811225b4:	10810cc4 	addi	r2,r2,1075
811225b8:	dd400a17 	ldw	r21,40(sp)
811225bc:	dd000817 	ldw	r20,32(sp)
811225c0:	003f0a06 	br	811221ec <__reset+0xfb1021ec>
811225c4:	00800704 	movi	r2,28
811225c8:	d9000817 	ldw	r4,32(sp)
811225cc:	a0a9883a 	add	r20,r20,r2
811225d0:	b0ad883a 	add	r22,r22,r2
811225d4:	2089883a 	add	r4,r4,r2
811225d8:	d9000815 	stw	r4,32(sp)
811225dc:	003f5106 	br	81122324 <__reset+0xfb102324>
811225e0:	d8c00317 	ldw	r3,12(sp)
811225e4:	b8c1fc0e 	bge	r23,r3,81122dd8 <_dtoa_r+0x15bc>
811225e8:	0027883a 	mov	r19,zero
811225ec:	b805883a 	mov	r2,r23
811225f0:	003f3e06 	br	811222ec <__reset+0xfb1022ec>
811225f4:	880b883a 	mov	r5,r17
811225f8:	e009883a 	mov	r4,fp
811225fc:	000f883a 	mov	r7,zero
81122600:	01800284 	movi	r6,10
81122604:	11252740 	call	81125274 <__multadd>
81122608:	d9000c17 	ldw	r4,48(sp)
8112260c:	1023883a 	mov	r17,r2
81122610:	0102040e 	bge	zero,r4,81122e24 <_dtoa_r+0x1608>
81122614:	d9000615 	stw	r4,24(sp)
81122618:	0500050e 	bge	zero,r20,81122630 <_dtoa_r+0xe14>
8112261c:	880b883a 	mov	r5,r17
81122620:	a00d883a 	mov	r6,r20
81122624:	e009883a 	mov	r4,fp
81122628:	112594c0 	call	8112594c <__lshift>
8112262c:	1023883a 	mov	r17,r2
81122630:	9801241e 	bne	r19,zero,81122ac4 <_dtoa_r+0x12a8>
81122634:	8829883a 	mov	r20,r17
81122638:	d9000617 	ldw	r4,24(sp)
8112263c:	dcc00717 	ldw	r19,28(sp)
81122640:	9480004c 	andi	r18,r18,1
81122644:	20bfffc4 	addi	r2,r4,-1
81122648:	9885883a 	add	r2,r19,r2
8112264c:	d8800415 	stw	r2,16(sp)
81122650:	dc800615 	stw	r18,24(sp)
81122654:	a80b883a 	mov	r5,r21
81122658:	8009883a 	mov	r4,r16
8112265c:	11216140 	call	81121614 <quorem>
81122660:	880b883a 	mov	r5,r17
81122664:	8009883a 	mov	r4,r16
81122668:	102f883a 	mov	r23,r2
8112266c:	1125a9c0 	call	81125a9c <__mcmp>
81122670:	a80b883a 	mov	r5,r21
81122674:	a00d883a 	mov	r6,r20
81122678:	e009883a 	mov	r4,fp
8112267c:	102d883a 	mov	r22,r2
81122680:	1125afc0 	call	81125afc <__mdiff>
81122684:	1007883a 	mov	r3,r2
81122688:	10800317 	ldw	r2,12(r2)
8112268c:	bc800c04 	addi	r18,r23,48
81122690:	180b883a 	mov	r5,r3
81122694:	10004e1e 	bne	r2,zero,811227d0 <_dtoa_r+0xfb4>
81122698:	8009883a 	mov	r4,r16
8112269c:	d8c01615 	stw	r3,88(sp)
811226a0:	1125a9c0 	call	81125a9c <__mcmp>
811226a4:	d8c01617 	ldw	r3,88(sp)
811226a8:	e009883a 	mov	r4,fp
811226ac:	d8801615 	stw	r2,88(sp)
811226b0:	180b883a 	mov	r5,r3
811226b4:	112524c0 	call	8112524c <_Bfree>
811226b8:	d8801617 	ldw	r2,88(sp)
811226bc:	1000041e 	bne	r2,zero,811226d0 <_dtoa_r+0xeb4>
811226c0:	d9800317 	ldw	r6,12(sp)
811226c4:	3000021e 	bne	r6,zero,811226d0 <_dtoa_r+0xeb4>
811226c8:	d8c00617 	ldw	r3,24(sp)
811226cc:	18003726 	beq	r3,zero,811227ac <_dtoa_r+0xf90>
811226d0:	b0002016 	blt	r22,zero,81122754 <_dtoa_r+0xf38>
811226d4:	b000041e 	bne	r22,zero,811226e8 <_dtoa_r+0xecc>
811226d8:	d9000317 	ldw	r4,12(sp)
811226dc:	2000021e 	bne	r4,zero,811226e8 <_dtoa_r+0xecc>
811226e0:	d8c00617 	ldw	r3,24(sp)
811226e4:	18001b26 	beq	r3,zero,81122754 <_dtoa_r+0xf38>
811226e8:	00810716 	blt	zero,r2,81122b08 <_dtoa_r+0x12ec>
811226ec:	d8c00417 	ldw	r3,16(sp)
811226f0:	9d800044 	addi	r22,r19,1
811226f4:	9c800005 	stb	r18,0(r19)
811226f8:	b02f883a 	mov	r23,r22
811226fc:	98c10626 	beq	r19,r3,81122b18 <_dtoa_r+0x12fc>
81122700:	800b883a 	mov	r5,r16
81122704:	000f883a 	mov	r7,zero
81122708:	01800284 	movi	r6,10
8112270c:	e009883a 	mov	r4,fp
81122710:	11252740 	call	81125274 <__multadd>
81122714:	1021883a 	mov	r16,r2
81122718:	000f883a 	mov	r7,zero
8112271c:	01800284 	movi	r6,10
81122720:	880b883a 	mov	r5,r17
81122724:	e009883a 	mov	r4,fp
81122728:	8d002526 	beq	r17,r20,811227c0 <_dtoa_r+0xfa4>
8112272c:	11252740 	call	81125274 <__multadd>
81122730:	a00b883a 	mov	r5,r20
81122734:	000f883a 	mov	r7,zero
81122738:	01800284 	movi	r6,10
8112273c:	e009883a 	mov	r4,fp
81122740:	1023883a 	mov	r17,r2
81122744:	11252740 	call	81125274 <__multadd>
81122748:	1029883a 	mov	r20,r2
8112274c:	b027883a 	mov	r19,r22
81122750:	003fc006 	br	81122654 <__reset+0xfb102654>
81122754:	9011883a 	mov	r8,r18
81122758:	00800e0e 	bge	zero,r2,81122794 <_dtoa_r+0xf78>
8112275c:	800b883a 	mov	r5,r16
81122760:	01800044 	movi	r6,1
81122764:	e009883a 	mov	r4,fp
81122768:	da001715 	stw	r8,92(sp)
8112276c:	112594c0 	call	8112594c <__lshift>
81122770:	a80b883a 	mov	r5,r21
81122774:	1009883a 	mov	r4,r2
81122778:	1021883a 	mov	r16,r2
8112277c:	1125a9c0 	call	81125a9c <__mcmp>
81122780:	da001717 	ldw	r8,92(sp)
81122784:	0081960e 	bge	zero,r2,81122de0 <_dtoa_r+0x15c4>
81122788:	00800e44 	movi	r2,57
8112278c:	40817026 	beq	r8,r2,81122d50 <_dtoa_r+0x1534>
81122790:	ba000c44 	addi	r8,r23,49
81122794:	8825883a 	mov	r18,r17
81122798:	9dc00044 	addi	r23,r19,1
8112279c:	9a000005 	stb	r8,0(r19)
811227a0:	a023883a 	mov	r17,r20
811227a4:	dc000915 	stw	r16,36(sp)
811227a8:	003f2406 	br	8112243c <__reset+0xfb10243c>
811227ac:	00800e44 	movi	r2,57
811227b0:	9011883a 	mov	r8,r18
811227b4:	90816626 	beq	r18,r2,81122d50 <_dtoa_r+0x1534>
811227b8:	05bff516 	blt	zero,r22,81122790 <__reset+0xfb102790>
811227bc:	003ff506 	br	81122794 <__reset+0xfb102794>
811227c0:	11252740 	call	81125274 <__multadd>
811227c4:	1023883a 	mov	r17,r2
811227c8:	1029883a 	mov	r20,r2
811227cc:	003fdf06 	br	8112274c <__reset+0xfb10274c>
811227d0:	e009883a 	mov	r4,fp
811227d4:	112524c0 	call	8112524c <_Bfree>
811227d8:	00800044 	movi	r2,1
811227dc:	003fbc06 	br	811226d0 <__reset+0xfb1026d0>
811227e0:	a80b883a 	mov	r5,r21
811227e4:	8009883a 	mov	r4,r16
811227e8:	1125a9c0 	call	81125a9c <__mcmp>
811227ec:	103edb0e 	bge	r2,zero,8112235c <__reset+0xfb10235c>
811227f0:	800b883a 	mov	r5,r16
811227f4:	000f883a 	mov	r7,zero
811227f8:	01800284 	movi	r6,10
811227fc:	e009883a 	mov	r4,fp
81122800:	11252740 	call	81125274 <__multadd>
81122804:	1021883a 	mov	r16,r2
81122808:	d8800517 	ldw	r2,20(sp)
8112280c:	d8c00b17 	ldw	r3,44(sp)
81122810:	10bfffc4 	addi	r2,r2,-1
81122814:	d8800515 	stw	r2,20(sp)
81122818:	183f761e 	bne	r3,zero,811225f4 <__reset+0xfb1025f4>
8112281c:	d9000c17 	ldw	r4,48(sp)
81122820:	0101730e 	bge	zero,r4,81122df0 <_dtoa_r+0x15d4>
81122824:	d9000615 	stw	r4,24(sp)
81122828:	003ed006 	br	8112236c <__reset+0xfb10236c>
8112282c:	00800084 	movi	r2,2
81122830:	3081861e 	bne	r6,r2,81122e4c <_dtoa_r+0x1630>
81122834:	d8000b15 	stw	zero,44(sp)
81122838:	003f3c06 	br	8112252c <__reset+0xfb10252c>
8112283c:	dc000917 	ldw	r16,36(sp)
81122840:	003e9206 	br	8112228c <__reset+0xfb10228c>
81122844:	d9c00317 	ldw	r7,12(sp)
81122848:	00800084 	movi	r2,2
8112284c:	11fec50e 	bge	r2,r7,81122364 <__reset+0xfb102364>
81122850:	d9000617 	ldw	r4,24(sp)
81122854:	20013c1e 	bne	r4,zero,81122d48 <_dtoa_r+0x152c>
81122858:	a80b883a 	mov	r5,r21
8112285c:	000f883a 	mov	r7,zero
81122860:	01800144 	movi	r6,5
81122864:	e009883a 	mov	r4,fp
81122868:	11252740 	call	81125274 <__multadd>
8112286c:	100b883a 	mov	r5,r2
81122870:	8009883a 	mov	r4,r16
81122874:	102b883a 	mov	r21,r2
81122878:	1125a9c0 	call	81125a9c <__mcmp>
8112287c:	dc000915 	stw	r16,36(sp)
81122880:	00bf410e 	bge	zero,r2,81122588 <__reset+0xfb102588>
81122884:	d9c00717 	ldw	r7,28(sp)
81122888:	00800c44 	movi	r2,49
8112288c:	38800005 	stb	r2,0(r7)
81122890:	d8800517 	ldw	r2,20(sp)
81122894:	3dc00044 	addi	r23,r7,1
81122898:	10800044 	addi	r2,r2,1
8112289c:	d8800515 	stw	r2,20(sp)
811228a0:	003f3d06 	br	81122598 <__reset+0xfb102598>
811228a4:	d9800517 	ldw	r6,20(sp)
811228a8:	d9c00717 	ldw	r7,28(sp)
811228ac:	00800c44 	movi	r2,49
811228b0:	31800044 	addi	r6,r6,1
811228b4:	d9800515 	stw	r6,20(sp)
811228b8:	38800005 	stb	r2,0(r7)
811228bc:	003edf06 	br	8112243c <__reset+0xfb10243c>
811228c0:	d8000b15 	stw	zero,44(sp)
811228c4:	003c9f06 	br	81121b44 <__reset+0xfb101b44>
811228c8:	903e7e1e 	bne	r18,zero,811222c4 <__reset+0xfb1022c4>
811228cc:	00800434 	movhi	r2,16
811228d0:	10bfffc4 	addi	r2,r2,-1
811228d4:	9884703a 	and	r2,r19,r2
811228d8:	1000ea1e 	bne	r2,zero,81122c84 <_dtoa_r+0x1468>
811228dc:	9cdffc2c 	andhi	r19,r19,32752
811228e0:	9800e826 	beq	r19,zero,81122c84 <_dtoa_r+0x1468>
811228e4:	d9c00817 	ldw	r7,32(sp)
811228e8:	b5800044 	addi	r22,r22,1
811228ec:	04c00044 	movi	r19,1
811228f0:	39c00044 	addi	r7,r7,1
811228f4:	d9c00815 	stw	r7,32(sp)
811228f8:	d8800d17 	ldw	r2,52(sp)
811228fc:	103e721e 	bne	r2,zero,811222c8 <__reset+0xfb1022c8>
81122900:	00800044 	movi	r2,1
81122904:	003e7906 	br	811222ec <__reset+0xfb1022ec>
81122908:	8009883a 	mov	r4,r16
8112290c:	111a7740 	call	8111a774 <__floatsidf>
81122910:	d9800f17 	ldw	r6,60(sp)
81122914:	d9c01017 	ldw	r7,64(sp)
81122918:	1009883a 	mov	r4,r2
8112291c:	180b883a 	mov	r5,r3
81122920:	11196d00 	call	811196d0 <__muldf3>
81122924:	000d883a 	mov	r6,zero
81122928:	01d00734 	movhi	r7,16412
8112292c:	1009883a 	mov	r4,r2
81122930:	180b883a 	mov	r5,r3
81122934:	112db9c0 	call	8112db9c <__adddf3>
81122938:	047f3034 	movhi	r17,64704
8112293c:	1021883a 	mov	r16,r2
81122940:	1c63883a 	add	r17,r3,r17
81122944:	d9000f17 	ldw	r4,60(sp)
81122948:	d9401017 	ldw	r5,64(sp)
8112294c:	000d883a 	mov	r6,zero
81122950:	01d00534 	movhi	r7,16404
81122954:	1119df00 	call	81119df0 <__subdf3>
81122958:	800d883a 	mov	r6,r16
8112295c:	880f883a 	mov	r7,r17
81122960:	1009883a 	mov	r4,r2
81122964:	180b883a 	mov	r5,r3
81122968:	102b883a 	mov	r21,r2
8112296c:	1829883a 	mov	r20,r3
81122970:	11195f40 	call	811195f4 <__gedf2>
81122974:	00806c16 	blt	zero,r2,81122b28 <_dtoa_r+0x130c>
81122978:	89e0003c 	xorhi	r7,r17,32768
8112297c:	800d883a 	mov	r6,r16
81122980:	a809883a 	mov	r4,r21
81122984:	a00b883a 	mov	r5,r20
81122988:	112edc80 	call	8112edc8 <__ledf2>
8112298c:	103d7e0e 	bge	r2,zero,81121f88 <__reset+0xfb101f88>
81122990:	002b883a 	mov	r21,zero
81122994:	0023883a 	mov	r17,zero
81122998:	003efb06 	br	81122588 <__reset+0xfb102588>
8112299c:	d8800717 	ldw	r2,28(sp)
811229a0:	003bd006 	br	811218e4 <__reset+0xfb1018e4>
811229a4:	d9000a17 	ldw	r4,40(sp)
811229a8:	d9800d17 	ldw	r6,52(sp)
811229ac:	dd400a15 	stw	r21,40(sp)
811229b0:	a905c83a 	sub	r2,r21,r4
811229b4:	308d883a 	add	r6,r6,r2
811229b8:	d9800d15 	stw	r6,52(sp)
811229bc:	002b883a 	mov	r21,zero
811229c0:	003e0606 	br	811221dc <__reset+0xfb1021dc>
811229c4:	9023883a 	mov	r17,r18
811229c8:	9829883a 	mov	r20,r19
811229cc:	04000084 	movi	r16,2
811229d0:	003c9206 	br	81121c1c <__reset+0xfb101c1c>
811229d4:	04000044 	movi	r16,1
811229d8:	dc000c15 	stw	r16,48(sp)
811229dc:	dc000615 	stw	r16,24(sp)
811229e0:	dc002215 	stw	r16,136(sp)
811229e4:	e0001115 	stw	zero,68(fp)
811229e8:	000b883a 	mov	r5,zero
811229ec:	003c6906 	br	81121b94 <__reset+0xfb101b94>
811229f0:	3021883a 	mov	r16,r6
811229f4:	003ffb06 	br	811229e4 <__reset+0xfb1029e4>
811229f8:	1000021e 	bne	r2,zero,81122a04 <_dtoa_r+0x11e8>
811229fc:	4200004c 	andi	r8,r8,1
81122a00:	403e7d1e 	bne	r8,zero,811223f8 <__reset+0xfb1023f8>
81122a04:	01000c04 	movi	r4,48
81122a08:	00000106 	br	81122a10 <_dtoa_r+0x11f4>
81122a0c:	102f883a 	mov	r23,r2
81122a10:	b8bfffc4 	addi	r2,r23,-1
81122a14:	10c00007 	ldb	r3,0(r2)
81122a18:	193ffc26 	beq	r3,r4,81122a0c <__reset+0xfb102a0c>
81122a1c:	003e8706 	br	8112243c <__reset+0xfb10243c>
81122a20:	d8800517 	ldw	r2,20(sp)
81122a24:	00a3c83a 	sub	r17,zero,r2
81122a28:	8800a426 	beq	r17,zero,81122cbc <_dtoa_r+0x14a0>
81122a2c:	888003cc 	andi	r2,r17,15
81122a30:	100490fa 	slli	r2,r2,3
81122a34:	00e04534 	movhi	r3,33044
81122a38:	18d48004 	addi	r3,r3,20992
81122a3c:	1885883a 	add	r2,r3,r2
81122a40:	11800017 	ldw	r6,0(r2)
81122a44:	11c00117 	ldw	r7,4(r2)
81122a48:	9009883a 	mov	r4,r18
81122a4c:	980b883a 	mov	r5,r19
81122a50:	8823d13a 	srai	r17,r17,4
81122a54:	11196d00 	call	811196d0 <__muldf3>
81122a58:	d8800f15 	stw	r2,60(sp)
81122a5c:	d8c01015 	stw	r3,64(sp)
81122a60:	8800e826 	beq	r17,zero,81122e04 <_dtoa_r+0x15e8>
81122a64:	05204534 	movhi	r20,33044
81122a68:	a5147604 	addi	r20,r20,20952
81122a6c:	04000084 	movi	r16,2
81122a70:	8980004c 	andi	r6,r17,1
81122a74:	1009883a 	mov	r4,r2
81122a78:	8823d07a 	srai	r17,r17,1
81122a7c:	180b883a 	mov	r5,r3
81122a80:	30000426 	beq	r6,zero,81122a94 <_dtoa_r+0x1278>
81122a84:	a1800017 	ldw	r6,0(r20)
81122a88:	a1c00117 	ldw	r7,4(r20)
81122a8c:	84000044 	addi	r16,r16,1
81122a90:	11196d00 	call	811196d0 <__muldf3>
81122a94:	a5000204 	addi	r20,r20,8
81122a98:	883ff51e 	bne	r17,zero,81122a70 <__reset+0xfb102a70>
81122a9c:	d8800f15 	stw	r2,60(sp)
81122aa0:	d8c01015 	stw	r3,64(sp)
81122aa4:	003c7606 	br	81121c80 <__reset+0xfb101c80>
81122aa8:	00c00c04 	movi	r3,48
81122aac:	10c00005 	stb	r3,0(r2)
81122ab0:	d8c00517 	ldw	r3,20(sp)
81122ab4:	bd3fffc3 	ldbu	r20,-1(r23)
81122ab8:	18c00044 	addi	r3,r3,1
81122abc:	d8c00515 	stw	r3,20(sp)
81122ac0:	003db906 	br	811221a8 <__reset+0xfb1021a8>
81122ac4:	89400117 	ldw	r5,4(r17)
81122ac8:	e009883a 	mov	r4,fp
81122acc:	112519c0 	call	8112519c <_Balloc>
81122ad0:	89800417 	ldw	r6,16(r17)
81122ad4:	89400304 	addi	r5,r17,12
81122ad8:	11000304 	addi	r4,r2,12
81122adc:	31800084 	addi	r6,r6,2
81122ae0:	318d883a 	add	r6,r6,r6
81122ae4:	318d883a 	add	r6,r6,r6
81122ae8:	1027883a 	mov	r19,r2
81122aec:	111abac0 	call	8111abac <memcpy>
81122af0:	01800044 	movi	r6,1
81122af4:	980b883a 	mov	r5,r19
81122af8:	e009883a 	mov	r4,fp
81122afc:	112594c0 	call	8112594c <__lshift>
81122b00:	1029883a 	mov	r20,r2
81122b04:	003ecc06 	br	81122638 <__reset+0xfb102638>
81122b08:	00800e44 	movi	r2,57
81122b0c:	90809026 	beq	r18,r2,81122d50 <_dtoa_r+0x1534>
81122b10:	92000044 	addi	r8,r18,1
81122b14:	003f1f06 	br	81122794 <__reset+0xfb102794>
81122b18:	9011883a 	mov	r8,r18
81122b1c:	8825883a 	mov	r18,r17
81122b20:	a023883a 	mov	r17,r20
81122b24:	003e2906 	br	811223cc <__reset+0xfb1023cc>
81122b28:	002b883a 	mov	r21,zero
81122b2c:	0023883a 	mov	r17,zero
81122b30:	003f5406 	br	81122884 <__reset+0xfb102884>
81122b34:	61bfffc4 	addi	r6,r12,-1
81122b38:	300490fa 	slli	r2,r6,3
81122b3c:	00e04534 	movhi	r3,33044
81122b40:	18d48004 	addi	r3,r3,20992
81122b44:	1885883a 	add	r2,r3,r2
81122b48:	11000017 	ldw	r4,0(r2)
81122b4c:	11400117 	ldw	r5,4(r2)
81122b50:	d8800717 	ldw	r2,28(sp)
81122b54:	880f883a 	mov	r7,r17
81122b58:	d9801215 	stw	r6,72(sp)
81122b5c:	800d883a 	mov	r6,r16
81122b60:	db001615 	stw	r12,88(sp)
81122b64:	15c00044 	addi	r23,r2,1
81122b68:	11196d00 	call	811196d0 <__muldf3>
81122b6c:	d9401017 	ldw	r5,64(sp)
81122b70:	d9000f17 	ldw	r4,60(sp)
81122b74:	d8c01515 	stw	r3,84(sp)
81122b78:	d8801415 	stw	r2,80(sp)
81122b7c:	111a6f40 	call	8111a6f4 <__fixdfsi>
81122b80:	1009883a 	mov	r4,r2
81122b84:	1021883a 	mov	r16,r2
81122b88:	111a7740 	call	8111a774 <__floatsidf>
81122b8c:	d9000f17 	ldw	r4,60(sp)
81122b90:	d9401017 	ldw	r5,64(sp)
81122b94:	100d883a 	mov	r6,r2
81122b98:	180f883a 	mov	r7,r3
81122b9c:	1119df00 	call	81119df0 <__subdf3>
81122ba0:	1829883a 	mov	r20,r3
81122ba4:	d8c00717 	ldw	r3,28(sp)
81122ba8:	84000c04 	addi	r16,r16,48
81122bac:	1023883a 	mov	r17,r2
81122bb0:	1c000005 	stb	r16,0(r3)
81122bb4:	db001617 	ldw	r12,88(sp)
81122bb8:	00800044 	movi	r2,1
81122bbc:	60802226 	beq	r12,r2,81122c48 <_dtoa_r+0x142c>
81122bc0:	d9c00717 	ldw	r7,28(sp)
81122bc4:	8805883a 	mov	r2,r17
81122bc8:	b82b883a 	mov	r21,r23
81122bcc:	3b19883a 	add	r12,r7,r12
81122bd0:	6023883a 	mov	r17,r12
81122bd4:	a007883a 	mov	r3,r20
81122bd8:	dc800f15 	stw	r18,60(sp)
81122bdc:	000d883a 	mov	r6,zero
81122be0:	01d00934 	movhi	r7,16420
81122be4:	1009883a 	mov	r4,r2
81122be8:	180b883a 	mov	r5,r3
81122bec:	11196d00 	call	811196d0 <__muldf3>
81122bf0:	180b883a 	mov	r5,r3
81122bf4:	1009883a 	mov	r4,r2
81122bf8:	1829883a 	mov	r20,r3
81122bfc:	1025883a 	mov	r18,r2
81122c00:	111a6f40 	call	8111a6f4 <__fixdfsi>
81122c04:	1009883a 	mov	r4,r2
81122c08:	1021883a 	mov	r16,r2
81122c0c:	111a7740 	call	8111a774 <__floatsidf>
81122c10:	100d883a 	mov	r6,r2
81122c14:	180f883a 	mov	r7,r3
81122c18:	9009883a 	mov	r4,r18
81122c1c:	a00b883a 	mov	r5,r20
81122c20:	84000c04 	addi	r16,r16,48
81122c24:	1119df00 	call	81119df0 <__subdf3>
81122c28:	ad400044 	addi	r21,r21,1
81122c2c:	ac3fffc5 	stb	r16,-1(r21)
81122c30:	ac7fea1e 	bne	r21,r17,81122bdc <__reset+0xfb102bdc>
81122c34:	1023883a 	mov	r17,r2
81122c38:	d8801217 	ldw	r2,72(sp)
81122c3c:	dc800f17 	ldw	r18,60(sp)
81122c40:	1829883a 	mov	r20,r3
81122c44:	b8af883a 	add	r23,r23,r2
81122c48:	d9001417 	ldw	r4,80(sp)
81122c4c:	d9401517 	ldw	r5,84(sp)
81122c50:	000d883a 	mov	r6,zero
81122c54:	01cff834 	movhi	r7,16352
81122c58:	112db9c0 	call	8112db9c <__adddf3>
81122c5c:	880d883a 	mov	r6,r17
81122c60:	a00f883a 	mov	r7,r20
81122c64:	1009883a 	mov	r4,r2
81122c68:	180b883a 	mov	r5,r3
81122c6c:	112edc80 	call	8112edc8 <__ledf2>
81122c70:	10003e0e 	bge	r2,zero,81122d6c <_dtoa_r+0x1550>
81122c74:	d9001317 	ldw	r4,76(sp)
81122c78:	bd3fffc3 	ldbu	r20,-1(r23)
81122c7c:	d9000515 	stw	r4,20(sp)
81122c80:	003d3b06 	br	81122170 <__reset+0xfb102170>
81122c84:	0027883a 	mov	r19,zero
81122c88:	003f1b06 	br	811228f8 <__reset+0xfb1028f8>
81122c8c:	d8800817 	ldw	r2,32(sp)
81122c90:	11e9c83a 	sub	r20,r2,r7
81122c94:	0005883a 	mov	r2,zero
81122c98:	003d5406 	br	811221ec <__reset+0xfb1021ec>
81122c9c:	00800044 	movi	r2,1
81122ca0:	003dc706 	br	811223c0 <__reset+0xfb1023c0>
81122ca4:	d8c00217 	ldw	r3,8(sp)
81122ca8:	00800d84 	movi	r2,54
81122cac:	dd400a17 	ldw	r21,40(sp)
81122cb0:	10c5c83a 	sub	r2,r2,r3
81122cb4:	dd000817 	ldw	r20,32(sp)
81122cb8:	003d4c06 	br	811221ec <__reset+0xfb1021ec>
81122cbc:	dc800f15 	stw	r18,60(sp)
81122cc0:	dcc01015 	stw	r19,64(sp)
81122cc4:	04000084 	movi	r16,2
81122cc8:	003bed06 	br	81121c80 <__reset+0xfb101c80>
81122ccc:	d9000617 	ldw	r4,24(sp)
81122cd0:	203f0d26 	beq	r4,zero,81122908 <__reset+0xfb102908>
81122cd4:	d9800c17 	ldw	r6,48(sp)
81122cd8:	01bcab0e 	bge	zero,r6,81121f88 <__reset+0xfb101f88>
81122cdc:	d9401017 	ldw	r5,64(sp)
81122ce0:	d9000f17 	ldw	r4,60(sp)
81122ce4:	000d883a 	mov	r6,zero
81122ce8:	01d00934 	movhi	r7,16420
81122cec:	11196d00 	call	811196d0 <__muldf3>
81122cf0:	81000044 	addi	r4,r16,1
81122cf4:	d8800f15 	stw	r2,60(sp)
81122cf8:	d8c01015 	stw	r3,64(sp)
81122cfc:	111a7740 	call	8111a774 <__floatsidf>
81122d00:	d9800f17 	ldw	r6,60(sp)
81122d04:	d9c01017 	ldw	r7,64(sp)
81122d08:	1009883a 	mov	r4,r2
81122d0c:	180b883a 	mov	r5,r3
81122d10:	11196d00 	call	811196d0 <__muldf3>
81122d14:	01d00734 	movhi	r7,16412
81122d18:	000d883a 	mov	r6,zero
81122d1c:	1009883a 	mov	r4,r2
81122d20:	180b883a 	mov	r5,r3
81122d24:	112db9c0 	call	8112db9c <__adddf3>
81122d28:	d9c00517 	ldw	r7,20(sp)
81122d2c:	047f3034 	movhi	r17,64704
81122d30:	1021883a 	mov	r16,r2
81122d34:	39ffffc4 	addi	r7,r7,-1
81122d38:	d9c01315 	stw	r7,76(sp)
81122d3c:	1c63883a 	add	r17,r3,r17
81122d40:	db000c17 	ldw	r12,48(sp)
81122d44:	003bea06 	br	81121cf0 <__reset+0xfb101cf0>
81122d48:	dc000915 	stw	r16,36(sp)
81122d4c:	003e0e06 	br	81122588 <__reset+0xfb102588>
81122d50:	01000e44 	movi	r4,57
81122d54:	8825883a 	mov	r18,r17
81122d58:	9dc00044 	addi	r23,r19,1
81122d5c:	99000005 	stb	r4,0(r19)
81122d60:	a023883a 	mov	r17,r20
81122d64:	dc000915 	stw	r16,36(sp)
81122d68:	003da406 	br	811223fc <__reset+0xfb1023fc>
81122d6c:	d9801417 	ldw	r6,80(sp)
81122d70:	d9c01517 	ldw	r7,84(sp)
81122d74:	0009883a 	mov	r4,zero
81122d78:	014ff834 	movhi	r5,16352
81122d7c:	1119df00 	call	81119df0 <__subdf3>
81122d80:	880d883a 	mov	r6,r17
81122d84:	a00f883a 	mov	r7,r20
81122d88:	1009883a 	mov	r4,r2
81122d8c:	180b883a 	mov	r5,r3
81122d90:	11195f40 	call	811195f4 <__gedf2>
81122d94:	00bc7c0e 	bge	zero,r2,81121f88 <__reset+0xfb101f88>
81122d98:	01000c04 	movi	r4,48
81122d9c:	00000106 	br	81122da4 <_dtoa_r+0x1588>
81122da0:	102f883a 	mov	r23,r2
81122da4:	b8bfffc4 	addi	r2,r23,-1
81122da8:	10c00007 	ldb	r3,0(r2)
81122dac:	193ffc26 	beq	r3,r4,81122da0 <__reset+0xfb102da0>
81122db0:	d9801317 	ldw	r6,76(sp)
81122db4:	d9800515 	stw	r6,20(sp)
81122db8:	003c4406 	br	81121ecc <__reset+0xfb101ecc>
81122dbc:	d9801317 	ldw	r6,76(sp)
81122dc0:	d9800515 	stw	r6,20(sp)
81122dc4:	003cea06 	br	81122170 <__reset+0xfb102170>
81122dc8:	dd800f17 	ldw	r22,60(sp)
81122dcc:	dcc01017 	ldw	r19,64(sp)
81122dd0:	dc801217 	ldw	r18,72(sp)
81122dd4:	003c6c06 	br	81121f88 <__reset+0xfb101f88>
81122dd8:	903e031e 	bne	r18,zero,811225e8 <__reset+0xfb1025e8>
81122ddc:	003ebb06 	br	811228cc <__reset+0xfb1028cc>
81122de0:	103e6c1e 	bne	r2,zero,81122794 <__reset+0xfb102794>
81122de4:	4080004c 	andi	r2,r8,1
81122de8:	103e6a26 	beq	r2,zero,81122794 <__reset+0xfb102794>
81122dec:	003e6606 	br	81122788 <__reset+0xfb102788>
81122df0:	d8c00317 	ldw	r3,12(sp)
81122df4:	00800084 	movi	r2,2
81122df8:	10c02916 	blt	r2,r3,81122ea0 <_dtoa_r+0x1684>
81122dfc:	d9000c17 	ldw	r4,48(sp)
81122e00:	003e8806 	br	81122824 <__reset+0xfb102824>
81122e04:	04000084 	movi	r16,2
81122e08:	003b9d06 	br	81121c80 <__reset+0xfb101c80>
81122e0c:	d9001317 	ldw	r4,76(sp)
81122e10:	d9000515 	stw	r4,20(sp)
81122e14:	003cd606 	br	81122170 <__reset+0xfb102170>
81122e18:	d8801317 	ldw	r2,76(sp)
81122e1c:	d8800515 	stw	r2,20(sp)
81122e20:	003c2a06 	br	81121ecc <__reset+0xfb101ecc>
81122e24:	d9800317 	ldw	r6,12(sp)
81122e28:	00800084 	movi	r2,2
81122e2c:	11801516 	blt	r2,r6,81122e84 <_dtoa_r+0x1668>
81122e30:	d9c00c17 	ldw	r7,48(sp)
81122e34:	d9c00615 	stw	r7,24(sp)
81122e38:	003df706 	br	81122618 <__reset+0xfb102618>
81122e3c:	193d3926 	beq	r3,r4,81122324 <__reset+0xfb102324>
81122e40:	00c00f04 	movi	r3,60
81122e44:	1885c83a 	sub	r2,r3,r2
81122e48:	003ddf06 	br	811225c8 <__reset+0xfb1025c8>
81122e4c:	e009883a 	mov	r4,fp
81122e50:	e0001115 	stw	zero,68(fp)
81122e54:	000b883a 	mov	r5,zero
81122e58:	112519c0 	call	8112519c <_Balloc>
81122e5c:	d8800715 	stw	r2,28(sp)
81122e60:	d8c00717 	ldw	r3,28(sp)
81122e64:	00bfffc4 	movi	r2,-1
81122e68:	01000044 	movi	r4,1
81122e6c:	d8800c15 	stw	r2,48(sp)
81122e70:	e0c01015 	stw	r3,64(fp)
81122e74:	d9000b15 	stw	r4,44(sp)
81122e78:	d8800615 	stw	r2,24(sp)
81122e7c:	d8002215 	stw	zero,136(sp)
81122e80:	003c4106 	br	81121f88 <__reset+0xfb101f88>
81122e84:	d8c00c17 	ldw	r3,48(sp)
81122e88:	d8c00615 	stw	r3,24(sp)
81122e8c:	003e7006 	br	81122850 <__reset+0xfb102850>
81122e90:	04400044 	movi	r17,1
81122e94:	003b2006 	br	81121b18 <__reset+0xfb101b18>
81122e98:	000b883a 	mov	r5,zero
81122e9c:	003b3d06 	br	81121b94 <__reset+0xfb101b94>
81122ea0:	d8800c17 	ldw	r2,48(sp)
81122ea4:	d8800615 	stw	r2,24(sp)
81122ea8:	003e6906 	br	81122850 <__reset+0xfb102850>

81122eac <__sflush_r>:
81122eac:	defffb04 	addi	sp,sp,-20
81122eb0:	de00012e 	bgeu	sp,et,81122eb8 <__sflush_r+0xc>
81122eb4:	003b68fa 	trap	3
81122eb8:	2880030b 	ldhu	r2,12(r5)
81122ebc:	dcc00315 	stw	r19,12(sp)
81122ec0:	dc400115 	stw	r17,4(sp)
81122ec4:	dfc00415 	stw	ra,16(sp)
81122ec8:	dc800215 	stw	r18,8(sp)
81122ecc:	dc000015 	stw	r16,0(sp)
81122ed0:	10c0020c 	andi	r3,r2,8
81122ed4:	2823883a 	mov	r17,r5
81122ed8:	2027883a 	mov	r19,r4
81122edc:	1800311e 	bne	r3,zero,81122fa4 <__sflush_r+0xf8>
81122ee0:	28c00117 	ldw	r3,4(r5)
81122ee4:	10820014 	ori	r2,r2,2048
81122ee8:	2880030d 	sth	r2,12(r5)
81122eec:	00c04b0e 	bge	zero,r3,8112301c <__sflush_r+0x170>
81122ef0:	8a000a17 	ldw	r8,40(r17)
81122ef4:	40002326 	beq	r8,zero,81122f84 <__sflush_r+0xd8>
81122ef8:	9c000017 	ldw	r16,0(r19)
81122efc:	10c4000c 	andi	r3,r2,4096
81122f00:	98000015 	stw	zero,0(r19)
81122f04:	18004826 	beq	r3,zero,81123028 <__sflush_r+0x17c>
81122f08:	89801417 	ldw	r6,80(r17)
81122f0c:	10c0010c 	andi	r3,r2,4
81122f10:	18000626 	beq	r3,zero,81122f2c <__sflush_r+0x80>
81122f14:	88c00117 	ldw	r3,4(r17)
81122f18:	88800c17 	ldw	r2,48(r17)
81122f1c:	30cdc83a 	sub	r6,r6,r3
81122f20:	10000226 	beq	r2,zero,81122f2c <__sflush_r+0x80>
81122f24:	88800f17 	ldw	r2,60(r17)
81122f28:	308dc83a 	sub	r6,r6,r2
81122f2c:	89400717 	ldw	r5,28(r17)
81122f30:	000f883a 	mov	r7,zero
81122f34:	9809883a 	mov	r4,r19
81122f38:	403ee83a 	callr	r8
81122f3c:	00ffffc4 	movi	r3,-1
81122f40:	10c04426 	beq	r2,r3,81123054 <__sflush_r+0x1a8>
81122f44:	88c0030b 	ldhu	r3,12(r17)
81122f48:	89000417 	ldw	r4,16(r17)
81122f4c:	88000115 	stw	zero,4(r17)
81122f50:	197dffcc 	andi	r5,r3,63487
81122f54:	8940030d 	sth	r5,12(r17)
81122f58:	89000015 	stw	r4,0(r17)
81122f5c:	18c4000c 	andi	r3,r3,4096
81122f60:	18002c1e 	bne	r3,zero,81123014 <__sflush_r+0x168>
81122f64:	89400c17 	ldw	r5,48(r17)
81122f68:	9c000015 	stw	r16,0(r19)
81122f6c:	28000526 	beq	r5,zero,81122f84 <__sflush_r+0xd8>
81122f70:	88801004 	addi	r2,r17,64
81122f74:	28800226 	beq	r5,r2,81122f80 <__sflush_r+0xd4>
81122f78:	9809883a 	mov	r4,r19
81122f7c:	11238b80 	call	811238b8 <_free_r>
81122f80:	88000c15 	stw	zero,48(r17)
81122f84:	0005883a 	mov	r2,zero
81122f88:	dfc00417 	ldw	ra,16(sp)
81122f8c:	dcc00317 	ldw	r19,12(sp)
81122f90:	dc800217 	ldw	r18,8(sp)
81122f94:	dc400117 	ldw	r17,4(sp)
81122f98:	dc000017 	ldw	r16,0(sp)
81122f9c:	dec00504 	addi	sp,sp,20
81122fa0:	f800283a 	ret
81122fa4:	2c800417 	ldw	r18,16(r5)
81122fa8:	903ff626 	beq	r18,zero,81122f84 <__reset+0xfb102f84>
81122fac:	2c000017 	ldw	r16,0(r5)
81122fb0:	108000cc 	andi	r2,r2,3
81122fb4:	2c800015 	stw	r18,0(r5)
81122fb8:	84a1c83a 	sub	r16,r16,r18
81122fbc:	1000131e 	bne	r2,zero,8112300c <__sflush_r+0x160>
81122fc0:	28800517 	ldw	r2,20(r5)
81122fc4:	88800215 	stw	r2,8(r17)
81122fc8:	04000316 	blt	zero,r16,81122fd8 <__sflush_r+0x12c>
81122fcc:	003fed06 	br	81122f84 <__reset+0xfb102f84>
81122fd0:	90a5883a 	add	r18,r18,r2
81122fd4:	043feb0e 	bge	zero,r16,81122f84 <__reset+0xfb102f84>
81122fd8:	88800917 	ldw	r2,36(r17)
81122fdc:	89400717 	ldw	r5,28(r17)
81122fe0:	800f883a 	mov	r7,r16
81122fe4:	900d883a 	mov	r6,r18
81122fe8:	9809883a 	mov	r4,r19
81122fec:	103ee83a 	callr	r2
81122ff0:	80a1c83a 	sub	r16,r16,r2
81122ff4:	00bff616 	blt	zero,r2,81122fd0 <__reset+0xfb102fd0>
81122ff8:	88c0030b 	ldhu	r3,12(r17)
81122ffc:	00bfffc4 	movi	r2,-1
81123000:	18c01014 	ori	r3,r3,64
81123004:	88c0030d 	sth	r3,12(r17)
81123008:	003fdf06 	br	81122f88 <__reset+0xfb102f88>
8112300c:	0005883a 	mov	r2,zero
81123010:	003fec06 	br	81122fc4 <__reset+0xfb102fc4>
81123014:	88801415 	stw	r2,80(r17)
81123018:	003fd206 	br	81122f64 <__reset+0xfb102f64>
8112301c:	28c00f17 	ldw	r3,60(r5)
81123020:	00ffb316 	blt	zero,r3,81122ef0 <__reset+0xfb102ef0>
81123024:	003fd706 	br	81122f84 <__reset+0xfb102f84>
81123028:	89400717 	ldw	r5,28(r17)
8112302c:	000d883a 	mov	r6,zero
81123030:	01c00044 	movi	r7,1
81123034:	9809883a 	mov	r4,r19
81123038:	403ee83a 	callr	r8
8112303c:	100d883a 	mov	r6,r2
81123040:	00bfffc4 	movi	r2,-1
81123044:	30801426 	beq	r6,r2,81123098 <__sflush_r+0x1ec>
81123048:	8880030b 	ldhu	r2,12(r17)
8112304c:	8a000a17 	ldw	r8,40(r17)
81123050:	003fae06 	br	81122f0c <__reset+0xfb102f0c>
81123054:	98c00017 	ldw	r3,0(r19)
81123058:	183fba26 	beq	r3,zero,81122f44 <__reset+0xfb102f44>
8112305c:	01000744 	movi	r4,29
81123060:	19000626 	beq	r3,r4,8112307c <__sflush_r+0x1d0>
81123064:	01000584 	movi	r4,22
81123068:	19000426 	beq	r3,r4,8112307c <__sflush_r+0x1d0>
8112306c:	88c0030b 	ldhu	r3,12(r17)
81123070:	18c01014 	ori	r3,r3,64
81123074:	88c0030d 	sth	r3,12(r17)
81123078:	003fc306 	br	81122f88 <__reset+0xfb102f88>
8112307c:	8880030b 	ldhu	r2,12(r17)
81123080:	88c00417 	ldw	r3,16(r17)
81123084:	88000115 	stw	zero,4(r17)
81123088:	10bdffcc 	andi	r2,r2,63487
8112308c:	8880030d 	sth	r2,12(r17)
81123090:	88c00015 	stw	r3,0(r17)
81123094:	003fb306 	br	81122f64 <__reset+0xfb102f64>
81123098:	98800017 	ldw	r2,0(r19)
8112309c:	103fea26 	beq	r2,zero,81123048 <__reset+0xfb103048>
811230a0:	00c00744 	movi	r3,29
811230a4:	10c00226 	beq	r2,r3,811230b0 <__sflush_r+0x204>
811230a8:	00c00584 	movi	r3,22
811230ac:	10c0031e 	bne	r2,r3,811230bc <__sflush_r+0x210>
811230b0:	9c000015 	stw	r16,0(r19)
811230b4:	0005883a 	mov	r2,zero
811230b8:	003fb306 	br	81122f88 <__reset+0xfb102f88>
811230bc:	88c0030b 	ldhu	r3,12(r17)
811230c0:	3005883a 	mov	r2,r6
811230c4:	18c01014 	ori	r3,r3,64
811230c8:	88c0030d 	sth	r3,12(r17)
811230cc:	003fae06 	br	81122f88 <__reset+0xfb102f88>

811230d0 <_fflush_r>:
811230d0:	defffd04 	addi	sp,sp,-12
811230d4:	de00012e 	bgeu	sp,et,811230dc <_fflush_r+0xc>
811230d8:	003b68fa 	trap	3
811230dc:	dc000115 	stw	r16,4(sp)
811230e0:	dfc00215 	stw	ra,8(sp)
811230e4:	2021883a 	mov	r16,r4
811230e8:	20000226 	beq	r4,zero,811230f4 <_fflush_r+0x24>
811230ec:	20800e17 	ldw	r2,56(r4)
811230f0:	10000c26 	beq	r2,zero,81123124 <_fflush_r+0x54>
811230f4:	2880030f 	ldh	r2,12(r5)
811230f8:	1000051e 	bne	r2,zero,81123110 <_fflush_r+0x40>
811230fc:	0005883a 	mov	r2,zero
81123100:	dfc00217 	ldw	ra,8(sp)
81123104:	dc000117 	ldw	r16,4(sp)
81123108:	dec00304 	addi	sp,sp,12
8112310c:	f800283a 	ret
81123110:	8009883a 	mov	r4,r16
81123114:	dfc00217 	ldw	ra,8(sp)
81123118:	dc000117 	ldw	r16,4(sp)
8112311c:	dec00304 	addi	sp,sp,12
81123120:	1122eac1 	jmpi	81122eac <__sflush_r>
81123124:	d9400015 	stw	r5,0(sp)
81123128:	11234cc0 	call	811234cc <__sinit>
8112312c:	d9400017 	ldw	r5,0(sp)
81123130:	003ff006 	br	811230f4 <__reset+0xfb1030f4>

81123134 <fflush>:
81123134:	20000526 	beq	r4,zero,8112314c <fflush+0x18>
81123138:	00a04534 	movhi	r2,33044
8112313c:	109e0f04 	addi	r2,r2,30780
81123140:	200b883a 	mov	r5,r4
81123144:	11000017 	ldw	r4,0(r2)
81123148:	11230d01 	jmpi	811230d0 <_fflush_r>
8112314c:	00a04534 	movhi	r2,33044
81123150:	109e0e04 	addi	r2,r2,30776
81123154:	11000017 	ldw	r4,0(r2)
81123158:	016044b4 	movhi	r5,33042
8112315c:	294c3404 	addi	r5,r5,12496
81123160:	11241601 	jmpi	81124160 <_fwalk_reent>

81123164 <__fp_unlock>:
81123164:	0005883a 	mov	r2,zero
81123168:	f800283a 	ret

8112316c <_cleanup_r>:
8112316c:	016044f4 	movhi	r5,33043
81123170:	296e2b04 	addi	r5,r5,-18260
81123174:	11241601 	jmpi	81124160 <_fwalk_reent>

81123178 <__sinit.part.1>:
81123178:	defff704 	addi	sp,sp,-36
8112317c:	00e044b4 	movhi	r3,33042
81123180:	de00012e 	bgeu	sp,et,81123188 <__sinit.part.1+0x10>
81123184:	003b68fa 	trap	3
81123188:	18cc5b04 	addi	r3,r3,12652
8112318c:	dfc00815 	stw	ra,32(sp)
81123190:	ddc00715 	stw	r23,28(sp)
81123194:	dd800615 	stw	r22,24(sp)
81123198:	dd400515 	stw	r21,20(sp)
8112319c:	dd000415 	stw	r20,16(sp)
811231a0:	dcc00315 	stw	r19,12(sp)
811231a4:	dc800215 	stw	r18,8(sp)
811231a8:	dc400115 	stw	r17,4(sp)
811231ac:	dc000015 	stw	r16,0(sp)
811231b0:	24000117 	ldw	r16,4(r4)
811231b4:	20c00f15 	stw	r3,60(r4)
811231b8:	2080bb04 	addi	r2,r4,748
811231bc:	00c000c4 	movi	r3,3
811231c0:	20c0b915 	stw	r3,740(r4)
811231c4:	2080ba15 	stw	r2,744(r4)
811231c8:	2000b815 	stw	zero,736(r4)
811231cc:	05c00204 	movi	r23,8
811231d0:	00800104 	movi	r2,4
811231d4:	2025883a 	mov	r18,r4
811231d8:	b80d883a 	mov	r6,r23
811231dc:	81001704 	addi	r4,r16,92
811231e0:	000b883a 	mov	r5,zero
811231e4:	80000015 	stw	zero,0(r16)
811231e8:	80000115 	stw	zero,4(r16)
811231ec:	80000215 	stw	zero,8(r16)
811231f0:	8080030d 	sth	r2,12(r16)
811231f4:	80001915 	stw	zero,100(r16)
811231f8:	8000038d 	sth	zero,14(r16)
811231fc:	80000415 	stw	zero,16(r16)
81123200:	80000515 	stw	zero,20(r16)
81123204:	80000615 	stw	zero,24(r16)
81123208:	111acfc0 	call	8111acfc <memset>
8112320c:	05a044b4 	movhi	r22,33042
81123210:	94400217 	ldw	r17,8(r18)
81123214:	056044b4 	movhi	r21,33042
81123218:	052044b4 	movhi	r20,33042
8112321c:	04e044b4 	movhi	r19,33042
81123220:	b59ac104 	addi	r22,r22,27396
81123224:	ad5ada04 	addi	r21,r21,27496
81123228:	a51afb04 	addi	r20,r20,27628
8112322c:	9cdb1404 	addi	r19,r19,27728
81123230:	85800815 	stw	r22,32(r16)
81123234:	85400915 	stw	r21,36(r16)
81123238:	85000a15 	stw	r20,40(r16)
8112323c:	84c00b15 	stw	r19,44(r16)
81123240:	84000715 	stw	r16,28(r16)
81123244:	00800284 	movi	r2,10
81123248:	8880030d 	sth	r2,12(r17)
8112324c:	00800044 	movi	r2,1
81123250:	b80d883a 	mov	r6,r23
81123254:	89001704 	addi	r4,r17,92
81123258:	000b883a 	mov	r5,zero
8112325c:	88000015 	stw	zero,0(r17)
81123260:	88000115 	stw	zero,4(r17)
81123264:	88000215 	stw	zero,8(r17)
81123268:	88001915 	stw	zero,100(r17)
8112326c:	8880038d 	sth	r2,14(r17)
81123270:	88000415 	stw	zero,16(r17)
81123274:	88000515 	stw	zero,20(r17)
81123278:	88000615 	stw	zero,24(r17)
8112327c:	111acfc0 	call	8111acfc <memset>
81123280:	94000317 	ldw	r16,12(r18)
81123284:	00800484 	movi	r2,18
81123288:	8c400715 	stw	r17,28(r17)
8112328c:	8d800815 	stw	r22,32(r17)
81123290:	8d400915 	stw	r21,36(r17)
81123294:	8d000a15 	stw	r20,40(r17)
81123298:	8cc00b15 	stw	r19,44(r17)
8112329c:	8080030d 	sth	r2,12(r16)
811232a0:	00800084 	movi	r2,2
811232a4:	80000015 	stw	zero,0(r16)
811232a8:	80000115 	stw	zero,4(r16)
811232ac:	80000215 	stw	zero,8(r16)
811232b0:	80001915 	stw	zero,100(r16)
811232b4:	8080038d 	sth	r2,14(r16)
811232b8:	80000415 	stw	zero,16(r16)
811232bc:	80000515 	stw	zero,20(r16)
811232c0:	80000615 	stw	zero,24(r16)
811232c4:	b80d883a 	mov	r6,r23
811232c8:	000b883a 	mov	r5,zero
811232cc:	81001704 	addi	r4,r16,92
811232d0:	111acfc0 	call	8111acfc <memset>
811232d4:	00800044 	movi	r2,1
811232d8:	84000715 	stw	r16,28(r16)
811232dc:	85800815 	stw	r22,32(r16)
811232e0:	85400915 	stw	r21,36(r16)
811232e4:	85000a15 	stw	r20,40(r16)
811232e8:	84c00b15 	stw	r19,44(r16)
811232ec:	90800e15 	stw	r2,56(r18)
811232f0:	dfc00817 	ldw	ra,32(sp)
811232f4:	ddc00717 	ldw	r23,28(sp)
811232f8:	dd800617 	ldw	r22,24(sp)
811232fc:	dd400517 	ldw	r21,20(sp)
81123300:	dd000417 	ldw	r20,16(sp)
81123304:	dcc00317 	ldw	r19,12(sp)
81123308:	dc800217 	ldw	r18,8(sp)
8112330c:	dc400117 	ldw	r17,4(sp)
81123310:	dc000017 	ldw	r16,0(sp)
81123314:	dec00904 	addi	sp,sp,36
81123318:	f800283a 	ret

8112331c <__fp_lock>:
8112331c:	0005883a 	mov	r2,zero
81123320:	f800283a 	ret

81123324 <__sfmoreglue>:
81123324:	defffc04 	addi	sp,sp,-16
81123328:	de00012e 	bgeu	sp,et,81123330 <__sfmoreglue+0xc>
8112332c:	003b68fa 	trap	3
81123330:	dc400115 	stw	r17,4(sp)
81123334:	2c7fffc4 	addi	r17,r5,-1
81123338:	8c401a24 	muli	r17,r17,104
8112333c:	dc800215 	stw	r18,8(sp)
81123340:	2825883a 	mov	r18,r5
81123344:	89401d04 	addi	r5,r17,116
81123348:	dc000015 	stw	r16,0(sp)
8112334c:	dfc00315 	stw	ra,12(sp)
81123350:	11245040 	call	81124504 <_malloc_r>
81123354:	1021883a 	mov	r16,r2
81123358:	10000726 	beq	r2,zero,81123378 <__sfmoreglue+0x54>
8112335c:	11000304 	addi	r4,r2,12
81123360:	10000015 	stw	zero,0(r2)
81123364:	14800115 	stw	r18,4(r2)
81123368:	11000215 	stw	r4,8(r2)
8112336c:	89801a04 	addi	r6,r17,104
81123370:	000b883a 	mov	r5,zero
81123374:	111acfc0 	call	8111acfc <memset>
81123378:	8005883a 	mov	r2,r16
8112337c:	dfc00317 	ldw	ra,12(sp)
81123380:	dc800217 	ldw	r18,8(sp)
81123384:	dc400117 	ldw	r17,4(sp)
81123388:	dc000017 	ldw	r16,0(sp)
8112338c:	dec00404 	addi	sp,sp,16
81123390:	f800283a 	ret

81123394 <__sfp>:
81123394:	defffb04 	addi	sp,sp,-20
81123398:	de00012e 	bgeu	sp,et,811233a0 <__sfp+0xc>
8112339c:	003b68fa 	trap	3
811233a0:	dc000015 	stw	r16,0(sp)
811233a4:	04204534 	movhi	r16,33044
811233a8:	841e0e04 	addi	r16,r16,30776
811233ac:	dcc00315 	stw	r19,12(sp)
811233b0:	2027883a 	mov	r19,r4
811233b4:	81000017 	ldw	r4,0(r16)
811233b8:	dfc00415 	stw	ra,16(sp)
811233bc:	dc800215 	stw	r18,8(sp)
811233c0:	20800e17 	ldw	r2,56(r4)
811233c4:	dc400115 	stw	r17,4(sp)
811233c8:	1000021e 	bne	r2,zero,811233d4 <__sfp+0x40>
811233cc:	11231780 	call	81123178 <__sinit.part.1>
811233d0:	81000017 	ldw	r4,0(r16)
811233d4:	2480b804 	addi	r18,r4,736
811233d8:	047fffc4 	movi	r17,-1
811233dc:	91000117 	ldw	r4,4(r18)
811233e0:	94000217 	ldw	r16,8(r18)
811233e4:	213fffc4 	addi	r4,r4,-1
811233e8:	20000a16 	blt	r4,zero,81123414 <__sfp+0x80>
811233ec:	8080030f 	ldh	r2,12(r16)
811233f0:	10000c26 	beq	r2,zero,81123424 <__sfp+0x90>
811233f4:	80c01d04 	addi	r3,r16,116
811233f8:	00000206 	br	81123404 <__sfp+0x70>
811233fc:	18bfe60f 	ldh	r2,-104(r3)
81123400:	10000826 	beq	r2,zero,81123424 <__sfp+0x90>
81123404:	213fffc4 	addi	r4,r4,-1
81123408:	1c3ffd04 	addi	r16,r3,-12
8112340c:	18c01a04 	addi	r3,r3,104
81123410:	247ffa1e 	bne	r4,r17,811233fc <__reset+0xfb1033fc>
81123414:	90800017 	ldw	r2,0(r18)
81123418:	10001d26 	beq	r2,zero,81123490 <__sfp+0xfc>
8112341c:	1025883a 	mov	r18,r2
81123420:	003fee06 	br	811233dc <__reset+0xfb1033dc>
81123424:	00bfffc4 	movi	r2,-1
81123428:	8080038d 	sth	r2,14(r16)
8112342c:	00800044 	movi	r2,1
81123430:	8080030d 	sth	r2,12(r16)
81123434:	80001915 	stw	zero,100(r16)
81123438:	80000015 	stw	zero,0(r16)
8112343c:	80000215 	stw	zero,8(r16)
81123440:	80000115 	stw	zero,4(r16)
81123444:	80000415 	stw	zero,16(r16)
81123448:	80000515 	stw	zero,20(r16)
8112344c:	80000615 	stw	zero,24(r16)
81123450:	01800204 	movi	r6,8
81123454:	000b883a 	mov	r5,zero
81123458:	81001704 	addi	r4,r16,92
8112345c:	111acfc0 	call	8111acfc <memset>
81123460:	8005883a 	mov	r2,r16
81123464:	80000c15 	stw	zero,48(r16)
81123468:	80000d15 	stw	zero,52(r16)
8112346c:	80001115 	stw	zero,68(r16)
81123470:	80001215 	stw	zero,72(r16)
81123474:	dfc00417 	ldw	ra,16(sp)
81123478:	dcc00317 	ldw	r19,12(sp)
8112347c:	dc800217 	ldw	r18,8(sp)
81123480:	dc400117 	ldw	r17,4(sp)
81123484:	dc000017 	ldw	r16,0(sp)
81123488:	dec00504 	addi	sp,sp,20
8112348c:	f800283a 	ret
81123490:	01400104 	movi	r5,4
81123494:	9809883a 	mov	r4,r19
81123498:	11233240 	call	81123324 <__sfmoreglue>
8112349c:	90800015 	stw	r2,0(r18)
811234a0:	103fde1e 	bne	r2,zero,8112341c <__reset+0xfb10341c>
811234a4:	00800304 	movi	r2,12
811234a8:	98800015 	stw	r2,0(r19)
811234ac:	0005883a 	mov	r2,zero
811234b0:	003ff006 	br	81123474 <__reset+0xfb103474>

811234b4 <_cleanup>:
811234b4:	00a04534 	movhi	r2,33044
811234b8:	109e0e04 	addi	r2,r2,30776
811234bc:	11000017 	ldw	r4,0(r2)
811234c0:	016044f4 	movhi	r5,33043
811234c4:	296e2b04 	addi	r5,r5,-18260
811234c8:	11241601 	jmpi	81124160 <_fwalk_reent>

811234cc <__sinit>:
811234cc:	20800e17 	ldw	r2,56(r4)
811234d0:	10000126 	beq	r2,zero,811234d8 <__sinit+0xc>
811234d4:	f800283a 	ret
811234d8:	11231781 	jmpi	81123178 <__sinit.part.1>

811234dc <__sfp_lock_acquire>:
811234dc:	f800283a 	ret

811234e0 <__sfp_lock_release>:
811234e0:	f800283a 	ret

811234e4 <__sinit_lock_acquire>:
811234e4:	f800283a 	ret

811234e8 <__sinit_lock_release>:
811234e8:	f800283a 	ret

811234ec <__fp_lock_all>:
811234ec:	00a04534 	movhi	r2,33044
811234f0:	109e0f04 	addi	r2,r2,30780
811234f4:	11000017 	ldw	r4,0(r2)
811234f8:	016044b4 	movhi	r5,33042
811234fc:	294cc704 	addi	r5,r5,13084
81123500:	11240941 	jmpi	81124094 <_fwalk>

81123504 <__fp_unlock_all>:
81123504:	00a04534 	movhi	r2,33044
81123508:	109e0f04 	addi	r2,r2,30780
8112350c:	11000017 	ldw	r4,0(r2)
81123510:	016044b4 	movhi	r5,33042
81123514:	294c5904 	addi	r5,r5,12644
81123518:	11240941 	jmpi	81124094 <_fwalk>

8112351c <_fread_r>:
8112351c:	defff404 	addi	sp,sp,-48
81123520:	de00012e 	bgeu	sp,et,81123528 <_fread_r+0xc>
81123524:	003b68fa 	trap	3
81123528:	dd800815 	stw	r22,32(sp)
8112352c:	39ad383a 	mul	r22,r7,r6
81123530:	dc000215 	stw	r16,8(sp)
81123534:	dfc00b15 	stw	ra,44(sp)
81123538:	df000a15 	stw	fp,40(sp)
8112353c:	ddc00915 	stw	r23,36(sp)
81123540:	dd400715 	stw	r21,28(sp)
81123544:	dd000615 	stw	r20,24(sp)
81123548:	dcc00515 	stw	r19,20(sp)
8112354c:	dc800415 	stw	r18,16(sp)
81123550:	dc400315 	stw	r17,12(sp)
81123554:	dc000c17 	ldw	r16,48(sp)
81123558:	b0003b26 	beq	r22,zero,81123648 <_fread_r+0x12c>
8112355c:	302f883a 	mov	r23,r6
81123560:	382b883a 	mov	r21,r7
81123564:	2029883a 	mov	r20,r4
81123568:	2827883a 	mov	r19,r5
8112356c:	20000226 	beq	r4,zero,81123578 <_fread_r+0x5c>
81123570:	20800e17 	ldw	r2,56(r4)
81123574:	10006e26 	beq	r2,zero,81123730 <_fread_r+0x214>
81123578:	8080030b 	ldhu	r2,12(r16)
8112357c:	10c8000c 	andi	r3,r2,8192
81123580:	1800061e 	bne	r3,zero,8112359c <_fread_r+0x80>
81123584:	81001917 	ldw	r4,100(r16)
81123588:	00f7ffc4 	movi	r3,-8193
8112358c:	10880014 	ori	r2,r2,8192
81123590:	20c6703a 	and	r3,r4,r3
81123594:	8080030d 	sth	r2,12(r16)
81123598:	80c01915 	stw	r3,100(r16)
8112359c:	84400117 	ldw	r17,4(r16)
811235a0:	88005f16 	blt	r17,zero,81123720 <_fread_r+0x204>
811235a4:	8809883a 	mov	r4,r17
811235a8:	1080008c 	andi	r2,r2,2
811235ac:	1000281e 	bne	r2,zero,81123650 <_fread_r+0x134>
811235b0:	b025883a 	mov	r18,r22
811235b4:	00000b06 	br	811235e4 <_fread_r+0xc8>
811235b8:	111abac0 	call	8111abac <memcpy>
811235bc:	80800017 	ldw	r2,0(r16)
811235c0:	9c67883a 	add	r19,r19,r17
811235c4:	9465c83a 	sub	r18,r18,r17
811235c8:	1463883a 	add	r17,r2,r17
811235cc:	800b883a 	mov	r5,r16
811235d0:	a009883a 	mov	r4,r20
811235d4:	84400015 	stw	r17,0(r16)
811235d8:	11267800 	call	81126780 <__srefill_r>
811235dc:	10004c1e 	bne	r2,zero,81123710 <_fread_r+0x1f4>
811235e0:	84400117 	ldw	r17,4(r16)
811235e4:	880d883a 	mov	r6,r17
811235e8:	9809883a 	mov	r4,r19
811235ec:	81400017 	ldw	r5,0(r16)
811235f0:	8cbff136 	bltu	r17,r18,811235b8 <__reset+0xfb1035b8>
811235f4:	900d883a 	mov	r6,r18
811235f8:	111abac0 	call	8111abac <memcpy>
811235fc:	80c00117 	ldw	r3,4(r16)
81123600:	81000017 	ldw	r4,0(r16)
81123604:	a805883a 	mov	r2,r21
81123608:	1c87c83a 	sub	r3,r3,r18
8112360c:	24a5883a 	add	r18,r4,r18
81123610:	80c00115 	stw	r3,4(r16)
81123614:	84800015 	stw	r18,0(r16)
81123618:	dfc00b17 	ldw	ra,44(sp)
8112361c:	df000a17 	ldw	fp,40(sp)
81123620:	ddc00917 	ldw	r23,36(sp)
81123624:	dd800817 	ldw	r22,32(sp)
81123628:	dd400717 	ldw	r21,28(sp)
8112362c:	dd000617 	ldw	r20,24(sp)
81123630:	dcc00517 	ldw	r19,20(sp)
81123634:	dc800417 	ldw	r18,16(sp)
81123638:	dc400317 	ldw	r17,12(sp)
8112363c:	dc000217 	ldw	r16,8(sp)
81123640:	dec00c04 	addi	sp,sp,48
81123644:	f800283a 	ret
81123648:	0005883a 	mov	r2,zero
8112364c:	003ff206 	br	81123618 <__reset+0xfb103618>
81123650:	b007883a 	mov	r3,r22
81123654:	2580012e 	bgeu	r4,r22,8112365c <_fread_r+0x140>
81123658:	2007883a 	mov	r3,r4
8112365c:	81400017 	ldw	r5,0(r16)
81123660:	180d883a 	mov	r6,r3
81123664:	9809883a 	mov	r4,r19
81123668:	d8c00115 	stw	r3,4(sp)
8112366c:	111abac0 	call	8111abac <memcpy>
81123670:	d8c00117 	ldw	r3,4(sp)
81123674:	84400017 	ldw	r17,0(r16)
81123678:	80800117 	ldw	r2,4(r16)
8112367c:	81400c17 	ldw	r5,48(r16)
81123680:	88e3883a 	add	r17,r17,r3
81123684:	10c5c83a 	sub	r2,r2,r3
81123688:	84400015 	stw	r17,0(r16)
8112368c:	80800115 	stw	r2,4(r16)
81123690:	b0e5c83a 	sub	r18,r22,r3
81123694:	28002b26 	beq	r5,zero,81123744 <_fread_r+0x228>
81123698:	90002b26 	beq	r18,zero,81123748 <_fread_r+0x22c>
8112369c:	80801004 	addi	r2,r16,64
811236a0:	28800526 	beq	r5,r2,811236b8 <_fread_r+0x19c>
811236a4:	a009883a 	mov	r4,r20
811236a8:	d8c00115 	stw	r3,4(sp)
811236ac:	11238b80 	call	811238b8 <_free_r>
811236b0:	d8c00117 	ldw	r3,4(sp)
811236b4:	84400017 	ldw	r17,0(r16)
811236b8:	80000c15 	stw	zero,48(r16)
811236bc:	80800517 	ldw	r2,20(r16)
811236c0:	87000417 	ldw	fp,16(r16)
811236c4:	98e7883a 	add	r19,r19,r3
811236c8:	d8800015 	stw	r2,0(sp)
811236cc:	00000106 	br	811236d4 <_fread_r+0x1b8>
811236d0:	90001d26 	beq	r18,zero,81123748 <_fread_r+0x22c>
811236d4:	84c00415 	stw	r19,16(r16)
811236d8:	84800515 	stw	r18,20(r16)
811236dc:	84c00015 	stw	r19,0(r16)
811236e0:	a009883a 	mov	r4,r20
811236e4:	800b883a 	mov	r5,r16
811236e8:	11267800 	call	81126780 <__srefill_r>
811236ec:	d9000017 	ldw	r4,0(sp)
811236f0:	80c00117 	ldw	r3,4(r16)
811236f4:	87000415 	stw	fp,16(r16)
811236f8:	81000515 	stw	r4,20(r16)
811236fc:	84400015 	stw	r17,0(r16)
81123700:	80000115 	stw	zero,4(r16)
81123704:	90e5c83a 	sub	r18,r18,r3
81123708:	98e7883a 	add	r19,r19,r3
8112370c:	103ff026 	beq	r2,zero,811236d0 <__reset+0xfb1036d0>
81123710:	b80b883a 	mov	r5,r23
81123714:	b489c83a 	sub	r4,r22,r18
81123718:	112d8e40 	call	8112d8e4 <__udivsi3>
8112371c:	003fbe06 	br	81123618 <__reset+0xfb103618>
81123720:	80000115 	stw	zero,4(r16)
81123724:	0009883a 	mov	r4,zero
81123728:	0023883a 	mov	r17,zero
8112372c:	003f9e06 	br	811235a8 <__reset+0xfb1035a8>
81123730:	11234cc0 	call	811234cc <__sinit>
81123734:	8080030b 	ldhu	r2,12(r16)
81123738:	10c8000c 	andi	r3,r2,8192
8112373c:	183f971e 	bne	r3,zero,8112359c <__reset+0xfb10359c>
81123740:	003f9006 	br	81123584 <__reset+0xfb103584>
81123744:	903fdd1e 	bne	r18,zero,811236bc <__reset+0xfb1036bc>
81123748:	a805883a 	mov	r2,r21
8112374c:	003fb206 	br	81123618 <__reset+0xfb103618>

81123750 <fread>:
81123750:	defffe04 	addi	sp,sp,-8
81123754:	00a04534 	movhi	r2,33044
81123758:	de00012e 	bgeu	sp,et,81123760 <fread+0x10>
8112375c:	003b68fa 	trap	3
81123760:	109e0f04 	addi	r2,r2,30780
81123764:	d9c00015 	stw	r7,0(sp)
81123768:	300f883a 	mov	r7,r6
8112376c:	280d883a 	mov	r6,r5
81123770:	200b883a 	mov	r5,r4
81123774:	11000017 	ldw	r4,0(r2)
81123778:	dfc00115 	stw	ra,4(sp)
8112377c:	112351c0 	call	8112351c <_fread_r>
81123780:	dfc00117 	ldw	ra,4(sp)
81123784:	dec00204 	addi	sp,sp,8
81123788:	f800283a 	ret

8112378c <_malloc_trim_r>:
8112378c:	defffb04 	addi	sp,sp,-20
81123790:	de00012e 	bgeu	sp,et,81123798 <_malloc_trim_r+0xc>
81123794:	003b68fa 	trap	3
81123798:	dcc00315 	stw	r19,12(sp)
8112379c:	04e04534 	movhi	r19,33044
811237a0:	dc800215 	stw	r18,8(sp)
811237a4:	dc400115 	stw	r17,4(sp)
811237a8:	dc000015 	stw	r16,0(sp)
811237ac:	dfc00415 	stw	ra,16(sp)
811237b0:	2821883a 	mov	r16,r5
811237b4:	9cd7eb04 	addi	r19,r19,24492
811237b8:	2025883a 	mov	r18,r4
811237bc:	1130b340 	call	81130b34 <__malloc_lock>
811237c0:	98800217 	ldw	r2,8(r19)
811237c4:	14400117 	ldw	r17,4(r2)
811237c8:	00bfff04 	movi	r2,-4
811237cc:	88a2703a 	and	r17,r17,r2
811237d0:	8c21c83a 	sub	r16,r17,r16
811237d4:	8403fbc4 	addi	r16,r16,4079
811237d8:	8020d33a 	srli	r16,r16,12
811237dc:	0083ffc4 	movi	r2,4095
811237e0:	843fffc4 	addi	r16,r16,-1
811237e4:	8020933a 	slli	r16,r16,12
811237e8:	1400060e 	bge	r2,r16,81123804 <_malloc_trim_r+0x78>
811237ec:	000b883a 	mov	r5,zero
811237f0:	9009883a 	mov	r4,r18
811237f4:	11269d00 	call	811269d0 <_sbrk_r>
811237f8:	98c00217 	ldw	r3,8(r19)
811237fc:	1c47883a 	add	r3,r3,r17
81123800:	10c00a26 	beq	r2,r3,8112382c <_malloc_trim_r+0xa0>
81123804:	9009883a 	mov	r4,r18
81123808:	1130c5c0 	call	81130c5c <__malloc_unlock>
8112380c:	0005883a 	mov	r2,zero
81123810:	dfc00417 	ldw	ra,16(sp)
81123814:	dcc00317 	ldw	r19,12(sp)
81123818:	dc800217 	ldw	r18,8(sp)
8112381c:	dc400117 	ldw	r17,4(sp)
81123820:	dc000017 	ldw	r16,0(sp)
81123824:	dec00504 	addi	sp,sp,20
81123828:	f800283a 	ret
8112382c:	040bc83a 	sub	r5,zero,r16
81123830:	9009883a 	mov	r4,r18
81123834:	11269d00 	call	811269d0 <_sbrk_r>
81123838:	00ffffc4 	movi	r3,-1
8112383c:	10c00d26 	beq	r2,r3,81123874 <_malloc_trim_r+0xe8>
81123840:	00e04534 	movhi	r3,33044
81123844:	18df1104 	addi	r3,r3,31812
81123848:	18800017 	ldw	r2,0(r3)
8112384c:	99000217 	ldw	r4,8(r19)
81123850:	8c23c83a 	sub	r17,r17,r16
81123854:	8c400054 	ori	r17,r17,1
81123858:	1421c83a 	sub	r16,r2,r16
8112385c:	24400115 	stw	r17,4(r4)
81123860:	9009883a 	mov	r4,r18
81123864:	1c000015 	stw	r16,0(r3)
81123868:	1130c5c0 	call	81130c5c <__malloc_unlock>
8112386c:	00800044 	movi	r2,1
81123870:	003fe706 	br	81123810 <__reset+0xfb103810>
81123874:	000b883a 	mov	r5,zero
81123878:	9009883a 	mov	r4,r18
8112387c:	11269d00 	call	811269d0 <_sbrk_r>
81123880:	99000217 	ldw	r4,8(r19)
81123884:	014003c4 	movi	r5,15
81123888:	1107c83a 	sub	r3,r2,r4
8112388c:	28ffdd0e 	bge	r5,r3,81123804 <__reset+0xfb103804>
81123890:	01604534 	movhi	r5,33044
81123894:	295e1104 	addi	r5,r5,30788
81123898:	29400017 	ldw	r5,0(r5)
8112389c:	18c00054 	ori	r3,r3,1
811238a0:	20c00115 	stw	r3,4(r4)
811238a4:	00e04534 	movhi	r3,33044
811238a8:	1145c83a 	sub	r2,r2,r5
811238ac:	18df1104 	addi	r3,r3,31812
811238b0:	18800015 	stw	r2,0(r3)
811238b4:	003fd306 	br	81123804 <__reset+0xfb103804>

811238b8 <_free_r>:
811238b8:	28004326 	beq	r5,zero,811239c8 <_free_r+0x110>
811238bc:	defffd04 	addi	sp,sp,-12
811238c0:	de00012e 	bgeu	sp,et,811238c8 <_free_r+0x10>
811238c4:	003b68fa 	trap	3
811238c8:	dc400115 	stw	r17,4(sp)
811238cc:	dc000015 	stw	r16,0(sp)
811238d0:	2023883a 	mov	r17,r4
811238d4:	2821883a 	mov	r16,r5
811238d8:	dfc00215 	stw	ra,8(sp)
811238dc:	1130b340 	call	81130b34 <__malloc_lock>
811238e0:	81ffff17 	ldw	r7,-4(r16)
811238e4:	00bfff84 	movi	r2,-2
811238e8:	01204534 	movhi	r4,33044
811238ec:	81bffe04 	addi	r6,r16,-8
811238f0:	3884703a 	and	r2,r7,r2
811238f4:	2117eb04 	addi	r4,r4,24492
811238f8:	308b883a 	add	r5,r6,r2
811238fc:	2a400117 	ldw	r9,4(r5)
81123900:	22000217 	ldw	r8,8(r4)
81123904:	00ffff04 	movi	r3,-4
81123908:	48c6703a 	and	r3,r9,r3
8112390c:	2a005726 	beq	r5,r8,81123a6c <_free_r+0x1b4>
81123910:	28c00115 	stw	r3,4(r5)
81123914:	39c0004c 	andi	r7,r7,1
81123918:	3800091e 	bne	r7,zero,81123940 <_free_r+0x88>
8112391c:	823ffe17 	ldw	r8,-8(r16)
81123920:	22400204 	addi	r9,r4,8
81123924:	320dc83a 	sub	r6,r6,r8
81123928:	31c00217 	ldw	r7,8(r6)
8112392c:	1205883a 	add	r2,r2,r8
81123930:	3a406526 	beq	r7,r9,81123ac8 <_free_r+0x210>
81123934:	32000317 	ldw	r8,12(r6)
81123938:	3a000315 	stw	r8,12(r7)
8112393c:	41c00215 	stw	r7,8(r8)
81123940:	28cf883a 	add	r7,r5,r3
81123944:	39c00117 	ldw	r7,4(r7)
81123948:	39c0004c 	andi	r7,r7,1
8112394c:	38003a26 	beq	r7,zero,81123a38 <_free_r+0x180>
81123950:	10c00054 	ori	r3,r2,1
81123954:	30c00115 	stw	r3,4(r6)
81123958:	3087883a 	add	r3,r6,r2
8112395c:	18800015 	stw	r2,0(r3)
81123960:	00c07fc4 	movi	r3,511
81123964:	18801936 	bltu	r3,r2,811239cc <_free_r+0x114>
81123968:	1004d0fa 	srli	r2,r2,3
8112396c:	01c00044 	movi	r7,1
81123970:	21400117 	ldw	r5,4(r4)
81123974:	10c00044 	addi	r3,r2,1
81123978:	18c7883a 	add	r3,r3,r3
8112397c:	1005d0ba 	srai	r2,r2,2
81123980:	18c7883a 	add	r3,r3,r3
81123984:	18c7883a 	add	r3,r3,r3
81123988:	1907883a 	add	r3,r3,r4
8112398c:	3884983a 	sll	r2,r7,r2
81123990:	19c00017 	ldw	r7,0(r3)
81123994:	1a3ffe04 	addi	r8,r3,-8
81123998:	1144b03a 	or	r2,r2,r5
8112399c:	32000315 	stw	r8,12(r6)
811239a0:	31c00215 	stw	r7,8(r6)
811239a4:	20800115 	stw	r2,4(r4)
811239a8:	19800015 	stw	r6,0(r3)
811239ac:	39800315 	stw	r6,12(r7)
811239b0:	8809883a 	mov	r4,r17
811239b4:	dfc00217 	ldw	ra,8(sp)
811239b8:	dc400117 	ldw	r17,4(sp)
811239bc:	dc000017 	ldw	r16,0(sp)
811239c0:	dec00304 	addi	sp,sp,12
811239c4:	1130c5c1 	jmpi	81130c5c <__malloc_unlock>
811239c8:	f800283a 	ret
811239cc:	100ad27a 	srli	r5,r2,9
811239d0:	00c00104 	movi	r3,4
811239d4:	19404a36 	bltu	r3,r5,81123b00 <_free_r+0x248>
811239d8:	100ad1ba 	srli	r5,r2,6
811239dc:	28c00e44 	addi	r3,r5,57
811239e0:	18c7883a 	add	r3,r3,r3
811239e4:	29400e04 	addi	r5,r5,56
811239e8:	18c7883a 	add	r3,r3,r3
811239ec:	18c7883a 	add	r3,r3,r3
811239f0:	1909883a 	add	r4,r3,r4
811239f4:	20c00017 	ldw	r3,0(r4)
811239f8:	01e04534 	movhi	r7,33044
811239fc:	213ffe04 	addi	r4,r4,-8
81123a00:	39d7eb04 	addi	r7,r7,24492
81123a04:	20c04426 	beq	r4,r3,81123b18 <_free_r+0x260>
81123a08:	01ffff04 	movi	r7,-4
81123a0c:	19400117 	ldw	r5,4(r3)
81123a10:	29ca703a 	and	r5,r5,r7
81123a14:	1140022e 	bgeu	r2,r5,81123a20 <_free_r+0x168>
81123a18:	18c00217 	ldw	r3,8(r3)
81123a1c:	20fffb1e 	bne	r4,r3,81123a0c <__reset+0xfb103a0c>
81123a20:	19000317 	ldw	r4,12(r3)
81123a24:	31000315 	stw	r4,12(r6)
81123a28:	30c00215 	stw	r3,8(r6)
81123a2c:	21800215 	stw	r6,8(r4)
81123a30:	19800315 	stw	r6,12(r3)
81123a34:	003fde06 	br	811239b0 <__reset+0xfb1039b0>
81123a38:	29c00217 	ldw	r7,8(r5)
81123a3c:	10c5883a 	add	r2,r2,r3
81123a40:	00e04534 	movhi	r3,33044
81123a44:	18d7ed04 	addi	r3,r3,24500
81123a48:	38c03b26 	beq	r7,r3,81123b38 <_free_r+0x280>
81123a4c:	2a000317 	ldw	r8,12(r5)
81123a50:	11400054 	ori	r5,r2,1
81123a54:	3087883a 	add	r3,r6,r2
81123a58:	3a000315 	stw	r8,12(r7)
81123a5c:	41c00215 	stw	r7,8(r8)
81123a60:	31400115 	stw	r5,4(r6)
81123a64:	18800015 	stw	r2,0(r3)
81123a68:	003fbd06 	br	81123960 <__reset+0xfb103960>
81123a6c:	39c0004c 	andi	r7,r7,1
81123a70:	10c5883a 	add	r2,r2,r3
81123a74:	3800071e 	bne	r7,zero,81123a94 <_free_r+0x1dc>
81123a78:	81fffe17 	ldw	r7,-8(r16)
81123a7c:	31cdc83a 	sub	r6,r6,r7
81123a80:	30c00317 	ldw	r3,12(r6)
81123a84:	31400217 	ldw	r5,8(r6)
81123a88:	11c5883a 	add	r2,r2,r7
81123a8c:	28c00315 	stw	r3,12(r5)
81123a90:	19400215 	stw	r5,8(r3)
81123a94:	10c00054 	ori	r3,r2,1
81123a98:	30c00115 	stw	r3,4(r6)
81123a9c:	00e04534 	movhi	r3,33044
81123aa0:	18de1204 	addi	r3,r3,30792
81123aa4:	18c00017 	ldw	r3,0(r3)
81123aa8:	21800215 	stw	r6,8(r4)
81123aac:	10ffc036 	bltu	r2,r3,811239b0 <__reset+0xfb1039b0>
81123ab0:	00a04534 	movhi	r2,33044
81123ab4:	109e8604 	addi	r2,r2,31256
81123ab8:	11400017 	ldw	r5,0(r2)
81123abc:	8809883a 	mov	r4,r17
81123ac0:	112378c0 	call	8112378c <_malloc_trim_r>
81123ac4:	003fba06 	br	811239b0 <__reset+0xfb1039b0>
81123ac8:	28c9883a 	add	r4,r5,r3
81123acc:	21000117 	ldw	r4,4(r4)
81123ad0:	2100004c 	andi	r4,r4,1
81123ad4:	2000391e 	bne	r4,zero,81123bbc <_free_r+0x304>
81123ad8:	29c00217 	ldw	r7,8(r5)
81123adc:	29000317 	ldw	r4,12(r5)
81123ae0:	1885883a 	add	r2,r3,r2
81123ae4:	10c00054 	ori	r3,r2,1
81123ae8:	39000315 	stw	r4,12(r7)
81123aec:	21c00215 	stw	r7,8(r4)
81123af0:	30c00115 	stw	r3,4(r6)
81123af4:	308d883a 	add	r6,r6,r2
81123af8:	30800015 	stw	r2,0(r6)
81123afc:	003fac06 	br	811239b0 <__reset+0xfb1039b0>
81123b00:	00c00504 	movi	r3,20
81123b04:	19401536 	bltu	r3,r5,81123b5c <_free_r+0x2a4>
81123b08:	28c01704 	addi	r3,r5,92
81123b0c:	18c7883a 	add	r3,r3,r3
81123b10:	294016c4 	addi	r5,r5,91
81123b14:	003fb406 	br	811239e8 <__reset+0xfb1039e8>
81123b18:	280bd0ba 	srai	r5,r5,2
81123b1c:	00c00044 	movi	r3,1
81123b20:	38800117 	ldw	r2,4(r7)
81123b24:	194a983a 	sll	r5,r3,r5
81123b28:	2007883a 	mov	r3,r4
81123b2c:	2884b03a 	or	r2,r5,r2
81123b30:	38800115 	stw	r2,4(r7)
81123b34:	003fbb06 	br	81123a24 <__reset+0xfb103a24>
81123b38:	21800515 	stw	r6,20(r4)
81123b3c:	21800415 	stw	r6,16(r4)
81123b40:	10c00054 	ori	r3,r2,1
81123b44:	31c00315 	stw	r7,12(r6)
81123b48:	31c00215 	stw	r7,8(r6)
81123b4c:	30c00115 	stw	r3,4(r6)
81123b50:	308d883a 	add	r6,r6,r2
81123b54:	30800015 	stw	r2,0(r6)
81123b58:	003f9506 	br	811239b0 <__reset+0xfb1039b0>
81123b5c:	00c01504 	movi	r3,84
81123b60:	19400536 	bltu	r3,r5,81123b78 <_free_r+0x2c0>
81123b64:	100ad33a 	srli	r5,r2,12
81123b68:	28c01bc4 	addi	r3,r5,111
81123b6c:	18c7883a 	add	r3,r3,r3
81123b70:	29401b84 	addi	r5,r5,110
81123b74:	003f9c06 	br	811239e8 <__reset+0xfb1039e8>
81123b78:	00c05504 	movi	r3,340
81123b7c:	19400536 	bltu	r3,r5,81123b94 <_free_r+0x2dc>
81123b80:	100ad3fa 	srli	r5,r2,15
81123b84:	28c01e04 	addi	r3,r5,120
81123b88:	18c7883a 	add	r3,r3,r3
81123b8c:	29401dc4 	addi	r5,r5,119
81123b90:	003f9506 	br	811239e8 <__reset+0xfb1039e8>
81123b94:	00c15504 	movi	r3,1364
81123b98:	19400536 	bltu	r3,r5,81123bb0 <_free_r+0x2f8>
81123b9c:	100ad4ba 	srli	r5,r2,18
81123ba0:	28c01f44 	addi	r3,r5,125
81123ba4:	18c7883a 	add	r3,r3,r3
81123ba8:	29401f04 	addi	r5,r5,124
81123bac:	003f8e06 	br	811239e8 <__reset+0xfb1039e8>
81123bb0:	00c03f84 	movi	r3,254
81123bb4:	01401f84 	movi	r5,126
81123bb8:	003f8b06 	br	811239e8 <__reset+0xfb1039e8>
81123bbc:	10c00054 	ori	r3,r2,1
81123bc0:	30c00115 	stw	r3,4(r6)
81123bc4:	308d883a 	add	r6,r6,r2
81123bc8:	30800015 	stw	r2,0(r6)
81123bcc:	003f7806 	br	811239b0 <__reset+0xfb1039b0>

81123bd0 <__sfvwrite_r>:
81123bd0:	30800217 	ldw	r2,8(r6)
81123bd4:	10006926 	beq	r2,zero,81123d7c <__sfvwrite_r+0x1ac>
81123bd8:	defff404 	addi	sp,sp,-48
81123bdc:	de00012e 	bgeu	sp,et,81123be4 <__sfvwrite_r+0x14>
81123be0:	003b68fa 	trap	3
81123be4:	28c0030b 	ldhu	r3,12(r5)
81123be8:	dd400715 	stw	r21,28(sp)
81123bec:	dd000615 	stw	r20,24(sp)
81123bf0:	dc000215 	stw	r16,8(sp)
81123bf4:	dfc00b15 	stw	ra,44(sp)
81123bf8:	df000a15 	stw	fp,40(sp)
81123bfc:	ddc00915 	stw	r23,36(sp)
81123c00:	dd800815 	stw	r22,32(sp)
81123c04:	dcc00515 	stw	r19,20(sp)
81123c08:	dc800415 	stw	r18,16(sp)
81123c0c:	dc400315 	stw	r17,12(sp)
81123c10:	1880020c 	andi	r2,r3,8
81123c14:	2821883a 	mov	r16,r5
81123c18:	202b883a 	mov	r21,r4
81123c1c:	3029883a 	mov	r20,r6
81123c20:	10002726 	beq	r2,zero,81123cc0 <__sfvwrite_r+0xf0>
81123c24:	28800417 	ldw	r2,16(r5)
81123c28:	10002526 	beq	r2,zero,81123cc0 <__sfvwrite_r+0xf0>
81123c2c:	1880008c 	andi	r2,r3,2
81123c30:	a4400017 	ldw	r17,0(r20)
81123c34:	10002a26 	beq	r2,zero,81123ce0 <__sfvwrite_r+0x110>
81123c38:	05a00034 	movhi	r22,32768
81123c3c:	0027883a 	mov	r19,zero
81123c40:	0025883a 	mov	r18,zero
81123c44:	b5bf0004 	addi	r22,r22,-1024
81123c48:	980d883a 	mov	r6,r19
81123c4c:	a809883a 	mov	r4,r21
81123c50:	90004626 	beq	r18,zero,81123d6c <__sfvwrite_r+0x19c>
81123c54:	900f883a 	mov	r7,r18
81123c58:	b480022e 	bgeu	r22,r18,81123c64 <__sfvwrite_r+0x94>
81123c5c:	01e00034 	movhi	r7,32768
81123c60:	39ff0004 	addi	r7,r7,-1024
81123c64:	80800917 	ldw	r2,36(r16)
81123c68:	81400717 	ldw	r5,28(r16)
81123c6c:	103ee83a 	callr	r2
81123c70:	0080570e 	bge	zero,r2,81123dd0 <__sfvwrite_r+0x200>
81123c74:	a0c00217 	ldw	r3,8(r20)
81123c78:	98a7883a 	add	r19,r19,r2
81123c7c:	90a5c83a 	sub	r18,r18,r2
81123c80:	1885c83a 	sub	r2,r3,r2
81123c84:	a0800215 	stw	r2,8(r20)
81123c88:	103fef1e 	bne	r2,zero,81123c48 <__reset+0xfb103c48>
81123c8c:	0005883a 	mov	r2,zero
81123c90:	dfc00b17 	ldw	ra,44(sp)
81123c94:	df000a17 	ldw	fp,40(sp)
81123c98:	ddc00917 	ldw	r23,36(sp)
81123c9c:	dd800817 	ldw	r22,32(sp)
81123ca0:	dd400717 	ldw	r21,28(sp)
81123ca4:	dd000617 	ldw	r20,24(sp)
81123ca8:	dcc00517 	ldw	r19,20(sp)
81123cac:	dc800417 	ldw	r18,16(sp)
81123cb0:	dc400317 	ldw	r17,12(sp)
81123cb4:	dc000217 	ldw	r16,8(sp)
81123cb8:	dec00c04 	addi	sp,sp,48
81123cbc:	f800283a 	ret
81123cc0:	800b883a 	mov	r5,r16
81123cc4:	a809883a 	mov	r4,r21
81123cc8:	11214b80 	call	811214b8 <__swsetup_r>
81123ccc:	1000eb1e 	bne	r2,zero,8112407c <__sfvwrite_r+0x4ac>
81123cd0:	80c0030b 	ldhu	r3,12(r16)
81123cd4:	a4400017 	ldw	r17,0(r20)
81123cd8:	1880008c 	andi	r2,r3,2
81123cdc:	103fd61e 	bne	r2,zero,81123c38 <__reset+0xfb103c38>
81123ce0:	1880004c 	andi	r2,r3,1
81123ce4:	10003f1e 	bne	r2,zero,81123de4 <__sfvwrite_r+0x214>
81123ce8:	0039883a 	mov	fp,zero
81123cec:	0025883a 	mov	r18,zero
81123cf0:	90001a26 	beq	r18,zero,81123d5c <__sfvwrite_r+0x18c>
81123cf4:	1880800c 	andi	r2,r3,512
81123cf8:	84c00217 	ldw	r19,8(r16)
81123cfc:	10002126 	beq	r2,zero,81123d84 <__sfvwrite_r+0x1b4>
81123d00:	982f883a 	mov	r23,r19
81123d04:	94c09336 	bltu	r18,r19,81123f54 <__sfvwrite_r+0x384>
81123d08:	1881200c 	andi	r2,r3,1152
81123d0c:	10009e1e 	bne	r2,zero,81123f88 <__sfvwrite_r+0x3b8>
81123d10:	81000017 	ldw	r4,0(r16)
81123d14:	b80d883a 	mov	r6,r23
81123d18:	e00b883a 	mov	r5,fp
81123d1c:	11250400 	call	81125040 <memmove>
81123d20:	80c00217 	ldw	r3,8(r16)
81123d24:	81000017 	ldw	r4,0(r16)
81123d28:	9005883a 	mov	r2,r18
81123d2c:	1ce7c83a 	sub	r19,r3,r19
81123d30:	25cf883a 	add	r7,r4,r23
81123d34:	84c00215 	stw	r19,8(r16)
81123d38:	81c00015 	stw	r7,0(r16)
81123d3c:	a0c00217 	ldw	r3,8(r20)
81123d40:	e0b9883a 	add	fp,fp,r2
81123d44:	90a5c83a 	sub	r18,r18,r2
81123d48:	18a7c83a 	sub	r19,r3,r2
81123d4c:	a4c00215 	stw	r19,8(r20)
81123d50:	983fce26 	beq	r19,zero,81123c8c <__reset+0xfb103c8c>
81123d54:	80c0030b 	ldhu	r3,12(r16)
81123d58:	903fe61e 	bne	r18,zero,81123cf4 <__reset+0xfb103cf4>
81123d5c:	8f000017 	ldw	fp,0(r17)
81123d60:	8c800117 	ldw	r18,4(r17)
81123d64:	8c400204 	addi	r17,r17,8
81123d68:	003fe106 	br	81123cf0 <__reset+0xfb103cf0>
81123d6c:	8cc00017 	ldw	r19,0(r17)
81123d70:	8c800117 	ldw	r18,4(r17)
81123d74:	8c400204 	addi	r17,r17,8
81123d78:	003fb306 	br	81123c48 <__reset+0xfb103c48>
81123d7c:	0005883a 	mov	r2,zero
81123d80:	f800283a 	ret
81123d84:	81000017 	ldw	r4,0(r16)
81123d88:	80800417 	ldw	r2,16(r16)
81123d8c:	11005736 	bltu	r2,r4,81123eec <__sfvwrite_r+0x31c>
81123d90:	85c00517 	ldw	r23,20(r16)
81123d94:	95c05536 	bltu	r18,r23,81123eec <__sfvwrite_r+0x31c>
81123d98:	00a00034 	movhi	r2,32768
81123d9c:	10bfffc4 	addi	r2,r2,-1
81123da0:	9009883a 	mov	r4,r18
81123da4:	1480012e 	bgeu	r2,r18,81123dac <__sfvwrite_r+0x1dc>
81123da8:	1009883a 	mov	r4,r2
81123dac:	b80b883a 	mov	r5,r23
81123db0:	112d7ec0 	call	8112d7ec <__divsi3>
81123db4:	15cf383a 	mul	r7,r2,r23
81123db8:	81400717 	ldw	r5,28(r16)
81123dbc:	80800917 	ldw	r2,36(r16)
81123dc0:	e00d883a 	mov	r6,fp
81123dc4:	a809883a 	mov	r4,r21
81123dc8:	103ee83a 	callr	r2
81123dcc:	00bfdb16 	blt	zero,r2,81123d3c <__reset+0xfb103d3c>
81123dd0:	8080030b 	ldhu	r2,12(r16)
81123dd4:	10801014 	ori	r2,r2,64
81123dd8:	8080030d 	sth	r2,12(r16)
81123ddc:	00bfffc4 	movi	r2,-1
81123de0:	003fab06 	br	81123c90 <__reset+0xfb103c90>
81123de4:	0027883a 	mov	r19,zero
81123de8:	0011883a 	mov	r8,zero
81123dec:	0039883a 	mov	fp,zero
81123df0:	0025883a 	mov	r18,zero
81123df4:	90001f26 	beq	r18,zero,81123e74 <__sfvwrite_r+0x2a4>
81123df8:	40005a26 	beq	r8,zero,81123f64 <__sfvwrite_r+0x394>
81123dfc:	982d883a 	mov	r22,r19
81123e00:	94c0012e 	bgeu	r18,r19,81123e08 <__sfvwrite_r+0x238>
81123e04:	902d883a 	mov	r22,r18
81123e08:	81000017 	ldw	r4,0(r16)
81123e0c:	80800417 	ldw	r2,16(r16)
81123e10:	b02f883a 	mov	r23,r22
81123e14:	81c00517 	ldw	r7,20(r16)
81123e18:	1100032e 	bgeu	r2,r4,81123e28 <__sfvwrite_r+0x258>
81123e1c:	80c00217 	ldw	r3,8(r16)
81123e20:	38c7883a 	add	r3,r7,r3
81123e24:	1d801816 	blt	r3,r22,81123e88 <__sfvwrite_r+0x2b8>
81123e28:	b1c03e16 	blt	r22,r7,81123f24 <__sfvwrite_r+0x354>
81123e2c:	80800917 	ldw	r2,36(r16)
81123e30:	81400717 	ldw	r5,28(r16)
81123e34:	e00d883a 	mov	r6,fp
81123e38:	da000115 	stw	r8,4(sp)
81123e3c:	a809883a 	mov	r4,r21
81123e40:	103ee83a 	callr	r2
81123e44:	102f883a 	mov	r23,r2
81123e48:	da000117 	ldw	r8,4(sp)
81123e4c:	00bfe00e 	bge	zero,r2,81123dd0 <__reset+0xfb103dd0>
81123e50:	9de7c83a 	sub	r19,r19,r23
81123e54:	98001f26 	beq	r19,zero,81123ed4 <__sfvwrite_r+0x304>
81123e58:	a0800217 	ldw	r2,8(r20)
81123e5c:	e5f9883a 	add	fp,fp,r23
81123e60:	95e5c83a 	sub	r18,r18,r23
81123e64:	15efc83a 	sub	r23,r2,r23
81123e68:	a5c00215 	stw	r23,8(r20)
81123e6c:	b83f8726 	beq	r23,zero,81123c8c <__reset+0xfb103c8c>
81123e70:	903fe11e 	bne	r18,zero,81123df8 <__reset+0xfb103df8>
81123e74:	8f000017 	ldw	fp,0(r17)
81123e78:	8c800117 	ldw	r18,4(r17)
81123e7c:	0011883a 	mov	r8,zero
81123e80:	8c400204 	addi	r17,r17,8
81123e84:	003fdb06 	br	81123df4 <__reset+0xfb103df4>
81123e88:	180d883a 	mov	r6,r3
81123e8c:	e00b883a 	mov	r5,fp
81123e90:	da000115 	stw	r8,4(sp)
81123e94:	d8c00015 	stw	r3,0(sp)
81123e98:	11250400 	call	81125040 <memmove>
81123e9c:	d8c00017 	ldw	r3,0(sp)
81123ea0:	80800017 	ldw	r2,0(r16)
81123ea4:	800b883a 	mov	r5,r16
81123ea8:	a809883a 	mov	r4,r21
81123eac:	10c5883a 	add	r2,r2,r3
81123eb0:	80800015 	stw	r2,0(r16)
81123eb4:	d8c00015 	stw	r3,0(sp)
81123eb8:	11230d00 	call	811230d0 <_fflush_r>
81123ebc:	d8c00017 	ldw	r3,0(sp)
81123ec0:	da000117 	ldw	r8,4(sp)
81123ec4:	103fc21e 	bne	r2,zero,81123dd0 <__reset+0xfb103dd0>
81123ec8:	182f883a 	mov	r23,r3
81123ecc:	9de7c83a 	sub	r19,r19,r23
81123ed0:	983fe11e 	bne	r19,zero,81123e58 <__reset+0xfb103e58>
81123ed4:	800b883a 	mov	r5,r16
81123ed8:	a809883a 	mov	r4,r21
81123edc:	11230d00 	call	811230d0 <_fflush_r>
81123ee0:	103fbb1e 	bne	r2,zero,81123dd0 <__reset+0xfb103dd0>
81123ee4:	0011883a 	mov	r8,zero
81123ee8:	003fdb06 	br	81123e58 <__reset+0xfb103e58>
81123eec:	94c0012e 	bgeu	r18,r19,81123ef4 <__sfvwrite_r+0x324>
81123ef0:	9027883a 	mov	r19,r18
81123ef4:	980d883a 	mov	r6,r19
81123ef8:	e00b883a 	mov	r5,fp
81123efc:	11250400 	call	81125040 <memmove>
81123f00:	80800217 	ldw	r2,8(r16)
81123f04:	80c00017 	ldw	r3,0(r16)
81123f08:	14c5c83a 	sub	r2,r2,r19
81123f0c:	1cc7883a 	add	r3,r3,r19
81123f10:	80800215 	stw	r2,8(r16)
81123f14:	80c00015 	stw	r3,0(r16)
81123f18:	10004326 	beq	r2,zero,81124028 <__sfvwrite_r+0x458>
81123f1c:	9805883a 	mov	r2,r19
81123f20:	003f8606 	br	81123d3c <__reset+0xfb103d3c>
81123f24:	b00d883a 	mov	r6,r22
81123f28:	e00b883a 	mov	r5,fp
81123f2c:	da000115 	stw	r8,4(sp)
81123f30:	11250400 	call	81125040 <memmove>
81123f34:	80800217 	ldw	r2,8(r16)
81123f38:	80c00017 	ldw	r3,0(r16)
81123f3c:	da000117 	ldw	r8,4(sp)
81123f40:	1585c83a 	sub	r2,r2,r22
81123f44:	1dad883a 	add	r22,r3,r22
81123f48:	80800215 	stw	r2,8(r16)
81123f4c:	85800015 	stw	r22,0(r16)
81123f50:	003fbf06 	br	81123e50 <__reset+0xfb103e50>
81123f54:	81000017 	ldw	r4,0(r16)
81123f58:	9027883a 	mov	r19,r18
81123f5c:	902f883a 	mov	r23,r18
81123f60:	003f6c06 	br	81123d14 <__reset+0xfb103d14>
81123f64:	900d883a 	mov	r6,r18
81123f68:	01400284 	movi	r5,10
81123f6c:	e009883a 	mov	r4,fp
81123f70:	1124f5c0 	call	81124f5c <memchr>
81123f74:	10003e26 	beq	r2,zero,81124070 <__sfvwrite_r+0x4a0>
81123f78:	10800044 	addi	r2,r2,1
81123f7c:	1727c83a 	sub	r19,r2,fp
81123f80:	02000044 	movi	r8,1
81123f84:	003f9d06 	br	81123dfc <__reset+0xfb103dfc>
81123f88:	80800517 	ldw	r2,20(r16)
81123f8c:	81400417 	ldw	r5,16(r16)
81123f90:	81c00017 	ldw	r7,0(r16)
81123f94:	10a7883a 	add	r19,r2,r2
81123f98:	9885883a 	add	r2,r19,r2
81123f9c:	1026d7fa 	srli	r19,r2,31
81123fa0:	396dc83a 	sub	r22,r7,r5
81123fa4:	b1000044 	addi	r4,r22,1
81123fa8:	9885883a 	add	r2,r19,r2
81123fac:	1027d07a 	srai	r19,r2,1
81123fb0:	2485883a 	add	r2,r4,r18
81123fb4:	980d883a 	mov	r6,r19
81123fb8:	9880022e 	bgeu	r19,r2,81123fc4 <__sfvwrite_r+0x3f4>
81123fbc:	1027883a 	mov	r19,r2
81123fc0:	100d883a 	mov	r6,r2
81123fc4:	18c1000c 	andi	r3,r3,1024
81123fc8:	18001c26 	beq	r3,zero,8112403c <__sfvwrite_r+0x46c>
81123fcc:	300b883a 	mov	r5,r6
81123fd0:	a809883a 	mov	r4,r21
81123fd4:	11245040 	call	81124504 <_malloc_r>
81123fd8:	102f883a 	mov	r23,r2
81123fdc:	10002926 	beq	r2,zero,81124084 <__sfvwrite_r+0x4b4>
81123fe0:	81400417 	ldw	r5,16(r16)
81123fe4:	b00d883a 	mov	r6,r22
81123fe8:	1009883a 	mov	r4,r2
81123fec:	111abac0 	call	8111abac <memcpy>
81123ff0:	8080030b 	ldhu	r2,12(r16)
81123ff4:	00fedfc4 	movi	r3,-1153
81123ff8:	10c4703a 	and	r2,r2,r3
81123ffc:	10802014 	ori	r2,r2,128
81124000:	8080030d 	sth	r2,12(r16)
81124004:	bd89883a 	add	r4,r23,r22
81124008:	9d8fc83a 	sub	r7,r19,r22
8112400c:	85c00415 	stw	r23,16(r16)
81124010:	84c00515 	stw	r19,20(r16)
81124014:	81000015 	stw	r4,0(r16)
81124018:	9027883a 	mov	r19,r18
8112401c:	81c00215 	stw	r7,8(r16)
81124020:	902f883a 	mov	r23,r18
81124024:	003f3b06 	br	81123d14 <__reset+0xfb103d14>
81124028:	800b883a 	mov	r5,r16
8112402c:	a809883a 	mov	r4,r21
81124030:	11230d00 	call	811230d0 <_fflush_r>
81124034:	103fb926 	beq	r2,zero,81123f1c <__reset+0xfb103f1c>
81124038:	003f6506 	br	81123dd0 <__reset+0xfb103dd0>
8112403c:	a809883a 	mov	r4,r21
81124040:	11261f80 	call	811261f8 <_realloc_r>
81124044:	102f883a 	mov	r23,r2
81124048:	103fee1e 	bne	r2,zero,81124004 <__reset+0xfb104004>
8112404c:	81400417 	ldw	r5,16(r16)
81124050:	a809883a 	mov	r4,r21
81124054:	11238b80 	call	811238b8 <_free_r>
81124058:	8080030b 	ldhu	r2,12(r16)
8112405c:	00ffdfc4 	movi	r3,-129
81124060:	1884703a 	and	r2,r3,r2
81124064:	00c00304 	movi	r3,12
81124068:	a8c00015 	stw	r3,0(r21)
8112406c:	003f5906 	br	81123dd4 <__reset+0xfb103dd4>
81124070:	94c00044 	addi	r19,r18,1
81124074:	02000044 	movi	r8,1
81124078:	003f6006 	br	81123dfc <__reset+0xfb103dfc>
8112407c:	00bfffc4 	movi	r2,-1
81124080:	003f0306 	br	81123c90 <__reset+0xfb103c90>
81124084:	00800304 	movi	r2,12
81124088:	a8800015 	stw	r2,0(r21)
8112408c:	8080030b 	ldhu	r2,12(r16)
81124090:	003f5006 	br	81123dd4 <__reset+0xfb103dd4>

81124094 <_fwalk>:
81124094:	defff704 	addi	sp,sp,-36
81124098:	de00012e 	bgeu	sp,et,811240a0 <_fwalk+0xc>
8112409c:	003b68fa 	trap	3
811240a0:	dd000415 	stw	r20,16(sp)
811240a4:	dfc00815 	stw	ra,32(sp)
811240a8:	ddc00715 	stw	r23,28(sp)
811240ac:	dd800615 	stw	r22,24(sp)
811240b0:	dd400515 	stw	r21,20(sp)
811240b4:	dcc00315 	stw	r19,12(sp)
811240b8:	dc800215 	stw	r18,8(sp)
811240bc:	dc400115 	stw	r17,4(sp)
811240c0:	dc000015 	stw	r16,0(sp)
811240c4:	2500b804 	addi	r20,r4,736
811240c8:	a0002326 	beq	r20,zero,81124158 <_fwalk+0xc4>
811240cc:	282b883a 	mov	r21,r5
811240d0:	002f883a 	mov	r23,zero
811240d4:	05800044 	movi	r22,1
811240d8:	04ffffc4 	movi	r19,-1
811240dc:	a4400117 	ldw	r17,4(r20)
811240e0:	a4800217 	ldw	r18,8(r20)
811240e4:	8c7fffc4 	addi	r17,r17,-1
811240e8:	88000d16 	blt	r17,zero,81124120 <_fwalk+0x8c>
811240ec:	94000304 	addi	r16,r18,12
811240f0:	94800384 	addi	r18,r18,14
811240f4:	8080000b 	ldhu	r2,0(r16)
811240f8:	8c7fffc4 	addi	r17,r17,-1
811240fc:	813ffd04 	addi	r4,r16,-12
81124100:	b080042e 	bgeu	r22,r2,81124114 <_fwalk+0x80>
81124104:	9080000f 	ldh	r2,0(r18)
81124108:	14c00226 	beq	r2,r19,81124114 <_fwalk+0x80>
8112410c:	a83ee83a 	callr	r21
81124110:	b8aeb03a 	or	r23,r23,r2
81124114:	84001a04 	addi	r16,r16,104
81124118:	94801a04 	addi	r18,r18,104
8112411c:	8cfff51e 	bne	r17,r19,811240f4 <__reset+0xfb1040f4>
81124120:	a5000017 	ldw	r20,0(r20)
81124124:	a03fed1e 	bne	r20,zero,811240dc <__reset+0xfb1040dc>
81124128:	b805883a 	mov	r2,r23
8112412c:	dfc00817 	ldw	ra,32(sp)
81124130:	ddc00717 	ldw	r23,28(sp)
81124134:	dd800617 	ldw	r22,24(sp)
81124138:	dd400517 	ldw	r21,20(sp)
8112413c:	dd000417 	ldw	r20,16(sp)
81124140:	dcc00317 	ldw	r19,12(sp)
81124144:	dc800217 	ldw	r18,8(sp)
81124148:	dc400117 	ldw	r17,4(sp)
8112414c:	dc000017 	ldw	r16,0(sp)
81124150:	dec00904 	addi	sp,sp,36
81124154:	f800283a 	ret
81124158:	002f883a 	mov	r23,zero
8112415c:	003ff206 	br	81124128 <__reset+0xfb104128>

81124160 <_fwalk_reent>:
81124160:	defff704 	addi	sp,sp,-36
81124164:	de00012e 	bgeu	sp,et,8112416c <_fwalk_reent+0xc>
81124168:	003b68fa 	trap	3
8112416c:	dd000415 	stw	r20,16(sp)
81124170:	dfc00815 	stw	ra,32(sp)
81124174:	ddc00715 	stw	r23,28(sp)
81124178:	dd800615 	stw	r22,24(sp)
8112417c:	dd400515 	stw	r21,20(sp)
81124180:	dcc00315 	stw	r19,12(sp)
81124184:	dc800215 	stw	r18,8(sp)
81124188:	dc400115 	stw	r17,4(sp)
8112418c:	dc000015 	stw	r16,0(sp)
81124190:	2500b804 	addi	r20,r4,736
81124194:	a0002326 	beq	r20,zero,81124224 <_fwalk_reent+0xc4>
81124198:	282b883a 	mov	r21,r5
8112419c:	2027883a 	mov	r19,r4
811241a0:	002f883a 	mov	r23,zero
811241a4:	05800044 	movi	r22,1
811241a8:	04bfffc4 	movi	r18,-1
811241ac:	a4400117 	ldw	r17,4(r20)
811241b0:	a4000217 	ldw	r16,8(r20)
811241b4:	8c7fffc4 	addi	r17,r17,-1
811241b8:	88000c16 	blt	r17,zero,811241ec <_fwalk_reent+0x8c>
811241bc:	84000304 	addi	r16,r16,12
811241c0:	8080000b 	ldhu	r2,0(r16)
811241c4:	8c7fffc4 	addi	r17,r17,-1
811241c8:	817ffd04 	addi	r5,r16,-12
811241cc:	b080052e 	bgeu	r22,r2,811241e4 <_fwalk_reent+0x84>
811241d0:	8080008f 	ldh	r2,2(r16)
811241d4:	9809883a 	mov	r4,r19
811241d8:	14800226 	beq	r2,r18,811241e4 <_fwalk_reent+0x84>
811241dc:	a83ee83a 	callr	r21
811241e0:	b8aeb03a 	or	r23,r23,r2
811241e4:	84001a04 	addi	r16,r16,104
811241e8:	8cbff51e 	bne	r17,r18,811241c0 <__reset+0xfb1041c0>
811241ec:	a5000017 	ldw	r20,0(r20)
811241f0:	a03fee1e 	bne	r20,zero,811241ac <__reset+0xfb1041ac>
811241f4:	b805883a 	mov	r2,r23
811241f8:	dfc00817 	ldw	ra,32(sp)
811241fc:	ddc00717 	ldw	r23,28(sp)
81124200:	dd800617 	ldw	r22,24(sp)
81124204:	dd400517 	ldw	r21,20(sp)
81124208:	dd000417 	ldw	r20,16(sp)
8112420c:	dcc00317 	ldw	r19,12(sp)
81124210:	dc800217 	ldw	r18,8(sp)
81124214:	dc400117 	ldw	r17,4(sp)
81124218:	dc000017 	ldw	r16,0(sp)
8112421c:	dec00904 	addi	sp,sp,36
81124220:	f800283a 	ret
81124224:	002f883a 	mov	r23,zero
81124228:	003ff206 	br	811241f4 <__reset+0xfb1041f4>

8112422c <iswspace>:
8112422c:	00803fc4 	movi	r2,255
81124230:	11000836 	bltu	r2,r4,81124254 <iswspace+0x28>
81124234:	00a04534 	movhi	r2,33044
81124238:	109e0d04 	addi	r2,r2,30772
8112423c:	10800017 	ldw	r2,0(r2)
81124240:	1109883a 	add	r4,r2,r4
81124244:	20800043 	ldbu	r2,1(r4)
81124248:	1080020c 	andi	r2,r2,8
8112424c:	10803fcc 	andi	r2,r2,255
81124250:	f800283a 	ret
81124254:	0005883a 	mov	r2,zero
81124258:	f800283a 	ret

8112425c <_setlocale_r>:
8112425c:	30001d26 	beq	r6,zero,811242d4 <_setlocale_r+0x78>
81124260:	01604534 	movhi	r5,33044
81124264:	defffe04 	addi	sp,sp,-8
81124268:	29546604 	addi	r5,r5,20888
8112426c:	3009883a 	mov	r4,r6
81124270:	de00012e 	bgeu	sp,et,81124278 <_setlocale_r+0x1c>
81124274:	003b68fa 	trap	3
81124278:	dc000015 	stw	r16,0(sp)
8112427c:	dfc00115 	stw	ra,4(sp)
81124280:	3021883a 	mov	r16,r6
81124284:	1126c580 	call	81126c58 <strcmp>
81124288:	1000061e 	bne	r2,zero,811242a4 <_setlocale_r+0x48>
8112428c:	00a04534 	movhi	r2,33044
81124290:	10946504 	addi	r2,r2,20884
81124294:	dfc00117 	ldw	ra,4(sp)
81124298:	dc000017 	ldw	r16,0(sp)
8112429c:	dec00204 	addi	sp,sp,8
811242a0:	f800283a 	ret
811242a4:	01604534 	movhi	r5,33044
811242a8:	29546504 	addi	r5,r5,20884
811242ac:	8009883a 	mov	r4,r16
811242b0:	1126c580 	call	81126c58 <strcmp>
811242b4:	103ff526 	beq	r2,zero,8112428c <__reset+0xfb10428c>
811242b8:	01604534 	movhi	r5,33044
811242bc:	29543e04 	addi	r5,r5,20728
811242c0:	8009883a 	mov	r4,r16
811242c4:	1126c580 	call	81126c58 <strcmp>
811242c8:	103ff026 	beq	r2,zero,8112428c <__reset+0xfb10428c>
811242cc:	0005883a 	mov	r2,zero
811242d0:	003ff006 	br	81124294 <__reset+0xfb104294>
811242d4:	00a04534 	movhi	r2,33044
811242d8:	10946504 	addi	r2,r2,20884
811242dc:	f800283a 	ret

811242e0 <__locale_charset>:
811242e0:	00a04534 	movhi	r2,33044
811242e4:	1097d504 	addi	r2,r2,24404
811242e8:	f800283a 	ret

811242ec <__locale_mb_cur_max>:
811242ec:	00a04534 	movhi	r2,33044
811242f0:	109e1004 	addi	r2,r2,30784
811242f4:	10800017 	ldw	r2,0(r2)
811242f8:	f800283a 	ret

811242fc <__locale_msgcharset>:
811242fc:	00a04534 	movhi	r2,33044
81124300:	1097cd04 	addi	r2,r2,24372
81124304:	f800283a 	ret

81124308 <__locale_cjk_lang>:
81124308:	0005883a 	mov	r2,zero
8112430c:	f800283a 	ret

81124310 <_localeconv_r>:
81124310:	00a04534 	movhi	r2,33044
81124314:	1097dd04 	addi	r2,r2,24436
81124318:	f800283a 	ret

8112431c <setlocale>:
8112431c:	00a04534 	movhi	r2,33044
81124320:	109e0f04 	addi	r2,r2,30780
81124324:	280d883a 	mov	r6,r5
81124328:	200b883a 	mov	r5,r4
8112432c:	11000017 	ldw	r4,0(r2)
81124330:	112425c1 	jmpi	8112425c <_setlocale_r>

81124334 <localeconv>:
81124334:	00a04534 	movhi	r2,33044
81124338:	1097dd04 	addi	r2,r2,24436
8112433c:	f800283a 	ret

81124340 <__smakebuf_r>:
81124340:	2880030b 	ldhu	r2,12(r5)
81124344:	10c0008c 	andi	r3,r2,2
81124348:	1800431e 	bne	r3,zero,81124458 <__smakebuf_r+0x118>
8112434c:	deffec04 	addi	sp,sp,-80
81124350:	de00012e 	bgeu	sp,et,81124358 <__smakebuf_r+0x18>
81124354:	003b68fa 	trap	3
81124358:	dc000f15 	stw	r16,60(sp)
8112435c:	2821883a 	mov	r16,r5
81124360:	2940038f 	ldh	r5,14(r5)
81124364:	dc401015 	stw	r17,64(sp)
81124368:	dfc01315 	stw	ra,76(sp)
8112436c:	dcc01215 	stw	r19,72(sp)
81124370:	dc801115 	stw	r18,68(sp)
81124374:	2023883a 	mov	r17,r4
81124378:	28001c16 	blt	r5,zero,811243ec <__smakebuf_r+0xac>
8112437c:	d80d883a 	mov	r6,sp
81124380:	112bbd00 	call	8112bbd0 <_fstat_r>
81124384:	10001816 	blt	r2,zero,811243e8 <__smakebuf_r+0xa8>
81124388:	d8800117 	ldw	r2,4(sp)
8112438c:	00e00014 	movui	r3,32768
81124390:	10bc000c 	andi	r2,r2,61440
81124394:	14c80020 	cmpeqi	r19,r2,8192
81124398:	10c03726 	beq	r2,r3,81124478 <__smakebuf_r+0x138>
8112439c:	80c0030b 	ldhu	r3,12(r16)
811243a0:	18c20014 	ori	r3,r3,2048
811243a4:	80c0030d 	sth	r3,12(r16)
811243a8:	00c80004 	movi	r3,8192
811243ac:	10c0521e 	bne	r2,r3,811244f8 <__smakebuf_r+0x1b8>
811243b0:	8140038f 	ldh	r5,14(r16)
811243b4:	8809883a 	mov	r4,r17
811243b8:	112c7d00 	call	8112c7d0 <_isatty_r>
811243bc:	10004c26 	beq	r2,zero,811244f0 <__smakebuf_r+0x1b0>
811243c0:	8080030b 	ldhu	r2,12(r16)
811243c4:	80c010c4 	addi	r3,r16,67
811243c8:	80c00015 	stw	r3,0(r16)
811243cc:	10800054 	ori	r2,r2,1
811243d0:	8080030d 	sth	r2,12(r16)
811243d4:	00800044 	movi	r2,1
811243d8:	80c00415 	stw	r3,16(r16)
811243dc:	80800515 	stw	r2,20(r16)
811243e0:	04810004 	movi	r18,1024
811243e4:	00000706 	br	81124404 <__smakebuf_r+0xc4>
811243e8:	8080030b 	ldhu	r2,12(r16)
811243ec:	10c0200c 	andi	r3,r2,128
811243f0:	18001f1e 	bne	r3,zero,81124470 <__smakebuf_r+0x130>
811243f4:	04810004 	movi	r18,1024
811243f8:	10820014 	ori	r2,r2,2048
811243fc:	8080030d 	sth	r2,12(r16)
81124400:	0027883a 	mov	r19,zero
81124404:	900b883a 	mov	r5,r18
81124408:	8809883a 	mov	r4,r17
8112440c:	11245040 	call	81124504 <_malloc_r>
81124410:	10002c26 	beq	r2,zero,811244c4 <__smakebuf_r+0x184>
81124414:	80c0030b 	ldhu	r3,12(r16)
81124418:	012044b4 	movhi	r4,33042
8112441c:	210c5b04 	addi	r4,r4,12652
81124420:	89000f15 	stw	r4,60(r17)
81124424:	18c02014 	ori	r3,r3,128
81124428:	80c0030d 	sth	r3,12(r16)
8112442c:	80800015 	stw	r2,0(r16)
81124430:	80800415 	stw	r2,16(r16)
81124434:	84800515 	stw	r18,20(r16)
81124438:	98001a1e 	bne	r19,zero,811244a4 <__smakebuf_r+0x164>
8112443c:	dfc01317 	ldw	ra,76(sp)
81124440:	dcc01217 	ldw	r19,72(sp)
81124444:	dc801117 	ldw	r18,68(sp)
81124448:	dc401017 	ldw	r17,64(sp)
8112444c:	dc000f17 	ldw	r16,60(sp)
81124450:	dec01404 	addi	sp,sp,80
81124454:	f800283a 	ret
81124458:	288010c4 	addi	r2,r5,67
8112445c:	28800015 	stw	r2,0(r5)
81124460:	28800415 	stw	r2,16(r5)
81124464:	00800044 	movi	r2,1
81124468:	28800515 	stw	r2,20(r5)
8112446c:	f800283a 	ret
81124470:	04801004 	movi	r18,64
81124474:	003fe006 	br	811243f8 <__reset+0xfb1043f8>
81124478:	81000a17 	ldw	r4,40(r16)
8112447c:	00e044b4 	movhi	r3,33042
81124480:	18dafb04 	addi	r3,r3,27628
81124484:	20ffc51e 	bne	r4,r3,8112439c <__reset+0xfb10439c>
81124488:	8080030b 	ldhu	r2,12(r16)
8112448c:	04810004 	movi	r18,1024
81124490:	84801315 	stw	r18,76(r16)
81124494:	1484b03a 	or	r2,r2,r18
81124498:	8080030d 	sth	r2,12(r16)
8112449c:	0027883a 	mov	r19,zero
811244a0:	003fd806 	br	81124404 <__reset+0xfb104404>
811244a4:	8140038f 	ldh	r5,14(r16)
811244a8:	8809883a 	mov	r4,r17
811244ac:	112c7d00 	call	8112c7d0 <_isatty_r>
811244b0:	103fe226 	beq	r2,zero,8112443c <__reset+0xfb10443c>
811244b4:	8080030b 	ldhu	r2,12(r16)
811244b8:	10800054 	ori	r2,r2,1
811244bc:	8080030d 	sth	r2,12(r16)
811244c0:	003fde06 	br	8112443c <__reset+0xfb10443c>
811244c4:	8080030b 	ldhu	r2,12(r16)
811244c8:	10c0800c 	andi	r3,r2,512
811244cc:	183fdb1e 	bne	r3,zero,8112443c <__reset+0xfb10443c>
811244d0:	10800094 	ori	r2,r2,2
811244d4:	80c010c4 	addi	r3,r16,67
811244d8:	8080030d 	sth	r2,12(r16)
811244dc:	00800044 	movi	r2,1
811244e0:	80c00015 	stw	r3,0(r16)
811244e4:	80c00415 	stw	r3,16(r16)
811244e8:	80800515 	stw	r2,20(r16)
811244ec:	003fd306 	br	8112443c <__reset+0xfb10443c>
811244f0:	04810004 	movi	r18,1024
811244f4:	003fc306 	br	81124404 <__reset+0xfb104404>
811244f8:	0027883a 	mov	r19,zero
811244fc:	04810004 	movi	r18,1024
81124500:	003fc006 	br	81124404 <__reset+0xfb104404>

81124504 <_malloc_r>:
81124504:	defff504 	addi	sp,sp,-44
81124508:	de00012e 	bgeu	sp,et,81124510 <_malloc_r+0xc>
8112450c:	003b68fa 	trap	3
81124510:	288002c4 	addi	r2,r5,11
81124514:	dc800315 	stw	r18,12(sp)
81124518:	dfc00a15 	stw	ra,40(sp)
8112451c:	df000915 	stw	fp,36(sp)
81124520:	ddc00815 	stw	r23,32(sp)
81124524:	dd800715 	stw	r22,28(sp)
81124528:	dd400615 	stw	r21,24(sp)
8112452c:	dd000515 	stw	r20,20(sp)
81124530:	dcc00415 	stw	r19,16(sp)
81124534:	dc400215 	stw	r17,8(sp)
81124538:	dc000115 	stw	r16,4(sp)
8112453c:	00c00584 	movi	r3,22
81124540:	2025883a 	mov	r18,r4
81124544:	18807f2e 	bgeu	r3,r2,81124744 <_malloc_r+0x240>
81124548:	047ffe04 	movi	r17,-8
8112454c:	1462703a 	and	r17,r2,r17
81124550:	8800a316 	blt	r17,zero,811247e0 <_malloc_r+0x2dc>
81124554:	8940a236 	bltu	r17,r5,811247e0 <_malloc_r+0x2dc>
81124558:	1130b340 	call	81130b34 <__malloc_lock>
8112455c:	00807dc4 	movi	r2,503
81124560:	1441e92e 	bgeu	r2,r17,81124d08 <_malloc_r+0x804>
81124564:	8804d27a 	srli	r2,r17,9
81124568:	1000a126 	beq	r2,zero,811247f0 <_malloc_r+0x2ec>
8112456c:	00c00104 	movi	r3,4
81124570:	18811e36 	bltu	r3,r2,811249ec <_malloc_r+0x4e8>
81124574:	8804d1ba 	srli	r2,r17,6
81124578:	12000e44 	addi	r8,r2,57
8112457c:	11c00e04 	addi	r7,r2,56
81124580:	4209883a 	add	r4,r8,r8
81124584:	04e04534 	movhi	r19,33044
81124588:	2109883a 	add	r4,r4,r4
8112458c:	9cd7eb04 	addi	r19,r19,24492
81124590:	2109883a 	add	r4,r4,r4
81124594:	9909883a 	add	r4,r19,r4
81124598:	24000117 	ldw	r16,4(r4)
8112459c:	213ffe04 	addi	r4,r4,-8
811245a0:	24009726 	beq	r4,r16,81124800 <_malloc_r+0x2fc>
811245a4:	80800117 	ldw	r2,4(r16)
811245a8:	01bfff04 	movi	r6,-4
811245ac:	014003c4 	movi	r5,15
811245b0:	1184703a 	and	r2,r2,r6
811245b4:	1447c83a 	sub	r3,r2,r17
811245b8:	28c00716 	blt	r5,r3,811245d8 <_malloc_r+0xd4>
811245bc:	1800920e 	bge	r3,zero,81124808 <_malloc_r+0x304>
811245c0:	84000317 	ldw	r16,12(r16)
811245c4:	24008e26 	beq	r4,r16,81124800 <_malloc_r+0x2fc>
811245c8:	80800117 	ldw	r2,4(r16)
811245cc:	1184703a 	and	r2,r2,r6
811245d0:	1447c83a 	sub	r3,r2,r17
811245d4:	28fff90e 	bge	r5,r3,811245bc <__reset+0xfb1045bc>
811245d8:	3809883a 	mov	r4,r7
811245dc:	01a04534 	movhi	r6,33044
811245e0:	9c000417 	ldw	r16,16(r19)
811245e4:	3197eb04 	addi	r6,r6,24492
811245e8:	32000204 	addi	r8,r6,8
811245ec:	82013426 	beq	r16,r8,81124ac0 <_malloc_r+0x5bc>
811245f0:	80c00117 	ldw	r3,4(r16)
811245f4:	00bfff04 	movi	r2,-4
811245f8:	188e703a 	and	r7,r3,r2
811245fc:	3c45c83a 	sub	r2,r7,r17
81124600:	00c003c4 	movi	r3,15
81124604:	18811f16 	blt	r3,r2,81124a84 <_malloc_r+0x580>
81124608:	32000515 	stw	r8,20(r6)
8112460c:	32000415 	stw	r8,16(r6)
81124610:	10007f0e 	bge	r2,zero,81124810 <_malloc_r+0x30c>
81124614:	00807fc4 	movi	r2,511
81124618:	11c0fd36 	bltu	r2,r7,81124a10 <_malloc_r+0x50c>
8112461c:	3806d0fa 	srli	r3,r7,3
81124620:	01c00044 	movi	r7,1
81124624:	30800117 	ldw	r2,4(r6)
81124628:	19400044 	addi	r5,r3,1
8112462c:	294b883a 	add	r5,r5,r5
81124630:	1807d0ba 	srai	r3,r3,2
81124634:	294b883a 	add	r5,r5,r5
81124638:	294b883a 	add	r5,r5,r5
8112463c:	298b883a 	add	r5,r5,r6
81124640:	38c6983a 	sll	r3,r7,r3
81124644:	29c00017 	ldw	r7,0(r5)
81124648:	2a7ffe04 	addi	r9,r5,-8
8112464c:	1886b03a 	or	r3,r3,r2
81124650:	82400315 	stw	r9,12(r16)
81124654:	81c00215 	stw	r7,8(r16)
81124658:	30c00115 	stw	r3,4(r6)
8112465c:	2c000015 	stw	r16,0(r5)
81124660:	3c000315 	stw	r16,12(r7)
81124664:	2005d0ba 	srai	r2,r4,2
81124668:	01400044 	movi	r5,1
8112466c:	288a983a 	sll	r5,r5,r2
81124670:	19406f36 	bltu	r3,r5,81124830 <_malloc_r+0x32c>
81124674:	28c4703a 	and	r2,r5,r3
81124678:	10000a1e 	bne	r2,zero,811246a4 <_malloc_r+0x1a0>
8112467c:	00bfff04 	movi	r2,-4
81124680:	294b883a 	add	r5,r5,r5
81124684:	2088703a 	and	r4,r4,r2
81124688:	28c4703a 	and	r2,r5,r3
8112468c:	21000104 	addi	r4,r4,4
81124690:	1000041e 	bne	r2,zero,811246a4 <_malloc_r+0x1a0>
81124694:	294b883a 	add	r5,r5,r5
81124698:	28c4703a 	and	r2,r5,r3
8112469c:	21000104 	addi	r4,r4,4
811246a0:	103ffc26 	beq	r2,zero,81124694 <__reset+0xfb104694>
811246a4:	02bfff04 	movi	r10,-4
811246a8:	024003c4 	movi	r9,15
811246ac:	21800044 	addi	r6,r4,1
811246b0:	318d883a 	add	r6,r6,r6
811246b4:	318d883a 	add	r6,r6,r6
811246b8:	318d883a 	add	r6,r6,r6
811246bc:	998d883a 	add	r6,r19,r6
811246c0:	333ffe04 	addi	r12,r6,-8
811246c4:	2017883a 	mov	r11,r4
811246c8:	31800104 	addi	r6,r6,4
811246cc:	34000017 	ldw	r16,0(r6)
811246d0:	31fffd04 	addi	r7,r6,-12
811246d4:	81c0041e 	bne	r16,r7,811246e8 <_malloc_r+0x1e4>
811246d8:	0000fb06 	br	81124ac8 <_malloc_r+0x5c4>
811246dc:	1801030e 	bge	r3,zero,81124aec <_malloc_r+0x5e8>
811246e0:	84000317 	ldw	r16,12(r16)
811246e4:	81c0f826 	beq	r16,r7,81124ac8 <_malloc_r+0x5c4>
811246e8:	80800117 	ldw	r2,4(r16)
811246ec:	1284703a 	and	r2,r2,r10
811246f0:	1447c83a 	sub	r3,r2,r17
811246f4:	48fff90e 	bge	r9,r3,811246dc <__reset+0xfb1046dc>
811246f8:	80800317 	ldw	r2,12(r16)
811246fc:	81000217 	ldw	r4,8(r16)
81124700:	89400054 	ori	r5,r17,1
81124704:	81400115 	stw	r5,4(r16)
81124708:	20800315 	stw	r2,12(r4)
8112470c:	11000215 	stw	r4,8(r2)
81124710:	8463883a 	add	r17,r16,r17
81124714:	9c400515 	stw	r17,20(r19)
81124718:	9c400415 	stw	r17,16(r19)
8112471c:	18800054 	ori	r2,r3,1
81124720:	88800115 	stw	r2,4(r17)
81124724:	8a000315 	stw	r8,12(r17)
81124728:	8a000215 	stw	r8,8(r17)
8112472c:	88e3883a 	add	r17,r17,r3
81124730:	88c00015 	stw	r3,0(r17)
81124734:	9009883a 	mov	r4,r18
81124738:	1130c5c0 	call	81130c5c <__malloc_unlock>
8112473c:	80800204 	addi	r2,r16,8
81124740:	00001b06 	br	811247b0 <_malloc_r+0x2ac>
81124744:	04400404 	movi	r17,16
81124748:	89402536 	bltu	r17,r5,811247e0 <_malloc_r+0x2dc>
8112474c:	1130b340 	call	81130b34 <__malloc_lock>
81124750:	00800184 	movi	r2,6
81124754:	01000084 	movi	r4,2
81124758:	04e04534 	movhi	r19,33044
8112475c:	1085883a 	add	r2,r2,r2
81124760:	9cd7eb04 	addi	r19,r19,24492
81124764:	1085883a 	add	r2,r2,r2
81124768:	9885883a 	add	r2,r19,r2
8112476c:	14000117 	ldw	r16,4(r2)
81124770:	10fffe04 	addi	r3,r2,-8
81124774:	80c0d926 	beq	r16,r3,81124adc <_malloc_r+0x5d8>
81124778:	80c00117 	ldw	r3,4(r16)
8112477c:	81000317 	ldw	r4,12(r16)
81124780:	00bfff04 	movi	r2,-4
81124784:	1884703a 	and	r2,r3,r2
81124788:	81400217 	ldw	r5,8(r16)
8112478c:	8085883a 	add	r2,r16,r2
81124790:	10c00117 	ldw	r3,4(r2)
81124794:	29000315 	stw	r4,12(r5)
81124798:	21400215 	stw	r5,8(r4)
8112479c:	18c00054 	ori	r3,r3,1
811247a0:	10c00115 	stw	r3,4(r2)
811247a4:	9009883a 	mov	r4,r18
811247a8:	1130c5c0 	call	81130c5c <__malloc_unlock>
811247ac:	80800204 	addi	r2,r16,8
811247b0:	dfc00a17 	ldw	ra,40(sp)
811247b4:	df000917 	ldw	fp,36(sp)
811247b8:	ddc00817 	ldw	r23,32(sp)
811247bc:	dd800717 	ldw	r22,28(sp)
811247c0:	dd400617 	ldw	r21,24(sp)
811247c4:	dd000517 	ldw	r20,20(sp)
811247c8:	dcc00417 	ldw	r19,16(sp)
811247cc:	dc800317 	ldw	r18,12(sp)
811247d0:	dc400217 	ldw	r17,8(sp)
811247d4:	dc000117 	ldw	r16,4(sp)
811247d8:	dec00b04 	addi	sp,sp,44
811247dc:	f800283a 	ret
811247e0:	00800304 	movi	r2,12
811247e4:	90800015 	stw	r2,0(r18)
811247e8:	0005883a 	mov	r2,zero
811247ec:	003ff006 	br	811247b0 <__reset+0xfb1047b0>
811247f0:	01002004 	movi	r4,128
811247f4:	02001004 	movi	r8,64
811247f8:	01c00fc4 	movi	r7,63
811247fc:	003f6106 	br	81124584 <__reset+0xfb104584>
81124800:	4009883a 	mov	r4,r8
81124804:	003f7506 	br	811245dc <__reset+0xfb1045dc>
81124808:	81000317 	ldw	r4,12(r16)
8112480c:	003fde06 	br	81124788 <__reset+0xfb104788>
81124810:	81c5883a 	add	r2,r16,r7
81124814:	11400117 	ldw	r5,4(r2)
81124818:	9009883a 	mov	r4,r18
8112481c:	29400054 	ori	r5,r5,1
81124820:	11400115 	stw	r5,4(r2)
81124824:	1130c5c0 	call	81130c5c <__malloc_unlock>
81124828:	80800204 	addi	r2,r16,8
8112482c:	003fe006 	br	811247b0 <__reset+0xfb1047b0>
81124830:	9c000217 	ldw	r16,8(r19)
81124834:	00bfff04 	movi	r2,-4
81124838:	85800117 	ldw	r22,4(r16)
8112483c:	b0ac703a 	and	r22,r22,r2
81124840:	b4400336 	bltu	r22,r17,81124850 <_malloc_r+0x34c>
81124844:	b445c83a 	sub	r2,r22,r17
81124848:	00c003c4 	movi	r3,15
8112484c:	18805d16 	blt	r3,r2,811249c4 <_malloc_r+0x4c0>
81124850:	05e04534 	movhi	r23,33044
81124854:	00a04534 	movhi	r2,33044
81124858:	109e8604 	addi	r2,r2,31256
8112485c:	bdde1104 	addi	r23,r23,30788
81124860:	15400017 	ldw	r21,0(r2)
81124864:	b8c00017 	ldw	r3,0(r23)
81124868:	00bfffc4 	movi	r2,-1
8112486c:	858d883a 	add	r6,r16,r22
81124870:	8d6b883a 	add	r21,r17,r21
81124874:	1880ea26 	beq	r3,r2,81124c20 <_malloc_r+0x71c>
81124878:	ad4403c4 	addi	r21,r21,4111
8112487c:	00bc0004 	movi	r2,-4096
81124880:	a8aa703a 	and	r21,r21,r2
81124884:	a80b883a 	mov	r5,r21
81124888:	9009883a 	mov	r4,r18
8112488c:	d9800015 	stw	r6,0(sp)
81124890:	11269d00 	call	811269d0 <_sbrk_r>
81124894:	1029883a 	mov	r20,r2
81124898:	00bfffc4 	movi	r2,-1
8112489c:	d9800017 	ldw	r6,0(sp)
811248a0:	a080e826 	beq	r20,r2,81124c44 <_malloc_r+0x740>
811248a4:	a180a636 	bltu	r20,r6,81124b40 <_malloc_r+0x63c>
811248a8:	07204534 	movhi	fp,33044
811248ac:	e71f1104 	addi	fp,fp,31812
811248b0:	e0800017 	ldw	r2,0(fp)
811248b4:	a887883a 	add	r3,r21,r2
811248b8:	e0c00015 	stw	r3,0(fp)
811248bc:	3500e626 	beq	r6,r20,81124c58 <_malloc_r+0x754>
811248c0:	b9000017 	ldw	r4,0(r23)
811248c4:	00bfffc4 	movi	r2,-1
811248c8:	2080ee26 	beq	r4,r2,81124c84 <_malloc_r+0x780>
811248cc:	a185c83a 	sub	r2,r20,r6
811248d0:	10c5883a 	add	r2,r2,r3
811248d4:	e0800015 	stw	r2,0(fp)
811248d8:	a0c001cc 	andi	r3,r20,7
811248dc:	1800bc26 	beq	r3,zero,81124bd0 <_malloc_r+0x6cc>
811248e0:	a0e9c83a 	sub	r20,r20,r3
811248e4:	00840204 	movi	r2,4104
811248e8:	a5000204 	addi	r20,r20,8
811248ec:	10c7c83a 	sub	r3,r2,r3
811248f0:	a545883a 	add	r2,r20,r21
811248f4:	1083ffcc 	andi	r2,r2,4095
811248f8:	18abc83a 	sub	r21,r3,r2
811248fc:	a80b883a 	mov	r5,r21
81124900:	9009883a 	mov	r4,r18
81124904:	11269d00 	call	811269d0 <_sbrk_r>
81124908:	00ffffc4 	movi	r3,-1
8112490c:	10c0e126 	beq	r2,r3,81124c94 <_malloc_r+0x790>
81124910:	1505c83a 	sub	r2,r2,r20
81124914:	1545883a 	add	r2,r2,r21
81124918:	10800054 	ori	r2,r2,1
8112491c:	e0c00017 	ldw	r3,0(fp)
81124920:	9d000215 	stw	r20,8(r19)
81124924:	a0800115 	stw	r2,4(r20)
81124928:	a8c7883a 	add	r3,r21,r3
8112492c:	e0c00015 	stw	r3,0(fp)
81124930:	84c00e26 	beq	r16,r19,8112496c <_malloc_r+0x468>
81124934:	018003c4 	movi	r6,15
81124938:	3580a72e 	bgeu	r6,r22,81124bd8 <_malloc_r+0x6d4>
8112493c:	81400117 	ldw	r5,4(r16)
81124940:	013ffe04 	movi	r4,-8
81124944:	b0bffd04 	addi	r2,r22,-12
81124948:	1104703a 	and	r2,r2,r4
8112494c:	2900004c 	andi	r4,r5,1
81124950:	2088b03a 	or	r4,r4,r2
81124954:	81000115 	stw	r4,4(r16)
81124958:	01400144 	movi	r5,5
8112495c:	8089883a 	add	r4,r16,r2
81124960:	21400115 	stw	r5,4(r4)
81124964:	21400215 	stw	r5,8(r4)
81124968:	3080cd36 	bltu	r6,r2,81124ca0 <_malloc_r+0x79c>
8112496c:	00a04534 	movhi	r2,33044
81124970:	109e8504 	addi	r2,r2,31252
81124974:	11000017 	ldw	r4,0(r2)
81124978:	20c0012e 	bgeu	r4,r3,81124980 <_malloc_r+0x47c>
8112497c:	10c00015 	stw	r3,0(r2)
81124980:	00a04534 	movhi	r2,33044
81124984:	109e8404 	addi	r2,r2,31248
81124988:	11000017 	ldw	r4,0(r2)
8112498c:	9c000217 	ldw	r16,8(r19)
81124990:	20c0012e 	bgeu	r4,r3,81124998 <_malloc_r+0x494>
81124994:	10c00015 	stw	r3,0(r2)
81124998:	80c00117 	ldw	r3,4(r16)
8112499c:	00bfff04 	movi	r2,-4
811249a0:	1886703a 	and	r3,r3,r2
811249a4:	1c45c83a 	sub	r2,r3,r17
811249a8:	1c400236 	bltu	r3,r17,811249b4 <_malloc_r+0x4b0>
811249ac:	00c003c4 	movi	r3,15
811249b0:	18800416 	blt	r3,r2,811249c4 <_malloc_r+0x4c0>
811249b4:	9009883a 	mov	r4,r18
811249b8:	1130c5c0 	call	81130c5c <__malloc_unlock>
811249bc:	0005883a 	mov	r2,zero
811249c0:	003f7b06 	br	811247b0 <__reset+0xfb1047b0>
811249c4:	88c00054 	ori	r3,r17,1
811249c8:	80c00115 	stw	r3,4(r16)
811249cc:	8463883a 	add	r17,r16,r17
811249d0:	10800054 	ori	r2,r2,1
811249d4:	9c400215 	stw	r17,8(r19)
811249d8:	88800115 	stw	r2,4(r17)
811249dc:	9009883a 	mov	r4,r18
811249e0:	1130c5c0 	call	81130c5c <__malloc_unlock>
811249e4:	80800204 	addi	r2,r16,8
811249e8:	003f7106 	br	811247b0 <__reset+0xfb1047b0>
811249ec:	00c00504 	movi	r3,20
811249f0:	18804a2e 	bgeu	r3,r2,81124b1c <_malloc_r+0x618>
811249f4:	00c01504 	movi	r3,84
811249f8:	18806e36 	bltu	r3,r2,81124bb4 <_malloc_r+0x6b0>
811249fc:	8804d33a 	srli	r2,r17,12
81124a00:	12001bc4 	addi	r8,r2,111
81124a04:	11c01b84 	addi	r7,r2,110
81124a08:	4209883a 	add	r4,r8,r8
81124a0c:	003edd06 	br	81124584 <__reset+0xfb104584>
81124a10:	3804d27a 	srli	r2,r7,9
81124a14:	00c00104 	movi	r3,4
81124a18:	1880442e 	bgeu	r3,r2,81124b2c <_malloc_r+0x628>
81124a1c:	00c00504 	movi	r3,20
81124a20:	18808136 	bltu	r3,r2,81124c28 <_malloc_r+0x724>
81124a24:	11401704 	addi	r5,r2,92
81124a28:	10c016c4 	addi	r3,r2,91
81124a2c:	294b883a 	add	r5,r5,r5
81124a30:	294b883a 	add	r5,r5,r5
81124a34:	294b883a 	add	r5,r5,r5
81124a38:	994b883a 	add	r5,r19,r5
81124a3c:	28800017 	ldw	r2,0(r5)
81124a40:	01a04534 	movhi	r6,33044
81124a44:	297ffe04 	addi	r5,r5,-8
81124a48:	3197eb04 	addi	r6,r6,24492
81124a4c:	28806526 	beq	r5,r2,81124be4 <_malloc_r+0x6e0>
81124a50:	01bfff04 	movi	r6,-4
81124a54:	10c00117 	ldw	r3,4(r2)
81124a58:	1986703a 	and	r3,r3,r6
81124a5c:	38c0022e 	bgeu	r7,r3,81124a68 <_malloc_r+0x564>
81124a60:	10800217 	ldw	r2,8(r2)
81124a64:	28bffb1e 	bne	r5,r2,81124a54 <__reset+0xfb104a54>
81124a68:	11400317 	ldw	r5,12(r2)
81124a6c:	98c00117 	ldw	r3,4(r19)
81124a70:	81400315 	stw	r5,12(r16)
81124a74:	80800215 	stw	r2,8(r16)
81124a78:	2c000215 	stw	r16,8(r5)
81124a7c:	14000315 	stw	r16,12(r2)
81124a80:	003ef806 	br	81124664 <__reset+0xfb104664>
81124a84:	88c00054 	ori	r3,r17,1
81124a88:	80c00115 	stw	r3,4(r16)
81124a8c:	8463883a 	add	r17,r16,r17
81124a90:	34400515 	stw	r17,20(r6)
81124a94:	34400415 	stw	r17,16(r6)
81124a98:	10c00054 	ori	r3,r2,1
81124a9c:	8a000315 	stw	r8,12(r17)
81124aa0:	8a000215 	stw	r8,8(r17)
81124aa4:	88c00115 	stw	r3,4(r17)
81124aa8:	88a3883a 	add	r17,r17,r2
81124aac:	88800015 	stw	r2,0(r17)
81124ab0:	9009883a 	mov	r4,r18
81124ab4:	1130c5c0 	call	81130c5c <__malloc_unlock>
81124ab8:	80800204 	addi	r2,r16,8
81124abc:	003f3c06 	br	811247b0 <__reset+0xfb1047b0>
81124ac0:	30c00117 	ldw	r3,4(r6)
81124ac4:	003ee706 	br	81124664 <__reset+0xfb104664>
81124ac8:	5ac00044 	addi	r11,r11,1
81124acc:	588000cc 	andi	r2,r11,3
81124ad0:	31800204 	addi	r6,r6,8
81124ad4:	103efd1e 	bne	r2,zero,811246cc <__reset+0xfb1046cc>
81124ad8:	00002406 	br	81124b6c <_malloc_r+0x668>
81124adc:	14000317 	ldw	r16,12(r2)
81124ae0:	143f251e 	bne	r2,r16,81124778 <__reset+0xfb104778>
81124ae4:	21000084 	addi	r4,r4,2
81124ae8:	003ebc06 	br	811245dc <__reset+0xfb1045dc>
81124aec:	8085883a 	add	r2,r16,r2
81124af0:	10c00117 	ldw	r3,4(r2)
81124af4:	81000317 	ldw	r4,12(r16)
81124af8:	81400217 	ldw	r5,8(r16)
81124afc:	18c00054 	ori	r3,r3,1
81124b00:	10c00115 	stw	r3,4(r2)
81124b04:	29000315 	stw	r4,12(r5)
81124b08:	21400215 	stw	r5,8(r4)
81124b0c:	9009883a 	mov	r4,r18
81124b10:	1130c5c0 	call	81130c5c <__malloc_unlock>
81124b14:	80800204 	addi	r2,r16,8
81124b18:	003f2506 	br	811247b0 <__reset+0xfb1047b0>
81124b1c:	12001704 	addi	r8,r2,92
81124b20:	11c016c4 	addi	r7,r2,91
81124b24:	4209883a 	add	r4,r8,r8
81124b28:	003e9606 	br	81124584 <__reset+0xfb104584>
81124b2c:	3804d1ba 	srli	r2,r7,6
81124b30:	11400e44 	addi	r5,r2,57
81124b34:	10c00e04 	addi	r3,r2,56
81124b38:	294b883a 	add	r5,r5,r5
81124b3c:	003fbc06 	br	81124a30 <__reset+0xfb104a30>
81124b40:	84ff5926 	beq	r16,r19,811248a8 <__reset+0xfb1048a8>
81124b44:	00a04534 	movhi	r2,33044
81124b48:	1097eb04 	addi	r2,r2,24492
81124b4c:	14000217 	ldw	r16,8(r2)
81124b50:	00bfff04 	movi	r2,-4
81124b54:	80c00117 	ldw	r3,4(r16)
81124b58:	1886703a 	and	r3,r3,r2
81124b5c:	003f9106 	br	811249a4 <__reset+0xfb1049a4>
81124b60:	60800217 	ldw	r2,8(r12)
81124b64:	213fffc4 	addi	r4,r4,-1
81124b68:	1300651e 	bne	r2,r12,81124d00 <_malloc_r+0x7fc>
81124b6c:	208000cc 	andi	r2,r4,3
81124b70:	633ffe04 	addi	r12,r12,-8
81124b74:	103ffa1e 	bne	r2,zero,81124b60 <__reset+0xfb104b60>
81124b78:	98800117 	ldw	r2,4(r19)
81124b7c:	0146303a 	nor	r3,zero,r5
81124b80:	1884703a 	and	r2,r3,r2
81124b84:	98800115 	stw	r2,4(r19)
81124b88:	294b883a 	add	r5,r5,r5
81124b8c:	117f2836 	bltu	r2,r5,81124830 <__reset+0xfb104830>
81124b90:	283f2726 	beq	r5,zero,81124830 <__reset+0xfb104830>
81124b94:	2886703a 	and	r3,r5,r2
81124b98:	5809883a 	mov	r4,r11
81124b9c:	183ec31e 	bne	r3,zero,811246ac <__reset+0xfb1046ac>
81124ba0:	294b883a 	add	r5,r5,r5
81124ba4:	2886703a 	and	r3,r5,r2
81124ba8:	21000104 	addi	r4,r4,4
81124bac:	183ffc26 	beq	r3,zero,81124ba0 <__reset+0xfb104ba0>
81124bb0:	003ebe06 	br	811246ac <__reset+0xfb1046ac>
81124bb4:	00c05504 	movi	r3,340
81124bb8:	18801236 	bltu	r3,r2,81124c04 <_malloc_r+0x700>
81124bbc:	8804d3fa 	srli	r2,r17,15
81124bc0:	12001e04 	addi	r8,r2,120
81124bc4:	11c01dc4 	addi	r7,r2,119
81124bc8:	4209883a 	add	r4,r8,r8
81124bcc:	003e6d06 	br	81124584 <__reset+0xfb104584>
81124bd0:	00c40004 	movi	r3,4096
81124bd4:	003f4606 	br	811248f0 <__reset+0xfb1048f0>
81124bd8:	00800044 	movi	r2,1
81124bdc:	a0800115 	stw	r2,4(r20)
81124be0:	003f7406 	br	811249b4 <__reset+0xfb1049b4>
81124be4:	1805d0ba 	srai	r2,r3,2
81124be8:	01c00044 	movi	r7,1
81124bec:	30c00117 	ldw	r3,4(r6)
81124bf0:	388e983a 	sll	r7,r7,r2
81124bf4:	2805883a 	mov	r2,r5
81124bf8:	38c6b03a 	or	r3,r7,r3
81124bfc:	30c00115 	stw	r3,4(r6)
81124c00:	003f9b06 	br	81124a70 <__reset+0xfb104a70>
81124c04:	00c15504 	movi	r3,1364
81124c08:	18801a36 	bltu	r3,r2,81124c74 <_malloc_r+0x770>
81124c0c:	8804d4ba 	srli	r2,r17,18
81124c10:	12001f44 	addi	r8,r2,125
81124c14:	11c01f04 	addi	r7,r2,124
81124c18:	4209883a 	add	r4,r8,r8
81124c1c:	003e5906 	br	81124584 <__reset+0xfb104584>
81124c20:	ad400404 	addi	r21,r21,16
81124c24:	003f1706 	br	81124884 <__reset+0xfb104884>
81124c28:	00c01504 	movi	r3,84
81124c2c:	18802336 	bltu	r3,r2,81124cbc <_malloc_r+0x7b8>
81124c30:	3804d33a 	srli	r2,r7,12
81124c34:	11401bc4 	addi	r5,r2,111
81124c38:	10c01b84 	addi	r3,r2,110
81124c3c:	294b883a 	add	r5,r5,r5
81124c40:	003f7b06 	br	81124a30 <__reset+0xfb104a30>
81124c44:	9c000217 	ldw	r16,8(r19)
81124c48:	00bfff04 	movi	r2,-4
81124c4c:	80c00117 	ldw	r3,4(r16)
81124c50:	1886703a 	and	r3,r3,r2
81124c54:	003f5306 	br	811249a4 <__reset+0xfb1049a4>
81124c58:	3083ffcc 	andi	r2,r6,4095
81124c5c:	103f181e 	bne	r2,zero,811248c0 <__reset+0xfb1048c0>
81124c60:	99000217 	ldw	r4,8(r19)
81124c64:	b545883a 	add	r2,r22,r21
81124c68:	10800054 	ori	r2,r2,1
81124c6c:	20800115 	stw	r2,4(r4)
81124c70:	003f3e06 	br	8112496c <__reset+0xfb10496c>
81124c74:	01003f84 	movi	r4,254
81124c78:	02001fc4 	movi	r8,127
81124c7c:	01c01f84 	movi	r7,126
81124c80:	003e4006 	br	81124584 <__reset+0xfb104584>
81124c84:	00a04534 	movhi	r2,33044
81124c88:	109e1104 	addi	r2,r2,30788
81124c8c:	15000015 	stw	r20,0(r2)
81124c90:	003f1106 	br	811248d8 <__reset+0xfb1048d8>
81124c94:	00800044 	movi	r2,1
81124c98:	002b883a 	mov	r21,zero
81124c9c:	003f1f06 	br	8112491c <__reset+0xfb10491c>
81124ca0:	81400204 	addi	r5,r16,8
81124ca4:	9009883a 	mov	r4,r18
81124ca8:	11238b80 	call	811238b8 <_free_r>
81124cac:	00a04534 	movhi	r2,33044
81124cb0:	109f1104 	addi	r2,r2,31812
81124cb4:	10c00017 	ldw	r3,0(r2)
81124cb8:	003f2c06 	br	8112496c <__reset+0xfb10496c>
81124cbc:	00c05504 	movi	r3,340
81124cc0:	18800536 	bltu	r3,r2,81124cd8 <_malloc_r+0x7d4>
81124cc4:	3804d3fa 	srli	r2,r7,15
81124cc8:	11401e04 	addi	r5,r2,120
81124ccc:	10c01dc4 	addi	r3,r2,119
81124cd0:	294b883a 	add	r5,r5,r5
81124cd4:	003f5606 	br	81124a30 <__reset+0xfb104a30>
81124cd8:	00c15504 	movi	r3,1364
81124cdc:	18800536 	bltu	r3,r2,81124cf4 <_malloc_r+0x7f0>
81124ce0:	3804d4ba 	srli	r2,r7,18
81124ce4:	11401f44 	addi	r5,r2,125
81124ce8:	10c01f04 	addi	r3,r2,124
81124cec:	294b883a 	add	r5,r5,r5
81124cf0:	003f4f06 	br	81124a30 <__reset+0xfb104a30>
81124cf4:	01403f84 	movi	r5,254
81124cf8:	00c01f84 	movi	r3,126
81124cfc:	003f4c06 	br	81124a30 <__reset+0xfb104a30>
81124d00:	98800117 	ldw	r2,4(r19)
81124d04:	003fa006 	br	81124b88 <__reset+0xfb104b88>
81124d08:	8808d0fa 	srli	r4,r17,3
81124d0c:	20800044 	addi	r2,r4,1
81124d10:	1085883a 	add	r2,r2,r2
81124d14:	003e9006 	br	81124758 <__reset+0xfb104758>

81124d18 <_mbrtowc_r>:
81124d18:	defff704 	addi	sp,sp,-36
81124d1c:	00a04534 	movhi	r2,33044
81124d20:	de00012e 	bgeu	sp,et,81124d28 <_mbrtowc_r+0x10>
81124d24:	003b68fa 	trap	3
81124d28:	109e1304 	addi	r2,r2,30796
81124d2c:	dc800715 	stw	r18,28(sp)
81124d30:	dc400615 	stw	r17,24(sp)
81124d34:	dc000515 	stw	r16,20(sp)
81124d38:	dfc00815 	stw	ra,32(sp)
81124d3c:	2021883a 	mov	r16,r4
81124d40:	dc400917 	ldw	r17,36(sp)
81124d44:	14800017 	ldw	r18,0(r2)
81124d48:	30001626 	beq	r6,zero,81124da4 <_mbrtowc_r+0x8c>
81124d4c:	d9400215 	stw	r5,8(sp)
81124d50:	d9800315 	stw	r6,12(sp)
81124d54:	d9c00415 	stw	r7,16(sp)
81124d58:	11242e00 	call	811242e0 <__locale_charset>
81124d5c:	d9c00417 	ldw	r7,16(sp)
81124d60:	d9800317 	ldw	r6,12(sp)
81124d64:	d9400217 	ldw	r5,8(sp)
81124d68:	d8800015 	stw	r2,0(sp)
81124d6c:	dc400115 	stw	r17,4(sp)
81124d70:	8009883a 	mov	r4,r16
81124d74:	903ee83a 	callr	r18
81124d78:	00ffffc4 	movi	r3,-1
81124d7c:	10c0031e 	bne	r2,r3,81124d8c <_mbrtowc_r+0x74>
81124d80:	88000015 	stw	zero,0(r17)
81124d84:	00c02284 	movi	r3,138
81124d88:	80c00015 	stw	r3,0(r16)
81124d8c:	dfc00817 	ldw	ra,32(sp)
81124d90:	dc800717 	ldw	r18,28(sp)
81124d94:	dc400617 	ldw	r17,24(sp)
81124d98:	dc000517 	ldw	r16,20(sp)
81124d9c:	dec00904 	addi	sp,sp,36
81124da0:	f800283a 	ret
81124da4:	11242e00 	call	811242e0 <__locale_charset>
81124da8:	01a04534 	movhi	r6,33044
81124dac:	31943e04 	addi	r6,r6,20728
81124db0:	dc400115 	stw	r17,4(sp)
81124db4:	d8800015 	stw	r2,0(sp)
81124db8:	01c00044 	movi	r7,1
81124dbc:	000b883a 	mov	r5,zero
81124dc0:	8009883a 	mov	r4,r16
81124dc4:	903ee83a 	callr	r18
81124dc8:	003feb06 	br	81124d78 <__reset+0xfb104d78>

81124dcc <mbrtowc>:
81124dcc:	defff704 	addi	sp,sp,-36
81124dd0:	00a04534 	movhi	r2,33044
81124dd4:	de00012e 	bgeu	sp,et,81124ddc <mbrtowc+0x10>
81124dd8:	003b68fa 	trap	3
81124ddc:	109e0f04 	addi	r2,r2,30780
81124de0:	dc800415 	stw	r18,16(sp)
81124de4:	dc400315 	stw	r17,12(sp)
81124de8:	dfc00815 	stw	ra,32(sp)
81124dec:	dd400715 	stw	r21,28(sp)
81124df0:	dd000615 	stw	r20,24(sp)
81124df4:	dcc00515 	stw	r19,20(sp)
81124df8:	dc000215 	stw	r16,8(sp)
81124dfc:	3825883a 	mov	r18,r7
81124e00:	14400017 	ldw	r17,0(r2)
81124e04:	28001c26 	beq	r5,zero,81124e78 <mbrtowc+0xac>
81124e08:	00a04534 	movhi	r2,33044
81124e0c:	109e1304 	addi	r2,r2,30796
81124e10:	15400017 	ldw	r21,0(r2)
81124e14:	2821883a 	mov	r16,r5
81124e18:	2027883a 	mov	r19,r4
81124e1c:	3029883a 	mov	r20,r6
81124e20:	11242e00 	call	811242e0 <__locale_charset>
81124e24:	d8800015 	stw	r2,0(sp)
81124e28:	dc800115 	stw	r18,4(sp)
81124e2c:	a00f883a 	mov	r7,r20
81124e30:	800d883a 	mov	r6,r16
81124e34:	980b883a 	mov	r5,r19
81124e38:	8809883a 	mov	r4,r17
81124e3c:	a83ee83a 	callr	r21
81124e40:	00ffffc4 	movi	r3,-1
81124e44:	10c0031e 	bne	r2,r3,81124e54 <mbrtowc+0x88>
81124e48:	90000015 	stw	zero,0(r18)
81124e4c:	00c02284 	movi	r3,138
81124e50:	88c00015 	stw	r3,0(r17)
81124e54:	dfc00817 	ldw	ra,32(sp)
81124e58:	dd400717 	ldw	r21,28(sp)
81124e5c:	dd000617 	ldw	r20,24(sp)
81124e60:	dcc00517 	ldw	r19,20(sp)
81124e64:	dc800417 	ldw	r18,16(sp)
81124e68:	dc400317 	ldw	r17,12(sp)
81124e6c:	dc000217 	ldw	r16,8(sp)
81124e70:	dec00904 	addi	sp,sp,36
81124e74:	f800283a 	ret
81124e78:	00a04534 	movhi	r2,33044
81124e7c:	109e1304 	addi	r2,r2,30796
81124e80:	14000017 	ldw	r16,0(r2)
81124e84:	11242e00 	call	811242e0 <__locale_charset>
81124e88:	01a04534 	movhi	r6,33044
81124e8c:	31943e04 	addi	r6,r6,20728
81124e90:	dc800115 	stw	r18,4(sp)
81124e94:	d8800015 	stw	r2,0(sp)
81124e98:	01c00044 	movi	r7,1
81124e9c:	000b883a 	mov	r5,zero
81124ea0:	8809883a 	mov	r4,r17
81124ea4:	803ee83a 	callr	r16
81124ea8:	003fe506 	br	81124e40 <__reset+0xfb104e40>

81124eac <__ascii_mbtowc>:
81124eac:	deffff04 	addi	sp,sp,-4
81124eb0:	de00012e 	bgeu	sp,et,81124eb8 <__ascii_mbtowc+0xc>
81124eb4:	003b68fa 	trap	3
81124eb8:	28000826 	beq	r5,zero,81124edc <__ascii_mbtowc+0x30>
81124ebc:	30000926 	beq	r6,zero,81124ee4 <__ascii_mbtowc+0x38>
81124ec0:	38000b26 	beq	r7,zero,81124ef0 <__ascii_mbtowc+0x44>
81124ec4:	30800003 	ldbu	r2,0(r6)
81124ec8:	28800015 	stw	r2,0(r5)
81124ecc:	30800003 	ldbu	r2,0(r6)
81124ed0:	1004c03a 	cmpne	r2,r2,zero
81124ed4:	dec00104 	addi	sp,sp,4
81124ed8:	f800283a 	ret
81124edc:	d80b883a 	mov	r5,sp
81124ee0:	303ff71e 	bne	r6,zero,81124ec0 <__reset+0xfb104ec0>
81124ee4:	0005883a 	mov	r2,zero
81124ee8:	dec00104 	addi	sp,sp,4
81124eec:	f800283a 	ret
81124ef0:	00bfff84 	movi	r2,-2
81124ef4:	003ff706 	br	81124ed4 <__reset+0xfb104ed4>

81124ef8 <_mbtowc_r>:
81124ef8:	00a04534 	movhi	r2,33044
81124efc:	defff804 	addi	sp,sp,-32
81124f00:	109e1304 	addi	r2,r2,30796
81124f04:	de00012e 	bgeu	sp,et,81124f0c <_mbtowc_r+0x14>
81124f08:	003b68fa 	trap	3
81124f0c:	dfc00715 	stw	ra,28(sp)
81124f10:	dc000615 	stw	r16,24(sp)
81124f14:	14000017 	ldw	r16,0(r2)
81124f18:	d9000215 	stw	r4,8(sp)
81124f1c:	d9400315 	stw	r5,12(sp)
81124f20:	d9800415 	stw	r6,16(sp)
81124f24:	d9c00515 	stw	r7,20(sp)
81124f28:	11242e00 	call	811242e0 <__locale_charset>
81124f2c:	d8800015 	stw	r2,0(sp)
81124f30:	d8800817 	ldw	r2,32(sp)
81124f34:	d9c00517 	ldw	r7,20(sp)
81124f38:	d9800417 	ldw	r6,16(sp)
81124f3c:	d9400317 	ldw	r5,12(sp)
81124f40:	d9000217 	ldw	r4,8(sp)
81124f44:	d8800115 	stw	r2,4(sp)
81124f48:	803ee83a 	callr	r16
81124f4c:	dfc00717 	ldw	ra,28(sp)
81124f50:	dc000617 	ldw	r16,24(sp)
81124f54:	dec00804 	addi	sp,sp,32
81124f58:	f800283a 	ret

81124f5c <memchr>:
81124f5c:	208000cc 	andi	r2,r4,3
81124f60:	280f883a 	mov	r7,r5
81124f64:	10003426 	beq	r2,zero,81125038 <memchr+0xdc>
81124f68:	30bfffc4 	addi	r2,r6,-1
81124f6c:	30001a26 	beq	r6,zero,81124fd8 <memchr+0x7c>
81124f70:	20c00003 	ldbu	r3,0(r4)
81124f74:	29803fcc 	andi	r6,r5,255
81124f78:	30c0051e 	bne	r6,r3,81124f90 <memchr+0x34>
81124f7c:	00001806 	br	81124fe0 <memchr+0x84>
81124f80:	10001526 	beq	r2,zero,81124fd8 <memchr+0x7c>
81124f84:	20c00003 	ldbu	r3,0(r4)
81124f88:	10bfffc4 	addi	r2,r2,-1
81124f8c:	30c01426 	beq	r6,r3,81124fe0 <memchr+0x84>
81124f90:	21000044 	addi	r4,r4,1
81124f94:	20c000cc 	andi	r3,r4,3
81124f98:	183ff91e 	bne	r3,zero,81124f80 <__reset+0xfb104f80>
81124f9c:	020000c4 	movi	r8,3
81124fa0:	40801136 	bltu	r8,r2,81124fe8 <memchr+0x8c>
81124fa4:	10000c26 	beq	r2,zero,81124fd8 <memchr+0x7c>
81124fa8:	20c00003 	ldbu	r3,0(r4)
81124fac:	29403fcc 	andi	r5,r5,255
81124fb0:	28c00b26 	beq	r5,r3,81124fe0 <memchr+0x84>
81124fb4:	20c00044 	addi	r3,r4,1
81124fb8:	39803fcc 	andi	r6,r7,255
81124fbc:	2089883a 	add	r4,r4,r2
81124fc0:	00000306 	br	81124fd0 <memchr+0x74>
81124fc4:	18c00044 	addi	r3,r3,1
81124fc8:	197fffc3 	ldbu	r5,-1(r3)
81124fcc:	31400526 	beq	r6,r5,81124fe4 <memchr+0x88>
81124fd0:	1805883a 	mov	r2,r3
81124fd4:	20fffb1e 	bne	r4,r3,81124fc4 <__reset+0xfb104fc4>
81124fd8:	0005883a 	mov	r2,zero
81124fdc:	f800283a 	ret
81124fe0:	2005883a 	mov	r2,r4
81124fe4:	f800283a 	ret
81124fe8:	28c03fcc 	andi	r3,r5,255
81124fec:	1812923a 	slli	r9,r3,8
81124ff0:	02ffbff4 	movhi	r11,65279
81124ff4:	02a02074 	movhi	r10,32897
81124ff8:	48d2b03a 	or	r9,r9,r3
81124ffc:	4806943a 	slli	r3,r9,16
81125000:	5affbfc4 	addi	r11,r11,-257
81125004:	52a02004 	addi	r10,r10,-32640
81125008:	48d2b03a 	or	r9,r9,r3
8112500c:	20c00017 	ldw	r3,0(r4)
81125010:	48c6f03a 	xor	r3,r9,r3
81125014:	1acd883a 	add	r6,r3,r11
81125018:	00c6303a 	nor	r3,zero,r3
8112501c:	30c6703a 	and	r3,r6,r3
81125020:	1a86703a 	and	r3,r3,r10
81125024:	183fe01e 	bne	r3,zero,81124fa8 <__reset+0xfb104fa8>
81125028:	10bfff04 	addi	r2,r2,-4
8112502c:	21000104 	addi	r4,r4,4
81125030:	40bff636 	bltu	r8,r2,8112500c <__reset+0xfb10500c>
81125034:	003fdb06 	br	81124fa4 <__reset+0xfb104fa4>
81125038:	3005883a 	mov	r2,r6
8112503c:	003fd706 	br	81124f9c <__reset+0xfb104f9c>

81125040 <memmove>:
81125040:	2005883a 	mov	r2,r4
81125044:	29000b2e 	bgeu	r5,r4,81125074 <memmove+0x34>
81125048:	298f883a 	add	r7,r5,r6
8112504c:	21c0092e 	bgeu	r4,r7,81125074 <memmove+0x34>
81125050:	2187883a 	add	r3,r4,r6
81125054:	198bc83a 	sub	r5,r3,r6
81125058:	30004826 	beq	r6,zero,8112517c <memmove+0x13c>
8112505c:	39ffffc4 	addi	r7,r7,-1
81125060:	39000003 	ldbu	r4,0(r7)
81125064:	18ffffc4 	addi	r3,r3,-1
81125068:	19000005 	stb	r4,0(r3)
8112506c:	28fffb1e 	bne	r5,r3,8112505c <__reset+0xfb10505c>
81125070:	f800283a 	ret
81125074:	00c003c4 	movi	r3,15
81125078:	1980412e 	bgeu	r3,r6,81125180 <memmove+0x140>
8112507c:	2886b03a 	or	r3,r5,r2
81125080:	18c000cc 	andi	r3,r3,3
81125084:	1800401e 	bne	r3,zero,81125188 <memmove+0x148>
81125088:	33fffc04 	addi	r15,r6,-16
8112508c:	781ed13a 	srli	r15,r15,4
81125090:	28c00104 	addi	r3,r5,4
81125094:	13400104 	addi	r13,r2,4
81125098:	781c913a 	slli	r14,r15,4
8112509c:	2b000204 	addi	r12,r5,8
811250a0:	12c00204 	addi	r11,r2,8
811250a4:	73800504 	addi	r14,r14,20
811250a8:	2a800304 	addi	r10,r5,12
811250ac:	12400304 	addi	r9,r2,12
811250b0:	2b9d883a 	add	r14,r5,r14
811250b4:	2811883a 	mov	r8,r5
811250b8:	100f883a 	mov	r7,r2
811250bc:	41000017 	ldw	r4,0(r8)
811250c0:	39c00404 	addi	r7,r7,16
811250c4:	18c00404 	addi	r3,r3,16
811250c8:	393ffc15 	stw	r4,-16(r7)
811250cc:	193ffc17 	ldw	r4,-16(r3)
811250d0:	6b400404 	addi	r13,r13,16
811250d4:	5ac00404 	addi	r11,r11,16
811250d8:	693ffc15 	stw	r4,-16(r13)
811250dc:	61000017 	ldw	r4,0(r12)
811250e0:	4a400404 	addi	r9,r9,16
811250e4:	42000404 	addi	r8,r8,16
811250e8:	593ffc15 	stw	r4,-16(r11)
811250ec:	51000017 	ldw	r4,0(r10)
811250f0:	63000404 	addi	r12,r12,16
811250f4:	52800404 	addi	r10,r10,16
811250f8:	493ffc15 	stw	r4,-16(r9)
811250fc:	1bbfef1e 	bne	r3,r14,811250bc <__reset+0xfb1050bc>
81125100:	79000044 	addi	r4,r15,1
81125104:	2008913a 	slli	r4,r4,4
81125108:	328003cc 	andi	r10,r6,15
8112510c:	02c000c4 	movi	r11,3
81125110:	1107883a 	add	r3,r2,r4
81125114:	290b883a 	add	r5,r5,r4
81125118:	5a801e2e 	bgeu	r11,r10,81125194 <memmove+0x154>
8112511c:	1813883a 	mov	r9,r3
81125120:	2811883a 	mov	r8,r5
81125124:	500f883a 	mov	r7,r10
81125128:	41000017 	ldw	r4,0(r8)
8112512c:	4a400104 	addi	r9,r9,4
81125130:	39ffff04 	addi	r7,r7,-4
81125134:	493fff15 	stw	r4,-4(r9)
81125138:	42000104 	addi	r8,r8,4
8112513c:	59fffa36 	bltu	r11,r7,81125128 <__reset+0xfb105128>
81125140:	513fff04 	addi	r4,r10,-4
81125144:	2008d0ba 	srli	r4,r4,2
81125148:	318000cc 	andi	r6,r6,3
8112514c:	21000044 	addi	r4,r4,1
81125150:	2109883a 	add	r4,r4,r4
81125154:	2109883a 	add	r4,r4,r4
81125158:	1907883a 	add	r3,r3,r4
8112515c:	290b883a 	add	r5,r5,r4
81125160:	30000b26 	beq	r6,zero,81125190 <memmove+0x150>
81125164:	198d883a 	add	r6,r3,r6
81125168:	29c00003 	ldbu	r7,0(r5)
8112516c:	18c00044 	addi	r3,r3,1
81125170:	29400044 	addi	r5,r5,1
81125174:	19ffffc5 	stb	r7,-1(r3)
81125178:	19bffb1e 	bne	r3,r6,81125168 <__reset+0xfb105168>
8112517c:	f800283a 	ret
81125180:	1007883a 	mov	r3,r2
81125184:	003ff606 	br	81125160 <__reset+0xfb105160>
81125188:	1007883a 	mov	r3,r2
8112518c:	003ff506 	br	81125164 <__reset+0xfb105164>
81125190:	f800283a 	ret
81125194:	500d883a 	mov	r6,r10
81125198:	003ff106 	br	81125160 <__reset+0xfb105160>

8112519c <_Balloc>:
8112519c:	defffc04 	addi	sp,sp,-16
811251a0:	de00012e 	bgeu	sp,et,811251a8 <_Balloc+0xc>
811251a4:	003b68fa 	trap	3
811251a8:	20801317 	ldw	r2,76(r4)
811251ac:	dc400115 	stw	r17,4(sp)
811251b0:	dc000015 	stw	r16,0(sp)
811251b4:	dfc00315 	stw	ra,12(sp)
811251b8:	dc800215 	stw	r18,8(sp)
811251bc:	2023883a 	mov	r17,r4
811251c0:	2821883a 	mov	r16,r5
811251c4:	10000f26 	beq	r2,zero,81125204 <_Balloc+0x68>
811251c8:	8407883a 	add	r3,r16,r16
811251cc:	18c7883a 	add	r3,r3,r3
811251d0:	10c7883a 	add	r3,r2,r3
811251d4:	18800017 	ldw	r2,0(r3)
811251d8:	10001126 	beq	r2,zero,81125220 <_Balloc+0x84>
811251dc:	11000017 	ldw	r4,0(r2)
811251e0:	19000015 	stw	r4,0(r3)
811251e4:	10000415 	stw	zero,16(r2)
811251e8:	10000315 	stw	zero,12(r2)
811251ec:	dfc00317 	ldw	ra,12(sp)
811251f0:	dc800217 	ldw	r18,8(sp)
811251f4:	dc400117 	ldw	r17,4(sp)
811251f8:	dc000017 	ldw	r16,0(sp)
811251fc:	dec00404 	addi	sp,sp,16
81125200:	f800283a 	ret
81125204:	01800844 	movi	r6,33
81125208:	01400104 	movi	r5,4
8112520c:	112b7e00 	call	8112b7e0 <_calloc_r>
81125210:	88801315 	stw	r2,76(r17)
81125214:	103fec1e 	bne	r2,zero,811251c8 <__reset+0xfb1051c8>
81125218:	0005883a 	mov	r2,zero
8112521c:	003ff306 	br	811251ec <__reset+0xfb1051ec>
81125220:	01400044 	movi	r5,1
81125224:	2c24983a 	sll	r18,r5,r16
81125228:	8809883a 	mov	r4,r17
8112522c:	91800144 	addi	r6,r18,5
81125230:	318d883a 	add	r6,r6,r6
81125234:	318d883a 	add	r6,r6,r6
81125238:	112b7e00 	call	8112b7e0 <_calloc_r>
8112523c:	103ff626 	beq	r2,zero,81125218 <__reset+0xfb105218>
81125240:	14000115 	stw	r16,4(r2)
81125244:	14800215 	stw	r18,8(r2)
81125248:	003fe606 	br	811251e4 <__reset+0xfb1051e4>

8112524c <_Bfree>:
8112524c:	28000826 	beq	r5,zero,81125270 <_Bfree+0x24>
81125250:	28c00117 	ldw	r3,4(r5)
81125254:	20801317 	ldw	r2,76(r4)
81125258:	18c7883a 	add	r3,r3,r3
8112525c:	18c7883a 	add	r3,r3,r3
81125260:	10c5883a 	add	r2,r2,r3
81125264:	10c00017 	ldw	r3,0(r2)
81125268:	28c00015 	stw	r3,0(r5)
8112526c:	11400015 	stw	r5,0(r2)
81125270:	f800283a 	ret

81125274 <__multadd>:
81125274:	defffa04 	addi	sp,sp,-24
81125278:	de00012e 	bgeu	sp,et,81125280 <__multadd+0xc>
8112527c:	003b68fa 	trap	3
81125280:	0011883a 	mov	r8,zero
81125284:	dc800315 	stw	r18,12(sp)
81125288:	dc400215 	stw	r17,8(sp)
8112528c:	dc000115 	stw	r16,4(sp)
81125290:	2823883a 	mov	r17,r5
81125294:	2c000417 	ldw	r16,16(r5)
81125298:	dfc00515 	stw	ra,20(sp)
8112529c:	dcc00415 	stw	r19,16(sp)
811252a0:	2025883a 	mov	r18,r4
811252a4:	29400504 	addi	r5,r5,20
811252a8:	28c00017 	ldw	r3,0(r5)
811252ac:	29400104 	addi	r5,r5,4
811252b0:	42000044 	addi	r8,r8,1
811252b4:	18bfffcc 	andi	r2,r3,65535
811252b8:	1185383a 	mul	r2,r2,r6
811252bc:	1806d43a 	srli	r3,r3,16
811252c0:	11cf883a 	add	r7,r2,r7
811252c4:	3808d43a 	srli	r4,r7,16
811252c8:	1987383a 	mul	r3,r3,r6
811252cc:	38bfffcc 	andi	r2,r7,65535
811252d0:	1907883a 	add	r3,r3,r4
811252d4:	1808943a 	slli	r4,r3,16
811252d8:	180ed43a 	srli	r7,r3,16
811252dc:	2085883a 	add	r2,r4,r2
811252e0:	28bfff15 	stw	r2,-4(r5)
811252e4:	443ff016 	blt	r8,r16,811252a8 <__reset+0xfb1052a8>
811252e8:	38000926 	beq	r7,zero,81125310 <__multadd+0x9c>
811252ec:	88800217 	ldw	r2,8(r17)
811252f0:	80800f0e 	bge	r16,r2,81125330 <__multadd+0xbc>
811252f4:	80800144 	addi	r2,r16,5
811252f8:	1085883a 	add	r2,r2,r2
811252fc:	1085883a 	add	r2,r2,r2
81125300:	8885883a 	add	r2,r17,r2
81125304:	11c00015 	stw	r7,0(r2)
81125308:	84000044 	addi	r16,r16,1
8112530c:	8c000415 	stw	r16,16(r17)
81125310:	8805883a 	mov	r2,r17
81125314:	dfc00517 	ldw	ra,20(sp)
81125318:	dcc00417 	ldw	r19,16(sp)
8112531c:	dc800317 	ldw	r18,12(sp)
81125320:	dc400217 	ldw	r17,8(sp)
81125324:	dc000117 	ldw	r16,4(sp)
81125328:	dec00604 	addi	sp,sp,24
8112532c:	f800283a 	ret
81125330:	89400117 	ldw	r5,4(r17)
81125334:	9009883a 	mov	r4,r18
81125338:	d9c00015 	stw	r7,0(sp)
8112533c:	29400044 	addi	r5,r5,1
81125340:	112519c0 	call	8112519c <_Balloc>
81125344:	89800417 	ldw	r6,16(r17)
81125348:	89400304 	addi	r5,r17,12
8112534c:	11000304 	addi	r4,r2,12
81125350:	31800084 	addi	r6,r6,2
81125354:	318d883a 	add	r6,r6,r6
81125358:	318d883a 	add	r6,r6,r6
8112535c:	1027883a 	mov	r19,r2
81125360:	111abac0 	call	8111abac <memcpy>
81125364:	d9c00017 	ldw	r7,0(sp)
81125368:	88000a26 	beq	r17,zero,81125394 <__multadd+0x120>
8112536c:	88c00117 	ldw	r3,4(r17)
81125370:	90801317 	ldw	r2,76(r18)
81125374:	18c7883a 	add	r3,r3,r3
81125378:	18c7883a 	add	r3,r3,r3
8112537c:	10c5883a 	add	r2,r2,r3
81125380:	10c00017 	ldw	r3,0(r2)
81125384:	88c00015 	stw	r3,0(r17)
81125388:	14400015 	stw	r17,0(r2)
8112538c:	9823883a 	mov	r17,r19
81125390:	003fd806 	br	811252f4 <__reset+0xfb1052f4>
81125394:	9823883a 	mov	r17,r19
81125398:	003fd606 	br	811252f4 <__reset+0xfb1052f4>

8112539c <__s2b>:
8112539c:	defff904 	addi	sp,sp,-28
811253a0:	de00012e 	bgeu	sp,et,811253a8 <__s2b+0xc>
811253a4:	003b68fa 	trap	3
811253a8:	dc400115 	stw	r17,4(sp)
811253ac:	dc000015 	stw	r16,0(sp)
811253b0:	2023883a 	mov	r17,r4
811253b4:	2821883a 	mov	r16,r5
811253b8:	39000204 	addi	r4,r7,8
811253bc:	01400244 	movi	r5,9
811253c0:	dcc00315 	stw	r19,12(sp)
811253c4:	dc800215 	stw	r18,8(sp)
811253c8:	dfc00615 	stw	ra,24(sp)
811253cc:	dd400515 	stw	r21,20(sp)
811253d0:	dd000415 	stw	r20,16(sp)
811253d4:	3825883a 	mov	r18,r7
811253d8:	3027883a 	mov	r19,r6
811253dc:	112d7ec0 	call	8112d7ec <__divsi3>
811253e0:	00c00044 	movi	r3,1
811253e4:	000b883a 	mov	r5,zero
811253e8:	1880030e 	bge	r3,r2,811253f8 <__s2b+0x5c>
811253ec:	18c7883a 	add	r3,r3,r3
811253f0:	29400044 	addi	r5,r5,1
811253f4:	18bffd16 	blt	r3,r2,811253ec <__reset+0xfb1053ec>
811253f8:	8809883a 	mov	r4,r17
811253fc:	112519c0 	call	8112519c <_Balloc>
81125400:	d8c00717 	ldw	r3,28(sp)
81125404:	10c00515 	stw	r3,20(r2)
81125408:	00c00044 	movi	r3,1
8112540c:	10c00415 	stw	r3,16(r2)
81125410:	00c00244 	movi	r3,9
81125414:	1cc0210e 	bge	r3,r19,8112549c <__s2b+0x100>
81125418:	80eb883a 	add	r21,r16,r3
8112541c:	a829883a 	mov	r20,r21
81125420:	84e1883a 	add	r16,r16,r19
81125424:	a1c00007 	ldb	r7,0(r20)
81125428:	01800284 	movi	r6,10
8112542c:	a5000044 	addi	r20,r20,1
81125430:	100b883a 	mov	r5,r2
81125434:	39fff404 	addi	r7,r7,-48
81125438:	8809883a 	mov	r4,r17
8112543c:	11252740 	call	81125274 <__multadd>
81125440:	a43ff81e 	bne	r20,r16,81125424 <__reset+0xfb105424>
81125444:	ace1883a 	add	r16,r21,r19
81125448:	843ffe04 	addi	r16,r16,-8
8112544c:	9c800a0e 	bge	r19,r18,81125478 <__s2b+0xdc>
81125450:	94e5c83a 	sub	r18,r18,r19
81125454:	84a5883a 	add	r18,r16,r18
81125458:	81c00007 	ldb	r7,0(r16)
8112545c:	01800284 	movi	r6,10
81125460:	84000044 	addi	r16,r16,1
81125464:	100b883a 	mov	r5,r2
81125468:	39fff404 	addi	r7,r7,-48
8112546c:	8809883a 	mov	r4,r17
81125470:	11252740 	call	81125274 <__multadd>
81125474:	84bff81e 	bne	r16,r18,81125458 <__reset+0xfb105458>
81125478:	dfc00617 	ldw	ra,24(sp)
8112547c:	dd400517 	ldw	r21,20(sp)
81125480:	dd000417 	ldw	r20,16(sp)
81125484:	dcc00317 	ldw	r19,12(sp)
81125488:	dc800217 	ldw	r18,8(sp)
8112548c:	dc400117 	ldw	r17,4(sp)
81125490:	dc000017 	ldw	r16,0(sp)
81125494:	dec00704 	addi	sp,sp,28
81125498:	f800283a 	ret
8112549c:	84000284 	addi	r16,r16,10
811254a0:	1827883a 	mov	r19,r3
811254a4:	003fe906 	br	8112544c <__reset+0xfb10544c>

811254a8 <__hi0bits>:
811254a8:	20bfffec 	andhi	r2,r4,65535
811254ac:	1000141e 	bne	r2,zero,81125500 <__hi0bits+0x58>
811254b0:	2008943a 	slli	r4,r4,16
811254b4:	00800404 	movi	r2,16
811254b8:	20ffc02c 	andhi	r3,r4,65280
811254bc:	1800021e 	bne	r3,zero,811254c8 <__hi0bits+0x20>
811254c0:	2008923a 	slli	r4,r4,8
811254c4:	10800204 	addi	r2,r2,8
811254c8:	20fc002c 	andhi	r3,r4,61440
811254cc:	1800021e 	bne	r3,zero,811254d8 <__hi0bits+0x30>
811254d0:	2008913a 	slli	r4,r4,4
811254d4:	10800104 	addi	r2,r2,4
811254d8:	20f0002c 	andhi	r3,r4,49152
811254dc:	1800031e 	bne	r3,zero,811254ec <__hi0bits+0x44>
811254e0:	2109883a 	add	r4,r4,r4
811254e4:	10800084 	addi	r2,r2,2
811254e8:	2109883a 	add	r4,r4,r4
811254ec:	20000316 	blt	r4,zero,811254fc <__hi0bits+0x54>
811254f0:	2110002c 	andhi	r4,r4,16384
811254f4:	2000041e 	bne	r4,zero,81125508 <__hi0bits+0x60>
811254f8:	00800804 	movi	r2,32
811254fc:	f800283a 	ret
81125500:	0005883a 	mov	r2,zero
81125504:	003fec06 	br	811254b8 <__reset+0xfb1054b8>
81125508:	10800044 	addi	r2,r2,1
8112550c:	f800283a 	ret

81125510 <__lo0bits>:
81125510:	20c00017 	ldw	r3,0(r4)
81125514:	188001cc 	andi	r2,r3,7
81125518:	10000826 	beq	r2,zero,8112553c <__lo0bits+0x2c>
8112551c:	1880004c 	andi	r2,r3,1
81125520:	1000211e 	bne	r2,zero,811255a8 <__lo0bits+0x98>
81125524:	1880008c 	andi	r2,r3,2
81125528:	1000211e 	bne	r2,zero,811255b0 <__lo0bits+0xa0>
8112552c:	1806d0ba 	srli	r3,r3,2
81125530:	00800084 	movi	r2,2
81125534:	20c00015 	stw	r3,0(r4)
81125538:	f800283a 	ret
8112553c:	18bfffcc 	andi	r2,r3,65535
81125540:	10001326 	beq	r2,zero,81125590 <__lo0bits+0x80>
81125544:	0005883a 	mov	r2,zero
81125548:	19403fcc 	andi	r5,r3,255
8112554c:	2800021e 	bne	r5,zero,81125558 <__lo0bits+0x48>
81125550:	1806d23a 	srli	r3,r3,8
81125554:	10800204 	addi	r2,r2,8
81125558:	194003cc 	andi	r5,r3,15
8112555c:	2800021e 	bne	r5,zero,81125568 <__lo0bits+0x58>
81125560:	1806d13a 	srli	r3,r3,4
81125564:	10800104 	addi	r2,r2,4
81125568:	194000cc 	andi	r5,r3,3
8112556c:	2800021e 	bne	r5,zero,81125578 <__lo0bits+0x68>
81125570:	1806d0ba 	srli	r3,r3,2
81125574:	10800084 	addi	r2,r2,2
81125578:	1940004c 	andi	r5,r3,1
8112557c:	2800081e 	bne	r5,zero,811255a0 <__lo0bits+0x90>
81125580:	1806d07a 	srli	r3,r3,1
81125584:	1800051e 	bne	r3,zero,8112559c <__lo0bits+0x8c>
81125588:	00800804 	movi	r2,32
8112558c:	f800283a 	ret
81125590:	1806d43a 	srli	r3,r3,16
81125594:	00800404 	movi	r2,16
81125598:	003feb06 	br	81125548 <__reset+0xfb105548>
8112559c:	10800044 	addi	r2,r2,1
811255a0:	20c00015 	stw	r3,0(r4)
811255a4:	f800283a 	ret
811255a8:	0005883a 	mov	r2,zero
811255ac:	f800283a 	ret
811255b0:	1806d07a 	srli	r3,r3,1
811255b4:	00800044 	movi	r2,1
811255b8:	20c00015 	stw	r3,0(r4)
811255bc:	f800283a 	ret

811255c0 <__i2b>:
811255c0:	defffd04 	addi	sp,sp,-12
811255c4:	de00012e 	bgeu	sp,et,811255cc <__i2b+0xc>
811255c8:	003b68fa 	trap	3
811255cc:	dc000015 	stw	r16,0(sp)
811255d0:	04000044 	movi	r16,1
811255d4:	dc400115 	stw	r17,4(sp)
811255d8:	2823883a 	mov	r17,r5
811255dc:	800b883a 	mov	r5,r16
811255e0:	dfc00215 	stw	ra,8(sp)
811255e4:	112519c0 	call	8112519c <_Balloc>
811255e8:	14400515 	stw	r17,20(r2)
811255ec:	14000415 	stw	r16,16(r2)
811255f0:	dfc00217 	ldw	ra,8(sp)
811255f4:	dc400117 	ldw	r17,4(sp)
811255f8:	dc000017 	ldw	r16,0(sp)
811255fc:	dec00304 	addi	sp,sp,12
81125600:	f800283a 	ret

81125604 <__multiply>:
81125604:	defffa04 	addi	sp,sp,-24
81125608:	de00012e 	bgeu	sp,et,81125610 <__multiply+0xc>
8112560c:	003b68fa 	trap	3
81125610:	dcc00315 	stw	r19,12(sp)
81125614:	dc800215 	stw	r18,8(sp)
81125618:	34c00417 	ldw	r19,16(r6)
8112561c:	2c800417 	ldw	r18,16(r5)
81125620:	dd000415 	stw	r20,16(sp)
81125624:	dc400115 	stw	r17,4(sp)
81125628:	dfc00515 	stw	ra,20(sp)
8112562c:	dc000015 	stw	r16,0(sp)
81125630:	2829883a 	mov	r20,r5
81125634:	3023883a 	mov	r17,r6
81125638:	94c0050e 	bge	r18,r19,81125650 <__multiply+0x4c>
8112563c:	9007883a 	mov	r3,r18
81125640:	3029883a 	mov	r20,r6
81125644:	9825883a 	mov	r18,r19
81125648:	2823883a 	mov	r17,r5
8112564c:	1827883a 	mov	r19,r3
81125650:	a0800217 	ldw	r2,8(r20)
81125654:	94e1883a 	add	r16,r18,r19
81125658:	a1400117 	ldw	r5,4(r20)
8112565c:	1400010e 	bge	r2,r16,81125664 <__multiply+0x60>
81125660:	29400044 	addi	r5,r5,1
81125664:	112519c0 	call	8112519c <_Balloc>
81125668:	8415883a 	add	r10,r16,r16
8112566c:	12c00504 	addi	r11,r2,20
81125670:	5295883a 	add	r10,r10,r10
81125674:	5a95883a 	add	r10,r11,r10
81125678:	5807883a 	mov	r3,r11
8112567c:	5a80032e 	bgeu	r11,r10,8112568c <__multiply+0x88>
81125680:	18000015 	stw	zero,0(r3)
81125684:	18c00104 	addi	r3,r3,4
81125688:	1abffd36 	bltu	r3,r10,81125680 <__reset+0xfb105680>
8112568c:	9ce7883a 	add	r19,r19,r19
81125690:	94a5883a 	add	r18,r18,r18
81125694:	89800504 	addi	r6,r17,20
81125698:	9ce7883a 	add	r19,r19,r19
8112569c:	a3400504 	addi	r13,r20,20
811256a0:	94a5883a 	add	r18,r18,r18
811256a4:	34d9883a 	add	r12,r6,r19
811256a8:	6c93883a 	add	r9,r13,r18
811256ac:	3300422e 	bgeu	r6,r12,811257b8 <__multiply+0x1b4>
811256b0:	37c00017 	ldw	ra,0(r6)
811256b4:	fbffffcc 	andi	r15,ra,65535
811256b8:	78001b26 	beq	r15,zero,81125728 <__multiply+0x124>
811256bc:	5811883a 	mov	r8,r11
811256c0:	681d883a 	mov	r14,r13
811256c4:	000f883a 	mov	r7,zero
811256c8:	71000017 	ldw	r4,0(r14)
811256cc:	40c00017 	ldw	r3,0(r8)
811256d0:	73800104 	addi	r14,r14,4
811256d4:	217fffcc 	andi	r5,r4,65535
811256d8:	2bcb383a 	mul	r5,r5,r15
811256dc:	2008d43a 	srli	r4,r4,16
811256e0:	1c7fffcc 	andi	r17,r3,65535
811256e4:	2c4b883a 	add	r5,r5,r17
811256e8:	29cb883a 	add	r5,r5,r7
811256ec:	23c9383a 	mul	r4,r4,r15
811256f0:	1806d43a 	srli	r3,r3,16
811256f4:	280ed43a 	srli	r7,r5,16
811256f8:	297fffcc 	andi	r5,r5,65535
811256fc:	20c7883a 	add	r3,r4,r3
81125700:	19c7883a 	add	r3,r3,r7
81125704:	1808943a 	slli	r4,r3,16
81125708:	4023883a 	mov	r17,r8
8112570c:	180ed43a 	srli	r7,r3,16
81125710:	214ab03a 	or	r5,r4,r5
81125714:	41400015 	stw	r5,0(r8)
81125718:	42000104 	addi	r8,r8,4
8112571c:	727fea36 	bltu	r14,r9,811256c8 <__reset+0xfb1056c8>
81125720:	89c00115 	stw	r7,4(r17)
81125724:	37c00017 	ldw	ra,0(r6)
81125728:	f83ed43a 	srli	ra,ra,16
8112572c:	f8001f26 	beq	ra,zero,811257ac <__multiply+0x1a8>
81125730:	58c00017 	ldw	r3,0(r11)
81125734:	681d883a 	mov	r14,r13
81125738:	581f883a 	mov	r15,r11
8112573c:	1811883a 	mov	r8,r3
81125740:	5825883a 	mov	r18,r11
81125744:	000f883a 	mov	r7,zero
81125748:	00000106 	br	81125750 <__multiply+0x14c>
8112574c:	8825883a 	mov	r18,r17
81125750:	7140000b 	ldhu	r5,0(r14)
81125754:	4010d43a 	srli	r8,r8,16
81125758:	193fffcc 	andi	r4,r3,65535
8112575c:	2fcb383a 	mul	r5,r5,ra
81125760:	7bc00104 	addi	r15,r15,4
81125764:	73800104 	addi	r14,r14,4
81125768:	2a0b883a 	add	r5,r5,r8
8112576c:	29cb883a 	add	r5,r5,r7
81125770:	2806943a 	slli	r3,r5,16
81125774:	94400104 	addi	r17,r18,4
81125778:	280ad43a 	srli	r5,r5,16
8112577c:	1908b03a 	or	r4,r3,r4
81125780:	793fff15 	stw	r4,-4(r15)
81125784:	70ffff17 	ldw	r3,-4(r14)
81125788:	8a000017 	ldw	r8,0(r17)
8112578c:	1806d43a 	srli	r3,r3,16
81125790:	413fffcc 	andi	r4,r8,65535
81125794:	1fc7383a 	mul	r3,r3,ra
81125798:	1907883a 	add	r3,r3,r4
8112579c:	1947883a 	add	r3,r3,r5
811257a0:	180ed43a 	srli	r7,r3,16
811257a4:	727fe936 	bltu	r14,r9,8112574c <__reset+0xfb10574c>
811257a8:	90c00115 	stw	r3,4(r18)
811257ac:	31800104 	addi	r6,r6,4
811257b0:	5ac00104 	addi	r11,r11,4
811257b4:	333fbe36 	bltu	r6,r12,811256b0 <__reset+0xfb1056b0>
811257b8:	0400090e 	bge	zero,r16,811257e0 <__multiply+0x1dc>
811257bc:	50ffff17 	ldw	r3,-4(r10)
811257c0:	52bfff04 	addi	r10,r10,-4
811257c4:	18000326 	beq	r3,zero,811257d4 <__multiply+0x1d0>
811257c8:	00000506 	br	811257e0 <__multiply+0x1dc>
811257cc:	50c00017 	ldw	r3,0(r10)
811257d0:	1800031e 	bne	r3,zero,811257e0 <__multiply+0x1dc>
811257d4:	843fffc4 	addi	r16,r16,-1
811257d8:	52bfff04 	addi	r10,r10,-4
811257dc:	803ffb1e 	bne	r16,zero,811257cc <__reset+0xfb1057cc>
811257e0:	14000415 	stw	r16,16(r2)
811257e4:	dfc00517 	ldw	ra,20(sp)
811257e8:	dd000417 	ldw	r20,16(sp)
811257ec:	dcc00317 	ldw	r19,12(sp)
811257f0:	dc800217 	ldw	r18,8(sp)
811257f4:	dc400117 	ldw	r17,4(sp)
811257f8:	dc000017 	ldw	r16,0(sp)
811257fc:	dec00604 	addi	sp,sp,24
81125800:	f800283a 	ret

81125804 <__pow5mult>:
81125804:	defffa04 	addi	sp,sp,-24
81125808:	de00012e 	bgeu	sp,et,81125810 <__pow5mult+0xc>
8112580c:	003b68fa 	trap	3
81125810:	308000cc 	andi	r2,r6,3
81125814:	dcc00315 	stw	r19,12(sp)
81125818:	dc000015 	stw	r16,0(sp)
8112581c:	dfc00515 	stw	ra,20(sp)
81125820:	dd000415 	stw	r20,16(sp)
81125824:	dc800215 	stw	r18,8(sp)
81125828:	dc400115 	stw	r17,4(sp)
8112582c:	3021883a 	mov	r16,r6
81125830:	2027883a 	mov	r19,r4
81125834:	10002f1e 	bne	r2,zero,811258f4 <__pow5mult+0xf0>
81125838:	2825883a 	mov	r18,r5
8112583c:	8021d0ba 	srai	r16,r16,2
81125840:	80001a26 	beq	r16,zero,811258ac <__pow5mult+0xa8>
81125844:	9c401217 	ldw	r17,72(r19)
81125848:	8800061e 	bne	r17,zero,81125864 <__pow5mult+0x60>
8112584c:	00003406 	br	81125920 <__pow5mult+0x11c>
81125850:	8021d07a 	srai	r16,r16,1
81125854:	80001526 	beq	r16,zero,811258ac <__pow5mult+0xa8>
81125858:	88800017 	ldw	r2,0(r17)
8112585c:	10001c26 	beq	r2,zero,811258d0 <__pow5mult+0xcc>
81125860:	1023883a 	mov	r17,r2
81125864:	8080004c 	andi	r2,r16,1
81125868:	103ff926 	beq	r2,zero,81125850 <__reset+0xfb105850>
8112586c:	880d883a 	mov	r6,r17
81125870:	900b883a 	mov	r5,r18
81125874:	9809883a 	mov	r4,r19
81125878:	11256040 	call	81125604 <__multiply>
8112587c:	90001b26 	beq	r18,zero,811258ec <__pow5mult+0xe8>
81125880:	91000117 	ldw	r4,4(r18)
81125884:	98c01317 	ldw	r3,76(r19)
81125888:	8021d07a 	srai	r16,r16,1
8112588c:	2109883a 	add	r4,r4,r4
81125890:	2109883a 	add	r4,r4,r4
81125894:	1907883a 	add	r3,r3,r4
81125898:	19000017 	ldw	r4,0(r3)
8112589c:	91000015 	stw	r4,0(r18)
811258a0:	1c800015 	stw	r18,0(r3)
811258a4:	1025883a 	mov	r18,r2
811258a8:	803feb1e 	bne	r16,zero,81125858 <__reset+0xfb105858>
811258ac:	9005883a 	mov	r2,r18
811258b0:	dfc00517 	ldw	ra,20(sp)
811258b4:	dd000417 	ldw	r20,16(sp)
811258b8:	dcc00317 	ldw	r19,12(sp)
811258bc:	dc800217 	ldw	r18,8(sp)
811258c0:	dc400117 	ldw	r17,4(sp)
811258c4:	dc000017 	ldw	r16,0(sp)
811258c8:	dec00604 	addi	sp,sp,24
811258cc:	f800283a 	ret
811258d0:	880d883a 	mov	r6,r17
811258d4:	880b883a 	mov	r5,r17
811258d8:	9809883a 	mov	r4,r19
811258dc:	11256040 	call	81125604 <__multiply>
811258e0:	88800015 	stw	r2,0(r17)
811258e4:	10000015 	stw	zero,0(r2)
811258e8:	003fdd06 	br	81125860 <__reset+0xfb105860>
811258ec:	1025883a 	mov	r18,r2
811258f0:	003fd706 	br	81125850 <__reset+0xfb105850>
811258f4:	10bfffc4 	addi	r2,r2,-1
811258f8:	1085883a 	add	r2,r2,r2
811258fc:	00e04534 	movhi	r3,33044
81125900:	18d46904 	addi	r3,r3,20900
81125904:	1085883a 	add	r2,r2,r2
81125908:	1885883a 	add	r2,r3,r2
8112590c:	11800017 	ldw	r6,0(r2)
81125910:	000f883a 	mov	r7,zero
81125914:	11252740 	call	81125274 <__multadd>
81125918:	1025883a 	mov	r18,r2
8112591c:	003fc706 	br	8112583c <__reset+0xfb10583c>
81125920:	05000044 	movi	r20,1
81125924:	a00b883a 	mov	r5,r20
81125928:	9809883a 	mov	r4,r19
8112592c:	112519c0 	call	8112519c <_Balloc>
81125930:	1023883a 	mov	r17,r2
81125934:	00809c44 	movi	r2,625
81125938:	88800515 	stw	r2,20(r17)
8112593c:	8d000415 	stw	r20,16(r17)
81125940:	9c401215 	stw	r17,72(r19)
81125944:	88000015 	stw	zero,0(r17)
81125948:	003fc606 	br	81125864 <__reset+0xfb105864>

8112594c <__lshift>:
8112594c:	defff904 	addi	sp,sp,-28
81125950:	de00012e 	bgeu	sp,et,81125958 <__lshift+0xc>
81125954:	003b68fa 	trap	3
81125958:	dd400515 	stw	r21,20(sp)
8112595c:	dcc00315 	stw	r19,12(sp)
81125960:	302bd17a 	srai	r21,r6,5
81125964:	2cc00417 	ldw	r19,16(r5)
81125968:	28800217 	ldw	r2,8(r5)
8112596c:	dd000415 	stw	r20,16(sp)
81125970:	ace7883a 	add	r19,r21,r19
81125974:	dc800215 	stw	r18,8(sp)
81125978:	dc400115 	stw	r17,4(sp)
8112597c:	dc000015 	stw	r16,0(sp)
81125980:	dfc00615 	stw	ra,24(sp)
81125984:	9c000044 	addi	r16,r19,1
81125988:	2823883a 	mov	r17,r5
8112598c:	3029883a 	mov	r20,r6
81125990:	2025883a 	mov	r18,r4
81125994:	29400117 	ldw	r5,4(r5)
81125998:	1400030e 	bge	r2,r16,811259a8 <__lshift+0x5c>
8112599c:	1085883a 	add	r2,r2,r2
811259a0:	29400044 	addi	r5,r5,1
811259a4:	143ffd16 	blt	r2,r16,8112599c <__reset+0xfb10599c>
811259a8:	9009883a 	mov	r4,r18
811259ac:	112519c0 	call	8112519c <_Balloc>
811259b0:	10c00504 	addi	r3,r2,20
811259b4:	0540070e 	bge	zero,r21,811259d4 <__lshift+0x88>
811259b8:	ad6b883a 	add	r21,r21,r21
811259bc:	ad6b883a 	add	r21,r21,r21
811259c0:	1809883a 	mov	r4,r3
811259c4:	1d47883a 	add	r3,r3,r21
811259c8:	20000015 	stw	zero,0(r4)
811259cc:	21000104 	addi	r4,r4,4
811259d0:	193ffd1e 	bne	r3,r4,811259c8 <__reset+0xfb1059c8>
811259d4:	8a000417 	ldw	r8,16(r17)
811259d8:	89000504 	addi	r4,r17,20
811259dc:	a18007cc 	andi	r6,r20,31
811259e0:	4211883a 	add	r8,r8,r8
811259e4:	4211883a 	add	r8,r8,r8
811259e8:	2211883a 	add	r8,r4,r8
811259ec:	30002326 	beq	r6,zero,81125a7c <__lshift+0x130>
811259f0:	02400804 	movi	r9,32
811259f4:	4993c83a 	sub	r9,r9,r6
811259f8:	000b883a 	mov	r5,zero
811259fc:	21c00017 	ldw	r7,0(r4)
81125a00:	1815883a 	mov	r10,r3
81125a04:	18c00104 	addi	r3,r3,4
81125a08:	398e983a 	sll	r7,r7,r6
81125a0c:	21000104 	addi	r4,r4,4
81125a10:	394ab03a 	or	r5,r7,r5
81125a14:	197fff15 	stw	r5,-4(r3)
81125a18:	217fff17 	ldw	r5,-4(r4)
81125a1c:	2a4ad83a 	srl	r5,r5,r9
81125a20:	223ff636 	bltu	r4,r8,811259fc <__reset+0xfb1059fc>
81125a24:	51400115 	stw	r5,4(r10)
81125a28:	28001a1e 	bne	r5,zero,81125a94 <__lshift+0x148>
81125a2c:	843fffc4 	addi	r16,r16,-1
81125a30:	14000415 	stw	r16,16(r2)
81125a34:	88000826 	beq	r17,zero,81125a58 <__lshift+0x10c>
81125a38:	89000117 	ldw	r4,4(r17)
81125a3c:	90c01317 	ldw	r3,76(r18)
81125a40:	2109883a 	add	r4,r4,r4
81125a44:	2109883a 	add	r4,r4,r4
81125a48:	1907883a 	add	r3,r3,r4
81125a4c:	19000017 	ldw	r4,0(r3)
81125a50:	89000015 	stw	r4,0(r17)
81125a54:	1c400015 	stw	r17,0(r3)
81125a58:	dfc00617 	ldw	ra,24(sp)
81125a5c:	dd400517 	ldw	r21,20(sp)
81125a60:	dd000417 	ldw	r20,16(sp)
81125a64:	dcc00317 	ldw	r19,12(sp)
81125a68:	dc800217 	ldw	r18,8(sp)
81125a6c:	dc400117 	ldw	r17,4(sp)
81125a70:	dc000017 	ldw	r16,0(sp)
81125a74:	dec00704 	addi	sp,sp,28
81125a78:	f800283a 	ret
81125a7c:	21400017 	ldw	r5,0(r4)
81125a80:	18c00104 	addi	r3,r3,4
81125a84:	21000104 	addi	r4,r4,4
81125a88:	197fff15 	stw	r5,-4(r3)
81125a8c:	223ffb36 	bltu	r4,r8,81125a7c <__reset+0xfb105a7c>
81125a90:	003fe606 	br	81125a2c <__reset+0xfb105a2c>
81125a94:	9c000084 	addi	r16,r19,2
81125a98:	003fe406 	br	81125a2c <__reset+0xfb105a2c>

81125a9c <__mcmp>:
81125a9c:	20800417 	ldw	r2,16(r4)
81125aa0:	28c00417 	ldw	r3,16(r5)
81125aa4:	10c5c83a 	sub	r2,r2,r3
81125aa8:	1000111e 	bne	r2,zero,81125af0 <__mcmp+0x54>
81125aac:	18c7883a 	add	r3,r3,r3
81125ab0:	18c7883a 	add	r3,r3,r3
81125ab4:	21000504 	addi	r4,r4,20
81125ab8:	29400504 	addi	r5,r5,20
81125abc:	20c5883a 	add	r2,r4,r3
81125ac0:	28cb883a 	add	r5,r5,r3
81125ac4:	00000106 	br	81125acc <__mcmp+0x30>
81125ac8:	20800a2e 	bgeu	r4,r2,81125af4 <__mcmp+0x58>
81125acc:	10bfff04 	addi	r2,r2,-4
81125ad0:	297fff04 	addi	r5,r5,-4
81125ad4:	11800017 	ldw	r6,0(r2)
81125ad8:	28c00017 	ldw	r3,0(r5)
81125adc:	30fffa26 	beq	r6,r3,81125ac8 <__reset+0xfb105ac8>
81125ae0:	30c00236 	bltu	r6,r3,81125aec <__mcmp+0x50>
81125ae4:	00800044 	movi	r2,1
81125ae8:	f800283a 	ret
81125aec:	00bfffc4 	movi	r2,-1
81125af0:	f800283a 	ret
81125af4:	0005883a 	mov	r2,zero
81125af8:	f800283a 	ret

81125afc <__mdiff>:
81125afc:	defffa04 	addi	sp,sp,-24
81125b00:	de00012e 	bgeu	sp,et,81125b08 <__mdiff+0xc>
81125b04:	003b68fa 	trap	3
81125b08:	28c00417 	ldw	r3,16(r5)
81125b0c:	30800417 	ldw	r2,16(r6)
81125b10:	dcc00315 	stw	r19,12(sp)
81125b14:	dc800215 	stw	r18,8(sp)
81125b18:	dfc00515 	stw	ra,20(sp)
81125b1c:	dd000415 	stw	r20,16(sp)
81125b20:	dc400115 	stw	r17,4(sp)
81125b24:	dc000015 	stw	r16,0(sp)
81125b28:	1887c83a 	sub	r3,r3,r2
81125b2c:	2825883a 	mov	r18,r5
81125b30:	3027883a 	mov	r19,r6
81125b34:	1800141e 	bne	r3,zero,81125b88 <__mdiff+0x8c>
81125b38:	1085883a 	add	r2,r2,r2
81125b3c:	1085883a 	add	r2,r2,r2
81125b40:	2a000504 	addi	r8,r5,20
81125b44:	34000504 	addi	r16,r6,20
81125b48:	4087883a 	add	r3,r8,r2
81125b4c:	8085883a 	add	r2,r16,r2
81125b50:	00000106 	br	81125b58 <__mdiff+0x5c>
81125b54:	40c0592e 	bgeu	r8,r3,81125cbc <__mdiff+0x1c0>
81125b58:	18ffff04 	addi	r3,r3,-4
81125b5c:	10bfff04 	addi	r2,r2,-4
81125b60:	19c00017 	ldw	r7,0(r3)
81125b64:	11400017 	ldw	r5,0(r2)
81125b68:	397ffa26 	beq	r7,r5,81125b54 <__reset+0xfb105b54>
81125b6c:	3940592e 	bgeu	r7,r5,81125cd4 <__mdiff+0x1d8>
81125b70:	9005883a 	mov	r2,r18
81125b74:	4023883a 	mov	r17,r8
81125b78:	9825883a 	mov	r18,r19
81125b7c:	05000044 	movi	r20,1
81125b80:	1027883a 	mov	r19,r2
81125b84:	00000406 	br	81125b98 <__mdiff+0x9c>
81125b88:	18005616 	blt	r3,zero,81125ce4 <__mdiff+0x1e8>
81125b8c:	34400504 	addi	r17,r6,20
81125b90:	2c000504 	addi	r16,r5,20
81125b94:	0029883a 	mov	r20,zero
81125b98:	91400117 	ldw	r5,4(r18)
81125b9c:	112519c0 	call	8112519c <_Balloc>
81125ba0:	92400417 	ldw	r9,16(r18)
81125ba4:	9b000417 	ldw	r12,16(r19)
81125ba8:	12c00504 	addi	r11,r2,20
81125bac:	4a51883a 	add	r8,r9,r9
81125bb0:	6319883a 	add	r12,r12,r12
81125bb4:	4211883a 	add	r8,r8,r8
81125bb8:	6319883a 	add	r12,r12,r12
81125bbc:	15000315 	stw	r20,12(r2)
81125bc0:	8211883a 	add	r8,r16,r8
81125bc4:	8b19883a 	add	r12,r17,r12
81125bc8:	0007883a 	mov	r3,zero
81125bcc:	81400017 	ldw	r5,0(r16)
81125bd0:	89c00017 	ldw	r7,0(r17)
81125bd4:	59800104 	addi	r6,r11,4
81125bd8:	293fffcc 	andi	r4,r5,65535
81125bdc:	20c7883a 	add	r3,r4,r3
81125be0:	393fffcc 	andi	r4,r7,65535
81125be4:	1909c83a 	sub	r4,r3,r4
81125be8:	280ad43a 	srli	r5,r5,16
81125bec:	380ed43a 	srli	r7,r7,16
81125bf0:	2007d43a 	srai	r3,r4,16
81125bf4:	213fffcc 	andi	r4,r4,65535
81125bf8:	29cbc83a 	sub	r5,r5,r7
81125bfc:	28c7883a 	add	r3,r5,r3
81125c00:	180a943a 	slli	r5,r3,16
81125c04:	8c400104 	addi	r17,r17,4
81125c08:	84000104 	addi	r16,r16,4
81125c0c:	2908b03a 	or	r4,r5,r4
81125c10:	59000015 	stw	r4,0(r11)
81125c14:	1807d43a 	srai	r3,r3,16
81125c18:	3015883a 	mov	r10,r6
81125c1c:	3017883a 	mov	r11,r6
81125c20:	8b3fea36 	bltu	r17,r12,81125bcc <__reset+0xfb105bcc>
81125c24:	8200162e 	bgeu	r16,r8,81125c80 <__mdiff+0x184>
81125c28:	8017883a 	mov	r11,r16
81125c2c:	59400017 	ldw	r5,0(r11)
81125c30:	31800104 	addi	r6,r6,4
81125c34:	5ac00104 	addi	r11,r11,4
81125c38:	293fffcc 	andi	r4,r5,65535
81125c3c:	20c7883a 	add	r3,r4,r3
81125c40:	280ed43a 	srli	r7,r5,16
81125c44:	180bd43a 	srai	r5,r3,16
81125c48:	193fffcc 	andi	r4,r3,65535
81125c4c:	3947883a 	add	r3,r7,r5
81125c50:	180a943a 	slli	r5,r3,16
81125c54:	1807d43a 	srai	r3,r3,16
81125c58:	2908b03a 	or	r4,r5,r4
81125c5c:	313fff15 	stw	r4,-4(r6)
81125c60:	5a3ff236 	bltu	r11,r8,81125c2c <__reset+0xfb105c2c>
81125c64:	0406303a 	nor	r3,zero,r16
81125c68:	1a07883a 	add	r3,r3,r8
81125c6c:	1806d0ba 	srli	r3,r3,2
81125c70:	18c00044 	addi	r3,r3,1
81125c74:	18c7883a 	add	r3,r3,r3
81125c78:	18c7883a 	add	r3,r3,r3
81125c7c:	50d5883a 	add	r10,r10,r3
81125c80:	50ffff04 	addi	r3,r10,-4
81125c84:	2000041e 	bne	r4,zero,81125c98 <__mdiff+0x19c>
81125c88:	18ffff04 	addi	r3,r3,-4
81125c8c:	19000017 	ldw	r4,0(r3)
81125c90:	4a7fffc4 	addi	r9,r9,-1
81125c94:	203ffc26 	beq	r4,zero,81125c88 <__reset+0xfb105c88>
81125c98:	12400415 	stw	r9,16(r2)
81125c9c:	dfc00517 	ldw	ra,20(sp)
81125ca0:	dd000417 	ldw	r20,16(sp)
81125ca4:	dcc00317 	ldw	r19,12(sp)
81125ca8:	dc800217 	ldw	r18,8(sp)
81125cac:	dc400117 	ldw	r17,4(sp)
81125cb0:	dc000017 	ldw	r16,0(sp)
81125cb4:	dec00604 	addi	sp,sp,24
81125cb8:	f800283a 	ret
81125cbc:	000b883a 	mov	r5,zero
81125cc0:	112519c0 	call	8112519c <_Balloc>
81125cc4:	00c00044 	movi	r3,1
81125cc8:	10c00415 	stw	r3,16(r2)
81125ccc:	10000515 	stw	zero,20(r2)
81125cd0:	003ff206 	br	81125c9c <__reset+0xfb105c9c>
81125cd4:	8023883a 	mov	r17,r16
81125cd8:	0029883a 	mov	r20,zero
81125cdc:	4021883a 	mov	r16,r8
81125ce0:	003fad06 	br	81125b98 <__reset+0xfb105b98>
81125ce4:	9005883a 	mov	r2,r18
81125ce8:	94400504 	addi	r17,r18,20
81125cec:	9c000504 	addi	r16,r19,20
81125cf0:	9825883a 	mov	r18,r19
81125cf4:	05000044 	movi	r20,1
81125cf8:	1027883a 	mov	r19,r2
81125cfc:	003fa606 	br	81125b98 <__reset+0xfb105b98>

81125d00 <__ulp>:
81125d00:	295ffc2c 	andhi	r5,r5,32752
81125d04:	00bf3034 	movhi	r2,64704
81125d08:	2887883a 	add	r3,r5,r2
81125d0c:	00c0020e 	bge	zero,r3,81125d18 <__ulp+0x18>
81125d10:	0005883a 	mov	r2,zero
81125d14:	f800283a 	ret
81125d18:	00c7c83a 	sub	r3,zero,r3
81125d1c:	1807d53a 	srai	r3,r3,20
81125d20:	008004c4 	movi	r2,19
81125d24:	10c00b0e 	bge	r2,r3,81125d54 <__ulp+0x54>
81125d28:	18bffb04 	addi	r2,r3,-20
81125d2c:	01000784 	movi	r4,30
81125d30:	0007883a 	mov	r3,zero
81125d34:	20800516 	blt	r4,r2,81125d4c <__ulp+0x4c>
81125d38:	010007c4 	movi	r4,31
81125d3c:	2089c83a 	sub	r4,r4,r2
81125d40:	00800044 	movi	r2,1
81125d44:	1104983a 	sll	r2,r2,r4
81125d48:	f800283a 	ret
81125d4c:	00800044 	movi	r2,1
81125d50:	f800283a 	ret
81125d54:	01400234 	movhi	r5,8
81125d58:	28c7d83a 	sra	r3,r5,r3
81125d5c:	0005883a 	mov	r2,zero
81125d60:	f800283a 	ret

81125d64 <__b2d>:
81125d64:	defffa04 	addi	sp,sp,-24
81125d68:	de00012e 	bgeu	sp,et,81125d70 <__b2d+0xc>
81125d6c:	003b68fa 	trap	3
81125d70:	dc000015 	stw	r16,0(sp)
81125d74:	24000417 	ldw	r16,16(r4)
81125d78:	dc400115 	stw	r17,4(sp)
81125d7c:	24400504 	addi	r17,r4,20
81125d80:	8421883a 	add	r16,r16,r16
81125d84:	8421883a 	add	r16,r16,r16
81125d88:	8c21883a 	add	r16,r17,r16
81125d8c:	dc800215 	stw	r18,8(sp)
81125d90:	84bfff17 	ldw	r18,-4(r16)
81125d94:	dd000415 	stw	r20,16(sp)
81125d98:	dcc00315 	stw	r19,12(sp)
81125d9c:	9009883a 	mov	r4,r18
81125da0:	2829883a 	mov	r20,r5
81125da4:	dfc00515 	stw	ra,20(sp)
81125da8:	11254a80 	call	811254a8 <__hi0bits>
81125dac:	00c00804 	movi	r3,32
81125db0:	1889c83a 	sub	r4,r3,r2
81125db4:	a1000015 	stw	r4,0(r20)
81125db8:	01000284 	movi	r4,10
81125dbc:	84ffff04 	addi	r19,r16,-4
81125dc0:	20801216 	blt	r4,r2,81125e0c <__b2d+0xa8>
81125dc4:	018002c4 	movi	r6,11
81125dc8:	308dc83a 	sub	r6,r6,r2
81125dcc:	9186d83a 	srl	r3,r18,r6
81125dd0:	18cffc34 	orhi	r3,r3,16368
81125dd4:	8cc0212e 	bgeu	r17,r19,81125e5c <__b2d+0xf8>
81125dd8:	813ffe17 	ldw	r4,-8(r16)
81125ddc:	218cd83a 	srl	r6,r4,r6
81125de0:	10800544 	addi	r2,r2,21
81125de4:	9084983a 	sll	r2,r18,r2
81125de8:	1184b03a 	or	r2,r2,r6
81125dec:	dfc00517 	ldw	ra,20(sp)
81125df0:	dd000417 	ldw	r20,16(sp)
81125df4:	dcc00317 	ldw	r19,12(sp)
81125df8:	dc800217 	ldw	r18,8(sp)
81125dfc:	dc400117 	ldw	r17,4(sp)
81125e00:	dc000017 	ldw	r16,0(sp)
81125e04:	dec00604 	addi	sp,sp,24
81125e08:	f800283a 	ret
81125e0c:	8cc00f2e 	bgeu	r17,r19,81125e4c <__b2d+0xe8>
81125e10:	117ffd44 	addi	r5,r2,-11
81125e14:	80bffe17 	ldw	r2,-8(r16)
81125e18:	28000e26 	beq	r5,zero,81125e54 <__b2d+0xf0>
81125e1c:	1949c83a 	sub	r4,r3,r5
81125e20:	9164983a 	sll	r18,r18,r5
81125e24:	1106d83a 	srl	r3,r2,r4
81125e28:	81bffe04 	addi	r6,r16,-8
81125e2c:	948ffc34 	orhi	r18,r18,16368
81125e30:	90c6b03a 	or	r3,r18,r3
81125e34:	89800e2e 	bgeu	r17,r6,81125e70 <__b2d+0x10c>
81125e38:	81bffd17 	ldw	r6,-12(r16)
81125e3c:	1144983a 	sll	r2,r2,r5
81125e40:	310ad83a 	srl	r5,r6,r4
81125e44:	2884b03a 	or	r2,r5,r2
81125e48:	003fe806 	br	81125dec <__reset+0xfb105dec>
81125e4c:	10bffd44 	addi	r2,r2,-11
81125e50:	1000041e 	bne	r2,zero,81125e64 <__b2d+0x100>
81125e54:	90cffc34 	orhi	r3,r18,16368
81125e58:	003fe406 	br	81125dec <__reset+0xfb105dec>
81125e5c:	000d883a 	mov	r6,zero
81125e60:	003fdf06 	br	81125de0 <__reset+0xfb105de0>
81125e64:	90a4983a 	sll	r18,r18,r2
81125e68:	0005883a 	mov	r2,zero
81125e6c:	003ff906 	br	81125e54 <__reset+0xfb105e54>
81125e70:	1144983a 	sll	r2,r2,r5
81125e74:	003fdd06 	br	81125dec <__reset+0xfb105dec>

81125e78 <__d2b>:
81125e78:	defff804 	addi	sp,sp,-32
81125e7c:	de00012e 	bgeu	sp,et,81125e84 <__d2b+0xc>
81125e80:	003b68fa 	trap	3
81125e84:	dc000215 	stw	r16,8(sp)
81125e88:	3021883a 	mov	r16,r6
81125e8c:	dc400315 	stw	r17,12(sp)
81125e90:	8022907a 	slli	r17,r16,1
81125e94:	dd000615 	stw	r20,24(sp)
81125e98:	2829883a 	mov	r20,r5
81125e9c:	01400044 	movi	r5,1
81125ea0:	dcc00515 	stw	r19,20(sp)
81125ea4:	dc800415 	stw	r18,16(sp)
81125ea8:	dfc00715 	stw	ra,28(sp)
81125eac:	3825883a 	mov	r18,r7
81125eb0:	8822d57a 	srli	r17,r17,21
81125eb4:	112519c0 	call	8112519c <_Balloc>
81125eb8:	1027883a 	mov	r19,r2
81125ebc:	00800434 	movhi	r2,16
81125ec0:	10bfffc4 	addi	r2,r2,-1
81125ec4:	808c703a 	and	r6,r16,r2
81125ec8:	88000126 	beq	r17,zero,81125ed0 <__d2b+0x58>
81125ecc:	31800434 	orhi	r6,r6,16
81125ed0:	d9800015 	stw	r6,0(sp)
81125ed4:	a0002426 	beq	r20,zero,81125f68 <__d2b+0xf0>
81125ed8:	d9000104 	addi	r4,sp,4
81125edc:	dd000115 	stw	r20,4(sp)
81125ee0:	11255100 	call	81125510 <__lo0bits>
81125ee4:	d8c00017 	ldw	r3,0(sp)
81125ee8:	10002f1e 	bne	r2,zero,81125fa8 <__d2b+0x130>
81125eec:	d9000117 	ldw	r4,4(sp)
81125ef0:	99000515 	stw	r4,20(r19)
81125ef4:	1821003a 	cmpeq	r16,r3,zero
81125ef8:	01000084 	movi	r4,2
81125efc:	2421c83a 	sub	r16,r4,r16
81125f00:	98c00615 	stw	r3,24(r19)
81125f04:	9c000415 	stw	r16,16(r19)
81125f08:	88001f1e 	bne	r17,zero,81125f88 <__d2b+0x110>
81125f0c:	10bef384 	addi	r2,r2,-1074
81125f10:	90800015 	stw	r2,0(r18)
81125f14:	00900034 	movhi	r2,16384
81125f18:	10bfffc4 	addi	r2,r2,-1
81125f1c:	8085883a 	add	r2,r16,r2
81125f20:	1085883a 	add	r2,r2,r2
81125f24:	1085883a 	add	r2,r2,r2
81125f28:	9885883a 	add	r2,r19,r2
81125f2c:	11000517 	ldw	r4,20(r2)
81125f30:	8020917a 	slli	r16,r16,5
81125f34:	11254a80 	call	811254a8 <__hi0bits>
81125f38:	d8c00817 	ldw	r3,32(sp)
81125f3c:	8085c83a 	sub	r2,r16,r2
81125f40:	18800015 	stw	r2,0(r3)
81125f44:	9805883a 	mov	r2,r19
81125f48:	dfc00717 	ldw	ra,28(sp)
81125f4c:	dd000617 	ldw	r20,24(sp)
81125f50:	dcc00517 	ldw	r19,20(sp)
81125f54:	dc800417 	ldw	r18,16(sp)
81125f58:	dc400317 	ldw	r17,12(sp)
81125f5c:	dc000217 	ldw	r16,8(sp)
81125f60:	dec00804 	addi	sp,sp,32
81125f64:	f800283a 	ret
81125f68:	d809883a 	mov	r4,sp
81125f6c:	11255100 	call	81125510 <__lo0bits>
81125f70:	d8c00017 	ldw	r3,0(sp)
81125f74:	04000044 	movi	r16,1
81125f78:	9c000415 	stw	r16,16(r19)
81125f7c:	98c00515 	stw	r3,20(r19)
81125f80:	10800804 	addi	r2,r2,32
81125f84:	883fe126 	beq	r17,zero,81125f0c <__reset+0xfb105f0c>
81125f88:	00c00d44 	movi	r3,53
81125f8c:	8c7ef344 	addi	r17,r17,-1075
81125f90:	88a3883a 	add	r17,r17,r2
81125f94:	1885c83a 	sub	r2,r3,r2
81125f98:	d8c00817 	ldw	r3,32(sp)
81125f9c:	94400015 	stw	r17,0(r18)
81125fa0:	18800015 	stw	r2,0(r3)
81125fa4:	003fe706 	br	81125f44 <__reset+0xfb105f44>
81125fa8:	01000804 	movi	r4,32
81125fac:	2089c83a 	sub	r4,r4,r2
81125fb0:	1908983a 	sll	r4,r3,r4
81125fb4:	d9400117 	ldw	r5,4(sp)
81125fb8:	1886d83a 	srl	r3,r3,r2
81125fbc:	2148b03a 	or	r4,r4,r5
81125fc0:	99000515 	stw	r4,20(r19)
81125fc4:	d8c00015 	stw	r3,0(sp)
81125fc8:	003fca06 	br	81125ef4 <__reset+0xfb105ef4>

81125fcc <__ratio>:
81125fcc:	defff904 	addi	sp,sp,-28
81125fd0:	de00012e 	bgeu	sp,et,81125fd8 <__ratio+0xc>
81125fd4:	003b68fa 	trap	3
81125fd8:	dc400315 	stw	r17,12(sp)
81125fdc:	2823883a 	mov	r17,r5
81125fe0:	d9400104 	addi	r5,sp,4
81125fe4:	dfc00615 	stw	ra,24(sp)
81125fe8:	dcc00515 	stw	r19,20(sp)
81125fec:	dc800415 	stw	r18,16(sp)
81125ff0:	2027883a 	mov	r19,r4
81125ff4:	dc000215 	stw	r16,8(sp)
81125ff8:	1125d640 	call	81125d64 <__b2d>
81125ffc:	d80b883a 	mov	r5,sp
81126000:	8809883a 	mov	r4,r17
81126004:	1025883a 	mov	r18,r2
81126008:	1821883a 	mov	r16,r3
8112600c:	1125d640 	call	81125d64 <__b2d>
81126010:	8a000417 	ldw	r8,16(r17)
81126014:	99000417 	ldw	r4,16(r19)
81126018:	d9400117 	ldw	r5,4(sp)
8112601c:	2209c83a 	sub	r4,r4,r8
81126020:	2010917a 	slli	r8,r4,5
81126024:	d9000017 	ldw	r4,0(sp)
81126028:	2909c83a 	sub	r4,r5,r4
8112602c:	4109883a 	add	r4,r8,r4
81126030:	01000e0e 	bge	zero,r4,8112606c <__ratio+0xa0>
81126034:	2008953a 	slli	r4,r4,20
81126038:	2421883a 	add	r16,r4,r16
8112603c:	100d883a 	mov	r6,r2
81126040:	180f883a 	mov	r7,r3
81126044:	9009883a 	mov	r4,r18
81126048:	800b883a 	mov	r5,r16
8112604c:	112e4500 	call	8112e450 <__divdf3>
81126050:	dfc00617 	ldw	ra,24(sp)
81126054:	dcc00517 	ldw	r19,20(sp)
81126058:	dc800417 	ldw	r18,16(sp)
8112605c:	dc400317 	ldw	r17,12(sp)
81126060:	dc000217 	ldw	r16,8(sp)
81126064:	dec00704 	addi	sp,sp,28
81126068:	f800283a 	ret
8112606c:	2008953a 	slli	r4,r4,20
81126070:	1907c83a 	sub	r3,r3,r4
81126074:	003ff106 	br	8112603c <__reset+0xfb10603c>

81126078 <_mprec_log10>:
81126078:	defffe04 	addi	sp,sp,-8
8112607c:	de00012e 	bgeu	sp,et,81126084 <_mprec_log10+0xc>
81126080:	003b68fa 	trap	3
81126084:	008005c4 	movi	r2,23
81126088:	dc000015 	stw	r16,0(sp)
8112608c:	dfc00115 	stw	ra,4(sp)
81126090:	2021883a 	mov	r16,r4
81126094:	11000d0e 	bge	r2,r4,811260cc <_mprec_log10+0x54>
81126098:	0005883a 	mov	r2,zero
8112609c:	00cffc34 	movhi	r3,16368
811260a0:	843fffc4 	addi	r16,r16,-1
811260a4:	000d883a 	mov	r6,zero
811260a8:	01d00934 	movhi	r7,16420
811260ac:	1009883a 	mov	r4,r2
811260b0:	180b883a 	mov	r5,r3
811260b4:	11196d00 	call	811196d0 <__muldf3>
811260b8:	803ff91e 	bne	r16,zero,811260a0 <__reset+0xfb1060a0>
811260bc:	dfc00117 	ldw	ra,4(sp)
811260c0:	dc000017 	ldw	r16,0(sp)
811260c4:	dec00204 	addi	sp,sp,8
811260c8:	f800283a 	ret
811260cc:	202090fa 	slli	r16,r4,3
811260d0:	00a04534 	movhi	r2,33044
811260d4:	10948004 	addi	r2,r2,20992
811260d8:	1421883a 	add	r16,r2,r16
811260dc:	80800017 	ldw	r2,0(r16)
811260e0:	80c00117 	ldw	r3,4(r16)
811260e4:	dfc00117 	ldw	ra,4(sp)
811260e8:	dc000017 	ldw	r16,0(sp)
811260ec:	dec00204 	addi	sp,sp,8
811260f0:	f800283a 	ret

811260f4 <__copybits>:
811260f4:	297fffc4 	addi	r5,r5,-1
811260f8:	280fd17a 	srai	r7,r5,5
811260fc:	30c00417 	ldw	r3,16(r6)
81126100:	30800504 	addi	r2,r6,20
81126104:	39c00044 	addi	r7,r7,1
81126108:	18c7883a 	add	r3,r3,r3
8112610c:	39cf883a 	add	r7,r7,r7
81126110:	18c7883a 	add	r3,r3,r3
81126114:	39cf883a 	add	r7,r7,r7
81126118:	10c7883a 	add	r3,r2,r3
8112611c:	21cf883a 	add	r7,r4,r7
81126120:	10c00d2e 	bgeu	r2,r3,81126158 <__copybits+0x64>
81126124:	200b883a 	mov	r5,r4
81126128:	12000017 	ldw	r8,0(r2)
8112612c:	29400104 	addi	r5,r5,4
81126130:	10800104 	addi	r2,r2,4
81126134:	2a3fff15 	stw	r8,-4(r5)
81126138:	10fffb36 	bltu	r2,r3,81126128 <__reset+0xfb106128>
8112613c:	1985c83a 	sub	r2,r3,r6
81126140:	10bffac4 	addi	r2,r2,-21
81126144:	1004d0ba 	srli	r2,r2,2
81126148:	10800044 	addi	r2,r2,1
8112614c:	1085883a 	add	r2,r2,r2
81126150:	1085883a 	add	r2,r2,r2
81126154:	2089883a 	add	r4,r4,r2
81126158:	21c0032e 	bgeu	r4,r7,81126168 <__copybits+0x74>
8112615c:	20000015 	stw	zero,0(r4)
81126160:	21000104 	addi	r4,r4,4
81126164:	21fffd36 	bltu	r4,r7,8112615c <__reset+0xfb10615c>
81126168:	f800283a 	ret

8112616c <__any_on>:
8112616c:	20c00417 	ldw	r3,16(r4)
81126170:	2805d17a 	srai	r2,r5,5
81126174:	21000504 	addi	r4,r4,20
81126178:	18800d0e 	bge	r3,r2,811261b0 <__any_on+0x44>
8112617c:	18c7883a 	add	r3,r3,r3
81126180:	18c7883a 	add	r3,r3,r3
81126184:	20c7883a 	add	r3,r4,r3
81126188:	20c0192e 	bgeu	r4,r3,811261f0 <__any_on+0x84>
8112618c:	18bfff17 	ldw	r2,-4(r3)
81126190:	18ffff04 	addi	r3,r3,-4
81126194:	1000041e 	bne	r2,zero,811261a8 <__any_on+0x3c>
81126198:	20c0142e 	bgeu	r4,r3,811261ec <__any_on+0x80>
8112619c:	18ffff04 	addi	r3,r3,-4
811261a0:	19400017 	ldw	r5,0(r3)
811261a4:	283ffc26 	beq	r5,zero,81126198 <__reset+0xfb106198>
811261a8:	00800044 	movi	r2,1
811261ac:	f800283a 	ret
811261b0:	10c00a0e 	bge	r2,r3,811261dc <__any_on+0x70>
811261b4:	1085883a 	add	r2,r2,r2
811261b8:	1085883a 	add	r2,r2,r2
811261bc:	294007cc 	andi	r5,r5,31
811261c0:	2087883a 	add	r3,r4,r2
811261c4:	283ff026 	beq	r5,zero,81126188 <__reset+0xfb106188>
811261c8:	19800017 	ldw	r6,0(r3)
811261cc:	3144d83a 	srl	r2,r6,r5
811261d0:	114a983a 	sll	r5,r2,r5
811261d4:	317ff41e 	bne	r6,r5,811261a8 <__reset+0xfb1061a8>
811261d8:	003feb06 	br	81126188 <__reset+0xfb106188>
811261dc:	1085883a 	add	r2,r2,r2
811261e0:	1085883a 	add	r2,r2,r2
811261e4:	2087883a 	add	r3,r4,r2
811261e8:	003fe706 	br	81126188 <__reset+0xfb106188>
811261ec:	f800283a 	ret
811261f0:	0005883a 	mov	r2,zero
811261f4:	f800283a 	ret

811261f8 <_realloc_r>:
811261f8:	defff604 	addi	sp,sp,-40
811261fc:	de00012e 	bgeu	sp,et,81126204 <_realloc_r+0xc>
81126200:	003b68fa 	trap	3
81126204:	dc800215 	stw	r18,8(sp)
81126208:	dfc00915 	stw	ra,36(sp)
8112620c:	df000815 	stw	fp,32(sp)
81126210:	ddc00715 	stw	r23,28(sp)
81126214:	dd800615 	stw	r22,24(sp)
81126218:	dd400515 	stw	r21,20(sp)
8112621c:	dd000415 	stw	r20,16(sp)
81126220:	dcc00315 	stw	r19,12(sp)
81126224:	dc400115 	stw	r17,4(sp)
81126228:	dc000015 	stw	r16,0(sp)
8112622c:	3025883a 	mov	r18,r6
81126230:	2800b726 	beq	r5,zero,81126510 <_realloc_r+0x318>
81126234:	282b883a 	mov	r21,r5
81126238:	2029883a 	mov	r20,r4
8112623c:	1130b340 	call	81130b34 <__malloc_lock>
81126240:	a8bfff17 	ldw	r2,-4(r21)
81126244:	043fff04 	movi	r16,-4
81126248:	90c002c4 	addi	r3,r18,11
8112624c:	01000584 	movi	r4,22
81126250:	acfffe04 	addi	r19,r21,-8
81126254:	1420703a 	and	r16,r2,r16
81126258:	20c0332e 	bgeu	r4,r3,81126328 <_realloc_r+0x130>
8112625c:	047ffe04 	movi	r17,-8
81126260:	1c62703a 	and	r17,r3,r17
81126264:	8807883a 	mov	r3,r17
81126268:	88005816 	blt	r17,zero,811263cc <_realloc_r+0x1d4>
8112626c:	8c805736 	bltu	r17,r18,811263cc <_realloc_r+0x1d4>
81126270:	80c0300e 	bge	r16,r3,81126334 <_realloc_r+0x13c>
81126274:	07204534 	movhi	fp,33044
81126278:	e717eb04 	addi	fp,fp,24492
8112627c:	e1c00217 	ldw	r7,8(fp)
81126280:	9c09883a 	add	r4,r19,r16
81126284:	22000117 	ldw	r8,4(r4)
81126288:	21c06326 	beq	r4,r7,81126418 <_realloc_r+0x220>
8112628c:	017fff84 	movi	r5,-2
81126290:	414a703a 	and	r5,r8,r5
81126294:	214b883a 	add	r5,r4,r5
81126298:	29800117 	ldw	r6,4(r5)
8112629c:	3180004c 	andi	r6,r6,1
811262a0:	30003f26 	beq	r6,zero,811263a0 <_realloc_r+0x1a8>
811262a4:	1080004c 	andi	r2,r2,1
811262a8:	10008326 	beq	r2,zero,811264b8 <_realloc_r+0x2c0>
811262ac:	900b883a 	mov	r5,r18
811262b0:	a009883a 	mov	r4,r20
811262b4:	11245040 	call	81124504 <_malloc_r>
811262b8:	1025883a 	mov	r18,r2
811262bc:	10011e26 	beq	r2,zero,81126738 <_realloc_r+0x540>
811262c0:	a93fff17 	ldw	r4,-4(r21)
811262c4:	10fffe04 	addi	r3,r2,-8
811262c8:	00bfff84 	movi	r2,-2
811262cc:	2084703a 	and	r2,r4,r2
811262d0:	9885883a 	add	r2,r19,r2
811262d4:	1880ee26 	beq	r3,r2,81126690 <_realloc_r+0x498>
811262d8:	81bfff04 	addi	r6,r16,-4
811262dc:	00800904 	movi	r2,36
811262e0:	1180b836 	bltu	r2,r6,811265c4 <_realloc_r+0x3cc>
811262e4:	00c004c4 	movi	r3,19
811262e8:	19809636 	bltu	r3,r6,81126544 <_realloc_r+0x34c>
811262ec:	9005883a 	mov	r2,r18
811262f0:	a807883a 	mov	r3,r21
811262f4:	19000017 	ldw	r4,0(r3)
811262f8:	11000015 	stw	r4,0(r2)
811262fc:	19000117 	ldw	r4,4(r3)
81126300:	11000115 	stw	r4,4(r2)
81126304:	18c00217 	ldw	r3,8(r3)
81126308:	10c00215 	stw	r3,8(r2)
8112630c:	a80b883a 	mov	r5,r21
81126310:	a009883a 	mov	r4,r20
81126314:	11238b80 	call	811238b8 <_free_r>
81126318:	a009883a 	mov	r4,r20
8112631c:	1130c5c0 	call	81130c5c <__malloc_unlock>
81126320:	9005883a 	mov	r2,r18
81126324:	00001206 	br	81126370 <_realloc_r+0x178>
81126328:	00c00404 	movi	r3,16
8112632c:	1823883a 	mov	r17,r3
81126330:	003fce06 	br	8112626c <__reset+0xfb10626c>
81126334:	a825883a 	mov	r18,r21
81126338:	8445c83a 	sub	r2,r16,r17
8112633c:	00c003c4 	movi	r3,15
81126340:	18802636 	bltu	r3,r2,811263dc <_realloc_r+0x1e4>
81126344:	99800117 	ldw	r6,4(r19)
81126348:	9c07883a 	add	r3,r19,r16
8112634c:	3180004c 	andi	r6,r6,1
81126350:	3420b03a 	or	r16,r6,r16
81126354:	9c000115 	stw	r16,4(r19)
81126358:	18800117 	ldw	r2,4(r3)
8112635c:	10800054 	ori	r2,r2,1
81126360:	18800115 	stw	r2,4(r3)
81126364:	a009883a 	mov	r4,r20
81126368:	1130c5c0 	call	81130c5c <__malloc_unlock>
8112636c:	9005883a 	mov	r2,r18
81126370:	dfc00917 	ldw	ra,36(sp)
81126374:	df000817 	ldw	fp,32(sp)
81126378:	ddc00717 	ldw	r23,28(sp)
8112637c:	dd800617 	ldw	r22,24(sp)
81126380:	dd400517 	ldw	r21,20(sp)
81126384:	dd000417 	ldw	r20,16(sp)
81126388:	dcc00317 	ldw	r19,12(sp)
8112638c:	dc800217 	ldw	r18,8(sp)
81126390:	dc400117 	ldw	r17,4(sp)
81126394:	dc000017 	ldw	r16,0(sp)
81126398:	dec00a04 	addi	sp,sp,40
8112639c:	f800283a 	ret
811263a0:	017fff04 	movi	r5,-4
811263a4:	414a703a 	and	r5,r8,r5
811263a8:	814d883a 	add	r6,r16,r5
811263ac:	30c01f16 	blt	r6,r3,8112642c <_realloc_r+0x234>
811263b0:	20800317 	ldw	r2,12(r4)
811263b4:	20c00217 	ldw	r3,8(r4)
811263b8:	a825883a 	mov	r18,r21
811263bc:	3021883a 	mov	r16,r6
811263c0:	18800315 	stw	r2,12(r3)
811263c4:	10c00215 	stw	r3,8(r2)
811263c8:	003fdb06 	br	81126338 <__reset+0xfb106338>
811263cc:	00800304 	movi	r2,12
811263d0:	a0800015 	stw	r2,0(r20)
811263d4:	0005883a 	mov	r2,zero
811263d8:	003fe506 	br	81126370 <__reset+0xfb106370>
811263dc:	98c00117 	ldw	r3,4(r19)
811263e0:	9c4b883a 	add	r5,r19,r17
811263e4:	11000054 	ori	r4,r2,1
811263e8:	18c0004c 	andi	r3,r3,1
811263ec:	1c62b03a 	or	r17,r3,r17
811263f0:	9c400115 	stw	r17,4(r19)
811263f4:	29000115 	stw	r4,4(r5)
811263f8:	2885883a 	add	r2,r5,r2
811263fc:	10c00117 	ldw	r3,4(r2)
81126400:	29400204 	addi	r5,r5,8
81126404:	a009883a 	mov	r4,r20
81126408:	18c00054 	ori	r3,r3,1
8112640c:	10c00115 	stw	r3,4(r2)
81126410:	11238b80 	call	811238b8 <_free_r>
81126414:	003fd306 	br	81126364 <__reset+0xfb106364>
81126418:	017fff04 	movi	r5,-4
8112641c:	414a703a 	and	r5,r8,r5
81126420:	89800404 	addi	r6,r17,16
81126424:	8151883a 	add	r8,r16,r5
81126428:	4180590e 	bge	r8,r6,81126590 <_realloc_r+0x398>
8112642c:	1080004c 	andi	r2,r2,1
81126430:	103f9e1e 	bne	r2,zero,811262ac <__reset+0xfb1062ac>
81126434:	adbffe17 	ldw	r22,-8(r21)
81126438:	00bfff04 	movi	r2,-4
8112643c:	9dadc83a 	sub	r22,r19,r22
81126440:	b1800117 	ldw	r6,4(r22)
81126444:	3084703a 	and	r2,r6,r2
81126448:	20002026 	beq	r4,zero,811264cc <_realloc_r+0x2d4>
8112644c:	80af883a 	add	r23,r16,r2
81126450:	b96f883a 	add	r23,r23,r5
81126454:	21c05f26 	beq	r4,r7,811265d4 <_realloc_r+0x3dc>
81126458:	b8c01c16 	blt	r23,r3,811264cc <_realloc_r+0x2d4>
8112645c:	20800317 	ldw	r2,12(r4)
81126460:	20c00217 	ldw	r3,8(r4)
81126464:	81bfff04 	addi	r6,r16,-4
81126468:	01000904 	movi	r4,36
8112646c:	18800315 	stw	r2,12(r3)
81126470:	10c00215 	stw	r3,8(r2)
81126474:	b0c00217 	ldw	r3,8(r22)
81126478:	b0800317 	ldw	r2,12(r22)
8112647c:	b4800204 	addi	r18,r22,8
81126480:	18800315 	stw	r2,12(r3)
81126484:	10c00215 	stw	r3,8(r2)
81126488:	21801b36 	bltu	r4,r6,811264f8 <_realloc_r+0x300>
8112648c:	008004c4 	movi	r2,19
81126490:	1180352e 	bgeu	r2,r6,81126568 <_realloc_r+0x370>
81126494:	a8800017 	ldw	r2,0(r21)
81126498:	b0800215 	stw	r2,8(r22)
8112649c:	a8800117 	ldw	r2,4(r21)
811264a0:	b0800315 	stw	r2,12(r22)
811264a4:	008006c4 	movi	r2,27
811264a8:	11807f36 	bltu	r2,r6,811266a8 <_realloc_r+0x4b0>
811264ac:	b0800404 	addi	r2,r22,16
811264b0:	ad400204 	addi	r21,r21,8
811264b4:	00002d06 	br	8112656c <_realloc_r+0x374>
811264b8:	adbffe17 	ldw	r22,-8(r21)
811264bc:	00bfff04 	movi	r2,-4
811264c0:	9dadc83a 	sub	r22,r19,r22
811264c4:	b1000117 	ldw	r4,4(r22)
811264c8:	2084703a 	and	r2,r4,r2
811264cc:	b03f7726 	beq	r22,zero,811262ac <__reset+0xfb1062ac>
811264d0:	80af883a 	add	r23,r16,r2
811264d4:	b8ff7516 	blt	r23,r3,811262ac <__reset+0xfb1062ac>
811264d8:	b0800317 	ldw	r2,12(r22)
811264dc:	b0c00217 	ldw	r3,8(r22)
811264e0:	81bfff04 	addi	r6,r16,-4
811264e4:	01000904 	movi	r4,36
811264e8:	18800315 	stw	r2,12(r3)
811264ec:	10c00215 	stw	r3,8(r2)
811264f0:	b4800204 	addi	r18,r22,8
811264f4:	21bfe52e 	bgeu	r4,r6,8112648c <__reset+0xfb10648c>
811264f8:	a80b883a 	mov	r5,r21
811264fc:	9009883a 	mov	r4,r18
81126500:	11250400 	call	81125040 <memmove>
81126504:	b821883a 	mov	r16,r23
81126508:	b027883a 	mov	r19,r22
8112650c:	003f8a06 	br	81126338 <__reset+0xfb106338>
81126510:	300b883a 	mov	r5,r6
81126514:	dfc00917 	ldw	ra,36(sp)
81126518:	df000817 	ldw	fp,32(sp)
8112651c:	ddc00717 	ldw	r23,28(sp)
81126520:	dd800617 	ldw	r22,24(sp)
81126524:	dd400517 	ldw	r21,20(sp)
81126528:	dd000417 	ldw	r20,16(sp)
8112652c:	dcc00317 	ldw	r19,12(sp)
81126530:	dc800217 	ldw	r18,8(sp)
81126534:	dc400117 	ldw	r17,4(sp)
81126538:	dc000017 	ldw	r16,0(sp)
8112653c:	dec00a04 	addi	sp,sp,40
81126540:	11245041 	jmpi	81124504 <_malloc_r>
81126544:	a8c00017 	ldw	r3,0(r21)
81126548:	90c00015 	stw	r3,0(r18)
8112654c:	a8c00117 	ldw	r3,4(r21)
81126550:	90c00115 	stw	r3,4(r18)
81126554:	00c006c4 	movi	r3,27
81126558:	19804536 	bltu	r3,r6,81126670 <_realloc_r+0x478>
8112655c:	90800204 	addi	r2,r18,8
81126560:	a8c00204 	addi	r3,r21,8
81126564:	003f6306 	br	811262f4 <__reset+0xfb1062f4>
81126568:	9005883a 	mov	r2,r18
8112656c:	a8c00017 	ldw	r3,0(r21)
81126570:	b821883a 	mov	r16,r23
81126574:	b027883a 	mov	r19,r22
81126578:	10c00015 	stw	r3,0(r2)
8112657c:	a8c00117 	ldw	r3,4(r21)
81126580:	10c00115 	stw	r3,4(r2)
81126584:	a8c00217 	ldw	r3,8(r21)
81126588:	10c00215 	stw	r3,8(r2)
8112658c:	003f6a06 	br	81126338 <__reset+0xfb106338>
81126590:	9c67883a 	add	r19,r19,r17
81126594:	4445c83a 	sub	r2,r8,r17
81126598:	e4c00215 	stw	r19,8(fp)
8112659c:	10800054 	ori	r2,r2,1
811265a0:	98800115 	stw	r2,4(r19)
811265a4:	a8bfff17 	ldw	r2,-4(r21)
811265a8:	a009883a 	mov	r4,r20
811265ac:	1080004c 	andi	r2,r2,1
811265b0:	1462b03a 	or	r17,r2,r17
811265b4:	ac7fff15 	stw	r17,-4(r21)
811265b8:	1130c5c0 	call	81130c5c <__malloc_unlock>
811265bc:	a805883a 	mov	r2,r21
811265c0:	003f6b06 	br	81126370 <__reset+0xfb106370>
811265c4:	a80b883a 	mov	r5,r21
811265c8:	9009883a 	mov	r4,r18
811265cc:	11250400 	call	81125040 <memmove>
811265d0:	003f4e06 	br	8112630c <__reset+0xfb10630c>
811265d4:	89000404 	addi	r4,r17,16
811265d8:	b93fbc16 	blt	r23,r4,811264cc <__reset+0xfb1064cc>
811265dc:	b0800317 	ldw	r2,12(r22)
811265e0:	b0c00217 	ldw	r3,8(r22)
811265e4:	81bfff04 	addi	r6,r16,-4
811265e8:	01000904 	movi	r4,36
811265ec:	18800315 	stw	r2,12(r3)
811265f0:	10c00215 	stw	r3,8(r2)
811265f4:	b4800204 	addi	r18,r22,8
811265f8:	21804336 	bltu	r4,r6,81126708 <_realloc_r+0x510>
811265fc:	008004c4 	movi	r2,19
81126600:	11803f2e 	bgeu	r2,r6,81126700 <_realloc_r+0x508>
81126604:	a8800017 	ldw	r2,0(r21)
81126608:	b0800215 	stw	r2,8(r22)
8112660c:	a8800117 	ldw	r2,4(r21)
81126610:	b0800315 	stw	r2,12(r22)
81126614:	008006c4 	movi	r2,27
81126618:	11803f36 	bltu	r2,r6,81126718 <_realloc_r+0x520>
8112661c:	b0800404 	addi	r2,r22,16
81126620:	ad400204 	addi	r21,r21,8
81126624:	a8c00017 	ldw	r3,0(r21)
81126628:	10c00015 	stw	r3,0(r2)
8112662c:	a8c00117 	ldw	r3,4(r21)
81126630:	10c00115 	stw	r3,4(r2)
81126634:	a8c00217 	ldw	r3,8(r21)
81126638:	10c00215 	stw	r3,8(r2)
8112663c:	b447883a 	add	r3,r22,r17
81126640:	bc45c83a 	sub	r2,r23,r17
81126644:	e0c00215 	stw	r3,8(fp)
81126648:	10800054 	ori	r2,r2,1
8112664c:	18800115 	stw	r2,4(r3)
81126650:	b0800117 	ldw	r2,4(r22)
81126654:	a009883a 	mov	r4,r20
81126658:	1080004c 	andi	r2,r2,1
8112665c:	1462b03a 	or	r17,r2,r17
81126660:	b4400115 	stw	r17,4(r22)
81126664:	1130c5c0 	call	81130c5c <__malloc_unlock>
81126668:	9005883a 	mov	r2,r18
8112666c:	003f4006 	br	81126370 <__reset+0xfb106370>
81126670:	a8c00217 	ldw	r3,8(r21)
81126674:	90c00215 	stw	r3,8(r18)
81126678:	a8c00317 	ldw	r3,12(r21)
8112667c:	90c00315 	stw	r3,12(r18)
81126680:	30801126 	beq	r6,r2,811266c8 <_realloc_r+0x4d0>
81126684:	90800404 	addi	r2,r18,16
81126688:	a8c00404 	addi	r3,r21,16
8112668c:	003f1906 	br	811262f4 <__reset+0xfb1062f4>
81126690:	90ffff17 	ldw	r3,-4(r18)
81126694:	00bfff04 	movi	r2,-4
81126698:	a825883a 	mov	r18,r21
8112669c:	1884703a 	and	r2,r3,r2
811266a0:	80a1883a 	add	r16,r16,r2
811266a4:	003f2406 	br	81126338 <__reset+0xfb106338>
811266a8:	a8800217 	ldw	r2,8(r21)
811266ac:	b0800415 	stw	r2,16(r22)
811266b0:	a8800317 	ldw	r2,12(r21)
811266b4:	b0800515 	stw	r2,20(r22)
811266b8:	31000a26 	beq	r6,r4,811266e4 <_realloc_r+0x4ec>
811266bc:	b0800604 	addi	r2,r22,24
811266c0:	ad400404 	addi	r21,r21,16
811266c4:	003fa906 	br	8112656c <__reset+0xfb10656c>
811266c8:	a9000417 	ldw	r4,16(r21)
811266cc:	90800604 	addi	r2,r18,24
811266d0:	a8c00604 	addi	r3,r21,24
811266d4:	91000415 	stw	r4,16(r18)
811266d8:	a9000517 	ldw	r4,20(r21)
811266dc:	91000515 	stw	r4,20(r18)
811266e0:	003f0406 	br	811262f4 <__reset+0xfb1062f4>
811266e4:	a8c00417 	ldw	r3,16(r21)
811266e8:	ad400604 	addi	r21,r21,24
811266ec:	b0800804 	addi	r2,r22,32
811266f0:	b0c00615 	stw	r3,24(r22)
811266f4:	a8ffff17 	ldw	r3,-4(r21)
811266f8:	b0c00715 	stw	r3,28(r22)
811266fc:	003f9b06 	br	8112656c <__reset+0xfb10656c>
81126700:	9005883a 	mov	r2,r18
81126704:	003fc706 	br	81126624 <__reset+0xfb106624>
81126708:	a80b883a 	mov	r5,r21
8112670c:	9009883a 	mov	r4,r18
81126710:	11250400 	call	81125040 <memmove>
81126714:	003fc906 	br	8112663c <__reset+0xfb10663c>
81126718:	a8800217 	ldw	r2,8(r21)
8112671c:	b0800415 	stw	r2,16(r22)
81126720:	a8800317 	ldw	r2,12(r21)
81126724:	b0800515 	stw	r2,20(r22)
81126728:	31000726 	beq	r6,r4,81126748 <_realloc_r+0x550>
8112672c:	b0800604 	addi	r2,r22,24
81126730:	ad400404 	addi	r21,r21,16
81126734:	003fbb06 	br	81126624 <__reset+0xfb106624>
81126738:	a009883a 	mov	r4,r20
8112673c:	1130c5c0 	call	81130c5c <__malloc_unlock>
81126740:	0005883a 	mov	r2,zero
81126744:	003f0a06 	br	81126370 <__reset+0xfb106370>
81126748:	a8c00417 	ldw	r3,16(r21)
8112674c:	ad400604 	addi	r21,r21,24
81126750:	b0800804 	addi	r2,r22,32
81126754:	b0c00615 	stw	r3,24(r22)
81126758:	a8ffff17 	ldw	r3,-4(r21)
8112675c:	b0c00715 	stw	r3,28(r22)
81126760:	003fb006 	br	81126624 <__reset+0xfb106624>

81126764 <lflush>:
81126764:	2080030b 	ldhu	r2,12(r4)
81126768:	00c00244 	movi	r3,9
8112676c:	1080024c 	andi	r2,r2,9
81126770:	10c00226 	beq	r2,r3,8112677c <lflush+0x18>
81126774:	0005883a 	mov	r2,zero
81126778:	f800283a 	ret
8112677c:	11231341 	jmpi	81123134 <fflush>

81126780 <__srefill_r>:
81126780:	defffc04 	addi	sp,sp,-16
81126784:	de00012e 	bgeu	sp,et,8112678c <__srefill_r+0xc>
81126788:	003b68fa 	trap	3
8112678c:	dc400115 	stw	r17,4(sp)
81126790:	dc000015 	stw	r16,0(sp)
81126794:	dfc00315 	stw	ra,12(sp)
81126798:	dc800215 	stw	r18,8(sp)
8112679c:	2023883a 	mov	r17,r4
811267a0:	2821883a 	mov	r16,r5
811267a4:	20000226 	beq	r4,zero,811267b0 <__srefill_r+0x30>
811267a8:	20800e17 	ldw	r2,56(r4)
811267ac:	10003c26 	beq	r2,zero,811268a0 <__srefill_r+0x120>
811267b0:	80c0030b 	ldhu	r3,12(r16)
811267b4:	1908000c 	andi	r4,r3,8192
811267b8:	1805883a 	mov	r2,r3
811267bc:	2000071e 	bne	r4,zero,811267dc <__srefill_r+0x5c>
811267c0:	81001917 	ldw	r4,100(r16)
811267c4:	18880014 	ori	r2,r3,8192
811267c8:	00f7ffc4 	movi	r3,-8193
811267cc:	20c8703a 	and	r4,r4,r3
811267d0:	8080030d 	sth	r2,12(r16)
811267d4:	1007883a 	mov	r3,r2
811267d8:	81001915 	stw	r4,100(r16)
811267dc:	80000115 	stw	zero,4(r16)
811267e0:	1100080c 	andi	r4,r2,32
811267e4:	2000571e 	bne	r4,zero,81126944 <__srefill_r+0x1c4>
811267e8:	1100010c 	andi	r4,r2,4
811267ec:	20001f26 	beq	r4,zero,8112686c <__srefill_r+0xec>
811267f0:	81400c17 	ldw	r5,48(r16)
811267f4:	28000826 	beq	r5,zero,81126818 <__srefill_r+0x98>
811267f8:	80801004 	addi	r2,r16,64
811267fc:	28800226 	beq	r5,r2,81126808 <__srefill_r+0x88>
81126800:	8809883a 	mov	r4,r17
81126804:	11238b80 	call	811238b8 <_free_r>
81126808:	80800f17 	ldw	r2,60(r16)
8112680c:	80000c15 	stw	zero,48(r16)
81126810:	80800115 	stw	r2,4(r16)
81126814:	1000391e 	bne	r2,zero,811268fc <__srefill_r+0x17c>
81126818:	80800417 	ldw	r2,16(r16)
8112681c:	10004b26 	beq	r2,zero,8112694c <__srefill_r+0x1cc>
81126820:	8480030b 	ldhu	r18,12(r16)
81126824:	908000cc 	andi	r2,r18,3
81126828:	10001f1e 	bne	r2,zero,811268a8 <__srefill_r+0x128>
8112682c:	81800417 	ldw	r6,16(r16)
81126830:	80800817 	ldw	r2,32(r16)
81126834:	81c00517 	ldw	r7,20(r16)
81126838:	81400717 	ldw	r5,28(r16)
8112683c:	81800015 	stw	r6,0(r16)
81126840:	8809883a 	mov	r4,r17
81126844:	103ee83a 	callr	r2
81126848:	80800115 	stw	r2,4(r16)
8112684c:	00800e0e 	bge	zero,r2,81126888 <__srefill_r+0x108>
81126850:	0005883a 	mov	r2,zero
81126854:	dfc00317 	ldw	ra,12(sp)
81126858:	dc800217 	ldw	r18,8(sp)
8112685c:	dc400117 	ldw	r17,4(sp)
81126860:	dc000017 	ldw	r16,0(sp)
81126864:	dec00404 	addi	sp,sp,16
81126868:	f800283a 	ret
8112686c:	1100040c 	andi	r4,r2,16
81126870:	20003026 	beq	r4,zero,81126934 <__srefill_r+0x1b4>
81126874:	1080020c 	andi	r2,r2,8
81126878:	1000241e 	bne	r2,zero,8112690c <__srefill_r+0x18c>
8112687c:	18c00114 	ori	r3,r3,4
81126880:	80c0030d 	sth	r3,12(r16)
81126884:	003fe406 	br	81126818 <__reset+0xfb106818>
81126888:	80c0030b 	ldhu	r3,12(r16)
8112688c:	1000161e 	bne	r2,zero,811268e8 <__srefill_r+0x168>
81126890:	18c00814 	ori	r3,r3,32
81126894:	00bfffc4 	movi	r2,-1
81126898:	80c0030d 	sth	r3,12(r16)
8112689c:	003fed06 	br	81126854 <__reset+0xfb106854>
811268a0:	11234cc0 	call	811234cc <__sinit>
811268a4:	003fc206 	br	811267b0 <__reset+0xfb1067b0>
811268a8:	00a04534 	movhi	r2,33044
811268ac:	109e0e04 	addi	r2,r2,30776
811268b0:	11000017 	ldw	r4,0(r2)
811268b4:	016044b4 	movhi	r5,33042
811268b8:	00800044 	movi	r2,1
811268bc:	2959d904 	addi	r5,r5,26468
811268c0:	8080030d 	sth	r2,12(r16)
811268c4:	11240940 	call	81124094 <_fwalk>
811268c8:	00800244 	movi	r2,9
811268cc:	8480030d 	sth	r18,12(r16)
811268d0:	9480024c 	andi	r18,r18,9
811268d4:	90bfd51e 	bne	r18,r2,8112682c <__reset+0xfb10682c>
811268d8:	800b883a 	mov	r5,r16
811268dc:	8809883a 	mov	r4,r17
811268e0:	1122eac0 	call	81122eac <__sflush_r>
811268e4:	003fd106 	br	8112682c <__reset+0xfb10682c>
811268e8:	18c01014 	ori	r3,r3,64
811268ec:	80000115 	stw	zero,4(r16)
811268f0:	00bfffc4 	movi	r2,-1
811268f4:	80c0030d 	sth	r3,12(r16)
811268f8:	003fd606 	br	81126854 <__reset+0xfb106854>
811268fc:	80c00e17 	ldw	r3,56(r16)
81126900:	0005883a 	mov	r2,zero
81126904:	80c00015 	stw	r3,0(r16)
81126908:	003fd206 	br	81126854 <__reset+0xfb106854>
8112690c:	800b883a 	mov	r5,r16
81126910:	8809883a 	mov	r4,r17
81126914:	11230d00 	call	811230d0 <_fflush_r>
81126918:	10000a1e 	bne	r2,zero,81126944 <__srefill_r+0x1c4>
8112691c:	8080030b 	ldhu	r2,12(r16)
81126920:	00fffdc4 	movi	r3,-9
81126924:	80000215 	stw	zero,8(r16)
81126928:	1886703a 	and	r3,r3,r2
8112692c:	80000615 	stw	zero,24(r16)
81126930:	003fd206 	br	8112687c <__reset+0xfb10687c>
81126934:	00800244 	movi	r2,9
81126938:	88800015 	stw	r2,0(r17)
8112693c:	18c01014 	ori	r3,r3,64
81126940:	80c0030d 	sth	r3,12(r16)
81126944:	00bfffc4 	movi	r2,-1
81126948:	003fc206 	br	81126854 <__reset+0xfb106854>
8112694c:	800b883a 	mov	r5,r16
81126950:	8809883a 	mov	r4,r17
81126954:	11243400 	call	81124340 <__smakebuf_r>
81126958:	003fb106 	br	81126820 <__reset+0xfb106820>

8112695c <__fpclassifyd>:
8112695c:	00a00034 	movhi	r2,32768
81126960:	10bfffc4 	addi	r2,r2,-1
81126964:	2884703a 	and	r2,r5,r2
81126968:	10000726 	beq	r2,zero,81126988 <__fpclassifyd+0x2c>
8112696c:	00fffc34 	movhi	r3,65520
81126970:	019ff834 	movhi	r6,32736
81126974:	28c7883a 	add	r3,r5,r3
81126978:	31bfffc4 	addi	r6,r6,-1
8112697c:	30c00536 	bltu	r6,r3,81126994 <__fpclassifyd+0x38>
81126980:	00800104 	movi	r2,4
81126984:	f800283a 	ret
81126988:	2000021e 	bne	r4,zero,81126994 <__fpclassifyd+0x38>
8112698c:	00800084 	movi	r2,2
81126990:	f800283a 	ret
81126994:	00dffc34 	movhi	r3,32752
81126998:	019ff834 	movhi	r6,32736
8112699c:	28cb883a 	add	r5,r5,r3
811269a0:	31bfffc4 	addi	r6,r6,-1
811269a4:	317ff62e 	bgeu	r6,r5,81126980 <__reset+0xfb106980>
811269a8:	01400434 	movhi	r5,16
811269ac:	297fffc4 	addi	r5,r5,-1
811269b0:	28800236 	bltu	r5,r2,811269bc <__fpclassifyd+0x60>
811269b4:	008000c4 	movi	r2,3
811269b8:	f800283a 	ret
811269bc:	10c00226 	beq	r2,r3,811269c8 <__fpclassifyd+0x6c>
811269c0:	0005883a 	mov	r2,zero
811269c4:	f800283a 	ret
811269c8:	2005003a 	cmpeq	r2,r4,zero
811269cc:	f800283a 	ret

811269d0 <_sbrk_r>:
811269d0:	defffd04 	addi	sp,sp,-12
811269d4:	de00012e 	bgeu	sp,et,811269dc <_sbrk_r+0xc>
811269d8:	003b68fa 	trap	3
811269dc:	dc000015 	stw	r16,0(sp)
811269e0:	04204534 	movhi	r16,33044
811269e4:	dc400115 	stw	r17,4(sp)
811269e8:	841e8704 	addi	r16,r16,31260
811269ec:	2023883a 	mov	r17,r4
811269f0:	2809883a 	mov	r4,r5
811269f4:	dfc00215 	stw	ra,8(sp)
811269f8:	80000015 	stw	zero,0(r16)
811269fc:	11304c40 	call	811304c4 <sbrk>
81126a00:	00ffffc4 	movi	r3,-1
81126a04:	10c00526 	beq	r2,r3,81126a1c <_sbrk_r+0x4c>
81126a08:	dfc00217 	ldw	ra,8(sp)
81126a0c:	dc400117 	ldw	r17,4(sp)
81126a10:	dc000017 	ldw	r16,0(sp)
81126a14:	dec00304 	addi	sp,sp,12
81126a18:	f800283a 	ret
81126a1c:	80c00017 	ldw	r3,0(r16)
81126a20:	183ff926 	beq	r3,zero,81126a08 <__reset+0xfb106a08>
81126a24:	88c00015 	stw	r3,0(r17)
81126a28:	003ff706 	br	81126a08 <__reset+0xfb106a08>

81126a2c <__sccl>:
81126a2c:	2a000003 	ldbu	r8,0(r5)
81126a30:	00801784 	movi	r2,94
81126a34:	40802a26 	beq	r8,r2,81126ae0 <__sccl+0xb4>
81126a38:	29400044 	addi	r5,r5,1
81126a3c:	000f883a 	mov	r7,zero
81126a40:	0013883a 	mov	r9,zero
81126a44:	2007883a 	mov	r3,r4
81126a48:	21804004 	addi	r6,r4,256
81126a4c:	19c00005 	stb	r7,0(r3)
81126a50:	18c00044 	addi	r3,r3,1
81126a54:	19bffd1e 	bne	r3,r6,81126a4c <__reset+0xfb106a4c>
81126a58:	40001126 	beq	r8,zero,81126aa0 <__sccl+0x74>
81126a5c:	00800044 	movi	r2,1
81126a60:	124fc83a 	sub	r7,r2,r9
81126a64:	02800b44 	movi	r10,45
81126a68:	02c01744 	movi	r11,93
81126a6c:	2205883a 	add	r2,r4,r8
81126a70:	11c00005 	stb	r7,0(r2)
81126a74:	28800044 	addi	r2,r5,1
81126a78:	28c00003 	ldbu	r3,0(r5)
81126a7c:	1a800a26 	beq	r3,r10,81126aa8 <__sccl+0x7c>
81126a80:	1ac00426 	beq	r3,r11,81126a94 <__sccl+0x68>
81126a84:	18000426 	beq	r3,zero,81126a98 <__sccl+0x6c>
81126a88:	1811883a 	mov	r8,r3
81126a8c:	100b883a 	mov	r5,r2
81126a90:	003ff606 	br	81126a6c <__reset+0xfb106a6c>
81126a94:	f800283a 	ret
81126a98:	2805883a 	mov	r2,r5
81126a9c:	f800283a 	ret
81126aa0:	28bfffc4 	addi	r2,r5,-1
81126aa4:	f800283a 	ret
81126aa8:	12400003 	ldbu	r9,0(r2)
81126aac:	4ac01126 	beq	r9,r11,81126af4 <__sccl+0xc8>
81126ab0:	4a001016 	blt	r9,r8,81126af4 <__sccl+0xc8>
81126ab4:	41800044 	addi	r6,r8,1
81126ab8:	29400084 	addi	r5,r5,2
81126abc:	2187883a 	add	r3,r4,r6
81126ac0:	00000106 	br	81126ac8 <__sccl+0x9c>
81126ac4:	31800044 	addi	r6,r6,1
81126ac8:	19c00005 	stb	r7,0(r3)
81126acc:	3011883a 	mov	r8,r6
81126ad0:	18c00044 	addi	r3,r3,1
81126ad4:	327ffb16 	blt	r6,r9,81126ac4 <__reset+0xfb106ac4>
81126ad8:	10800084 	addi	r2,r2,2
81126adc:	003fe606 	br	81126a78 <__reset+0xfb106a78>
81126ae0:	2a000043 	ldbu	r8,1(r5)
81126ae4:	01c00044 	movi	r7,1
81126ae8:	29400084 	addi	r5,r5,2
81126aec:	02400044 	movi	r9,1
81126af0:	003fd406 	br	81126a44 <__reset+0xfb106a44>
81126af4:	5011883a 	mov	r8,r10
81126af8:	003fe406 	br	81126a8c <__reset+0xfb106a8c>

81126afc <nanf>:
81126afc:	009ff034 	movhi	r2,32704
81126b00:	f800283a 	ret

81126b04 <__sread>:
81126b04:	defffe04 	addi	sp,sp,-8
81126b08:	de00012e 	bgeu	sp,et,81126b10 <__sread+0xc>
81126b0c:	003b68fa 	trap	3
81126b10:	dc000015 	stw	r16,0(sp)
81126b14:	2821883a 	mov	r16,r5
81126b18:	2940038f 	ldh	r5,14(r5)
81126b1c:	dfc00115 	stw	ra,4(sp)
81126b20:	112c8940 	call	8112c894 <_read_r>
81126b24:	10000716 	blt	r2,zero,81126b44 <__sread+0x40>
81126b28:	80c01417 	ldw	r3,80(r16)
81126b2c:	1887883a 	add	r3,r3,r2
81126b30:	80c01415 	stw	r3,80(r16)
81126b34:	dfc00117 	ldw	ra,4(sp)
81126b38:	dc000017 	ldw	r16,0(sp)
81126b3c:	dec00204 	addi	sp,sp,8
81126b40:	f800283a 	ret
81126b44:	80c0030b 	ldhu	r3,12(r16)
81126b48:	18fbffcc 	andi	r3,r3,61439
81126b4c:	80c0030d 	sth	r3,12(r16)
81126b50:	dfc00117 	ldw	ra,4(sp)
81126b54:	dc000017 	ldw	r16,0(sp)
81126b58:	dec00204 	addi	sp,sp,8
81126b5c:	f800283a 	ret

81126b60 <__seofread>:
81126b60:	0005883a 	mov	r2,zero
81126b64:	f800283a 	ret

81126b68 <__swrite>:
81126b68:	defffb04 	addi	sp,sp,-20
81126b6c:	de00012e 	bgeu	sp,et,81126b74 <__swrite+0xc>
81126b70:	003b68fa 	trap	3
81126b74:	2880030b 	ldhu	r2,12(r5)
81126b78:	dcc00315 	stw	r19,12(sp)
81126b7c:	dc800215 	stw	r18,8(sp)
81126b80:	dc400115 	stw	r17,4(sp)
81126b84:	dc000015 	stw	r16,0(sp)
81126b88:	dfc00415 	stw	ra,16(sp)
81126b8c:	10c0400c 	andi	r3,r2,256
81126b90:	2821883a 	mov	r16,r5
81126b94:	2023883a 	mov	r17,r4
81126b98:	3025883a 	mov	r18,r6
81126b9c:	3827883a 	mov	r19,r7
81126ba0:	18000526 	beq	r3,zero,81126bb8 <__swrite+0x50>
81126ba4:	2940038f 	ldh	r5,14(r5)
81126ba8:	01c00084 	movi	r7,2
81126bac:	000d883a 	mov	r6,zero
81126bb0:	112c82c0 	call	8112c82c <_lseek_r>
81126bb4:	8080030b 	ldhu	r2,12(r16)
81126bb8:	8140038f 	ldh	r5,14(r16)
81126bbc:	10bbffcc 	andi	r2,r2,61439
81126bc0:	980f883a 	mov	r7,r19
81126bc4:	900d883a 	mov	r6,r18
81126bc8:	8809883a 	mov	r4,r17
81126bcc:	8080030d 	sth	r2,12(r16)
81126bd0:	dfc00417 	ldw	ra,16(sp)
81126bd4:	dcc00317 	ldw	r19,12(sp)
81126bd8:	dc800217 	ldw	r18,8(sp)
81126bdc:	dc400117 	ldw	r17,4(sp)
81126be0:	dc000017 	ldw	r16,0(sp)
81126be4:	dec00504 	addi	sp,sp,20
81126be8:	112b71c1 	jmpi	8112b71c <_write_r>

81126bec <__sseek>:
81126bec:	defffe04 	addi	sp,sp,-8
81126bf0:	de00012e 	bgeu	sp,et,81126bf8 <__sseek+0xc>
81126bf4:	003b68fa 	trap	3
81126bf8:	dc000015 	stw	r16,0(sp)
81126bfc:	2821883a 	mov	r16,r5
81126c00:	2940038f 	ldh	r5,14(r5)
81126c04:	dfc00115 	stw	ra,4(sp)
81126c08:	112c82c0 	call	8112c82c <_lseek_r>
81126c0c:	00ffffc4 	movi	r3,-1
81126c10:	10c00826 	beq	r2,r3,81126c34 <__sseek+0x48>
81126c14:	80c0030b 	ldhu	r3,12(r16)
81126c18:	80801415 	stw	r2,80(r16)
81126c1c:	18c40014 	ori	r3,r3,4096
81126c20:	80c0030d 	sth	r3,12(r16)
81126c24:	dfc00117 	ldw	ra,4(sp)
81126c28:	dc000017 	ldw	r16,0(sp)
81126c2c:	dec00204 	addi	sp,sp,8
81126c30:	f800283a 	ret
81126c34:	80c0030b 	ldhu	r3,12(r16)
81126c38:	18fbffcc 	andi	r3,r3,61439
81126c3c:	80c0030d 	sth	r3,12(r16)
81126c40:	dfc00117 	ldw	ra,4(sp)
81126c44:	dc000017 	ldw	r16,0(sp)
81126c48:	dec00204 	addi	sp,sp,8
81126c4c:	f800283a 	ret

81126c50 <__sclose>:
81126c50:	2940038f 	ldh	r5,14(r5)
81126c54:	112b7841 	jmpi	8112b784 <_close_r>

81126c58 <strcmp>:
81126c58:	2144b03a 	or	r2,r4,r5
81126c5c:	108000cc 	andi	r2,r2,3
81126c60:	1000171e 	bne	r2,zero,81126cc0 <strcmp+0x68>
81126c64:	20800017 	ldw	r2,0(r4)
81126c68:	28c00017 	ldw	r3,0(r5)
81126c6c:	10c0141e 	bne	r2,r3,81126cc0 <strcmp+0x68>
81126c70:	027fbff4 	movhi	r9,65279
81126c74:	4a7fbfc4 	addi	r9,r9,-257
81126c78:	0086303a 	nor	r3,zero,r2
81126c7c:	02202074 	movhi	r8,32897
81126c80:	1245883a 	add	r2,r2,r9
81126c84:	42202004 	addi	r8,r8,-32640
81126c88:	10c4703a 	and	r2,r2,r3
81126c8c:	1204703a 	and	r2,r2,r8
81126c90:	10000226 	beq	r2,zero,81126c9c <strcmp+0x44>
81126c94:	00002306 	br	81126d24 <strcmp+0xcc>
81126c98:	1000221e 	bne	r2,zero,81126d24 <strcmp+0xcc>
81126c9c:	21000104 	addi	r4,r4,4
81126ca0:	20c00017 	ldw	r3,0(r4)
81126ca4:	29400104 	addi	r5,r5,4
81126ca8:	29800017 	ldw	r6,0(r5)
81126cac:	1a4f883a 	add	r7,r3,r9
81126cb0:	00c4303a 	nor	r2,zero,r3
81126cb4:	3884703a 	and	r2,r7,r2
81126cb8:	1204703a 	and	r2,r2,r8
81126cbc:	19bff626 	beq	r3,r6,81126c98 <__reset+0xfb106c98>
81126cc0:	20800003 	ldbu	r2,0(r4)
81126cc4:	10c03fcc 	andi	r3,r2,255
81126cc8:	18c0201c 	xori	r3,r3,128
81126ccc:	18ffe004 	addi	r3,r3,-128
81126cd0:	18000c26 	beq	r3,zero,81126d04 <strcmp+0xac>
81126cd4:	29800007 	ldb	r6,0(r5)
81126cd8:	19800326 	beq	r3,r6,81126ce8 <strcmp+0x90>
81126cdc:	00001306 	br	81126d2c <strcmp+0xd4>
81126ce0:	29800007 	ldb	r6,0(r5)
81126ce4:	11800b1e 	bne	r2,r6,81126d14 <strcmp+0xbc>
81126ce8:	21000044 	addi	r4,r4,1
81126cec:	20c00003 	ldbu	r3,0(r4)
81126cf0:	29400044 	addi	r5,r5,1
81126cf4:	18803fcc 	andi	r2,r3,255
81126cf8:	1080201c 	xori	r2,r2,128
81126cfc:	10bfe004 	addi	r2,r2,-128
81126d00:	103ff71e 	bne	r2,zero,81126ce0 <__reset+0xfb106ce0>
81126d04:	0007883a 	mov	r3,zero
81126d08:	28800003 	ldbu	r2,0(r5)
81126d0c:	1885c83a 	sub	r2,r3,r2
81126d10:	f800283a 	ret
81126d14:	28800003 	ldbu	r2,0(r5)
81126d18:	18c03fcc 	andi	r3,r3,255
81126d1c:	1885c83a 	sub	r2,r3,r2
81126d20:	f800283a 	ret
81126d24:	0005883a 	mov	r2,zero
81126d28:	f800283a 	ret
81126d2c:	10c03fcc 	andi	r3,r2,255
81126d30:	003ff506 	br	81126d08 <__reset+0xfb106d08>

81126d34 <sulp>:
81126d34:	defffd04 	addi	sp,sp,-12
81126d38:	de00012e 	bgeu	sp,et,81126d40 <sulp+0xc>
81126d3c:	003b68fa 	trap	3
81126d40:	dc400115 	stw	r17,4(sp)
81126d44:	3023883a 	mov	r17,r6
81126d48:	dc000015 	stw	r16,0(sp)
81126d4c:	dfc00215 	stw	ra,8(sp)
81126d50:	2821883a 	mov	r16,r5
81126d54:	1125d000 	call	81125d00 <__ulp>
81126d58:	88000c26 	beq	r17,zero,81126d8c <sulp+0x58>
81126d5c:	841ffc2c 	andhi	r16,r16,32752
81126d60:	8020d53a 	srli	r16,r16,20
81126d64:	01c01ac4 	movi	r7,107
81126d68:	3c21c83a 	sub	r16,r7,r16
81126d6c:	0400070e 	bge	zero,r16,81126d8c <sulp+0x58>
81126d70:	8020953a 	slli	r16,r16,20
81126d74:	01cffc34 	movhi	r7,16368
81126d78:	000d883a 	mov	r6,zero
81126d7c:	81cf883a 	add	r7,r16,r7
81126d80:	1009883a 	mov	r4,r2
81126d84:	180b883a 	mov	r5,r3
81126d88:	11196d00 	call	811196d0 <__muldf3>
81126d8c:	dfc00217 	ldw	ra,8(sp)
81126d90:	dc400117 	ldw	r17,4(sp)
81126d94:	dc000017 	ldw	r16,0(sp)
81126d98:	dec00304 	addi	sp,sp,12
81126d9c:	f800283a 	ret

81126da0 <_strtod_r>:
81126da0:	deffe204 	addi	sp,sp,-120
81126da4:	de00012e 	bgeu	sp,et,81126dac <_strtod_r+0xc>
81126da8:	003b68fa 	trap	3
81126dac:	ddc01b15 	stw	r23,108(sp)
81126db0:	dd001815 	stw	r20,96(sp)
81126db4:	dc801615 	stw	r18,88(sp)
81126db8:	dc401515 	stw	r17,84(sp)
81126dbc:	dc001415 	stw	r16,80(sp)
81126dc0:	d9400615 	stw	r5,24(sp)
81126dc4:	dfc01d15 	stw	ra,116(sp)
81126dc8:	df001c15 	stw	fp,112(sp)
81126dcc:	dd801a15 	stw	r22,104(sp)
81126dd0:	dd401915 	stw	r21,100(sp)
81126dd4:	dcc01715 	stw	r19,92(sp)
81126dd8:	2021883a 	mov	r16,r4
81126ddc:	d8000515 	stw	zero,20(sp)
81126de0:	2809883a 	mov	r4,r5
81126de4:	20800003 	ldbu	r2,0(r4)
81126de8:	01e044b4 	movhi	r7,33042
81126dec:	282f883a 	mov	r23,r5
81126df0:	10c03fcc 	andi	r3,r2,255
81126df4:	01400b44 	movi	r5,45
81126df8:	39db8704 	addi	r7,r7,28188
81126dfc:	3029883a 	mov	r20,r6
81126e00:	0025883a 	mov	r18,zero
81126e04:	0023883a 	mov	r17,zero
81126e08:	28c0ba36 	bltu	r5,r3,811270f4 <_strtod_r+0x354>
81126e0c:	180690ba 	slli	r3,r3,2
81126e10:	19c7883a 	add	r3,r3,r7
81126e14:	18c00017 	ldw	r3,0(r3)
81126e18:	1800683a 	jmp	r3
81126e1c:	81126edc 	xori	r4,r16,18875
81126e20:	811270f4 	orhi	r4,r16,18883
81126e24:	811270f4 	orhi	r4,r16,18883
81126e28:	811270f4 	orhi	r4,r16,18883
81126e2c:	811270f4 	orhi	r4,r16,18883
81126e30:	811270f4 	orhi	r4,r16,18883
81126e34:	811270f4 	orhi	r4,r16,18883
81126e38:	811270f4 	orhi	r4,r16,18883
81126e3c:	811270f4 	orhi	r4,r16,18883
81126e40:	811270e0 	cmpeqi	r4,r16,18883
81126e44:	811270e0 	cmpeqi	r4,r16,18883
81126e48:	811270e0 	cmpeqi	r4,r16,18883
81126e4c:	811270e0 	cmpeqi	r4,r16,18883
81126e50:	811270e0 	cmpeqi	r4,r16,18883
81126e54:	811270f4 	orhi	r4,r16,18883
81126e58:	811270f4 	orhi	r4,r16,18883
81126e5c:	811270f4 	orhi	r4,r16,18883
81126e60:	811270f4 	orhi	r4,r16,18883
81126e64:	811270f4 	orhi	r4,r16,18883
81126e68:	811270f4 	orhi	r4,r16,18883
81126e6c:	811270f4 	orhi	r4,r16,18883
81126e70:	811270f4 	orhi	r4,r16,18883
81126e74:	811270f4 	orhi	r4,r16,18883
81126e78:	811270f4 	orhi	r4,r16,18883
81126e7c:	811270f4 	orhi	r4,r16,18883
81126e80:	811270f4 	orhi	r4,r16,18883
81126e84:	811270f4 	orhi	r4,r16,18883
81126e88:	811270f4 	orhi	r4,r16,18883
81126e8c:	811270f4 	orhi	r4,r16,18883
81126e90:	811270f4 	orhi	r4,r16,18883
81126e94:	811270f4 	orhi	r4,r16,18883
81126e98:	811270f4 	orhi	r4,r16,18883
81126e9c:	811270e0 	cmpeqi	r4,r16,18883
81126ea0:	811270f4 	orhi	r4,r16,18883
81126ea4:	811270f4 	orhi	r4,r16,18883
81126ea8:	811270f4 	orhi	r4,r16,18883
81126eac:	811270f4 	orhi	r4,r16,18883
81126eb0:	811270f4 	orhi	r4,r16,18883
81126eb4:	811270f4 	orhi	r4,r16,18883
81126eb8:	811270f4 	orhi	r4,r16,18883
81126ebc:	811270f4 	orhi	r4,r16,18883
81126ec0:	811270f4 	orhi	r4,r16,18883
81126ec4:	811270f4 	orhi	r4,r16,18883
81126ec8:	81126f34 	orhi	r4,r16,18876
81126ecc:	811270f4 	orhi	r4,r16,18883
81126ed0:	811270d4 	ori	r4,r16,18883
81126ed4:	00801244 	movi	r2,73
81126ed8:	88843526 	beq	r17,r2,81127fb0 <_strtod_r+0x1210>
81126edc:	002b883a 	mov	r21,zero
81126ee0:	002d883a 	mov	r22,zero
81126ee4:	a0000526 	beq	r20,zero,81126efc <_strtod_r+0x15c>
81126ee8:	d8000715 	stw	zero,28(sp)
81126eec:	a5c00015 	stw	r23,0(r20)
81126ef0:	d9000717 	ldw	r4,28(sp)
81126ef4:	20000126 	beq	r4,zero,81126efc <_strtod_r+0x15c>
81126ef8:	b5a0003c 	xorhi	r22,r22,32768
81126efc:	a805883a 	mov	r2,r21
81126f00:	b007883a 	mov	r3,r22
81126f04:	dfc01d17 	ldw	ra,116(sp)
81126f08:	df001c17 	ldw	fp,112(sp)
81126f0c:	ddc01b17 	ldw	r23,108(sp)
81126f10:	dd801a17 	ldw	r22,104(sp)
81126f14:	dd401917 	ldw	r21,100(sp)
81126f18:	dd001817 	ldw	r20,96(sp)
81126f1c:	dcc01717 	ldw	r19,92(sp)
81126f20:	dc801617 	ldw	r18,88(sp)
81126f24:	dc401517 	ldw	r17,84(sp)
81126f28:	dc001417 	ldw	r16,80(sp)
81126f2c:	dec01e04 	addi	sp,sp,120
81126f30:	f800283a 	ret
81126f34:	d8000715 	stw	zero,28(sp)
81126f38:	24c00044 	addi	r19,r4,1
81126f3c:	dcc00615 	stw	r19,24(sp)
81126f40:	20800043 	ldbu	r2,1(r4)
81126f44:	10c03fcc 	andi	r3,r2,255
81126f48:	18c0201c 	xori	r3,r3,128
81126f4c:	18ffe004 	addi	r3,r3,-128
81126f50:	183fe226 	beq	r3,zero,81126edc <__reset+0xfb106edc>
81126f54:	11403fcc 	andi	r5,r2,255
81126f58:	2940201c 	xori	r5,r5,128
81126f5c:	297fe004 	addi	r5,r5,-128
81126f60:	00c00c04 	movi	r3,48
81126f64:	28c0e526 	beq	r5,r3,811272fc <_strtod_r+0x55c>
81126f68:	dcc00815 	stw	r19,32(sp)
81126f6c:	0025883a 	mov	r18,zero
81126f70:	10fff404 	addi	r3,r2,-48
81126f74:	18c03fcc 	andi	r3,r3,255
81126f78:	01000244 	movi	r4,9
81126f7c:	20c37536 	bltu	r4,r3,81127d54 <_strtod_r+0xfb4>
81126f80:	dd400817 	ldw	r21,32(sp)
81126f84:	0027883a 	mov	r19,zero
81126f88:	0039883a 	mov	fp,zero
81126f8c:	002d883a 	mov	r22,zero
81126f90:	01400204 	movi	r5,8
81126f94:	2d805a16 	blt	r5,r22,81127100 <_strtod_r+0x360>
81126f98:	e70002a4 	muli	fp,fp,10
81126f9c:	10c03fcc 	andi	r3,r2,255
81126fa0:	18c0201c 	xori	r3,r3,128
81126fa4:	18ffe004 	addi	r3,r3,-128
81126fa8:	e0f9883a 	add	fp,fp,r3
81126fac:	e73ff404 	addi	fp,fp,-48
81126fb0:	ad400044 	addi	r21,r21,1
81126fb4:	dd400615 	stw	r21,24(sp)
81126fb8:	a8800003 	ldbu	r2,0(r21)
81126fbc:	b5800044 	addi	r22,r22,1
81126fc0:	10fff404 	addi	r3,r2,-48
81126fc4:	18c03fcc 	andi	r3,r3,255
81126fc8:	20fff22e 	bgeu	r4,r3,81126f94 <__reset+0xfb106f94>
81126fcc:	14403fcc 	andi	r17,r2,255
81126fd0:	8c40201c 	xori	r17,r17,128
81126fd4:	8c7fe004 	addi	r17,r17,-128
81126fd8:	8009883a 	mov	r4,r16
81126fdc:	11243100 	call	81124310 <_localeconv_r>
81126fe0:	11400017 	ldw	r5,0(r2)
81126fe4:	8009883a 	mov	r4,r16
81126fe8:	d9401315 	stw	r5,76(sp)
81126fec:	11243100 	call	81124310 <_localeconv_r>
81126ff0:	11000017 	ldw	r4,0(r2)
81126ff4:	111b1180 	call	8111b118 <strlen>
81126ff8:	d9401317 	ldw	r5,76(sp)
81126ffc:	100d883a 	mov	r6,r2
81127000:	a809883a 	mov	r4,r21
81127004:	112c8fc0 	call	8112c8fc <strncmp>
81127008:	1000ce26 	beq	r2,zero,81127344 <_strtod_r+0x5a4>
8112700c:	b013883a 	mov	r9,r22
81127010:	000b883a 	mov	r5,zero
81127014:	0015883a 	mov	r10,zero
81127018:	0017883a 	mov	r11,zero
8112701c:	00801944 	movi	r2,101
81127020:	88807826 	beq	r17,r2,81127204 <_strtod_r+0x464>
81127024:	00801144 	movi	r2,69
81127028:	88807626 	beq	r17,r2,81127204 <_strtod_r+0x464>
8112702c:	002b883a 	mov	r21,zero
81127030:	48003d1e 	bne	r9,zero,81127128 <_strtod_r+0x388>
81127034:	2800391e 	bne	r5,zero,8112711c <_strtod_r+0x37c>
81127038:	9000381e 	bne	r18,zero,8112711c <_strtod_r+0x37c>
8112703c:	583fa71e 	bne	r11,zero,81126edc <__reset+0xfb106edc>
81127040:	00801384 	movi	r2,78
81127044:	88800526 	beq	r17,r2,8112705c <_strtod_r+0x2bc>
81127048:	147fa20e 	bge	r2,r17,81126ed4 <__reset+0xfb106ed4>
8112704c:	00801a44 	movi	r2,105
81127050:	8883d726 	beq	r17,r2,81127fb0 <_strtod_r+0x1210>
81127054:	00801b84 	movi	r2,110
81127058:	88bfa01e 	bne	r17,r2,81126edc <__reset+0xfb106edc>
8112705c:	01604534 	movhi	r5,33044
81127060:	d9000617 	ldw	r4,24(sp)
81127064:	2954b504 	addi	r5,r5,21204
81127068:	01c00644 	movi	r7,25
8112706c:	00000b06 	br	8112709c <_strtod_r+0x2fc>
81127070:	21000044 	addi	r4,r4,1
81127074:	20800003 	ldbu	r2,0(r4)
81127078:	10ffefc4 	addi	r3,r2,-65
8112707c:	10803fcc 	andi	r2,r2,255
81127080:	1080201c 	xori	r2,r2,128
81127084:	18c03fcc 	andi	r3,r3,255
81127088:	10bfe004 	addi	r2,r2,-128
8112708c:	38c00136 	bltu	r7,r3,81127094 <_strtod_r+0x2f4>
81127090:	10800804 	addi	r2,r2,32
81127094:	29400044 	addi	r5,r5,1
81127098:	11bf901e 	bne	r2,r6,81126edc <__reset+0xfb106edc>
8112709c:	29800007 	ldb	r6,0(r5)
811270a0:	303ff31e 	bne	r6,zero,81127070 <__reset+0xfb107070>
811270a4:	20800044 	addi	r2,r4,1
811270a8:	d8800615 	stw	r2,24(sp)
811270ac:	20c00047 	ldb	r3,1(r4)
811270b0:	00800a04 	movi	r2,40
811270b4:	18849d26 	beq	r3,r2,8112832c <_strtod_r+0x158c>
811270b8:	047ffe34 	movhi	r17,65528
811270bc:	0025883a 	mov	r18,zero
811270c0:	902b883a 	mov	r21,r18
811270c4:	882d883a 	mov	r22,r17
811270c8:	a03f8926 	beq	r20,zero,81126ef0 <__reset+0xfb106ef0>
811270cc:	ddc00617 	ldw	r23,24(sp)
811270d0:	003f8606 	br	81126eec <__reset+0xfb106eec>
811270d4:	00800044 	movi	r2,1
811270d8:	d8800715 	stw	r2,28(sp)
811270dc:	003f9606 	br	81126f38 <__reset+0xfb106f38>
811270e0:	21000044 	addi	r4,r4,1
811270e4:	d9000615 	stw	r4,24(sp)
811270e8:	20800003 	ldbu	r2,0(r4)
811270ec:	10c03fcc 	andi	r3,r2,255
811270f0:	28ff462e 	bgeu	r5,r3,81126e0c <__reset+0xfb106e0c>
811270f4:	2027883a 	mov	r19,r4
811270f8:	d8000715 	stw	zero,28(sp)
811270fc:	003f9506 	br	81126f54 <__reset+0xfb106f54>
81127100:	9cc002a4 	muli	r19,r19,10
81127104:	10803fcc 	andi	r2,r2,255
81127108:	1080201c 	xori	r2,r2,128
8112710c:	10bfe004 	addi	r2,r2,-128
81127110:	9885883a 	add	r2,r19,r2
81127114:	14fff404 	addi	r19,r2,-48
81127118:	003fa506 	br	81126fb0 <__reset+0xfb106fb0>
8112711c:	002b883a 	mov	r21,zero
81127120:	002d883a 	mov	r22,zero
81127124:	003fe806 	br	811270c8 <__reset+0xfb1070c8>
81127128:	aaabc83a 	sub	r21,r21,r10
8112712c:	b000011e 	bne	r22,zero,81127134 <_strtod_r+0x394>
81127130:	482d883a 	mov	r22,r9
81127134:	00800404 	movi	r2,16
81127138:	482f883a 	mov	r23,r9
8112713c:	1240010e 	bge	r2,r9,81127144 <_strtod_r+0x3a4>
81127140:	102f883a 	mov	r23,r2
81127144:	e009883a 	mov	r4,fp
81127148:	da401315 	stw	r9,76(sp)
8112714c:	112eebc0 	call	8112eebc <__floatunsidf>
81127150:	1025883a 	mov	r18,r2
81127154:	00800244 	movi	r2,9
81127158:	1823883a 	mov	r17,r3
8112715c:	da401317 	ldw	r9,76(sp)
81127160:	15c0160e 	bge	r2,r23,811271bc <_strtod_r+0x41c>
81127164:	b8bffdc4 	addi	r2,r23,-9
81127168:	100490fa 	slli	r2,r2,3
8112716c:	180b883a 	mov	r5,r3
81127170:	00e04534 	movhi	r3,33044
81127174:	18d48004 	addi	r3,r3,20992
81127178:	1885883a 	add	r2,r3,r2
8112717c:	11800017 	ldw	r6,0(r2)
81127180:	11c00117 	ldw	r7,4(r2)
81127184:	9009883a 	mov	r4,r18
81127188:	11196d00 	call	811196d0 <__muldf3>
8112718c:	9809883a 	mov	r4,r19
81127190:	1025883a 	mov	r18,r2
81127194:	1823883a 	mov	r17,r3
81127198:	112eebc0 	call	8112eebc <__floatunsidf>
8112719c:	9009883a 	mov	r4,r18
811271a0:	880b883a 	mov	r5,r17
811271a4:	100d883a 	mov	r6,r2
811271a8:	180f883a 	mov	r7,r3
811271ac:	112db9c0 	call	8112db9c <__adddf3>
811271b0:	da401317 	ldw	r9,76(sp)
811271b4:	1025883a 	mov	r18,r2
811271b8:	1823883a 	mov	r17,r3
811271bc:	008003c4 	movi	r2,15
811271c0:	12407b16 	blt	r2,r9,811273b0 <_strtod_r+0x610>
811271c4:	a83fbe26 	beq	r21,zero,811270c0 <__reset+0xfb1070c0>
811271c8:	0543670e 	bge	zero,r21,81127f68 <_strtod_r+0x11c8>
811271cc:	00c00584 	movi	r3,22
811271d0:	1d42e816 	blt	r3,r21,81127d74 <_strtod_r+0xfd4>
811271d4:	a82a90fa 	slli	r21,r21,3
811271d8:	00a04534 	movhi	r2,33044
811271dc:	10948004 	addi	r2,r2,20992
811271e0:	1545883a 	add	r2,r2,r21
811271e4:	11000017 	ldw	r4,0(r2)
811271e8:	11400117 	ldw	r5,4(r2)
811271ec:	900d883a 	mov	r6,r18
811271f0:	880f883a 	mov	r7,r17
811271f4:	11196d00 	call	811196d0 <__muldf3>
811271f8:	102b883a 	mov	r21,r2
811271fc:	182d883a 	mov	r22,r3
81127200:	003fb106 	br	811270c8 <__reset+0xfb1070c8>
81127204:	4801b526 	beq	r9,zero,811278dc <_strtod_r+0xb3c>
81127208:	ddc00617 	ldw	r23,24(sp)
8112720c:	00c00ac4 	movi	r3,43
81127210:	b8800044 	addi	r2,r23,1
81127214:	d8800615 	stw	r2,24(sp)
81127218:	b8800047 	ldb	r2,1(r23)
8112721c:	10c1e926 	beq	r2,r3,811279c4 <_strtod_r+0xc24>
81127220:	00c00b44 	movi	r3,45
81127224:	10c1ec26 	beq	r2,r3,811279d8 <_strtod_r+0xc38>
81127228:	1023883a 	mov	r17,r2
8112722c:	0019883a 	mov	r12,zero
81127230:	88bff404 	addi	r2,r17,-48
81127234:	00c00244 	movi	r3,9
81127238:	1881b736 	bltu	r3,r2,81127918 <_strtod_r+0xb78>
8112723c:	00800c04 	movi	r2,48
81127240:	8880071e 	bne	r17,r2,81127260 <_strtod_r+0x4c0>
81127244:	d8800617 	ldw	r2,24(sp)
81127248:	8807883a 	mov	r3,r17
8112724c:	10800044 	addi	r2,r2,1
81127250:	d8800615 	stw	r2,24(sp)
81127254:	14400007 	ldb	r17,0(r2)
81127258:	10800044 	addi	r2,r2,1
8112725c:	88fffc26 	beq	r17,r3,81127250 <__reset+0xfb107250>
81127260:	88bff3c4 	addi	r2,r17,-49
81127264:	00c00204 	movi	r3,8
81127268:	18bf7036 	bltu	r3,r2,8112702c <__reset+0xfb10702c>
8112726c:	db800617 	ldw	r14,24(sp)
81127270:	88bff404 	addi	r2,r17,-48
81127274:	03400244 	movi	r13,9
81127278:	71c00044 	addi	r7,r14,1
8112727c:	d9c00615 	stw	r7,24(sp)
81127280:	74400043 	ldbu	r17,1(r14)
81127284:	88fff404 	addi	r3,r17,-48
81127288:	8c403fcc 	andi	r17,r17,255
8112728c:	8c40201c 	xori	r17,r17,128
81127290:	18c03fcc 	andi	r3,r3,255
81127294:	8c7fe004 	addi	r17,r17,-128
81127298:	68c00e36 	bltu	r13,r3,811272d4 <_strtod_r+0x534>
8112729c:	71000084 	addi	r4,r14,2
811272a0:	d9000615 	stw	r4,24(sp)
811272a4:	108002a4 	muli	r2,r2,10
811272a8:	21800003 	ldbu	r6,0(r4)
811272ac:	200f883a 	mov	r7,r4
811272b0:	1463883a 	add	r17,r2,r17
811272b4:	30fff404 	addi	r3,r6,-48
811272b8:	88bff404 	addi	r2,r17,-48
811272bc:	34403fcc 	andi	r17,r6,255
811272c0:	8c40201c 	xori	r17,r17,128
811272c4:	18c03fcc 	andi	r3,r3,255
811272c8:	8c7fe004 	addi	r17,r17,-128
811272cc:	21000044 	addi	r4,r4,1
811272d0:	68fff32e 	bgeu	r13,r3,811272a0 <__reset+0xfb1072a0>
811272d4:	3b8fc83a 	sub	r7,r7,r14
811272d8:	00c00204 	movi	r3,8
811272dc:	19c29716 	blt	r3,r7,81127d3c <_strtod_r+0xf9c>
811272e0:	102b883a 	mov	r21,r2
811272e4:	009387c4 	movi	r2,19999
811272e8:	1540010e 	bge	r2,r21,811272f0 <_strtod_r+0x550>
811272ec:	102b883a 	mov	r21,r2
811272f0:	603f4f26 	beq	r12,zero,81127030 <__reset+0xfb107030>
811272f4:	056bc83a 	sub	r21,zero,r21
811272f8:	003f4d06 	br	81127030 <__reset+0xfb107030>
811272fc:	98800047 	ldb	r2,1(r19)
81127300:	00c01604 	movi	r3,88
81127304:	10c1de26 	beq	r2,r3,81127a80 <_strtod_r+0xce0>
81127308:	00c01e04 	movi	r3,120
8112730c:	10c1dc26 	beq	r2,r3,81127a80 <_strtod_r+0xce0>
81127310:	98c00044 	addi	r3,r19,1
81127314:	1827883a 	mov	r19,r3
81127318:	d8c00615 	stw	r3,24(sp)
8112731c:	18c00044 	addi	r3,r3,1
81127320:	18bfffc3 	ldbu	r2,-1(r3)
81127324:	11003fcc 	andi	r4,r2,255
81127328:	2100201c 	xori	r4,r4,128
8112732c:	213fe004 	addi	r4,r4,-128
81127330:	217ff826 	beq	r4,r5,81127314 <__reset+0xfb107314>
81127334:	203f7926 	beq	r4,zero,8112711c <__reset+0xfb10711c>
81127338:	dcc00815 	stw	r19,32(sp)
8112733c:	04800044 	movi	r18,1
81127340:	003f0b06 	br	81126f70 <__reset+0xfb106f70>
81127344:	8009883a 	mov	r4,r16
81127348:	11243100 	call	81124310 <_localeconv_r>
8112734c:	11000017 	ldw	r4,0(r2)
81127350:	111b1180 	call	8111b118 <strlen>
81127354:	d8c00617 	ldw	r3,24(sp)
81127358:	1885883a 	add	r2,r3,r2
8112735c:	d8800615 	stw	r2,24(sp)
81127360:	14400007 	ldb	r17,0(r2)
81127364:	b001881e 	bne	r22,zero,81127988 <_strtod_r+0xbe8>
81127368:	00c00c04 	movi	r3,48
8112736c:	88c3391e 	bne	r17,r3,81128054 <_strtod_r+0x12b4>
81127370:	10c00044 	addi	r3,r2,1
81127374:	8809883a 	mov	r4,r17
81127378:	d8c00615 	stw	r3,24(sp)
8112737c:	1c400007 	ldb	r17,0(r3)
81127380:	188bc83a 	sub	r5,r3,r2
81127384:	18c00044 	addi	r3,r3,1
81127388:	893ffb26 	beq	r17,r4,81127378 <__reset+0xfb107378>
8112738c:	88bff3c4 	addi	r2,r17,-49
81127390:	00c00204 	movi	r3,8
81127394:	1882e72e 	bgeu	r3,r2,81127f34 <_strtod_r+0x1194>
81127398:	00801944 	movi	r2,101
8112739c:	88814d26 	beq	r17,r2,811278d4 <_strtod_r+0xb34>
811273a0:	0013883a 	mov	r9,zero
811273a4:	0015883a 	mov	r10,zero
811273a8:	02c00044 	movi	r11,1
811273ac:	003f1d06 	br	81127024 <__reset+0xfb107024>
811273b0:	4defc83a 	sub	r23,r9,r23
811273b4:	bd6f883a 	add	r23,r23,r21
811273b8:	05c21e0e 	bge	zero,r23,81127c34 <_strtod_r+0xe94>
811273bc:	b88003cc 	andi	r2,r23,15
811273c0:	10000d26 	beq	r2,zero,811273f8 <_strtod_r+0x658>
811273c4:	100490fa 	slli	r2,r2,3
811273c8:	00e04534 	movhi	r3,33044
811273cc:	18d48004 	addi	r3,r3,20992
811273d0:	1885883a 	add	r2,r3,r2
811273d4:	11000017 	ldw	r4,0(r2)
811273d8:	11400117 	ldw	r5,4(r2)
811273dc:	900d883a 	mov	r6,r18
811273e0:	880f883a 	mov	r7,r17
811273e4:	da401315 	stw	r9,76(sp)
811273e8:	11196d00 	call	811196d0 <__muldf3>
811273ec:	da401317 	ldw	r9,76(sp)
811273f0:	1025883a 	mov	r18,r2
811273f4:	1823883a 	mov	r17,r3
811273f8:	023ffc04 	movi	r8,-16
811273fc:	ba10703a 	and	r8,r23,r8
81127400:	40003c26 	beq	r8,zero,811274f4 <_strtod_r+0x754>
81127404:	00804d04 	movi	r2,308
81127408:	1201cd16 	blt	r2,r8,81127b40 <_strtod_r+0xda0>
8112740c:	4011d13a 	srai	r8,r8,4
81127410:	03000044 	movi	r12,1
81127414:	62037c0e 	bge	r12,r8,81128208 <_strtod_r+0x1468>
81127418:	01204534 	movhi	r4,33044
8112741c:	21147604 	addi	r4,r4,20952
81127420:	2015883a 	mov	r10,r4
81127424:	0027883a 	mov	r19,zero
81127428:	d9000915 	stw	r4,36(sp)
8112742c:	9005883a 	mov	r2,r18
81127430:	8807883a 	mov	r3,r17
81127434:	dc000c15 	stw	r16,48(sp)
81127438:	dc800e15 	stw	r18,56(sp)
8112743c:	9821883a 	mov	r16,r19
81127440:	0009883a 	mov	r4,zero
81127444:	8827883a 	mov	r19,r17
81127448:	602f883a 	mov	r23,r12
8112744c:	da400a15 	stw	r9,40(sp)
81127450:	5025883a 	mov	r18,r10
81127454:	4023883a 	mov	r17,r8
81127458:	8980004c 	andi	r6,r17,1
8112745c:	30000626 	beq	r6,zero,81127478 <_strtod_r+0x6d8>
81127460:	91800017 	ldw	r6,0(r18)
81127464:	91c00117 	ldw	r7,4(r18)
81127468:	1009883a 	mov	r4,r2
8112746c:	180b883a 	mov	r5,r3
81127470:	11196d00 	call	811196d0 <__muldf3>
81127474:	01000044 	movi	r4,1
81127478:	8823d07a 	srai	r17,r17,1
8112747c:	84000044 	addi	r16,r16,1
81127480:	94800204 	addi	r18,r18,8
81127484:	8dfff41e 	bne	r17,r23,81127458 <__reset+0xfb107458>
81127488:	21003fcc 	andi	r4,r4,255
8112748c:	9823883a 	mov	r17,r19
81127490:	da400a17 	ldw	r9,40(sp)
81127494:	8027883a 	mov	r19,r16
81127498:	dc800e17 	ldw	r18,56(sp)
8112749c:	dc000c17 	ldw	r16,48(sp)
811274a0:	2003b11e 	bne	r4,zero,81128368 <_strtod_r+0x15c8>
811274a4:	981690fa 	slli	r11,r19,3
811274a8:	d8800917 	ldw	r2,36(sp)
811274ac:	01ff2c34 	movhi	r7,64688
811274b0:	900d883a 	mov	r6,r18
811274b4:	12ef883a 	add	r23,r2,r11
811274b8:	b9000017 	ldw	r4,0(r23)
811274bc:	b9400117 	ldw	r5,4(r23)
811274c0:	89cf883a 	add	r7,r17,r7
811274c4:	da401315 	stw	r9,76(sp)
811274c8:	11196d00 	call	811196d0 <__muldf3>
811274cc:	1025883a 	mov	r18,r2
811274d0:	011f2834 	movhi	r4,31904
811274d4:	189ffc2c 	andhi	r2,r3,32752
811274d8:	da401317 	ldw	r9,76(sp)
811274dc:	20819836 	bltu	r4,r2,81127b40 <_strtod_r+0xda0>
811274e0:	011f2434 	movhi	r4,31888
811274e4:	2083382e 	bgeu	r4,r2,811281c8 <_strtod_r+0x1428>
811274e8:	045ffc34 	movhi	r17,32752
811274ec:	8c7fffc4 	addi	r17,r17,-1
811274f0:	04bfffc4 	movi	r18,-1
811274f4:	d8000915 	stw	zero,36(sp)
811274f8:	d9400817 	ldw	r5,32(sp)
811274fc:	df000015 	stw	fp,0(sp)
81127500:	480f883a 	mov	r7,r9
81127504:	b00d883a 	mov	r6,r22
81127508:	8009883a 	mov	r4,r16
8112750c:	112539c0 	call	8112539c <__s2b>
81127510:	d8800815 	stw	r2,32(sp)
81127514:	10018a26 	beq	r2,zero,81127b40 <_strtod_r+0xda0>
81127518:	a807d7fa 	srai	r3,r21,31
8112751c:	0545c83a 	sub	r2,zero,r21
81127520:	dd400a15 	stw	r21,40(sp)
81127524:	1886703a 	and	r3,r3,r2
81127528:	d8c00c15 	stw	r3,48(sp)
8112752c:	a8013516 	blt	r21,zero,81127a04 <_strtod_r+0xc64>
81127530:	d9400817 	ldw	r5,32(sp)
81127534:	0011883a 	mov	r8,zero
81127538:	0027883a 	mov	r19,zero
8112753c:	29400304 	addi	r5,r5,12
81127540:	d9400f15 	stw	r5,60(sp)
81127544:	402b883a 	mov	r21,r8
81127548:	dd001215 	stw	r20,72(sp)
8112754c:	d8800817 	ldw	r2,32(sp)
81127550:	8009883a 	mov	r4,r16
81127554:	11400117 	ldw	r5,4(r2)
81127558:	112519c0 	call	8112519c <_Balloc>
8112755c:	1029883a 	mov	r20,r2
81127560:	10012d26 	beq	r2,zero,81127a18 <_strtod_r+0xc78>
81127564:	d8c00817 	ldw	r3,32(sp)
81127568:	d9400f17 	ldw	r5,60(sp)
8112756c:	11000304 	addi	r4,r2,12
81127570:	19800417 	ldw	r6,16(r3)
81127574:	31800084 	addi	r6,r6,2
81127578:	318d883a 	add	r6,r6,r6
8112757c:	318d883a 	add	r6,r6,r6
81127580:	111abac0 	call	8111abac <memcpy>
81127584:	d9000204 	addi	r4,sp,8
81127588:	d9000015 	stw	r4,0(sp)
8112758c:	d9c00404 	addi	r7,sp,16
81127590:	900b883a 	mov	r5,r18
81127594:	880d883a 	mov	r6,r17
81127598:	8009883a 	mov	r4,r16
8112759c:	1125e780 	call	81125e78 <__d2b>
811275a0:	d8800515 	stw	r2,20(sp)
811275a4:	dc801115 	stw	r18,68(sp)
811275a8:	dc401015 	stw	r17,64(sp)
811275ac:	10027c26 	beq	r2,zero,81127fa0 <_strtod_r+0x1200>
811275b0:	01400044 	movi	r5,1
811275b4:	8009883a 	mov	r4,r16
811275b8:	11255c00 	call	811255c0 <__i2b>
811275bc:	1027883a 	mov	r19,r2
811275c0:	10011526 	beq	r2,zero,81127a18 <_strtod_r+0xc78>
811275c4:	d8800417 	ldw	r2,16(sp)
811275c8:	1000c816 	blt	r2,zero,811278ec <_strtod_r+0xb4c>
811275cc:	d9400c17 	ldw	r5,48(sp)
811275d0:	d9000a17 	ldw	r4,40(sp)
811275d4:	28ad883a 	add	r22,r5,r2
811275d8:	d9400917 	ldw	r5,36(sp)
811275dc:	df000217 	ldw	fp,8(sp)
811275e0:	05ff0084 	movi	r23,-1022
811275e4:	1147c83a 	sub	r3,r2,r5
811275e8:	1f07883a 	add	r3,r3,fp
811275ec:	00800d84 	movi	r2,54
811275f0:	18ffffc4 	addi	r3,r3,-1
811275f4:	1739c83a 	sub	fp,r2,fp
811275f8:	1dc0a50e 	bge	r3,r23,81127890 <_strtod_r+0xaf0>
811275fc:	b8efc83a 	sub	r23,r23,r3
81127600:	008007c4 	movi	r2,31
81127604:	e5f9c83a 	sub	fp,fp,r23
81127608:	15c0bc16 	blt	r2,r23,811278fc <_strtod_r+0xb5c>
8112760c:	00800044 	movi	r2,1
81127610:	15c4983a 	sll	r2,r2,r23
81127614:	d8000b15 	stw	zero,44(sp)
81127618:	d8800d15 	stw	r2,52(sp)
8112761c:	2707883a 	add	r3,r4,fp
81127620:	d9000917 	ldw	r4,36(sp)
81127624:	b739883a 	add	fp,r22,fp
81127628:	20ef883a 	add	r23,r4,r3
8112762c:	b009883a 	mov	r4,r22
81127630:	e580010e 	bge	fp,r22,81127638 <_strtod_r+0x898>
81127634:	e009883a 	mov	r4,fp
81127638:	b805883a 	mov	r2,r23
8112763c:	25c0010e 	bge	r4,r23,81127644 <_strtod_r+0x8a4>
81127640:	2005883a 	mov	r2,r4
81127644:	0080030e 	bge	zero,r2,81127654 <_strtod_r+0x8b4>
81127648:	e0b9c83a 	sub	fp,fp,r2
8112764c:	b8afc83a 	sub	r23,r23,r2
81127650:	b0adc83a 	sub	r22,r22,r2
81127654:	d9400c17 	ldw	r5,48(sp)
81127658:	28001126 	beq	r5,zero,811276a0 <_strtod_r+0x900>
8112765c:	280d883a 	mov	r6,r5
81127660:	8009883a 	mov	r4,r16
81127664:	980b883a 	mov	r5,r19
81127668:	11258040 	call	81125804 <__pow5mult>
8112766c:	1027883a 	mov	r19,r2
81127670:	1000e926 	beq	r2,zero,81127a18 <_strtod_r+0xc78>
81127674:	d9800517 	ldw	r6,20(sp)
81127678:	100b883a 	mov	r5,r2
8112767c:	8009883a 	mov	r4,r16
81127680:	11256040 	call	81125604 <__multiply>
81127684:	1000e426 	beq	r2,zero,81127a18 <_strtod_r+0xc78>
81127688:	d9400517 	ldw	r5,20(sp)
8112768c:	8009883a 	mov	r4,r16
81127690:	d8801315 	stw	r2,76(sp)
81127694:	112524c0 	call	8112524c <_Bfree>
81127698:	d8801317 	ldw	r2,76(sp)
8112769c:	d8800515 	stw	r2,20(sp)
811276a0:	0700060e 	bge	zero,fp,811276bc <_strtod_r+0x91c>
811276a4:	d9400517 	ldw	r5,20(sp)
811276a8:	e00d883a 	mov	r6,fp
811276ac:	8009883a 	mov	r4,r16
811276b0:	112594c0 	call	8112594c <__lshift>
811276b4:	d8800515 	stw	r2,20(sp)
811276b8:	10023926 	beq	r2,zero,81127fa0 <_strtod_r+0x1200>
811276bc:	d8800a17 	ldw	r2,40(sp)
811276c0:	10000626 	beq	r2,zero,811276dc <_strtod_r+0x93c>
811276c4:	d9800a17 	ldw	r6,40(sp)
811276c8:	a00b883a 	mov	r5,r20
811276cc:	8009883a 	mov	r4,r16
811276d0:	11258040 	call	81125804 <__pow5mult>
811276d4:	1029883a 	mov	r20,r2
811276d8:	1000cf26 	beq	r2,zero,81127a18 <_strtod_r+0xc78>
811276dc:	05c0060e 	bge	zero,r23,811276f8 <_strtod_r+0x958>
811276e0:	a00b883a 	mov	r5,r20
811276e4:	b80d883a 	mov	r6,r23
811276e8:	8009883a 	mov	r4,r16
811276ec:	112594c0 	call	8112594c <__lshift>
811276f0:	1029883a 	mov	r20,r2
811276f4:	1000c826 	beq	r2,zero,81127a18 <_strtod_r+0xc78>
811276f8:	0580060e 	bge	zero,r22,81127714 <_strtod_r+0x974>
811276fc:	980b883a 	mov	r5,r19
81127700:	b00d883a 	mov	r6,r22
81127704:	8009883a 	mov	r4,r16
81127708:	112594c0 	call	8112594c <__lshift>
8112770c:	1027883a 	mov	r19,r2
81127710:	1000c126 	beq	r2,zero,81127a18 <_strtod_r+0xc78>
81127714:	d9400517 	ldw	r5,20(sp)
81127718:	a00d883a 	mov	r6,r20
8112771c:	8009883a 	mov	r4,r16
81127720:	1125afc0 	call	81125afc <__mdiff>
81127724:	102b883a 	mov	r21,r2
81127728:	1000bb26 	beq	r2,zero,81127a18 <_strtod_r+0xc78>
8112772c:	10c00317 	ldw	r3,12(r2)
81127730:	980b883a 	mov	r5,r19
81127734:	10000315 	stw	zero,12(r2)
81127738:	1009883a 	mov	r4,r2
8112773c:	d8c00e15 	stw	r3,56(sp)
81127740:	1125a9c0 	call	81125a9c <__mcmp>
81127744:	10027616 	blt	r2,zero,81128120 <_strtod_r+0x1380>
81127748:	10024426 	beq	r2,zero,8112805c <_strtod_r+0x12bc>
8112774c:	980b883a 	mov	r5,r19
81127750:	a809883a 	mov	r4,r21
81127754:	1125fcc0 	call	81125fcc <__ratio>
81127758:	000d883a 	mov	r6,zero
8112775c:	01d00034 	movhi	r7,16384
81127760:	1009883a 	mov	r4,r2
81127764:	180b883a 	mov	r5,r3
81127768:	102f883a 	mov	r23,r2
8112776c:	182d883a 	mov	r22,r3
81127770:	112edc80 	call	8112edc8 <__ledf2>
81127774:	00804a16 	blt	zero,r2,811278a0 <_strtod_r+0xb00>
81127778:	d9400e17 	ldw	r5,56(sp)
8112777c:	28006b26 	beq	r5,zero,8112792c <_strtod_r+0xb8c>
81127780:	058ffc34 	movhi	r22,16368
81127784:	d8000b15 	stw	zero,44(sp)
81127788:	d8000d15 	stw	zero,52(sp)
8112778c:	b02f883a 	mov	r23,r22
81127790:	8f1ffc2c 	andhi	fp,r17,32752
81127794:	009ff834 	movhi	r2,32736
81127798:	e080cd26 	beq	fp,r2,81127ad0 <_strtod_r+0xd30>
8112779c:	d9400917 	ldw	r5,36(sp)
811277a0:	28001a26 	beq	r5,zero,8112780c <_strtod_r+0xa6c>
811277a4:	0081a834 	movhi	r2,1696
811277a8:	17001836 	bltu	r2,fp,8112780c <_strtod_r+0xa6c>
811277ac:	d9000d17 	ldw	r4,52(sp)
811277b0:	01d07834 	movhi	r7,16864
811277b4:	39ffffc4 	addi	r7,r7,-1
811277b8:	01bff034 	movhi	r6,65472
811277bc:	b80b883a 	mov	r5,r23
811277c0:	112edc80 	call	8112edc8 <__ledf2>
811277c4:	00800e16 	blt	zero,r2,81127800 <_strtod_r+0xa60>
811277c8:	d9000d17 	ldw	r4,52(sp)
811277cc:	b80b883a 	mov	r5,r23
811277d0:	1118c340 	call	81118c34 <__fixunsdfsi>
811277d4:	10018126 	beq	r2,zero,81127ddc <_strtod_r+0x103c>
811277d8:	1009883a 	mov	r4,r2
811277dc:	112eebc0 	call	8112eebc <__floatunsidf>
811277e0:	d8800d15 	stw	r2,52(sp)
811277e4:	182f883a 	mov	r23,r3
811277e8:	d8800e17 	ldw	r2,56(sp)
811277ec:	1001791e 	bne	r2,zero,81127dd4 <_strtod_r+0x1034>
811277f0:	ba20003c 	xorhi	r8,r23,32768
811277f4:	d8c00d17 	ldw	r3,52(sp)
811277f8:	402d883a 	mov	r22,r8
811277fc:	d8c00b15 	stw	r3,44(sp)
81127800:	0081ac34 	movhi	r2,1712
81127804:	b091883a 	add	r8,r22,r2
81127808:	472dc83a 	sub	r22,r8,fp
8112780c:	9009883a 	mov	r4,r18
81127810:	880b883a 	mov	r5,r17
81127814:	1125d000 	call	81125d00 <__ulp>
81127818:	d9000b17 	ldw	r4,44(sp)
8112781c:	b00b883a 	mov	r5,r22
81127820:	100d883a 	mov	r6,r2
81127824:	180f883a 	mov	r7,r3
81127828:	11196d00 	call	811196d0 <__muldf3>
8112782c:	900d883a 	mov	r6,r18
81127830:	880f883a 	mov	r7,r17
81127834:	1009883a 	mov	r4,r2
81127838:	180b883a 	mov	r5,r3
8112783c:	112db9c0 	call	8112db9c <__adddf3>
81127840:	1025883a 	mov	r18,r2
81127844:	1823883a 	mov	r17,r3
81127848:	182d883a 	mov	r22,r3
8112784c:	d9000917 	ldw	r4,36(sp)
81127850:	2000021e 	bne	r4,zero,8112785c <_strtod_r+0xabc>
81127854:	b09ffc2c 	andhi	r2,r22,32752
81127858:	e080be26 	beq	fp,r2,81127b54 <_strtod_r+0xdb4>
8112785c:	d9400517 	ldw	r5,20(sp)
81127860:	8009883a 	mov	r4,r16
81127864:	112524c0 	call	8112524c <_Bfree>
81127868:	a00b883a 	mov	r5,r20
8112786c:	8009883a 	mov	r4,r16
81127870:	112524c0 	call	8112524c <_Bfree>
81127874:	980b883a 	mov	r5,r19
81127878:	8009883a 	mov	r4,r16
8112787c:	112524c0 	call	8112524c <_Bfree>
81127880:	a80b883a 	mov	r5,r21
81127884:	8009883a 	mov	r4,r16
81127888:	112524c0 	call	8112524c <_Bfree>
8112788c:	003f2f06 	br	8112754c <__reset+0xfb10754c>
81127890:	00c00044 	movi	r3,1
81127894:	d8000b15 	stw	zero,44(sp)
81127898:	d8c00d15 	stw	r3,52(sp)
8112789c:	003f5f06 	br	8112761c <__reset+0xfb10761c>
811278a0:	b809883a 	mov	r4,r23
811278a4:	000d883a 	mov	r6,zero
811278a8:	01cff834 	movhi	r7,16352
811278ac:	b00b883a 	mov	r5,r22
811278b0:	11196d00 	call	811196d0 <__muldf3>
811278b4:	d9000e17 	ldw	r4,56(sp)
811278b8:	d8800d15 	stw	r2,52(sp)
811278bc:	182f883a 	mov	r23,r3
811278c0:	2000181e 	bne	r4,zero,81127924 <_strtod_r+0xb84>
811278c4:	1a20003c 	xorhi	r8,r3,32768
811278c8:	d8800b15 	stw	r2,44(sp)
811278cc:	402d883a 	mov	r22,r8
811278d0:	003faf06 	br	81127790 <__reset+0xfb107790>
811278d4:	0015883a 	mov	r10,zero
811278d8:	02c00044 	movi	r11,1
811278dc:	2800011e 	bne	r5,zero,811278e4 <_strtod_r+0xb44>
811278e0:	903d7e26 	beq	r18,zero,81126edc <__reset+0xfb106edc>
811278e4:	0013883a 	mov	r9,zero
811278e8:	003e4706 	br	81127208 <__reset+0xfb107208>
811278ec:	d8c00a17 	ldw	r3,40(sp)
811278f0:	dd800c17 	ldw	r22,48(sp)
811278f4:	1889c83a 	sub	r4,r3,r2
811278f8:	003f3706 	br	811275d8 <__reset+0xfb1075d8>
811278fc:	00bef884 	movi	r2,-1054
81127900:	05c00044 	movi	r23,1
81127904:	10c5c83a 	sub	r2,r2,r3
81127908:	b884983a 	sll	r2,r23,r2
8112790c:	ddc00d15 	stw	r23,52(sp)
81127910:	d8800b15 	stw	r2,44(sp)
81127914:	003f4106 	br	8112761c <__reset+0xfb10761c>
81127918:	ddc00615 	stw	r23,24(sp)
8112791c:	002b883a 	mov	r21,zero
81127920:	003dc306 	br	81127030 <__reset+0xfb107030>
81127924:	1811883a 	mov	r8,r3
81127928:	003fe706 	br	811278c8 <__reset+0xfb1078c8>
8112792c:	90002e1e 	bne	r18,zero,811279e8 <_strtod_r+0xc48>
81127930:	00c00434 	movhi	r3,16
81127934:	18ffffc4 	addi	r3,r3,-1
81127938:	88c4703a 	and	r2,r17,r3
8112793c:	10002c1e 	bne	r2,zero,811279f0 <_strtod_r+0xc50>
81127940:	000d883a 	mov	r6,zero
81127944:	01cffc34 	movhi	r7,16368
81127948:	b809883a 	mov	r4,r23
8112794c:	b00b883a 	mov	r5,r22
81127950:	112edc80 	call	8112edc8 <__ledf2>
81127954:	10021716 	blt	r2,zero,811281b4 <_strtod_r+0x1414>
81127958:	b809883a 	mov	r4,r23
8112795c:	b00b883a 	mov	r5,r22
81127960:	000d883a 	mov	r6,zero
81127964:	01cff834 	movhi	r7,16352
81127968:	11196d00 	call	811196d0 <__muldf3>
8112796c:	d8800d15 	stw	r2,52(sp)
81127970:	182f883a 	mov	r23,r3
81127974:	102d883a 	mov	r22,r2
81127978:	1a20003c 	xorhi	r8,r3,32768
8112797c:	dd800b15 	stw	r22,44(sp)
81127980:	402d883a 	mov	r22,r8
81127984:	003f8206 	br	81127790 <__reset+0xfb107790>
81127988:	b013883a 	mov	r9,r22
8112798c:	000b883a 	mov	r5,zero
81127990:	0015883a 	mov	r10,zero
81127994:	893ff404 	addi	r4,r17,-48
81127998:	00800244 	movi	r2,9
8112799c:	11001036 	bltu	r2,r4,811279e0 <_strtod_r+0xc40>
811279a0:	28c00044 	addi	r3,r5,1
811279a4:	2023883a 	mov	r17,r4
811279a8:	20014d1e 	bne	r4,zero,81127ee0 <_strtod_r+0x1140>
811279ac:	d9800617 	ldw	r6,24(sp)
811279b0:	180b883a 	mov	r5,r3
811279b4:	30800044 	addi	r2,r6,1
811279b8:	d8800615 	stw	r2,24(sp)
811279bc:	34400047 	ldb	r17,1(r6)
811279c0:	003ff406 	br	81127994 <__reset+0xfb107994>
811279c4:	0019883a 	mov	r12,zero
811279c8:	b8800084 	addi	r2,r23,2
811279cc:	d8800615 	stw	r2,24(sp)
811279d0:	bc400087 	ldb	r17,2(r23)
811279d4:	003e1606 	br	81127230 <__reset+0xfb107230>
811279d8:	03000044 	movi	r12,1
811279dc:	003ffa06 	br	811279c8 <__reset+0xfb1079c8>
811279e0:	02c00044 	movi	r11,1
811279e4:	003d8d06 	br	8112701c <__reset+0xfb10701c>
811279e8:	00800044 	movi	r2,1
811279ec:	9080fe26 	beq	r18,r2,81127de8 <_strtod_r+0x1048>
811279f0:	d8000b15 	stw	zero,44(sp)
811279f4:	05affc34 	movhi	r22,49136
811279f8:	d8000d15 	stw	zero,52(sp)
811279fc:	05cffc34 	movhi	r23,16368
81127a00:	003f6306 	br	81127790 <__reset+0xfb107790>
81127a04:	d8000a15 	stw	zero,40(sp)
81127a08:	003ec906 	br	81127530 <__reset+0xfb107530>
81127a0c:	d9001117 	ldw	r4,68(sp)
81127a10:	00bfffc4 	movi	r2,-1
81127a14:	2080461e 	bne	r4,r2,81127b30 <_strtod_r+0xd90>
81127a18:	dd000a15 	stw	r20,40(sp)
81127a1c:	dd001217 	ldw	r20,72(sp)
81127a20:	a811883a 	mov	r8,r21
81127a24:	d8800517 	ldw	r2,20(sp)
81127a28:	00c00884 	movi	r3,34
81127a2c:	80c00015 	stw	r3,0(r16)
81127a30:	002b883a 	mov	r21,zero
81127a34:	059ffc34 	movhi	r22,32752
81127a38:	100b883a 	mov	r5,r2
81127a3c:	8009883a 	mov	r4,r16
81127a40:	da001315 	stw	r8,76(sp)
81127a44:	112524c0 	call	8112524c <_Bfree>
81127a48:	d9400a17 	ldw	r5,40(sp)
81127a4c:	8009883a 	mov	r4,r16
81127a50:	112524c0 	call	8112524c <_Bfree>
81127a54:	980b883a 	mov	r5,r19
81127a58:	8009883a 	mov	r4,r16
81127a5c:	112524c0 	call	8112524c <_Bfree>
81127a60:	d9400817 	ldw	r5,32(sp)
81127a64:	8009883a 	mov	r4,r16
81127a68:	112524c0 	call	8112524c <_Bfree>
81127a6c:	da001317 	ldw	r8,76(sp)
81127a70:	8009883a 	mov	r4,r16
81127a74:	400b883a 	mov	r5,r8
81127a78:	112524c0 	call	8112524c <_Bfree>
81127a7c:	003d9206 	br	811270c8 <__reset+0xfb1070c8>
81127a80:	d8c00717 	ldw	r3,28(sp)
81127a84:	d8800504 	addi	r2,sp,20
81127a88:	01a04534 	movhi	r6,33044
81127a8c:	3194bb04 	addi	r6,r6,21228
81127a90:	d8c00115 	stw	r3,4(sp)
81127a94:	d8800015 	stw	r2,0(sp)
81127a98:	d9c00404 	addi	r7,sp,16
81127a9c:	d9400604 	addi	r5,sp,24
81127aa0:	8009883a 	mov	r4,r16
81127aa4:	112bd340 	call	8112bd34 <__gethex>
81127aa8:	154001cc 	andi	r21,r2,7
81127aac:	a83d9b26 	beq	r21,zero,8112711c <__reset+0xfb10711c>
81127ab0:	00c00184 	movi	r3,6
81127ab4:	a8c0d61e 	bne	r21,r3,81127e10 <_strtod_r+0x1070>
81127ab8:	9cc00044 	addi	r19,r19,1
81127abc:	dcc00615 	stw	r19,24(sp)
81127ac0:	002b883a 	mov	r21,zero
81127ac4:	002d883a 	mov	r22,zero
81127ac8:	d8000715 	stw	zero,28(sp)
81127acc:	003d7e06 	br	811270c8 <__reset+0xfb1070c8>
81127ad0:	00bf2c34 	movhi	r2,64688
81127ad4:	88a3883a 	add	r17,r17,r2
81127ad8:	9009883a 	mov	r4,r18
81127adc:	880b883a 	mov	r5,r17
81127ae0:	1125d000 	call	81125d00 <__ulp>
81127ae4:	d9000b17 	ldw	r4,44(sp)
81127ae8:	100d883a 	mov	r6,r2
81127aec:	180f883a 	mov	r7,r3
81127af0:	b00b883a 	mov	r5,r22
81127af4:	11196d00 	call	811196d0 <__muldf3>
81127af8:	900d883a 	mov	r6,r18
81127afc:	180b883a 	mov	r5,r3
81127b00:	880f883a 	mov	r7,r17
81127b04:	1009883a 	mov	r4,r2
81127b08:	112db9c0 	call	8112db9c <__adddf3>
81127b0c:	015f2834 	movhi	r5,31904
81127b10:	1025883a 	mov	r18,r2
81127b14:	297fffc4 	addi	r5,r5,-1
81127b18:	189ffc2c 	andhi	r2,r3,32752
81127b1c:	2880892e 	bgeu	r5,r2,81127d44 <_strtod_r+0xfa4>
81127b20:	d8801017 	ldw	r2,64(sp)
81127b24:	00dffc34 	movhi	r3,32752
81127b28:	18ffffc4 	addi	r3,r3,-1
81127b2c:	10ffb726 	beq	r2,r3,81127a0c <__reset+0xfb107a0c>
81127b30:	045ffc34 	movhi	r17,32752
81127b34:	8c7fffc4 	addi	r17,r17,-1
81127b38:	04bfffc4 	movi	r18,-1
81127b3c:	003f4706 	br	8112785c <__reset+0xfb10785c>
81127b40:	00800884 	movi	r2,34
81127b44:	80800015 	stw	r2,0(r16)
81127b48:	002b883a 	mov	r21,zero
81127b4c:	059ffc34 	movhi	r22,32752
81127b50:	003d5d06 	br	811270c8 <__reset+0xfb1070c8>
81127b54:	d9000d17 	ldw	r4,52(sp)
81127b58:	b80b883a 	mov	r5,r23
81127b5c:	111a6f40 	call	8111a6f4 <__fixdfsi>
81127b60:	1009883a 	mov	r4,r2
81127b64:	111a7740 	call	8111a774 <__floatsidf>
81127b68:	d9000d17 	ldw	r4,52(sp)
81127b6c:	b80b883a 	mov	r5,r23
81127b70:	100d883a 	mov	r6,r2
81127b74:	180f883a 	mov	r7,r3
81127b78:	1119df00 	call	81119df0 <__subdf3>
81127b7c:	d9400e17 	ldw	r5,56(sp)
81127b80:	1039883a 	mov	fp,r2
81127b84:	182f883a 	mov	r23,r3
81127b88:	2800141e 	bne	r5,zero,81127bdc <_strtod_r+0xe3c>
81127b8c:	9000131e 	bne	r18,zero,81127bdc <_strtod_r+0xe3c>
81127b90:	00800434 	movhi	r2,16
81127b94:	10bfffc4 	addi	r2,r2,-1
81127b98:	b0ac703a 	and	r22,r22,r2
81127b9c:	b0000f1e 	bne	r22,zero,81127bdc <_strtod_r+0xe3c>
81127ba0:	01a52834 	movhi	r6,38048
81127ba4:	01cff434 	movhi	r7,16336
81127ba8:	318d6544 	addi	r6,r6,13717
81127bac:	39ffffc4 	addi	r7,r7,-1
81127bb0:	e009883a 	mov	r4,fp
81127bb4:	180b883a 	mov	r5,r3
81127bb8:	112edc80 	call	8112edc8 <__ledf2>
81127bbc:	103f270e 	bge	r2,zero,8112785c <__reset+0xfb10785c>
81127bc0:	dd000a15 	stw	r20,40(sp)
81127bc4:	a811883a 	mov	r8,r21
81127bc8:	dd001217 	ldw	r20,72(sp)
81127bcc:	d8800517 	ldw	r2,20(sp)
81127bd0:	002b883a 	mov	r21,zero
81127bd4:	882d883a 	mov	r22,r17
81127bd8:	003f9706 	br	81127a38 <__reset+0xfb107a38>
81127bdc:	01a52834 	movhi	r6,38048
81127be0:	01cff834 	movhi	r7,16352
81127be4:	318d6544 	addi	r6,r6,13717
81127be8:	39ffffc4 	addi	r7,r7,-1
81127bec:	e009883a 	mov	r4,fp
81127bf0:	b80b883a 	mov	r5,r23
81127bf4:	112edc80 	call	8112edc8 <__ledf2>
81127bf8:	10000716 	blt	r2,zero,81127c18 <_strtod_r+0xe78>
81127bfc:	018d6c34 	movhi	r6,13744
81127c00:	31b94d44 	addi	r6,r6,-6859
81127c04:	01cff834 	movhi	r7,16352
81127c08:	e009883a 	mov	r4,fp
81127c0c:	b80b883a 	mov	r5,r23
81127c10:	11195f40 	call	811195f4 <__gedf2>
81127c14:	00bf110e 	bge	zero,r2,8112785c <__reset+0xfb10785c>
81127c18:	dd000a15 	stw	r20,40(sp)
81127c1c:	a811883a 	mov	r8,r21
81127c20:	dd001217 	ldw	r20,72(sp)
81127c24:	d8800517 	ldw	r2,20(sp)
81127c28:	902b883a 	mov	r21,r18
81127c2c:	882d883a 	mov	r22,r17
81127c30:	003f8106 	br	81127a38 <__reset+0xfb107a38>
81127c34:	b83e2f26 	beq	r23,zero,811274f4 <__reset+0xfb1074f4>
81127c38:	05efc83a 	sub	r23,zero,r23
81127c3c:	b88003cc 	andi	r2,r23,15
81127c40:	10000d26 	beq	r2,zero,81127c78 <_strtod_r+0xed8>
81127c44:	100490fa 	slli	r2,r2,3
81127c48:	00e04534 	movhi	r3,33044
81127c4c:	18d48004 	addi	r3,r3,20992
81127c50:	1885883a 	add	r2,r3,r2
81127c54:	11800017 	ldw	r6,0(r2)
81127c58:	11c00117 	ldw	r7,4(r2)
81127c5c:	9009883a 	mov	r4,r18
81127c60:	880b883a 	mov	r5,r17
81127c64:	da401315 	stw	r9,76(sp)
81127c68:	112e4500 	call	8112e450 <__divdf3>
81127c6c:	da401317 	ldw	r9,76(sp)
81127c70:	1025883a 	mov	r18,r2
81127c74:	1823883a 	mov	r17,r3
81127c78:	b82fd13a 	srai	r23,r23,4
81127c7c:	b83e1d26 	beq	r23,zero,811274f4 <__reset+0xfb1074f4>
81127c80:	008007c4 	movi	r2,31
81127c84:	15c02816 	blt	r2,r23,81127d28 <_strtod_r+0xf88>
81127c88:	b880040c 	andi	r2,r23,16
81127c8c:	10019726 	beq	r2,zero,811282ec <_strtod_r+0x154c>
81127c90:	05c1880e 	bge	zero,r23,811282b4 <_strtod_r+0x1514>
81127c94:	00c01a84 	movi	r3,106
81127c98:	d8c00915 	stw	r3,36(sp)
81127c9c:	04e04534 	movhi	r19,33044
81127ca0:	9cd4c004 	addi	r19,r19,21248
81127ca4:	8807883a 	mov	r3,r17
81127ca8:	9005883a 	mov	r2,r18
81127cac:	8023883a 	mov	r17,r16
81127cb0:	0009883a 	mov	r4,zero
81127cb4:	9821883a 	mov	r16,r19
81127cb8:	da400a15 	stw	r9,40(sp)
81127cbc:	1827883a 	mov	r19,r3
81127cc0:	b980004c 	andi	r6,r23,1
81127cc4:	30000626 	beq	r6,zero,81127ce0 <_strtod_r+0xf40>
81127cc8:	81800017 	ldw	r6,0(r16)
81127ccc:	81c00117 	ldw	r7,4(r16)
81127cd0:	1009883a 	mov	r4,r2
81127cd4:	180b883a 	mov	r5,r3
81127cd8:	11196d00 	call	811196d0 <__muldf3>
81127cdc:	01000044 	movi	r4,1
81127ce0:	b82fd07a 	srai	r23,r23,1
81127ce4:	84000204 	addi	r16,r16,8
81127ce8:	b83ff51e 	bne	r23,zero,81127cc0 <__reset+0xfb107cc0>
81127cec:	21003fcc 	andi	r4,r4,255
81127cf0:	8821883a 	mov	r16,r17
81127cf4:	da400a17 	ldw	r9,40(sp)
81127cf8:	9823883a 	mov	r17,r19
81127cfc:	2001a51e 	bne	r4,zero,81128394 <_strtod_r+0x15f4>
81127d00:	d9000917 	ldw	r4,36(sp)
81127d04:	20016d1e 	bne	r4,zero,811282bc <_strtod_r+0x151c>
81127d08:	000d883a 	mov	r6,zero
81127d0c:	000f883a 	mov	r7,zero
81127d10:	9009883a 	mov	r4,r18
81127d14:	880b883a 	mov	r5,r17
81127d18:	da401315 	stw	r9,76(sp)
81127d1c:	112ed400 	call	8112ed40 <__eqdf2>
81127d20:	da401317 	ldw	r9,76(sp)
81127d24:	103df41e 	bne	r2,zero,811274f8 <__reset+0xfb1074f8>
81127d28:	00800884 	movi	r2,34
81127d2c:	80800015 	stw	r2,0(r16)
81127d30:	002b883a 	mov	r21,zero
81127d34:	002d883a 	mov	r22,zero
81127d38:	003ce306 	br	811270c8 <__reset+0xfb1070c8>
81127d3c:	055387c4 	movi	r21,19999
81127d40:	003d6b06 	br	811272f0 <__reset+0xfb1072f0>
81127d44:	0440d434 	movhi	r17,848
81127d48:	1c63883a 	add	r17,r3,r17
81127d4c:	882d883a 	mov	r22,r17
81127d50:	003ebe06 	br	8112784c <__reset+0xfb10784c>
81127d54:	14403fcc 	andi	r17,r2,255
81127d58:	8c40201c 	xori	r17,r17,128
81127d5c:	8c7fe004 	addi	r17,r17,-128
81127d60:	dd400817 	ldw	r21,32(sp)
81127d64:	0027883a 	mov	r19,zero
81127d68:	0039883a 	mov	fp,zero
81127d6c:	002d883a 	mov	r22,zero
81127d70:	003c9906 	br	81126fd8 <__reset+0xfb106fd8>
81127d74:	00c00944 	movi	r3,37
81127d78:	1a47c83a 	sub	r3,r3,r9
81127d7c:	1d7d8c16 	blt	r3,r21,811273b0 <__reset+0xfb1073b0>
81127d80:	1261c83a 	sub	r16,r2,r9
81127d84:	800490fa 	slli	r2,r16,3
81127d88:	04e04534 	movhi	r19,33044
81127d8c:	9cd48004 	addi	r19,r19,20992
81127d90:	9885883a 	add	r2,r19,r2
81127d94:	11000017 	ldw	r4,0(r2)
81127d98:	11400117 	ldw	r5,4(r2)
81127d9c:	900d883a 	mov	r6,r18
81127da0:	880f883a 	mov	r7,r17
81127da4:	11196d00 	call	811196d0 <__muldf3>
81127da8:	ac0dc83a 	sub	r6,r21,r16
81127dac:	300c90fa 	slli	r6,r6,3
81127db0:	1009883a 	mov	r4,r2
81127db4:	180b883a 	mov	r5,r3
81127db8:	9985883a 	add	r2,r19,r6
81127dbc:	11800017 	ldw	r6,0(r2)
81127dc0:	11c00117 	ldw	r7,4(r2)
81127dc4:	11196d00 	call	811196d0 <__muldf3>
81127dc8:	102b883a 	mov	r21,r2
81127dcc:	182d883a 	mov	r22,r3
81127dd0:	003cbd06 	br	811270c8 <__reset+0xfb1070c8>
81127dd4:	b811883a 	mov	r8,r23
81127dd8:	003e8606 	br	811277f4 <__reset+0xfb1077f4>
81127ddc:	d8000d15 	stw	zero,52(sp)
81127de0:	05cffc34 	movhi	r23,16368
81127de4:	003e8006 	br	811277e8 <__reset+0xfb1077e8>
81127de8:	883f011e 	bne	r17,zero,811279f0 <__reset+0xfb1079f0>
81127dec:	dd000a15 	stw	r20,40(sp)
81127df0:	dd001217 	ldw	r20,72(sp)
81127df4:	a811883a 	mov	r8,r21
81127df8:	00800884 	movi	r2,34
81127dfc:	80800015 	stw	r2,0(r16)
81127e00:	002b883a 	mov	r21,zero
81127e04:	d8800517 	ldw	r2,20(sp)
81127e08:	002d883a 	mov	r22,zero
81127e0c:	003f0a06 	br	81127a38 <__reset+0xfb107a38>
81127e10:	d9800517 	ldw	r6,20(sp)
81127e14:	30000826 	beq	r6,zero,81127e38 <_strtod_r+0x1098>
81127e18:	01400d44 	movi	r5,53
81127e1c:	d9000204 	addi	r4,sp,8
81127e20:	d8801315 	stw	r2,76(sp)
81127e24:	11260f40 	call	811260f4 <__copybits>
81127e28:	d9400517 	ldw	r5,20(sp)
81127e2c:	8009883a 	mov	r4,r16
81127e30:	112524c0 	call	8112524c <_Bfree>
81127e34:	d8801317 	ldw	r2,76(sp)
81127e38:	00c00184 	movi	r3,6
81127e3c:	1d400f36 	bltu	r3,r21,81127e7c <_strtod_r+0x10dc>
81127e40:	a82a90ba 	slli	r21,r21,2
81127e44:	00e044b4 	movhi	r3,33042
81127e48:	18df9604 	addi	r3,r3,32344
81127e4c:	a8eb883a 	add	r21,r21,r3
81127e50:	a8c00017 	ldw	r3,0(r21)
81127e54:	1800683a 	jmp	r3
81127e58:	81127ed4 	ori	r4,r16,18939
81127e5c:	81127eac 	andhi	r4,r16,18938
81127e60:	81127e90 	cmplti	r4,r16,18938
81127e64:	81127e74 	orhi	r4,r16,18937
81127e68:	81127e9c 	xori	r4,r16,18938
81127e6c:	81127eac 	andhi	r4,r16,18938
81127e70:	81127ed4 	ori	r4,r16,18939
81127e74:	045ffc34 	movhi	r17,32752
81127e78:	0025883a 	mov	r18,zero
81127e7c:	1080020c 	andi	r2,r2,8
81127e80:	902b883a 	mov	r21,r18
81127e84:	103c8f26 	beq	r2,zero,811270c4 <__reset+0xfb1070c4>
81127e88:	8da00034 	orhi	r22,r17,32768
81127e8c:	003c8e06 	br	811270c8 <__reset+0xfb1070c8>
81127e90:	dc800217 	ldw	r18,8(sp)
81127e94:	dc400317 	ldw	r17,12(sp)
81127e98:	003ff806 	br	81127e7c <__reset+0xfb107e7c>
81127e9c:	04600034 	movhi	r17,32768
81127ea0:	8c7fffc4 	addi	r17,r17,-1
81127ea4:	04bfffc4 	movi	r18,-1
81127ea8:	003ff406 	br	81127e7c <__reset+0xfb107e7c>
81127eac:	d8c00417 	ldw	r3,16(sp)
81127eb0:	dc400317 	ldw	r17,12(sp)
81127eb4:	013ffc34 	movhi	r4,65520
81127eb8:	18c10cc4 	addi	r3,r3,1075
81127ebc:	1806953a 	slli	r3,r3,20
81127ec0:	213fffc4 	addi	r4,r4,-1
81127ec4:	8922703a 	and	r17,r17,r4
81127ec8:	dc800217 	ldw	r18,8(sp)
81127ecc:	88e2b03a 	or	r17,r17,r3
81127ed0:	003fea06 	br	81127e7c <__reset+0xfb107e7c>
81127ed4:	0023883a 	mov	r17,zero
81127ed8:	0025883a 	mov	r18,zero
81127edc:	003fe706 	br	81127e7c <__reset+0xfb107e7c>
81127ee0:	01800044 	movi	r6,1
81127ee4:	50d5883a 	add	r10,r10,r3
81127ee8:	2a4b883a 	add	r5,r5,r9
81127eec:	19811a26 	beq	r3,r6,81128358 <_strtod_r+0x15b8>
81127ef0:	01800204 	movi	r6,8
81127ef4:	01c00404 	movi	r7,16
81127ef8:	4a400044 	addi	r9,r9,1
81127efc:	48bfffc4 	addi	r2,r9,-1
81127f00:	30801616 	blt	r6,r2,81127f5c <_strtod_r+0x11bc>
81127f04:	e70002a4 	muli	fp,fp,10
81127f08:	497ffb1e 	bne	r9,r5,81127ef8 <__reset+0xfb107ef8>
81127f0c:	d9800617 	ldw	r6,24(sp)
81127f10:	4a400044 	addi	r9,r9,1
81127f14:	00c00204 	movi	r3,8
81127f18:	19400c0e 	bge	r3,r5,81127f4c <_strtod_r+0x11ac>
81127f1c:	00800404 	movi	r2,16
81127f20:	000b883a 	mov	r5,zero
81127f24:	127ea316 	blt	r2,r9,811279b4 <__reset+0xfb1079b4>
81127f28:	988002a4 	muli	r2,r19,10
81127f2c:	20a7883a 	add	r19,r4,r2
81127f30:	003ea006 	br	811279b4 <__reset+0xfb1079b4>
81127f34:	d8800617 	ldw	r2,24(sp)
81127f38:	8c7ff404 	addi	r17,r17,-48
81127f3c:	2a800044 	addi	r10,r5,1
81127f40:	d8800815 	stw	r2,32(sp)
81127f44:	100d883a 	mov	r6,r2
81127f48:	02400044 	movi	r9,1
81127f4c:	e08002a4 	muli	r2,fp,10
81127f50:	000b883a 	mov	r5,zero
81127f54:	88b9883a 	add	fp,r17,r2
81127f58:	003e9606 	br	811279b4 <__reset+0xfb1079b4>
81127f5c:	3a7fea16 	blt	r7,r9,81127f08 <__reset+0xfb107f08>
81127f60:	9cc002a4 	muli	r19,r19,10
81127f64:	003fe806 	br	81127f08 <__reset+0xfb107f08>
81127f68:	00bffa84 	movi	r2,-22
81127f6c:	a8bd1016 	blt	r21,r2,811273b0 <__reset+0xfb1073b0>
81127f70:	a82a90fa 	slli	r21,r21,3
81127f74:	00a04534 	movhi	r2,33044
81127f78:	10948004 	addi	r2,r2,20992
81127f7c:	1545c83a 	sub	r2,r2,r21
81127f80:	11800017 	ldw	r6,0(r2)
81127f84:	11c00117 	ldw	r7,4(r2)
81127f88:	9009883a 	mov	r4,r18
81127f8c:	880b883a 	mov	r5,r17
81127f90:	112e4500 	call	8112e450 <__divdf3>
81127f94:	102b883a 	mov	r21,r2
81127f98:	182d883a 	mov	r22,r3
81127f9c:	003c4a06 	br	811270c8 <__reset+0xfb1070c8>
81127fa0:	dd000a15 	stw	r20,40(sp)
81127fa4:	a811883a 	mov	r8,r21
81127fa8:	dd001217 	ldw	r20,72(sp)
81127fac:	003e9e06 	br	81127a28 <__reset+0xfb107a28>
81127fb0:	01604534 	movhi	r5,33044
81127fb4:	d9000617 	ldw	r4,24(sp)
81127fb8:	2954b204 	addi	r5,r5,21192
81127fbc:	01c00644 	movi	r7,25
81127fc0:	00000b06 	br	81127ff0 <_strtod_r+0x1250>
81127fc4:	21000044 	addi	r4,r4,1
81127fc8:	20800003 	ldbu	r2,0(r4)
81127fcc:	10ffefc4 	addi	r3,r2,-65
81127fd0:	10803fcc 	andi	r2,r2,255
81127fd4:	1080201c 	xori	r2,r2,128
81127fd8:	18c03fcc 	andi	r3,r3,255
81127fdc:	10bfe004 	addi	r2,r2,-128
81127fe0:	38c00136 	bltu	r7,r3,81127fe8 <_strtod_r+0x1248>
81127fe4:	10800804 	addi	r2,r2,32
81127fe8:	29400044 	addi	r5,r5,1
81127fec:	11bbbb1e 	bne	r2,r6,81126edc <__reset+0xfb106edc>
81127ff0:	29800007 	ldb	r6,0(r5)
81127ff4:	303ff31e 	bne	r6,zero,81127fc4 <__reset+0xfb107fc4>
81127ff8:	01a04534 	movhi	r6,33044
81127ffc:	d9000615 	stw	r4,24(sp)
81128000:	3194b304 	addi	r6,r6,21196
81128004:	200b883a 	mov	r5,r4
81128008:	02000644 	movi	r8,25
8112800c:	00000a06 	br	81128038 <_strtod_r+0x1298>
81128010:	28800003 	ldbu	r2,0(r5)
81128014:	10ffefc4 	addi	r3,r2,-65
81128018:	10803fcc 	andi	r2,r2,255
8112801c:	1080201c 	xori	r2,r2,128
81128020:	18c03fcc 	andi	r3,r3,255
81128024:	10bfe004 	addi	r2,r2,-128
81128028:	40c00136 	bltu	r8,r3,81128030 <_strtod_r+0x1290>
8112802c:	10800804 	addi	r2,r2,32
81128030:	31800044 	addi	r6,r6,1
81128034:	11c0711e 	bne	r2,r7,811281fc <_strtod_r+0x145c>
81128038:	31c00007 	ldb	r7,0(r6)
8112803c:	29400044 	addi	r5,r5,1
81128040:	383ff31e 	bne	r7,zero,81128010 <__reset+0xfb108010>
81128044:	d9400615 	stw	r5,24(sp)
81128048:	045ffc34 	movhi	r17,32752
8112804c:	0025883a 	mov	r18,zero
81128050:	003c1b06 	br	811270c0 <__reset+0xfb1070c0>
81128054:	000b883a 	mov	r5,zero
81128058:	003ccc06 	br	8112738c <__reset+0xfb10738c>
8112805c:	d9400e17 	ldw	r5,56(sp)
81128060:	dd000a15 	stw	r20,40(sp)
81128064:	00800434 	movhi	r2,16
81128068:	a811883a 	mov	r8,r21
8112806c:	dd001217 	ldw	r20,72(sp)
81128070:	dd401117 	ldw	r21,68(sp)
81128074:	dd801017 	ldw	r22,64(sp)
81128078:	10bfffc4 	addi	r2,r2,-1
8112807c:	28005626 	beq	r5,zero,811281d8 <_strtod_r+0x1438>
81128080:	8886703a 	and	r3,r17,r2
81128084:	18807826 	beq	r3,r2,81128268 <_strtod_r+0x14c8>
81128088:	d8c00b17 	ldw	r3,44(sp)
8112808c:	18005726 	beq	r3,zero,811281ec <_strtod_r+0x144c>
81128090:	1c44703a 	and	r2,r3,r17
81128094:	10000f26 	beq	r2,zero,811280d4 <_strtod_r+0x1334>
81128098:	d9000e17 	ldw	r4,56(sp)
8112809c:	d9800917 	ldw	r6,36(sp)
811280a0:	20005e26 	beq	r4,zero,8112821c <_strtod_r+0x147c>
811280a4:	9009883a 	mov	r4,r18
811280a8:	880b883a 	mov	r5,r17
811280ac:	da001315 	stw	r8,76(sp)
811280b0:	1126d340 	call	81126d34 <sulp>
811280b4:	100d883a 	mov	r6,r2
811280b8:	180f883a 	mov	r7,r3
811280bc:	9009883a 	mov	r4,r18
811280c0:	880b883a 	mov	r5,r17
811280c4:	112db9c0 	call	8112db9c <__adddf3>
811280c8:	da001317 	ldw	r8,76(sp)
811280cc:	102b883a 	mov	r21,r2
811280d0:	182d883a 	mov	r22,r3
811280d4:	d8c00917 	ldw	r3,36(sp)
811280d8:	18000f26 	beq	r3,zero,81128118 <_strtod_r+0x1378>
811280dc:	a809883a 	mov	r4,r21
811280e0:	b00b883a 	mov	r5,r22
811280e4:	000d883a 	mov	r6,zero
811280e8:	01ce5434 	movhi	r7,14672
811280ec:	da001315 	stw	r8,76(sp)
811280f0:	11196d00 	call	811196d0 <__muldf3>
811280f4:	102b883a 	mov	r21,r2
811280f8:	182d883a 	mov	r22,r3
811280fc:	da001317 	ldw	r8,76(sp)
81128100:	1800051e 	bne	r3,zero,81128118 <_strtod_r+0x1378>
81128104:	d8800517 	ldw	r2,20(sp)
81128108:	a83e4b1e 	bne	r21,zero,81127a38 <__reset+0xfb107a38>
8112810c:	00c00884 	movi	r3,34
81128110:	80c00015 	stw	r3,0(r16)
81128114:	003e4806 	br	81127a38 <__reset+0xfb107a38>
81128118:	d8800517 	ldw	r2,20(sp)
8112811c:	003e4606 	br	81127a38 <__reset+0xfb107a38>
81128120:	d9000e17 	ldw	r4,56(sp)
81128124:	dd000a15 	stw	r20,40(sp)
81128128:	a811883a 	mov	r8,r21
8112812c:	dd001217 	ldw	r20,72(sp)
81128130:	dd401117 	ldw	r21,68(sp)
81128134:	dd801017 	ldw	r22,64(sp)
81128138:	203fe61e 	bne	r4,zero,811280d4 <__reset+0xfb1080d4>
8112813c:	903fe51e 	bne	r18,zero,811280d4 <__reset+0xfb1080d4>
81128140:	00800434 	movhi	r2,16
81128144:	10bfffc4 	addi	r2,r2,-1
81128148:	8884703a 	and	r2,r17,r2
8112814c:	103fe11e 	bne	r2,zero,811280d4 <__reset+0xfb1080d4>
81128150:	8ddffc2c 	andhi	r23,r17,32752
81128154:	0081ac34 	movhi	r2,1712
81128158:	15ffde2e 	bgeu	r2,r23,811280d4 <__reset+0xfb1080d4>
8112815c:	40800517 	ldw	r2,20(r8)
81128160:	1000031e 	bne	r2,zero,81128170 <_strtod_r+0x13d0>
81128164:	40800417 	ldw	r2,16(r8)
81128168:	00c00044 	movi	r3,1
8112816c:	18bfd90e 	bge	r3,r2,811280d4 <__reset+0xfb1080d4>
81128170:	400b883a 	mov	r5,r8
81128174:	01800044 	movi	r6,1
81128178:	8009883a 	mov	r4,r16
8112817c:	112594c0 	call	8112594c <__lshift>
81128180:	980b883a 	mov	r5,r19
81128184:	1009883a 	mov	r4,r2
81128188:	d8801315 	stw	r2,76(sp)
8112818c:	1125a9c0 	call	81125a9c <__mcmp>
81128190:	da001317 	ldw	r8,76(sp)
81128194:	00bfcf0e 	bge	zero,r2,811280d4 <__reset+0xfb1080d4>
81128198:	d8c00917 	ldw	r3,36(sp)
8112819c:	18005c26 	beq	r3,zero,81128310 <_strtod_r+0x1570>
811281a0:	0081ac34 	movhi	r2,1712
811281a4:	15c05a16 	blt	r2,r23,81128310 <_strtod_r+0x1570>
811281a8:	0080dc34 	movhi	r2,880
811281ac:	15ffcb16 	blt	r2,r23,811280dc <__reset+0xfb1080dc>
811281b0:	003f1106 	br	81127df8 <__reset+0xfb107df8>
811281b4:	002d883a 	mov	r22,zero
811281b8:	022ff834 	movhi	r8,49120
811281bc:	d8000d15 	stw	zero,52(sp)
811281c0:	05cff834 	movhi	r23,16352
811281c4:	003ded06 	br	8112797c <__reset+0xfb10797c>
811281c8:	0440d434 	movhi	r17,848
811281cc:	1c63883a 	add	r17,r3,r17
811281d0:	d8000915 	stw	zero,36(sp)
811281d4:	003cc806 	br	811274f8 <__reset+0xfb1074f8>
811281d8:	8884703a 	and	r2,r17,r2
811281dc:	103faa1e 	bne	r2,zero,81128088 <__reset+0xfb108088>
811281e0:	903fa91e 	bne	r18,zero,81128088 <__reset+0xfb108088>
811281e4:	8ddffc2c 	andhi	r23,r17,32752
811281e8:	003feb06 	br	81128198 <__reset+0xfb108198>
811281ec:	d8c00d17 	ldw	r3,52(sp)
811281f0:	1cae703a 	and	r23,r3,r18
811281f4:	b83fb726 	beq	r23,zero,811280d4 <__reset+0xfb1080d4>
811281f8:	003fa706 	br	81128098 <__reset+0xfb108098>
811281fc:	21000044 	addi	r4,r4,1
81128200:	d9000615 	stw	r4,24(sp)
81128204:	003f9006 	br	81128048 <__reset+0xfb108048>
81128208:	01604534 	movhi	r5,33044
8112820c:	29547604 	addi	r5,r5,20952
81128210:	d9400915 	stw	r5,36(sp)
81128214:	0027883a 	mov	r19,zero
81128218:	003ca206 	br	811274a4 <__reset+0xfb1074a4>
8112821c:	9009883a 	mov	r4,r18
81128220:	880b883a 	mov	r5,r17
81128224:	da001315 	stw	r8,76(sp)
81128228:	1126d340 	call	81126d34 <sulp>
8112822c:	100d883a 	mov	r6,r2
81128230:	180f883a 	mov	r7,r3
81128234:	9009883a 	mov	r4,r18
81128238:	880b883a 	mov	r5,r17
8112823c:	1119df00 	call	81119df0 <__subdf3>
81128240:	000d883a 	mov	r6,zero
81128244:	000f883a 	mov	r7,zero
81128248:	1009883a 	mov	r4,r2
8112824c:	180b883a 	mov	r5,r3
81128250:	102b883a 	mov	r21,r2
81128254:	182d883a 	mov	r22,r3
81128258:	112ed400 	call	8112ed40 <__eqdf2>
8112825c:	da001317 	ldw	r8,76(sp)
81128260:	103ee526 	beq	r2,zero,81127df8 <__reset+0xfb107df8>
81128264:	003f9b06 	br	811280d4 <__reset+0xfb1080d4>
81128268:	d8800917 	ldw	r2,36(sp)
8112826c:	10002226 	beq	r2,zero,811282f8 <_strtod_r+0x1558>
81128270:	889ffc2c 	andhi	r2,r17,32752
81128274:	00c1a834 	movhi	r3,1696
81128278:	18801f36 	bltu	r3,r2,811282f8 <_strtod_r+0x1558>
8112827c:	1004d53a 	srli	r2,r2,20
81128280:	00c01ac4 	movi	r3,107
81128284:	1887c83a 	sub	r3,r3,r2
81128288:	00bfffc4 	movi	r2,-1
8112828c:	10c4983a 	sll	r2,r2,r3
81128290:	14bf7d1e 	bne	r2,r18,81128088 <__reset+0xfb108088>
81128294:	00dffc34 	movhi	r3,32752
81128298:	18ffffc4 	addi	r3,r3,-1
8112829c:	88c03526 	beq	r17,r3,81128374 <_strtod_r+0x15d4>
811282a0:	8c5ffc2c 	andhi	r17,r17,32752
811282a4:	00800434 	movhi	r2,16
811282a8:	002b883a 	mov	r21,zero
811282ac:	88ad883a 	add	r22,r17,r2
811282b0:	003f8806 	br	811280d4 <__reset+0xfb1080d4>
811282b4:	01401a84 	movi	r5,106
811282b8:	d9400915 	stw	r5,36(sp)
811282bc:	8ddffc2c 	andhi	r23,r17,32752
811282c0:	b82ed53a 	srli	r23,r23,20
811282c4:	00801ac4 	movi	r2,107
811282c8:	15c5c83a 	sub	r2,r2,r23
811282cc:	00be8e0e 	bge	zero,r2,81127d08 <__reset+0xfb107d08>
811282d0:	00c007c4 	movi	r3,31
811282d4:	18800a0e 	bge	r3,r2,81128300 <_strtod_r+0x1560>
811282d8:	00c00d04 	movi	r3,52
811282dc:	0025883a 	mov	r18,zero
811282e0:	1880270e 	bge	r3,r2,81128380 <_strtod_r+0x15e0>
811282e4:	0440dc34 	movhi	r17,880
811282e8:	003e8706 	br	81127d08 <__reset+0xfb107d08>
811282ec:	d8000915 	stw	zero,36(sp)
811282f0:	05fe6a16 	blt	zero,r23,81127c9c <__reset+0xfb107c9c>
811282f4:	003e8406 	br	81127d08 <__reset+0xfb107d08>
811282f8:	00bfffc4 	movi	r2,-1
811282fc:	003fe406 	br	81128290 <__reset+0xfb108290>
81128300:	00ffffc4 	movi	r3,-1
81128304:	1884983a 	sll	r2,r3,r2
81128308:	14a4703a 	and	r18,r2,r18
8112830c:	003e7e06 	br	81127d08 <__reset+0xfb107d08>
81128310:	00bffc34 	movhi	r2,65520
81128314:	b8af883a 	add	r23,r23,r2
81128318:	057fffc4 	movi	r21,-1
8112831c:	00800434 	movhi	r2,16
81128320:	1545883a 	add	r2,r2,r21
81128324:	b8acb03a 	or	r22,r23,r2
81128328:	003f6a06 	br	811280d4 <__reset+0xfb1080d4>
8112832c:	01604534 	movhi	r5,33044
81128330:	2954b604 	addi	r5,r5,21208
81128334:	d9800204 	addi	r6,sp,8
81128338:	d9000604 	addi	r4,sp,24
8112833c:	112c56c0 	call	8112c56c <__hexnan>
81128340:	00c00144 	movi	r3,5
81128344:	10fb5c1e 	bne	r2,r3,811270b8 <__reset+0xfb1070b8>
81128348:	dc400317 	ldw	r17,12(sp)
8112834c:	dc800217 	ldw	r18,8(sp)
81128350:	8c5ffc34 	orhi	r17,r17,32752
81128354:	003b5a06 	br	811270c0 <__reset+0xfb1070c0>
81128358:	480b883a 	mov	r5,r9
8112835c:	d9800617 	ldw	r6,24(sp)
81128360:	4a400044 	addi	r9,r9,1
81128364:	003eeb06 	br	81127f14 <__reset+0xfb107f14>
81128368:	1025883a 	mov	r18,r2
8112836c:	1823883a 	mov	r17,r3
81128370:	003c4c06 	br	811274a4 <__reset+0xfb1074a4>
81128374:	00ffffc4 	movi	r3,-1
81128378:	10ffc91e 	bne	r2,r3,811282a0 <__reset+0xfb1082a0>
8112837c:	003da906 	br	81127a24 <__reset+0xfb107a24>
81128380:	10bff804 	addi	r2,r2,-32
81128384:	00ffffc4 	movi	r3,-1
81128388:	1884983a 	sll	r2,r3,r2
8112838c:	1462703a 	and	r17,r2,r17
81128390:	003e5d06 	br	81127d08 <__reset+0xfb107d08>
81128394:	1025883a 	mov	r18,r2
81128398:	1823883a 	mov	r17,r3
8112839c:	003e5806 	br	81127d00 <__reset+0xfb107d00>

811283a0 <strtod>:
811283a0:	00a04534 	movhi	r2,33044
811283a4:	109e0f04 	addi	r2,r2,30780
811283a8:	280d883a 	mov	r6,r5
811283ac:	200b883a 	mov	r5,r4
811283b0:	11000017 	ldw	r4,0(r2)
811283b4:	1126da01 	jmpi	81126da0 <_strtod_r>

811283b8 <strtof>:
811283b8:	defffb04 	addi	sp,sp,-20
811283bc:	de00012e 	bgeu	sp,et,811283c4 <strtof+0xc>
811283c0:	003b68fa 	trap	3
811283c4:	dcc00315 	stw	r19,12(sp)
811283c8:	04e04534 	movhi	r19,33044
811283cc:	9cde0f04 	addi	r19,r19,30780
811283d0:	280d883a 	mov	r6,r5
811283d4:	200b883a 	mov	r5,r4
811283d8:	99000017 	ldw	r4,0(r19)
811283dc:	dfc00415 	stw	ra,16(sp)
811283e0:	dc800215 	stw	r18,8(sp)
811283e4:	dc400115 	stw	r17,4(sp)
811283e8:	dc000015 	stw	r16,0(sp)
811283ec:	1126da00 	call	81126da0 <_strtod_r>
811283f0:	1009883a 	mov	r4,r2
811283f4:	180b883a 	mov	r5,r3
811283f8:	1025883a 	mov	r18,r2
811283fc:	1823883a 	mov	r17,r3
81128400:	111a9700 	call	8111a970 <__truncdfsf2>
81128404:	000b883a 	mov	r5,zero
81128408:	1009883a 	mov	r4,r2
8112840c:	1021883a 	mov	r16,r2
81128410:	112d9a00 	call	8112d9a0 <__eqsf2>
81128414:	1000111e 	bne	r2,zero,8112845c <strtof+0xa4>
81128418:	000d883a 	mov	r6,zero
8112841c:	000f883a 	mov	r7,zero
81128420:	9009883a 	mov	r4,r18
81128424:	880b883a 	mov	r5,r17
81128428:	112ed400 	call	8112ed40 <__eqdf2>
8112842c:	10000b26 	beq	r2,zero,8112845c <strtof+0xa4>
81128430:	98800017 	ldw	r2,0(r19)
81128434:	00c00884 	movi	r3,34
81128438:	10c00015 	stw	r3,0(r2)
8112843c:	8005883a 	mov	r2,r16
81128440:	dfc00417 	ldw	ra,16(sp)
81128444:	dcc00317 	ldw	r19,12(sp)
81128448:	dc800217 	ldw	r18,8(sp)
8112844c:	dc400117 	ldw	r17,4(sp)
81128450:	dc000017 	ldw	r16,0(sp)
81128454:	dec00504 	addi	sp,sp,20
81128458:	f800283a 	ret
8112845c:	015fe034 	movhi	r5,32640
81128460:	297fffc4 	addi	r5,r5,-1
81128464:	8009883a 	mov	r4,r16
81128468:	112da180 	call	8112da18 <__gesf2>
8112846c:	0080070e 	bge	zero,r2,8112848c <strtof+0xd4>
81128470:	01dffc34 	movhi	r7,32752
81128474:	39ffffc4 	addi	r7,r7,-1
81128478:	01bfffc4 	movi	r6,-1
8112847c:	9009883a 	mov	r4,r18
81128480:	880b883a 	mov	r5,r17
81128484:	11195f40 	call	811195f4 <__gedf2>
81128488:	00bfe90e 	bge	zero,r2,81128430 <__reset+0xfb108430>
8112848c:	017fe034 	movhi	r5,65408
81128490:	297fffc4 	addi	r5,r5,-1
81128494:	8009883a 	mov	r4,r16
81128498:	112dad40 	call	8112dad4 <__lesf2>
8112849c:	103fe70e 	bge	r2,zero,8112843c <__reset+0xfb10843c>
811284a0:	01fffc34 	movhi	r7,65520
811284a4:	39ffffc4 	addi	r7,r7,-1
811284a8:	01bfffc4 	movi	r6,-1
811284ac:	9009883a 	mov	r4,r18
811284b0:	880b883a 	mov	r5,r17
811284b4:	112edc80 	call	8112edc8 <__ledf2>
811284b8:	103fdd0e 	bge	r2,zero,81128430 <__reset+0xfb108430>
811284bc:	003fdf06 	br	8112843c <__reset+0xfb10843c>

811284c0 <_strtoul_r>:
811284c0:	00a04534 	movhi	r2,33044
811284c4:	defff604 	addi	sp,sp,-40
811284c8:	109e0d04 	addi	r2,r2,30772
811284cc:	de00012e 	bgeu	sp,et,811284d4 <_strtoul_r+0x14>
811284d0:	003b68fa 	trap	3
811284d4:	dc800315 	stw	r18,12(sp)
811284d8:	14800017 	ldw	r18,0(r2)
811284dc:	dd400615 	stw	r21,24(sp)
811284e0:	dd000515 	stw	r20,20(sp)
811284e4:	dcc00415 	stw	r19,16(sp)
811284e8:	2029883a 	mov	r20,r4
811284ec:	dfc00915 	stw	ra,36(sp)
811284f0:	ddc00815 	stw	r23,32(sp)
811284f4:	dd800715 	stw	r22,28(sp)
811284f8:	dc400215 	stw	r17,8(sp)
811284fc:	dc000115 	stw	r16,4(sp)
81128500:	2827883a 	mov	r19,r5
81128504:	382b883a 	mov	r21,r7
81128508:	2809883a 	mov	r4,r5
8112850c:	24000003 	ldbu	r16,0(r4)
81128510:	24400044 	addi	r17,r4,1
81128514:	2007883a 	mov	r3,r4
81128518:	9405883a 	add	r2,r18,r16
8112851c:	10800043 	ldbu	r2,1(r2)
81128520:	8809883a 	mov	r4,r17
81128524:	1080020c 	andi	r2,r2,8
81128528:	103ff81e 	bne	r2,zero,8112850c <__reset+0xfb10850c>
8112852c:	00800b44 	movi	r2,45
81128530:	80805326 	beq	r16,r2,81128680 <_strtoul_r+0x1c0>
81128534:	00800ac4 	movi	r2,43
81128538:	80805526 	beq	r16,r2,81128690 <_strtoul_r+0x1d0>
8112853c:	002f883a 	mov	r23,zero
81128540:	a8000f26 	beq	r21,zero,81128580 <_strtoul_r+0xc0>
81128544:	00800404 	movi	r2,16
81128548:	a8805f26 	beq	r21,r2,811286c8 <_strtoul_r+0x208>
8112854c:	013fffc4 	movi	r4,-1
81128550:	a80b883a 	mov	r5,r21
81128554:	d9800015 	stw	r6,0(sp)
81128558:	112d8e40 	call	8112d8e4 <__udivsi3>
8112855c:	a80b883a 	mov	r5,r21
81128560:	013fffc4 	movi	r4,-1
81128564:	102d883a 	mov	r22,r2
81128568:	112d9480 	call	8112d948 <__umodsi3>
8112856c:	d9800017 	ldw	r6,0(sp)
81128570:	1019883a 	mov	r12,r2
81128574:	a817883a 	mov	r11,r21
81128578:	b00f883a 	mov	r7,r22
8112857c:	00000706 	br	8112859c <_strtoul_r+0xdc>
81128580:	00800c04 	movi	r2,48
81128584:	80804626 	beq	r16,r2,811286a0 <_strtoul_r+0x1e0>
81128588:	05400284 	movi	r21,10
8112858c:	01c666b4 	movhi	r7,6554
81128590:	03000144 	movi	r12,5
81128594:	39e66644 	addi	r7,r7,-26215
81128598:	a817883a 	mov	r11,r21
8112859c:	9407883a 	add	r3,r18,r16
811285a0:	18c00043 	ldbu	r3,1(r3)
811285a4:	8809883a 	mov	r4,r17
811285a8:	0011883a 	mov	r8,zero
811285ac:	1940010c 	andi	r5,r3,4
811285b0:	0005883a 	mov	r2,zero
811285b4:	02800044 	movi	r10,1
811285b8:	027fffc4 	movi	r9,-1
811285bc:	28000e26 	beq	r5,zero,811285f8 <_strtoul_r+0x138>
811285c0:	843ff404 	addi	r16,r16,-48
811285c4:	8540120e 	bge	r16,r21,81128610 <_strtoul_r+0x150>
811285c8:	42400526 	beq	r8,r9,811285e0 <_strtoul_r+0x120>
811285cc:	38802236 	bltu	r7,r2,81128658 <_strtoul_r+0x198>
811285d0:	11c02026 	beq	r2,r7,81128654 <_strtoul_r+0x194>
811285d4:	12c5383a 	mul	r2,r2,r11
811285d8:	02000044 	movi	r8,1
811285dc:	8085883a 	add	r2,r16,r2
811285e0:	24000003 	ldbu	r16,0(r4)
811285e4:	21000044 	addi	r4,r4,1
811285e8:	9407883a 	add	r3,r18,r16
811285ec:	18c00043 	ldbu	r3,1(r3)
811285f0:	1940010c 	andi	r5,r3,4
811285f4:	283ff21e 	bne	r5,zero,811285c0 <__reset+0xfb1085c0>
811285f8:	18c000cc 	andi	r3,r3,3
811285fc:	18000426 	beq	r3,zero,81128610 <_strtoul_r+0x150>
81128600:	1a801726 	beq	r3,r10,81128660 <_strtoul_r+0x1a0>
81128604:	00c015c4 	movi	r3,87
81128608:	80e1c83a 	sub	r16,r16,r3
8112860c:	857fee16 	blt	r16,r21,811285c8 <__reset+0xfb1085c8>
81128610:	40001516 	blt	r8,zero,81128668 <_strtoul_r+0x1a8>
81128614:	b8000126 	beq	r23,zero,8112861c <_strtoul_r+0x15c>
81128618:	0085c83a 	sub	r2,zero,r2
8112861c:	30000226 	beq	r6,zero,81128628 <_strtoul_r+0x168>
81128620:	4000151e 	bne	r8,zero,81128678 <_strtoul_r+0x1b8>
81128624:	34c00015 	stw	r19,0(r6)
81128628:	dfc00917 	ldw	ra,36(sp)
8112862c:	ddc00817 	ldw	r23,32(sp)
81128630:	dd800717 	ldw	r22,28(sp)
81128634:	dd400617 	ldw	r21,24(sp)
81128638:	dd000517 	ldw	r20,20(sp)
8112863c:	dcc00417 	ldw	r19,16(sp)
81128640:	dc800317 	ldw	r18,12(sp)
81128644:	dc400217 	ldw	r17,8(sp)
81128648:	dc000117 	ldw	r16,4(sp)
8112864c:	dec00a04 	addi	sp,sp,40
81128650:	f800283a 	ret
81128654:	643fdf0e 	bge	r12,r16,811285d4 <__reset+0xfb1085d4>
81128658:	023fffc4 	movi	r8,-1
8112865c:	003fe006 	br	811285e0 <__reset+0xfb1085e0>
81128660:	00c00dc4 	movi	r3,55
81128664:	003fe806 	br	81128608 <__reset+0xfb108608>
81128668:	00800884 	movi	r2,34
8112866c:	a0800015 	stw	r2,0(r20)
81128670:	00bfffc4 	movi	r2,-1
81128674:	303fec26 	beq	r6,zero,81128628 <__reset+0xfb108628>
81128678:	24ffffc4 	addi	r19,r4,-1
8112867c:	003fe906 	br	81128624 <__reset+0xfb108624>
81128680:	1c400084 	addi	r17,r3,2
81128684:	1c000043 	ldbu	r16,1(r3)
81128688:	05c00044 	movi	r23,1
8112868c:	003fac06 	br	81128540 <__reset+0xfb108540>
81128690:	1c400084 	addi	r17,r3,2
81128694:	1c000043 	ldbu	r16,1(r3)
81128698:	002f883a 	mov	r23,zero
8112869c:	003fa806 	br	81128540 <__reset+0xfb108540>
811286a0:	88800003 	ldbu	r2,0(r17)
811286a4:	00c01604 	movi	r3,88
811286a8:	108037cc 	andi	r2,r2,223
811286ac:	10c00c26 	beq	r2,r3,811286e0 <_strtoul_r+0x220>
811286b0:	05400204 	movi	r21,8
811286b4:	01c80034 	movhi	r7,8192
811286b8:	030001c4 	movi	r12,7
811286bc:	39ffffc4 	addi	r7,r7,-1
811286c0:	a817883a 	mov	r11,r21
811286c4:	003fb506 	br	8112859c <__reset+0xfb10859c>
811286c8:	00800c04 	movi	r2,48
811286cc:	80800c1e 	bne	r16,r2,81128700 <_strtoul_r+0x240>
811286d0:	88800003 	ldbu	r2,0(r17)
811286d4:	00c01604 	movi	r3,88
811286d8:	108037cc 	andi	r2,r2,223
811286dc:	10c0081e 	bne	r2,r3,81128700 <_strtoul_r+0x240>
811286e0:	02c00404 	movi	r11,16
811286e4:	05840034 	movhi	r22,4096
811286e8:	8c000043 	ldbu	r16,1(r17)
811286ec:	030003c4 	movi	r12,15
811286f0:	8c400084 	addi	r17,r17,2
811286f4:	b5bfffc4 	addi	r22,r22,-1
811286f8:	582b883a 	mov	r21,r11
811286fc:	003f9e06 	br	81128578 <__reset+0xfb108578>
81128700:	01c40034 	movhi	r7,4096
81128704:	030003c4 	movi	r12,15
81128708:	39ffffc4 	addi	r7,r7,-1
8112870c:	a817883a 	mov	r11,r21
81128710:	003fa206 	br	8112859c <__reset+0xfb10859c>

81128714 <strtoul>:
81128714:	00a04534 	movhi	r2,33044
81128718:	109e0f04 	addi	r2,r2,30780
8112871c:	300f883a 	mov	r7,r6
81128720:	280d883a 	mov	r6,r5
81128724:	200b883a 	mov	r5,r4
81128728:	11000017 	ldw	r4,0(r2)
8112872c:	11284c01 	jmpi	811284c0 <_strtoul_r>

81128730 <_strtoull_r>:
81128730:	00a04534 	movhi	r2,33044
81128734:	defff404 	addi	sp,sp,-48
81128738:	109e0d04 	addi	r2,r2,30772
8112873c:	de00012e 	bgeu	sp,et,81128744 <_strtoull_r+0x14>
81128740:	003b68fa 	trap	3
81128744:	dc400315 	stw	r17,12(sp)
81128748:	14400017 	ldw	r17,0(r2)
8112874c:	dd400715 	stw	r21,28(sp)
81128750:	dd000615 	stw	r20,24(sp)
81128754:	dcc00515 	stw	r19,20(sp)
81128758:	dc800415 	stw	r18,16(sp)
8112875c:	dfc00b15 	stw	ra,44(sp)
81128760:	df000a15 	stw	fp,40(sp)
81128764:	ddc00915 	stw	r23,36(sp)
81128768:	dd800815 	stw	r22,32(sp)
8112876c:	dc000215 	stw	r16,8(sp)
81128770:	2827883a 	mov	r19,r5
81128774:	202b883a 	mov	r21,r4
81128778:	3029883a 	mov	r20,r6
8112877c:	3825883a 	mov	r18,r7
81128780:	2807883a 	mov	r3,r5
81128784:	1c000003 	ldbu	r16,0(r3)
81128788:	1f000044 	addi	fp,r3,1
8112878c:	1809883a 	mov	r4,r3
81128790:	8c05883a 	add	r2,r17,r16
81128794:	10800043 	ldbu	r2,1(r2)
81128798:	e007883a 	mov	r3,fp
8112879c:	1080020c 	andi	r2,r2,8
811287a0:	103ff81e 	bne	r2,zero,81128784 <__reset+0xfb108784>
811287a4:	00800b44 	movi	r2,45
811287a8:	80806e26 	beq	r16,r2,81128964 <_strtoull_r+0x234>
811287ac:	00800ac4 	movi	r2,43
811287b0:	80807026 	beq	r16,r2,81128974 <_strtoull_r+0x244>
811287b4:	002f883a 	mov	r23,zero
811287b8:	90001426 	beq	r18,zero,8112880c <_strtoull_r+0xdc>
811287bc:	00800404 	movi	r2,16
811287c0:	90807c26 	beq	r18,r2,811289b4 <_strtoull_r+0x284>
811287c4:	902dd7fa 	srai	r22,r18,31
811287c8:	013fffc4 	movi	r4,-1
811287cc:	200b883a 	mov	r5,r4
811287d0:	900d883a 	mov	r6,r18
811287d4:	b00f883a 	mov	r7,r22
811287d8:	112cd2c0 	call	8112cd2c <__udivdi3>
811287dc:	013fffc4 	movi	r4,-1
811287e0:	900d883a 	mov	r6,r18
811287e4:	b00f883a 	mov	r7,r22
811287e8:	200b883a 	mov	r5,r4
811287ec:	d8c00115 	stw	r3,4(sp)
811287f0:	d8800015 	stw	r2,0(sp)
811287f4:	112d2ac0 	call	8112d2ac <__umoddi3>
811287f8:	101b883a 	mov	r13,r2
811287fc:	9015883a 	mov	r10,r18
81128800:	dac00017 	ldw	r11,0(sp)
81128804:	da000117 	ldw	r8,4(sp)
81128808:	00000a06 	br	81128834 <_strtoull_r+0x104>
8112880c:	00800c04 	movi	r2,48
81128810:	80805c26 	beq	r16,r2,81128984 <_strtoull_r+0x254>
81128814:	02800284 	movi	r10,10
81128818:	02e666b4 	movhi	r11,39322
8112881c:	020666b4 	movhi	r8,6554
81128820:	03400144 	movi	r13,5
81128824:	5ae66644 	addi	r11,r11,-26215
81128828:	42266644 	addi	r8,r8,-26215
8112882c:	002d883a 	mov	r22,zero
81128830:	5025883a 	mov	r18,r10
81128834:	8c0b883a 	add	r5,r17,r16
81128838:	29400043 	ldbu	r5,1(r5)
8112883c:	e009883a 	mov	r4,fp
81128840:	000f883a 	mov	r7,zero
81128844:	2980010c 	andi	r6,r5,4
81128848:	0005883a 	mov	r2,zero
8112884c:	0007883a 	mov	r3,zero
81128850:	03000044 	movi	r12,1
81128854:	027fffc4 	movi	r9,-1
81128858:	30000d26 	beq	r6,zero,81128890 <_strtoull_r+0x160>
8112885c:	843ff404 	addi	r16,r16,-48
81128860:	8480110e 	bge	r16,r18,811288a8 <_strtoull_r+0x178>
81128864:	3a400426 	beq	r7,r9,81128878 <_strtoull_r+0x148>
81128868:	40c00236 	bltu	r8,r3,81128874 <_strtoull_r+0x144>
8112886c:	1a00231e 	bne	r3,r8,811288fc <_strtoull_r+0x1cc>
81128870:	5880222e 	bgeu	r11,r2,811288fc <_strtoull_r+0x1cc>
81128874:	01ffffc4 	movi	r7,-1
81128878:	24000003 	ldbu	r16,0(r4)
8112887c:	21000044 	addi	r4,r4,1
81128880:	8c0b883a 	add	r5,r17,r16
81128884:	29400043 	ldbu	r5,1(r5)
81128888:	2980010c 	andi	r6,r5,4
8112888c:	303ff31e 	bne	r6,zero,8112885c <__reset+0xfb10885c>
81128890:	294000cc 	andi	r5,r5,3
81128894:	28000426 	beq	r5,zero,811288a8 <_strtoull_r+0x178>
81128898:	2b002626 	beq	r5,r12,81128934 <_strtoull_r+0x204>
8112889c:	014015c4 	movi	r5,87
811288a0:	8161c83a 	sub	r16,r16,r5
811288a4:	84bfef16 	blt	r16,r18,81128864 <__reset+0xfb108864>
811288a8:	38002716 	blt	r7,zero,81128948 <_strtoull_r+0x218>
811288ac:	b8000426 	beq	r23,zero,811288c0 <_strtoull_r+0x190>
811288b0:	0085c83a 	sub	r2,zero,r2
811288b4:	100ac03a 	cmpne	r5,r2,zero
811288b8:	00e1c83a 	sub	r16,zero,r3
811288bc:	8147c83a 	sub	r3,r16,r5
811288c0:	a0000226 	beq	r20,zero,811288cc <_strtoull_r+0x19c>
811288c4:	3800251e 	bne	r7,zero,8112895c <_strtoull_r+0x22c>
811288c8:	a4c00015 	stw	r19,0(r20)
811288cc:	dfc00b17 	ldw	ra,44(sp)
811288d0:	df000a17 	ldw	fp,40(sp)
811288d4:	ddc00917 	ldw	r23,36(sp)
811288d8:	dd800817 	ldw	r22,32(sp)
811288dc:	dd400717 	ldw	r21,28(sp)
811288e0:	dd000617 	ldw	r20,24(sp)
811288e4:	dcc00517 	ldw	r19,20(sp)
811288e8:	dc800417 	ldw	r18,16(sp)
811288ec:	dc400317 	ldw	r17,12(sp)
811288f0:	dc000217 	ldw	r16,8(sp)
811288f4:	dec00c04 	addi	sp,sp,48
811288f8:	f800283a 	ret
811288fc:	12c00f26 	beq	r2,r11,8112893c <_strtoull_r+0x20c>
81128900:	b08d383a 	mul	r6,r22,r2
81128904:	1a87383a 	mul	r3,r3,r10
81128908:	128a383a 	mulxuu	r5,r2,r10
8112890c:	1285383a 	mul	r2,r2,r10
81128910:	800fd7fa 	srai	r7,r16,31
81128914:	1987883a 	add	r3,r3,r6
81128918:	8085883a 	add	r2,r16,r2
8112891c:	1947883a 	add	r3,r3,r5
81128920:	38c7883a 	add	r3,r7,r3
81128924:	1421803a 	cmpltu	r16,r2,r16
81128928:	80c7883a 	add	r3,r16,r3
8112892c:	01c00044 	movi	r7,1
81128930:	003fd106 	br	81128878 <__reset+0xfb108878>
81128934:	01400dc4 	movi	r5,55
81128938:	003fd906 	br	811288a0 <__reset+0xfb1088a0>
8112893c:	1a3ff01e 	bne	r3,r8,81128900 <__reset+0xfb108900>
81128940:	6c3fcc16 	blt	r13,r16,81128874 <__reset+0xfb108874>
81128944:	003fee06 	br	81128900 <__reset+0xfb108900>
81128948:	00800884 	movi	r2,34
8112894c:	a8800015 	stw	r2,0(r21)
81128950:	00bfffc4 	movi	r2,-1
81128954:	1007883a 	mov	r3,r2
81128958:	a03fdc26 	beq	r20,zero,811288cc <__reset+0xfb1088cc>
8112895c:	24ffffc4 	addi	r19,r4,-1
81128960:	003fd906 	br	811288c8 <__reset+0xfb1088c8>
81128964:	27000084 	addi	fp,r4,2
81128968:	24000043 	ldbu	r16,1(r4)
8112896c:	05c00044 	movi	r23,1
81128970:	003f9106 	br	811287b8 <__reset+0xfb1087b8>
81128974:	27000084 	addi	fp,r4,2
81128978:	24000043 	ldbu	r16,1(r4)
8112897c:	002f883a 	mov	r23,zero
81128980:	003f8d06 	br	811287b8 <__reset+0xfb1087b8>
81128984:	e0800003 	ldbu	r2,0(fp)
81128988:	00c01604 	movi	r3,88
8112898c:	108037cc 	andi	r2,r2,223
81128990:	10c00e26 	beq	r2,r3,811289cc <_strtoull_r+0x29c>
81128994:	02800204 	movi	r10,8
81128998:	02ffffc4 	movi	r11,-1
8112899c:	02080034 	movhi	r8,8192
811289a0:	034001c4 	movi	r13,7
811289a4:	42d1883a 	add	r8,r8,r11
811289a8:	002d883a 	mov	r22,zero
811289ac:	5025883a 	mov	r18,r10
811289b0:	003fa006 	br	81128834 <__reset+0xfb108834>
811289b4:	00800c04 	movi	r2,48
811289b8:	80800e1e 	bne	r16,r2,811289f4 <_strtoull_r+0x2c4>
811289bc:	e0800003 	ldbu	r2,0(fp)
811289c0:	00c01604 	movi	r3,88
811289c4:	108037cc 	andi	r2,r2,223
811289c8:	10c00a1e 	bne	r2,r3,811289f4 <_strtoull_r+0x2c4>
811289cc:	02800404 	movi	r10,16
811289d0:	02ffffc4 	movi	r11,-1
811289d4:	02040034 	movhi	r8,4096
811289d8:	e4000043 	ldbu	r16,1(fp)
811289dc:	034003c4 	movi	r13,15
811289e0:	e7000084 	addi	fp,fp,2
811289e4:	42d1883a 	add	r8,r8,r11
811289e8:	002d883a 	mov	r22,zero
811289ec:	5025883a 	mov	r18,r10
811289f0:	003f9006 	br	81128834 <__reset+0xfb108834>
811289f4:	02ffffc4 	movi	r11,-1
811289f8:	02040034 	movhi	r8,4096
811289fc:	034003c4 	movi	r13,15
81128a00:	42d1883a 	add	r8,r8,r11
81128a04:	9015883a 	mov	r10,r18
81128a08:	002d883a 	mov	r22,zero
81128a0c:	003f8906 	br	81128834 <__reset+0xfb108834>

81128a10 <__ssprint_r>:
81128a10:	defff604 	addi	sp,sp,-40
81128a14:	de00012e 	bgeu	sp,et,81128a1c <__ssprint_r+0xc>
81128a18:	003b68fa 	trap	3
81128a1c:	30800217 	ldw	r2,8(r6)
81128a20:	dc800215 	stw	r18,8(sp)
81128a24:	dfc00915 	stw	ra,36(sp)
81128a28:	df000815 	stw	fp,32(sp)
81128a2c:	ddc00715 	stw	r23,28(sp)
81128a30:	dd800615 	stw	r22,24(sp)
81128a34:	dd400515 	stw	r21,20(sp)
81128a38:	dd000415 	stw	r20,16(sp)
81128a3c:	dcc00315 	stw	r19,12(sp)
81128a40:	dc400115 	stw	r17,4(sp)
81128a44:	dc000015 	stw	r16,0(sp)
81128a48:	3025883a 	mov	r18,r6
81128a4c:	10005826 	beq	r2,zero,81128bb0 <__ssprint_r+0x1a0>
81128a50:	2027883a 	mov	r19,r4
81128a54:	35c00017 	ldw	r23,0(r6)
81128a58:	29000017 	ldw	r4,0(r5)
81128a5c:	28800217 	ldw	r2,8(r5)
81128a60:	2823883a 	mov	r17,r5
81128a64:	0039883a 	mov	fp,zero
81128a68:	0021883a 	mov	r16,zero
81128a6c:	80003926 	beq	r16,zero,81128b54 <__ssprint_r+0x144>
81128a70:	102b883a 	mov	r21,r2
81128a74:	102d883a 	mov	r22,r2
81128a78:	80803a36 	bltu	r16,r2,81128b64 <__ssprint_r+0x154>
81128a7c:	88c0030b 	ldhu	r3,12(r17)
81128a80:	1881200c 	andi	r2,r3,1152
81128a84:	10002626 	beq	r2,zero,81128b20 <__ssprint_r+0x110>
81128a88:	88800517 	ldw	r2,20(r17)
81128a8c:	89400417 	ldw	r5,16(r17)
81128a90:	81800044 	addi	r6,r16,1
81128a94:	108f883a 	add	r7,r2,r2
81128a98:	3885883a 	add	r2,r7,r2
81128a9c:	100ed7fa 	srli	r7,r2,31
81128aa0:	216dc83a 	sub	r22,r4,r5
81128aa4:	3589883a 	add	r4,r6,r22
81128aa8:	3885883a 	add	r2,r7,r2
81128aac:	102bd07a 	srai	r21,r2,1
81128ab0:	a80d883a 	mov	r6,r21
81128ab4:	a900022e 	bgeu	r21,r4,81128ac0 <__ssprint_r+0xb0>
81128ab8:	202b883a 	mov	r21,r4
81128abc:	200d883a 	mov	r6,r4
81128ac0:	18c1000c 	andi	r3,r3,1024
81128ac4:	18002a26 	beq	r3,zero,81128b70 <__ssprint_r+0x160>
81128ac8:	300b883a 	mov	r5,r6
81128acc:	9809883a 	mov	r4,r19
81128ad0:	11245040 	call	81124504 <_malloc_r>
81128ad4:	1029883a 	mov	r20,r2
81128ad8:	10002c26 	beq	r2,zero,81128b8c <__ssprint_r+0x17c>
81128adc:	89400417 	ldw	r5,16(r17)
81128ae0:	b00d883a 	mov	r6,r22
81128ae4:	1009883a 	mov	r4,r2
81128ae8:	111abac0 	call	8111abac <memcpy>
81128aec:	8880030b 	ldhu	r2,12(r17)
81128af0:	00fedfc4 	movi	r3,-1153
81128af4:	10c4703a 	and	r2,r2,r3
81128af8:	10802014 	ori	r2,r2,128
81128afc:	8880030d 	sth	r2,12(r17)
81128b00:	a589883a 	add	r4,r20,r22
81128b04:	adadc83a 	sub	r22,r21,r22
81128b08:	8d400515 	stw	r21,20(r17)
81128b0c:	8d800215 	stw	r22,8(r17)
81128b10:	8d000415 	stw	r20,16(r17)
81128b14:	89000015 	stw	r4,0(r17)
81128b18:	802b883a 	mov	r21,r16
81128b1c:	802d883a 	mov	r22,r16
81128b20:	b00d883a 	mov	r6,r22
81128b24:	e00b883a 	mov	r5,fp
81128b28:	11250400 	call	81125040 <memmove>
81128b2c:	88800217 	ldw	r2,8(r17)
81128b30:	89000017 	ldw	r4,0(r17)
81128b34:	90c00217 	ldw	r3,8(r18)
81128b38:	1545c83a 	sub	r2,r2,r21
81128b3c:	2589883a 	add	r4,r4,r22
81128b40:	88800215 	stw	r2,8(r17)
81128b44:	89000015 	stw	r4,0(r17)
81128b48:	1c21c83a 	sub	r16,r3,r16
81128b4c:	94000215 	stw	r16,8(r18)
81128b50:	80001726 	beq	r16,zero,81128bb0 <__ssprint_r+0x1a0>
81128b54:	bf000017 	ldw	fp,0(r23)
81128b58:	bc000117 	ldw	r16,4(r23)
81128b5c:	bdc00204 	addi	r23,r23,8
81128b60:	003fc206 	br	81128a6c <__reset+0xfb108a6c>
81128b64:	802b883a 	mov	r21,r16
81128b68:	802d883a 	mov	r22,r16
81128b6c:	003fec06 	br	81128b20 <__reset+0xfb108b20>
81128b70:	9809883a 	mov	r4,r19
81128b74:	11261f80 	call	811261f8 <_realloc_r>
81128b78:	1029883a 	mov	r20,r2
81128b7c:	103fe01e 	bne	r2,zero,81128b00 <__reset+0xfb108b00>
81128b80:	89400417 	ldw	r5,16(r17)
81128b84:	9809883a 	mov	r4,r19
81128b88:	11238b80 	call	811238b8 <_free_r>
81128b8c:	88c0030b 	ldhu	r3,12(r17)
81128b90:	00800304 	movi	r2,12
81128b94:	98800015 	stw	r2,0(r19)
81128b98:	18c01014 	ori	r3,r3,64
81128b9c:	88c0030d 	sth	r3,12(r17)
81128ba0:	00bfffc4 	movi	r2,-1
81128ba4:	90000215 	stw	zero,8(r18)
81128ba8:	90000115 	stw	zero,4(r18)
81128bac:	00000206 	br	81128bb8 <__ssprint_r+0x1a8>
81128bb0:	90000115 	stw	zero,4(r18)
81128bb4:	0005883a 	mov	r2,zero
81128bb8:	dfc00917 	ldw	ra,36(sp)
81128bbc:	df000817 	ldw	fp,32(sp)
81128bc0:	ddc00717 	ldw	r23,28(sp)
81128bc4:	dd800617 	ldw	r22,24(sp)
81128bc8:	dd400517 	ldw	r21,20(sp)
81128bcc:	dd000417 	ldw	r20,16(sp)
81128bd0:	dcc00317 	ldw	r19,12(sp)
81128bd4:	dc800217 	ldw	r18,8(sp)
81128bd8:	dc400117 	ldw	r17,4(sp)
81128bdc:	dc000017 	ldw	r16,0(sp)
81128be0:	dec00a04 	addi	sp,sp,40
81128be4:	f800283a 	ret

81128be8 <___svfiprintf_internal_r>:
81128be8:	deffc804 	addi	sp,sp,-224
81128bec:	de00012e 	bgeu	sp,et,81128bf4 <___svfiprintf_internal_r+0xc>
81128bf0:	003b68fa 	trap	3
81128bf4:	2880030b 	ldhu	r2,12(r5)
81128bf8:	dcc03115 	stw	r19,196(sp)
81128bfc:	dfc03715 	stw	ra,220(sp)
81128c00:	df003615 	stw	fp,216(sp)
81128c04:	ddc03515 	stw	r23,212(sp)
81128c08:	dd803415 	stw	r22,208(sp)
81128c0c:	dd403315 	stw	r21,204(sp)
81128c10:	dd003215 	stw	r20,200(sp)
81128c14:	dc803015 	stw	r18,192(sp)
81128c18:	dc402f15 	stw	r17,188(sp)
81128c1c:	dc002e15 	stw	r16,184(sp)
81128c20:	d9402715 	stw	r5,156(sp)
81128c24:	d9002a15 	stw	r4,168(sp)
81128c28:	1080200c 	andi	r2,r2,128
81128c2c:	d9c02315 	stw	r7,140(sp)
81128c30:	3027883a 	mov	r19,r6
81128c34:	10000226 	beq	r2,zero,81128c40 <___svfiprintf_internal_r+0x58>
81128c38:	28800417 	ldw	r2,16(r5)
81128c3c:	10041d26 	beq	r2,zero,81129cb4 <___svfiprintf_internal_r+0x10cc>
81128c40:	dac01a04 	addi	r11,sp,104
81128c44:	dac01e15 	stw	r11,120(sp)
81128c48:	d8801e17 	ldw	r2,120(sp)
81128c4c:	dac019c4 	addi	r11,sp,103
81128c50:	dd402a17 	ldw	r21,168(sp)
81128c54:	ddc02717 	ldw	r23,156(sp)
81128c58:	05a04534 	movhi	r22,33044
81128c5c:	05204534 	movhi	r20,33044
81128c60:	dac01f15 	stw	r11,124(sp)
81128c64:	12d7c83a 	sub	r11,r2,r11
81128c68:	b594ce04 	addi	r22,r22,21304
81128c6c:	a514ca04 	addi	r20,r20,21288
81128c70:	dec01a15 	stw	sp,104(sp)
81128c74:	d8001c15 	stw	zero,112(sp)
81128c78:	d8001b15 	stw	zero,108(sp)
81128c7c:	d811883a 	mov	r8,sp
81128c80:	d8002915 	stw	zero,164(sp)
81128c84:	d8002515 	stw	zero,148(sp)
81128c88:	dac02b15 	stw	r11,172(sp)
81128c8c:	98800007 	ldb	r2,0(r19)
81128c90:	1002dd26 	beq	r2,zero,81129808 <___svfiprintf_internal_r+0xc20>
81128c94:	00c00944 	movi	r3,37
81128c98:	9823883a 	mov	r17,r19
81128c9c:	10c0021e 	bne	r2,r3,81128ca8 <___svfiprintf_internal_r+0xc0>
81128ca0:	00001406 	br	81128cf4 <___svfiprintf_internal_r+0x10c>
81128ca4:	10c00326 	beq	r2,r3,81128cb4 <___svfiprintf_internal_r+0xcc>
81128ca8:	8c400044 	addi	r17,r17,1
81128cac:	88800007 	ldb	r2,0(r17)
81128cb0:	103ffc1e 	bne	r2,zero,81128ca4 <__reset+0xfb108ca4>
81128cb4:	8ce1c83a 	sub	r16,r17,r19
81128cb8:	80000e26 	beq	r16,zero,81128cf4 <___svfiprintf_internal_r+0x10c>
81128cbc:	d8c01c17 	ldw	r3,112(sp)
81128cc0:	d8801b17 	ldw	r2,108(sp)
81128cc4:	44c00015 	stw	r19,0(r8)
81128cc8:	1c07883a 	add	r3,r3,r16
81128ccc:	10800044 	addi	r2,r2,1
81128cd0:	d8c01c15 	stw	r3,112(sp)
81128cd4:	44000115 	stw	r16,4(r8)
81128cd8:	d8801b15 	stw	r2,108(sp)
81128cdc:	00c001c4 	movi	r3,7
81128ce0:	18831e16 	blt	r3,r2,8112995c <___svfiprintf_internal_r+0xd74>
81128ce4:	42000204 	addi	r8,r8,8
81128ce8:	dac02517 	ldw	r11,148(sp)
81128cec:	5c17883a 	add	r11,r11,r16
81128cf0:	dac02515 	stw	r11,148(sp)
81128cf4:	88800007 	ldb	r2,0(r17)
81128cf8:	1002c526 	beq	r2,zero,81129810 <___svfiprintf_internal_r+0xc28>
81128cfc:	88c00047 	ldb	r3,1(r17)
81128d00:	8cc00044 	addi	r19,r17,1
81128d04:	d8001d85 	stb	zero,118(sp)
81128d08:	0009883a 	mov	r4,zero
81128d0c:	000f883a 	mov	r7,zero
81128d10:	043fffc4 	movi	r16,-1
81128d14:	d8002415 	stw	zero,144(sp)
81128d18:	0025883a 	mov	r18,zero
81128d1c:	01401604 	movi	r5,88
81128d20:	01800244 	movi	r6,9
81128d24:	02800a84 	movi	r10,42
81128d28:	02401b04 	movi	r9,108
81128d2c:	9cc00044 	addi	r19,r19,1
81128d30:	18bff804 	addi	r2,r3,-32
81128d34:	2881dd36 	bltu	r5,r2,811294ac <___svfiprintf_internal_r+0x8c4>
81128d38:	100490ba 	slli	r2,r2,2
81128d3c:	02e044f4 	movhi	r11,33043
81128d40:	5ae35404 	addi	r11,r11,-29360
81128d44:	12c5883a 	add	r2,r2,r11
81128d48:	10800017 	ldw	r2,0(r2)
81128d4c:	1000683a 	jmp	r2
81128d50:	81128f4c 	andi	r4,r16,19005
81128d54:	811294ac 	andhi	r4,r16,19026
81128d58:	811294ac 	andhi	r4,r16,19026
81128d5c:	81128f40 	call	881128f4 <__reset+0x20f28f4>
81128d60:	811294ac 	andhi	r4,r16,19026
81128d64:	811294ac 	andhi	r4,r16,19026
81128d68:	811294ac 	andhi	r4,r16,19026
81128d6c:	811294ac 	andhi	r4,r16,19026
81128d70:	811294ac 	andhi	r4,r16,19026
81128d74:	811294ac 	andhi	r4,r16,19026
81128d78:	81128eb4 	orhi	r4,r16,19002
81128d7c:	81129090 	cmplti	r4,r16,19010
81128d80:	811294ac 	andhi	r4,r16,19026
81128d84:	81128ee0 	cmpeqi	r4,r16,19003
81128d88:	811294e0 	cmpeqi	r4,r16,19027
81128d8c:	811294ac 	andhi	r4,r16,19026
81128d90:	811294d4 	ori	r4,r16,19027
81128d94:	81129474 	orhi	r4,r16,19025
81128d98:	81129474 	orhi	r4,r16,19025
81128d9c:	81129474 	orhi	r4,r16,19025
81128da0:	81129474 	orhi	r4,r16,19025
81128da4:	81129474 	orhi	r4,r16,19025
81128da8:	81129474 	orhi	r4,r16,19025
81128dac:	81129474 	orhi	r4,r16,19025
81128db0:	81129474 	orhi	r4,r16,19025
81128db4:	81129474 	orhi	r4,r16,19025
81128db8:	811294ac 	andhi	r4,r16,19026
81128dbc:	811294ac 	andhi	r4,r16,19026
81128dc0:	811294ac 	andhi	r4,r16,19026
81128dc4:	811294ac 	andhi	r4,r16,19026
81128dc8:	811294ac 	andhi	r4,r16,19026
81128dcc:	811294ac 	andhi	r4,r16,19026
81128dd0:	811294ac 	andhi	r4,r16,19026
81128dd4:	811294ac 	andhi	r4,r16,19026
81128dd8:	811294ac 	andhi	r4,r16,19026
81128ddc:	811294ac 	andhi	r4,r16,19026
81128de0:	81129410 	cmplti	r4,r16,19024
81128de4:	811294ac 	andhi	r4,r16,19026
81128de8:	811294ac 	andhi	r4,r16,19026
81128dec:	811294ac 	andhi	r4,r16,19026
81128df0:	811294ac 	andhi	r4,r16,19026
81128df4:	811294ac 	andhi	r4,r16,19026
81128df8:	811294ac 	andhi	r4,r16,19026
81128dfc:	811294ac 	andhi	r4,r16,19026
81128e00:	811294ac 	andhi	r4,r16,19026
81128e04:	811294ac 	andhi	r4,r16,19026
81128e08:	811294ac 	andhi	r4,r16,19026
81128e0c:	81129588 	cmpgei	r4,r16,19030
81128e10:	811294ac 	andhi	r4,r16,19026
81128e14:	811294ac 	andhi	r4,r16,19026
81128e18:	811294ac 	andhi	r4,r16,19026
81128e1c:	811294ac 	andhi	r4,r16,19026
81128e20:	811294ac 	andhi	r4,r16,19026
81128e24:	81129520 	cmpeqi	r4,r16,19028
81128e28:	811294ac 	andhi	r4,r16,19026
81128e2c:	811294ac 	andhi	r4,r16,19026
81128e30:	81129254 	ori	r4,r16,19017
81128e34:	811294ac 	andhi	r4,r16,19026
81128e38:	811294ac 	andhi	r4,r16,19026
81128e3c:	811294ac 	andhi	r4,r16,19026
81128e40:	811294ac 	andhi	r4,r16,19026
81128e44:	811294ac 	andhi	r4,r16,19026
81128e48:	811294ac 	andhi	r4,r16,19026
81128e4c:	811294ac 	andhi	r4,r16,19026
81128e50:	811294ac 	andhi	r4,r16,19026
81128e54:	811294ac 	andhi	r4,r16,19026
81128e58:	811294ac 	andhi	r4,r16,19026
81128e5c:	81129144 	addi	r4,r16,19013
81128e60:	811292f0 	cmpltui	r4,r16,19019
81128e64:	811294ac 	andhi	r4,r16,19026
81128e68:	811294ac 	andhi	r4,r16,19026
81128e6c:	811294ac 	andhi	r4,r16,19026
81128e70:	811292e4 	muli	r4,r16,19019
81128e74:	811292f0 	cmpltui	r4,r16,19019
81128e78:	811294ac 	andhi	r4,r16,19026
81128e7c:	811294ac 	andhi	r4,r16,19026
81128e80:	811292d4 	ori	r4,r16,19019
81128e84:	811294ac 	andhi	r4,r16,19026
81128e88:	81129298 	cmpnei	r4,r16,19018
81128e8c:	811290a0 	cmpeqi	r4,r16,19010
81128e90:	81128eec 	andhi	r4,r16,19003
81128e94:	81129404 	addi	r4,r16,19024
81128e98:	811294ac 	andhi	r4,r16,19026
81128e9c:	811293b8 	rdprs	r4,r16,19022
81128ea0:	811294ac 	andhi	r4,r16,19026
81128ea4:	81129010 	cmplti	r4,r16,19008
81128ea8:	811294ac 	andhi	r4,r16,19026
81128eac:	811294ac 	andhi	r4,r16,19026
81128eb0:	81128f6c 	andhi	r4,r16,19005
81128eb4:	dac02317 	ldw	r11,140(sp)
81128eb8:	5ac00017 	ldw	r11,0(r11)
81128ebc:	dac02415 	stw	r11,144(sp)
81128ec0:	dac02317 	ldw	r11,140(sp)
81128ec4:	58800104 	addi	r2,r11,4
81128ec8:	dac02417 	ldw	r11,144(sp)
81128ecc:	5802e90e 	bge	r11,zero,81129a74 <___svfiprintf_internal_r+0xe8c>
81128ed0:	dac02417 	ldw	r11,144(sp)
81128ed4:	d8802315 	stw	r2,140(sp)
81128ed8:	02d7c83a 	sub	r11,zero,r11
81128edc:	dac02415 	stw	r11,144(sp)
81128ee0:	94800114 	ori	r18,r18,4
81128ee4:	98c00007 	ldb	r3,0(r19)
81128ee8:	003f9006 	br	81128d2c <__reset+0xfb108d2c>
81128eec:	00800c04 	movi	r2,48
81128ef0:	dac02317 	ldw	r11,140(sp)
81128ef4:	d8801d05 	stb	r2,116(sp)
81128ef8:	00801e04 	movi	r2,120
81128efc:	d8801d45 	stb	r2,117(sp)
81128f00:	d8001d85 	stb	zero,118(sp)
81128f04:	58c00104 	addi	r3,r11,4
81128f08:	5f000017 	ldw	fp,0(r11)
81128f0c:	0013883a 	mov	r9,zero
81128f10:	90800094 	ori	r2,r18,2
81128f14:	80032b16 	blt	r16,zero,81129bc4 <___svfiprintf_internal_r+0xfdc>
81128f18:	00bfdfc4 	movi	r2,-129
81128f1c:	90a4703a 	and	r18,r18,r2
81128f20:	d8c02315 	stw	r3,140(sp)
81128f24:	94800094 	ori	r18,r18,2
81128f28:	e002dc26 	beq	fp,zero,81129a9c <___svfiprintf_internal_r+0xeb4>
81128f2c:	01204534 	movhi	r4,33044
81128f30:	21143f04 	addi	r4,r4,20732
81128f34:	0015883a 	mov	r10,zero
81128f38:	d9002915 	stw	r4,164(sp)
81128f3c:	00002306 	br	81128fcc <___svfiprintf_internal_r+0x3e4>
81128f40:	94800054 	ori	r18,r18,1
81128f44:	98c00007 	ldb	r3,0(r19)
81128f48:	003f7806 	br	81128d2c <__reset+0xfb108d2c>
81128f4c:	38803fcc 	andi	r2,r7,255
81128f50:	1080201c 	xori	r2,r2,128
81128f54:	10bfe004 	addi	r2,r2,-128
81128f58:	1002f31e 	bne	r2,zero,81129b28 <___svfiprintf_internal_r+0xf40>
81128f5c:	01000044 	movi	r4,1
81128f60:	01c00804 	movi	r7,32
81128f64:	98c00007 	ldb	r3,0(r19)
81128f68:	003f7006 	br	81128d2c <__reset+0xfb108d2c>
81128f6c:	21003fcc 	andi	r4,r4,255
81128f70:	2003aa1e 	bne	r4,zero,81129e1c <___svfiprintf_internal_r+0x1234>
81128f74:	00a04534 	movhi	r2,33044
81128f78:	10943f04 	addi	r2,r2,20732
81128f7c:	d8802915 	stw	r2,164(sp)
81128f80:	9080080c 	andi	r2,r18,32
81128f84:	1000ba26 	beq	r2,zero,81129270 <___svfiprintf_internal_r+0x688>
81128f88:	dac02317 	ldw	r11,140(sp)
81128f8c:	5f000017 	ldw	fp,0(r11)
81128f90:	5a400117 	ldw	r9,4(r11)
81128f94:	5ac00204 	addi	r11,r11,8
81128f98:	dac02315 	stw	r11,140(sp)
81128f9c:	9080004c 	andi	r2,r18,1
81128fa0:	10029026 	beq	r2,zero,811299e4 <___svfiprintf_internal_r+0xdfc>
81128fa4:	e244b03a 	or	r2,fp,r9
81128fa8:	1002d41e 	bne	r2,zero,81129afc <___svfiprintf_internal_r+0xf14>
81128fac:	d8001d85 	stb	zero,118(sp)
81128fb0:	80030b16 	blt	r16,zero,81129be0 <___svfiprintf_internal_r+0xff8>
81128fb4:	00bfdfc4 	movi	r2,-129
81128fb8:	90a4703a 	and	r18,r18,r2
81128fbc:	0015883a 	mov	r10,zero
81128fc0:	80002426 	beq	r16,zero,81129054 <___svfiprintf_internal_r+0x46c>
81128fc4:	0039883a 	mov	fp,zero
81128fc8:	0013883a 	mov	r9,zero
81128fcc:	d9002917 	ldw	r4,164(sp)
81128fd0:	dc401a04 	addi	r17,sp,104
81128fd4:	e08003cc 	andi	r2,fp,15
81128fd8:	4806973a 	slli	r3,r9,28
81128fdc:	2085883a 	add	r2,r4,r2
81128fe0:	e038d13a 	srli	fp,fp,4
81128fe4:	10800003 	ldbu	r2,0(r2)
81128fe8:	4812d13a 	srli	r9,r9,4
81128fec:	8c7fffc4 	addi	r17,r17,-1
81128ff0:	1f38b03a 	or	fp,r3,fp
81128ff4:	88800005 	stb	r2,0(r17)
81128ff8:	e244b03a 	or	r2,fp,r9
81128ffc:	103ff51e 	bne	r2,zero,81128fd4 <__reset+0xfb108fd4>
81129000:	dac01e17 	ldw	r11,120(sp)
81129004:	5c57c83a 	sub	r11,r11,r17
81129008:	dac02115 	stw	r11,132(sp)
8112900c:	00001406 	br	81129060 <___svfiprintf_internal_r+0x478>
81129010:	21003fcc 	andi	r4,r4,255
81129014:	2003741e 	bne	r4,zero,81129de8 <___svfiprintf_internal_r+0x1200>
81129018:	9080080c 	andi	r2,r18,32
8112901c:	10014526 	beq	r2,zero,81129534 <___svfiprintf_internal_r+0x94c>
81129020:	dac02317 	ldw	r11,140(sp)
81129024:	d8001d85 	stb	zero,118(sp)
81129028:	58c00204 	addi	r3,r11,8
8112902c:	5f000017 	ldw	fp,0(r11)
81129030:	5a400117 	ldw	r9,4(r11)
81129034:	8002d916 	blt	r16,zero,81129b9c <___svfiprintf_internal_r+0xfb4>
81129038:	013fdfc4 	movi	r4,-129
8112903c:	e244b03a 	or	r2,fp,r9
81129040:	d8c02315 	stw	r3,140(sp)
81129044:	9124703a 	and	r18,r18,r4
81129048:	0015883a 	mov	r10,zero
8112904c:	1000b91e 	bne	r2,zero,81129334 <___svfiprintf_internal_r+0x74c>
81129050:	8002e61e 	bne	r16,zero,81129bec <___svfiprintf_internal_r+0x1004>
81129054:	0021883a 	mov	r16,zero
81129058:	d8002115 	stw	zero,132(sp)
8112905c:	dc401a04 	addi	r17,sp,104
81129060:	d8c02117 	ldw	r3,132(sp)
81129064:	dc002015 	stw	r16,128(sp)
81129068:	80c0010e 	bge	r16,r3,81129070 <___svfiprintf_internal_r+0x488>
8112906c:	d8c02015 	stw	r3,128(sp)
81129070:	52803fcc 	andi	r10,r10,255
81129074:	5280201c 	xori	r10,r10,128
81129078:	52bfe004 	addi	r10,r10,-128
8112907c:	50003c26 	beq	r10,zero,81129170 <___svfiprintf_internal_r+0x588>
81129080:	dac02017 	ldw	r11,128(sp)
81129084:	5ac00044 	addi	r11,r11,1
81129088:	dac02015 	stw	r11,128(sp)
8112908c:	00003806 	br	81129170 <___svfiprintf_internal_r+0x588>
81129090:	01000044 	movi	r4,1
81129094:	01c00ac4 	movi	r7,43
81129098:	98c00007 	ldb	r3,0(r19)
8112909c:	003f2306 	br	81128d2c <__reset+0xfb108d2c>
811290a0:	21003fcc 	andi	r4,r4,255
811290a4:	2003481e 	bne	r4,zero,81129dc8 <___svfiprintf_internal_r+0x11e0>
811290a8:	9080080c 	andi	r2,r18,32
811290ac:	10013b26 	beq	r2,zero,8112959c <___svfiprintf_internal_r+0x9b4>
811290b0:	dac02317 	ldw	r11,140(sp)
811290b4:	d8001d85 	stb	zero,118(sp)
811290b8:	58800204 	addi	r2,r11,8
811290bc:	5f000017 	ldw	fp,0(r11)
811290c0:	5a400117 	ldw	r9,4(r11)
811290c4:	8002a816 	blt	r16,zero,81129b68 <___svfiprintf_internal_r+0xf80>
811290c8:	013fdfc4 	movi	r4,-129
811290cc:	e246b03a 	or	r3,fp,r9
811290d0:	d8802315 	stw	r2,140(sp)
811290d4:	9124703a 	and	r18,r18,r4
811290d8:	18013c26 	beq	r3,zero,811295cc <___svfiprintf_internal_r+0x9e4>
811290dc:	0015883a 	mov	r10,zero
811290e0:	dc401a04 	addi	r17,sp,104
811290e4:	e006d0fa 	srli	r3,fp,3
811290e8:	4808977a 	slli	r4,r9,29
811290ec:	4812d0fa 	srli	r9,r9,3
811290f0:	e70001cc 	andi	fp,fp,7
811290f4:	e0800c04 	addi	r2,fp,48
811290f8:	8c7fffc4 	addi	r17,r17,-1
811290fc:	20f8b03a 	or	fp,r4,r3
81129100:	88800005 	stb	r2,0(r17)
81129104:	e246b03a 	or	r3,fp,r9
81129108:	183ff61e 	bne	r3,zero,811290e4 <__reset+0xfb1090e4>
8112910c:	90c0004c 	andi	r3,r18,1
81129110:	1800a526 	beq	r3,zero,811293a8 <___svfiprintf_internal_r+0x7c0>
81129114:	10803fcc 	andi	r2,r2,255
81129118:	1080201c 	xori	r2,r2,128
8112911c:	10bfe004 	addi	r2,r2,-128
81129120:	00c00c04 	movi	r3,48
81129124:	10ffb626 	beq	r2,r3,81129000 <__reset+0xfb109000>
81129128:	88ffffc5 	stb	r3,-1(r17)
8112912c:	d8c01e17 	ldw	r3,120(sp)
81129130:	88bfffc4 	addi	r2,r17,-1
81129134:	1023883a 	mov	r17,r2
81129138:	1887c83a 	sub	r3,r3,r2
8112913c:	d8c02115 	stw	r3,132(sp)
81129140:	003fc706 	br	81129060 <__reset+0xfb109060>
81129144:	dac02317 	ldw	r11,140(sp)
81129148:	00c00044 	movi	r3,1
8112914c:	d8c02015 	stw	r3,128(sp)
81129150:	58800017 	ldw	r2,0(r11)
81129154:	5ac00104 	addi	r11,r11,4
81129158:	d8001d85 	stb	zero,118(sp)
8112915c:	d8801005 	stb	r2,64(sp)
81129160:	dac02315 	stw	r11,140(sp)
81129164:	d8c02115 	stw	r3,132(sp)
81129168:	dc401004 	addi	r17,sp,64
8112916c:	0021883a 	mov	r16,zero
81129170:	90c0008c 	andi	r3,r18,2
81129174:	d8c02215 	stw	r3,136(sp)
81129178:	18000326 	beq	r3,zero,81129188 <___svfiprintf_internal_r+0x5a0>
8112917c:	dac02017 	ldw	r11,128(sp)
81129180:	5ac00084 	addi	r11,r11,2
81129184:	dac02015 	stw	r11,128(sp)
81129188:	90c0210c 	andi	r3,r18,132
8112918c:	d8c02615 	stw	r3,152(sp)
81129190:	1801131e 	bne	r3,zero,811295e0 <___svfiprintf_internal_r+0x9f8>
81129194:	dac02417 	ldw	r11,144(sp)
81129198:	d8c02017 	ldw	r3,128(sp)
8112919c:	58f9c83a 	sub	fp,r11,r3
811291a0:	07010f0e 	bge	zero,fp,811295e0 <___svfiprintf_internal_r+0x9f8>
811291a4:	02400404 	movi	r9,16
811291a8:	d8c01c17 	ldw	r3,112(sp)
811291ac:	d8801b17 	ldw	r2,108(sp)
811291b0:	4f02d60e 	bge	r9,fp,81129d0c <___svfiprintf_internal_r+0x1124>
811291b4:	01604534 	movhi	r5,33044
811291b8:	2954ce04 	addi	r5,r5,21304
811291bc:	d9402815 	stw	r5,160(sp)
811291c0:	028001c4 	movi	r10,7
811291c4:	00000306 	br	811291d4 <___svfiprintf_internal_r+0x5ec>
811291c8:	e73ffc04 	addi	fp,fp,-16
811291cc:	42000204 	addi	r8,r8,8
811291d0:	4f00150e 	bge	r9,fp,81129228 <___svfiprintf_internal_r+0x640>
811291d4:	18c00404 	addi	r3,r3,16
811291d8:	10800044 	addi	r2,r2,1
811291dc:	45800015 	stw	r22,0(r8)
811291e0:	42400115 	stw	r9,4(r8)
811291e4:	d8c01c15 	stw	r3,112(sp)
811291e8:	d8801b15 	stw	r2,108(sp)
811291ec:	50bff60e 	bge	r10,r2,811291c8 <__reset+0xfb1091c8>
811291f0:	d9801a04 	addi	r6,sp,104
811291f4:	b80b883a 	mov	r5,r23
811291f8:	a809883a 	mov	r4,r21
811291fc:	da402c15 	stw	r9,176(sp)
81129200:	da802d15 	stw	r10,180(sp)
81129204:	1128a100 	call	81128a10 <__ssprint_r>
81129208:	da402c17 	ldw	r9,176(sp)
8112920c:	da802d17 	ldw	r10,180(sp)
81129210:	1001851e 	bne	r2,zero,81129828 <___svfiprintf_internal_r+0xc40>
81129214:	e73ffc04 	addi	fp,fp,-16
81129218:	d8c01c17 	ldw	r3,112(sp)
8112921c:	d8801b17 	ldw	r2,108(sp)
81129220:	d811883a 	mov	r8,sp
81129224:	4f3feb16 	blt	r9,fp,811291d4 <__reset+0xfb1091d4>
81129228:	dac02817 	ldw	r11,160(sp)
8112922c:	e0c7883a 	add	r3,fp,r3
81129230:	10800044 	addi	r2,r2,1
81129234:	42c00015 	stw	r11,0(r8)
81129238:	47000115 	stw	fp,4(r8)
8112923c:	d8c01c15 	stw	r3,112(sp)
81129240:	d8801b15 	stw	r2,108(sp)
81129244:	010001c4 	movi	r4,7
81129248:	2081ee16 	blt	r4,r2,81129a04 <___svfiprintf_internal_r+0xe1c>
8112924c:	42000204 	addi	r8,r8,8
81129250:	0000e506 	br	811295e8 <___svfiprintf_internal_r+0xa00>
81129254:	21003fcc 	andi	r4,r4,255
81129258:	2002dd1e 	bne	r4,zero,81129dd0 <___svfiprintf_internal_r+0x11e8>
8112925c:	00a04534 	movhi	r2,33044
81129260:	10943a04 	addi	r2,r2,20712
81129264:	d8802915 	stw	r2,164(sp)
81129268:	9080080c 	andi	r2,r18,32
8112926c:	103f461e 	bne	r2,zero,81128f88 <__reset+0xfb108f88>
81129270:	9080040c 	andi	r2,r18,16
81129274:	10022e1e 	bne	r2,zero,81129b30 <___svfiprintf_internal_r+0xf48>
81129278:	9080100c 	andi	r2,r18,64
8112927c:	dac02317 	ldw	r11,140(sp)
81129280:	10027326 	beq	r2,zero,81129c50 <___svfiprintf_internal_r+0x1068>
81129284:	5f00000b 	ldhu	fp,0(r11)
81129288:	5ac00104 	addi	r11,r11,4
8112928c:	0013883a 	mov	r9,zero
81129290:	dac02315 	stw	r11,140(sp)
81129294:	003f4106 	br	81128f9c <__reset+0xfb108f9c>
81129298:	21003fcc 	andi	r4,r4,255
8112929c:	2002e11e 	bne	r4,zero,81129e24 <___svfiprintf_internal_r+0x123c>
811292a0:	9080080c 	andi	r2,r18,32
811292a4:	1002011e 	bne	r2,zero,81129aac <___svfiprintf_internal_r+0xec4>
811292a8:	9080040c 	andi	r2,r18,16
811292ac:	10023e1e 	bne	r2,zero,81129ba8 <___svfiprintf_internal_r+0xfc0>
811292b0:	9480100c 	andi	r18,r18,64
811292b4:	90023c26 	beq	r18,zero,81129ba8 <___svfiprintf_internal_r+0xfc0>
811292b8:	dac02317 	ldw	r11,140(sp)
811292bc:	58800017 	ldw	r2,0(r11)
811292c0:	5ac00104 	addi	r11,r11,4
811292c4:	dac02315 	stw	r11,140(sp)
811292c8:	dac02517 	ldw	r11,148(sp)
811292cc:	12c0000d 	sth	r11,0(r2)
811292d0:	003e6e06 	br	81128c8c <__reset+0xfb108c8c>
811292d4:	98c00007 	ldb	r3,0(r19)
811292d8:	1a422926 	beq	r3,r9,81129b80 <___svfiprintf_internal_r+0xf98>
811292dc:	94800414 	ori	r18,r18,16
811292e0:	003e9206 	br	81128d2c <__reset+0xfb108d2c>
811292e4:	94801014 	ori	r18,r18,64
811292e8:	98c00007 	ldb	r3,0(r19)
811292ec:	003e8f06 	br	81128d2c <__reset+0xfb108d2c>
811292f0:	21003fcc 	andi	r4,r4,255
811292f4:	2002c71e 	bne	r4,zero,81129e14 <___svfiprintf_internal_r+0x122c>
811292f8:	9080080c 	andi	r2,r18,32
811292fc:	10004926 	beq	r2,zero,81129424 <___svfiprintf_internal_r+0x83c>
81129300:	dac02317 	ldw	r11,140(sp)
81129304:	58800117 	ldw	r2,4(r11)
81129308:	5f000017 	ldw	fp,0(r11)
8112930c:	5ac00204 	addi	r11,r11,8
81129310:	dac02315 	stw	r11,140(sp)
81129314:	1013883a 	mov	r9,r2
81129318:	10004b16 	blt	r2,zero,81129448 <___svfiprintf_internal_r+0x860>
8112931c:	da801d83 	ldbu	r10,118(sp)
81129320:	8001cb16 	blt	r16,zero,81129a50 <___svfiprintf_internal_r+0xe68>
81129324:	00ffdfc4 	movi	r3,-129
81129328:	e244b03a 	or	r2,fp,r9
8112932c:	90e4703a 	and	r18,r18,r3
81129330:	103f4726 	beq	r2,zero,81129050 <__reset+0xfb109050>
81129334:	48008c26 	beq	r9,zero,81129568 <___svfiprintf_internal_r+0x980>
81129338:	dc802015 	stw	r18,128(sp)
8112933c:	dc002115 	stw	r16,132(sp)
81129340:	dc401a04 	addi	r17,sp,104
81129344:	e021883a 	mov	r16,fp
81129348:	da002215 	stw	r8,136(sp)
8112934c:	5039883a 	mov	fp,r10
81129350:	4825883a 	mov	r18,r9
81129354:	8009883a 	mov	r4,r16
81129358:	900b883a 	mov	r5,r18
8112935c:	01800284 	movi	r6,10
81129360:	000f883a 	mov	r7,zero
81129364:	112d2ac0 	call	8112d2ac <__umoddi3>
81129368:	10800c04 	addi	r2,r2,48
8112936c:	8c7fffc4 	addi	r17,r17,-1
81129370:	8009883a 	mov	r4,r16
81129374:	900b883a 	mov	r5,r18
81129378:	88800005 	stb	r2,0(r17)
8112937c:	01800284 	movi	r6,10
81129380:	000f883a 	mov	r7,zero
81129384:	112cd2c0 	call	8112cd2c <__udivdi3>
81129388:	1021883a 	mov	r16,r2
8112938c:	10c4b03a 	or	r2,r2,r3
81129390:	1825883a 	mov	r18,r3
81129394:	103fef1e 	bne	r2,zero,81129354 <__reset+0xfb109354>
81129398:	dc802017 	ldw	r18,128(sp)
8112939c:	dc002117 	ldw	r16,132(sp)
811293a0:	da002217 	ldw	r8,136(sp)
811293a4:	e015883a 	mov	r10,fp
811293a8:	d8c01e17 	ldw	r3,120(sp)
811293ac:	1c47c83a 	sub	r3,r3,r17
811293b0:	d8c02115 	stw	r3,132(sp)
811293b4:	003f2a06 	br	81129060 <__reset+0xfb109060>
811293b8:	dac02317 	ldw	r11,140(sp)
811293bc:	d8001d85 	stb	zero,118(sp)
811293c0:	5c400017 	ldw	r17,0(r11)
811293c4:	5f000104 	addi	fp,r11,4
811293c8:	88022f26 	beq	r17,zero,81129c88 <___svfiprintf_internal_r+0x10a0>
811293cc:	80022516 	blt	r16,zero,81129c64 <___svfiprintf_internal_r+0x107c>
811293d0:	800d883a 	mov	r6,r16
811293d4:	000b883a 	mov	r5,zero
811293d8:	8809883a 	mov	r4,r17
811293dc:	da002c15 	stw	r8,176(sp)
811293e0:	1124f5c0 	call	81124f5c <memchr>
811293e4:	da002c17 	ldw	r8,176(sp)
811293e8:	10026426 	beq	r2,zero,81129d7c <___svfiprintf_internal_r+0x1194>
811293ec:	1445c83a 	sub	r2,r2,r17
811293f0:	d8802115 	stw	r2,132(sp)
811293f4:	da801d83 	ldbu	r10,118(sp)
811293f8:	df002315 	stw	fp,140(sp)
811293fc:	0021883a 	mov	r16,zero
81129400:	003f1706 	br	81129060 <__reset+0xfb109060>
81129404:	94800814 	ori	r18,r18,32
81129408:	98c00007 	ldb	r3,0(r19)
8112940c:	003e4706 	br	81128d2c <__reset+0xfb108d2c>
81129410:	21003fcc 	andi	r4,r4,255
81129414:	2002701e 	bne	r4,zero,81129dd8 <___svfiprintf_internal_r+0x11f0>
81129418:	94800414 	ori	r18,r18,16
8112941c:	9080080c 	andi	r2,r18,32
81129420:	103fb71e 	bne	r2,zero,81129300 <__reset+0xfb109300>
81129424:	9080040c 	andi	r2,r18,16
81129428:	1001ab26 	beq	r2,zero,81129ad8 <___svfiprintf_internal_r+0xef0>
8112942c:	dac02317 	ldw	r11,140(sp)
81129430:	5f000017 	ldw	fp,0(r11)
81129434:	5ac00104 	addi	r11,r11,4
81129438:	dac02315 	stw	r11,140(sp)
8112943c:	e013d7fa 	srai	r9,fp,31
81129440:	4805883a 	mov	r2,r9
81129444:	103fb50e 	bge	r2,zero,8112931c <__reset+0xfb10931c>
81129448:	0739c83a 	sub	fp,zero,fp
8112944c:	02800b44 	movi	r10,45
81129450:	e004c03a 	cmpne	r2,fp,zero
81129454:	0253c83a 	sub	r9,zero,r9
81129458:	da801d85 	stb	r10,118(sp)
8112945c:	4893c83a 	sub	r9,r9,r2
81129460:	80023016 	blt	r16,zero,81129d24 <___svfiprintf_internal_r+0x113c>
81129464:	00bfdfc4 	movi	r2,-129
81129468:	90a4703a 	and	r18,r18,r2
8112946c:	483fb21e 	bne	r9,zero,81129338 <__reset+0xfb109338>
81129470:	00003d06 	br	81129568 <___svfiprintf_internal_r+0x980>
81129474:	9817883a 	mov	r11,r19
81129478:	d8002415 	stw	zero,144(sp)
8112947c:	18bff404 	addi	r2,r3,-48
81129480:	0019883a 	mov	r12,zero
81129484:	58c00007 	ldb	r3,0(r11)
81129488:	630002a4 	muli	r12,r12,10
8112948c:	9cc00044 	addi	r19,r19,1
81129490:	9817883a 	mov	r11,r19
81129494:	1319883a 	add	r12,r2,r12
81129498:	18bff404 	addi	r2,r3,-48
8112949c:	30bff92e 	bgeu	r6,r2,81129484 <__reset+0xfb109484>
811294a0:	db002415 	stw	r12,144(sp)
811294a4:	18bff804 	addi	r2,r3,-32
811294a8:	28be232e 	bgeu	r5,r2,81128d38 <__reset+0xfb108d38>
811294ac:	21003fcc 	andi	r4,r4,255
811294b0:	20024b1e 	bne	r4,zero,81129de0 <___svfiprintf_internal_r+0x11f8>
811294b4:	1800d626 	beq	r3,zero,81129810 <___svfiprintf_internal_r+0xc28>
811294b8:	02c00044 	movi	r11,1
811294bc:	dac02015 	stw	r11,128(sp)
811294c0:	d8c01005 	stb	r3,64(sp)
811294c4:	d8001d85 	stb	zero,118(sp)
811294c8:	dac02115 	stw	r11,132(sp)
811294cc:	dc401004 	addi	r17,sp,64
811294d0:	003f2606 	br	8112916c <__reset+0xfb10916c>
811294d4:	94802014 	ori	r18,r18,128
811294d8:	98c00007 	ldb	r3,0(r19)
811294dc:	003e1306 	br	81128d2c <__reset+0xfb108d2c>
811294e0:	98c00007 	ldb	r3,0(r19)
811294e4:	9ac00044 	addi	r11,r19,1
811294e8:	1a822b26 	beq	r3,r10,81129d98 <___svfiprintf_internal_r+0x11b0>
811294ec:	18bff404 	addi	r2,r3,-48
811294f0:	0021883a 	mov	r16,zero
811294f4:	30821e36 	bltu	r6,r2,81129d70 <___svfiprintf_internal_r+0x1188>
811294f8:	58c00007 	ldb	r3,0(r11)
811294fc:	840002a4 	muli	r16,r16,10
81129500:	5cc00044 	addi	r19,r11,1
81129504:	9817883a 	mov	r11,r19
81129508:	80a1883a 	add	r16,r16,r2
8112950c:	18bff404 	addi	r2,r3,-48
81129510:	30bff92e 	bgeu	r6,r2,811294f8 <__reset+0xfb1094f8>
81129514:	803e060e 	bge	r16,zero,81128d30 <__reset+0xfb108d30>
81129518:	043fffc4 	movi	r16,-1
8112951c:	003e0406 	br	81128d30 <__reset+0xfb108d30>
81129520:	21003fcc 	andi	r4,r4,255
81129524:	2002371e 	bne	r4,zero,81129e04 <___svfiprintf_internal_r+0x121c>
81129528:	94800414 	ori	r18,r18,16
8112952c:	9080080c 	andi	r2,r18,32
81129530:	103ebb1e 	bne	r2,zero,81129020 <__reset+0xfb109020>
81129534:	9080040c 	andi	r2,r18,16
81129538:	10013b26 	beq	r2,zero,81129a28 <___svfiprintf_internal_r+0xe40>
8112953c:	dac02317 	ldw	r11,140(sp)
81129540:	d8001d85 	stb	zero,118(sp)
81129544:	0013883a 	mov	r9,zero
81129548:	58800104 	addi	r2,r11,4
8112954c:	5f000017 	ldw	fp,0(r11)
81129550:	80013d16 	blt	r16,zero,81129a48 <___svfiprintf_internal_r+0xe60>
81129554:	00ffdfc4 	movi	r3,-129
81129558:	d8802315 	stw	r2,140(sp)
8112955c:	90e4703a 	and	r18,r18,r3
81129560:	0015883a 	mov	r10,zero
81129564:	e03eba26 	beq	fp,zero,81129050 <__reset+0xfb109050>
81129568:	00800244 	movi	r2,9
8112956c:	173f7236 	bltu	r2,fp,81129338 <__reset+0xfb109338>
81129570:	dac02b17 	ldw	r11,172(sp)
81129574:	e7000c04 	addi	fp,fp,48
81129578:	df0019c5 	stb	fp,103(sp)
8112957c:	dac02115 	stw	r11,132(sp)
81129580:	dc4019c4 	addi	r17,sp,103
81129584:	003eb606 	br	81129060 <__reset+0xfb109060>
81129588:	21003fcc 	andi	r4,r4,255
8112958c:	20021f1e 	bne	r4,zero,81129e0c <___svfiprintf_internal_r+0x1224>
81129590:	94800414 	ori	r18,r18,16
81129594:	9080080c 	andi	r2,r18,32
81129598:	103ec51e 	bne	r2,zero,811290b0 <__reset+0xfb1090b0>
8112959c:	9080040c 	andi	r2,r18,16
811295a0:	10016926 	beq	r2,zero,81129b48 <___svfiprintf_internal_r+0xf60>
811295a4:	dac02317 	ldw	r11,140(sp)
811295a8:	d8001d85 	stb	zero,118(sp)
811295ac:	0013883a 	mov	r9,zero
811295b0:	58800104 	addi	r2,r11,4
811295b4:	5f000017 	ldw	fp,0(r11)
811295b8:	80016b16 	blt	r16,zero,81129b68 <___svfiprintf_internal_r+0xf80>
811295bc:	00ffdfc4 	movi	r3,-129
811295c0:	d8802315 	stw	r2,140(sp)
811295c4:	90e4703a 	and	r18,r18,r3
811295c8:	e03ec41e 	bne	fp,zero,811290dc <__reset+0xfb1090dc>
811295cc:	0015883a 	mov	r10,zero
811295d0:	8001c226 	beq	r16,zero,81129cdc <___svfiprintf_internal_r+0x10f4>
811295d4:	0039883a 	mov	fp,zero
811295d8:	0013883a 	mov	r9,zero
811295dc:	003ec006 	br	811290e0 <__reset+0xfb1090e0>
811295e0:	d8c01c17 	ldw	r3,112(sp)
811295e4:	d8801b17 	ldw	r2,108(sp)
811295e8:	d9001d87 	ldb	r4,118(sp)
811295ec:	20000b26 	beq	r4,zero,8112961c <___svfiprintf_internal_r+0xa34>
811295f0:	d9001d84 	addi	r4,sp,118
811295f4:	18c00044 	addi	r3,r3,1
811295f8:	10800044 	addi	r2,r2,1
811295fc:	41000015 	stw	r4,0(r8)
81129600:	01000044 	movi	r4,1
81129604:	41000115 	stw	r4,4(r8)
81129608:	d8c01c15 	stw	r3,112(sp)
8112960c:	d8801b15 	stw	r2,108(sp)
81129610:	010001c4 	movi	r4,7
81129614:	2080e116 	blt	r4,r2,8112999c <___svfiprintf_internal_r+0xdb4>
81129618:	42000204 	addi	r8,r8,8
8112961c:	dac02217 	ldw	r11,136(sp)
81129620:	58000b26 	beq	r11,zero,81129650 <___svfiprintf_internal_r+0xa68>
81129624:	d9001d04 	addi	r4,sp,116
81129628:	18c00084 	addi	r3,r3,2
8112962c:	10800044 	addi	r2,r2,1
81129630:	41000015 	stw	r4,0(r8)
81129634:	01000084 	movi	r4,2
81129638:	41000115 	stw	r4,4(r8)
8112963c:	d8c01c15 	stw	r3,112(sp)
81129640:	d8801b15 	stw	r2,108(sp)
81129644:	010001c4 	movi	r4,7
81129648:	2080dd16 	blt	r4,r2,811299c0 <___svfiprintf_internal_r+0xdd8>
8112964c:	42000204 	addi	r8,r8,8
81129650:	dac02617 	ldw	r11,152(sp)
81129654:	01002004 	movi	r4,128
81129658:	59008426 	beq	r11,r4,8112986c <___svfiprintf_internal_r+0xc84>
8112965c:	dac02117 	ldw	r11,132(sp)
81129660:	82e1c83a 	sub	r16,r16,r11
81129664:	0400270e 	bge	zero,r16,81129704 <___svfiprintf_internal_r+0xb1c>
81129668:	01c00404 	movi	r7,16
8112966c:	3c016a0e 	bge	r7,r16,81129c18 <___svfiprintf_internal_r+0x1030>
81129670:	01604534 	movhi	r5,33044
81129674:	2954ca04 	addi	r5,r5,21288
81129678:	d9402215 	stw	r5,136(sp)
8112967c:	070001c4 	movi	fp,7
81129680:	00000306 	br	81129690 <___svfiprintf_internal_r+0xaa8>
81129684:	843ffc04 	addi	r16,r16,-16
81129688:	42000204 	addi	r8,r8,8
8112968c:	3c00130e 	bge	r7,r16,811296dc <___svfiprintf_internal_r+0xaf4>
81129690:	18c00404 	addi	r3,r3,16
81129694:	10800044 	addi	r2,r2,1
81129698:	45000015 	stw	r20,0(r8)
8112969c:	41c00115 	stw	r7,4(r8)
811296a0:	d8c01c15 	stw	r3,112(sp)
811296a4:	d8801b15 	stw	r2,108(sp)
811296a8:	e0bff60e 	bge	fp,r2,81129684 <__reset+0xfb109684>
811296ac:	d9801a04 	addi	r6,sp,104
811296b0:	b80b883a 	mov	r5,r23
811296b4:	a809883a 	mov	r4,r21
811296b8:	d9c02c15 	stw	r7,176(sp)
811296bc:	1128a100 	call	81128a10 <__ssprint_r>
811296c0:	d9c02c17 	ldw	r7,176(sp)
811296c4:	1000581e 	bne	r2,zero,81129828 <___svfiprintf_internal_r+0xc40>
811296c8:	843ffc04 	addi	r16,r16,-16
811296cc:	d8c01c17 	ldw	r3,112(sp)
811296d0:	d8801b17 	ldw	r2,108(sp)
811296d4:	d811883a 	mov	r8,sp
811296d8:	3c3fed16 	blt	r7,r16,81129690 <__reset+0xfb109690>
811296dc:	dac02217 	ldw	r11,136(sp)
811296e0:	1c07883a 	add	r3,r3,r16
811296e4:	10800044 	addi	r2,r2,1
811296e8:	42c00015 	stw	r11,0(r8)
811296ec:	44000115 	stw	r16,4(r8)
811296f0:	d8c01c15 	stw	r3,112(sp)
811296f4:	d8801b15 	stw	r2,108(sp)
811296f8:	010001c4 	movi	r4,7
811296fc:	20809e16 	blt	r4,r2,81129978 <___svfiprintf_internal_r+0xd90>
81129700:	42000204 	addi	r8,r8,8
81129704:	dac02117 	ldw	r11,132(sp)
81129708:	10800044 	addi	r2,r2,1
8112970c:	44400015 	stw	r17,0(r8)
81129710:	58c7883a 	add	r3,r11,r3
81129714:	42c00115 	stw	r11,4(r8)
81129718:	d8c01c15 	stw	r3,112(sp)
8112971c:	d8801b15 	stw	r2,108(sp)
81129720:	010001c4 	movi	r4,7
81129724:	20807f16 	blt	r4,r2,81129924 <___svfiprintf_internal_r+0xd3c>
81129728:	42000204 	addi	r8,r8,8
8112972c:	9480010c 	andi	r18,r18,4
81129730:	90002926 	beq	r18,zero,811297d8 <___svfiprintf_internal_r+0xbf0>
81129734:	dac02417 	ldw	r11,144(sp)
81129738:	d8802017 	ldw	r2,128(sp)
8112973c:	58a1c83a 	sub	r16,r11,r2
81129740:	0400250e 	bge	zero,r16,811297d8 <___svfiprintf_internal_r+0xbf0>
81129744:	04400404 	movi	r17,16
81129748:	d8801b17 	ldw	r2,108(sp)
8112974c:	8c017c0e 	bge	r17,r16,81129d40 <___svfiprintf_internal_r+0x1158>
81129750:	01604534 	movhi	r5,33044
81129754:	2954ce04 	addi	r5,r5,21304
81129758:	d9402815 	stw	r5,160(sp)
8112975c:	048001c4 	movi	r18,7
81129760:	00000306 	br	81129770 <___svfiprintf_internal_r+0xb88>
81129764:	843ffc04 	addi	r16,r16,-16
81129768:	42000204 	addi	r8,r8,8
8112976c:	8c00110e 	bge	r17,r16,811297b4 <___svfiprintf_internal_r+0xbcc>
81129770:	18c00404 	addi	r3,r3,16
81129774:	10800044 	addi	r2,r2,1
81129778:	45800015 	stw	r22,0(r8)
8112977c:	44400115 	stw	r17,4(r8)
81129780:	d8c01c15 	stw	r3,112(sp)
81129784:	d8801b15 	stw	r2,108(sp)
81129788:	90bff60e 	bge	r18,r2,81129764 <__reset+0xfb109764>
8112978c:	d9801a04 	addi	r6,sp,104
81129790:	b80b883a 	mov	r5,r23
81129794:	a809883a 	mov	r4,r21
81129798:	1128a100 	call	81128a10 <__ssprint_r>
8112979c:	1000221e 	bne	r2,zero,81129828 <___svfiprintf_internal_r+0xc40>
811297a0:	843ffc04 	addi	r16,r16,-16
811297a4:	d8c01c17 	ldw	r3,112(sp)
811297a8:	d8801b17 	ldw	r2,108(sp)
811297ac:	d811883a 	mov	r8,sp
811297b0:	8c3fef16 	blt	r17,r16,81129770 <__reset+0xfb109770>
811297b4:	dac02817 	ldw	r11,160(sp)
811297b8:	1c07883a 	add	r3,r3,r16
811297bc:	10800044 	addi	r2,r2,1
811297c0:	42c00015 	stw	r11,0(r8)
811297c4:	44000115 	stw	r16,4(r8)
811297c8:	d8c01c15 	stw	r3,112(sp)
811297cc:	d8801b15 	stw	r2,108(sp)
811297d0:	010001c4 	movi	r4,7
811297d4:	2080aa16 	blt	r4,r2,81129a80 <___svfiprintf_internal_r+0xe98>
811297d8:	d8802417 	ldw	r2,144(sp)
811297dc:	dac02017 	ldw	r11,128(sp)
811297e0:	12c0010e 	bge	r2,r11,811297e8 <___svfiprintf_internal_r+0xc00>
811297e4:	5805883a 	mov	r2,r11
811297e8:	dac02517 	ldw	r11,148(sp)
811297ec:	5897883a 	add	r11,r11,r2
811297f0:	dac02515 	stw	r11,148(sp)
811297f4:	1800531e 	bne	r3,zero,81129944 <___svfiprintf_internal_r+0xd5c>
811297f8:	98800007 	ldb	r2,0(r19)
811297fc:	d8001b15 	stw	zero,108(sp)
81129800:	d811883a 	mov	r8,sp
81129804:	103d231e 	bne	r2,zero,81128c94 <__reset+0xfb108c94>
81129808:	9823883a 	mov	r17,r19
8112980c:	003d3906 	br	81128cf4 <__reset+0xfb108cf4>
81129810:	d8801c17 	ldw	r2,112(sp)
81129814:	10000426 	beq	r2,zero,81129828 <___svfiprintf_internal_r+0xc40>
81129818:	d9402717 	ldw	r5,156(sp)
8112981c:	d9002a17 	ldw	r4,168(sp)
81129820:	d9801a04 	addi	r6,sp,104
81129824:	1128a100 	call	81128a10 <__ssprint_r>
81129828:	dac02717 	ldw	r11,156(sp)
8112982c:	d8802517 	ldw	r2,148(sp)
81129830:	58c0030b 	ldhu	r3,12(r11)
81129834:	18c0100c 	andi	r3,r3,64
81129838:	1801381e 	bne	r3,zero,81129d1c <___svfiprintf_internal_r+0x1134>
8112983c:	dfc03717 	ldw	ra,220(sp)
81129840:	df003617 	ldw	fp,216(sp)
81129844:	ddc03517 	ldw	r23,212(sp)
81129848:	dd803417 	ldw	r22,208(sp)
8112984c:	dd403317 	ldw	r21,204(sp)
81129850:	dd003217 	ldw	r20,200(sp)
81129854:	dcc03117 	ldw	r19,196(sp)
81129858:	dc803017 	ldw	r18,192(sp)
8112985c:	dc402f17 	ldw	r17,188(sp)
81129860:	dc002e17 	ldw	r16,184(sp)
81129864:	dec03804 	addi	sp,sp,224
81129868:	f800283a 	ret
8112986c:	dac02417 	ldw	r11,144(sp)
81129870:	d9002017 	ldw	r4,128(sp)
81129874:	5939c83a 	sub	fp,r11,r4
81129878:	073f780e 	bge	zero,fp,8112965c <__reset+0xfb10965c>
8112987c:	02400404 	movi	r9,16
81129880:	4f01370e 	bge	r9,fp,81129d60 <___svfiprintf_internal_r+0x1178>
81129884:	02e04534 	movhi	r11,33044
81129888:	5ad4ca04 	addi	r11,r11,21288
8112988c:	dac02215 	stw	r11,136(sp)
81129890:	028001c4 	movi	r10,7
81129894:	00000306 	br	811298a4 <___svfiprintf_internal_r+0xcbc>
81129898:	e73ffc04 	addi	fp,fp,-16
8112989c:	42000204 	addi	r8,r8,8
811298a0:	4f00150e 	bge	r9,fp,811298f8 <___svfiprintf_internal_r+0xd10>
811298a4:	18c00404 	addi	r3,r3,16
811298a8:	10800044 	addi	r2,r2,1
811298ac:	45000015 	stw	r20,0(r8)
811298b0:	42400115 	stw	r9,4(r8)
811298b4:	d8c01c15 	stw	r3,112(sp)
811298b8:	d8801b15 	stw	r2,108(sp)
811298bc:	50bff60e 	bge	r10,r2,81129898 <__reset+0xfb109898>
811298c0:	d9801a04 	addi	r6,sp,104
811298c4:	b80b883a 	mov	r5,r23
811298c8:	a809883a 	mov	r4,r21
811298cc:	da402c15 	stw	r9,176(sp)
811298d0:	da802d15 	stw	r10,180(sp)
811298d4:	1128a100 	call	81128a10 <__ssprint_r>
811298d8:	da402c17 	ldw	r9,176(sp)
811298dc:	da802d17 	ldw	r10,180(sp)
811298e0:	103fd11e 	bne	r2,zero,81129828 <__reset+0xfb109828>
811298e4:	e73ffc04 	addi	fp,fp,-16
811298e8:	d8c01c17 	ldw	r3,112(sp)
811298ec:	d8801b17 	ldw	r2,108(sp)
811298f0:	d811883a 	mov	r8,sp
811298f4:	4f3feb16 	blt	r9,fp,811298a4 <__reset+0xfb1098a4>
811298f8:	dac02217 	ldw	r11,136(sp)
811298fc:	1f07883a 	add	r3,r3,fp
81129900:	10800044 	addi	r2,r2,1
81129904:	42c00015 	stw	r11,0(r8)
81129908:	47000115 	stw	fp,4(r8)
8112990c:	d8c01c15 	stw	r3,112(sp)
81129910:	d8801b15 	stw	r2,108(sp)
81129914:	010001c4 	movi	r4,7
81129918:	2080b616 	blt	r4,r2,81129bf4 <___svfiprintf_internal_r+0x100c>
8112991c:	42000204 	addi	r8,r8,8
81129920:	003f4e06 	br	8112965c <__reset+0xfb10965c>
81129924:	d9801a04 	addi	r6,sp,104
81129928:	b80b883a 	mov	r5,r23
8112992c:	a809883a 	mov	r4,r21
81129930:	1128a100 	call	81128a10 <__ssprint_r>
81129934:	103fbc1e 	bne	r2,zero,81129828 <__reset+0xfb109828>
81129938:	d8c01c17 	ldw	r3,112(sp)
8112993c:	d811883a 	mov	r8,sp
81129940:	003f7a06 	br	8112972c <__reset+0xfb10972c>
81129944:	d9801a04 	addi	r6,sp,104
81129948:	b80b883a 	mov	r5,r23
8112994c:	a809883a 	mov	r4,r21
81129950:	1128a100 	call	81128a10 <__ssprint_r>
81129954:	103fa826 	beq	r2,zero,811297f8 <__reset+0xfb1097f8>
81129958:	003fb306 	br	81129828 <__reset+0xfb109828>
8112995c:	d9801a04 	addi	r6,sp,104
81129960:	b80b883a 	mov	r5,r23
81129964:	a809883a 	mov	r4,r21
81129968:	1128a100 	call	81128a10 <__ssprint_r>
8112996c:	103fae1e 	bne	r2,zero,81129828 <__reset+0xfb109828>
81129970:	d811883a 	mov	r8,sp
81129974:	003cdc06 	br	81128ce8 <__reset+0xfb108ce8>
81129978:	d9801a04 	addi	r6,sp,104
8112997c:	b80b883a 	mov	r5,r23
81129980:	a809883a 	mov	r4,r21
81129984:	1128a100 	call	81128a10 <__ssprint_r>
81129988:	103fa71e 	bne	r2,zero,81129828 <__reset+0xfb109828>
8112998c:	d8c01c17 	ldw	r3,112(sp)
81129990:	d8801b17 	ldw	r2,108(sp)
81129994:	d811883a 	mov	r8,sp
81129998:	003f5a06 	br	81129704 <__reset+0xfb109704>
8112999c:	d9801a04 	addi	r6,sp,104
811299a0:	b80b883a 	mov	r5,r23
811299a4:	a809883a 	mov	r4,r21
811299a8:	1128a100 	call	81128a10 <__ssprint_r>
811299ac:	103f9e1e 	bne	r2,zero,81129828 <__reset+0xfb109828>
811299b0:	d8c01c17 	ldw	r3,112(sp)
811299b4:	d8801b17 	ldw	r2,108(sp)
811299b8:	d811883a 	mov	r8,sp
811299bc:	003f1706 	br	8112961c <__reset+0xfb10961c>
811299c0:	d9801a04 	addi	r6,sp,104
811299c4:	b80b883a 	mov	r5,r23
811299c8:	a809883a 	mov	r4,r21
811299cc:	1128a100 	call	81128a10 <__ssprint_r>
811299d0:	103f951e 	bne	r2,zero,81129828 <__reset+0xfb109828>
811299d4:	d8c01c17 	ldw	r3,112(sp)
811299d8:	d8801b17 	ldw	r2,108(sp)
811299dc:	d811883a 	mov	r8,sp
811299e0:	003f1b06 	br	81129650 <__reset+0xfb109650>
811299e4:	d8001d85 	stb	zero,118(sp)
811299e8:	80007b16 	blt	r16,zero,81129bd8 <___svfiprintf_internal_r+0xff0>
811299ec:	00ffdfc4 	movi	r3,-129
811299f0:	e244b03a 	or	r2,fp,r9
811299f4:	90e4703a 	and	r18,r18,r3
811299f8:	103d7026 	beq	r2,zero,81128fbc <__reset+0xfb108fbc>
811299fc:	0015883a 	mov	r10,zero
81129a00:	003d7206 	br	81128fcc <__reset+0xfb108fcc>
81129a04:	d9801a04 	addi	r6,sp,104
81129a08:	b80b883a 	mov	r5,r23
81129a0c:	a809883a 	mov	r4,r21
81129a10:	1128a100 	call	81128a10 <__ssprint_r>
81129a14:	103f841e 	bne	r2,zero,81129828 <__reset+0xfb109828>
81129a18:	d8c01c17 	ldw	r3,112(sp)
81129a1c:	d8801b17 	ldw	r2,108(sp)
81129a20:	d811883a 	mov	r8,sp
81129a24:	003ef006 	br	811295e8 <__reset+0xfb1095e8>
81129a28:	9080100c 	andi	r2,r18,64
81129a2c:	d8001d85 	stb	zero,118(sp)
81129a30:	dac02317 	ldw	r11,140(sp)
81129a34:	10008126 	beq	r2,zero,81129c3c <___svfiprintf_internal_r+0x1054>
81129a38:	58800104 	addi	r2,r11,4
81129a3c:	5f00000b 	ldhu	fp,0(r11)
81129a40:	0013883a 	mov	r9,zero
81129a44:	803ec30e 	bge	r16,zero,81129554 <__reset+0xfb109554>
81129a48:	d8802315 	stw	r2,140(sp)
81129a4c:	0015883a 	mov	r10,zero
81129a50:	e244b03a 	or	r2,fp,r9
81129a54:	103e371e 	bne	r2,zero,81129334 <__reset+0xfb109334>
81129a58:	00800044 	movi	r2,1
81129a5c:	10803fcc 	andi	r2,r2,255
81129a60:	00c00044 	movi	r3,1
81129a64:	10c06126 	beq	r2,r3,81129bec <___svfiprintf_internal_r+0x1004>
81129a68:	00c00084 	movi	r3,2
81129a6c:	10fd5526 	beq	r2,r3,81128fc4 <__reset+0xfb108fc4>
81129a70:	003ed806 	br	811295d4 <__reset+0xfb1095d4>
81129a74:	d8802315 	stw	r2,140(sp)
81129a78:	98c00007 	ldb	r3,0(r19)
81129a7c:	003cab06 	br	81128d2c <__reset+0xfb108d2c>
81129a80:	d9801a04 	addi	r6,sp,104
81129a84:	b80b883a 	mov	r5,r23
81129a88:	a809883a 	mov	r4,r21
81129a8c:	1128a100 	call	81128a10 <__ssprint_r>
81129a90:	103f651e 	bne	r2,zero,81129828 <__reset+0xfb109828>
81129a94:	d8c01c17 	ldw	r3,112(sp)
81129a98:	003f4f06 	br	811297d8 <__reset+0xfb1097d8>
81129a9c:	00a04534 	movhi	r2,33044
81129aa0:	10943f04 	addi	r2,r2,20732
81129aa4:	d8802915 	stw	r2,164(sp)
81129aa8:	003d4406 	br	81128fbc <__reset+0xfb108fbc>
81129aac:	dac02317 	ldw	r11,140(sp)
81129ab0:	58800017 	ldw	r2,0(r11)
81129ab4:	dac02517 	ldw	r11,148(sp)
81129ab8:	5807d7fa 	srai	r3,r11,31
81129abc:	dac02317 	ldw	r11,140(sp)
81129ac0:	10c00115 	stw	r3,4(r2)
81129ac4:	5ac00104 	addi	r11,r11,4
81129ac8:	dac02315 	stw	r11,140(sp)
81129acc:	dac02517 	ldw	r11,148(sp)
81129ad0:	12c00015 	stw	r11,0(r2)
81129ad4:	003c6d06 	br	81128c8c <__reset+0xfb108c8c>
81129ad8:	9080100c 	andi	r2,r18,64
81129adc:	dac02317 	ldw	r11,140(sp)
81129ae0:	103e5326 	beq	r2,zero,81129430 <__reset+0xfb109430>
81129ae4:	5f00000f 	ldh	fp,0(r11)
81129ae8:	5ac00104 	addi	r11,r11,4
81129aec:	dac02315 	stw	r11,140(sp)
81129af0:	e013d7fa 	srai	r9,fp,31
81129af4:	4805883a 	mov	r2,r9
81129af8:	003e0706 	br	81129318 <__reset+0xfb109318>
81129afc:	00800c04 	movi	r2,48
81129b00:	d8801d05 	stb	r2,116(sp)
81129b04:	d8c01d45 	stb	r3,117(sp)
81129b08:	d8001d85 	stb	zero,118(sp)
81129b0c:	90800094 	ori	r2,r18,2
81129b10:	80008f16 	blt	r16,zero,81129d50 <___svfiprintf_internal_r+0x1168>
81129b14:	00bfdfc4 	movi	r2,-129
81129b18:	90a4703a 	and	r18,r18,r2
81129b1c:	94800094 	ori	r18,r18,2
81129b20:	0015883a 	mov	r10,zero
81129b24:	003d2906 	br	81128fcc <__reset+0xfb108fcc>
81129b28:	98c00007 	ldb	r3,0(r19)
81129b2c:	003c7f06 	br	81128d2c <__reset+0xfb108d2c>
81129b30:	dac02317 	ldw	r11,140(sp)
81129b34:	0013883a 	mov	r9,zero
81129b38:	5f000017 	ldw	fp,0(r11)
81129b3c:	5ac00104 	addi	r11,r11,4
81129b40:	dac02315 	stw	r11,140(sp)
81129b44:	003d1506 	br	81128f9c <__reset+0xfb108f9c>
81129b48:	9080100c 	andi	r2,r18,64
81129b4c:	d8001d85 	stb	zero,118(sp)
81129b50:	dac02317 	ldw	r11,140(sp)
81129b54:	10003426 	beq	r2,zero,81129c28 <___svfiprintf_internal_r+0x1040>
81129b58:	58800104 	addi	r2,r11,4
81129b5c:	5f00000b 	ldhu	fp,0(r11)
81129b60:	0013883a 	mov	r9,zero
81129b64:	803e950e 	bge	r16,zero,811295bc <__reset+0xfb1095bc>
81129b68:	e246b03a 	or	r3,fp,r9
81129b6c:	d8802315 	stw	r2,140(sp)
81129b70:	183d5a1e 	bne	r3,zero,811290dc <__reset+0xfb1090dc>
81129b74:	0015883a 	mov	r10,zero
81129b78:	0005883a 	mov	r2,zero
81129b7c:	003fb706 	br	81129a5c <__reset+0xfb109a5c>
81129b80:	98c00043 	ldbu	r3,1(r19)
81129b84:	94800814 	ori	r18,r18,32
81129b88:	9cc00044 	addi	r19,r19,1
81129b8c:	18c03fcc 	andi	r3,r3,255
81129b90:	18c0201c 	xori	r3,r3,128
81129b94:	18ffe004 	addi	r3,r3,-128
81129b98:	003c6406 	br	81128d2c <__reset+0xfb108d2c>
81129b9c:	d8c02315 	stw	r3,140(sp)
81129ba0:	0015883a 	mov	r10,zero
81129ba4:	003faa06 	br	81129a50 <__reset+0xfb109a50>
81129ba8:	dac02317 	ldw	r11,140(sp)
81129bac:	58800017 	ldw	r2,0(r11)
81129bb0:	5ac00104 	addi	r11,r11,4
81129bb4:	dac02315 	stw	r11,140(sp)
81129bb8:	dac02517 	ldw	r11,148(sp)
81129bbc:	12c00015 	stw	r11,0(r2)
81129bc0:	003c3206 	br	81128c8c <__reset+0xfb108c8c>
81129bc4:	01204534 	movhi	r4,33044
81129bc8:	21143f04 	addi	r4,r4,20732
81129bcc:	d9002915 	stw	r4,164(sp)
81129bd0:	d8c02315 	stw	r3,140(sp)
81129bd4:	1025883a 	mov	r18,r2
81129bd8:	e244b03a 	or	r2,fp,r9
81129bdc:	103f871e 	bne	r2,zero,811299fc <__reset+0xfb1099fc>
81129be0:	0015883a 	mov	r10,zero
81129be4:	00800084 	movi	r2,2
81129be8:	003f9c06 	br	81129a5c <__reset+0xfb109a5c>
81129bec:	0039883a 	mov	fp,zero
81129bf0:	003e5f06 	br	81129570 <__reset+0xfb109570>
81129bf4:	d9801a04 	addi	r6,sp,104
81129bf8:	b80b883a 	mov	r5,r23
81129bfc:	a809883a 	mov	r4,r21
81129c00:	1128a100 	call	81128a10 <__ssprint_r>
81129c04:	103f081e 	bne	r2,zero,81129828 <__reset+0xfb109828>
81129c08:	d8c01c17 	ldw	r3,112(sp)
81129c0c:	d8801b17 	ldw	r2,108(sp)
81129c10:	d811883a 	mov	r8,sp
81129c14:	003e9106 	br	8112965c <__reset+0xfb10965c>
81129c18:	01204534 	movhi	r4,33044
81129c1c:	2114ca04 	addi	r4,r4,21288
81129c20:	d9002215 	stw	r4,136(sp)
81129c24:	003ead06 	br	811296dc <__reset+0xfb1096dc>
81129c28:	58800104 	addi	r2,r11,4
81129c2c:	5f000017 	ldw	fp,0(r11)
81129c30:	0013883a 	mov	r9,zero
81129c34:	803e610e 	bge	r16,zero,811295bc <__reset+0xfb1095bc>
81129c38:	003fcb06 	br	81129b68 <__reset+0xfb109b68>
81129c3c:	58800104 	addi	r2,r11,4
81129c40:	5f000017 	ldw	fp,0(r11)
81129c44:	0013883a 	mov	r9,zero
81129c48:	803e420e 	bge	r16,zero,81129554 <__reset+0xfb109554>
81129c4c:	003f7e06 	br	81129a48 <__reset+0xfb109a48>
81129c50:	5f000017 	ldw	fp,0(r11)
81129c54:	5ac00104 	addi	r11,r11,4
81129c58:	0013883a 	mov	r9,zero
81129c5c:	dac02315 	stw	r11,140(sp)
81129c60:	003cce06 	br	81128f9c <__reset+0xfb108f9c>
81129c64:	8809883a 	mov	r4,r17
81129c68:	da002c15 	stw	r8,176(sp)
81129c6c:	111b1180 	call	8111b118 <strlen>
81129c70:	d8802115 	stw	r2,132(sp)
81129c74:	da801d83 	ldbu	r10,118(sp)
81129c78:	df002315 	stw	fp,140(sp)
81129c7c:	0021883a 	mov	r16,zero
81129c80:	da002c17 	ldw	r8,176(sp)
81129c84:	003cf606 	br	81129060 <__reset+0xfb109060>
81129c88:	00800184 	movi	r2,6
81129c8c:	1400012e 	bgeu	r2,r16,81129c94 <___svfiprintf_internal_r+0x10ac>
81129c90:	1021883a 	mov	r16,r2
81129c94:	dc002115 	stw	r16,132(sp)
81129c98:	8005883a 	mov	r2,r16
81129c9c:	80003c16 	blt	r16,zero,81129d90 <___svfiprintf_internal_r+0x11a8>
81129ca0:	04604534 	movhi	r17,33044
81129ca4:	d8802015 	stw	r2,128(sp)
81129ca8:	df002315 	stw	fp,140(sp)
81129cac:	8c544404 	addi	r17,r17,20752
81129cb0:	003d2e06 	br	8112916c <__reset+0xfb10916c>
81129cb4:	04001004 	movi	r16,64
81129cb8:	800b883a 	mov	r5,r16
81129cbc:	11245040 	call	81124504 <_malloc_r>
81129cc0:	dac02717 	ldw	r11,156(sp)
81129cc4:	58800015 	stw	r2,0(r11)
81129cc8:	58800415 	stw	r2,16(r11)
81129ccc:	10004826 	beq	r2,zero,81129df0 <___svfiprintf_internal_r+0x1208>
81129cd0:	dac02717 	ldw	r11,156(sp)
81129cd4:	5c000515 	stw	r16,20(r11)
81129cd8:	003bd906 	br	81128c40 <__reset+0xfb108c40>
81129cdc:	9080004c 	andi	r2,r18,1
81129ce0:	0015883a 	mov	r10,zero
81129ce4:	10000626 	beq	r2,zero,81129d00 <___svfiprintf_internal_r+0x1118>
81129ce8:	dac02b17 	ldw	r11,172(sp)
81129cec:	00800c04 	movi	r2,48
81129cf0:	d88019c5 	stb	r2,103(sp)
81129cf4:	dac02115 	stw	r11,132(sp)
81129cf8:	dc4019c4 	addi	r17,sp,103
81129cfc:	003cd806 	br	81129060 <__reset+0xfb109060>
81129d00:	d8002115 	stw	zero,132(sp)
81129d04:	dc401a04 	addi	r17,sp,104
81129d08:	003cd506 	br	81129060 <__reset+0xfb109060>
81129d0c:	01204534 	movhi	r4,33044
81129d10:	2114ce04 	addi	r4,r4,21304
81129d14:	d9002815 	stw	r4,160(sp)
81129d18:	003d4306 	br	81129228 <__reset+0xfb109228>
81129d1c:	00bfffc4 	movi	r2,-1
81129d20:	003ec606 	br	8112983c <__reset+0xfb10983c>
81129d24:	00800044 	movi	r2,1
81129d28:	10803fcc 	andi	r2,r2,255
81129d2c:	00c00044 	movi	r3,1
81129d30:	10fd8026 	beq	r2,r3,81129334 <__reset+0xfb109334>
81129d34:	00c00084 	movi	r3,2
81129d38:	10fca426 	beq	r2,r3,81128fcc <__reset+0xfb108fcc>
81129d3c:	003ce806 	br	811290e0 <__reset+0xfb1090e0>
81129d40:	01204534 	movhi	r4,33044
81129d44:	2114ce04 	addi	r4,r4,21304
81129d48:	d9002815 	stw	r4,160(sp)
81129d4c:	003e9906 	br	811297b4 <__reset+0xfb1097b4>
81129d50:	1025883a 	mov	r18,r2
81129d54:	0015883a 	mov	r10,zero
81129d58:	00800084 	movi	r2,2
81129d5c:	003ff206 	br	81129d28 <__reset+0xfb109d28>
81129d60:	01604534 	movhi	r5,33044
81129d64:	2954ca04 	addi	r5,r5,21288
81129d68:	d9402215 	stw	r5,136(sp)
81129d6c:	003ee206 	br	811298f8 <__reset+0xfb1098f8>
81129d70:	5827883a 	mov	r19,r11
81129d74:	0021883a 	mov	r16,zero
81129d78:	003bed06 	br	81128d30 <__reset+0xfb108d30>
81129d7c:	dc002115 	stw	r16,132(sp)
81129d80:	da801d83 	ldbu	r10,118(sp)
81129d84:	df002315 	stw	fp,140(sp)
81129d88:	0021883a 	mov	r16,zero
81129d8c:	003cb406 	br	81129060 <__reset+0xfb109060>
81129d90:	0005883a 	mov	r2,zero
81129d94:	003fc206 	br	81129ca0 <__reset+0xfb109ca0>
81129d98:	d8802317 	ldw	r2,140(sp)
81129d9c:	98c00043 	ldbu	r3,1(r19)
81129da0:	5827883a 	mov	r19,r11
81129da4:	14000017 	ldw	r16,0(r2)
81129da8:	10800104 	addi	r2,r2,4
81129dac:	d8802315 	stw	r2,140(sp)
81129db0:	803f760e 	bge	r16,zero,81129b8c <__reset+0xfb109b8c>
81129db4:	18c03fcc 	andi	r3,r3,255
81129db8:	18c0201c 	xori	r3,r3,128
81129dbc:	043fffc4 	movi	r16,-1
81129dc0:	18ffe004 	addi	r3,r3,-128
81129dc4:	003bd906 	br	81128d2c <__reset+0xfb108d2c>
81129dc8:	d9c01d85 	stb	r7,118(sp)
81129dcc:	003cb606 	br	811290a8 <__reset+0xfb1090a8>
81129dd0:	d9c01d85 	stb	r7,118(sp)
81129dd4:	003d2106 	br	8112925c <__reset+0xfb10925c>
81129dd8:	d9c01d85 	stb	r7,118(sp)
81129ddc:	003d8e06 	br	81129418 <__reset+0xfb109418>
81129de0:	d9c01d85 	stb	r7,118(sp)
81129de4:	003db306 	br	811294b4 <__reset+0xfb1094b4>
81129de8:	d9c01d85 	stb	r7,118(sp)
81129dec:	003c8a06 	br	81129018 <__reset+0xfb109018>
81129df0:	dac02a17 	ldw	r11,168(sp)
81129df4:	00800304 	movi	r2,12
81129df8:	58800015 	stw	r2,0(r11)
81129dfc:	00bfffc4 	movi	r2,-1
81129e00:	003e8e06 	br	8112983c <__reset+0xfb10983c>
81129e04:	d9c01d85 	stb	r7,118(sp)
81129e08:	003dc706 	br	81129528 <__reset+0xfb109528>
81129e0c:	d9c01d85 	stb	r7,118(sp)
81129e10:	003ddf06 	br	81129590 <__reset+0xfb109590>
81129e14:	d9c01d85 	stb	r7,118(sp)
81129e18:	003d3706 	br	811292f8 <__reset+0xfb1092f8>
81129e1c:	d9c01d85 	stb	r7,118(sp)
81129e20:	003c5406 	br	81128f74 <__reset+0xfb108f74>
81129e24:	d9c01d85 	stb	r7,118(sp)
81129e28:	003d1d06 	br	811292a0 <__reset+0xfb1092a0>

81129e2c <__submore>:
81129e2c:	defffa04 	addi	sp,sp,-24
81129e30:	de00012e 	bgeu	sp,et,81129e38 <__submore+0xc>
81129e34:	003b68fa 	trap	3
81129e38:	dc000015 	stw	r16,0(sp)
81129e3c:	2821883a 	mov	r16,r5
81129e40:	29400c17 	ldw	r5,48(r5)
81129e44:	dfc00515 	stw	ra,20(sp)
81129e48:	dd000415 	stw	r20,16(sp)
81129e4c:	dcc00315 	stw	r19,12(sp)
81129e50:	dc800215 	stw	r18,8(sp)
81129e54:	dc400115 	stw	r17,4(sp)
81129e58:	80801004 	addi	r2,r16,64
81129e5c:	28801726 	beq	r5,r2,81129ebc <__submore+0x90>
81129e60:	84400d17 	ldw	r17,52(r16)
81129e64:	8c67883a 	add	r19,r17,r17
81129e68:	980d883a 	mov	r6,r19
81129e6c:	11261f80 	call	811261f8 <_realloc_r>
81129e70:	1025883a 	mov	r18,r2
81129e74:	10002226 	beq	r2,zero,81129f00 <__submore+0xd4>
81129e78:	1469883a 	add	r20,r2,r17
81129e7c:	880d883a 	mov	r6,r17
81129e80:	100b883a 	mov	r5,r2
81129e84:	a009883a 	mov	r4,r20
81129e88:	111abac0 	call	8111abac <memcpy>
81129e8c:	0005883a 	mov	r2,zero
81129e90:	85000015 	stw	r20,0(r16)
81129e94:	84800c15 	stw	r18,48(r16)
81129e98:	84c00d15 	stw	r19,52(r16)
81129e9c:	dfc00517 	ldw	ra,20(sp)
81129ea0:	dd000417 	ldw	r20,16(sp)
81129ea4:	dcc00317 	ldw	r19,12(sp)
81129ea8:	dc800217 	ldw	r18,8(sp)
81129eac:	dc400117 	ldw	r17,4(sp)
81129eb0:	dc000017 	ldw	r16,0(sp)
81129eb4:	dec00604 	addi	sp,sp,24
81129eb8:	f800283a 	ret
81129ebc:	04410004 	movi	r17,1024
81129ec0:	880b883a 	mov	r5,r17
81129ec4:	11245040 	call	81124504 <_malloc_r>
81129ec8:	1007883a 	mov	r3,r2
81129ecc:	10000c26 	beq	r2,zero,81129f00 <__submore+0xd4>
81129ed0:	80801083 	ldbu	r2,66(r16)
81129ed4:	80c00c15 	stw	r3,48(r16)
81129ed8:	84400d15 	stw	r17,52(r16)
81129edc:	1880ffc5 	stb	r2,1023(r3)
81129ee0:	81401043 	ldbu	r5,65(r16)
81129ee4:	1900ff44 	addi	r4,r3,1021
81129ee8:	0005883a 	mov	r2,zero
81129eec:	1940ff85 	stb	r5,1022(r3)
81129ef0:	81401003 	ldbu	r5,64(r16)
81129ef4:	1940ff45 	stb	r5,1021(r3)
81129ef8:	81000015 	stw	r4,0(r16)
81129efc:	003fe706 	br	81129e9c <__reset+0xfb109e9c>
81129f00:	00bfffc4 	movi	r2,-1
81129f04:	003fe506 	br	81129e9c <__reset+0xfb109e9c>

81129f08 <_ungetc_r>:
81129f08:	00bfffc4 	movi	r2,-1
81129f0c:	28806326 	beq	r5,r2,8112a09c <_ungetc_r+0x194>
81129f10:	defffb04 	addi	sp,sp,-20
81129f14:	de00012e 	bgeu	sp,et,81129f1c <_ungetc_r+0x14>
81129f18:	003b68fa 	trap	3
81129f1c:	dcc00315 	stw	r19,12(sp)
81129f20:	dc400115 	stw	r17,4(sp)
81129f24:	dc000015 	stw	r16,0(sp)
81129f28:	dfc00415 	stw	ra,16(sp)
81129f2c:	dc800215 	stw	r18,8(sp)
81129f30:	2023883a 	mov	r17,r4
81129f34:	3021883a 	mov	r16,r6
81129f38:	2827883a 	mov	r19,r5
81129f3c:	20000226 	beq	r4,zero,81129f48 <_ungetc_r+0x40>
81129f40:	20800e17 	ldw	r2,56(r4)
81129f44:	10002e26 	beq	r2,zero,8112a000 <_ungetc_r+0xf8>
81129f48:	80c0030b 	ldhu	r3,12(r16)
81129f4c:	1888000c 	andi	r2,r3,8192
81129f50:	1000051e 	bne	r2,zero,81129f68 <_ungetc_r+0x60>
81129f54:	81001917 	ldw	r4,100(r16)
81129f58:	00b7ffc4 	movi	r2,-8193
81129f5c:	18c80014 	ori	r3,r3,8192
81129f60:	2084703a 	and	r2,r4,r2
81129f64:	80801915 	stw	r2,100(r16)
81129f68:	00bff7c4 	movi	r2,-33
81129f6c:	1884703a 	and	r2,r3,r2
81129f70:	8080030d 	sth	r2,12(r16)
81129f74:	1900010c 	andi	r4,r3,4
81129f78:	2000061e 	bne	r4,zero,81129f94 <_ungetc_r+0x8c>
81129f7c:	1900040c 	andi	r4,r3,16
81129f80:	20001d26 	beq	r4,zero,81129ff8 <_ungetc_r+0xf0>
81129f84:	18c0020c 	andi	r3,r3,8
81129f88:	1800331e 	bne	r3,zero,8112a058 <_ungetc_r+0x150>
81129f8c:	10800114 	ori	r2,r2,4
81129f90:	8080030d 	sth	r2,12(r16)
81129f94:	80800c17 	ldw	r2,48(r16)
81129f98:	9c803fcc 	andi	r18,r19,255
81129f9c:	10001a26 	beq	r2,zero,8112a008 <_ungetc_r+0x100>
81129fa0:	80c00117 	ldw	r3,4(r16)
81129fa4:	80800d17 	ldw	r2,52(r16)
81129fa8:	18800f0e 	bge	r3,r2,81129fe8 <_ungetc_r+0xe0>
81129fac:	80c00017 	ldw	r3,0(r16)
81129fb0:	9005883a 	mov	r2,r18
81129fb4:	193fffc4 	addi	r4,r3,-1
81129fb8:	81000015 	stw	r4,0(r16)
81129fbc:	1cffffc5 	stb	r19,-1(r3)
81129fc0:	80c00117 	ldw	r3,4(r16)
81129fc4:	18c00044 	addi	r3,r3,1
81129fc8:	80c00115 	stw	r3,4(r16)
81129fcc:	dfc00417 	ldw	ra,16(sp)
81129fd0:	dcc00317 	ldw	r19,12(sp)
81129fd4:	dc800217 	ldw	r18,8(sp)
81129fd8:	dc400117 	ldw	r17,4(sp)
81129fdc:	dc000017 	ldw	r16,0(sp)
81129fe0:	dec00504 	addi	sp,sp,20
81129fe4:	f800283a 	ret
81129fe8:	800b883a 	mov	r5,r16
81129fec:	8809883a 	mov	r4,r17
81129ff0:	1129e2c0 	call	81129e2c <__submore>
81129ff4:	103fed26 	beq	r2,zero,81129fac <__reset+0xfb109fac>
81129ff8:	00bfffc4 	movi	r2,-1
81129ffc:	003ff306 	br	81129fcc <__reset+0xfb109fcc>
8112a000:	11234cc0 	call	811234cc <__sinit>
8112a004:	003fd006 	br	81129f48 <__reset+0xfb109f48>
8112a008:	80c00417 	ldw	r3,16(r16)
8112a00c:	80800017 	ldw	r2,0(r16)
8112a010:	18000326 	beq	r3,zero,8112a020 <_ungetc_r+0x118>
8112a014:	1880022e 	bgeu	r3,r2,8112a020 <_ungetc_r+0x118>
8112a018:	10ffffc3 	ldbu	r3,-1(r2)
8112a01c:	90c01826 	beq	r18,r3,8112a080 <_ungetc_r+0x178>
8112a020:	81400117 	ldw	r5,4(r16)
8112a024:	80800e15 	stw	r2,56(r16)
8112a028:	008000c4 	movi	r2,3
8112a02c:	81001004 	addi	r4,r16,64
8112a030:	80c01084 	addi	r3,r16,66
8112a034:	80800d15 	stw	r2,52(r16)
8112a038:	00800044 	movi	r2,1
8112a03c:	80800115 	stw	r2,4(r16)
8112a040:	81400f15 	stw	r5,60(r16)
8112a044:	81000c15 	stw	r4,48(r16)
8112a048:	84c01085 	stb	r19,66(r16)
8112a04c:	80c00015 	stw	r3,0(r16)
8112a050:	9005883a 	mov	r2,r18
8112a054:	003fdd06 	br	81129fcc <__reset+0xfb109fcc>
8112a058:	800b883a 	mov	r5,r16
8112a05c:	8809883a 	mov	r4,r17
8112a060:	11230d00 	call	811230d0 <_fflush_r>
8112a064:	103fe41e 	bne	r2,zero,81129ff8 <__reset+0xfb109ff8>
8112a068:	8080030b 	ldhu	r2,12(r16)
8112a06c:	00fffdc4 	movi	r3,-9
8112a070:	80000215 	stw	zero,8(r16)
8112a074:	1884703a 	and	r2,r3,r2
8112a078:	80000615 	stw	zero,24(r16)
8112a07c:	003fc306 	br	81129f8c <__reset+0xfb109f8c>
8112a080:	80c00117 	ldw	r3,4(r16)
8112a084:	10bfffc4 	addi	r2,r2,-1
8112a088:	80800015 	stw	r2,0(r16)
8112a08c:	18800044 	addi	r2,r3,1
8112a090:	80800115 	stw	r2,4(r16)
8112a094:	9005883a 	mov	r2,r18
8112a098:	003fcc06 	br	81129fcc <__reset+0xfb109fcc>
8112a09c:	00bfffc4 	movi	r2,-1
8112a0a0:	f800283a 	ret

8112a0a4 <ungetc>:
8112a0a4:	00a04534 	movhi	r2,33044
8112a0a8:	109e0f04 	addi	r2,r2,30780
8112a0ac:	280d883a 	mov	r6,r5
8112a0b0:	200b883a 	mov	r5,r4
8112a0b4:	11000017 	ldw	r4,0(r2)
8112a0b8:	1129f081 	jmpi	81129f08 <_ungetc_r>

8112a0bc <__sprint_r.part.0>:
8112a0bc:	defff604 	addi	sp,sp,-40
8112a0c0:	de00012e 	bgeu	sp,et,8112a0c8 <__sprint_r.part.0+0xc>
8112a0c4:	003b68fa 	trap	3
8112a0c8:	28801917 	ldw	r2,100(r5)
8112a0cc:	dd400515 	stw	r21,20(sp)
8112a0d0:	dfc00915 	stw	ra,36(sp)
8112a0d4:	df000815 	stw	fp,32(sp)
8112a0d8:	ddc00715 	stw	r23,28(sp)
8112a0dc:	dd800615 	stw	r22,24(sp)
8112a0e0:	dd000415 	stw	r20,16(sp)
8112a0e4:	dcc00315 	stw	r19,12(sp)
8112a0e8:	dc800215 	stw	r18,8(sp)
8112a0ec:	dc400115 	stw	r17,4(sp)
8112a0f0:	dc000015 	stw	r16,0(sp)
8112a0f4:	1088000c 	andi	r2,r2,8192
8112a0f8:	302b883a 	mov	r21,r6
8112a0fc:	10002e26 	beq	r2,zero,8112a1b8 <__sprint_r.part.0+0xfc>
8112a100:	30800217 	ldw	r2,8(r6)
8112a104:	35800017 	ldw	r22,0(r6)
8112a108:	10002926 	beq	r2,zero,8112a1b0 <__sprint_r.part.0+0xf4>
8112a10c:	2827883a 	mov	r19,r5
8112a110:	2029883a 	mov	r20,r4
8112a114:	b5c00104 	addi	r23,r22,4
8112a118:	04bfffc4 	movi	r18,-1
8112a11c:	bc400017 	ldw	r17,0(r23)
8112a120:	b4000017 	ldw	r16,0(r22)
8112a124:	0039883a 	mov	fp,zero
8112a128:	8822d0ba 	srli	r17,r17,2
8112a12c:	8800031e 	bne	r17,zero,8112a13c <__sprint_r.part.0+0x80>
8112a130:	00001806 	br	8112a194 <__sprint_r.part.0+0xd8>
8112a134:	84000104 	addi	r16,r16,4
8112a138:	8f001526 	beq	r17,fp,8112a190 <__sprint_r.part.0+0xd4>
8112a13c:	81400017 	ldw	r5,0(r16)
8112a140:	980d883a 	mov	r6,r19
8112a144:	a009883a 	mov	r4,r20
8112a148:	112bb240 	call	8112bb24 <_fputwc_r>
8112a14c:	e7000044 	addi	fp,fp,1
8112a150:	14bff81e 	bne	r2,r18,8112a134 <__reset+0xfb10a134>
8112a154:	9005883a 	mov	r2,r18
8112a158:	a8000215 	stw	zero,8(r21)
8112a15c:	a8000115 	stw	zero,4(r21)
8112a160:	dfc00917 	ldw	ra,36(sp)
8112a164:	df000817 	ldw	fp,32(sp)
8112a168:	ddc00717 	ldw	r23,28(sp)
8112a16c:	dd800617 	ldw	r22,24(sp)
8112a170:	dd400517 	ldw	r21,20(sp)
8112a174:	dd000417 	ldw	r20,16(sp)
8112a178:	dcc00317 	ldw	r19,12(sp)
8112a17c:	dc800217 	ldw	r18,8(sp)
8112a180:	dc400117 	ldw	r17,4(sp)
8112a184:	dc000017 	ldw	r16,0(sp)
8112a188:	dec00a04 	addi	sp,sp,40
8112a18c:	f800283a 	ret
8112a190:	a8800217 	ldw	r2,8(r21)
8112a194:	8c63883a 	add	r17,r17,r17
8112a198:	8c63883a 	add	r17,r17,r17
8112a19c:	1445c83a 	sub	r2,r2,r17
8112a1a0:	a8800215 	stw	r2,8(r21)
8112a1a4:	b5800204 	addi	r22,r22,8
8112a1a8:	bdc00204 	addi	r23,r23,8
8112a1ac:	103fdb1e 	bne	r2,zero,8112a11c <__reset+0xfb10a11c>
8112a1b0:	0005883a 	mov	r2,zero
8112a1b4:	003fe806 	br	8112a158 <__reset+0xfb10a158>
8112a1b8:	1123bd00 	call	81123bd0 <__sfvwrite_r>
8112a1bc:	003fe606 	br	8112a158 <__reset+0xfb10a158>

8112a1c0 <__sprint_r>:
8112a1c0:	30c00217 	ldw	r3,8(r6)
8112a1c4:	18000126 	beq	r3,zero,8112a1cc <__sprint_r+0xc>
8112a1c8:	112a0bc1 	jmpi	8112a0bc <__sprint_r.part.0>
8112a1cc:	30000115 	stw	zero,4(r6)
8112a1d0:	0005883a 	mov	r2,zero
8112a1d4:	f800283a 	ret

8112a1d8 <___vfiprintf_internal_r>:
8112a1d8:	deffc904 	addi	sp,sp,-220
8112a1dc:	de00012e 	bgeu	sp,et,8112a1e4 <___vfiprintf_internal_r+0xc>
8112a1e0:	003b68fa 	trap	3
8112a1e4:	df003515 	stw	fp,212(sp)
8112a1e8:	dd003115 	stw	r20,196(sp)
8112a1ec:	dfc03615 	stw	ra,216(sp)
8112a1f0:	ddc03415 	stw	r23,208(sp)
8112a1f4:	dd803315 	stw	r22,204(sp)
8112a1f8:	dd403215 	stw	r21,200(sp)
8112a1fc:	dcc03015 	stw	r19,192(sp)
8112a200:	dc802f15 	stw	r18,188(sp)
8112a204:	dc402e15 	stw	r17,184(sp)
8112a208:	dc002d15 	stw	r16,180(sp)
8112a20c:	d9002015 	stw	r4,128(sp)
8112a210:	d9c02215 	stw	r7,136(sp)
8112a214:	2829883a 	mov	r20,r5
8112a218:	3039883a 	mov	fp,r6
8112a21c:	20000226 	beq	r4,zero,8112a228 <___vfiprintf_internal_r+0x50>
8112a220:	20800e17 	ldw	r2,56(r4)
8112a224:	1000cf26 	beq	r2,zero,8112a564 <___vfiprintf_internal_r+0x38c>
8112a228:	a080030b 	ldhu	r2,12(r20)
8112a22c:	10c8000c 	andi	r3,r2,8192
8112a230:	1800061e 	bne	r3,zero,8112a24c <___vfiprintf_internal_r+0x74>
8112a234:	a1001917 	ldw	r4,100(r20)
8112a238:	00f7ffc4 	movi	r3,-8193
8112a23c:	10880014 	ori	r2,r2,8192
8112a240:	20c6703a 	and	r3,r4,r3
8112a244:	a080030d 	sth	r2,12(r20)
8112a248:	a0c01915 	stw	r3,100(r20)
8112a24c:	10c0020c 	andi	r3,r2,8
8112a250:	1800a926 	beq	r3,zero,8112a4f8 <___vfiprintf_internal_r+0x320>
8112a254:	a0c00417 	ldw	r3,16(r20)
8112a258:	1800a726 	beq	r3,zero,8112a4f8 <___vfiprintf_internal_r+0x320>
8112a25c:	1080068c 	andi	r2,r2,26
8112a260:	00c00284 	movi	r3,10
8112a264:	10c0ac26 	beq	r2,r3,8112a518 <___vfiprintf_internal_r+0x340>
8112a268:	da801a04 	addi	r10,sp,104
8112a26c:	da801e15 	stw	r10,120(sp)
8112a270:	d8801e17 	ldw	r2,120(sp)
8112a274:	da8019c4 	addi	r10,sp,103
8112a278:	05a04534 	movhi	r22,33044
8112a27c:	05e04534 	movhi	r23,33044
8112a280:	da801f15 	stw	r10,124(sp)
8112a284:	1295c83a 	sub	r10,r2,r10
8112a288:	b594d604 	addi	r22,r22,21336
8112a28c:	bdd4d204 	addi	r23,r23,21320
8112a290:	dec01a15 	stw	sp,104(sp)
8112a294:	d8001c15 	stw	zero,112(sp)
8112a298:	d8001b15 	stw	zero,108(sp)
8112a29c:	d8002615 	stw	zero,152(sp)
8112a2a0:	d8002315 	stw	zero,140(sp)
8112a2a4:	da802715 	stw	r10,156(sp)
8112a2a8:	d811883a 	mov	r8,sp
8112a2ac:	dd002115 	stw	r20,132(sp)
8112a2b0:	e021883a 	mov	r16,fp
8112a2b4:	80800007 	ldb	r2,0(r16)
8112a2b8:	1003ea26 	beq	r2,zero,8112b264 <___vfiprintf_internal_r+0x108c>
8112a2bc:	00c00944 	movi	r3,37
8112a2c0:	8025883a 	mov	r18,r16
8112a2c4:	10c0021e 	bne	r2,r3,8112a2d0 <___vfiprintf_internal_r+0xf8>
8112a2c8:	00001606 	br	8112a324 <___vfiprintf_internal_r+0x14c>
8112a2cc:	10c00326 	beq	r2,r3,8112a2dc <___vfiprintf_internal_r+0x104>
8112a2d0:	94800044 	addi	r18,r18,1
8112a2d4:	90800007 	ldb	r2,0(r18)
8112a2d8:	103ffc1e 	bne	r2,zero,8112a2cc <__reset+0xfb10a2cc>
8112a2dc:	9423c83a 	sub	r17,r18,r16
8112a2e0:	88001026 	beq	r17,zero,8112a324 <___vfiprintf_internal_r+0x14c>
8112a2e4:	d8c01c17 	ldw	r3,112(sp)
8112a2e8:	d8801b17 	ldw	r2,108(sp)
8112a2ec:	44000015 	stw	r16,0(r8)
8112a2f0:	88c7883a 	add	r3,r17,r3
8112a2f4:	10800044 	addi	r2,r2,1
8112a2f8:	44400115 	stw	r17,4(r8)
8112a2fc:	d8c01c15 	stw	r3,112(sp)
8112a300:	d8801b15 	stw	r2,108(sp)
8112a304:	010001c4 	movi	r4,7
8112a308:	2080760e 	bge	r4,r2,8112a4e4 <___vfiprintf_internal_r+0x30c>
8112a30c:	1803821e 	bne	r3,zero,8112b118 <___vfiprintf_internal_r+0xf40>
8112a310:	da802317 	ldw	r10,140(sp)
8112a314:	d8001b15 	stw	zero,108(sp)
8112a318:	d811883a 	mov	r8,sp
8112a31c:	5455883a 	add	r10,r10,r17
8112a320:	da802315 	stw	r10,140(sp)
8112a324:	90800007 	ldb	r2,0(r18)
8112a328:	10044626 	beq	r2,zero,8112b444 <___vfiprintf_internal_r+0x126c>
8112a32c:	90c00047 	ldb	r3,1(r18)
8112a330:	94000044 	addi	r16,r18,1
8112a334:	d8001d85 	stb	zero,118(sp)
8112a338:	0009883a 	mov	r4,zero
8112a33c:	000f883a 	mov	r7,zero
8112a340:	027fffc4 	movi	r9,-1
8112a344:	0023883a 	mov	r17,zero
8112a348:	0029883a 	mov	r20,zero
8112a34c:	01401604 	movi	r5,88
8112a350:	01800244 	movi	r6,9
8112a354:	03400a84 	movi	r13,42
8112a358:	03001b04 	movi	r12,108
8112a35c:	84000044 	addi	r16,r16,1
8112a360:	18bff804 	addi	r2,r3,-32
8112a364:	28827336 	bltu	r5,r2,8112ad34 <___vfiprintf_internal_r+0xb5c>
8112a368:	100490ba 	slli	r2,r2,2
8112a36c:	02a044f4 	movhi	r10,33043
8112a370:	52a8e004 	addi	r10,r10,-23680
8112a374:	1285883a 	add	r2,r2,r10
8112a378:	10800017 	ldw	r2,0(r2)
8112a37c:	1000683a 	jmp	r2
8112a380:	8112aa68 	cmpgeui	r4,r16,19113
8112a384:	8112ad34 	orhi	r4,r16,19124
8112a388:	8112ad34 	orhi	r4,r16,19124
8112a38c:	8112aa88 	cmpgei	r4,r16,19114
8112a390:	8112ad34 	orhi	r4,r16,19124
8112a394:	8112ad34 	orhi	r4,r16,19124
8112a398:	8112ad34 	orhi	r4,r16,19124
8112a39c:	8112ad34 	orhi	r4,r16,19124
8112a3a0:	8112ad34 	orhi	r4,r16,19124
8112a3a4:	8112ad34 	orhi	r4,r16,19124
8112a3a8:	8112ac70 	cmpltui	r4,r16,19121
8112a3ac:	8112ac8c 	andi	r4,r16,19122
8112a3b0:	8112ad34 	orhi	r4,r16,19124
8112a3b4:	8112a574 	orhi	r4,r16,19093
8112a3b8:	8112ac9c 	xori	r4,r16,19122
8112a3bc:	8112ad34 	orhi	r4,r16,19124
8112a3c0:	8112aa94 	ori	r4,r16,19114
8112a3c4:	8112aaa0 	cmpeqi	r4,r16,19114
8112a3c8:	8112aaa0 	cmpeqi	r4,r16,19114
8112a3cc:	8112aaa0 	cmpeqi	r4,r16,19114
8112a3d0:	8112aaa0 	cmpeqi	r4,r16,19114
8112a3d4:	8112aaa0 	cmpeqi	r4,r16,19114
8112a3d8:	8112aaa0 	cmpeqi	r4,r16,19114
8112a3dc:	8112aaa0 	cmpeqi	r4,r16,19114
8112a3e0:	8112aaa0 	cmpeqi	r4,r16,19114
8112a3e4:	8112aaa0 	cmpeqi	r4,r16,19114
8112a3e8:	8112ad34 	orhi	r4,r16,19124
8112a3ec:	8112ad34 	orhi	r4,r16,19124
8112a3f0:	8112ad34 	orhi	r4,r16,19124
8112a3f4:	8112ad34 	orhi	r4,r16,19124
8112a3f8:	8112ad34 	orhi	r4,r16,19124
8112a3fc:	8112ad34 	orhi	r4,r16,19124
8112a400:	8112ad34 	orhi	r4,r16,19124
8112a404:	8112ad34 	orhi	r4,r16,19124
8112a408:	8112ad34 	orhi	r4,r16,19124
8112a40c:	8112ad34 	orhi	r4,r16,19124
8112a410:	8112aacc 	andi	r4,r16,19115
8112a414:	8112ad34 	orhi	r4,r16,19124
8112a418:	8112ad34 	orhi	r4,r16,19124
8112a41c:	8112ad34 	orhi	r4,r16,19124
8112a420:	8112ad34 	orhi	r4,r16,19124
8112a424:	8112ad34 	orhi	r4,r16,19124
8112a428:	8112ad34 	orhi	r4,r16,19124
8112a42c:	8112ad34 	orhi	r4,r16,19124
8112a430:	8112ad34 	orhi	r4,r16,19124
8112a434:	8112ad34 	orhi	r4,r16,19124
8112a438:	8112ad34 	orhi	r4,r16,19124
8112a43c:	8112ab04 	addi	r4,r16,19116
8112a440:	8112ad34 	orhi	r4,r16,19124
8112a444:	8112ad34 	orhi	r4,r16,19124
8112a448:	8112ad34 	orhi	r4,r16,19124
8112a44c:	8112ad34 	orhi	r4,r16,19124
8112a450:	8112ad34 	orhi	r4,r16,19124
8112a454:	8112ab5c 	xori	r4,r16,19117
8112a458:	8112ad34 	orhi	r4,r16,19124
8112a45c:	8112ad34 	orhi	r4,r16,19124
8112a460:	8112abcc 	andi	r4,r16,19119
8112a464:	8112ad34 	orhi	r4,r16,19124
8112a468:	8112ad34 	orhi	r4,r16,19124
8112a46c:	8112ad34 	orhi	r4,r16,19124
8112a470:	8112ad34 	orhi	r4,r16,19124
8112a474:	8112ad34 	orhi	r4,r16,19124
8112a478:	8112ad34 	orhi	r4,r16,19124
8112a47c:	8112ad34 	orhi	r4,r16,19124
8112a480:	8112ad34 	orhi	r4,r16,19124
8112a484:	8112ad34 	orhi	r4,r16,19124
8112a488:	8112ad34 	orhi	r4,r16,19124
8112a48c:	8112a978 	rdprs	r4,r16,19109
8112a490:	8112a9a4 	muli	r4,r16,19110
8112a494:	8112ad34 	orhi	r4,r16,19124
8112a498:	8112ad34 	orhi	r4,r16,19124
8112a49c:	8112ad34 	orhi	r4,r16,19124
8112a4a0:	8112acdc 	xori	r4,r16,19123
8112a4a4:	8112a9a4 	muli	r4,r16,19110
8112a4a8:	8112ad34 	orhi	r4,r16,19124
8112a4ac:	8112ad34 	orhi	r4,r16,19124
8112a4b0:	8112a838 	rdprs	r4,r16,19104
8112a4b4:	8112ad34 	orhi	r4,r16,19124
8112a4b8:	8112a848 	cmpgei	r4,r16,19105
8112a4bc:	8112a884 	addi	r4,r16,19106
8112a4c0:	8112a580 	call	88112a58 <__reset+0x20f2a58>
8112a4c4:	8112a82c 	andhi	r4,r16,19104
8112a4c8:	8112ad34 	orhi	r4,r16,19124
8112a4cc:	8112ac08 	cmpgei	r4,r16,19120
8112a4d0:	8112ad34 	orhi	r4,r16,19124
8112a4d4:	8112ac60 	cmpeqi	r4,r16,19121
8112a4d8:	8112ad34 	orhi	r4,r16,19124
8112a4dc:	8112ad34 	orhi	r4,r16,19124
8112a4e0:	8112a924 	muli	r4,r16,19108
8112a4e4:	42000204 	addi	r8,r8,8
8112a4e8:	da802317 	ldw	r10,140(sp)
8112a4ec:	5455883a 	add	r10,r10,r17
8112a4f0:	da802315 	stw	r10,140(sp)
8112a4f4:	003f8b06 	br	8112a324 <__reset+0xfb10a324>
8112a4f8:	d9002017 	ldw	r4,128(sp)
8112a4fc:	a00b883a 	mov	r5,r20
8112a500:	11214b80 	call	811214b8 <__swsetup_r>
8112a504:	1003b11e 	bne	r2,zero,8112b3cc <___vfiprintf_internal_r+0x11f4>
8112a508:	a080030b 	ldhu	r2,12(r20)
8112a50c:	00c00284 	movi	r3,10
8112a510:	1080068c 	andi	r2,r2,26
8112a514:	10ff541e 	bne	r2,r3,8112a268 <__reset+0xfb10a268>
8112a518:	a080038f 	ldh	r2,14(r20)
8112a51c:	103f5216 	blt	r2,zero,8112a268 <__reset+0xfb10a268>
8112a520:	d9c02217 	ldw	r7,136(sp)
8112a524:	d9002017 	ldw	r4,128(sp)
8112a528:	e00d883a 	mov	r6,fp
8112a52c:	a00b883a 	mov	r5,r20
8112a530:	112b6580 	call	8112b658 <__sbprintf>
8112a534:	dfc03617 	ldw	ra,216(sp)
8112a538:	df003517 	ldw	fp,212(sp)
8112a53c:	ddc03417 	ldw	r23,208(sp)
8112a540:	dd803317 	ldw	r22,204(sp)
8112a544:	dd403217 	ldw	r21,200(sp)
8112a548:	dd003117 	ldw	r20,196(sp)
8112a54c:	dcc03017 	ldw	r19,192(sp)
8112a550:	dc802f17 	ldw	r18,188(sp)
8112a554:	dc402e17 	ldw	r17,184(sp)
8112a558:	dc002d17 	ldw	r16,180(sp)
8112a55c:	dec03704 	addi	sp,sp,220
8112a560:	f800283a 	ret
8112a564:	11234cc0 	call	811234cc <__sinit>
8112a568:	003f2f06 	br	8112a228 <__reset+0xfb10a228>
8112a56c:	0463c83a 	sub	r17,zero,r17
8112a570:	d8802215 	stw	r2,136(sp)
8112a574:	a5000114 	ori	r20,r20,4
8112a578:	80c00007 	ldb	r3,0(r16)
8112a57c:	003f7706 	br	8112a35c <__reset+0xfb10a35c>
8112a580:	00800c04 	movi	r2,48
8112a584:	da802217 	ldw	r10,136(sp)
8112a588:	d8801d05 	stb	r2,116(sp)
8112a58c:	00801e04 	movi	r2,120
8112a590:	d8801d45 	stb	r2,117(sp)
8112a594:	d8001d85 	stb	zero,118(sp)
8112a598:	50c00104 	addi	r3,r10,4
8112a59c:	54800017 	ldw	r18,0(r10)
8112a5a0:	0027883a 	mov	r19,zero
8112a5a4:	a0800094 	ori	r2,r20,2
8112a5a8:	48030b16 	blt	r9,zero,8112b1d8 <___vfiprintf_internal_r+0x1000>
8112a5ac:	00bfdfc4 	movi	r2,-129
8112a5b0:	a096703a 	and	r11,r20,r2
8112a5b4:	d8c02215 	stw	r3,136(sp)
8112a5b8:	5d000094 	ori	r20,r11,2
8112a5bc:	90032b1e 	bne	r18,zero,8112b26c <___vfiprintf_internal_r+0x1094>
8112a5c0:	00a04534 	movhi	r2,33044
8112a5c4:	10943f04 	addi	r2,r2,20732
8112a5c8:	d8802615 	stw	r2,152(sp)
8112a5cc:	0039883a 	mov	fp,zero
8112a5d0:	48017b1e 	bne	r9,zero,8112abc0 <___vfiprintf_internal_r+0x9e8>
8112a5d4:	0013883a 	mov	r9,zero
8112a5d8:	0027883a 	mov	r19,zero
8112a5dc:	dd401a04 	addi	r21,sp,104
8112a5e0:	4825883a 	mov	r18,r9
8112a5e4:	4cc0010e 	bge	r9,r19,8112a5ec <___vfiprintf_internal_r+0x414>
8112a5e8:	9825883a 	mov	r18,r19
8112a5ec:	e7003fcc 	andi	fp,fp,255
8112a5f0:	e700201c 	xori	fp,fp,128
8112a5f4:	e73fe004 	addi	fp,fp,-128
8112a5f8:	e0000126 	beq	fp,zero,8112a600 <___vfiprintf_internal_r+0x428>
8112a5fc:	94800044 	addi	r18,r18,1
8112a600:	a380008c 	andi	r14,r20,2
8112a604:	70000126 	beq	r14,zero,8112a60c <___vfiprintf_internal_r+0x434>
8112a608:	94800084 	addi	r18,r18,2
8112a60c:	a700210c 	andi	fp,r20,132
8112a610:	e001df1e 	bne	fp,zero,8112ad90 <___vfiprintf_internal_r+0xbb8>
8112a614:	8c87c83a 	sub	r3,r17,r18
8112a618:	00c1dd0e 	bge	zero,r3,8112ad90 <___vfiprintf_internal_r+0xbb8>
8112a61c:	01c00404 	movi	r7,16
8112a620:	d8801c17 	ldw	r2,112(sp)
8112a624:	38c3ad0e 	bge	r7,r3,8112b4dc <___vfiprintf_internal_r+0x1304>
8112a628:	02a04534 	movhi	r10,33044
8112a62c:	5294d604 	addi	r10,r10,21336
8112a630:	dc002915 	stw	r16,164(sp)
8112a634:	d9801b17 	ldw	r6,108(sp)
8112a638:	da802415 	stw	r10,144(sp)
8112a63c:	03c001c4 	movi	r15,7
8112a640:	da402515 	stw	r9,148(sp)
8112a644:	db802815 	stw	r14,160(sp)
8112a648:	1821883a 	mov	r16,r3
8112a64c:	00000506 	br	8112a664 <___vfiprintf_internal_r+0x48c>
8112a650:	31400084 	addi	r5,r6,2
8112a654:	42000204 	addi	r8,r8,8
8112a658:	200d883a 	mov	r6,r4
8112a65c:	843ffc04 	addi	r16,r16,-16
8112a660:	3c000d0e 	bge	r7,r16,8112a698 <___vfiprintf_internal_r+0x4c0>
8112a664:	10800404 	addi	r2,r2,16
8112a668:	31000044 	addi	r4,r6,1
8112a66c:	45800015 	stw	r22,0(r8)
8112a670:	41c00115 	stw	r7,4(r8)
8112a674:	d8801c15 	stw	r2,112(sp)
8112a678:	d9001b15 	stw	r4,108(sp)
8112a67c:	793ff40e 	bge	r15,r4,8112a650 <__reset+0xfb10a650>
8112a680:	1001b51e 	bne	r2,zero,8112ad58 <___vfiprintf_internal_r+0xb80>
8112a684:	843ffc04 	addi	r16,r16,-16
8112a688:	000d883a 	mov	r6,zero
8112a68c:	01400044 	movi	r5,1
8112a690:	d811883a 	mov	r8,sp
8112a694:	3c3ff316 	blt	r7,r16,8112a664 <__reset+0xfb10a664>
8112a698:	8007883a 	mov	r3,r16
8112a69c:	da402517 	ldw	r9,148(sp)
8112a6a0:	db802817 	ldw	r14,160(sp)
8112a6a4:	dc002917 	ldw	r16,164(sp)
8112a6a8:	da802417 	ldw	r10,144(sp)
8112a6ac:	1885883a 	add	r2,r3,r2
8112a6b0:	40c00115 	stw	r3,4(r8)
8112a6b4:	42800015 	stw	r10,0(r8)
8112a6b8:	d8801c15 	stw	r2,112(sp)
8112a6bc:	d9401b15 	stw	r5,108(sp)
8112a6c0:	00c001c4 	movi	r3,7
8112a6c4:	19426016 	blt	r3,r5,8112b048 <___vfiprintf_internal_r+0xe70>
8112a6c8:	d8c01d87 	ldb	r3,118(sp)
8112a6cc:	42000204 	addi	r8,r8,8
8112a6d0:	29000044 	addi	r4,r5,1
8112a6d4:	1801b31e 	bne	r3,zero,8112ada4 <___vfiprintf_internal_r+0xbcc>
8112a6d8:	7001c026 	beq	r14,zero,8112addc <___vfiprintf_internal_r+0xc04>
8112a6dc:	d8c01d04 	addi	r3,sp,116
8112a6e0:	10800084 	addi	r2,r2,2
8112a6e4:	40c00015 	stw	r3,0(r8)
8112a6e8:	00c00084 	movi	r3,2
8112a6ec:	40c00115 	stw	r3,4(r8)
8112a6f0:	d8801c15 	stw	r2,112(sp)
8112a6f4:	d9001b15 	stw	r4,108(sp)
8112a6f8:	00c001c4 	movi	r3,7
8112a6fc:	1902650e 	bge	r3,r4,8112b094 <___vfiprintf_internal_r+0xebc>
8112a700:	10029a1e 	bne	r2,zero,8112b16c <___vfiprintf_internal_r+0xf94>
8112a704:	00c02004 	movi	r3,128
8112a708:	01000044 	movi	r4,1
8112a70c:	000b883a 	mov	r5,zero
8112a710:	d811883a 	mov	r8,sp
8112a714:	e0c1b31e 	bne	fp,r3,8112ade4 <___vfiprintf_internal_r+0xc0c>
8112a718:	8cb9c83a 	sub	fp,r17,r18
8112a71c:	0701b10e 	bge	zero,fp,8112ade4 <___vfiprintf_internal_r+0xc0c>
8112a720:	01c00404 	movi	r7,16
8112a724:	3f03890e 	bge	r7,fp,8112b54c <___vfiprintf_internal_r+0x1374>
8112a728:	00e04534 	movhi	r3,33044
8112a72c:	18d4d204 	addi	r3,r3,21320
8112a730:	d8c02415 	stw	r3,144(sp)
8112a734:	8007883a 	mov	r3,r16
8112a738:	034001c4 	movi	r13,7
8112a73c:	e021883a 	mov	r16,fp
8112a740:	da402515 	stw	r9,148(sp)
8112a744:	1839883a 	mov	fp,r3
8112a748:	00000506 	br	8112a760 <___vfiprintf_internal_r+0x588>
8112a74c:	29800084 	addi	r6,r5,2
8112a750:	42000204 	addi	r8,r8,8
8112a754:	180b883a 	mov	r5,r3
8112a758:	843ffc04 	addi	r16,r16,-16
8112a75c:	3c000d0e 	bge	r7,r16,8112a794 <___vfiprintf_internal_r+0x5bc>
8112a760:	10800404 	addi	r2,r2,16
8112a764:	28c00044 	addi	r3,r5,1
8112a768:	45c00015 	stw	r23,0(r8)
8112a76c:	41c00115 	stw	r7,4(r8)
8112a770:	d8801c15 	stw	r2,112(sp)
8112a774:	d8c01b15 	stw	r3,108(sp)
8112a778:	68fff40e 	bge	r13,r3,8112a74c <__reset+0xfb10a74c>
8112a77c:	1002241e 	bne	r2,zero,8112b010 <___vfiprintf_internal_r+0xe38>
8112a780:	843ffc04 	addi	r16,r16,-16
8112a784:	01800044 	movi	r6,1
8112a788:	000b883a 	mov	r5,zero
8112a78c:	d811883a 	mov	r8,sp
8112a790:	3c3ff316 	blt	r7,r16,8112a760 <__reset+0xfb10a760>
8112a794:	da402517 	ldw	r9,148(sp)
8112a798:	e007883a 	mov	r3,fp
8112a79c:	8039883a 	mov	fp,r16
8112a7a0:	1821883a 	mov	r16,r3
8112a7a4:	d8c02417 	ldw	r3,144(sp)
8112a7a8:	1705883a 	add	r2,r2,fp
8112a7ac:	47000115 	stw	fp,4(r8)
8112a7b0:	40c00015 	stw	r3,0(r8)
8112a7b4:	d8801c15 	stw	r2,112(sp)
8112a7b8:	d9801b15 	stw	r6,108(sp)
8112a7bc:	00c001c4 	movi	r3,7
8112a7c0:	19827616 	blt	r3,r6,8112b19c <___vfiprintf_internal_r+0xfc4>
8112a7c4:	4cf9c83a 	sub	fp,r9,r19
8112a7c8:	42000204 	addi	r8,r8,8
8112a7cc:	31000044 	addi	r4,r6,1
8112a7d0:	300b883a 	mov	r5,r6
8112a7d4:	07018516 	blt	zero,fp,8112adec <___vfiprintf_internal_r+0xc14>
8112a7d8:	9885883a 	add	r2,r19,r2
8112a7dc:	45400015 	stw	r21,0(r8)
8112a7e0:	44c00115 	stw	r19,4(r8)
8112a7e4:	d8801c15 	stw	r2,112(sp)
8112a7e8:	d9001b15 	stw	r4,108(sp)
8112a7ec:	00c001c4 	movi	r3,7
8112a7f0:	1901dd0e 	bge	r3,r4,8112af68 <___vfiprintf_internal_r+0xd90>
8112a7f4:	1002401e 	bne	r2,zero,8112b0f8 <___vfiprintf_internal_r+0xf20>
8112a7f8:	d8001b15 	stw	zero,108(sp)
8112a7fc:	a2c0010c 	andi	r11,r20,4
8112a800:	58000226 	beq	r11,zero,8112a80c <___vfiprintf_internal_r+0x634>
8112a804:	8ca7c83a 	sub	r19,r17,r18
8112a808:	04c2f216 	blt	zero,r19,8112b3d4 <___vfiprintf_internal_r+0x11fc>
8112a80c:	8c80010e 	bge	r17,r18,8112a814 <___vfiprintf_internal_r+0x63c>
8112a810:	9023883a 	mov	r17,r18
8112a814:	da802317 	ldw	r10,140(sp)
8112a818:	5455883a 	add	r10,r10,r17
8112a81c:	da802315 	stw	r10,140(sp)
8112a820:	d8001b15 	stw	zero,108(sp)
8112a824:	d811883a 	mov	r8,sp
8112a828:	003ea206 	br	8112a2b4 <__reset+0xfb10a2b4>
8112a82c:	a5000814 	ori	r20,r20,32
8112a830:	80c00007 	ldb	r3,0(r16)
8112a834:	003ec906 	br	8112a35c <__reset+0xfb10a35c>
8112a838:	80c00007 	ldb	r3,0(r16)
8112a83c:	1b030926 	beq	r3,r12,8112b464 <___vfiprintf_internal_r+0x128c>
8112a840:	a5000414 	ori	r20,r20,16
8112a844:	003ec506 	br	8112a35c <__reset+0xfb10a35c>
8112a848:	21003fcc 	andi	r4,r4,255
8112a84c:	20035e1e 	bne	r4,zero,8112b5c8 <___vfiprintf_internal_r+0x13f0>
8112a850:	a080080c 	andi	r2,r20,32
8112a854:	1002a526 	beq	r2,zero,8112b2ec <___vfiprintf_internal_r+0x1114>
8112a858:	da802217 	ldw	r10,136(sp)
8112a85c:	50800017 	ldw	r2,0(r10)
8112a860:	da802317 	ldw	r10,140(sp)
8112a864:	5007d7fa 	srai	r3,r10,31
8112a868:	da802217 	ldw	r10,136(sp)
8112a86c:	10c00115 	stw	r3,4(r2)
8112a870:	52800104 	addi	r10,r10,4
8112a874:	da802215 	stw	r10,136(sp)
8112a878:	da802317 	ldw	r10,140(sp)
8112a87c:	12800015 	stw	r10,0(r2)
8112a880:	003e8c06 	br	8112a2b4 <__reset+0xfb10a2b4>
8112a884:	21003fcc 	andi	r4,r4,255
8112a888:	2003511e 	bne	r4,zero,8112b5d0 <___vfiprintf_internal_r+0x13f8>
8112a88c:	a080080c 	andi	r2,r20,32
8112a890:	1000a126 	beq	r2,zero,8112ab18 <___vfiprintf_internal_r+0x940>
8112a894:	da802217 	ldw	r10,136(sp)
8112a898:	d8001d85 	stb	zero,118(sp)
8112a89c:	50800204 	addi	r2,r10,8
8112a8a0:	54800017 	ldw	r18,0(r10)
8112a8a4:	54c00117 	ldw	r19,4(r10)
8112a8a8:	4802b416 	blt	r9,zero,8112b37c <___vfiprintf_internal_r+0x11a4>
8112a8ac:	013fdfc4 	movi	r4,-129
8112a8b0:	94c6b03a 	or	r3,r18,r19
8112a8b4:	d8802215 	stw	r2,136(sp)
8112a8b8:	a128703a 	and	r20,r20,r4
8112a8bc:	1800a226 	beq	r3,zero,8112ab48 <___vfiprintf_internal_r+0x970>
8112a8c0:	0039883a 	mov	fp,zero
8112a8c4:	dd401a04 	addi	r21,sp,104
8112a8c8:	9006d0fa 	srli	r3,r18,3
8112a8cc:	9808977a 	slli	r4,r19,29
8112a8d0:	9826d0fa 	srli	r19,r19,3
8112a8d4:	948001cc 	andi	r18,r18,7
8112a8d8:	90800c04 	addi	r2,r18,48
8112a8dc:	ad7fffc4 	addi	r21,r21,-1
8112a8e0:	20e4b03a 	or	r18,r4,r3
8112a8e4:	a8800005 	stb	r2,0(r21)
8112a8e8:	94c6b03a 	or	r3,r18,r19
8112a8ec:	183ff61e 	bne	r3,zero,8112a8c8 <__reset+0xfb10a8c8>
8112a8f0:	a0c0004c 	andi	r3,r20,1
8112a8f4:	18005926 	beq	r3,zero,8112aa5c <___vfiprintf_internal_r+0x884>
8112a8f8:	10803fcc 	andi	r2,r2,255
8112a8fc:	1080201c 	xori	r2,r2,128
8112a900:	10bfe004 	addi	r2,r2,-128
8112a904:	00c00c04 	movi	r3,48
8112a908:	10c05426 	beq	r2,r3,8112aa5c <___vfiprintf_internal_r+0x884>
8112a90c:	da801e17 	ldw	r10,120(sp)
8112a910:	a8bfffc4 	addi	r2,r21,-1
8112a914:	a8ffffc5 	stb	r3,-1(r21)
8112a918:	50a7c83a 	sub	r19,r10,r2
8112a91c:	102b883a 	mov	r21,r2
8112a920:	003f2f06 	br	8112a5e0 <__reset+0xfb10a5e0>
8112a924:	21003fcc 	andi	r4,r4,255
8112a928:	2003421e 	bne	r4,zero,8112b634 <___vfiprintf_internal_r+0x145c>
8112a92c:	00a04534 	movhi	r2,33044
8112a930:	10943f04 	addi	r2,r2,20732
8112a934:	d8802615 	stw	r2,152(sp)
8112a938:	a080080c 	andi	r2,r20,32
8112a93c:	1000aa26 	beq	r2,zero,8112abe8 <___vfiprintf_internal_r+0xa10>
8112a940:	da802217 	ldw	r10,136(sp)
8112a944:	54800017 	ldw	r18,0(r10)
8112a948:	54c00117 	ldw	r19,4(r10)
8112a94c:	52800204 	addi	r10,r10,8
8112a950:	da802215 	stw	r10,136(sp)
8112a954:	a080004c 	andi	r2,r20,1
8112a958:	1001d226 	beq	r2,zero,8112b0a4 <___vfiprintf_internal_r+0xecc>
8112a95c:	94c4b03a 	or	r2,r18,r19
8112a960:	1002351e 	bne	r2,zero,8112b238 <___vfiprintf_internal_r+0x1060>
8112a964:	d8001d85 	stb	zero,118(sp)
8112a968:	48022216 	blt	r9,zero,8112b1f4 <___vfiprintf_internal_r+0x101c>
8112a96c:	00bfdfc4 	movi	r2,-129
8112a970:	a0a8703a 	and	r20,r20,r2
8112a974:	003f1506 	br	8112a5cc <__reset+0xfb10a5cc>
8112a978:	da802217 	ldw	r10,136(sp)
8112a97c:	04800044 	movi	r18,1
8112a980:	d8001d85 	stb	zero,118(sp)
8112a984:	50800017 	ldw	r2,0(r10)
8112a988:	52800104 	addi	r10,r10,4
8112a98c:	da802215 	stw	r10,136(sp)
8112a990:	d8801005 	stb	r2,64(sp)
8112a994:	9027883a 	mov	r19,r18
8112a998:	dd401004 	addi	r21,sp,64
8112a99c:	0013883a 	mov	r9,zero
8112a9a0:	003f1706 	br	8112a600 <__reset+0xfb10a600>
8112a9a4:	21003fcc 	andi	r4,r4,255
8112a9a8:	2003201e 	bne	r4,zero,8112b62c <___vfiprintf_internal_r+0x1454>
8112a9ac:	a080080c 	andi	r2,r20,32
8112a9b0:	10004b26 	beq	r2,zero,8112aae0 <___vfiprintf_internal_r+0x908>
8112a9b4:	da802217 	ldw	r10,136(sp)
8112a9b8:	50800117 	ldw	r2,4(r10)
8112a9bc:	54800017 	ldw	r18,0(r10)
8112a9c0:	52800204 	addi	r10,r10,8
8112a9c4:	da802215 	stw	r10,136(sp)
8112a9c8:	1027883a 	mov	r19,r2
8112a9cc:	10022c16 	blt	r2,zero,8112b280 <___vfiprintf_internal_r+0x10a8>
8112a9d0:	df001d83 	ldbu	fp,118(sp)
8112a9d4:	48007216 	blt	r9,zero,8112aba0 <___vfiprintf_internal_r+0x9c8>
8112a9d8:	00ffdfc4 	movi	r3,-129
8112a9dc:	94c4b03a 	or	r2,r18,r19
8112a9e0:	a0e8703a 	and	r20,r20,r3
8112a9e4:	1000cc26 	beq	r2,zero,8112ad18 <___vfiprintf_internal_r+0xb40>
8112a9e8:	98021026 	beq	r19,zero,8112b22c <___vfiprintf_internal_r+0x1054>
8112a9ec:	dc402415 	stw	r17,144(sp)
8112a9f0:	dc002515 	stw	r16,148(sp)
8112a9f4:	9823883a 	mov	r17,r19
8112a9f8:	9021883a 	mov	r16,r18
8112a9fc:	dd401a04 	addi	r21,sp,104
8112aa00:	4825883a 	mov	r18,r9
8112aa04:	4027883a 	mov	r19,r8
8112aa08:	8009883a 	mov	r4,r16
8112aa0c:	880b883a 	mov	r5,r17
8112aa10:	01800284 	movi	r6,10
8112aa14:	000f883a 	mov	r7,zero
8112aa18:	112d2ac0 	call	8112d2ac <__umoddi3>
8112aa1c:	10800c04 	addi	r2,r2,48
8112aa20:	ad7fffc4 	addi	r21,r21,-1
8112aa24:	8009883a 	mov	r4,r16
8112aa28:	880b883a 	mov	r5,r17
8112aa2c:	a8800005 	stb	r2,0(r21)
8112aa30:	01800284 	movi	r6,10
8112aa34:	000f883a 	mov	r7,zero
8112aa38:	112cd2c0 	call	8112cd2c <__udivdi3>
8112aa3c:	1021883a 	mov	r16,r2
8112aa40:	10c4b03a 	or	r2,r2,r3
8112aa44:	1823883a 	mov	r17,r3
8112aa48:	103fef1e 	bne	r2,zero,8112aa08 <__reset+0xfb10aa08>
8112aa4c:	dc402417 	ldw	r17,144(sp)
8112aa50:	dc002517 	ldw	r16,148(sp)
8112aa54:	9013883a 	mov	r9,r18
8112aa58:	9811883a 	mov	r8,r19
8112aa5c:	da801e17 	ldw	r10,120(sp)
8112aa60:	5567c83a 	sub	r19,r10,r21
8112aa64:	003ede06 	br	8112a5e0 <__reset+0xfb10a5e0>
8112aa68:	38803fcc 	andi	r2,r7,255
8112aa6c:	1080201c 	xori	r2,r2,128
8112aa70:	10bfe004 	addi	r2,r2,-128
8112aa74:	1002371e 	bne	r2,zero,8112b354 <___vfiprintf_internal_r+0x117c>
8112aa78:	01000044 	movi	r4,1
8112aa7c:	01c00804 	movi	r7,32
8112aa80:	80c00007 	ldb	r3,0(r16)
8112aa84:	003e3506 	br	8112a35c <__reset+0xfb10a35c>
8112aa88:	a5000054 	ori	r20,r20,1
8112aa8c:	80c00007 	ldb	r3,0(r16)
8112aa90:	003e3206 	br	8112a35c <__reset+0xfb10a35c>
8112aa94:	a5002014 	ori	r20,r20,128
8112aa98:	80c00007 	ldb	r3,0(r16)
8112aa9c:	003e2f06 	br	8112a35c <__reset+0xfb10a35c>
8112aaa0:	8015883a 	mov	r10,r16
8112aaa4:	0023883a 	mov	r17,zero
8112aaa8:	18bff404 	addi	r2,r3,-48
8112aaac:	50c00007 	ldb	r3,0(r10)
8112aab0:	8c4002a4 	muli	r17,r17,10
8112aab4:	84000044 	addi	r16,r16,1
8112aab8:	8015883a 	mov	r10,r16
8112aabc:	1463883a 	add	r17,r2,r17
8112aac0:	18bff404 	addi	r2,r3,-48
8112aac4:	30bff92e 	bgeu	r6,r2,8112aaac <__reset+0xfb10aaac>
8112aac8:	003e2506 	br	8112a360 <__reset+0xfb10a360>
8112aacc:	21003fcc 	andi	r4,r4,255
8112aad0:	2002d41e 	bne	r4,zero,8112b624 <___vfiprintf_internal_r+0x144c>
8112aad4:	a5000414 	ori	r20,r20,16
8112aad8:	a080080c 	andi	r2,r20,32
8112aadc:	103fb51e 	bne	r2,zero,8112a9b4 <__reset+0xfb10a9b4>
8112aae0:	a080040c 	andi	r2,r20,16
8112aae4:	1001f826 	beq	r2,zero,8112b2c8 <___vfiprintf_internal_r+0x10f0>
8112aae8:	da802217 	ldw	r10,136(sp)
8112aaec:	54800017 	ldw	r18,0(r10)
8112aaf0:	52800104 	addi	r10,r10,4
8112aaf4:	da802215 	stw	r10,136(sp)
8112aaf8:	9027d7fa 	srai	r19,r18,31
8112aafc:	9805883a 	mov	r2,r19
8112ab00:	003fb206 	br	8112a9cc <__reset+0xfb10a9cc>
8112ab04:	21003fcc 	andi	r4,r4,255
8112ab08:	2002c41e 	bne	r4,zero,8112b61c <___vfiprintf_internal_r+0x1444>
8112ab0c:	a5000414 	ori	r20,r20,16
8112ab10:	a080080c 	andi	r2,r20,32
8112ab14:	103f5f1e 	bne	r2,zero,8112a894 <__reset+0xfb10a894>
8112ab18:	a080040c 	andi	r2,r20,16
8112ab1c:	10020f26 	beq	r2,zero,8112b35c <___vfiprintf_internal_r+0x1184>
8112ab20:	da802217 	ldw	r10,136(sp)
8112ab24:	d8001d85 	stb	zero,118(sp)
8112ab28:	0027883a 	mov	r19,zero
8112ab2c:	50800104 	addi	r2,r10,4
8112ab30:	54800017 	ldw	r18,0(r10)
8112ab34:	48021116 	blt	r9,zero,8112b37c <___vfiprintf_internal_r+0x11a4>
8112ab38:	00ffdfc4 	movi	r3,-129
8112ab3c:	d8802215 	stw	r2,136(sp)
8112ab40:	a0e8703a 	and	r20,r20,r3
8112ab44:	903f5e1e 	bne	r18,zero,8112a8c0 <__reset+0xfb10a8c0>
8112ab48:	0039883a 	mov	fp,zero
8112ab4c:	4802a626 	beq	r9,zero,8112b5e8 <___vfiprintf_internal_r+0x1410>
8112ab50:	0025883a 	mov	r18,zero
8112ab54:	0027883a 	mov	r19,zero
8112ab58:	003f5a06 	br	8112a8c4 <__reset+0xfb10a8c4>
8112ab5c:	21003fcc 	andi	r4,r4,255
8112ab60:	20029f1e 	bne	r4,zero,8112b5e0 <___vfiprintf_internal_r+0x1408>
8112ab64:	a5000414 	ori	r20,r20,16
8112ab68:	a080080c 	andi	r2,r20,32
8112ab6c:	10005e1e 	bne	r2,zero,8112ace8 <___vfiprintf_internal_r+0xb10>
8112ab70:	a080040c 	andi	r2,r20,16
8112ab74:	1001a21e 	bne	r2,zero,8112b200 <___vfiprintf_internal_r+0x1028>
8112ab78:	a080100c 	andi	r2,r20,64
8112ab7c:	d8001d85 	stb	zero,118(sp)
8112ab80:	da802217 	ldw	r10,136(sp)
8112ab84:	1002231e 	bne	r2,zero,8112b414 <___vfiprintf_internal_r+0x123c>
8112ab88:	50800104 	addi	r2,r10,4
8112ab8c:	54800017 	ldw	r18,0(r10)
8112ab90:	0027883a 	mov	r19,zero
8112ab94:	4801a00e 	bge	r9,zero,8112b218 <___vfiprintf_internal_r+0x1040>
8112ab98:	d8802215 	stw	r2,136(sp)
8112ab9c:	0039883a 	mov	fp,zero
8112aba0:	94c4b03a 	or	r2,r18,r19
8112aba4:	103f901e 	bne	r2,zero,8112a9e8 <__reset+0xfb10a9e8>
8112aba8:	00800044 	movi	r2,1
8112abac:	10803fcc 	andi	r2,r2,255
8112abb0:	00c00044 	movi	r3,1
8112abb4:	10c05926 	beq	r2,r3,8112ad1c <___vfiprintf_internal_r+0xb44>
8112abb8:	00c00084 	movi	r3,2
8112abbc:	10ffe41e 	bne	r2,r3,8112ab50 <__reset+0xfb10ab50>
8112abc0:	0025883a 	mov	r18,zero
8112abc4:	0027883a 	mov	r19,zero
8112abc8:	00013d06 	br	8112b0c0 <___vfiprintf_internal_r+0xee8>
8112abcc:	21003fcc 	andi	r4,r4,255
8112abd0:	2002811e 	bne	r4,zero,8112b5d8 <___vfiprintf_internal_r+0x1400>
8112abd4:	00a04534 	movhi	r2,33044
8112abd8:	10943a04 	addi	r2,r2,20712
8112abdc:	d8802615 	stw	r2,152(sp)
8112abe0:	a080080c 	andi	r2,r20,32
8112abe4:	103f561e 	bne	r2,zero,8112a940 <__reset+0xfb10a940>
8112abe8:	a080040c 	andi	r2,r20,16
8112abec:	1001d126 	beq	r2,zero,8112b334 <___vfiprintf_internal_r+0x115c>
8112abf0:	da802217 	ldw	r10,136(sp)
8112abf4:	0027883a 	mov	r19,zero
8112abf8:	54800017 	ldw	r18,0(r10)
8112abfc:	52800104 	addi	r10,r10,4
8112ac00:	da802215 	stw	r10,136(sp)
8112ac04:	003f5306 	br	8112a954 <__reset+0xfb10a954>
8112ac08:	da802217 	ldw	r10,136(sp)
8112ac0c:	d8001d85 	stb	zero,118(sp)
8112ac10:	55400017 	ldw	r21,0(r10)
8112ac14:	50c00104 	addi	r3,r10,4
8112ac18:	a8024226 	beq	r21,zero,8112b524 <___vfiprintf_internal_r+0x134c>
8112ac1c:	48021816 	blt	r9,zero,8112b480 <___vfiprintf_internal_r+0x12a8>
8112ac20:	480d883a 	mov	r6,r9
8112ac24:	000b883a 	mov	r5,zero
8112ac28:	a809883a 	mov	r4,r21
8112ac2c:	d8c02a15 	stw	r3,168(sp)
8112ac30:	da002b15 	stw	r8,172(sp)
8112ac34:	da402c15 	stw	r9,176(sp)
8112ac38:	1124f5c0 	call	81124f5c <memchr>
8112ac3c:	d8c02a17 	ldw	r3,168(sp)
8112ac40:	da002b17 	ldw	r8,172(sp)
8112ac44:	da402c17 	ldw	r9,176(sp)
8112ac48:	10024826 	beq	r2,zero,8112b56c <___vfiprintf_internal_r+0x1394>
8112ac4c:	1567c83a 	sub	r19,r2,r21
8112ac50:	df001d83 	ldbu	fp,118(sp)
8112ac54:	d8c02215 	stw	r3,136(sp)
8112ac58:	0013883a 	mov	r9,zero
8112ac5c:	003e6006 	br	8112a5e0 <__reset+0xfb10a5e0>
8112ac60:	21003fcc 	andi	r4,r4,255
8112ac64:	203fc026 	beq	r4,zero,8112ab68 <__reset+0xfb10ab68>
8112ac68:	d9c01d85 	stb	r7,118(sp)
8112ac6c:	003fbe06 	br	8112ab68 <__reset+0xfb10ab68>
8112ac70:	da802217 	ldw	r10,136(sp)
8112ac74:	54400017 	ldw	r17,0(r10)
8112ac78:	50800104 	addi	r2,r10,4
8112ac7c:	883e3b16 	blt	r17,zero,8112a56c <__reset+0xfb10a56c>
8112ac80:	d8802215 	stw	r2,136(sp)
8112ac84:	80c00007 	ldb	r3,0(r16)
8112ac88:	003db406 	br	8112a35c <__reset+0xfb10a35c>
8112ac8c:	01000044 	movi	r4,1
8112ac90:	01c00ac4 	movi	r7,43
8112ac94:	80c00007 	ldb	r3,0(r16)
8112ac98:	003db006 	br	8112a35c <__reset+0xfb10a35c>
8112ac9c:	80c00007 	ldb	r3,0(r16)
8112aca0:	82800044 	addi	r10,r16,1
8112aca4:	1b423c26 	beq	r3,r13,8112b598 <___vfiprintf_internal_r+0x13c0>
8112aca8:	18bff404 	addi	r2,r3,-48
8112acac:	0013883a 	mov	r9,zero
8112acb0:	30822b36 	bltu	r6,r2,8112b560 <___vfiprintf_internal_r+0x1388>
8112acb4:	50c00007 	ldb	r3,0(r10)
8112acb8:	4a4002a4 	muli	r9,r9,10
8112acbc:	54000044 	addi	r16,r10,1
8112acc0:	8015883a 	mov	r10,r16
8112acc4:	4893883a 	add	r9,r9,r2
8112acc8:	18bff404 	addi	r2,r3,-48
8112accc:	30bff92e 	bgeu	r6,r2,8112acb4 <__reset+0xfb10acb4>
8112acd0:	483da30e 	bge	r9,zero,8112a360 <__reset+0xfb10a360>
8112acd4:	027fffc4 	movi	r9,-1
8112acd8:	003da106 	br	8112a360 <__reset+0xfb10a360>
8112acdc:	a5001014 	ori	r20,r20,64
8112ace0:	80c00007 	ldb	r3,0(r16)
8112ace4:	003d9d06 	br	8112a35c <__reset+0xfb10a35c>
8112ace8:	da802217 	ldw	r10,136(sp)
8112acec:	d8001d85 	stb	zero,118(sp)
8112acf0:	50c00204 	addi	r3,r10,8
8112acf4:	54800017 	ldw	r18,0(r10)
8112acf8:	54c00117 	ldw	r19,4(r10)
8112acfc:	4801ca16 	blt	r9,zero,8112b428 <___vfiprintf_internal_r+0x1250>
8112ad00:	013fdfc4 	movi	r4,-129
8112ad04:	94c4b03a 	or	r2,r18,r19
8112ad08:	d8c02215 	stw	r3,136(sp)
8112ad0c:	a128703a 	and	r20,r20,r4
8112ad10:	0039883a 	mov	fp,zero
8112ad14:	103f341e 	bne	r2,zero,8112a9e8 <__reset+0xfb10a9e8>
8112ad18:	483e2e26 	beq	r9,zero,8112a5d4 <__reset+0xfb10a5d4>
8112ad1c:	0025883a 	mov	r18,zero
8112ad20:	94800c04 	addi	r18,r18,48
8112ad24:	dc8019c5 	stb	r18,103(sp)
8112ad28:	dcc02717 	ldw	r19,156(sp)
8112ad2c:	dd4019c4 	addi	r21,sp,103
8112ad30:	003e2b06 	br	8112a5e0 <__reset+0xfb10a5e0>
8112ad34:	21003fcc 	andi	r4,r4,255
8112ad38:	2002361e 	bne	r4,zero,8112b614 <___vfiprintf_internal_r+0x143c>
8112ad3c:	1801c126 	beq	r3,zero,8112b444 <___vfiprintf_internal_r+0x126c>
8112ad40:	04800044 	movi	r18,1
8112ad44:	d8c01005 	stb	r3,64(sp)
8112ad48:	d8001d85 	stb	zero,118(sp)
8112ad4c:	9027883a 	mov	r19,r18
8112ad50:	dd401004 	addi	r21,sp,64
8112ad54:	003f1106 	br	8112a99c <__reset+0xfb10a99c>
8112ad58:	d9402117 	ldw	r5,132(sp)
8112ad5c:	d9002017 	ldw	r4,128(sp)
8112ad60:	d9801a04 	addi	r6,sp,104
8112ad64:	d9c02b15 	stw	r7,172(sp)
8112ad68:	dbc02a15 	stw	r15,168(sp)
8112ad6c:	112a0bc0 	call	8112a0bc <__sprint_r.part.0>
8112ad70:	d9c02b17 	ldw	r7,172(sp)
8112ad74:	dbc02a17 	ldw	r15,168(sp)
8112ad78:	10006d1e 	bne	r2,zero,8112af30 <___vfiprintf_internal_r+0xd58>
8112ad7c:	d9801b17 	ldw	r6,108(sp)
8112ad80:	d8801c17 	ldw	r2,112(sp)
8112ad84:	d811883a 	mov	r8,sp
8112ad88:	31400044 	addi	r5,r6,1
8112ad8c:	003e3306 	br	8112a65c <__reset+0xfb10a65c>
8112ad90:	d9401b17 	ldw	r5,108(sp)
8112ad94:	d8801c17 	ldw	r2,112(sp)
8112ad98:	29000044 	addi	r4,r5,1
8112ad9c:	d8c01d87 	ldb	r3,118(sp)
8112ada0:	183e4d26 	beq	r3,zero,8112a6d8 <__reset+0xfb10a6d8>
8112ada4:	00c00044 	movi	r3,1
8112ada8:	d9401d84 	addi	r5,sp,118
8112adac:	10c5883a 	add	r2,r2,r3
8112adb0:	41400015 	stw	r5,0(r8)
8112adb4:	40c00115 	stw	r3,4(r8)
8112adb8:	d8801c15 	stw	r2,112(sp)
8112adbc:	d9001b15 	stw	r4,108(sp)
8112adc0:	014001c4 	movi	r5,7
8112adc4:	2900a90e 	bge	r5,r4,8112b06c <___vfiprintf_internal_r+0xe94>
8112adc8:	1000da1e 	bne	r2,zero,8112b134 <___vfiprintf_internal_r+0xf5c>
8112adcc:	7000ab1e 	bne	r14,zero,8112b07c <___vfiprintf_internal_r+0xea4>
8112add0:	000b883a 	mov	r5,zero
8112add4:	1809883a 	mov	r4,r3
8112add8:	d811883a 	mov	r8,sp
8112addc:	00c02004 	movi	r3,128
8112ade0:	e0fe4d26 	beq	fp,r3,8112a718 <__reset+0xfb10a718>
8112ade4:	4cf9c83a 	sub	fp,r9,r19
8112ade8:	073e7b0e 	bge	zero,fp,8112a7d8 <__reset+0xfb10a7d8>
8112adec:	01c00404 	movi	r7,16
8112adf0:	3f01900e 	bge	r7,fp,8112b434 <___vfiprintf_internal_r+0x125c>
8112adf4:	00e04534 	movhi	r3,33044
8112adf8:	18d4d204 	addi	r3,r3,21320
8112adfc:	d8c02415 	stw	r3,144(sp)
8112ae00:	034001c4 	movi	r13,7
8112ae04:	00000506 	br	8112ae1c <___vfiprintf_internal_r+0xc44>
8112ae08:	29000084 	addi	r4,r5,2
8112ae0c:	42000204 	addi	r8,r8,8
8112ae10:	180b883a 	mov	r5,r3
8112ae14:	e73ffc04 	addi	fp,fp,-16
8112ae18:	3f000d0e 	bge	r7,fp,8112ae50 <___vfiprintf_internal_r+0xc78>
8112ae1c:	10800404 	addi	r2,r2,16
8112ae20:	28c00044 	addi	r3,r5,1
8112ae24:	45c00015 	stw	r23,0(r8)
8112ae28:	41c00115 	stw	r7,4(r8)
8112ae2c:	d8801c15 	stw	r2,112(sp)
8112ae30:	d8c01b15 	stw	r3,108(sp)
8112ae34:	68fff40e 	bge	r13,r3,8112ae08 <__reset+0xfb10ae08>
8112ae38:	1000101e 	bne	r2,zero,8112ae7c <___vfiprintf_internal_r+0xca4>
8112ae3c:	e73ffc04 	addi	fp,fp,-16
8112ae40:	01000044 	movi	r4,1
8112ae44:	000b883a 	mov	r5,zero
8112ae48:	d811883a 	mov	r8,sp
8112ae4c:	3f3ff316 	blt	r7,fp,8112ae1c <__reset+0xfb10ae1c>
8112ae50:	da802417 	ldw	r10,144(sp)
8112ae54:	1705883a 	add	r2,r2,fp
8112ae58:	47000115 	stw	fp,4(r8)
8112ae5c:	42800015 	stw	r10,0(r8)
8112ae60:	d8801c15 	stw	r2,112(sp)
8112ae64:	d9001b15 	stw	r4,108(sp)
8112ae68:	00c001c4 	movi	r3,7
8112ae6c:	19003616 	blt	r3,r4,8112af48 <___vfiprintf_internal_r+0xd70>
8112ae70:	42000204 	addi	r8,r8,8
8112ae74:	21000044 	addi	r4,r4,1
8112ae78:	003e5706 	br	8112a7d8 <__reset+0xfb10a7d8>
8112ae7c:	d9402117 	ldw	r5,132(sp)
8112ae80:	d9002017 	ldw	r4,128(sp)
8112ae84:	d9801a04 	addi	r6,sp,104
8112ae88:	d9c02b15 	stw	r7,172(sp)
8112ae8c:	db402a15 	stw	r13,168(sp)
8112ae90:	112a0bc0 	call	8112a0bc <__sprint_r.part.0>
8112ae94:	d9c02b17 	ldw	r7,172(sp)
8112ae98:	db402a17 	ldw	r13,168(sp)
8112ae9c:	1000241e 	bne	r2,zero,8112af30 <___vfiprintf_internal_r+0xd58>
8112aea0:	d9401b17 	ldw	r5,108(sp)
8112aea4:	d8801c17 	ldw	r2,112(sp)
8112aea8:	d811883a 	mov	r8,sp
8112aeac:	29000044 	addi	r4,r5,1
8112aeb0:	003fd806 	br	8112ae14 <__reset+0xfb10ae14>
8112aeb4:	d9401b17 	ldw	r5,108(sp)
8112aeb8:	00e04534 	movhi	r3,33044
8112aebc:	18d4d604 	addi	r3,r3,21336
8112aec0:	d8c02415 	stw	r3,144(sp)
8112aec4:	29400044 	addi	r5,r5,1
8112aec8:	d8c02417 	ldw	r3,144(sp)
8112aecc:	14c5883a 	add	r2,r2,r19
8112aed0:	44c00115 	stw	r19,4(r8)
8112aed4:	40c00015 	stw	r3,0(r8)
8112aed8:	d8801c15 	stw	r2,112(sp)
8112aedc:	d9401b15 	stw	r5,108(sp)
8112aee0:	00c001c4 	movi	r3,7
8112aee4:	1940070e 	bge	r3,r5,8112af04 <___vfiprintf_internal_r+0xd2c>
8112aee8:	103e4826 	beq	r2,zero,8112a80c <__reset+0xfb10a80c>
8112aeec:	d9402117 	ldw	r5,132(sp)
8112aef0:	d9002017 	ldw	r4,128(sp)
8112aef4:	d9801a04 	addi	r6,sp,104
8112aef8:	112a0bc0 	call	8112a0bc <__sprint_r.part.0>
8112aefc:	10000c1e 	bne	r2,zero,8112af30 <___vfiprintf_internal_r+0xd58>
8112af00:	d8801c17 	ldw	r2,112(sp)
8112af04:	8c80010e 	bge	r17,r18,8112af0c <___vfiprintf_internal_r+0xd34>
8112af08:	9023883a 	mov	r17,r18
8112af0c:	da802317 	ldw	r10,140(sp)
8112af10:	5455883a 	add	r10,r10,r17
8112af14:	da802315 	stw	r10,140(sp)
8112af18:	103e4126 	beq	r2,zero,8112a820 <__reset+0xfb10a820>
8112af1c:	d9402117 	ldw	r5,132(sp)
8112af20:	d9002017 	ldw	r4,128(sp)
8112af24:	d9801a04 	addi	r6,sp,104
8112af28:	112a0bc0 	call	8112a0bc <__sprint_r.part.0>
8112af2c:	103e3c26 	beq	r2,zero,8112a820 <__reset+0xfb10a820>
8112af30:	dd002117 	ldw	r20,132(sp)
8112af34:	a080030b 	ldhu	r2,12(r20)
8112af38:	1080100c 	andi	r2,r2,64
8112af3c:	1001231e 	bne	r2,zero,8112b3cc <___vfiprintf_internal_r+0x11f4>
8112af40:	d8802317 	ldw	r2,140(sp)
8112af44:	003d7b06 	br	8112a534 <__reset+0xfb10a534>
8112af48:	1000991e 	bne	r2,zero,8112b1b0 <___vfiprintf_internal_r+0xfd8>
8112af4c:	00c00044 	movi	r3,1
8112af50:	9805883a 	mov	r2,r19
8112af54:	dd400015 	stw	r21,0(sp)
8112af58:	dcc00115 	stw	r19,4(sp)
8112af5c:	dcc01c15 	stw	r19,112(sp)
8112af60:	d8c01b15 	stw	r3,108(sp)
8112af64:	d811883a 	mov	r8,sp
8112af68:	42000204 	addi	r8,r8,8
8112af6c:	a2c0010c 	andi	r11,r20,4
8112af70:	583fe426 	beq	r11,zero,8112af04 <__reset+0xfb10af04>
8112af74:	8ca7c83a 	sub	r19,r17,r18
8112af78:	04ffe20e 	bge	zero,r19,8112af04 <__reset+0xfb10af04>
8112af7c:	01c00404 	movi	r7,16
8112af80:	3cffcc0e 	bge	r7,r19,8112aeb4 <__reset+0xfb10aeb4>
8112af84:	02a04534 	movhi	r10,33044
8112af88:	5294d604 	addi	r10,r10,21336
8112af8c:	d9001b17 	ldw	r4,108(sp)
8112af90:	da802415 	stw	r10,144(sp)
8112af94:	382b883a 	mov	r21,r7
8112af98:	050001c4 	movi	r20,7
8112af9c:	df002017 	ldw	fp,128(sp)
8112afa0:	00000506 	br	8112afb8 <___vfiprintf_internal_r+0xde0>
8112afa4:	21400084 	addi	r5,r4,2
8112afa8:	42000204 	addi	r8,r8,8
8112afac:	1809883a 	mov	r4,r3
8112afb0:	9cfffc04 	addi	r19,r19,-16
8112afb4:	acffc40e 	bge	r21,r19,8112aec8 <__reset+0xfb10aec8>
8112afb8:	10800404 	addi	r2,r2,16
8112afbc:	20c00044 	addi	r3,r4,1
8112afc0:	45800015 	stw	r22,0(r8)
8112afc4:	45400115 	stw	r21,4(r8)
8112afc8:	d8801c15 	stw	r2,112(sp)
8112afcc:	d8c01b15 	stw	r3,108(sp)
8112afd0:	a0fff40e 	bge	r20,r3,8112afa4 <__reset+0xfb10afa4>
8112afd4:	1000041e 	bne	r2,zero,8112afe8 <___vfiprintf_internal_r+0xe10>
8112afd8:	01400044 	movi	r5,1
8112afdc:	0009883a 	mov	r4,zero
8112afe0:	d811883a 	mov	r8,sp
8112afe4:	003ff206 	br	8112afb0 <__reset+0xfb10afb0>
8112afe8:	d9402117 	ldw	r5,132(sp)
8112afec:	d9801a04 	addi	r6,sp,104
8112aff0:	e009883a 	mov	r4,fp
8112aff4:	112a0bc0 	call	8112a0bc <__sprint_r.part.0>
8112aff8:	103fcd1e 	bne	r2,zero,8112af30 <__reset+0xfb10af30>
8112affc:	d9001b17 	ldw	r4,108(sp)
8112b000:	d8801c17 	ldw	r2,112(sp)
8112b004:	d811883a 	mov	r8,sp
8112b008:	21400044 	addi	r5,r4,1
8112b00c:	003fe806 	br	8112afb0 <__reset+0xfb10afb0>
8112b010:	d9402117 	ldw	r5,132(sp)
8112b014:	d9002017 	ldw	r4,128(sp)
8112b018:	d9801a04 	addi	r6,sp,104
8112b01c:	d9c02b15 	stw	r7,172(sp)
8112b020:	db402a15 	stw	r13,168(sp)
8112b024:	112a0bc0 	call	8112a0bc <__sprint_r.part.0>
8112b028:	d9c02b17 	ldw	r7,172(sp)
8112b02c:	db402a17 	ldw	r13,168(sp)
8112b030:	103fbf1e 	bne	r2,zero,8112af30 <__reset+0xfb10af30>
8112b034:	d9401b17 	ldw	r5,108(sp)
8112b038:	d8801c17 	ldw	r2,112(sp)
8112b03c:	d811883a 	mov	r8,sp
8112b040:	29800044 	addi	r6,r5,1
8112b044:	003dc406 	br	8112a758 <__reset+0xfb10a758>
8112b048:	1000d21e 	bne	r2,zero,8112b394 <___vfiprintf_internal_r+0x11bc>
8112b04c:	d8c01d87 	ldb	r3,118(sp)
8112b050:	18009526 	beq	r3,zero,8112b2a8 <___vfiprintf_internal_r+0x10d0>
8112b054:	00800044 	movi	r2,1
8112b058:	d8c01d84 	addi	r3,sp,118
8112b05c:	1009883a 	mov	r4,r2
8112b060:	d8c00015 	stw	r3,0(sp)
8112b064:	d8800115 	stw	r2,4(sp)
8112b068:	d811883a 	mov	r8,sp
8112b06c:	200b883a 	mov	r5,r4
8112b070:	42000204 	addi	r8,r8,8
8112b074:	21000044 	addi	r4,r4,1
8112b078:	003d9706 	br	8112a6d8 <__reset+0xfb10a6d8>
8112b07c:	d9001d04 	addi	r4,sp,116
8112b080:	00800084 	movi	r2,2
8112b084:	d9000015 	stw	r4,0(sp)
8112b088:	d8800115 	stw	r2,4(sp)
8112b08c:	1809883a 	mov	r4,r3
8112b090:	d811883a 	mov	r8,sp
8112b094:	200b883a 	mov	r5,r4
8112b098:	42000204 	addi	r8,r8,8
8112b09c:	21000044 	addi	r4,r4,1
8112b0a0:	003f4e06 	br	8112addc <__reset+0xfb10addc>
8112b0a4:	d8001d85 	stb	zero,118(sp)
8112b0a8:	48005016 	blt	r9,zero,8112b1ec <___vfiprintf_internal_r+0x1014>
8112b0ac:	00ffdfc4 	movi	r3,-129
8112b0b0:	94c4b03a 	or	r2,r18,r19
8112b0b4:	a0e8703a 	and	r20,r20,r3
8112b0b8:	103d4426 	beq	r2,zero,8112a5cc <__reset+0xfb10a5cc>
8112b0bc:	0039883a 	mov	fp,zero
8112b0c0:	d9002617 	ldw	r4,152(sp)
8112b0c4:	dd401a04 	addi	r21,sp,104
8112b0c8:	908003cc 	andi	r2,r18,15
8112b0cc:	9806973a 	slli	r3,r19,28
8112b0d0:	2085883a 	add	r2,r4,r2
8112b0d4:	9024d13a 	srli	r18,r18,4
8112b0d8:	10800003 	ldbu	r2,0(r2)
8112b0dc:	9826d13a 	srli	r19,r19,4
8112b0e0:	ad7fffc4 	addi	r21,r21,-1
8112b0e4:	1ca4b03a 	or	r18,r3,r18
8112b0e8:	a8800005 	stb	r2,0(r21)
8112b0ec:	94c4b03a 	or	r2,r18,r19
8112b0f0:	103ff51e 	bne	r2,zero,8112b0c8 <__reset+0xfb10b0c8>
8112b0f4:	003e5906 	br	8112aa5c <__reset+0xfb10aa5c>
8112b0f8:	d9402117 	ldw	r5,132(sp)
8112b0fc:	d9002017 	ldw	r4,128(sp)
8112b100:	d9801a04 	addi	r6,sp,104
8112b104:	112a0bc0 	call	8112a0bc <__sprint_r.part.0>
8112b108:	103f891e 	bne	r2,zero,8112af30 <__reset+0xfb10af30>
8112b10c:	d8801c17 	ldw	r2,112(sp)
8112b110:	d811883a 	mov	r8,sp
8112b114:	003f9506 	br	8112af6c <__reset+0xfb10af6c>
8112b118:	d9402117 	ldw	r5,132(sp)
8112b11c:	d9002017 	ldw	r4,128(sp)
8112b120:	d9801a04 	addi	r6,sp,104
8112b124:	112a0bc0 	call	8112a0bc <__sprint_r.part.0>
8112b128:	103f811e 	bne	r2,zero,8112af30 <__reset+0xfb10af30>
8112b12c:	d811883a 	mov	r8,sp
8112b130:	003ced06 	br	8112a4e8 <__reset+0xfb10a4e8>
8112b134:	d9402117 	ldw	r5,132(sp)
8112b138:	d9002017 	ldw	r4,128(sp)
8112b13c:	d9801a04 	addi	r6,sp,104
8112b140:	da402c15 	stw	r9,176(sp)
8112b144:	db802a15 	stw	r14,168(sp)
8112b148:	112a0bc0 	call	8112a0bc <__sprint_r.part.0>
8112b14c:	da402c17 	ldw	r9,176(sp)
8112b150:	db802a17 	ldw	r14,168(sp)
8112b154:	103f761e 	bne	r2,zero,8112af30 <__reset+0xfb10af30>
8112b158:	d9401b17 	ldw	r5,108(sp)
8112b15c:	d8801c17 	ldw	r2,112(sp)
8112b160:	d811883a 	mov	r8,sp
8112b164:	29000044 	addi	r4,r5,1
8112b168:	003d5b06 	br	8112a6d8 <__reset+0xfb10a6d8>
8112b16c:	d9402117 	ldw	r5,132(sp)
8112b170:	d9002017 	ldw	r4,128(sp)
8112b174:	d9801a04 	addi	r6,sp,104
8112b178:	da402c15 	stw	r9,176(sp)
8112b17c:	112a0bc0 	call	8112a0bc <__sprint_r.part.0>
8112b180:	da402c17 	ldw	r9,176(sp)
8112b184:	103f6a1e 	bne	r2,zero,8112af30 <__reset+0xfb10af30>
8112b188:	d9401b17 	ldw	r5,108(sp)
8112b18c:	d8801c17 	ldw	r2,112(sp)
8112b190:	d811883a 	mov	r8,sp
8112b194:	29000044 	addi	r4,r5,1
8112b198:	003f1006 	br	8112addc <__reset+0xfb10addc>
8112b19c:	1000c31e 	bne	r2,zero,8112b4ac <___vfiprintf_internal_r+0x12d4>
8112b1a0:	01000044 	movi	r4,1
8112b1a4:	000b883a 	mov	r5,zero
8112b1a8:	d811883a 	mov	r8,sp
8112b1ac:	003f0d06 	br	8112ade4 <__reset+0xfb10ade4>
8112b1b0:	d9402117 	ldw	r5,132(sp)
8112b1b4:	d9002017 	ldw	r4,128(sp)
8112b1b8:	d9801a04 	addi	r6,sp,104
8112b1bc:	112a0bc0 	call	8112a0bc <__sprint_r.part.0>
8112b1c0:	103f5b1e 	bne	r2,zero,8112af30 <__reset+0xfb10af30>
8112b1c4:	d9001b17 	ldw	r4,108(sp)
8112b1c8:	d8801c17 	ldw	r2,112(sp)
8112b1cc:	d811883a 	mov	r8,sp
8112b1d0:	21000044 	addi	r4,r4,1
8112b1d4:	003d8006 	br	8112a7d8 <__reset+0xfb10a7d8>
8112b1d8:	01204534 	movhi	r4,33044
8112b1dc:	21143f04 	addi	r4,r4,20732
8112b1e0:	d9002615 	stw	r4,152(sp)
8112b1e4:	d8c02215 	stw	r3,136(sp)
8112b1e8:	1029883a 	mov	r20,r2
8112b1ec:	94c4b03a 	or	r2,r18,r19
8112b1f0:	103fb21e 	bne	r2,zero,8112b0bc <__reset+0xfb10b0bc>
8112b1f4:	0039883a 	mov	fp,zero
8112b1f8:	00800084 	movi	r2,2
8112b1fc:	003e6b06 	br	8112abac <__reset+0xfb10abac>
8112b200:	da802217 	ldw	r10,136(sp)
8112b204:	d8001d85 	stb	zero,118(sp)
8112b208:	0027883a 	mov	r19,zero
8112b20c:	50800104 	addi	r2,r10,4
8112b210:	54800017 	ldw	r18,0(r10)
8112b214:	483e6016 	blt	r9,zero,8112ab98 <__reset+0xfb10ab98>
8112b218:	00ffdfc4 	movi	r3,-129
8112b21c:	d8802215 	stw	r2,136(sp)
8112b220:	a0e8703a 	and	r20,r20,r3
8112b224:	0039883a 	mov	fp,zero
8112b228:	903ebb26 	beq	r18,zero,8112ad18 <__reset+0xfb10ad18>
8112b22c:	00800244 	movi	r2,9
8112b230:	14bdee36 	bltu	r2,r18,8112a9ec <__reset+0xfb10a9ec>
8112b234:	003eba06 	br	8112ad20 <__reset+0xfb10ad20>
8112b238:	00800c04 	movi	r2,48
8112b23c:	d8c01d45 	stb	r3,117(sp)
8112b240:	d8801d05 	stb	r2,116(sp)
8112b244:	d8001d85 	stb	zero,118(sp)
8112b248:	a0c00094 	ori	r3,r20,2
8112b24c:	4800a916 	blt	r9,zero,8112b4f4 <___vfiprintf_internal_r+0x131c>
8112b250:	00bfdfc4 	movi	r2,-129
8112b254:	a096703a 	and	r11,r20,r2
8112b258:	5d000094 	ori	r20,r11,2
8112b25c:	0039883a 	mov	fp,zero
8112b260:	003f9706 	br	8112b0c0 <__reset+0xfb10b0c0>
8112b264:	8025883a 	mov	r18,r16
8112b268:	003c2e06 	br	8112a324 <__reset+0xfb10a324>
8112b26c:	00a04534 	movhi	r2,33044
8112b270:	10943f04 	addi	r2,r2,20732
8112b274:	0039883a 	mov	fp,zero
8112b278:	d8802615 	stw	r2,152(sp)
8112b27c:	003f9006 	br	8112b0c0 <__reset+0xfb10b0c0>
8112b280:	04a5c83a 	sub	r18,zero,r18
8112b284:	07000b44 	movi	fp,45
8112b288:	9004c03a 	cmpne	r2,r18,zero
8112b28c:	04e7c83a 	sub	r19,zero,r19
8112b290:	df001d85 	stb	fp,118(sp)
8112b294:	98a7c83a 	sub	r19,r19,r2
8112b298:	48009f16 	blt	r9,zero,8112b518 <___vfiprintf_internal_r+0x1340>
8112b29c:	00bfdfc4 	movi	r2,-129
8112b2a0:	a0a8703a 	and	r20,r20,r2
8112b2a4:	003dd006 	br	8112a9e8 <__reset+0xfb10a9e8>
8112b2a8:	70004c26 	beq	r14,zero,8112b3dc <___vfiprintf_internal_r+0x1204>
8112b2ac:	00800084 	movi	r2,2
8112b2b0:	d8c01d04 	addi	r3,sp,116
8112b2b4:	d8c00015 	stw	r3,0(sp)
8112b2b8:	d8800115 	stw	r2,4(sp)
8112b2bc:	01000044 	movi	r4,1
8112b2c0:	d811883a 	mov	r8,sp
8112b2c4:	003f7306 	br	8112b094 <__reset+0xfb10b094>
8112b2c8:	a080100c 	andi	r2,r20,64
8112b2cc:	da802217 	ldw	r10,136(sp)
8112b2d0:	103e0626 	beq	r2,zero,8112aaec <__reset+0xfb10aaec>
8112b2d4:	5480000f 	ldh	r18,0(r10)
8112b2d8:	52800104 	addi	r10,r10,4
8112b2dc:	da802215 	stw	r10,136(sp)
8112b2e0:	9027d7fa 	srai	r19,r18,31
8112b2e4:	9805883a 	mov	r2,r19
8112b2e8:	003db806 	br	8112a9cc <__reset+0xfb10a9cc>
8112b2ec:	a080040c 	andi	r2,r20,16
8112b2f0:	1000091e 	bne	r2,zero,8112b318 <___vfiprintf_internal_r+0x1140>
8112b2f4:	a2c0100c 	andi	r11,r20,64
8112b2f8:	58000726 	beq	r11,zero,8112b318 <___vfiprintf_internal_r+0x1140>
8112b2fc:	da802217 	ldw	r10,136(sp)
8112b300:	50800017 	ldw	r2,0(r10)
8112b304:	52800104 	addi	r10,r10,4
8112b308:	da802215 	stw	r10,136(sp)
8112b30c:	da802317 	ldw	r10,140(sp)
8112b310:	1280000d 	sth	r10,0(r2)
8112b314:	003be706 	br	8112a2b4 <__reset+0xfb10a2b4>
8112b318:	da802217 	ldw	r10,136(sp)
8112b31c:	50800017 	ldw	r2,0(r10)
8112b320:	52800104 	addi	r10,r10,4
8112b324:	da802215 	stw	r10,136(sp)
8112b328:	da802317 	ldw	r10,140(sp)
8112b32c:	12800015 	stw	r10,0(r2)
8112b330:	003be006 	br	8112a2b4 <__reset+0xfb10a2b4>
8112b334:	a080100c 	andi	r2,r20,64
8112b338:	da802217 	ldw	r10,136(sp)
8112b33c:	10003026 	beq	r2,zero,8112b400 <___vfiprintf_internal_r+0x1228>
8112b340:	5480000b 	ldhu	r18,0(r10)
8112b344:	52800104 	addi	r10,r10,4
8112b348:	0027883a 	mov	r19,zero
8112b34c:	da802215 	stw	r10,136(sp)
8112b350:	003d8006 	br	8112a954 <__reset+0xfb10a954>
8112b354:	80c00007 	ldb	r3,0(r16)
8112b358:	003c0006 	br	8112a35c <__reset+0xfb10a35c>
8112b35c:	a080100c 	andi	r2,r20,64
8112b360:	d8001d85 	stb	zero,118(sp)
8112b364:	da802217 	ldw	r10,136(sp)
8112b368:	1000201e 	bne	r2,zero,8112b3ec <___vfiprintf_internal_r+0x1214>
8112b36c:	50800104 	addi	r2,r10,4
8112b370:	54800017 	ldw	r18,0(r10)
8112b374:	0027883a 	mov	r19,zero
8112b378:	483def0e 	bge	r9,zero,8112ab38 <__reset+0xfb10ab38>
8112b37c:	94c6b03a 	or	r3,r18,r19
8112b380:	d8802215 	stw	r2,136(sp)
8112b384:	183d4e1e 	bne	r3,zero,8112a8c0 <__reset+0xfb10a8c0>
8112b388:	0039883a 	mov	fp,zero
8112b38c:	0005883a 	mov	r2,zero
8112b390:	003e0606 	br	8112abac <__reset+0xfb10abac>
8112b394:	d9402117 	ldw	r5,132(sp)
8112b398:	d9002017 	ldw	r4,128(sp)
8112b39c:	d9801a04 	addi	r6,sp,104
8112b3a0:	da402c15 	stw	r9,176(sp)
8112b3a4:	db802a15 	stw	r14,168(sp)
8112b3a8:	112a0bc0 	call	8112a0bc <__sprint_r.part.0>
8112b3ac:	da402c17 	ldw	r9,176(sp)
8112b3b0:	db802a17 	ldw	r14,168(sp)
8112b3b4:	103ede1e 	bne	r2,zero,8112af30 <__reset+0xfb10af30>
8112b3b8:	d9401b17 	ldw	r5,108(sp)
8112b3bc:	d8801c17 	ldw	r2,112(sp)
8112b3c0:	d811883a 	mov	r8,sp
8112b3c4:	29000044 	addi	r4,r5,1
8112b3c8:	003e7406 	br	8112ad9c <__reset+0xfb10ad9c>
8112b3cc:	00bfffc4 	movi	r2,-1
8112b3d0:	003c5806 	br	8112a534 <__reset+0xfb10a534>
8112b3d4:	d811883a 	mov	r8,sp
8112b3d8:	003ee806 	br	8112af7c <__reset+0xfb10af7c>
8112b3dc:	000b883a 	mov	r5,zero
8112b3e0:	01000044 	movi	r4,1
8112b3e4:	d811883a 	mov	r8,sp
8112b3e8:	003e7c06 	br	8112addc <__reset+0xfb10addc>
8112b3ec:	50800104 	addi	r2,r10,4
8112b3f0:	5480000b 	ldhu	r18,0(r10)
8112b3f4:	0027883a 	mov	r19,zero
8112b3f8:	483dcf0e 	bge	r9,zero,8112ab38 <__reset+0xfb10ab38>
8112b3fc:	003fdf06 	br	8112b37c <__reset+0xfb10b37c>
8112b400:	54800017 	ldw	r18,0(r10)
8112b404:	52800104 	addi	r10,r10,4
8112b408:	0027883a 	mov	r19,zero
8112b40c:	da802215 	stw	r10,136(sp)
8112b410:	003d5006 	br	8112a954 <__reset+0xfb10a954>
8112b414:	50800104 	addi	r2,r10,4
8112b418:	5480000b 	ldhu	r18,0(r10)
8112b41c:	0027883a 	mov	r19,zero
8112b420:	483f7d0e 	bge	r9,zero,8112b218 <__reset+0xfb10b218>
8112b424:	003ddc06 	br	8112ab98 <__reset+0xfb10ab98>
8112b428:	d8c02215 	stw	r3,136(sp)
8112b42c:	0039883a 	mov	fp,zero
8112b430:	003ddb06 	br	8112aba0 <__reset+0xfb10aba0>
8112b434:	02a04534 	movhi	r10,33044
8112b438:	5294d204 	addi	r10,r10,21320
8112b43c:	da802415 	stw	r10,144(sp)
8112b440:	003e8306 	br	8112ae50 <__reset+0xfb10ae50>
8112b444:	d8801c17 	ldw	r2,112(sp)
8112b448:	dd002117 	ldw	r20,132(sp)
8112b44c:	103eb926 	beq	r2,zero,8112af34 <__reset+0xfb10af34>
8112b450:	d9002017 	ldw	r4,128(sp)
8112b454:	d9801a04 	addi	r6,sp,104
8112b458:	a00b883a 	mov	r5,r20
8112b45c:	112a0bc0 	call	8112a0bc <__sprint_r.part.0>
8112b460:	003eb406 	br	8112af34 <__reset+0xfb10af34>
8112b464:	80c00043 	ldbu	r3,1(r16)
8112b468:	a5000814 	ori	r20,r20,32
8112b46c:	84000044 	addi	r16,r16,1
8112b470:	18c03fcc 	andi	r3,r3,255
8112b474:	18c0201c 	xori	r3,r3,128
8112b478:	18ffe004 	addi	r3,r3,-128
8112b47c:	003bb706 	br	8112a35c <__reset+0xfb10a35c>
8112b480:	a809883a 	mov	r4,r21
8112b484:	d8c02a15 	stw	r3,168(sp)
8112b488:	da002b15 	stw	r8,172(sp)
8112b48c:	111b1180 	call	8111b118 <strlen>
8112b490:	d8c02a17 	ldw	r3,168(sp)
8112b494:	1027883a 	mov	r19,r2
8112b498:	df001d83 	ldbu	fp,118(sp)
8112b49c:	d8c02215 	stw	r3,136(sp)
8112b4a0:	0013883a 	mov	r9,zero
8112b4a4:	da002b17 	ldw	r8,172(sp)
8112b4a8:	003c4d06 	br	8112a5e0 <__reset+0xfb10a5e0>
8112b4ac:	d9402117 	ldw	r5,132(sp)
8112b4b0:	d9002017 	ldw	r4,128(sp)
8112b4b4:	d9801a04 	addi	r6,sp,104
8112b4b8:	da402c15 	stw	r9,176(sp)
8112b4bc:	112a0bc0 	call	8112a0bc <__sprint_r.part.0>
8112b4c0:	da402c17 	ldw	r9,176(sp)
8112b4c4:	103e9a1e 	bne	r2,zero,8112af30 <__reset+0xfb10af30>
8112b4c8:	d9401b17 	ldw	r5,108(sp)
8112b4cc:	d8801c17 	ldw	r2,112(sp)
8112b4d0:	d811883a 	mov	r8,sp
8112b4d4:	29000044 	addi	r4,r5,1
8112b4d8:	003e4206 	br	8112ade4 <__reset+0xfb10ade4>
8112b4dc:	d9401b17 	ldw	r5,108(sp)
8112b4e0:	01204534 	movhi	r4,33044
8112b4e4:	2114d604 	addi	r4,r4,21336
8112b4e8:	d9002415 	stw	r4,144(sp)
8112b4ec:	29400044 	addi	r5,r5,1
8112b4f0:	003c6d06 	br	8112a6a8 <__reset+0xfb10a6a8>
8112b4f4:	0039883a 	mov	fp,zero
8112b4f8:	00800084 	movi	r2,2
8112b4fc:	10803fcc 	andi	r2,r2,255
8112b500:	01000044 	movi	r4,1
8112b504:	11001e26 	beq	r2,r4,8112b580 <___vfiprintf_internal_r+0x13a8>
8112b508:	01000084 	movi	r4,2
8112b50c:	11001e1e 	bne	r2,r4,8112b588 <___vfiprintf_internal_r+0x13b0>
8112b510:	1829883a 	mov	r20,r3
8112b514:	003eea06 	br	8112b0c0 <__reset+0xfb10b0c0>
8112b518:	a007883a 	mov	r3,r20
8112b51c:	00800044 	movi	r2,1
8112b520:	003ff606 	br	8112b4fc <__reset+0xfb10b4fc>
8112b524:	00800184 	movi	r2,6
8112b528:	1240012e 	bgeu	r2,r9,8112b530 <___vfiprintf_internal_r+0x1358>
8112b52c:	1013883a 	mov	r9,r2
8112b530:	4827883a 	mov	r19,r9
8112b534:	4825883a 	mov	r18,r9
8112b538:	48001516 	blt	r9,zero,8112b590 <___vfiprintf_internal_r+0x13b8>
8112b53c:	05604534 	movhi	r21,33044
8112b540:	d8c02215 	stw	r3,136(sp)
8112b544:	ad544404 	addi	r21,r21,20752
8112b548:	003d1406 	br	8112a99c <__reset+0xfb10a99c>
8112b54c:	02a04534 	movhi	r10,33044
8112b550:	5294d204 	addi	r10,r10,21320
8112b554:	da802415 	stw	r10,144(sp)
8112b558:	200d883a 	mov	r6,r4
8112b55c:	003c9106 	br	8112a7a4 <__reset+0xfb10a7a4>
8112b560:	5021883a 	mov	r16,r10
8112b564:	0013883a 	mov	r9,zero
8112b568:	003b7d06 	br	8112a360 <__reset+0xfb10a360>
8112b56c:	4827883a 	mov	r19,r9
8112b570:	df001d83 	ldbu	fp,118(sp)
8112b574:	d8c02215 	stw	r3,136(sp)
8112b578:	0013883a 	mov	r9,zero
8112b57c:	003c1806 	br	8112a5e0 <__reset+0xfb10a5e0>
8112b580:	1829883a 	mov	r20,r3
8112b584:	003d1806 	br	8112a9e8 <__reset+0xfb10a9e8>
8112b588:	1829883a 	mov	r20,r3
8112b58c:	003ccd06 	br	8112a8c4 <__reset+0xfb10a8c4>
8112b590:	0025883a 	mov	r18,zero
8112b594:	003fe906 	br	8112b53c <__reset+0xfb10b53c>
8112b598:	d8802217 	ldw	r2,136(sp)
8112b59c:	80c00043 	ldbu	r3,1(r16)
8112b5a0:	5021883a 	mov	r16,r10
8112b5a4:	12400017 	ldw	r9,0(r2)
8112b5a8:	10800104 	addi	r2,r2,4
8112b5ac:	d8802215 	stw	r2,136(sp)
8112b5b0:	483faf0e 	bge	r9,zero,8112b470 <__reset+0xfb10b470>
8112b5b4:	18c03fcc 	andi	r3,r3,255
8112b5b8:	18c0201c 	xori	r3,r3,128
8112b5bc:	027fffc4 	movi	r9,-1
8112b5c0:	18ffe004 	addi	r3,r3,-128
8112b5c4:	003b6506 	br	8112a35c <__reset+0xfb10a35c>
8112b5c8:	d9c01d85 	stb	r7,118(sp)
8112b5cc:	003ca006 	br	8112a850 <__reset+0xfb10a850>
8112b5d0:	d9c01d85 	stb	r7,118(sp)
8112b5d4:	003cad06 	br	8112a88c <__reset+0xfb10a88c>
8112b5d8:	d9c01d85 	stb	r7,118(sp)
8112b5dc:	003d7d06 	br	8112abd4 <__reset+0xfb10abd4>
8112b5e0:	d9c01d85 	stb	r7,118(sp)
8112b5e4:	003d5f06 	br	8112ab64 <__reset+0xfb10ab64>
8112b5e8:	a080004c 	andi	r2,r20,1
8112b5ec:	0039883a 	mov	fp,zero
8112b5f0:	10000526 	beq	r2,zero,8112b608 <___vfiprintf_internal_r+0x1430>
8112b5f4:	00800c04 	movi	r2,48
8112b5f8:	d88019c5 	stb	r2,103(sp)
8112b5fc:	dcc02717 	ldw	r19,156(sp)
8112b600:	dd4019c4 	addi	r21,sp,103
8112b604:	003bf606 	br	8112a5e0 <__reset+0xfb10a5e0>
8112b608:	0027883a 	mov	r19,zero
8112b60c:	dd401a04 	addi	r21,sp,104
8112b610:	003bf306 	br	8112a5e0 <__reset+0xfb10a5e0>
8112b614:	d9c01d85 	stb	r7,118(sp)
8112b618:	003dc806 	br	8112ad3c <__reset+0xfb10ad3c>
8112b61c:	d9c01d85 	stb	r7,118(sp)
8112b620:	003d3a06 	br	8112ab0c <__reset+0xfb10ab0c>
8112b624:	d9c01d85 	stb	r7,118(sp)
8112b628:	003d2a06 	br	8112aad4 <__reset+0xfb10aad4>
8112b62c:	d9c01d85 	stb	r7,118(sp)
8112b630:	003cde06 	br	8112a9ac <__reset+0xfb10a9ac>
8112b634:	d9c01d85 	stb	r7,118(sp)
8112b638:	003cbc06 	br	8112a92c <__reset+0xfb10a92c>

8112b63c <__vfiprintf_internal>:
8112b63c:	00a04534 	movhi	r2,33044
8112b640:	109e0f04 	addi	r2,r2,30780
8112b644:	300f883a 	mov	r7,r6
8112b648:	280d883a 	mov	r6,r5
8112b64c:	200b883a 	mov	r5,r4
8112b650:	11000017 	ldw	r4,0(r2)
8112b654:	112a1d81 	jmpi	8112a1d8 <___vfiprintf_internal_r>

8112b658 <__sbprintf>:
8112b658:	defee204 	addi	sp,sp,-1144
8112b65c:	de00012e 	bgeu	sp,et,8112b664 <__sbprintf+0xc>
8112b660:	003b68fa 	trap	3
8112b664:	2880030b 	ldhu	r2,12(r5)
8112b668:	2ac01917 	ldw	r11,100(r5)
8112b66c:	2a80038b 	ldhu	r10,14(r5)
8112b670:	2a400717 	ldw	r9,28(r5)
8112b674:	2a000917 	ldw	r8,36(r5)
8112b678:	00c10004 	movi	r3,1024
8112b67c:	dc011a15 	stw	r16,1128(sp)
8112b680:	10bfff4c 	andi	r2,r2,65533
8112b684:	2821883a 	mov	r16,r5
8112b688:	d8cb883a 	add	r5,sp,r3
8112b68c:	dc811c15 	stw	r18,1136(sp)
8112b690:	dc411b15 	stw	r17,1132(sp)
8112b694:	dfc11d15 	stw	ra,1140(sp)
8112b698:	2025883a 	mov	r18,r4
8112b69c:	d881030d 	sth	r2,1036(sp)
8112b6a0:	dac11915 	stw	r11,1124(sp)
8112b6a4:	da81038d 	sth	r10,1038(sp)
8112b6a8:	da410715 	stw	r9,1052(sp)
8112b6ac:	da010915 	stw	r8,1060(sp)
8112b6b0:	dec10015 	stw	sp,1024(sp)
8112b6b4:	dec10415 	stw	sp,1040(sp)
8112b6b8:	d8c10215 	stw	r3,1032(sp)
8112b6bc:	d8c10515 	stw	r3,1044(sp)
8112b6c0:	d8010615 	stw	zero,1048(sp)
8112b6c4:	112a1d80 	call	8112a1d8 <___vfiprintf_internal_r>
8112b6c8:	1023883a 	mov	r17,r2
8112b6cc:	10000416 	blt	r2,zero,8112b6e0 <__sbprintf+0x88>
8112b6d0:	d9410004 	addi	r5,sp,1024
8112b6d4:	9009883a 	mov	r4,r18
8112b6d8:	11230d00 	call	811230d0 <_fflush_r>
8112b6dc:	10000d1e 	bne	r2,zero,8112b714 <__sbprintf+0xbc>
8112b6e0:	d881030b 	ldhu	r2,1036(sp)
8112b6e4:	1080100c 	andi	r2,r2,64
8112b6e8:	10000326 	beq	r2,zero,8112b6f8 <__sbprintf+0xa0>
8112b6ec:	8080030b 	ldhu	r2,12(r16)
8112b6f0:	10801014 	ori	r2,r2,64
8112b6f4:	8080030d 	sth	r2,12(r16)
8112b6f8:	8805883a 	mov	r2,r17
8112b6fc:	dfc11d17 	ldw	ra,1140(sp)
8112b700:	dc811c17 	ldw	r18,1136(sp)
8112b704:	dc411b17 	ldw	r17,1132(sp)
8112b708:	dc011a17 	ldw	r16,1128(sp)
8112b70c:	dec11e04 	addi	sp,sp,1144
8112b710:	f800283a 	ret
8112b714:	047fffc4 	movi	r17,-1
8112b718:	003ff106 	br	8112b6e0 <__reset+0xfb10b6e0>

8112b71c <_write_r>:
8112b71c:	defffd04 	addi	sp,sp,-12
8112b720:	de00012e 	bgeu	sp,et,8112b728 <_write_r+0xc>
8112b724:	003b68fa 	trap	3
8112b728:	2805883a 	mov	r2,r5
8112b72c:	dc000015 	stw	r16,0(sp)
8112b730:	04204534 	movhi	r16,33044
8112b734:	dc400115 	stw	r17,4(sp)
8112b738:	300b883a 	mov	r5,r6
8112b73c:	841e8704 	addi	r16,r16,31260
8112b740:	2023883a 	mov	r17,r4
8112b744:	380d883a 	mov	r6,r7
8112b748:	1009883a 	mov	r4,r2
8112b74c:	dfc00215 	stw	ra,8(sp)
8112b750:	80000015 	stw	zero,0(r16)
8112b754:	11308f40 	call	811308f4 <write>
8112b758:	00ffffc4 	movi	r3,-1
8112b75c:	10c00526 	beq	r2,r3,8112b774 <_write_r+0x58>
8112b760:	dfc00217 	ldw	ra,8(sp)
8112b764:	dc400117 	ldw	r17,4(sp)
8112b768:	dc000017 	ldw	r16,0(sp)
8112b76c:	dec00304 	addi	sp,sp,12
8112b770:	f800283a 	ret
8112b774:	80c00017 	ldw	r3,0(r16)
8112b778:	183ff926 	beq	r3,zero,8112b760 <__reset+0xfb10b760>
8112b77c:	88c00015 	stw	r3,0(r17)
8112b780:	003ff706 	br	8112b760 <__reset+0xfb10b760>

8112b784 <_close_r>:
8112b784:	defffd04 	addi	sp,sp,-12
8112b788:	de00012e 	bgeu	sp,et,8112b790 <_close_r+0xc>
8112b78c:	003b68fa 	trap	3
8112b790:	dc000015 	stw	r16,0(sp)
8112b794:	04204534 	movhi	r16,33044
8112b798:	dc400115 	stw	r17,4(sp)
8112b79c:	841e8704 	addi	r16,r16,31260
8112b7a0:	2023883a 	mov	r17,r4
8112b7a4:	2809883a 	mov	r4,r5
8112b7a8:	dfc00215 	stw	ra,8(sp)
8112b7ac:	80000015 	stw	zero,0(r16)
8112b7b0:	112f0e00 	call	8112f0e0 <close>
8112b7b4:	00ffffc4 	movi	r3,-1
8112b7b8:	10c00526 	beq	r2,r3,8112b7d0 <_close_r+0x4c>
8112b7bc:	dfc00217 	ldw	ra,8(sp)
8112b7c0:	dc400117 	ldw	r17,4(sp)
8112b7c4:	dc000017 	ldw	r16,0(sp)
8112b7c8:	dec00304 	addi	sp,sp,12
8112b7cc:	f800283a 	ret
8112b7d0:	80c00017 	ldw	r3,0(r16)
8112b7d4:	183ff926 	beq	r3,zero,8112b7bc <__reset+0xfb10b7bc>
8112b7d8:	88c00015 	stw	r3,0(r17)
8112b7dc:	003ff706 	br	8112b7bc <__reset+0xfb10b7bc>

8112b7e0 <_calloc_r>:
8112b7e0:	298b383a 	mul	r5,r5,r6
8112b7e4:	defffe04 	addi	sp,sp,-8
8112b7e8:	de00012e 	bgeu	sp,et,8112b7f0 <_calloc_r+0x10>
8112b7ec:	003b68fa 	trap	3
8112b7f0:	dfc00115 	stw	ra,4(sp)
8112b7f4:	dc000015 	stw	r16,0(sp)
8112b7f8:	11245040 	call	81124504 <_malloc_r>
8112b7fc:	10002926 	beq	r2,zero,8112b8a4 <_calloc_r+0xc4>
8112b800:	11bfff17 	ldw	r6,-4(r2)
8112b804:	1021883a 	mov	r16,r2
8112b808:	00bfff04 	movi	r2,-4
8112b80c:	308c703a 	and	r6,r6,r2
8112b810:	00c00904 	movi	r3,36
8112b814:	308d883a 	add	r6,r6,r2
8112b818:	19801636 	bltu	r3,r6,8112b874 <_calloc_r+0x94>
8112b81c:	008004c4 	movi	r2,19
8112b820:	11800b2e 	bgeu	r2,r6,8112b850 <_calloc_r+0x70>
8112b824:	80000015 	stw	zero,0(r16)
8112b828:	80000115 	stw	zero,4(r16)
8112b82c:	008006c4 	movi	r2,27
8112b830:	11801a2e 	bgeu	r2,r6,8112b89c <_calloc_r+0xbc>
8112b834:	80000215 	stw	zero,8(r16)
8112b838:	80000315 	stw	zero,12(r16)
8112b83c:	30c0151e 	bne	r6,r3,8112b894 <_calloc_r+0xb4>
8112b840:	80000415 	stw	zero,16(r16)
8112b844:	80800604 	addi	r2,r16,24
8112b848:	80000515 	stw	zero,20(r16)
8112b84c:	00000106 	br	8112b854 <_calloc_r+0x74>
8112b850:	8005883a 	mov	r2,r16
8112b854:	10000015 	stw	zero,0(r2)
8112b858:	10000115 	stw	zero,4(r2)
8112b85c:	10000215 	stw	zero,8(r2)
8112b860:	8005883a 	mov	r2,r16
8112b864:	dfc00117 	ldw	ra,4(sp)
8112b868:	dc000017 	ldw	r16,0(sp)
8112b86c:	dec00204 	addi	sp,sp,8
8112b870:	f800283a 	ret
8112b874:	000b883a 	mov	r5,zero
8112b878:	8009883a 	mov	r4,r16
8112b87c:	111acfc0 	call	8111acfc <memset>
8112b880:	8005883a 	mov	r2,r16
8112b884:	dfc00117 	ldw	ra,4(sp)
8112b888:	dc000017 	ldw	r16,0(sp)
8112b88c:	dec00204 	addi	sp,sp,8
8112b890:	f800283a 	ret
8112b894:	80800404 	addi	r2,r16,16
8112b898:	003fee06 	br	8112b854 <__reset+0xfb10b854>
8112b89c:	80800204 	addi	r2,r16,8
8112b8a0:	003fec06 	br	8112b854 <__reset+0xfb10b854>
8112b8a4:	0005883a 	mov	r2,zero
8112b8a8:	003fee06 	br	8112b864 <__reset+0xfb10b864>

8112b8ac <_fclose_r>:
8112b8ac:	28003b26 	beq	r5,zero,8112b99c <_fclose_r+0xf0>
8112b8b0:	defffc04 	addi	sp,sp,-16
8112b8b4:	de00012e 	bgeu	sp,et,8112b8bc <_fclose_r+0x10>
8112b8b8:	003b68fa 	trap	3
8112b8bc:	dc400115 	stw	r17,4(sp)
8112b8c0:	dc000015 	stw	r16,0(sp)
8112b8c4:	dfc00315 	stw	ra,12(sp)
8112b8c8:	dc800215 	stw	r18,8(sp)
8112b8cc:	2023883a 	mov	r17,r4
8112b8d0:	2821883a 	mov	r16,r5
8112b8d4:	20000226 	beq	r4,zero,8112b8e0 <_fclose_r+0x34>
8112b8d8:	20800e17 	ldw	r2,56(r4)
8112b8dc:	10002726 	beq	r2,zero,8112b97c <_fclose_r+0xd0>
8112b8e0:	8080030f 	ldh	r2,12(r16)
8112b8e4:	1000071e 	bne	r2,zero,8112b904 <_fclose_r+0x58>
8112b8e8:	0005883a 	mov	r2,zero
8112b8ec:	dfc00317 	ldw	ra,12(sp)
8112b8f0:	dc800217 	ldw	r18,8(sp)
8112b8f4:	dc400117 	ldw	r17,4(sp)
8112b8f8:	dc000017 	ldw	r16,0(sp)
8112b8fc:	dec00404 	addi	sp,sp,16
8112b900:	f800283a 	ret
8112b904:	800b883a 	mov	r5,r16
8112b908:	8809883a 	mov	r4,r17
8112b90c:	1122eac0 	call	81122eac <__sflush_r>
8112b910:	1025883a 	mov	r18,r2
8112b914:	80800b17 	ldw	r2,44(r16)
8112b918:	10000426 	beq	r2,zero,8112b92c <_fclose_r+0x80>
8112b91c:	81400717 	ldw	r5,28(r16)
8112b920:	8809883a 	mov	r4,r17
8112b924:	103ee83a 	callr	r2
8112b928:	10001616 	blt	r2,zero,8112b984 <_fclose_r+0xd8>
8112b92c:	8080030b 	ldhu	r2,12(r16)
8112b930:	1080200c 	andi	r2,r2,128
8112b934:	1000151e 	bne	r2,zero,8112b98c <_fclose_r+0xe0>
8112b938:	81400c17 	ldw	r5,48(r16)
8112b93c:	28000526 	beq	r5,zero,8112b954 <_fclose_r+0xa8>
8112b940:	80801004 	addi	r2,r16,64
8112b944:	28800226 	beq	r5,r2,8112b950 <_fclose_r+0xa4>
8112b948:	8809883a 	mov	r4,r17
8112b94c:	11238b80 	call	811238b8 <_free_r>
8112b950:	80000c15 	stw	zero,48(r16)
8112b954:	81401117 	ldw	r5,68(r16)
8112b958:	28000326 	beq	r5,zero,8112b968 <_fclose_r+0xbc>
8112b95c:	8809883a 	mov	r4,r17
8112b960:	11238b80 	call	811238b8 <_free_r>
8112b964:	80001115 	stw	zero,68(r16)
8112b968:	11234dc0 	call	811234dc <__sfp_lock_acquire>
8112b96c:	8000030d 	sth	zero,12(r16)
8112b970:	11234e00 	call	811234e0 <__sfp_lock_release>
8112b974:	9005883a 	mov	r2,r18
8112b978:	003fdc06 	br	8112b8ec <__reset+0xfb10b8ec>
8112b97c:	11234cc0 	call	811234cc <__sinit>
8112b980:	003fd706 	br	8112b8e0 <__reset+0xfb10b8e0>
8112b984:	04bfffc4 	movi	r18,-1
8112b988:	003fe806 	br	8112b92c <__reset+0xfb10b92c>
8112b98c:	81400417 	ldw	r5,16(r16)
8112b990:	8809883a 	mov	r4,r17
8112b994:	11238b80 	call	811238b8 <_free_r>
8112b998:	003fe706 	br	8112b938 <__reset+0xfb10b938>
8112b99c:	0005883a 	mov	r2,zero
8112b9a0:	f800283a 	ret

8112b9a4 <fclose>:
8112b9a4:	00a04534 	movhi	r2,33044
8112b9a8:	109e0f04 	addi	r2,r2,30780
8112b9ac:	200b883a 	mov	r5,r4
8112b9b0:	11000017 	ldw	r4,0(r2)
8112b9b4:	112b8ac1 	jmpi	8112b8ac <_fclose_r>

8112b9b8 <__fputwc>:
8112b9b8:	defff804 	addi	sp,sp,-32
8112b9bc:	de00012e 	bgeu	sp,et,8112b9c4 <__fputwc+0xc>
8112b9c0:	003b68fa 	trap	3
8112b9c4:	dcc00415 	stw	r19,16(sp)
8112b9c8:	dc800315 	stw	r18,12(sp)
8112b9cc:	dc000115 	stw	r16,4(sp)
8112b9d0:	dfc00715 	stw	ra,28(sp)
8112b9d4:	dd400615 	stw	r21,24(sp)
8112b9d8:	dd000515 	stw	r20,20(sp)
8112b9dc:	dc400215 	stw	r17,8(sp)
8112b9e0:	2027883a 	mov	r19,r4
8112b9e4:	2825883a 	mov	r18,r5
8112b9e8:	3021883a 	mov	r16,r6
8112b9ec:	11242ec0 	call	811242ec <__locale_mb_cur_max>
8112b9f0:	00c00044 	movi	r3,1
8112b9f4:	10c03e26 	beq	r2,r3,8112baf0 <__fputwc+0x138>
8112b9f8:	81c01704 	addi	r7,r16,92
8112b9fc:	900d883a 	mov	r6,r18
8112ba00:	d80b883a 	mov	r5,sp
8112ba04:	9809883a 	mov	r4,r19
8112ba08:	112cb2c0 	call	8112cb2c <_wcrtomb_r>
8112ba0c:	1029883a 	mov	r20,r2
8112ba10:	00bfffc4 	movi	r2,-1
8112ba14:	a0802026 	beq	r20,r2,8112ba98 <__fputwc+0xe0>
8112ba18:	d9400003 	ldbu	r5,0(sp)
8112ba1c:	a0001c26 	beq	r20,zero,8112ba90 <__fputwc+0xd8>
8112ba20:	0023883a 	mov	r17,zero
8112ba24:	05400284 	movi	r21,10
8112ba28:	00000906 	br	8112ba50 <__fputwc+0x98>
8112ba2c:	80800017 	ldw	r2,0(r16)
8112ba30:	11400005 	stb	r5,0(r2)
8112ba34:	80c00017 	ldw	r3,0(r16)
8112ba38:	18c00044 	addi	r3,r3,1
8112ba3c:	80c00015 	stw	r3,0(r16)
8112ba40:	8c400044 	addi	r17,r17,1
8112ba44:	dc45883a 	add	r2,sp,r17
8112ba48:	8d00112e 	bgeu	r17,r20,8112ba90 <__fputwc+0xd8>
8112ba4c:	11400003 	ldbu	r5,0(r2)
8112ba50:	80c00217 	ldw	r3,8(r16)
8112ba54:	18ffffc4 	addi	r3,r3,-1
8112ba58:	80c00215 	stw	r3,8(r16)
8112ba5c:	183ff30e 	bge	r3,zero,8112ba2c <__reset+0xfb10ba2c>
8112ba60:	80800617 	ldw	r2,24(r16)
8112ba64:	18801916 	blt	r3,r2,8112bacc <__fputwc+0x114>
8112ba68:	80800017 	ldw	r2,0(r16)
8112ba6c:	11400005 	stb	r5,0(r2)
8112ba70:	80800017 	ldw	r2,0(r16)
8112ba74:	10c00003 	ldbu	r3,0(r2)
8112ba78:	10800044 	addi	r2,r2,1
8112ba7c:	1d402326 	beq	r3,r21,8112bb0c <__fputwc+0x154>
8112ba80:	80800015 	stw	r2,0(r16)
8112ba84:	8c400044 	addi	r17,r17,1
8112ba88:	dc45883a 	add	r2,sp,r17
8112ba8c:	8d3fef36 	bltu	r17,r20,8112ba4c <__reset+0xfb10ba4c>
8112ba90:	9005883a 	mov	r2,r18
8112ba94:	00000406 	br	8112baa8 <__fputwc+0xf0>
8112ba98:	80c0030b 	ldhu	r3,12(r16)
8112ba9c:	a005883a 	mov	r2,r20
8112baa0:	18c01014 	ori	r3,r3,64
8112baa4:	80c0030d 	sth	r3,12(r16)
8112baa8:	dfc00717 	ldw	ra,28(sp)
8112baac:	dd400617 	ldw	r21,24(sp)
8112bab0:	dd000517 	ldw	r20,20(sp)
8112bab4:	dcc00417 	ldw	r19,16(sp)
8112bab8:	dc800317 	ldw	r18,12(sp)
8112babc:	dc400217 	ldw	r17,8(sp)
8112bac0:	dc000117 	ldw	r16,4(sp)
8112bac4:	dec00804 	addi	sp,sp,32
8112bac8:	f800283a 	ret
8112bacc:	800d883a 	mov	r6,r16
8112bad0:	29403fcc 	andi	r5,r5,255
8112bad4:	9809883a 	mov	r4,r19
8112bad8:	112c9cc0 	call	8112c9cc <__swbuf_r>
8112badc:	10bfffe0 	cmpeqi	r2,r2,-1
8112bae0:	10803fcc 	andi	r2,r2,255
8112bae4:	103fd626 	beq	r2,zero,8112ba40 <__reset+0xfb10ba40>
8112bae8:	00bfffc4 	movi	r2,-1
8112baec:	003fee06 	br	8112baa8 <__reset+0xfb10baa8>
8112baf0:	90ffffc4 	addi	r3,r18,-1
8112baf4:	01003f84 	movi	r4,254
8112baf8:	20ffbf36 	bltu	r4,r3,8112b9f8 <__reset+0xfb10b9f8>
8112bafc:	900b883a 	mov	r5,r18
8112bb00:	dc800005 	stb	r18,0(sp)
8112bb04:	1029883a 	mov	r20,r2
8112bb08:	003fc506 	br	8112ba20 <__reset+0xfb10ba20>
8112bb0c:	800d883a 	mov	r6,r16
8112bb10:	a80b883a 	mov	r5,r21
8112bb14:	9809883a 	mov	r4,r19
8112bb18:	112c9cc0 	call	8112c9cc <__swbuf_r>
8112bb1c:	10bfffe0 	cmpeqi	r2,r2,-1
8112bb20:	003fef06 	br	8112bae0 <__reset+0xfb10bae0>

8112bb24 <_fputwc_r>:
8112bb24:	3080030b 	ldhu	r2,12(r6)
8112bb28:	10c8000c 	andi	r3,r2,8192
8112bb2c:	1800051e 	bne	r3,zero,8112bb44 <_fputwc_r+0x20>
8112bb30:	30c01917 	ldw	r3,100(r6)
8112bb34:	10880014 	ori	r2,r2,8192
8112bb38:	3080030d 	sth	r2,12(r6)
8112bb3c:	18880014 	ori	r2,r3,8192
8112bb40:	30801915 	stw	r2,100(r6)
8112bb44:	112b9b81 	jmpi	8112b9b8 <__fputwc>

8112bb48 <fputwc>:
8112bb48:	00a04534 	movhi	r2,33044
8112bb4c:	defffc04 	addi	sp,sp,-16
8112bb50:	109e0f04 	addi	r2,r2,30780
8112bb54:	de00012e 	bgeu	sp,et,8112bb5c <fputwc+0x14>
8112bb58:	003b68fa 	trap	3
8112bb5c:	dc000115 	stw	r16,4(sp)
8112bb60:	14000017 	ldw	r16,0(r2)
8112bb64:	dc400215 	stw	r17,8(sp)
8112bb68:	dfc00315 	stw	ra,12(sp)
8112bb6c:	2023883a 	mov	r17,r4
8112bb70:	80000226 	beq	r16,zero,8112bb7c <fputwc+0x34>
8112bb74:	80800e17 	ldw	r2,56(r16)
8112bb78:	10001026 	beq	r2,zero,8112bbbc <fputwc+0x74>
8112bb7c:	2880030b 	ldhu	r2,12(r5)
8112bb80:	10c8000c 	andi	r3,r2,8192
8112bb84:	1800051e 	bne	r3,zero,8112bb9c <fputwc+0x54>
8112bb88:	28c01917 	ldw	r3,100(r5)
8112bb8c:	10880014 	ori	r2,r2,8192
8112bb90:	2880030d 	sth	r2,12(r5)
8112bb94:	18880014 	ori	r2,r3,8192
8112bb98:	28801915 	stw	r2,100(r5)
8112bb9c:	280d883a 	mov	r6,r5
8112bba0:	8009883a 	mov	r4,r16
8112bba4:	880b883a 	mov	r5,r17
8112bba8:	dfc00317 	ldw	ra,12(sp)
8112bbac:	dc400217 	ldw	r17,8(sp)
8112bbb0:	dc000117 	ldw	r16,4(sp)
8112bbb4:	dec00404 	addi	sp,sp,16
8112bbb8:	112b9b81 	jmpi	8112b9b8 <__fputwc>
8112bbbc:	8009883a 	mov	r4,r16
8112bbc0:	d9400015 	stw	r5,0(sp)
8112bbc4:	11234cc0 	call	811234cc <__sinit>
8112bbc8:	d9400017 	ldw	r5,0(sp)
8112bbcc:	003feb06 	br	8112bb7c <__reset+0xfb10bb7c>

8112bbd0 <_fstat_r>:
8112bbd0:	defffd04 	addi	sp,sp,-12
8112bbd4:	de00012e 	bgeu	sp,et,8112bbdc <_fstat_r+0xc>
8112bbd8:	003b68fa 	trap	3
8112bbdc:	2805883a 	mov	r2,r5
8112bbe0:	dc000015 	stw	r16,0(sp)
8112bbe4:	04204534 	movhi	r16,33044
8112bbe8:	dc400115 	stw	r17,4(sp)
8112bbec:	841e8704 	addi	r16,r16,31260
8112bbf0:	2023883a 	mov	r17,r4
8112bbf4:	300b883a 	mov	r5,r6
8112bbf8:	1009883a 	mov	r4,r2
8112bbfc:	dfc00215 	stw	ra,8(sp)
8112bc00:	80000015 	stw	zero,0(r16)
8112bc04:	112f2580 	call	8112f258 <fstat>
8112bc08:	00ffffc4 	movi	r3,-1
8112bc0c:	10c00526 	beq	r2,r3,8112bc24 <_fstat_r+0x54>
8112bc10:	dfc00217 	ldw	ra,8(sp)
8112bc14:	dc400117 	ldw	r17,4(sp)
8112bc18:	dc000017 	ldw	r16,0(sp)
8112bc1c:	dec00304 	addi	sp,sp,12
8112bc20:	f800283a 	ret
8112bc24:	80c00017 	ldw	r3,0(r16)
8112bc28:	183ff926 	beq	r3,zero,8112bc10 <__reset+0xfb10bc10>
8112bc2c:	88c00015 	stw	r3,0(r17)
8112bc30:	003ff706 	br	8112bc10 <__reset+0xfb10bc10>

8112bc34 <rshift>:
8112bc34:	2807d17a 	srai	r3,r5,5
8112bc38:	20800417 	ldw	r2,16(r4)
8112bc3c:	22000504 	addi	r8,r4,20
8112bc40:	1880250e 	bge	r3,r2,8112bcd8 <rshift+0xa4>
8112bc44:	1085883a 	add	r2,r2,r2
8112bc48:	18c7883a 	add	r3,r3,r3
8112bc4c:	1085883a 	add	r2,r2,r2
8112bc50:	18c7883a 	add	r3,r3,r3
8112bc54:	294007cc 	andi	r5,r5,31
8112bc58:	4085883a 	add	r2,r8,r2
8112bc5c:	40c7883a 	add	r3,r8,r3
8112bc60:	28002026 	beq	r5,zero,8112bce4 <rshift+0xb0>
8112bc64:	19800017 	ldw	r6,0(r3)
8112bc68:	02c00804 	movi	r11,32
8112bc6c:	19c00104 	addi	r7,r3,4
8112bc70:	5957c83a 	sub	r11,r11,r5
8112bc74:	314cd83a 	srl	r6,r6,r5
8112bc78:	38802c2e 	bgeu	r7,r2,8112bd2c <rshift+0xf8>
8112bc7c:	4015883a 	mov	r10,r8
8112bc80:	3a400017 	ldw	r9,0(r7)
8112bc84:	52800104 	addi	r10,r10,4
8112bc88:	39c00104 	addi	r7,r7,4
8112bc8c:	4ad2983a 	sll	r9,r9,r11
8112bc90:	498cb03a 	or	r6,r9,r6
8112bc94:	51bfff15 	stw	r6,-4(r10)
8112bc98:	39bfff17 	ldw	r6,-4(r7)
8112bc9c:	314cd83a 	srl	r6,r6,r5
8112bca0:	38bff736 	bltu	r7,r2,8112bc80 <__reset+0xfb10bc80>
8112bca4:	10c7c83a 	sub	r3,r2,r3
8112bca8:	18fffec4 	addi	r3,r3,-5
8112bcac:	1806d0ba 	srli	r3,r3,2
8112bcb0:	18c00044 	addi	r3,r3,1
8112bcb4:	18c7883a 	add	r3,r3,r3
8112bcb8:	18c7883a 	add	r3,r3,r3
8112bcbc:	40c7883a 	add	r3,r8,r3
8112bcc0:	19800015 	stw	r6,0(r3)
8112bcc4:	30000126 	beq	r6,zero,8112bccc <rshift+0x98>
8112bcc8:	18c00104 	addi	r3,r3,4
8112bccc:	1a05c83a 	sub	r2,r3,r8
8112bcd0:	1005d0ba 	srai	r2,r2,2
8112bcd4:	00001206 	br	8112bd20 <rshift+0xec>
8112bcd8:	20000415 	stw	zero,16(r4)
8112bcdc:	20000515 	stw	zero,20(r4)
8112bce0:	f800283a 	ret
8112bce4:	18bffc2e 	bgeu	r3,r2,8112bcd8 <__reset+0xfb10bcd8>
8112bce8:	180d883a 	mov	r6,r3
8112bcec:	400b883a 	mov	r5,r8
8112bcf0:	31c00017 	ldw	r7,0(r6)
8112bcf4:	29400104 	addi	r5,r5,4
8112bcf8:	31800104 	addi	r6,r6,4
8112bcfc:	29ffff15 	stw	r7,-4(r5)
8112bd00:	30bffb36 	bltu	r6,r2,8112bcf0 <__reset+0xfb10bcf0>
8112bd04:	00c6303a 	nor	r3,zero,r3
8112bd08:	1885883a 	add	r2,r3,r2
8112bd0c:	1004d0ba 	srli	r2,r2,2
8112bd10:	10800044 	addi	r2,r2,1
8112bd14:	1085883a 	add	r2,r2,r2
8112bd18:	1085883a 	add	r2,r2,r2
8112bd1c:	1005d0ba 	srai	r2,r2,2
8112bd20:	20800415 	stw	r2,16(r4)
8112bd24:	103fed26 	beq	r2,zero,8112bcdc <__reset+0xfb10bcdc>
8112bd28:	f800283a 	ret
8112bd2c:	4007883a 	mov	r3,r8
8112bd30:	003fe306 	br	8112bcc0 <__reset+0xfb10bcc0>

8112bd34 <__gethex>:
8112bd34:	deffeb04 	addi	sp,sp,-84
8112bd38:	de00012e 	bgeu	sp,et,8112bd40 <__gethex+0xc>
8112bd3c:	003b68fa 	trap	3
8112bd40:	dfc01415 	stw	ra,80(sp)
8112bd44:	dd801115 	stw	r22,68(sp)
8112bd48:	dcc00e15 	stw	r19,56(sp)
8112bd4c:	dc800d15 	stw	r18,52(sp)
8112bd50:	2827883a 	mov	r19,r5
8112bd54:	d9000115 	stw	r4,4(sp)
8112bd58:	d9800015 	stw	r6,0(sp)
8112bd5c:	d9c00415 	stw	r7,16(sp)
8112bd60:	df001315 	stw	fp,76(sp)
8112bd64:	ddc01215 	stw	r23,72(sp)
8112bd68:	dd401015 	stw	r21,64(sp)
8112bd6c:	dd000f15 	stw	r20,60(sp)
8112bd70:	dc400c15 	stw	r17,48(sp)
8112bd74:	dc000b15 	stw	r16,44(sp)
8112bd78:	11243100 	call	81124310 <_localeconv_r>
8112bd7c:	14800017 	ldw	r18,0(r2)
8112bd80:	9009883a 	mov	r4,r18
8112bd84:	111b1180 	call	8111b118 <strlen>
8112bd88:	98c00017 	ldw	r3,0(r19)
8112bd8c:	102d883a 	mov	r22,r2
8112bd90:	9085883a 	add	r2,r18,r2
8112bd94:	10bfffc3 	ldbu	r2,-1(r2)
8112bd98:	19000083 	ldbu	r4,2(r3)
8112bd9c:	d8800305 	stb	r2,12(sp)
8112bda0:	00800c04 	movi	r2,48
8112bda4:	2081521e 	bne	r4,r2,8112c2f0 <__gethex+0x5bc>
8112bda8:	017fff84 	movi	r5,-2
8112bdac:	188000c4 	addi	r2,r3,3
8112bdb0:	28cbc83a 	sub	r5,r5,r3
8112bdb4:	200d883a 	mov	r6,r4
8112bdb8:	28a3883a 	add	r17,r5,r2
8112bdbc:	102b883a 	mov	r21,r2
8112bdc0:	10800044 	addi	r2,r2,1
8112bdc4:	113fffc3 	ldbu	r4,-1(r2)
8112bdc8:	21bffb26 	beq	r4,r6,8112bdb8 <__reset+0xfb10bdb8>
8112bdcc:	05204534 	movhi	r20,33044
8112bdd0:	a514da04 	addi	r20,r20,21352
8112bdd4:	a109883a 	add	r4,r20,r4
8112bdd8:	20800003 	ldbu	r2,0(r4)
8112bddc:	10008826 	beq	r2,zero,8112c000 <__gethex+0x2cc>
8112bde0:	a8800003 	ldbu	r2,0(r21)
8112bde4:	0015883a 	mov	r10,zero
8112bde8:	002f883a 	mov	r23,zero
8112bdec:	a085883a 	add	r2,r20,r2
8112bdf0:	10800003 	ldbu	r2,0(r2)
8112bdf4:	a821883a 	mov	r16,r21
8112bdf8:	10000526 	beq	r2,zero,8112be10 <__gethex+0xdc>
8112bdfc:	84000044 	addi	r16,r16,1
8112be00:	80800003 	ldbu	r2,0(r16)
8112be04:	a085883a 	add	r2,r20,r2
8112be08:	10800003 	ldbu	r2,0(r2)
8112be0c:	103ffb1e 	bne	r2,zero,8112bdfc <__reset+0xfb10bdfc>
8112be10:	b00d883a 	mov	r6,r22
8112be14:	900b883a 	mov	r5,r18
8112be18:	8009883a 	mov	r4,r16
8112be1c:	da800a15 	stw	r10,40(sp)
8112be20:	112c8fc0 	call	8112c8fc <strncmp>
8112be24:	da800a17 	ldw	r10,40(sp)
8112be28:	1000031e 	bne	r2,zero,8112be38 <__gethex+0x104>
8112be2c:	b8015226 	beq	r23,zero,8112c378 <__gethex+0x644>
8112be30:	80800003 	ldbu	r2,0(r16)
8112be34:	00000206 	br	8112be40 <__gethex+0x10c>
8112be38:	80800003 	ldbu	r2,0(r16)
8112be3c:	b8011f26 	beq	r23,zero,8112c2bc <__gethex+0x588>
8112be40:	85efc83a 	sub	r23,r16,r23
8112be44:	bdef883a 	add	r23,r23,r23
8112be48:	bdef883a 	add	r23,r23,r23
8112be4c:	05efc83a 	sub	r23,zero,r23
8112be50:	10803fcc 	andi	r2,r2,255
8112be54:	01001404 	movi	r4,80
8112be58:	11008626 	beq	r2,r4,8112c074 <__gethex+0x340>
8112be5c:	01001c04 	movi	r4,112
8112be60:	11008426 	beq	r2,r4,8112c074 <__gethex+0x340>
8112be64:	8039883a 	mov	fp,r16
8112be68:	9c000015 	stw	r16,0(r19)
8112be6c:	5000711e 	bne	r10,zero,8112c034 <__gethex+0x300>
8112be70:	e545c83a 	sub	r2,fp,r21
8112be74:	10bfffc4 	addi	r2,r2,-1
8112be78:	010001c4 	movi	r4,7
8112be7c:	000b883a 	mov	r5,zero
8112be80:	2080030e 	bge	r4,r2,8112be90 <__gethex+0x15c>
8112be84:	1005d07a 	srai	r2,r2,1
8112be88:	29400044 	addi	r5,r5,1
8112be8c:	20bffd16 	blt	r4,r2,8112be84 <__reset+0xfb10be84>
8112be90:	d9000117 	ldw	r4,4(sp)
8112be94:	112519c0 	call	8112519c <_Balloc>
8112be98:	10c00504 	addi	r3,r2,20
8112be9c:	d8c00215 	stw	r3,8(sp)
8112bea0:	1021883a 	mov	r16,r2
8112bea4:	af01732e 	bgeu	r21,fp,8112c474 <__gethex+0x740>
8112bea8:	dc400303 	ldbu	r17,12(sp)
8112beac:	03400044 	movi	r13,1
8112beb0:	1815883a 	mov	r10,r3
8112beb4:	0013883a 	mov	r9,zero
8112beb8:	0027883a 	mov	r19,zero
8112bebc:	6d9bc83a 	sub	r13,r13,r22
8112bec0:	02c00804 	movi	r11,32
8112bec4:	e0bfffc3 	ldbu	r2,-1(fp)
8112bec8:	e3bfffc4 	addi	r14,fp,-1
8112becc:	88803026 	beq	r17,r2,8112bf90 <__gethex+0x25c>
8112bed0:	9ac04526 	beq	r19,r11,8112bfe8 <__gethex+0x2b4>
8112bed4:	980b883a 	mov	r5,r19
8112bed8:	9cc00104 	addi	r19,r19,4
8112bedc:	e13fffc3 	ldbu	r4,-1(fp)
8112bee0:	7039883a 	mov	fp,r14
8112bee4:	a109883a 	add	r4,r20,r4
8112bee8:	20800003 	ldbu	r2,0(r4)
8112beec:	108003cc 	andi	r2,r2,15
8112bef0:	1144983a 	sll	r2,r2,r5
8112bef4:	4892b03a 	or	r9,r9,r2
8112bef8:	af3ff236 	bltu	r21,fp,8112bec4 <__reset+0xfb10bec4>
8112befc:	d8c00217 	ldw	r3,8(sp)
8112bf00:	50800104 	addi	r2,r10,4
8112bf04:	52400015 	stw	r9,0(r10)
8112bf08:	10c5c83a 	sub	r2,r2,r3
8112bf0c:	1005d0ba 	srai	r2,r2,2
8112bf10:	4809883a 	mov	r4,r9
8112bf14:	80800415 	stw	r2,16(r16)
8112bf18:	1022917a 	slli	r17,r2,5
8112bf1c:	11254a80 	call	811254a8 <__hi0bits>
8112bf20:	d8c00017 	ldw	r3,0(sp)
8112bf24:	8885c83a 	sub	r2,r17,r2
8112bf28:	1c800017 	ldw	r18,0(r3)
8112bf2c:	9080c716 	blt	r18,r2,8112c24c <__gethex+0x518>
8112bf30:	1480e416 	blt	r2,r18,8112c2c4 <__gethex+0x590>
8112bf34:	0027883a 	mov	r19,zero
8112bf38:	d8c00017 	ldw	r3,0(sp)
8112bf3c:	18800217 	ldw	r2,8(r3)
8112bf40:	15c08d16 	blt	r2,r23,8112c178 <__gethex+0x444>
8112bf44:	d8c00017 	ldw	r3,0(sp)
8112bf48:	18800117 	ldw	r2,4(r3)
8112bf4c:	b880aa0e 	bge	r23,r2,8112c1f8 <__gethex+0x4c4>
8112bf50:	15efc83a 	sub	r23,r2,r23
8112bf54:	bc80ed16 	blt	r23,r18,8112c30c <__gethex+0x5d8>
8112bf58:	18c00317 	ldw	r3,12(r3)
8112bf5c:	01000084 	movi	r4,2
8112bf60:	19014926 	beq	r3,r4,8112c488 <__gethex+0x754>
8112bf64:	010000c4 	movi	r4,3
8112bf68:	19012e26 	beq	r3,r4,8112c424 <__gethex+0x6f0>
8112bf6c:	01000044 	movi	r4,1
8112bf70:	19014826 	beq	r3,r4,8112c494 <__gethex+0x760>
8112bf74:	d9000117 	ldw	r4,4(sp)
8112bf78:	800b883a 	mov	r5,r16
8112bf7c:	112524c0 	call	8112524c <_Bfree>
8112bf80:	d8801517 	ldw	r2,84(sp)
8112bf84:	10000015 	stw	zero,0(r2)
8112bf88:	00801404 	movi	r2,80
8112bf8c:	00002b06 	br	8112c03c <__gethex+0x308>
8112bf90:	735f883a 	add	r15,r14,r13
8112bf94:	7d7fce36 	bltu	r15,r21,8112bed0 <__reset+0xfb10bed0>
8112bf98:	7809883a 	mov	r4,r15
8112bf9c:	b00d883a 	mov	r6,r22
8112bfa0:	900b883a 	mov	r5,r18
8112bfa4:	da400515 	stw	r9,20(sp)
8112bfa8:	da800a15 	stw	r10,40(sp)
8112bfac:	dac00915 	stw	r11,36(sp)
8112bfb0:	db400815 	stw	r13,32(sp)
8112bfb4:	db800615 	stw	r14,24(sp)
8112bfb8:	dbc00715 	stw	r15,28(sp)
8112bfbc:	112c8fc0 	call	8112c8fc <strncmp>
8112bfc0:	da400517 	ldw	r9,20(sp)
8112bfc4:	da800a17 	ldw	r10,40(sp)
8112bfc8:	dac00917 	ldw	r11,36(sp)
8112bfcc:	db400817 	ldw	r13,32(sp)
8112bfd0:	db800617 	ldw	r14,24(sp)
8112bfd4:	dbc00717 	ldw	r15,28(sp)
8112bfd8:	103fbd1e 	bne	r2,zero,8112bed0 <__reset+0xfb10bed0>
8112bfdc:	7839883a 	mov	fp,r15
8112bfe0:	af3fb836 	bltu	r21,fp,8112bec4 <__reset+0xfb10bec4>
8112bfe4:	003fc506 	br	8112befc <__reset+0xfb10befc>
8112bfe8:	04c00104 	movi	r19,4
8112bfec:	52400015 	stw	r9,0(r10)
8112bff0:	000b883a 	mov	r5,zero
8112bff4:	54d5883a 	add	r10,r10,r19
8112bff8:	0013883a 	mov	r9,zero
8112bffc:	003fb706 	br	8112bedc <__reset+0xfb10bedc>
8112c000:	b00d883a 	mov	r6,r22
8112c004:	900b883a 	mov	r5,r18
8112c008:	a809883a 	mov	r4,r21
8112c00c:	112c8fc0 	call	8112c8fc <strncmp>
8112c010:	10006426 	beq	r2,zero,8112c1a4 <__gethex+0x470>
8112c014:	a8800003 	ldbu	r2,0(r21)
8112c018:	a821883a 	mov	r16,r21
8112c01c:	10803fcc 	andi	r2,r2,255
8112c020:	01001404 	movi	r4,80
8112c024:	11001126 	beq	r2,r4,8112c06c <__gethex+0x338>
8112c028:	01001c04 	movi	r4,112
8112c02c:	11000f26 	beq	r2,r4,8112c06c <__gethex+0x338>
8112c030:	9c000015 	stw	r16,0(r19)
8112c034:	8800831e 	bne	r17,zero,8112c244 <__gethex+0x510>
8112c038:	00800184 	movi	r2,6
8112c03c:	dfc01417 	ldw	ra,80(sp)
8112c040:	df001317 	ldw	fp,76(sp)
8112c044:	ddc01217 	ldw	r23,72(sp)
8112c048:	dd801117 	ldw	r22,68(sp)
8112c04c:	dd401017 	ldw	r21,64(sp)
8112c050:	dd000f17 	ldw	r20,60(sp)
8112c054:	dcc00e17 	ldw	r19,56(sp)
8112c058:	dc800d17 	ldw	r18,52(sp)
8112c05c:	dc400c17 	ldw	r17,48(sp)
8112c060:	dc000b17 	ldw	r16,44(sp)
8112c064:	dec01504 	addi	sp,sp,84
8112c068:	f800283a 	ret
8112c06c:	002f883a 	mov	r23,zero
8112c070:	02800044 	movi	r10,1
8112c074:	80800043 	ldbu	r2,1(r16)
8112c078:	01400ac4 	movi	r5,43
8112c07c:	11003fcc 	andi	r4,r2,255
8112c080:	21406e26 	beq	r4,r5,8112c23c <__gethex+0x508>
8112c084:	01400b44 	movi	r5,45
8112c088:	21404226 	beq	r4,r5,8112c194 <__gethex+0x460>
8112c08c:	81400044 	addi	r5,r16,1
8112c090:	000d883a 	mov	r6,zero
8112c094:	10803fcc 	andi	r2,r2,255
8112c098:	a085883a 	add	r2,r20,r2
8112c09c:	11000003 	ldbu	r4,0(r2)
8112c0a0:	03000604 	movi	r12,24
8112c0a4:	20bfffc4 	addi	r2,r4,-1
8112c0a8:	10803fcc 	andi	r2,r2,255
8112c0ac:	60bf6d36 	bltu	r12,r2,8112be64 <__reset+0xfb10be64>
8112c0b0:	2ac00043 	ldbu	r11,1(r5)
8112c0b4:	20803fcc 	andi	r2,r4,255
8112c0b8:	01204534 	movhi	r4,33044
8112c0bc:	2114da04 	addi	r4,r4,21352
8112c0c0:	22c9883a 	add	r4,r4,r11
8112c0c4:	23400003 	ldbu	r13,0(r4)
8112c0c8:	10bffc04 	addi	r2,r2,-16
8112c0cc:	29400044 	addi	r5,r5,1
8112c0d0:	693fffc4 	addi	r4,r13,-1
8112c0d4:	21003fcc 	andi	r4,r4,255
8112c0d8:	6b403fcc 	andi	r13,r13,255
8112c0dc:	61000b36 	bltu	r12,r4,8112c10c <__gethex+0x3d8>
8112c0e0:	29400044 	addi	r5,r5,1
8112c0e4:	29000003 	ldbu	r4,0(r5)
8112c0e8:	108002a4 	muli	r2,r2,10
8112c0ec:	a109883a 	add	r4,r20,r4
8112c0f0:	22c00003 	ldbu	r11,0(r4)
8112c0f4:	1345883a 	add	r2,r2,r13
8112c0f8:	10bffc04 	addi	r2,r2,-16
8112c0fc:	593fffc4 	addi	r4,r11,-1
8112c100:	21003fcc 	andi	r4,r4,255
8112c104:	5b403fcc 	andi	r13,r11,255
8112c108:	613ff52e 	bgeu	r12,r4,8112c0e0 <__reset+0xfb10c0e0>
8112c10c:	30000126 	beq	r6,zero,8112c114 <__gethex+0x3e0>
8112c110:	0085c83a 	sub	r2,zero,r2
8112c114:	8039883a 	mov	fp,r16
8112c118:	b8af883a 	add	r23,r23,r2
8112c11c:	2821883a 	mov	r16,r5
8112c120:	003f5106 	br	8112be68 <__reset+0xfb10be68>
8112c124:	80800217 	ldw	r2,8(r16)
8112c128:	e080f00e 	bge	fp,r2,8112c4ec <__gethex+0x7b8>
8112c12c:	e007883a 	mov	r3,fp
8112c130:	18800144 	addi	r2,r3,5
8112c134:	1085883a 	add	r2,r2,r2
8112c138:	18c00044 	addi	r3,r3,1
8112c13c:	1085883a 	add	r2,r2,r2
8112c140:	8085883a 	add	r2,r16,r2
8112c144:	80c00415 	stw	r3,16(r16)
8112c148:	01000044 	movi	r4,1
8112c14c:	11000015 	stw	r4,0(r2)
8112c150:	00800084 	movi	r2,2
8112c154:	8880d826 	beq	r17,r2,8112c4b8 <__gethex+0x784>
8112c158:	e0c0ac0e 	bge	fp,r3,8112c40c <__gethex+0x6d8>
8112c15c:	01400044 	movi	r5,1
8112c160:	8009883a 	mov	r4,r16
8112c164:	112bc340 	call	8112bc34 <rshift>
8112c168:	d8c00017 	ldw	r3,0(sp)
8112c16c:	bdc00044 	addi	r23,r23,1
8112c170:	18800217 	ldw	r2,8(r3)
8112c174:	15c0a70e 	bge	r2,r23,8112c414 <__gethex+0x6e0>
8112c178:	d9000117 	ldw	r4,4(sp)
8112c17c:	800b883a 	mov	r5,r16
8112c180:	112524c0 	call	8112524c <_Bfree>
8112c184:	d9001517 	ldw	r4,84(sp)
8112c188:	008028c4 	movi	r2,163
8112c18c:	20000015 	stw	zero,0(r4)
8112c190:	003faa06 	br	8112c03c <__reset+0xfb10c03c>
8112c194:	01800044 	movi	r6,1
8112c198:	80800083 	ldbu	r2,2(r16)
8112c19c:	81400084 	addi	r5,r16,2
8112c1a0:	003fbc06 	br	8112c094 <__reset+0xfb10c094>
8112c1a4:	ada1883a 	add	r16,r21,r22
8112c1a8:	81000003 	ldbu	r4,0(r16)
8112c1ac:	21403fcc 	andi	r5,r4,255
8112c1b0:	a145883a 	add	r2,r20,r5
8112c1b4:	10800003 	ldbu	r2,0(r2)
8112c1b8:	11803fcc 	andi	r6,r2,255
8112c1bc:	30004f26 	beq	r6,zero,8112c2fc <__gethex+0x5c8>
8112c1c0:	00c00c04 	movi	r3,48
8112c1c4:	802b883a 	mov	r21,r16
8112c1c8:	28c0061e 	bne	r5,r3,8112c1e4 <__gethex+0x4b0>
8112c1cc:	2809883a 	mov	r4,r5
8112c1d0:	ad400044 	addi	r21,r21,1
8112c1d4:	a8800003 	ldbu	r2,0(r21)
8112c1d8:	113ffd26 	beq	r2,r4,8112c1d0 <__reset+0xfb10c1d0>
8112c1dc:	a085883a 	add	r2,r20,r2
8112c1e0:	10800003 	ldbu	r2,0(r2)
8112c1e4:	10803fcc 	andi	r2,r2,255
8112c1e8:	1015003a 	cmpeq	r10,r2,zero
8112c1ec:	802f883a 	mov	r23,r16
8112c1f0:	04400044 	movi	r17,1
8112c1f4:	003eff06 	br	8112bdf4 <__reset+0xfb10bdf4>
8112c1f8:	04400044 	movi	r17,1
8112c1fc:	98000926 	beq	r19,zero,8112c224 <__gethex+0x4f0>
8112c200:	d8c00017 	ldw	r3,0(sp)
8112c204:	18800317 	ldw	r2,12(r3)
8112c208:	00c00084 	movi	r3,2
8112c20c:	10c06826 	beq	r2,r3,8112c3b0 <__gethex+0x67c>
8112c210:	00c000c4 	movi	r3,3
8112c214:	10c06a26 	beq	r2,r3,8112c3c0 <__gethex+0x68c>
8112c218:	00c00044 	movi	r3,1
8112c21c:	10c08d26 	beq	r2,r3,8112c454 <__gethex+0x720>
8112c220:	8c400414 	ori	r17,r17,16
8112c224:	d9001517 	ldw	r4,84(sp)
8112c228:	d8c00417 	ldw	r3,16(sp)
8112c22c:	8805883a 	mov	r2,r17
8112c230:	24000015 	stw	r16,0(r4)
8112c234:	1dc00015 	stw	r23,0(r3)
8112c238:	003f8006 	br	8112c03c <__reset+0xfb10c03c>
8112c23c:	000d883a 	mov	r6,zero
8112c240:	003fd506 	br	8112c198 <__reset+0xfb10c198>
8112c244:	0005883a 	mov	r2,zero
8112c248:	003f7c06 	br	8112c03c <__reset+0xfb10c03c>
8112c24c:	14a3c83a 	sub	r17,r2,r18
8112c250:	880b883a 	mov	r5,r17
8112c254:	8009883a 	mov	r4,r16
8112c258:	112616c0 	call	8112616c <__any_on>
8112c25c:	10002926 	beq	r2,zero,8112c304 <__gethex+0x5d0>
8112c260:	897fffc4 	addi	r5,r17,-1
8112c264:	2807d17a 	srai	r3,r5,5
8112c268:	d8800217 	ldw	r2,8(sp)
8112c26c:	290007cc 	andi	r4,r5,31
8112c270:	18c7883a 	add	r3,r3,r3
8112c274:	18c7883a 	add	r3,r3,r3
8112c278:	04c00044 	movi	r19,1
8112c27c:	10c7883a 	add	r3,r2,r3
8112c280:	9908983a 	sll	r4,r19,r4
8112c284:	18c00017 	ldw	r3,0(r3)
8112c288:	20c6703a 	and	r3,r4,r3
8112c28c:	18000626 	beq	r3,zero,8112c2a8 <__gethex+0x574>
8112c290:	99407b0e 	bge	r19,r5,8112c480 <__gethex+0x74c>
8112c294:	897fff84 	addi	r5,r17,-2
8112c298:	8009883a 	mov	r4,r16
8112c29c:	112616c0 	call	8112616c <__any_on>
8112c2a0:	10007726 	beq	r2,zero,8112c480 <__gethex+0x74c>
8112c2a4:	04c000c4 	movi	r19,3
8112c2a8:	880b883a 	mov	r5,r17
8112c2ac:	8009883a 	mov	r4,r16
8112c2b0:	112bc340 	call	8112bc34 <rshift>
8112c2b4:	bc6f883a 	add	r23,r23,r17
8112c2b8:	003f1f06 	br	8112bf38 <__reset+0xfb10bf38>
8112c2bc:	002f883a 	mov	r23,zero
8112c2c0:	003ee306 	br	8112be50 <__reset+0xfb10be50>
8112c2c4:	d9000117 	ldw	r4,4(sp)
8112c2c8:	90a3c83a 	sub	r17,r18,r2
8112c2cc:	800b883a 	mov	r5,r16
8112c2d0:	880d883a 	mov	r6,r17
8112c2d4:	112594c0 	call	8112594c <__lshift>
8112c2d8:	10c00504 	addi	r3,r2,20
8112c2dc:	1021883a 	mov	r16,r2
8112c2e0:	bc6fc83a 	sub	r23,r23,r17
8112c2e4:	d8c00215 	stw	r3,8(sp)
8112c2e8:	0027883a 	mov	r19,zero
8112c2ec:	003f1206 	br	8112bf38 <__reset+0xfb10bf38>
8112c2f0:	1d400084 	addi	r21,r3,2
8112c2f4:	0023883a 	mov	r17,zero
8112c2f8:	003eb406 	br	8112bdcc <__reset+0xfb10bdcc>
8112c2fc:	2005883a 	mov	r2,r4
8112c300:	003f4606 	br	8112c01c <__reset+0xfb10c01c>
8112c304:	0027883a 	mov	r19,zero
8112c308:	003fe706 	br	8112c2a8 <__reset+0xfb10c2a8>
8112c30c:	bc7fffc4 	addi	r17,r23,-1
8112c310:	9800421e 	bne	r19,zero,8112c41c <__gethex+0x6e8>
8112c314:	88000426 	beq	r17,zero,8112c328 <__gethex+0x5f4>
8112c318:	880b883a 	mov	r5,r17
8112c31c:	8009883a 	mov	r4,r16
8112c320:	112616c0 	call	8112616c <__any_on>
8112c324:	1027883a 	mov	r19,r2
8112c328:	8805d17a 	srai	r2,r17,5
8112c32c:	d8c00217 	ldw	r3,8(sp)
8112c330:	8c4007cc 	andi	r17,r17,31
8112c334:	1085883a 	add	r2,r2,r2
8112c338:	1085883a 	add	r2,r2,r2
8112c33c:	1885883a 	add	r2,r3,r2
8112c340:	00c00044 	movi	r3,1
8112c344:	1c62983a 	sll	r17,r3,r17
8112c348:	10800017 	ldw	r2,0(r2)
8112c34c:	8884703a 	and	r2,r17,r2
8112c350:	10000126 	beq	r2,zero,8112c358 <__gethex+0x624>
8112c354:	9cc00094 	ori	r19,r19,2
8112c358:	b80b883a 	mov	r5,r23
8112c35c:	8009883a 	mov	r4,r16
8112c360:	112bc340 	call	8112bc34 <rshift>
8112c364:	d8c00017 	ldw	r3,0(sp)
8112c368:	95e5c83a 	sub	r18,r18,r23
8112c36c:	04400084 	movi	r17,2
8112c370:	1dc00117 	ldw	r23,4(r3)
8112c374:	003fa106 	br	8112c1fc <__reset+0xfb10c1fc>
8112c378:	85af883a 	add	r23,r16,r22
8112c37c:	b8800003 	ldbu	r2,0(r23)
8112c380:	b821883a 	mov	r16,r23
8112c384:	11003fcc 	andi	r4,r2,255
8112c388:	a109883a 	add	r4,r20,r4
8112c38c:	21000003 	ldbu	r4,0(r4)
8112c390:	203eaa26 	beq	r4,zero,8112be3c <__reset+0xfb10be3c>
8112c394:	84000044 	addi	r16,r16,1
8112c398:	80800003 	ldbu	r2,0(r16)
8112c39c:	11003fcc 	andi	r4,r2,255
8112c3a0:	a109883a 	add	r4,r20,r4
8112c3a4:	21000003 	ldbu	r4,0(r4)
8112c3a8:	203ffa1e 	bne	r4,zero,8112c394 <__reset+0xfb10c394>
8112c3ac:	003ea306 	br	8112be3c <__reset+0xfb10be3c>
8112c3b0:	d9001617 	ldw	r4,88(sp)
8112c3b4:	00800044 	movi	r2,1
8112c3b8:	1109c83a 	sub	r4,r2,r4
8112c3bc:	d9001615 	stw	r4,88(sp)
8112c3c0:	d8801617 	ldw	r2,88(sp)
8112c3c4:	103f9626 	beq	r2,zero,8112c220 <__reset+0xfb10c220>
8112c3c8:	87000417 	ldw	fp,16(r16)
8112c3cc:	d9800217 	ldw	r6,8(sp)
8112c3d0:	013fffc4 	movi	r4,-1
8112c3d4:	e727883a 	add	r19,fp,fp
8112c3d8:	9ce7883a 	add	r19,r19,r19
8112c3dc:	3005883a 	mov	r2,r6
8112c3e0:	34cb883a 	add	r5,r6,r19
8112c3e4:	00000306 	br	8112c3f4 <__gethex+0x6c0>
8112c3e8:	10000015 	stw	zero,0(r2)
8112c3ec:	10800104 	addi	r2,r2,4
8112c3f0:	117f4c2e 	bgeu	r2,r5,8112c124 <__reset+0xfb10c124>
8112c3f4:	10c00017 	ldw	r3,0(r2)
8112c3f8:	193ffb26 	beq	r3,r4,8112c3e8 <__reset+0xfb10c3e8>
8112c3fc:	18c00044 	addi	r3,r3,1
8112c400:	10c00015 	stw	r3,0(r2)
8112c404:	00800084 	movi	r2,2
8112c408:	88802b26 	beq	r17,r2,8112c4b8 <__gethex+0x784>
8112c40c:	948007cc 	andi	r18,r18,31
8112c410:	90002f1e 	bne	r18,zero,8112c4d0 <__gethex+0x79c>
8112c414:	04400844 	movi	r17,33
8112c418:	003f8206 	br	8112c224 <__reset+0xfb10c224>
8112c41c:	04c00044 	movi	r19,1
8112c420:	003fc106 	br	8112c328 <__reset+0xfb10c328>
8112c424:	d8c01617 	ldw	r3,88(sp)
8112c428:	183ed226 	beq	r3,zero,8112bf74 <__reset+0xfb10bf74>
8112c42c:	d8c00417 	ldw	r3,16(sp)
8112c430:	d9001517 	ldw	r4,84(sp)
8112c434:	18800015 	stw	r2,0(r3)
8112c438:	d8c00217 	ldw	r3,8(sp)
8112c43c:	00800044 	movi	r2,1
8112c440:	80800415 	stw	r2,16(r16)
8112c444:	18800015 	stw	r2,0(r3)
8112c448:	24000015 	stw	r16,0(r4)
8112c44c:	00801884 	movi	r2,98
8112c450:	003efa06 	br	8112c03c <__reset+0xfb10c03c>
8112c454:	9880008c 	andi	r2,r19,2
8112c458:	103f7126 	beq	r2,zero,8112c220 <__reset+0xfb10c220>
8112c45c:	d8c00217 	ldw	r3,8(sp)
8112c460:	18800017 	ldw	r2,0(r3)
8112c464:	9884b03a 	or	r2,r19,r2
8112c468:	1080004c 	andi	r2,r2,1
8112c46c:	103fd61e 	bne	r2,zero,8112c3c8 <__reset+0xfb10c3c8>
8112c470:	003f6b06 	br	8112c220 <__reset+0xfb10c220>
8112c474:	da800217 	ldw	r10,8(sp)
8112c478:	0013883a 	mov	r9,zero
8112c47c:	003e9f06 	br	8112befc <__reset+0xfb10befc>
8112c480:	04c00084 	movi	r19,2
8112c484:	003f8806 	br	8112c2a8 <__reset+0xfb10c2a8>
8112c488:	d9001617 	ldw	r4,88(sp)
8112c48c:	203fe726 	beq	r4,zero,8112c42c <__reset+0xfb10c42c>
8112c490:	003eb806 	br	8112bf74 <__reset+0xfb10bf74>
8112c494:	95feb71e 	bne	r18,r23,8112bf74 <__reset+0xfb10bf74>
8112c498:	1cbfe40e 	bge	r3,r18,8112c42c <__reset+0xfb10c42c>
8112c49c:	917fffc4 	addi	r5,r18,-1
8112c4a0:	8009883a 	mov	r4,r16
8112c4a4:	112616c0 	call	8112616c <__any_on>
8112c4a8:	103eb226 	beq	r2,zero,8112bf74 <__reset+0xfb10bf74>
8112c4ac:	d8c00017 	ldw	r3,0(sp)
8112c4b0:	18800117 	ldw	r2,4(r3)
8112c4b4:	003fdd06 	br	8112c42c <__reset+0xfb10c42c>
8112c4b8:	d8c00017 	ldw	r3,0(sp)
8112c4bc:	18800017 	ldw	r2,0(r3)
8112c4c0:	10bfffc4 	addi	r2,r2,-1
8112c4c4:	90801c26 	beq	r18,r2,8112c538 <__gethex+0x804>
8112c4c8:	04400884 	movi	r17,34
8112c4cc:	003f5506 	br	8112c224 <__reset+0xfb10c224>
8112c4d0:	34c5883a 	add	r2,r6,r19
8112c4d4:	113fff17 	ldw	r4,-4(r2)
8112c4d8:	11254a80 	call	811254a8 <__hi0bits>
8112c4dc:	00c00804 	movi	r3,32
8112c4e0:	1ca5c83a 	sub	r18,r3,r18
8112c4e4:	14bfcb0e 	bge	r2,r18,8112c414 <__reset+0xfb10c414>
8112c4e8:	003f1c06 	br	8112c15c <__reset+0xfb10c15c>
8112c4ec:	81400117 	ldw	r5,4(r16)
8112c4f0:	d9000117 	ldw	r4,4(sp)
8112c4f4:	29400044 	addi	r5,r5,1
8112c4f8:	112519c0 	call	8112519c <_Balloc>
8112c4fc:	81800417 	ldw	r6,16(r16)
8112c500:	81400304 	addi	r5,r16,12
8112c504:	11000304 	addi	r4,r2,12
8112c508:	31800084 	addi	r6,r6,2
8112c50c:	318d883a 	add	r6,r6,r6
8112c510:	318d883a 	add	r6,r6,r6
8112c514:	1029883a 	mov	r20,r2
8112c518:	111abac0 	call	8111abac <memcpy>
8112c51c:	d9000117 	ldw	r4,4(sp)
8112c520:	800b883a 	mov	r5,r16
8112c524:	a021883a 	mov	r16,r20
8112c528:	112524c0 	call	8112524c <_Bfree>
8112c52c:	a0c00417 	ldw	r3,16(r20)
8112c530:	a1800504 	addi	r6,r20,20
8112c534:	003efe06 	br	8112c130 <__reset+0xfb10c130>
8112c538:	9005d17a 	srai	r2,r18,5
8112c53c:	944007cc 	andi	r17,r18,31
8112c540:	1085883a 	add	r2,r2,r2
8112c544:	1085883a 	add	r2,r2,r2
8112c548:	3087883a 	add	r3,r6,r2
8112c54c:	00800044 	movi	r2,1
8112c550:	1462983a 	sll	r17,r2,r17
8112c554:	18800017 	ldw	r2,0(r3)
8112c558:	8884703a 	and	r2,r17,r2
8112c55c:	1022c03a 	cmpne	r17,r2,zero
8112c560:	00800884 	movi	r2,34
8112c564:	1463c83a 	sub	r17,r2,r17
8112c568:	003f2e06 	br	8112c224 <__reset+0xfb10c224>

8112c56c <__hexnan>:
8112c56c:	defff904 	addi	sp,sp,-28
8112c570:	de00012e 	bgeu	sp,et,8112c578 <__hexnan+0xc>
8112c574:	003b68fa 	trap	3
8112c578:	dc800215 	stw	r18,8(sp)
8112c57c:	2c800017 	ldw	r18,0(r5)
8112c580:	dfc00615 	stw	ra,24(sp)
8112c584:	dd400515 	stw	r21,20(sp)
8112c588:	901fd17a 	srai	r15,r18,5
8112c58c:	dd000415 	stw	r20,16(sp)
8112c590:	dcc00315 	stw	r19,12(sp)
8112c594:	7bdf883a 	add	r15,r15,r15
8112c598:	7bdf883a 	add	r15,r15,r15
8112c59c:	dc400115 	stw	r17,4(sp)
8112c5a0:	dc000015 	stw	r16,0(sp)
8112c5a4:	948007cc 	andi	r18,r18,31
8112c5a8:	33df883a 	add	r15,r6,r15
8112c5ac:	90000126 	beq	r18,zero,8112c5b4 <__hexnan+0x48>
8112c5b0:	7bc00104 	addi	r15,r15,4
8112c5b4:	22000017 	ldw	r8,0(r4)
8112c5b8:	7affff04 	addi	r11,r15,-4
8112c5bc:	03a04534 	movhi	r14,33044
8112c5c0:	783fff15 	stw	zero,-4(r15)
8112c5c4:	581b883a 	mov	r13,r11
8112c5c8:	580b883a 	mov	r5,r11
8112c5cc:	000f883a 	mov	r7,zero
8112c5d0:	003f883a 	mov	ra,zero
8112c5d4:	0019883a 	mov	r12,zero
8112c5d8:	7394da04 	addi	r14,r14,21352
8112c5dc:	04400204 	movi	r17,8
8112c5e0:	04000804 	movi	r16,32
8112c5e4:	04c001c4 	movi	r19,7
8112c5e8:	42000044 	addi	r8,r8,1
8112c5ec:	40c00003 	ldbu	r3,0(r8)
8112c5f0:	18001d26 	beq	r3,zero,8112c668 <__hexnan+0xfc>
8112c5f4:	70c5883a 	add	r2,r14,r3
8112c5f8:	10800003 	ldbu	r2,0(r2)
8112c5fc:	12403fcc 	andi	r9,r2,255
8112c600:	4800301e 	bne	r9,zero,8112c6c4 <__hexnan+0x158>
8112c604:	80c04236 	bltu	r16,r3,8112c710 <__hexnan+0x1a4>
8112c608:	fb3ff70e 	bge	ra,r12,8112c5e8 <__reset+0xfb10c5e8>
8112c60c:	2b40112e 	bgeu	r5,r13,8112c654 <__hexnan+0xe8>
8112c610:	99c01016 	blt	r19,r7,8112c654 <__hexnan+0xe8>
8112c614:	89e9c83a 	sub	r20,r17,r7
8112c618:	a529883a 	add	r20,r20,r20
8112c61c:	2a800017 	ldw	r10,0(r5)
8112c620:	a529883a 	add	r20,r20,r20
8112c624:	852bc83a 	sub	r21,r16,r20
8112c628:	28c00104 	addi	r3,r5,4
8112c62c:	2805883a 	mov	r2,r5
8112c630:	19c00017 	ldw	r7,0(r3)
8112c634:	10800104 	addi	r2,r2,4
8112c638:	18c00104 	addi	r3,r3,4
8112c63c:	3d52983a 	sll	r9,r7,r21
8112c640:	4a92b03a 	or	r9,r9,r10
8112c644:	3d14d83a 	srl	r10,r7,r20
8112c648:	127fff15 	stw	r9,-4(r2)
8112c64c:	1abfff15 	stw	r10,-4(r3)
8112c650:	137ff736 	bltu	r2,r13,8112c630 <__reset+0xfb10c630>
8112c654:	31402836 	bltu	r6,r5,8112c6f8 <__hexnan+0x18c>
8112c658:	42000044 	addi	r8,r8,1
8112c65c:	40c00003 	ldbu	r3,0(r8)
8112c660:	01c00204 	movi	r7,8
8112c664:	183fe31e 	bne	r3,zero,8112c5f4 <__reset+0xfb10c5f4>
8112c668:	60002b26 	beq	r12,zero,8112c718 <__hexnan+0x1ac>
8112c66c:	2b40022e 	bgeu	r5,r13,8112c678 <__hexnan+0x10c>
8112c670:	008001c4 	movi	r2,7
8112c674:	11c0430e 	bge	r2,r7,8112c784 <__hexnan+0x218>
8112c678:	3140312e 	bgeu	r6,r5,8112c740 <__hexnan+0x1d4>
8112c67c:	3007883a 	mov	r3,r6
8112c680:	29000017 	ldw	r4,0(r5)
8112c684:	18800104 	addi	r2,r3,4
8112c688:	29400104 	addi	r5,r5,4
8112c68c:	19000015 	stw	r4,0(r3)
8112c690:	1007883a 	mov	r3,r2
8112c694:	597ffa2e 	bgeu	r11,r5,8112c680 <__reset+0xfb10c680>
8112c698:	10000015 	stw	zero,0(r2)
8112c69c:	10800104 	addi	r2,r2,4
8112c6a0:	58bffd2e 	bgeu	r11,r2,8112c698 <__reset+0xfb10c698>
8112c6a4:	78bfff17 	ldw	r2,-4(r15)
8112c6a8:	1000041e 	bne	r2,zero,8112c6bc <__hexnan+0x150>
8112c6ac:	32c02d26 	beq	r6,r11,8112c764 <__hexnan+0x1f8>
8112c6b0:	5affff04 	addi	r11,r11,-4
8112c6b4:	58800017 	ldw	r2,0(r11)
8112c6b8:	103ffc26 	beq	r2,zero,8112c6ac <__reset+0xfb10c6ac>
8112c6bc:	00800144 	movi	r2,5
8112c6c0:	00001606 	br	8112c71c <__hexnan+0x1b0>
8112c6c4:	39c00044 	addi	r7,r7,1
8112c6c8:	63000044 	addi	r12,r12,1
8112c6cc:	89c0040e 	bge	r17,r7,8112c6e0 <__hexnan+0x174>
8112c6d0:	317fc52e 	bgeu	r6,r5,8112c5e8 <__reset+0xfb10c5e8>
8112c6d4:	283fff15 	stw	zero,-4(r5)
8112c6d8:	01c00044 	movi	r7,1
8112c6dc:	297fff04 	addi	r5,r5,-4
8112c6e0:	28c00017 	ldw	r3,0(r5)
8112c6e4:	108003cc 	andi	r2,r2,15
8112c6e8:	1806913a 	slli	r3,r3,4
8112c6ec:	1884b03a 	or	r2,r3,r2
8112c6f0:	28800015 	stw	r2,0(r5)
8112c6f4:	003fbc06 	br	8112c5e8 <__reset+0xfb10c5e8>
8112c6f8:	2b7fff04 	addi	r13,r5,-4
8112c6fc:	283fff15 	stw	zero,-4(r5)
8112c700:	603f883a 	mov	ra,r12
8112c704:	680b883a 	mov	r5,r13
8112c708:	000f883a 	mov	r7,zero
8112c70c:	003fb606 	br	8112c5e8 <__reset+0xfb10c5e8>
8112c710:	00800a44 	movi	r2,41
8112c714:	18801726 	beq	r3,r2,8112c774 <__hexnan+0x208>
8112c718:	00800104 	movi	r2,4
8112c71c:	dfc00617 	ldw	ra,24(sp)
8112c720:	dd400517 	ldw	r21,20(sp)
8112c724:	dd000417 	ldw	r20,16(sp)
8112c728:	dcc00317 	ldw	r19,12(sp)
8112c72c:	dc800217 	ldw	r18,8(sp)
8112c730:	dc400117 	ldw	r17,4(sp)
8112c734:	dc000017 	ldw	r16,0(sp)
8112c738:	dec00704 	addi	sp,sp,28
8112c73c:	f800283a 	ret
8112c740:	903fd826 	beq	r18,zero,8112c6a4 <__reset+0xfb10c6a4>
8112c744:	00c00804 	movi	r3,32
8112c748:	1ca5c83a 	sub	r18,r3,r18
8112c74c:	00ffffc4 	movi	r3,-1
8112c750:	78bfff17 	ldw	r2,-4(r15)
8112c754:	1c86d83a 	srl	r3,r3,r18
8112c758:	1884703a 	and	r2,r3,r2
8112c75c:	78bfff15 	stw	r2,-4(r15)
8112c760:	003fd106 	br	8112c6a8 <__reset+0xfb10c6a8>
8112c764:	00800044 	movi	r2,1
8112c768:	58800015 	stw	r2,0(r11)
8112c76c:	00800144 	movi	r2,5
8112c770:	003fea06 	br	8112c71c <__reset+0xfb10c71c>
8112c774:	42000044 	addi	r8,r8,1
8112c778:	22000015 	stw	r8,0(r4)
8112c77c:	603fbb1e 	bne	r12,zero,8112c66c <__reset+0xfb10c66c>
8112c780:	003fe506 	br	8112c718 <__reset+0xfb10c718>
8112c784:	02400204 	movi	r9,8
8112c788:	49d3c83a 	sub	r9,r9,r7
8112c78c:	4a53883a 	add	r9,r9,r9
8112c790:	2a000017 	ldw	r8,0(r5)
8112c794:	4a53883a 	add	r9,r9,r9
8112c798:	02800804 	movi	r10,32
8112c79c:	5255c83a 	sub	r10,r10,r9
8112c7a0:	28c00104 	addi	r3,r5,4
8112c7a4:	2805883a 	mov	r2,r5
8112c7a8:	19c00017 	ldw	r7,0(r3)
8112c7ac:	10800104 	addi	r2,r2,4
8112c7b0:	18c00104 	addi	r3,r3,4
8112c7b4:	3a88983a 	sll	r4,r7,r10
8112c7b8:	2208b03a 	or	r4,r4,r8
8112c7bc:	3a50d83a 	srl	r8,r7,r9
8112c7c0:	113fff15 	stw	r4,-4(r2)
8112c7c4:	1a3fff15 	stw	r8,-4(r3)
8112c7c8:	137ff736 	bltu	r2,r13,8112c7a8 <__reset+0xfb10c7a8>
8112c7cc:	003faa06 	br	8112c678 <__reset+0xfb10c678>

8112c7d0 <_isatty_r>:
8112c7d0:	defffd04 	addi	sp,sp,-12
8112c7d4:	de00012e 	bgeu	sp,et,8112c7dc <_isatty_r+0xc>
8112c7d8:	003b68fa 	trap	3
8112c7dc:	dc000015 	stw	r16,0(sp)
8112c7e0:	04204534 	movhi	r16,33044
8112c7e4:	dc400115 	stw	r17,4(sp)
8112c7e8:	841e8704 	addi	r16,r16,31260
8112c7ec:	2023883a 	mov	r17,r4
8112c7f0:	2809883a 	mov	r4,r5
8112c7f4:	dfc00215 	stw	ra,8(sp)
8112c7f8:	80000015 	stw	zero,0(r16)
8112c7fc:	112f4dc0 	call	8112f4dc <isatty>
8112c800:	00ffffc4 	movi	r3,-1
8112c804:	10c00526 	beq	r2,r3,8112c81c <_isatty_r+0x4c>
8112c808:	dfc00217 	ldw	ra,8(sp)
8112c80c:	dc400117 	ldw	r17,4(sp)
8112c810:	dc000017 	ldw	r16,0(sp)
8112c814:	dec00304 	addi	sp,sp,12
8112c818:	f800283a 	ret
8112c81c:	80c00017 	ldw	r3,0(r16)
8112c820:	183ff926 	beq	r3,zero,8112c808 <__reset+0xfb10c808>
8112c824:	88c00015 	stw	r3,0(r17)
8112c828:	003ff706 	br	8112c808 <__reset+0xfb10c808>

8112c82c <_lseek_r>:
8112c82c:	defffd04 	addi	sp,sp,-12
8112c830:	de00012e 	bgeu	sp,et,8112c838 <_lseek_r+0xc>
8112c834:	003b68fa 	trap	3
8112c838:	2805883a 	mov	r2,r5
8112c83c:	dc000015 	stw	r16,0(sp)
8112c840:	04204534 	movhi	r16,33044
8112c844:	dc400115 	stw	r17,4(sp)
8112c848:	300b883a 	mov	r5,r6
8112c84c:	841e8704 	addi	r16,r16,31260
8112c850:	2023883a 	mov	r17,r4
8112c854:	380d883a 	mov	r6,r7
8112c858:	1009883a 	mov	r4,r2
8112c85c:	dfc00215 	stw	ra,8(sp)
8112c860:	80000015 	stw	zero,0(r16)
8112c864:	11300d80 	call	811300d8 <lseek>
8112c868:	00ffffc4 	movi	r3,-1
8112c86c:	10c00526 	beq	r2,r3,8112c884 <_lseek_r+0x58>
8112c870:	dfc00217 	ldw	ra,8(sp)
8112c874:	dc400117 	ldw	r17,4(sp)
8112c878:	dc000017 	ldw	r16,0(sp)
8112c87c:	dec00304 	addi	sp,sp,12
8112c880:	f800283a 	ret
8112c884:	80c00017 	ldw	r3,0(r16)
8112c888:	183ff926 	beq	r3,zero,8112c870 <__reset+0xfb10c870>
8112c88c:	88c00015 	stw	r3,0(r17)
8112c890:	003ff706 	br	8112c870 <__reset+0xfb10c870>

8112c894 <_read_r>:
8112c894:	defffd04 	addi	sp,sp,-12
8112c898:	de00012e 	bgeu	sp,et,8112c8a0 <_read_r+0xc>
8112c89c:	003b68fa 	trap	3
8112c8a0:	2805883a 	mov	r2,r5
8112c8a4:	dc000015 	stw	r16,0(sp)
8112c8a8:	04204534 	movhi	r16,33044
8112c8ac:	dc400115 	stw	r17,4(sp)
8112c8b0:	300b883a 	mov	r5,r6
8112c8b4:	841e8704 	addi	r16,r16,31260
8112c8b8:	2023883a 	mov	r17,r4
8112c8bc:	380d883a 	mov	r6,r7
8112c8c0:	1009883a 	mov	r4,r2
8112c8c4:	dfc00215 	stw	ra,8(sp)
8112c8c8:	80000015 	stw	zero,0(r16)
8112c8cc:	11303540 	call	81130354 <read>
8112c8d0:	00ffffc4 	movi	r3,-1
8112c8d4:	10c00526 	beq	r2,r3,8112c8ec <_read_r+0x58>
8112c8d8:	dfc00217 	ldw	ra,8(sp)
8112c8dc:	dc400117 	ldw	r17,4(sp)
8112c8e0:	dc000017 	ldw	r16,0(sp)
8112c8e4:	dec00304 	addi	sp,sp,12
8112c8e8:	f800283a 	ret
8112c8ec:	80c00017 	ldw	r3,0(r16)
8112c8f0:	183ff926 	beq	r3,zero,8112c8d8 <__reset+0xfb10c8d8>
8112c8f4:	88c00015 	stw	r3,0(r17)
8112c8f8:	003ff706 	br	8112c8d8 <__reset+0xfb10c8d8>

8112c8fc <strncmp>:
8112c8fc:	30003126 	beq	r6,zero,8112c9c4 <strncmp+0xc8>
8112c900:	2144b03a 	or	r2,r4,r5
8112c904:	108000cc 	andi	r2,r2,3
8112c908:	10001e1e 	bne	r2,zero,8112c984 <strncmp+0x88>
8112c90c:	024000c4 	movi	r9,3
8112c910:	49801c2e 	bgeu	r9,r6,8112c984 <strncmp+0x88>
8112c914:	20800017 	ldw	r2,0(r4)
8112c918:	28c00017 	ldw	r3,0(r5)
8112c91c:	10c0191e 	bne	r2,r3,8112c984 <strncmp+0x88>
8112c920:	31bfff04 	addi	r6,r6,-4
8112c924:	30002726 	beq	r6,zero,8112c9c4 <strncmp+0xc8>
8112c928:	02ffbff4 	movhi	r11,65279
8112c92c:	5affbfc4 	addi	r11,r11,-257
8112c930:	0086303a 	nor	r3,zero,r2
8112c934:	02a02074 	movhi	r10,32897
8112c938:	12c5883a 	add	r2,r2,r11
8112c93c:	52a02004 	addi	r10,r10,-32640
8112c940:	10c4703a 	and	r2,r2,r3
8112c944:	1284703a 	and	r2,r2,r10
8112c948:	10000b26 	beq	r2,zero,8112c978 <strncmp+0x7c>
8112c94c:	00001d06 	br	8112c9c4 <strncmp+0xc8>
8112c950:	20c00017 	ldw	r3,0(r4)
8112c954:	29c00017 	ldw	r7,0(r5)
8112c958:	1ad1883a 	add	r8,r3,r11
8112c95c:	00c4303a 	nor	r2,zero,r3
8112c960:	4084703a 	and	r2,r8,r2
8112c964:	1284703a 	and	r2,r2,r10
8112c968:	19c0061e 	bne	r3,r7,8112c984 <strncmp+0x88>
8112c96c:	31bfff04 	addi	r6,r6,-4
8112c970:	30001426 	beq	r6,zero,8112c9c4 <strncmp+0xc8>
8112c974:	1000131e 	bne	r2,zero,8112c9c4 <strncmp+0xc8>
8112c978:	21000104 	addi	r4,r4,4
8112c97c:	29400104 	addi	r5,r5,4
8112c980:	49bff336 	bltu	r9,r6,8112c950 <__reset+0xfb10c950>
8112c984:	28800007 	ldb	r2,0(r5)
8112c988:	20c00007 	ldb	r3,0(r4)
8112c98c:	31bfffc4 	addi	r6,r6,-1
8112c990:	10c0081e 	bne	r2,r3,8112c9b4 <strncmp+0xb8>
8112c994:	30000b26 	beq	r6,zero,8112c9c4 <strncmp+0xc8>
8112c998:	10000a26 	beq	r2,zero,8112c9c4 <strncmp+0xc8>
8112c99c:	21000044 	addi	r4,r4,1
8112c9a0:	29400044 	addi	r5,r5,1
8112c9a4:	20800007 	ldb	r2,0(r4)
8112c9a8:	28c00007 	ldb	r3,0(r5)
8112c9ac:	31bfffc4 	addi	r6,r6,-1
8112c9b0:	10fff826 	beq	r2,r3,8112c994 <__reset+0xfb10c994>
8112c9b4:	20800003 	ldbu	r2,0(r4)
8112c9b8:	28c00003 	ldbu	r3,0(r5)
8112c9bc:	10c5c83a 	sub	r2,r2,r3
8112c9c0:	f800283a 	ret
8112c9c4:	0005883a 	mov	r2,zero
8112c9c8:	f800283a 	ret

8112c9cc <__swbuf_r>:
8112c9cc:	defffb04 	addi	sp,sp,-20
8112c9d0:	de00012e 	bgeu	sp,et,8112c9d8 <__swbuf_r+0xc>
8112c9d4:	003b68fa 	trap	3
8112c9d8:	dcc00315 	stw	r19,12(sp)
8112c9dc:	dc800215 	stw	r18,8(sp)
8112c9e0:	dc000015 	stw	r16,0(sp)
8112c9e4:	dfc00415 	stw	ra,16(sp)
8112c9e8:	dc400115 	stw	r17,4(sp)
8112c9ec:	2025883a 	mov	r18,r4
8112c9f0:	2827883a 	mov	r19,r5
8112c9f4:	3021883a 	mov	r16,r6
8112c9f8:	20000226 	beq	r4,zero,8112ca04 <__swbuf_r+0x38>
8112c9fc:	20800e17 	ldw	r2,56(r4)
8112ca00:	10004226 	beq	r2,zero,8112cb0c <__swbuf_r+0x140>
8112ca04:	80800617 	ldw	r2,24(r16)
8112ca08:	8100030b 	ldhu	r4,12(r16)
8112ca0c:	80800215 	stw	r2,8(r16)
8112ca10:	2080020c 	andi	r2,r4,8
8112ca14:	10003626 	beq	r2,zero,8112caf0 <__swbuf_r+0x124>
8112ca18:	80c00417 	ldw	r3,16(r16)
8112ca1c:	18003426 	beq	r3,zero,8112caf0 <__swbuf_r+0x124>
8112ca20:	2088000c 	andi	r2,r4,8192
8112ca24:	9c403fcc 	andi	r17,r19,255
8112ca28:	10001a26 	beq	r2,zero,8112ca94 <__swbuf_r+0xc8>
8112ca2c:	80800017 	ldw	r2,0(r16)
8112ca30:	81000517 	ldw	r4,20(r16)
8112ca34:	10c7c83a 	sub	r3,r2,r3
8112ca38:	1900200e 	bge	r3,r4,8112cabc <__swbuf_r+0xf0>
8112ca3c:	18c00044 	addi	r3,r3,1
8112ca40:	81000217 	ldw	r4,8(r16)
8112ca44:	11400044 	addi	r5,r2,1
8112ca48:	81400015 	stw	r5,0(r16)
8112ca4c:	213fffc4 	addi	r4,r4,-1
8112ca50:	81000215 	stw	r4,8(r16)
8112ca54:	14c00005 	stb	r19,0(r2)
8112ca58:	80800517 	ldw	r2,20(r16)
8112ca5c:	10c01e26 	beq	r2,r3,8112cad8 <__swbuf_r+0x10c>
8112ca60:	8080030b 	ldhu	r2,12(r16)
8112ca64:	1080004c 	andi	r2,r2,1
8112ca68:	10000226 	beq	r2,zero,8112ca74 <__swbuf_r+0xa8>
8112ca6c:	00800284 	movi	r2,10
8112ca70:	88801926 	beq	r17,r2,8112cad8 <__swbuf_r+0x10c>
8112ca74:	8805883a 	mov	r2,r17
8112ca78:	dfc00417 	ldw	ra,16(sp)
8112ca7c:	dcc00317 	ldw	r19,12(sp)
8112ca80:	dc800217 	ldw	r18,8(sp)
8112ca84:	dc400117 	ldw	r17,4(sp)
8112ca88:	dc000017 	ldw	r16,0(sp)
8112ca8c:	dec00504 	addi	sp,sp,20
8112ca90:	f800283a 	ret
8112ca94:	81401917 	ldw	r5,100(r16)
8112ca98:	00b7ffc4 	movi	r2,-8193
8112ca9c:	21080014 	ori	r4,r4,8192
8112caa0:	2884703a 	and	r2,r5,r2
8112caa4:	80801915 	stw	r2,100(r16)
8112caa8:	80800017 	ldw	r2,0(r16)
8112caac:	8100030d 	sth	r4,12(r16)
8112cab0:	81000517 	ldw	r4,20(r16)
8112cab4:	10c7c83a 	sub	r3,r2,r3
8112cab8:	193fe016 	blt	r3,r4,8112ca3c <__reset+0xfb10ca3c>
8112cabc:	800b883a 	mov	r5,r16
8112cac0:	9009883a 	mov	r4,r18
8112cac4:	11230d00 	call	811230d0 <_fflush_r>
8112cac8:	1000071e 	bne	r2,zero,8112cae8 <__swbuf_r+0x11c>
8112cacc:	80800017 	ldw	r2,0(r16)
8112cad0:	00c00044 	movi	r3,1
8112cad4:	003fda06 	br	8112ca40 <__reset+0xfb10ca40>
8112cad8:	800b883a 	mov	r5,r16
8112cadc:	9009883a 	mov	r4,r18
8112cae0:	11230d00 	call	811230d0 <_fflush_r>
8112cae4:	103fe326 	beq	r2,zero,8112ca74 <__reset+0xfb10ca74>
8112cae8:	00bfffc4 	movi	r2,-1
8112caec:	003fe206 	br	8112ca78 <__reset+0xfb10ca78>
8112caf0:	800b883a 	mov	r5,r16
8112caf4:	9009883a 	mov	r4,r18
8112caf8:	11214b80 	call	811214b8 <__swsetup_r>
8112cafc:	103ffa1e 	bne	r2,zero,8112cae8 <__reset+0xfb10cae8>
8112cb00:	8100030b 	ldhu	r4,12(r16)
8112cb04:	80c00417 	ldw	r3,16(r16)
8112cb08:	003fc506 	br	8112ca20 <__reset+0xfb10ca20>
8112cb0c:	11234cc0 	call	811234cc <__sinit>
8112cb10:	003fbc06 	br	8112ca04 <__reset+0xfb10ca04>

8112cb14 <__swbuf>:
8112cb14:	00a04534 	movhi	r2,33044
8112cb18:	109e0f04 	addi	r2,r2,30780
8112cb1c:	280d883a 	mov	r6,r5
8112cb20:	200b883a 	mov	r5,r4
8112cb24:	11000017 	ldw	r4,0(r2)
8112cb28:	112c9cc1 	jmpi	8112c9cc <__swbuf_r>

8112cb2c <_wcrtomb_r>:
8112cb2c:	defff604 	addi	sp,sp,-40
8112cb30:	00a04534 	movhi	r2,33044
8112cb34:	de00012e 	bgeu	sp,et,8112cb3c <_wcrtomb_r+0x10>
8112cb38:	003b68fa 	trap	3
8112cb3c:	109e1404 	addi	r2,r2,30800
8112cb40:	dc800815 	stw	r18,32(sp)
8112cb44:	dc400715 	stw	r17,28(sp)
8112cb48:	dc000615 	stw	r16,24(sp)
8112cb4c:	dfc00915 	stw	ra,36(sp)
8112cb50:	2021883a 	mov	r16,r4
8112cb54:	3823883a 	mov	r17,r7
8112cb58:	14800017 	ldw	r18,0(r2)
8112cb5c:	28001426 	beq	r5,zero,8112cbb0 <_wcrtomb_r+0x84>
8112cb60:	d9400415 	stw	r5,16(sp)
8112cb64:	d9800515 	stw	r6,20(sp)
8112cb68:	11242e00 	call	811242e0 <__locale_charset>
8112cb6c:	d9800517 	ldw	r6,20(sp)
8112cb70:	d9400417 	ldw	r5,16(sp)
8112cb74:	100f883a 	mov	r7,r2
8112cb78:	dc400015 	stw	r17,0(sp)
8112cb7c:	8009883a 	mov	r4,r16
8112cb80:	903ee83a 	callr	r18
8112cb84:	00ffffc4 	movi	r3,-1
8112cb88:	10c0031e 	bne	r2,r3,8112cb98 <_wcrtomb_r+0x6c>
8112cb8c:	88000015 	stw	zero,0(r17)
8112cb90:	00c02284 	movi	r3,138
8112cb94:	80c00015 	stw	r3,0(r16)
8112cb98:	dfc00917 	ldw	ra,36(sp)
8112cb9c:	dc800817 	ldw	r18,32(sp)
8112cba0:	dc400717 	ldw	r17,28(sp)
8112cba4:	dc000617 	ldw	r16,24(sp)
8112cba8:	dec00a04 	addi	sp,sp,40
8112cbac:	f800283a 	ret
8112cbb0:	11242e00 	call	811242e0 <__locale_charset>
8112cbb4:	100f883a 	mov	r7,r2
8112cbb8:	dc400015 	stw	r17,0(sp)
8112cbbc:	000d883a 	mov	r6,zero
8112cbc0:	d9400104 	addi	r5,sp,4
8112cbc4:	8009883a 	mov	r4,r16
8112cbc8:	903ee83a 	callr	r18
8112cbcc:	003fed06 	br	8112cb84 <__reset+0xfb10cb84>

8112cbd0 <wcrtomb>:
8112cbd0:	defff604 	addi	sp,sp,-40
8112cbd4:	00a04534 	movhi	r2,33044
8112cbd8:	de00012e 	bgeu	sp,et,8112cbe0 <wcrtomb+0x10>
8112cbdc:	003b68fa 	trap	3
8112cbe0:	109e0f04 	addi	r2,r2,30780
8112cbe4:	dc800615 	stw	r18,24(sp)
8112cbe8:	dc400515 	stw	r17,20(sp)
8112cbec:	dfc00915 	stw	ra,36(sp)
8112cbf0:	dd000815 	stw	r20,32(sp)
8112cbf4:	dcc00715 	stw	r19,28(sp)
8112cbf8:	dc000415 	stw	r16,16(sp)
8112cbfc:	3025883a 	mov	r18,r6
8112cc00:	14400017 	ldw	r17,0(r2)
8112cc04:	20001926 	beq	r4,zero,8112cc6c <wcrtomb+0x9c>
8112cc08:	00a04534 	movhi	r2,33044
8112cc0c:	109e1404 	addi	r2,r2,30800
8112cc10:	15000017 	ldw	r20,0(r2)
8112cc14:	2021883a 	mov	r16,r4
8112cc18:	2827883a 	mov	r19,r5
8112cc1c:	11242e00 	call	811242e0 <__locale_charset>
8112cc20:	100f883a 	mov	r7,r2
8112cc24:	dc800015 	stw	r18,0(sp)
8112cc28:	980d883a 	mov	r6,r19
8112cc2c:	800b883a 	mov	r5,r16
8112cc30:	8809883a 	mov	r4,r17
8112cc34:	a03ee83a 	callr	r20
8112cc38:	00ffffc4 	movi	r3,-1
8112cc3c:	10c0031e 	bne	r2,r3,8112cc4c <wcrtomb+0x7c>
8112cc40:	90000015 	stw	zero,0(r18)
8112cc44:	00c02284 	movi	r3,138
8112cc48:	88c00015 	stw	r3,0(r17)
8112cc4c:	dfc00917 	ldw	ra,36(sp)
8112cc50:	dd000817 	ldw	r20,32(sp)
8112cc54:	dcc00717 	ldw	r19,28(sp)
8112cc58:	dc800617 	ldw	r18,24(sp)
8112cc5c:	dc400517 	ldw	r17,20(sp)
8112cc60:	dc000417 	ldw	r16,16(sp)
8112cc64:	dec00a04 	addi	sp,sp,40
8112cc68:	f800283a 	ret
8112cc6c:	00a04534 	movhi	r2,33044
8112cc70:	109e1404 	addi	r2,r2,30800
8112cc74:	14000017 	ldw	r16,0(r2)
8112cc78:	11242e00 	call	811242e0 <__locale_charset>
8112cc7c:	100f883a 	mov	r7,r2
8112cc80:	dc800015 	stw	r18,0(sp)
8112cc84:	000d883a 	mov	r6,zero
8112cc88:	d9400104 	addi	r5,sp,4
8112cc8c:	8809883a 	mov	r4,r17
8112cc90:	803ee83a 	callr	r16
8112cc94:	003fe806 	br	8112cc38 <__reset+0xfb10cc38>

8112cc98 <__ascii_wctomb>:
8112cc98:	28000526 	beq	r5,zero,8112ccb0 <__ascii_wctomb+0x18>
8112cc9c:	00803fc4 	movi	r2,255
8112cca0:	11800536 	bltu	r2,r6,8112ccb8 <__ascii_wctomb+0x20>
8112cca4:	29800005 	stb	r6,0(r5)
8112cca8:	00800044 	movi	r2,1
8112ccac:	f800283a 	ret
8112ccb0:	0005883a 	mov	r2,zero
8112ccb4:	f800283a 	ret
8112ccb8:	00802284 	movi	r2,138
8112ccbc:	20800015 	stw	r2,0(r4)
8112ccc0:	00bfffc4 	movi	r2,-1
8112ccc4:	f800283a 	ret

8112ccc8 <_wctomb_r>:
8112ccc8:	00a04534 	movhi	r2,33044
8112cccc:	defff904 	addi	sp,sp,-28
8112ccd0:	109e1404 	addi	r2,r2,30800
8112ccd4:	de00012e 	bgeu	sp,et,8112ccdc <_wctomb_r+0x14>
8112ccd8:	003b68fa 	trap	3
8112ccdc:	dfc00615 	stw	ra,24(sp)
8112cce0:	dc400515 	stw	r17,20(sp)
8112cce4:	dc000415 	stw	r16,16(sp)
8112cce8:	3823883a 	mov	r17,r7
8112ccec:	14000017 	ldw	r16,0(r2)
8112ccf0:	d9000115 	stw	r4,4(sp)
8112ccf4:	d9400215 	stw	r5,8(sp)
8112ccf8:	d9800315 	stw	r6,12(sp)
8112ccfc:	11242e00 	call	811242e0 <__locale_charset>
8112cd00:	d9800317 	ldw	r6,12(sp)
8112cd04:	d9400217 	ldw	r5,8(sp)
8112cd08:	d9000117 	ldw	r4,4(sp)
8112cd0c:	100f883a 	mov	r7,r2
8112cd10:	dc400015 	stw	r17,0(sp)
8112cd14:	803ee83a 	callr	r16
8112cd18:	dfc00617 	ldw	ra,24(sp)
8112cd1c:	dc400517 	ldw	r17,20(sp)
8112cd20:	dc000417 	ldw	r16,16(sp)
8112cd24:	dec00704 	addi	sp,sp,28
8112cd28:	f800283a 	ret

8112cd2c <__udivdi3>:
8112cd2c:	defff504 	addi	sp,sp,-44
8112cd30:	de00012e 	bgeu	sp,et,8112cd38 <__udivdi3+0xc>
8112cd34:	003b68fa 	trap	3
8112cd38:	dcc00415 	stw	r19,16(sp)
8112cd3c:	dc000115 	stw	r16,4(sp)
8112cd40:	dfc00a15 	stw	ra,40(sp)
8112cd44:	df000915 	stw	fp,36(sp)
8112cd48:	ddc00815 	stw	r23,32(sp)
8112cd4c:	dd800715 	stw	r22,28(sp)
8112cd50:	dd400615 	stw	r21,24(sp)
8112cd54:	dd000515 	stw	r20,20(sp)
8112cd58:	dc800315 	stw	r18,12(sp)
8112cd5c:	dc400215 	stw	r17,8(sp)
8112cd60:	2027883a 	mov	r19,r4
8112cd64:	2821883a 	mov	r16,r5
8112cd68:	3800411e 	bne	r7,zero,8112ce70 <__udivdi3+0x144>
8112cd6c:	3023883a 	mov	r17,r6
8112cd70:	2025883a 	mov	r18,r4
8112cd74:	2980522e 	bgeu	r5,r6,8112cec0 <__udivdi3+0x194>
8112cd78:	00bfffd4 	movui	r2,65535
8112cd7c:	282d883a 	mov	r22,r5
8112cd80:	1180a836 	bltu	r2,r6,8112d024 <__udivdi3+0x2f8>
8112cd84:	00803fc4 	movi	r2,255
8112cd88:	1185803a 	cmpltu	r2,r2,r6
8112cd8c:	100490fa 	slli	r2,r2,3
8112cd90:	3086d83a 	srl	r3,r6,r2
8112cd94:	01204534 	movhi	r4,33044
8112cd98:	21135484 	addi	r4,r4,19794
8112cd9c:	20c7883a 	add	r3,r4,r3
8112cda0:	18c00003 	ldbu	r3,0(r3)
8112cda4:	1885883a 	add	r2,r3,r2
8112cda8:	00c00804 	movi	r3,32
8112cdac:	1887c83a 	sub	r3,r3,r2
8112cdb0:	18000526 	beq	r3,zero,8112cdc8 <__udivdi3+0x9c>
8112cdb4:	80e0983a 	sll	r16,r16,r3
8112cdb8:	9884d83a 	srl	r2,r19,r2
8112cdbc:	30e2983a 	sll	r17,r6,r3
8112cdc0:	98e4983a 	sll	r18,r19,r3
8112cdc4:	142cb03a 	or	r22,r2,r16
8112cdc8:	882ad43a 	srli	r21,r17,16
8112cdcc:	b009883a 	mov	r4,r22
8112cdd0:	8d3fffcc 	andi	r20,r17,65535
8112cdd4:	a80b883a 	mov	r5,r21
8112cdd8:	112d9480 	call	8112d948 <__umodsi3>
8112cddc:	b009883a 	mov	r4,r22
8112cde0:	a80b883a 	mov	r5,r21
8112cde4:	1027883a 	mov	r19,r2
8112cde8:	112d8e40 	call	8112d8e4 <__udivsi3>
8112cdec:	102d883a 	mov	r22,r2
8112cdf0:	9826943a 	slli	r19,r19,16
8112cdf4:	9004d43a 	srli	r2,r18,16
8112cdf8:	a5a1383a 	mul	r16,r20,r22
8112cdfc:	14c4b03a 	or	r2,r2,r19
8112ce00:	1400052e 	bgeu	r2,r16,8112ce18 <__udivdi3+0xec>
8112ce04:	1445883a 	add	r2,r2,r17
8112ce08:	b0ffffc4 	addi	r3,r22,-1
8112ce0c:	14400136 	bltu	r2,r17,8112ce14 <__udivdi3+0xe8>
8112ce10:	14012336 	bltu	r2,r16,8112d2a0 <__udivdi3+0x574>
8112ce14:	182d883a 	mov	r22,r3
8112ce18:	1421c83a 	sub	r16,r2,r16
8112ce1c:	a80b883a 	mov	r5,r21
8112ce20:	8009883a 	mov	r4,r16
8112ce24:	112d9480 	call	8112d948 <__umodsi3>
8112ce28:	1027883a 	mov	r19,r2
8112ce2c:	a80b883a 	mov	r5,r21
8112ce30:	8009883a 	mov	r4,r16
8112ce34:	112d8e40 	call	8112d8e4 <__udivsi3>
8112ce38:	9826943a 	slli	r19,r19,16
8112ce3c:	a0a9383a 	mul	r20,r20,r2
8112ce40:	94bfffcc 	andi	r18,r18,65535
8112ce44:	94e4b03a 	or	r18,r18,r19
8112ce48:	9500052e 	bgeu	r18,r20,8112ce60 <__udivdi3+0x134>
8112ce4c:	8ca5883a 	add	r18,r17,r18
8112ce50:	10ffffc4 	addi	r3,r2,-1
8112ce54:	9440f136 	bltu	r18,r17,8112d21c <__udivdi3+0x4f0>
8112ce58:	9500f02e 	bgeu	r18,r20,8112d21c <__udivdi3+0x4f0>
8112ce5c:	10bfff84 	addi	r2,r2,-2
8112ce60:	b00c943a 	slli	r6,r22,16
8112ce64:	0007883a 	mov	r3,zero
8112ce68:	3084b03a 	or	r2,r6,r2
8112ce6c:	00005906 	br	8112cfd4 <__udivdi3+0x2a8>
8112ce70:	29c05636 	bltu	r5,r7,8112cfcc <__udivdi3+0x2a0>
8112ce74:	00bfffd4 	movui	r2,65535
8112ce78:	11c0622e 	bgeu	r2,r7,8112d004 <__udivdi3+0x2d8>
8112ce7c:	00804034 	movhi	r2,256
8112ce80:	10bfffc4 	addi	r2,r2,-1
8112ce84:	11c0ee36 	bltu	r2,r7,8112d240 <__udivdi3+0x514>
8112ce88:	00800404 	movi	r2,16
8112ce8c:	3886d83a 	srl	r3,r7,r2
8112ce90:	01204534 	movhi	r4,33044
8112ce94:	21135484 	addi	r4,r4,19794
8112ce98:	20c7883a 	add	r3,r4,r3
8112ce9c:	18c00003 	ldbu	r3,0(r3)
8112cea0:	05400804 	movi	r21,32
8112cea4:	1885883a 	add	r2,r3,r2
8112cea8:	a8abc83a 	sub	r21,r21,r2
8112ceac:	a800621e 	bne	r21,zero,8112d038 <__udivdi3+0x30c>
8112ceb0:	3c00e936 	bltu	r7,r16,8112d258 <__udivdi3+0x52c>
8112ceb4:	9985403a 	cmpgeu	r2,r19,r6
8112ceb8:	0007883a 	mov	r3,zero
8112cebc:	00004506 	br	8112cfd4 <__udivdi3+0x2a8>
8112cec0:	3000041e 	bne	r6,zero,8112ced4 <__udivdi3+0x1a8>
8112cec4:	000b883a 	mov	r5,zero
8112cec8:	01000044 	movi	r4,1
8112cecc:	112d8e40 	call	8112d8e4 <__udivsi3>
8112ced0:	1023883a 	mov	r17,r2
8112ced4:	00bfffd4 	movui	r2,65535
8112ced8:	14404e2e 	bgeu	r2,r17,8112d014 <__udivdi3+0x2e8>
8112cedc:	00804034 	movhi	r2,256
8112cee0:	10bfffc4 	addi	r2,r2,-1
8112cee4:	1440d836 	bltu	r2,r17,8112d248 <__udivdi3+0x51c>
8112cee8:	00800404 	movi	r2,16
8112ceec:	8886d83a 	srl	r3,r17,r2
8112cef0:	01204534 	movhi	r4,33044
8112cef4:	21135484 	addi	r4,r4,19794
8112cef8:	20c7883a 	add	r3,r4,r3
8112cefc:	18c00003 	ldbu	r3,0(r3)
8112cf00:	1885883a 	add	r2,r3,r2
8112cf04:	00c00804 	movi	r3,32
8112cf08:	1887c83a 	sub	r3,r3,r2
8112cf0c:	18008f1e 	bne	r3,zero,8112d14c <__udivdi3+0x420>
8112cf10:	882ad43a 	srli	r21,r17,16
8112cf14:	8461c83a 	sub	r16,r16,r17
8112cf18:	8d3fffcc 	andi	r20,r17,65535
8112cf1c:	00c00044 	movi	r3,1
8112cf20:	8009883a 	mov	r4,r16
8112cf24:	a80b883a 	mov	r5,r21
8112cf28:	d8c00015 	stw	r3,0(sp)
8112cf2c:	112d9480 	call	8112d948 <__umodsi3>
8112cf30:	8009883a 	mov	r4,r16
8112cf34:	a80b883a 	mov	r5,r21
8112cf38:	1027883a 	mov	r19,r2
8112cf3c:	112d8e40 	call	8112d8e4 <__udivsi3>
8112cf40:	9826943a 	slli	r19,r19,16
8112cf44:	9008d43a 	srli	r4,r18,16
8112cf48:	1521383a 	mul	r16,r2,r20
8112cf4c:	102d883a 	mov	r22,r2
8112cf50:	24c8b03a 	or	r4,r4,r19
8112cf54:	d8c00017 	ldw	r3,0(sp)
8112cf58:	2400052e 	bgeu	r4,r16,8112cf70 <__udivdi3+0x244>
8112cf5c:	2449883a 	add	r4,r4,r17
8112cf60:	b0bfffc4 	addi	r2,r22,-1
8112cf64:	24400136 	bltu	r4,r17,8112cf6c <__udivdi3+0x240>
8112cf68:	2400ca36 	bltu	r4,r16,8112d294 <__udivdi3+0x568>
8112cf6c:	102d883a 	mov	r22,r2
8112cf70:	2421c83a 	sub	r16,r4,r16
8112cf74:	a80b883a 	mov	r5,r21
8112cf78:	8009883a 	mov	r4,r16
8112cf7c:	d8c00015 	stw	r3,0(sp)
8112cf80:	112d9480 	call	8112d948 <__umodsi3>
8112cf84:	1027883a 	mov	r19,r2
8112cf88:	a80b883a 	mov	r5,r21
8112cf8c:	8009883a 	mov	r4,r16
8112cf90:	112d8e40 	call	8112d8e4 <__udivsi3>
8112cf94:	9826943a 	slli	r19,r19,16
8112cf98:	1529383a 	mul	r20,r2,r20
8112cf9c:	94bfffcc 	andi	r18,r18,65535
8112cfa0:	94e4b03a 	or	r18,r18,r19
8112cfa4:	d8c00017 	ldw	r3,0(sp)
8112cfa8:	9500052e 	bgeu	r18,r20,8112cfc0 <__udivdi3+0x294>
8112cfac:	8ca5883a 	add	r18,r17,r18
8112cfb0:	113fffc4 	addi	r4,r2,-1
8112cfb4:	94409736 	bltu	r18,r17,8112d214 <__udivdi3+0x4e8>
8112cfb8:	9500962e 	bgeu	r18,r20,8112d214 <__udivdi3+0x4e8>
8112cfbc:	10bfff84 	addi	r2,r2,-2
8112cfc0:	b00c943a 	slli	r6,r22,16
8112cfc4:	3084b03a 	or	r2,r6,r2
8112cfc8:	00000206 	br	8112cfd4 <__udivdi3+0x2a8>
8112cfcc:	0007883a 	mov	r3,zero
8112cfd0:	0005883a 	mov	r2,zero
8112cfd4:	dfc00a17 	ldw	ra,40(sp)
8112cfd8:	df000917 	ldw	fp,36(sp)
8112cfdc:	ddc00817 	ldw	r23,32(sp)
8112cfe0:	dd800717 	ldw	r22,28(sp)
8112cfe4:	dd400617 	ldw	r21,24(sp)
8112cfe8:	dd000517 	ldw	r20,20(sp)
8112cfec:	dcc00417 	ldw	r19,16(sp)
8112cff0:	dc800317 	ldw	r18,12(sp)
8112cff4:	dc400217 	ldw	r17,8(sp)
8112cff8:	dc000117 	ldw	r16,4(sp)
8112cffc:	dec00b04 	addi	sp,sp,44
8112d000:	f800283a 	ret
8112d004:	00803fc4 	movi	r2,255
8112d008:	11c5803a 	cmpltu	r2,r2,r7
8112d00c:	100490fa 	slli	r2,r2,3
8112d010:	003f9e06 	br	8112ce8c <__reset+0xfb10ce8c>
8112d014:	00803fc4 	movi	r2,255
8112d018:	1445803a 	cmpltu	r2,r2,r17
8112d01c:	100490fa 	slli	r2,r2,3
8112d020:	003fb206 	br	8112ceec <__reset+0xfb10ceec>
8112d024:	00804034 	movhi	r2,256
8112d028:	10bfffc4 	addi	r2,r2,-1
8112d02c:	11808836 	bltu	r2,r6,8112d250 <__udivdi3+0x524>
8112d030:	00800404 	movi	r2,16
8112d034:	003f5606 	br	8112cd90 <__reset+0xfb10cd90>
8112d038:	30aed83a 	srl	r23,r6,r2
8112d03c:	3d4e983a 	sll	r7,r7,r21
8112d040:	80acd83a 	srl	r22,r16,r2
8112d044:	9884d83a 	srl	r2,r19,r2
8112d048:	3deeb03a 	or	r23,r7,r23
8112d04c:	b824d43a 	srli	r18,r23,16
8112d050:	8560983a 	sll	r16,r16,r21
8112d054:	b009883a 	mov	r4,r22
8112d058:	900b883a 	mov	r5,r18
8112d05c:	3568983a 	sll	r20,r6,r21
8112d060:	1420b03a 	or	r16,r2,r16
8112d064:	112d9480 	call	8112d948 <__umodsi3>
8112d068:	b009883a 	mov	r4,r22
8112d06c:	900b883a 	mov	r5,r18
8112d070:	1023883a 	mov	r17,r2
8112d074:	112d8e40 	call	8112d8e4 <__udivsi3>
8112d078:	8808943a 	slli	r4,r17,16
8112d07c:	bf3fffcc 	andi	fp,r23,65535
8112d080:	8006d43a 	srli	r3,r16,16
8112d084:	e0a3383a 	mul	r17,fp,r2
8112d088:	100d883a 	mov	r6,r2
8112d08c:	1906b03a 	or	r3,r3,r4
8112d090:	1c40042e 	bgeu	r3,r17,8112d0a4 <__udivdi3+0x378>
8112d094:	1dc7883a 	add	r3,r3,r23
8112d098:	10bfffc4 	addi	r2,r2,-1
8112d09c:	1dc0752e 	bgeu	r3,r23,8112d274 <__udivdi3+0x548>
8112d0a0:	100d883a 	mov	r6,r2
8112d0a4:	1c63c83a 	sub	r17,r3,r17
8112d0a8:	900b883a 	mov	r5,r18
8112d0ac:	8809883a 	mov	r4,r17
8112d0b0:	d9800015 	stw	r6,0(sp)
8112d0b4:	112d9480 	call	8112d948 <__umodsi3>
8112d0b8:	102d883a 	mov	r22,r2
8112d0bc:	8809883a 	mov	r4,r17
8112d0c0:	900b883a 	mov	r5,r18
8112d0c4:	112d8e40 	call	8112d8e4 <__udivsi3>
8112d0c8:	b02c943a 	slli	r22,r22,16
8112d0cc:	e089383a 	mul	r4,fp,r2
8112d0d0:	843fffcc 	andi	r16,r16,65535
8112d0d4:	85a0b03a 	or	r16,r16,r22
8112d0d8:	d9800017 	ldw	r6,0(sp)
8112d0dc:	8100042e 	bgeu	r16,r4,8112d0f0 <__udivdi3+0x3c4>
8112d0e0:	85e1883a 	add	r16,r16,r23
8112d0e4:	10ffffc4 	addi	r3,r2,-1
8112d0e8:	85c05e2e 	bgeu	r16,r23,8112d264 <__udivdi3+0x538>
8112d0ec:	1805883a 	mov	r2,r3
8112d0f0:	300c943a 	slli	r6,r6,16
8112d0f4:	a17fffcc 	andi	r5,r20,65535
8112d0f8:	a028d43a 	srli	r20,r20,16
8112d0fc:	3084b03a 	or	r2,r6,r2
8112d100:	10ffffcc 	andi	r3,r2,65535
8112d104:	100cd43a 	srli	r6,r2,16
8112d108:	194f383a 	mul	r7,r3,r5
8112d10c:	1d07383a 	mul	r3,r3,r20
8112d110:	314b383a 	mul	r5,r6,r5
8112d114:	3810d43a 	srli	r8,r7,16
8112d118:	8121c83a 	sub	r16,r16,r4
8112d11c:	1947883a 	add	r3,r3,r5
8112d120:	40c7883a 	add	r3,r8,r3
8112d124:	350d383a 	mul	r6,r6,r20
8112d128:	1940022e 	bgeu	r3,r5,8112d134 <__udivdi3+0x408>
8112d12c:	01000074 	movhi	r4,1
8112d130:	310d883a 	add	r6,r6,r4
8112d134:	1828d43a 	srli	r20,r3,16
8112d138:	a18d883a 	add	r6,r20,r6
8112d13c:	81803e36 	bltu	r16,r6,8112d238 <__udivdi3+0x50c>
8112d140:	81803826 	beq	r16,r6,8112d224 <__udivdi3+0x4f8>
8112d144:	0007883a 	mov	r3,zero
8112d148:	003fa206 	br	8112cfd4 <__reset+0xfb10cfd4>
8112d14c:	88e2983a 	sll	r17,r17,r3
8112d150:	80a8d83a 	srl	r20,r16,r2
8112d154:	80e0983a 	sll	r16,r16,r3
8112d158:	882ad43a 	srli	r21,r17,16
8112d15c:	9884d83a 	srl	r2,r19,r2
8112d160:	a009883a 	mov	r4,r20
8112d164:	a80b883a 	mov	r5,r21
8112d168:	142eb03a 	or	r23,r2,r16
8112d16c:	98e4983a 	sll	r18,r19,r3
8112d170:	112d9480 	call	8112d948 <__umodsi3>
8112d174:	a009883a 	mov	r4,r20
8112d178:	a80b883a 	mov	r5,r21
8112d17c:	1021883a 	mov	r16,r2
8112d180:	112d8e40 	call	8112d8e4 <__udivsi3>
8112d184:	1039883a 	mov	fp,r2
8112d188:	8d3fffcc 	andi	r20,r17,65535
8112d18c:	8020943a 	slli	r16,r16,16
8112d190:	b804d43a 	srli	r2,r23,16
8112d194:	a72d383a 	mul	r22,r20,fp
8112d198:	1404b03a 	or	r2,r2,r16
8112d19c:	1580062e 	bgeu	r2,r22,8112d1b8 <__udivdi3+0x48c>
8112d1a0:	1445883a 	add	r2,r2,r17
8112d1a4:	e0ffffc4 	addi	r3,fp,-1
8112d1a8:	14403836 	bltu	r2,r17,8112d28c <__udivdi3+0x560>
8112d1ac:	1580372e 	bgeu	r2,r22,8112d28c <__udivdi3+0x560>
8112d1b0:	e73fff84 	addi	fp,fp,-2
8112d1b4:	1445883a 	add	r2,r2,r17
8112d1b8:	15adc83a 	sub	r22,r2,r22
8112d1bc:	a80b883a 	mov	r5,r21
8112d1c0:	b009883a 	mov	r4,r22
8112d1c4:	112d9480 	call	8112d948 <__umodsi3>
8112d1c8:	1027883a 	mov	r19,r2
8112d1cc:	b009883a 	mov	r4,r22
8112d1d0:	a80b883a 	mov	r5,r21
8112d1d4:	112d8e40 	call	8112d8e4 <__udivsi3>
8112d1d8:	9826943a 	slli	r19,r19,16
8112d1dc:	a0a1383a 	mul	r16,r20,r2
8112d1e0:	b93fffcc 	andi	r4,r23,65535
8112d1e4:	24c8b03a 	or	r4,r4,r19
8112d1e8:	2400062e 	bgeu	r4,r16,8112d204 <__udivdi3+0x4d8>
8112d1ec:	2449883a 	add	r4,r4,r17
8112d1f0:	10ffffc4 	addi	r3,r2,-1
8112d1f4:	24402336 	bltu	r4,r17,8112d284 <__udivdi3+0x558>
8112d1f8:	2400222e 	bgeu	r4,r16,8112d284 <__udivdi3+0x558>
8112d1fc:	10bfff84 	addi	r2,r2,-2
8112d200:	2449883a 	add	r4,r4,r17
8112d204:	e038943a 	slli	fp,fp,16
8112d208:	2421c83a 	sub	r16,r4,r16
8112d20c:	e086b03a 	or	r3,fp,r2
8112d210:	003f4306 	br	8112cf20 <__reset+0xfb10cf20>
8112d214:	2005883a 	mov	r2,r4
8112d218:	003f6906 	br	8112cfc0 <__reset+0xfb10cfc0>
8112d21c:	1805883a 	mov	r2,r3
8112d220:	003f0f06 	br	8112ce60 <__reset+0xfb10ce60>
8112d224:	1806943a 	slli	r3,r3,16
8112d228:	9d66983a 	sll	r19,r19,r21
8112d22c:	39ffffcc 	andi	r7,r7,65535
8112d230:	19c7883a 	add	r3,r3,r7
8112d234:	98ffc32e 	bgeu	r19,r3,8112d144 <__reset+0xfb10d144>
8112d238:	10bfffc4 	addi	r2,r2,-1
8112d23c:	003fc106 	br	8112d144 <__reset+0xfb10d144>
8112d240:	00800604 	movi	r2,24
8112d244:	003f1106 	br	8112ce8c <__reset+0xfb10ce8c>
8112d248:	00800604 	movi	r2,24
8112d24c:	003f2706 	br	8112ceec <__reset+0xfb10ceec>
8112d250:	00800604 	movi	r2,24
8112d254:	003ece06 	br	8112cd90 <__reset+0xfb10cd90>
8112d258:	0007883a 	mov	r3,zero
8112d25c:	00800044 	movi	r2,1
8112d260:	003f5c06 	br	8112cfd4 <__reset+0xfb10cfd4>
8112d264:	813fa12e 	bgeu	r16,r4,8112d0ec <__reset+0xfb10d0ec>
8112d268:	10bfff84 	addi	r2,r2,-2
8112d26c:	85e1883a 	add	r16,r16,r23
8112d270:	003f9f06 	br	8112d0f0 <__reset+0xfb10d0f0>
8112d274:	1c7f8a2e 	bgeu	r3,r17,8112d0a0 <__reset+0xfb10d0a0>
8112d278:	31bfff84 	addi	r6,r6,-2
8112d27c:	1dc7883a 	add	r3,r3,r23
8112d280:	003f8806 	br	8112d0a4 <__reset+0xfb10d0a4>
8112d284:	1805883a 	mov	r2,r3
8112d288:	003fde06 	br	8112d204 <__reset+0xfb10d204>
8112d28c:	1839883a 	mov	fp,r3
8112d290:	003fc906 	br	8112d1b8 <__reset+0xfb10d1b8>
8112d294:	b5bfff84 	addi	r22,r22,-2
8112d298:	2449883a 	add	r4,r4,r17
8112d29c:	003f3406 	br	8112cf70 <__reset+0xfb10cf70>
8112d2a0:	b5bfff84 	addi	r22,r22,-2
8112d2a4:	1445883a 	add	r2,r2,r17
8112d2a8:	003edb06 	br	8112ce18 <__reset+0xfb10ce18>

8112d2ac <__umoddi3>:
8112d2ac:	defff404 	addi	sp,sp,-48
8112d2b0:	de00012e 	bgeu	sp,et,8112d2b8 <__umoddi3+0xc>
8112d2b4:	003b68fa 	trap	3
8112d2b8:	df000a15 	stw	fp,40(sp)
8112d2bc:	dc400315 	stw	r17,12(sp)
8112d2c0:	dc000215 	stw	r16,8(sp)
8112d2c4:	dfc00b15 	stw	ra,44(sp)
8112d2c8:	ddc00915 	stw	r23,36(sp)
8112d2cc:	dd800815 	stw	r22,32(sp)
8112d2d0:	dd400715 	stw	r21,28(sp)
8112d2d4:	dd000615 	stw	r20,24(sp)
8112d2d8:	dcc00515 	stw	r19,20(sp)
8112d2dc:	dc800415 	stw	r18,16(sp)
8112d2e0:	2021883a 	mov	r16,r4
8112d2e4:	2823883a 	mov	r17,r5
8112d2e8:	2839883a 	mov	fp,r5
8112d2ec:	38003c1e 	bne	r7,zero,8112d3e0 <__umoddi3+0x134>
8112d2f0:	3027883a 	mov	r19,r6
8112d2f4:	2029883a 	mov	r20,r4
8112d2f8:	2980512e 	bgeu	r5,r6,8112d440 <__umoddi3+0x194>
8112d2fc:	00bfffd4 	movui	r2,65535
8112d300:	11809a36 	bltu	r2,r6,8112d56c <__umoddi3+0x2c0>
8112d304:	01003fc4 	movi	r4,255
8112d308:	2189803a 	cmpltu	r4,r4,r6
8112d30c:	200890fa 	slli	r4,r4,3
8112d310:	3104d83a 	srl	r2,r6,r4
8112d314:	00e04534 	movhi	r3,33044
8112d318:	18d35484 	addi	r3,r3,19794
8112d31c:	1885883a 	add	r2,r3,r2
8112d320:	10c00003 	ldbu	r3,0(r2)
8112d324:	00800804 	movi	r2,32
8112d328:	1909883a 	add	r4,r3,r4
8112d32c:	1125c83a 	sub	r18,r2,r4
8112d330:	90000526 	beq	r18,zero,8112d348 <__umoddi3+0x9c>
8112d334:	8ca2983a 	sll	r17,r17,r18
8112d338:	8108d83a 	srl	r4,r16,r4
8112d33c:	34a6983a 	sll	r19,r6,r18
8112d340:	84a8983a 	sll	r20,r16,r18
8112d344:	2478b03a 	or	fp,r4,r17
8112d348:	982ed43a 	srli	r23,r19,16
8112d34c:	e009883a 	mov	r4,fp
8112d350:	9dbfffcc 	andi	r22,r19,65535
8112d354:	b80b883a 	mov	r5,r23
8112d358:	112d9480 	call	8112d948 <__umodsi3>
8112d35c:	e009883a 	mov	r4,fp
8112d360:	b80b883a 	mov	r5,r23
8112d364:	102b883a 	mov	r21,r2
8112d368:	112d8e40 	call	8112d8e4 <__udivsi3>
8112d36c:	a806943a 	slli	r3,r21,16
8112d370:	a008d43a 	srli	r4,r20,16
8112d374:	b085383a 	mul	r2,r22,r2
8112d378:	20c8b03a 	or	r4,r4,r3
8112d37c:	2080032e 	bgeu	r4,r2,8112d38c <__umoddi3+0xe0>
8112d380:	24c9883a 	add	r4,r4,r19
8112d384:	24c00136 	bltu	r4,r19,8112d38c <__umoddi3+0xe0>
8112d388:	20811036 	bltu	r4,r2,8112d7cc <__umoddi3+0x520>
8112d38c:	20abc83a 	sub	r21,r4,r2
8112d390:	b80b883a 	mov	r5,r23
8112d394:	a809883a 	mov	r4,r21
8112d398:	112d9480 	call	8112d948 <__umodsi3>
8112d39c:	1023883a 	mov	r17,r2
8112d3a0:	b80b883a 	mov	r5,r23
8112d3a4:	a809883a 	mov	r4,r21
8112d3a8:	112d8e40 	call	8112d8e4 <__udivsi3>
8112d3ac:	8822943a 	slli	r17,r17,16
8112d3b0:	b085383a 	mul	r2,r22,r2
8112d3b4:	a0ffffcc 	andi	r3,r20,65535
8112d3b8:	1c46b03a 	or	r3,r3,r17
8112d3bc:	1880042e 	bgeu	r3,r2,8112d3d0 <__umoddi3+0x124>
8112d3c0:	1cc7883a 	add	r3,r3,r19
8112d3c4:	1cc00236 	bltu	r3,r19,8112d3d0 <__umoddi3+0x124>
8112d3c8:	1880012e 	bgeu	r3,r2,8112d3d0 <__umoddi3+0x124>
8112d3cc:	1cc7883a 	add	r3,r3,r19
8112d3d0:	1885c83a 	sub	r2,r3,r2
8112d3d4:	1484d83a 	srl	r2,r2,r18
8112d3d8:	0007883a 	mov	r3,zero
8112d3dc:	00004f06 	br	8112d51c <__umoddi3+0x270>
8112d3e0:	29c04c36 	bltu	r5,r7,8112d514 <__umoddi3+0x268>
8112d3e4:	00bfffd4 	movui	r2,65535
8112d3e8:	11c0582e 	bgeu	r2,r7,8112d54c <__umoddi3+0x2a0>
8112d3ec:	00804034 	movhi	r2,256
8112d3f0:	10bfffc4 	addi	r2,r2,-1
8112d3f4:	11c0e736 	bltu	r2,r7,8112d794 <__umoddi3+0x4e8>
8112d3f8:	01000404 	movi	r4,16
8112d3fc:	3904d83a 	srl	r2,r7,r4
8112d400:	00e04534 	movhi	r3,33044
8112d404:	18d35484 	addi	r3,r3,19794
8112d408:	1885883a 	add	r2,r3,r2
8112d40c:	14c00003 	ldbu	r19,0(r2)
8112d410:	00c00804 	movi	r3,32
8112d414:	9927883a 	add	r19,r19,r4
8112d418:	1ce9c83a 	sub	r20,r3,r19
8112d41c:	a000581e 	bne	r20,zero,8112d580 <__umoddi3+0x2d4>
8112d420:	3c400136 	bltu	r7,r17,8112d428 <__umoddi3+0x17c>
8112d424:	8180eb36 	bltu	r16,r6,8112d7d4 <__umoddi3+0x528>
8112d428:	8185c83a 	sub	r2,r16,r6
8112d42c:	89e3c83a 	sub	r17,r17,r7
8112d430:	8089803a 	cmpltu	r4,r16,r2
8112d434:	8939c83a 	sub	fp,r17,r4
8112d438:	e007883a 	mov	r3,fp
8112d43c:	00003706 	br	8112d51c <__umoddi3+0x270>
8112d440:	3000041e 	bne	r6,zero,8112d454 <__umoddi3+0x1a8>
8112d444:	000b883a 	mov	r5,zero
8112d448:	01000044 	movi	r4,1
8112d44c:	112d8e40 	call	8112d8e4 <__udivsi3>
8112d450:	1027883a 	mov	r19,r2
8112d454:	00bfffd4 	movui	r2,65535
8112d458:	14c0402e 	bgeu	r2,r19,8112d55c <__umoddi3+0x2b0>
8112d45c:	00804034 	movhi	r2,256
8112d460:	10bfffc4 	addi	r2,r2,-1
8112d464:	14c0cd36 	bltu	r2,r19,8112d79c <__umoddi3+0x4f0>
8112d468:	00800404 	movi	r2,16
8112d46c:	9886d83a 	srl	r3,r19,r2
8112d470:	01204534 	movhi	r4,33044
8112d474:	21135484 	addi	r4,r4,19794
8112d478:	20c7883a 	add	r3,r4,r3
8112d47c:	18c00003 	ldbu	r3,0(r3)
8112d480:	1887883a 	add	r3,r3,r2
8112d484:	00800804 	movi	r2,32
8112d488:	10e5c83a 	sub	r18,r2,r3
8112d48c:	9000901e 	bne	r18,zero,8112d6d0 <__umoddi3+0x424>
8112d490:	982cd43a 	srli	r22,r19,16
8112d494:	8ce3c83a 	sub	r17,r17,r19
8112d498:	9d7fffcc 	andi	r21,r19,65535
8112d49c:	b00b883a 	mov	r5,r22
8112d4a0:	8809883a 	mov	r4,r17
8112d4a4:	112d9480 	call	8112d948 <__umodsi3>
8112d4a8:	8809883a 	mov	r4,r17
8112d4ac:	b00b883a 	mov	r5,r22
8112d4b0:	1021883a 	mov	r16,r2
8112d4b4:	112d8e40 	call	8112d8e4 <__udivsi3>
8112d4b8:	8006943a 	slli	r3,r16,16
8112d4bc:	a008d43a 	srli	r4,r20,16
8112d4c0:	1545383a 	mul	r2,r2,r21
8112d4c4:	20c8b03a 	or	r4,r4,r3
8112d4c8:	2080042e 	bgeu	r4,r2,8112d4dc <__umoddi3+0x230>
8112d4cc:	24c9883a 	add	r4,r4,r19
8112d4d0:	24c00236 	bltu	r4,r19,8112d4dc <__umoddi3+0x230>
8112d4d4:	2080012e 	bgeu	r4,r2,8112d4dc <__umoddi3+0x230>
8112d4d8:	24c9883a 	add	r4,r4,r19
8112d4dc:	20a1c83a 	sub	r16,r4,r2
8112d4e0:	b00b883a 	mov	r5,r22
8112d4e4:	8009883a 	mov	r4,r16
8112d4e8:	112d9480 	call	8112d948 <__umodsi3>
8112d4ec:	1023883a 	mov	r17,r2
8112d4f0:	b00b883a 	mov	r5,r22
8112d4f4:	8009883a 	mov	r4,r16
8112d4f8:	112d8e40 	call	8112d8e4 <__udivsi3>
8112d4fc:	8822943a 	slli	r17,r17,16
8112d500:	1545383a 	mul	r2,r2,r21
8112d504:	a53fffcc 	andi	r20,r20,65535
8112d508:	a446b03a 	or	r3,r20,r17
8112d50c:	18bfb02e 	bgeu	r3,r2,8112d3d0 <__reset+0xfb10d3d0>
8112d510:	003fab06 	br	8112d3c0 <__reset+0xfb10d3c0>
8112d514:	2005883a 	mov	r2,r4
8112d518:	2807883a 	mov	r3,r5
8112d51c:	dfc00b17 	ldw	ra,44(sp)
8112d520:	df000a17 	ldw	fp,40(sp)
8112d524:	ddc00917 	ldw	r23,36(sp)
8112d528:	dd800817 	ldw	r22,32(sp)
8112d52c:	dd400717 	ldw	r21,28(sp)
8112d530:	dd000617 	ldw	r20,24(sp)
8112d534:	dcc00517 	ldw	r19,20(sp)
8112d538:	dc800417 	ldw	r18,16(sp)
8112d53c:	dc400317 	ldw	r17,12(sp)
8112d540:	dc000217 	ldw	r16,8(sp)
8112d544:	dec00c04 	addi	sp,sp,48
8112d548:	f800283a 	ret
8112d54c:	04c03fc4 	movi	r19,255
8112d550:	99c9803a 	cmpltu	r4,r19,r7
8112d554:	200890fa 	slli	r4,r4,3
8112d558:	003fa806 	br	8112d3fc <__reset+0xfb10d3fc>
8112d55c:	00803fc4 	movi	r2,255
8112d560:	14c5803a 	cmpltu	r2,r2,r19
8112d564:	100490fa 	slli	r2,r2,3
8112d568:	003fc006 	br	8112d46c <__reset+0xfb10d46c>
8112d56c:	00804034 	movhi	r2,256
8112d570:	10bfffc4 	addi	r2,r2,-1
8112d574:	11808b36 	bltu	r2,r6,8112d7a4 <__umoddi3+0x4f8>
8112d578:	01000404 	movi	r4,16
8112d57c:	003f6406 	br	8112d310 <__reset+0xfb10d310>
8112d580:	34c4d83a 	srl	r2,r6,r19
8112d584:	3d0e983a 	sll	r7,r7,r20
8112d588:	8cf8d83a 	srl	fp,r17,r19
8112d58c:	8d10983a 	sll	r8,r17,r20
8112d590:	38aab03a 	or	r21,r7,r2
8112d594:	a82cd43a 	srli	r22,r21,16
8112d598:	84e2d83a 	srl	r17,r16,r19
8112d59c:	e009883a 	mov	r4,fp
8112d5a0:	b00b883a 	mov	r5,r22
8112d5a4:	8a22b03a 	or	r17,r17,r8
8112d5a8:	3524983a 	sll	r18,r6,r20
8112d5ac:	112d9480 	call	8112d948 <__umodsi3>
8112d5b0:	e009883a 	mov	r4,fp
8112d5b4:	b00b883a 	mov	r5,r22
8112d5b8:	102f883a 	mov	r23,r2
8112d5bc:	112d8e40 	call	8112d8e4 <__udivsi3>
8112d5c0:	100d883a 	mov	r6,r2
8112d5c4:	b808943a 	slli	r4,r23,16
8112d5c8:	aa3fffcc 	andi	r8,r21,65535
8112d5cc:	8804d43a 	srli	r2,r17,16
8112d5d0:	41af383a 	mul	r23,r8,r6
8112d5d4:	8520983a 	sll	r16,r16,r20
8112d5d8:	1104b03a 	or	r2,r2,r4
8112d5dc:	15c0042e 	bgeu	r2,r23,8112d5f0 <__umoddi3+0x344>
8112d5e0:	1545883a 	add	r2,r2,r21
8112d5e4:	30ffffc4 	addi	r3,r6,-1
8112d5e8:	1540742e 	bgeu	r2,r21,8112d7bc <__umoddi3+0x510>
8112d5ec:	180d883a 	mov	r6,r3
8112d5f0:	15efc83a 	sub	r23,r2,r23
8112d5f4:	b00b883a 	mov	r5,r22
8112d5f8:	b809883a 	mov	r4,r23
8112d5fc:	d9800115 	stw	r6,4(sp)
8112d600:	da000015 	stw	r8,0(sp)
8112d604:	112d9480 	call	8112d948 <__umodsi3>
8112d608:	b00b883a 	mov	r5,r22
8112d60c:	b809883a 	mov	r4,r23
8112d610:	1039883a 	mov	fp,r2
8112d614:	112d8e40 	call	8112d8e4 <__udivsi3>
8112d618:	da000017 	ldw	r8,0(sp)
8112d61c:	e038943a 	slli	fp,fp,16
8112d620:	100b883a 	mov	r5,r2
8112d624:	4089383a 	mul	r4,r8,r2
8112d628:	8a3fffcc 	andi	r8,r17,65535
8112d62c:	4710b03a 	or	r8,r8,fp
8112d630:	d9800117 	ldw	r6,4(sp)
8112d634:	4100042e 	bgeu	r8,r4,8112d648 <__umoddi3+0x39c>
8112d638:	4551883a 	add	r8,r8,r21
8112d63c:	10bfffc4 	addi	r2,r2,-1
8112d640:	45405a2e 	bgeu	r8,r21,8112d7ac <__umoddi3+0x500>
8112d644:	100b883a 	mov	r5,r2
8112d648:	300c943a 	slli	r6,r6,16
8112d64c:	91ffffcc 	andi	r7,r18,65535
8112d650:	9004d43a 	srli	r2,r18,16
8112d654:	314cb03a 	or	r6,r6,r5
8112d658:	317fffcc 	andi	r5,r6,65535
8112d65c:	300cd43a 	srli	r6,r6,16
8112d660:	29d3383a 	mul	r9,r5,r7
8112d664:	288b383a 	mul	r5,r5,r2
8112d668:	31cf383a 	mul	r7,r6,r7
8112d66c:	4806d43a 	srli	r3,r9,16
8112d670:	4111c83a 	sub	r8,r8,r4
8112d674:	29cb883a 	add	r5,r5,r7
8112d678:	194b883a 	add	r5,r3,r5
8112d67c:	3085383a 	mul	r2,r6,r2
8112d680:	29c0022e 	bgeu	r5,r7,8112d68c <__umoddi3+0x3e0>
8112d684:	00c00074 	movhi	r3,1
8112d688:	10c5883a 	add	r2,r2,r3
8112d68c:	2808d43a 	srli	r4,r5,16
8112d690:	280a943a 	slli	r5,r5,16
8112d694:	4a7fffcc 	andi	r9,r9,65535
8112d698:	2085883a 	add	r2,r4,r2
8112d69c:	2a4b883a 	add	r5,r5,r9
8112d6a0:	40803636 	bltu	r8,r2,8112d77c <__umoddi3+0x4d0>
8112d6a4:	40804d26 	beq	r8,r2,8112d7dc <__umoddi3+0x530>
8112d6a8:	4089c83a 	sub	r4,r8,r2
8112d6ac:	280f883a 	mov	r7,r5
8112d6b0:	81cfc83a 	sub	r7,r16,r7
8112d6b4:	81c7803a 	cmpltu	r3,r16,r7
8112d6b8:	20c7c83a 	sub	r3,r4,r3
8112d6bc:	1cc4983a 	sll	r2,r3,r19
8112d6c0:	3d0ed83a 	srl	r7,r7,r20
8112d6c4:	1d06d83a 	srl	r3,r3,r20
8112d6c8:	11c4b03a 	or	r2,r2,r7
8112d6cc:	003f9306 	br	8112d51c <__reset+0xfb10d51c>
8112d6d0:	9ca6983a 	sll	r19,r19,r18
8112d6d4:	88e8d83a 	srl	r20,r17,r3
8112d6d8:	80c4d83a 	srl	r2,r16,r3
8112d6dc:	982cd43a 	srli	r22,r19,16
8112d6e0:	8ca2983a 	sll	r17,r17,r18
8112d6e4:	a009883a 	mov	r4,r20
8112d6e8:	b00b883a 	mov	r5,r22
8112d6ec:	1478b03a 	or	fp,r2,r17
8112d6f0:	112d9480 	call	8112d948 <__umodsi3>
8112d6f4:	a009883a 	mov	r4,r20
8112d6f8:	b00b883a 	mov	r5,r22
8112d6fc:	1023883a 	mov	r17,r2
8112d700:	112d8e40 	call	8112d8e4 <__udivsi3>
8112d704:	9d7fffcc 	andi	r21,r19,65535
8112d708:	880a943a 	slli	r5,r17,16
8112d70c:	e008d43a 	srli	r4,fp,16
8112d710:	a885383a 	mul	r2,r21,r2
8112d714:	84a8983a 	sll	r20,r16,r18
8112d718:	2148b03a 	or	r4,r4,r5
8112d71c:	2080042e 	bgeu	r4,r2,8112d730 <__umoddi3+0x484>
8112d720:	24c9883a 	add	r4,r4,r19
8112d724:	24c00236 	bltu	r4,r19,8112d730 <__umoddi3+0x484>
8112d728:	2080012e 	bgeu	r4,r2,8112d730 <__umoddi3+0x484>
8112d72c:	24c9883a 	add	r4,r4,r19
8112d730:	20a3c83a 	sub	r17,r4,r2
8112d734:	b00b883a 	mov	r5,r22
8112d738:	8809883a 	mov	r4,r17
8112d73c:	112d9480 	call	8112d948 <__umodsi3>
8112d740:	102f883a 	mov	r23,r2
8112d744:	8809883a 	mov	r4,r17
8112d748:	b00b883a 	mov	r5,r22
8112d74c:	112d8e40 	call	8112d8e4 <__udivsi3>
8112d750:	b82e943a 	slli	r23,r23,16
8112d754:	a885383a 	mul	r2,r21,r2
8112d758:	e13fffcc 	andi	r4,fp,65535
8112d75c:	25c8b03a 	or	r4,r4,r23
8112d760:	2080042e 	bgeu	r4,r2,8112d774 <__umoddi3+0x4c8>
8112d764:	24c9883a 	add	r4,r4,r19
8112d768:	24c00236 	bltu	r4,r19,8112d774 <__umoddi3+0x4c8>
8112d76c:	2080012e 	bgeu	r4,r2,8112d774 <__umoddi3+0x4c8>
8112d770:	24c9883a 	add	r4,r4,r19
8112d774:	20a3c83a 	sub	r17,r4,r2
8112d778:	003f4806 	br	8112d49c <__reset+0xfb10d49c>
8112d77c:	2c8fc83a 	sub	r7,r5,r18
8112d780:	1545c83a 	sub	r2,r2,r21
8112d784:	29cb803a 	cmpltu	r5,r5,r7
8112d788:	1145c83a 	sub	r2,r2,r5
8112d78c:	4089c83a 	sub	r4,r8,r2
8112d790:	003fc706 	br	8112d6b0 <__reset+0xfb10d6b0>
8112d794:	01000604 	movi	r4,24
8112d798:	003f1806 	br	8112d3fc <__reset+0xfb10d3fc>
8112d79c:	00800604 	movi	r2,24
8112d7a0:	003f3206 	br	8112d46c <__reset+0xfb10d46c>
8112d7a4:	01000604 	movi	r4,24
8112d7a8:	003ed906 	br	8112d310 <__reset+0xfb10d310>
8112d7ac:	413fa52e 	bgeu	r8,r4,8112d644 <__reset+0xfb10d644>
8112d7b0:	297fff84 	addi	r5,r5,-2
8112d7b4:	4551883a 	add	r8,r8,r21
8112d7b8:	003fa306 	br	8112d648 <__reset+0xfb10d648>
8112d7bc:	15ff8b2e 	bgeu	r2,r23,8112d5ec <__reset+0xfb10d5ec>
8112d7c0:	31bfff84 	addi	r6,r6,-2
8112d7c4:	1545883a 	add	r2,r2,r21
8112d7c8:	003f8906 	br	8112d5f0 <__reset+0xfb10d5f0>
8112d7cc:	24c9883a 	add	r4,r4,r19
8112d7d0:	003eee06 	br	8112d38c <__reset+0xfb10d38c>
8112d7d4:	8005883a 	mov	r2,r16
8112d7d8:	003f1706 	br	8112d438 <__reset+0xfb10d438>
8112d7dc:	817fe736 	bltu	r16,r5,8112d77c <__reset+0xfb10d77c>
8112d7e0:	280f883a 	mov	r7,r5
8112d7e4:	0009883a 	mov	r4,zero
8112d7e8:	003fb106 	br	8112d6b0 <__reset+0xfb10d6b0>

8112d7ec <__divsi3>:
8112d7ec:	20001b16 	blt	r4,zero,8112d85c <__divsi3+0x70>
8112d7f0:	000f883a 	mov	r7,zero
8112d7f4:	28001616 	blt	r5,zero,8112d850 <__divsi3+0x64>
8112d7f8:	200d883a 	mov	r6,r4
8112d7fc:	29001a2e 	bgeu	r5,r4,8112d868 <__divsi3+0x7c>
8112d800:	00800804 	movi	r2,32
8112d804:	00c00044 	movi	r3,1
8112d808:	00000106 	br	8112d810 <__divsi3+0x24>
8112d80c:	10000d26 	beq	r2,zero,8112d844 <__divsi3+0x58>
8112d810:	294b883a 	add	r5,r5,r5
8112d814:	10bfffc4 	addi	r2,r2,-1
8112d818:	18c7883a 	add	r3,r3,r3
8112d81c:	293ffb36 	bltu	r5,r4,8112d80c <__reset+0xfb10d80c>
8112d820:	0005883a 	mov	r2,zero
8112d824:	18000726 	beq	r3,zero,8112d844 <__divsi3+0x58>
8112d828:	0005883a 	mov	r2,zero
8112d82c:	31400236 	bltu	r6,r5,8112d838 <__divsi3+0x4c>
8112d830:	314dc83a 	sub	r6,r6,r5
8112d834:	10c4b03a 	or	r2,r2,r3
8112d838:	1806d07a 	srli	r3,r3,1
8112d83c:	280ad07a 	srli	r5,r5,1
8112d840:	183ffa1e 	bne	r3,zero,8112d82c <__reset+0xfb10d82c>
8112d844:	38000126 	beq	r7,zero,8112d84c <__divsi3+0x60>
8112d848:	0085c83a 	sub	r2,zero,r2
8112d84c:	f800283a 	ret
8112d850:	014bc83a 	sub	r5,zero,r5
8112d854:	39c0005c 	xori	r7,r7,1
8112d858:	003fe706 	br	8112d7f8 <__reset+0xfb10d7f8>
8112d85c:	0109c83a 	sub	r4,zero,r4
8112d860:	01c00044 	movi	r7,1
8112d864:	003fe306 	br	8112d7f4 <__reset+0xfb10d7f4>
8112d868:	00c00044 	movi	r3,1
8112d86c:	003fee06 	br	8112d828 <__reset+0xfb10d828>

8112d870 <__modsi3>:
8112d870:	20001716 	blt	r4,zero,8112d8d0 <__modsi3+0x60>
8112d874:	000f883a 	mov	r7,zero
8112d878:	2005883a 	mov	r2,r4
8112d87c:	28001216 	blt	r5,zero,8112d8c8 <__modsi3+0x58>
8112d880:	2900162e 	bgeu	r5,r4,8112d8dc <__modsi3+0x6c>
8112d884:	01800804 	movi	r6,32
8112d888:	00c00044 	movi	r3,1
8112d88c:	00000106 	br	8112d894 <__modsi3+0x24>
8112d890:	30000a26 	beq	r6,zero,8112d8bc <__modsi3+0x4c>
8112d894:	294b883a 	add	r5,r5,r5
8112d898:	31bfffc4 	addi	r6,r6,-1
8112d89c:	18c7883a 	add	r3,r3,r3
8112d8a0:	293ffb36 	bltu	r5,r4,8112d890 <__reset+0xfb10d890>
8112d8a4:	18000526 	beq	r3,zero,8112d8bc <__modsi3+0x4c>
8112d8a8:	1806d07a 	srli	r3,r3,1
8112d8ac:	11400136 	bltu	r2,r5,8112d8b4 <__modsi3+0x44>
8112d8b0:	1145c83a 	sub	r2,r2,r5
8112d8b4:	280ad07a 	srli	r5,r5,1
8112d8b8:	183ffb1e 	bne	r3,zero,8112d8a8 <__reset+0xfb10d8a8>
8112d8bc:	38000126 	beq	r7,zero,8112d8c4 <__modsi3+0x54>
8112d8c0:	0085c83a 	sub	r2,zero,r2
8112d8c4:	f800283a 	ret
8112d8c8:	014bc83a 	sub	r5,zero,r5
8112d8cc:	003fec06 	br	8112d880 <__reset+0xfb10d880>
8112d8d0:	0109c83a 	sub	r4,zero,r4
8112d8d4:	01c00044 	movi	r7,1
8112d8d8:	003fe706 	br	8112d878 <__reset+0xfb10d878>
8112d8dc:	00c00044 	movi	r3,1
8112d8e0:	003ff106 	br	8112d8a8 <__reset+0xfb10d8a8>

8112d8e4 <__udivsi3>:
8112d8e4:	200d883a 	mov	r6,r4
8112d8e8:	2900152e 	bgeu	r5,r4,8112d940 <__udivsi3+0x5c>
8112d8ec:	28001416 	blt	r5,zero,8112d940 <__udivsi3+0x5c>
8112d8f0:	00800804 	movi	r2,32
8112d8f4:	00c00044 	movi	r3,1
8112d8f8:	00000206 	br	8112d904 <__udivsi3+0x20>
8112d8fc:	10000e26 	beq	r2,zero,8112d938 <__udivsi3+0x54>
8112d900:	28000516 	blt	r5,zero,8112d918 <__udivsi3+0x34>
8112d904:	294b883a 	add	r5,r5,r5
8112d908:	10bfffc4 	addi	r2,r2,-1
8112d90c:	18c7883a 	add	r3,r3,r3
8112d910:	293ffa36 	bltu	r5,r4,8112d8fc <__reset+0xfb10d8fc>
8112d914:	18000826 	beq	r3,zero,8112d938 <__udivsi3+0x54>
8112d918:	0005883a 	mov	r2,zero
8112d91c:	31400236 	bltu	r6,r5,8112d928 <__udivsi3+0x44>
8112d920:	314dc83a 	sub	r6,r6,r5
8112d924:	10c4b03a 	or	r2,r2,r3
8112d928:	1806d07a 	srli	r3,r3,1
8112d92c:	280ad07a 	srli	r5,r5,1
8112d930:	183ffa1e 	bne	r3,zero,8112d91c <__reset+0xfb10d91c>
8112d934:	f800283a 	ret
8112d938:	0005883a 	mov	r2,zero
8112d93c:	f800283a 	ret
8112d940:	00c00044 	movi	r3,1
8112d944:	003ff406 	br	8112d918 <__reset+0xfb10d918>

8112d948 <__umodsi3>:
8112d948:	2005883a 	mov	r2,r4
8112d94c:	2900122e 	bgeu	r5,r4,8112d998 <__umodsi3+0x50>
8112d950:	28001116 	blt	r5,zero,8112d998 <__umodsi3+0x50>
8112d954:	01800804 	movi	r6,32
8112d958:	00c00044 	movi	r3,1
8112d95c:	00000206 	br	8112d968 <__umodsi3+0x20>
8112d960:	30000c26 	beq	r6,zero,8112d994 <__umodsi3+0x4c>
8112d964:	28000516 	blt	r5,zero,8112d97c <__umodsi3+0x34>
8112d968:	294b883a 	add	r5,r5,r5
8112d96c:	31bfffc4 	addi	r6,r6,-1
8112d970:	18c7883a 	add	r3,r3,r3
8112d974:	293ffa36 	bltu	r5,r4,8112d960 <__reset+0xfb10d960>
8112d978:	18000626 	beq	r3,zero,8112d994 <__umodsi3+0x4c>
8112d97c:	1806d07a 	srli	r3,r3,1
8112d980:	11400136 	bltu	r2,r5,8112d988 <__umodsi3+0x40>
8112d984:	1145c83a 	sub	r2,r2,r5
8112d988:	280ad07a 	srli	r5,r5,1
8112d98c:	183ffb1e 	bne	r3,zero,8112d97c <__reset+0xfb10d97c>
8112d990:	f800283a 	ret
8112d994:	f800283a 	ret
8112d998:	00c00044 	movi	r3,1
8112d99c:	003ff706 	br	8112d97c <__reset+0xfb10d97c>

8112d9a0 <__eqsf2>:
8112d9a0:	2006d5fa 	srli	r3,r4,23
8112d9a4:	280cd5fa 	srli	r6,r5,23
8112d9a8:	01c02034 	movhi	r7,128
8112d9ac:	39ffffc4 	addi	r7,r7,-1
8112d9b0:	18c03fcc 	andi	r3,r3,255
8112d9b4:	02003fc4 	movi	r8,255
8112d9b8:	3904703a 	and	r2,r7,r4
8112d9bc:	31803fcc 	andi	r6,r6,255
8112d9c0:	394e703a 	and	r7,r7,r5
8112d9c4:	2008d7fa 	srli	r4,r4,31
8112d9c8:	280ad7fa 	srli	r5,r5,31
8112d9cc:	1a000d26 	beq	r3,r8,8112da04 <__eqsf2+0x64>
8112d9d0:	02003fc4 	movi	r8,255
8112d9d4:	32000826 	beq	r6,r8,8112d9f8 <__eqsf2+0x58>
8112d9d8:	19800226 	beq	r3,r6,8112d9e4 <__eqsf2+0x44>
8112d9dc:	00800044 	movi	r2,1
8112d9e0:	f800283a 	ret
8112d9e4:	11fffd1e 	bne	r2,r7,8112d9dc <__reset+0xfb10d9dc>
8112d9e8:	21400926 	beq	r4,r5,8112da10 <__eqsf2+0x70>
8112d9ec:	183ffb1e 	bne	r3,zero,8112d9dc <__reset+0xfb10d9dc>
8112d9f0:	1004c03a 	cmpne	r2,r2,zero
8112d9f4:	f800283a 	ret
8112d9f8:	383ff726 	beq	r7,zero,8112d9d8 <__reset+0xfb10d9d8>
8112d9fc:	00800044 	movi	r2,1
8112da00:	f800283a 	ret
8112da04:	103ff226 	beq	r2,zero,8112d9d0 <__reset+0xfb10d9d0>
8112da08:	00800044 	movi	r2,1
8112da0c:	f800283a 	ret
8112da10:	0005883a 	mov	r2,zero
8112da14:	f800283a 	ret

8112da18 <__gesf2>:
8112da18:	2004d5fa 	srli	r2,r4,23
8112da1c:	2806d5fa 	srli	r3,r5,23
8112da20:	01802034 	movhi	r6,128
8112da24:	31bfffc4 	addi	r6,r6,-1
8112da28:	10803fcc 	andi	r2,r2,255
8112da2c:	01c03fc4 	movi	r7,255
8112da30:	3110703a 	and	r8,r6,r4
8112da34:	18c03fcc 	andi	r3,r3,255
8112da38:	314c703a 	and	r6,r6,r5
8112da3c:	2008d7fa 	srli	r4,r4,31
8112da40:	280ad7fa 	srli	r5,r5,31
8112da44:	11c01926 	beq	r2,r7,8112daac <__gesf2+0x94>
8112da48:	01c03fc4 	movi	r7,255
8112da4c:	19c00f26 	beq	r3,r7,8112da8c <__gesf2+0x74>
8112da50:	1000061e 	bne	r2,zero,8112da6c <__gesf2+0x54>
8112da54:	400f003a 	cmpeq	r7,r8,zero
8112da58:	1800071e 	bne	r3,zero,8112da78 <__gesf2+0x60>
8112da5c:	3000061e 	bne	r6,zero,8112da78 <__gesf2+0x60>
8112da60:	0005883a 	mov	r2,zero
8112da64:	40000e1e 	bne	r8,zero,8112daa0 <__gesf2+0x88>
8112da68:	f800283a 	ret
8112da6c:	18000a1e 	bne	r3,zero,8112da98 <__gesf2+0x80>
8112da70:	30000b26 	beq	r6,zero,8112daa0 <__gesf2+0x88>
8112da74:	000f883a 	mov	r7,zero
8112da78:	29403fcc 	andi	r5,r5,255
8112da7c:	38000726 	beq	r7,zero,8112da9c <__gesf2+0x84>
8112da80:	28000826 	beq	r5,zero,8112daa4 <__gesf2+0x8c>
8112da84:	00800044 	movi	r2,1
8112da88:	f800283a 	ret
8112da8c:	303ff026 	beq	r6,zero,8112da50 <__reset+0xfb10da50>
8112da90:	00bfff84 	movi	r2,-2
8112da94:	f800283a 	ret
8112da98:	29403fcc 	andi	r5,r5,255
8112da9c:	21400526 	beq	r4,r5,8112dab4 <__gesf2+0x9c>
8112daa0:	203ff826 	beq	r4,zero,8112da84 <__reset+0xfb10da84>
8112daa4:	00bfffc4 	movi	r2,-1
8112daa8:	f800283a 	ret
8112daac:	403fe626 	beq	r8,zero,8112da48 <__reset+0xfb10da48>
8112dab0:	003ff706 	br	8112da90 <__reset+0xfb10da90>
8112dab4:	18bffa16 	blt	r3,r2,8112daa0 <__reset+0xfb10daa0>
8112dab8:	10c00216 	blt	r2,r3,8112dac4 <__gesf2+0xac>
8112dabc:	323ff836 	bltu	r6,r8,8112daa0 <__reset+0xfb10daa0>
8112dac0:	4180022e 	bgeu	r8,r6,8112dacc <__gesf2+0xb4>
8112dac4:	203fef1e 	bne	r4,zero,8112da84 <__reset+0xfb10da84>
8112dac8:	003ff606 	br	8112daa4 <__reset+0xfb10daa4>
8112dacc:	0005883a 	mov	r2,zero
8112dad0:	f800283a 	ret

8112dad4 <__lesf2>:
8112dad4:	2004d5fa 	srli	r2,r4,23
8112dad8:	280cd5fa 	srli	r6,r5,23
8112dadc:	00c02034 	movhi	r3,128
8112dae0:	18ffffc4 	addi	r3,r3,-1
8112dae4:	10803fcc 	andi	r2,r2,255
8112dae8:	01c03fc4 	movi	r7,255
8112daec:	1910703a 	and	r8,r3,r4
8112daf0:	31803fcc 	andi	r6,r6,255
8112daf4:	1946703a 	and	r3,r3,r5
8112daf8:	2008d7fa 	srli	r4,r4,31
8112dafc:	280ad7fa 	srli	r5,r5,31
8112db00:	11c01b26 	beq	r2,r7,8112db70 <__lesf2+0x9c>
8112db04:	01c03fc4 	movi	r7,255
8112db08:	31c01126 	beq	r6,r7,8112db50 <__lesf2+0x7c>
8112db0c:	1000071e 	bne	r2,zero,8112db2c <__lesf2+0x58>
8112db10:	400f003a 	cmpeq	r7,r8,zero
8112db14:	21003fcc 	andi	r4,r4,255
8112db18:	3000081e 	bne	r6,zero,8112db3c <__lesf2+0x68>
8112db1c:	1800071e 	bne	r3,zero,8112db3c <__lesf2+0x68>
8112db20:	0005883a 	mov	r2,zero
8112db24:	40000f1e 	bne	r8,zero,8112db64 <__lesf2+0x90>
8112db28:	f800283a 	ret
8112db2c:	21003fcc 	andi	r4,r4,255
8112db30:	30000a1e 	bne	r6,zero,8112db5c <__lesf2+0x88>
8112db34:	18000b26 	beq	r3,zero,8112db64 <__lesf2+0x90>
8112db38:	000f883a 	mov	r7,zero
8112db3c:	29403fcc 	andi	r5,r5,255
8112db40:	38000726 	beq	r7,zero,8112db60 <__lesf2+0x8c>
8112db44:	28000826 	beq	r5,zero,8112db68 <__lesf2+0x94>
8112db48:	00800044 	movi	r2,1
8112db4c:	f800283a 	ret
8112db50:	183fee26 	beq	r3,zero,8112db0c <__reset+0xfb10db0c>
8112db54:	00800084 	movi	r2,2
8112db58:	f800283a 	ret
8112db5c:	29403fcc 	andi	r5,r5,255
8112db60:	21400626 	beq	r4,r5,8112db7c <__lesf2+0xa8>
8112db64:	203ff826 	beq	r4,zero,8112db48 <__reset+0xfb10db48>
8112db68:	00bfffc4 	movi	r2,-1
8112db6c:	f800283a 	ret
8112db70:	403fe426 	beq	r8,zero,8112db04 <__reset+0xfb10db04>
8112db74:	00800084 	movi	r2,2
8112db78:	f800283a 	ret
8112db7c:	30bff916 	blt	r6,r2,8112db64 <__reset+0xfb10db64>
8112db80:	11800216 	blt	r2,r6,8112db8c <__lesf2+0xb8>
8112db84:	1a3ff736 	bltu	r3,r8,8112db64 <__reset+0xfb10db64>
8112db88:	40c0022e 	bgeu	r8,r3,8112db94 <__lesf2+0xc0>
8112db8c:	203fee1e 	bne	r4,zero,8112db48 <__reset+0xfb10db48>
8112db90:	003ff506 	br	8112db68 <__reset+0xfb10db68>
8112db94:	0005883a 	mov	r2,zero
8112db98:	f800283a 	ret

8112db9c <__adddf3>:
8112db9c:	02c00434 	movhi	r11,16
8112dba0:	5affffc4 	addi	r11,r11,-1
8112dba4:	2806d7fa 	srli	r3,r5,31
8112dba8:	2ad4703a 	and	r10,r5,r11
8112dbac:	3ad2703a 	and	r9,r7,r11
8112dbb0:	3804d53a 	srli	r2,r7,20
8112dbb4:	3018d77a 	srli	r12,r6,29
8112dbb8:	280ad53a 	srli	r5,r5,20
8112dbbc:	501490fa 	slli	r10,r10,3
8112dbc0:	2010d77a 	srli	r8,r4,29
8112dbc4:	481290fa 	slli	r9,r9,3
8112dbc8:	380ed7fa 	srli	r7,r7,31
8112dbcc:	defffb04 	addi	sp,sp,-20
8112dbd0:	de00012e 	bgeu	sp,et,8112dbd8 <__adddf3+0x3c>
8112dbd4:	003b68fa 	trap	3
8112dbd8:	dc800215 	stw	r18,8(sp)
8112dbdc:	dc400115 	stw	r17,4(sp)
8112dbe0:	dc000015 	stw	r16,0(sp)
8112dbe4:	dfc00415 	stw	ra,16(sp)
8112dbe8:	dcc00315 	stw	r19,12(sp)
8112dbec:	1c803fcc 	andi	r18,r3,255
8112dbf0:	2c01ffcc 	andi	r16,r5,2047
8112dbf4:	5210b03a 	or	r8,r10,r8
8112dbf8:	202290fa 	slli	r17,r4,3
8112dbfc:	1081ffcc 	andi	r2,r2,2047
8112dc00:	4b12b03a 	or	r9,r9,r12
8112dc04:	300c90fa 	slli	r6,r6,3
8112dc08:	91c07526 	beq	r18,r7,8112dde0 <__adddf3+0x244>
8112dc0c:	8087c83a 	sub	r3,r16,r2
8112dc10:	00c0ab0e 	bge	zero,r3,8112dec0 <__adddf3+0x324>
8112dc14:	10002a1e 	bne	r2,zero,8112dcc0 <__adddf3+0x124>
8112dc18:	4984b03a 	or	r2,r9,r6
8112dc1c:	1000961e 	bne	r2,zero,8112de78 <__adddf3+0x2dc>
8112dc20:	888001cc 	andi	r2,r17,7
8112dc24:	10000726 	beq	r2,zero,8112dc44 <__adddf3+0xa8>
8112dc28:	888003cc 	andi	r2,r17,15
8112dc2c:	00c00104 	movi	r3,4
8112dc30:	10c00426 	beq	r2,r3,8112dc44 <__adddf3+0xa8>
8112dc34:	88c7883a 	add	r3,r17,r3
8112dc38:	1c63803a 	cmpltu	r17,r3,r17
8112dc3c:	4451883a 	add	r8,r8,r17
8112dc40:	1823883a 	mov	r17,r3
8112dc44:	4080202c 	andhi	r2,r8,128
8112dc48:	10005926 	beq	r2,zero,8112ddb0 <__adddf3+0x214>
8112dc4c:	84000044 	addi	r16,r16,1
8112dc50:	0081ffc4 	movi	r2,2047
8112dc54:	8080ba26 	beq	r16,r2,8112df40 <__adddf3+0x3a4>
8112dc58:	00bfe034 	movhi	r2,65408
8112dc5c:	10bfffc4 	addi	r2,r2,-1
8112dc60:	4090703a 	and	r8,r8,r2
8112dc64:	4004977a 	slli	r2,r8,29
8112dc68:	4010927a 	slli	r8,r8,9
8112dc6c:	8822d0fa 	srli	r17,r17,3
8112dc70:	8401ffcc 	andi	r16,r16,2047
8112dc74:	4010d33a 	srli	r8,r8,12
8112dc78:	9007883a 	mov	r3,r18
8112dc7c:	1444b03a 	or	r2,r2,r17
8112dc80:	8401ffcc 	andi	r16,r16,2047
8112dc84:	8020953a 	slli	r16,r16,20
8112dc88:	18c03fcc 	andi	r3,r3,255
8112dc8c:	01000434 	movhi	r4,16
8112dc90:	213fffc4 	addi	r4,r4,-1
8112dc94:	180697fa 	slli	r3,r3,31
8112dc98:	4110703a 	and	r8,r8,r4
8112dc9c:	4410b03a 	or	r8,r8,r16
8112dca0:	40c6b03a 	or	r3,r8,r3
8112dca4:	dfc00417 	ldw	ra,16(sp)
8112dca8:	dcc00317 	ldw	r19,12(sp)
8112dcac:	dc800217 	ldw	r18,8(sp)
8112dcb0:	dc400117 	ldw	r17,4(sp)
8112dcb4:	dc000017 	ldw	r16,0(sp)
8112dcb8:	dec00504 	addi	sp,sp,20
8112dcbc:	f800283a 	ret
8112dcc0:	0081ffc4 	movi	r2,2047
8112dcc4:	80bfd626 	beq	r16,r2,8112dc20 <__reset+0xfb10dc20>
8112dcc8:	4a402034 	orhi	r9,r9,128
8112dccc:	00800e04 	movi	r2,56
8112dcd0:	10c09f16 	blt	r2,r3,8112df50 <__adddf3+0x3b4>
8112dcd4:	008007c4 	movi	r2,31
8112dcd8:	10c0c216 	blt	r2,r3,8112dfe4 <__adddf3+0x448>
8112dcdc:	00800804 	movi	r2,32
8112dce0:	10c5c83a 	sub	r2,r2,r3
8112dce4:	488a983a 	sll	r5,r9,r2
8112dce8:	30c8d83a 	srl	r4,r6,r3
8112dcec:	3084983a 	sll	r2,r6,r2
8112dcf0:	48c6d83a 	srl	r3,r9,r3
8112dcf4:	290cb03a 	or	r6,r5,r4
8112dcf8:	1004c03a 	cmpne	r2,r2,zero
8112dcfc:	308cb03a 	or	r6,r6,r2
8112dd00:	898dc83a 	sub	r6,r17,r6
8112dd04:	89a3803a 	cmpltu	r17,r17,r6
8112dd08:	40d1c83a 	sub	r8,r8,r3
8112dd0c:	4451c83a 	sub	r8,r8,r17
8112dd10:	3023883a 	mov	r17,r6
8112dd14:	4080202c 	andhi	r2,r8,128
8112dd18:	10002326 	beq	r2,zero,8112dda8 <__adddf3+0x20c>
8112dd1c:	04c02034 	movhi	r19,128
8112dd20:	9cffffc4 	addi	r19,r19,-1
8112dd24:	44e6703a 	and	r19,r8,r19
8112dd28:	98007626 	beq	r19,zero,8112df04 <__adddf3+0x368>
8112dd2c:	9809883a 	mov	r4,r19
8112dd30:	111ab180 	call	8111ab18 <__clzsi2>
8112dd34:	10fffe04 	addi	r3,r2,-8
8112dd38:	010007c4 	movi	r4,31
8112dd3c:	20c07716 	blt	r4,r3,8112df1c <__adddf3+0x380>
8112dd40:	00800804 	movi	r2,32
8112dd44:	10c5c83a 	sub	r2,r2,r3
8112dd48:	8884d83a 	srl	r2,r17,r2
8112dd4c:	98d0983a 	sll	r8,r19,r3
8112dd50:	88e2983a 	sll	r17,r17,r3
8112dd54:	1204b03a 	or	r2,r2,r8
8112dd58:	1c007416 	blt	r3,r16,8112df2c <__adddf3+0x390>
8112dd5c:	1c21c83a 	sub	r16,r3,r16
8112dd60:	82000044 	addi	r8,r16,1
8112dd64:	00c007c4 	movi	r3,31
8112dd68:	1a009116 	blt	r3,r8,8112dfb0 <__adddf3+0x414>
8112dd6c:	00c00804 	movi	r3,32
8112dd70:	1a07c83a 	sub	r3,r3,r8
8112dd74:	8a08d83a 	srl	r4,r17,r8
8112dd78:	88e2983a 	sll	r17,r17,r3
8112dd7c:	10c6983a 	sll	r3,r2,r3
8112dd80:	1210d83a 	srl	r8,r2,r8
8112dd84:	8804c03a 	cmpne	r2,r17,zero
8112dd88:	1906b03a 	or	r3,r3,r4
8112dd8c:	18a2b03a 	or	r17,r3,r2
8112dd90:	0021883a 	mov	r16,zero
8112dd94:	003fa206 	br	8112dc20 <__reset+0xfb10dc20>
8112dd98:	1890b03a 	or	r8,r3,r2
8112dd9c:	40017d26 	beq	r8,zero,8112e394 <__adddf3+0x7f8>
8112dda0:	1011883a 	mov	r8,r2
8112dda4:	1823883a 	mov	r17,r3
8112dda8:	888001cc 	andi	r2,r17,7
8112ddac:	103f9e1e 	bne	r2,zero,8112dc28 <__reset+0xfb10dc28>
8112ddb0:	4004977a 	slli	r2,r8,29
8112ddb4:	8822d0fa 	srli	r17,r17,3
8112ddb8:	4010d0fa 	srli	r8,r8,3
8112ddbc:	9007883a 	mov	r3,r18
8112ddc0:	1444b03a 	or	r2,r2,r17
8112ddc4:	0101ffc4 	movi	r4,2047
8112ddc8:	81002426 	beq	r16,r4,8112de5c <__adddf3+0x2c0>
8112ddcc:	8120703a 	and	r16,r16,r4
8112ddd0:	01000434 	movhi	r4,16
8112ddd4:	213fffc4 	addi	r4,r4,-1
8112ddd8:	4110703a 	and	r8,r8,r4
8112dddc:	003fa806 	br	8112dc80 <__reset+0xfb10dc80>
8112dde0:	8089c83a 	sub	r4,r16,r2
8112dde4:	01005e0e 	bge	zero,r4,8112df60 <__adddf3+0x3c4>
8112dde8:	10002b26 	beq	r2,zero,8112de98 <__adddf3+0x2fc>
8112ddec:	0081ffc4 	movi	r2,2047
8112ddf0:	80bf8b26 	beq	r16,r2,8112dc20 <__reset+0xfb10dc20>
8112ddf4:	4a402034 	orhi	r9,r9,128
8112ddf8:	00800e04 	movi	r2,56
8112ddfc:	1100a40e 	bge	r2,r4,8112e090 <__adddf3+0x4f4>
8112de00:	498cb03a 	or	r6,r9,r6
8112de04:	300ac03a 	cmpne	r5,r6,zero
8112de08:	0013883a 	mov	r9,zero
8112de0c:	2c4b883a 	add	r5,r5,r17
8112de10:	2c63803a 	cmpltu	r17,r5,r17
8112de14:	4a11883a 	add	r8,r9,r8
8112de18:	8a11883a 	add	r8,r17,r8
8112de1c:	2823883a 	mov	r17,r5
8112de20:	4080202c 	andhi	r2,r8,128
8112de24:	103fe026 	beq	r2,zero,8112dda8 <__reset+0xfb10dda8>
8112de28:	84000044 	addi	r16,r16,1
8112de2c:	0081ffc4 	movi	r2,2047
8112de30:	8080d226 	beq	r16,r2,8112e17c <__adddf3+0x5e0>
8112de34:	00bfe034 	movhi	r2,65408
8112de38:	10bfffc4 	addi	r2,r2,-1
8112de3c:	4090703a 	and	r8,r8,r2
8112de40:	880ad07a 	srli	r5,r17,1
8112de44:	400897fa 	slli	r4,r8,31
8112de48:	88c0004c 	andi	r3,r17,1
8112de4c:	28e2b03a 	or	r17,r5,r3
8112de50:	4010d07a 	srli	r8,r8,1
8112de54:	2462b03a 	or	r17,r4,r17
8112de58:	003f7106 	br	8112dc20 <__reset+0xfb10dc20>
8112de5c:	4088b03a 	or	r4,r8,r2
8112de60:	20014526 	beq	r4,zero,8112e378 <__adddf3+0x7dc>
8112de64:	01000434 	movhi	r4,16
8112de68:	42000234 	orhi	r8,r8,8
8112de6c:	213fffc4 	addi	r4,r4,-1
8112de70:	4110703a 	and	r8,r8,r4
8112de74:	003f8206 	br	8112dc80 <__reset+0xfb10dc80>
8112de78:	18ffffc4 	addi	r3,r3,-1
8112de7c:	1800491e 	bne	r3,zero,8112dfa4 <__adddf3+0x408>
8112de80:	898bc83a 	sub	r5,r17,r6
8112de84:	8963803a 	cmpltu	r17,r17,r5
8112de88:	4251c83a 	sub	r8,r8,r9
8112de8c:	4451c83a 	sub	r8,r8,r17
8112de90:	2823883a 	mov	r17,r5
8112de94:	003f9f06 	br	8112dd14 <__reset+0xfb10dd14>
8112de98:	4984b03a 	or	r2,r9,r6
8112de9c:	103f6026 	beq	r2,zero,8112dc20 <__reset+0xfb10dc20>
8112dea0:	213fffc4 	addi	r4,r4,-1
8112dea4:	2000931e 	bne	r4,zero,8112e0f4 <__adddf3+0x558>
8112dea8:	898d883a 	add	r6,r17,r6
8112deac:	3463803a 	cmpltu	r17,r6,r17
8112deb0:	4251883a 	add	r8,r8,r9
8112deb4:	8a11883a 	add	r8,r17,r8
8112deb8:	3023883a 	mov	r17,r6
8112debc:	003fd806 	br	8112de20 <__reset+0xfb10de20>
8112dec0:	1800541e 	bne	r3,zero,8112e014 <__adddf3+0x478>
8112dec4:	80800044 	addi	r2,r16,1
8112dec8:	1081ffcc 	andi	r2,r2,2047
8112decc:	00c00044 	movi	r3,1
8112ded0:	1880a00e 	bge	r3,r2,8112e154 <__adddf3+0x5b8>
8112ded4:	8989c83a 	sub	r4,r17,r6
8112ded8:	8905803a 	cmpltu	r2,r17,r4
8112dedc:	4267c83a 	sub	r19,r8,r9
8112dee0:	98a7c83a 	sub	r19,r19,r2
8112dee4:	9880202c 	andhi	r2,r19,128
8112dee8:	10006326 	beq	r2,zero,8112e078 <__adddf3+0x4dc>
8112deec:	3463c83a 	sub	r17,r6,r17
8112def0:	4a07c83a 	sub	r3,r9,r8
8112def4:	344d803a 	cmpltu	r6,r6,r17
8112def8:	19a7c83a 	sub	r19,r3,r6
8112defc:	3825883a 	mov	r18,r7
8112df00:	983f8a1e 	bne	r19,zero,8112dd2c <__reset+0xfb10dd2c>
8112df04:	8809883a 	mov	r4,r17
8112df08:	111ab180 	call	8111ab18 <__clzsi2>
8112df0c:	10800804 	addi	r2,r2,32
8112df10:	10fffe04 	addi	r3,r2,-8
8112df14:	010007c4 	movi	r4,31
8112df18:	20ff890e 	bge	r4,r3,8112dd40 <__reset+0xfb10dd40>
8112df1c:	10bff604 	addi	r2,r2,-40
8112df20:	8884983a 	sll	r2,r17,r2
8112df24:	0023883a 	mov	r17,zero
8112df28:	1c3f8c0e 	bge	r3,r16,8112dd5c <__reset+0xfb10dd5c>
8112df2c:	023fe034 	movhi	r8,65408
8112df30:	423fffc4 	addi	r8,r8,-1
8112df34:	80e1c83a 	sub	r16,r16,r3
8112df38:	1210703a 	and	r8,r2,r8
8112df3c:	003f3806 	br	8112dc20 <__reset+0xfb10dc20>
8112df40:	9007883a 	mov	r3,r18
8112df44:	0011883a 	mov	r8,zero
8112df48:	0005883a 	mov	r2,zero
8112df4c:	003f4c06 	br	8112dc80 <__reset+0xfb10dc80>
8112df50:	498cb03a 	or	r6,r9,r6
8112df54:	300cc03a 	cmpne	r6,r6,zero
8112df58:	0007883a 	mov	r3,zero
8112df5c:	003f6806 	br	8112dd00 <__reset+0xfb10dd00>
8112df60:	20009c1e 	bne	r4,zero,8112e1d4 <__adddf3+0x638>
8112df64:	80800044 	addi	r2,r16,1
8112df68:	1141ffcc 	andi	r5,r2,2047
8112df6c:	01000044 	movi	r4,1
8112df70:	2140670e 	bge	r4,r5,8112e110 <__adddf3+0x574>
8112df74:	0101ffc4 	movi	r4,2047
8112df78:	11007f26 	beq	r2,r4,8112e178 <__adddf3+0x5dc>
8112df7c:	898d883a 	add	r6,r17,r6
8112df80:	4247883a 	add	r3,r8,r9
8112df84:	3451803a 	cmpltu	r8,r6,r17
8112df88:	40d1883a 	add	r8,r8,r3
8112df8c:	402297fa 	slli	r17,r8,31
8112df90:	300cd07a 	srli	r6,r6,1
8112df94:	4010d07a 	srli	r8,r8,1
8112df98:	1021883a 	mov	r16,r2
8112df9c:	89a2b03a 	or	r17,r17,r6
8112dfa0:	003f1f06 	br	8112dc20 <__reset+0xfb10dc20>
8112dfa4:	0081ffc4 	movi	r2,2047
8112dfa8:	80bf481e 	bne	r16,r2,8112dccc <__reset+0xfb10dccc>
8112dfac:	003f1c06 	br	8112dc20 <__reset+0xfb10dc20>
8112dfb0:	843ff844 	addi	r16,r16,-31
8112dfb4:	01000804 	movi	r4,32
8112dfb8:	1406d83a 	srl	r3,r2,r16
8112dfbc:	41005026 	beq	r8,r4,8112e100 <__adddf3+0x564>
8112dfc0:	01001004 	movi	r4,64
8112dfc4:	2211c83a 	sub	r8,r4,r8
8112dfc8:	1204983a 	sll	r2,r2,r8
8112dfcc:	88a2b03a 	or	r17,r17,r2
8112dfd0:	8822c03a 	cmpne	r17,r17,zero
8112dfd4:	1c62b03a 	or	r17,r3,r17
8112dfd8:	0011883a 	mov	r8,zero
8112dfdc:	0021883a 	mov	r16,zero
8112dfe0:	003f7106 	br	8112dda8 <__reset+0xfb10dda8>
8112dfe4:	193ff804 	addi	r4,r3,-32
8112dfe8:	00800804 	movi	r2,32
8112dfec:	4908d83a 	srl	r4,r9,r4
8112dff0:	18804526 	beq	r3,r2,8112e108 <__adddf3+0x56c>
8112dff4:	00801004 	movi	r2,64
8112dff8:	10c5c83a 	sub	r2,r2,r3
8112dffc:	4886983a 	sll	r3,r9,r2
8112e000:	198cb03a 	or	r6,r3,r6
8112e004:	300cc03a 	cmpne	r6,r6,zero
8112e008:	218cb03a 	or	r6,r4,r6
8112e00c:	0007883a 	mov	r3,zero
8112e010:	003f3b06 	br	8112dd00 <__reset+0xfb10dd00>
8112e014:	80002a26 	beq	r16,zero,8112e0c0 <__adddf3+0x524>
8112e018:	0101ffc4 	movi	r4,2047
8112e01c:	11006826 	beq	r2,r4,8112e1c0 <__adddf3+0x624>
8112e020:	00c7c83a 	sub	r3,zero,r3
8112e024:	42002034 	orhi	r8,r8,128
8112e028:	01000e04 	movi	r4,56
8112e02c:	20c07c16 	blt	r4,r3,8112e220 <__adddf3+0x684>
8112e030:	010007c4 	movi	r4,31
8112e034:	20c0da16 	blt	r4,r3,8112e3a0 <__adddf3+0x804>
8112e038:	01000804 	movi	r4,32
8112e03c:	20c9c83a 	sub	r4,r4,r3
8112e040:	4114983a 	sll	r10,r8,r4
8112e044:	88cad83a 	srl	r5,r17,r3
8112e048:	8908983a 	sll	r4,r17,r4
8112e04c:	40c6d83a 	srl	r3,r8,r3
8112e050:	5162b03a 	or	r17,r10,r5
8112e054:	2008c03a 	cmpne	r4,r4,zero
8112e058:	8922b03a 	or	r17,r17,r4
8112e05c:	3463c83a 	sub	r17,r6,r17
8112e060:	48c7c83a 	sub	r3,r9,r3
8112e064:	344d803a 	cmpltu	r6,r6,r17
8112e068:	1991c83a 	sub	r8,r3,r6
8112e06c:	1021883a 	mov	r16,r2
8112e070:	3825883a 	mov	r18,r7
8112e074:	003f2706 	br	8112dd14 <__reset+0xfb10dd14>
8112e078:	24d0b03a 	or	r8,r4,r19
8112e07c:	40001b1e 	bne	r8,zero,8112e0ec <__adddf3+0x550>
8112e080:	0005883a 	mov	r2,zero
8112e084:	0007883a 	mov	r3,zero
8112e088:	0021883a 	mov	r16,zero
8112e08c:	003f4d06 	br	8112ddc4 <__reset+0xfb10ddc4>
8112e090:	008007c4 	movi	r2,31
8112e094:	11003c16 	blt	r2,r4,8112e188 <__adddf3+0x5ec>
8112e098:	00800804 	movi	r2,32
8112e09c:	1105c83a 	sub	r2,r2,r4
8112e0a0:	488e983a 	sll	r7,r9,r2
8112e0a4:	310ad83a 	srl	r5,r6,r4
8112e0a8:	3084983a 	sll	r2,r6,r2
8112e0ac:	4912d83a 	srl	r9,r9,r4
8112e0b0:	394ab03a 	or	r5,r7,r5
8112e0b4:	1004c03a 	cmpne	r2,r2,zero
8112e0b8:	288ab03a 	or	r5,r5,r2
8112e0bc:	003f5306 	br	8112de0c <__reset+0xfb10de0c>
8112e0c0:	4448b03a 	or	r4,r8,r17
8112e0c4:	20003e26 	beq	r4,zero,8112e1c0 <__adddf3+0x624>
8112e0c8:	00c6303a 	nor	r3,zero,r3
8112e0cc:	18003a1e 	bne	r3,zero,8112e1b8 <__adddf3+0x61c>
8112e0d0:	3463c83a 	sub	r17,r6,r17
8112e0d4:	4a07c83a 	sub	r3,r9,r8
8112e0d8:	344d803a 	cmpltu	r6,r6,r17
8112e0dc:	1991c83a 	sub	r8,r3,r6
8112e0e0:	1021883a 	mov	r16,r2
8112e0e4:	3825883a 	mov	r18,r7
8112e0e8:	003f0a06 	br	8112dd14 <__reset+0xfb10dd14>
8112e0ec:	2023883a 	mov	r17,r4
8112e0f0:	003f0d06 	br	8112dd28 <__reset+0xfb10dd28>
8112e0f4:	0081ffc4 	movi	r2,2047
8112e0f8:	80bf3f1e 	bne	r16,r2,8112ddf8 <__reset+0xfb10ddf8>
8112e0fc:	003ec806 	br	8112dc20 <__reset+0xfb10dc20>
8112e100:	0005883a 	mov	r2,zero
8112e104:	003fb106 	br	8112dfcc <__reset+0xfb10dfcc>
8112e108:	0007883a 	mov	r3,zero
8112e10c:	003fbc06 	br	8112e000 <__reset+0xfb10e000>
8112e110:	4444b03a 	or	r2,r8,r17
8112e114:	8000871e 	bne	r16,zero,8112e334 <__adddf3+0x798>
8112e118:	1000ba26 	beq	r2,zero,8112e404 <__adddf3+0x868>
8112e11c:	4984b03a 	or	r2,r9,r6
8112e120:	103ebf26 	beq	r2,zero,8112dc20 <__reset+0xfb10dc20>
8112e124:	8985883a 	add	r2,r17,r6
8112e128:	4247883a 	add	r3,r8,r9
8112e12c:	1451803a 	cmpltu	r8,r2,r17
8112e130:	40d1883a 	add	r8,r8,r3
8112e134:	40c0202c 	andhi	r3,r8,128
8112e138:	1023883a 	mov	r17,r2
8112e13c:	183f1a26 	beq	r3,zero,8112dda8 <__reset+0xfb10dda8>
8112e140:	00bfe034 	movhi	r2,65408
8112e144:	10bfffc4 	addi	r2,r2,-1
8112e148:	2021883a 	mov	r16,r4
8112e14c:	4090703a 	and	r8,r8,r2
8112e150:	003eb306 	br	8112dc20 <__reset+0xfb10dc20>
8112e154:	4444b03a 	or	r2,r8,r17
8112e158:	8000291e 	bne	r16,zero,8112e200 <__adddf3+0x664>
8112e15c:	10004b1e 	bne	r2,zero,8112e28c <__adddf3+0x6f0>
8112e160:	4990b03a 	or	r8,r9,r6
8112e164:	40008b26 	beq	r8,zero,8112e394 <__adddf3+0x7f8>
8112e168:	4811883a 	mov	r8,r9
8112e16c:	3023883a 	mov	r17,r6
8112e170:	3825883a 	mov	r18,r7
8112e174:	003eaa06 	br	8112dc20 <__reset+0xfb10dc20>
8112e178:	1021883a 	mov	r16,r2
8112e17c:	0011883a 	mov	r8,zero
8112e180:	0005883a 	mov	r2,zero
8112e184:	003f0f06 	br	8112ddc4 <__reset+0xfb10ddc4>
8112e188:	217ff804 	addi	r5,r4,-32
8112e18c:	00800804 	movi	r2,32
8112e190:	494ad83a 	srl	r5,r9,r5
8112e194:	20807d26 	beq	r4,r2,8112e38c <__adddf3+0x7f0>
8112e198:	00801004 	movi	r2,64
8112e19c:	1109c83a 	sub	r4,r2,r4
8112e1a0:	4912983a 	sll	r9,r9,r4
8112e1a4:	498cb03a 	or	r6,r9,r6
8112e1a8:	300cc03a 	cmpne	r6,r6,zero
8112e1ac:	298ab03a 	or	r5,r5,r6
8112e1b0:	0013883a 	mov	r9,zero
8112e1b4:	003f1506 	br	8112de0c <__reset+0xfb10de0c>
8112e1b8:	0101ffc4 	movi	r4,2047
8112e1bc:	113f9a1e 	bne	r2,r4,8112e028 <__reset+0xfb10e028>
8112e1c0:	4811883a 	mov	r8,r9
8112e1c4:	3023883a 	mov	r17,r6
8112e1c8:	1021883a 	mov	r16,r2
8112e1cc:	3825883a 	mov	r18,r7
8112e1d0:	003e9306 	br	8112dc20 <__reset+0xfb10dc20>
8112e1d4:	8000161e 	bne	r16,zero,8112e230 <__adddf3+0x694>
8112e1d8:	444ab03a 	or	r5,r8,r17
8112e1dc:	28005126 	beq	r5,zero,8112e324 <__adddf3+0x788>
8112e1e0:	0108303a 	nor	r4,zero,r4
8112e1e4:	20004d1e 	bne	r4,zero,8112e31c <__adddf3+0x780>
8112e1e8:	89a3883a 	add	r17,r17,r6
8112e1ec:	4253883a 	add	r9,r8,r9
8112e1f0:	898d803a 	cmpltu	r6,r17,r6
8112e1f4:	3251883a 	add	r8,r6,r9
8112e1f8:	1021883a 	mov	r16,r2
8112e1fc:	003f0806 	br	8112de20 <__reset+0xfb10de20>
8112e200:	1000301e 	bne	r2,zero,8112e2c4 <__adddf3+0x728>
8112e204:	4984b03a 	or	r2,r9,r6
8112e208:	10007126 	beq	r2,zero,8112e3d0 <__adddf3+0x834>
8112e20c:	4811883a 	mov	r8,r9
8112e210:	3023883a 	mov	r17,r6
8112e214:	3825883a 	mov	r18,r7
8112e218:	0401ffc4 	movi	r16,2047
8112e21c:	003e8006 	br	8112dc20 <__reset+0xfb10dc20>
8112e220:	4462b03a 	or	r17,r8,r17
8112e224:	8822c03a 	cmpne	r17,r17,zero
8112e228:	0007883a 	mov	r3,zero
8112e22c:	003f8b06 	br	8112e05c <__reset+0xfb10e05c>
8112e230:	0141ffc4 	movi	r5,2047
8112e234:	11403b26 	beq	r2,r5,8112e324 <__adddf3+0x788>
8112e238:	0109c83a 	sub	r4,zero,r4
8112e23c:	42002034 	orhi	r8,r8,128
8112e240:	01400e04 	movi	r5,56
8112e244:	29006716 	blt	r5,r4,8112e3e4 <__adddf3+0x848>
8112e248:	014007c4 	movi	r5,31
8112e24c:	29007016 	blt	r5,r4,8112e410 <__adddf3+0x874>
8112e250:	01400804 	movi	r5,32
8112e254:	290bc83a 	sub	r5,r5,r4
8112e258:	4154983a 	sll	r10,r8,r5
8112e25c:	890ed83a 	srl	r7,r17,r4
8112e260:	894a983a 	sll	r5,r17,r5
8112e264:	4108d83a 	srl	r4,r8,r4
8112e268:	51e2b03a 	or	r17,r10,r7
8112e26c:	280ac03a 	cmpne	r5,r5,zero
8112e270:	8962b03a 	or	r17,r17,r5
8112e274:	89a3883a 	add	r17,r17,r6
8112e278:	2253883a 	add	r9,r4,r9
8112e27c:	898d803a 	cmpltu	r6,r17,r6
8112e280:	3251883a 	add	r8,r6,r9
8112e284:	1021883a 	mov	r16,r2
8112e288:	003ee506 	br	8112de20 <__reset+0xfb10de20>
8112e28c:	4984b03a 	or	r2,r9,r6
8112e290:	103e6326 	beq	r2,zero,8112dc20 <__reset+0xfb10dc20>
8112e294:	8987c83a 	sub	r3,r17,r6
8112e298:	88c9803a 	cmpltu	r4,r17,r3
8112e29c:	4245c83a 	sub	r2,r8,r9
8112e2a0:	1105c83a 	sub	r2,r2,r4
8112e2a4:	1100202c 	andhi	r4,r2,128
8112e2a8:	203ebb26 	beq	r4,zero,8112dd98 <__reset+0xfb10dd98>
8112e2ac:	3463c83a 	sub	r17,r6,r17
8112e2b0:	4a07c83a 	sub	r3,r9,r8
8112e2b4:	344d803a 	cmpltu	r6,r6,r17
8112e2b8:	1991c83a 	sub	r8,r3,r6
8112e2bc:	3825883a 	mov	r18,r7
8112e2c0:	003e5706 	br	8112dc20 <__reset+0xfb10dc20>
8112e2c4:	4984b03a 	or	r2,r9,r6
8112e2c8:	10002e26 	beq	r2,zero,8112e384 <__adddf3+0x7e8>
8112e2cc:	4004d0fa 	srli	r2,r8,3
8112e2d0:	8822d0fa 	srli	r17,r17,3
8112e2d4:	4010977a 	slli	r8,r8,29
8112e2d8:	10c0022c 	andhi	r3,r2,8
8112e2dc:	4462b03a 	or	r17,r8,r17
8112e2e0:	18000826 	beq	r3,zero,8112e304 <__adddf3+0x768>
8112e2e4:	4808d0fa 	srli	r4,r9,3
8112e2e8:	20c0022c 	andhi	r3,r4,8
8112e2ec:	1800051e 	bne	r3,zero,8112e304 <__adddf3+0x768>
8112e2f0:	300cd0fa 	srli	r6,r6,3
8112e2f4:	4806977a 	slli	r3,r9,29
8112e2f8:	2005883a 	mov	r2,r4
8112e2fc:	3825883a 	mov	r18,r7
8112e300:	19a2b03a 	or	r17,r3,r6
8112e304:	8810d77a 	srli	r8,r17,29
8112e308:	100490fa 	slli	r2,r2,3
8112e30c:	882290fa 	slli	r17,r17,3
8112e310:	0401ffc4 	movi	r16,2047
8112e314:	4090b03a 	or	r8,r8,r2
8112e318:	003e4106 	br	8112dc20 <__reset+0xfb10dc20>
8112e31c:	0141ffc4 	movi	r5,2047
8112e320:	117fc71e 	bne	r2,r5,8112e240 <__reset+0xfb10e240>
8112e324:	4811883a 	mov	r8,r9
8112e328:	3023883a 	mov	r17,r6
8112e32c:	1021883a 	mov	r16,r2
8112e330:	003e3b06 	br	8112dc20 <__reset+0xfb10dc20>
8112e334:	10002f26 	beq	r2,zero,8112e3f4 <__adddf3+0x858>
8112e338:	4984b03a 	or	r2,r9,r6
8112e33c:	10001126 	beq	r2,zero,8112e384 <__adddf3+0x7e8>
8112e340:	4004d0fa 	srli	r2,r8,3
8112e344:	8822d0fa 	srli	r17,r17,3
8112e348:	4010977a 	slli	r8,r8,29
8112e34c:	10c0022c 	andhi	r3,r2,8
8112e350:	4462b03a 	or	r17,r8,r17
8112e354:	183feb26 	beq	r3,zero,8112e304 <__reset+0xfb10e304>
8112e358:	4808d0fa 	srli	r4,r9,3
8112e35c:	20c0022c 	andhi	r3,r4,8
8112e360:	183fe81e 	bne	r3,zero,8112e304 <__reset+0xfb10e304>
8112e364:	300cd0fa 	srli	r6,r6,3
8112e368:	4806977a 	slli	r3,r9,29
8112e36c:	2005883a 	mov	r2,r4
8112e370:	19a2b03a 	or	r17,r3,r6
8112e374:	003fe306 	br	8112e304 <__reset+0xfb10e304>
8112e378:	0011883a 	mov	r8,zero
8112e37c:	0005883a 	mov	r2,zero
8112e380:	003e3f06 	br	8112dc80 <__reset+0xfb10dc80>
8112e384:	0401ffc4 	movi	r16,2047
8112e388:	003e2506 	br	8112dc20 <__reset+0xfb10dc20>
8112e38c:	0013883a 	mov	r9,zero
8112e390:	003f8406 	br	8112e1a4 <__reset+0xfb10e1a4>
8112e394:	0005883a 	mov	r2,zero
8112e398:	0007883a 	mov	r3,zero
8112e39c:	003e8906 	br	8112ddc4 <__reset+0xfb10ddc4>
8112e3a0:	197ff804 	addi	r5,r3,-32
8112e3a4:	01000804 	movi	r4,32
8112e3a8:	414ad83a 	srl	r5,r8,r5
8112e3ac:	19002426 	beq	r3,r4,8112e440 <__adddf3+0x8a4>
8112e3b0:	01001004 	movi	r4,64
8112e3b4:	20c7c83a 	sub	r3,r4,r3
8112e3b8:	40c6983a 	sll	r3,r8,r3
8112e3bc:	1c46b03a 	or	r3,r3,r17
8112e3c0:	1806c03a 	cmpne	r3,r3,zero
8112e3c4:	28e2b03a 	or	r17,r5,r3
8112e3c8:	0007883a 	mov	r3,zero
8112e3cc:	003f2306 	br	8112e05c <__reset+0xfb10e05c>
8112e3d0:	0007883a 	mov	r3,zero
8112e3d4:	5811883a 	mov	r8,r11
8112e3d8:	00bfffc4 	movi	r2,-1
8112e3dc:	0401ffc4 	movi	r16,2047
8112e3e0:	003e7806 	br	8112ddc4 <__reset+0xfb10ddc4>
8112e3e4:	4462b03a 	or	r17,r8,r17
8112e3e8:	8822c03a 	cmpne	r17,r17,zero
8112e3ec:	0009883a 	mov	r4,zero
8112e3f0:	003fa006 	br	8112e274 <__reset+0xfb10e274>
8112e3f4:	4811883a 	mov	r8,r9
8112e3f8:	3023883a 	mov	r17,r6
8112e3fc:	0401ffc4 	movi	r16,2047
8112e400:	003e0706 	br	8112dc20 <__reset+0xfb10dc20>
8112e404:	4811883a 	mov	r8,r9
8112e408:	3023883a 	mov	r17,r6
8112e40c:	003e0406 	br	8112dc20 <__reset+0xfb10dc20>
8112e410:	21fff804 	addi	r7,r4,-32
8112e414:	01400804 	movi	r5,32
8112e418:	41ced83a 	srl	r7,r8,r7
8112e41c:	21400a26 	beq	r4,r5,8112e448 <__adddf3+0x8ac>
8112e420:	01401004 	movi	r5,64
8112e424:	2909c83a 	sub	r4,r5,r4
8112e428:	4108983a 	sll	r4,r8,r4
8112e42c:	2448b03a 	or	r4,r4,r17
8112e430:	2008c03a 	cmpne	r4,r4,zero
8112e434:	3922b03a 	or	r17,r7,r4
8112e438:	0009883a 	mov	r4,zero
8112e43c:	003f8d06 	br	8112e274 <__reset+0xfb10e274>
8112e440:	0007883a 	mov	r3,zero
8112e444:	003fdd06 	br	8112e3bc <__reset+0xfb10e3bc>
8112e448:	0009883a 	mov	r4,zero
8112e44c:	003ff706 	br	8112e42c <__reset+0xfb10e42c>

8112e450 <__divdf3>:
8112e450:	defff204 	addi	sp,sp,-56
8112e454:	de00012e 	bgeu	sp,et,8112e45c <__divdf3+0xc>
8112e458:	003b68fa 	trap	3
8112e45c:	dd400915 	stw	r21,36(sp)
8112e460:	282ad53a 	srli	r21,r5,20
8112e464:	dd000815 	stw	r20,32(sp)
8112e468:	2828d7fa 	srli	r20,r5,31
8112e46c:	dc000415 	stw	r16,16(sp)
8112e470:	04000434 	movhi	r16,16
8112e474:	df000c15 	stw	fp,48(sp)
8112e478:	843fffc4 	addi	r16,r16,-1
8112e47c:	dfc00d15 	stw	ra,52(sp)
8112e480:	ddc00b15 	stw	r23,44(sp)
8112e484:	dd800a15 	stw	r22,40(sp)
8112e488:	dcc00715 	stw	r19,28(sp)
8112e48c:	dc800615 	stw	r18,24(sp)
8112e490:	dc400515 	stw	r17,20(sp)
8112e494:	ad41ffcc 	andi	r21,r21,2047
8112e498:	2c20703a 	and	r16,r5,r16
8112e49c:	a7003fcc 	andi	fp,r20,255
8112e4a0:	a8006126 	beq	r21,zero,8112e628 <__divdf3+0x1d8>
8112e4a4:	0081ffc4 	movi	r2,2047
8112e4a8:	2025883a 	mov	r18,r4
8112e4ac:	a8803726 	beq	r21,r2,8112e58c <__divdf3+0x13c>
8112e4b0:	80800434 	orhi	r2,r16,16
8112e4b4:	100490fa 	slli	r2,r2,3
8112e4b8:	2020d77a 	srli	r16,r4,29
8112e4bc:	202490fa 	slli	r18,r4,3
8112e4c0:	ad7f0044 	addi	r21,r21,-1023
8112e4c4:	80a0b03a 	or	r16,r16,r2
8112e4c8:	0027883a 	mov	r19,zero
8112e4cc:	0013883a 	mov	r9,zero
8112e4d0:	3804d53a 	srli	r2,r7,20
8112e4d4:	382cd7fa 	srli	r22,r7,31
8112e4d8:	04400434 	movhi	r17,16
8112e4dc:	8c7fffc4 	addi	r17,r17,-1
8112e4e0:	1081ffcc 	andi	r2,r2,2047
8112e4e4:	3011883a 	mov	r8,r6
8112e4e8:	3c62703a 	and	r17,r7,r17
8112e4ec:	b5c03fcc 	andi	r23,r22,255
8112e4f0:	10006c26 	beq	r2,zero,8112e6a4 <__divdf3+0x254>
8112e4f4:	00c1ffc4 	movi	r3,2047
8112e4f8:	10c06426 	beq	r2,r3,8112e68c <__divdf3+0x23c>
8112e4fc:	88c00434 	orhi	r3,r17,16
8112e500:	180690fa 	slli	r3,r3,3
8112e504:	3022d77a 	srli	r17,r6,29
8112e508:	301090fa 	slli	r8,r6,3
8112e50c:	10bf0044 	addi	r2,r2,-1023
8112e510:	88e2b03a 	or	r17,r17,r3
8112e514:	000f883a 	mov	r7,zero
8112e518:	a58cf03a 	xor	r6,r20,r22
8112e51c:	3cc8b03a 	or	r4,r7,r19
8112e520:	a8abc83a 	sub	r21,r21,r2
8112e524:	008003c4 	movi	r2,15
8112e528:	3007883a 	mov	r3,r6
8112e52c:	34c03fcc 	andi	r19,r6,255
8112e530:	11009036 	bltu	r2,r4,8112e774 <__divdf3+0x324>
8112e534:	200890ba 	slli	r4,r4,2
8112e538:	00a044f4 	movhi	r2,33043
8112e53c:	10b95304 	addi	r2,r2,-6836
8112e540:	2089883a 	add	r4,r4,r2
8112e544:	20800017 	ldw	r2,0(r4)
8112e548:	1000683a 	jmp	r2
8112e54c:	8112e774 	orhi	r4,r16,19357
8112e550:	8112e5c4 	addi	r4,r16,19351
8112e554:	8112e764 	muli	r4,r16,19357
8112e558:	8112e5b8 	rdprs	r4,r16,19350
8112e55c:	8112e764 	muli	r4,r16,19357
8112e560:	8112e738 	rdprs	r4,r16,19356
8112e564:	8112e764 	muli	r4,r16,19357
8112e568:	8112e5b8 	rdprs	r4,r16,19350
8112e56c:	8112e5c4 	addi	r4,r16,19351
8112e570:	8112e5c4 	addi	r4,r16,19351
8112e574:	8112e738 	rdprs	r4,r16,19356
8112e578:	8112e5b8 	rdprs	r4,r16,19350
8112e57c:	8112e5a8 	cmpgeui	r4,r16,19350
8112e580:	8112e5a8 	cmpgeui	r4,r16,19350
8112e584:	8112e5a8 	cmpgeui	r4,r16,19350
8112e588:	8112ea58 	cmpnei	r4,r16,19369
8112e58c:	2404b03a 	or	r2,r4,r16
8112e590:	1000661e 	bne	r2,zero,8112e72c <__divdf3+0x2dc>
8112e594:	04c00204 	movi	r19,8
8112e598:	0021883a 	mov	r16,zero
8112e59c:	0025883a 	mov	r18,zero
8112e5a0:	02400084 	movi	r9,2
8112e5a4:	003fca06 	br	8112e4d0 <__reset+0xfb10e4d0>
8112e5a8:	8023883a 	mov	r17,r16
8112e5ac:	9011883a 	mov	r8,r18
8112e5b0:	e02f883a 	mov	r23,fp
8112e5b4:	480f883a 	mov	r7,r9
8112e5b8:	00800084 	movi	r2,2
8112e5bc:	3881311e 	bne	r7,r2,8112ea84 <__divdf3+0x634>
8112e5c0:	b827883a 	mov	r19,r23
8112e5c4:	98c0004c 	andi	r3,r19,1
8112e5c8:	0081ffc4 	movi	r2,2047
8112e5cc:	000b883a 	mov	r5,zero
8112e5d0:	0025883a 	mov	r18,zero
8112e5d4:	1004953a 	slli	r2,r2,20
8112e5d8:	18c03fcc 	andi	r3,r3,255
8112e5dc:	04400434 	movhi	r17,16
8112e5e0:	8c7fffc4 	addi	r17,r17,-1
8112e5e4:	180697fa 	slli	r3,r3,31
8112e5e8:	2c4a703a 	and	r5,r5,r17
8112e5ec:	288ab03a 	or	r5,r5,r2
8112e5f0:	28c6b03a 	or	r3,r5,r3
8112e5f4:	9005883a 	mov	r2,r18
8112e5f8:	dfc00d17 	ldw	ra,52(sp)
8112e5fc:	df000c17 	ldw	fp,48(sp)
8112e600:	ddc00b17 	ldw	r23,44(sp)
8112e604:	dd800a17 	ldw	r22,40(sp)
8112e608:	dd400917 	ldw	r21,36(sp)
8112e60c:	dd000817 	ldw	r20,32(sp)
8112e610:	dcc00717 	ldw	r19,28(sp)
8112e614:	dc800617 	ldw	r18,24(sp)
8112e618:	dc400517 	ldw	r17,20(sp)
8112e61c:	dc000417 	ldw	r16,16(sp)
8112e620:	dec00e04 	addi	sp,sp,56
8112e624:	f800283a 	ret
8112e628:	2404b03a 	or	r2,r4,r16
8112e62c:	2027883a 	mov	r19,r4
8112e630:	10003926 	beq	r2,zero,8112e718 <__divdf3+0x2c8>
8112e634:	80012e26 	beq	r16,zero,8112eaf0 <__divdf3+0x6a0>
8112e638:	8009883a 	mov	r4,r16
8112e63c:	d9800315 	stw	r6,12(sp)
8112e640:	d9c00215 	stw	r7,8(sp)
8112e644:	111ab180 	call	8111ab18 <__clzsi2>
8112e648:	d9800317 	ldw	r6,12(sp)
8112e64c:	d9c00217 	ldw	r7,8(sp)
8112e650:	113ffd44 	addi	r4,r2,-11
8112e654:	00c00704 	movi	r3,28
8112e658:	19012116 	blt	r3,r4,8112eae0 <__divdf3+0x690>
8112e65c:	00c00744 	movi	r3,29
8112e660:	147ffe04 	addi	r17,r2,-8
8112e664:	1907c83a 	sub	r3,r3,r4
8112e668:	8460983a 	sll	r16,r16,r17
8112e66c:	98c6d83a 	srl	r3,r19,r3
8112e670:	9c64983a 	sll	r18,r19,r17
8112e674:	1c20b03a 	or	r16,r3,r16
8112e678:	1080fcc4 	addi	r2,r2,1011
8112e67c:	00abc83a 	sub	r21,zero,r2
8112e680:	0027883a 	mov	r19,zero
8112e684:	0013883a 	mov	r9,zero
8112e688:	003f9106 	br	8112e4d0 <__reset+0xfb10e4d0>
8112e68c:	3446b03a 	or	r3,r6,r17
8112e690:	18001f1e 	bne	r3,zero,8112e710 <__divdf3+0x2c0>
8112e694:	0023883a 	mov	r17,zero
8112e698:	0011883a 	mov	r8,zero
8112e69c:	01c00084 	movi	r7,2
8112e6a0:	003f9d06 	br	8112e518 <__reset+0xfb10e518>
8112e6a4:	3446b03a 	or	r3,r6,r17
8112e6a8:	18001526 	beq	r3,zero,8112e700 <__divdf3+0x2b0>
8112e6ac:	88011b26 	beq	r17,zero,8112eb1c <__divdf3+0x6cc>
8112e6b0:	8809883a 	mov	r4,r17
8112e6b4:	d9800315 	stw	r6,12(sp)
8112e6b8:	da400115 	stw	r9,4(sp)
8112e6bc:	111ab180 	call	8111ab18 <__clzsi2>
8112e6c0:	d9800317 	ldw	r6,12(sp)
8112e6c4:	da400117 	ldw	r9,4(sp)
8112e6c8:	113ffd44 	addi	r4,r2,-11
8112e6cc:	00c00704 	movi	r3,28
8112e6d0:	19010e16 	blt	r3,r4,8112eb0c <__divdf3+0x6bc>
8112e6d4:	00c00744 	movi	r3,29
8112e6d8:	123ffe04 	addi	r8,r2,-8
8112e6dc:	1907c83a 	sub	r3,r3,r4
8112e6e0:	8a22983a 	sll	r17,r17,r8
8112e6e4:	30c6d83a 	srl	r3,r6,r3
8112e6e8:	3210983a 	sll	r8,r6,r8
8112e6ec:	1c62b03a 	or	r17,r3,r17
8112e6f0:	1080fcc4 	addi	r2,r2,1011
8112e6f4:	0085c83a 	sub	r2,zero,r2
8112e6f8:	000f883a 	mov	r7,zero
8112e6fc:	003f8606 	br	8112e518 <__reset+0xfb10e518>
8112e700:	0023883a 	mov	r17,zero
8112e704:	0011883a 	mov	r8,zero
8112e708:	01c00044 	movi	r7,1
8112e70c:	003f8206 	br	8112e518 <__reset+0xfb10e518>
8112e710:	01c000c4 	movi	r7,3
8112e714:	003f8006 	br	8112e518 <__reset+0xfb10e518>
8112e718:	04c00104 	movi	r19,4
8112e71c:	0021883a 	mov	r16,zero
8112e720:	0025883a 	mov	r18,zero
8112e724:	02400044 	movi	r9,1
8112e728:	003f6906 	br	8112e4d0 <__reset+0xfb10e4d0>
8112e72c:	04c00304 	movi	r19,12
8112e730:	024000c4 	movi	r9,3
8112e734:	003f6606 	br	8112e4d0 <__reset+0xfb10e4d0>
8112e738:	01400434 	movhi	r5,16
8112e73c:	0007883a 	mov	r3,zero
8112e740:	297fffc4 	addi	r5,r5,-1
8112e744:	04bfffc4 	movi	r18,-1
8112e748:	0081ffc4 	movi	r2,2047
8112e74c:	003fa106 	br	8112e5d4 <__reset+0xfb10e5d4>
8112e750:	00c00044 	movi	r3,1
8112e754:	1887c83a 	sub	r3,r3,r2
8112e758:	01000e04 	movi	r4,56
8112e75c:	20c1210e 	bge	r4,r3,8112ebe4 <__divdf3+0x794>
8112e760:	98c0004c 	andi	r3,r19,1
8112e764:	0005883a 	mov	r2,zero
8112e768:	000b883a 	mov	r5,zero
8112e76c:	0025883a 	mov	r18,zero
8112e770:	003f9806 	br	8112e5d4 <__reset+0xfb10e5d4>
8112e774:	8c00fd36 	bltu	r17,r16,8112eb6c <__divdf3+0x71c>
8112e778:	8440fb26 	beq	r16,r17,8112eb68 <__divdf3+0x718>
8112e77c:	8007883a 	mov	r3,r16
8112e780:	ad7fffc4 	addi	r21,r21,-1
8112e784:	0021883a 	mov	r16,zero
8112e788:	4004d63a 	srli	r2,r8,24
8112e78c:	8822923a 	slli	r17,r17,8
8112e790:	1809883a 	mov	r4,r3
8112e794:	402c923a 	slli	r22,r8,8
8112e798:	88b8b03a 	or	fp,r17,r2
8112e79c:	e028d43a 	srli	r20,fp,16
8112e7a0:	d8c00015 	stw	r3,0(sp)
8112e7a4:	e5ffffcc 	andi	r23,fp,65535
8112e7a8:	a00b883a 	mov	r5,r20
8112e7ac:	112d8e40 	call	8112d8e4 <__udivsi3>
8112e7b0:	d8c00017 	ldw	r3,0(sp)
8112e7b4:	a00b883a 	mov	r5,r20
8112e7b8:	d8800315 	stw	r2,12(sp)
8112e7bc:	1809883a 	mov	r4,r3
8112e7c0:	112d9480 	call	8112d948 <__umodsi3>
8112e7c4:	d9800317 	ldw	r6,12(sp)
8112e7c8:	1006943a 	slli	r3,r2,16
8112e7cc:	9004d43a 	srli	r2,r18,16
8112e7d0:	b9a3383a 	mul	r17,r23,r6
8112e7d4:	10c4b03a 	or	r2,r2,r3
8112e7d8:	1440062e 	bgeu	r2,r17,8112e7f4 <__divdf3+0x3a4>
8112e7dc:	1705883a 	add	r2,r2,fp
8112e7e0:	30ffffc4 	addi	r3,r6,-1
8112e7e4:	1700ee36 	bltu	r2,fp,8112eba0 <__divdf3+0x750>
8112e7e8:	1440ed2e 	bgeu	r2,r17,8112eba0 <__divdf3+0x750>
8112e7ec:	31bfff84 	addi	r6,r6,-2
8112e7f0:	1705883a 	add	r2,r2,fp
8112e7f4:	1463c83a 	sub	r17,r2,r17
8112e7f8:	a00b883a 	mov	r5,r20
8112e7fc:	8809883a 	mov	r4,r17
8112e800:	d9800315 	stw	r6,12(sp)
8112e804:	112d8e40 	call	8112d8e4 <__udivsi3>
8112e808:	a00b883a 	mov	r5,r20
8112e80c:	8809883a 	mov	r4,r17
8112e810:	d8800215 	stw	r2,8(sp)
8112e814:	112d9480 	call	8112d948 <__umodsi3>
8112e818:	d9c00217 	ldw	r7,8(sp)
8112e81c:	1004943a 	slli	r2,r2,16
8112e820:	94bfffcc 	andi	r18,r18,65535
8112e824:	b9d1383a 	mul	r8,r23,r7
8112e828:	90a4b03a 	or	r18,r18,r2
8112e82c:	d9800317 	ldw	r6,12(sp)
8112e830:	9200062e 	bgeu	r18,r8,8112e84c <__divdf3+0x3fc>
8112e834:	9725883a 	add	r18,r18,fp
8112e838:	38bfffc4 	addi	r2,r7,-1
8112e83c:	9700d636 	bltu	r18,fp,8112eb98 <__divdf3+0x748>
8112e840:	9200d52e 	bgeu	r18,r8,8112eb98 <__divdf3+0x748>
8112e844:	39ffff84 	addi	r7,r7,-2
8112e848:	9725883a 	add	r18,r18,fp
8112e84c:	3004943a 	slli	r2,r6,16
8112e850:	b012d43a 	srli	r9,r22,16
8112e854:	b1bfffcc 	andi	r6,r22,65535
8112e858:	11e2b03a 	or	r17,r2,r7
8112e85c:	8806d43a 	srli	r3,r17,16
8112e860:	893fffcc 	andi	r4,r17,65535
8112e864:	218b383a 	mul	r5,r4,r6
8112e868:	30c5383a 	mul	r2,r6,r3
8112e86c:	2249383a 	mul	r4,r4,r9
8112e870:	280ed43a 	srli	r7,r5,16
8112e874:	9225c83a 	sub	r18,r18,r8
8112e878:	2089883a 	add	r4,r4,r2
8112e87c:	3909883a 	add	r4,r7,r4
8112e880:	1a47383a 	mul	r3,r3,r9
8112e884:	2080022e 	bgeu	r4,r2,8112e890 <__divdf3+0x440>
8112e888:	00800074 	movhi	r2,1
8112e88c:	1887883a 	add	r3,r3,r2
8112e890:	2004d43a 	srli	r2,r4,16
8112e894:	2008943a 	slli	r4,r4,16
8112e898:	297fffcc 	andi	r5,r5,65535
8112e89c:	10c7883a 	add	r3,r2,r3
8112e8a0:	2149883a 	add	r4,r4,r5
8112e8a4:	90c0a536 	bltu	r18,r3,8112eb3c <__divdf3+0x6ec>
8112e8a8:	90c0bf26 	beq	r18,r3,8112eba8 <__divdf3+0x758>
8112e8ac:	90c7c83a 	sub	r3,r18,r3
8112e8b0:	810fc83a 	sub	r7,r16,r4
8112e8b4:	81e5803a 	cmpltu	r18,r16,r7
8112e8b8:	1ca5c83a 	sub	r18,r3,r18
8112e8bc:	e480c126 	beq	fp,r18,8112ebc4 <__divdf3+0x774>
8112e8c0:	a00b883a 	mov	r5,r20
8112e8c4:	9009883a 	mov	r4,r18
8112e8c8:	d9800315 	stw	r6,12(sp)
8112e8cc:	d9c00215 	stw	r7,8(sp)
8112e8d0:	da400115 	stw	r9,4(sp)
8112e8d4:	112d8e40 	call	8112d8e4 <__udivsi3>
8112e8d8:	a00b883a 	mov	r5,r20
8112e8dc:	9009883a 	mov	r4,r18
8112e8e0:	d8800015 	stw	r2,0(sp)
8112e8e4:	112d9480 	call	8112d948 <__umodsi3>
8112e8e8:	d9c00217 	ldw	r7,8(sp)
8112e8ec:	da000017 	ldw	r8,0(sp)
8112e8f0:	1006943a 	slli	r3,r2,16
8112e8f4:	3804d43a 	srli	r2,r7,16
8112e8f8:	ba21383a 	mul	r16,r23,r8
8112e8fc:	d9800317 	ldw	r6,12(sp)
8112e900:	10c4b03a 	or	r2,r2,r3
8112e904:	da400117 	ldw	r9,4(sp)
8112e908:	1400062e 	bgeu	r2,r16,8112e924 <__divdf3+0x4d4>
8112e90c:	1705883a 	add	r2,r2,fp
8112e910:	40ffffc4 	addi	r3,r8,-1
8112e914:	1700ad36 	bltu	r2,fp,8112ebcc <__divdf3+0x77c>
8112e918:	1400ac2e 	bgeu	r2,r16,8112ebcc <__divdf3+0x77c>
8112e91c:	423fff84 	addi	r8,r8,-2
8112e920:	1705883a 	add	r2,r2,fp
8112e924:	1421c83a 	sub	r16,r2,r16
8112e928:	a00b883a 	mov	r5,r20
8112e92c:	8009883a 	mov	r4,r16
8112e930:	d9800315 	stw	r6,12(sp)
8112e934:	d9c00215 	stw	r7,8(sp)
8112e938:	da000015 	stw	r8,0(sp)
8112e93c:	da400115 	stw	r9,4(sp)
8112e940:	112d8e40 	call	8112d8e4 <__udivsi3>
8112e944:	8009883a 	mov	r4,r16
8112e948:	a00b883a 	mov	r5,r20
8112e94c:	1025883a 	mov	r18,r2
8112e950:	112d9480 	call	8112d948 <__umodsi3>
8112e954:	d9c00217 	ldw	r7,8(sp)
8112e958:	1004943a 	slli	r2,r2,16
8112e95c:	bcaf383a 	mul	r23,r23,r18
8112e960:	393fffcc 	andi	r4,r7,65535
8112e964:	2088b03a 	or	r4,r4,r2
8112e968:	d9800317 	ldw	r6,12(sp)
8112e96c:	da000017 	ldw	r8,0(sp)
8112e970:	da400117 	ldw	r9,4(sp)
8112e974:	25c0062e 	bgeu	r4,r23,8112e990 <__divdf3+0x540>
8112e978:	2709883a 	add	r4,r4,fp
8112e97c:	90bfffc4 	addi	r2,r18,-1
8112e980:	27009436 	bltu	r4,fp,8112ebd4 <__divdf3+0x784>
8112e984:	25c0932e 	bgeu	r4,r23,8112ebd4 <__divdf3+0x784>
8112e988:	94bfff84 	addi	r18,r18,-2
8112e98c:	2709883a 	add	r4,r4,fp
8112e990:	4004943a 	slli	r2,r8,16
8112e994:	25efc83a 	sub	r23,r4,r23
8112e998:	1490b03a 	or	r8,r2,r18
8112e99c:	4008d43a 	srli	r4,r8,16
8112e9a0:	40ffffcc 	andi	r3,r8,65535
8112e9a4:	30c5383a 	mul	r2,r6,r3
8112e9a8:	1a47383a 	mul	r3,r3,r9
8112e9ac:	310d383a 	mul	r6,r6,r4
8112e9b0:	100ad43a 	srli	r5,r2,16
8112e9b4:	4913383a 	mul	r9,r9,r4
8112e9b8:	1987883a 	add	r3,r3,r6
8112e9bc:	28c7883a 	add	r3,r5,r3
8112e9c0:	1980022e 	bgeu	r3,r6,8112e9cc <__divdf3+0x57c>
8112e9c4:	01000074 	movhi	r4,1
8112e9c8:	4913883a 	add	r9,r9,r4
8112e9cc:	1808d43a 	srli	r4,r3,16
8112e9d0:	1806943a 	slli	r3,r3,16
8112e9d4:	10bfffcc 	andi	r2,r2,65535
8112e9d8:	2253883a 	add	r9,r4,r9
8112e9dc:	1887883a 	add	r3,r3,r2
8112e9e0:	ba403836 	bltu	r23,r9,8112eac4 <__divdf3+0x674>
8112e9e4:	ba403626 	beq	r23,r9,8112eac0 <__divdf3+0x670>
8112e9e8:	42000054 	ori	r8,r8,1
8112e9ec:	a880ffc4 	addi	r2,r21,1023
8112e9f0:	00bf570e 	bge	zero,r2,8112e750 <__reset+0xfb10e750>
8112e9f4:	40c001cc 	andi	r3,r8,7
8112e9f8:	18000726 	beq	r3,zero,8112ea18 <__divdf3+0x5c8>
8112e9fc:	40c003cc 	andi	r3,r8,15
8112ea00:	01000104 	movi	r4,4
8112ea04:	19000426 	beq	r3,r4,8112ea18 <__divdf3+0x5c8>
8112ea08:	4107883a 	add	r3,r8,r4
8112ea0c:	1a11803a 	cmpltu	r8,r3,r8
8112ea10:	8a23883a 	add	r17,r17,r8
8112ea14:	1811883a 	mov	r8,r3
8112ea18:	88c0402c 	andhi	r3,r17,256
8112ea1c:	18000426 	beq	r3,zero,8112ea30 <__divdf3+0x5e0>
8112ea20:	00ffc034 	movhi	r3,65280
8112ea24:	18ffffc4 	addi	r3,r3,-1
8112ea28:	a8810004 	addi	r2,r21,1024
8112ea2c:	88e2703a 	and	r17,r17,r3
8112ea30:	00c1ff84 	movi	r3,2046
8112ea34:	18bee316 	blt	r3,r2,8112e5c4 <__reset+0xfb10e5c4>
8112ea38:	8824977a 	slli	r18,r17,29
8112ea3c:	4010d0fa 	srli	r8,r8,3
8112ea40:	8822927a 	slli	r17,r17,9
8112ea44:	1081ffcc 	andi	r2,r2,2047
8112ea48:	9224b03a 	or	r18,r18,r8
8112ea4c:	880ad33a 	srli	r5,r17,12
8112ea50:	98c0004c 	andi	r3,r19,1
8112ea54:	003edf06 	br	8112e5d4 <__reset+0xfb10e5d4>
8112ea58:	8080022c 	andhi	r2,r16,8
8112ea5c:	10001226 	beq	r2,zero,8112eaa8 <__divdf3+0x658>
8112ea60:	8880022c 	andhi	r2,r17,8
8112ea64:	1000101e 	bne	r2,zero,8112eaa8 <__divdf3+0x658>
8112ea68:	00800434 	movhi	r2,16
8112ea6c:	89400234 	orhi	r5,r17,8
8112ea70:	10bfffc4 	addi	r2,r2,-1
8112ea74:	b007883a 	mov	r3,r22
8112ea78:	288a703a 	and	r5,r5,r2
8112ea7c:	4025883a 	mov	r18,r8
8112ea80:	003f3106 	br	8112e748 <__reset+0xfb10e748>
8112ea84:	008000c4 	movi	r2,3
8112ea88:	3880a626 	beq	r7,r2,8112ed24 <__divdf3+0x8d4>
8112ea8c:	00800044 	movi	r2,1
8112ea90:	3880521e 	bne	r7,r2,8112ebdc <__divdf3+0x78c>
8112ea94:	b807883a 	mov	r3,r23
8112ea98:	0005883a 	mov	r2,zero
8112ea9c:	000b883a 	mov	r5,zero
8112eaa0:	0025883a 	mov	r18,zero
8112eaa4:	003ecb06 	br	8112e5d4 <__reset+0xfb10e5d4>
8112eaa8:	00800434 	movhi	r2,16
8112eaac:	81400234 	orhi	r5,r16,8
8112eab0:	10bfffc4 	addi	r2,r2,-1
8112eab4:	a007883a 	mov	r3,r20
8112eab8:	288a703a 	and	r5,r5,r2
8112eabc:	003f2206 	br	8112e748 <__reset+0xfb10e748>
8112eac0:	183fca26 	beq	r3,zero,8112e9ec <__reset+0xfb10e9ec>
8112eac4:	e5ef883a 	add	r23,fp,r23
8112eac8:	40bfffc4 	addi	r2,r8,-1
8112eacc:	bf00392e 	bgeu	r23,fp,8112ebb4 <__divdf3+0x764>
8112ead0:	1011883a 	mov	r8,r2
8112ead4:	ba7fc41e 	bne	r23,r9,8112e9e8 <__reset+0xfb10e9e8>
8112ead8:	b0ffc31e 	bne	r22,r3,8112e9e8 <__reset+0xfb10e9e8>
8112eadc:	003fc306 	br	8112e9ec <__reset+0xfb10e9ec>
8112eae0:	143ff604 	addi	r16,r2,-40
8112eae4:	9c20983a 	sll	r16,r19,r16
8112eae8:	0025883a 	mov	r18,zero
8112eaec:	003ee206 	br	8112e678 <__reset+0xfb10e678>
8112eaf0:	d9800315 	stw	r6,12(sp)
8112eaf4:	d9c00215 	stw	r7,8(sp)
8112eaf8:	111ab180 	call	8111ab18 <__clzsi2>
8112eafc:	10800804 	addi	r2,r2,32
8112eb00:	d9c00217 	ldw	r7,8(sp)
8112eb04:	d9800317 	ldw	r6,12(sp)
8112eb08:	003ed106 	br	8112e650 <__reset+0xfb10e650>
8112eb0c:	147ff604 	addi	r17,r2,-40
8112eb10:	3462983a 	sll	r17,r6,r17
8112eb14:	0011883a 	mov	r8,zero
8112eb18:	003ef506 	br	8112e6f0 <__reset+0xfb10e6f0>
8112eb1c:	3009883a 	mov	r4,r6
8112eb20:	d9800315 	stw	r6,12(sp)
8112eb24:	da400115 	stw	r9,4(sp)
8112eb28:	111ab180 	call	8111ab18 <__clzsi2>
8112eb2c:	10800804 	addi	r2,r2,32
8112eb30:	da400117 	ldw	r9,4(sp)
8112eb34:	d9800317 	ldw	r6,12(sp)
8112eb38:	003ee306 	br	8112e6c8 <__reset+0xfb10e6c8>
8112eb3c:	85a1883a 	add	r16,r16,r22
8112eb40:	8585803a 	cmpltu	r2,r16,r22
8112eb44:	1705883a 	add	r2,r2,fp
8112eb48:	14a5883a 	add	r18,r2,r18
8112eb4c:	88bfffc4 	addi	r2,r17,-1
8112eb50:	e4800c2e 	bgeu	fp,r18,8112eb84 <__divdf3+0x734>
8112eb54:	90c03e36 	bltu	r18,r3,8112ec50 <__divdf3+0x800>
8112eb58:	1c806926 	beq	r3,r18,8112ed00 <__divdf3+0x8b0>
8112eb5c:	90c7c83a 	sub	r3,r18,r3
8112eb60:	1023883a 	mov	r17,r2
8112eb64:	003f5206 	br	8112e8b0 <__reset+0xfb10e8b0>
8112eb68:	923f0436 	bltu	r18,r8,8112e77c <__reset+0xfb10e77c>
8112eb6c:	800897fa 	slli	r4,r16,31
8112eb70:	9004d07a 	srli	r2,r18,1
8112eb74:	8006d07a 	srli	r3,r16,1
8112eb78:	902097fa 	slli	r16,r18,31
8112eb7c:	20a4b03a 	or	r18,r4,r2
8112eb80:	003f0106 	br	8112e788 <__reset+0xfb10e788>
8112eb84:	e4bff51e 	bne	fp,r18,8112eb5c <__reset+0xfb10eb5c>
8112eb88:	85bff22e 	bgeu	r16,r22,8112eb54 <__reset+0xfb10eb54>
8112eb8c:	e0c7c83a 	sub	r3,fp,r3
8112eb90:	1023883a 	mov	r17,r2
8112eb94:	003f4606 	br	8112e8b0 <__reset+0xfb10e8b0>
8112eb98:	100f883a 	mov	r7,r2
8112eb9c:	003f2b06 	br	8112e84c <__reset+0xfb10e84c>
8112eba0:	180d883a 	mov	r6,r3
8112eba4:	003f1306 	br	8112e7f4 <__reset+0xfb10e7f4>
8112eba8:	813fe436 	bltu	r16,r4,8112eb3c <__reset+0xfb10eb3c>
8112ebac:	0007883a 	mov	r3,zero
8112ebb0:	003f3f06 	br	8112e8b0 <__reset+0xfb10e8b0>
8112ebb4:	ba402c36 	bltu	r23,r9,8112ec68 <__divdf3+0x818>
8112ebb8:	4dc05426 	beq	r9,r23,8112ed0c <__divdf3+0x8bc>
8112ebbc:	1011883a 	mov	r8,r2
8112ebc0:	003f8906 	br	8112e9e8 <__reset+0xfb10e9e8>
8112ebc4:	023fffc4 	movi	r8,-1
8112ebc8:	003f8806 	br	8112e9ec <__reset+0xfb10e9ec>
8112ebcc:	1811883a 	mov	r8,r3
8112ebd0:	003f5406 	br	8112e924 <__reset+0xfb10e924>
8112ebd4:	1025883a 	mov	r18,r2
8112ebd8:	003f6d06 	br	8112e990 <__reset+0xfb10e990>
8112ebdc:	b827883a 	mov	r19,r23
8112ebe0:	003f8206 	br	8112e9ec <__reset+0xfb10e9ec>
8112ebe4:	010007c4 	movi	r4,31
8112ebe8:	20c02616 	blt	r4,r3,8112ec84 <__divdf3+0x834>
8112ebec:	00800804 	movi	r2,32
8112ebf0:	10c5c83a 	sub	r2,r2,r3
8112ebf4:	888a983a 	sll	r5,r17,r2
8112ebf8:	40c8d83a 	srl	r4,r8,r3
8112ebfc:	4084983a 	sll	r2,r8,r2
8112ec00:	88e2d83a 	srl	r17,r17,r3
8112ec04:	2906b03a 	or	r3,r5,r4
8112ec08:	1004c03a 	cmpne	r2,r2,zero
8112ec0c:	1886b03a 	or	r3,r3,r2
8112ec10:	188001cc 	andi	r2,r3,7
8112ec14:	10000726 	beq	r2,zero,8112ec34 <__divdf3+0x7e4>
8112ec18:	188003cc 	andi	r2,r3,15
8112ec1c:	01000104 	movi	r4,4
8112ec20:	11000426 	beq	r2,r4,8112ec34 <__divdf3+0x7e4>
8112ec24:	1805883a 	mov	r2,r3
8112ec28:	10c00104 	addi	r3,r2,4
8112ec2c:	1885803a 	cmpltu	r2,r3,r2
8112ec30:	88a3883a 	add	r17,r17,r2
8112ec34:	8880202c 	andhi	r2,r17,128
8112ec38:	10002726 	beq	r2,zero,8112ecd8 <__divdf3+0x888>
8112ec3c:	98c0004c 	andi	r3,r19,1
8112ec40:	00800044 	movi	r2,1
8112ec44:	000b883a 	mov	r5,zero
8112ec48:	0025883a 	mov	r18,zero
8112ec4c:	003e6106 	br	8112e5d4 <__reset+0xfb10e5d4>
8112ec50:	85a1883a 	add	r16,r16,r22
8112ec54:	8585803a 	cmpltu	r2,r16,r22
8112ec58:	1705883a 	add	r2,r2,fp
8112ec5c:	14a5883a 	add	r18,r2,r18
8112ec60:	8c7fff84 	addi	r17,r17,-2
8112ec64:	003f1106 	br	8112e8ac <__reset+0xfb10e8ac>
8112ec68:	b589883a 	add	r4,r22,r22
8112ec6c:	25ad803a 	cmpltu	r22,r4,r22
8112ec70:	b739883a 	add	fp,r22,fp
8112ec74:	40bfff84 	addi	r2,r8,-2
8112ec78:	bf2f883a 	add	r23,r23,fp
8112ec7c:	202d883a 	mov	r22,r4
8112ec80:	003f9306 	br	8112ead0 <__reset+0xfb10ead0>
8112ec84:	013ff844 	movi	r4,-31
8112ec88:	2085c83a 	sub	r2,r4,r2
8112ec8c:	8888d83a 	srl	r4,r17,r2
8112ec90:	00800804 	movi	r2,32
8112ec94:	18802126 	beq	r3,r2,8112ed1c <__divdf3+0x8cc>
8112ec98:	00801004 	movi	r2,64
8112ec9c:	10c5c83a 	sub	r2,r2,r3
8112eca0:	8884983a 	sll	r2,r17,r2
8112eca4:	1204b03a 	or	r2,r2,r8
8112eca8:	1004c03a 	cmpne	r2,r2,zero
8112ecac:	2084b03a 	or	r2,r4,r2
8112ecb0:	144001cc 	andi	r17,r2,7
8112ecb4:	88000d1e 	bne	r17,zero,8112ecec <__divdf3+0x89c>
8112ecb8:	000b883a 	mov	r5,zero
8112ecbc:	1024d0fa 	srli	r18,r2,3
8112ecc0:	98c0004c 	andi	r3,r19,1
8112ecc4:	0005883a 	mov	r2,zero
8112ecc8:	9464b03a 	or	r18,r18,r17
8112eccc:	003e4106 	br	8112e5d4 <__reset+0xfb10e5d4>
8112ecd0:	1007883a 	mov	r3,r2
8112ecd4:	0023883a 	mov	r17,zero
8112ecd8:	880a927a 	slli	r5,r17,9
8112ecdc:	1805883a 	mov	r2,r3
8112ece0:	8822977a 	slli	r17,r17,29
8112ece4:	280ad33a 	srli	r5,r5,12
8112ece8:	003ff406 	br	8112ecbc <__reset+0xfb10ecbc>
8112ecec:	10c003cc 	andi	r3,r2,15
8112ecf0:	01000104 	movi	r4,4
8112ecf4:	193ff626 	beq	r3,r4,8112ecd0 <__reset+0xfb10ecd0>
8112ecf8:	0023883a 	mov	r17,zero
8112ecfc:	003fca06 	br	8112ec28 <__reset+0xfb10ec28>
8112ed00:	813fd336 	bltu	r16,r4,8112ec50 <__reset+0xfb10ec50>
8112ed04:	1023883a 	mov	r17,r2
8112ed08:	003fa806 	br	8112ebac <__reset+0xfb10ebac>
8112ed0c:	b0ffd636 	bltu	r22,r3,8112ec68 <__reset+0xfb10ec68>
8112ed10:	1011883a 	mov	r8,r2
8112ed14:	b0ff341e 	bne	r22,r3,8112e9e8 <__reset+0xfb10e9e8>
8112ed18:	003f3406 	br	8112e9ec <__reset+0xfb10e9ec>
8112ed1c:	0005883a 	mov	r2,zero
8112ed20:	003fe006 	br	8112eca4 <__reset+0xfb10eca4>
8112ed24:	00800434 	movhi	r2,16
8112ed28:	89400234 	orhi	r5,r17,8
8112ed2c:	10bfffc4 	addi	r2,r2,-1
8112ed30:	b807883a 	mov	r3,r23
8112ed34:	288a703a 	and	r5,r5,r2
8112ed38:	4025883a 	mov	r18,r8
8112ed3c:	003e8206 	br	8112e748 <__reset+0xfb10e748>

8112ed40 <__eqdf2>:
8112ed40:	2804d53a 	srli	r2,r5,20
8112ed44:	3806d53a 	srli	r3,r7,20
8112ed48:	02000434 	movhi	r8,16
8112ed4c:	423fffc4 	addi	r8,r8,-1
8112ed50:	1081ffcc 	andi	r2,r2,2047
8112ed54:	0281ffc4 	movi	r10,2047
8112ed58:	2a12703a 	and	r9,r5,r8
8112ed5c:	18c1ffcc 	andi	r3,r3,2047
8112ed60:	3a10703a 	and	r8,r7,r8
8112ed64:	280ad7fa 	srli	r5,r5,31
8112ed68:	380ed7fa 	srli	r7,r7,31
8112ed6c:	12801026 	beq	r2,r10,8112edb0 <__eqdf2+0x70>
8112ed70:	0281ffc4 	movi	r10,2047
8112ed74:	1a800a26 	beq	r3,r10,8112eda0 <__eqdf2+0x60>
8112ed78:	10c00226 	beq	r2,r3,8112ed84 <__eqdf2+0x44>
8112ed7c:	00800044 	movi	r2,1
8112ed80:	f800283a 	ret
8112ed84:	4a3ffd1e 	bne	r9,r8,8112ed7c <__reset+0xfb10ed7c>
8112ed88:	21bffc1e 	bne	r4,r6,8112ed7c <__reset+0xfb10ed7c>
8112ed8c:	29c00c26 	beq	r5,r7,8112edc0 <__eqdf2+0x80>
8112ed90:	103ffa1e 	bne	r2,zero,8112ed7c <__reset+0xfb10ed7c>
8112ed94:	2244b03a 	or	r2,r4,r9
8112ed98:	1004c03a 	cmpne	r2,r2,zero
8112ed9c:	f800283a 	ret
8112eda0:	3214b03a 	or	r10,r6,r8
8112eda4:	503ff426 	beq	r10,zero,8112ed78 <__reset+0xfb10ed78>
8112eda8:	00800044 	movi	r2,1
8112edac:	f800283a 	ret
8112edb0:	2254b03a 	or	r10,r4,r9
8112edb4:	503fee26 	beq	r10,zero,8112ed70 <__reset+0xfb10ed70>
8112edb8:	00800044 	movi	r2,1
8112edbc:	f800283a 	ret
8112edc0:	0005883a 	mov	r2,zero
8112edc4:	f800283a 	ret

8112edc8 <__ledf2>:
8112edc8:	2804d53a 	srli	r2,r5,20
8112edcc:	3810d53a 	srli	r8,r7,20
8112edd0:	00c00434 	movhi	r3,16
8112edd4:	18ffffc4 	addi	r3,r3,-1
8112edd8:	1081ffcc 	andi	r2,r2,2047
8112eddc:	0241ffc4 	movi	r9,2047
8112ede0:	28d4703a 	and	r10,r5,r3
8112ede4:	4201ffcc 	andi	r8,r8,2047
8112ede8:	38c6703a 	and	r3,r7,r3
8112edec:	280ad7fa 	srli	r5,r5,31
8112edf0:	380ed7fa 	srli	r7,r7,31
8112edf4:	12401f26 	beq	r2,r9,8112ee74 <__ledf2+0xac>
8112edf8:	0241ffc4 	movi	r9,2047
8112edfc:	42401426 	beq	r8,r9,8112ee50 <__ledf2+0x88>
8112ee00:	1000091e 	bne	r2,zero,8112ee28 <__ledf2+0x60>
8112ee04:	2296b03a 	or	r11,r4,r10
8112ee08:	5813003a 	cmpeq	r9,r11,zero
8112ee0c:	29403fcc 	andi	r5,r5,255
8112ee10:	40000a1e 	bne	r8,zero,8112ee3c <__ledf2+0x74>
8112ee14:	30d8b03a 	or	r12,r6,r3
8112ee18:	6000081e 	bne	r12,zero,8112ee3c <__ledf2+0x74>
8112ee1c:	0005883a 	mov	r2,zero
8112ee20:	5800111e 	bne	r11,zero,8112ee68 <__ledf2+0xa0>
8112ee24:	f800283a 	ret
8112ee28:	29403fcc 	andi	r5,r5,255
8112ee2c:	40000c1e 	bne	r8,zero,8112ee60 <__ledf2+0x98>
8112ee30:	30d2b03a 	or	r9,r6,r3
8112ee34:	48000c26 	beq	r9,zero,8112ee68 <__ledf2+0xa0>
8112ee38:	0013883a 	mov	r9,zero
8112ee3c:	39c03fcc 	andi	r7,r7,255
8112ee40:	48000826 	beq	r9,zero,8112ee64 <__ledf2+0x9c>
8112ee44:	38001126 	beq	r7,zero,8112ee8c <__ledf2+0xc4>
8112ee48:	00800044 	movi	r2,1
8112ee4c:	f800283a 	ret
8112ee50:	30d2b03a 	or	r9,r6,r3
8112ee54:	483fea26 	beq	r9,zero,8112ee00 <__reset+0xfb10ee00>
8112ee58:	00800084 	movi	r2,2
8112ee5c:	f800283a 	ret
8112ee60:	39c03fcc 	andi	r7,r7,255
8112ee64:	39400726 	beq	r7,r5,8112ee84 <__ledf2+0xbc>
8112ee68:	2800081e 	bne	r5,zero,8112ee8c <__ledf2+0xc4>
8112ee6c:	00800044 	movi	r2,1
8112ee70:	f800283a 	ret
8112ee74:	2292b03a 	or	r9,r4,r10
8112ee78:	483fdf26 	beq	r9,zero,8112edf8 <__reset+0xfb10edf8>
8112ee7c:	00800084 	movi	r2,2
8112ee80:	f800283a 	ret
8112ee84:	4080030e 	bge	r8,r2,8112ee94 <__ledf2+0xcc>
8112ee88:	383fef26 	beq	r7,zero,8112ee48 <__reset+0xfb10ee48>
8112ee8c:	00bfffc4 	movi	r2,-1
8112ee90:	f800283a 	ret
8112ee94:	123feb16 	blt	r2,r8,8112ee44 <__reset+0xfb10ee44>
8112ee98:	1abff336 	bltu	r3,r10,8112ee68 <__reset+0xfb10ee68>
8112ee9c:	50c00326 	beq	r10,r3,8112eeac <__ledf2+0xe4>
8112eea0:	50c0042e 	bgeu	r10,r3,8112eeb4 <__ledf2+0xec>
8112eea4:	283fe81e 	bne	r5,zero,8112ee48 <__reset+0xfb10ee48>
8112eea8:	003ff806 	br	8112ee8c <__reset+0xfb10ee8c>
8112eeac:	313fee36 	bltu	r6,r4,8112ee68 <__reset+0xfb10ee68>
8112eeb0:	21bffc36 	bltu	r4,r6,8112eea4 <__reset+0xfb10eea4>
8112eeb4:	0005883a 	mov	r2,zero
8112eeb8:	f800283a 	ret

8112eebc <__floatunsidf>:
8112eebc:	defffe04 	addi	sp,sp,-8
8112eec0:	de00012e 	bgeu	sp,et,8112eec8 <__floatunsidf+0xc>
8112eec4:	003b68fa 	trap	3
8112eec8:	dc000015 	stw	r16,0(sp)
8112eecc:	dfc00115 	stw	ra,4(sp)
8112eed0:	2021883a 	mov	r16,r4
8112eed4:	20002226 	beq	r4,zero,8112ef60 <__floatunsidf+0xa4>
8112eed8:	111ab180 	call	8111ab18 <__clzsi2>
8112eedc:	01010784 	movi	r4,1054
8112eee0:	2089c83a 	sub	r4,r4,r2
8112eee4:	01810cc4 	movi	r6,1075
8112eee8:	310dc83a 	sub	r6,r6,r4
8112eeec:	00c007c4 	movi	r3,31
8112eef0:	1980120e 	bge	r3,r6,8112ef3c <__floatunsidf+0x80>
8112eef4:	00c104c4 	movi	r3,1043
8112eef8:	1907c83a 	sub	r3,r3,r4
8112eefc:	80ca983a 	sll	r5,r16,r3
8112ef00:	00800434 	movhi	r2,16
8112ef04:	10bfffc4 	addi	r2,r2,-1
8112ef08:	2101ffcc 	andi	r4,r4,2047
8112ef0c:	0021883a 	mov	r16,zero
8112ef10:	288a703a 	and	r5,r5,r2
8112ef14:	2008953a 	slli	r4,r4,20
8112ef18:	00c00434 	movhi	r3,16
8112ef1c:	18ffffc4 	addi	r3,r3,-1
8112ef20:	28c6703a 	and	r3,r5,r3
8112ef24:	8005883a 	mov	r2,r16
8112ef28:	1906b03a 	or	r3,r3,r4
8112ef2c:	dfc00117 	ldw	ra,4(sp)
8112ef30:	dc000017 	ldw	r16,0(sp)
8112ef34:	dec00204 	addi	sp,sp,8
8112ef38:	f800283a 	ret
8112ef3c:	00c002c4 	movi	r3,11
8112ef40:	188bc83a 	sub	r5,r3,r2
8112ef44:	814ad83a 	srl	r5,r16,r5
8112ef48:	00c00434 	movhi	r3,16
8112ef4c:	18ffffc4 	addi	r3,r3,-1
8112ef50:	81a0983a 	sll	r16,r16,r6
8112ef54:	2101ffcc 	andi	r4,r4,2047
8112ef58:	28ca703a 	and	r5,r5,r3
8112ef5c:	003fed06 	br	8112ef14 <__reset+0xfb10ef14>
8112ef60:	0009883a 	mov	r4,zero
8112ef64:	000b883a 	mov	r5,zero
8112ef68:	003fea06 	br	8112ef14 <__reset+0xfb10ef14>

8112ef6c <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
8112ef6c:	defffb04 	addi	sp,sp,-20
8112ef70:	de00012e 	bgeu	sp,et,8112ef78 <alt_busy_sleep+0xc>
8112ef74:	003b68fa 	trap	3
8112ef78:	df000415 	stw	fp,16(sp)
8112ef7c:	df000404 	addi	fp,sp,16
8112ef80:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
8112ef84:	008000c4 	movi	r2,3
8112ef88:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
8112ef8c:	e0fffd17 	ldw	r3,-12(fp)
8112ef90:	008003f4 	movhi	r2,15
8112ef94:	10909004 	addi	r2,r2,16960
8112ef98:	1887383a 	mul	r3,r3,r2
8112ef9c:	00817db4 	movhi	r2,1526
8112efa0:	10b84004 	addi	r2,r2,-7936
8112efa4:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
8112efa8:	00a00034 	movhi	r2,32768
8112efac:	10bfffc4 	addi	r2,r2,-1
8112efb0:	10c5203a 	divu	r2,r2,r3
8112efb4:	e0ffff17 	ldw	r3,-4(fp)
8112efb8:	1885203a 	divu	r2,r3,r2
8112efbc:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
8112efc0:	e0bffe17 	ldw	r2,-8(fp)
8112efc4:	10002526 	beq	r2,zero,8112f05c <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
8112efc8:	e03ffc15 	stw	zero,-16(fp)
8112efcc:	00001406 	br	8112f020 <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
8112efd0:	00a00034 	movhi	r2,32768
8112efd4:	10bfffc4 	addi	r2,r2,-1
8112efd8:	10bfffc4 	addi	r2,r2,-1
8112efdc:	103ffe1e 	bne	r2,zero,8112efd8 <__reset+0xfb10efd8>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
8112efe0:	e0fffd17 	ldw	r3,-12(fp)
8112efe4:	008003f4 	movhi	r2,15
8112efe8:	10909004 	addi	r2,r2,16960
8112efec:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
8112eff0:	00817db4 	movhi	r2,1526
8112eff4:	10b84004 	addi	r2,r2,-7936
8112eff8:	10c7203a 	divu	r3,r2,r3
8112effc:	00a00034 	movhi	r2,32768
8112f000:	10bfffc4 	addi	r2,r2,-1
8112f004:	10c5203a 	divu	r2,r2,r3
8112f008:	e0ffff17 	ldw	r3,-4(fp)
8112f00c:	1885c83a 	sub	r2,r3,r2
8112f010:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
8112f014:	e0bffc17 	ldw	r2,-16(fp)
8112f018:	10800044 	addi	r2,r2,1
8112f01c:	e0bffc15 	stw	r2,-16(fp)
8112f020:	e0fffc17 	ldw	r3,-16(fp)
8112f024:	e0bffe17 	ldw	r2,-8(fp)
8112f028:	18bfe916 	blt	r3,r2,8112efd0 <__reset+0xfb10efd0>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
8112f02c:	e0fffd17 	ldw	r3,-12(fp)
8112f030:	008003f4 	movhi	r2,15
8112f034:	10909004 	addi	r2,r2,16960
8112f038:	1887383a 	mul	r3,r3,r2
8112f03c:	00817db4 	movhi	r2,1526
8112f040:	10b84004 	addi	r2,r2,-7936
8112f044:	10c7203a 	divu	r3,r2,r3
8112f048:	e0bfff17 	ldw	r2,-4(fp)
8112f04c:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
8112f050:	10bfffc4 	addi	r2,r2,-1
8112f054:	103ffe1e 	bne	r2,zero,8112f050 <__reset+0xfb10f050>
8112f058:	00000b06 	br	8112f088 <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
8112f05c:	e0fffd17 	ldw	r3,-12(fp)
8112f060:	008003f4 	movhi	r2,15
8112f064:	10909004 	addi	r2,r2,16960
8112f068:	1887383a 	mul	r3,r3,r2
8112f06c:	00817db4 	movhi	r2,1526
8112f070:	10b84004 	addi	r2,r2,-7936
8112f074:	10c7203a 	divu	r3,r2,r3
8112f078:	e0bfff17 	ldw	r2,-4(fp)
8112f07c:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
8112f080:	10bfffc4 	addi	r2,r2,-1
8112f084:	00bffe16 	blt	zero,r2,8112f080 <__reset+0xfb10f080>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
8112f088:	0005883a 	mov	r2,zero
}
8112f08c:	e037883a 	mov	sp,fp
8112f090:	df000017 	ldw	fp,0(sp)
8112f094:	dec00104 	addi	sp,sp,4
8112f098:	f800283a 	ret

8112f09c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112f09c:	defffe04 	addi	sp,sp,-8
8112f0a0:	de00012e 	bgeu	sp,et,8112f0a8 <alt_get_errno+0xc>
8112f0a4:	003b68fa 	trap	3
8112f0a8:	dfc00115 	stw	ra,4(sp)
8112f0ac:	df000015 	stw	fp,0(sp)
8112f0b0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8112f0b4:	d0a01017 	ldw	r2,-32704(gp)
8112f0b8:	10000326 	beq	r2,zero,8112f0c8 <alt_get_errno+0x2c>
8112f0bc:	d0a01017 	ldw	r2,-32704(gp)
8112f0c0:	103ee83a 	callr	r2
8112f0c4:	00000106 	br	8112f0cc <alt_get_errno+0x30>
8112f0c8:	d0a07d04 	addi	r2,gp,-32268
}
8112f0cc:	e037883a 	mov	sp,fp
8112f0d0:	dfc00117 	ldw	ra,4(sp)
8112f0d4:	df000017 	ldw	fp,0(sp)
8112f0d8:	dec00204 	addi	sp,sp,8
8112f0dc:	f800283a 	ret

8112f0e0 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
8112f0e0:	defffb04 	addi	sp,sp,-20
8112f0e4:	de00012e 	bgeu	sp,et,8112f0ec <close+0xc>
8112f0e8:	003b68fa 	trap	3
8112f0ec:	dfc00415 	stw	ra,16(sp)
8112f0f0:	df000315 	stw	fp,12(sp)
8112f0f4:	df000304 	addi	fp,sp,12
8112f0f8:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
8112f0fc:	e0bfff17 	ldw	r2,-4(fp)
8112f100:	10000616 	blt	r2,zero,8112f11c <close+0x3c>
8112f104:	e0bfff17 	ldw	r2,-4(fp)
8112f108:	10c00324 	muli	r3,r2,12
8112f10c:	00a04534 	movhi	r2,33044
8112f110:	1098f704 	addi	r2,r2,25564
8112f114:	1885883a 	add	r2,r3,r2
8112f118:	00000106 	br	8112f120 <close+0x40>
8112f11c:	0005883a 	mov	r2,zero
8112f120:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
8112f124:	e0bffd17 	ldw	r2,-12(fp)
8112f128:	10001926 	beq	r2,zero,8112f190 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
8112f12c:	e0bffd17 	ldw	r2,-12(fp)
8112f130:	10800017 	ldw	r2,0(r2)
8112f134:	10800417 	ldw	r2,16(r2)
8112f138:	10000626 	beq	r2,zero,8112f154 <close+0x74>
8112f13c:	e0bffd17 	ldw	r2,-12(fp)
8112f140:	10800017 	ldw	r2,0(r2)
8112f144:	10800417 	ldw	r2,16(r2)
8112f148:	e13ffd17 	ldw	r4,-12(fp)
8112f14c:	103ee83a 	callr	r2
8112f150:	00000106 	br	8112f158 <close+0x78>
8112f154:	0005883a 	mov	r2,zero
8112f158:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
8112f15c:	e13fff17 	ldw	r4,-4(fp)
8112f160:	11304580 	call	81130458 <alt_release_fd>
    if (rval < 0)
8112f164:	e0bffe17 	ldw	r2,-8(fp)
8112f168:	1000070e 	bge	r2,zero,8112f188 <close+0xa8>
    {
      ALT_ERRNO = -rval;
8112f16c:	112f09c0 	call	8112f09c <alt_get_errno>
8112f170:	1007883a 	mov	r3,r2
8112f174:	e0bffe17 	ldw	r2,-8(fp)
8112f178:	0085c83a 	sub	r2,zero,r2
8112f17c:	18800015 	stw	r2,0(r3)
      return -1;
8112f180:	00bfffc4 	movi	r2,-1
8112f184:	00000706 	br	8112f1a4 <close+0xc4>
    }
    return 0;
8112f188:	0005883a 	mov	r2,zero
8112f18c:	00000506 	br	8112f1a4 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
8112f190:	112f09c0 	call	8112f09c <alt_get_errno>
8112f194:	1007883a 	mov	r3,r2
8112f198:	00801444 	movi	r2,81
8112f19c:	18800015 	stw	r2,0(r3)
    return -1;
8112f1a0:	00bfffc4 	movi	r2,-1
  }
}
8112f1a4:	e037883a 	mov	sp,fp
8112f1a8:	dfc00117 	ldw	ra,4(sp)
8112f1ac:	df000017 	ldw	fp,0(sp)
8112f1b0:	dec00204 	addi	sp,sp,8
8112f1b4:	f800283a 	ret

8112f1b8 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
8112f1b8:	deffff04 	addi	sp,sp,-4
8112f1bc:	de00012e 	bgeu	sp,et,8112f1c4 <alt_dcache_flush_all+0xc>
8112f1c0:	003b68fa 	trap	3
8112f1c4:	df000015 	stw	fp,0(sp)
8112f1c8:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
8112f1cc:	0001883a 	nop
8112f1d0:	e037883a 	mov	sp,fp
8112f1d4:	df000017 	ldw	fp,0(sp)
8112f1d8:	dec00104 	addi	sp,sp,4
8112f1dc:	f800283a 	ret

8112f1e0 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
8112f1e0:	defffc04 	addi	sp,sp,-16
8112f1e4:	de00012e 	bgeu	sp,et,8112f1ec <alt_dev_null_write+0xc>
8112f1e8:	003b68fa 	trap	3
8112f1ec:	df000315 	stw	fp,12(sp)
8112f1f0:	df000304 	addi	fp,sp,12
8112f1f4:	e13ffd15 	stw	r4,-12(fp)
8112f1f8:	e17ffe15 	stw	r5,-8(fp)
8112f1fc:	e1bfff15 	stw	r6,-4(fp)
  return len;
8112f200:	e0bfff17 	ldw	r2,-4(fp)
}
8112f204:	e037883a 	mov	sp,fp
8112f208:	df000017 	ldw	fp,0(sp)
8112f20c:	dec00104 	addi	sp,sp,4
8112f210:	f800283a 	ret

8112f214 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112f214:	defffe04 	addi	sp,sp,-8
8112f218:	de00012e 	bgeu	sp,et,8112f220 <alt_get_errno+0xc>
8112f21c:	003b68fa 	trap	3
8112f220:	dfc00115 	stw	ra,4(sp)
8112f224:	df000015 	stw	fp,0(sp)
8112f228:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8112f22c:	d0a01017 	ldw	r2,-32704(gp)
8112f230:	10000326 	beq	r2,zero,8112f240 <alt_get_errno+0x2c>
8112f234:	d0a01017 	ldw	r2,-32704(gp)
8112f238:	103ee83a 	callr	r2
8112f23c:	00000106 	br	8112f244 <alt_get_errno+0x30>
8112f240:	d0a07d04 	addi	r2,gp,-32268
}
8112f244:	e037883a 	mov	sp,fp
8112f248:	dfc00117 	ldw	ra,4(sp)
8112f24c:	df000017 	ldw	fp,0(sp)
8112f250:	dec00204 	addi	sp,sp,8
8112f254:	f800283a 	ret

8112f258 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
8112f258:	defffb04 	addi	sp,sp,-20
8112f25c:	de00012e 	bgeu	sp,et,8112f264 <fstat+0xc>
8112f260:	003b68fa 	trap	3
8112f264:	dfc00415 	stw	ra,16(sp)
8112f268:	df000315 	stw	fp,12(sp)
8112f26c:	df000304 	addi	fp,sp,12
8112f270:	e13ffe15 	stw	r4,-8(fp)
8112f274:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8112f278:	e0bffe17 	ldw	r2,-8(fp)
8112f27c:	10000616 	blt	r2,zero,8112f298 <fstat+0x40>
8112f280:	e0bffe17 	ldw	r2,-8(fp)
8112f284:	10c00324 	muli	r3,r2,12
8112f288:	00a04534 	movhi	r2,33044
8112f28c:	1098f704 	addi	r2,r2,25564
8112f290:	1885883a 	add	r2,r3,r2
8112f294:	00000106 	br	8112f29c <fstat+0x44>
8112f298:	0005883a 	mov	r2,zero
8112f29c:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
8112f2a0:	e0bffd17 	ldw	r2,-12(fp)
8112f2a4:	10001026 	beq	r2,zero,8112f2e8 <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
8112f2a8:	e0bffd17 	ldw	r2,-12(fp)
8112f2ac:	10800017 	ldw	r2,0(r2)
8112f2b0:	10800817 	ldw	r2,32(r2)
8112f2b4:	10000726 	beq	r2,zero,8112f2d4 <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
8112f2b8:	e0bffd17 	ldw	r2,-12(fp)
8112f2bc:	10800017 	ldw	r2,0(r2)
8112f2c0:	10800817 	ldw	r2,32(r2)
8112f2c4:	e17fff17 	ldw	r5,-4(fp)
8112f2c8:	e13ffd17 	ldw	r4,-12(fp)
8112f2cc:	103ee83a 	callr	r2
8112f2d0:	00000a06 	br	8112f2fc <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
8112f2d4:	e0bfff17 	ldw	r2,-4(fp)
8112f2d8:	00c80004 	movi	r3,8192
8112f2dc:	10c00115 	stw	r3,4(r2)
      return 0;
8112f2e0:	0005883a 	mov	r2,zero
8112f2e4:	00000506 	br	8112f2fc <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
8112f2e8:	112f2140 	call	8112f214 <alt_get_errno>
8112f2ec:	1007883a 	mov	r3,r2
8112f2f0:	00801444 	movi	r2,81
8112f2f4:	18800015 	stw	r2,0(r3)
    return -1;
8112f2f8:	00bfffc4 	movi	r2,-1
  }
}
8112f2fc:	e037883a 	mov	sp,fp
8112f300:	dfc00117 	ldw	ra,4(sp)
8112f304:	df000017 	ldw	fp,0(sp)
8112f308:	dec00204 	addi	sp,sp,8
8112f30c:	f800283a 	ret

8112f310 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
8112f310:	defff004 	addi	sp,sp,-64
8112f314:	de00012e 	bgeu	sp,et,8112f31c <alt_irq_register+0xc>
8112f318:	003b68fa 	trap	3
8112f31c:	df000f15 	stw	fp,60(sp)
8112f320:	df000f04 	addi	fp,sp,60
8112f324:	e13ffd15 	stw	r4,-12(fp)
8112f328:	e17ffe15 	stw	r5,-8(fp)
8112f32c:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
8112f330:	00bffa84 	movi	r2,-22
8112f334:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
8112f338:	e0bffd17 	ldw	r2,-12(fp)
8112f33c:	10800828 	cmpgeui	r2,r2,32
8112f340:	1000501e 	bne	r2,zero,8112f484 <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f344:	0005303a 	rdctl	r2,status
8112f348:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f34c:	e0fff617 	ldw	r3,-40(fp)
8112f350:	00bfff84 	movi	r2,-2
8112f354:	1884703a 	and	r2,r3,r2
8112f358:	1001703a 	wrctl	status,r2
  
  return context;
8112f35c:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
8112f360:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
8112f364:	00a045b4 	movhi	r2,33046
8112f368:	10865d04 	addi	r2,r2,6516
8112f36c:	e0fffd17 	ldw	r3,-12(fp)
8112f370:	180690fa 	slli	r3,r3,3
8112f374:	10c5883a 	add	r2,r2,r3
8112f378:	e0ffff17 	ldw	r3,-4(fp)
8112f37c:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
8112f380:	00a045b4 	movhi	r2,33046
8112f384:	10865d04 	addi	r2,r2,6516
8112f388:	e0fffd17 	ldw	r3,-12(fp)
8112f38c:	180690fa 	slli	r3,r3,3
8112f390:	10c5883a 	add	r2,r2,r3
8112f394:	10800104 	addi	r2,r2,4
8112f398:	e0fffe17 	ldw	r3,-8(fp)
8112f39c:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
8112f3a0:	e0bfff17 	ldw	r2,-4(fp)
8112f3a4:	10001926 	beq	r2,zero,8112f40c <alt_irq_register+0xfc>
8112f3a8:	e0bffd17 	ldw	r2,-12(fp)
8112f3ac:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f3b0:	0005303a 	rdctl	r2,status
8112f3b4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f3b8:	e0fff717 	ldw	r3,-36(fp)
8112f3bc:	00bfff84 	movi	r2,-2
8112f3c0:	1884703a 	and	r2,r3,r2
8112f3c4:	1001703a 	wrctl	status,r2
  
  return context;
8112f3c8:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8112f3cc:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
8112f3d0:	00c00044 	movi	r3,1
8112f3d4:	e0bff217 	ldw	r2,-56(fp)
8112f3d8:	1884983a 	sll	r2,r3,r2
8112f3dc:	1007883a 	mov	r3,r2
8112f3e0:	d0a07f17 	ldw	r2,-32260(gp)
8112f3e4:	1884b03a 	or	r2,r3,r2
8112f3e8:	d0a07f15 	stw	r2,-32260(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8112f3ec:	d0a07f17 	ldw	r2,-32260(gp)
8112f3f0:	100170fa 	wrctl	ienable,r2
8112f3f4:	e0bff817 	ldw	r2,-32(fp)
8112f3f8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112f3fc:	e0bff917 	ldw	r2,-28(fp)
8112f400:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8112f404:	0005883a 	mov	r2,zero
8112f408:	00001906 	br	8112f470 <alt_irq_register+0x160>
8112f40c:	e0bffd17 	ldw	r2,-12(fp)
8112f410:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8112f414:	0005303a 	rdctl	r2,status
8112f418:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8112f41c:	e0fffa17 	ldw	r3,-24(fp)
8112f420:	00bfff84 	movi	r2,-2
8112f424:	1884703a 	and	r2,r3,r2
8112f428:	1001703a 	wrctl	status,r2
  
  return context;
8112f42c:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
8112f430:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
8112f434:	00c00044 	movi	r3,1
8112f438:	e0bff417 	ldw	r2,-48(fp)
8112f43c:	1884983a 	sll	r2,r3,r2
8112f440:	0084303a 	nor	r2,zero,r2
8112f444:	1007883a 	mov	r3,r2
8112f448:	d0a07f17 	ldw	r2,-32260(gp)
8112f44c:	1884703a 	and	r2,r3,r2
8112f450:	d0a07f15 	stw	r2,-32260(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
8112f454:	d0a07f17 	ldw	r2,-32260(gp)
8112f458:	100170fa 	wrctl	ienable,r2
8112f45c:	e0bffb17 	ldw	r2,-20(fp)
8112f460:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8112f464:	e0bffc17 	ldw	r2,-16(fp)
8112f468:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8112f46c:	0005883a 	mov	r2,zero
8112f470:	e0bff115 	stw	r2,-60(fp)
8112f474:	e0bff317 	ldw	r2,-52(fp)
8112f478:	e0bff515 	stw	r2,-44(fp)
8112f47c:	e0bff517 	ldw	r2,-44(fp)
8112f480:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
8112f484:	e0bff117 	ldw	r2,-60(fp)
}
8112f488:	e037883a 	mov	sp,fp
8112f48c:	df000017 	ldw	fp,0(sp)
8112f490:	dec00104 	addi	sp,sp,4
8112f494:	f800283a 	ret

8112f498 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8112f498:	defffe04 	addi	sp,sp,-8
8112f49c:	de00012e 	bgeu	sp,et,8112f4a4 <alt_get_errno+0xc>
8112f4a0:	003b68fa 	trap	3
8112f4a4:	dfc00115 	stw	ra,4(sp)
8112f4a8:	df000015 	stw	fp,0(sp)
8112f4ac:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8112f4b0:	d0a01017 	ldw	r2,-32704(gp)
8112f4b4:	10000326 	beq	r2,zero,8112f4c4 <alt_get_errno+0x2c>
8112f4b8:	d0a01017 	ldw	r2,-32704(gp)
8112f4bc:	103ee83a 	callr	r2
8112f4c0:	00000106 	br	8112f4c8 <alt_get_errno+0x30>
8112f4c4:	d0a07d04 	addi	r2,gp,-32268
}
8112f4c8:	e037883a 	mov	sp,fp
8112f4cc:	dfc00117 	ldw	ra,4(sp)
8112f4d0:	df000017 	ldw	fp,0(sp)
8112f4d4:	dec00204 	addi	sp,sp,8
8112f4d8:	f800283a 	ret

8112f4dc <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
8112f4dc:	deffed04 	addi	sp,sp,-76
8112f4e0:	de00012e 	bgeu	sp,et,8112f4e8 <isatty+0xc>
8112f4e4:	003b68fa 	trap	3
8112f4e8:	dfc01215 	stw	ra,72(sp)
8112f4ec:	df001115 	stw	fp,68(sp)
8112f4f0:	df001104 	addi	fp,sp,68
8112f4f4:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8112f4f8:	e0bfff17 	ldw	r2,-4(fp)
8112f4fc:	10000616 	blt	r2,zero,8112f518 <isatty+0x3c>
8112f500:	e0bfff17 	ldw	r2,-4(fp)
8112f504:	10c00324 	muli	r3,r2,12
8112f508:	00a04534 	movhi	r2,33044
8112f50c:	1098f704 	addi	r2,r2,25564
8112f510:	1885883a 	add	r2,r3,r2
8112f514:	00000106 	br	8112f51c <isatty+0x40>
8112f518:	0005883a 	mov	r2,zero
8112f51c:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
8112f520:	e0bfef17 	ldw	r2,-68(fp)
8112f524:	10000e26 	beq	r2,zero,8112f560 <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
8112f528:	e0bfef17 	ldw	r2,-68(fp)
8112f52c:	10800017 	ldw	r2,0(r2)
8112f530:	10800817 	ldw	r2,32(r2)
8112f534:	1000021e 	bne	r2,zero,8112f540 <isatty+0x64>
    {
      return 1;
8112f538:	00800044 	movi	r2,1
8112f53c:	00000d06 	br	8112f574 <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
8112f540:	e0bff004 	addi	r2,fp,-64
8112f544:	100b883a 	mov	r5,r2
8112f548:	e13fff17 	ldw	r4,-4(fp)
8112f54c:	112f2580 	call	8112f258 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
8112f550:	e0bff117 	ldw	r2,-60(fp)
8112f554:	10880020 	cmpeqi	r2,r2,8192
8112f558:	10803fcc 	andi	r2,r2,255
8112f55c:	00000506 	br	8112f574 <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
8112f560:	112f4980 	call	8112f498 <alt_get_errno>
8112f564:	1007883a 	mov	r3,r2
8112f568:	00801444 	movi	r2,81
8112f56c:	18800015 	stw	r2,0(r3)
    return 0;
8112f570:	0005883a 	mov	r2,zero
  }
}
8112f574:	e037883a 	mov	sp,fp
8112f578:	dfc00117 	ldw	ra,4(sp)
8112f57c:	df000017 	ldw	fp,0(sp)
8112f580:	dec00204 	addi	sp,sp,8
8112f584:	f800283a 	ret

8112f588 <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
8112f588:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
8112f58c:	318c2404 	addi	r6,r6,12432

8112f590 <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
8112f590:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
8112f594:	01c00826 	beq	zero,r7,8112f5b8 <end_tx>

8112f598 <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
8112f598:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
8112f59c:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
8112f5a0:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
8112f5a4:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
8112f5a8:	283ffb26 	beq	r5,zero,8112f598 <__reset+0xfb10f598>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
8112f5ac:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
8112f5b0:	21000044 	addi	r4,r4,1
	br tx_next_char
8112f5b4:	003ff606 	br	8112f590 <__reset+0xfb10f590>

8112f5b8 <end_tx>:
end_tx:	
        ret
8112f5b8:	f800283a 	ret

8112f5bc <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
8112f5bc:	defffd04 	addi	sp,sp,-12
8112f5c0:	de00012e 	bgeu	sp,et,8112f5c8 <alt_log_txchar+0xc>
8112f5c4:	003b68fa 	trap	3
8112f5c8:	df000215 	stw	fp,8(sp)
8112f5cc:	df000204 	addi	fp,sp,8
8112f5d0:	e13ffe15 	stw	r4,-8(fp)
8112f5d4:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
8112f5d8:	0001883a 	nop
8112f5dc:	e0bfff17 	ldw	r2,-4(fp)
8112f5e0:	10800104 	addi	r2,r2,4
8112f5e4:	10800037 	ldwio	r2,0(r2)
8112f5e8:	10bfffec 	andhi	r2,r2,65535
8112f5ec:	103ffb26 	beq	r2,zero,8112f5dc <__reset+0xfb10f5dc>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
8112f5f0:	e0bfff17 	ldw	r2,-4(fp)
8112f5f4:	e0fffe17 	ldw	r3,-8(fp)
8112f5f8:	10c00035 	stwio	r3,0(r2)
}
8112f5fc:	0001883a 	nop
8112f600:	e037883a 	mov	sp,fp
8112f604:	df000017 	ldw	fp,0(sp)
8112f608:	dec00104 	addi	sp,sp,4
8112f60c:	f800283a 	ret

8112f610 <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
8112f610:	defffb04 	addi	sp,sp,-20
8112f614:	de00012e 	bgeu	sp,et,8112f61c <alt_log_repchar+0xc>
8112f618:	003b68fa 	trap	3
8112f61c:	dfc00415 	stw	ra,16(sp)
8112f620:	df000315 	stw	fp,12(sp)
8112f624:	df000304 	addi	fp,sp,12
8112f628:	2005883a 	mov	r2,r4
8112f62c:	e17ffe15 	stw	r5,-8(fp)
8112f630:	e1bfff15 	stw	r6,-4(fp)
8112f634:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
8112f638:	00000506 	br	8112f650 <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
8112f63c:	e0bffd07 	ldb	r2,-12(fp)
8112f640:	e0ffff17 	ldw	r3,-4(fp)
8112f644:	180b883a 	mov	r5,r3
8112f648:	1009883a 	mov	r4,r2
8112f64c:	112f5bc0 	call	8112f5bc <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
8112f650:	e0bffe17 	ldw	r2,-8(fp)
8112f654:	10ffffc4 	addi	r3,r2,-1
8112f658:	e0fffe15 	stw	r3,-8(fp)
8112f65c:	00bff716 	blt	zero,r2,8112f63c <__reset+0xfb10f63c>
    alt_log_txchar(c,(char*) base);
}
8112f660:	0001883a 	nop
8112f664:	e037883a 	mov	sp,fp
8112f668:	dfc00117 	ldw	ra,4(sp)
8112f66c:	df000017 	ldw	fp,0(sp)
8112f670:	dec00204 	addi	sp,sp,8
8112f674:	f800283a 	ret

8112f678 <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
8112f678:	deffe904 	addi	sp,sp,-92
8112f67c:	de00012e 	bgeu	sp,et,8112f684 <alt_log_private_printf+0xc>
8112f680:	003b68fa 	trap	3
8112f684:	dfc01615 	stw	ra,88(sp)
8112f688:	df001515 	stw	fp,84(sp)
8112f68c:	dc001415 	stw	r16,80(sp)
8112f690:	df001504 	addi	fp,sp,84
8112f694:	e13ffc15 	stw	r4,-16(fp)
8112f698:	e17ffd15 	stw	r5,-12(fp)
8112f69c:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
8112f6a0:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
8112f6a4:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
8112f6a8:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
8112f6ac:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
8112f6b0:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
8112f6b4:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
8112f6b8:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
8112f6bc:	e0bffc17 	ldw	r2,-16(fp)
8112f6c0:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
8112f6c4:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
8112f6c8:	00014b06 	br	8112fbf8 <alt_log_private_printf+0x580>
    {
    switch(state)
8112f6cc:	e0bfec17 	ldw	r2,-80(fp)
8112f6d0:	10c00060 	cmpeqi	r3,r2,1
8112f6d4:	18001b1e 	bne	r3,zero,8112f744 <alt_log_private_printf+0xcc>
8112f6d8:	10c000a0 	cmpeqi	r3,r2,2
8112f6dc:	18002d1e 	bne	r3,zero,8112f794 <alt_log_private_printf+0x11c>
8112f6e0:	10000126 	beq	r2,zero,8112f6e8 <alt_log_private_printf+0x70>
8112f6e4:	00014406 	br	8112fbf8 <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
8112f6e8:	e0bffb07 	ldb	r2,-20(fp)
8112f6ec:	10800958 	cmpnei	r2,r2,37
8112f6f0:	10000e1e 	bne	r2,zero,8112f72c <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
8112f6f4:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
8112f6f8:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
8112f6fc:	00800284 	movi	r2,10
8112f700:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
8112f704:	00800044 	movi	r2,1
8112f708:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
8112f70c:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
8112f710:	00bfffc4 	movi	r2,-1
8112f714:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
8112f718:	00bfffc4 	movi	r2,-1
8112f71c:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
8112f720:	00800044 	movi	r2,1
8112f724:	e0bfec15 	stw	r2,-80(fp)
8112f728:	00013306 	br	8112fbf8 <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
8112f72c:	e0bffb07 	ldb	r2,-20(fp)
8112f730:	e0fffd17 	ldw	r3,-12(fp)
8112f734:	180b883a 	mov	r5,r3
8112f738:	1009883a 	mov	r4,r2
8112f73c:	112f5bc0 	call	8112f5bc <alt_log_txchar>
        }
        break;
8112f740:	00012d06 	br	8112fbf8 <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
8112f744:	e0bffb07 	ldb	r2,-20(fp)
8112f748:	10800c18 	cmpnei	r2,r2,48
8112f74c:	1000051e 	bne	r2,zero,8112f764 <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
8112f750:	00800044 	movi	r2,1
8112f754:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
8112f758:	00800084 	movi	r2,2
8112f75c:	e0bfec15 	stw	r2,-80(fp)
8112f760:	00012506 	br	8112fbf8 <alt_log_private_printf+0x580>
        }
        else if(c == '%')
8112f764:	e0bffb07 	ldb	r2,-20(fp)
8112f768:	10800958 	cmpnei	r2,r2,37
8112f76c:	1000071e 	bne	r2,zero,8112f78c <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
8112f770:	e0bffb07 	ldb	r2,-20(fp)
8112f774:	e0fffd17 	ldw	r3,-12(fp)
8112f778:	180b883a 	mov	r5,r3
8112f77c:	1009883a 	mov	r4,r2
8112f780:	112f5bc0 	call	8112f5bc <alt_log_txchar>
          state = pfState_chars;
8112f784:	e03fec15 	stw	zero,-80(fp)
8112f788:	00011b06 	br	8112fbf8 <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
8112f78c:	00800084 	movi	r2,2
8112f790:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
8112f794:	e0bffb07 	ldb	r2,-20(fp)
8112f798:	10800b98 	cmpnei	r2,r2,46
8112f79c:	1000021e 	bne	r2,zero,8112f7a8 <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
8112f7a0:	e03ff015 	stw	zero,-64(fp)
8112f7a4:	00011306 	br	8112fbf4 <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
8112f7a8:	e0bffb07 	ldb	r2,-20(fp)
8112f7ac:	10800c10 	cmplti	r2,r2,48
8112f7b0:	10001a1e 	bne	r2,zero,8112f81c <alt_log_private_printf+0x1a4>
8112f7b4:	e0bffb07 	ldb	r2,-20(fp)
8112f7b8:	10800e88 	cmpgei	r2,r2,58
8112f7bc:	1000171e 	bne	r2,zero,8112f81c <alt_log_private_printf+0x1a4>
        {
          c -= '0';
8112f7c0:	e0bffb03 	ldbu	r2,-20(fp)
8112f7c4:	10bff404 	addi	r2,r2,-48
8112f7c8:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
8112f7cc:	e0bff017 	ldw	r2,-64(fp)
8112f7d0:	10000c0e 	bge	r2,zero,8112f804 <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
8112f7d4:	e0bfef17 	ldw	r2,-68(fp)
8112f7d8:	1000020e 	bge	r2,zero,8112f7e4 <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
8112f7dc:	e03fef15 	stw	zero,-68(fp)
8112f7e0:	00000306 	br	8112f7f0 <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
8112f7e4:	e0bfef17 	ldw	r2,-68(fp)
8112f7e8:	108002a4 	muli	r2,r2,10
8112f7ec:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
8112f7f0:	e0bffb07 	ldb	r2,-20(fp)
8112f7f4:	e0ffef17 	ldw	r3,-68(fp)
8112f7f8:	1885883a 	add	r2,r3,r2
8112f7fc:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
8112f800:	0000fc06 	br	8112fbf4 <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
8112f804:	e0bff017 	ldw	r2,-64(fp)
8112f808:	10c002a4 	muli	r3,r2,10
8112f80c:	e0bffb07 	ldb	r2,-20(fp)
8112f810:	1885883a 	add	r2,r3,r2
8112f814:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
8112f818:	0000f606 	br	8112fbf4 <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
8112f81c:	e0bffb07 	ldb	r2,-20(fp)
8112f820:	10801b18 	cmpnei	r2,r2,108
8112f824:	1000031e 	bne	r2,zero,8112f834 <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
8112f828:	00800044 	movi	r2,1
8112f82c:	e0bfee15 	stw	r2,-72(fp)
8112f830:	0000f006 	br	8112fbf4 <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
8112f834:	e0bffb07 	ldb	r2,-20(fp)
8112f838:	10bfea04 	addi	r2,r2,-88
8112f83c:	10c00868 	cmpgeui	r3,r2,33
8112f840:	1800eb1e 	bne	r3,zero,8112fbf0 <alt_log_private_printf+0x578>
8112f844:	100690ba 	slli	r3,r2,2
8112f848:	00a044f4 	movhi	r2,33043
8112f84c:	10be1704 	addi	r2,r2,-1956
8112f850:	1885883a 	add	r2,r3,r2
8112f854:	10800017 	ldw	r2,0(r2)
8112f858:	1000683a 	jmp	r2
8112f85c:	8112fb1c 	xori	r4,r16,19436
8112f860:	8112fbf0 	cmpltui	r4,r16,19439
8112f864:	8112fbf0 	cmpltui	r4,r16,19439
8112f868:	8112fbf0 	cmpltui	r4,r16,19439
8112f86c:	8112fbf0 	cmpltui	r4,r16,19439
8112f870:	8112fbf0 	cmpltui	r4,r16,19439
8112f874:	8112fbf0 	cmpltui	r4,r16,19439
8112f878:	8112fbf0 	cmpltui	r4,r16,19439
8112f87c:	8112fbf0 	cmpltui	r4,r16,19439
8112f880:	8112fbf0 	cmpltui	r4,r16,19439
8112f884:	8112fbf0 	cmpltui	r4,r16,19439
8112f888:	8112fb34 	orhi	r4,r16,19436
8112f88c:	8112f8e0 	cmpeqi	r4,r16,19427
8112f890:	8112fbf0 	cmpltui	r4,r16,19439
8112f894:	8112fbf0 	cmpltui	r4,r16,19439
8112f898:	8112fbf0 	cmpltui	r4,r16,19439
8112f89c:	8112fbf0 	cmpltui	r4,r16,19439
8112f8a0:	8112f8e0 	cmpeqi	r4,r16,19427
8112f8a4:	8112fbf0 	cmpltui	r4,r16,19439
8112f8a8:	8112fbf0 	cmpltui	r4,r16,19439
8112f8ac:	8112fbf0 	cmpltui	r4,r16,19439
8112f8b0:	8112fbf0 	cmpltui	r4,r16,19439
8112f8b4:	8112fbf0 	cmpltui	r4,r16,19439
8112f8b8:	8112fafc 	xorhi	r4,r16,19435
8112f8bc:	8112fbf0 	cmpltui	r4,r16,19439
8112f8c0:	8112fbf0 	cmpltui	r4,r16,19439
8112f8c4:	8112fbf0 	cmpltui	r4,r16,19439
8112f8c8:	8112fb70 	cmpltui	r4,r16,19437
8112f8cc:	8112fbf0 	cmpltui	r4,r16,19439
8112f8d0:	8112faf4 	orhi	r4,r16,19435
8112f8d4:	8112fbf0 	cmpltui	r4,r16,19439
8112f8d8:	8112fbf0 	cmpltui	r4,r16,19439
8112f8dc:	8112fb0c 	andi	r4,r16,19436
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
8112f8e0:	e0bfee17 	ldw	r2,-72(fp)
8112f8e4:	10000e26 	beq	r2,zero,8112f920 <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
8112f8e8:	e0bff217 	ldw	r2,-56(fp)
8112f8ec:	10000626 	beq	r2,zero,8112f908 <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
8112f8f0:	e0bffe17 	ldw	r2,-8(fp)
8112f8f4:	10c00104 	addi	r3,r2,4
8112f8f8:	e0fffe15 	stw	r3,-8(fp)
8112f8fc:	10800017 	ldw	r2,0(r2)
8112f900:	e0bff415 	stw	r2,-48(fp)
8112f904:	00001306 	br	8112f954 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
8112f908:	e0bffe17 	ldw	r2,-8(fp)
8112f90c:	10c00104 	addi	r3,r2,4
8112f910:	e0fffe15 	stw	r3,-8(fp)
8112f914:	10800017 	ldw	r2,0(r2)
8112f918:	e0bff415 	stw	r2,-48(fp)
8112f91c:	00000d06 	br	8112f954 <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
8112f920:	e0bff217 	ldw	r2,-56(fp)
8112f924:	10000626 	beq	r2,zero,8112f940 <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
8112f928:	e0bffe17 	ldw	r2,-8(fp)
8112f92c:	10c00104 	addi	r3,r2,4
8112f930:	e0fffe15 	stw	r3,-8(fp)
8112f934:	10800017 	ldw	r2,0(r2)
8112f938:	e0bff415 	stw	r2,-48(fp)
8112f93c:	00000506 	br	8112f954 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
8112f940:	e0bffe17 	ldw	r2,-8(fp)
8112f944:	10c00104 	addi	r3,r2,4
8112f948:	e0fffe15 	stw	r3,-8(fp)
8112f94c:	10800017 	ldw	r2,0(r2)
8112f950:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
8112f954:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
8112f958:	e0bff217 	ldw	r2,-56(fp)
8112f95c:	10000726 	beq	r2,zero,8112f97c <alt_log_private_printf+0x304>
8112f960:	e0bff417 	ldw	r2,-48(fp)
8112f964:	1000050e 	bge	r2,zero,8112f97c <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
8112f968:	e0bff417 	ldw	r2,-48(fp)
8112f96c:	0085c83a 	sub	r2,zero,r2
8112f970:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
8112f974:	00800044 	movi	r2,1
8112f978:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
8112f97c:	e0bff417 	ldw	r2,-48(fp)
8112f980:	e0bff615 	stw	r2,-40(fp)
                p = 1;
8112f984:	00800044 	movi	r2,1
8112f988:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
8112f98c:	00800044 	movi	r2,1
8112f990:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
8112f994:	00000706 	br	8112f9b4 <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
8112f998:	e0bff817 	ldw	r2,-32(fp)
8112f99c:	10800044 	addi	r2,r2,1
8112f9a0:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
8112f9a4:	e0bff117 	ldw	r2,-60(fp)
8112f9a8:	e0fff517 	ldw	r3,-44(fp)
8112f9ac:	1885383a 	mul	r2,r3,r2
8112f9b0:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
8112f9b4:	e0bff117 	ldw	r2,-60(fp)
8112f9b8:	e0fff617 	ldw	r3,-40(fp)
8112f9bc:	1885203a 	divu	r2,r3,r2
8112f9c0:	e0bff615 	stw	r2,-40(fp)
8112f9c4:	e0bff617 	ldw	r2,-40(fp)
8112f9c8:	103ff31e 	bne	r2,zero,8112f998 <__reset+0xfb10f998>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
8112f9cc:	e0ffef17 	ldw	r3,-68(fp)
8112f9d0:	e0bff817 	ldw	r2,-32(fp)
8112f9d4:	1885c83a 	sub	r2,r3,r2
8112f9d8:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
8112f9dc:	e0bfed17 	ldw	r2,-76(fp)
8112f9e0:	10000e26 	beq	r2,zero,8112fa1c <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
8112f9e4:	e0bff717 	ldw	r2,-36(fp)
8112f9e8:	10000726 	beq	r2,zero,8112fa08 <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
8112f9ec:	e0bffd17 	ldw	r2,-12(fp)
8112f9f0:	100b883a 	mov	r5,r2
8112f9f4:	01000b44 	movi	r4,45
8112f9f8:	112f5bc0 	call	8112f5bc <alt_log_txchar>
                    fmtBeforeDecimal--;
8112f9fc:	e0bfef17 	ldw	r2,-68(fp)
8112fa00:	10bfffc4 	addi	r2,r2,-1
8112fa04:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
8112fa08:	e1bffd17 	ldw	r6,-12(fp)
8112fa0c:	e17fef17 	ldw	r5,-68(fp)
8112fa10:	01000c04 	movi	r4,48
8112fa14:	112f6100 	call	8112f610 <alt_log_repchar>
8112fa18:	00003206 	br	8112fae4 <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
8112fa1c:	e0bff717 	ldw	r2,-36(fp)
8112fa20:	10000326 	beq	r2,zero,8112fa30 <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
8112fa24:	e0bfef17 	ldw	r2,-68(fp)
8112fa28:	10bfffc4 	addi	r2,r2,-1
8112fa2c:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
8112fa30:	e1bffd17 	ldw	r6,-12(fp)
8112fa34:	e17fef17 	ldw	r5,-68(fp)
8112fa38:	01000804 	movi	r4,32
8112fa3c:	112f6100 	call	8112f610 <alt_log_repchar>
                    if(sign)
8112fa40:	e0bff717 	ldw	r2,-36(fp)
8112fa44:	10002726 	beq	r2,zero,8112fae4 <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
8112fa48:	e0bffd17 	ldw	r2,-12(fp)
8112fa4c:	100b883a 	mov	r5,r2
8112fa50:	01000b44 	movi	r4,45
8112fa54:	112f5bc0 	call	8112f5bc <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
8112fa58:	00002206 	br	8112fae4 <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
8112fa5c:	e0fff417 	ldw	r3,-48(fp)
8112fa60:	e0bff517 	ldw	r2,-44(fp)
8112fa64:	1885203a 	divu	r2,r3,r2
8112fa68:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
8112fa6c:	e0bff903 	ldbu	r2,-28(fp)
8112fa70:	10800c04 	addi	r2,r2,48
8112fa74:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
8112fa78:	e0bff903 	ldbu	r2,-28(fp)
8112fa7c:	10800eb0 	cmpltui	r2,r2,58
8112fa80:	1000081e 	bne	r2,zero,8112faa4 <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
8112fa84:	e0bff317 	ldw	r2,-52(fp)
8112fa88:	10000226 	beq	r2,zero,8112fa94 <alt_log_private_printf+0x41c>
8112fa8c:	008001c4 	movi	r2,7
8112fa90:	00000106 	br	8112fa98 <alt_log_private_printf+0x420>
8112fa94:	008009c4 	movi	r2,39
8112fa98:	e0fff903 	ldbu	r3,-28(fp)
8112fa9c:	10c5883a 	add	r2,r2,r3
8112faa0:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
8112faa4:	e0bff903 	ldbu	r2,-28(fp)
8112faa8:	e0fffd17 	ldw	r3,-12(fp)
8112faac:	180b883a 	mov	r5,r3
8112fab0:	1009883a 	mov	r4,r2
8112fab4:	112f5bc0 	call	8112f5bc <alt_log_txchar>

                  v = v % p;
8112fab8:	e0bff417 	ldw	r2,-48(fp)
8112fabc:	e0fff517 	ldw	r3,-44(fp)
8112fac0:	10c9203a 	divu	r4,r2,r3
8112fac4:	e0fff517 	ldw	r3,-44(fp)
8112fac8:	20c7383a 	mul	r3,r4,r3
8112facc:	10c5c83a 	sub	r2,r2,r3
8112fad0:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
8112fad4:	e0bff117 	ldw	r2,-60(fp)
8112fad8:	e0fff517 	ldw	r3,-44(fp)
8112fadc:	1885203a 	divu	r2,r3,r2
8112fae0:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
8112fae4:	e0bff517 	ldw	r2,-44(fp)
8112fae8:	103fdc1e 	bne	r2,zero,8112fa5c <__reset+0xfb10fa5c>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
8112faec:	e03fec15 	stw	zero,-80(fp)
              break;
8112faf0:	00003f06 	br	8112fbf0 <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
8112faf4:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
8112faf8:	003f7906 	br	8112f8e0 <__reset+0xfb10f8e0>
            case 'o':
              fmtSigned = 0;
8112fafc:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
8112fb00:	00800204 	movi	r2,8
8112fb04:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
8112fb08:	003f7506 	br	8112f8e0 <__reset+0xfb10f8e0>
            case 'x':
              fmtSigned = 0;
8112fb0c:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
8112fb10:	00800404 	movi	r2,16
8112fb14:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
8112fb18:	003f7106 	br	8112f8e0 <__reset+0xfb10f8e0>
            case 'X':
              fmtSigned = 0;
8112fb1c:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
8112fb20:	00800404 	movi	r2,16
8112fb24:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
8112fb28:	00800044 	movi	r2,1
8112fb2c:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
8112fb30:	003f6b06 	br	8112f8e0 <__reset+0xfb10f8e0>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
8112fb34:	e0bfef17 	ldw	r2,-68(fp)
8112fb38:	10bfffc4 	addi	r2,r2,-1
8112fb3c:	e1bffd17 	ldw	r6,-12(fp)
8112fb40:	100b883a 	mov	r5,r2
8112fb44:	01000804 	movi	r4,32
8112fb48:	112f6100 	call	8112f610 <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
8112fb4c:	e0bffe17 	ldw	r2,-8(fp)
8112fb50:	10c00104 	addi	r3,r2,4
8112fb54:	e0fffe15 	stw	r3,-8(fp)
8112fb58:	10800017 	ldw	r2,0(r2)
8112fb5c:	e0fffd17 	ldw	r3,-12(fp)
8112fb60:	180b883a 	mov	r5,r3
8112fb64:	1009883a 	mov	r4,r2
8112fb68:	112f5bc0 	call	8112f5bc <alt_log_txchar>
              break;
8112fb6c:	00002006 	br	8112fbf0 <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
8112fb70:	e0bffe17 	ldw	r2,-8(fp)
8112fb74:	10c00104 	addi	r3,r2,4
8112fb78:	e0fffe15 	stw	r3,-8(fp)
8112fb7c:	10800017 	ldw	r2,0(r2)
8112fb80:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
8112fb84:	e43fef17 	ldw	r16,-68(fp)
8112fb88:	e13ffa17 	ldw	r4,-24(fp)
8112fb8c:	111b1180 	call	8111b118 <strlen>
8112fb90:	8085c83a 	sub	r2,r16,r2
8112fb94:	e1bffd17 	ldw	r6,-12(fp)
8112fb98:	100b883a 	mov	r5,r2
8112fb9c:	01000804 	movi	r4,32
8112fba0:	112f6100 	call	8112f610 <alt_log_repchar>

                while(*s)
8112fba4:	00000b06 	br	8112fbd4 <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
8112fba8:	e0bffa17 	ldw	r2,-24(fp)
8112fbac:	10c00044 	addi	r3,r2,1
8112fbb0:	e0fffa15 	stw	r3,-24(fp)
8112fbb4:	10800003 	ldbu	r2,0(r2)
8112fbb8:	10803fcc 	andi	r2,r2,255
8112fbbc:	1080201c 	xori	r2,r2,128
8112fbc0:	10bfe004 	addi	r2,r2,-128
8112fbc4:	e0fffd17 	ldw	r3,-12(fp)
8112fbc8:	180b883a 	mov	r5,r3
8112fbcc:	1009883a 	mov	r4,r2
8112fbd0:	112f5bc0 	call	8112f5bc <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
8112fbd4:	e0bffa17 	ldw	r2,-24(fp)
8112fbd8:	10800003 	ldbu	r2,0(r2)
8112fbdc:	10803fcc 	andi	r2,r2,255
8112fbe0:	1080201c 	xori	r2,r2,128
8112fbe4:	10bfe004 	addi	r2,r2,-128
8112fbe8:	103fef1e 	bne	r2,zero,8112fba8 <__reset+0xfb10fba8>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
8112fbec:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
8112fbf0:	e03fec15 	stw	zero,-80(fp)
          }
        break;
8112fbf4:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
8112fbf8:	e0bfeb17 	ldw	r2,-84(fp)
8112fbfc:	10c00044 	addi	r3,r2,1
8112fc00:	e0ffeb15 	stw	r3,-84(fp)
8112fc04:	10800003 	ldbu	r2,0(r2)
8112fc08:	e0bffb05 	stb	r2,-20(fp)
8112fc0c:	e0bffb07 	ldb	r2,-20(fp)
8112fc10:	103eae1e 	bne	r2,zero,8112f6cc <__reset+0xfb10f6cc>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
8112fc14:	0001883a 	nop
8112fc18:	e6ffff04 	addi	sp,fp,-4
8112fc1c:	dfc00217 	ldw	ra,8(sp)
8112fc20:	df000117 	ldw	fp,4(sp)
8112fc24:	dc000017 	ldw	r16,0(sp)
8112fc28:	dec00304 	addi	sp,sp,12
8112fc2c:	f800283a 	ret

8112fc30 <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
8112fc30:	defff904 	addi	sp,sp,-28
8112fc34:	de00012e 	bgeu	sp,et,8112fc3c <alt_log_printf_proc+0xc>
8112fc38:	003b68fa 	trap	3
8112fc3c:	dfc00315 	stw	ra,12(sp)
8112fc40:	df000215 	stw	fp,8(sp)
8112fc44:	df000204 	addi	fp,sp,8
8112fc48:	e13fff15 	stw	r4,-4(fp)
8112fc4c:	e1400215 	stw	r5,8(fp)
8112fc50:	e1800315 	stw	r6,12(fp)
8112fc54:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
8112fc58:	e0800204 	addi	r2,fp,8
8112fc5c:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
8112fc60:	e0bffe17 	ldw	r2,-8(fp)
8112fc64:	100d883a 	mov	r6,r2
8112fc68:	01604834 	movhi	r5,33056
8112fc6c:	294c2404 	addi	r5,r5,12432
8112fc70:	e13fff17 	ldw	r4,-4(fp)
8112fc74:	112f6780 	call	8112f678 <alt_log_private_printf>
    return (0);
8112fc78:	0005883a 	mov	r2,zero
}
8112fc7c:	e037883a 	mov	sp,fp
8112fc80:	dfc00117 	ldw	ra,4(sp)
8112fc84:	df000017 	ldw	fp,0(sp)
8112fc88:	dec00504 	addi	sp,sp,20
8112fc8c:	f800283a 	ret

8112fc90 <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
8112fc90:	defff904 	addi	sp,sp,-28
8112fc94:	de00012e 	bgeu	sp,et,8112fc9c <altera_avalon_jtag_uart_report_log+0xc>
8112fc98:	003b68fa 	trap	3
8112fc9c:	dfc00615 	stw	ra,24(sp)
8112fca0:	df000515 	stw	fp,20(sp)
8112fca4:	dc400415 	stw	r17,16(sp)
8112fca8:	dc000315 	stw	r16,12(sp)
8112fcac:	df000504 	addi	fp,sp,20
8112fcb0:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
8112fcb4:	d0a08083 	ldbu	r2,-32254(gp)
8112fcb8:	10803fcc 	andi	r2,r2,255
8112fcbc:	10001426 	beq	r2,zero,8112fd10 <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
8112fcc0:	e0bffd17 	ldw	r2,-12(fp)
8112fcc4:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
8112fcc8:	00a04534 	movhi	r2,33044
8112fccc:	10951d04 	addi	r2,r2,21620
8112fcd0:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
8112fcd4:	e0bffb17 	ldw	r2,-20(fp)
8112fcd8:	10800017 	ldw	r2,0(r2)
8112fcdc:	e1bffc17 	ldw	r6,-16(fp)
8112fce0:	100b883a 	mov	r5,r2
8112fce4:	e13ffb17 	ldw	r4,-20(fp)
8112fce8:	112fd300 	call	8112fd30 <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
8112fcec:	d0e08717 	ldw	r3,-32228(gp)
        return ALT_LOG_JTAG_UART_TICKS;
8112fcf0:	00b33374 	movhi	r2,52429
8112fcf4:	10b33344 	addi	r2,r2,-13107
8112fcf8:	1888383a 	mulxuu	r4,r3,r2
8112fcfc:	1885383a 	mul	r2,r3,r2
8112fd00:	1021883a 	mov	r16,r2
8112fd04:	2023883a 	mov	r17,r4
8112fd08:	8804d0fa 	srli	r2,r17,3
8112fd0c:	00000106 	br	8112fd14 <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
8112fd10:	0005883a 	mov	r2,zero
    }
}
8112fd14:	e6fffe04 	addi	sp,fp,-8
8112fd18:	dfc00317 	ldw	ra,12(sp)
8112fd1c:	df000217 	ldw	fp,8(sp)
8112fd20:	dc400117 	ldw	r17,4(sp)
8112fd24:	dc000017 	ldw	r16,0(sp)
8112fd28:	dec00404 	addi	sp,sp,16
8112fd2c:	f800283a 	ret

8112fd30 <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
8112fd30:	deffef04 	addi	sp,sp,-68
8112fd34:	de00012e 	bgeu	sp,et,8112fd3c <alt_log_jtag_uart_print_control_reg+0xc>
8112fd38:	003b68fa 	trap	3
8112fd3c:	dfc01015 	stw	ra,64(sp)
8112fd40:	df000f15 	stw	fp,60(sp)
8112fd44:	df000f04 	addi	fp,sp,60
8112fd48:	e13ffd15 	stw	r4,-12(fp)
8112fd4c:	e17ffe15 	stw	r5,-8(fp)
8112fd50:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
8112fd54:	e0bffe17 	ldw	r2,-8(fp)
8112fd58:	10800104 	addi	r2,r2,4
8112fd5c:	10800037 	ldwio	r2,0(r2)
8112fd60:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
8112fd64:	e0bff617 	ldw	r2,-40(fp)
8112fd68:	1004d43a 	srli	r2,r2,16
8112fd6c:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
8112fd70:	e0bff617 	ldw	r2,-40(fp)
8112fd74:	1080008c 	andi	r2,r2,2
8112fd78:	1004d07a 	srli	r2,r2,1
8112fd7c:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
8112fd80:	e0bff617 	ldw	r2,-40(fp)
8112fd84:	1080004c 	andi	r2,r2,1
8112fd88:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
8112fd8c:	e0bff617 	ldw	r2,-40(fp)
8112fd90:	1080400c 	andi	r2,r2,256
8112fd94:	1004d23a 	srli	r2,r2,8
8112fd98:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
8112fd9c:	e0bff617 	ldw	r2,-40(fp)
8112fda0:	1080800c 	andi	r2,r2,512
8112fda4:	1004d27a 	srli	r2,r2,9
8112fda8:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
8112fdac:	e0bff617 	ldw	r2,-40(fp)
8112fdb0:	1081000c 	andi	r2,r2,1024
8112fdb4:	1004d2ba 	srli	r2,r2,10
8112fdb8:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
8112fdbc:	e0bffd17 	ldw	r2,-12(fp)
8112fdc0:	10c01017 	ldw	r3,64(r2)
8112fdc4:	e0bffd17 	ldw	r2,-12(fp)
8112fdc8:	10800f17 	ldw	r2,60(r2)
8112fdcc:	1887c83a 	sub	r3,r3,r2
8112fdd0:	e0bff917 	ldw	r2,-28(fp)
8112fdd4:	d8800415 	stw	r2,16(sp)
8112fdd8:	e0bff817 	ldw	r2,-32(fp)
8112fddc:	d8800315 	stw	r2,12(sp)
8112fde0:	e0bffa17 	ldw	r2,-24(fp)
8112fde4:	d8800215 	stw	r2,8(sp)
8112fde8:	e0bffb17 	ldw	r2,-20(fp)
8112fdec:	d8800115 	stw	r2,4(sp)
8112fdf0:	e0bffc17 	ldw	r2,-16(fp)
8112fdf4:	d8800015 	stw	r2,0(sp)
8112fdf8:	e1fff717 	ldw	r7,-36(fp)
8112fdfc:	180d883a 	mov	r6,r3
8112fe00:	e17fff17 	ldw	r5,-4(fp)
8112fe04:	01204534 	movhi	r4,33044
8112fe08:	21152004 	addi	r4,r4,21632
8112fe0c:	112fc300 	call	8112fc30 <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
8112fe10:	0001883a 	nop

}
8112fe14:	e037883a 	mov	sp,fp
8112fe18:	dfc00117 	ldw	ra,4(sp)
8112fe1c:	df000017 	ldw	fp,0(sp)
8112fe20:	dec00204 	addi	sp,sp,8
8112fe24:	f800283a 	ret

8112fe28 <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
8112fe28:	defffb04 	addi	sp,sp,-20
8112fe2c:	de00012e 	bgeu	sp,et,8112fe34 <alt_log_jtag_uart_startup_info+0xc>
8112fe30:	003b68fa 	trap	3
8112fe34:	dfc00415 	stw	ra,16(sp)
8112fe38:	df000315 	stw	fp,12(sp)
8112fe3c:	df000304 	addi	fp,sp,12
8112fe40:	e13ffe15 	stw	r4,-8(fp)
8112fe44:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
8112fe48:	00a04534 	movhi	r2,33044
8112fe4c:	10953204 	addi	r2,r2,21704
8112fe50:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
8112fe54:	e1bffd17 	ldw	r6,-12(fp)
8112fe58:	e17fff17 	ldw	r5,-4(fp)
8112fe5c:	e13ffe17 	ldw	r4,-8(fp)
8112fe60:	112fd300 	call	8112fd30 <alt_log_jtag_uart_print_control_reg>
     return;
8112fe64:	0001883a 	nop
}
8112fe68:	e037883a 	mov	sp,fp
8112fe6c:	dfc00117 	ldw	ra,4(sp)
8112fe70:	df000017 	ldw	fp,0(sp)
8112fe74:	dec00204 	addi	sp,sp,8
8112fe78:	f800283a 	ret

8112fe7c <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
8112fe7c:	defffb04 	addi	sp,sp,-20
8112fe80:	de00012e 	bgeu	sp,et,8112fe88 <alt_log_jtag_uart_isr_proc+0xc>
8112fe84:	003b68fa 	trap	3
8112fe88:	dfc00415 	stw	ra,16(sp)
8112fe8c:	df000315 	stw	fp,12(sp)
8112fe90:	df000304 	addi	fp,sp,12
8112fe94:	e13ffe15 	stw	r4,-8(fp)
8112fe98:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
8112fe9c:	d0a080c3 	ldbu	r2,-32253(gp)
8112fea0:	10803fcc 	andi	r2,r2,255
8112fea4:	10000826 	beq	r2,zero,8112fec8 <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
8112fea8:	00a04534 	movhi	r2,33044
8112feac:	10953704 	addi	r2,r2,21724
8112feb0:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
8112feb4:	e1bffd17 	ldw	r6,-12(fp)
8112feb8:	e17ffe17 	ldw	r5,-8(fp)
8112febc:	e13fff17 	ldw	r4,-4(fp)
8112fec0:	112fd300 	call	8112fd30 <alt_log_jtag_uart_print_control_reg>
    }
    return;
8112fec4:	0001883a 	nop
8112fec8:	0001883a 	nop
}
8112fecc:	e037883a 	mov	sp,fp
8112fed0:	dfc00117 	ldw	ra,4(sp)
8112fed4:	df000017 	ldw	fp,0(sp)
8112fed8:	dec00204 	addi	sp,sp,8
8112fedc:	f800283a 	ret

8112fee0 <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
8112fee0:	defffa04 	addi	sp,sp,-24
8112fee4:	de00012e 	bgeu	sp,et,8112feec <alt_log_write+0xc>
8112fee8:	003b68fa 	trap	3
8112feec:	dfc00515 	stw	ra,20(sp)
8112fef0:	df000415 	stw	fp,16(sp)
8112fef4:	df000404 	addi	fp,sp,16
8112fef8:	e13ffe15 	stw	r4,-8(fp)
8112fefc:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
8112ff00:	d0a08003 	ldbu	r2,-32256(gp)
8112ff04:	10803fcc 	andi	r2,r2,255
8112ff08:	10004026 	beq	r2,zero,8113000c <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
8112ff0c:	e0bfff17 	ldw	r2,-4(fp)
8112ff10:	10c00430 	cmpltui	r3,r2,16
8112ff14:	1800011e 	bne	r3,zero,8112ff1c <alt_log_write+0x3c>
8112ff18:	008003c4 	movi	r2,15
8112ff1c:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
8112ff20:	e0bffd17 	ldw	r2,-12(fp)
8112ff24:	10800088 	cmpgei	r2,r2,2
8112ff28:	10003726 	beq	r2,zero,81130008 <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
8112ff2c:	e0bffd17 	ldw	r2,-12(fp)
8112ff30:	100d883a 	mov	r6,r2
8112ff34:	e17ffe17 	ldw	r5,-8(fp)
8112ff38:	012045b4 	movhi	r4,33046
8112ff3c:	212cd704 	addi	r4,r4,-19620
8112ff40:	11440240 	call	81144024 <strncpy>
    alt_log_write_buf[length-1]='\n';
8112ff44:	e0bffd17 	ldw	r2,-12(fp)
8112ff48:	10ffffc4 	addi	r3,r2,-1
8112ff4c:	00a045b4 	movhi	r2,33046
8112ff50:	10acd704 	addi	r2,r2,-19620
8112ff54:	10c5883a 	add	r2,r2,r3
8112ff58:	00c00284 	movi	r3,10
8112ff5c:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
8112ff60:	00a045b4 	movhi	r2,33046
8112ff64:	10acd704 	addi	r2,r2,-19620
8112ff68:	e0fffd17 	ldw	r3,-12(fp)
8112ff6c:	10c5883a 	add	r2,r2,r3
8112ff70:	00c00344 	movi	r3,13
8112ff74:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
8112ff78:	e0bffd17 	ldw	r2,-12(fp)
8112ff7c:	10c00044 	addi	r3,r2,1
8112ff80:	00a045b4 	movhi	r2,33046
8112ff84:	10acd704 	addi	r2,r2,-19620
8112ff88:	10c5883a 	add	r2,r2,r3
8112ff8c:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
8112ff90:	e03ffc15 	stw	zero,-16(fp)
8112ff94:	00001306 	br	8112ffe4 <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
8112ff98:	00a045b4 	movhi	r2,33046
8112ff9c:	10acd704 	addi	r2,r2,-19620
8112ffa0:	e0fffc17 	ldw	r3,-16(fp)
8112ffa4:	10c5883a 	add	r2,r2,r3
8112ffa8:	10800003 	ldbu	r2,0(r2)
8112ffac:	10803fcc 	andi	r2,r2,255
8112ffb0:	1080201c 	xori	r2,r2,128
8112ffb4:	10bfe004 	addi	r2,r2,-128
8112ffb8:	10800118 	cmpnei	r2,r2,4
8112ffbc:	1000061e 	bne	r2,zero,8112ffd8 <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
8112ffc0:	00a045b4 	movhi	r2,33046
8112ffc4:	10acd704 	addi	r2,r2,-19620
8112ffc8:	e0fffc17 	ldw	r3,-16(fp)
8112ffcc:	10c5883a 	add	r2,r2,r3
8112ffd0:	00c01104 	movi	r3,68
8112ffd4:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
8112ffd8:	e0bffc17 	ldw	r2,-16(fp)
8112ffdc:	10800044 	addi	r2,r2,1
8112ffe0:	e0bffc15 	stw	r2,-16(fp)
8112ffe4:	e0fffc17 	ldw	r3,-16(fp)
8112ffe8:	e0bffd17 	ldw	r2,-12(fp)
8112ffec:	18bfea16 	blt	r3,r2,8112ff98 <__reset+0xfb10ff98>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
8112fff0:	016045b4 	movhi	r5,33046
8112fff4:	296cd704 	addi	r5,r5,-19620
8112fff8:	01204534 	movhi	r4,33044
8112fffc:	21153a04 	addi	r4,r4,21736
81130000:	112fc300 	call	8112fc30 <alt_log_printf_proc>
81130004:	00000106 	br	8113000c <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
81130008:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
8113000c:	e037883a 	mov	sp,fp
81130010:	dfc00117 	ldw	ra,4(sp)
81130014:	df000017 	ldw	fp,0(sp)
81130018:	dec00204 	addi	sp,sp,8
8113001c:	f800283a 	ret

81130020 <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
81130020:	defffe04 	addi	sp,sp,-8
81130024:	de00012e 	bgeu	sp,et,8113002c <alt_log_system_clock+0xc>
81130028:	003b68fa 	trap	3
8113002c:	dfc00115 	stw	ra,4(sp)
81130030:	df000015 	stw	fp,0(sp)
81130034:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
81130038:	d0a08043 	ldbu	r2,-32255(gp)
8113003c:	10803fcc 	andi	r2,r2,255
81130040:	10000e26 	beq	r2,zero,8113007c <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
81130044:	d0a08317 	ldw	r2,-32244(gp)
81130048:	10800044 	addi	r2,r2,1
8113004c:	d0a08315 	stw	r2,-32244(gp)
81130050:	d0a08717 	ldw	r2,-32228(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
81130054:	d0e08317 	ldw	r3,-32244(gp)
81130058:	10c0082e 	bgeu	r2,r3,8113007c <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
8113005c:	d0208315 	stw	zero,-32244(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
81130060:	d0a08217 	ldw	r2,-32248(gp)
81130064:	10c00044 	addi	r3,r2,1
81130068:	d0e08215 	stw	r3,-32248(gp)
8113006c:	100b883a 	mov	r5,r2
81130070:	01204534 	movhi	r4,33044
81130074:	21153e04 	addi	r4,r4,21752
81130078:	112fc300 	call	8112fc30 <alt_log_printf_proc>
        }
    }
}
8113007c:	0001883a 	nop
81130080:	e037883a 	mov	sp,fp
81130084:	dfc00117 	ldw	ra,4(sp)
81130088:	df000017 	ldw	fp,0(sp)
8113008c:	dec00204 	addi	sp,sp,8
81130090:	f800283a 	ret

81130094 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81130094:	defffe04 	addi	sp,sp,-8
81130098:	de00012e 	bgeu	sp,et,811300a0 <alt_get_errno+0xc>
8113009c:	003b68fa 	trap	3
811300a0:	dfc00115 	stw	ra,4(sp)
811300a4:	df000015 	stw	fp,0(sp)
811300a8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811300ac:	d0a01017 	ldw	r2,-32704(gp)
811300b0:	10000326 	beq	r2,zero,811300c0 <alt_get_errno+0x2c>
811300b4:	d0a01017 	ldw	r2,-32704(gp)
811300b8:	103ee83a 	callr	r2
811300bc:	00000106 	br	811300c4 <alt_get_errno+0x30>
811300c0:	d0a07d04 	addi	r2,gp,-32268
}
811300c4:	e037883a 	mov	sp,fp
811300c8:	dfc00117 	ldw	ra,4(sp)
811300cc:	df000017 	ldw	fp,0(sp)
811300d0:	dec00204 	addi	sp,sp,8
811300d4:	f800283a 	ret

811300d8 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
811300d8:	defff904 	addi	sp,sp,-28
811300dc:	de00012e 	bgeu	sp,et,811300e4 <lseek+0xc>
811300e0:	003b68fa 	trap	3
811300e4:	dfc00615 	stw	ra,24(sp)
811300e8:	df000515 	stw	fp,20(sp)
811300ec:	df000504 	addi	fp,sp,20
811300f0:	e13ffd15 	stw	r4,-12(fp)
811300f4:	e17ffe15 	stw	r5,-8(fp)
811300f8:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
811300fc:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81130100:	e0bffd17 	ldw	r2,-12(fp)
81130104:	10000616 	blt	r2,zero,81130120 <lseek+0x48>
81130108:	e0bffd17 	ldw	r2,-12(fp)
8113010c:	10c00324 	muli	r3,r2,12
81130110:	00a04534 	movhi	r2,33044
81130114:	1098f704 	addi	r2,r2,25564
81130118:	1885883a 	add	r2,r3,r2
8113011c:	00000106 	br	81130124 <lseek+0x4c>
81130120:	0005883a 	mov	r2,zero
81130124:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
81130128:	e0bffc17 	ldw	r2,-16(fp)
8113012c:	10001026 	beq	r2,zero,81130170 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
81130130:	e0bffc17 	ldw	r2,-16(fp)
81130134:	10800017 	ldw	r2,0(r2)
81130138:	10800717 	ldw	r2,28(r2)
8113013c:	10000926 	beq	r2,zero,81130164 <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
81130140:	e0bffc17 	ldw	r2,-16(fp)
81130144:	10800017 	ldw	r2,0(r2)
81130148:	10800717 	ldw	r2,28(r2)
8113014c:	e1bfff17 	ldw	r6,-4(fp)
81130150:	e17ffe17 	ldw	r5,-8(fp)
81130154:	e13ffc17 	ldw	r4,-16(fp)
81130158:	103ee83a 	callr	r2
8113015c:	e0bffb15 	stw	r2,-20(fp)
81130160:	00000506 	br	81130178 <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
81130164:	00bfde84 	movi	r2,-134
81130168:	e0bffb15 	stw	r2,-20(fp)
8113016c:	00000206 	br	81130178 <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
81130170:	00bfebc4 	movi	r2,-81
81130174:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
81130178:	e0bffb17 	ldw	r2,-20(fp)
8113017c:	1000070e 	bge	r2,zero,8113019c <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
81130180:	11300940 	call	81130094 <alt_get_errno>
81130184:	1007883a 	mov	r3,r2
81130188:	e0bffb17 	ldw	r2,-20(fp)
8113018c:	0085c83a 	sub	r2,zero,r2
81130190:	18800015 	stw	r2,0(r3)
    rc = -1;
81130194:	00bfffc4 	movi	r2,-1
81130198:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
8113019c:	e0bffb17 	ldw	r2,-20(fp)
}
811301a0:	e037883a 	mov	sp,fp
811301a4:	dfc00117 	ldw	ra,4(sp)
811301a8:	df000017 	ldw	fp,0(sp)
811301ac:	dec00204 	addi	sp,sp,8
811301b0:	f800283a 	ret

811301b4 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
811301b4:	defff904 	addi	sp,sp,-28
811301b8:	de00012e 	bgeu	sp,et,811301c0 <alt_main+0xc>
811301bc:	003b68fa 	trap	3
811301c0:	dfc00615 	stw	ra,24(sp)
811301c4:	df000515 	stw	fp,20(sp)
811301c8:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
811301cc:	d0a01217 	ldw	r2,-32696(gp)
811301d0:	10800058 	cmpnei	r2,r2,1
811301d4:	1000031e 	bne	r2,zero,811301e4 <alt_main+0x30>
811301d8:	01204534 	movhi	r4,33044
811301dc:	21154404 	addi	r4,r4,21776
811301e0:	112fc300 	call	8112fc30 <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
811301e4:	0009883a 	mov	r4,zero
811301e8:	113aaa00 	call	8113aaa0 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
811301ec:	d0a01217 	ldw	r2,-32696(gp)
811301f0:	10800058 	cmpnei	r2,r2,1
811301f4:	1000031e 	bne	r2,zero,81130204 <alt_main+0x50>
811301f8:	01204534 	movhi	r4,33044
811301fc:	21155204 	addi	r4,r4,21832
81130200:	112fc300 	call	8112fc30 <alt_log_printf_proc>
  ALT_OS_INIT();
81130204:	11315340 	call	81131534 <OSInit>
81130208:	01000044 	movi	r4,1
8113020c:	11372500 	call	81137250 <OSSemCreate>
81130210:	d0a08a15 	stw	r2,-32216(gp)
81130214:	01000044 	movi	r4,1
81130218:	11372500 	call	81137250 <OSSemCreate>
8113021c:	d0a08c15 	stw	r2,-32208(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
81130220:	d0a01217 	ldw	r2,-32696(gp)
81130224:	10800058 	cmpnei	r2,r2,1
81130228:	1000031e 	bne	r2,zero,81130238 <alt_main+0x84>
8113022c:	01204534 	movhi	r4,33044
81130230:	21156004 	addi	r4,r4,21888
81130234:	112fc300 	call	8112fc30 <alt_log_printf_proc>
81130238:	d0a07e04 	addi	r2,gp,-32264
8113023c:	e0bffc15 	stw	r2,-16(fp)
81130240:	00800044 	movi	r2,1
81130244:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81130248:	e0bffd0b 	ldhu	r2,-12(fp)
8113024c:	1009883a 	mov	r4,r2
81130250:	11372500 	call	81137250 <OSSemCreate>
81130254:	1007883a 	mov	r3,r2
81130258:	e0bffc17 	ldw	r2,-16(fp)
8113025c:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
81130260:	d0a01217 	ldw	r2,-32696(gp)
81130264:	10800058 	cmpnei	r2,r2,1
81130268:	1000031e 	bne	r2,zero,81130278 <alt_main+0xc4>
8113026c:	01204534 	movhi	r4,33044
81130270:	21156e04 	addi	r4,r4,21944
81130274:	112fc300 	call	8112fc30 <alt_log_printf_proc>
  alt_sys_init();
81130278:	113aae00 	call	8113aae0 <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
8113027c:	d0a01217 	ldw	r2,-32696(gp)
81130280:	10800058 	cmpnei	r2,r2,1
81130284:	1000031e 	bne	r2,zero,81130294 <alt_main+0xe0>
81130288:	01204534 	movhi	r4,33044
8113028c:	21157804 	addi	r4,r4,21984
81130290:	112fc300 	call	8112fc30 <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
81130294:	d0a01217 	ldw	r2,-32696(gp)
81130298:	10800058 	cmpnei	r2,r2,1
8113029c:	1000031e 	bne	r2,zero,811302ac <alt_main+0xf8>
811302a0:	01204534 	movhi	r4,33044
811302a4:	21158104 	addi	r4,r4,22020
811302a8:	112fc300 	call	8112fc30 <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
811302ac:	01a04534 	movhi	r6,33044
811302b0:	31958904 	addi	r6,r6,22052
811302b4:	01604534 	movhi	r5,33044
811302b8:	29558e04 	addi	r5,r5,22072
811302bc:	01204534 	movhi	r4,33044
811302c0:	21158e04 	addi	r4,r4,22072
811302c4:	11431dc0 	call	811431dc <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
811302c8:	d0a01217 	ldw	r2,-32696(gp)
811302cc:	10800058 	cmpnei	r2,r2,1
811302d0:	1000031e 	bne	r2,zero,811302e0 <alt_main+0x12c>
811302d4:	01204534 	movhi	r4,33044
811302d8:	21159204 	addi	r4,r4,22088
811302dc:	112fc300 	call	8112fc30 <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
811302e0:	d0a08417 	ldw	r2,-32240(gp)
811302e4:	d0e08517 	ldw	r3,-32236(gp)
811302e8:	d1208617 	ldw	r4,-32232(gp)
811302ec:	200d883a 	mov	r6,r4
811302f0:	180b883a 	mov	r5,r3
811302f4:	1009883a 	mov	r4,r2
811302f8:	111333c0 	call	8111333c <main>
811302fc:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
81130300:	01000044 	movi	r4,1
81130304:	112f0e00 	call	8112f0e0 <close>
  exit (result);
81130308:	e13ffb17 	ldw	r4,-20(fp)
8113030c:	1143df00 	call	81143df0 <exit>

81130310 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81130310:	defffe04 	addi	sp,sp,-8
81130314:	de00012e 	bgeu	sp,et,8113031c <alt_get_errno+0xc>
81130318:	003b68fa 	trap	3
8113031c:	dfc00115 	stw	ra,4(sp)
81130320:	df000015 	stw	fp,0(sp)
81130324:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81130328:	d0a01017 	ldw	r2,-32704(gp)
8113032c:	10000326 	beq	r2,zero,8113033c <alt_get_errno+0x2c>
81130330:	d0a01017 	ldw	r2,-32704(gp)
81130334:	103ee83a 	callr	r2
81130338:	00000106 	br	81130340 <alt_get_errno+0x30>
8113033c:	d0a07d04 	addi	r2,gp,-32268
}
81130340:	e037883a 	mov	sp,fp
81130344:	dfc00117 	ldw	ra,4(sp)
81130348:	df000017 	ldw	fp,0(sp)
8113034c:	dec00204 	addi	sp,sp,8
81130350:	f800283a 	ret

81130354 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
81130354:	defff904 	addi	sp,sp,-28
81130358:	de00012e 	bgeu	sp,et,81130360 <read+0xc>
8113035c:	003b68fa 	trap	3
81130360:	dfc00615 	stw	ra,24(sp)
81130364:	df000515 	stw	fp,20(sp)
81130368:	df000504 	addi	fp,sp,20
8113036c:	e13ffd15 	stw	r4,-12(fp)
81130370:	e17ffe15 	stw	r5,-8(fp)
81130374:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81130378:	e0bffd17 	ldw	r2,-12(fp)
8113037c:	10000616 	blt	r2,zero,81130398 <read+0x44>
81130380:	e0bffd17 	ldw	r2,-12(fp)
81130384:	10c00324 	muli	r3,r2,12
81130388:	00a04534 	movhi	r2,33044
8113038c:	1098f704 	addi	r2,r2,25564
81130390:	1885883a 	add	r2,r3,r2
81130394:	00000106 	br	8113039c <read+0x48>
81130398:	0005883a 	mov	r2,zero
8113039c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
811303a0:	e0bffb17 	ldw	r2,-20(fp)
811303a4:	10002226 	beq	r2,zero,81130430 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
811303a8:	e0bffb17 	ldw	r2,-20(fp)
811303ac:	10800217 	ldw	r2,8(r2)
811303b0:	108000cc 	andi	r2,r2,3
811303b4:	10800060 	cmpeqi	r2,r2,1
811303b8:	1000181e 	bne	r2,zero,8113041c <read+0xc8>
        (fd->dev->read))
811303bc:	e0bffb17 	ldw	r2,-20(fp)
811303c0:	10800017 	ldw	r2,0(r2)
811303c4:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
811303c8:	10001426 	beq	r2,zero,8113041c <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
811303cc:	e0bffb17 	ldw	r2,-20(fp)
811303d0:	10800017 	ldw	r2,0(r2)
811303d4:	10800517 	ldw	r2,20(r2)
811303d8:	e0ffff17 	ldw	r3,-4(fp)
811303dc:	180d883a 	mov	r6,r3
811303e0:	e17ffe17 	ldw	r5,-8(fp)
811303e4:	e13ffb17 	ldw	r4,-20(fp)
811303e8:	103ee83a 	callr	r2
811303ec:	e0bffc15 	stw	r2,-16(fp)
811303f0:	e0bffc17 	ldw	r2,-16(fp)
811303f4:	1000070e 	bge	r2,zero,81130414 <read+0xc0>
        {
          ALT_ERRNO = -rval;
811303f8:	11303100 	call	81130310 <alt_get_errno>
811303fc:	1007883a 	mov	r3,r2
81130400:	e0bffc17 	ldw	r2,-16(fp)
81130404:	0085c83a 	sub	r2,zero,r2
81130408:	18800015 	stw	r2,0(r3)
          return -1;
8113040c:	00bfffc4 	movi	r2,-1
81130410:	00000c06 	br	81130444 <read+0xf0>
        }
        return rval;
81130414:	e0bffc17 	ldw	r2,-16(fp)
81130418:	00000a06 	br	81130444 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
8113041c:	11303100 	call	81130310 <alt_get_errno>
81130420:	1007883a 	mov	r3,r2
81130424:	00800344 	movi	r2,13
81130428:	18800015 	stw	r2,0(r3)
8113042c:	00000406 	br	81130440 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
81130430:	11303100 	call	81130310 <alt_get_errno>
81130434:	1007883a 	mov	r3,r2
81130438:	00801444 	movi	r2,81
8113043c:	18800015 	stw	r2,0(r3)
  }
  return -1;
81130440:	00bfffc4 	movi	r2,-1
}
81130444:	e037883a 	mov	sp,fp
81130448:	dfc00117 	ldw	ra,4(sp)
8113044c:	df000017 	ldw	fp,0(sp)
81130450:	dec00204 	addi	sp,sp,8
81130454:	f800283a 	ret

81130458 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
81130458:	defffe04 	addi	sp,sp,-8
8113045c:	de00012e 	bgeu	sp,et,81130464 <alt_release_fd+0xc>
81130460:	003b68fa 	trap	3
81130464:	df000115 	stw	fp,4(sp)
81130468:	df000104 	addi	fp,sp,4
8113046c:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
81130470:	e0bfff17 	ldw	r2,-4(fp)
81130474:	108000d0 	cmplti	r2,r2,3
81130478:	10000d1e 	bne	r2,zero,811304b0 <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
8113047c:	00a04534 	movhi	r2,33044
81130480:	1098f704 	addi	r2,r2,25564
81130484:	e0ffff17 	ldw	r3,-4(fp)
81130488:	18c00324 	muli	r3,r3,12
8113048c:	10c5883a 	add	r2,r2,r3
81130490:	10800204 	addi	r2,r2,8
81130494:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
81130498:	00a04534 	movhi	r2,33044
8113049c:	1098f704 	addi	r2,r2,25564
811304a0:	e0ffff17 	ldw	r3,-4(fp)
811304a4:	18c00324 	muli	r3,r3,12
811304a8:	10c5883a 	add	r2,r2,r3
811304ac:	10000015 	stw	zero,0(r2)
  }
}
811304b0:	0001883a 	nop
811304b4:	e037883a 	mov	sp,fp
811304b8:	df000017 	ldw	fp,0(sp)
811304bc:	dec00104 	addi	sp,sp,4
811304c0:	f800283a 	ret

811304c4 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
811304c4:	defff604 	addi	sp,sp,-40
811304c8:	de00012e 	bgeu	sp,et,811304d0 <sbrk+0xc>
811304cc:	003b68fa 	trap	3
811304d0:	df000915 	stw	fp,36(sp)
811304d4:	df000904 	addi	fp,sp,36
811304d8:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811304dc:	0005303a 	rdctl	r2,status
811304e0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811304e4:	e0fffe17 	ldw	r3,-8(fp)
811304e8:	00bfff84 	movi	r2,-2
811304ec:	1884703a 	and	r2,r3,r2
811304f0:	1001703a 	wrctl	status,r2
  
  return context;
811304f4:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
811304f8:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
811304fc:	d0a01317 	ldw	r2,-32692(gp)
81130500:	10c000c4 	addi	r3,r2,3
81130504:	00bfff04 	movi	r2,-4
81130508:	1884703a 	and	r2,r3,r2
8113050c:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
81130510:	d0e01317 	ldw	r3,-32692(gp)
81130514:	e0bfff17 	ldw	r2,-4(fp)
81130518:	1887883a 	add	r3,r3,r2
8113051c:	00a04834 	movhi	r2,33056
81130520:	10a80004 	addi	r2,r2,-24576
81130524:	10c0062e 	bgeu	r2,r3,81130540 <sbrk+0x7c>
81130528:	e0bff817 	ldw	r2,-32(fp)
8113052c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130530:	e0bff717 	ldw	r2,-36(fp)
81130534:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
81130538:	00bfffc4 	movi	r2,-1
8113053c:	00001c06 	br	811305b0 <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
81130540:	d0a01317 	ldw	r2,-32692(gp)
81130544:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
81130548:	d0e01317 	ldw	r3,-32692(gp)
8113054c:	e0bfff17 	ldw	r2,-4(fp)
81130550:	1885883a 	add	r2,r3,r2
81130554:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
81130558:	c005883a 	mov	r2,et
8113055c:	e0bff915 	stw	r2,-28(fp)

  return limit; 
81130560:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
81130564:	e0bffa17 	ldw	r2,-24(fp)
81130568:	18800c1e 	bne	r3,r2,8113059c <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
8113056c:	d805883a 	mov	r2,sp
81130570:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
81130574:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
81130578:	d0e01317 	ldw	r3,-32692(gp)
8113057c:	18800136 	bltu	r3,r2,81130584 <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
81130580:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
81130584:	d0a01317 	ldw	r2,-32692(gp)
81130588:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
8113058c:	e0bffc17 	ldw	r2,-16(fp)
81130590:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
81130594:	e0bffc17 	ldw	r2,-16(fp)
81130598:	1031883a 	mov	et,r2
8113059c:	e0bff817 	ldw	r2,-32(fp)
811305a0:	e0bffd15 	stw	r2,-12(fp)
811305a4:	e0bffd17 	ldw	r2,-12(fp)
811305a8:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
811305ac:	e0bffa17 	ldw	r2,-24(fp)
} 
811305b0:	e037883a 	mov	sp,fp
811305b4:	df000017 	ldw	fp,0(sp)
811305b8:	dec00104 	addi	sp,sp,4
811305bc:	f800283a 	ret

811305c0 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
811305c0:	defffa04 	addi	sp,sp,-24
811305c4:	de00012e 	bgeu	sp,et,811305cc <alt_alarm_stop+0xc>
811305c8:	003b68fa 	trap	3
811305cc:	df000515 	stw	fp,20(sp)
811305d0:	df000504 	addi	fp,sp,20
811305d4:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811305d8:	0005303a 	rdctl	r2,status
811305dc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811305e0:	e0fffc17 	ldw	r3,-16(fp)
811305e4:	00bfff84 	movi	r2,-2
811305e8:	1884703a 	and	r2,r3,r2
811305ec:	1001703a 	wrctl	status,r2
  
  return context;
811305f0:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
811305f4:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
811305f8:	e0bfff17 	ldw	r2,-4(fp)
811305fc:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
81130600:	e0bffd17 	ldw	r2,-12(fp)
81130604:	10800017 	ldw	r2,0(r2)
81130608:	e0fffd17 	ldw	r3,-12(fp)
8113060c:	18c00117 	ldw	r3,4(r3)
81130610:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
81130614:	e0bffd17 	ldw	r2,-12(fp)
81130618:	10800117 	ldw	r2,4(r2)
8113061c:	e0fffd17 	ldw	r3,-12(fp)
81130620:	18c00017 	ldw	r3,0(r3)
81130624:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
81130628:	e0bffd17 	ldw	r2,-12(fp)
8113062c:	e0fffd17 	ldw	r3,-12(fp)
81130630:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
81130634:	e0bffd17 	ldw	r2,-12(fp)
81130638:	e0fffd17 	ldw	r3,-12(fp)
8113063c:	10c00015 	stw	r3,0(r2)
81130640:	e0bffb17 	ldw	r2,-20(fp)
81130644:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130648:	e0bffe17 	ldw	r2,-8(fp)
8113064c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
81130650:	0001883a 	nop
81130654:	e037883a 	mov	sp,fp
81130658:	df000017 	ldw	fp,0(sp)
8113065c:	dec00104 	addi	sp,sp,4
81130660:	f800283a 	ret

81130664 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
81130664:	defffb04 	addi	sp,sp,-20
81130668:	de00012e 	bgeu	sp,et,81130670 <alt_tick+0xc>
8113066c:	003b68fa 	trap	3
81130670:	dfc00415 	stw	ra,16(sp)
81130674:	df000315 	stw	fp,12(sp)
81130678:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
8113067c:	d0a01417 	ldw	r2,-32688(gp)
81130680:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
81130684:	d0a08817 	ldw	r2,-32224(gp)
81130688:	10800044 	addi	r2,r2,1
8113068c:	d0a08815 	stw	r2,-32224(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81130690:	00002e06 	br	8113074c <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
81130694:	e0bffd17 	ldw	r2,-12(fp)
81130698:	10800017 	ldw	r2,0(r2)
8113069c:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
811306a0:	e0bffd17 	ldw	r2,-12(fp)
811306a4:	10800403 	ldbu	r2,16(r2)
811306a8:	10803fcc 	andi	r2,r2,255
811306ac:	10000426 	beq	r2,zero,811306c0 <alt_tick+0x5c>
811306b0:	d0a08817 	ldw	r2,-32224(gp)
811306b4:	1000021e 	bne	r2,zero,811306c0 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
811306b8:	e0bffd17 	ldw	r2,-12(fp)
811306bc:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
811306c0:	e0bffd17 	ldw	r2,-12(fp)
811306c4:	10800217 	ldw	r2,8(r2)
811306c8:	d0e08817 	ldw	r3,-32224(gp)
811306cc:	18801d36 	bltu	r3,r2,81130744 <alt_tick+0xe0>
811306d0:	e0bffd17 	ldw	r2,-12(fp)
811306d4:	10800403 	ldbu	r2,16(r2)
811306d8:	10803fcc 	andi	r2,r2,255
811306dc:	1000191e 	bne	r2,zero,81130744 <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
811306e0:	e0bffd17 	ldw	r2,-12(fp)
811306e4:	10800317 	ldw	r2,12(r2)
811306e8:	e0fffd17 	ldw	r3,-12(fp)
811306ec:	18c00517 	ldw	r3,20(r3)
811306f0:	1809883a 	mov	r4,r3
811306f4:	103ee83a 	callr	r2
811306f8:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
811306fc:	e0bfff17 	ldw	r2,-4(fp)
81130700:	1000031e 	bne	r2,zero,81130710 <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
81130704:	e13ffd17 	ldw	r4,-12(fp)
81130708:	11305c00 	call	811305c0 <alt_alarm_stop>
8113070c:	00000d06 	br	81130744 <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
81130710:	e0bffd17 	ldw	r2,-12(fp)
81130714:	10c00217 	ldw	r3,8(r2)
81130718:	e0bfff17 	ldw	r2,-4(fp)
8113071c:	1887883a 	add	r3,r3,r2
81130720:	e0bffd17 	ldw	r2,-12(fp)
81130724:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
81130728:	e0bffd17 	ldw	r2,-12(fp)
8113072c:	10c00217 	ldw	r3,8(r2)
81130730:	d0a08817 	ldw	r2,-32224(gp)
81130734:	1880032e 	bgeu	r3,r2,81130744 <alt_tick+0xe0>
        {
          alarm->rollover = 1;
81130738:	e0bffd17 	ldw	r2,-12(fp)
8113073c:	00c00044 	movi	r3,1
81130740:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
81130744:	e0bffe17 	ldw	r2,-8(fp)
81130748:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
8113074c:	e0fffd17 	ldw	r3,-12(fp)
81130750:	d0a01404 	addi	r2,gp,-32688
81130754:	18bfcf1e 	bne	r3,r2,81130694 <__reset+0xfb110694>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
81130758:	11319940 	call	81131994 <OSTimeTick>
}
8113075c:	0001883a 	nop
81130760:	e037883a 	mov	sp,fp
81130764:	dfc00117 	ldw	ra,4(sp)
81130768:	df000017 	ldw	fp,0(sp)
8113076c:	dec00204 	addi	sp,sp,8
81130770:	f800283a 	ret

81130774 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
81130774:	defffb04 	addi	sp,sp,-20
81130778:	de00012e 	bgeu	sp,et,81130780 <usleep+0xc>
8113077c:	003b68fa 	trap	3
81130780:	dfc00415 	stw	ra,16(sp)
81130784:	df000315 	stw	fp,12(sp)
81130788:	df000304 	addi	fp,sp,12
8113078c:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
81130790:	d0a09003 	ldbu	r2,-32192(gp)
81130794:	10803fcc 	andi	r2,r2,255
81130798:	1000031e 	bne	r2,zero,811307a8 <usleep+0x34>
  {
    return alt_busy_sleep (us);
8113079c:	e13fff17 	ldw	r4,-4(fp)
811307a0:	112ef6c0 	call	8112ef6c <alt_busy_sleep>
811307a4:	00003d06 	br	8113089c <usleep+0x128>
811307a8:	d0a08717 	ldw	r2,-32228(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
811307ac:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
811307b0:	e0ffff17 	ldw	r3,-4(fp)
811307b4:	0090c734 	movhi	r2,17180
811307b8:	10b7a0c4 	addi	r2,r2,-8573
811307bc:	1888383a 	mulxuu	r4,r3,r2
811307c0:	1885383a 	mul	r2,r3,r2
811307c4:	1013883a 	mov	r9,r2
811307c8:	2015883a 	mov	r10,r4
811307cc:	5006d4ba 	srli	r3,r10,18
811307d0:	e0bffe17 	ldw	r2,-8(fp)
811307d4:	1893383a 	mul	r9,r3,r2
811307d8:	e0ffff17 	ldw	r3,-4(fp)
811307dc:	0090c734 	movhi	r2,17180
811307e0:	10b7a0c4 	addi	r2,r2,-8573
811307e4:	1888383a 	mulxuu	r4,r3,r2
811307e8:	1885383a 	mul	r2,r3,r2
811307ec:	100f883a 	mov	r7,r2
811307f0:	2011883a 	mov	r8,r4
811307f4:	4004d4ba 	srli	r2,r8,18
811307f8:	010003f4 	movhi	r4,15
811307fc:	21109004 	addi	r4,r4,16960
81130800:	1105383a 	mul	r2,r2,r4
81130804:	1885c83a 	sub	r2,r3,r2
81130808:	e0fffe17 	ldw	r3,-8(fp)
8113080c:	10c7383a 	mul	r3,r2,r3
81130810:	0090c734 	movhi	r2,17180
81130814:	10b7a0c4 	addi	r2,r2,-8573
81130818:	1888383a 	mulxuu	r4,r3,r2
8113081c:	1885383a 	mul	r2,r3,r2
81130820:	100b883a 	mov	r5,r2
81130824:	200d883a 	mov	r6,r4
81130828:	3004d4ba 	srli	r2,r6,18
8113082c:	4885883a 	add	r2,r9,r2
81130830:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81130834:	00000706 	br	81130854 <usleep+0xe0>
  {
    OSTimeDly(0xffff);
81130838:	013fffd4 	movui	r4,65535
8113083c:	11394040 	call	81139404 <OSTimeDly>
    ticks -= 0xffff;
81130840:	e0fffd17 	ldw	r3,-12(fp)
81130844:	00bffff4 	movhi	r2,65535
81130848:	10800044 	addi	r2,r2,1
8113084c:	1885883a 	add	r2,r3,r2
81130850:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81130854:	e0bffd17 	ldw	r2,-12(fp)
81130858:	00ffffd4 	movui	r3,65535
8113085c:	18bff636 	bltu	r3,r2,81130838 <__reset+0xfb110838>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
81130860:	e0bffd17 	ldw	r2,-12(fp)
81130864:	10bfffcc 	andi	r2,r2,65535
81130868:	1009883a 	mov	r4,r2
8113086c:	11394040 	call	81139404 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
81130870:	008003f4 	movhi	r2,15
81130874:	10909004 	addi	r2,r2,16960
81130878:	e0fffe17 	ldw	r3,-8(fp)
8113087c:	10c7203a 	divu	r3,r2,r3
81130880:	e0bfff17 	ldw	r2,-4(fp)
81130884:	10c9203a 	divu	r4,r2,r3
81130888:	20c7383a 	mul	r3,r4,r3
8113088c:	10c5c83a 	sub	r2,r2,r3
81130890:	1009883a 	mov	r4,r2
81130894:	112ef6c0 	call	8112ef6c <alt_busy_sleep>

  return 0;  
81130898:	0005883a 	mov	r2,zero
}
8113089c:	e037883a 	mov	sp,fp
811308a0:	dfc00117 	ldw	ra,4(sp)
811308a4:	df000017 	ldw	fp,0(sp)
811308a8:	dec00204 	addi	sp,sp,8
811308ac:	f800283a 	ret

811308b0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811308b0:	defffe04 	addi	sp,sp,-8
811308b4:	de00012e 	bgeu	sp,et,811308bc <alt_get_errno+0xc>
811308b8:	003b68fa 	trap	3
811308bc:	dfc00115 	stw	ra,4(sp)
811308c0:	df000015 	stw	fp,0(sp)
811308c4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811308c8:	d0a01017 	ldw	r2,-32704(gp)
811308cc:	10000326 	beq	r2,zero,811308dc <alt_get_errno+0x2c>
811308d0:	d0a01017 	ldw	r2,-32704(gp)
811308d4:	103ee83a 	callr	r2
811308d8:	00000106 	br	811308e0 <alt_get_errno+0x30>
811308dc:	d0a07d04 	addi	r2,gp,-32268
}
811308e0:	e037883a 	mov	sp,fp
811308e4:	dfc00117 	ldw	ra,4(sp)
811308e8:	df000017 	ldw	fp,0(sp)
811308ec:	dec00204 	addi	sp,sp,8
811308f0:	f800283a 	ret

811308f4 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
811308f4:	defff904 	addi	sp,sp,-28
811308f8:	de00012e 	bgeu	sp,et,81130900 <write+0xc>
811308fc:	003b68fa 	trap	3
81130900:	dfc00615 	stw	ra,24(sp)
81130904:	df000515 	stw	fp,20(sp)
81130908:	df000504 	addi	fp,sp,20
8113090c:	e13ffd15 	stw	r4,-12(fp)
81130910:	e17ffe15 	stw	r5,-8(fp)
81130914:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81130918:	e0bffd17 	ldw	r2,-12(fp)
8113091c:	10000616 	blt	r2,zero,81130938 <write+0x44>
81130920:	e0bffd17 	ldw	r2,-12(fp)
81130924:	10c00324 	muli	r3,r2,12
81130928:	00a04534 	movhi	r2,33044
8113092c:	1098f704 	addi	r2,r2,25564
81130930:	1885883a 	add	r2,r3,r2
81130934:	00000106 	br	8113093c <write+0x48>
81130938:	0005883a 	mov	r2,zero
8113093c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81130940:	e0bffb17 	ldw	r2,-20(fp)
81130944:	10002426 	beq	r2,zero,811309d8 <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
81130948:	e0bffb17 	ldw	r2,-20(fp)
8113094c:	10800217 	ldw	r2,8(r2)
81130950:	108000cc 	andi	r2,r2,3
81130954:	10001b26 	beq	r2,zero,811309c4 <write+0xd0>
81130958:	e0bffb17 	ldw	r2,-20(fp)
8113095c:	10800017 	ldw	r2,0(r2)
81130960:	10800617 	ldw	r2,24(r2)
81130964:	10001726 	beq	r2,zero,811309c4 <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
81130968:	e17fff17 	ldw	r5,-4(fp)
8113096c:	e13ffe17 	ldw	r4,-8(fp)
81130970:	112fee00 	call	8112fee0 <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
81130974:	e0bffb17 	ldw	r2,-20(fp)
81130978:	10800017 	ldw	r2,0(r2)
8113097c:	10800617 	ldw	r2,24(r2)
81130980:	e0ffff17 	ldw	r3,-4(fp)
81130984:	180d883a 	mov	r6,r3
81130988:	e17ffe17 	ldw	r5,-8(fp)
8113098c:	e13ffb17 	ldw	r4,-20(fp)
81130990:	103ee83a 	callr	r2
81130994:	e0bffc15 	stw	r2,-16(fp)
81130998:	e0bffc17 	ldw	r2,-16(fp)
8113099c:	1000070e 	bge	r2,zero,811309bc <write+0xc8>
      {
        ALT_ERRNO = -rval;
811309a0:	11308b00 	call	811308b0 <alt_get_errno>
811309a4:	1007883a 	mov	r3,r2
811309a8:	e0bffc17 	ldw	r2,-16(fp)
811309ac:	0085c83a 	sub	r2,zero,r2
811309b0:	18800015 	stw	r2,0(r3)
        return -1;
811309b4:	00bfffc4 	movi	r2,-1
811309b8:	00000c06 	br	811309ec <write+0xf8>
      }
      return rval;
811309bc:	e0bffc17 	ldw	r2,-16(fp)
811309c0:	00000a06 	br	811309ec <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
811309c4:	11308b00 	call	811308b0 <alt_get_errno>
811309c8:	1007883a 	mov	r3,r2
811309cc:	00800344 	movi	r2,13
811309d0:	18800015 	stw	r2,0(r3)
811309d4:	00000406 	br	811309e8 <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
811309d8:	11308b00 	call	811308b0 <alt_get_errno>
811309dc:	1007883a 	mov	r3,r2
811309e0:	00801444 	movi	r2,81
811309e4:	18800015 	stw	r2,0(r3)
  }
  return -1;
811309e8:	00bfffc4 	movi	r2,-1
}
811309ec:	e037883a 	mov	sp,fp
811309f0:	dfc00117 	ldw	ra,4(sp)
811309f4:	df000017 	ldw	fp,0(sp)
811309f8:	dec00204 	addi	sp,sp,8
811309fc:	f800283a 	ret

81130a00 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
81130a00:	deffde04 	addi	sp,sp,-136
81130a04:	de00012e 	bgeu	sp,et,81130a0c <__env_lock+0xc>
81130a08:	003b68fa 	trap	3
81130a0c:	dfc02115 	stw	ra,132(sp)
81130a10:	df002015 	stw	fp,128(sp)
81130a14:	df002004 	addi	fp,sp,128
81130a18:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81130a1c:	e0bfe104 	addi	r2,fp,-124
81130a20:	100b883a 	mov	r5,r2
81130a24:	01003fc4 	movi	r4,255
81130a28:	11392600 	call	81139260 <OSTaskQuery>
81130a2c:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81130a30:	e0bffe83 	ldbu	r2,-6(fp)
81130a34:	10803fcc 	andi	r2,r2,255
81130a38:	10001e1e 	bne	r2,zero,81130ab4 <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
81130a3c:	e0bfed83 	ldbu	r2,-74(fp)
81130a40:	10803fcc 	andi	r2,r2,255
81130a44:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
81130a48:	d0a08a17 	ldw	r2,-32216(gp)
81130a4c:	e0fffc04 	addi	r3,fp,-16
81130a50:	180b883a 	mov	r5,r3
81130a54:	1009883a 	mov	r4,r2
81130a58:	1137a180 	call	81137a18 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
81130a5c:	e0bffe03 	ldbu	r2,-8(fp)
81130a60:	10803fcc 	andi	r2,r2,255
81130a64:	10000726 	beq	r2,zero,81130a84 <__env_lock+0x84>
81130a68:	d0a01617 	ldw	r2,-32680(gp)
81130a6c:	e0ffe017 	ldw	r3,-128(fp)
81130a70:	1880041e 	bne	r3,r2,81130a84 <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
81130a74:	d0a08917 	ldw	r2,-32220(gp)
81130a78:	10800044 	addi	r2,r2,1
81130a7c:	d0a08915 	stw	r2,-32220(gp)
81130a80:	00000a06 	br	81130aac <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
81130a84:	d0a08a17 	ldw	r2,-32216(gp)
81130a88:	e0fffe84 	addi	r3,fp,-6
81130a8c:	180d883a 	mov	r6,r3
81130a90:	000b883a 	mov	r5,zero
81130a94:	1009883a 	mov	r4,r2
81130a98:	11375780 	call	81137578 <OSSemPend>
    locks  = 1;
81130a9c:	00800044 	movi	r2,1
81130aa0:	d0a08915 	stw	r2,-32220(gp)
    lockid = id;
81130aa4:	e0bfe017 	ldw	r2,-128(fp)
81130aa8:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81130aac:	0001883a 	nop
81130ab0:	00000106 	br	81130ab8 <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81130ab4:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81130ab8:	e037883a 	mov	sp,fp
81130abc:	dfc00117 	ldw	ra,4(sp)
81130ac0:	df000017 	ldw	fp,0(sp)
81130ac4:	dec00204 	addi	sp,sp,8
81130ac8:	f800283a 	ret

81130acc <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
81130acc:	defffd04 	addi	sp,sp,-12
81130ad0:	de00012e 	bgeu	sp,et,81130ad8 <__env_unlock+0xc>
81130ad4:	003b68fa 	trap	3
81130ad8:	dfc00215 	stw	ra,8(sp)
81130adc:	df000115 	stw	fp,4(sp)
81130ae0:	df000104 	addi	fp,sp,4
81130ae4:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
81130ae8:	d0a08917 	ldw	r2,-32220(gp)
81130aec:	10000b26 	beq	r2,zero,81130b1c <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
81130af0:	d0a08917 	ldw	r2,-32220(gp)
81130af4:	10bfffc4 	addi	r2,r2,-1
81130af8:	d0a08915 	stw	r2,-32220(gp)
81130afc:	d0a08917 	ldw	r2,-32220(gp)
81130b00:	1000071e 	bne	r2,zero,81130b20 <__env_unlock+0x54>
  {
    lockid = -1;
81130b04:	00bfffc4 	movi	r2,-1
81130b08:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
81130b0c:	d0a08a17 	ldw	r2,-32216(gp)
81130b10:	1009883a 	mov	r4,r2
81130b14:	11379000 	call	81137900 <OSSemPost>
81130b18:	00000106 	br	81130b20 <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
81130b1c:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81130b20:	e037883a 	mov	sp,fp
81130b24:	dfc00117 	ldw	ra,4(sp)
81130b28:	df000017 	ldw	fp,0(sp)
81130b2c:	dec00204 	addi	sp,sp,8
81130b30:	f800283a 	ret

81130b34 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
81130b34:	deffda04 	addi	sp,sp,-152
81130b38:	de00012e 	bgeu	sp,et,81130b40 <__malloc_lock+0xc>
81130b3c:	003b68fa 	trap	3
81130b40:	dfc02515 	stw	ra,148(sp)
81130b44:	df002415 	stw	fp,144(sp)
81130b48:	df002404 	addi	fp,sp,144
81130b4c:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81130b50:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
81130b54:	d0a09003 	ldbu	r2,-32192(gp)
81130b58:	10803fcc 	andi	r2,r2,255
81130b5c:	10800060 	cmpeqi	r2,r2,1
81130b60:	10003626 	beq	r2,zero,81130c3c <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81130b64:	e0bfe104 	addi	r2,fp,-124
81130b68:	100b883a 	mov	r5,r2
81130b6c:	01003fc4 	movi	r4,255
81130b70:	11392600 	call	81139260 <OSTaskQuery>
81130b74:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81130b78:	e0bffe83 	ldbu	r2,-6(fp)
81130b7c:	10803fcc 	andi	r2,r2,255
81130b80:	1000301e 	bne	r2,zero,81130c44 <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
81130b84:	e0bfed83 	ldbu	r2,-74(fp)
81130b88:	10803fcc 	andi	r2,r2,255
81130b8c:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
81130b90:	d0a08c17 	ldw	r2,-32208(gp)
81130b94:	e0fffc04 	addi	r3,fp,-16
81130b98:	180b883a 	mov	r5,r3
81130b9c:	1009883a 	mov	r4,r2
81130ba0:	1137a180 	call	81137a18 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130ba4:	0005303a 	rdctl	r2,status
81130ba8:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130bac:	e0ffe017 	ldw	r3,-128(fp)
81130bb0:	00bfff84 	movi	r2,-2
81130bb4:	1884703a 	and	r2,r3,r2
81130bb8:	1001703a 	wrctl	status,r2
  
  return context;
81130bbc:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
81130bc0:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
81130bc4:	e0bffc0b 	ldhu	r2,-16(fp)
81130bc8:	10bfffcc 	andi	r2,r2,65535
81130bcc:	10000b1e 	bne	r2,zero,81130bfc <__malloc_lock+0xc8>
81130bd0:	d0a01717 	ldw	r2,-32676(gp)
81130bd4:	e0ffdd17 	ldw	r3,-140(fp)
81130bd8:	1880081e 	bne	r3,r2,81130bfc <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
81130bdc:	d0a08b17 	ldw	r2,-32212(gp)
81130be0:	10800044 	addi	r2,r2,1
81130be4:	d0a08b15 	stw	r2,-32212(gp)
81130be8:	e0bfdc17 	ldw	r2,-144(fp)
81130bec:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130bf0:	e0bfde17 	ldw	r2,-136(fp)
81130bf4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
81130bf8:	00000e06 	br	81130c34 <__malloc_lock+0x100>
81130bfc:	e0bfdc17 	ldw	r2,-144(fp)
81130c00:	e0bfdf15 	stw	r2,-132(fp)
81130c04:	e0bfdf17 	ldw	r2,-132(fp)
81130c08:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
81130c0c:	d0a08c17 	ldw	r2,-32208(gp)
81130c10:	e0fffe84 	addi	r3,fp,-6
81130c14:	180d883a 	mov	r6,r3
81130c18:	000b883a 	mov	r5,zero
81130c1c:	1009883a 	mov	r4,r2
81130c20:	11375780 	call	81137578 <OSSemPend>
    locks  = 1;
81130c24:	00800044 	movi	r2,1
81130c28:	d0a08b15 	stw	r2,-32212(gp)
    lockid = id;
81130c2c:	e0bfdd17 	ldw	r2,-140(fp)
81130c30:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81130c34:	0001883a 	nop
81130c38:	00000306 	br	81130c48 <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
81130c3c:	0001883a 	nop
81130c40:	00000106 	br	81130c48 <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81130c44:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81130c48:	e037883a 	mov	sp,fp
81130c4c:	dfc00117 	ldw	ra,4(sp)
81130c50:	df000017 	ldw	fp,0(sp)
81130c54:	dec00204 	addi	sp,sp,8
81130c58:	f800283a 	ret

81130c5c <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
81130c5c:	defff804 	addi	sp,sp,-32
81130c60:	de00012e 	bgeu	sp,et,81130c68 <__malloc_unlock+0xc>
81130c64:	003b68fa 	trap	3
81130c68:	dfc00715 	stw	ra,28(sp)
81130c6c:	df000615 	stw	fp,24(sp)
81130c70:	df000604 	addi	fp,sp,24
81130c74:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81130c78:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
81130c7c:	d0a09003 	ldbu	r2,-32192(gp)
81130c80:	10803fcc 	andi	r2,r2,255
81130c84:	10800060 	cmpeqi	r2,r2,1
81130c88:	10002326 	beq	r2,zero,81130d18 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130c8c:	0005303a 	rdctl	r2,status
81130c90:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130c94:	e0fffe17 	ldw	r3,-8(fp)
81130c98:	00bfff84 	movi	r2,-2
81130c9c:	1884703a 	and	r2,r3,r2
81130ca0:	1001703a 	wrctl	status,r2
  
  return context;
81130ca4:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
81130ca8:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
81130cac:	d0a08b17 	ldw	r2,-32212(gp)
81130cb0:	1000051e 	bne	r2,zero,81130cc8 <__malloc_unlock+0x6c>
81130cb4:	e0bffa17 	ldw	r2,-24(fp)
81130cb8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130cbc:	e0bffb17 	ldw	r2,-20(fp)
81130cc0:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
81130cc4:	00001506 	br	81130d1c <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
81130cc8:	d0a08b17 	ldw	r2,-32212(gp)
81130ccc:	10bfffc4 	addi	r2,r2,-1
81130cd0:	d0a08b15 	stw	r2,-32212(gp)
81130cd4:	d0a08b17 	ldw	r2,-32212(gp)
81130cd8:	10000a1e 	bne	r2,zero,81130d04 <__malloc_unlock+0xa8>
  {
    lockid = -1;
81130cdc:	00bfffc4 	movi	r2,-1
81130ce0:	d0a01715 	stw	r2,-32676(gp)
81130ce4:	e0bffa17 	ldw	r2,-24(fp)
81130ce8:	e0bffc15 	stw	r2,-16(fp)
81130cec:	e0bffc17 	ldw	r2,-16(fp)
81130cf0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
81130cf4:	d0a08c17 	ldw	r2,-32208(gp)
81130cf8:	1009883a 	mov	r4,r2
81130cfc:	11379000 	call	81137900 <OSSemPost>
81130d00:	00000606 	br	81130d1c <__malloc_unlock+0xc0>
81130d04:	e0bffa17 	ldw	r2,-24(fp)
81130d08:	e0bffd15 	stw	r2,-12(fp)
81130d0c:	e0bffd17 	ldw	r2,-12(fp)
81130d10:	1001703a 	wrctl	status,r2
81130d14:	00000106 	br	81130d1c <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
81130d18:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81130d1c:	e037883a 	mov	sp,fp
81130d20:	dfc00117 	ldw	ra,4(sp)
81130d24:	df000017 	ldw	fp,0(sp)
81130d28:	dec00204 	addi	sp,sp,8
81130d2c:	f800283a 	ret

81130d30 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
81130d30:	defff704 	addi	sp,sp,-36
81130d34:	de00012e 	bgeu	sp,et,81130d3c <OSEventNameGet+0xc>
81130d38:	003b68fa 	trap	3
81130d3c:	dfc00815 	stw	ra,32(sp)
81130d40:	df000715 	stw	fp,28(sp)
81130d44:	df000704 	addi	fp,sp,28
81130d48:	e13ffd15 	stw	r4,-12(fp)
81130d4c:	e17ffe15 	stw	r5,-8(fp)
81130d50:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81130d54:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81130d58:	e0bfff17 	ldw	r2,-4(fp)
81130d5c:	1000021e 	bne	r2,zero,81130d68 <OSEventNameGet+0x38>
        return (0);
81130d60:	0005883a 	mov	r2,zero
81130d64:	00003706 	br	81130e44 <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81130d68:	e0bffd17 	ldw	r2,-12(fp)
81130d6c:	1000051e 	bne	r2,zero,81130d84 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
81130d70:	e0bfff17 	ldw	r2,-4(fp)
81130d74:	00c00104 	movi	r3,4
81130d78:	10c00005 	stb	r3,0(r2)
        return (0);
81130d7c:	0005883a 	mov	r2,zero
81130d80:	00003006 	br	81130e44 <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81130d84:	e0bffe17 	ldw	r2,-8(fp)
81130d88:	1000051e 	bne	r2,zero,81130da0 <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81130d8c:	e0bfff17 	ldw	r2,-4(fp)
81130d90:	00c00304 	movi	r3,12
81130d94:	10c00005 	stb	r3,0(r2)
        return (0);
81130d98:	0005883a 	mov	r2,zero
81130d9c:	00002906 	br	81130e44 <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81130da0:	d0a0a003 	ldbu	r2,-32128(gp)
81130da4:	10803fcc 	andi	r2,r2,255
81130da8:	10000526 	beq	r2,zero,81130dc0 <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
81130dac:	e0bfff17 	ldw	r2,-4(fp)
81130db0:	00c00444 	movi	r3,17
81130db4:	10c00005 	stb	r3,0(r2)
        return (0);
81130db8:	0005883a 	mov	r2,zero
81130dbc:	00002106 	br	81130e44 <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
81130dc0:	e0bffd17 	ldw	r2,-12(fp)
81130dc4:	10800003 	ldbu	r2,0(r2)
81130dc8:	10803fcc 	andi	r2,r2,255
81130dcc:	10bfffc4 	addi	r2,r2,-1
81130dd0:	10800128 	cmpgeui	r2,r2,4
81130dd4:	10000526 	beq	r2,zero,81130dec <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81130dd8:	e0bfff17 	ldw	r2,-4(fp)
81130ddc:	00c00044 	movi	r3,1
81130de0:	10c00005 	stb	r3,0(r2)
             return (0);
81130de4:	0005883a 	mov	r2,zero
81130de8:	00001606 	br	81130e44 <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81130dec:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130df0:	0005303a 	rdctl	r2,status
81130df4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130df8:	e0fffb17 	ldw	r3,-20(fp)
81130dfc:	00bfff84 	movi	r2,-2
81130e00:	1884703a 	and	r2,r3,r2
81130e04:	1001703a 	wrctl	status,r2
  
  return context;
81130e08:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
81130e0c:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
81130e10:	e0bffd17 	ldw	r2,-12(fp)
81130e14:	10800444 	addi	r2,r2,17
81130e18:	100b883a 	mov	r5,r2
81130e1c:	e13ffe17 	ldw	r4,-8(fp)
81130e20:	113281c0 	call	8113281c <OS_StrCopy>
81130e24:	e0bffa05 	stb	r2,-24(fp)
81130e28:	e0bff917 	ldw	r2,-28(fp)
81130e2c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130e30:	e0bffc17 	ldw	r2,-16(fp)
81130e34:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81130e38:	e0bfff17 	ldw	r2,-4(fp)
81130e3c:	10000005 	stb	zero,0(r2)
    return (len);
81130e40:	e0bffa03 	ldbu	r2,-24(fp)
}
81130e44:	e037883a 	mov	sp,fp
81130e48:	dfc00117 	ldw	ra,4(sp)
81130e4c:	df000017 	ldw	fp,0(sp)
81130e50:	dec00204 	addi	sp,sp,8
81130e54:	f800283a 	ret

81130e58 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
81130e58:	defff604 	addi	sp,sp,-40
81130e5c:	de00012e 	bgeu	sp,et,81130e64 <OSEventNameSet+0xc>
81130e60:	003b68fa 	trap	3
81130e64:	dfc00915 	stw	ra,36(sp)
81130e68:	df000815 	stw	fp,32(sp)
81130e6c:	df000804 	addi	fp,sp,32
81130e70:	e13ffd15 	stw	r4,-12(fp)
81130e74:	e17ffe15 	stw	r5,-8(fp)
81130e78:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81130e7c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81130e80:	e0bfff17 	ldw	r2,-4(fp)
81130e84:	10004026 	beq	r2,zero,81130f88 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81130e88:	e0bffd17 	ldw	r2,-12(fp)
81130e8c:	1000041e 	bne	r2,zero,81130ea0 <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
81130e90:	e0bfff17 	ldw	r2,-4(fp)
81130e94:	00c00104 	movi	r3,4
81130e98:	10c00005 	stb	r3,0(r2)
        return;
81130e9c:	00003b06 	br	81130f8c <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81130ea0:	e0bffe17 	ldw	r2,-8(fp)
81130ea4:	1000041e 	bne	r2,zero,81130eb8 <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81130ea8:	e0bfff17 	ldw	r2,-4(fp)
81130eac:	00c00304 	movi	r3,12
81130eb0:	10c00005 	stb	r3,0(r2)
        return;
81130eb4:	00003506 	br	81130f8c <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81130eb8:	d0a0a003 	ldbu	r2,-32128(gp)
81130ebc:	10803fcc 	andi	r2,r2,255
81130ec0:	10000426 	beq	r2,zero,81130ed4 <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81130ec4:	e0bfff17 	ldw	r2,-4(fp)
81130ec8:	00c00484 	movi	r3,18
81130ecc:	10c00005 	stb	r3,0(r2)
        return;
81130ed0:	00002e06 	br	81130f8c <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
81130ed4:	e0bffd17 	ldw	r2,-12(fp)
81130ed8:	10800003 	ldbu	r2,0(r2)
81130edc:	10803fcc 	andi	r2,r2,255
81130ee0:	10bfffc4 	addi	r2,r2,-1
81130ee4:	10800128 	cmpgeui	r2,r2,4
81130ee8:	10000426 	beq	r2,zero,81130efc <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81130eec:	e0bfff17 	ldw	r2,-4(fp)
81130ef0:	00c00044 	movi	r3,1
81130ef4:	10c00005 	stb	r3,0(r2)
             return;
81130ef8:	00002406 	br	81130f8c <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81130efc:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81130f00:	0005303a 	rdctl	r2,status
81130f04:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81130f08:	e0fffc17 	ldw	r3,-16(fp)
81130f0c:	00bfff84 	movi	r2,-2
81130f10:	1884703a 	and	r2,r3,r2
81130f14:	1001703a 	wrctl	status,r2
  
  return context;
81130f18:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
81130f1c:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
81130f20:	e13ffe17 	ldw	r4,-8(fp)
81130f24:	11328980 	call	81132898 <OS_StrLen>
81130f28:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
81130f2c:	e0bffa03 	ldbu	r2,-24(fp)
81130f30:	10800830 	cmpltui	r2,r2,32
81130f34:	1000081e 	bne	r2,zero,81130f58 <OSEventNameSet+0x100>
81130f38:	e0bff817 	ldw	r2,-32(fp)
81130f3c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81130f40:	e0bff917 	ldw	r2,-28(fp)
81130f44:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
81130f48:	e0bfff17 	ldw	r2,-4(fp)
81130f4c:	00c002c4 	movi	r3,11
81130f50:	10c00005 	stb	r3,0(r2)
        return;
81130f54:	00000d06 	br	81130f8c <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
81130f58:	e0bffd17 	ldw	r2,-12(fp)
81130f5c:	10800444 	addi	r2,r2,17
81130f60:	e17ffe17 	ldw	r5,-8(fp)
81130f64:	1009883a 	mov	r4,r2
81130f68:	113281c0 	call	8113281c <OS_StrCopy>
81130f6c:	e0bff817 	ldw	r2,-32(fp)
81130f70:	e0bffb15 	stw	r2,-20(fp)
81130f74:	e0bffb17 	ldw	r2,-20(fp)
81130f78:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81130f7c:	e0bfff17 	ldw	r2,-4(fp)
81130f80:	10000005 	stb	zero,0(r2)
81130f84:	00000106 	br	81130f8c <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81130f88:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81130f8c:	e037883a 	mov	sp,fp
81130f90:	dfc00117 	ldw	ra,4(sp)
81130f94:	df000017 	ldw	fp,0(sp)
81130f98:	dec00204 	addi	sp,sp,8
81130f9c:	f800283a 	ret

81130fa0 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
81130fa0:	deffed04 	addi	sp,sp,-76
81130fa4:	de00012e 	bgeu	sp,et,81130fac <OSEventPendMulti+0xc>
81130fa8:	003b68fa 	trap	3
81130fac:	dfc01215 	stw	ra,72(sp)
81130fb0:	df001115 	stw	fp,68(sp)
81130fb4:	df001104 	addi	fp,sp,68
81130fb8:	e13ffc15 	stw	r4,-16(fp)
81130fbc:	e17ffd15 	stw	r5,-12(fp)
81130fc0:	e1bffe15 	stw	r6,-8(fp)
81130fc4:	3805883a 	mov	r2,r7
81130fc8:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
81130fcc:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
81130fd0:	e0800217 	ldw	r2,8(fp)
81130fd4:	1000021e 	bne	r2,zero,81130fe0 <OSEventPendMulti+0x40>
        return (0);
81130fd8:	0005883a 	mov	r2,zero
81130fdc:	00015006 	br	81131520 <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
81130fe0:	e0bffc17 	ldw	r2,-16(fp)
81130fe4:	1000051e 	bne	r2,zero,81130ffc <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
81130fe8:	e0800217 	ldw	r2,8(fp)
81130fec:	00c00104 	movi	r3,4
81130ff0:	10c00005 	stb	r3,0(r2)
        return (0);
81130ff4:	0005883a 	mov	r2,zero
81130ff8:	00014906 	br	81131520 <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
81130ffc:	e0bffd17 	ldw	r2,-12(fp)
81131000:	1000051e 	bne	r2,zero,81131018 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
81131004:	e0800217 	ldw	r2,8(fp)
81131008:	00c00104 	movi	r3,4
8113100c:	10c00005 	stb	r3,0(r2)
        return (0);
81131010:	0005883a 	mov	r2,zero
81131014:	00014206 	br	81131520 <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
81131018:	e0bffe17 	ldw	r2,-8(fp)
8113101c:	1000051e 	bne	r2,zero,81131034 <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
81131020:	e0800217 	ldw	r2,8(fp)
81131024:	00c00104 	movi	r3,4
81131028:	10c00005 	stb	r3,0(r2)
        return (0);
8113102c:	0005883a 	mov	r2,zero
81131030:	00013b06 	br	81131520 <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
81131034:	e0bffd17 	ldw	r2,-12(fp)
81131038:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
8113103c:	e0bffc17 	ldw	r2,-16(fp)
81131040:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
81131044:	e0bfef17 	ldw	r2,-68(fp)
81131048:	10800017 	ldw	r2,0(r2)
8113104c:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
81131050:	00001506 	br	811310a8 <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
81131054:	e0bff017 	ldw	r2,-64(fp)
81131058:	10800003 	ldbu	r2,0(r2)
8113105c:	10803fcc 	andi	r2,r2,255
81131060:	10c000a0 	cmpeqi	r3,r2,2
81131064:	1800071e 	bne	r3,zero,81131084 <OSEventPendMulti+0xe4>
81131068:	108000e0 	cmpeqi	r2,r2,3
8113106c:	1000071e 	bne	r2,zero,8113108c <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
81131070:	e0800217 	ldw	r2,8(fp)
81131074:	00c00044 	movi	r3,1
81131078:	10c00005 	stb	r3,0(r2)
                 return (0);
8113107c:	0005883a 	mov	r2,zero
81131080:	00012706 	br	81131520 <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
81131084:	0001883a 	nop
81131088:	00000106 	br	81131090 <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
8113108c:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
81131090:	e0bfef17 	ldw	r2,-68(fp)
81131094:	10800104 	addi	r2,r2,4
81131098:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
8113109c:	e0bfef17 	ldw	r2,-68(fp)
811310a0:	10800017 	ldw	r2,0(r2)
811310a4:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
811310a8:	e0bff017 	ldw	r2,-64(fp)
811310ac:	103fe91e 	bne	r2,zero,81131054 <__reset+0xfb111054>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
811310b0:	d0a0a003 	ldbu	r2,-32128(gp)
811310b4:	10803fcc 	andi	r2,r2,255
811310b8:	10000526 	beq	r2,zero,811310d0 <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
811310bc:	e0800217 	ldw	r2,8(fp)
811310c0:	00c00084 	movi	r3,2
811310c4:	10c00005 	stb	r3,0(r2)
        return (0);
811310c8:	0005883a 	mov	r2,zero
811310cc:	00011406 	br	81131520 <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
811310d0:	d0a08e03 	ldbu	r2,-32200(gp)
811310d4:	10803fcc 	andi	r2,r2,255
811310d8:	10000526 	beq	r2,zero,811310f0 <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
811310dc:	e0800217 	ldw	r2,8(fp)
811310e0:	00c00344 	movi	r3,13
811310e4:	10c00005 	stb	r3,0(r2)
        return (0);
811310e8:	0005883a 	mov	r2,zero
811310ec:	00010c06 	br	81131520 <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811310f0:	0005303a 	rdctl	r2,status
811310f4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811310f8:	e0fffb17 	ldw	r3,-20(fp)
811310fc:	00bfff84 	movi	r2,-2
81131100:	1884703a 	and	r2,r3,r2
81131104:	1001703a 	wrctl	status,r2
  
  return context;
81131108:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
8113110c:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
81131110:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
81131114:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
81131118:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
8113111c:	e0bffc17 	ldw	r2,-16(fp)
81131120:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
81131124:	e0bfef17 	ldw	r2,-68(fp)
81131128:	10800017 	ldw	r2,0(r2)
8113112c:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
81131130:	00006406 	br	811312c4 <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
81131134:	e0bff017 	ldw	r2,-64(fp)
81131138:	10800003 	ldbu	r2,0(r2)
8113113c:	10803fcc 	andi	r2,r2,255
81131140:	10c000a0 	cmpeqi	r3,r2,2
81131144:	18001f1e 	bne	r3,zero,811311c4 <OSEventPendMulti+0x224>
81131148:	108000e0 	cmpeqi	r2,r2,3
8113114c:	10004c26 	beq	r2,zero,81131280 <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
81131150:	e0bff017 	ldw	r2,-64(fp)
81131154:	1080020b 	ldhu	r2,8(r2)
81131158:	10bfffcc 	andi	r2,r2,65535
8113115c:	10001526 	beq	r2,zero,811311b4 <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
81131160:	e0bff017 	ldw	r2,-64(fp)
81131164:	1080020b 	ldhu	r2,8(r2)
81131168:	10bfffc4 	addi	r2,r2,-1
8113116c:	1007883a 	mov	r3,r2
81131170:	e0bff017 	ldw	r2,-64(fp)
81131174:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
81131178:	e0bffd17 	ldw	r2,-12(fp)
8113117c:	10c00104 	addi	r3,r2,4
81131180:	e0fffd15 	stw	r3,-12(fp)
81131184:	e0fff017 	ldw	r3,-64(fp)
81131188:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
8113118c:	00800044 	movi	r2,1
81131190:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
81131194:	e0bffe17 	ldw	r2,-8(fp)
81131198:	10c00104 	addi	r3,r2,4
8113119c:	e0fffe15 	stw	r3,-8(fp)
811311a0:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
811311a4:	e0bff18b 	ldhu	r2,-58(fp)
811311a8:	10800044 	addi	r2,r2,1
811311ac:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
811311b0:	00003e06 	br	811312ac <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
811311b4:	e0bff203 	ldbu	r2,-56(fp)
811311b8:	10800054 	ori	r2,r2,1
811311bc:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
811311c0:	00003a06 	br	811312ac <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
811311c4:	e0bff017 	ldw	r2,-64(fp)
811311c8:	10800117 	ldw	r2,4(r2)
811311cc:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
811311d0:	e0bff517 	ldw	r2,-44(fp)
811311d4:	1080058b 	ldhu	r2,22(r2)
811311d8:	10bfffcc 	andi	r2,r2,65535
811311dc:	10002426 	beq	r2,zero,81131270 <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
811311e0:	e0bffe17 	ldw	r2,-8(fp)
811311e4:	10c00104 	addi	r3,r2,4
811311e8:	e0fffe15 	stw	r3,-8(fp)
811311ec:	e0fff517 	ldw	r3,-44(fp)
811311f0:	18c00417 	ldw	r3,16(r3)
811311f4:	19400104 	addi	r5,r3,4
811311f8:	e13ff517 	ldw	r4,-44(fp)
811311fc:	21400415 	stw	r5,16(r4)
81131200:	18c00017 	ldw	r3,0(r3)
81131204:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
81131208:	e0bff517 	ldw	r2,-44(fp)
8113120c:	10c00417 	ldw	r3,16(r2)
81131210:	e0bff517 	ldw	r2,-44(fp)
81131214:	10800217 	ldw	r2,8(r2)
81131218:	1880041e 	bne	r3,r2,8113122c <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
8113121c:	e0bff517 	ldw	r2,-44(fp)
81131220:	10c00117 	ldw	r3,4(r2)
81131224:	e0bff517 	ldw	r2,-44(fp)
81131228:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
8113122c:	e0bff517 	ldw	r2,-44(fp)
81131230:	1080058b 	ldhu	r2,22(r2)
81131234:	10bfffc4 	addi	r2,r2,-1
81131238:	1007883a 	mov	r3,r2
8113123c:	e0bff517 	ldw	r2,-44(fp)
81131240:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
81131244:	e0bffd17 	ldw	r2,-12(fp)
81131248:	10c00104 	addi	r3,r2,4
8113124c:	e0fffd15 	stw	r3,-12(fp)
81131250:	e0fff017 	ldw	r3,-64(fp)
81131254:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
81131258:	00800044 	movi	r2,1
8113125c:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
81131260:	e0bff18b 	ldhu	r2,-58(fp)
81131264:	10800044 	addi	r2,r2,1
81131268:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
8113126c:	00000f06 	br	811312ac <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
81131270:	e0bff203 	ldbu	r2,-56(fp)
81131274:	10800114 	ori	r2,r2,4
81131278:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
8113127c:	00000b06 	br	811312ac <OSEventPendMulti+0x30c>
81131280:	e0bff317 	ldw	r2,-52(fp)
81131284:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131288:	e0bff417 	ldw	r2,-48(fp)
8113128c:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
81131290:	e0bffd17 	ldw	r2,-12(fp)
81131294:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
81131298:	e0800217 	ldw	r2,8(fp)
8113129c:	00c00044 	movi	r3,1
811312a0:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
811312a4:	e0bff18b 	ldhu	r2,-58(fp)
811312a8:	00009d06 	br	81131520 <OSEventPendMulti+0x580>
        }
        pevents++;
811312ac:	e0bfef17 	ldw	r2,-68(fp)
811312b0:	10800104 	addi	r2,r2,4
811312b4:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
811312b8:	e0bfef17 	ldw	r2,-68(fp)
811312bc:	10800017 	ldw	r2,0(r2)
811312c0:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
811312c4:	e0bff017 	ldw	r2,-64(fp)
811312c8:	103f9a1e 	bne	r2,zero,81131134 <__reset+0xfb111134>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
811312cc:	e0bff103 	ldbu	r2,-60(fp)
811312d0:	10800058 	cmpnei	r2,r2,1
811312d4:	10000a1e 	bne	r2,zero,81131300 <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
811312d8:	e0bffd17 	ldw	r2,-12(fp)
811312dc:	10000015 	stw	zero,0(r2)
811312e0:	e0bff317 	ldw	r2,-52(fp)
811312e4:	e0bff615 	stw	r2,-40(fp)
811312e8:	e0bff617 	ldw	r2,-40(fp)
811312ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
811312f0:	e0800217 	ldw	r2,8(fp)
811312f4:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
811312f8:	e0bff18b 	ldhu	r2,-58(fp)
811312fc:	00008806 	br	81131520 <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
81131300:	d0a0a117 	ldw	r2,-32124(gp)
81131304:	d0e0a117 	ldw	r3,-32124(gp)
81131308:	19000c03 	ldbu	r4,48(r3)
8113130c:	e0fff203 	ldbu	r3,-56(fp)
81131310:	20c6b03a 	or	r3,r4,r3
81131314:	1809883a 	mov	r4,r3
81131318:	00ffe004 	movi	r3,-128
8113131c:	20c6b03a 	or	r3,r4,r3
81131320:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81131324:	d0a0a117 	ldw	r2,-32124(gp)
81131328:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
8113132c:	d0a0a117 	ldw	r2,-32124(gp)
81131330:	e0ffff0b 	ldhu	r3,-4(fp)
81131334:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
81131338:	e13ffc17 	ldw	r4,-16(fp)
8113133c:	1131ec40 	call	81131ec4 <OS_EventTaskWaitMulti>
81131340:	e0bff317 	ldw	r2,-52(fp)
81131344:	e0bff915 	stw	r2,-28(fp)
81131348:	e0bff917 	ldw	r2,-28(fp)
8113134c:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
81131350:	11326c80 	call	811326c8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131354:	0005303a 	rdctl	r2,status
81131358:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113135c:	e0fff717 	ldw	r3,-36(fp)
81131360:	00bfff84 	movi	r2,-2
81131364:	1884703a 	and	r2,r3,r2
81131368:	1001703a 	wrctl	status,r2
  
  return context;
8113136c:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
81131370:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
81131374:	d0a0a117 	ldw	r2,-32124(gp)
81131378:	10800c43 	ldbu	r2,49(r2)
8113137c:	10803fcc 	andi	r2,r2,255
81131380:	10000226 	beq	r2,zero,8113138c <OSEventPendMulti+0x3ec>
81131384:	108000a0 	cmpeqi	r2,r2,2
81131388:	10001826 	beq	r2,zero,811313ec <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
8113138c:	d0a0a117 	ldw	r2,-32124(gp)
81131390:	10800717 	ldw	r2,28(r2)
81131394:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
81131398:	e0bff017 	ldw	r2,-64(fp)
8113139c:	10000b26 	beq	r2,zero,811313cc <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
811313a0:	e0bffd17 	ldw	r2,-12(fp)
811313a4:	10c00104 	addi	r3,r2,4
811313a8:	e0fffd15 	stw	r3,-12(fp)
811313ac:	e0fff017 	ldw	r3,-64(fp)
811313b0:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
811313b4:	e0bffd17 	ldw	r2,-12(fp)
811313b8:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
811313bc:	e0bff18b 	ldhu	r2,-58(fp)
811313c0:	10800044 	addi	r2,r2,1
811313c4:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
811313c8:	00000d06 	br	81131400 <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
811313cc:	d0a0a117 	ldw	r2,-32124(gp)
811313d0:	00c00044 	movi	r3,1
811313d4:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
811313d8:	d0a0a117 	ldw	r2,-32124(gp)
811313dc:	e17ffc17 	ldw	r5,-16(fp)
811313e0:	1009883a 	mov	r4,r2
811313e4:	11320dc0 	call	811320dc <OS_EventTaskRemoveMulti>
             }
			 break;
811313e8:	00000506 	br	81131400 <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
811313ec:	d0a0a117 	ldw	r2,-32124(gp)
811313f0:	e17ffc17 	ldw	r5,-16(fp)
811313f4:	1009883a 	mov	r4,r2
811313f8:	11320dc0 	call	811320dc <OS_EventTaskRemoveMulti>
             break;
811313fc:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
81131400:	d0a0a117 	ldw	r2,-32124(gp)
81131404:	10800c43 	ldbu	r2,49(r2)
81131408:	10803fcc 	andi	r2,r2,255
8113140c:	10000326 	beq	r2,zero,8113141c <OSEventPendMulti+0x47c>
81131410:	108000a0 	cmpeqi	r2,r2,2
81131414:	1000231e 	bne	r2,zero,811314a4 <OSEventPendMulti+0x504>
81131418:	00002a06 	br	811314c4 <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
8113141c:	e0bff017 	ldw	r2,-64(fp)
81131420:	10800003 	ldbu	r2,0(r2)
81131424:	10803fcc 	andi	r2,r2,255
81131428:	0080100e 	bge	zero,r2,8113146c <OSEventPendMulti+0x4cc>
8113142c:	10c000d0 	cmplti	r3,r2,3
81131430:	1800071e 	bne	r3,zero,81131450 <OSEventPendMulti+0x4b0>
81131434:	108000e0 	cmpeqi	r2,r2,3
81131438:	10000c26 	beq	r2,zero,8113146c <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
8113143c:	e0bffe17 	ldw	r2,-8(fp)
81131440:	10c00104 	addi	r3,r2,4
81131444:	e0fffe15 	stw	r3,-8(fp)
81131448:	10000015 	stw	zero,0(r2)
                      break;
8113144c:	00001206 	br	81131498 <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
81131450:	e0bffe17 	ldw	r2,-8(fp)
81131454:	10c00104 	addi	r3,r2,4
81131458:	e0fffe15 	stw	r3,-8(fp)
8113145c:	d0e0a117 	ldw	r3,-32124(gp)
81131460:	18c00917 	ldw	r3,36(r3)
81131464:	10c00015 	stw	r3,0(r2)
                      break;
81131468:	00000b06 	br	81131498 <OSEventPendMulti+0x4f8>
8113146c:	e0bff317 	ldw	r2,-52(fp)
81131470:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131474:	e0bff817 	ldw	r2,-32(fp)
81131478:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
8113147c:	e0bffd17 	ldw	r2,-12(fp)
81131480:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
81131484:	e0800217 	ldw	r2,8(fp)
81131488:	00c00044 	movi	r3,1
8113148c:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
81131490:	e0bff18b 	ldhu	r2,-58(fp)
81131494:	00002206 	br	81131520 <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
81131498:	e0800217 	ldw	r2,8(fp)
8113149c:	10000005 	stb	zero,0(r2)
             break;
811314a0:	00001006 	br	811314e4 <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
811314a4:	e0bffe17 	ldw	r2,-8(fp)
811314a8:	10c00104 	addi	r3,r2,4
811314ac:	e0fffe15 	stw	r3,-8(fp)
811314b0:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
811314b4:	e0800217 	ldw	r2,8(fp)
811314b8:	00c00384 	movi	r3,14
811314bc:	10c00005 	stb	r3,0(r2)
             break;
811314c0:	00000806 	br	811314e4 <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
811314c4:	e0bffe17 	ldw	r2,-8(fp)
811314c8:	10c00104 	addi	r3,r2,4
811314cc:	e0fffe15 	stw	r3,-8(fp)
811314d0:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
811314d4:	e0800217 	ldw	r2,8(fp)
811314d8:	00c00284 	movi	r3,10
811314dc:	10c00005 	stb	r3,0(r2)
             break;
811314e0:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
811314e4:	d0a0a117 	ldw	r2,-32124(gp)
811314e8:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
811314ec:	d0a0a117 	ldw	r2,-32124(gp)
811314f0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
811314f4:	d0a0a117 	ldw	r2,-32124(gp)
811314f8:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
811314fc:	d0a0a117 	ldw	r2,-32124(gp)
81131500:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
81131504:	d0a0a117 	ldw	r2,-32124(gp)
81131508:	10000915 	stw	zero,36(r2)
8113150c:	e0bff317 	ldw	r2,-52(fp)
81131510:	e0bffa15 	stw	r2,-24(fp)
81131514:	e0bffa17 	ldw	r2,-24(fp)
81131518:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
8113151c:	e0bff18b 	ldhu	r2,-58(fp)
}
81131520:	e037883a 	mov	sp,fp
81131524:	dfc00117 	ldw	ra,4(sp)
81131528:	df000017 	ldw	fp,0(sp)
8113152c:	dec00204 	addi	sp,sp,8
81131530:	f800283a 	ret

81131534 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
81131534:	defffe04 	addi	sp,sp,-8
81131538:	de00012e 	bgeu	sp,et,81131540 <OSInit+0xc>
8113153c:	003b68fa 	trap	3
81131540:	dfc00115 	stw	ra,4(sp)
81131544:	df000015 	stw	fp,0(sp)
81131548:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
8113154c:	1143ab00 	call	81143ab0 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
81131550:	113233c0 	call	8113233c <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
81131554:	113238c0 	call	8113238c <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
81131558:	11325100 	call	81132510 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
8113155c:	11322540 	call	81132254 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
81131560:	11344d00 	call	811344d0 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
81131564:	1134e180 	call	81134e18 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
81131568:	11370e80 	call	811370e8 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
8113156c:	11324000 	call	81132400 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
81131570:	11324880 	call	81132488 <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
81131574:	113a48c0 	call	8113a48c <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
81131578:	1143adc0 	call	81143adc <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
8113157c:	1132dec0 	call	81132dec <OSDebugInit>
#endif
}
81131580:	0001883a 	nop
81131584:	e037883a 	mov	sp,fp
81131588:	dfc00117 	ldw	ra,4(sp)
8113158c:	df000017 	ldw	fp,0(sp)
81131590:	dec00204 	addi	sp,sp,8
81131594:	f800283a 	ret

81131598 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
81131598:	deffff04 	addi	sp,sp,-4
8113159c:	de00012e 	bgeu	sp,et,811315a4 <OSIntEnter+0xc>
811315a0:	003b68fa 	trap	3
811315a4:	df000015 	stw	fp,0(sp)
811315a8:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
811315ac:	d0a09003 	ldbu	r2,-32192(gp)
811315b0:	10803fcc 	andi	r2,r2,255
811315b4:	10800058 	cmpnei	r2,r2,1
811315b8:	1000071e 	bne	r2,zero,811315d8 <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
811315bc:	d0a0a003 	ldbu	r2,-32128(gp)
811315c0:	10803fcc 	andi	r2,r2,255
811315c4:	10803fe0 	cmpeqi	r2,r2,255
811315c8:	1000031e 	bne	r2,zero,811315d8 <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
811315cc:	d0a0a003 	ldbu	r2,-32128(gp)
811315d0:	10800044 	addi	r2,r2,1
811315d4:	d0a0a005 	stb	r2,-32128(gp)
        }
    }
}
811315d8:	0001883a 	nop
811315dc:	e037883a 	mov	sp,fp
811315e0:	df000017 	ldw	fp,0(sp)
811315e4:	dec00104 	addi	sp,sp,4
811315e8:	f800283a 	ret

811315ec <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
811315ec:	defffb04 	addi	sp,sp,-20
811315f0:	de00012e 	bgeu	sp,et,811315f8 <OSIntExit+0xc>
811315f4:	003b68fa 	trap	3
811315f8:	dfc00415 	stw	ra,16(sp)
811315fc:	df000315 	stw	fp,12(sp)
81131600:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81131604:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
81131608:	d0a09003 	ldbu	r2,-32192(gp)
8113160c:	10803fcc 	andi	r2,r2,255
81131610:	10800058 	cmpnei	r2,r2,1
81131614:	10002f1e 	bne	r2,zero,811316d4 <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131618:	0005303a 	rdctl	r2,status
8113161c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131620:	e0ffff17 	ldw	r3,-4(fp)
81131624:	00bfff84 	movi	r2,-2
81131628:	1884703a 	and	r2,r3,r2
8113162c:	1001703a 	wrctl	status,r2
  
  return context;
81131630:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81131634:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
81131638:	d0a0a003 	ldbu	r2,-32128(gp)
8113163c:	10803fcc 	andi	r2,r2,255
81131640:	10000326 	beq	r2,zero,81131650 <OSIntExit+0x64>
            OSIntNesting--;
81131644:	d0a0a003 	ldbu	r2,-32128(gp)
81131648:	10bfffc4 	addi	r2,r2,-1
8113164c:	d0a0a005 	stb	r2,-32128(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
81131650:	d0a0a003 	ldbu	r2,-32128(gp)
81131654:	10803fcc 	andi	r2,r2,255
81131658:	10001a1e 	bne	r2,zero,811316c4 <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
8113165c:	d0a08e03 	ldbu	r2,-32200(gp)
81131660:	10803fcc 	andi	r2,r2,255
81131664:	1000171e 	bne	r2,zero,811316c4 <OSIntExit+0xd8>
                OS_SchedNew();
81131668:	11327a00 	call	811327a0 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
8113166c:	d0e09283 	ldbu	r3,-32182(gp)
81131670:	d0a092c3 	ldbu	r2,-32181(gp)
81131674:	18c03fcc 	andi	r3,r3,255
81131678:	10803fcc 	andi	r2,r2,255
8113167c:	18801126 	beq	r3,r2,811316c4 <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
81131680:	d0a09283 	ldbu	r2,-32182(gp)
81131684:	10c03fcc 	andi	r3,r2,255
81131688:	00a045b4 	movhi	r2,33046
8113168c:	1084d804 	addi	r2,r2,4960
81131690:	18c7883a 	add	r3,r3,r3
81131694:	18c7883a 	add	r3,r3,r3
81131698:	10c5883a 	add	r2,r2,r3
8113169c:	10800017 	ldw	r2,0(r2)
811316a0:	d0a09b15 	stw	r2,-32148(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
811316a4:	d0a09b17 	ldw	r2,-32148(gp)
811316a8:	10c00e17 	ldw	r3,56(r2)
811316ac:	18c00044 	addi	r3,r3,1
811316b0:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
811316b4:	d0a09517 	ldw	r2,-32172(gp)
811316b8:	10800044 	addi	r2,r2,1
811316bc:	d0a09515 	stw	r2,-32172(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
811316c0:	11437700 	call	81143770 <OSCtxSw>
811316c4:	e0bffd17 	ldw	r2,-12(fp)
811316c8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811316cc:	e0bffe17 	ldw	r2,-8(fp)
811316d0:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
811316d4:	0001883a 	nop
811316d8:	e037883a 	mov	sp,fp
811316dc:	dfc00117 	ldw	ra,4(sp)
811316e0:	df000017 	ldw	fp,0(sp)
811316e4:	dec00204 	addi	sp,sp,8
811316e8:	f800283a 	ret

811316ec <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
811316ec:	defffc04 	addi	sp,sp,-16
811316f0:	de00012e 	bgeu	sp,et,811316f8 <OSSchedLock+0xc>
811316f4:	003b68fa 	trap	3
811316f8:	df000315 	stw	fp,12(sp)
811316fc:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81131700:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
81131704:	d0a09003 	ldbu	r2,-32192(gp)
81131708:	10803fcc 	andi	r2,r2,255
8113170c:	10800058 	cmpnei	r2,r2,1
81131710:	1000161e 	bne	r2,zero,8113176c <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131714:	0005303a 	rdctl	r2,status
81131718:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113171c:	e0ffff17 	ldw	r3,-4(fp)
81131720:	00bfff84 	movi	r2,-2
81131724:	1884703a 	and	r2,r3,r2
81131728:	1001703a 	wrctl	status,r2
  
  return context;
8113172c:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81131730:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
81131734:	d0a0a003 	ldbu	r2,-32128(gp)
81131738:	10803fcc 	andi	r2,r2,255
8113173c:	1000071e 	bne	r2,zero,8113175c <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
81131740:	d0a08e03 	ldbu	r2,-32200(gp)
81131744:	10803fcc 	andi	r2,r2,255
81131748:	10803fe0 	cmpeqi	r2,r2,255
8113174c:	1000031e 	bne	r2,zero,8113175c <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
81131750:	d0a08e03 	ldbu	r2,-32200(gp)
81131754:	10800044 	addi	r2,r2,1
81131758:	d0a08e05 	stb	r2,-32200(gp)
8113175c:	e0bffd17 	ldw	r2,-12(fp)
81131760:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131764:	e0bffe17 	ldw	r2,-8(fp)
81131768:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
8113176c:	0001883a 	nop
81131770:	e037883a 	mov	sp,fp
81131774:	df000017 	ldw	fp,0(sp)
81131778:	dec00104 	addi	sp,sp,4
8113177c:	f800283a 	ret

81131780 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
81131780:	defff804 	addi	sp,sp,-32
81131784:	de00012e 	bgeu	sp,et,8113178c <OSSchedUnlock+0xc>
81131788:	003b68fa 	trap	3
8113178c:	dfc00715 	stw	ra,28(sp)
81131790:	df000615 	stw	fp,24(sp)
81131794:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81131798:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
8113179c:	d0a09003 	ldbu	r2,-32192(gp)
811317a0:	10803fcc 	andi	r2,r2,255
811317a4:	10800058 	cmpnei	r2,r2,1
811317a8:	1000281e 	bne	r2,zero,8113184c <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811317ac:	0005303a 	rdctl	r2,status
811317b0:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811317b4:	e0ffff17 	ldw	r3,-4(fp)
811317b8:	00bfff84 	movi	r2,-2
811317bc:	1884703a 	and	r2,r3,r2
811317c0:	1001703a 	wrctl	status,r2
  
  return context;
811317c4:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
811317c8:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
811317cc:	d0a08e03 	ldbu	r2,-32200(gp)
811317d0:	10803fcc 	andi	r2,r2,255
811317d4:	10001926 	beq	r2,zero,8113183c <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
811317d8:	d0a08e03 	ldbu	r2,-32200(gp)
811317dc:	10bfffc4 	addi	r2,r2,-1
811317e0:	d0a08e05 	stb	r2,-32200(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
811317e4:	d0a08e03 	ldbu	r2,-32200(gp)
811317e8:	10803fcc 	andi	r2,r2,255
811317ec:	10000e1e 	bne	r2,zero,81131828 <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
811317f0:	d0a0a003 	ldbu	r2,-32128(gp)
811317f4:	10803fcc 	andi	r2,r2,255
811317f8:	1000061e 	bne	r2,zero,81131814 <OSSchedUnlock+0x94>
811317fc:	e0bffa17 	ldw	r2,-24(fp)
81131800:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131804:	e0bffb17 	ldw	r2,-20(fp)
81131808:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
8113180c:	11326c80 	call	811326c8 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
81131810:	00000e06 	br	8113184c <OSSchedUnlock+0xcc>
81131814:	e0bffa17 	ldw	r2,-24(fp)
81131818:	e0bffc15 	stw	r2,-16(fp)
8113181c:	e0bffc17 	ldw	r2,-16(fp)
81131820:	1001703a 	wrctl	status,r2
81131824:	00000906 	br	8113184c <OSSchedUnlock+0xcc>
81131828:	e0bffa17 	ldw	r2,-24(fp)
8113182c:	e0bffd15 	stw	r2,-12(fp)
81131830:	e0bffd17 	ldw	r2,-12(fp)
81131834:	1001703a 	wrctl	status,r2
81131838:	00000406 	br	8113184c <OSSchedUnlock+0xcc>
8113183c:	e0bffa17 	ldw	r2,-24(fp)
81131840:	e0bffe15 	stw	r2,-8(fp)
81131844:	e0bffe17 	ldw	r2,-8(fp)
81131848:	1001703a 	wrctl	status,r2
8113184c:	0001883a 	nop
81131850:	e037883a 	mov	sp,fp
81131854:	dfc00117 	ldw	ra,4(sp)
81131858:	df000017 	ldw	fp,0(sp)
8113185c:	dec00204 	addi	sp,sp,8
81131860:	f800283a 	ret

81131864 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
81131864:	defffe04 	addi	sp,sp,-8
81131868:	de00012e 	bgeu	sp,et,81131870 <OSStart+0xc>
8113186c:	003b68fa 	trap	3
81131870:	dfc00115 	stw	ra,4(sp)
81131874:	df000015 	stw	fp,0(sp)
81131878:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
8113187c:	d0a09003 	ldbu	r2,-32192(gp)
81131880:	10803fcc 	andi	r2,r2,255
81131884:	10000f1e 	bne	r2,zero,811318c4 <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
81131888:	11327a00 	call	811327a0 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
8113188c:	d0a09283 	ldbu	r2,-32182(gp)
81131890:	d0a092c5 	stb	r2,-32181(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
81131894:	d0a09283 	ldbu	r2,-32182(gp)
81131898:	10c03fcc 	andi	r3,r2,255
8113189c:	00a045b4 	movhi	r2,33046
811318a0:	1084d804 	addi	r2,r2,4960
811318a4:	18c7883a 	add	r3,r3,r3
811318a8:	18c7883a 	add	r3,r3,r3
811318ac:	10c5883a 	add	r2,r2,r3
811318b0:	10800017 	ldw	r2,0(r2)
811318b4:	d0a09b15 	stw	r2,-32148(gp)
        OSTCBCur      = OSTCBHighRdy;
811318b8:	d0a09b17 	ldw	r2,-32148(gp)
811318bc:	d0a0a115 	stw	r2,-32124(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
811318c0:	114380c0 	call	8114380c <OSStartHighRdy>
    }
}
811318c4:	0001883a 	nop
811318c8:	e037883a 	mov	sp,fp
811318cc:	dfc00117 	ldw	ra,4(sp)
811318d0:	df000017 	ldw	fp,0(sp)
811318d4:	dec00204 	addi	sp,sp,8
811318d8:	f800283a 	ret

811318dc <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
811318dc:	defff904 	addi	sp,sp,-28
811318e0:	de00012e 	bgeu	sp,et,811318e8 <OSStatInit+0xc>
811318e4:	003b68fa 	trap	3
811318e8:	dfc00615 	stw	ra,24(sp)
811318ec:	df000515 	stw	fp,20(sp)
811318f0:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811318f4:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
811318f8:	01000084 	movi	r4,2
811318fc:	11394040 	call	81139404 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131900:	0005303a 	rdctl	r2,status
81131904:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131908:	e0fffc17 	ldw	r3,-16(fp)
8113190c:	00bfff84 	movi	r2,-2
81131910:	1884703a 	and	r2,r3,r2
81131914:	1001703a 	wrctl	status,r2
  
  return context;
81131918:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
8113191c:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
81131920:	d0209115 	stw	zero,-32188(gp)
81131924:	e0bffb17 	ldw	r2,-20(fp)
81131928:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113192c:	e0bffd17 	ldw	r2,-12(fp)
81131930:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
81131934:	01001904 	movi	r4,100
81131938:	11394040 	call	81139404 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113193c:	0005303a 	rdctl	r2,status
81131940:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131944:	e0fffe17 	ldw	r3,-8(fp)
81131948:	00bfff84 	movi	r2,-2
8113194c:	1884703a 	and	r2,r3,r2
81131950:	1001703a 	wrctl	status,r2
  
  return context;
81131954:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
81131958:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
8113195c:	d0a09117 	ldw	r2,-32188(gp)
81131960:	d0a09715 	stw	r2,-32164(gp)
    OSStatRdy    = OS_TRUE;
81131964:	00800044 	movi	r2,1
81131968:	d0a0a605 	stb	r2,-32104(gp)
8113196c:	e0bffb17 	ldw	r2,-20(fp)
81131970:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131974:	e0bfff17 	ldw	r2,-4(fp)
81131978:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
8113197c:	0001883a 	nop
81131980:	e037883a 	mov	sp,fp
81131984:	dfc00117 	ldw	ra,4(sp)
81131988:	df000017 	ldw	fp,0(sp)
8113198c:	dec00204 	addi	sp,sp,8
81131990:	f800283a 	ret

81131994 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
81131994:	defff704 	addi	sp,sp,-36
81131998:	de00012e 	bgeu	sp,et,811319a0 <OSTimeTick+0xc>
8113199c:	003b68fa 	trap	3
811319a0:	dfc00815 	stw	ra,32(sp)
811319a4:	df000715 	stw	fp,28(sp)
811319a8:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
811319ac:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
811319b0:	1143a5c0 	call	81143a5c <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811319b4:	0005303a 	rdctl	r2,status
811319b8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811319bc:	e0fffd17 	ldw	r3,-12(fp)
811319c0:	00bfff84 	movi	r2,-2
811319c4:	1884703a 	and	r2,r3,r2
811319c8:	1001703a 	wrctl	status,r2
  
  return context;
811319cc:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
811319d0:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
811319d4:	d0a0a317 	ldw	r2,-32116(gp)
811319d8:	10800044 	addi	r2,r2,1
811319dc:	d0a0a315 	stw	r2,-32116(gp)
811319e0:	e0bffb17 	ldw	r2,-20(fp)
811319e4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811319e8:	e0bfff17 	ldw	r2,-4(fp)
811319ec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
811319f0:	d0a09003 	ldbu	r2,-32192(gp)
811319f4:	10803fcc 	andi	r2,r2,255
811319f8:	10800058 	cmpnei	r2,r2,1
811319fc:	10006a1e 	bne	r2,zero,81131ba8 <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
81131a00:	d0a09403 	ldbu	r2,-32176(gp)
81131a04:	10803fcc 	andi	r2,r2,255
81131a08:	10c00060 	cmpeqi	r3,r2,1
81131a0c:	1800061e 	bne	r3,zero,81131a28 <OSTimeTick+0x94>
81131a10:	10c000a0 	cmpeqi	r3,r2,2
81131a14:	1800061e 	bne	r3,zero,81131a30 <OSTimeTick+0x9c>
81131a18:	10000a1e 	bne	r2,zero,81131a44 <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
81131a1c:	00800044 	movi	r2,1
81131a20:	e0bffa05 	stb	r2,-24(fp)
                 break;
81131a24:	00000b06 	br	81131a54 <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
81131a28:	e03ffa05 	stb	zero,-24(fp)
                 break;
81131a2c:	00000906 	br	81131a54 <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
81131a30:	00800044 	movi	r2,1
81131a34:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
81131a38:	00800044 	movi	r2,1
81131a3c:	d0a09405 	stb	r2,-32176(gp)
                 break;
81131a40:	00000406 	br	81131a54 <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
81131a44:	00800044 	movi	r2,1
81131a48:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
81131a4c:	d0209405 	stb	zero,-32176(gp)
                 break;
81131a50:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
81131a54:	e0bffa03 	ldbu	r2,-24(fp)
81131a58:	10005226 	beq	r2,zero,81131ba4 <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
81131a5c:	d0a09317 	ldw	r2,-32180(gp)
81131a60:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
81131a64:	00004906 	br	81131b8c <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81131a68:	0005303a 	rdctl	r2,status
81131a6c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81131a70:	e0fffc17 	ldw	r3,-16(fp)
81131a74:	00bfff84 	movi	r2,-2
81131a78:	1884703a 	and	r2,r3,r2
81131a7c:	1001703a 	wrctl	status,r2
  
  return context;
81131a80:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
81131a84:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
81131a88:	e0bff917 	ldw	r2,-28(fp)
81131a8c:	10800b8b 	ldhu	r2,46(r2)
81131a90:	10bfffcc 	andi	r2,r2,65535
81131a94:	10003626 	beq	r2,zero,81131b70 <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
81131a98:	e0bff917 	ldw	r2,-28(fp)
81131a9c:	10800b8b 	ldhu	r2,46(r2)
81131aa0:	10bfffc4 	addi	r2,r2,-1
81131aa4:	1007883a 	mov	r3,r2
81131aa8:	e0bff917 	ldw	r2,-28(fp)
81131aac:	10c00b8d 	sth	r3,46(r2)
81131ab0:	e0bff917 	ldw	r2,-28(fp)
81131ab4:	10800b8b 	ldhu	r2,46(r2)
81131ab8:	10bfffcc 	andi	r2,r2,65535
81131abc:	10002c1e 	bne	r2,zero,81131b70 <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81131ac0:	e0bff917 	ldw	r2,-28(fp)
81131ac4:	10800c03 	ldbu	r2,48(r2)
81131ac8:	10803fcc 	andi	r2,r2,255
81131acc:	10800dcc 	andi	r2,r2,55
81131ad0:	10000b26 	beq	r2,zero,81131b00 <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
81131ad4:	e0bff917 	ldw	r2,-28(fp)
81131ad8:	10c00c03 	ldbu	r3,48(r2)
81131adc:	00bff204 	movi	r2,-56
81131ae0:	1884703a 	and	r2,r3,r2
81131ae4:	1007883a 	mov	r3,r2
81131ae8:	e0bff917 	ldw	r2,-28(fp)
81131aec:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
81131af0:	e0bff917 	ldw	r2,-28(fp)
81131af4:	00c00044 	movi	r3,1
81131af8:	10c00c45 	stb	r3,49(r2)
81131afc:	00000206 	br	81131b08 <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
81131b00:	e0bff917 	ldw	r2,-28(fp)
81131b04:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
81131b08:	e0bff917 	ldw	r2,-28(fp)
81131b0c:	10800c03 	ldbu	r2,48(r2)
81131b10:	10803fcc 	andi	r2,r2,255
81131b14:	1080020c 	andi	r2,r2,8
81131b18:	1000151e 	bne	r2,zero,81131b70 <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
81131b1c:	e0bff917 	ldw	r2,-28(fp)
81131b20:	10c00d83 	ldbu	r3,54(r2)
81131b24:	d0a09d03 	ldbu	r2,-32140(gp)
81131b28:	1884b03a 	or	r2,r3,r2
81131b2c:	d0a09d05 	stb	r2,-32140(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81131b30:	e0bff917 	ldw	r2,-28(fp)
81131b34:	10800d03 	ldbu	r2,52(r2)
81131b38:	10c03fcc 	andi	r3,r2,255
81131b3c:	e0bff917 	ldw	r2,-28(fp)
81131b40:	10800d03 	ldbu	r2,52(r2)
81131b44:	11003fcc 	andi	r4,r2,255
81131b48:	d0a09d44 	addi	r2,gp,-32139
81131b4c:	2085883a 	add	r2,r4,r2
81131b50:	11000003 	ldbu	r4,0(r2)
81131b54:	e0bff917 	ldw	r2,-28(fp)
81131b58:	10800d43 	ldbu	r2,53(r2)
81131b5c:	2084b03a 	or	r2,r4,r2
81131b60:	1009883a 	mov	r4,r2
81131b64:	d0a09d44 	addi	r2,gp,-32139
81131b68:	1885883a 	add	r2,r3,r2
81131b6c:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
81131b70:	e0bff917 	ldw	r2,-28(fp)
81131b74:	10800517 	ldw	r2,20(r2)
81131b78:	e0bff915 	stw	r2,-28(fp)
81131b7c:	e0bffb17 	ldw	r2,-20(fp)
81131b80:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81131b84:	e0bffe17 	ldw	r2,-8(fp)
81131b88:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
81131b8c:	e0bff917 	ldw	r2,-28(fp)
81131b90:	10800c83 	ldbu	r2,50(r2)
81131b94:	10803fcc 	andi	r2,r2,255
81131b98:	10800a98 	cmpnei	r2,r2,42
81131b9c:	103fb21e 	bne	r2,zero,81131a68 <__reset+0xfb111a68>
81131ba0:	00000106 	br	81131ba8 <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
81131ba4:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
81131ba8:	e037883a 	mov	sp,fp
81131bac:	dfc00117 	ldw	ra,4(sp)
81131bb0:	df000017 	ldw	fp,0(sp)
81131bb4:	dec00204 	addi	sp,sp,8
81131bb8:	f800283a 	ret

81131bbc <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
81131bbc:	deffff04 	addi	sp,sp,-4
81131bc0:	de00012e 	bgeu	sp,et,81131bc8 <OSVersion+0xc>
81131bc4:	003b68fa 	trap	3
81131bc8:	df000015 	stw	fp,0(sp)
81131bcc:	d839883a 	mov	fp,sp
    return (OS_VERSION);
81131bd0:	00804784 	movi	r2,286
}
81131bd4:	e037883a 	mov	sp,fp
81131bd8:	df000017 	ldw	fp,0(sp)
81131bdc:	dec00104 	addi	sp,sp,4
81131be0:	f800283a 	ret

81131be4 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
81131be4:	deffff04 	addi	sp,sp,-4
81131be8:	de00012e 	bgeu	sp,et,81131bf0 <OS_Dummy+0xc>
81131bec:	003b68fa 	trap	3
81131bf0:	df000015 	stw	fp,0(sp)
81131bf4:	d839883a 	mov	fp,sp
}
81131bf8:	0001883a 	nop
81131bfc:	e037883a 	mov	sp,fp
81131c00:	df000017 	ldw	fp,0(sp)
81131c04:	dec00104 	addi	sp,sp,4
81131c08:	f800283a 	ret

81131c0c <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
81131c0c:	defff804 	addi	sp,sp,-32
81131c10:	de00012e 	bgeu	sp,et,81131c18 <OS_EventTaskRdy+0xc>
81131c14:	003b68fa 	trap	3
81131c18:	dfc00715 	stw	ra,28(sp)
81131c1c:	df000615 	stw	fp,24(sp)
81131c20:	df000604 	addi	fp,sp,24
81131c24:	e13ffc15 	stw	r4,-16(fp)
81131c28:	e17ffd15 	stw	r5,-12(fp)
81131c2c:	3007883a 	mov	r3,r6
81131c30:	3805883a 	mov	r2,r7
81131c34:	e0fffe05 	stb	r3,-8(fp)
81131c38:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
81131c3c:	e0bffc17 	ldw	r2,-16(fp)
81131c40:	10800283 	ldbu	r2,10(r2)
81131c44:	10c03fcc 	andi	r3,r2,255
81131c48:	00a04534 	movhi	r2,33044
81131c4c:	10959a04 	addi	r2,r2,22120
81131c50:	10c5883a 	add	r2,r2,r3
81131c54:	10800003 	ldbu	r2,0(r2)
81131c58:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
81131c5c:	e0bffa03 	ldbu	r2,-24(fp)
81131c60:	e0fffc17 	ldw	r3,-16(fp)
81131c64:	1885883a 	add	r2,r3,r2
81131c68:	108002c4 	addi	r2,r2,11
81131c6c:	10800003 	ldbu	r2,0(r2)
81131c70:	10c03fcc 	andi	r3,r2,255
81131c74:	00a04534 	movhi	r2,33044
81131c78:	10959a04 	addi	r2,r2,22120
81131c7c:	10c5883a 	add	r2,r2,r3
81131c80:	10800003 	ldbu	r2,0(r2)
81131c84:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
81131c88:	e0bffa03 	ldbu	r2,-24(fp)
81131c8c:	100490fa 	slli	r2,r2,3
81131c90:	1007883a 	mov	r3,r2
81131c94:	e0bffa43 	ldbu	r2,-23(fp)
81131c98:	1885883a 	add	r2,r3,r2
81131c9c:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
81131ca0:	e0fffa83 	ldbu	r3,-22(fp)
81131ca4:	00a045b4 	movhi	r2,33046
81131ca8:	1084d804 	addi	r2,r2,4960
81131cac:	18c7883a 	add	r3,r3,r3
81131cb0:	18c7883a 	add	r3,r3,r3
81131cb4:	10c5883a 	add	r2,r2,r3
81131cb8:	10800017 	ldw	r2,0(r2)
81131cbc:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
81131cc0:	e0bffb17 	ldw	r2,-20(fp)
81131cc4:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
81131cc8:	e0bffb17 	ldw	r2,-20(fp)
81131ccc:	e0fffd17 	ldw	r3,-12(fp)
81131cd0:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
81131cd4:	e0bffb17 	ldw	r2,-20(fp)
81131cd8:	10800c03 	ldbu	r2,48(r2)
81131cdc:	1007883a 	mov	r3,r2
81131ce0:	e0bffe03 	ldbu	r2,-8(fp)
81131ce4:	0084303a 	nor	r2,zero,r2
81131ce8:	1884703a 	and	r2,r3,r2
81131cec:	1007883a 	mov	r3,r2
81131cf0:	e0bffb17 	ldw	r2,-20(fp)
81131cf4:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
81131cf8:	e0bffb17 	ldw	r2,-20(fp)
81131cfc:	e0ffff03 	ldbu	r3,-4(fp)
81131d00:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
81131d04:	e0bffb17 	ldw	r2,-20(fp)
81131d08:	10800c03 	ldbu	r2,48(r2)
81131d0c:	10803fcc 	andi	r2,r2,255
81131d10:	1080020c 	andi	r2,r2,8
81131d14:	1000111e 	bne	r2,zero,81131d5c <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
81131d18:	e0bffb17 	ldw	r2,-20(fp)
81131d1c:	10c00d83 	ldbu	r3,54(r2)
81131d20:	d0a09d03 	ldbu	r2,-32140(gp)
81131d24:	1884b03a 	or	r2,r3,r2
81131d28:	d0a09d05 	stb	r2,-32140(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
81131d2c:	e0fffa03 	ldbu	r3,-24(fp)
81131d30:	e13ffa03 	ldbu	r4,-24(fp)
81131d34:	d0a09d44 	addi	r2,gp,-32139
81131d38:	2085883a 	add	r2,r4,r2
81131d3c:	11000003 	ldbu	r4,0(r2)
81131d40:	e0bffb17 	ldw	r2,-20(fp)
81131d44:	10800d43 	ldbu	r2,53(r2)
81131d48:	2084b03a 	or	r2,r4,r2
81131d4c:	1009883a 	mov	r4,r2
81131d50:	d0a09d44 	addi	r2,gp,-32139
81131d54:	1885883a 	add	r2,r3,r2
81131d58:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
81131d5c:	e17ffc17 	ldw	r5,-16(fp)
81131d60:	e13ffb17 	ldw	r4,-20(fp)
81131d64:	113201c0 	call	8113201c <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
81131d68:	e0bffb17 	ldw	r2,-20(fp)
81131d6c:	10800817 	ldw	r2,32(r2)
81131d70:	10000826 	beq	r2,zero,81131d94 <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
81131d74:	e0bffb17 	ldw	r2,-20(fp)
81131d78:	10800817 	ldw	r2,32(r2)
81131d7c:	100b883a 	mov	r5,r2
81131d80:	e13ffb17 	ldw	r4,-20(fp)
81131d84:	11320dc0 	call	811320dc <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
81131d88:	e0bffb17 	ldw	r2,-20(fp)
81131d8c:	e0fffc17 	ldw	r3,-16(fp)
81131d90:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
81131d94:	e0bffa83 	ldbu	r2,-22(fp)
}
81131d98:	e037883a 	mov	sp,fp
81131d9c:	dfc00117 	ldw	ra,4(sp)
81131da0:	df000017 	ldw	fp,0(sp)
81131da4:	dec00204 	addi	sp,sp,8
81131da8:	f800283a 	ret

81131dac <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
81131dac:	defffd04 	addi	sp,sp,-12
81131db0:	de00012e 	bgeu	sp,et,81131db8 <OS_EventTaskWait+0xc>
81131db4:	003b68fa 	trap	3
81131db8:	df000215 	stw	fp,8(sp)
81131dbc:	df000204 	addi	fp,sp,8
81131dc0:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
81131dc4:	d0a0a117 	ldw	r2,-32124(gp)
81131dc8:	e0ffff17 	ldw	r3,-4(fp)
81131dcc:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
81131dd0:	d0a0a117 	ldw	r2,-32124(gp)
81131dd4:	10800d03 	ldbu	r2,52(r2)
81131dd8:	10803fcc 	andi	r2,r2,255
81131ddc:	d0e0a117 	ldw	r3,-32124(gp)
81131de0:	18c00d03 	ldbu	r3,52(r3)
81131de4:	18c03fcc 	andi	r3,r3,255
81131de8:	e13fff17 	ldw	r4,-4(fp)
81131dec:	20c7883a 	add	r3,r4,r3
81131df0:	18c002c4 	addi	r3,r3,11
81131df4:	19000003 	ldbu	r4,0(r3)
81131df8:	d0e0a117 	ldw	r3,-32124(gp)
81131dfc:	18c00d43 	ldbu	r3,53(r3)
81131e00:	20c6b03a 	or	r3,r4,r3
81131e04:	1809883a 	mov	r4,r3
81131e08:	e0ffff17 	ldw	r3,-4(fp)
81131e0c:	1885883a 	add	r2,r3,r2
81131e10:	108002c4 	addi	r2,r2,11
81131e14:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
81131e18:	e0bfff17 	ldw	r2,-4(fp)
81131e1c:	10c00283 	ldbu	r3,10(r2)
81131e20:	d0a0a117 	ldw	r2,-32124(gp)
81131e24:	10800d83 	ldbu	r2,54(r2)
81131e28:	1884b03a 	or	r2,r3,r2
81131e2c:	1007883a 	mov	r3,r2
81131e30:	e0bfff17 	ldw	r2,-4(fp)
81131e34:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
81131e38:	d0a0a117 	ldw	r2,-32124(gp)
81131e3c:	10800d03 	ldbu	r2,52(r2)
81131e40:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
81131e44:	e0fffe03 	ldbu	r3,-8(fp)
81131e48:	e13ffe03 	ldbu	r4,-8(fp)
81131e4c:	d0a09d44 	addi	r2,gp,-32139
81131e50:	2085883a 	add	r2,r4,r2
81131e54:	10800003 	ldbu	r2,0(r2)
81131e58:	1009883a 	mov	r4,r2
81131e5c:	d0a0a117 	ldw	r2,-32124(gp)
81131e60:	10800d43 	ldbu	r2,53(r2)
81131e64:	0084303a 	nor	r2,zero,r2
81131e68:	2084703a 	and	r2,r4,r2
81131e6c:	1009883a 	mov	r4,r2
81131e70:	d0a09d44 	addi	r2,gp,-32139
81131e74:	1885883a 	add	r2,r3,r2
81131e78:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81131e7c:	e0fffe03 	ldbu	r3,-8(fp)
81131e80:	d0a09d44 	addi	r2,gp,-32139
81131e84:	1885883a 	add	r2,r3,r2
81131e88:	10800003 	ldbu	r2,0(r2)
81131e8c:	10803fcc 	andi	r2,r2,255
81131e90:	1000071e 	bne	r2,zero,81131eb0 <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
81131e94:	d0a0a117 	ldw	r2,-32124(gp)
81131e98:	10800d83 	ldbu	r2,54(r2)
81131e9c:	0084303a 	nor	r2,zero,r2
81131ea0:	1007883a 	mov	r3,r2
81131ea4:	d0a09d03 	ldbu	r2,-32140(gp)
81131ea8:	1884703a 	and	r2,r3,r2
81131eac:	d0a09d05 	stb	r2,-32140(gp)
    }
}
81131eb0:	0001883a 	nop
81131eb4:	e037883a 	mov	sp,fp
81131eb8:	df000017 	ldw	fp,0(sp)
81131ebc:	dec00104 	addi	sp,sp,4
81131ec0:	f800283a 	ret

81131ec4 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
81131ec4:	defffb04 	addi	sp,sp,-20
81131ec8:	de00012e 	bgeu	sp,et,81131ed0 <OS_EventTaskWaitMulti+0xc>
81131ecc:	003b68fa 	trap	3
81131ed0:	df000415 	stw	fp,16(sp)
81131ed4:	df000404 	addi	fp,sp,16
81131ed8:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
81131edc:	d0a0a117 	ldw	r2,-32124(gp)
81131ee0:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
81131ee4:	d0a0a117 	ldw	r2,-32124(gp)
81131ee8:	e0ffff17 	ldw	r3,-4(fp)
81131eec:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
81131ef0:	e0bfff17 	ldw	r2,-4(fp)
81131ef4:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
81131ef8:	e0bffc17 	ldw	r2,-16(fp)
81131efc:	10800017 	ldw	r2,0(r2)
81131f00:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
81131f04:	00002006 	br	81131f88 <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
81131f08:	d0a0a117 	ldw	r2,-32124(gp)
81131f0c:	10800d03 	ldbu	r2,52(r2)
81131f10:	10803fcc 	andi	r2,r2,255
81131f14:	d0e0a117 	ldw	r3,-32124(gp)
81131f18:	18c00d03 	ldbu	r3,52(r3)
81131f1c:	18c03fcc 	andi	r3,r3,255
81131f20:	e13ffd17 	ldw	r4,-12(fp)
81131f24:	20c7883a 	add	r3,r4,r3
81131f28:	18c002c4 	addi	r3,r3,11
81131f2c:	19000003 	ldbu	r4,0(r3)
81131f30:	d0e0a117 	ldw	r3,-32124(gp)
81131f34:	18c00d43 	ldbu	r3,53(r3)
81131f38:	20c6b03a 	or	r3,r4,r3
81131f3c:	1809883a 	mov	r4,r3
81131f40:	e0fffd17 	ldw	r3,-12(fp)
81131f44:	1885883a 	add	r2,r3,r2
81131f48:	108002c4 	addi	r2,r2,11
81131f4c:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
81131f50:	e0bffd17 	ldw	r2,-12(fp)
81131f54:	10c00283 	ldbu	r3,10(r2)
81131f58:	d0a0a117 	ldw	r2,-32124(gp)
81131f5c:	10800d83 	ldbu	r2,54(r2)
81131f60:	1884b03a 	or	r2,r3,r2
81131f64:	1007883a 	mov	r3,r2
81131f68:	e0bffd17 	ldw	r2,-12(fp)
81131f6c:	10c00285 	stb	r3,10(r2)
        pevents++;
81131f70:	e0bffc17 	ldw	r2,-16(fp)
81131f74:	10800104 	addi	r2,r2,4
81131f78:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
81131f7c:	e0bffc17 	ldw	r2,-16(fp)
81131f80:	10800017 	ldw	r2,0(r2)
81131f84:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
81131f88:	e0bffd17 	ldw	r2,-12(fp)
81131f8c:	103fde1e 	bne	r2,zero,81131f08 <__reset+0xfb111f08>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
81131f90:	d0a0a117 	ldw	r2,-32124(gp)
81131f94:	10800d03 	ldbu	r2,52(r2)
81131f98:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
81131f9c:	e0fffe03 	ldbu	r3,-8(fp)
81131fa0:	e13ffe03 	ldbu	r4,-8(fp)
81131fa4:	d0a09d44 	addi	r2,gp,-32139
81131fa8:	2085883a 	add	r2,r4,r2
81131fac:	10800003 	ldbu	r2,0(r2)
81131fb0:	1009883a 	mov	r4,r2
81131fb4:	d0a0a117 	ldw	r2,-32124(gp)
81131fb8:	10800d43 	ldbu	r2,53(r2)
81131fbc:	0084303a 	nor	r2,zero,r2
81131fc0:	2084703a 	and	r2,r4,r2
81131fc4:	1009883a 	mov	r4,r2
81131fc8:	d0a09d44 	addi	r2,gp,-32139
81131fcc:	1885883a 	add	r2,r3,r2
81131fd0:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81131fd4:	e0fffe03 	ldbu	r3,-8(fp)
81131fd8:	d0a09d44 	addi	r2,gp,-32139
81131fdc:	1885883a 	add	r2,r3,r2
81131fe0:	10800003 	ldbu	r2,0(r2)
81131fe4:	10803fcc 	andi	r2,r2,255
81131fe8:	1000071e 	bne	r2,zero,81132008 <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
81131fec:	d0a0a117 	ldw	r2,-32124(gp)
81131ff0:	10800d83 	ldbu	r2,54(r2)
81131ff4:	0084303a 	nor	r2,zero,r2
81131ff8:	1007883a 	mov	r3,r2
81131ffc:	d0a09d03 	ldbu	r2,-32140(gp)
81132000:	1884703a 	and	r2,r3,r2
81132004:	d0a09d05 	stb	r2,-32140(gp)
    }
}
81132008:	0001883a 	nop
8113200c:	e037883a 	mov	sp,fp
81132010:	df000017 	ldw	fp,0(sp)
81132014:	dec00104 	addi	sp,sp,4
81132018:	f800283a 	ret

8113201c <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
8113201c:	defffc04 	addi	sp,sp,-16
81132020:	de00012e 	bgeu	sp,et,81132028 <OS_EventTaskRemove+0xc>
81132024:	003b68fa 	trap	3
81132028:	df000315 	stw	fp,12(sp)
8113202c:	df000304 	addi	fp,sp,12
81132030:	e13ffe15 	stw	r4,-8(fp)
81132034:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
81132038:	e0bffe17 	ldw	r2,-8(fp)
8113203c:	10800d03 	ldbu	r2,52(r2)
81132040:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
81132044:	e0bffd03 	ldbu	r2,-12(fp)
81132048:	e0fffd03 	ldbu	r3,-12(fp)
8113204c:	e13fff17 	ldw	r4,-4(fp)
81132050:	20c7883a 	add	r3,r4,r3
81132054:	18c002c4 	addi	r3,r3,11
81132058:	18c00003 	ldbu	r3,0(r3)
8113205c:	1809883a 	mov	r4,r3
81132060:	e0fffe17 	ldw	r3,-8(fp)
81132064:	18c00d43 	ldbu	r3,53(r3)
81132068:	00c6303a 	nor	r3,zero,r3
8113206c:	20c6703a 	and	r3,r4,r3
81132070:	1809883a 	mov	r4,r3
81132074:	e0ffff17 	ldw	r3,-4(fp)
81132078:	1885883a 	add	r2,r3,r2
8113207c:	108002c4 	addi	r2,r2,11
81132080:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
81132084:	e0bffd03 	ldbu	r2,-12(fp)
81132088:	e0ffff17 	ldw	r3,-4(fp)
8113208c:	1885883a 	add	r2,r3,r2
81132090:	108002c4 	addi	r2,r2,11
81132094:	10800003 	ldbu	r2,0(r2)
81132098:	10803fcc 	andi	r2,r2,255
8113209c:	10000a1e 	bne	r2,zero,811320c8 <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
811320a0:	e0bfff17 	ldw	r2,-4(fp)
811320a4:	10800283 	ldbu	r2,10(r2)
811320a8:	1007883a 	mov	r3,r2
811320ac:	e0bffe17 	ldw	r2,-8(fp)
811320b0:	10800d83 	ldbu	r2,54(r2)
811320b4:	0084303a 	nor	r2,zero,r2
811320b8:	1884703a 	and	r2,r3,r2
811320bc:	1007883a 	mov	r3,r2
811320c0:	e0bfff17 	ldw	r2,-4(fp)
811320c4:	10c00285 	stb	r3,10(r2)
    }
}
811320c8:	0001883a 	nop
811320cc:	e037883a 	mov	sp,fp
811320d0:	df000017 	ldw	fp,0(sp)
811320d4:	dec00104 	addi	sp,sp,4
811320d8:	f800283a 	ret

811320dc <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
811320dc:	defffa04 	addi	sp,sp,-24
811320e0:	de00012e 	bgeu	sp,et,811320e8 <OS_EventTaskRemoveMulti+0xc>
811320e4:	003b68fa 	trap	3
811320e8:	df000515 	stw	fp,20(sp)
811320ec:	df000504 	addi	fp,sp,20
811320f0:	e13ffe15 	stw	r4,-8(fp)
811320f4:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
811320f8:	e0bffe17 	ldw	r2,-8(fp)
811320fc:	10800d03 	ldbu	r2,52(r2)
81132100:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
81132104:	e0bffe17 	ldw	r2,-8(fp)
81132108:	10800d83 	ldbu	r2,54(r2)
8113210c:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
81132110:	e0bffe17 	ldw	r2,-8(fp)
81132114:	10800d43 	ldbu	r2,53(r2)
81132118:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
8113211c:	e0bfff17 	ldw	r2,-4(fp)
81132120:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
81132124:	e0bffb17 	ldw	r2,-20(fp)
81132128:	10800017 	ldw	r2,0(r2)
8113212c:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
81132130:	00002506 	br	811321c8 <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
81132134:	e0bffd03 	ldbu	r2,-12(fp)
81132138:	e0fffd03 	ldbu	r3,-12(fp)
8113213c:	e13ffc17 	ldw	r4,-16(fp)
81132140:	20c7883a 	add	r3,r4,r3
81132144:	18c002c4 	addi	r3,r3,11
81132148:	18c00003 	ldbu	r3,0(r3)
8113214c:	1809883a 	mov	r4,r3
81132150:	e0fffd83 	ldbu	r3,-10(fp)
81132154:	00c6303a 	nor	r3,zero,r3
81132158:	20c6703a 	and	r3,r4,r3
8113215c:	1809883a 	mov	r4,r3
81132160:	e0fffc17 	ldw	r3,-16(fp)
81132164:	1885883a 	add	r2,r3,r2
81132168:	108002c4 	addi	r2,r2,11
8113216c:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
81132170:	e0bffd03 	ldbu	r2,-12(fp)
81132174:	e0fffc17 	ldw	r3,-16(fp)
81132178:	1885883a 	add	r2,r3,r2
8113217c:	108002c4 	addi	r2,r2,11
81132180:	10800003 	ldbu	r2,0(r2)
81132184:	10803fcc 	andi	r2,r2,255
81132188:	1000091e 	bne	r2,zero,811321b0 <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
8113218c:	e0bffc17 	ldw	r2,-16(fp)
81132190:	10800283 	ldbu	r2,10(r2)
81132194:	1007883a 	mov	r3,r2
81132198:	e0bffd43 	ldbu	r2,-11(fp)
8113219c:	0084303a 	nor	r2,zero,r2
811321a0:	1884703a 	and	r2,r3,r2
811321a4:	1007883a 	mov	r3,r2
811321a8:	e0bffc17 	ldw	r2,-16(fp)
811321ac:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
811321b0:	e0bffb17 	ldw	r2,-20(fp)
811321b4:	10800104 	addi	r2,r2,4
811321b8:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
811321bc:	e0bffb17 	ldw	r2,-20(fp)
811321c0:	10800017 	ldw	r2,0(r2)
811321c4:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
811321c8:	e0bffc17 	ldw	r2,-16(fp)
811321cc:	103fd91e 	bne	r2,zero,81132134 <__reset+0xfb112134>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
811321d0:	0001883a 	nop
811321d4:	e037883a 	mov	sp,fp
811321d8:	df000017 	ldw	fp,0(sp)
811321dc:	dec00104 	addi	sp,sp,4
811321e0:	f800283a 	ret

811321e4 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
811321e4:	defffc04 	addi	sp,sp,-16
811321e8:	de00012e 	bgeu	sp,et,811321f0 <OS_EventWaitListInit+0xc>
811321ec:	003b68fa 	trap	3
811321f0:	df000315 	stw	fp,12(sp)
811321f4:	df000304 	addi	fp,sp,12
811321f8:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
811321fc:	e0bfff17 	ldw	r2,-4(fp)
81132200:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
81132204:	e0bfff17 	ldw	r2,-4(fp)
81132208:	108002c4 	addi	r2,r2,11
8113220c:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81132210:	e03ffe05 	stb	zero,-8(fp)
81132214:	00000706 	br	81132234 <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
81132218:	e0bffd17 	ldw	r2,-12(fp)
8113221c:	10c00044 	addi	r3,r2,1
81132220:	e0fffd15 	stw	r3,-12(fp)
81132224:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81132228:	e0bffe03 	ldbu	r2,-8(fp)
8113222c:	10800044 	addi	r2,r2,1
81132230:	e0bffe05 	stb	r2,-8(fp)
81132234:	e0bffe03 	ldbu	r2,-8(fp)
81132238:	108001b0 	cmpltui	r2,r2,6
8113223c:	103ff61e 	bne	r2,zero,81132218 <__reset+0xfb112218>
        *ptbl++ = 0;
    }
}
81132240:	0001883a 	nop
81132244:	e037883a 	mov	sp,fp
81132248:	df000017 	ldw	fp,0(sp)
8113224c:	dec00104 	addi	sp,sp,4
81132250:	f800283a 	ret

81132254 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
81132254:	defffb04 	addi	sp,sp,-20
81132258:	de00012e 	bgeu	sp,et,81132260 <OS_InitEventList+0xc>
8113225c:	003b68fa 	trap	3
81132260:	dfc00415 	stw	ra,16(sp)
81132264:	df000315 	stw	fp,12(sp)
81132268:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
8113226c:	01434004 	movi	r5,3328
81132270:	012045b4 	movhi	r4,33046
81132274:	213d2a04 	addi	r4,r4,-2904
81132278:	11325fc0 	call	811325fc <OS_MemClr>
    pevent1 = &OSEventTbl[0];
8113227c:	00a045b4 	movhi	r2,33046
81132280:	10bd2a04 	addi	r2,r2,-2904
81132284:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
81132288:	00a045b4 	movhi	r2,33046
8113228c:	10bd3704 	addi	r2,r2,-2852
81132290:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
81132294:	e03ffd0d 	sth	zero,-12(fp)
81132298:	00001306 	br	811322e8 <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113229c:	e0bffe17 	ldw	r2,-8(fp)
811322a0:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
811322a4:	e0bffe17 	ldw	r2,-8(fp)
811322a8:	e0ffff17 	ldw	r3,-4(fp)
811322ac:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
811322b0:	e0bffe17 	ldw	r2,-8(fp)
811322b4:	00c00fc4 	movi	r3,63
811322b8:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
811322bc:	e0bffe17 	ldw	r2,-8(fp)
811322c0:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
811322c4:	e0bffe17 	ldw	r2,-8(fp)
811322c8:	10800d04 	addi	r2,r2,52
811322cc:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
811322d0:	e0bfff17 	ldw	r2,-4(fp)
811322d4:	10800d04 	addi	r2,r2,52
811322d8:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
811322dc:	e0bffd0b 	ldhu	r2,-12(fp)
811322e0:	10800044 	addi	r2,r2,1
811322e4:	e0bffd0d 	sth	r2,-12(fp)
811322e8:	e0bffd0b 	ldhu	r2,-12(fp)
811322ec:	10800ff0 	cmpltui	r2,r2,63
811322f0:	103fea1e 	bne	r2,zero,8113229c <__reset+0xfb11229c>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
811322f4:	e0bffe17 	ldw	r2,-8(fp)
811322f8:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
811322fc:	e0bffe17 	ldw	r2,-8(fp)
81132300:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
81132304:	e0bffe17 	ldw	r2,-8(fp)
81132308:	00c00fc4 	movi	r3,63
8113230c:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
81132310:	e0bffe17 	ldw	r2,-8(fp)
81132314:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
81132318:	00a045b4 	movhi	r2,33046
8113231c:	10bd2a04 	addi	r2,r2,-2904
81132320:	d0a09f15 	stw	r2,-32132(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
81132324:	0001883a 	nop
81132328:	e037883a 	mov	sp,fp
8113232c:	dfc00117 	ldw	ra,4(sp)
81132330:	df000017 	ldw	fp,0(sp)
81132334:	dec00204 	addi	sp,sp,8
81132338:	f800283a 	ret

8113233c <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
8113233c:	deffff04 	addi	sp,sp,-4
81132340:	de00012e 	bgeu	sp,et,81132348 <OS_InitMisc+0xc>
81132344:	003b68fa 	trap	3
81132348:	df000015 	stw	fp,0(sp)
8113234c:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
81132350:	d020a315 	stw	zero,-32116(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
81132354:	d020a005 	stb	zero,-32128(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
81132358:	d0208e05 	stb	zero,-32200(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
8113235c:	d0209945 	stb	zero,-32155(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
81132360:	d0209005 	stb	zero,-32192(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
81132364:	d0209515 	stw	zero,-32172(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
81132368:	d0209115 	stw	zero,-32188(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
8113236c:	d020a715 	stw	zero,-32100(gp)
    OSIdleCtrMax  = 0L;
81132370:	d0209715 	stw	zero,-32164(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
81132374:	d020a605 	stb	zero,-32104(gp)
#endif
}
81132378:	0001883a 	nop
8113237c:	e037883a 	mov	sp,fp
81132380:	df000017 	ldw	fp,0(sp)
81132384:	dec00104 	addi	sp,sp,4
81132388:	f800283a 	ret

8113238c <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
8113238c:	defffd04 	addi	sp,sp,-12
81132390:	de00012e 	bgeu	sp,et,81132398 <OS_InitRdyList+0xc>
81132394:	003b68fa 	trap	3
81132398:	df000215 	stw	fp,8(sp)
8113239c:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
811323a0:	d0209d05 	stb	zero,-32140(gp)
    prdytbl       = &OSRdyTbl[0];
811323a4:	d0a09d44 	addi	r2,gp,-32139
811323a8:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
811323ac:	e03ffe05 	stb	zero,-8(fp)
811323b0:	00000706 	br	811323d0 <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
811323b4:	e0bfff17 	ldw	r2,-4(fp)
811323b8:	10c00044 	addi	r3,r2,1
811323bc:	e0ffff15 	stw	r3,-4(fp)
811323c0:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
811323c4:	e0bffe03 	ldbu	r2,-8(fp)
811323c8:	10800044 	addi	r2,r2,1
811323cc:	e0bffe05 	stb	r2,-8(fp)
811323d0:	e0bffe03 	ldbu	r2,-8(fp)
811323d4:	108001b0 	cmpltui	r2,r2,6
811323d8:	103ff61e 	bne	r2,zero,811323b4 <__reset+0xfb1123b4>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
811323dc:	d02092c5 	stb	zero,-32181(gp)
    OSPrioHighRdy = 0;
811323e0:	d0209285 	stb	zero,-32182(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
811323e4:	d0209b15 	stw	zero,-32148(gp)
    OSTCBCur      = (OS_TCB *)0;
811323e8:	d020a115 	stw	zero,-32124(gp)
}
811323ec:	0001883a 	nop
811323f0:	e037883a 	mov	sp,fp
811323f4:	df000017 	ldw	fp,0(sp)
811323f8:	dec00104 	addi	sp,sp,4
811323fc:	f800283a 	ret

81132400 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
81132400:	defff804 	addi	sp,sp,-32
81132404:	de00012e 	bgeu	sp,et,8113240c <OS_InitTaskIdle+0xc>
81132408:	003b68fa 	trap	3
8113240c:	dfc00715 	stw	ra,28(sp)
81132410:	df000615 	stw	fp,24(sp)
81132414:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
81132418:	008000c4 	movi	r2,3
8113241c:	d8800415 	stw	r2,16(sp)
81132420:	d8000315 	stw	zero,12(sp)
81132424:	00810004 	movi	r2,1024
81132428:	d8800215 	stw	r2,8(sp)
8113242c:	00a045b4 	movhi	r2,33046
81132430:	10b92a04 	addi	r2,r2,-7000
81132434:	d8800115 	stw	r2,4(sp)
81132438:	00bfffd4 	movui	r2,65535
8113243c:	d8800015 	stw	r2,0(sp)
81132440:	01c00a84 	movi	r7,42
81132444:	01a045b4 	movhi	r6,33046
81132448:	31bd2904 	addi	r6,r6,-2908
8113244c:	000b883a 	mov	r5,zero
81132450:	012044f4 	movhi	r4,33043
81132454:	210a3d04 	addi	r4,r4,10484
81132458:	11382e40 	call	811382e4 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
8113245c:	e1bfff04 	addi	r6,fp,-4
81132460:	01604534 	movhi	r5,33044
81132464:	2955da04 	addi	r5,r5,22376
81132468:	01000a84 	movi	r4,42
8113246c:	1138b140 	call	81138b14 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
81132470:	0001883a 	nop
81132474:	e037883a 	mov	sp,fp
81132478:	dfc00117 	ldw	ra,4(sp)
8113247c:	df000017 	ldw	fp,0(sp)
81132480:	dec00204 	addi	sp,sp,8
81132484:	f800283a 	ret

81132488 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
81132488:	defff804 	addi	sp,sp,-32
8113248c:	de00012e 	bgeu	sp,et,81132494 <OS_InitTaskStat+0xc>
81132490:	003b68fa 	trap	3
81132494:	dfc00715 	stw	ra,28(sp)
81132498:	df000615 	stw	fp,24(sp)
8113249c:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
811324a0:	008000c4 	movi	r2,3
811324a4:	d8800415 	stw	r2,16(sp)
811324a8:	d8000315 	stw	zero,12(sp)
811324ac:	00810004 	movi	r2,1024
811324b0:	d8800215 	stw	r2,8(sp)
811324b4:	00a045b4 	movhi	r2,33046
811324b8:	10b26a04 	addi	r2,r2,-13912
811324bc:	d8800115 	stw	r2,4(sp)
811324c0:	00bfff94 	movui	r2,65534
811324c4:	d8800015 	stw	r2,0(sp)
811324c8:	01c00a44 	movi	r7,41
811324cc:	01a045b4 	movhi	r6,33046
811324d0:	31b66904 	addi	r6,r6,-9820
811324d4:	000b883a 	mov	r5,zero
811324d8:	012044f4 	movhi	r4,33043
811324dc:	210a5604 	addi	r4,r4,10584
811324e0:	11382e40 	call	811382e4 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
811324e4:	e1bfff04 	addi	r6,fp,-4
811324e8:	01604534 	movhi	r5,33044
811324ec:	2955de04 	addi	r5,r5,22392
811324f0:	01000a44 	movi	r4,41
811324f4:	1138b140 	call	81138b14 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
811324f8:	0001883a 	nop
811324fc:	e037883a 	mov	sp,fp
81132500:	dfc00117 	ldw	ra,4(sp)
81132504:	df000017 	ldw	fp,0(sp)
81132508:	dec00204 	addi	sp,sp,8
8113250c:	f800283a 	ret

81132510 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
81132510:	defffb04 	addi	sp,sp,-20
81132514:	de00012e 	bgeu	sp,et,8113251c <OS_InitTCBList+0xc>
81132518:	003b68fa 	trap	3
8113251c:	dfc00415 	stw	ra,16(sp)
81132520:	df000315 	stw	fp,12(sp)
81132524:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
81132528:	01446e04 	movi	r5,4536
8113252c:	012045b4 	movhi	r4,33046
81132530:	21006a04 	addi	r4,r4,424
81132534:	11325fc0 	call	811325fc <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
81132538:	01402b04 	movi	r5,172
8113253c:	012045b4 	movhi	r4,33046
81132540:	2104d804 	addi	r4,r4,4960
81132544:	11325fc0 	call	811325fc <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
81132548:	00a045b4 	movhi	r2,33046
8113254c:	10806a04 	addi	r2,r2,424
81132550:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
81132554:	00a045b4 	movhi	r2,33046
81132558:	10808504 	addi	r2,r2,532
8113255c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81132560:	e03ffd05 	stb	zero,-12(fp)
81132564:	00001106 	br	811325ac <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
81132568:	e0bffe17 	ldw	r2,-8(fp)
8113256c:	e0ffff17 	ldw	r3,-4(fp)
81132570:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
81132574:	e0bffe17 	ldw	r2,-8(fp)
81132578:	00c00fc4 	movi	r3,63
8113257c:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81132580:	e0bffe17 	ldw	r2,-8(fp)
81132584:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
81132588:	e0bffe17 	ldw	r2,-8(fp)
8113258c:	10801b04 	addi	r2,r2,108
81132590:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
81132594:	e0bfff17 	ldw	r2,-4(fp)
81132598:	10801b04 	addi	r2,r2,108
8113259c:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
811325a0:	e0bffd03 	ldbu	r2,-12(fp)
811325a4:	10800044 	addi	r2,r2,1
811325a8:	e0bffd05 	stb	r2,-12(fp)
811325ac:	e0bffd03 	ldbu	r2,-12(fp)
811325b0:	10800a70 	cmpltui	r2,r2,41
811325b4:	103fec1e 	bne	r2,zero,81132568 <__reset+0xfb112568>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
811325b8:	e0bffe17 	ldw	r2,-8(fp)
811325bc:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
811325c0:	e0bffe17 	ldw	r2,-8(fp)
811325c4:	00c00fc4 	movi	r3,63
811325c8:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
811325cc:	e0bffe17 	ldw	r2,-8(fp)
811325d0:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
811325d4:	d0209315 	stw	zero,-32180(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
811325d8:	00a045b4 	movhi	r2,33046
811325dc:	10806a04 	addi	r2,r2,424
811325e0:	d0a09815 	stw	r2,-32160(gp)
}
811325e4:	0001883a 	nop
811325e8:	e037883a 	mov	sp,fp
811325ec:	dfc00117 	ldw	ra,4(sp)
811325f0:	df000017 	ldw	fp,0(sp)
811325f4:	dec00204 	addi	sp,sp,8
811325f8:	f800283a 	ret

811325fc <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
811325fc:	defffd04 	addi	sp,sp,-12
81132600:	de00012e 	bgeu	sp,et,81132608 <OS_MemClr+0xc>
81132604:	003b68fa 	trap	3
81132608:	df000215 	stw	fp,8(sp)
8113260c:	df000204 	addi	fp,sp,8
81132610:	e13ffe15 	stw	r4,-8(fp)
81132614:	2805883a 	mov	r2,r5
81132618:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
8113261c:	00000706 	br	8113263c <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
81132620:	e0bffe17 	ldw	r2,-8(fp)
81132624:	10c00044 	addi	r3,r2,1
81132628:	e0fffe15 	stw	r3,-8(fp)
8113262c:	10000005 	stb	zero,0(r2)
        size--;
81132630:	e0bfff0b 	ldhu	r2,-4(fp)
81132634:	10bfffc4 	addi	r2,r2,-1
81132638:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
8113263c:	e0bfff0b 	ldhu	r2,-4(fp)
81132640:	103ff71e 	bne	r2,zero,81132620 <__reset+0xfb112620>
        *pdest++ = (INT8U)0;
        size--;
    }
}
81132644:	0001883a 	nop
81132648:	e037883a 	mov	sp,fp
8113264c:	df000017 	ldw	fp,0(sp)
81132650:	dec00104 	addi	sp,sp,4
81132654:	f800283a 	ret

81132658 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
81132658:	defffc04 	addi	sp,sp,-16
8113265c:	de00012e 	bgeu	sp,et,81132664 <OS_MemCopy+0xc>
81132660:	003b68fa 	trap	3
81132664:	df000315 	stw	fp,12(sp)
81132668:	df000304 	addi	fp,sp,12
8113266c:	e13ffd15 	stw	r4,-12(fp)
81132670:	e17ffe15 	stw	r5,-8(fp)
81132674:	3005883a 	mov	r2,r6
81132678:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
8113267c:	00000b06 	br	811326ac <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
81132680:	e0bffd17 	ldw	r2,-12(fp)
81132684:	10c00044 	addi	r3,r2,1
81132688:	e0fffd15 	stw	r3,-12(fp)
8113268c:	e0fffe17 	ldw	r3,-8(fp)
81132690:	19000044 	addi	r4,r3,1
81132694:	e13ffe15 	stw	r4,-8(fp)
81132698:	18c00003 	ldbu	r3,0(r3)
8113269c:	10c00005 	stb	r3,0(r2)
        size--;
811326a0:	e0bfff0b 	ldhu	r2,-4(fp)
811326a4:	10bfffc4 	addi	r2,r2,-1
811326a8:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
811326ac:	e0bfff0b 	ldhu	r2,-4(fp)
811326b0:	103ff31e 	bne	r2,zero,81132680 <__reset+0xfb112680>
        *pdest++ = *psrc++;
        size--;
    }
}
811326b4:	0001883a 	nop
811326b8:	e037883a 	mov	sp,fp
811326bc:	df000017 	ldw	fp,0(sp)
811326c0:	dec00104 	addi	sp,sp,4
811326c4:	f800283a 	ret

811326c8 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
811326c8:	defffb04 	addi	sp,sp,-20
811326cc:	de00012e 	bgeu	sp,et,811326d4 <OS_Sched+0xc>
811326d0:	003b68fa 	trap	3
811326d4:	dfc00415 	stw	ra,16(sp)
811326d8:	df000315 	stw	fp,12(sp)
811326dc:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
811326e0:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811326e4:	0005303a 	rdctl	r2,status
811326e8:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811326ec:	e0ffff17 	ldw	r3,-4(fp)
811326f0:	00bfff84 	movi	r2,-2
811326f4:	1884703a 	and	r2,r3,r2
811326f8:	1001703a 	wrctl	status,r2
  
  return context;
811326fc:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
81132700:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
81132704:	d0a0a003 	ldbu	r2,-32128(gp)
81132708:	10803fcc 	andi	r2,r2,255
8113270c:	10001a1e 	bne	r2,zero,81132778 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
81132710:	d0a08e03 	ldbu	r2,-32200(gp)
81132714:	10803fcc 	andi	r2,r2,255
81132718:	1000171e 	bne	r2,zero,81132778 <OS_Sched+0xb0>
            OS_SchedNew();
8113271c:	11327a00 	call	811327a0 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
81132720:	d0e09283 	ldbu	r3,-32182(gp)
81132724:	d0a092c3 	ldbu	r2,-32181(gp)
81132728:	18c03fcc 	andi	r3,r3,255
8113272c:	10803fcc 	andi	r2,r2,255
81132730:	18801126 	beq	r3,r2,81132778 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
81132734:	d0a09283 	ldbu	r2,-32182(gp)
81132738:	10c03fcc 	andi	r3,r2,255
8113273c:	00a045b4 	movhi	r2,33046
81132740:	1084d804 	addi	r2,r2,4960
81132744:	18c7883a 	add	r3,r3,r3
81132748:	18c7883a 	add	r3,r3,r3
8113274c:	10c5883a 	add	r2,r2,r3
81132750:	10800017 	ldw	r2,0(r2)
81132754:	d0a09b15 	stw	r2,-32148(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
81132758:	d0a09b17 	ldw	r2,-32148(gp)
8113275c:	10c00e17 	ldw	r3,56(r2)
81132760:	18c00044 	addi	r3,r3,1
81132764:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
81132768:	d0a09517 	ldw	r2,-32172(gp)
8113276c:	10800044 	addi	r2,r2,1
81132770:	d0a09515 	stw	r2,-32172(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
81132774:	11437700 	call	81143770 <OSCtxSw>
81132778:	e0bffd17 	ldw	r2,-12(fp)
8113277c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132780:	e0bffe17 	ldw	r2,-8(fp)
81132784:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
81132788:	0001883a 	nop
8113278c:	e037883a 	mov	sp,fp
81132790:	dfc00117 	ldw	ra,4(sp)
81132794:	df000017 	ldw	fp,0(sp)
81132798:	dec00204 	addi	sp,sp,8
8113279c:	f800283a 	ret

811327a0 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
811327a0:	defffe04 	addi	sp,sp,-8
811327a4:	de00012e 	bgeu	sp,et,811327ac <OS_SchedNew+0xc>
811327a8:	003b68fa 	trap	3
811327ac:	df000115 	stw	fp,4(sp)
811327b0:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
811327b4:	d0a09d03 	ldbu	r2,-32140(gp)
811327b8:	10c03fcc 	andi	r3,r2,255
811327bc:	00a04534 	movhi	r2,33044
811327c0:	10959a04 	addi	r2,r2,22120
811327c4:	10c5883a 	add	r2,r2,r3
811327c8:	10800003 	ldbu	r2,0(r2)
811327cc:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
811327d0:	e0bfff03 	ldbu	r2,-4(fp)
811327d4:	100490fa 	slli	r2,r2,3
811327d8:	1009883a 	mov	r4,r2
811327dc:	e0ffff03 	ldbu	r3,-4(fp)
811327e0:	d0a09d44 	addi	r2,gp,-32139
811327e4:	1885883a 	add	r2,r3,r2
811327e8:	10800003 	ldbu	r2,0(r2)
811327ec:	10c03fcc 	andi	r3,r2,255
811327f0:	00a04534 	movhi	r2,33044
811327f4:	10959a04 	addi	r2,r2,22120
811327f8:	10c5883a 	add	r2,r2,r3
811327fc:	10800003 	ldbu	r2,0(r2)
81132800:	2085883a 	add	r2,r4,r2
81132804:	d0a09285 	stb	r2,-32182(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
81132808:	0001883a 	nop
8113280c:	e037883a 	mov	sp,fp
81132810:	df000017 	ldw	fp,0(sp)
81132814:	dec00104 	addi	sp,sp,4
81132818:	f800283a 	ret

8113281c <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
8113281c:	defffc04 	addi	sp,sp,-16
81132820:	de00012e 	bgeu	sp,et,81132828 <OS_StrCopy+0xc>
81132824:	003b68fa 	trap	3
81132828:	df000315 	stw	fp,12(sp)
8113282c:	df000304 	addi	fp,sp,12
81132830:	e13ffe15 	stw	r4,-8(fp)
81132834:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
81132838:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
8113283c:	00000b06 	br	8113286c <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
81132840:	e0bffe17 	ldw	r2,-8(fp)
81132844:	10c00044 	addi	r3,r2,1
81132848:	e0fffe15 	stw	r3,-8(fp)
8113284c:	e0ffff17 	ldw	r3,-4(fp)
81132850:	19000044 	addi	r4,r3,1
81132854:	e13fff15 	stw	r4,-4(fp)
81132858:	18c00003 	ldbu	r3,0(r3)
8113285c:	10c00005 	stb	r3,0(r2)
        len++;
81132860:	e0bffd03 	ldbu	r2,-12(fp)
81132864:	10800044 	addi	r2,r2,1
81132868:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
8113286c:	e0bfff17 	ldw	r2,-4(fp)
81132870:	10800003 	ldbu	r2,0(r2)
81132874:	10803fcc 	andi	r2,r2,255
81132878:	103ff11e 	bne	r2,zero,81132840 <__reset+0xfb112840>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
8113287c:	e0bffe17 	ldw	r2,-8(fp)
81132880:	10000005 	stb	zero,0(r2)
    return (len);
81132884:	e0bffd03 	ldbu	r2,-12(fp)
}
81132888:	e037883a 	mov	sp,fp
8113288c:	df000017 	ldw	fp,0(sp)
81132890:	dec00104 	addi	sp,sp,4
81132894:	f800283a 	ret

81132898 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
81132898:	defffd04 	addi	sp,sp,-12
8113289c:	de00012e 	bgeu	sp,et,811328a4 <OS_StrLen+0xc>
811328a0:	003b68fa 	trap	3
811328a4:	df000215 	stw	fp,8(sp)
811328a8:	df000204 	addi	fp,sp,8
811328ac:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
811328b0:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
811328b4:	00000606 	br	811328d0 <OS_StrLen+0x38>
        psrc++;
811328b8:	e0bfff17 	ldw	r2,-4(fp)
811328bc:	10800044 	addi	r2,r2,1
811328c0:	e0bfff15 	stw	r2,-4(fp)
        len++;
811328c4:	e0bffe03 	ldbu	r2,-8(fp)
811328c8:	10800044 	addi	r2,r2,1
811328cc:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
811328d0:	e0bfff17 	ldw	r2,-4(fp)
811328d4:	10800003 	ldbu	r2,0(r2)
811328d8:	10803fcc 	andi	r2,r2,255
811328dc:	103ff61e 	bne	r2,zero,811328b8 <__reset+0xfb1128b8>
        psrc++;
        len++;
    }
    return (len);
811328e0:	e0bffe03 	ldbu	r2,-8(fp)
}
811328e4:	e037883a 	mov	sp,fp
811328e8:	df000017 	ldw	fp,0(sp)
811328ec:	dec00104 	addi	sp,sp,4
811328f0:	f800283a 	ret

811328f4 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
811328f4:	defffa04 	addi	sp,sp,-24
811328f8:	de00012e 	bgeu	sp,et,81132900 <OS_TaskIdle+0xc>
811328fc:	003b68fa 	trap	3
81132900:	dfc00515 	stw	ra,20(sp)
81132904:	df000415 	stw	fp,16(sp)
81132908:	df000404 	addi	fp,sp,16
8113290c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81132910:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132914:	0005303a 	rdctl	r2,status
81132918:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113291c:	e0fffd17 	ldw	r3,-12(fp)
81132920:	00bfff84 	movi	r2,-2
81132924:	1884703a 	and	r2,r3,r2
81132928:	1001703a 	wrctl	status,r2
  
  return context;
8113292c:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
81132930:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
81132934:	d0a09117 	ldw	r2,-32188(gp)
81132938:	10800044 	addi	r2,r2,1
8113293c:	d0a09115 	stw	r2,-32188(gp)
81132940:	e0bffc17 	ldw	r2,-16(fp)
81132944:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132948:	e0bffe17 	ldw	r2,-8(fp)
8113294c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
81132950:	1143b040 	call	81143b04 <OSTaskIdleHook>
    }
81132954:	003fef06 	br	81132914 <__reset+0xfb112914>

81132958 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
81132958:	defff804 	addi	sp,sp,-32
8113295c:	de00012e 	bgeu	sp,et,81132964 <OS_TaskStat+0xc>
81132960:	003b68fa 	trap	3
81132964:	dfc00715 	stw	ra,28(sp)
81132968:	df000615 	stw	fp,24(sp)
8113296c:	dc400515 	stw	r17,20(sp)
81132970:	dc000415 	stw	r16,16(sp)
81132974:	df000604 	addi	fp,sp,24
81132978:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113297c:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81132980:	00000206 	br	8113298c <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
81132984:	01003204 	movi	r4,200
81132988:	11394040 	call	81139404 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
8113298c:	d0a0a603 	ldbu	r2,-32104(gp)
81132990:	10803fcc 	andi	r2,r2,255
81132994:	103ffb26 	beq	r2,zero,81132984 <__reset+0xfb112984>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
81132998:	d0e09717 	ldw	r3,-32164(gp)
8113299c:	00947b34 	movhi	r2,20972
811329a0:	10a147c4 	addi	r2,r2,-31457
811329a4:	1888383a 	mulxuu	r4,r3,r2
811329a8:	1885383a 	mul	r2,r3,r2
811329ac:	1021883a 	mov	r16,r2
811329b0:	2023883a 	mov	r17,r4
811329b4:	8804d17a 	srli	r2,r17,5
811329b8:	d0a09715 	stw	r2,-32164(gp)
    if (OSIdleCtrMax == 0L) {
811329bc:	d0a09717 	ldw	r2,-32164(gp)
811329c0:	1000031e 	bne	r2,zero,811329d0 <OS_TaskStat+0x78>
        OSCPUUsage = 0;
811329c4:	d0209905 	stb	zero,-32156(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
811329c8:	01003fc4 	movi	r4,255
811329cc:	11390740 	call	81139074 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811329d0:	0005303a 	rdctl	r2,status
811329d4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811329d8:	e0fffb17 	ldw	r3,-20(fp)
811329dc:	00bfff84 	movi	r2,-2
811329e0:	1884703a 	and	r2,r3,r2
811329e4:	1001703a 	wrctl	status,r2
  
  return context;
811329e8:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
811329ec:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
811329f0:	d0a09117 	ldw	r2,-32188(gp)
811329f4:	d0a0a715 	stw	r2,-32100(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
811329f8:	d0209115 	stw	zero,-32188(gp)
811329fc:	e0bffa17 	ldw	r2,-24(fp)
81132a00:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132a04:	e0bffc17 	ldw	r2,-16(fp)
81132a08:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
81132a0c:	d0e0a717 	ldw	r3,-32100(gp)
81132a10:	d0a09717 	ldw	r2,-32164(gp)
81132a14:	1885203a 	divu	r2,r3,r2
81132a18:	1007883a 	mov	r3,r2
81132a1c:	00801904 	movi	r2,100
81132a20:	10c5c83a 	sub	r2,r2,r3
81132a24:	d0a09905 	stb	r2,-32156(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
81132a28:	1143a340 	call	81143a34 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
81132a2c:	1132a3c0 	call	81132a3c <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
81132a30:	01001904 	movi	r4,100
81132a34:	11394040 	call	81139404 <OSTimeDly>
    }
81132a38:	003fe506 	br	811329d0 <__reset+0xfb1129d0>

81132a3c <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
81132a3c:	defffa04 	addi	sp,sp,-24
81132a40:	de00012e 	bgeu	sp,et,81132a48 <OS_TaskStatStkChk+0xc>
81132a44:	003b68fa 	trap	3
81132a48:	dfc00515 	stw	ra,20(sp)
81132a4c:	df000415 	stw	fp,16(sp)
81132a50:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
81132a54:	e03ffc05 	stb	zero,-16(fp)
81132a58:	00002406 	br	81132aec <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
81132a5c:	e0bffc03 	ldbu	r2,-16(fp)
81132a60:	e0fffe04 	addi	r3,fp,-8
81132a64:	180b883a 	mov	r5,r3
81132a68:	1009883a 	mov	r4,r2
81132a6c:	1138eac0 	call	81138eac <OSTaskStkChk>
81132a70:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
81132a74:	e0bffc43 	ldbu	r2,-15(fp)
81132a78:	1000191e 	bne	r2,zero,81132ae0 <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
81132a7c:	e0fffc03 	ldbu	r3,-16(fp)
81132a80:	00a045b4 	movhi	r2,33046
81132a84:	1084d804 	addi	r2,r2,4960
81132a88:	18c7883a 	add	r3,r3,r3
81132a8c:	18c7883a 	add	r3,r3,r3
81132a90:	10c5883a 	add	r2,r2,r3
81132a94:	10800017 	ldw	r2,0(r2)
81132a98:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
81132a9c:	e0bffd17 	ldw	r2,-12(fp)
81132aa0:	10000f26 	beq	r2,zero,81132ae0 <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
81132aa4:	e0bffd17 	ldw	r2,-12(fp)
81132aa8:	10800060 	cmpeqi	r2,r2,1
81132aac:	10000c1e 	bne	r2,zero,81132ae0 <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
81132ab0:	e0bffd17 	ldw	r2,-12(fp)
81132ab4:	10c00217 	ldw	r3,8(r2)
81132ab8:	e0bffd17 	ldw	r2,-12(fp)
81132abc:	10800317 	ldw	r2,12(r2)
81132ac0:	1085883a 	add	r2,r2,r2
81132ac4:	1085883a 	add	r2,r2,r2
81132ac8:	1887883a 	add	r3,r3,r2
81132acc:	e0bffd17 	ldw	r2,-12(fp)
81132ad0:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
81132ad4:	e0ffff17 	ldw	r3,-4(fp)
81132ad8:	e0bffd17 	ldw	r2,-12(fp)
81132adc:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
81132ae0:	e0bffc03 	ldbu	r2,-16(fp)
81132ae4:	10800044 	addi	r2,r2,1
81132ae8:	e0bffc05 	stb	r2,-16(fp)
81132aec:	e0bffc03 	ldbu	r2,-16(fp)
81132af0:	10800af0 	cmpltui	r2,r2,43
81132af4:	103fd91e 	bne	r2,zero,81132a5c <__reset+0xfb112a5c>
#endif
                }
            }
        }
    }
}
81132af8:	0001883a 	nop
81132afc:	e037883a 	mov	sp,fp
81132b00:	dfc00117 	ldw	ra,4(sp)
81132b04:	df000017 	ldw	fp,0(sp)
81132b08:	dec00204 	addi	sp,sp,8
81132b0c:	f800283a 	ret

81132b10 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
81132b10:	defff204 	addi	sp,sp,-56
81132b14:	de00012e 	bgeu	sp,et,81132b1c <OS_TCBInit+0xc>
81132b18:	003b68fa 	trap	3
81132b1c:	dfc00d15 	stw	ra,52(sp)
81132b20:	df000c15 	stw	fp,48(sp)
81132b24:	df000c04 	addi	fp,sp,48
81132b28:	e17ffc15 	stw	r5,-16(fp)
81132b2c:	e1bffd15 	stw	r6,-12(fp)
81132b30:	3807883a 	mov	r3,r7
81132b34:	e0800417 	ldw	r2,16(fp)
81132b38:	e13ffb05 	stb	r4,-20(fp)
81132b3c:	e0fffe0d 	sth	r3,-8(fp)
81132b40:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81132b44:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132b48:	0005303a 	rdctl	r2,status
81132b4c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132b50:	e0fffa17 	ldw	r3,-24(fp)
81132b54:	00bfff84 	movi	r2,-2
81132b58:	1884703a 	and	r2,r3,r2
81132b5c:	1001703a 	wrctl	status,r2
  
  return context;
81132b60:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
81132b64:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
81132b68:	d0a09817 	ldw	r2,-32160(gp)
81132b6c:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
81132b70:	e0bff617 	ldw	r2,-40(fp)
81132b74:	10009326 	beq	r2,zero,81132dc4 <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
81132b78:	e0bff617 	ldw	r2,-40(fp)
81132b7c:	10800517 	ldw	r2,20(r2)
81132b80:	d0a09815 	stw	r2,-32160(gp)
81132b84:	e0bff417 	ldw	r2,-48(fp)
81132b88:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132b8c:	e0bff817 	ldw	r2,-32(fp)
81132b90:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
81132b94:	e0bff617 	ldw	r2,-40(fp)
81132b98:	e0fffc17 	ldw	r3,-16(fp)
81132b9c:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
81132ba0:	e0bff617 	ldw	r2,-40(fp)
81132ba4:	e0fffb03 	ldbu	r3,-20(fp)
81132ba8:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
81132bac:	e0bff617 	ldw	r2,-40(fp)
81132bb0:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
81132bb4:	e0bff617 	ldw	r2,-40(fp)
81132bb8:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
81132bbc:	e0bff617 	ldw	r2,-40(fp)
81132bc0:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
81132bc4:	e0bff617 	ldw	r2,-40(fp)
81132bc8:	e0c00317 	ldw	r3,12(fp)
81132bcc:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
81132bd0:	e0bff617 	ldw	r2,-40(fp)
81132bd4:	e0c00217 	ldw	r3,8(fp)
81132bd8:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
81132bdc:	e0bff617 	ldw	r2,-40(fp)
81132be0:	e0fffd17 	ldw	r3,-12(fp)
81132be4:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
81132be8:	e0bff617 	ldw	r2,-40(fp)
81132bec:	e0ffff0b 	ldhu	r3,-4(fp)
81132bf0:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
81132bf4:	e0bff617 	ldw	r2,-40(fp)
81132bf8:	e0fffe0b 	ldhu	r3,-8(fp)
81132bfc:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
81132c00:	e0bff617 	ldw	r2,-40(fp)
81132c04:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
81132c08:	e0bffb03 	ldbu	r2,-20(fp)
81132c0c:	1004d0fa 	srli	r2,r2,3
81132c10:	1007883a 	mov	r3,r2
81132c14:	e0bff617 	ldw	r2,-40(fp)
81132c18:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
81132c1c:	e0bffb03 	ldbu	r2,-20(fp)
81132c20:	108001cc 	andi	r2,r2,7
81132c24:	1007883a 	mov	r3,r2
81132c28:	e0bff617 	ldw	r2,-40(fp)
81132c2c:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
81132c30:	e0bff617 	ldw	r2,-40(fp)
81132c34:	10800d03 	ldbu	r2,52(r2)
81132c38:	10803fcc 	andi	r2,r2,255
81132c3c:	00c00044 	movi	r3,1
81132c40:	1884983a 	sll	r2,r3,r2
81132c44:	1007883a 	mov	r3,r2
81132c48:	e0bff617 	ldw	r2,-40(fp)
81132c4c:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
81132c50:	e0bff617 	ldw	r2,-40(fp)
81132c54:	10800cc3 	ldbu	r2,51(r2)
81132c58:	10803fcc 	andi	r2,r2,255
81132c5c:	00c00044 	movi	r3,1
81132c60:	1884983a 	sll	r2,r3,r2
81132c64:	1007883a 	mov	r3,r2
81132c68:	e0bff617 	ldw	r2,-40(fp)
81132c6c:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
81132c70:	e0bff617 	ldw	r2,-40(fp)
81132c74:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
81132c78:	e0bff617 	ldw	r2,-40(fp)
81132c7c:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
81132c80:	e0bff617 	ldw	r2,-40(fp)
81132c84:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
81132c88:	e0bff617 	ldw	r2,-40(fp)
81132c8c:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
81132c90:	e0bff617 	ldw	r2,-40(fp)
81132c94:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
81132c98:	e0bff617 	ldw	r2,-40(fp)
81132c9c:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
81132ca0:	e0bff617 	ldw	r2,-40(fp)
81132ca4:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
81132ca8:	e0bff617 	ldw	r2,-40(fp)
81132cac:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
81132cb0:	e0bff617 	ldw	r2,-40(fp)
81132cb4:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
81132cb8:	e0bff617 	ldw	r2,-40(fp)
81132cbc:	00c00fc4 	movi	r3,63
81132cc0:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
81132cc4:	e0bff617 	ldw	r2,-40(fp)
81132cc8:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
81132ccc:	e13ff617 	ldw	r4,-40(fp)
81132cd0:	1143b2c0 	call	81143b2c <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
81132cd4:	e13ff617 	ldw	r4,-40(fp)
81132cd8:	11439b40 	call	811439b4 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132cdc:	0005303a 	rdctl	r2,status
81132ce0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81132ce4:	e0fff517 	ldw	r3,-44(fp)
81132ce8:	00bfff84 	movi	r2,-2
81132cec:	1884703a 	and	r2,r3,r2
81132cf0:	1001703a 	wrctl	status,r2
  
  return context;
81132cf4:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
81132cf8:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
81132cfc:	e0fffb03 	ldbu	r3,-20(fp)
81132d00:	00a045b4 	movhi	r2,33046
81132d04:	1084d804 	addi	r2,r2,4960
81132d08:	18c7883a 	add	r3,r3,r3
81132d0c:	18c7883a 	add	r3,r3,r3
81132d10:	10c5883a 	add	r2,r2,r3
81132d14:	e0fff617 	ldw	r3,-40(fp)
81132d18:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
81132d1c:	d0e09317 	ldw	r3,-32180(gp)
81132d20:	e0bff617 	ldw	r2,-40(fp)
81132d24:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
81132d28:	e0bff617 	ldw	r2,-40(fp)
81132d2c:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
81132d30:	d0a09317 	ldw	r2,-32180(gp)
81132d34:	10000326 	beq	r2,zero,81132d44 <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
81132d38:	d0a09317 	ldw	r2,-32180(gp)
81132d3c:	e0fff617 	ldw	r3,-40(fp)
81132d40:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
81132d44:	e0bff617 	ldw	r2,-40(fp)
81132d48:	d0a09315 	stw	r2,-32180(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
81132d4c:	e0bff617 	ldw	r2,-40(fp)
81132d50:	10c00d83 	ldbu	r3,54(r2)
81132d54:	d0a09d03 	ldbu	r2,-32140(gp)
81132d58:	1884b03a 	or	r2,r3,r2
81132d5c:	d0a09d05 	stb	r2,-32140(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81132d60:	e0bff617 	ldw	r2,-40(fp)
81132d64:	10800d03 	ldbu	r2,52(r2)
81132d68:	10c03fcc 	andi	r3,r2,255
81132d6c:	e0bff617 	ldw	r2,-40(fp)
81132d70:	10800d03 	ldbu	r2,52(r2)
81132d74:	11003fcc 	andi	r4,r2,255
81132d78:	d0a09d44 	addi	r2,gp,-32139
81132d7c:	2085883a 	add	r2,r4,r2
81132d80:	11000003 	ldbu	r4,0(r2)
81132d84:	e0bff617 	ldw	r2,-40(fp)
81132d88:	10800d43 	ldbu	r2,53(r2)
81132d8c:	2084b03a 	or	r2,r4,r2
81132d90:	1009883a 	mov	r4,r2
81132d94:	d0a09d44 	addi	r2,gp,-32139
81132d98:	1885883a 	add	r2,r3,r2
81132d9c:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
81132da0:	d0a09943 	ldbu	r2,-32155(gp)
81132da4:	10800044 	addi	r2,r2,1
81132da8:	d0a09945 	stb	r2,-32155(gp)
81132dac:	e0bff417 	ldw	r2,-48(fp)
81132db0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132db4:	e0bff717 	ldw	r2,-36(fp)
81132db8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
81132dbc:	0005883a 	mov	r2,zero
81132dc0:	00000506 	br	81132dd8 <OS_TCBInit+0x2c8>
81132dc4:	e0bff417 	ldw	r2,-48(fp)
81132dc8:	e0bff915 	stw	r2,-28(fp)
81132dcc:	e0bff917 	ldw	r2,-28(fp)
81132dd0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
81132dd4:	00801084 	movi	r2,66
}
81132dd8:	e037883a 	mov	sp,fp
81132ddc:	dfc00117 	ldw	ra,4(sp)
81132de0:	df000017 	ldw	fp,0(sp)
81132de4:	dec00204 	addi	sp,sp,8
81132de8:	f800283a 	ret

81132dec <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
81132dec:	defffe04 	addi	sp,sp,-8
81132df0:	de00012e 	bgeu	sp,et,81132df8 <OSDebugInit+0xc>
81132df4:	003b68fa 	trap	3
81132df8:	df000115 	stw	fp,4(sp)
81132dfc:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
81132e00:	d0a01804 	addi	r2,gp,-32672
81132e04:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
81132e08:	d0a01904 	addi	r2,gp,-32668
81132e0c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
81132e10:	d0a01a84 	addi	r2,gp,-32662
81132e14:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
81132e18:	d0a01b04 	addi	r2,gp,-32660
81132e1c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
81132e20:	d0a01a04 	addi	r2,gp,-32664
81132e24:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
81132e28:	d0a01b84 	addi	r2,gp,-32658
81132e2c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
81132e30:	d0a01c04 	addi	r2,gp,-32656
81132e34:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
81132e38:	d0a01c84 	addi	r2,gp,-32654
81132e3c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
81132e40:	d0a01d04 	addi	r2,gp,-32652
81132e44:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
81132e48:	d0a01d84 	addi	r2,gp,-32650
81132e4c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
81132e50:	d0a01e04 	addi	r2,gp,-32648
81132e54:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
81132e58:	d0a01e84 	addi	r2,gp,-32646
81132e5c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
81132e60:	d0a01f04 	addi	r2,gp,-32644
81132e64:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
81132e68:	d0a01f84 	addi	r2,gp,-32642
81132e6c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
81132e70:	d0a02004 	addi	r2,gp,-32640
81132e74:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
81132e78:	d0a02084 	addi	r2,gp,-32638
81132e7c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
81132e80:	d0a02104 	addi	r2,gp,-32636
81132e84:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
81132e88:	d0a02184 	addi	r2,gp,-32634
81132e8c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
81132e90:	d0a02204 	addi	r2,gp,-32632
81132e94:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
81132e98:	d0a02284 	addi	r2,gp,-32630
81132e9c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
81132ea0:	d0a02304 	addi	r2,gp,-32628
81132ea4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
81132ea8:	d0a02384 	addi	r2,gp,-32626
81132eac:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
81132eb0:	d0a02404 	addi	r2,gp,-32624
81132eb4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
81132eb8:	d0a02484 	addi	r2,gp,-32622
81132ebc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
81132ec0:	d0a02504 	addi	r2,gp,-32620
81132ec4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
81132ec8:	d0a02584 	addi	r2,gp,-32618
81132ecc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
81132ed0:	d0a02604 	addi	r2,gp,-32616
81132ed4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
81132ed8:	d0a02684 	addi	r2,gp,-32614
81132edc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
81132ee0:	d0a02704 	addi	r2,gp,-32612
81132ee4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
81132ee8:	d0a02784 	addi	r2,gp,-32610
81132eec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
81132ef0:	d0a02804 	addi	r2,gp,-32608
81132ef4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
81132ef8:	d0a02884 	addi	r2,gp,-32606
81132efc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
81132f00:	d0a02904 	addi	r2,gp,-32604
81132f04:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
81132f08:	d0a02984 	addi	r2,gp,-32602
81132f0c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
81132f10:	d0a02a04 	addi	r2,gp,-32600
81132f14:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
81132f18:	d0a02a84 	addi	r2,gp,-32598
81132f1c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
81132f20:	d0a02b04 	addi	r2,gp,-32596
81132f24:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
81132f28:	d0a02b84 	addi	r2,gp,-32594
81132f2c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
81132f30:	d0a02c04 	addi	r2,gp,-32592
81132f34:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
81132f38:	d0a02c84 	addi	r2,gp,-32590
81132f3c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
81132f40:	d0a02d04 	addi	r2,gp,-32588
81132f44:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
81132f48:	d0a02d84 	addi	r2,gp,-32586
81132f4c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
81132f50:	d0a02e04 	addi	r2,gp,-32584
81132f54:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
81132f58:	d0a02e84 	addi	r2,gp,-32582
81132f5c:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
81132f60:	00a045b4 	movhi	r2,33046
81132f64:	10aef604 	addi	r2,r2,-17448
81132f68:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
81132f6c:	00a045b4 	movhi	r2,33046
81132f70:	10ace204 	addi	r2,r2,-19576
81132f74:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
81132f78:	d0a02f84 	addi	r2,gp,-32578
81132f7c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
81132f80:	d0a03004 	addi	r2,gp,-32576
81132f84:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
81132f88:	d0a03084 	addi	r2,gp,-32574
81132f8c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
81132f90:	d0a03104 	addi	r2,gp,-32572
81132f94:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
81132f98:	d0a03184 	addi	r2,gp,-32570
81132f9c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
81132fa0:	d0a03204 	addi	r2,gp,-32568
81132fa4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
81132fa8:	d0a03284 	addi	r2,gp,-32566
81132fac:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
81132fb0:	d0a03304 	addi	r2,gp,-32564
81132fb4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
81132fb8:	d0a03384 	addi	r2,gp,-32562
81132fbc:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
81132fc0:	d0a02f04 	addi	r2,gp,-32580
81132fc4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
81132fc8:	d0a03404 	addi	r2,gp,-32560
81132fcc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
81132fd0:	0001883a 	nop
81132fd4:	e037883a 	mov	sp,fp
81132fd8:	df000017 	ldw	fp,0(sp)
81132fdc:	dec00104 	addi	sp,sp,4
81132fe0:	f800283a 	ret

81132fe4 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
81132fe4:	defff204 	addi	sp,sp,-56
81132fe8:	de00012e 	bgeu	sp,et,81132ff0 <OSFlagAccept+0xc>
81132fec:	003b68fa 	trap	3
81132ff0:	df000d15 	stw	fp,52(sp)
81132ff4:	df000d04 	addi	fp,sp,52
81132ff8:	e13ffc15 	stw	r4,-16(fp)
81132ffc:	2807883a 	mov	r3,r5
81133000:	3005883a 	mov	r2,r6
81133004:	e1ffff15 	stw	r7,-4(fp)
81133008:	e0fffd0d 	sth	r3,-12(fp)
8113300c:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81133010:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81133014:	e0bfff17 	ldw	r2,-4(fp)
81133018:	1000021e 	bne	r2,zero,81133024 <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
8113301c:	0005883a 	mov	r2,zero
81133020:	0000b006 	br	811332e4 <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81133024:	e0bffc17 	ldw	r2,-16(fp)
81133028:	1000051e 	bne	r2,zero,81133040 <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
8113302c:	e0bfff17 	ldw	r2,-4(fp)
81133030:	00c01b84 	movi	r3,110
81133034:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81133038:	0005883a 	mov	r2,zero
8113303c:	0000a906 	br	811332e4 <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
81133040:	e0bffc17 	ldw	r2,-16(fp)
81133044:	10800003 	ldbu	r2,0(r2)
81133048:	10803fcc 	andi	r2,r2,255
8113304c:	10800160 	cmpeqi	r2,r2,5
81133050:	1000051e 	bne	r2,zero,81133068 <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
81133054:	e0bfff17 	ldw	r2,-4(fp)
81133058:	00c00044 	movi	r3,1
8113305c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81133060:	0005883a 	mov	r2,zero
81133064:	00009f06 	br	811332e4 <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
81133068:	e0fffe03 	ldbu	r3,-8(fp)
8113306c:	00bfe004 	movi	r2,-128
81133070:	1884703a 	and	r2,r3,r2
81133074:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
81133078:	e0bff503 	ldbu	r2,-44(fp)
8113307c:	10000626 	beq	r2,zero,81133098 <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
81133080:	e0bffe03 	ldbu	r2,-8(fp)
81133084:	10801fcc 	andi	r2,r2,127
81133088:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113308c:	00800044 	movi	r2,1
81133090:	e0bff385 	stb	r2,-50(fp)
81133094:	00000106 	br	8113309c <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
81133098:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
8113309c:	e0bfff17 	ldw	r2,-4(fp)
811330a0:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811330a4:	0005303a 	rdctl	r2,status
811330a8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811330ac:	e0fffb17 	ldw	r3,-20(fp)
811330b0:	00bfff84 	movi	r2,-2
811330b4:	1884703a 	and	r2,r3,r2
811330b8:	1001703a 	wrctl	status,r2
  
  return context;
811330bc:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
811330c0:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
811330c4:	e0bffe03 	ldbu	r2,-8(fp)
811330c8:	10c00060 	cmpeqi	r3,r2,1
811330cc:	18005f1e 	bne	r3,zero,8113324c <OSFlagAccept+0x268>
811330d0:	10c00088 	cmpgei	r3,r2,2
811330d4:	1800021e 	bne	r3,zero,811330e0 <OSFlagAccept+0xfc>
811330d8:	10003f26 	beq	r2,zero,811331d8 <OSFlagAccept+0x1f4>
811330dc:	00007706 	br	811332bc <OSFlagAccept+0x2d8>
811330e0:	10c000a0 	cmpeqi	r3,r2,2
811330e4:	1800031e 	bne	r3,zero,811330f4 <OSFlagAccept+0x110>
811330e8:	108000e0 	cmpeqi	r2,r2,3
811330ec:	10001e1e 	bne	r2,zero,81133168 <OSFlagAccept+0x184>
811330f0:	00007206 	br	811332bc <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
811330f4:	e0bffc17 	ldw	r2,-16(fp)
811330f8:	10c0020b 	ldhu	r3,8(r2)
811330fc:	e0bffd0b 	ldhu	r2,-12(fp)
81133100:	1884703a 	and	r2,r3,r2
81133104:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81133108:	e0fff30b 	ldhu	r3,-52(fp)
8113310c:	e0bffd0b 	ldhu	r2,-12(fp)
81133110:	18800d1e 	bne	r3,r2,81133148 <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81133114:	e0bff383 	ldbu	r2,-50(fp)
81133118:	10800058 	cmpnei	r2,r2,1
8113311c:	10000d1e 	bne	r2,zero,81133154 <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
81133120:	e0bffc17 	ldw	r2,-16(fp)
81133124:	1080020b 	ldhu	r2,8(r2)
81133128:	1007883a 	mov	r3,r2
8113312c:	e0bff30b 	ldhu	r2,-52(fp)
81133130:	0084303a 	nor	r2,zero,r2
81133134:	1884703a 	and	r2,r3,r2
81133138:	1007883a 	mov	r3,r2
8113313c:	e0bffc17 	ldw	r2,-16(fp)
81133140:	10c0020d 	sth	r3,8(r2)
81133144:	00000306 	br	81133154 <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81133148:	e0bfff17 	ldw	r2,-4(fp)
8113314c:	00c01c04 	movi	r3,112
81133150:	10c00005 	stb	r3,0(r2)
81133154:	e0bff417 	ldw	r2,-48(fp)
81133158:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113315c:	e0bff617 	ldw	r2,-40(fp)
81133160:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81133164:	00005e06 	br	811332e0 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
81133168:	e0bffc17 	ldw	r2,-16(fp)
8113316c:	10c0020b 	ldhu	r3,8(r2)
81133170:	e0bffd0b 	ldhu	r2,-12(fp)
81133174:	1884703a 	and	r2,r3,r2
81133178:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113317c:	e0bff30b 	ldhu	r2,-52(fp)
81133180:	10000d26 	beq	r2,zero,811331b8 <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81133184:	e0bff383 	ldbu	r2,-50(fp)
81133188:	10800058 	cmpnei	r2,r2,1
8113318c:	10000d1e 	bne	r2,zero,811331c4 <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
81133190:	e0bffc17 	ldw	r2,-16(fp)
81133194:	1080020b 	ldhu	r2,8(r2)
81133198:	1007883a 	mov	r3,r2
8113319c:	e0bff30b 	ldhu	r2,-52(fp)
811331a0:	0084303a 	nor	r2,zero,r2
811331a4:	1884703a 	and	r2,r3,r2
811331a8:	1007883a 	mov	r3,r2
811331ac:	e0bffc17 	ldw	r2,-16(fp)
811331b0:	10c0020d 	sth	r3,8(r2)
811331b4:	00000306 	br	811331c4 <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
811331b8:	e0bfff17 	ldw	r2,-4(fp)
811331bc:	00c01c04 	movi	r3,112
811331c0:	10c00005 	stb	r3,0(r2)
811331c4:	e0bff417 	ldw	r2,-48(fp)
811331c8:	e0bff715 	stw	r2,-36(fp)
811331cc:	e0bff717 	ldw	r2,-36(fp)
811331d0:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
811331d4:	00004206 	br	811332e0 <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
811331d8:	e0bffc17 	ldw	r2,-16(fp)
811331dc:	1080020b 	ldhu	r2,8(r2)
811331e0:	0084303a 	nor	r2,zero,r2
811331e4:	1007883a 	mov	r3,r2
811331e8:	e0bffd0b 	ldhu	r2,-12(fp)
811331ec:	1884703a 	and	r2,r3,r2
811331f0:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
811331f4:	e0fff30b 	ldhu	r3,-52(fp)
811331f8:	e0bffd0b 	ldhu	r2,-12(fp)
811331fc:	18800b1e 	bne	r3,r2,8113322c <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81133200:	e0bff383 	ldbu	r2,-50(fp)
81133204:	10800058 	cmpnei	r2,r2,1
81133208:	10000b1e 	bne	r2,zero,81133238 <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
8113320c:	e0bffc17 	ldw	r2,-16(fp)
81133210:	10c0020b 	ldhu	r3,8(r2)
81133214:	e0bff30b 	ldhu	r2,-52(fp)
81133218:	1884b03a 	or	r2,r3,r2
8113321c:	1007883a 	mov	r3,r2
81133220:	e0bffc17 	ldw	r2,-16(fp)
81133224:	10c0020d 	sth	r3,8(r2)
81133228:	00000306 	br	81133238 <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113322c:	e0bfff17 	ldw	r2,-4(fp)
81133230:	00c01c04 	movi	r3,112
81133234:	10c00005 	stb	r3,0(r2)
81133238:	e0bff417 	ldw	r2,-48(fp)
8113323c:	e0bff815 	stw	r2,-32(fp)
81133240:	e0bff817 	ldw	r2,-32(fp)
81133244:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81133248:	00002506 	br	811332e0 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
8113324c:	e0bffc17 	ldw	r2,-16(fp)
81133250:	1080020b 	ldhu	r2,8(r2)
81133254:	0084303a 	nor	r2,zero,r2
81133258:	1007883a 	mov	r3,r2
8113325c:	e0bffd0b 	ldhu	r2,-12(fp)
81133260:	1884703a 	and	r2,r3,r2
81133264:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
81133268:	e0bff30b 	ldhu	r2,-52(fp)
8113326c:	10000b26 	beq	r2,zero,8113329c <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81133270:	e0bff383 	ldbu	r2,-50(fp)
81133274:	10800058 	cmpnei	r2,r2,1
81133278:	10000b1e 	bne	r2,zero,811332a8 <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113327c:	e0bffc17 	ldw	r2,-16(fp)
81133280:	10c0020b 	ldhu	r3,8(r2)
81133284:	e0bff30b 	ldhu	r2,-52(fp)
81133288:	1884b03a 	or	r2,r3,r2
8113328c:	1007883a 	mov	r3,r2
81133290:	e0bffc17 	ldw	r2,-16(fp)
81133294:	10c0020d 	sth	r3,8(r2)
81133298:	00000306 	br	811332a8 <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113329c:	e0bfff17 	ldw	r2,-4(fp)
811332a0:	00c01c04 	movi	r3,112
811332a4:	10c00005 	stb	r3,0(r2)
811332a8:	e0bff417 	ldw	r2,-48(fp)
811332ac:	e0bff915 	stw	r2,-28(fp)
811332b0:	e0bff917 	ldw	r2,-28(fp)
811332b4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
811332b8:	00000906 	br	811332e0 <OSFlagAccept+0x2fc>
811332bc:	e0bff417 	ldw	r2,-48(fp)
811332c0:	e0bffa15 	stw	r2,-24(fp)
811332c4:	e0bffa17 	ldw	r2,-24(fp)
811332c8:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
811332cc:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
811332d0:	e0bfff17 	ldw	r2,-4(fp)
811332d4:	00c01bc4 	movi	r3,111
811332d8:	10c00005 	stb	r3,0(r2)
             break;
811332dc:	0001883a 	nop
    }
    return (flags_rdy);
811332e0:	e0bff30b 	ldhu	r2,-52(fp)
}
811332e4:	e037883a 	mov	sp,fp
811332e8:	df000017 	ldw	fp,0(sp)
811332ec:	dec00104 	addi	sp,sp,4
811332f0:	f800283a 	ret

811332f4 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
811332f4:	defff804 	addi	sp,sp,-32
811332f8:	de00012e 	bgeu	sp,et,81133300 <OSFlagCreate+0xc>
811332fc:	003b68fa 	trap	3
81133300:	df000715 	stw	fp,28(sp)
81133304:	df000704 	addi	fp,sp,28
81133308:	2005883a 	mov	r2,r4
8113330c:	e17fff15 	stw	r5,-4(fp)
81133310:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
81133314:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
81133318:	e0bfff17 	ldw	r2,-4(fp)
8113331c:	1000021e 	bne	r2,zero,81133328 <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
81133320:	0005883a 	mov	r2,zero
81133324:	00003306 	br	811333f4 <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
81133328:	d0a0a003 	ldbu	r2,-32128(gp)
8113332c:	10803fcc 	andi	r2,r2,255
81133330:	10000526 	beq	r2,zero,81133348 <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
81133334:	e0bfff17 	ldw	r2,-4(fp)
81133338:	00c00404 	movi	r3,16
8113333c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
81133340:	0005883a 	mov	r2,zero
81133344:	00002b06 	br	811333f4 <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133348:	0005303a 	rdctl	r2,status
8113334c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133350:	e0fffd17 	ldw	r3,-12(fp)
81133354:	00bfff84 	movi	r2,-2
81133358:	1884703a 	and	r2,r3,r2
8113335c:	1001703a 	wrctl	status,r2
  
  return context;
81133360:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81133364:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
81133368:	d0a0a517 	ldw	r2,-32108(gp)
8113336c:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
81133370:	e0bffb17 	ldw	r2,-20(fp)
81133374:	10001726 	beq	r2,zero,811333d4 <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
81133378:	d0a0a517 	ldw	r2,-32108(gp)
8113337c:	10800117 	ldw	r2,4(r2)
81133380:	d0a0a515 	stw	r2,-32108(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
81133384:	e0bffb17 	ldw	r2,-20(fp)
81133388:	00c00144 	movi	r3,5
8113338c:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
81133390:	e0bffb17 	ldw	r2,-20(fp)
81133394:	e0fffe0b 	ldhu	r3,-8(fp)
81133398:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
8113339c:	e0bffb17 	ldw	r2,-20(fp)
811333a0:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
811333a4:	e0bffb17 	ldw	r2,-20(fp)
811333a8:	00c00fc4 	movi	r3,63
811333ac:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
811333b0:	e0bffb17 	ldw	r2,-20(fp)
811333b4:	100002c5 	stb	zero,11(r2)
811333b8:	e0bff917 	ldw	r2,-28(fp)
811333bc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811333c0:	e0bffa17 	ldw	r2,-24(fp)
811333c4:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
811333c8:	e0bfff17 	ldw	r2,-4(fp)
811333cc:	10000005 	stb	zero,0(r2)
811333d0:	00000706 	br	811333f0 <OSFlagCreate+0xfc>
811333d4:	e0bff917 	ldw	r2,-28(fp)
811333d8:	e0bffc15 	stw	r2,-16(fp)
811333dc:	e0bffc17 	ldw	r2,-16(fp)
811333e0:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
811333e4:	e0bfff17 	ldw	r2,-4(fp)
811333e8:	00c01c84 	movi	r3,114
811333ec:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
811333f0:	e0bffb17 	ldw	r2,-20(fp)
}
811333f4:	e037883a 	mov	sp,fp
811333f8:	df000017 	ldw	fp,0(sp)
811333fc:	dec00104 	addi	sp,sp,4
81133400:	f800283a 	ret

81133404 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
81133404:	defff204 	addi	sp,sp,-56
81133408:	de00012e 	bgeu	sp,et,81133410 <OSFlagDel+0xc>
8113340c:	003b68fa 	trap	3
81133410:	dfc00d15 	stw	ra,52(sp)
81133414:	df000c15 	stw	fp,48(sp)
81133418:	df000c04 	addi	fp,sp,48
8113341c:	e13ffd15 	stw	r4,-12(fp)
81133420:	2805883a 	mov	r2,r5
81133424:	e1bfff15 	stw	r6,-4(fp)
81133428:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113342c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81133430:	e0bfff17 	ldw	r2,-4(fp)
81133434:	1000021e 	bne	r2,zero,81133440 <OSFlagDel+0x3c>
        return (pgrp);
81133438:	e0bffd17 	ldw	r2,-12(fp)
8113343c:	00008006 	br	81133640 <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81133440:	e0bffd17 	ldw	r2,-12(fp)
81133444:	1000051e 	bne	r2,zero,8113345c <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81133448:	e0bfff17 	ldw	r2,-4(fp)
8113344c:	00c01b84 	movi	r3,110
81133450:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81133454:	e0bffd17 	ldw	r2,-12(fp)
81133458:	00007906 	br	81133640 <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113345c:	d0a0a003 	ldbu	r2,-32128(gp)
81133460:	10803fcc 	andi	r2,r2,255
81133464:	10000526 	beq	r2,zero,8113347c <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
81133468:	e0bfff17 	ldw	r2,-4(fp)
8113346c:	00c003c4 	movi	r3,15
81133470:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81133474:	e0bffd17 	ldw	r2,-12(fp)
81133478:	00007106 	br	81133640 <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
8113347c:	e0bffd17 	ldw	r2,-12(fp)
81133480:	10800003 	ldbu	r2,0(r2)
81133484:	10803fcc 	andi	r2,r2,255
81133488:	10800160 	cmpeqi	r2,r2,5
8113348c:	1000051e 	bne	r2,zero,811334a4 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
81133490:	e0bfff17 	ldw	r2,-4(fp)
81133494:	00c00044 	movi	r3,1
81133498:	10c00005 	stb	r3,0(r2)
        return (pgrp);
8113349c:	e0bffd17 	ldw	r2,-12(fp)
811334a0:	00006706 	br	81133640 <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811334a4:	0005303a 	rdctl	r2,status
811334a8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811334ac:	e0fffc17 	ldw	r3,-16(fp)
811334b0:	00bfff84 	movi	r2,-2
811334b4:	1884703a 	and	r2,r3,r2
811334b8:	1001703a 	wrctl	status,r2
  
  return context;
811334bc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811334c0:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
811334c4:	e0bffd17 	ldw	r2,-12(fp)
811334c8:	10800117 	ldw	r2,4(r2)
811334cc:	10000326 	beq	r2,zero,811334dc <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
811334d0:	00800044 	movi	r2,1
811334d4:	e0bff405 	stb	r2,-48(fp)
811334d8:	00000106 	br	811334e0 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
811334dc:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
811334e0:	e0bffe03 	ldbu	r2,-8(fp)
811334e4:	10000326 	beq	r2,zero,811334f4 <OSFlagDel+0xf0>
811334e8:	10800060 	cmpeqi	r2,r2,1
811334ec:	1000231e 	bne	r2,zero,8113357c <OSFlagDel+0x178>
811334f0:	00004806 	br	81133614 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
811334f4:	e0bff403 	ldbu	r2,-48(fp)
811334f8:	1000161e 	bne	r2,zero,81133554 <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
811334fc:	e0bffd17 	ldw	r2,-12(fp)
81133500:	00c00fc4 	movi	r3,63
81133504:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81133508:	e0bffd17 	ldw	r2,-12(fp)
8113350c:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81133510:	e0bffd17 	ldw	r2,-12(fp)
81133514:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
81133518:	d0e0a517 	ldw	r3,-32108(gp)
8113351c:	e0bffd17 	ldw	r2,-12(fp)
81133520:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
81133524:	e0bffd17 	ldw	r2,-12(fp)
81133528:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
8113352c:	e0bffd17 	ldw	r2,-12(fp)
81133530:	d0a0a515 	stw	r2,-32108(gp)
81133534:	e0bff717 	ldw	r2,-36(fp)
81133538:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113353c:	e0bff817 	ldw	r2,-32(fp)
81133540:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
81133544:	e0bfff17 	ldw	r2,-4(fp)
81133548:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
8113354c:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
81133550:	00003a06 	br	8113363c <OSFlagDel+0x238>
81133554:	e0bff717 	ldw	r2,-36(fp)
81133558:	e0bff915 	stw	r2,-28(fp)
8113355c:	e0bff917 	ldw	r2,-28(fp)
81133560:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
81133564:	e0bfff17 	ldw	r2,-4(fp)
81133568:	00c01244 	movi	r3,73
8113356c:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
81133570:	e0bffd17 	ldw	r2,-12(fp)
81133574:	e0bff615 	stw	r2,-40(fp)
             }
             break;
81133578:	00003006 	br	8113363c <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113357c:	e0bffd17 	ldw	r2,-12(fp)
81133580:	10800117 	ldw	r2,4(r2)
81133584:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
81133588:	00000606 	br	811335a4 <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
8113358c:	000b883a 	mov	r5,zero
81133590:	e13ff517 	ldw	r4,-44(fp)
81133594:	11345b80 	call	811345b8 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
81133598:	e0bff517 	ldw	r2,-44(fp)
8113359c:	10800017 	ldw	r2,0(r2)
811335a0:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
811335a4:	e0bff517 	ldw	r2,-44(fp)
811335a8:	103ff81e 	bne	r2,zero,8113358c <__reset+0xfb11358c>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
811335ac:	e0bffd17 	ldw	r2,-12(fp)
811335b0:	00c00fc4 	movi	r3,63
811335b4:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
811335b8:	e0bffd17 	ldw	r2,-12(fp)
811335bc:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
811335c0:	e0bffd17 	ldw	r2,-12(fp)
811335c4:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
811335c8:	d0e0a517 	ldw	r3,-32108(gp)
811335cc:	e0bffd17 	ldw	r2,-12(fp)
811335d0:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
811335d4:	e0bffd17 	ldw	r2,-12(fp)
811335d8:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
811335dc:	e0bffd17 	ldw	r2,-12(fp)
811335e0:	d0a0a515 	stw	r2,-32108(gp)
811335e4:	e0bff717 	ldw	r2,-36(fp)
811335e8:	e0bffa15 	stw	r2,-24(fp)
811335ec:	e0bffa17 	ldw	r2,-24(fp)
811335f0:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
811335f4:	e0bff403 	ldbu	r2,-48(fp)
811335f8:	10800058 	cmpnei	r2,r2,1
811335fc:	1000011e 	bne	r2,zero,81133604 <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81133600:	11326c80 	call	811326c8 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
81133604:	e0bfff17 	ldw	r2,-4(fp)
81133608:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
8113360c:	e03ff615 	stw	zero,-40(fp)
             break;
81133610:	00000a06 	br	8113363c <OSFlagDel+0x238>
81133614:	e0bff717 	ldw	r2,-36(fp)
81133618:	e0bffb15 	stw	r2,-20(fp)
8113361c:	e0bffb17 	ldw	r2,-20(fp)
81133620:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
81133624:	e0bfff17 	ldw	r2,-4(fp)
81133628:	00c001c4 	movi	r3,7
8113362c:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
81133630:	e0bffd17 	ldw	r2,-12(fp)
81133634:	e0bff615 	stw	r2,-40(fp)
             break;
81133638:	0001883a 	nop
    }
    return (pgrp_return);
8113363c:	e0bff617 	ldw	r2,-40(fp)
}
81133640:	e037883a 	mov	sp,fp
81133644:	dfc00117 	ldw	ra,4(sp)
81133648:	df000017 	ldw	fp,0(sp)
8113364c:	dec00204 	addi	sp,sp,8
81133650:	f800283a 	ret

81133654 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
81133654:	defff604 	addi	sp,sp,-40
81133658:	de00012e 	bgeu	sp,et,81133660 <OSFlagNameGet+0xc>
8113365c:	003b68fa 	trap	3
81133660:	dfc00915 	stw	ra,36(sp)
81133664:	df000815 	stw	fp,32(sp)
81133668:	df000804 	addi	fp,sp,32
8113366c:	e13ffd15 	stw	r4,-12(fp)
81133670:	e17ffe15 	stw	r5,-8(fp)
81133674:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81133678:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113367c:	e0bfff17 	ldw	r2,-4(fp)
81133680:	1000021e 	bne	r2,zero,8113368c <OSFlagNameGet+0x38>
        return (0);
81133684:	0005883a 	mov	r2,zero
81133688:	00003906 	br	81133770 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
8113368c:	e0bffd17 	ldw	r2,-12(fp)
81133690:	1000051e 	bne	r2,zero,811336a8 <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81133694:	e0bfff17 	ldw	r2,-4(fp)
81133698:	00c01b84 	movi	r3,110
8113369c:	10c00005 	stb	r3,0(r2)
        return (0);
811336a0:	0005883a 	mov	r2,zero
811336a4:	00003206 	br	81133770 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
811336a8:	e0bffe17 	ldw	r2,-8(fp)
811336ac:	1000051e 	bne	r2,zero,811336c4 <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
811336b0:	e0bfff17 	ldw	r2,-4(fp)
811336b4:	00c00304 	movi	r3,12
811336b8:	10c00005 	stb	r3,0(r2)
        return (0);
811336bc:	0005883a 	mov	r2,zero
811336c0:	00002b06 	br	81133770 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
811336c4:	d0a0a003 	ldbu	r2,-32128(gp)
811336c8:	10803fcc 	andi	r2,r2,255
811336cc:	10000526 	beq	r2,zero,811336e4 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
811336d0:	e0bfff17 	ldw	r2,-4(fp)
811336d4:	00c00444 	movi	r3,17
811336d8:	10c00005 	stb	r3,0(r2)
        return (0);
811336dc:	0005883a 	mov	r2,zero
811336e0:	00002306 	br	81133770 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811336e4:	0005303a 	rdctl	r2,status
811336e8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811336ec:	e0fffc17 	ldw	r3,-16(fp)
811336f0:	00bfff84 	movi	r2,-2
811336f4:	1884703a 	and	r2,r3,r2
811336f8:	1001703a 	wrctl	status,r2
  
  return context;
811336fc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81133700:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
81133704:	e0bffd17 	ldw	r2,-12(fp)
81133708:	10800003 	ldbu	r2,0(r2)
8113370c:	10803fcc 	andi	r2,r2,255
81133710:	10800160 	cmpeqi	r2,r2,5
81133714:	1000091e 	bne	r2,zero,8113373c <OSFlagNameGet+0xe8>
81133718:	e0bff817 	ldw	r2,-32(fp)
8113371c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133720:	e0bff917 	ldw	r2,-28(fp)
81133724:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
81133728:	e0bfff17 	ldw	r2,-4(fp)
8113372c:	00c00044 	movi	r3,1
81133730:	10c00005 	stb	r3,0(r2)
        return (0);
81133734:	0005883a 	mov	r2,zero
81133738:	00000d06 	br	81133770 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
8113373c:	e0bffd17 	ldw	r2,-12(fp)
81133740:	10800284 	addi	r2,r2,10
81133744:	100b883a 	mov	r5,r2
81133748:	e13ffe17 	ldw	r4,-8(fp)
8113374c:	113281c0 	call	8113281c <OS_StrCopy>
81133750:	e0bffb05 	stb	r2,-20(fp)
81133754:	e0bff817 	ldw	r2,-32(fp)
81133758:	e0bffa15 	stw	r2,-24(fp)
8113375c:	e0bffa17 	ldw	r2,-24(fp)
81133760:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81133764:	e0bfff17 	ldw	r2,-4(fp)
81133768:	10000005 	stb	zero,0(r2)
    return (len);
8113376c:	e0bffb03 	ldbu	r2,-20(fp)
}
81133770:	e037883a 	mov	sp,fp
81133774:	dfc00117 	ldw	ra,4(sp)
81133778:	df000017 	ldw	fp,0(sp)
8113377c:	dec00204 	addi	sp,sp,8
81133780:	f800283a 	ret

81133784 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
81133784:	defff504 	addi	sp,sp,-44
81133788:	de00012e 	bgeu	sp,et,81133790 <OSFlagNameSet+0xc>
8113378c:	003b68fa 	trap	3
81133790:	dfc00a15 	stw	ra,40(sp)
81133794:	df000915 	stw	fp,36(sp)
81133798:	df000904 	addi	fp,sp,36
8113379c:	e13ffd15 	stw	r4,-12(fp)
811337a0:	e17ffe15 	stw	r5,-8(fp)
811337a4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811337a8:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811337ac:	e0bfff17 	ldw	r2,-4(fp)
811337b0:	10004326 	beq	r2,zero,811338c0 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
811337b4:	e0bffd17 	ldw	r2,-12(fp)
811337b8:	1000041e 	bne	r2,zero,811337cc <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811337bc:	e0bfff17 	ldw	r2,-4(fp)
811337c0:	00c01b84 	movi	r3,110
811337c4:	10c00005 	stb	r3,0(r2)
        return;
811337c8:	00003e06 	br	811338c4 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
811337cc:	e0bffe17 	ldw	r2,-8(fp)
811337d0:	1000041e 	bne	r2,zero,811337e4 <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
811337d4:	e0bfff17 	ldw	r2,-4(fp)
811337d8:	00c00304 	movi	r3,12
811337dc:	10c00005 	stb	r3,0(r2)
        return;
811337e0:	00003806 	br	811338c4 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
811337e4:	d0a0a003 	ldbu	r2,-32128(gp)
811337e8:	10803fcc 	andi	r2,r2,255
811337ec:	10000426 	beq	r2,zero,81133800 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
811337f0:	e0bfff17 	ldw	r2,-4(fp)
811337f4:	00c00484 	movi	r3,18
811337f8:	10c00005 	stb	r3,0(r2)
        return;
811337fc:	00003106 	br	811338c4 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133800:	0005303a 	rdctl	r2,status
81133804:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133808:	e0fffc17 	ldw	r3,-16(fp)
8113380c:	00bfff84 	movi	r2,-2
81133810:	1884703a 	and	r2,r3,r2
81133814:	1001703a 	wrctl	status,r2
  
  return context;
81133818:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113381c:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
81133820:	e0bffd17 	ldw	r2,-12(fp)
81133824:	10800003 	ldbu	r2,0(r2)
81133828:	10803fcc 	andi	r2,r2,255
8113382c:	10800160 	cmpeqi	r2,r2,5
81133830:	1000081e 	bne	r2,zero,81133854 <OSFlagNameSet+0xd0>
81133834:	e0bff717 	ldw	r2,-36(fp)
81133838:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113383c:	e0bff817 	ldw	r2,-32(fp)
81133840:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
81133844:	e0bfff17 	ldw	r2,-4(fp)
81133848:	00c00044 	movi	r3,1
8113384c:	10c00005 	stb	r3,0(r2)
        return;
81133850:	00001c06 	br	811338c4 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
81133854:	e13ffe17 	ldw	r4,-8(fp)
81133858:	11328980 	call	81132898 <OS_StrLen>
8113385c:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
81133860:	e0bffa03 	ldbu	r2,-24(fp)
81133864:	10800830 	cmpltui	r2,r2,32
81133868:	1000081e 	bne	r2,zero,8113388c <OSFlagNameSet+0x108>
8113386c:	e0bff717 	ldw	r2,-36(fp)
81133870:	e0bff915 	stw	r2,-28(fp)
81133874:	e0bff917 	ldw	r2,-28(fp)
81133878:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
8113387c:	e0bfff17 	ldw	r2,-4(fp)
81133880:	00c01cc4 	movi	r3,115
81133884:	10c00005 	stb	r3,0(r2)
        return;
81133888:	00000e06 	br	811338c4 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
8113388c:	e0bffd17 	ldw	r2,-12(fp)
81133890:	10800284 	addi	r2,r2,10
81133894:	e17ffe17 	ldw	r5,-8(fp)
81133898:	1009883a 	mov	r4,r2
8113389c:	113281c0 	call	8113281c <OS_StrCopy>
811338a0:	e0bff717 	ldw	r2,-36(fp)
811338a4:	e0bffb15 	stw	r2,-20(fp)
811338a8:	e0bffb17 	ldw	r2,-20(fp)
811338ac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811338b0:	e0bfff17 	ldw	r2,-4(fp)
811338b4:	10000005 	stb	zero,0(r2)
    return;
811338b8:	0001883a 	nop
811338bc:	00000106 	br	811338c4 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
811338c0:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
811338c4:	e037883a 	mov	sp,fp
811338c8:	dfc00117 	ldw	ra,4(sp)
811338cc:	df000017 	ldw	fp,0(sp)
811338d0:	dec00204 	addi	sp,sp,8
811338d4:	f800283a 	ret

811338d8 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
811338d8:	deffe104 	addi	sp,sp,-124
811338dc:	de00012e 	bgeu	sp,et,811338e4 <OSFlagPend+0xc>
811338e0:	003b68fa 	trap	3
811338e4:	dfc01e15 	stw	ra,120(sp)
811338e8:	df001d15 	stw	fp,116(sp)
811338ec:	df001d04 	addi	fp,sp,116
811338f0:	e13ffc15 	stw	r4,-16(fp)
811338f4:	2809883a 	mov	r4,r5
811338f8:	3007883a 	mov	r3,r6
811338fc:	3805883a 	mov	r2,r7
81133900:	e13ffd0d 	sth	r4,-12(fp)
81133904:	e0fffe05 	stb	r3,-8(fp)
81133908:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113390c:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81133910:	e0800217 	ldw	r2,8(fp)
81133914:	1000021e 	bne	r2,zero,81133920 <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
81133918:	0005883a 	mov	r2,zero
8113391c:	00015906 	br	81133e84 <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81133920:	e0bffc17 	ldw	r2,-16(fp)
81133924:	1000051e 	bne	r2,zero,8113393c <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81133928:	e0800217 	ldw	r2,8(fp)
8113392c:	00c01b84 	movi	r3,110
81133930:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81133934:	0005883a 	mov	r2,zero
81133938:	00015206 	br	81133e84 <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113393c:	d0a0a003 	ldbu	r2,-32128(gp)
81133940:	10803fcc 	andi	r2,r2,255
81133944:	10000526 	beq	r2,zero,8113395c <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
81133948:	e0800217 	ldw	r2,8(fp)
8113394c:	00c00084 	movi	r3,2
81133950:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81133954:	0005883a 	mov	r2,zero
81133958:	00014a06 	br	81133e84 <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113395c:	d0a08e03 	ldbu	r2,-32200(gp)
81133960:	10803fcc 	andi	r2,r2,255
81133964:	10000526 	beq	r2,zero,8113397c <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
81133968:	e0800217 	ldw	r2,8(fp)
8113396c:	00c00344 	movi	r3,13
81133970:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81133974:	0005883a 	mov	r2,zero
81133978:	00014206 	br	81133e84 <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
8113397c:	e0bffc17 	ldw	r2,-16(fp)
81133980:	10800003 	ldbu	r2,0(r2)
81133984:	10803fcc 	andi	r2,r2,255
81133988:	10800160 	cmpeqi	r2,r2,5
8113398c:	1000051e 	bne	r2,zero,811339a4 <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
81133990:	e0800217 	ldw	r2,8(fp)
81133994:	00c00044 	movi	r3,1
81133998:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113399c:	0005883a 	mov	r2,zero
811339a0:	00013806 	br	81133e84 <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
811339a4:	e0fffe03 	ldbu	r3,-8(fp)
811339a8:	00bfe004 	movi	r2,-128
811339ac:	1884703a 	and	r2,r3,r2
811339b0:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
811339b4:	e0bfe603 	ldbu	r2,-104(fp)
811339b8:	10000626 	beq	r2,zero,811339d4 <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
811339bc:	e0bffe03 	ldbu	r2,-8(fp)
811339c0:	10801fcc 	andi	r2,r2,127
811339c4:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
811339c8:	00800044 	movi	r2,1
811339cc:	e0bfe405 	stb	r2,-112(fp)
811339d0:	00000106 	br	811339d8 <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
811339d4:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811339d8:	0005303a 	rdctl	r2,status
811339dc:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811339e0:	e0fff617 	ldw	r3,-40(fp)
811339e4:	00bfff84 	movi	r2,-2
811339e8:	1884703a 	and	r2,r3,r2
811339ec:	1001703a 	wrctl	status,r2
  
  return context;
811339f0:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
811339f4:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
811339f8:	e0bffe03 	ldbu	r2,-8(fp)
811339fc:	10c00060 	cmpeqi	r3,r2,1
81133a00:	1800921e 	bne	r3,zero,81133c4c <OSFlagPend+0x374>
81133a04:	10c00088 	cmpgei	r3,r2,2
81133a08:	1800021e 	bne	r3,zero,81133a14 <OSFlagPend+0x13c>
81133a0c:	10006126 	beq	r2,zero,81133b94 <OSFlagPend+0x2bc>
81133a10:	0000bb06 	br	81133d00 <OSFlagPend+0x428>
81133a14:	10c000a0 	cmpeqi	r3,r2,2
81133a18:	1800031e 	bne	r3,zero,81133a28 <OSFlagPend+0x150>
81133a1c:	108000e0 	cmpeqi	r2,r2,3
81133a20:	10002f1e 	bne	r2,zero,81133ae0 <OSFlagPend+0x208>
81133a24:	0000b606 	br	81133d00 <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
81133a28:	e0bffc17 	ldw	r2,-16(fp)
81133a2c:	10c0020b 	ldhu	r3,8(r2)
81133a30:	e0bffd0b 	ldhu	r2,-12(fp)
81133a34:	1884703a 	and	r2,r3,r2
81133a38:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81133a3c:	e0ffe80b 	ldhu	r3,-96(fp)
81133a40:	e0bffd0b 	ldhu	r2,-12(fp)
81133a44:	1880171e 	bne	r3,r2,81133aa4 <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81133a48:	e0bfe403 	ldbu	r2,-112(fp)
81133a4c:	10800058 	cmpnei	r2,r2,1
81133a50:	1000091e 	bne	r2,zero,81133a78 <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
81133a54:	e0bffc17 	ldw	r2,-16(fp)
81133a58:	1080020b 	ldhu	r2,8(r2)
81133a5c:	1007883a 	mov	r3,r2
81133a60:	e0bfe80b 	ldhu	r2,-96(fp)
81133a64:	0084303a 	nor	r2,zero,r2
81133a68:	1884703a 	and	r2,r3,r2
81133a6c:	1007883a 	mov	r3,r2
81133a70:	e0bffc17 	ldw	r2,-16(fp)
81133a74:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81133a78:	d0a0a117 	ldw	r2,-32124(gp)
81133a7c:	e0ffe80b 	ldhu	r3,-96(fp)
81133a80:	10c00b0d 	sth	r3,44(r2)
81133a84:	e0bfe517 	ldw	r2,-108(fp)
81133a88:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133a8c:	e0bfe717 	ldw	r2,-100(fp)
81133a90:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81133a94:	e0800217 	ldw	r2,8(fp)
81133a98:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81133a9c:	e0bfe80b 	ldhu	r2,-96(fp)
81133aa0:	0000f806 	br	81133e84 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81133aa4:	e13ffd0b 	ldhu	r4,-12(fp)
81133aa8:	e17ffe03 	ldbu	r5,-8(fp)
81133aac:	e0bfff0b 	ldhu	r2,-4(fp)
81133ab0:	e0fff704 	addi	r3,fp,-36
81133ab4:	d8800015 	stw	r2,0(sp)
81133ab8:	280f883a 	mov	r7,r5
81133abc:	200d883a 	mov	r6,r4
81133ac0:	180b883a 	mov	r5,r3
81133ac4:	e13ffc17 	ldw	r4,-16(fp)
81133ac8:	11343680 	call	81134368 <OS_FlagBlock>
81133acc:	e0bfe517 	ldw	r2,-108(fp)
81133ad0:	e0bfe915 	stw	r2,-92(fp)
81133ad4:	e0bfe917 	ldw	r2,-92(fp)
81133ad8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81133adc:	00009206 	br	81133d28 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
81133ae0:	e0bffc17 	ldw	r2,-16(fp)
81133ae4:	10c0020b 	ldhu	r3,8(r2)
81133ae8:	e0bffd0b 	ldhu	r2,-12(fp)
81133aec:	1884703a 	and	r2,r3,r2
81133af0:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
81133af4:	e0bfe80b 	ldhu	r2,-96(fp)
81133af8:	10001726 	beq	r2,zero,81133b58 <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81133afc:	e0bfe403 	ldbu	r2,-112(fp)
81133b00:	10800058 	cmpnei	r2,r2,1
81133b04:	1000091e 	bne	r2,zero,81133b2c <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
81133b08:	e0bffc17 	ldw	r2,-16(fp)
81133b0c:	1080020b 	ldhu	r2,8(r2)
81133b10:	1007883a 	mov	r3,r2
81133b14:	e0bfe80b 	ldhu	r2,-96(fp)
81133b18:	0084303a 	nor	r2,zero,r2
81133b1c:	1884703a 	and	r2,r3,r2
81133b20:	1007883a 	mov	r3,r2
81133b24:	e0bffc17 	ldw	r2,-16(fp)
81133b28:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81133b2c:	d0a0a117 	ldw	r2,-32124(gp)
81133b30:	e0ffe80b 	ldhu	r3,-96(fp)
81133b34:	10c00b0d 	sth	r3,44(r2)
81133b38:	e0bfe517 	ldw	r2,-108(fp)
81133b3c:	e0bfea15 	stw	r2,-88(fp)
81133b40:	e0bfea17 	ldw	r2,-88(fp)
81133b44:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81133b48:	e0800217 	ldw	r2,8(fp)
81133b4c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81133b50:	e0bfe80b 	ldhu	r2,-96(fp)
81133b54:	0000cb06 	br	81133e84 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81133b58:	e13ffd0b 	ldhu	r4,-12(fp)
81133b5c:	e17ffe03 	ldbu	r5,-8(fp)
81133b60:	e0bfff0b 	ldhu	r2,-4(fp)
81133b64:	e0fff704 	addi	r3,fp,-36
81133b68:	d8800015 	stw	r2,0(sp)
81133b6c:	280f883a 	mov	r7,r5
81133b70:	200d883a 	mov	r6,r4
81133b74:	180b883a 	mov	r5,r3
81133b78:	e13ffc17 	ldw	r4,-16(fp)
81133b7c:	11343680 	call	81134368 <OS_FlagBlock>
81133b80:	e0bfe517 	ldw	r2,-108(fp)
81133b84:	e0bfeb15 	stw	r2,-84(fp)
81133b88:	e0bfeb17 	ldw	r2,-84(fp)
81133b8c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81133b90:	00006506 	br	81133d28 <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
81133b94:	e0bffc17 	ldw	r2,-16(fp)
81133b98:	1080020b 	ldhu	r2,8(r2)
81133b9c:	0084303a 	nor	r2,zero,r2
81133ba0:	1007883a 	mov	r3,r2
81133ba4:	e0bffd0b 	ldhu	r2,-12(fp)
81133ba8:	1884703a 	and	r2,r3,r2
81133bac:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81133bb0:	e0ffe80b 	ldhu	r3,-96(fp)
81133bb4:	e0bffd0b 	ldhu	r2,-12(fp)
81133bb8:	1880151e 	bne	r3,r2,81133c10 <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81133bbc:	e0bfe403 	ldbu	r2,-112(fp)
81133bc0:	10800058 	cmpnei	r2,r2,1
81133bc4:	1000071e 	bne	r2,zero,81133be4 <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
81133bc8:	e0bffc17 	ldw	r2,-16(fp)
81133bcc:	10c0020b 	ldhu	r3,8(r2)
81133bd0:	e0bfe80b 	ldhu	r2,-96(fp)
81133bd4:	1884b03a 	or	r2,r3,r2
81133bd8:	1007883a 	mov	r3,r2
81133bdc:	e0bffc17 	ldw	r2,-16(fp)
81133be0:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81133be4:	d0a0a117 	ldw	r2,-32124(gp)
81133be8:	e0ffe80b 	ldhu	r3,-96(fp)
81133bec:	10c00b0d 	sth	r3,44(r2)
81133bf0:	e0bfe517 	ldw	r2,-108(fp)
81133bf4:	e0bfec15 	stw	r2,-80(fp)
81133bf8:	e0bfec17 	ldw	r2,-80(fp)
81133bfc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81133c00:	e0800217 	ldw	r2,8(fp)
81133c04:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81133c08:	e0bfe80b 	ldhu	r2,-96(fp)
81133c0c:	00009d06 	br	81133e84 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81133c10:	e13ffd0b 	ldhu	r4,-12(fp)
81133c14:	e17ffe03 	ldbu	r5,-8(fp)
81133c18:	e0bfff0b 	ldhu	r2,-4(fp)
81133c1c:	e0fff704 	addi	r3,fp,-36
81133c20:	d8800015 	stw	r2,0(sp)
81133c24:	280f883a 	mov	r7,r5
81133c28:	200d883a 	mov	r6,r4
81133c2c:	180b883a 	mov	r5,r3
81133c30:	e13ffc17 	ldw	r4,-16(fp)
81133c34:	11343680 	call	81134368 <OS_FlagBlock>
81133c38:	e0bfe517 	ldw	r2,-108(fp)
81133c3c:	e0bfed15 	stw	r2,-76(fp)
81133c40:	e0bfed17 	ldw	r2,-76(fp)
81133c44:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81133c48:	00003706 	br	81133d28 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
81133c4c:	e0bffc17 	ldw	r2,-16(fp)
81133c50:	1080020b 	ldhu	r2,8(r2)
81133c54:	0084303a 	nor	r2,zero,r2
81133c58:	1007883a 	mov	r3,r2
81133c5c:	e0bffd0b 	ldhu	r2,-12(fp)
81133c60:	1884703a 	and	r2,r3,r2
81133c64:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
81133c68:	e0bfe80b 	ldhu	r2,-96(fp)
81133c6c:	10001526 	beq	r2,zero,81133cc4 <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81133c70:	e0bfe403 	ldbu	r2,-112(fp)
81133c74:	10800058 	cmpnei	r2,r2,1
81133c78:	1000071e 	bne	r2,zero,81133c98 <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
81133c7c:	e0bffc17 	ldw	r2,-16(fp)
81133c80:	10c0020b 	ldhu	r3,8(r2)
81133c84:	e0bfe80b 	ldhu	r2,-96(fp)
81133c88:	1884b03a 	or	r2,r3,r2
81133c8c:	1007883a 	mov	r3,r2
81133c90:	e0bffc17 	ldw	r2,-16(fp)
81133c94:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81133c98:	d0a0a117 	ldw	r2,-32124(gp)
81133c9c:	e0ffe80b 	ldhu	r3,-96(fp)
81133ca0:	10c00b0d 	sth	r3,44(r2)
81133ca4:	e0bfe517 	ldw	r2,-108(fp)
81133ca8:	e0bfee15 	stw	r2,-72(fp)
81133cac:	e0bfee17 	ldw	r2,-72(fp)
81133cb0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81133cb4:	e0800217 	ldw	r2,8(fp)
81133cb8:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81133cbc:	e0bfe80b 	ldhu	r2,-96(fp)
81133cc0:	00007006 	br	81133e84 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81133cc4:	e13ffd0b 	ldhu	r4,-12(fp)
81133cc8:	e17ffe03 	ldbu	r5,-8(fp)
81133ccc:	e0bfff0b 	ldhu	r2,-4(fp)
81133cd0:	e0fff704 	addi	r3,fp,-36
81133cd4:	d8800015 	stw	r2,0(sp)
81133cd8:	280f883a 	mov	r7,r5
81133cdc:	200d883a 	mov	r6,r4
81133ce0:	180b883a 	mov	r5,r3
81133ce4:	e13ffc17 	ldw	r4,-16(fp)
81133ce8:	11343680 	call	81134368 <OS_FlagBlock>
81133cec:	e0bfe517 	ldw	r2,-108(fp)
81133cf0:	e0bfef15 	stw	r2,-68(fp)
81133cf4:	e0bfef17 	ldw	r2,-68(fp)
81133cf8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81133cfc:	00000a06 	br	81133d28 <OSFlagPend+0x450>
81133d00:	e0bfe517 	ldw	r2,-108(fp)
81133d04:	e0bff015 	stw	r2,-64(fp)
81133d08:	e0bff017 	ldw	r2,-64(fp)
81133d0c:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
81133d10:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
81133d14:	e0800217 	ldw	r2,8(fp)
81133d18:	00c01bc4 	movi	r3,111
81133d1c:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
81133d20:	e0bfe80b 	ldhu	r2,-96(fp)
81133d24:	00005706 	br	81133e84 <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
81133d28:	11326c80 	call	811326c8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133d2c:	0005303a 	rdctl	r2,status
81133d30:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133d34:	e0fff117 	ldw	r3,-60(fp)
81133d38:	00bfff84 	movi	r2,-2
81133d3c:	1884703a 	and	r2,r3,r2
81133d40:	1001703a 	wrctl	status,r2
  
  return context;
81133d44:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
81133d48:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
81133d4c:	d0a0a117 	ldw	r2,-32124(gp)
81133d50:	10800c43 	ldbu	r2,49(r2)
81133d54:	10803fcc 	andi	r2,r2,255
81133d58:	10001c26 	beq	r2,zero,81133dcc <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
81133d5c:	d0a0a117 	ldw	r2,-32124(gp)
81133d60:	10800c43 	ldbu	r2,49(r2)
81133d64:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81133d68:	d0a0a117 	ldw	r2,-32124(gp)
81133d6c:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
81133d70:	e0bff704 	addi	r2,fp,-36
81133d74:	1009883a 	mov	r4,r2
81133d78:	11346b40 	call	811346b4 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
81133d7c:	d0a0a117 	ldw	r2,-32124(gp)
81133d80:	10000c05 	stb	zero,48(r2)
81133d84:	e0bfe517 	ldw	r2,-108(fp)
81133d88:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133d8c:	e0bff217 	ldw	r2,-56(fp)
81133d90:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
81133d94:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
81133d98:	e0bff303 	ldbu	r2,-52(fp)
81133d9c:	108000a0 	cmpeqi	r2,r2,2
81133da0:	10000426 	beq	r2,zero,81133db4 <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
81133da4:	e0800217 	ldw	r2,8(fp)
81133da8:	00c00384 	movi	r3,14
81133dac:	10c00005 	stb	r3,0(r2)
                 break;
81133db0:	00000406 	br	81133dc4 <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
81133db4:	e0800217 	ldw	r2,8(fp)
81133db8:	00c00284 	movi	r3,10
81133dbc:	10c00005 	stb	r3,0(r2)
                 break;
81133dc0:	0001883a 	nop
        }
        return (flags_rdy);
81133dc4:	e0bfe80b 	ldhu	r2,-96(fp)
81133dc8:	00002e06 	br	81133e84 <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
81133dcc:	d0a0a117 	ldw	r2,-32124(gp)
81133dd0:	10800b0b 	ldhu	r2,44(r2)
81133dd4:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
81133dd8:	e0bfe403 	ldbu	r2,-112(fp)
81133ddc:	10800058 	cmpnei	r2,r2,1
81133de0:	1000211e 	bne	r2,zero,81133e68 <OSFlagPend+0x590>
        switch (wait_type) {
81133de4:	e0bffe03 	ldbu	r2,-8(fp)
81133de8:	10001616 	blt	r2,zero,81133e44 <OSFlagPend+0x56c>
81133dec:	10c00090 	cmplti	r3,r2,2
81133df0:	18000c1e 	bne	r3,zero,81133e24 <OSFlagPend+0x54c>
81133df4:	10800108 	cmpgei	r2,r2,4
81133df8:	1000121e 	bne	r2,zero,81133e44 <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
81133dfc:	e0bffc17 	ldw	r2,-16(fp)
81133e00:	1080020b 	ldhu	r2,8(r2)
81133e04:	1007883a 	mov	r3,r2
81133e08:	e0bfe80b 	ldhu	r2,-96(fp)
81133e0c:	0084303a 	nor	r2,zero,r2
81133e10:	1884703a 	and	r2,r3,r2
81133e14:	1007883a 	mov	r3,r2
81133e18:	e0bffc17 	ldw	r2,-16(fp)
81133e1c:	10c0020d 	sth	r3,8(r2)
                 break;
81133e20:	00001106 	br	81133e68 <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
81133e24:	e0bffc17 	ldw	r2,-16(fp)
81133e28:	10c0020b 	ldhu	r3,8(r2)
81133e2c:	e0bfe80b 	ldhu	r2,-96(fp)
81133e30:	1884b03a 	or	r2,r3,r2
81133e34:	1007883a 	mov	r3,r2
81133e38:	e0bffc17 	ldw	r2,-16(fp)
81133e3c:	10c0020d 	sth	r3,8(r2)
                 break;
81133e40:	00000906 	br	81133e68 <OSFlagPend+0x590>
81133e44:	e0bfe517 	ldw	r2,-108(fp)
81133e48:	e0bff415 	stw	r2,-48(fp)
81133e4c:	e0bff417 	ldw	r2,-48(fp)
81133e50:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
81133e54:	e0800217 	ldw	r2,8(fp)
81133e58:	00c01bc4 	movi	r3,111
81133e5c:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
81133e60:	0005883a 	mov	r2,zero
81133e64:	00000706 	br	81133e84 <OSFlagPend+0x5ac>
81133e68:	e0bfe517 	ldw	r2,-108(fp)
81133e6c:	e0bff515 	stw	r2,-44(fp)
81133e70:	e0bff517 	ldw	r2,-44(fp)
81133e74:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
81133e78:	e0800217 	ldw	r2,8(fp)
81133e7c:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
81133e80:	e0bfe80b 	ldhu	r2,-96(fp)
}
81133e84:	e037883a 	mov	sp,fp
81133e88:	dfc00117 	ldw	ra,4(sp)
81133e8c:	df000017 	ldw	fp,0(sp)
81133e90:	dec00204 	addi	sp,sp,8
81133e94:	f800283a 	ret

81133e98 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
81133e98:	defffb04 	addi	sp,sp,-20
81133e9c:	de00012e 	bgeu	sp,et,81133ea4 <OSFlagPendGetFlagsRdy+0xc>
81133ea0:	003b68fa 	trap	3
81133ea4:	df000415 	stw	fp,16(sp)
81133ea8:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81133eac:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133eb0:	0005303a 	rdctl	r2,status
81133eb4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133eb8:	e0fffe17 	ldw	r3,-8(fp)
81133ebc:	00bfff84 	movi	r2,-2
81133ec0:	1884703a 	and	r2,r3,r2
81133ec4:	1001703a 	wrctl	status,r2
  
  return context;
81133ec8:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
81133ecc:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
81133ed0:	d0a0a117 	ldw	r2,-32124(gp)
81133ed4:	10800b0b 	ldhu	r2,44(r2)
81133ed8:	e0bffd0d 	sth	r2,-12(fp)
81133edc:	e0bffc17 	ldw	r2,-16(fp)
81133ee0:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133ee4:	e0bfff17 	ldw	r2,-4(fp)
81133ee8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
81133eec:	e0bffd0b 	ldhu	r2,-12(fp)
}
81133ef0:	e037883a 	mov	sp,fp
81133ef4:	df000017 	ldw	fp,0(sp)
81133ef8:	dec00104 	addi	sp,sp,4
81133efc:	f800283a 	ret

81133f00 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
81133f00:	deffef04 	addi	sp,sp,-68
81133f04:	de00012e 	bgeu	sp,et,81133f0c <OSFlagPost+0xc>
81133f08:	003b68fa 	trap	3
81133f0c:	dfc01015 	stw	ra,64(sp)
81133f10:	df000f15 	stw	fp,60(sp)
81133f14:	df000f04 	addi	fp,sp,60
81133f18:	e13ffc15 	stw	r4,-16(fp)
81133f1c:	2807883a 	mov	r3,r5
81133f20:	3005883a 	mov	r2,r6
81133f24:	e1ffff15 	stw	r7,-4(fp)
81133f28:	e0fffd0d 	sth	r3,-12(fp)
81133f2c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
81133f30:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
81133f34:	e0bfff17 	ldw	r2,-4(fp)
81133f38:	1000021e 	bne	r2,zero,81133f44 <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
81133f3c:	0005883a 	mov	r2,zero
81133f40:	0000d106 	br	81134288 <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
81133f44:	e0bffc17 	ldw	r2,-16(fp)
81133f48:	1000051e 	bne	r2,zero,81133f60 <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81133f4c:	e0bfff17 	ldw	r2,-4(fp)
81133f50:	00c01b84 	movi	r3,110
81133f54:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81133f58:	0005883a 	mov	r2,zero
81133f5c:	0000ca06 	br	81134288 <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
81133f60:	e0bffc17 	ldw	r2,-16(fp)
81133f64:	10800003 	ldbu	r2,0(r2)
81133f68:	10803fcc 	andi	r2,r2,255
81133f6c:	10800160 	cmpeqi	r2,r2,5
81133f70:	1000051e 	bne	r2,zero,81133f88 <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
81133f74:	e0bfff17 	ldw	r2,-4(fp)
81133f78:	00c00044 	movi	r3,1
81133f7c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81133f80:	0005883a 	mov	r2,zero
81133f84:	0000c006 	br	81134288 <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133f88:	0005303a 	rdctl	r2,status
81133f8c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133f90:	e0fffb17 	ldw	r3,-20(fp)
81133f94:	00bfff84 	movi	r2,-2
81133f98:	1884703a 	and	r2,r3,r2
81133f9c:	1001703a 	wrctl	status,r2
  
  return context;
81133fa0:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81133fa4:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
81133fa8:	e0bffe03 	ldbu	r2,-8(fp)
81133fac:	10000326 	beq	r2,zero,81133fbc <OSFlagPost+0xbc>
81133fb0:	10800060 	cmpeqi	r2,r2,1
81133fb4:	10000b1e 	bne	r2,zero,81133fe4 <OSFlagPost+0xe4>
81133fb8:	00001206 	br	81134004 <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
81133fbc:	e0bffc17 	ldw	r2,-16(fp)
81133fc0:	1080020b 	ldhu	r2,8(r2)
81133fc4:	1007883a 	mov	r3,r2
81133fc8:	e0bffd0b 	ldhu	r2,-12(fp)
81133fcc:	0084303a 	nor	r2,zero,r2
81133fd0:	1884703a 	and	r2,r3,r2
81133fd4:	1007883a 	mov	r3,r2
81133fd8:	e0bffc17 	ldw	r2,-16(fp)
81133fdc:	10c0020d 	sth	r3,8(r2)
             break;
81133fe0:	00001106 	br	81134028 <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
81133fe4:	e0bffc17 	ldw	r2,-16(fp)
81133fe8:	10c0020b 	ldhu	r3,8(r2)
81133fec:	e0bffd0b 	ldhu	r2,-12(fp)
81133ff0:	1884b03a 	or	r2,r3,r2
81133ff4:	1007883a 	mov	r3,r2
81133ff8:	e0bffc17 	ldw	r2,-16(fp)
81133ffc:	10c0020d 	sth	r3,8(r2)
             break;
81134000:	00000906 	br	81134028 <OSFlagPost+0x128>
81134004:	e0bff317 	ldw	r2,-52(fp)
81134008:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113400c:	e0bff417 	ldw	r2,-48(fp)
81134010:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
81134014:	e0bfff17 	ldw	r2,-4(fp)
81134018:	00c01c44 	movi	r3,113
8113401c:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
81134020:	0005883a 	mov	r2,zero
81134024:	00009806 	br	81134288 <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
81134028:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
8113402c:	e0bffc17 	ldw	r2,-16(fp)
81134030:	10800117 	ldw	r2,4(r2)
81134034:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
81134038:	00007706 	br	81134218 <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
8113403c:	e0bff117 	ldw	r2,-60(fp)
81134040:	10800483 	ldbu	r2,18(r2)
81134044:	10803fcc 	andi	r2,r2,255
81134048:	10c00060 	cmpeqi	r3,r2,1
8113404c:	18004a1e 	bne	r3,zero,81134178 <OSFlagPost+0x278>
81134050:	10c00088 	cmpgei	r3,r2,2
81134054:	1800021e 	bne	r3,zero,81134060 <OSFlagPost+0x160>
81134058:	10002f26 	beq	r2,zero,81134118 <OSFlagPost+0x218>
8113405c:	00005b06 	br	811341cc <OSFlagPost+0x2cc>
81134060:	10c000a0 	cmpeqi	r3,r2,2
81134064:	1800031e 	bne	r3,zero,81134074 <OSFlagPost+0x174>
81134068:	108000e0 	cmpeqi	r2,r2,3
8113406c:	1000171e 	bne	r2,zero,811340cc <OSFlagPost+0x1cc>
81134070:	00005606 	br	811341cc <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81134074:	e0bffc17 	ldw	r2,-16(fp)
81134078:	10c0020b 	ldhu	r3,8(r2)
8113407c:	e0bff117 	ldw	r2,-60(fp)
81134080:	1080040b 	ldhu	r2,16(r2)
81134084:	1884703a 	and	r2,r3,r2
81134088:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113408c:	e0bff117 	ldw	r2,-60(fp)
81134090:	1080040b 	ldhu	r2,16(r2)
81134094:	10ffffcc 	andi	r3,r2,65535
81134098:	e0bff60b 	ldhu	r2,-40(fp)
8113409c:	1880541e 	bne	r3,r2,811341f0 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
811340a0:	e0bff60b 	ldhu	r2,-40(fp)
811340a4:	100b883a 	mov	r5,r2
811340a8:	e13ff117 	ldw	r4,-60(fp)
811340ac:	11345b80 	call	811345b8 <OS_FlagTaskRdy>
811340b0:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
811340b4:	e0bff683 	ldbu	r2,-38(fp)
811340b8:	10800058 	cmpnei	r2,r2,1
811340bc:	10004c1e 	bne	r2,zero,811341f0 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
811340c0:	00800044 	movi	r2,1
811340c4:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
811340c8:	00004906 	br	811341f0 <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
811340cc:	e0bffc17 	ldw	r2,-16(fp)
811340d0:	10c0020b 	ldhu	r3,8(r2)
811340d4:	e0bff117 	ldw	r2,-60(fp)
811340d8:	1080040b 	ldhu	r2,16(r2)
811340dc:	1884703a 	and	r2,r3,r2
811340e0:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
811340e4:	e0bff60b 	ldhu	r2,-40(fp)
811340e8:	10004326 	beq	r2,zero,811341f8 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
811340ec:	e0bff60b 	ldhu	r2,-40(fp)
811340f0:	100b883a 	mov	r5,r2
811340f4:	e13ff117 	ldw	r4,-60(fp)
811340f8:	11345b80 	call	811345b8 <OS_FlagTaskRdy>
811340fc:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81134100:	e0bff683 	ldbu	r2,-38(fp)
81134104:	10800058 	cmpnei	r2,r2,1
81134108:	10003b1e 	bne	r2,zero,811341f8 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113410c:	00800044 	movi	r2,1
81134110:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81134114:	00003806 	br	811341f8 <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81134118:	e0bffc17 	ldw	r2,-16(fp)
8113411c:	1080020b 	ldhu	r2,8(r2)
81134120:	0084303a 	nor	r2,zero,r2
81134124:	1007883a 	mov	r3,r2
81134128:	e0bff117 	ldw	r2,-60(fp)
8113412c:	1080040b 	ldhu	r2,16(r2)
81134130:	1884703a 	and	r2,r3,r2
81134134:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
81134138:	e0bff117 	ldw	r2,-60(fp)
8113413c:	1080040b 	ldhu	r2,16(r2)
81134140:	10ffffcc 	andi	r3,r2,65535
81134144:	e0bff60b 	ldhu	r2,-40(fp)
81134148:	18802d1e 	bne	r3,r2,81134200 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113414c:	e0bff60b 	ldhu	r2,-40(fp)
81134150:	100b883a 	mov	r5,r2
81134154:	e13ff117 	ldw	r4,-60(fp)
81134158:	11345b80 	call	811345b8 <OS_FlagTaskRdy>
8113415c:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81134160:	e0bff683 	ldbu	r2,-38(fp)
81134164:	10800058 	cmpnei	r2,r2,1
81134168:	1000251e 	bne	r2,zero,81134200 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113416c:	00800044 	movi	r2,1
81134170:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81134174:	00002206 	br	81134200 <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81134178:	e0bffc17 	ldw	r2,-16(fp)
8113417c:	1080020b 	ldhu	r2,8(r2)
81134180:	0084303a 	nor	r2,zero,r2
81134184:	1007883a 	mov	r3,r2
81134188:	e0bff117 	ldw	r2,-60(fp)
8113418c:	1080040b 	ldhu	r2,16(r2)
81134190:	1884703a 	and	r2,r3,r2
81134194:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
81134198:	e0bff60b 	ldhu	r2,-40(fp)
8113419c:	10001a26 	beq	r2,zero,81134208 <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
811341a0:	e0bff60b 	ldhu	r2,-40(fp)
811341a4:	100b883a 	mov	r5,r2
811341a8:	e13ff117 	ldw	r4,-60(fp)
811341ac:	11345b80 	call	811345b8 <OS_FlagTaskRdy>
811341b0:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
811341b4:	e0bff683 	ldbu	r2,-38(fp)
811341b8:	10800058 	cmpnei	r2,r2,1
811341bc:	1000121e 	bne	r2,zero,81134208 <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
811341c0:	00800044 	movi	r2,1
811341c4:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
811341c8:	00000f06 	br	81134208 <OSFlagPost+0x308>
811341cc:	e0bff317 	ldw	r2,-52(fp)
811341d0:	e0bff515 	stw	r2,-44(fp)
811341d4:	e0bff517 	ldw	r2,-44(fp)
811341d8:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
811341dc:	e0bfff17 	ldw	r2,-4(fp)
811341e0:	00c01bc4 	movi	r3,111
811341e4:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
811341e8:	0005883a 	mov	r2,zero
811341ec:	00002606 	br	81134288 <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811341f0:	0001883a 	nop
811341f4:	00000506 	br	8113420c <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811341f8:	0001883a 	nop
811341fc:	00000306 	br	8113420c <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81134200:	0001883a 	nop
81134204:	00000106 	br	8113420c <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81134208:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
8113420c:	e0bff117 	ldw	r2,-60(fp)
81134210:	10800017 	ldw	r2,0(r2)
81134214:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
81134218:	e0bff117 	ldw	r2,-60(fp)
8113421c:	103f871e 	bne	r2,zero,8113403c <__reset+0xfb11403c>
81134220:	e0bff317 	ldw	r2,-52(fp)
81134224:	e0bff715 	stw	r2,-36(fp)
81134228:	e0bff717 	ldw	r2,-36(fp)
8113422c:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
81134230:	e0bff203 	ldbu	r2,-56(fp)
81134234:	10800058 	cmpnei	r2,r2,1
81134238:	1000011e 	bne	r2,zero,81134240 <OSFlagPost+0x340>
        OS_Sched();
8113423c:	11326c80 	call	811326c8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134240:	0005303a 	rdctl	r2,status
81134244:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134248:	e0fffa17 	ldw	r3,-24(fp)
8113424c:	00bfff84 	movi	r2,-2
81134250:	1884703a 	and	r2,r3,r2
81134254:	1001703a 	wrctl	status,r2
  
  return context;
81134258:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
8113425c:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
81134260:	e0bffc17 	ldw	r2,-16(fp)
81134264:	1080020b 	ldhu	r2,8(r2)
81134268:	e0bff90d 	sth	r2,-28(fp)
8113426c:	e0bff317 	ldw	r2,-52(fp)
81134270:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134274:	e0bff817 	ldw	r2,-32(fp)
81134278:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
8113427c:	e0bfff17 	ldw	r2,-4(fp)
81134280:	10000005 	stb	zero,0(r2)
    return (flags_cur);
81134284:	e0bff90b 	ldhu	r2,-28(fp)
}
81134288:	e037883a 	mov	sp,fp
8113428c:	dfc00117 	ldw	ra,4(sp)
81134290:	df000017 	ldw	fp,0(sp)
81134294:	dec00204 	addi	sp,sp,8
81134298:	f800283a 	ret

8113429c <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
8113429c:	defff904 	addi	sp,sp,-28
811342a0:	de00012e 	bgeu	sp,et,811342a8 <OSFlagQuery+0xc>
811342a4:	003b68fa 	trap	3
811342a8:	df000615 	stw	fp,24(sp)
811342ac:	df000604 	addi	fp,sp,24
811342b0:	e13ffe15 	stw	r4,-8(fp)
811342b4:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
811342b8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
811342bc:	e0bfff17 	ldw	r2,-4(fp)
811342c0:	1000021e 	bne	r2,zero,811342cc <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
811342c4:	0005883a 	mov	r2,zero
811342c8:	00002306 	br	81134358 <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
811342cc:	e0bffe17 	ldw	r2,-8(fp)
811342d0:	1000051e 	bne	r2,zero,811342e8 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811342d4:	e0bfff17 	ldw	r2,-4(fp)
811342d8:	00c01b84 	movi	r3,110
811342dc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811342e0:	0005883a 	mov	r2,zero
811342e4:	00001c06 	br	81134358 <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
811342e8:	e0bffe17 	ldw	r2,-8(fp)
811342ec:	10800003 	ldbu	r2,0(r2)
811342f0:	10803fcc 	andi	r2,r2,255
811342f4:	10800160 	cmpeqi	r2,r2,5
811342f8:	1000051e 	bne	r2,zero,81134310 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
811342fc:	e0bfff17 	ldw	r2,-4(fp)
81134300:	00c00044 	movi	r3,1
81134304:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81134308:	0005883a 	mov	r2,zero
8113430c:	00001206 	br	81134358 <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134310:	0005303a 	rdctl	r2,status
81134314:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134318:	e0fffc17 	ldw	r3,-16(fp)
8113431c:	00bfff84 	movi	r2,-2
81134320:	1884703a 	and	r2,r3,r2
81134324:	1001703a 	wrctl	status,r2
  
  return context;
81134328:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113432c:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
81134330:	e0bffe17 	ldw	r2,-8(fp)
81134334:	1080020b 	ldhu	r2,8(r2)
81134338:	e0bffb0d 	sth	r2,-20(fp)
8113433c:	e0bffa17 	ldw	r2,-24(fp)
81134340:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134344:	e0bffd17 	ldw	r2,-12(fp)
81134348:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113434c:	e0bfff17 	ldw	r2,-4(fp)
81134350:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
81134354:	e0bffb0b 	ldhu	r2,-20(fp)
}
81134358:	e037883a 	mov	sp,fp
8113435c:	df000017 	ldw	fp,0(sp)
81134360:	dec00104 	addi	sp,sp,4
81134364:	f800283a 	ret

81134368 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
81134368:	defff804 	addi	sp,sp,-32
8113436c:	de00012e 	bgeu	sp,et,81134374 <OS_FlagBlock+0xc>
81134370:	003b68fa 	trap	3
81134374:	df000715 	stw	fp,28(sp)
81134378:	df000704 	addi	fp,sp,28
8113437c:	e13ffb15 	stw	r4,-20(fp)
81134380:	e17ffc15 	stw	r5,-16(fp)
81134384:	3009883a 	mov	r4,r6
81134388:	3807883a 	mov	r3,r7
8113438c:	e0800117 	ldw	r2,4(fp)
81134390:	e13ffd0d 	sth	r4,-12(fp)
81134394:	e0fffe05 	stb	r3,-8(fp)
81134398:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
8113439c:	d0a0a117 	ldw	r2,-32124(gp)
811343a0:	d0e0a117 	ldw	r3,-32124(gp)
811343a4:	18c00c03 	ldbu	r3,48(r3)
811343a8:	18c00814 	ori	r3,r3,32
811343ac:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
811343b0:	d0a0a117 	ldw	r2,-32124(gp)
811343b4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
811343b8:	d0a0a117 	ldw	r2,-32124(gp)
811343bc:	e0ffff0b 	ldhu	r3,-4(fp)
811343c0:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
811343c4:	d0a0a117 	ldw	r2,-32124(gp)
811343c8:	e0fffc17 	ldw	r3,-16(fp)
811343cc:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
811343d0:	e0bffc17 	ldw	r2,-16(fp)
811343d4:	e0fffd0b 	ldhu	r3,-12(fp)
811343d8:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
811343dc:	e0bffc17 	ldw	r2,-16(fp)
811343e0:	e0fffe03 	ldbu	r3,-8(fp)
811343e4:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
811343e8:	d0e0a117 	ldw	r3,-32124(gp)
811343ec:	e0bffc17 	ldw	r2,-16(fp)
811343f0:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
811343f4:	e0bffb17 	ldw	r2,-20(fp)
811343f8:	10c00117 	ldw	r3,4(r2)
811343fc:	e0bffc17 	ldw	r2,-16(fp)
81134400:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
81134404:	e0bffc17 	ldw	r2,-16(fp)
81134408:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
8113440c:	e0bffc17 	ldw	r2,-16(fp)
81134410:	e0fffb17 	ldw	r3,-20(fp)
81134414:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
81134418:	e0bffb17 	ldw	r2,-20(fp)
8113441c:	10800117 	ldw	r2,4(r2)
81134420:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
81134424:	e0bff917 	ldw	r2,-28(fp)
81134428:	10000326 	beq	r2,zero,81134438 <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
8113442c:	e0bff917 	ldw	r2,-28(fp)
81134430:	e0fffc17 	ldw	r3,-16(fp)
81134434:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
81134438:	e0bffb17 	ldw	r2,-20(fp)
8113443c:	e0fffc17 	ldw	r3,-16(fp)
81134440:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
81134444:	d0a0a117 	ldw	r2,-32124(gp)
81134448:	10800d03 	ldbu	r2,52(r2)
8113444c:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
81134450:	e0fffa03 	ldbu	r3,-24(fp)
81134454:	e13ffa03 	ldbu	r4,-24(fp)
81134458:	d0a09d44 	addi	r2,gp,-32139
8113445c:	2085883a 	add	r2,r4,r2
81134460:	10800003 	ldbu	r2,0(r2)
81134464:	1009883a 	mov	r4,r2
81134468:	d0a0a117 	ldw	r2,-32124(gp)
8113446c:	10800d43 	ldbu	r2,53(r2)
81134470:	0084303a 	nor	r2,zero,r2
81134474:	2084703a 	and	r2,r4,r2
81134478:	1009883a 	mov	r4,r2
8113447c:	d0a09d44 	addi	r2,gp,-32139
81134480:	1885883a 	add	r2,r3,r2
81134484:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
81134488:	e0fffa03 	ldbu	r3,-24(fp)
8113448c:	d0a09d44 	addi	r2,gp,-32139
81134490:	1885883a 	add	r2,r3,r2
81134494:	10800003 	ldbu	r2,0(r2)
81134498:	10803fcc 	andi	r2,r2,255
8113449c:	1000071e 	bne	r2,zero,811344bc <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
811344a0:	d0a0a117 	ldw	r2,-32124(gp)
811344a4:	10800d83 	ldbu	r2,54(r2)
811344a8:	0084303a 	nor	r2,zero,r2
811344ac:	1007883a 	mov	r3,r2
811344b0:	d0a09d03 	ldbu	r2,-32140(gp)
811344b4:	1884703a 	and	r2,r3,r2
811344b8:	d0a09d05 	stb	r2,-32140(gp)
    }
}
811344bc:	0001883a 	nop
811344c0:	e037883a 	mov	sp,fp
811344c4:	df000017 	ldw	fp,0(sp)
811344c8:	dec00104 	addi	sp,sp,4
811344cc:	f800283a 	ret

811344d0 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
811344d0:	defffb04 	addi	sp,sp,-20
811344d4:	de00012e 	bgeu	sp,et,811344dc <OS_FlagInit+0xc>
811344d8:	003b68fa 	trap	3
811344dc:	dfc00415 	stw	ra,16(sp)
811344e0:	df000315 	stw	fp,12(sp)
811344e4:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
811344e8:	01421004 	movi	r5,2112
811344ec:	012045b4 	movhi	r4,33046
811344f0:	212ce604 	addi	r4,r4,-19560
811344f4:	11325fc0 	call	811325fc <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
811344f8:	00a045b4 	movhi	r2,33046
811344fc:	10ace604 	addi	r2,r2,-19560
81134500:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
81134504:	00a045b4 	movhi	r2,33046
81134508:	10acf104 	addi	r2,r2,-19516
8113450c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
81134510:	e03ffd0d 	sth	zero,-12(fp)
81134514:	00001306 	br	81134564 <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81134518:	e0bffe17 	ldw	r2,-8(fp)
8113451c:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
81134520:	e0bffe17 	ldw	r2,-8(fp)
81134524:	e0ffff17 	ldw	r3,-4(fp)
81134528:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
8113452c:	e0bffe17 	ldw	r2,-8(fp)
81134530:	00c00fc4 	movi	r3,63
81134534:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
81134538:	e0bffe17 	ldw	r2,-8(fp)
8113453c:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
81134540:	e0bffe17 	ldw	r2,-8(fp)
81134544:	10800b04 	addi	r2,r2,44
81134548:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
8113454c:	e0bfff17 	ldw	r2,-4(fp)
81134550:	10800b04 	addi	r2,r2,44
81134554:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
81134558:	e0bffd0b 	ldhu	r2,-12(fp)
8113455c:	10800044 	addi	r2,r2,1
81134560:	e0bffd0d 	sth	r2,-12(fp)
81134564:	e0bffd0b 	ldhu	r2,-12(fp)
81134568:	10800bf0 	cmpltui	r2,r2,47
8113456c:	103fea1e 	bne	r2,zero,81134518 <__reset+0xfb114518>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81134570:	e0bffe17 	ldw	r2,-8(fp)
81134574:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
81134578:	e0bffe17 	ldw	r2,-8(fp)
8113457c:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
81134580:	e0bffe17 	ldw	r2,-8(fp)
81134584:	00c00fc4 	movi	r3,63
81134588:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
8113458c:	e0bffe17 	ldw	r2,-8(fp)
81134590:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
81134594:	00a045b4 	movhi	r2,33046
81134598:	10ace604 	addi	r2,r2,-19560
8113459c:	d0a0a515 	stw	r2,-32108(gp)
#endif
}
811345a0:	0001883a 	nop
811345a4:	e037883a 	mov	sp,fp
811345a8:	dfc00117 	ldw	ra,4(sp)
811345ac:	df000017 	ldw	fp,0(sp)
811345b0:	dec00204 	addi	sp,sp,8
811345b4:	f800283a 	ret

811345b8 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
811345b8:	defffa04 	addi	sp,sp,-24
811345bc:	de00012e 	bgeu	sp,et,811345c4 <OS_FlagTaskRdy+0xc>
811345c0:	003b68fa 	trap	3
811345c4:	dfc00515 	stw	ra,20(sp)
811345c8:	df000415 	stw	fp,16(sp)
811345cc:	df000404 	addi	fp,sp,16
811345d0:	e13ffe15 	stw	r4,-8(fp)
811345d4:	2805883a 	mov	r2,r5
811345d8:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
811345dc:	e0bffe17 	ldw	r2,-8(fp)
811345e0:	10800217 	ldw	r2,8(r2)
811345e4:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
811345e8:	e0bffd17 	ldw	r2,-12(fp)
811345ec:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
811345f0:	e0bffd17 	ldw	r2,-12(fp)
811345f4:	e0ffff0b 	ldhu	r3,-4(fp)
811345f8:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
811345fc:	e0bffd17 	ldw	r2,-12(fp)
81134600:	10c00c03 	ldbu	r3,48(r2)
81134604:	00bff7c4 	movi	r2,-33
81134608:	1884703a 	and	r2,r3,r2
8113460c:	1007883a 	mov	r3,r2
81134610:	e0bffd17 	ldw	r2,-12(fp)
81134614:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
81134618:	e0bffd17 	ldw	r2,-12(fp)
8113461c:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
81134620:	e0bffd17 	ldw	r2,-12(fp)
81134624:	10800c03 	ldbu	r2,48(r2)
81134628:	10803fcc 	andi	r2,r2,255
8113462c:	1000181e 	bne	r2,zero,81134690 <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
81134630:	e0bffd17 	ldw	r2,-12(fp)
81134634:	10c00d83 	ldbu	r3,54(r2)
81134638:	d0a09d03 	ldbu	r2,-32140(gp)
8113463c:	1884b03a 	or	r2,r3,r2
81134640:	d0a09d05 	stb	r2,-32140(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81134644:	e0bffd17 	ldw	r2,-12(fp)
81134648:	10800d03 	ldbu	r2,52(r2)
8113464c:	10c03fcc 	andi	r3,r2,255
81134650:	e0bffd17 	ldw	r2,-12(fp)
81134654:	10800d03 	ldbu	r2,52(r2)
81134658:	11003fcc 	andi	r4,r2,255
8113465c:	d0a09d44 	addi	r2,gp,-32139
81134660:	2085883a 	add	r2,r4,r2
81134664:	11000003 	ldbu	r4,0(r2)
81134668:	e0bffd17 	ldw	r2,-12(fp)
8113466c:	10800d43 	ldbu	r2,53(r2)
81134670:	2084b03a 	or	r2,r4,r2
81134674:	1009883a 	mov	r4,r2
81134678:	d0a09d44 	addi	r2,gp,-32139
8113467c:	1885883a 	add	r2,r3,r2
81134680:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
81134684:	00800044 	movi	r2,1
81134688:	e0bffc05 	stb	r2,-16(fp)
8113468c:	00000106 	br	81134694 <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
81134690:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
81134694:	e13ffe17 	ldw	r4,-8(fp)
81134698:	11346b40 	call	811346b4 <OS_FlagUnlink>
    return (sched);
8113469c:	e0bffc03 	ldbu	r2,-16(fp)
}
811346a0:	e037883a 	mov	sp,fp
811346a4:	dfc00117 	ldw	ra,4(sp)
811346a8:	df000017 	ldw	fp,0(sp)
811346ac:	dec00204 	addi	sp,sp,8
811346b0:	f800283a 	ret

811346b4 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
811346b4:	defffa04 	addi	sp,sp,-24
811346b8:	de00012e 	bgeu	sp,et,811346c0 <OS_FlagUnlink+0xc>
811346bc:	003b68fa 	trap	3
811346c0:	df000515 	stw	fp,20(sp)
811346c4:	df000504 	addi	fp,sp,20
811346c8:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
811346cc:	e0bfff17 	ldw	r2,-4(fp)
811346d0:	10800117 	ldw	r2,4(r2)
811346d4:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
811346d8:	e0bfff17 	ldw	r2,-4(fp)
811346dc:	10800017 	ldw	r2,0(r2)
811346e0:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
811346e4:	e0bffb17 	ldw	r2,-20(fp)
811346e8:	10000b1e 	bne	r2,zero,81134718 <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
811346ec:	e0bfff17 	ldw	r2,-4(fp)
811346f0:	10800317 	ldw	r2,12(r2)
811346f4:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
811346f8:	e0bffd17 	ldw	r2,-12(fp)
811346fc:	e0fffc17 	ldw	r3,-16(fp)
81134700:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
81134704:	e0bffc17 	ldw	r2,-16(fp)
81134708:	10000b26 	beq	r2,zero,81134738 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
8113470c:	e0bffc17 	ldw	r2,-16(fp)
81134710:	10000115 	stw	zero,4(r2)
81134714:	00000806 	br	81134738 <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
81134718:	e0bffb17 	ldw	r2,-20(fp)
8113471c:	e0fffc17 	ldw	r3,-16(fp)
81134720:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
81134724:	e0bffc17 	ldw	r2,-16(fp)
81134728:	10000326 	beq	r2,zero,81134738 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
8113472c:	e0bffc17 	ldw	r2,-16(fp)
81134730:	e0fffb17 	ldw	r3,-20(fp)
81134734:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
81134738:	e0bfff17 	ldw	r2,-4(fp)
8113473c:	10800217 	ldw	r2,8(r2)
81134740:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
81134744:	e0bffe17 	ldw	r2,-8(fp)
81134748:	10000a15 	stw	zero,40(r2)
#endif
}
8113474c:	0001883a 	nop
81134750:	e037883a 	mov	sp,fp
81134754:	df000017 	ldw	fp,0(sp)
81134758:	dec00104 	addi	sp,sp,4
8113475c:	f800283a 	ret

81134760 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
81134760:	defff404 	addi	sp,sp,-48
81134764:	de00012e 	bgeu	sp,et,8113476c <OSMemCreate+0xc>
81134768:	003b68fa 	trap	3
8113476c:	df000b15 	stw	fp,44(sp)
81134770:	df000b04 	addi	fp,sp,44
81134774:	e13ffc15 	stw	r4,-16(fp)
81134778:	e17ffd15 	stw	r5,-12(fp)
8113477c:	e1bffe15 	stw	r6,-8(fp)
81134780:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81134784:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81134788:	e0bfff17 	ldw	r2,-4(fp)
8113478c:	1000021e 	bne	r2,zero,81134798 <OSMemCreate+0x38>
        return ((OS_MEM *)0);
81134790:	0005883a 	mov	r2,zero
81134794:	00006506 	br	8113492c <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
81134798:	e0bffc17 	ldw	r2,-16(fp)
8113479c:	1000051e 	bne	r2,zero,811347b4 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
811347a0:	e0bfff17 	ldw	r2,-4(fp)
811347a4:	00c01884 	movi	r3,98
811347a8:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
811347ac:	0005883a 	mov	r2,zero
811347b0:	00005e06 	br	8113492c <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
811347b4:	e0bffc17 	ldw	r2,-16(fp)
811347b8:	108000cc 	andi	r2,r2,3
811347bc:	10000526 	beq	r2,zero,811347d4 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
811347c0:	e0bfff17 	ldw	r2,-4(fp)
811347c4:	00c01884 	movi	r3,98
811347c8:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
811347cc:	0005883a 	mov	r2,zero
811347d0:	00005606 	br	8113492c <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
811347d4:	e0bffd17 	ldw	r2,-12(fp)
811347d8:	108000a8 	cmpgeui	r2,r2,2
811347dc:	1000051e 	bne	r2,zero,811347f4 <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
811347e0:	e0bfff17 	ldw	r2,-4(fp)
811347e4:	00c016c4 	movi	r3,91
811347e8:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
811347ec:	0005883a 	mov	r2,zero
811347f0:	00004e06 	br	8113492c <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
811347f4:	e0bffe17 	ldw	r2,-8(fp)
811347f8:	10800128 	cmpgeui	r2,r2,4
811347fc:	1000051e 	bne	r2,zero,81134814 <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
81134800:	e0bfff17 	ldw	r2,-4(fp)
81134804:	00c01704 	movi	r3,92
81134808:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
8113480c:	0005883a 	mov	r2,zero
81134810:	00004606 	br	8113492c <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134814:	0005303a 	rdctl	r2,status
81134818:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113481c:	e0fffb17 	ldw	r3,-20(fp)
81134820:	00bfff84 	movi	r2,-2
81134824:	1884703a 	and	r2,r3,r2
81134828:	1001703a 	wrctl	status,r2
  
  return context;
8113482c:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81134830:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
81134834:	d0a09a17 	ldw	r2,-32152(gp)
81134838:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
8113483c:	d0a09a17 	ldw	r2,-32152(gp)
81134840:	10000326 	beq	r2,zero,81134850 <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
81134844:	d0a09a17 	ldw	r2,-32152(gp)
81134848:	10800117 	ldw	r2,4(r2)
8113484c:	d0a09a15 	stw	r2,-32152(gp)
81134850:	e0bff817 	ldw	r2,-32(fp)
81134854:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134858:	e0bff917 	ldw	r2,-28(fp)
8113485c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
81134860:	e0bffa17 	ldw	r2,-24(fp)
81134864:	1000051e 	bne	r2,zero,8113487c <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
81134868:	e0bfff17 	ldw	r2,-4(fp)
8113486c:	00c01684 	movi	r3,90
81134870:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81134874:	0005883a 	mov	r2,zero
81134878:	00002c06 	br	8113492c <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
8113487c:	e0bffc17 	ldw	r2,-16(fp)
81134880:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
81134884:	e0fffc17 	ldw	r3,-16(fp)
81134888:	e0bffe17 	ldw	r2,-8(fp)
8113488c:	1885883a 	add	r2,r3,r2
81134890:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
81134894:	e03ff715 	stw	zero,-36(fp)
81134898:	00000c06 	br	811348cc <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
8113489c:	e0bff617 	ldw	r2,-40(fp)
811348a0:	e0fff517 	ldw	r3,-44(fp)
811348a4:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
811348a8:	e0bff517 	ldw	r2,-44(fp)
811348ac:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
811348b0:	e0fff517 	ldw	r3,-44(fp)
811348b4:	e0bffe17 	ldw	r2,-8(fp)
811348b8:	1885883a 	add	r2,r3,r2
811348bc:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
811348c0:	e0bff717 	ldw	r2,-36(fp)
811348c4:	10800044 	addi	r2,r2,1
811348c8:	e0bff715 	stw	r2,-36(fp)
811348cc:	e0bffd17 	ldw	r2,-12(fp)
811348d0:	10bfffc4 	addi	r2,r2,-1
811348d4:	e0fff717 	ldw	r3,-36(fp)
811348d8:	18bff036 	bltu	r3,r2,8113489c <__reset+0xfb11489c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
811348dc:	e0bff617 	ldw	r2,-40(fp)
811348e0:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
811348e4:	e0bffa17 	ldw	r2,-24(fp)
811348e8:	e0fffc17 	ldw	r3,-16(fp)
811348ec:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
811348f0:	e0bffa17 	ldw	r2,-24(fp)
811348f4:	e0fffc17 	ldw	r3,-16(fp)
811348f8:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
811348fc:	e0bffa17 	ldw	r2,-24(fp)
81134900:	e0fffd17 	ldw	r3,-12(fp)
81134904:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
81134908:	e0bffa17 	ldw	r2,-24(fp)
8113490c:	e0fffd17 	ldw	r3,-12(fp)
81134910:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
81134914:	e0bffa17 	ldw	r2,-24(fp)
81134918:	e0fffe17 	ldw	r3,-8(fp)
8113491c:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
81134920:	e0bfff17 	ldw	r2,-4(fp)
81134924:	10000005 	stb	zero,0(r2)
    return (pmem);
81134928:	e0bffa17 	ldw	r2,-24(fp)
}
8113492c:	e037883a 	mov	sp,fp
81134930:	df000017 	ldw	fp,0(sp)
81134934:	dec00104 	addi	sp,sp,4
81134938:	f800283a 	ret

8113493c <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
8113493c:	defff804 	addi	sp,sp,-32
81134940:	de00012e 	bgeu	sp,et,81134948 <OSMemGet+0xc>
81134944:	003b68fa 	trap	3
81134948:	df000715 	stw	fp,28(sp)
8113494c:	df000704 	addi	fp,sp,28
81134950:	e13ffe15 	stw	r4,-8(fp)
81134954:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81134958:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113495c:	e0bfff17 	ldw	r2,-4(fp)
81134960:	1000021e 	bne	r2,zero,8113496c <OSMemGet+0x30>
        return ((void *)0);
81134964:	0005883a 	mov	r2,zero
81134968:	00002e06 	br	81134a24 <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
8113496c:	e0bffe17 	ldw	r2,-8(fp)
81134970:	1000051e 	bne	r2,zero,81134988 <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81134974:	e0bfff17 	ldw	r2,-4(fp)
81134978:	00c01804 	movi	r3,96
8113497c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81134980:	0005883a 	mov	r2,zero
81134984:	00002706 	br	81134a24 <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134988:	0005303a 	rdctl	r2,status
8113498c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134990:	e0fffd17 	ldw	r3,-12(fp)
81134994:	00bfff84 	movi	r2,-2
81134998:	1884703a 	and	r2,r3,r2
8113499c:	1001703a 	wrctl	status,r2
  
  return context;
811349a0:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
811349a4:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
811349a8:	e0bffe17 	ldw	r2,-8(fp)
811349ac:	10800417 	ldw	r2,16(r2)
811349b0:	10001426 	beq	r2,zero,81134a04 <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
811349b4:	e0bffe17 	ldw	r2,-8(fp)
811349b8:	10800117 	ldw	r2,4(r2)
811349bc:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
811349c0:	e0bffb17 	ldw	r2,-20(fp)
811349c4:	10c00017 	ldw	r3,0(r2)
811349c8:	e0bffe17 	ldw	r2,-8(fp)
811349cc:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
811349d0:	e0bffe17 	ldw	r2,-8(fp)
811349d4:	10800417 	ldw	r2,16(r2)
811349d8:	10ffffc4 	addi	r3,r2,-1
811349dc:	e0bffe17 	ldw	r2,-8(fp)
811349e0:	10c00415 	stw	r3,16(r2)
811349e4:	e0bff917 	ldw	r2,-28(fp)
811349e8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811349ec:	e0bffa17 	ldw	r2,-24(fp)
811349f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
811349f4:	e0bfff17 	ldw	r2,-4(fp)
811349f8:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
811349fc:	e0bffb17 	ldw	r2,-20(fp)
81134a00:	00000806 	br	81134a24 <OSMemGet+0xe8>
81134a04:	e0bff917 	ldw	r2,-28(fp)
81134a08:	e0bffc15 	stw	r2,-16(fp)
81134a0c:	e0bffc17 	ldw	r2,-16(fp)
81134a10:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
81134a14:	e0bfff17 	ldw	r2,-4(fp)
81134a18:	00c01744 	movi	r3,93
81134a1c:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
81134a20:	0005883a 	mov	r2,zero
}
81134a24:	e037883a 	mov	sp,fp
81134a28:	df000017 	ldw	fp,0(sp)
81134a2c:	dec00104 	addi	sp,sp,4
81134a30:	f800283a 	ret

81134a34 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
81134a34:	defff704 	addi	sp,sp,-36
81134a38:	de00012e 	bgeu	sp,et,81134a40 <OSMemNameGet+0xc>
81134a3c:	003b68fa 	trap	3
81134a40:	dfc00815 	stw	ra,32(sp)
81134a44:	df000715 	stw	fp,28(sp)
81134a48:	df000704 	addi	fp,sp,28
81134a4c:	e13ffd15 	stw	r4,-12(fp)
81134a50:	e17ffe15 	stw	r5,-8(fp)
81134a54:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134a58:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81134a5c:	e0bfff17 	ldw	r2,-4(fp)
81134a60:	1000021e 	bne	r2,zero,81134a6c <OSMemNameGet+0x38>
        return (0);
81134a64:	0005883a 	mov	r2,zero
81134a68:	00002b06 	br	81134b18 <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
81134a6c:	e0bffd17 	ldw	r2,-12(fp)
81134a70:	1000051e 	bne	r2,zero,81134a88 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81134a74:	e0bfff17 	ldw	r2,-4(fp)
81134a78:	00c01804 	movi	r3,96
81134a7c:	10c00005 	stb	r3,0(r2)
        return (0);
81134a80:	0005883a 	mov	r2,zero
81134a84:	00002406 	br	81134b18 <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81134a88:	e0bffe17 	ldw	r2,-8(fp)
81134a8c:	1000051e 	bne	r2,zero,81134aa4 <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81134a90:	e0bfff17 	ldw	r2,-4(fp)
81134a94:	00c00304 	movi	r3,12
81134a98:	10c00005 	stb	r3,0(r2)
        return (0);
81134a9c:	0005883a 	mov	r2,zero
81134aa0:	00001d06 	br	81134b18 <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81134aa4:	d0a0a003 	ldbu	r2,-32128(gp)
81134aa8:	10803fcc 	andi	r2,r2,255
81134aac:	10000526 	beq	r2,zero,81134ac4 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
81134ab0:	e0bfff17 	ldw	r2,-4(fp)
81134ab4:	00c00444 	movi	r3,17
81134ab8:	10c00005 	stb	r3,0(r2)
        return (0);
81134abc:	0005883a 	mov	r2,zero
81134ac0:	00001506 	br	81134b18 <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134ac4:	0005303a 	rdctl	r2,status
81134ac8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134acc:	e0fffb17 	ldw	r3,-20(fp)
81134ad0:	00bfff84 	movi	r2,-2
81134ad4:	1884703a 	and	r2,r3,r2
81134ad8:	1001703a 	wrctl	status,r2
  
  return context;
81134adc:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
81134ae0:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
81134ae4:	e0bffd17 	ldw	r2,-12(fp)
81134ae8:	10800504 	addi	r2,r2,20
81134aec:	100b883a 	mov	r5,r2
81134af0:	e13ffe17 	ldw	r4,-8(fp)
81134af4:	113281c0 	call	8113281c <OS_StrCopy>
81134af8:	e0bffa05 	stb	r2,-24(fp)
81134afc:	e0bff917 	ldw	r2,-28(fp)
81134b00:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134b04:	e0bffc17 	ldw	r2,-16(fp)
81134b08:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81134b0c:	e0bfff17 	ldw	r2,-4(fp)
81134b10:	10000005 	stb	zero,0(r2)
    return (len);
81134b14:	e0bffa03 	ldbu	r2,-24(fp)
}
81134b18:	e037883a 	mov	sp,fp
81134b1c:	dfc00117 	ldw	ra,4(sp)
81134b20:	df000017 	ldw	fp,0(sp)
81134b24:	dec00204 	addi	sp,sp,8
81134b28:	f800283a 	ret

81134b2c <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
81134b2c:	defff604 	addi	sp,sp,-40
81134b30:	de00012e 	bgeu	sp,et,81134b38 <OSMemNameSet+0xc>
81134b34:	003b68fa 	trap	3
81134b38:	dfc00915 	stw	ra,36(sp)
81134b3c:	df000815 	stw	fp,32(sp)
81134b40:	df000804 	addi	fp,sp,32
81134b44:	e13ffd15 	stw	r4,-12(fp)
81134b48:	e17ffe15 	stw	r5,-8(fp)
81134b4c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134b50:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81134b54:	e0bfff17 	ldw	r2,-4(fp)
81134b58:	10003526 	beq	r2,zero,81134c30 <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
81134b5c:	e0bffd17 	ldw	r2,-12(fp)
81134b60:	1000041e 	bne	r2,zero,81134b74 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81134b64:	e0bfff17 	ldw	r2,-4(fp)
81134b68:	00c01804 	movi	r3,96
81134b6c:	10c00005 	stb	r3,0(r2)
        return;
81134b70:	00003006 	br	81134c34 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81134b74:	e0bffe17 	ldw	r2,-8(fp)
81134b78:	1000041e 	bne	r2,zero,81134b8c <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81134b7c:	e0bfff17 	ldw	r2,-4(fp)
81134b80:	00c00304 	movi	r3,12
81134b84:	10c00005 	stb	r3,0(r2)
        return;
81134b88:	00002a06 	br	81134c34 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81134b8c:	d0a0a003 	ldbu	r2,-32128(gp)
81134b90:	10803fcc 	andi	r2,r2,255
81134b94:	10000426 	beq	r2,zero,81134ba8 <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81134b98:	e0bfff17 	ldw	r2,-4(fp)
81134b9c:	00c00484 	movi	r3,18
81134ba0:	10c00005 	stb	r3,0(r2)
        return;
81134ba4:	00002306 	br	81134c34 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134ba8:	0005303a 	rdctl	r2,status
81134bac:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134bb0:	e0fffc17 	ldw	r3,-16(fp)
81134bb4:	00bfff84 	movi	r2,-2
81134bb8:	1884703a 	and	r2,r3,r2
81134bbc:	1001703a 	wrctl	status,r2
  
  return context;
81134bc0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81134bc4:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
81134bc8:	e13ffe17 	ldw	r4,-8(fp)
81134bcc:	11328980 	call	81132898 <OS_StrLen>
81134bd0:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
81134bd4:	e0bffa03 	ldbu	r2,-24(fp)
81134bd8:	10800830 	cmpltui	r2,r2,32
81134bdc:	1000081e 	bne	r2,zero,81134c00 <OSMemNameSet+0xd4>
81134be0:	e0bff817 	ldw	r2,-32(fp)
81134be4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134be8:	e0bff917 	ldw	r2,-28(fp)
81134bec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
81134bf0:	e0bfff17 	ldw	r2,-4(fp)
81134bf4:	00c018c4 	movi	r3,99
81134bf8:	10c00005 	stb	r3,0(r2)
        return;
81134bfc:	00000d06 	br	81134c34 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
81134c00:	e0bffd17 	ldw	r2,-12(fp)
81134c04:	10800504 	addi	r2,r2,20
81134c08:	e17ffe17 	ldw	r5,-8(fp)
81134c0c:	1009883a 	mov	r4,r2
81134c10:	113281c0 	call	8113281c <OS_StrCopy>
81134c14:	e0bff817 	ldw	r2,-32(fp)
81134c18:	e0bffb15 	stw	r2,-20(fp)
81134c1c:	e0bffb17 	ldw	r2,-20(fp)
81134c20:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81134c24:	e0bfff17 	ldw	r2,-4(fp)
81134c28:	10000005 	stb	zero,0(r2)
81134c2c:	00000106 	br	81134c34 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81134c30:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81134c34:	e037883a 	mov	sp,fp
81134c38:	dfc00117 	ldw	ra,4(sp)
81134c3c:	df000017 	ldw	fp,0(sp)
81134c40:	dec00204 	addi	sp,sp,8
81134c44:	f800283a 	ret

81134c48 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
81134c48:	defff904 	addi	sp,sp,-28
81134c4c:	de00012e 	bgeu	sp,et,81134c54 <OSMemPut+0xc>
81134c50:	003b68fa 	trap	3
81134c54:	df000615 	stw	fp,24(sp)
81134c58:	df000604 	addi	fp,sp,24
81134c5c:	e13ffe15 	stw	r4,-8(fp)
81134c60:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134c64:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
81134c68:	e0bffe17 	ldw	r2,-8(fp)
81134c6c:	1000021e 	bne	r2,zero,81134c78 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
81134c70:	00801804 	movi	r2,96
81134c74:	00002806 	br	81134d18 <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
81134c78:	e0bfff17 	ldw	r2,-4(fp)
81134c7c:	1000021e 	bne	r2,zero,81134c88 <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
81134c80:	008017c4 	movi	r2,95
81134c84:	00002406 	br	81134d18 <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134c88:	0005303a 	rdctl	r2,status
81134c8c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134c90:	e0fffd17 	ldw	r3,-12(fp)
81134c94:	00bfff84 	movi	r2,-2
81134c98:	1884703a 	and	r2,r3,r2
81134c9c:	1001703a 	wrctl	status,r2
  
  return context;
81134ca0:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81134ca4:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
81134ca8:	e0bffe17 	ldw	r2,-8(fp)
81134cac:	10c00417 	ldw	r3,16(r2)
81134cb0:	e0bffe17 	ldw	r2,-8(fp)
81134cb4:	10800317 	ldw	r2,12(r2)
81134cb8:	18800636 	bltu	r3,r2,81134cd4 <OSMemPut+0x8c>
81134cbc:	e0bffa17 	ldw	r2,-24(fp)
81134cc0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134cc4:	e0bffb17 	ldw	r2,-20(fp)
81134cc8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
81134ccc:	00801784 	movi	r2,94
81134cd0:	00001106 	br	81134d18 <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
81134cd4:	e0bffe17 	ldw	r2,-8(fp)
81134cd8:	10c00117 	ldw	r3,4(r2)
81134cdc:	e0bfff17 	ldw	r2,-4(fp)
81134ce0:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
81134ce4:	e0bffe17 	ldw	r2,-8(fp)
81134ce8:	e0ffff17 	ldw	r3,-4(fp)
81134cec:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
81134cf0:	e0bffe17 	ldw	r2,-8(fp)
81134cf4:	10800417 	ldw	r2,16(r2)
81134cf8:	10c00044 	addi	r3,r2,1
81134cfc:	e0bffe17 	ldw	r2,-8(fp)
81134d00:	10c00415 	stw	r3,16(r2)
81134d04:	e0bffa17 	ldw	r2,-24(fp)
81134d08:	e0bffc15 	stw	r2,-16(fp)
81134d0c:	e0bffc17 	ldw	r2,-16(fp)
81134d10:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
81134d14:	0005883a 	mov	r2,zero
}
81134d18:	e037883a 	mov	sp,fp
81134d1c:	df000017 	ldw	fp,0(sp)
81134d20:	dec00104 	addi	sp,sp,4
81134d24:	f800283a 	ret

81134d28 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
81134d28:	defffa04 	addi	sp,sp,-24
81134d2c:	de00012e 	bgeu	sp,et,81134d34 <OSMemQuery+0xc>
81134d30:	003b68fa 	trap	3
81134d34:	df000515 	stw	fp,20(sp)
81134d38:	df000504 	addi	fp,sp,20
81134d3c:	e13ffe15 	stw	r4,-8(fp)
81134d40:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134d44:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
81134d48:	e0bffe17 	ldw	r2,-8(fp)
81134d4c:	1000021e 	bne	r2,zero,81134d58 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
81134d50:	00801804 	movi	r2,96
81134d54:	00002c06 	br	81134e08 <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
81134d58:	e0bfff17 	ldw	r2,-4(fp)
81134d5c:	1000021e 	bne	r2,zero,81134d68 <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
81134d60:	00801844 	movi	r2,97
81134d64:	00002806 	br	81134e08 <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134d68:	0005303a 	rdctl	r2,status
81134d6c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134d70:	e0fffc17 	ldw	r3,-16(fp)
81134d74:	00bfff84 	movi	r2,-2
81134d78:	1884703a 	and	r2,r3,r2
81134d7c:	1001703a 	wrctl	status,r2
  
  return context;
81134d80:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81134d84:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
81134d88:	e0bffe17 	ldw	r2,-8(fp)
81134d8c:	10c00017 	ldw	r3,0(r2)
81134d90:	e0bfff17 	ldw	r2,-4(fp)
81134d94:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
81134d98:	e0bffe17 	ldw	r2,-8(fp)
81134d9c:	10c00117 	ldw	r3,4(r2)
81134da0:	e0bfff17 	ldw	r2,-4(fp)
81134da4:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
81134da8:	e0bffe17 	ldw	r2,-8(fp)
81134dac:	10c00217 	ldw	r3,8(r2)
81134db0:	e0bfff17 	ldw	r2,-4(fp)
81134db4:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
81134db8:	e0bffe17 	ldw	r2,-8(fp)
81134dbc:	10c00317 	ldw	r3,12(r2)
81134dc0:	e0bfff17 	ldw	r2,-4(fp)
81134dc4:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
81134dc8:	e0bffe17 	ldw	r2,-8(fp)
81134dcc:	10c00417 	ldw	r3,16(r2)
81134dd0:	e0bfff17 	ldw	r2,-4(fp)
81134dd4:	10c00415 	stw	r3,16(r2)
81134dd8:	e0bffb17 	ldw	r2,-20(fp)
81134ddc:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134de0:	e0bffd17 	ldw	r2,-12(fp)
81134de4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
81134de8:	e0bfff17 	ldw	r2,-4(fp)
81134dec:	10c00317 	ldw	r3,12(r2)
81134df0:	e0bfff17 	ldw	r2,-4(fp)
81134df4:	10800417 	ldw	r2,16(r2)
81134df8:	1887c83a 	sub	r3,r3,r2
81134dfc:	e0bfff17 	ldw	r2,-4(fp)
81134e00:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
81134e04:	0005883a 	mov	r2,zero
}
81134e08:	e037883a 	mov	sp,fp
81134e0c:	df000017 	ldw	fp,0(sp)
81134e10:	dec00104 	addi	sp,sp,4
81134e14:	f800283a 	ret

81134e18 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
81134e18:	defffc04 	addi	sp,sp,-16
81134e1c:	de00012e 	bgeu	sp,et,81134e24 <OS_MemInit+0xc>
81134e20:	003b68fa 	trap	3
81134e24:	dfc00315 	stw	ra,12(sp)
81134e28:	df000215 	stw	fp,8(sp)
81134e2c:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
81134e30:	01430c04 	movi	r5,3120
81134e34:	012045b4 	movhi	r4,33046
81134e38:	212f5e04 	addi	r4,r4,-17032
81134e3c:	11325fc0 	call	811325fc <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
81134e40:	00a045b4 	movhi	r2,33046
81134e44:	10af5e04 	addi	r2,r2,-17032
81134e48:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
81134e4c:	e03fff0d 	sth	zero,-4(fp)
81134e50:	00001306 	br	81134ea0 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
81134e54:	e0bfff0b 	ldhu	r2,-4(fp)
81134e58:	10800044 	addi	r2,r2,1
81134e5c:	10c00d24 	muli	r3,r2,52
81134e60:	00a045b4 	movhi	r2,33046
81134e64:	10af5e04 	addi	r2,r2,-17032
81134e68:	1887883a 	add	r3,r3,r2
81134e6c:	e0bffe17 	ldw	r2,-8(fp)
81134e70:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
81134e74:	e0bffe17 	ldw	r2,-8(fp)
81134e78:	00c00fc4 	movi	r3,63
81134e7c:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
81134e80:	e0bffe17 	ldw	r2,-8(fp)
81134e84:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
81134e88:	e0bffe17 	ldw	r2,-8(fp)
81134e8c:	10800d04 	addi	r2,r2,52
81134e90:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
81134e94:	e0bfff0b 	ldhu	r2,-4(fp)
81134e98:	10800044 	addi	r2,r2,1
81134e9c:	e0bfff0d 	sth	r2,-4(fp)
81134ea0:	e0bfff0b 	ldhu	r2,-4(fp)
81134ea4:	10800ef0 	cmpltui	r2,r2,59
81134ea8:	103fea1e 	bne	r2,zero,81134e54 <__reset+0xfb114e54>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
81134eac:	e0bffe17 	ldw	r2,-8(fp)
81134eb0:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
81134eb4:	e0bffe17 	ldw	r2,-8(fp)
81134eb8:	00c00fc4 	movi	r3,63
81134ebc:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
81134ec0:	e0bffe17 	ldw	r2,-8(fp)
81134ec4:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
81134ec8:	00a045b4 	movhi	r2,33046
81134ecc:	10af5e04 	addi	r2,r2,-17032
81134ed0:	d0a09a15 	stw	r2,-32152(gp)
#endif
}
81134ed4:	0001883a 	nop
81134ed8:	e037883a 	mov	sp,fp
81134edc:	dfc00117 	ldw	ra,4(sp)
81134ee0:	df000017 	ldw	fp,0(sp)
81134ee4:	dec00204 	addi	sp,sp,8
81134ee8:	f800283a 	ret

81134eec <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
81134eec:	defff704 	addi	sp,sp,-36
81134ef0:	de00012e 	bgeu	sp,et,81134ef8 <OSMutexAccept+0xc>
81134ef4:	003b68fa 	trap	3
81134ef8:	df000815 	stw	fp,32(sp)
81134efc:	df000804 	addi	fp,sp,32
81134f00:	e13ffe15 	stw	r4,-8(fp)
81134f04:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81134f08:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
81134f0c:	e0bfff17 	ldw	r2,-4(fp)
81134f10:	1000021e 	bne	r2,zero,81134f1c <OSMutexAccept+0x30>
        return (OS_FALSE);
81134f14:	0005883a 	mov	r2,zero
81134f18:	00005b06 	br	81135088 <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
81134f1c:	e0bffe17 	ldw	r2,-8(fp)
81134f20:	1000051e 	bne	r2,zero,81134f38 <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81134f24:	e0bfff17 	ldw	r2,-4(fp)
81134f28:	00c00104 	movi	r3,4
81134f2c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81134f30:	0005883a 	mov	r2,zero
81134f34:	00005406 	br	81135088 <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
81134f38:	e0bffe17 	ldw	r2,-8(fp)
81134f3c:	10800003 	ldbu	r2,0(r2)
81134f40:	10803fcc 	andi	r2,r2,255
81134f44:	10800120 	cmpeqi	r2,r2,4
81134f48:	1000051e 	bne	r2,zero,81134f60 <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
81134f4c:	e0bfff17 	ldw	r2,-4(fp)
81134f50:	00c00044 	movi	r3,1
81134f54:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81134f58:	0005883a 	mov	r2,zero
81134f5c:	00004a06 	br	81135088 <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
81134f60:	d0a0a003 	ldbu	r2,-32128(gp)
81134f64:	10803fcc 	andi	r2,r2,255
81134f68:	10000526 	beq	r2,zero,81134f80 <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
81134f6c:	e0bfff17 	ldw	r2,-4(fp)
81134f70:	00c00084 	movi	r3,2
81134f74:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81134f78:	0005883a 	mov	r2,zero
81134f7c:	00004206 	br	81135088 <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134f80:	0005303a 	rdctl	r2,status
81134f84:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134f88:	e0fffd17 	ldw	r3,-12(fp)
81134f8c:	00bfff84 	movi	r2,-2
81134f90:	1884703a 	and	r2,r3,r2
81134f94:	1001703a 	wrctl	status,r2
  
  return context;
81134f98:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
81134f9c:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
81134fa0:	e0bffe17 	ldw	r2,-8(fp)
81134fa4:	1080020b 	ldhu	r2,8(r2)
81134fa8:	10bfffcc 	andi	r2,r2,65535
81134fac:	1004d23a 	srli	r2,r2,8
81134fb0:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
81134fb4:	e0bffe17 	ldw	r2,-8(fp)
81134fb8:	1080020b 	ldhu	r2,8(r2)
81134fbc:	10bfffcc 	andi	r2,r2,65535
81134fc0:	10803fcc 	andi	r2,r2,255
81134fc4:	10803fd8 	cmpnei	r2,r2,255
81134fc8:	1000281e 	bne	r2,zero,8113506c <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
81134fcc:	e0bffe17 	ldw	r2,-8(fp)
81134fd0:	10c0020b 	ldhu	r3,8(r2)
81134fd4:	00bfc004 	movi	r2,-256
81134fd8:	1884703a 	and	r2,r3,r2
81134fdc:	1007883a 	mov	r3,r2
81134fe0:	e0bffe17 	ldw	r2,-8(fp)
81134fe4:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
81134fe8:	e0bffe17 	ldw	r2,-8(fp)
81134fec:	10c0020b 	ldhu	r3,8(r2)
81134ff0:	d0a0a117 	ldw	r2,-32124(gp)
81134ff4:	10800c83 	ldbu	r2,50(r2)
81134ff8:	10803fcc 	andi	r2,r2,255
81134ffc:	1884b03a 	or	r2,r3,r2
81135000:	1007883a 	mov	r3,r2
81135004:	e0bffe17 	ldw	r2,-8(fp)
81135008:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
8113500c:	d0e0a117 	ldw	r3,-32124(gp)
81135010:	e0bffe17 	ldw	r2,-8(fp)
81135014:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
81135018:	d0a0a117 	ldw	r2,-32124(gp)
8113501c:	10800c83 	ldbu	r2,50(r2)
81135020:	10803fcc 	andi	r2,r2,255
81135024:	e0fffa03 	ldbu	r3,-24(fp)
81135028:	18800836 	bltu	r3,r2,8113504c <OSMutexAccept+0x160>
8113502c:	e0bff817 	ldw	r2,-32(fp)
81135030:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135034:	e0bff917 	ldw	r2,-28(fp)
81135038:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
8113503c:	e0bfff17 	ldw	r2,-4(fp)
81135040:	00c01e04 	movi	r3,120
81135044:	10c00005 	stb	r3,0(r2)
81135048:	00000606 	br	81135064 <OSMutexAccept+0x178>
8113504c:	e0bff817 	ldw	r2,-32(fp)
81135050:	e0bffb15 	stw	r2,-20(fp)
81135054:	e0bffb17 	ldw	r2,-20(fp)
81135058:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113505c:	e0bfff17 	ldw	r2,-4(fp)
81135060:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
81135064:	00800044 	movi	r2,1
81135068:	00000706 	br	81135088 <OSMutexAccept+0x19c>
8113506c:	e0bff817 	ldw	r2,-32(fp)
81135070:	e0bffc15 	stw	r2,-16(fp)
81135074:	e0bffc17 	ldw	r2,-16(fp)
81135078:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113507c:	e0bfff17 	ldw	r2,-4(fp)
81135080:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
81135084:	0005883a 	mov	r2,zero
}
81135088:	e037883a 	mov	sp,fp
8113508c:	df000017 	ldw	fp,0(sp)
81135090:	dec00104 	addi	sp,sp,4
81135094:	f800283a 	ret

81135098 <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
81135098:	defff604 	addi	sp,sp,-40
8113509c:	de00012e 	bgeu	sp,et,811350a4 <OSMutexCreate+0xc>
811350a0:	003b68fa 	trap	3
811350a4:	dfc00915 	stw	ra,36(sp)
811350a8:	df000815 	stw	fp,32(sp)
811350ac:	df000804 	addi	fp,sp,32
811350b0:	2005883a 	mov	r2,r4
811350b4:	e17fff15 	stw	r5,-4(fp)
811350b8:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
811350bc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
811350c0:	e0bfff17 	ldw	r2,-4(fp)
811350c4:	1000021e 	bne	r2,zero,811350d0 <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
811350c8:	0005883a 	mov	r2,zero
811350cc:	00006106 	br	81135254 <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
811350d0:	e0bffe03 	ldbu	r2,-8(fp)
811350d4:	10800ab0 	cmpltui	r2,r2,42
811350d8:	1000051e 	bne	r2,zero,811350f0 <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
811350dc:	e0bfff17 	ldw	r2,-4(fp)
811350e0:	00c00a84 	movi	r3,42
811350e4:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
811350e8:	0005883a 	mov	r2,zero
811350ec:	00005906 	br	81135254 <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811350f0:	d0a0a003 	ldbu	r2,-32128(gp)
811350f4:	10803fcc 	andi	r2,r2,255
811350f8:	10000526 	beq	r2,zero,81135110 <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
811350fc:	e0bfff17 	ldw	r2,-4(fp)
81135100:	00c00404 	movi	r3,16
81135104:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
81135108:	0005883a 	mov	r2,zero
8113510c:	00005106 	br	81135254 <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135110:	0005303a 	rdctl	r2,status
81135114:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135118:	e0fffd17 	ldw	r3,-12(fp)
8113511c:	00bfff84 	movi	r2,-2
81135120:	1884703a 	and	r2,r3,r2
81135124:	1001703a 	wrctl	status,r2
  
  return context;
81135128:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113512c:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
81135130:	e0fffe03 	ldbu	r3,-8(fp)
81135134:	00a045b4 	movhi	r2,33046
81135138:	1084d804 	addi	r2,r2,4960
8113513c:	18c7883a 	add	r3,r3,r3
81135140:	18c7883a 	add	r3,r3,r3
81135144:	10c5883a 	add	r2,r2,r3
81135148:	10800017 	ldw	r2,0(r2)
8113514c:	10000926 	beq	r2,zero,81135174 <OSMutexCreate+0xdc>
81135150:	e0bff817 	ldw	r2,-32(fp)
81135154:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135158:	e0bff917 	ldw	r2,-28(fp)
8113515c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
81135160:	e0bfff17 	ldw	r2,-4(fp)
81135164:	00c00a04 	movi	r3,40
81135168:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113516c:	0005883a 	mov	r2,zero
81135170:	00003806 	br	81135254 <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
81135174:	e0fffe03 	ldbu	r3,-8(fp)
81135178:	00a045b4 	movhi	r2,33046
8113517c:	1084d804 	addi	r2,r2,4960
81135180:	18c7883a 	add	r3,r3,r3
81135184:	18c7883a 	add	r3,r3,r3
81135188:	10c5883a 	add	r2,r2,r3
8113518c:	00c00044 	movi	r3,1
81135190:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
81135194:	d0a09f17 	ldw	r2,-32132(gp)
81135198:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
8113519c:	e0bffb17 	ldw	r2,-20(fp)
811351a0:	1000101e 	bne	r2,zero,811351e4 <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
811351a4:	e0fffe03 	ldbu	r3,-8(fp)
811351a8:	00a045b4 	movhi	r2,33046
811351ac:	1084d804 	addi	r2,r2,4960
811351b0:	18c7883a 	add	r3,r3,r3
811351b4:	18c7883a 	add	r3,r3,r3
811351b8:	10c5883a 	add	r2,r2,r3
811351bc:	10000015 	stw	zero,0(r2)
811351c0:	e0bff817 	ldw	r2,-32(fp)
811351c4:	e0bffa15 	stw	r2,-24(fp)
811351c8:	e0bffa17 	ldw	r2,-24(fp)
811351cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
811351d0:	e0bfff17 	ldw	r2,-4(fp)
811351d4:	00c00104 	movi	r3,4
811351d8:	10c00005 	stb	r3,0(r2)
        return (pevent);
811351dc:	e0bffb17 	ldw	r2,-20(fp)
811351e0:	00001c06 	br	81135254 <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
811351e4:	d0a09f17 	ldw	r2,-32132(gp)
811351e8:	10800117 	ldw	r2,4(r2)
811351ec:	d0a09f15 	stw	r2,-32132(gp)
811351f0:	e0bff817 	ldw	r2,-32(fp)
811351f4:	e0bffc15 	stw	r2,-16(fp)
811351f8:	e0bffc17 	ldw	r2,-16(fp)
811351fc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
81135200:	e0bffb17 	ldw	r2,-20(fp)
81135204:	00c00104 	movi	r3,4
81135208:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
8113520c:	e0bffe03 	ldbu	r2,-8(fp)
81135210:	1004923a 	slli	r2,r2,8
81135214:	10803fd4 	ori	r2,r2,255
81135218:	1007883a 	mov	r3,r2
8113521c:	e0bffb17 	ldw	r2,-20(fp)
81135220:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
81135224:	e0bffb17 	ldw	r2,-20(fp)
81135228:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
8113522c:	e0bffb17 	ldw	r2,-20(fp)
81135230:	00c00fc4 	movi	r3,63
81135234:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
81135238:	e0bffb17 	ldw	r2,-20(fp)
8113523c:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
81135240:	e13ffb17 	ldw	r4,-20(fp)
81135244:	11321e40 	call	811321e4 <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
81135248:	e0bfff17 	ldw	r2,-4(fp)
8113524c:	10000005 	stb	zero,0(r2)
    return (pevent);
81135250:	e0bffb17 	ldw	r2,-20(fp)
}
81135254:	e037883a 	mov	sp,fp
81135258:	dfc00117 	ldw	ra,4(sp)
8113525c:	df000017 	ldw	fp,0(sp)
81135260:	dec00204 	addi	sp,sp,8
81135264:	f800283a 	ret

81135268 <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81135268:	defff004 	addi	sp,sp,-64
8113526c:	de00012e 	bgeu	sp,et,81135274 <OSMutexDel+0xc>
81135270:	003b68fa 	trap	3
81135274:	dfc00f15 	stw	ra,60(sp)
81135278:	df000e15 	stw	fp,56(sp)
8113527c:	df000e04 	addi	fp,sp,56
81135280:	e13ffd15 	stw	r4,-12(fp)
81135284:	2805883a 	mov	r2,r5
81135288:	e1bfff15 	stw	r6,-4(fp)
8113528c:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81135290:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81135294:	e0bfff17 	ldw	r2,-4(fp)
81135298:	1000021e 	bne	r2,zero,811352a4 <OSMutexDel+0x3c>
        return (pevent);
8113529c:	e0bffd17 	ldw	r2,-12(fp)
811352a0:	0000ad06 	br	81135558 <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
811352a4:	e0bffd17 	ldw	r2,-12(fp)
811352a8:	1000051e 	bne	r2,zero,811352c0 <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
811352ac:	e0bfff17 	ldw	r2,-4(fp)
811352b0:	00c00104 	movi	r3,4
811352b4:	10c00005 	stb	r3,0(r2)
        return (pevent);
811352b8:	e0bffd17 	ldw	r2,-12(fp)
811352bc:	0000a606 	br	81135558 <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
811352c0:	e0bffd17 	ldw	r2,-12(fp)
811352c4:	10800003 	ldbu	r2,0(r2)
811352c8:	10803fcc 	andi	r2,r2,255
811352cc:	10800120 	cmpeqi	r2,r2,4
811352d0:	1000051e 	bne	r2,zero,811352e8 <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
811352d4:	e0bfff17 	ldw	r2,-4(fp)
811352d8:	00c00044 	movi	r3,1
811352dc:	10c00005 	stb	r3,0(r2)
        return (pevent);
811352e0:	e0bffd17 	ldw	r2,-12(fp)
811352e4:	00009c06 	br	81135558 <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811352e8:	d0a0a003 	ldbu	r2,-32128(gp)
811352ec:	10803fcc 	andi	r2,r2,255
811352f0:	10000526 	beq	r2,zero,81135308 <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
811352f4:	e0bfff17 	ldw	r2,-4(fp)
811352f8:	00c003c4 	movi	r3,15
811352fc:	10c00005 	stb	r3,0(r2)
        return (pevent);
81135300:	e0bffd17 	ldw	r2,-12(fp)
81135304:	00009406 	br	81135558 <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135308:	0005303a 	rdctl	r2,status
8113530c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135310:	e0fffc17 	ldw	r3,-16(fp)
81135314:	00bfff84 	movi	r2,-2
81135318:	1884703a 	and	r2,r3,r2
8113531c:	1001703a 	wrctl	status,r2
  
  return context;
81135320:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81135324:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
81135328:	e0bffd17 	ldw	r2,-12(fp)
8113532c:	10800283 	ldbu	r2,10(r2)
81135330:	10803fcc 	andi	r2,r2,255
81135334:	10000326 	beq	r2,zero,81135344 <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81135338:	00800044 	movi	r2,1
8113533c:	e0bff205 	stb	r2,-56(fp)
81135340:	00000106 	br	81135348 <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81135344:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
81135348:	e0bffe03 	ldbu	r2,-8(fp)
8113534c:	10000326 	beq	r2,zero,8113535c <OSMutexDel+0xf4>
81135350:	10800060 	cmpeqi	r2,r2,1
81135354:	10002f1e 	bne	r2,zero,81135414 <OSMutexDel+0x1ac>
81135358:	00007406 	br	8113552c <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
8113535c:	e0bff203 	ldbu	r2,-56(fp)
81135360:	1000221e 	bne	r2,zero,811353ec <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
81135364:	e0bffd17 	ldw	r2,-12(fp)
81135368:	00c00fc4 	movi	r3,63
8113536c:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
81135370:	e0bffd17 	ldw	r2,-12(fp)
81135374:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
81135378:	e0bffd17 	ldw	r2,-12(fp)
8113537c:	1080020b 	ldhu	r2,8(r2)
81135380:	10bfffcc 	andi	r2,r2,65535
81135384:	1004d23a 	srli	r2,r2,8
81135388:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
8113538c:	e0fff603 	ldbu	r3,-40(fp)
81135390:	00a045b4 	movhi	r2,33046
81135394:	1084d804 	addi	r2,r2,4960
81135398:	18c7883a 	add	r3,r3,r3
8113539c:	18c7883a 	add	r3,r3,r3
811353a0:	10c5883a 	add	r2,r2,r3
811353a4:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
811353a8:	e0bffd17 	ldw	r2,-12(fp)
811353ac:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
811353b0:	d0e09f17 	ldw	r3,-32132(gp)
811353b4:	e0bffd17 	ldw	r2,-12(fp)
811353b8:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
811353bc:	e0bffd17 	ldw	r2,-12(fp)
811353c0:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
811353c4:	e0bffd17 	ldw	r2,-12(fp)
811353c8:	d0a09f15 	stw	r2,-32132(gp)
811353cc:	e0bff417 	ldw	r2,-48(fp)
811353d0:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811353d4:	e0bff517 	ldw	r2,-44(fp)
811353d8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
811353dc:	e0bfff17 	ldw	r2,-4(fp)
811353e0:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
811353e4:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
811353e8:	00005a06 	br	81135554 <OSMutexDel+0x2ec>
811353ec:	e0bff417 	ldw	r2,-48(fp)
811353f0:	e0bff715 	stw	r2,-36(fp)
811353f4:	e0bff717 	ldw	r2,-36(fp)
811353f8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
811353fc:	e0bfff17 	ldw	r2,-4(fp)
81135400:	00c01244 	movi	r3,73
81135404:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
81135408:	e0bffd17 	ldw	r2,-12(fp)
8113540c:	e0bff315 	stw	r2,-52(fp)
             }
             break;
81135410:	00005006 	br	81135554 <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
81135414:	e0bffd17 	ldw	r2,-12(fp)
81135418:	1080020b 	ldhu	r2,8(r2)
8113541c:	10bfffcc 	andi	r2,r2,65535
81135420:	1004d23a 	srli	r2,r2,8
81135424:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
81135428:	e0bffd17 	ldw	r2,-12(fp)
8113542c:	1080020b 	ldhu	r2,8(r2)
81135430:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
81135434:	e0bffd17 	ldw	r2,-12(fp)
81135438:	10800117 	ldw	r2,4(r2)
8113543c:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
81135440:	e0bffa17 	ldw	r2,-24(fp)
81135444:	10000f26 	beq	r2,zero,81135484 <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
81135448:	e0bffa17 	ldw	r2,-24(fp)
8113544c:	10800c83 	ldbu	r2,50(r2)
81135450:	10c03fcc 	andi	r3,r2,255
81135454:	e0bff603 	ldbu	r2,-40(fp)
81135458:	18800a1e 	bne	r3,r2,81135484 <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
8113545c:	e0bff903 	ldbu	r2,-28(fp)
81135460:	100b883a 	mov	r5,r2
81135464:	e13ffa17 	ldw	r4,-24(fp)
81135468:	1135ea40 	call	81135ea4 <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113546c:	00000506 	br	81135484 <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
81135470:	000f883a 	mov	r7,zero
81135474:	01800404 	movi	r6,16
81135478:	000b883a 	mov	r5,zero
8113547c:	e13ffd17 	ldw	r4,-12(fp)
81135480:	1131c0c0 	call	81131c0c <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
81135484:	e0bffd17 	ldw	r2,-12(fp)
81135488:	10800283 	ldbu	r2,10(r2)
8113548c:	10803fcc 	andi	r2,r2,255
81135490:	103ff71e 	bne	r2,zero,81135470 <__reset+0xfb115470>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
81135494:	e0bffd17 	ldw	r2,-12(fp)
81135498:	00c00fc4 	movi	r3,63
8113549c:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
811354a0:	e0bffd17 	ldw	r2,-12(fp)
811354a4:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
811354a8:	e0bffd17 	ldw	r2,-12(fp)
811354ac:	1080020b 	ldhu	r2,8(r2)
811354b0:	10bfffcc 	andi	r2,r2,65535
811354b4:	1004d23a 	srli	r2,r2,8
811354b8:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
811354bc:	e0fff603 	ldbu	r3,-40(fp)
811354c0:	00a045b4 	movhi	r2,33046
811354c4:	1084d804 	addi	r2,r2,4960
811354c8:	18c7883a 	add	r3,r3,r3
811354cc:	18c7883a 	add	r3,r3,r3
811354d0:	10c5883a 	add	r2,r2,r3
811354d4:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
811354d8:	e0bffd17 	ldw	r2,-12(fp)
811354dc:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
811354e0:	d0e09f17 	ldw	r3,-32132(gp)
811354e4:	e0bffd17 	ldw	r2,-12(fp)
811354e8:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
811354ec:	e0bffd17 	ldw	r2,-12(fp)
811354f0:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
811354f4:	e0bffd17 	ldw	r2,-12(fp)
811354f8:	d0a09f15 	stw	r2,-32132(gp)
811354fc:	e0bff417 	ldw	r2,-48(fp)
81135500:	e0bff815 	stw	r2,-32(fp)
81135504:	e0bff817 	ldw	r2,-32(fp)
81135508:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113550c:	e0bff203 	ldbu	r2,-56(fp)
81135510:	10800058 	cmpnei	r2,r2,1
81135514:	1000011e 	bne	r2,zero,8113551c <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81135518:	11326c80 	call	811326c8 <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
8113551c:	e0bfff17 	ldw	r2,-4(fp)
81135520:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
81135524:	e03ff315 	stw	zero,-52(fp)
             break;
81135528:	00000a06 	br	81135554 <OSMutexDel+0x2ec>
8113552c:	e0bff417 	ldw	r2,-48(fp)
81135530:	e0bffb15 	stw	r2,-20(fp)
81135534:	e0bffb17 	ldw	r2,-20(fp)
81135538:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
8113553c:	e0bfff17 	ldw	r2,-4(fp)
81135540:	00c001c4 	movi	r3,7
81135544:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
81135548:	e0bffd17 	ldw	r2,-12(fp)
8113554c:	e0bff315 	stw	r2,-52(fp)
             break;
81135550:	0001883a 	nop
    }
    return (pevent_return);
81135554:	e0bff317 	ldw	r2,-52(fp)
}
81135558:	e037883a 	mov	sp,fp
8113555c:	dfc00117 	ldw	ra,4(sp)
81135560:	df000017 	ldw	fp,0(sp)
81135564:	dec00204 	addi	sp,sp,8
81135568:	f800283a 	ret

8113556c <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113556c:	deffee04 	addi	sp,sp,-72
81135570:	de00012e 	bgeu	sp,et,81135578 <OSMutexPend+0xc>
81135574:	003b68fa 	trap	3
81135578:	dfc01115 	stw	ra,68(sp)
8113557c:	df001015 	stw	fp,64(sp)
81135580:	df001004 	addi	fp,sp,64
81135584:	e13ffd15 	stw	r4,-12(fp)
81135588:	2805883a 	mov	r2,r5
8113558c:	e1bfff15 	stw	r6,-4(fp)
81135590:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81135594:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81135598:	e0bfff17 	ldw	r2,-4(fp)
8113559c:	10015626 	beq	r2,zero,81135af8 <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
811355a0:	e0bffd17 	ldw	r2,-12(fp)
811355a4:	1000041e 	bne	r2,zero,811355b8 <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
811355a8:	e0bfff17 	ldw	r2,-4(fp)
811355ac:	00c00104 	movi	r3,4
811355b0:	10c00005 	stb	r3,0(r2)
        return;
811355b4:	00015106 	br	81135afc <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
811355b8:	e0bffd17 	ldw	r2,-12(fp)
811355bc:	10800003 	ldbu	r2,0(r2)
811355c0:	10803fcc 	andi	r2,r2,255
811355c4:	10800120 	cmpeqi	r2,r2,4
811355c8:	1000041e 	bne	r2,zero,811355dc <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
811355cc:	e0bfff17 	ldw	r2,-4(fp)
811355d0:	00c00044 	movi	r3,1
811355d4:	10c00005 	stb	r3,0(r2)
        return;
811355d8:	00014806 	br	81135afc <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811355dc:	d0a0a003 	ldbu	r2,-32128(gp)
811355e0:	10803fcc 	andi	r2,r2,255
811355e4:	10000426 	beq	r2,zero,811355f8 <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
811355e8:	e0bfff17 	ldw	r2,-4(fp)
811355ec:	00c00084 	movi	r3,2
811355f0:	10c00005 	stb	r3,0(r2)
        return;
811355f4:	00014106 	br	81135afc <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
811355f8:	d0a08e03 	ldbu	r2,-32200(gp)
811355fc:	10803fcc 	andi	r2,r2,255
81135600:	10000426 	beq	r2,zero,81135614 <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
81135604:	e0bfff17 	ldw	r2,-4(fp)
81135608:	00c00344 	movi	r3,13
8113560c:	10c00005 	stb	r3,0(r2)
        return;
81135610:	00013a06 	br	81135afc <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135614:	0005303a 	rdctl	r2,status
81135618:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113561c:	e0fffc17 	ldw	r3,-16(fp)
81135620:	00bfff84 	movi	r2,-2
81135624:	1884703a 	and	r2,r3,r2
81135628:	1001703a 	wrctl	status,r2
  
  return context;
8113562c:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81135630:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
81135634:	e0bffd17 	ldw	r2,-12(fp)
81135638:	1080020b 	ldhu	r2,8(r2)
8113563c:	10bfffcc 	andi	r2,r2,65535
81135640:	1004d23a 	srli	r2,r2,8
81135644:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
81135648:	e0bffd17 	ldw	r2,-12(fp)
8113564c:	1080020b 	ldhu	r2,8(r2)
81135650:	10803fcc 	andi	r2,r2,255
81135654:	10803fd8 	cmpnei	r2,r2,255
81135658:	1000271e 	bne	r2,zero,811356f8 <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
8113565c:	e0bffd17 	ldw	r2,-12(fp)
81135660:	10c0020b 	ldhu	r3,8(r2)
81135664:	00bfc004 	movi	r2,-256
81135668:	1884703a 	and	r2,r3,r2
8113566c:	1007883a 	mov	r3,r2
81135670:	e0bffd17 	ldw	r2,-12(fp)
81135674:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
81135678:	e0bffd17 	ldw	r2,-12(fp)
8113567c:	10c0020b 	ldhu	r3,8(r2)
81135680:	d0a0a117 	ldw	r2,-32124(gp)
81135684:	10800c83 	ldbu	r2,50(r2)
81135688:	10803fcc 	andi	r2,r2,255
8113568c:	1884b03a 	or	r2,r3,r2
81135690:	1007883a 	mov	r3,r2
81135694:	e0bffd17 	ldw	r2,-12(fp)
81135698:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
8113569c:	d0e0a117 	ldw	r3,-32124(gp)
811356a0:	e0bffd17 	ldw	r2,-12(fp)
811356a4:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
811356a8:	d0a0a117 	ldw	r2,-32124(gp)
811356ac:	10800c83 	ldbu	r2,50(r2)
811356b0:	10803fcc 	andi	r2,r2,255
811356b4:	e0fff303 	ldbu	r3,-52(fp)
811356b8:	18800836 	bltu	r3,r2,811356dc <OSMutexPend+0x170>
811356bc:	e0bff117 	ldw	r2,-60(fp)
811356c0:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811356c4:	e0bff217 	ldw	r2,-56(fp)
811356c8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
811356cc:	e0bfff17 	ldw	r2,-4(fp)
811356d0:	00c01e04 	movi	r3,120
811356d4:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
811356d8:	00010806 	br	81135afc <OSMutexPend+0x590>
811356dc:	e0bff117 	ldw	r2,-60(fp)
811356e0:	e0bff415 	stw	r2,-48(fp)
811356e4:	e0bff417 	ldw	r2,-48(fp)
811356e8:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
811356ec:	e0bfff17 	ldw	r2,-4(fp)
811356f0:	10000005 	stb	zero,0(r2)
        }
        return;
811356f4:	00010106 	br	81135afc <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
811356f8:	e0bffd17 	ldw	r2,-12(fp)
811356fc:	1080020b 	ldhu	r2,8(r2)
81135700:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
81135704:	e0bffd17 	ldw	r2,-12(fp)
81135708:	10800117 	ldw	r2,4(r2)
8113570c:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
81135710:	e0bff717 	ldw	r2,-36(fp)
81135714:	10800c83 	ldbu	r2,50(r2)
81135718:	10803fcc 	andi	r2,r2,255
8113571c:	e0fff303 	ldbu	r3,-52(fp)
81135720:	1880b92e 	bgeu	r3,r2,81135a08 <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
81135724:	d0a0a117 	ldw	r2,-32124(gp)
81135728:	10800c83 	ldbu	r2,50(r2)
8113572c:	10c03fcc 	andi	r3,r2,255
81135730:	e0bff603 	ldbu	r2,-40(fp)
81135734:	1880b42e 	bgeu	r3,r2,81135a08 <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
81135738:	e0bff717 	ldw	r2,-36(fp)
8113573c:	10800d03 	ldbu	r2,52(r2)
81135740:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
81135744:	e0fff803 	ldbu	r3,-32(fp)
81135748:	d0a09d44 	addi	r2,gp,-32139
8113574c:	1885883a 	add	r2,r3,r2
81135750:	10c00003 	ldbu	r3,0(r2)
81135754:	e0bff717 	ldw	r2,-36(fp)
81135758:	10800d43 	ldbu	r2,53(r2)
8113575c:	1884703a 	and	r2,r3,r2
81135760:	10803fcc 	andi	r2,r2,255
81135764:	10001e26 	beq	r2,zero,811357e0 <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
81135768:	e0fff803 	ldbu	r3,-32(fp)
8113576c:	e13ff803 	ldbu	r4,-32(fp)
81135770:	d0a09d44 	addi	r2,gp,-32139
81135774:	2085883a 	add	r2,r4,r2
81135778:	10800003 	ldbu	r2,0(r2)
8113577c:	1009883a 	mov	r4,r2
81135780:	e0bff717 	ldw	r2,-36(fp)
81135784:	10800d43 	ldbu	r2,53(r2)
81135788:	0084303a 	nor	r2,zero,r2
8113578c:	2084703a 	and	r2,r4,r2
81135790:	1009883a 	mov	r4,r2
81135794:	d0a09d44 	addi	r2,gp,-32139
81135798:	1885883a 	add	r2,r3,r2
8113579c:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
811357a0:	e0fff803 	ldbu	r3,-32(fp)
811357a4:	d0a09d44 	addi	r2,gp,-32139
811357a8:	1885883a 	add	r2,r3,r2
811357ac:	10800003 	ldbu	r2,0(r2)
811357b0:	10803fcc 	andi	r2,r2,255
811357b4:	1000071e 	bne	r2,zero,811357d4 <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
811357b8:	e0bff717 	ldw	r2,-36(fp)
811357bc:	10800d83 	ldbu	r2,54(r2)
811357c0:	0084303a 	nor	r2,zero,r2
811357c4:	1007883a 	mov	r3,r2
811357c8:	d0a09d03 	ldbu	r2,-32140(gp)
811357cc:	1884703a 	and	r2,r3,r2
811357d0:	d0a09d05 	stb	r2,-32140(gp)
                }
                rdy = OS_TRUE;
811357d4:	00800044 	movi	r2,1
811357d8:	e0bff005 	stb	r2,-64(fp)
811357dc:	00002a06 	br	81135888 <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
811357e0:	e0bff717 	ldw	r2,-36(fp)
811357e4:	10800717 	ldw	r2,28(r2)
811357e8:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
811357ec:	e0bff917 	ldw	r2,-28(fp)
811357f0:	10002426 	beq	r2,zero,81135884 <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
811357f4:	e0bff717 	ldw	r2,-36(fp)
811357f8:	10800d03 	ldbu	r2,52(r2)
811357fc:	10803fcc 	andi	r2,r2,255
81135800:	e0fff717 	ldw	r3,-36(fp)
81135804:	18c00d03 	ldbu	r3,52(r3)
81135808:	18c03fcc 	andi	r3,r3,255
8113580c:	e13ff917 	ldw	r4,-28(fp)
81135810:	20c7883a 	add	r3,r4,r3
81135814:	18c002c4 	addi	r3,r3,11
81135818:	18c00003 	ldbu	r3,0(r3)
8113581c:	1809883a 	mov	r4,r3
81135820:	e0fff717 	ldw	r3,-36(fp)
81135824:	18c00d43 	ldbu	r3,53(r3)
81135828:	00c6303a 	nor	r3,zero,r3
8113582c:	20c6703a 	and	r3,r4,r3
81135830:	1809883a 	mov	r4,r3
81135834:	e0fff917 	ldw	r3,-28(fp)
81135838:	1887883a 	add	r3,r3,r2
8113583c:	18c002c4 	addi	r3,r3,11
81135840:	19000005 	stb	r4,0(r3)
81135844:	e0fff917 	ldw	r3,-28(fp)
81135848:	1885883a 	add	r2,r3,r2
8113584c:	108002c4 	addi	r2,r2,11
81135850:	10800003 	ldbu	r2,0(r2)
81135854:	10803fcc 	andi	r2,r2,255
81135858:	10000a1e 	bne	r2,zero,81135884 <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
8113585c:	e0bff917 	ldw	r2,-28(fp)
81135860:	10800283 	ldbu	r2,10(r2)
81135864:	1007883a 	mov	r3,r2
81135868:	e0bff717 	ldw	r2,-36(fp)
8113586c:	10800d83 	ldbu	r2,54(r2)
81135870:	0084303a 	nor	r2,zero,r2
81135874:	1884703a 	and	r2,r3,r2
81135878:	1007883a 	mov	r3,r2
8113587c:	e0bff917 	ldw	r2,-28(fp)
81135880:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
81135884:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
81135888:	e0bff717 	ldw	r2,-36(fp)
8113588c:	e0fff303 	ldbu	r3,-52(fp)
81135890:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
81135894:	e0bff717 	ldw	r2,-36(fp)
81135898:	10800c83 	ldbu	r2,50(r2)
8113589c:	10803fcc 	andi	r2,r2,255
811358a0:	1004d0fa 	srli	r2,r2,3
811358a4:	1007883a 	mov	r3,r2
811358a8:	e0bff717 	ldw	r2,-36(fp)
811358ac:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
811358b0:	e0bff717 	ldw	r2,-36(fp)
811358b4:	10800c83 	ldbu	r2,50(r2)
811358b8:	108001cc 	andi	r2,r2,7
811358bc:	1007883a 	mov	r3,r2
811358c0:	e0bff717 	ldw	r2,-36(fp)
811358c4:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
811358c8:	e0bff717 	ldw	r2,-36(fp)
811358cc:	10800d03 	ldbu	r2,52(r2)
811358d0:	10803fcc 	andi	r2,r2,255
811358d4:	00c00044 	movi	r3,1
811358d8:	1884983a 	sll	r2,r3,r2
811358dc:	1007883a 	mov	r3,r2
811358e0:	e0bff717 	ldw	r2,-36(fp)
811358e4:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
811358e8:	e0bff717 	ldw	r2,-36(fp)
811358ec:	10800cc3 	ldbu	r2,51(r2)
811358f0:	10803fcc 	andi	r2,r2,255
811358f4:	00c00044 	movi	r3,1
811358f8:	1884983a 	sll	r2,r3,r2
811358fc:	1007883a 	mov	r3,r2
81135900:	e0bff717 	ldw	r2,-36(fp)
81135904:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
81135908:	e0bff003 	ldbu	r2,-64(fp)
8113590c:	10800058 	cmpnei	r2,r2,1
81135910:	1000161e 	bne	r2,zero,8113596c <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
81135914:	e0bff717 	ldw	r2,-36(fp)
81135918:	10c00d83 	ldbu	r3,54(r2)
8113591c:	d0a09d03 	ldbu	r2,-32140(gp)
81135920:	1884b03a 	or	r2,r3,r2
81135924:	d0a09d05 	stb	r2,-32140(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81135928:	e0bff717 	ldw	r2,-36(fp)
8113592c:	10800d03 	ldbu	r2,52(r2)
81135930:	10c03fcc 	andi	r3,r2,255
81135934:	e0bff717 	ldw	r2,-36(fp)
81135938:	10800d03 	ldbu	r2,52(r2)
8113593c:	11003fcc 	andi	r4,r2,255
81135940:	d0a09d44 	addi	r2,gp,-32139
81135944:	2085883a 	add	r2,r4,r2
81135948:	11000003 	ldbu	r4,0(r2)
8113594c:	e0bff717 	ldw	r2,-36(fp)
81135950:	10800d43 	ldbu	r2,53(r2)
81135954:	2084b03a 	or	r2,r4,r2
81135958:	1009883a 	mov	r4,r2
8113595c:	d0a09d44 	addi	r2,gp,-32139
81135960:	1885883a 	add	r2,r3,r2
81135964:	11000005 	stb	r4,0(r2)
81135968:	00001f06 	br	811359e8 <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113596c:	e0bff717 	ldw	r2,-36(fp)
81135970:	10800717 	ldw	r2,28(r2)
81135974:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
81135978:	e0bff917 	ldw	r2,-28(fp)
8113597c:	10001a26 	beq	r2,zero,811359e8 <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
81135980:	e0bff917 	ldw	r2,-28(fp)
81135984:	10c00283 	ldbu	r3,10(r2)
81135988:	e0bff717 	ldw	r2,-36(fp)
8113598c:	10800d83 	ldbu	r2,54(r2)
81135990:	1884b03a 	or	r2,r3,r2
81135994:	1007883a 	mov	r3,r2
81135998:	e0bff917 	ldw	r2,-28(fp)
8113599c:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811359a0:	e0bff717 	ldw	r2,-36(fp)
811359a4:	10800d03 	ldbu	r2,52(r2)
811359a8:	10803fcc 	andi	r2,r2,255
811359ac:	e0fff717 	ldw	r3,-36(fp)
811359b0:	18c00d03 	ldbu	r3,52(r3)
811359b4:	18c03fcc 	andi	r3,r3,255
811359b8:	e13ff917 	ldw	r4,-28(fp)
811359bc:	20c7883a 	add	r3,r4,r3
811359c0:	18c002c4 	addi	r3,r3,11
811359c4:	19000003 	ldbu	r4,0(r3)
811359c8:	e0fff717 	ldw	r3,-36(fp)
811359cc:	18c00d43 	ldbu	r3,53(r3)
811359d0:	20c6b03a 	or	r3,r4,r3
811359d4:	1809883a 	mov	r4,r3
811359d8:	e0fff917 	ldw	r3,-28(fp)
811359dc:	1885883a 	add	r2,r3,r2
811359e0:	108002c4 	addi	r2,r2,11
811359e4:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
811359e8:	e0fff303 	ldbu	r3,-52(fp)
811359ec:	00a045b4 	movhi	r2,33046
811359f0:	1084d804 	addi	r2,r2,4960
811359f4:	18c7883a 	add	r3,r3,r3
811359f8:	18c7883a 	add	r3,r3,r3
811359fc:	10c5883a 	add	r2,r2,r3
81135a00:	e0fff717 	ldw	r3,-36(fp)
81135a04:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
81135a08:	d0a0a117 	ldw	r2,-32124(gp)
81135a0c:	d0e0a117 	ldw	r3,-32124(gp)
81135a10:	18c00c03 	ldbu	r3,48(r3)
81135a14:	18c00414 	ori	r3,r3,16
81135a18:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81135a1c:	d0a0a117 	ldw	r2,-32124(gp)
81135a20:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
81135a24:	d0a0a117 	ldw	r2,-32124(gp)
81135a28:	e0fffe0b 	ldhu	r3,-8(fp)
81135a2c:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
81135a30:	e13ffd17 	ldw	r4,-12(fp)
81135a34:	1131dac0 	call	81131dac <OS_EventTaskWait>
81135a38:	e0bff117 	ldw	r2,-60(fp)
81135a3c:	e0bffb15 	stw	r2,-20(fp)
81135a40:	e0bffb17 	ldw	r2,-20(fp)
81135a44:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
81135a48:	11326c80 	call	811326c8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135a4c:	0005303a 	rdctl	r2,status
81135a50:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135a54:	e0fff517 	ldw	r3,-44(fp)
81135a58:	00bfff84 	movi	r2,-2
81135a5c:	1884703a 	and	r2,r3,r2
81135a60:	1001703a 	wrctl	status,r2
  
  return context;
81135a64:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
81135a68:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
81135a6c:	d0a0a117 	ldw	r2,-32124(gp)
81135a70:	10800c43 	ldbu	r2,49(r2)
81135a74:	10803fcc 	andi	r2,r2,255
81135a78:	10000326 	beq	r2,zero,81135a88 <OSMutexPend+0x51c>
81135a7c:	108000a0 	cmpeqi	r2,r2,2
81135a80:	1000041e 	bne	r2,zero,81135a94 <OSMutexPend+0x528>
81135a84:	00000706 	br	81135aa4 <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
81135a88:	e0bfff17 	ldw	r2,-4(fp)
81135a8c:	10000005 	stb	zero,0(r2)
             break;
81135a90:	00000c06 	br	81135ac4 <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
81135a94:	e0bfff17 	ldw	r2,-4(fp)
81135a98:	00c00384 	movi	r3,14
81135a9c:	10c00005 	stb	r3,0(r2)
             break;
81135aa0:	00000806 	br	81135ac4 <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
81135aa4:	d0a0a117 	ldw	r2,-32124(gp)
81135aa8:	e17ffd17 	ldw	r5,-12(fp)
81135aac:	1009883a 	mov	r4,r2
81135ab0:	113201c0 	call	8113201c <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
81135ab4:	e0bfff17 	ldw	r2,-4(fp)
81135ab8:	00c00284 	movi	r3,10
81135abc:	10c00005 	stb	r3,0(r2)
             break;
81135ac0:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81135ac4:	d0a0a117 	ldw	r2,-32124(gp)
81135ac8:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
81135acc:	d0a0a117 	ldw	r2,-32124(gp)
81135ad0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81135ad4:	d0a0a117 	ldw	r2,-32124(gp)
81135ad8:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81135adc:	d0a0a117 	ldw	r2,-32124(gp)
81135ae0:	10000815 	stw	zero,32(r2)
81135ae4:	e0bff117 	ldw	r2,-60(fp)
81135ae8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135aec:	e0bffa17 	ldw	r2,-24(fp)
81135af0:	1001703a 	wrctl	status,r2
81135af4:	00000106 	br	81135afc <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
81135af8:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
81135afc:	e037883a 	mov	sp,fp
81135b00:	dfc00117 	ldw	ra,4(sp)
81135b04:	df000017 	ldw	fp,0(sp)
81135b08:	dec00204 	addi	sp,sp,8
81135b0c:	f800283a 	ret

81135b10 <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
81135b10:	defff604 	addi	sp,sp,-40
81135b14:	de00012e 	bgeu	sp,et,81135b1c <OSMutexPost+0xc>
81135b18:	003b68fa 	trap	3
81135b1c:	dfc00915 	stw	ra,36(sp)
81135b20:	df000815 	stw	fp,32(sp)
81135b24:	df000804 	addi	fp,sp,32
81135b28:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81135b2c:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
81135b30:	d0a0a003 	ldbu	r2,-32128(gp)
81135b34:	10803fcc 	andi	r2,r2,255
81135b38:	10000226 	beq	r2,zero,81135b44 <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
81135b3c:	00800144 	movi	r2,5
81135b40:	00007606 	br	81135d1c <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81135b44:	e0bfff17 	ldw	r2,-4(fp)
81135b48:	1000021e 	bne	r2,zero,81135b54 <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
81135b4c:	00800104 	movi	r2,4
81135b50:	00007206 	br	81135d1c <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
81135b54:	e0bfff17 	ldw	r2,-4(fp)
81135b58:	10800003 	ldbu	r2,0(r2)
81135b5c:	10803fcc 	andi	r2,r2,255
81135b60:	10800120 	cmpeqi	r2,r2,4
81135b64:	1000021e 	bne	r2,zero,81135b70 <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
81135b68:	00800044 	movi	r2,1
81135b6c:	00006b06 	br	81135d1c <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135b70:	0005303a 	rdctl	r2,status
81135b74:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135b78:	e0fffe17 	ldw	r3,-8(fp)
81135b7c:	00bfff84 	movi	r2,-2
81135b80:	1884703a 	and	r2,r3,r2
81135b84:	1001703a 	wrctl	status,r2
  
  return context;
81135b88:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81135b8c:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
81135b90:	e0bfff17 	ldw	r2,-4(fp)
81135b94:	1080020b 	ldhu	r2,8(r2)
81135b98:	10bfffcc 	andi	r2,r2,65535
81135b9c:	1004d23a 	srli	r2,r2,8
81135ba0:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
81135ba4:	e0bfff17 	ldw	r2,-4(fp)
81135ba8:	1080020b 	ldhu	r2,8(r2)
81135bac:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
81135bb0:	e0bfff17 	ldw	r2,-4(fp)
81135bb4:	10c00117 	ldw	r3,4(r2)
81135bb8:	d0a0a117 	ldw	r2,-32124(gp)
81135bbc:	18800626 	beq	r3,r2,81135bd8 <OSMutexPost+0xc8>
81135bc0:	e0bff817 	ldw	r2,-32(fp)
81135bc4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135bc8:	e0bff917 	ldw	r2,-28(fp)
81135bcc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
81135bd0:	00801904 	movi	r2,100
81135bd4:	00005106 	br	81135d1c <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
81135bd8:	d0a0a117 	ldw	r2,-32124(gp)
81135bdc:	10800c83 	ldbu	r2,50(r2)
81135be0:	10c03fcc 	andi	r3,r2,255
81135be4:	e0bffa03 	ldbu	r2,-24(fp)
81135be8:	1880051e 	bne	r3,r2,81135c00 <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
81135bec:	d0a0a117 	ldw	r2,-32124(gp)
81135bf0:	e0fffa43 	ldbu	r3,-23(fp)
81135bf4:	180b883a 	mov	r5,r3
81135bf8:	1009883a 	mov	r4,r2
81135bfc:	1135ea40 	call	81135ea4 <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
81135c00:	e0fffa03 	ldbu	r3,-24(fp)
81135c04:	00a045b4 	movhi	r2,33046
81135c08:	1084d804 	addi	r2,r2,4960
81135c0c:	18c7883a 	add	r3,r3,r3
81135c10:	18c7883a 	add	r3,r3,r3
81135c14:	10c5883a 	add	r2,r2,r3
81135c18:	00c00044 	movi	r3,1
81135c1c:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
81135c20:	e0bfff17 	ldw	r2,-4(fp)
81135c24:	10800283 	ldbu	r2,10(r2)
81135c28:	10803fcc 	andi	r2,r2,255
81135c2c:	10002e26 	beq	r2,zero,81135ce8 <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
81135c30:	000f883a 	mov	r7,zero
81135c34:	01800404 	movi	r6,16
81135c38:	000b883a 	mov	r5,zero
81135c3c:	e13fff17 	ldw	r4,-4(fp)
81135c40:	1131c0c0 	call	81131c0c <OS_EventTaskRdy>
81135c44:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
81135c48:	e0bfff17 	ldw	r2,-4(fp)
81135c4c:	10c0020b 	ldhu	r3,8(r2)
81135c50:	00bfc004 	movi	r2,-256
81135c54:	1884703a 	and	r2,r3,r2
81135c58:	1007883a 	mov	r3,r2
81135c5c:	e0bfff17 	ldw	r2,-4(fp)
81135c60:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
81135c64:	e0bfff17 	ldw	r2,-4(fp)
81135c68:	10c0020b 	ldhu	r3,8(r2)
81135c6c:	e0bffa43 	ldbu	r2,-23(fp)
81135c70:	1884b03a 	or	r2,r3,r2
81135c74:	1007883a 	mov	r3,r2
81135c78:	e0bfff17 	ldw	r2,-4(fp)
81135c7c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
81135c80:	e0fffa43 	ldbu	r3,-23(fp)
81135c84:	00a045b4 	movhi	r2,33046
81135c88:	1084d804 	addi	r2,r2,4960
81135c8c:	18c7883a 	add	r3,r3,r3
81135c90:	18c7883a 	add	r3,r3,r3
81135c94:	10c5883a 	add	r2,r2,r3
81135c98:	10c00017 	ldw	r3,0(r2)
81135c9c:	e0bfff17 	ldw	r2,-4(fp)
81135ca0:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
81135ca4:	e0bffa43 	ldbu	r2,-23(fp)
81135ca8:	e0fffa03 	ldbu	r3,-24(fp)
81135cac:	18800736 	bltu	r3,r2,81135ccc <OSMutexPost+0x1bc>
81135cb0:	e0bff817 	ldw	r2,-32(fp)
81135cb4:	e0bffb15 	stw	r2,-20(fp)
81135cb8:	e0bffb17 	ldw	r2,-20(fp)
81135cbc:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
81135cc0:	11326c80 	call	811326c8 <OS_Sched>
            return (OS_ERR_PIP_LOWER);
81135cc4:	00801e04 	movi	r2,120
81135cc8:	00001406 	br	81135d1c <OSMutexPost+0x20c>
81135ccc:	e0bff817 	ldw	r2,-32(fp)
81135cd0:	e0bffc15 	stw	r2,-16(fp)
81135cd4:	e0bffc17 	ldw	r2,-16(fp)
81135cd8:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
81135cdc:	11326c80 	call	811326c8 <OS_Sched>
            return (OS_ERR_NONE);
81135ce0:	0005883a 	mov	r2,zero
81135ce4:	00000d06 	br	81135d1c <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
81135ce8:	e0bfff17 	ldw	r2,-4(fp)
81135cec:	1080020b 	ldhu	r2,8(r2)
81135cf0:	10803fd4 	ori	r2,r2,255
81135cf4:	1007883a 	mov	r3,r2
81135cf8:	e0bfff17 	ldw	r2,-4(fp)
81135cfc:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
81135d00:	e0bfff17 	ldw	r2,-4(fp)
81135d04:	10000115 	stw	zero,4(r2)
81135d08:	e0bff817 	ldw	r2,-32(fp)
81135d0c:	e0bffd15 	stw	r2,-12(fp)
81135d10:	e0bffd17 	ldw	r2,-12(fp)
81135d14:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81135d18:	0005883a 	mov	r2,zero
}
81135d1c:	e037883a 	mov	sp,fp
81135d20:	dfc00117 	ldw	ra,4(sp)
81135d24:	df000017 	ldw	fp,0(sp)
81135d28:	dec00204 	addi	sp,sp,8
81135d2c:	f800283a 	ret

81135d30 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
81135d30:	defff704 	addi	sp,sp,-36
81135d34:	de00012e 	bgeu	sp,et,81135d3c <OSMutexQuery+0xc>
81135d38:	003b68fa 	trap	3
81135d3c:	df000815 	stw	fp,32(sp)
81135d40:	df000804 	addi	fp,sp,32
81135d44:	e13ffe15 	stw	r4,-8(fp)
81135d48:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81135d4c:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81135d50:	d0a0a003 	ldbu	r2,-32128(gp)
81135d54:	10803fcc 	andi	r2,r2,255
81135d58:	10000226 	beq	r2,zero,81135d64 <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
81135d5c:	00800184 	movi	r2,6
81135d60:	00004c06 	br	81135e94 <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81135d64:	e0bffe17 	ldw	r2,-8(fp)
81135d68:	1000021e 	bne	r2,zero,81135d74 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
81135d6c:	00800104 	movi	r2,4
81135d70:	00004806 	br	81135e94 <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
81135d74:	e0bfff17 	ldw	r2,-4(fp)
81135d78:	1000021e 	bne	r2,zero,81135d84 <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
81135d7c:	00800244 	movi	r2,9
81135d80:	00004406 	br	81135e94 <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81135d84:	e0bffe17 	ldw	r2,-8(fp)
81135d88:	10800003 	ldbu	r2,0(r2)
81135d8c:	10803fcc 	andi	r2,r2,255
81135d90:	10800120 	cmpeqi	r2,r2,4
81135d94:	1000021e 	bne	r2,zero,81135da0 <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
81135d98:	00800044 	movi	r2,1
81135d9c:	00003d06 	br	81135e94 <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135da0:	0005303a 	rdctl	r2,status
81135da4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135da8:	e0fffd17 	ldw	r3,-12(fp)
81135dac:	00bfff84 	movi	r2,-2
81135db0:	1884703a 	and	r2,r3,r2
81135db4:	1001703a 	wrctl	status,r2
  
  return context;
81135db8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81135dbc:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
81135dc0:	e0bffe17 	ldw	r2,-8(fp)
81135dc4:	1080020b 	ldhu	r2,8(r2)
81135dc8:	10bfffcc 	andi	r2,r2,65535
81135dcc:	1004d23a 	srli	r2,r2,8
81135dd0:	1007883a 	mov	r3,r2
81135dd4:	e0bfff17 	ldw	r2,-4(fp)
81135dd8:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
81135ddc:	e0bffe17 	ldw	r2,-8(fp)
81135de0:	1080020b 	ldhu	r2,8(r2)
81135de4:	1007883a 	mov	r3,r2
81135de8:	e0bfff17 	ldw	r2,-4(fp)
81135dec:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
81135df0:	e0bfff17 	ldw	r2,-4(fp)
81135df4:	10800203 	ldbu	r2,8(r2)
81135df8:	10803fcc 	andi	r2,r2,255
81135dfc:	10803fd8 	cmpnei	r2,r2,255
81135e00:	1000041e 	bne	r2,zero,81135e14 <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
81135e04:	e0bfff17 	ldw	r2,-4(fp)
81135e08:	00c00044 	movi	r3,1
81135e0c:	10c001c5 	stb	r3,7(r2)
81135e10:	00000206 	br	81135e1c <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
81135e14:	e0bfff17 	ldw	r2,-4(fp)
81135e18:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
81135e1c:	e0bffe17 	ldw	r2,-8(fp)
81135e20:	10c00283 	ldbu	r3,10(r2)
81135e24:	e0bfff17 	ldw	r2,-4(fp)
81135e28:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
81135e2c:	e0bffe17 	ldw	r2,-8(fp)
81135e30:	108002c4 	addi	r2,r2,11
81135e34:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
81135e38:	e0bfff17 	ldw	r2,-4(fp)
81135e3c:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81135e40:	e03ff805 	stb	zero,-32(fp)
81135e44:	00000b06 	br	81135e74 <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
81135e48:	e0bffa17 	ldw	r2,-24(fp)
81135e4c:	10c00044 	addi	r3,r2,1
81135e50:	e0fffa15 	stw	r3,-24(fp)
81135e54:	e0fff917 	ldw	r3,-28(fp)
81135e58:	19000044 	addi	r4,r3,1
81135e5c:	e13ff915 	stw	r4,-28(fp)
81135e60:	18c00003 	ldbu	r3,0(r3)
81135e64:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81135e68:	e0bff803 	ldbu	r2,-32(fp)
81135e6c:	10800044 	addi	r2,r2,1
81135e70:	e0bff805 	stb	r2,-32(fp)
81135e74:	e0bff803 	ldbu	r2,-32(fp)
81135e78:	108001b0 	cmpltui	r2,r2,6
81135e7c:	103ff21e 	bne	r2,zero,81135e48 <__reset+0xfb115e48>
81135e80:	e0bffb17 	ldw	r2,-20(fp)
81135e84:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135e88:	e0bffc17 	ldw	r2,-16(fp)
81135e8c:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81135e90:	0005883a 	mov	r2,zero
}
81135e94:	e037883a 	mov	sp,fp
81135e98:	df000017 	ldw	fp,0(sp)
81135e9c:	dec00104 	addi	sp,sp,4
81135ea0:	f800283a 	ret

81135ea4 <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
81135ea4:	defffc04 	addi	sp,sp,-16
81135ea8:	de00012e 	bgeu	sp,et,81135eb0 <OSMutex_RdyAtPrio+0xc>
81135eac:	003b68fa 	trap	3
81135eb0:	df000315 	stw	fp,12(sp)
81135eb4:	df000304 	addi	fp,sp,12
81135eb8:	e13ffe15 	stw	r4,-8(fp)
81135ebc:	2805883a 	mov	r2,r5
81135ec0:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
81135ec4:	e0bffe17 	ldw	r2,-8(fp)
81135ec8:	10800d03 	ldbu	r2,52(r2)
81135ecc:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
81135ed0:	e0fffd03 	ldbu	r3,-12(fp)
81135ed4:	e13ffd03 	ldbu	r4,-12(fp)
81135ed8:	d0a09d44 	addi	r2,gp,-32139
81135edc:	2085883a 	add	r2,r4,r2
81135ee0:	10800003 	ldbu	r2,0(r2)
81135ee4:	1009883a 	mov	r4,r2
81135ee8:	e0bffe17 	ldw	r2,-8(fp)
81135eec:	10800d43 	ldbu	r2,53(r2)
81135ef0:	0084303a 	nor	r2,zero,r2
81135ef4:	2084703a 	and	r2,r4,r2
81135ef8:	1009883a 	mov	r4,r2
81135efc:	d0a09d44 	addi	r2,gp,-32139
81135f00:	1885883a 	add	r2,r3,r2
81135f04:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81135f08:	e0fffd03 	ldbu	r3,-12(fp)
81135f0c:	d0a09d44 	addi	r2,gp,-32139
81135f10:	1885883a 	add	r2,r3,r2
81135f14:	10800003 	ldbu	r2,0(r2)
81135f18:	10803fcc 	andi	r2,r2,255
81135f1c:	1000071e 	bne	r2,zero,81135f3c <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
81135f20:	e0bffe17 	ldw	r2,-8(fp)
81135f24:	10800d83 	ldbu	r2,54(r2)
81135f28:	0084303a 	nor	r2,zero,r2
81135f2c:	1007883a 	mov	r3,r2
81135f30:	d0a09d03 	ldbu	r2,-32140(gp)
81135f34:	1884703a 	and	r2,r3,r2
81135f38:	d0a09d05 	stb	r2,-32140(gp)
    }
    ptcb->OSTCBPrio         = prio;
81135f3c:	e0bffe17 	ldw	r2,-8(fp)
81135f40:	e0ffff03 	ldbu	r3,-4(fp)
81135f44:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
81135f48:	e0bfff03 	ldbu	r2,-4(fp)
81135f4c:	1004d0fa 	srli	r2,r2,3
81135f50:	108001cc 	andi	r2,r2,7
81135f54:	1007883a 	mov	r3,r2
81135f58:	e0bffe17 	ldw	r2,-8(fp)
81135f5c:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
81135f60:	e0bfff03 	ldbu	r2,-4(fp)
81135f64:	108001cc 	andi	r2,r2,7
81135f68:	1007883a 	mov	r3,r2
81135f6c:	e0bffe17 	ldw	r2,-8(fp)
81135f70:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
81135f74:	e0bffe17 	ldw	r2,-8(fp)
81135f78:	10800d03 	ldbu	r2,52(r2)
81135f7c:	10803fcc 	andi	r2,r2,255
81135f80:	00c00044 	movi	r3,1
81135f84:	1884983a 	sll	r2,r3,r2
81135f88:	1007883a 	mov	r3,r2
81135f8c:	e0bffe17 	ldw	r2,-8(fp)
81135f90:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
81135f94:	e0bffe17 	ldw	r2,-8(fp)
81135f98:	10800cc3 	ldbu	r2,51(r2)
81135f9c:	10803fcc 	andi	r2,r2,255
81135fa0:	00c00044 	movi	r3,1
81135fa4:	1884983a 	sll	r2,r3,r2
81135fa8:	1007883a 	mov	r3,r2
81135fac:	e0bffe17 	ldw	r2,-8(fp)
81135fb0:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
81135fb4:	e0bffe17 	ldw	r2,-8(fp)
81135fb8:	10c00d83 	ldbu	r3,54(r2)
81135fbc:	d0a09d03 	ldbu	r2,-32140(gp)
81135fc0:	1884b03a 	or	r2,r3,r2
81135fc4:	d0a09d05 	stb	r2,-32140(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81135fc8:	e0bffe17 	ldw	r2,-8(fp)
81135fcc:	10800d03 	ldbu	r2,52(r2)
81135fd0:	10c03fcc 	andi	r3,r2,255
81135fd4:	e0bffe17 	ldw	r2,-8(fp)
81135fd8:	10800d03 	ldbu	r2,52(r2)
81135fdc:	11003fcc 	andi	r4,r2,255
81135fe0:	d0a09d44 	addi	r2,gp,-32139
81135fe4:	2085883a 	add	r2,r4,r2
81135fe8:	11000003 	ldbu	r4,0(r2)
81135fec:	e0bffe17 	ldw	r2,-8(fp)
81135ff0:	10800d43 	ldbu	r2,53(r2)
81135ff4:	2084b03a 	or	r2,r4,r2
81135ff8:	1009883a 	mov	r4,r2
81135ffc:	d0a09d44 	addi	r2,gp,-32139
81136000:	1885883a 	add	r2,r3,r2
81136004:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
81136008:	e0ffff03 	ldbu	r3,-4(fp)
8113600c:	00a045b4 	movhi	r2,33046
81136010:	1084d804 	addi	r2,r2,4960
81136014:	18c7883a 	add	r3,r3,r3
81136018:	18c7883a 	add	r3,r3,r3
8113601c:	10c5883a 	add	r2,r2,r3
81136020:	e0fffe17 	ldw	r3,-8(fp)
81136024:	10c00015 	stw	r3,0(r2)
}
81136028:	0001883a 	nop
8113602c:	e037883a 	mov	sp,fp
81136030:	df000017 	ldw	fp,0(sp)
81136034:	dec00104 	addi	sp,sp,4
81136038:	f800283a 	ret

8113603c <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
8113603c:	defff804 	addi	sp,sp,-32
81136040:	de00012e 	bgeu	sp,et,81136048 <OSQAccept+0xc>
81136044:	003b68fa 	trap	3
81136048:	df000715 	stw	fp,28(sp)
8113604c:	df000704 	addi	fp,sp,28
81136050:	e13ffe15 	stw	r4,-8(fp)
81136054:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136058:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113605c:	e0bfff17 	ldw	r2,-4(fp)
81136060:	1000021e 	bne	r2,zero,8113606c <OSQAccept+0x30>
        return ((void *)0);
81136064:	0005883a 	mov	r2,zero
81136068:	00004206 	br	81136174 <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113606c:	e0bffe17 	ldw	r2,-8(fp)
81136070:	1000051e 	bne	r2,zero,81136088 <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81136074:	e0bfff17 	ldw	r2,-4(fp)
81136078:	00c00104 	movi	r3,4
8113607c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81136080:	0005883a 	mov	r2,zero
81136084:	00003b06 	br	81136174 <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
81136088:	e0bffe17 	ldw	r2,-8(fp)
8113608c:	10800003 	ldbu	r2,0(r2)
81136090:	10803fcc 	andi	r2,r2,255
81136094:	108000a0 	cmpeqi	r2,r2,2
81136098:	1000051e 	bne	r2,zero,811360b0 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113609c:	e0bfff17 	ldw	r2,-4(fp)
811360a0:	00c00044 	movi	r3,1
811360a4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
811360a8:	0005883a 	mov	r2,zero
811360ac:	00003106 	br	81136174 <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811360b0:	0005303a 	rdctl	r2,status
811360b4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811360b8:	e0fffd17 	ldw	r3,-12(fp)
811360bc:	00bfff84 	movi	r2,-2
811360c0:	1884703a 	and	r2,r3,r2
811360c4:	1001703a 	wrctl	status,r2
  
  return context;
811360c8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811360cc:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
811360d0:	e0bffe17 	ldw	r2,-8(fp)
811360d4:	10800117 	ldw	r2,4(r2)
811360d8:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
811360dc:	e0bffc17 	ldw	r2,-16(fp)
811360e0:	1080058b 	ldhu	r2,22(r2)
811360e4:	10bfffcc 	andi	r2,r2,65535
811360e8:	10001926 	beq	r2,zero,81136150 <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
811360ec:	e0bffc17 	ldw	r2,-16(fp)
811360f0:	10800417 	ldw	r2,16(r2)
811360f4:	11000104 	addi	r4,r2,4
811360f8:	e0fffc17 	ldw	r3,-16(fp)
811360fc:	19000415 	stw	r4,16(r3)
81136100:	10800017 	ldw	r2,0(r2)
81136104:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
81136108:	e0bffc17 	ldw	r2,-16(fp)
8113610c:	1080058b 	ldhu	r2,22(r2)
81136110:	10bfffc4 	addi	r2,r2,-1
81136114:	1007883a 	mov	r3,r2
81136118:	e0bffc17 	ldw	r2,-16(fp)
8113611c:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
81136120:	e0bffc17 	ldw	r2,-16(fp)
81136124:	10c00417 	ldw	r3,16(r2)
81136128:	e0bffc17 	ldw	r2,-16(fp)
8113612c:	10800217 	ldw	r2,8(r2)
81136130:	1880041e 	bne	r3,r2,81136144 <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
81136134:	e0bffc17 	ldw	r2,-16(fp)
81136138:	10c00117 	ldw	r3,4(r2)
8113613c:	e0bffc17 	ldw	r2,-16(fp)
81136140:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
81136144:	e0bfff17 	ldw	r2,-4(fp)
81136148:	10000005 	stb	zero,0(r2)
8113614c:	00000406 	br	81136160 <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
81136150:	e0bfff17 	ldw	r2,-4(fp)
81136154:	00c007c4 	movi	r3,31
81136158:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
8113615c:	e03ff915 	stw	zero,-28(fp)
81136160:	e0bffa17 	ldw	r2,-24(fp)
81136164:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136168:	e0bffb17 	ldw	r2,-20(fp)
8113616c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
81136170:	e0bff917 	ldw	r2,-28(fp)
}
81136174:	e037883a 	mov	sp,fp
81136178:	df000017 	ldw	fp,0(sp)
8113617c:	dec00104 	addi	sp,sp,4
81136180:	f800283a 	ret

81136184 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
81136184:	defff404 	addi	sp,sp,-48
81136188:	de00012e 	bgeu	sp,et,81136190 <OSQCreate+0xc>
8113618c:	003b68fa 	trap	3
81136190:	dfc00b15 	stw	ra,44(sp)
81136194:	df000a15 	stw	fp,40(sp)
81136198:	df000a04 	addi	fp,sp,40
8113619c:	e13ffe15 	stw	r4,-8(fp)
811361a0:	2805883a 	mov	r2,r5
811361a4:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811361a8:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
811361ac:	d0a0a003 	ldbu	r2,-32128(gp)
811361b0:	10803fcc 	andi	r2,r2,255
811361b4:	10000226 	beq	r2,zero,811361c0 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
811361b8:	0005883a 	mov	r2,zero
811361bc:	00005906 	br	81136324 <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811361c0:	0005303a 	rdctl	r2,status
811361c4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811361c8:	e0fffd17 	ldw	r3,-12(fp)
811361cc:	00bfff84 	movi	r2,-2
811361d0:	1884703a 	and	r2,r3,r2
811361d4:	1001703a 	wrctl	status,r2
  
  return context;
811361d8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811361dc:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
811361e0:	d0a09f17 	ldw	r2,-32132(gp)
811361e4:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
811361e8:	d0a09f17 	ldw	r2,-32132(gp)
811361ec:	10000326 	beq	r2,zero,811361fc <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
811361f0:	d0a09f17 	ldw	r2,-32132(gp)
811361f4:	10800117 	ldw	r2,4(r2)
811361f8:	d0a09f15 	stw	r2,-32132(gp)
811361fc:	e0bff717 	ldw	r2,-36(fp)
81136200:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136204:	e0bff817 	ldw	r2,-32(fp)
81136208:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
8113620c:	e0bff617 	ldw	r2,-40(fp)
81136210:	10004326 	beq	r2,zero,81136320 <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136214:	0005303a 	rdctl	r2,status
81136218:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113621c:	e0fff917 	ldw	r3,-28(fp)
81136220:	00bfff84 	movi	r2,-2
81136224:	1884703a 	and	r2,r3,r2
81136228:	1001703a 	wrctl	status,r2
  
  return context;
8113622c:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
81136230:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
81136234:	d0a09c17 	ldw	r2,-32144(gp)
81136238:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
8113623c:	e0bffb17 	ldw	r2,-20(fp)
81136240:	10002d26 	beq	r2,zero,811362f8 <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
81136244:	d0a09c17 	ldw	r2,-32144(gp)
81136248:	10800017 	ldw	r2,0(r2)
8113624c:	d0a09c15 	stw	r2,-32144(gp)
81136250:	e0bff717 	ldw	r2,-36(fp)
81136254:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136258:	e0bffa17 	ldw	r2,-24(fp)
8113625c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
81136260:	e0bffb17 	ldw	r2,-20(fp)
81136264:	e0fffe17 	ldw	r3,-8(fp)
81136268:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
8113626c:	e0bfff0b 	ldhu	r2,-4(fp)
81136270:	1085883a 	add	r2,r2,r2
81136274:	1085883a 	add	r2,r2,r2
81136278:	1007883a 	mov	r3,r2
8113627c:	e0bffe17 	ldw	r2,-8(fp)
81136280:	10c7883a 	add	r3,r2,r3
81136284:	e0bffb17 	ldw	r2,-20(fp)
81136288:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
8113628c:	e0bffb17 	ldw	r2,-20(fp)
81136290:	e0fffe17 	ldw	r3,-8(fp)
81136294:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
81136298:	e0bffb17 	ldw	r2,-20(fp)
8113629c:	e0fffe17 	ldw	r3,-8(fp)
811362a0:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
811362a4:	e0bffb17 	ldw	r2,-20(fp)
811362a8:	e0ffff0b 	ldhu	r3,-4(fp)
811362ac:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
811362b0:	e0bffb17 	ldw	r2,-20(fp)
811362b4:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
811362b8:	e0bff617 	ldw	r2,-40(fp)
811362bc:	00c00084 	movi	r3,2
811362c0:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
811362c4:	e0bff617 	ldw	r2,-40(fp)
811362c8:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
811362cc:	e0bff617 	ldw	r2,-40(fp)
811362d0:	e0fffb17 	ldw	r3,-20(fp)
811362d4:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
811362d8:	e0bff617 	ldw	r2,-40(fp)
811362dc:	00c00fc4 	movi	r3,63
811362e0:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
811362e4:	e0bff617 	ldw	r2,-40(fp)
811362e8:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
811362ec:	e13ff617 	ldw	r4,-40(fp)
811362f0:	11321e40 	call	811321e4 <OS_EventWaitListInit>
811362f4:	00000a06 	br	81136320 <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
811362f8:	d0e09f17 	ldw	r3,-32132(gp)
811362fc:	e0bff617 	ldw	r2,-40(fp)
81136300:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
81136304:	e0bff617 	ldw	r2,-40(fp)
81136308:	d0a09f15 	stw	r2,-32132(gp)
8113630c:	e0bff717 	ldw	r2,-36(fp)
81136310:	e0bffc15 	stw	r2,-16(fp)
81136314:	e0bffc17 	ldw	r2,-16(fp)
81136318:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
8113631c:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
81136320:	e0bff617 	ldw	r2,-40(fp)
}
81136324:	e037883a 	mov	sp,fp
81136328:	dfc00117 	ldw	ra,4(sp)
8113632c:	df000017 	ldw	fp,0(sp)
81136330:	dec00204 	addi	sp,sp,8
81136334:	f800283a 	ret

81136338 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81136338:	defff204 	addi	sp,sp,-56
8113633c:	de00012e 	bgeu	sp,et,81136344 <OSQDel+0xc>
81136340:	003b68fa 	trap	3
81136344:	dfc00d15 	stw	ra,52(sp)
81136348:	df000c15 	stw	fp,48(sp)
8113634c:	df000c04 	addi	fp,sp,48
81136350:	e13ffd15 	stw	r4,-12(fp)
81136354:	2805883a 	mov	r2,r5
81136358:	e1bfff15 	stw	r6,-4(fp)
8113635c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81136360:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81136364:	e0bfff17 	ldw	r2,-4(fp)
81136368:	1000021e 	bne	r2,zero,81136374 <OSQDel+0x3c>
        return (pevent);
8113636c:	e0bffd17 	ldw	r2,-12(fp)
81136370:	00008e06 	br	811365ac <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81136374:	e0bffd17 	ldw	r2,-12(fp)
81136378:	1000051e 	bne	r2,zero,81136390 <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113637c:	e0bfff17 	ldw	r2,-4(fp)
81136380:	00c00104 	movi	r3,4
81136384:	10c00005 	stb	r3,0(r2)
        return (pevent);
81136388:	e0bffd17 	ldw	r2,-12(fp)
8113638c:	00008706 	br	811365ac <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
81136390:	e0bffd17 	ldw	r2,-12(fp)
81136394:	10800003 	ldbu	r2,0(r2)
81136398:	10803fcc 	andi	r2,r2,255
8113639c:	108000a0 	cmpeqi	r2,r2,2
811363a0:	1000051e 	bne	r2,zero,811363b8 <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
811363a4:	e0bfff17 	ldw	r2,-4(fp)
811363a8:	00c00044 	movi	r3,1
811363ac:	10c00005 	stb	r3,0(r2)
        return (pevent);
811363b0:	e0bffd17 	ldw	r2,-12(fp)
811363b4:	00007d06 	br	811365ac <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811363b8:	d0a0a003 	ldbu	r2,-32128(gp)
811363bc:	10803fcc 	andi	r2,r2,255
811363c0:	10000526 	beq	r2,zero,811363d8 <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
811363c4:	e0bfff17 	ldw	r2,-4(fp)
811363c8:	00c003c4 	movi	r3,15
811363cc:	10c00005 	stb	r3,0(r2)
        return (pevent);
811363d0:	e0bffd17 	ldw	r2,-12(fp)
811363d4:	00007506 	br	811365ac <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811363d8:	0005303a 	rdctl	r2,status
811363dc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811363e0:	e0fffc17 	ldw	r3,-16(fp)
811363e4:	00bfff84 	movi	r2,-2
811363e8:	1884703a 	and	r2,r3,r2
811363ec:	1001703a 	wrctl	status,r2
  
  return context;
811363f0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811363f4:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
811363f8:	e0bffd17 	ldw	r2,-12(fp)
811363fc:	10800283 	ldbu	r2,10(r2)
81136400:	10803fcc 	andi	r2,r2,255
81136404:	10000326 	beq	r2,zero,81136414 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81136408:	00800044 	movi	r2,1
8113640c:	e0bff405 	stb	r2,-48(fp)
81136410:	00000106 	br	81136418 <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81136414:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
81136418:	e0bffe03 	ldbu	r2,-8(fp)
8113641c:	10000326 	beq	r2,zero,8113642c <OSQDel+0xf4>
81136420:	10800060 	cmpeqi	r2,r2,1
81136424:	1000301e 	bne	r2,zero,811364e8 <OSQDel+0x1b0>
81136428:	00005506 	br	81136580 <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
8113642c:	e0bff403 	ldbu	r2,-48(fp)
81136430:	10001e1e 	bne	r2,zero,811364ac <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
81136434:	e0bffd17 	ldw	r2,-12(fp)
81136438:	00c00fc4 	movi	r3,63
8113643c:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
81136440:	e0bffd17 	ldw	r2,-12(fp)
81136444:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
81136448:	e0bffd17 	ldw	r2,-12(fp)
8113644c:	10800117 	ldw	r2,4(r2)
81136450:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
81136454:	d0e09c17 	ldw	r3,-32144(gp)
81136458:	e0bff817 	ldw	r2,-32(fp)
8113645c:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
81136460:	e0bff817 	ldw	r2,-32(fp)
81136464:	d0a09c15 	stw	r2,-32144(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81136468:	e0bffd17 	ldw	r2,-12(fp)
8113646c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
81136470:	d0e09f17 	ldw	r3,-32132(gp)
81136474:	e0bffd17 	ldw	r2,-12(fp)
81136478:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113647c:	e0bffd17 	ldw	r2,-12(fp)
81136480:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
81136484:	e0bffd17 	ldw	r2,-12(fp)
81136488:	d0a09f15 	stw	r2,-32132(gp)
8113648c:	e0bff617 	ldw	r2,-40(fp)
81136490:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136494:	e0bff717 	ldw	r2,-36(fp)
81136498:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113649c:	e0bfff17 	ldw	r2,-4(fp)
811364a0:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
811364a4:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
811364a8:	00003f06 	br	811365a8 <OSQDel+0x270>
811364ac:	e0bff617 	ldw	r2,-40(fp)
811364b0:	e0bff915 	stw	r2,-28(fp)
811364b4:	e0bff917 	ldw	r2,-28(fp)
811364b8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
811364bc:	e0bfff17 	ldw	r2,-4(fp)
811364c0:	00c01244 	movi	r3,73
811364c4:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
811364c8:	e0bffd17 	ldw	r2,-12(fp)
811364cc:	e0bff515 	stw	r2,-44(fp)
             }
             break;
811364d0:	00003506 	br	811365a8 <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
811364d4:	000f883a 	mov	r7,zero
811364d8:	01800104 	movi	r6,4
811364dc:	000b883a 	mov	r5,zero
811364e0:	e13ffd17 	ldw	r4,-12(fp)
811364e4:	1131c0c0 	call	81131c0c <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
811364e8:	e0bffd17 	ldw	r2,-12(fp)
811364ec:	10800283 	ldbu	r2,10(r2)
811364f0:	10803fcc 	andi	r2,r2,255
811364f4:	103ff71e 	bne	r2,zero,811364d4 <__reset+0xfb1164d4>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
811364f8:	e0bffd17 	ldw	r2,-12(fp)
811364fc:	00c00fc4 	movi	r3,63
81136500:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
81136504:	e0bffd17 	ldw	r2,-12(fp)
81136508:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
8113650c:	e0bffd17 	ldw	r2,-12(fp)
81136510:	10800117 	ldw	r2,4(r2)
81136514:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
81136518:	d0e09c17 	ldw	r3,-32144(gp)
8113651c:	e0bff817 	ldw	r2,-32(fp)
81136520:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
81136524:	e0bff817 	ldw	r2,-32(fp)
81136528:	d0a09c15 	stw	r2,-32144(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113652c:	e0bffd17 	ldw	r2,-12(fp)
81136530:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
81136534:	d0e09f17 	ldw	r3,-32132(gp)
81136538:	e0bffd17 	ldw	r2,-12(fp)
8113653c:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
81136540:	e0bffd17 	ldw	r2,-12(fp)
81136544:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
81136548:	e0bffd17 	ldw	r2,-12(fp)
8113654c:	d0a09f15 	stw	r2,-32132(gp)
81136550:	e0bff617 	ldw	r2,-40(fp)
81136554:	e0bffa15 	stw	r2,-24(fp)
81136558:	e0bffa17 	ldw	r2,-24(fp)
8113655c:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81136560:	e0bff403 	ldbu	r2,-48(fp)
81136564:	10800058 	cmpnei	r2,r2,1
81136568:	1000011e 	bne	r2,zero,81136570 <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113656c:	11326c80 	call	811326c8 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
81136570:	e0bfff17 	ldw	r2,-4(fp)
81136574:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
81136578:	e03ff515 	stw	zero,-44(fp)
             break;
8113657c:	00000a06 	br	811365a8 <OSQDel+0x270>
81136580:	e0bff617 	ldw	r2,-40(fp)
81136584:	e0bffb15 	stw	r2,-20(fp)
81136588:	e0bffb17 	ldw	r2,-20(fp)
8113658c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
81136590:	e0bfff17 	ldw	r2,-4(fp)
81136594:	00c001c4 	movi	r3,7
81136598:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113659c:	e0bffd17 	ldw	r2,-12(fp)
811365a0:	e0bff515 	stw	r2,-44(fp)
             break;
811365a4:	0001883a 	nop
    }
    return (pevent_return);
811365a8:	e0bff517 	ldw	r2,-44(fp)
}
811365ac:	e037883a 	mov	sp,fp
811365b0:	dfc00117 	ldw	ra,4(sp)
811365b4:	df000017 	ldw	fp,0(sp)
811365b8:	dec00204 	addi	sp,sp,8
811365bc:	f800283a 	ret

811365c0 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
811365c0:	defffa04 	addi	sp,sp,-24
811365c4:	de00012e 	bgeu	sp,et,811365cc <OSQFlush+0xc>
811365c8:	003b68fa 	trap	3
811365cc:	df000515 	stw	fp,20(sp)
811365d0:	df000504 	addi	fp,sp,20
811365d4:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811365d8:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811365dc:	e0bfff17 	ldw	r2,-4(fp)
811365e0:	1000021e 	bne	r2,zero,811365ec <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
811365e4:	00800104 	movi	r2,4
811365e8:	00002106 	br	81136670 <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
811365ec:	e0bfff17 	ldw	r2,-4(fp)
811365f0:	10800003 	ldbu	r2,0(r2)
811365f4:	10803fcc 	andi	r2,r2,255
811365f8:	108000a0 	cmpeqi	r2,r2,2
811365fc:	1000021e 	bne	r2,zero,81136608 <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
81136600:	00800044 	movi	r2,1
81136604:	00001a06 	br	81136670 <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136608:	0005303a 	rdctl	r2,status
8113660c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136610:	e0fffd17 	ldw	r3,-12(fp)
81136614:	00bfff84 	movi	r2,-2
81136618:	1884703a 	and	r2,r3,r2
8113661c:	1001703a 	wrctl	status,r2
  
  return context;
81136620:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81136624:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
81136628:	e0bfff17 	ldw	r2,-4(fp)
8113662c:	10800117 	ldw	r2,4(r2)
81136630:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
81136634:	e0bffc17 	ldw	r2,-16(fp)
81136638:	10c00117 	ldw	r3,4(r2)
8113663c:	e0bffc17 	ldw	r2,-16(fp)
81136640:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
81136644:	e0bffc17 	ldw	r2,-16(fp)
81136648:	10c00117 	ldw	r3,4(r2)
8113664c:	e0bffc17 	ldw	r2,-16(fp)
81136650:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
81136654:	e0bffc17 	ldw	r2,-16(fp)
81136658:	1000058d 	sth	zero,22(r2)
8113665c:	e0bffb17 	ldw	r2,-20(fp)
81136660:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136664:	e0bffe17 	ldw	r2,-8(fp)
81136668:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113666c:	0005883a 	mov	r2,zero
}
81136670:	e037883a 	mov	sp,fp
81136674:	df000017 	ldw	fp,0(sp)
81136678:	dec00104 	addi	sp,sp,4
8113667c:	f800283a 	ret

81136680 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81136680:	defff304 	addi	sp,sp,-52
81136684:	de00012e 	bgeu	sp,et,8113668c <OSQPend+0xc>
81136688:	003b68fa 	trap	3
8113668c:	dfc00c15 	stw	ra,48(sp)
81136690:	df000b15 	stw	fp,44(sp)
81136694:	df000b04 	addi	fp,sp,44
81136698:	e13ffd15 	stw	r4,-12(fp)
8113669c:	2805883a 	mov	r2,r5
811366a0:	e1bfff15 	stw	r6,-4(fp)
811366a4:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811366a8:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811366ac:	e0bfff17 	ldw	r2,-4(fp)
811366b0:	1000021e 	bne	r2,zero,811366bc <OSQPend+0x3c>
        return ((void *)0);
811366b4:	0005883a 	mov	r2,zero
811366b8:	00009106 	br	81136900 <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
811366bc:	e0bffd17 	ldw	r2,-12(fp)
811366c0:	1000051e 	bne	r2,zero,811366d8 <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
811366c4:	e0bfff17 	ldw	r2,-4(fp)
811366c8:	00c00104 	movi	r3,4
811366cc:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
811366d0:	0005883a 	mov	r2,zero
811366d4:	00008a06 	br	81136900 <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
811366d8:	e0bffd17 	ldw	r2,-12(fp)
811366dc:	10800003 	ldbu	r2,0(r2)
811366e0:	10803fcc 	andi	r2,r2,255
811366e4:	108000a0 	cmpeqi	r2,r2,2
811366e8:	1000051e 	bne	r2,zero,81136700 <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
811366ec:	e0bfff17 	ldw	r2,-4(fp)
811366f0:	00c00044 	movi	r3,1
811366f4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
811366f8:	0005883a 	mov	r2,zero
811366fc:	00008006 	br	81136900 <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
81136700:	d0a0a003 	ldbu	r2,-32128(gp)
81136704:	10803fcc 	andi	r2,r2,255
81136708:	10000526 	beq	r2,zero,81136720 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
8113670c:	e0bfff17 	ldw	r2,-4(fp)
81136710:	00c00084 	movi	r3,2
81136714:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81136718:	0005883a 	mov	r2,zero
8113671c:	00007806 	br	81136900 <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
81136720:	d0a08e03 	ldbu	r2,-32200(gp)
81136724:	10803fcc 	andi	r2,r2,255
81136728:	10000526 	beq	r2,zero,81136740 <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
8113672c:	e0bfff17 	ldw	r2,-4(fp)
81136730:	00c00344 	movi	r3,13
81136734:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81136738:	0005883a 	mov	r2,zero
8113673c:	00007006 	br	81136900 <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136740:	0005303a 	rdctl	r2,status
81136744:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136748:	e0fffc17 	ldw	r3,-16(fp)
8113674c:	00bfff84 	movi	r2,-2
81136750:	1884703a 	and	r2,r3,r2
81136754:	1001703a 	wrctl	status,r2
  
  return context;
81136758:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113675c:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
81136760:	e0bffd17 	ldw	r2,-12(fp)
81136764:	10800117 	ldw	r2,4(r2)
81136768:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113676c:	e0bff817 	ldw	r2,-32(fp)
81136770:	1080058b 	ldhu	r2,22(r2)
81136774:	10bfffcc 	andi	r2,r2,65535
81136778:	10001e26 	beq	r2,zero,811367f4 <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113677c:	e0bff817 	ldw	r2,-32(fp)
81136780:	10800417 	ldw	r2,16(r2)
81136784:	11000104 	addi	r4,r2,4
81136788:	e0fff817 	ldw	r3,-32(fp)
8113678c:	19000415 	stw	r4,16(r3)
81136790:	10800017 	ldw	r2,0(r2)
81136794:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
81136798:	e0bff817 	ldw	r2,-32(fp)
8113679c:	1080058b 	ldhu	r2,22(r2)
811367a0:	10bfffc4 	addi	r2,r2,-1
811367a4:	1007883a 	mov	r3,r2
811367a8:	e0bff817 	ldw	r2,-32(fp)
811367ac:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
811367b0:	e0bff817 	ldw	r2,-32(fp)
811367b4:	10c00417 	ldw	r3,16(r2)
811367b8:	e0bff817 	ldw	r2,-32(fp)
811367bc:	10800217 	ldw	r2,8(r2)
811367c0:	1880041e 	bne	r3,r2,811367d4 <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
811367c4:	e0bff817 	ldw	r2,-32(fp)
811367c8:	10c00117 	ldw	r3,4(r2)
811367cc:	e0bff817 	ldw	r2,-32(fp)
811367d0:	10c00415 	stw	r3,16(r2)
811367d4:	e0bff617 	ldw	r2,-40(fp)
811367d8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811367dc:	e0bff717 	ldw	r2,-36(fp)
811367e0:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
811367e4:	e0bfff17 	ldw	r2,-4(fp)
811367e8:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
811367ec:	e0bff517 	ldw	r2,-44(fp)
811367f0:	00004306 	br	81136900 <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
811367f4:	d0a0a117 	ldw	r2,-32124(gp)
811367f8:	d0e0a117 	ldw	r3,-32124(gp)
811367fc:	18c00c03 	ldbu	r3,48(r3)
81136800:	18c00114 	ori	r3,r3,4
81136804:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81136808:	d0a0a117 	ldw	r2,-32124(gp)
8113680c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
81136810:	d0a0a117 	ldw	r2,-32124(gp)
81136814:	e0fffe0b 	ldhu	r3,-8(fp)
81136818:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
8113681c:	e13ffd17 	ldw	r4,-12(fp)
81136820:	1131dac0 	call	81131dac <OS_EventTaskWait>
81136824:	e0bff617 	ldw	r2,-40(fp)
81136828:	e0bffb15 	stw	r2,-20(fp)
8113682c:	e0bffb17 	ldw	r2,-20(fp)
81136830:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
81136834:	11326c80 	call	811326c8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136838:	0005303a 	rdctl	r2,status
8113683c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136840:	e0fff917 	ldw	r3,-28(fp)
81136844:	00bfff84 	movi	r2,-2
81136848:	1884703a 	and	r2,r3,r2
8113684c:	1001703a 	wrctl	status,r2
  
  return context;
81136850:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
81136854:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
81136858:	d0a0a117 	ldw	r2,-32124(gp)
8113685c:	10800c43 	ldbu	r2,49(r2)
81136860:	10803fcc 	andi	r2,r2,255
81136864:	10000326 	beq	r2,zero,81136874 <OSQPend+0x1f4>
81136868:	108000a0 	cmpeqi	r2,r2,2
8113686c:	1000071e 	bne	r2,zero,8113688c <OSQPend+0x20c>
81136870:	00000b06 	br	811368a0 <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
81136874:	d0a0a117 	ldw	r2,-32124(gp)
81136878:	10800917 	ldw	r2,36(r2)
8113687c:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
81136880:	e0bfff17 	ldw	r2,-4(fp)
81136884:	10000005 	stb	zero,0(r2)
             break;
81136888:	00000e06 	br	811368c4 <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
8113688c:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
81136890:	e0bfff17 	ldw	r2,-4(fp)
81136894:	00c00384 	movi	r3,14
81136898:	10c00005 	stb	r3,0(r2)
             break;
8113689c:	00000906 	br	811368c4 <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
811368a0:	d0a0a117 	ldw	r2,-32124(gp)
811368a4:	e17ffd17 	ldw	r5,-12(fp)
811368a8:	1009883a 	mov	r4,r2
811368ac:	113201c0 	call	8113201c <OS_EventTaskRemove>
             pmsg = (void *)0;
811368b0:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
811368b4:	e0bfff17 	ldw	r2,-4(fp)
811368b8:	00c00284 	movi	r3,10
811368bc:	10c00005 	stb	r3,0(r2)
             break;
811368c0:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
811368c4:	d0a0a117 	ldw	r2,-32124(gp)
811368c8:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
811368cc:	d0a0a117 	ldw	r2,-32124(gp)
811368d0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
811368d4:	d0a0a117 	ldw	r2,-32124(gp)
811368d8:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
811368dc:	d0a0a117 	ldw	r2,-32124(gp)
811368e0:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
811368e4:	d0a0a117 	ldw	r2,-32124(gp)
811368e8:	10000915 	stw	zero,36(r2)
811368ec:	e0bff617 	ldw	r2,-40(fp)
811368f0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811368f4:	e0bffa17 	ldw	r2,-24(fp)
811368f8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
811368fc:	e0bff517 	ldw	r2,-44(fp)
}
81136900:	e037883a 	mov	sp,fp
81136904:	dfc00117 	ldw	ra,4(sp)
81136908:	df000017 	ldw	fp,0(sp)
8113690c:	dec00204 	addi	sp,sp,8
81136910:	f800283a 	ret

81136914 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81136914:	defff604 	addi	sp,sp,-40
81136918:	de00012e 	bgeu	sp,et,81136920 <OSQPendAbort+0xc>
8113691c:	003b68fa 	trap	3
81136920:	dfc00915 	stw	ra,36(sp)
81136924:	df000815 	stw	fp,32(sp)
81136928:	df000804 	addi	fp,sp,32
8113692c:	e13ffd15 	stw	r4,-12(fp)
81136930:	2805883a 	mov	r2,r5
81136934:	e1bfff15 	stw	r6,-4(fp)
81136938:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113693c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81136940:	e0bfff17 	ldw	r2,-4(fp)
81136944:	1000021e 	bne	r2,zero,81136950 <OSQPendAbort+0x3c>
        return (0);
81136948:	0005883a 	mov	r2,zero
8113694c:	00004906 	br	81136a74 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81136950:	e0bffd17 	ldw	r2,-12(fp)
81136954:	1000051e 	bne	r2,zero,8113696c <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81136958:	e0bfff17 	ldw	r2,-4(fp)
8113695c:	00c00104 	movi	r3,4
81136960:	10c00005 	stb	r3,0(r2)
        return (0);
81136964:	0005883a 	mov	r2,zero
81136968:	00004206 	br	81136a74 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113696c:	e0bffd17 	ldw	r2,-12(fp)
81136970:	10800003 	ldbu	r2,0(r2)
81136974:	10803fcc 	andi	r2,r2,255
81136978:	108000a0 	cmpeqi	r2,r2,2
8113697c:	1000051e 	bne	r2,zero,81136994 <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81136980:	e0bfff17 	ldw	r2,-4(fp)
81136984:	00c00044 	movi	r3,1
81136988:	10c00005 	stb	r3,0(r2)
        return (0);
8113698c:	0005883a 	mov	r2,zero
81136990:	00003806 	br	81136a74 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136994:	0005303a 	rdctl	r2,status
81136998:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113699c:	e0fffc17 	ldw	r3,-16(fp)
811369a0:	00bfff84 	movi	r2,-2
811369a4:	1884703a 	and	r2,r3,r2
811369a8:	1001703a 	wrctl	status,r2
  
  return context;
811369ac:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811369b0:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
811369b4:	e0bffd17 	ldw	r2,-12(fp)
811369b8:	10800283 	ldbu	r2,10(r2)
811369bc:	10803fcc 	andi	r2,r2,255
811369c0:	10002526 	beq	r2,zero,81136a58 <OSQPendAbort+0x144>
        nbr_tasks = 0;
811369c4:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
811369c8:	e0bffe03 	ldbu	r2,-8(fp)
811369cc:	10800060 	cmpeqi	r2,r2,1
811369d0:	10000e26 	beq	r2,zero,81136a0c <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
811369d4:	00000806 	br	811369f8 <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
811369d8:	01c00084 	movi	r7,2
811369dc:	01800104 	movi	r6,4
811369e0:	000b883a 	mov	r5,zero
811369e4:	e13ffd17 	ldw	r4,-12(fp)
811369e8:	1131c0c0 	call	81131c0c <OS_EventTaskRdy>
                     nbr_tasks++;
811369ec:	e0bff803 	ldbu	r2,-32(fp)
811369f0:	10800044 	addi	r2,r2,1
811369f4:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
811369f8:	e0bffd17 	ldw	r2,-12(fp)
811369fc:	10800283 	ldbu	r2,10(r2)
81136a00:	10803fcc 	andi	r2,r2,255
81136a04:	103ff41e 	bne	r2,zero,811369d8 <__reset+0xfb1169d8>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
81136a08:	00000906 	br	81136a30 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
81136a0c:	01c00084 	movi	r7,2
81136a10:	01800104 	movi	r6,4
81136a14:	000b883a 	mov	r5,zero
81136a18:	e13ffd17 	ldw	r4,-12(fp)
81136a1c:	1131c0c0 	call	81131c0c <OS_EventTaskRdy>
                 nbr_tasks++;
81136a20:	e0bff803 	ldbu	r2,-32(fp)
81136a24:	10800044 	addi	r2,r2,1
81136a28:	e0bff805 	stb	r2,-32(fp)
                 break;
81136a2c:	0001883a 	nop
81136a30:	e0bff917 	ldw	r2,-28(fp)
81136a34:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136a38:	e0bffa17 	ldw	r2,-24(fp)
81136a3c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
81136a40:	11326c80 	call	811326c8 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
81136a44:	e0bfff17 	ldw	r2,-4(fp)
81136a48:	00c00384 	movi	r3,14
81136a4c:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
81136a50:	e0bff803 	ldbu	r2,-32(fp)
81136a54:	00000706 	br	81136a74 <OSQPendAbort+0x160>
81136a58:	e0bff917 	ldw	r2,-28(fp)
81136a5c:	e0bffb15 	stw	r2,-20(fp)
81136a60:	e0bffb17 	ldw	r2,-20(fp)
81136a64:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81136a68:	e0bfff17 	ldw	r2,-4(fp)
81136a6c:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
81136a70:	0005883a 	mov	r2,zero
}
81136a74:	e037883a 	mov	sp,fp
81136a78:	dfc00117 	ldw	ra,4(sp)
81136a7c:	df000017 	ldw	fp,0(sp)
81136a80:	dec00204 	addi	sp,sp,8
81136a84:	f800283a 	ret

81136a88 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
81136a88:	defff604 	addi	sp,sp,-40
81136a8c:	de00012e 	bgeu	sp,et,81136a94 <OSQPost+0xc>
81136a90:	003b68fa 	trap	3
81136a94:	dfc00915 	stw	ra,36(sp)
81136a98:	df000815 	stw	fp,32(sp)
81136a9c:	df000804 	addi	fp,sp,32
81136aa0:	e13ffe15 	stw	r4,-8(fp)
81136aa4:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81136aa8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
81136aac:	e0bffe17 	ldw	r2,-8(fp)
81136ab0:	1000021e 	bne	r2,zero,81136abc <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
81136ab4:	00800104 	movi	r2,4
81136ab8:	00004a06 	br	81136be4 <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
81136abc:	e0bffe17 	ldw	r2,-8(fp)
81136ac0:	10800003 	ldbu	r2,0(r2)
81136ac4:	10803fcc 	andi	r2,r2,255
81136ac8:	108000a0 	cmpeqi	r2,r2,2
81136acc:	1000021e 	bne	r2,zero,81136ad8 <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
81136ad0:	00800044 	movi	r2,1
81136ad4:	00004306 	br	81136be4 <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136ad8:	0005303a 	rdctl	r2,status
81136adc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136ae0:	e0fffd17 	ldw	r3,-12(fp)
81136ae4:	00bfff84 	movi	r2,-2
81136ae8:	1884703a 	and	r2,r3,r2
81136aec:	1001703a 	wrctl	status,r2
  
  return context;
81136af0:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81136af4:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
81136af8:	e0bffe17 	ldw	r2,-8(fp)
81136afc:	10800283 	ldbu	r2,10(r2)
81136b00:	10803fcc 	andi	r2,r2,255
81136b04:	10000c26 	beq	r2,zero,81136b38 <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81136b08:	000f883a 	mov	r7,zero
81136b0c:	01800104 	movi	r6,4
81136b10:	e17fff17 	ldw	r5,-4(fp)
81136b14:	e13ffe17 	ldw	r4,-8(fp)
81136b18:	1131c0c0 	call	81131c0c <OS_EventTaskRdy>
81136b1c:	e0bff817 	ldw	r2,-32(fp)
81136b20:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136b24:	e0bff917 	ldw	r2,-28(fp)
81136b28:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
81136b2c:	11326c80 	call	811326c8 <OS_Sched>
        return (OS_ERR_NONE);
81136b30:	0005883a 	mov	r2,zero
81136b34:	00002b06 	br	81136be4 <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
81136b38:	e0bffe17 	ldw	r2,-8(fp)
81136b3c:	10800117 	ldw	r2,4(r2)
81136b40:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
81136b44:	e0bffb17 	ldw	r2,-20(fp)
81136b48:	10c0058b 	ldhu	r3,22(r2)
81136b4c:	e0bffb17 	ldw	r2,-20(fp)
81136b50:	1080050b 	ldhu	r2,20(r2)
81136b54:	18ffffcc 	andi	r3,r3,65535
81136b58:	10bfffcc 	andi	r2,r2,65535
81136b5c:	18800636 	bltu	r3,r2,81136b78 <OSQPost+0xf0>
81136b60:	e0bff817 	ldw	r2,-32(fp)
81136b64:	e0bffa15 	stw	r2,-24(fp)
81136b68:	e0bffa17 	ldw	r2,-24(fp)
81136b6c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81136b70:	00800784 	movi	r2,30
81136b74:	00001b06 	br	81136be4 <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
81136b78:	e0bffb17 	ldw	r2,-20(fp)
81136b7c:	10800317 	ldw	r2,12(r2)
81136b80:	11000104 	addi	r4,r2,4
81136b84:	e0fffb17 	ldw	r3,-20(fp)
81136b88:	19000315 	stw	r4,12(r3)
81136b8c:	e0ffff17 	ldw	r3,-4(fp)
81136b90:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
81136b94:	e0bffb17 	ldw	r2,-20(fp)
81136b98:	1080058b 	ldhu	r2,22(r2)
81136b9c:	10800044 	addi	r2,r2,1
81136ba0:	1007883a 	mov	r3,r2
81136ba4:	e0bffb17 	ldw	r2,-20(fp)
81136ba8:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
81136bac:	e0bffb17 	ldw	r2,-20(fp)
81136bb0:	10c00317 	ldw	r3,12(r2)
81136bb4:	e0bffb17 	ldw	r2,-20(fp)
81136bb8:	10800217 	ldw	r2,8(r2)
81136bbc:	1880041e 	bne	r3,r2,81136bd0 <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
81136bc0:	e0bffb17 	ldw	r2,-20(fp)
81136bc4:	10c00117 	ldw	r3,4(r2)
81136bc8:	e0bffb17 	ldw	r2,-20(fp)
81136bcc:	10c00315 	stw	r3,12(r2)
81136bd0:	e0bff817 	ldw	r2,-32(fp)
81136bd4:	e0bffc15 	stw	r2,-16(fp)
81136bd8:	e0bffc17 	ldw	r2,-16(fp)
81136bdc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81136be0:	0005883a 	mov	r2,zero
}
81136be4:	e037883a 	mov	sp,fp
81136be8:	dfc00117 	ldw	ra,4(sp)
81136bec:	df000017 	ldw	fp,0(sp)
81136bf0:	dec00204 	addi	sp,sp,8
81136bf4:	f800283a 	ret

81136bf8 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
81136bf8:	defff604 	addi	sp,sp,-40
81136bfc:	de00012e 	bgeu	sp,et,81136c04 <OSQPostFront+0xc>
81136c00:	003b68fa 	trap	3
81136c04:	dfc00915 	stw	ra,36(sp)
81136c08:	df000815 	stw	fp,32(sp)
81136c0c:	df000804 	addi	fp,sp,32
81136c10:	e13ffe15 	stw	r4,-8(fp)
81136c14:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81136c18:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81136c1c:	e0bffe17 	ldw	r2,-8(fp)
81136c20:	1000021e 	bne	r2,zero,81136c2c <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
81136c24:	00800104 	movi	r2,4
81136c28:	00004c06 	br	81136d5c <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
81136c2c:	e0bffe17 	ldw	r2,-8(fp)
81136c30:	10800003 	ldbu	r2,0(r2)
81136c34:	10803fcc 	andi	r2,r2,255
81136c38:	108000a0 	cmpeqi	r2,r2,2
81136c3c:	1000021e 	bne	r2,zero,81136c48 <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
81136c40:	00800044 	movi	r2,1
81136c44:	00004506 	br	81136d5c <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136c48:	0005303a 	rdctl	r2,status
81136c4c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136c50:	e0fffd17 	ldw	r3,-12(fp)
81136c54:	00bfff84 	movi	r2,-2
81136c58:	1884703a 	and	r2,r3,r2
81136c5c:	1001703a 	wrctl	status,r2
  
  return context;
81136c60:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81136c64:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
81136c68:	e0bffe17 	ldw	r2,-8(fp)
81136c6c:	10800283 	ldbu	r2,10(r2)
81136c70:	10803fcc 	andi	r2,r2,255
81136c74:	10000c26 	beq	r2,zero,81136ca8 <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81136c78:	000f883a 	mov	r7,zero
81136c7c:	01800104 	movi	r6,4
81136c80:	e17fff17 	ldw	r5,-4(fp)
81136c84:	e13ffe17 	ldw	r4,-8(fp)
81136c88:	1131c0c0 	call	81131c0c <OS_EventTaskRdy>
81136c8c:	e0bff817 	ldw	r2,-32(fp)
81136c90:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136c94:	e0bff917 	ldw	r2,-28(fp)
81136c98:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
81136c9c:	11326c80 	call	811326c8 <OS_Sched>
        return (OS_ERR_NONE);
81136ca0:	0005883a 	mov	r2,zero
81136ca4:	00002d06 	br	81136d5c <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
81136ca8:	e0bffe17 	ldw	r2,-8(fp)
81136cac:	10800117 	ldw	r2,4(r2)
81136cb0:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
81136cb4:	e0bffb17 	ldw	r2,-20(fp)
81136cb8:	10c0058b 	ldhu	r3,22(r2)
81136cbc:	e0bffb17 	ldw	r2,-20(fp)
81136cc0:	1080050b 	ldhu	r2,20(r2)
81136cc4:	18ffffcc 	andi	r3,r3,65535
81136cc8:	10bfffcc 	andi	r2,r2,65535
81136ccc:	18800636 	bltu	r3,r2,81136ce8 <OSQPostFront+0xf0>
81136cd0:	e0bff817 	ldw	r2,-32(fp)
81136cd4:	e0bffa15 	stw	r2,-24(fp)
81136cd8:	e0bffa17 	ldw	r2,-24(fp)
81136cdc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81136ce0:	00800784 	movi	r2,30
81136ce4:	00001d06 	br	81136d5c <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
81136ce8:	e0bffb17 	ldw	r2,-20(fp)
81136cec:	10c00417 	ldw	r3,16(r2)
81136cf0:	e0bffb17 	ldw	r2,-20(fp)
81136cf4:	10800117 	ldw	r2,4(r2)
81136cf8:	1880041e 	bne	r3,r2,81136d0c <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
81136cfc:	e0bffb17 	ldw	r2,-20(fp)
81136d00:	10c00217 	ldw	r3,8(r2)
81136d04:	e0bffb17 	ldw	r2,-20(fp)
81136d08:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
81136d0c:	e0bffb17 	ldw	r2,-20(fp)
81136d10:	10800417 	ldw	r2,16(r2)
81136d14:	10ffff04 	addi	r3,r2,-4
81136d18:	e0bffb17 	ldw	r2,-20(fp)
81136d1c:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
81136d20:	e0bffb17 	ldw	r2,-20(fp)
81136d24:	10800417 	ldw	r2,16(r2)
81136d28:	e0ffff17 	ldw	r3,-4(fp)
81136d2c:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
81136d30:	e0bffb17 	ldw	r2,-20(fp)
81136d34:	1080058b 	ldhu	r2,22(r2)
81136d38:	10800044 	addi	r2,r2,1
81136d3c:	1007883a 	mov	r3,r2
81136d40:	e0bffb17 	ldw	r2,-20(fp)
81136d44:	10c0058d 	sth	r3,22(r2)
81136d48:	e0bff817 	ldw	r2,-32(fp)
81136d4c:	e0bffc15 	stw	r2,-16(fp)
81136d50:	e0bffc17 	ldw	r2,-16(fp)
81136d54:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81136d58:	0005883a 	mov	r2,zero
}
81136d5c:	e037883a 	mov	sp,fp
81136d60:	dfc00117 	ldw	ra,4(sp)
81136d64:	df000017 	ldw	fp,0(sp)
81136d68:	dec00204 	addi	sp,sp,8
81136d6c:	f800283a 	ret

81136d70 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
81136d70:	defff504 	addi	sp,sp,-44
81136d74:	de00012e 	bgeu	sp,et,81136d7c <OSQPostOpt+0xc>
81136d78:	003b68fa 	trap	3
81136d7c:	dfc00a15 	stw	ra,40(sp)
81136d80:	df000915 	stw	fp,36(sp)
81136d84:	df000904 	addi	fp,sp,36
81136d88:	e13ffd15 	stw	r4,-12(fp)
81136d8c:	e17ffe15 	stw	r5,-8(fp)
81136d90:	3005883a 	mov	r2,r6
81136d94:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81136d98:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81136d9c:	e0bffd17 	ldw	r2,-12(fp)
81136da0:	1000021e 	bne	r2,zero,81136dac <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
81136da4:	00800104 	movi	r2,4
81136da8:	00007106 	br	81136f70 <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
81136dac:	e0bffd17 	ldw	r2,-12(fp)
81136db0:	10800003 	ldbu	r2,0(r2)
81136db4:	10803fcc 	andi	r2,r2,255
81136db8:	108000a0 	cmpeqi	r2,r2,2
81136dbc:	1000021e 	bne	r2,zero,81136dc8 <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
81136dc0:	00800044 	movi	r2,1
81136dc4:	00006a06 	br	81136f70 <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136dc8:	0005303a 	rdctl	r2,status
81136dcc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136dd0:	e0fffc17 	ldw	r3,-16(fp)
81136dd4:	00bfff84 	movi	r2,-2
81136dd8:	1884703a 	and	r2,r3,r2
81136ddc:	1001703a 	wrctl	status,r2
  
  return context;
81136de0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81136de4:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
81136de8:	e0bffd17 	ldw	r2,-12(fp)
81136dec:	10800283 	ldbu	r2,10(r2)
81136df0:	10803fcc 	andi	r2,r2,255
81136df4:	10001d26 	beq	r2,zero,81136e6c <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
81136df8:	e0bfff03 	ldbu	r2,-4(fp)
81136dfc:	1080004c 	andi	r2,r2,1
81136e00:	10000b26 	beq	r2,zero,81136e30 <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
81136e04:	00000506 	br	81136e1c <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81136e08:	000f883a 	mov	r7,zero
81136e0c:	01800104 	movi	r6,4
81136e10:	e17ffe17 	ldw	r5,-8(fp)
81136e14:	e13ffd17 	ldw	r4,-12(fp)
81136e18:	1131c0c0 	call	81131c0c <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
81136e1c:	e0bffd17 	ldw	r2,-12(fp)
81136e20:	10800283 	ldbu	r2,10(r2)
81136e24:	10803fcc 	andi	r2,r2,255
81136e28:	103ff71e 	bne	r2,zero,81136e08 <__reset+0xfb116e08>
81136e2c:	00000506 	br	81136e44 <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
81136e30:	000f883a 	mov	r7,zero
81136e34:	01800104 	movi	r6,4
81136e38:	e17ffe17 	ldw	r5,-8(fp)
81136e3c:	e13ffd17 	ldw	r4,-12(fp)
81136e40:	1131c0c0 	call	81131c0c <OS_EventTaskRdy>
81136e44:	e0bff717 	ldw	r2,-36(fp)
81136e48:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136e4c:	e0bff817 	ldw	r2,-32(fp)
81136e50:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
81136e54:	e0bfff03 	ldbu	r2,-4(fp)
81136e58:	1080010c 	andi	r2,r2,4
81136e5c:	1000011e 	bne	r2,zero,81136e64 <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
81136e60:	11326c80 	call	811326c8 <OS_Sched>
        }
        return (OS_ERR_NONE);
81136e64:	0005883a 	mov	r2,zero
81136e68:	00004106 	br	81136f70 <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
81136e6c:	e0bffd17 	ldw	r2,-12(fp)
81136e70:	10800117 	ldw	r2,4(r2)
81136e74:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
81136e78:	e0bffa17 	ldw	r2,-24(fp)
81136e7c:	10c0058b 	ldhu	r3,22(r2)
81136e80:	e0bffa17 	ldw	r2,-24(fp)
81136e84:	1080050b 	ldhu	r2,20(r2)
81136e88:	18ffffcc 	andi	r3,r3,65535
81136e8c:	10bfffcc 	andi	r2,r2,65535
81136e90:	18800636 	bltu	r3,r2,81136eac <OSQPostOpt+0x13c>
81136e94:	e0bff717 	ldw	r2,-36(fp)
81136e98:	e0bff915 	stw	r2,-28(fp)
81136e9c:	e0bff917 	ldw	r2,-28(fp)
81136ea0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
81136ea4:	00800784 	movi	r2,30
81136ea8:	00003106 	br	81136f70 <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
81136eac:	e0bfff03 	ldbu	r2,-4(fp)
81136eb0:	1080008c 	andi	r2,r2,2
81136eb4:	10001326 	beq	r2,zero,81136f04 <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
81136eb8:	e0bffa17 	ldw	r2,-24(fp)
81136ebc:	10c00417 	ldw	r3,16(r2)
81136ec0:	e0bffa17 	ldw	r2,-24(fp)
81136ec4:	10800117 	ldw	r2,4(r2)
81136ec8:	1880041e 	bne	r3,r2,81136edc <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
81136ecc:	e0bffa17 	ldw	r2,-24(fp)
81136ed0:	10c00217 	ldw	r3,8(r2)
81136ed4:	e0bffa17 	ldw	r2,-24(fp)
81136ed8:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
81136edc:	e0bffa17 	ldw	r2,-24(fp)
81136ee0:	10800417 	ldw	r2,16(r2)
81136ee4:	10ffff04 	addi	r3,r2,-4
81136ee8:	e0bffa17 	ldw	r2,-24(fp)
81136eec:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
81136ef0:	e0bffa17 	ldw	r2,-24(fp)
81136ef4:	10800417 	ldw	r2,16(r2)
81136ef8:	e0fffe17 	ldw	r3,-8(fp)
81136efc:	10c00015 	stw	r3,0(r2)
81136f00:	00001006 	br	81136f44 <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
81136f04:	e0bffa17 	ldw	r2,-24(fp)
81136f08:	10800317 	ldw	r2,12(r2)
81136f0c:	11000104 	addi	r4,r2,4
81136f10:	e0fffa17 	ldw	r3,-24(fp)
81136f14:	19000315 	stw	r4,12(r3)
81136f18:	e0fffe17 	ldw	r3,-8(fp)
81136f1c:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
81136f20:	e0bffa17 	ldw	r2,-24(fp)
81136f24:	10c00317 	ldw	r3,12(r2)
81136f28:	e0bffa17 	ldw	r2,-24(fp)
81136f2c:	10800217 	ldw	r2,8(r2)
81136f30:	1880041e 	bne	r3,r2,81136f44 <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
81136f34:	e0bffa17 	ldw	r2,-24(fp)
81136f38:	10c00117 	ldw	r3,4(r2)
81136f3c:	e0bffa17 	ldw	r2,-24(fp)
81136f40:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
81136f44:	e0bffa17 	ldw	r2,-24(fp)
81136f48:	1080058b 	ldhu	r2,22(r2)
81136f4c:	10800044 	addi	r2,r2,1
81136f50:	1007883a 	mov	r3,r2
81136f54:	e0bffa17 	ldw	r2,-24(fp)
81136f58:	10c0058d 	sth	r3,22(r2)
81136f5c:	e0bff717 	ldw	r2,-36(fp)
81136f60:	e0bffb15 	stw	r2,-20(fp)
81136f64:	e0bffb17 	ldw	r2,-20(fp)
81136f68:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81136f6c:	0005883a 	mov	r2,zero
}
81136f70:	e037883a 	mov	sp,fp
81136f74:	dfc00117 	ldw	ra,4(sp)
81136f78:	df000017 	ldw	fp,0(sp)
81136f7c:	dec00204 	addi	sp,sp,8
81136f80:	f800283a 	ret

81136f84 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
81136f84:	defff604 	addi	sp,sp,-40
81136f88:	de00012e 	bgeu	sp,et,81136f90 <OSQQuery+0xc>
81136f8c:	003b68fa 	trap	3
81136f90:	df000915 	stw	fp,36(sp)
81136f94:	df000904 	addi	fp,sp,36
81136f98:	e13ffe15 	stw	r4,-8(fp)
81136f9c:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81136fa0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
81136fa4:	e0bffe17 	ldw	r2,-8(fp)
81136fa8:	1000021e 	bne	r2,zero,81136fb4 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
81136fac:	00800104 	movi	r2,4
81136fb0:	00004906 	br	811370d8 <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
81136fb4:	e0bfff17 	ldw	r2,-4(fp)
81136fb8:	1000021e 	bne	r2,zero,81136fc4 <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
81136fbc:	00800244 	movi	r2,9
81136fc0:	00004506 	br	811370d8 <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
81136fc4:	e0bffe17 	ldw	r2,-8(fp)
81136fc8:	10800003 	ldbu	r2,0(r2)
81136fcc:	10803fcc 	andi	r2,r2,255
81136fd0:	108000a0 	cmpeqi	r2,r2,2
81136fd4:	1000021e 	bne	r2,zero,81136fe0 <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
81136fd8:	00800044 	movi	r2,1
81136fdc:	00003e06 	br	811370d8 <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136fe0:	0005303a 	rdctl	r2,status
81136fe4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136fe8:	e0fffd17 	ldw	r3,-12(fp)
81136fec:	00bfff84 	movi	r2,-2
81136ff0:	1884703a 	and	r2,r3,r2
81136ff4:	1001703a 	wrctl	status,r2
  
  return context;
81136ff8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81136ffc:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
81137000:	e0bffe17 	ldw	r2,-8(fp)
81137004:	10c00283 	ldbu	r3,10(r2)
81137008:	e0bfff17 	ldw	r2,-4(fp)
8113700c:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
81137010:	e0bffe17 	ldw	r2,-8(fp)
81137014:	108002c4 	addi	r2,r2,11
81137018:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
8113701c:	e0bfff17 	ldw	r2,-4(fp)
81137020:	10800204 	addi	r2,r2,8
81137024:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81137028:	e03ff705 	stb	zero,-36(fp)
8113702c:	00000b06 	br	8113705c <OSQQuery+0xd8>
        *pdest++ = *psrc++;
81137030:	e0bff917 	ldw	r2,-28(fp)
81137034:	10c00044 	addi	r3,r2,1
81137038:	e0fff915 	stw	r3,-28(fp)
8113703c:	e0fff817 	ldw	r3,-32(fp)
81137040:	19000044 	addi	r4,r3,1
81137044:	e13ff815 	stw	r4,-32(fp)
81137048:	18c00003 	ldbu	r3,0(r3)
8113704c:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81137050:	e0bff703 	ldbu	r2,-36(fp)
81137054:	10800044 	addi	r2,r2,1
81137058:	e0bff705 	stb	r2,-36(fp)
8113705c:	e0bff703 	ldbu	r2,-36(fp)
81137060:	108001b0 	cmpltui	r2,r2,6
81137064:	103ff21e 	bne	r2,zero,81137030 <__reset+0xfb117030>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
81137068:	e0bffe17 	ldw	r2,-8(fp)
8113706c:	10800117 	ldw	r2,4(r2)
81137070:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
81137074:	e0bffc17 	ldw	r2,-16(fp)
81137078:	1080058b 	ldhu	r2,22(r2)
8113707c:	10bfffcc 	andi	r2,r2,65535
81137080:	10000626 	beq	r2,zero,8113709c <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
81137084:	e0bffc17 	ldw	r2,-16(fp)
81137088:	10800417 	ldw	r2,16(r2)
8113708c:	10c00017 	ldw	r3,0(r2)
81137090:	e0bfff17 	ldw	r2,-4(fp)
81137094:	10c00015 	stw	r3,0(r2)
81137098:	00000206 	br	811370a4 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
8113709c:	e0bfff17 	ldw	r2,-4(fp)
811370a0:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
811370a4:	e0bffc17 	ldw	r2,-16(fp)
811370a8:	10c0058b 	ldhu	r3,22(r2)
811370ac:	e0bfff17 	ldw	r2,-4(fp)
811370b0:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
811370b4:	e0bffc17 	ldw	r2,-16(fp)
811370b8:	10c0050b 	ldhu	r3,20(r2)
811370bc:	e0bfff17 	ldw	r2,-4(fp)
811370c0:	10c0018d 	sth	r3,6(r2)
811370c4:	e0bffa17 	ldw	r2,-24(fp)
811370c8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811370cc:	e0bffb17 	ldw	r2,-20(fp)
811370d0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
811370d4:	0005883a 	mov	r2,zero
}
811370d8:	e037883a 	mov	sp,fp
811370dc:	df000017 	ldw	fp,0(sp)
811370e0:	dec00104 	addi	sp,sp,4
811370e4:	f800283a 	ret

811370e8 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
811370e8:	defffb04 	addi	sp,sp,-20
811370ec:	de00012e 	bgeu	sp,et,811370f4 <OS_QInit+0xc>
811370f0:	003b68fa 	trap	3
811370f4:	dfc00415 	stw	ra,16(sp)
811370f8:	df000315 	stw	fp,12(sp)
811370fc:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
81137100:	0140c004 	movi	r5,768
81137104:	012045b4 	movhi	r4,33046
81137108:	21366a04 	addi	r4,r4,-9816
8113710c:	11325fc0 	call	811325fc <OS_MemClr>
    pq1 = &OSQTbl[0];
81137110:	00a045b4 	movhi	r2,33046
81137114:	10b66a04 	addi	r2,r2,-9816
81137118:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
8113711c:	00a045b4 	movhi	r2,33046
81137120:	10b67004 	addi	r2,r2,-9792
81137124:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
81137128:	e03ffd0d 	sth	zero,-12(fp)
8113712c:	00000c06 	br	81137160 <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
81137130:	e0bffe17 	ldw	r2,-8(fp)
81137134:	e0ffff17 	ldw	r3,-4(fp)
81137138:	10c00015 	stw	r3,0(r2)
        pq1++;
8113713c:	e0bffe17 	ldw	r2,-8(fp)
81137140:	10800604 	addi	r2,r2,24
81137144:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
81137148:	e0bfff17 	ldw	r2,-4(fp)
8113714c:	10800604 	addi	r2,r2,24
81137150:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
81137154:	e0bffd0b 	ldhu	r2,-12(fp)
81137158:	10800044 	addi	r2,r2,1
8113715c:	e0bffd0d 	sth	r2,-12(fp)
81137160:	e0bffd0b 	ldhu	r2,-12(fp)
81137164:	108007f0 	cmpltui	r2,r2,31
81137168:	103ff11e 	bne	r2,zero,81137130 <__reset+0xfb117130>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
8113716c:	e0bffe17 	ldw	r2,-8(fp)
81137170:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
81137174:	00a045b4 	movhi	r2,33046
81137178:	10b66a04 	addi	r2,r2,-9816
8113717c:	d0a09c15 	stw	r2,-32144(gp)
#endif
}
81137180:	0001883a 	nop
81137184:	e037883a 	mov	sp,fp
81137188:	dfc00117 	ldw	ra,4(sp)
8113718c:	df000017 	ldw	fp,0(sp)
81137190:	dec00204 	addi	sp,sp,8
81137194:	f800283a 	ret

81137198 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
81137198:	defffa04 	addi	sp,sp,-24
8113719c:	de00012e 	bgeu	sp,et,811371a4 <OSSemAccept+0xc>
811371a0:	003b68fa 	trap	3
811371a4:	df000515 	stw	fp,20(sp)
811371a8:	df000504 	addi	fp,sp,20
811371ac:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811371b0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811371b4:	e0bfff17 	ldw	r2,-4(fp)
811371b8:	1000021e 	bne	r2,zero,811371c4 <OSSemAccept+0x2c>
        return (0);
811371bc:	0005883a 	mov	r2,zero
811371c0:	00001f06 	br	81137240 <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811371c4:	e0bfff17 	ldw	r2,-4(fp)
811371c8:	10800003 	ldbu	r2,0(r2)
811371cc:	10803fcc 	andi	r2,r2,255
811371d0:	108000e0 	cmpeqi	r2,r2,3
811371d4:	1000021e 	bne	r2,zero,811371e0 <OSSemAccept+0x48>
        return (0);
811371d8:	0005883a 	mov	r2,zero
811371dc:	00001806 	br	81137240 <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811371e0:	0005303a 	rdctl	r2,status
811371e4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811371e8:	e0fffe17 	ldw	r3,-8(fp)
811371ec:	00bfff84 	movi	r2,-2
811371f0:	1884703a 	and	r2,r3,r2
811371f4:	1001703a 	wrctl	status,r2
  
  return context;
811371f8:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
811371fc:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
81137200:	e0bfff17 	ldw	r2,-4(fp)
81137204:	1080020b 	ldhu	r2,8(r2)
81137208:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
8113720c:	e0bffd0b 	ldhu	r2,-12(fp)
81137210:	10000626 	beq	r2,zero,8113722c <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
81137214:	e0bfff17 	ldw	r2,-4(fp)
81137218:	1080020b 	ldhu	r2,8(r2)
8113721c:	10bfffc4 	addi	r2,r2,-1
81137220:	1007883a 	mov	r3,r2
81137224:	e0bfff17 	ldw	r2,-4(fp)
81137228:	10c0020d 	sth	r3,8(r2)
8113722c:	e0bffb17 	ldw	r2,-20(fp)
81137230:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137234:	e0bffc17 	ldw	r2,-16(fp)
81137238:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
8113723c:	e0bffd0b 	ldhu	r2,-12(fp)
}
81137240:	e037883a 	mov	sp,fp
81137244:	df000017 	ldw	fp,0(sp)
81137248:	dec00104 	addi	sp,sp,4
8113724c:	f800283a 	ret

81137250 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
81137250:	defff904 	addi	sp,sp,-28
81137254:	de00012e 	bgeu	sp,et,8113725c <OSSemCreate+0xc>
81137258:	003b68fa 	trap	3
8113725c:	dfc00615 	stw	ra,24(sp)
81137260:	df000515 	stw	fp,20(sp)
81137264:	df000504 	addi	fp,sp,20
81137268:	2005883a 	mov	r2,r4
8113726c:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81137270:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81137274:	d0a0a003 	ldbu	r2,-32128(gp)
81137278:	10803fcc 	andi	r2,r2,255
8113727c:	10000226 	beq	r2,zero,81137288 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
81137280:	0005883a 	mov	r2,zero
81137284:	00002506 	br	8113731c <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137288:	0005303a 	rdctl	r2,status
8113728c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137290:	e0fffe17 	ldw	r3,-8(fp)
81137294:	00bfff84 	movi	r2,-2
81137298:	1884703a 	and	r2,r3,r2
8113729c:	1001703a 	wrctl	status,r2
  
  return context;
811372a0:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
811372a4:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
811372a8:	d0a09f17 	ldw	r2,-32132(gp)
811372ac:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
811372b0:	d0a09f17 	ldw	r2,-32132(gp)
811372b4:	10000326 	beq	r2,zero,811372c4 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
811372b8:	d0a09f17 	ldw	r2,-32132(gp)
811372bc:	10800117 	ldw	r2,4(r2)
811372c0:	d0a09f15 	stw	r2,-32132(gp)
811372c4:	e0bffb17 	ldw	r2,-20(fp)
811372c8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811372cc:	e0bffc17 	ldw	r2,-16(fp)
811372d0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
811372d4:	e0bffd17 	ldw	r2,-12(fp)
811372d8:	10000f26 	beq	r2,zero,81137318 <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
811372dc:	e0bffd17 	ldw	r2,-12(fp)
811372e0:	00c000c4 	movi	r3,3
811372e4:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
811372e8:	e0bffd17 	ldw	r2,-12(fp)
811372ec:	e0ffff0b 	ldhu	r3,-4(fp)
811372f0:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
811372f4:	e0bffd17 	ldw	r2,-12(fp)
811372f8:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
811372fc:	e0bffd17 	ldw	r2,-12(fp)
81137300:	00c00fc4 	movi	r3,63
81137304:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
81137308:	e0bffd17 	ldw	r2,-12(fp)
8113730c:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
81137310:	e13ffd17 	ldw	r4,-12(fp)
81137314:	11321e40 	call	811321e4 <OS_EventWaitListInit>
    }
    return (pevent);
81137318:	e0bffd17 	ldw	r2,-12(fp)
}
8113731c:	e037883a 	mov	sp,fp
81137320:	dfc00117 	ldw	ra,4(sp)
81137324:	df000017 	ldw	fp,0(sp)
81137328:	dec00204 	addi	sp,sp,8
8113732c:	f800283a 	ret

81137330 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81137330:	defff304 	addi	sp,sp,-52
81137334:	de00012e 	bgeu	sp,et,8113733c <OSSemDel+0xc>
81137338:	003b68fa 	trap	3
8113733c:	dfc00c15 	stw	ra,48(sp)
81137340:	df000b15 	stw	fp,44(sp)
81137344:	df000b04 	addi	fp,sp,44
81137348:	e13ffd15 	stw	r4,-12(fp)
8113734c:	2805883a 	mov	r2,r5
81137350:	e1bfff15 	stw	r6,-4(fp)
81137354:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81137358:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113735c:	e0bfff17 	ldw	r2,-4(fp)
81137360:	1000021e 	bne	r2,zero,8113736c <OSSemDel+0x3c>
        return (pevent);
81137364:	e0bffd17 	ldw	r2,-12(fp)
81137368:	00007e06 	br	81137564 <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113736c:	e0bffd17 	ldw	r2,-12(fp)
81137370:	1000051e 	bne	r2,zero,81137388 <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81137374:	e0bfff17 	ldw	r2,-4(fp)
81137378:	00c00104 	movi	r3,4
8113737c:	10c00005 	stb	r3,0(r2)
        return (pevent);
81137380:	e0bffd17 	ldw	r2,-12(fp)
81137384:	00007706 	br	81137564 <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
81137388:	e0bffd17 	ldw	r2,-12(fp)
8113738c:	10800003 	ldbu	r2,0(r2)
81137390:	10803fcc 	andi	r2,r2,255
81137394:	108000e0 	cmpeqi	r2,r2,3
81137398:	1000051e 	bne	r2,zero,811373b0 <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113739c:	e0bfff17 	ldw	r2,-4(fp)
811373a0:	00c00044 	movi	r3,1
811373a4:	10c00005 	stb	r3,0(r2)
        return (pevent);
811373a8:	e0bffd17 	ldw	r2,-12(fp)
811373ac:	00006d06 	br	81137564 <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811373b0:	d0a0a003 	ldbu	r2,-32128(gp)
811373b4:	10803fcc 	andi	r2,r2,255
811373b8:	10000526 	beq	r2,zero,811373d0 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
811373bc:	e0bfff17 	ldw	r2,-4(fp)
811373c0:	00c003c4 	movi	r3,15
811373c4:	10c00005 	stb	r3,0(r2)
        return (pevent);
811373c8:	e0bffd17 	ldw	r2,-12(fp)
811373cc:	00006506 	br	81137564 <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811373d0:	0005303a 	rdctl	r2,status
811373d4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811373d8:	e0fffc17 	ldw	r3,-16(fp)
811373dc:	00bfff84 	movi	r2,-2
811373e0:	1884703a 	and	r2,r3,r2
811373e4:	1001703a 	wrctl	status,r2
  
  return context;
811373e8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811373ec:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
811373f0:	e0bffd17 	ldw	r2,-12(fp)
811373f4:	10800283 	ldbu	r2,10(r2)
811373f8:	10803fcc 	andi	r2,r2,255
811373fc:	10000326 	beq	r2,zero,8113740c <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81137400:	00800044 	movi	r2,1
81137404:	e0bff505 	stb	r2,-44(fp)
81137408:	00000106 	br	81137410 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113740c:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
81137410:	e0bffe03 	ldbu	r2,-8(fp)
81137414:	10000326 	beq	r2,zero,81137424 <OSSemDel+0xf4>
81137418:	10800060 	cmpeqi	r2,r2,1
8113741c:	1000281e 	bne	r2,zero,811374c0 <OSSemDel+0x190>
81137420:	00004506 	br	81137538 <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
81137424:	e0bff503 	ldbu	r2,-44(fp)
81137428:	1000161e 	bne	r2,zero,81137484 <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113742c:	e0bffd17 	ldw	r2,-12(fp)
81137430:	00c00fc4 	movi	r3,63
81137434:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
81137438:	e0bffd17 	ldw	r2,-12(fp)
8113743c:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81137440:	e0bffd17 	ldw	r2,-12(fp)
81137444:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
81137448:	d0e09f17 	ldw	r3,-32132(gp)
8113744c:	e0bffd17 	ldw	r2,-12(fp)
81137450:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
81137454:	e0bffd17 	ldw	r2,-12(fp)
81137458:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113745c:	e0bffd17 	ldw	r2,-12(fp)
81137460:	d0a09f15 	stw	r2,-32132(gp)
81137464:	e0bff717 	ldw	r2,-36(fp)
81137468:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113746c:	e0bff817 	ldw	r2,-32(fp)
81137470:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
81137474:	e0bfff17 	ldw	r2,-4(fp)
81137478:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
8113747c:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
81137480:	00003706 	br	81137560 <OSSemDel+0x230>
81137484:	e0bff717 	ldw	r2,-36(fp)
81137488:	e0bff915 	stw	r2,-28(fp)
8113748c:	e0bff917 	ldw	r2,-28(fp)
81137490:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
81137494:	e0bfff17 	ldw	r2,-4(fp)
81137498:	00c01244 	movi	r3,73
8113749c:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
811374a0:	e0bffd17 	ldw	r2,-12(fp)
811374a4:	e0bff615 	stw	r2,-40(fp)
             }
             break;
811374a8:	00002d06 	br	81137560 <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
811374ac:	000f883a 	mov	r7,zero
811374b0:	01800044 	movi	r6,1
811374b4:	000b883a 	mov	r5,zero
811374b8:	e13ffd17 	ldw	r4,-12(fp)
811374bc:	1131c0c0 	call	81131c0c <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
811374c0:	e0bffd17 	ldw	r2,-12(fp)
811374c4:	10800283 	ldbu	r2,10(r2)
811374c8:	10803fcc 	andi	r2,r2,255
811374cc:	103ff71e 	bne	r2,zero,811374ac <__reset+0xfb1174ac>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
811374d0:	e0bffd17 	ldw	r2,-12(fp)
811374d4:	00c00fc4 	movi	r3,63
811374d8:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
811374dc:	e0bffd17 	ldw	r2,-12(fp)
811374e0:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
811374e4:	e0bffd17 	ldw	r2,-12(fp)
811374e8:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
811374ec:	d0e09f17 	ldw	r3,-32132(gp)
811374f0:	e0bffd17 	ldw	r2,-12(fp)
811374f4:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
811374f8:	e0bffd17 	ldw	r2,-12(fp)
811374fc:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
81137500:	e0bffd17 	ldw	r2,-12(fp)
81137504:	d0a09f15 	stw	r2,-32132(gp)
81137508:	e0bff717 	ldw	r2,-36(fp)
8113750c:	e0bffa15 	stw	r2,-24(fp)
81137510:	e0bffa17 	ldw	r2,-24(fp)
81137514:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81137518:	e0bff503 	ldbu	r2,-44(fp)
8113751c:	10800058 	cmpnei	r2,r2,1
81137520:	1000011e 	bne	r2,zero,81137528 <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81137524:	11326c80 	call	811326c8 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
81137528:	e0bfff17 	ldw	r2,-4(fp)
8113752c:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
81137530:	e03ff615 	stw	zero,-40(fp)
             break;
81137534:	00000a06 	br	81137560 <OSSemDel+0x230>
81137538:	e0bff717 	ldw	r2,-36(fp)
8113753c:	e0bffb15 	stw	r2,-20(fp)
81137540:	e0bffb17 	ldw	r2,-20(fp)
81137544:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
81137548:	e0bfff17 	ldw	r2,-4(fp)
8113754c:	00c001c4 	movi	r3,7
81137550:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
81137554:	e0bffd17 	ldw	r2,-12(fp)
81137558:	e0bff615 	stw	r2,-40(fp)
             break;
8113755c:	0001883a 	nop
    }
    return (pevent_return);
81137560:	e0bff617 	ldw	r2,-40(fp)
}
81137564:	e037883a 	mov	sp,fp
81137568:	dfc00117 	ldw	ra,4(sp)
8113756c:	df000017 	ldw	fp,0(sp)
81137570:	dec00204 	addi	sp,sp,8
81137574:	f800283a 	ret

81137578 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81137578:	defff504 	addi	sp,sp,-44
8113757c:	de00012e 	bgeu	sp,et,81137584 <OSSemPend+0xc>
81137580:	003b68fa 	trap	3
81137584:	dfc00a15 	stw	ra,40(sp)
81137588:	df000915 	stw	fp,36(sp)
8113758c:	df000904 	addi	fp,sp,36
81137590:	e13ffd15 	stw	r4,-12(fp)
81137594:	2805883a 	mov	r2,r5
81137598:	e1bfff15 	stw	r6,-4(fp)
8113759c:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811375a0:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
811375a4:	e0bfff17 	ldw	r2,-4(fp)
811375a8:	10007226 	beq	r2,zero,81137774 <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811375ac:	e0bffd17 	ldw	r2,-12(fp)
811375b0:	1000041e 	bne	r2,zero,811375c4 <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
811375b4:	e0bfff17 	ldw	r2,-4(fp)
811375b8:	00c00104 	movi	r3,4
811375bc:	10c00005 	stb	r3,0(r2)
        return;
811375c0:	00006d06 	br	81137778 <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811375c4:	e0bffd17 	ldw	r2,-12(fp)
811375c8:	10800003 	ldbu	r2,0(r2)
811375cc:	10803fcc 	andi	r2,r2,255
811375d0:	108000e0 	cmpeqi	r2,r2,3
811375d4:	1000041e 	bne	r2,zero,811375e8 <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
811375d8:	e0bfff17 	ldw	r2,-4(fp)
811375dc:	00c00044 	movi	r3,1
811375e0:	10c00005 	stb	r3,0(r2)
        return;
811375e4:	00006406 	br	81137778 <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
811375e8:	d0a0a003 	ldbu	r2,-32128(gp)
811375ec:	10803fcc 	andi	r2,r2,255
811375f0:	10000426 	beq	r2,zero,81137604 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
811375f4:	e0bfff17 	ldw	r2,-4(fp)
811375f8:	00c00084 	movi	r3,2
811375fc:	10c00005 	stb	r3,0(r2)
        return;
81137600:	00005d06 	br	81137778 <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
81137604:	d0a08e03 	ldbu	r2,-32200(gp)
81137608:	10803fcc 	andi	r2,r2,255
8113760c:	10000426 	beq	r2,zero,81137620 <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
81137610:	e0bfff17 	ldw	r2,-4(fp)
81137614:	00c00344 	movi	r3,13
81137618:	10c00005 	stb	r3,0(r2)
        return;
8113761c:	00005606 	br	81137778 <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137620:	0005303a 	rdctl	r2,status
81137624:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137628:	e0fffc17 	ldw	r3,-16(fp)
8113762c:	00bfff84 	movi	r2,-2
81137630:	1884703a 	and	r2,r3,r2
81137634:	1001703a 	wrctl	status,r2
  
  return context;
81137638:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113763c:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
81137640:	e0bffd17 	ldw	r2,-12(fp)
81137644:	1080020b 	ldhu	r2,8(r2)
81137648:	10bfffcc 	andi	r2,r2,65535
8113764c:	10000d26 	beq	r2,zero,81137684 <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
81137650:	e0bffd17 	ldw	r2,-12(fp)
81137654:	1080020b 	ldhu	r2,8(r2)
81137658:	10bfffc4 	addi	r2,r2,-1
8113765c:	1007883a 	mov	r3,r2
81137660:	e0bffd17 	ldw	r2,-12(fp)
81137664:	10c0020d 	sth	r3,8(r2)
81137668:	e0bff717 	ldw	r2,-36(fp)
8113766c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137670:	e0bff817 	ldw	r2,-32(fp)
81137674:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
81137678:	e0bfff17 	ldw	r2,-4(fp)
8113767c:	10000005 	stb	zero,0(r2)
        return;
81137680:	00003d06 	br	81137778 <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
81137684:	d0a0a117 	ldw	r2,-32124(gp)
81137688:	d0e0a117 	ldw	r3,-32124(gp)
8113768c:	18c00c03 	ldbu	r3,48(r3)
81137690:	18c00054 	ori	r3,r3,1
81137694:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81137698:	d0a0a117 	ldw	r2,-32124(gp)
8113769c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
811376a0:	d0a0a117 	ldw	r2,-32124(gp)
811376a4:	e0fffe0b 	ldhu	r3,-8(fp)
811376a8:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
811376ac:	e13ffd17 	ldw	r4,-12(fp)
811376b0:	1131dac0 	call	81131dac <OS_EventTaskWait>
811376b4:	e0bff717 	ldw	r2,-36(fp)
811376b8:	e0bffb15 	stw	r2,-20(fp)
811376bc:	e0bffb17 	ldw	r2,-20(fp)
811376c0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
811376c4:	11326c80 	call	811326c8 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811376c8:	0005303a 	rdctl	r2,status
811376cc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811376d0:	e0fff917 	ldw	r3,-28(fp)
811376d4:	00bfff84 	movi	r2,-2
811376d8:	1884703a 	and	r2,r3,r2
811376dc:	1001703a 	wrctl	status,r2
  
  return context;
811376e0:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
811376e4:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
811376e8:	d0a0a117 	ldw	r2,-32124(gp)
811376ec:	10800c43 	ldbu	r2,49(r2)
811376f0:	10803fcc 	andi	r2,r2,255
811376f4:	10000326 	beq	r2,zero,81137704 <OSSemPend+0x18c>
811376f8:	108000a0 	cmpeqi	r2,r2,2
811376fc:	1000041e 	bne	r2,zero,81137710 <OSSemPend+0x198>
81137700:	00000706 	br	81137720 <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
81137704:	e0bfff17 	ldw	r2,-4(fp)
81137708:	10000005 	stb	zero,0(r2)
             break;
8113770c:	00000c06 	br	81137740 <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
81137710:	e0bfff17 	ldw	r2,-4(fp)
81137714:	00c00384 	movi	r3,14
81137718:	10c00005 	stb	r3,0(r2)
             break;
8113771c:	00000806 	br	81137740 <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
81137720:	d0a0a117 	ldw	r2,-32124(gp)
81137724:	e17ffd17 	ldw	r5,-12(fp)
81137728:	1009883a 	mov	r4,r2
8113772c:	113201c0 	call	8113201c <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
81137730:	e0bfff17 	ldw	r2,-4(fp)
81137734:	00c00284 	movi	r3,10
81137738:	10c00005 	stb	r3,0(r2)
             break;
8113773c:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81137740:	d0a0a117 	ldw	r2,-32124(gp)
81137744:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
81137748:	d0a0a117 	ldw	r2,-32124(gp)
8113774c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81137750:	d0a0a117 	ldw	r2,-32124(gp)
81137754:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81137758:	d0a0a117 	ldw	r2,-32124(gp)
8113775c:	10000815 	stw	zero,32(r2)
81137760:	e0bff717 	ldw	r2,-36(fp)
81137764:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137768:	e0bffa17 	ldw	r2,-24(fp)
8113776c:	1001703a 	wrctl	status,r2
81137770:	00000106 	br	81137778 <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
81137774:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
81137778:	e037883a 	mov	sp,fp
8113777c:	dfc00117 	ldw	ra,4(sp)
81137780:	df000017 	ldw	fp,0(sp)
81137784:	dec00204 	addi	sp,sp,8
81137788:	f800283a 	ret

8113778c <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113778c:	defff604 	addi	sp,sp,-40
81137790:	de00012e 	bgeu	sp,et,81137798 <OSSemPendAbort+0xc>
81137794:	003b68fa 	trap	3
81137798:	dfc00915 	stw	ra,36(sp)
8113779c:	df000815 	stw	fp,32(sp)
811377a0:	df000804 	addi	fp,sp,32
811377a4:	e13ffd15 	stw	r4,-12(fp)
811377a8:	2805883a 	mov	r2,r5
811377ac:	e1bfff15 	stw	r6,-4(fp)
811377b0:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811377b4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
811377b8:	e0bfff17 	ldw	r2,-4(fp)
811377bc:	1000021e 	bne	r2,zero,811377c8 <OSSemPendAbort+0x3c>
        return (0);
811377c0:	0005883a 	mov	r2,zero
811377c4:	00004906 	br	811378ec <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811377c8:	e0bffd17 	ldw	r2,-12(fp)
811377cc:	1000051e 	bne	r2,zero,811377e4 <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
811377d0:	e0bfff17 	ldw	r2,-4(fp)
811377d4:	00c00104 	movi	r3,4
811377d8:	10c00005 	stb	r3,0(r2)
        return (0);
811377dc:	0005883a 	mov	r2,zero
811377e0:	00004206 	br	811378ec <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
811377e4:	e0bffd17 	ldw	r2,-12(fp)
811377e8:	10800003 	ldbu	r2,0(r2)
811377ec:	10803fcc 	andi	r2,r2,255
811377f0:	108000e0 	cmpeqi	r2,r2,3
811377f4:	1000051e 	bne	r2,zero,8113780c <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
811377f8:	e0bfff17 	ldw	r2,-4(fp)
811377fc:	00c00044 	movi	r3,1
81137800:	10c00005 	stb	r3,0(r2)
        return (0);
81137804:	0005883a 	mov	r2,zero
81137808:	00003806 	br	811378ec <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113780c:	0005303a 	rdctl	r2,status
81137810:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137814:	e0fffc17 	ldw	r3,-16(fp)
81137818:	00bfff84 	movi	r2,-2
8113781c:	1884703a 	and	r2,r3,r2
81137820:	1001703a 	wrctl	status,r2
  
  return context;
81137824:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81137828:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
8113782c:	e0bffd17 	ldw	r2,-12(fp)
81137830:	10800283 	ldbu	r2,10(r2)
81137834:	10803fcc 	andi	r2,r2,255
81137838:	10002526 	beq	r2,zero,811378d0 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
8113783c:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
81137840:	e0bffe03 	ldbu	r2,-8(fp)
81137844:	10800060 	cmpeqi	r2,r2,1
81137848:	10000e26 	beq	r2,zero,81137884 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8113784c:	00000806 	br	81137870 <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
81137850:	01c00084 	movi	r7,2
81137854:	01800044 	movi	r6,1
81137858:	000b883a 	mov	r5,zero
8113785c:	e13ffd17 	ldw	r4,-12(fp)
81137860:	1131c0c0 	call	81131c0c <OS_EventTaskRdy>
                     nbr_tasks++;
81137864:	e0bff803 	ldbu	r2,-32(fp)
81137868:	10800044 	addi	r2,r2,1
8113786c:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
81137870:	e0bffd17 	ldw	r2,-12(fp)
81137874:	10800283 	ldbu	r2,10(r2)
81137878:	10803fcc 	andi	r2,r2,255
8113787c:	103ff41e 	bne	r2,zero,81137850 <__reset+0xfb117850>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
81137880:	00000906 	br	811378a8 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
81137884:	01c00084 	movi	r7,2
81137888:	01800044 	movi	r6,1
8113788c:	000b883a 	mov	r5,zero
81137890:	e13ffd17 	ldw	r4,-12(fp)
81137894:	1131c0c0 	call	81131c0c <OS_EventTaskRdy>
                 nbr_tasks++;
81137898:	e0bff803 	ldbu	r2,-32(fp)
8113789c:	10800044 	addi	r2,r2,1
811378a0:	e0bff805 	stb	r2,-32(fp)
                 break;
811378a4:	0001883a 	nop
811378a8:	e0bff917 	ldw	r2,-28(fp)
811378ac:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811378b0:	e0bffa17 	ldw	r2,-24(fp)
811378b4:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
811378b8:	11326c80 	call	811326c8 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
811378bc:	e0bfff17 	ldw	r2,-4(fp)
811378c0:	00c00384 	movi	r3,14
811378c4:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
811378c8:	e0bff803 	ldbu	r2,-32(fp)
811378cc:	00000706 	br	811378ec <OSSemPendAbort+0x160>
811378d0:	e0bff917 	ldw	r2,-28(fp)
811378d4:	e0bffb15 	stw	r2,-20(fp)
811378d8:	e0bffb17 	ldw	r2,-20(fp)
811378dc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811378e0:	e0bfff17 	ldw	r2,-4(fp)
811378e4:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
811378e8:	0005883a 	mov	r2,zero
}
811378ec:	e037883a 	mov	sp,fp
811378f0:	dfc00117 	ldw	ra,4(sp)
811378f4:	df000017 	ldw	fp,0(sp)
811378f8:	dec00204 	addi	sp,sp,8
811378fc:	f800283a 	ret

81137900 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
81137900:	defff804 	addi	sp,sp,-32
81137904:	de00012e 	bgeu	sp,et,8113790c <OSSemPost+0xc>
81137908:	003b68fa 	trap	3
8113790c:	dfc00715 	stw	ra,28(sp)
81137910:	df000615 	stw	fp,24(sp)
81137914:	df000604 	addi	fp,sp,24
81137918:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113791c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81137920:	e0bfff17 	ldw	r2,-4(fp)
81137924:	1000021e 	bne	r2,zero,81137930 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
81137928:	00800104 	movi	r2,4
8113792c:	00003506 	br	81137a04 <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81137930:	e0bfff17 	ldw	r2,-4(fp)
81137934:	10800003 	ldbu	r2,0(r2)
81137938:	10803fcc 	andi	r2,r2,255
8113793c:	108000e0 	cmpeqi	r2,r2,3
81137940:	1000021e 	bne	r2,zero,8113794c <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
81137944:	00800044 	movi	r2,1
81137948:	00002e06 	br	81137a04 <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113794c:	0005303a 	rdctl	r2,status
81137950:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137954:	e0fffe17 	ldw	r3,-8(fp)
81137958:	00bfff84 	movi	r2,-2
8113795c:	1884703a 	and	r2,r3,r2
81137960:	1001703a 	wrctl	status,r2
  
  return context;
81137964:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81137968:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
8113796c:	e0bfff17 	ldw	r2,-4(fp)
81137970:	10800283 	ldbu	r2,10(r2)
81137974:	10803fcc 	andi	r2,r2,255
81137978:	10000c26 	beq	r2,zero,811379ac <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113797c:	000f883a 	mov	r7,zero
81137980:	01800044 	movi	r6,1
81137984:	000b883a 	mov	r5,zero
81137988:	e13fff17 	ldw	r4,-4(fp)
8113798c:	1131c0c0 	call	81131c0c <OS_EventTaskRdy>
81137990:	e0bffa17 	ldw	r2,-24(fp)
81137994:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137998:	e0bffb17 	ldw	r2,-20(fp)
8113799c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
811379a0:	11326c80 	call	811326c8 <OS_Sched>
        return (OS_ERR_NONE);
811379a4:	0005883a 	mov	r2,zero
811379a8:	00001606 	br	81137a04 <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
811379ac:	e0bfff17 	ldw	r2,-4(fp)
811379b0:	1080020b 	ldhu	r2,8(r2)
811379b4:	10ffffcc 	andi	r3,r2,65535
811379b8:	00bfffd4 	movui	r2,65535
811379bc:	18800c26 	beq	r3,r2,811379f0 <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
811379c0:	e0bfff17 	ldw	r2,-4(fp)
811379c4:	1080020b 	ldhu	r2,8(r2)
811379c8:	10800044 	addi	r2,r2,1
811379cc:	1007883a 	mov	r3,r2
811379d0:	e0bfff17 	ldw	r2,-4(fp)
811379d4:	10c0020d 	sth	r3,8(r2)
811379d8:	e0bffa17 	ldw	r2,-24(fp)
811379dc:	e0bffc15 	stw	r2,-16(fp)
811379e0:	e0bffc17 	ldw	r2,-16(fp)
811379e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
811379e8:	0005883a 	mov	r2,zero
811379ec:	00000506 	br	81137a04 <OSSemPost+0x104>
811379f0:	e0bffa17 	ldw	r2,-24(fp)
811379f4:	e0bffd15 	stw	r2,-12(fp)
811379f8:	e0bffd17 	ldw	r2,-12(fp)
811379fc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
81137a00:	00800c84 	movi	r2,50
}
81137a04:	e037883a 	mov	sp,fp
81137a08:	dfc00117 	ldw	ra,4(sp)
81137a0c:	df000017 	ldw	fp,0(sp)
81137a10:	dec00204 	addi	sp,sp,8
81137a14:	f800283a 	ret

81137a18 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
81137a18:	defff704 	addi	sp,sp,-36
81137a1c:	de00012e 	bgeu	sp,et,81137a24 <OSSemQuery+0xc>
81137a20:	003b68fa 	trap	3
81137a24:	df000815 	stw	fp,32(sp)
81137a28:	df000804 	addi	fp,sp,32
81137a2c:	e13ffe15 	stw	r4,-8(fp)
81137a30:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81137a34:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81137a38:	e0bffe17 	ldw	r2,-8(fp)
81137a3c:	1000021e 	bne	r2,zero,81137a48 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
81137a40:	00800104 	movi	r2,4
81137a44:	00003606 	br	81137b20 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
81137a48:	e0bfff17 	ldw	r2,-4(fp)
81137a4c:	1000021e 	bne	r2,zero,81137a58 <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
81137a50:	00800244 	movi	r2,9
81137a54:	00003206 	br	81137b20 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
81137a58:	e0bffe17 	ldw	r2,-8(fp)
81137a5c:	10800003 	ldbu	r2,0(r2)
81137a60:	10803fcc 	andi	r2,r2,255
81137a64:	108000e0 	cmpeqi	r2,r2,3
81137a68:	1000021e 	bne	r2,zero,81137a74 <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
81137a6c:	00800044 	movi	r2,1
81137a70:	00002b06 	br	81137b20 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137a74:	0005303a 	rdctl	r2,status
81137a78:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137a7c:	e0fffd17 	ldw	r3,-12(fp)
81137a80:	00bfff84 	movi	r2,-2
81137a84:	1884703a 	and	r2,r3,r2
81137a88:	1001703a 	wrctl	status,r2
  
  return context;
81137a8c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81137a90:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
81137a94:	e0bffe17 	ldw	r2,-8(fp)
81137a98:	10c00283 	ldbu	r3,10(r2)
81137a9c:	e0bfff17 	ldw	r2,-4(fp)
81137aa0:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
81137aa4:	e0bffe17 	ldw	r2,-8(fp)
81137aa8:	108002c4 	addi	r2,r2,11
81137aac:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
81137ab0:	e0bfff17 	ldw	r2,-4(fp)
81137ab4:	10800084 	addi	r2,r2,2
81137ab8:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81137abc:	e03ffa05 	stb	zero,-24(fp)
81137ac0:	00000b06 	br	81137af0 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
81137ac4:	e0bff917 	ldw	r2,-28(fp)
81137ac8:	10c00044 	addi	r3,r2,1
81137acc:	e0fff915 	stw	r3,-28(fp)
81137ad0:	e0fff817 	ldw	r3,-32(fp)
81137ad4:	19000044 	addi	r4,r3,1
81137ad8:	e13ff815 	stw	r4,-32(fp)
81137adc:	18c00003 	ldbu	r3,0(r3)
81137ae0:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
81137ae4:	e0bffa03 	ldbu	r2,-24(fp)
81137ae8:	10800044 	addi	r2,r2,1
81137aec:	e0bffa05 	stb	r2,-24(fp)
81137af0:	e0bffa03 	ldbu	r2,-24(fp)
81137af4:	108001b0 	cmpltui	r2,r2,6
81137af8:	103ff21e 	bne	r2,zero,81137ac4 <__reset+0xfb117ac4>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
81137afc:	e0bffe17 	ldw	r2,-8(fp)
81137b00:	10c0020b 	ldhu	r3,8(r2)
81137b04:	e0bfff17 	ldw	r2,-4(fp)
81137b08:	10c0000d 	sth	r3,0(r2)
81137b0c:	e0bffb17 	ldw	r2,-20(fp)
81137b10:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137b14:	e0bffc17 	ldw	r2,-16(fp)
81137b18:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81137b1c:	0005883a 	mov	r2,zero
}
81137b20:	e037883a 	mov	sp,fp
81137b24:	df000017 	ldw	fp,0(sp)
81137b28:	dec00104 	addi	sp,sp,4
81137b2c:	f800283a 	ret

81137b30 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
81137b30:	defff904 	addi	sp,sp,-28
81137b34:	de00012e 	bgeu	sp,et,81137b3c <OSSemSet+0xc>
81137b38:	003b68fa 	trap	3
81137b3c:	df000615 	stw	fp,24(sp)
81137b40:	df000604 	addi	fp,sp,24
81137b44:	e13ffd15 	stw	r4,-12(fp)
81137b48:	2805883a 	mov	r2,r5
81137b4c:	e1bfff15 	stw	r6,-4(fp)
81137b50:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81137b54:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81137b58:	e0bfff17 	ldw	r2,-4(fp)
81137b5c:	10003126 	beq	r2,zero,81137c24 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81137b60:	e0bffd17 	ldw	r2,-12(fp)
81137b64:	1000041e 	bne	r2,zero,81137b78 <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
81137b68:	e0bfff17 	ldw	r2,-4(fp)
81137b6c:	00c00104 	movi	r3,4
81137b70:	10c00005 	stb	r3,0(r2)
        return;
81137b74:	00002c06 	br	81137c28 <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
81137b78:	e0bffd17 	ldw	r2,-12(fp)
81137b7c:	10800003 	ldbu	r2,0(r2)
81137b80:	10803fcc 	andi	r2,r2,255
81137b84:	108000e0 	cmpeqi	r2,r2,3
81137b88:	1000041e 	bne	r2,zero,81137b9c <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
81137b8c:	e0bfff17 	ldw	r2,-4(fp)
81137b90:	00c00044 	movi	r3,1
81137b94:	10c00005 	stb	r3,0(r2)
        return;
81137b98:	00002306 	br	81137c28 <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137b9c:	0005303a 	rdctl	r2,status
81137ba0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137ba4:	e0fffc17 	ldw	r3,-16(fp)
81137ba8:	00bfff84 	movi	r2,-2
81137bac:	1884703a 	and	r2,r3,r2
81137bb0:	1001703a 	wrctl	status,r2
  
  return context;
81137bb4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81137bb8:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
81137bbc:	e0bfff17 	ldw	r2,-4(fp)
81137bc0:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
81137bc4:	e0bffd17 	ldw	r2,-12(fp)
81137bc8:	1080020b 	ldhu	r2,8(r2)
81137bcc:	10bfffcc 	andi	r2,r2,65535
81137bd0:	10000426 	beq	r2,zero,81137be4 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
81137bd4:	e0bffd17 	ldw	r2,-12(fp)
81137bd8:	e0fffe0b 	ldhu	r3,-8(fp)
81137bdc:	10c0020d 	sth	r3,8(r2)
81137be0:	00000b06 	br	81137c10 <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
81137be4:	e0bffd17 	ldw	r2,-12(fp)
81137be8:	10800283 	ldbu	r2,10(r2)
81137bec:	10803fcc 	andi	r2,r2,255
81137bf0:	1000041e 	bne	r2,zero,81137c04 <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
81137bf4:	e0bffd17 	ldw	r2,-12(fp)
81137bf8:	e0fffe0b 	ldhu	r3,-8(fp)
81137bfc:	10c0020d 	sth	r3,8(r2)
81137c00:	00000306 	br	81137c10 <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
81137c04:	e0bfff17 	ldw	r2,-4(fp)
81137c08:	00c01244 	movi	r3,73
81137c0c:	10c00005 	stb	r3,0(r2)
81137c10:	e0bffa17 	ldw	r2,-24(fp)
81137c14:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137c18:	e0bffb17 	ldw	r2,-20(fp)
81137c1c:	1001703a 	wrctl	status,r2
81137c20:	00000106 	br	81137c28 <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
81137c24:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
81137c28:	e037883a 	mov	sp,fp
81137c2c:	df000017 	ldw	fp,0(sp)
81137c30:	dec00104 	addi	sp,sp,4
81137c34:	f800283a 	ret

81137c38 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
81137c38:	defff104 	addi	sp,sp,-60
81137c3c:	de00012e 	bgeu	sp,et,81137c44 <OSTaskChangePrio+0xc>
81137c40:	003b68fa 	trap	3
81137c44:	dfc00e15 	stw	ra,56(sp)
81137c48:	df000d15 	stw	fp,52(sp)
81137c4c:	df000d04 	addi	fp,sp,52
81137c50:	2007883a 	mov	r3,r4
81137c54:	2805883a 	mov	r2,r5
81137c58:	e0fffe05 	stb	r3,-8(fp)
81137c5c:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
81137c60:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
81137c64:	e0bffe03 	ldbu	r2,-8(fp)
81137c68:	10800ab0 	cmpltui	r2,r2,42
81137c6c:	1000051e 	bne	r2,zero,81137c84 <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
81137c70:	e0bffe03 	ldbu	r2,-8(fp)
81137c74:	10803fe0 	cmpeqi	r2,r2,255
81137c78:	1000021e 	bne	r2,zero,81137c84 <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
81137c7c:	00800a84 	movi	r2,42
81137c80:	00012606 	br	8113811c <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
81137c84:	e0bfff03 	ldbu	r2,-4(fp)
81137c88:	10800ab0 	cmpltui	r2,r2,42
81137c8c:	1000021e 	bne	r2,zero,81137c98 <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
81137c90:	00800a84 	movi	r2,42
81137c94:	00012106 	br	8113811c <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137c98:	0005303a 	rdctl	r2,status
81137c9c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137ca0:	e0fffd17 	ldw	r3,-12(fp)
81137ca4:	00bfff84 	movi	r2,-2
81137ca8:	1884703a 	and	r2,r3,r2
81137cac:	1001703a 	wrctl	status,r2
  
  return context;
81137cb0:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81137cb4:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
81137cb8:	e0ffff03 	ldbu	r3,-4(fp)
81137cbc:	00a045b4 	movhi	r2,33046
81137cc0:	1084d804 	addi	r2,r2,4960
81137cc4:	18c7883a 	add	r3,r3,r3
81137cc8:	18c7883a 	add	r3,r3,r3
81137ccc:	10c5883a 	add	r2,r2,r3
81137cd0:	10800017 	ldw	r2,0(r2)
81137cd4:	10000626 	beq	r2,zero,81137cf0 <OSTaskChangePrio+0xb8>
81137cd8:	e0bff517 	ldw	r2,-44(fp)
81137cdc:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137ce0:	e0bff617 	ldw	r2,-40(fp)
81137ce4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
81137ce8:	00800a04 	movi	r2,40
81137cec:	00010b06 	br	8113811c <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
81137cf0:	e0bffe03 	ldbu	r2,-8(fp)
81137cf4:	10803fd8 	cmpnei	r2,r2,255
81137cf8:	1000031e 	bne	r2,zero,81137d08 <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
81137cfc:	d0a0a117 	ldw	r2,-32124(gp)
81137d00:	10800c83 	ldbu	r2,50(r2)
81137d04:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
81137d08:	e0fffe03 	ldbu	r3,-8(fp)
81137d0c:	00a045b4 	movhi	r2,33046
81137d10:	1084d804 	addi	r2,r2,4960
81137d14:	18c7883a 	add	r3,r3,r3
81137d18:	18c7883a 	add	r3,r3,r3
81137d1c:	10c5883a 	add	r2,r2,r3
81137d20:	10800017 	ldw	r2,0(r2)
81137d24:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
81137d28:	e0bff817 	ldw	r2,-32(fp)
81137d2c:	1000061e 	bne	r2,zero,81137d48 <OSTaskChangePrio+0x110>
81137d30:	e0bff517 	ldw	r2,-44(fp)
81137d34:	e0bff715 	stw	r2,-36(fp)
81137d38:	e0bff717 	ldw	r2,-36(fp)
81137d3c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
81137d40:	00800a44 	movi	r2,41
81137d44:	0000f506 	br	8113811c <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
81137d48:	e0bff817 	ldw	r2,-32(fp)
81137d4c:	10800058 	cmpnei	r2,r2,1
81137d50:	1000061e 	bne	r2,zero,81137d6c <OSTaskChangePrio+0x134>
81137d54:	e0bff517 	ldw	r2,-44(fp)
81137d58:	e0bff915 	stw	r2,-28(fp)
81137d5c:	e0bff917 	ldw	r2,-28(fp)
81137d60:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
81137d64:	008010c4 	movi	r2,67
81137d68:	0000ec06 	br	8113811c <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
81137d6c:	e0bfff03 	ldbu	r2,-4(fp)
81137d70:	1004d0fa 	srli	r2,r2,3
81137d74:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
81137d78:	e0bfff03 	ldbu	r2,-4(fp)
81137d7c:	108001cc 	andi	r2,r2,7
81137d80:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
81137d84:	e0bffb03 	ldbu	r2,-20(fp)
81137d88:	00c00044 	movi	r3,1
81137d8c:	1884983a 	sll	r2,r3,r2
81137d90:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
81137d94:	e0bffb43 	ldbu	r2,-19(fp)
81137d98:	00c00044 	movi	r3,1
81137d9c:	1884983a 	sll	r2,r3,r2
81137da0:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
81137da4:	e0fffe03 	ldbu	r3,-8(fp)
81137da8:	00a045b4 	movhi	r2,33046
81137dac:	1084d804 	addi	r2,r2,4960
81137db0:	18c7883a 	add	r3,r3,r3
81137db4:	18c7883a 	add	r3,r3,r3
81137db8:	10c5883a 	add	r2,r2,r3
81137dbc:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
81137dc0:	e0ffff03 	ldbu	r3,-4(fp)
81137dc4:	00a045b4 	movhi	r2,33046
81137dc8:	1084d804 	addi	r2,r2,4960
81137dcc:	18c7883a 	add	r3,r3,r3
81137dd0:	18c7883a 	add	r3,r3,r3
81137dd4:	10c5883a 	add	r2,r2,r3
81137dd8:	e0fff817 	ldw	r3,-32(fp)
81137ddc:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
81137de0:	e0bff817 	ldw	r2,-32(fp)
81137de4:	10800d03 	ldbu	r2,52(r2)
81137de8:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
81137dec:	e0bff817 	ldw	r2,-32(fp)
81137df0:	10800d83 	ldbu	r2,54(r2)
81137df4:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
81137df8:	e0bff817 	ldw	r2,-32(fp)
81137dfc:	10800d43 	ldbu	r2,53(r2)
81137e00:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
81137e04:	e0fffc03 	ldbu	r3,-16(fp)
81137e08:	d0a09d44 	addi	r2,gp,-32139
81137e0c:	1885883a 	add	r2,r3,r2
81137e10:	10c00003 	ldbu	r3,0(r2)
81137e14:	e0bffc83 	ldbu	r2,-14(fp)
81137e18:	1884703a 	and	r2,r3,r2
81137e1c:	10803fcc 	andi	r2,r2,255
81137e20:	10002826 	beq	r2,zero,81137ec4 <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
81137e24:	e0fffc03 	ldbu	r3,-16(fp)
81137e28:	e13ffc03 	ldbu	r4,-16(fp)
81137e2c:	d0a09d44 	addi	r2,gp,-32139
81137e30:	2085883a 	add	r2,r4,r2
81137e34:	10800003 	ldbu	r2,0(r2)
81137e38:	1009883a 	mov	r4,r2
81137e3c:	e0bffc83 	ldbu	r2,-14(fp)
81137e40:	0084303a 	nor	r2,zero,r2
81137e44:	2084703a 	and	r2,r4,r2
81137e48:	1009883a 	mov	r4,r2
81137e4c:	d0a09d44 	addi	r2,gp,-32139
81137e50:	1885883a 	add	r2,r3,r2
81137e54:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
81137e58:	e0fffc03 	ldbu	r3,-16(fp)
81137e5c:	d0a09d44 	addi	r2,gp,-32139
81137e60:	1885883a 	add	r2,r3,r2
81137e64:	10800003 	ldbu	r2,0(r2)
81137e68:	10803fcc 	andi	r2,r2,255
81137e6c:	1000061e 	bne	r2,zero,81137e88 <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
81137e70:	e0bffc43 	ldbu	r2,-15(fp)
81137e74:	0084303a 	nor	r2,zero,r2
81137e78:	1007883a 	mov	r3,r2
81137e7c:	d0a09d03 	ldbu	r2,-32140(gp)
81137e80:	1884703a 	and	r2,r3,r2
81137e84:	d0a09d05 	stb	r2,-32140(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
81137e88:	d0e09d03 	ldbu	r3,-32140(gp)
81137e8c:	e0bffb83 	ldbu	r2,-18(fp)
81137e90:	1884b03a 	or	r2,r3,r2
81137e94:	d0a09d05 	stb	r2,-32140(gp)
         OSRdyTbl[y_new] |= bitx_new;
81137e98:	e0fffb03 	ldbu	r3,-20(fp)
81137e9c:	e13ffb03 	ldbu	r4,-20(fp)
81137ea0:	d0a09d44 	addi	r2,gp,-32139
81137ea4:	2085883a 	add	r2,r4,r2
81137ea8:	11000003 	ldbu	r4,0(r2)
81137eac:	e0bffbc3 	ldbu	r2,-17(fp)
81137eb0:	2084b03a 	or	r2,r4,r2
81137eb4:	1009883a 	mov	r4,r2
81137eb8:	d0a09d44 	addi	r2,gp,-32139
81137ebc:	1885883a 	add	r2,r3,r2
81137ec0:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
81137ec4:	e0bff817 	ldw	r2,-32(fp)
81137ec8:	10800717 	ldw	r2,28(r2)
81137ecc:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
81137ed0:	e0bff317 	ldw	r2,-52(fp)
81137ed4:	10003326 	beq	r2,zero,81137fa4 <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
81137ed8:	e0bffc03 	ldbu	r2,-16(fp)
81137edc:	e0fffc03 	ldbu	r3,-16(fp)
81137ee0:	e13ff317 	ldw	r4,-52(fp)
81137ee4:	20c7883a 	add	r3,r4,r3
81137ee8:	18c002c4 	addi	r3,r3,11
81137eec:	18c00003 	ldbu	r3,0(r3)
81137ef0:	1809883a 	mov	r4,r3
81137ef4:	e0fffc83 	ldbu	r3,-14(fp)
81137ef8:	00c6303a 	nor	r3,zero,r3
81137efc:	20c6703a 	and	r3,r4,r3
81137f00:	1809883a 	mov	r4,r3
81137f04:	e0fff317 	ldw	r3,-52(fp)
81137f08:	1885883a 	add	r2,r3,r2
81137f0c:	108002c4 	addi	r2,r2,11
81137f10:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
81137f14:	e0bffc03 	ldbu	r2,-16(fp)
81137f18:	e0fff317 	ldw	r3,-52(fp)
81137f1c:	1885883a 	add	r2,r3,r2
81137f20:	108002c4 	addi	r2,r2,11
81137f24:	10800003 	ldbu	r2,0(r2)
81137f28:	10803fcc 	andi	r2,r2,255
81137f2c:	1000091e 	bne	r2,zero,81137f54 <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
81137f30:	e0bff317 	ldw	r2,-52(fp)
81137f34:	10800283 	ldbu	r2,10(r2)
81137f38:	1007883a 	mov	r3,r2
81137f3c:	e0bffc43 	ldbu	r2,-15(fp)
81137f40:	0084303a 	nor	r2,zero,r2
81137f44:	1884703a 	and	r2,r3,r2
81137f48:	1007883a 	mov	r3,r2
81137f4c:	e0bff317 	ldw	r2,-52(fp)
81137f50:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
81137f54:	e0bff317 	ldw	r2,-52(fp)
81137f58:	10c00283 	ldbu	r3,10(r2)
81137f5c:	e0bffb83 	ldbu	r2,-18(fp)
81137f60:	1884b03a 	or	r2,r3,r2
81137f64:	1007883a 	mov	r3,r2
81137f68:	e0bff317 	ldw	r2,-52(fp)
81137f6c:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
81137f70:	e0bffb03 	ldbu	r2,-20(fp)
81137f74:	e0fffb03 	ldbu	r3,-20(fp)
81137f78:	e13ff317 	ldw	r4,-52(fp)
81137f7c:	20c7883a 	add	r3,r4,r3
81137f80:	18c002c4 	addi	r3,r3,11
81137f84:	19000003 	ldbu	r4,0(r3)
81137f88:	e0fffbc3 	ldbu	r3,-17(fp)
81137f8c:	20c6b03a 	or	r3,r4,r3
81137f90:	1809883a 	mov	r4,r3
81137f94:	e0fff317 	ldw	r3,-52(fp)
81137f98:	1885883a 	add	r2,r3,r2
81137f9c:	108002c4 	addi	r2,r2,11
81137fa0:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
81137fa4:	e0bff817 	ldw	r2,-32(fp)
81137fa8:	10800817 	ldw	r2,32(r2)
81137fac:	10004226 	beq	r2,zero,811380b8 <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
81137fb0:	e0bff817 	ldw	r2,-32(fp)
81137fb4:	10800817 	ldw	r2,32(r2)
81137fb8:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
81137fbc:	e0bff417 	ldw	r2,-48(fp)
81137fc0:	10800017 	ldw	r2,0(r2)
81137fc4:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
81137fc8:	00003906 	br	811380b0 <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
81137fcc:	e0bffc03 	ldbu	r2,-16(fp)
81137fd0:	e0fffc03 	ldbu	r3,-16(fp)
81137fd4:	e13ff317 	ldw	r4,-52(fp)
81137fd8:	20c7883a 	add	r3,r4,r3
81137fdc:	18c002c4 	addi	r3,r3,11
81137fe0:	18c00003 	ldbu	r3,0(r3)
81137fe4:	1809883a 	mov	r4,r3
81137fe8:	e0fffc83 	ldbu	r3,-14(fp)
81137fec:	00c6303a 	nor	r3,zero,r3
81137ff0:	20c6703a 	and	r3,r4,r3
81137ff4:	1809883a 	mov	r4,r3
81137ff8:	e0fff317 	ldw	r3,-52(fp)
81137ffc:	1885883a 	add	r2,r3,r2
81138000:	108002c4 	addi	r2,r2,11
81138004:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
81138008:	e0bffc03 	ldbu	r2,-16(fp)
8113800c:	e0fff317 	ldw	r3,-52(fp)
81138010:	1885883a 	add	r2,r3,r2
81138014:	108002c4 	addi	r2,r2,11
81138018:	10800003 	ldbu	r2,0(r2)
8113801c:	10803fcc 	andi	r2,r2,255
81138020:	1000091e 	bne	r2,zero,81138048 <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
81138024:	e0bff317 	ldw	r2,-52(fp)
81138028:	10800283 	ldbu	r2,10(r2)
8113802c:	1007883a 	mov	r3,r2
81138030:	e0bffc43 	ldbu	r2,-15(fp)
81138034:	0084303a 	nor	r2,zero,r2
81138038:	1884703a 	and	r2,r3,r2
8113803c:	1007883a 	mov	r3,r2
81138040:	e0bff317 	ldw	r2,-52(fp)
81138044:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
81138048:	e0bff317 	ldw	r2,-52(fp)
8113804c:	10c00283 	ldbu	r3,10(r2)
81138050:	e0bffb83 	ldbu	r2,-18(fp)
81138054:	1884b03a 	or	r2,r3,r2
81138058:	1007883a 	mov	r3,r2
8113805c:	e0bff317 	ldw	r2,-52(fp)
81138060:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
81138064:	e0bffb03 	ldbu	r2,-20(fp)
81138068:	e0fffb03 	ldbu	r3,-20(fp)
8113806c:	e13ff317 	ldw	r4,-52(fp)
81138070:	20c7883a 	add	r3,r4,r3
81138074:	18c002c4 	addi	r3,r3,11
81138078:	19000003 	ldbu	r4,0(r3)
8113807c:	e0fffbc3 	ldbu	r3,-17(fp)
81138080:	20c6b03a 	or	r3,r4,r3
81138084:	1809883a 	mov	r4,r3
81138088:	e0fff317 	ldw	r3,-52(fp)
8113808c:	1885883a 	add	r2,r3,r2
81138090:	108002c4 	addi	r2,r2,11
81138094:	11000005 	stb	r4,0(r2)
            pevents++;
81138098:	e0bff417 	ldw	r2,-48(fp)
8113809c:	10800104 	addi	r2,r2,4
811380a0:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
811380a4:	e0bff417 	ldw	r2,-48(fp)
811380a8:	10800017 	ldw	r2,0(r2)
811380ac:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
811380b0:	e0bff317 	ldw	r2,-52(fp)
811380b4:	103fc51e 	bne	r2,zero,81137fcc <__reset+0xfb117fcc>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
811380b8:	e0bff817 	ldw	r2,-32(fp)
811380bc:	e0ffff03 	ldbu	r3,-4(fp)
811380c0:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
811380c4:	e0bff817 	ldw	r2,-32(fp)
811380c8:	e0fffb03 	ldbu	r3,-20(fp)
811380cc:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
811380d0:	e0bff817 	ldw	r2,-32(fp)
811380d4:	e0fffb43 	ldbu	r3,-19(fp)
811380d8:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
811380dc:	e0bff817 	ldw	r2,-32(fp)
811380e0:	e0fffb83 	ldbu	r3,-18(fp)
811380e4:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
811380e8:	e0bff817 	ldw	r2,-32(fp)
811380ec:	e0fffbc3 	ldbu	r3,-17(fp)
811380f0:	10c00d45 	stb	r3,53(r2)
811380f4:	e0bff517 	ldw	r2,-44(fp)
811380f8:	e0bffa15 	stw	r2,-24(fp)
811380fc:	e0bffa17 	ldw	r2,-24(fp)
81138100:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
81138104:	d0a09003 	ldbu	r2,-32192(gp)
81138108:	10803fcc 	andi	r2,r2,255
8113810c:	10800058 	cmpnei	r2,r2,1
81138110:	1000011e 	bne	r2,zero,81138118 <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
81138114:	11326c80 	call	811326c8 <OS_Sched>
    }
    return (OS_ERR_NONE);
81138118:	0005883a 	mov	r2,zero
}
8113811c:	e037883a 	mov	sp,fp
81138120:	dfc00117 	ldw	ra,4(sp)
81138124:	df000017 	ldw	fp,0(sp)
81138128:	dec00204 	addi	sp,sp,8
8113812c:	f800283a 	ret

81138130 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
81138130:	deffee04 	addi	sp,sp,-72
81138134:	de00012e 	bgeu	sp,et,8113813c <OSTaskCreate+0xc>
81138138:	003b68fa 	trap	3
8113813c:	dfc01115 	stw	ra,68(sp)
81138140:	df001015 	stw	fp,64(sp)
81138144:	df001004 	addi	fp,sp,64
81138148:	e13ffc15 	stw	r4,-16(fp)
8113814c:	e17ffd15 	stw	r5,-12(fp)
81138150:	e1bffe15 	stw	r6,-8(fp)
81138154:	3805883a 	mov	r2,r7
81138158:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113815c:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
81138160:	e0bfff03 	ldbu	r2,-4(fp)
81138164:	10800af0 	cmpltui	r2,r2,43
81138168:	1000021e 	bne	r2,zero,81138174 <OSTaskCreate+0x44>
        return (OS_ERR_PRIO_INVALID);
8113816c:	00800a84 	movi	r2,42
81138170:	00005706 	br	811382d0 <OSTaskCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138174:	0005303a 	rdctl	r2,status
81138178:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113817c:	e0fffb17 	ldw	r3,-20(fp)
81138180:	00bfff84 	movi	r2,-2
81138184:	1884703a 	and	r2,r3,r2
81138188:	1001703a 	wrctl	status,r2
  
  return context;
8113818c:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81138190:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
81138194:	d0a0a003 	ldbu	r2,-32128(gp)
81138198:	10803fcc 	andi	r2,r2,255
8113819c:	10000626 	beq	r2,zero,811381b8 <OSTaskCreate+0x88>
811381a0:	e0bff317 	ldw	r2,-52(fp)
811381a4:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811381a8:	e0bff417 	ldw	r2,-48(fp)
811381ac:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
811381b0:	00800f04 	movi	r2,60
811381b4:	00004606 	br	811382d0 <OSTaskCreate+0x1a0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
811381b8:	e0ffff03 	ldbu	r3,-4(fp)
811381bc:	00a045b4 	movhi	r2,33046
811381c0:	1084d804 	addi	r2,r2,4960
811381c4:	18c7883a 	add	r3,r3,r3
811381c8:	18c7883a 	add	r3,r3,r3
811381cc:	10c5883a 	add	r2,r2,r3
811381d0:	10800017 	ldw	r2,0(r2)
811381d4:	1000391e 	bne	r2,zero,811382bc <OSTaskCreate+0x18c>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
811381d8:	e0ffff03 	ldbu	r3,-4(fp)
811381dc:	00a045b4 	movhi	r2,33046
811381e0:	1084d804 	addi	r2,r2,4960
811381e4:	18c7883a 	add	r3,r3,r3
811381e8:	18c7883a 	add	r3,r3,r3
811381ec:	10c5883a 	add	r2,r2,r3
811381f0:	00c00044 	movi	r3,1
811381f4:	10c00015 	stw	r3,0(r2)
811381f8:	e0bff317 	ldw	r2,-52(fp)
811381fc:	e0bff515 	stw	r2,-44(fp)
81138200:	e0bff517 	ldw	r2,-44(fp)
81138204:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
81138208:	000f883a 	mov	r7,zero
8113820c:	e1bffe17 	ldw	r6,-8(fp)
81138210:	e17ffd17 	ldw	r5,-12(fp)
81138214:	e13ffc17 	ldw	r4,-16(fp)
81138218:	11438500 	call	81143850 <OSTaskStkInit>
8113821c:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
81138220:	e0bfff03 	ldbu	r2,-4(fp)
81138224:	d8000215 	stw	zero,8(sp)
81138228:	d8000115 	stw	zero,4(sp)
8113822c:	d8000015 	stw	zero,0(sp)
81138230:	000f883a 	mov	r7,zero
81138234:	000d883a 	mov	r6,zero
81138238:	e17ff717 	ldw	r5,-36(fp)
8113823c:	1009883a 	mov	r4,r2
81138240:	1132b100 	call	81132b10 <OS_TCBInit>
81138244:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
81138248:	e0bff803 	ldbu	r2,-32(fp)
8113824c:	1000061e 	bne	r2,zero,81138268 <OSTaskCreate+0x138>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
81138250:	d0a09003 	ldbu	r2,-32192(gp)
81138254:	10803fcc 	andi	r2,r2,255
81138258:	10800058 	cmpnei	r2,r2,1
8113825c:	1000151e 	bne	r2,zero,811382b4 <OSTaskCreate+0x184>
                OS_Sched();
81138260:	11326c80 	call	811326c8 <OS_Sched>
81138264:	00001306 	br	811382b4 <OSTaskCreate+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138268:	0005303a 	rdctl	r2,status
8113826c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138270:	e0fffa17 	ldw	r3,-24(fp)
81138274:	00bfff84 	movi	r2,-2
81138278:	1884703a 	and	r2,r3,r2
8113827c:	1001703a 	wrctl	status,r2
  
  return context;
81138280:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
81138284:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
81138288:	e0ffff03 	ldbu	r3,-4(fp)
8113828c:	00a045b4 	movhi	r2,33046
81138290:	1084d804 	addi	r2,r2,4960
81138294:	18c7883a 	add	r3,r3,r3
81138298:	18c7883a 	add	r3,r3,r3
8113829c:	10c5883a 	add	r2,r2,r3
811382a0:	10000015 	stw	zero,0(r2)
811382a4:	e0bff317 	ldw	r2,-52(fp)
811382a8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811382ac:	e0bff617 	ldw	r2,-40(fp)
811382b0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
811382b4:	e0bff803 	ldbu	r2,-32(fp)
811382b8:	00000506 	br	811382d0 <OSTaskCreate+0x1a0>
811382bc:	e0bff317 	ldw	r2,-52(fp)
811382c0:	e0bff915 	stw	r2,-28(fp)
811382c4:	e0bff917 	ldw	r2,-28(fp)
811382c8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
811382cc:	00800a04 	movi	r2,40
}
811382d0:	e037883a 	mov	sp,fp
811382d4:	dfc00117 	ldw	ra,4(sp)
811382d8:	df000017 	ldw	fp,0(sp)
811382dc:	dec00204 	addi	sp,sp,8
811382e0:	f800283a 	ret

811382e4 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
811382e4:	deffec04 	addi	sp,sp,-80
811382e8:	de00012e 	bgeu	sp,et,811382f0 <OSTaskCreateExt+0xc>
811382ec:	003b68fa 	trap	3
811382f0:	dfc01315 	stw	ra,76(sp)
811382f4:	df001215 	stw	fp,72(sp)
811382f8:	df001204 	addi	fp,sp,72
811382fc:	e13ffa15 	stw	r4,-24(fp)
81138300:	e17ffb15 	stw	r5,-20(fp)
81138304:	e1bffc15 	stw	r6,-16(fp)
81138308:	3809883a 	mov	r4,r7
8113830c:	e0c00217 	ldw	r3,8(fp)
81138310:	e0800617 	ldw	r2,24(fp)
81138314:	e13ffd05 	stb	r4,-12(fp)
81138318:	e0fffe0d 	sth	r3,-8(fp)
8113831c:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
81138320:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
81138324:	e0bffd03 	ldbu	r2,-12(fp)
81138328:	10800af0 	cmpltui	r2,r2,43
8113832c:	1000021e 	bne	r2,zero,81138338 <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
81138330:	00800a84 	movi	r2,42
81138334:	00006106 	br	811384bc <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138338:	0005303a 	rdctl	r2,status
8113833c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138340:	e0fff917 	ldw	r3,-28(fp)
81138344:	00bfff84 	movi	r2,-2
81138348:	1884703a 	and	r2,r3,r2
8113834c:	1001703a 	wrctl	status,r2
  
  return context;
81138350:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81138354:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
81138358:	d0a0a003 	ldbu	r2,-32128(gp)
8113835c:	10803fcc 	andi	r2,r2,255
81138360:	10000626 	beq	r2,zero,8113837c <OSTaskCreateExt+0x98>
81138364:	e0bff117 	ldw	r2,-60(fp)
81138368:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113836c:	e0bff217 	ldw	r2,-56(fp)
81138370:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
81138374:	00800f04 	movi	r2,60
81138378:	00005006 	br	811384bc <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113837c:	e0fffd03 	ldbu	r3,-12(fp)
81138380:	00a045b4 	movhi	r2,33046
81138384:	1084d804 	addi	r2,r2,4960
81138388:	18c7883a 	add	r3,r3,r3
8113838c:	18c7883a 	add	r3,r3,r3
81138390:	10c5883a 	add	r2,r2,r3
81138394:	10800017 	ldw	r2,0(r2)
81138398:	1000431e 	bne	r2,zero,811384a8 <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113839c:	e0fffd03 	ldbu	r3,-12(fp)
811383a0:	00a045b4 	movhi	r2,33046
811383a4:	1084d804 	addi	r2,r2,4960
811383a8:	18c7883a 	add	r3,r3,r3
811383ac:	18c7883a 	add	r3,r3,r3
811383b0:	10c5883a 	add	r2,r2,r3
811383b4:	00c00044 	movi	r3,1
811383b8:	10c00015 	stw	r3,0(r2)
811383bc:	e0bff117 	ldw	r2,-60(fp)
811383c0:	e0bff315 	stw	r2,-52(fp)
811383c4:	e0bff317 	ldw	r2,-52(fp)
811383c8:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
811383cc:	e0bfff0b 	ldhu	r2,-4(fp)
811383d0:	100d883a 	mov	r6,r2
811383d4:	e1400417 	ldw	r5,16(fp)
811383d8:	e1000317 	ldw	r4,12(fp)
811383dc:	113938c0 	call	8113938c <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
811383e0:	e0bfff0b 	ldhu	r2,-4(fp)
811383e4:	100f883a 	mov	r7,r2
811383e8:	e1bffc17 	ldw	r6,-16(fp)
811383ec:	e17ffb17 	ldw	r5,-20(fp)
811383f0:	e13ffa17 	ldw	r4,-24(fp)
811383f4:	11438500 	call	81143850 <OSTaskStkInit>
811383f8:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
811383fc:	e0fffd03 	ldbu	r3,-12(fp)
81138400:	e13ffe0b 	ldhu	r4,-8(fp)
81138404:	e0bfff0b 	ldhu	r2,-4(fp)
81138408:	d8800215 	stw	r2,8(sp)
8113840c:	e0800517 	ldw	r2,20(fp)
81138410:	d8800115 	stw	r2,4(sp)
81138414:	e0800417 	ldw	r2,16(fp)
81138418:	d8800015 	stw	r2,0(sp)
8113841c:	200f883a 	mov	r7,r4
81138420:	e1800317 	ldw	r6,12(fp)
81138424:	e17ff517 	ldw	r5,-44(fp)
81138428:	1809883a 	mov	r4,r3
8113842c:	1132b100 	call	81132b10 <OS_TCBInit>
81138430:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
81138434:	e0bff603 	ldbu	r2,-40(fp)
81138438:	1000061e 	bne	r2,zero,81138454 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
8113843c:	d0a09003 	ldbu	r2,-32192(gp)
81138440:	10803fcc 	andi	r2,r2,255
81138444:	10800058 	cmpnei	r2,r2,1
81138448:	1000151e 	bne	r2,zero,811384a0 <OSTaskCreateExt+0x1bc>
                OS_Sched();
8113844c:	11326c80 	call	811326c8 <OS_Sched>
81138450:	00001306 	br	811384a0 <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138454:	0005303a 	rdctl	r2,status
81138458:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113845c:	e0fff817 	ldw	r3,-32(fp)
81138460:	00bfff84 	movi	r2,-2
81138464:	1884703a 	and	r2,r3,r2
81138468:	1001703a 	wrctl	status,r2
  
  return context;
8113846c:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
81138470:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
81138474:	e0fffd03 	ldbu	r3,-12(fp)
81138478:	00a045b4 	movhi	r2,33046
8113847c:	1084d804 	addi	r2,r2,4960
81138480:	18c7883a 	add	r3,r3,r3
81138484:	18c7883a 	add	r3,r3,r3
81138488:	10c5883a 	add	r2,r2,r3
8113848c:	10000015 	stw	zero,0(r2)
81138490:	e0bff117 	ldw	r2,-60(fp)
81138494:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138498:	e0bff417 	ldw	r2,-48(fp)
8113849c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
811384a0:	e0bff603 	ldbu	r2,-40(fp)
811384a4:	00000506 	br	811384bc <OSTaskCreateExt+0x1d8>
811384a8:	e0bff117 	ldw	r2,-60(fp)
811384ac:	e0bff715 	stw	r2,-36(fp)
811384b0:	e0bff717 	ldw	r2,-36(fp)
811384b4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
811384b8:	00800a04 	movi	r2,40
}
811384bc:	e037883a 	mov	sp,fp
811384c0:	dfc00117 	ldw	ra,4(sp)
811384c4:	df000017 	ldw	fp,0(sp)
811384c8:	dec00204 	addi	sp,sp,8
811384cc:	f800283a 	ret

811384d0 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
811384d0:	defff404 	addi	sp,sp,-48
811384d4:	de00012e 	bgeu	sp,et,811384dc <OSTaskDel+0xc>
811384d8:	003b68fa 	trap	3
811384dc:	dfc00b15 	stw	ra,44(sp)
811384e0:	df000a15 	stw	fp,40(sp)
811384e4:	df000a04 	addi	fp,sp,40
811384e8:	2005883a 	mov	r2,r4
811384ec:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
811384f0:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
811384f4:	d0a0a003 	ldbu	r2,-32128(gp)
811384f8:	10803fcc 	andi	r2,r2,255
811384fc:	10000226 	beq	r2,zero,81138508 <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
81138500:	00801004 	movi	r2,64
81138504:	0000c006 	br	81138808 <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
81138508:	e0bfff03 	ldbu	r2,-4(fp)
8113850c:	10800a98 	cmpnei	r2,r2,42
81138510:	1000021e 	bne	r2,zero,8113851c <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
81138514:	00800f84 	movi	r2,62
81138518:	0000bb06 	br	81138808 <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
8113851c:	e0bfff03 	ldbu	r2,-4(fp)
81138520:	10800ab0 	cmpltui	r2,r2,42
81138524:	1000051e 	bne	r2,zero,8113853c <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
81138528:	e0bfff03 	ldbu	r2,-4(fp)
8113852c:	10803fe0 	cmpeqi	r2,r2,255
81138530:	1000021e 	bne	r2,zero,8113853c <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
81138534:	00800a84 	movi	r2,42
81138538:	0000b306 	br	81138808 <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113853c:	0005303a 	rdctl	r2,status
81138540:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138544:	e0fffe17 	ldw	r3,-8(fp)
81138548:	00bfff84 	movi	r2,-2
8113854c:	1884703a 	and	r2,r3,r2
81138550:	1001703a 	wrctl	status,r2
  
  return context;
81138554:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
81138558:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
8113855c:	e0bfff03 	ldbu	r2,-4(fp)
81138560:	10803fd8 	cmpnei	r2,r2,255
81138564:	1000031e 	bne	r2,zero,81138574 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
81138568:	d0a0a117 	ldw	r2,-32124(gp)
8113856c:	10800c83 	ldbu	r2,50(r2)
81138570:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81138574:	e0ffff03 	ldbu	r3,-4(fp)
81138578:	00a045b4 	movhi	r2,33046
8113857c:	1084d804 	addi	r2,r2,4960
81138580:	18c7883a 	add	r3,r3,r3
81138584:	18c7883a 	add	r3,r3,r3
81138588:	10c5883a 	add	r2,r2,r3
8113858c:	10800017 	ldw	r2,0(r2)
81138590:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
81138594:	e0bff817 	ldw	r2,-32(fp)
81138598:	1000061e 	bne	r2,zero,811385b4 <OSTaskDel+0xe4>
8113859c:	e0bff617 	ldw	r2,-40(fp)
811385a0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811385a4:	e0bff717 	ldw	r2,-36(fp)
811385a8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
811385ac:	008010c4 	movi	r2,67
811385b0:	00009506 	br	81138808 <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
811385b4:	e0bff817 	ldw	r2,-32(fp)
811385b8:	10800058 	cmpnei	r2,r2,1
811385bc:	1000061e 	bne	r2,zero,811385d8 <OSTaskDel+0x108>
811385c0:	e0bff617 	ldw	r2,-40(fp)
811385c4:	e0bff915 	stw	r2,-28(fp)
811385c8:	e0bff917 	ldw	r2,-28(fp)
811385cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
811385d0:	00800f44 	movi	r2,61
811385d4:	00008c06 	br	81138808 <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
811385d8:	e0bff817 	ldw	r2,-32(fp)
811385dc:	10800d03 	ldbu	r2,52(r2)
811385e0:	10c03fcc 	andi	r3,r2,255
811385e4:	e0bff817 	ldw	r2,-32(fp)
811385e8:	10800d03 	ldbu	r2,52(r2)
811385ec:	11003fcc 	andi	r4,r2,255
811385f0:	d0a09d44 	addi	r2,gp,-32139
811385f4:	2085883a 	add	r2,r4,r2
811385f8:	10800003 	ldbu	r2,0(r2)
811385fc:	1009883a 	mov	r4,r2
81138600:	e0bff817 	ldw	r2,-32(fp)
81138604:	10800d43 	ldbu	r2,53(r2)
81138608:	0084303a 	nor	r2,zero,r2
8113860c:	2084703a 	and	r2,r4,r2
81138610:	1009883a 	mov	r4,r2
81138614:	d0a09d44 	addi	r2,gp,-32139
81138618:	1885883a 	add	r2,r3,r2
8113861c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
81138620:	e0bff817 	ldw	r2,-32(fp)
81138624:	10800d03 	ldbu	r2,52(r2)
81138628:	10c03fcc 	andi	r3,r2,255
8113862c:	d0a09d44 	addi	r2,gp,-32139
81138630:	1885883a 	add	r2,r3,r2
81138634:	10800003 	ldbu	r2,0(r2)
81138638:	10803fcc 	andi	r2,r2,255
8113863c:	1000071e 	bne	r2,zero,8113865c <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
81138640:	e0bff817 	ldw	r2,-32(fp)
81138644:	10800d83 	ldbu	r2,54(r2)
81138648:	0084303a 	nor	r2,zero,r2
8113864c:	1007883a 	mov	r3,r2
81138650:	d0a09d03 	ldbu	r2,-32140(gp)
81138654:	1884703a 	and	r2,r3,r2
81138658:	d0a09d05 	stb	r2,-32140(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
8113865c:	e0bff817 	ldw	r2,-32(fp)
81138660:	10800717 	ldw	r2,28(r2)
81138664:	10000526 	beq	r2,zero,8113867c <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
81138668:	e0bff817 	ldw	r2,-32(fp)
8113866c:	10800717 	ldw	r2,28(r2)
81138670:	100b883a 	mov	r5,r2
81138674:	e13ff817 	ldw	r4,-32(fp)
81138678:	113201c0 	call	8113201c <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
8113867c:	e0bff817 	ldw	r2,-32(fp)
81138680:	10800817 	ldw	r2,32(r2)
81138684:	10000526 	beq	r2,zero,8113869c <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
81138688:	e0bff817 	ldw	r2,-32(fp)
8113868c:	10800817 	ldw	r2,32(r2)
81138690:	100b883a 	mov	r5,r2
81138694:	e13ff817 	ldw	r4,-32(fp)
81138698:	11320dc0 	call	811320dc <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
8113869c:	e0bff817 	ldw	r2,-32(fp)
811386a0:	10800a17 	ldw	r2,40(r2)
811386a4:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
811386a8:	e0bffb17 	ldw	r2,-20(fp)
811386ac:	10000226 	beq	r2,zero,811386b8 <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
811386b0:	e13ffb17 	ldw	r4,-20(fp)
811386b4:	11346b40 	call	811346b4 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
811386b8:	e0bff817 	ldw	r2,-32(fp)
811386bc:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
811386c0:	e0bff817 	ldw	r2,-32(fp)
811386c4:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
811386c8:	e0bff817 	ldw	r2,-32(fp)
811386cc:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
811386d0:	d0a08e03 	ldbu	r2,-32200(gp)
811386d4:	10803fcc 	andi	r2,r2,255
811386d8:	10803fe0 	cmpeqi	r2,r2,255
811386dc:	1000031e 	bne	r2,zero,811386ec <OSTaskDel+0x21c>
        OSLockNesting++;
811386e0:	d0a08e03 	ldbu	r2,-32200(gp)
811386e4:	10800044 	addi	r2,r2,1
811386e8:	d0a08e05 	stb	r2,-32200(gp)
811386ec:	e0bff617 	ldw	r2,-40(fp)
811386f0:	e0bffd15 	stw	r2,-12(fp)
811386f4:	e0bffd17 	ldw	r2,-12(fp)
811386f8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
811386fc:	1131be40 	call	81131be4 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138700:	0005303a 	rdctl	r2,status
81138704:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138708:	e0fffa17 	ldw	r3,-24(fp)
8113870c:	00bfff84 	movi	r2,-2
81138710:	1884703a 	and	r2,r3,r2
81138714:	1001703a 	wrctl	status,r2
  
  return context;
81138718:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
8113871c:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
81138720:	d0a08e03 	ldbu	r2,-32200(gp)
81138724:	10803fcc 	andi	r2,r2,255
81138728:	10000326 	beq	r2,zero,81138738 <OSTaskDel+0x268>
        OSLockNesting--;
8113872c:	d0a08e03 	ldbu	r2,-32200(gp)
81138730:	10bfffc4 	addi	r2,r2,-1
81138734:	d0a08e05 	stb	r2,-32200(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
81138738:	e13ff817 	ldw	r4,-32(fp)
8113873c:	11439e00 	call	811439e0 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
81138740:	d0a09943 	ldbu	r2,-32155(gp)
81138744:	10bfffc4 	addi	r2,r2,-1
81138748:	d0a09945 	stb	r2,-32155(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
8113874c:	e0ffff03 	ldbu	r3,-4(fp)
81138750:	00a045b4 	movhi	r2,33046
81138754:	1084d804 	addi	r2,r2,4960
81138758:	18c7883a 	add	r3,r3,r3
8113875c:	18c7883a 	add	r3,r3,r3
81138760:	10c5883a 	add	r2,r2,r3
81138764:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
81138768:	e0bff817 	ldw	r2,-32(fp)
8113876c:	10800617 	ldw	r2,24(r2)
81138770:	1000071e 	bne	r2,zero,81138790 <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
81138774:	e0bff817 	ldw	r2,-32(fp)
81138778:	10800517 	ldw	r2,20(r2)
8113877c:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
81138780:	e0bff817 	ldw	r2,-32(fp)
81138784:	10800517 	ldw	r2,20(r2)
81138788:	d0a09315 	stw	r2,-32180(gp)
8113878c:	00000a06 	br	811387b8 <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
81138790:	e0bff817 	ldw	r2,-32(fp)
81138794:	10800617 	ldw	r2,24(r2)
81138798:	e0fff817 	ldw	r3,-32(fp)
8113879c:	18c00517 	ldw	r3,20(r3)
811387a0:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
811387a4:	e0bff817 	ldw	r2,-32(fp)
811387a8:	10800517 	ldw	r2,20(r2)
811387ac:	e0fff817 	ldw	r3,-32(fp)
811387b0:	18c00617 	ldw	r3,24(r3)
811387b4:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
811387b8:	d0e09817 	ldw	r3,-32160(gp)
811387bc:	e0bff817 	ldw	r2,-32(fp)
811387c0:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
811387c4:	e0bff817 	ldw	r2,-32(fp)
811387c8:	d0a09815 	stw	r2,-32160(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
811387cc:	e0bff817 	ldw	r2,-32(fp)
811387d0:	00c00fc4 	movi	r3,63
811387d4:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
811387d8:	e0bff817 	ldw	r2,-32(fp)
811387dc:	10001345 	stb	zero,77(r2)
811387e0:	e0bff617 	ldw	r2,-40(fp)
811387e4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811387e8:	e0bffc17 	ldw	r2,-16(fp)
811387ec:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
811387f0:	d0a09003 	ldbu	r2,-32192(gp)
811387f4:	10803fcc 	andi	r2,r2,255
811387f8:	10800058 	cmpnei	r2,r2,1
811387fc:	1000011e 	bne	r2,zero,81138804 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
81138800:	11326c80 	call	811326c8 <OS_Sched>
    }
    return (OS_ERR_NONE);
81138804:	0005883a 	mov	r2,zero
}
81138808:	e037883a 	mov	sp,fp
8113880c:	dfc00117 	ldw	ra,4(sp)
81138810:	df000017 	ldw	fp,0(sp)
81138814:	dec00204 	addi	sp,sp,8
81138818:	f800283a 	ret

8113881c <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
8113881c:	defff504 	addi	sp,sp,-44
81138820:	de00012e 	bgeu	sp,et,81138828 <OSTaskDelReq+0xc>
81138824:	003b68fa 	trap	3
81138828:	df000a15 	stw	fp,40(sp)
8113882c:	df000a04 	addi	fp,sp,40
81138830:	2005883a 	mov	r2,r4
81138834:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138838:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
8113883c:	e0bfff03 	ldbu	r2,-4(fp)
81138840:	10800a98 	cmpnei	r2,r2,42
81138844:	1000021e 	bne	r2,zero,81138850 <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
81138848:	00800f84 	movi	r2,62
8113884c:	00004506 	br	81138964 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
81138850:	e0bfff03 	ldbu	r2,-4(fp)
81138854:	10800ab0 	cmpltui	r2,r2,42
81138858:	1000051e 	bne	r2,zero,81138870 <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
8113885c:	e0bfff03 	ldbu	r2,-4(fp)
81138860:	10803fe0 	cmpeqi	r2,r2,255
81138864:	1000021e 	bne	r2,zero,81138870 <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
81138868:	00800a84 	movi	r2,42
8113886c:	00003d06 	br	81138964 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
81138870:	e0bfff03 	ldbu	r2,-4(fp)
81138874:	10803fd8 	cmpnei	r2,r2,255
81138878:	1000111e 	bne	r2,zero,811388c0 <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113887c:	0005303a 	rdctl	r2,status
81138880:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138884:	e0fff917 	ldw	r3,-28(fp)
81138888:	00bfff84 	movi	r2,-2
8113888c:	1884703a 	and	r2,r3,r2
81138890:	1001703a 	wrctl	status,r2
  
  return context;
81138894:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
81138898:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
8113889c:	d0a0a117 	ldw	r2,-32124(gp)
811388a0:	10800dc3 	ldbu	r2,55(r2)
811388a4:	e0bff805 	stb	r2,-32(fp)
811388a8:	e0bff617 	ldw	r2,-40(fp)
811388ac:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811388b0:	e0bffe17 	ldw	r2,-8(fp)
811388b4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
811388b8:	e0bff803 	ldbu	r2,-32(fp)
811388bc:	00002906 	br	81138964 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811388c0:	0005303a 	rdctl	r2,status
811388c4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811388c8:	e0fff717 	ldw	r3,-36(fp)
811388cc:	00bfff84 	movi	r2,-2
811388d0:	1884703a 	and	r2,r3,r2
811388d4:	1001703a 	wrctl	status,r2
  
  return context;
811388d8:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
811388dc:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
811388e0:	e0ffff03 	ldbu	r3,-4(fp)
811388e4:	00a045b4 	movhi	r2,33046
811388e8:	1084d804 	addi	r2,r2,4960
811388ec:	18c7883a 	add	r3,r3,r3
811388f0:	18c7883a 	add	r3,r3,r3
811388f4:	10c5883a 	add	r2,r2,r3
811388f8:	10800017 	ldw	r2,0(r2)
811388fc:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
81138900:	e0bffb17 	ldw	r2,-20(fp)
81138904:	1000061e 	bne	r2,zero,81138920 <OSTaskDelReq+0x104>
81138908:	e0bff617 	ldw	r2,-40(fp)
8113890c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138910:	e0bffa17 	ldw	r2,-24(fp)
81138914:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
81138918:	008010c4 	movi	r2,67
8113891c:	00001106 	br	81138964 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
81138920:	e0bffb17 	ldw	r2,-20(fp)
81138924:	10800058 	cmpnei	r2,r2,1
81138928:	1000061e 	bne	r2,zero,81138944 <OSTaskDelReq+0x128>
8113892c:	e0bff617 	ldw	r2,-40(fp)
81138930:	e0bffc15 	stw	r2,-16(fp)
81138934:	e0bffc17 	ldw	r2,-16(fp)
81138938:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113893c:	00800f44 	movi	r2,61
81138940:	00000806 	br	81138964 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
81138944:	e0bffb17 	ldw	r2,-20(fp)
81138948:	00c00fc4 	movi	r3,63
8113894c:	10c00dc5 	stb	r3,55(r2)
81138950:	e0bff617 	ldw	r2,-40(fp)
81138954:	e0bffd15 	stw	r2,-12(fp)
81138958:	e0bffd17 	ldw	r2,-12(fp)
8113895c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81138960:	0005883a 	mov	r2,zero
}
81138964:	e037883a 	mov	sp,fp
81138968:	df000017 	ldw	fp,0(sp)
8113896c:	dec00104 	addi	sp,sp,4
81138970:	f800283a 	ret

81138974 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
81138974:	defff404 	addi	sp,sp,-48
81138978:	de00012e 	bgeu	sp,et,81138980 <OSTaskNameGet+0xc>
8113897c:	003b68fa 	trap	3
81138980:	dfc00b15 	stw	ra,44(sp)
81138984:	df000a15 	stw	fp,40(sp)
81138988:	df000a04 	addi	fp,sp,40
8113898c:	2005883a 	mov	r2,r4
81138990:	e17ffe15 	stw	r5,-8(fp)
81138994:	e1bfff15 	stw	r6,-4(fp)
81138998:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
8113899c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
811389a0:	e0bfff17 	ldw	r2,-4(fp)
811389a4:	1000021e 	bne	r2,zero,811389b0 <OSTaskNameGet+0x3c>
        return (0);
811389a8:	0005883a 	mov	r2,zero
811389ac:	00005406 	br	81138b00 <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
811389b0:	e0bffd03 	ldbu	r2,-12(fp)
811389b4:	10800af0 	cmpltui	r2,r2,43
811389b8:	1000081e 	bne	r2,zero,811389dc <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
811389bc:	e0bffd03 	ldbu	r2,-12(fp)
811389c0:	10803fe0 	cmpeqi	r2,r2,255
811389c4:	1000051e 	bne	r2,zero,811389dc <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
811389c8:	e0bfff17 	ldw	r2,-4(fp)
811389cc:	00c00a84 	movi	r3,42
811389d0:	10c00005 	stb	r3,0(r2)
            return (0);
811389d4:	0005883a 	mov	r2,zero
811389d8:	00004906 	br	81138b00 <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
811389dc:	e0bffe17 	ldw	r2,-8(fp)
811389e0:	1000051e 	bne	r2,zero,811389f8 <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
811389e4:	e0bfff17 	ldw	r2,-4(fp)
811389e8:	00c00304 	movi	r3,12
811389ec:	10c00005 	stb	r3,0(r2)
        return (0);
811389f0:	0005883a 	mov	r2,zero
811389f4:	00004206 	br	81138b00 <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
811389f8:	d0a0a003 	ldbu	r2,-32128(gp)
811389fc:	10803fcc 	andi	r2,r2,255
81138a00:	10000526 	beq	r2,zero,81138a18 <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
81138a04:	e0bfff17 	ldw	r2,-4(fp)
81138a08:	00c00444 	movi	r3,17
81138a0c:	10c00005 	stb	r3,0(r2)
        return (0);
81138a10:	0005883a 	mov	r2,zero
81138a14:	00003a06 	br	81138b00 <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138a18:	0005303a 	rdctl	r2,status
81138a1c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138a20:	e0fffc17 	ldw	r3,-16(fp)
81138a24:	00bfff84 	movi	r2,-2
81138a28:	1884703a 	and	r2,r3,r2
81138a2c:	1001703a 	wrctl	status,r2
  
  return context;
81138a30:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81138a34:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
81138a38:	e0bffd03 	ldbu	r2,-12(fp)
81138a3c:	10803fd8 	cmpnei	r2,r2,255
81138a40:	1000031e 	bne	r2,zero,81138a50 <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
81138a44:	d0a0a117 	ldw	r2,-32124(gp)
81138a48:	10800c83 	ldbu	r2,50(r2)
81138a4c:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81138a50:	e0fffd03 	ldbu	r3,-12(fp)
81138a54:	00a045b4 	movhi	r2,33046
81138a58:	1084d804 	addi	r2,r2,4960
81138a5c:	18c7883a 	add	r3,r3,r3
81138a60:	18c7883a 	add	r3,r3,r3
81138a64:	10c5883a 	add	r2,r2,r3
81138a68:	10800017 	ldw	r2,0(r2)
81138a6c:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
81138a70:	e0bff817 	ldw	r2,-32(fp)
81138a74:	1000091e 	bne	r2,zero,81138a9c <OSTaskNameGet+0x128>
81138a78:	e0bff617 	ldw	r2,-40(fp)
81138a7c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138a80:	e0bff717 	ldw	r2,-36(fp)
81138a84:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
81138a88:	e0bfff17 	ldw	r2,-4(fp)
81138a8c:	00c010c4 	movi	r3,67
81138a90:	10c00005 	stb	r3,0(r2)
        return (0);
81138a94:	0005883a 	mov	r2,zero
81138a98:	00001906 	br	81138b00 <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
81138a9c:	e0bff817 	ldw	r2,-32(fp)
81138aa0:	10800058 	cmpnei	r2,r2,1
81138aa4:	1000091e 	bne	r2,zero,81138acc <OSTaskNameGet+0x158>
81138aa8:	e0bff617 	ldw	r2,-40(fp)
81138aac:	e0bff915 	stw	r2,-28(fp)
81138ab0:	e0bff917 	ldw	r2,-28(fp)
81138ab4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
81138ab8:	e0bfff17 	ldw	r2,-4(fp)
81138abc:	00c010c4 	movi	r3,67
81138ac0:	10c00005 	stb	r3,0(r2)
        return (0);
81138ac4:	0005883a 	mov	r2,zero
81138ac8:	00000d06 	br	81138b00 <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
81138acc:	e0bff817 	ldw	r2,-32(fp)
81138ad0:	10801304 	addi	r2,r2,76
81138ad4:	100b883a 	mov	r5,r2
81138ad8:	e13ffe17 	ldw	r4,-8(fp)
81138adc:	113281c0 	call	8113281c <OS_StrCopy>
81138ae0:	e0bffb05 	stb	r2,-20(fp)
81138ae4:	e0bff617 	ldw	r2,-40(fp)
81138ae8:	e0bffa15 	stw	r2,-24(fp)
81138aec:	e0bffa17 	ldw	r2,-24(fp)
81138af0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81138af4:	e0bfff17 	ldw	r2,-4(fp)
81138af8:	10000005 	stb	zero,0(r2)
    return (len);
81138afc:	e0bffb03 	ldbu	r2,-20(fp)
}
81138b00:	e037883a 	mov	sp,fp
81138b04:	dfc00117 	ldw	ra,4(sp)
81138b08:	df000017 	ldw	fp,0(sp)
81138b0c:	dec00204 	addi	sp,sp,8
81138b10:	f800283a 	ret

81138b14 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
81138b14:	defff304 	addi	sp,sp,-52
81138b18:	de00012e 	bgeu	sp,et,81138b20 <OSTaskNameSet+0xc>
81138b1c:	003b68fa 	trap	3
81138b20:	dfc00c15 	stw	ra,48(sp)
81138b24:	df000b15 	stw	fp,44(sp)
81138b28:	df000b04 	addi	fp,sp,44
81138b2c:	2005883a 	mov	r2,r4
81138b30:	e17ffe15 	stw	r5,-8(fp)
81138b34:	e1bfff15 	stw	r6,-4(fp)
81138b38:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
81138b3c:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
81138b40:	e0bfff17 	ldw	r2,-4(fp)
81138b44:	10005c26 	beq	r2,zero,81138cb8 <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
81138b48:	e0bffd03 	ldbu	r2,-12(fp)
81138b4c:	10800af0 	cmpltui	r2,r2,43
81138b50:	1000071e 	bne	r2,zero,81138b70 <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
81138b54:	e0bffd03 	ldbu	r2,-12(fp)
81138b58:	10803fe0 	cmpeqi	r2,r2,255
81138b5c:	1000041e 	bne	r2,zero,81138b70 <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
81138b60:	e0bfff17 	ldw	r2,-4(fp)
81138b64:	00c00a84 	movi	r3,42
81138b68:	10c00005 	stb	r3,0(r2)
            return;
81138b6c:	00005306 	br	81138cbc <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
81138b70:	e0bffe17 	ldw	r2,-8(fp)
81138b74:	1000041e 	bne	r2,zero,81138b88 <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
81138b78:	e0bfff17 	ldw	r2,-4(fp)
81138b7c:	00c00304 	movi	r3,12
81138b80:	10c00005 	stb	r3,0(r2)
        return;
81138b84:	00004d06 	br	81138cbc <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
81138b88:	d0a0a003 	ldbu	r2,-32128(gp)
81138b8c:	10803fcc 	andi	r2,r2,255
81138b90:	10000426 	beq	r2,zero,81138ba4 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
81138b94:	e0bfff17 	ldw	r2,-4(fp)
81138b98:	00c00484 	movi	r3,18
81138b9c:	10c00005 	stb	r3,0(r2)
        return;
81138ba0:	00004606 	br	81138cbc <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138ba4:	0005303a 	rdctl	r2,status
81138ba8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138bac:	e0fffc17 	ldw	r3,-16(fp)
81138bb0:	00bfff84 	movi	r2,-2
81138bb4:	1884703a 	and	r2,r3,r2
81138bb8:	1001703a 	wrctl	status,r2
  
  return context;
81138bbc:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81138bc0:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
81138bc4:	e0bffd03 	ldbu	r2,-12(fp)
81138bc8:	10803fd8 	cmpnei	r2,r2,255
81138bcc:	1000031e 	bne	r2,zero,81138bdc <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
81138bd0:	d0a0a117 	ldw	r2,-32124(gp)
81138bd4:	10800c83 	ldbu	r2,50(r2)
81138bd8:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81138bdc:	e0fffd03 	ldbu	r3,-12(fp)
81138be0:	00a045b4 	movhi	r2,33046
81138be4:	1084d804 	addi	r2,r2,4960
81138be8:	18c7883a 	add	r3,r3,r3
81138bec:	18c7883a 	add	r3,r3,r3
81138bf0:	10c5883a 	add	r2,r2,r3
81138bf4:	10800017 	ldw	r2,0(r2)
81138bf8:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
81138bfc:	e0bff717 	ldw	r2,-36(fp)
81138c00:	1000081e 	bne	r2,zero,81138c24 <OSTaskNameSet+0x110>
81138c04:	e0bff517 	ldw	r2,-44(fp)
81138c08:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138c0c:	e0bff617 	ldw	r2,-40(fp)
81138c10:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
81138c14:	e0bfff17 	ldw	r2,-4(fp)
81138c18:	00c010c4 	movi	r3,67
81138c1c:	10c00005 	stb	r3,0(r2)
        return;
81138c20:	00002606 	br	81138cbc <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
81138c24:	e0bff717 	ldw	r2,-36(fp)
81138c28:	10800058 	cmpnei	r2,r2,1
81138c2c:	1000081e 	bne	r2,zero,81138c50 <OSTaskNameSet+0x13c>
81138c30:	e0bff517 	ldw	r2,-44(fp)
81138c34:	e0bff815 	stw	r2,-32(fp)
81138c38:	e0bff817 	ldw	r2,-32(fp)
81138c3c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
81138c40:	e0bfff17 	ldw	r2,-4(fp)
81138c44:	00c010c4 	movi	r3,67
81138c48:	10c00005 	stb	r3,0(r2)
        return;
81138c4c:	00001b06 	br	81138cbc <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
81138c50:	e13ffe17 	ldw	r4,-8(fp)
81138c54:	11328980 	call	81132898 <OS_StrLen>
81138c58:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
81138c5c:	e0bffa03 	ldbu	r2,-24(fp)
81138c60:	10800830 	cmpltui	r2,r2,32
81138c64:	1000081e 	bne	r2,zero,81138c88 <OSTaskNameSet+0x174>
81138c68:	e0bff517 	ldw	r2,-44(fp)
81138c6c:	e0bff915 	stw	r2,-28(fp)
81138c70:	e0bff917 	ldw	r2,-28(fp)
81138c74:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
81138c78:	e0bfff17 	ldw	r2,-4(fp)
81138c7c:	00c01044 	movi	r3,65
81138c80:	10c00005 	stb	r3,0(r2)
        return;
81138c84:	00000d06 	br	81138cbc <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
81138c88:	e0bff717 	ldw	r2,-36(fp)
81138c8c:	10801304 	addi	r2,r2,76
81138c90:	e17ffe17 	ldw	r5,-8(fp)
81138c94:	1009883a 	mov	r4,r2
81138c98:	113281c0 	call	8113281c <OS_StrCopy>
81138c9c:	e0bff517 	ldw	r2,-44(fp)
81138ca0:	e0bffb15 	stw	r2,-20(fp)
81138ca4:	e0bffb17 	ldw	r2,-20(fp)
81138ca8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81138cac:	e0bfff17 	ldw	r2,-4(fp)
81138cb0:	10000005 	stb	zero,0(r2)
81138cb4:	00000106 	br	81138cbc <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
81138cb8:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81138cbc:	e037883a 	mov	sp,fp
81138cc0:	dfc00117 	ldw	ra,4(sp)
81138cc4:	df000017 	ldw	fp,0(sp)
81138cc8:	dec00204 	addi	sp,sp,8
81138ccc:	f800283a 	ret

81138cd0 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
81138cd0:	defff404 	addi	sp,sp,-48
81138cd4:	de00012e 	bgeu	sp,et,81138cdc <OSTaskResume+0xc>
81138cd8:	003b68fa 	trap	3
81138cdc:	dfc00b15 	stw	ra,44(sp)
81138ce0:	df000a15 	stw	fp,40(sp)
81138ce4:	df000a04 	addi	fp,sp,40
81138ce8:	2005883a 	mov	r2,r4
81138cec:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
81138cf0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
81138cf4:	e0bfff03 	ldbu	r2,-4(fp)
81138cf8:	10800ab0 	cmpltui	r2,r2,42
81138cfc:	1000021e 	bne	r2,zero,81138d08 <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
81138d00:	00800a84 	movi	r2,42
81138d04:	00006406 	br	81138e98 <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138d08:	0005303a 	rdctl	r2,status
81138d0c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138d10:	e0fffe17 	ldw	r3,-8(fp)
81138d14:	00bfff84 	movi	r2,-2
81138d18:	1884703a 	and	r2,r3,r2
81138d1c:	1001703a 	wrctl	status,r2
  
  return context;
81138d20:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81138d24:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
81138d28:	e0ffff03 	ldbu	r3,-4(fp)
81138d2c:	00a045b4 	movhi	r2,33046
81138d30:	1084d804 	addi	r2,r2,4960
81138d34:	18c7883a 	add	r3,r3,r3
81138d38:	18c7883a 	add	r3,r3,r3
81138d3c:	10c5883a 	add	r2,r2,r3
81138d40:	10800017 	ldw	r2,0(r2)
81138d44:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
81138d48:	e0bff817 	ldw	r2,-32(fp)
81138d4c:	1000061e 	bne	r2,zero,81138d68 <OSTaskResume+0x98>
81138d50:	e0bff617 	ldw	r2,-40(fp)
81138d54:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138d58:	e0bff717 	ldw	r2,-36(fp)
81138d5c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
81138d60:	00801184 	movi	r2,70
81138d64:	00004c06 	br	81138e98 <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
81138d68:	e0bff817 	ldw	r2,-32(fp)
81138d6c:	10800058 	cmpnei	r2,r2,1
81138d70:	1000061e 	bne	r2,zero,81138d8c <OSTaskResume+0xbc>
81138d74:	e0bff617 	ldw	r2,-40(fp)
81138d78:	e0bff915 	stw	r2,-28(fp)
81138d7c:	e0bff917 	ldw	r2,-28(fp)
81138d80:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81138d84:	008010c4 	movi	r2,67
81138d88:	00004306 	br	81138e98 <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
81138d8c:	e0bff817 	ldw	r2,-32(fp)
81138d90:	10800c03 	ldbu	r2,48(r2)
81138d94:	10803fcc 	andi	r2,r2,255
81138d98:	1080020c 	andi	r2,r2,8
81138d9c:	10003926 	beq	r2,zero,81138e84 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
81138da0:	e0bff817 	ldw	r2,-32(fp)
81138da4:	10c00c03 	ldbu	r3,48(r2)
81138da8:	00bffdc4 	movi	r2,-9
81138dac:	1884703a 	and	r2,r3,r2
81138db0:	1007883a 	mov	r3,r2
81138db4:	e0bff817 	ldw	r2,-32(fp)
81138db8:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
81138dbc:	e0bff817 	ldw	r2,-32(fp)
81138dc0:	10800c03 	ldbu	r2,48(r2)
81138dc4:	10803fcc 	andi	r2,r2,255
81138dc8:	1000281e 	bne	r2,zero,81138e6c <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
81138dcc:	e0bff817 	ldw	r2,-32(fp)
81138dd0:	10800b8b 	ldhu	r2,46(r2)
81138dd4:	10bfffcc 	andi	r2,r2,65535
81138dd8:	10001f1e 	bne	r2,zero,81138e58 <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
81138ddc:	e0bff817 	ldw	r2,-32(fp)
81138de0:	10c00d83 	ldbu	r3,54(r2)
81138de4:	d0a09d03 	ldbu	r2,-32140(gp)
81138de8:	1884b03a 	or	r2,r3,r2
81138dec:	d0a09d05 	stb	r2,-32140(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81138df0:	e0bff817 	ldw	r2,-32(fp)
81138df4:	10800d03 	ldbu	r2,52(r2)
81138df8:	10c03fcc 	andi	r3,r2,255
81138dfc:	e0bff817 	ldw	r2,-32(fp)
81138e00:	10800d03 	ldbu	r2,52(r2)
81138e04:	11003fcc 	andi	r4,r2,255
81138e08:	d0a09d44 	addi	r2,gp,-32139
81138e0c:	2085883a 	add	r2,r4,r2
81138e10:	11000003 	ldbu	r4,0(r2)
81138e14:	e0bff817 	ldw	r2,-32(fp)
81138e18:	10800d43 	ldbu	r2,53(r2)
81138e1c:	2084b03a 	or	r2,r4,r2
81138e20:	1009883a 	mov	r4,r2
81138e24:	d0a09d44 	addi	r2,gp,-32139
81138e28:	1885883a 	add	r2,r3,r2
81138e2c:	11000005 	stb	r4,0(r2)
81138e30:	e0bff617 	ldw	r2,-40(fp)
81138e34:	e0bffa15 	stw	r2,-24(fp)
81138e38:	e0bffa17 	ldw	r2,-24(fp)
81138e3c:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
81138e40:	d0a09003 	ldbu	r2,-32192(gp)
81138e44:	10803fcc 	andi	r2,r2,255
81138e48:	10800058 	cmpnei	r2,r2,1
81138e4c:	10000b1e 	bne	r2,zero,81138e7c <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
81138e50:	11326c80 	call	811326c8 <OS_Sched>
81138e54:	00000906 	br	81138e7c <OSTaskResume+0x1ac>
81138e58:	e0bff617 	ldw	r2,-40(fp)
81138e5c:	e0bffb15 	stw	r2,-20(fp)
81138e60:	e0bffb17 	ldw	r2,-20(fp)
81138e64:	1001703a 	wrctl	status,r2
81138e68:	00000406 	br	81138e7c <OSTaskResume+0x1ac>
81138e6c:	e0bff617 	ldw	r2,-40(fp)
81138e70:	e0bffc15 	stw	r2,-16(fp)
81138e74:	e0bffc17 	ldw	r2,-16(fp)
81138e78:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
81138e7c:	0005883a 	mov	r2,zero
81138e80:	00000506 	br	81138e98 <OSTaskResume+0x1c8>
81138e84:	e0bff617 	ldw	r2,-40(fp)
81138e88:	e0bffd15 	stw	r2,-12(fp)
81138e8c:	e0bffd17 	ldw	r2,-12(fp)
81138e90:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
81138e94:	00801104 	movi	r2,68
}
81138e98:	e037883a 	mov	sp,fp
81138e9c:	dfc00117 	ldw	ra,4(sp)
81138ea0:	df000017 	ldw	fp,0(sp)
81138ea4:	dec00204 	addi	sp,sp,8
81138ea8:	f800283a 	ret

81138eac <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
81138eac:	defff304 	addi	sp,sp,-52
81138eb0:	de00012e 	bgeu	sp,et,81138eb8 <OSTaskStkChk+0xc>
81138eb4:	003b68fa 	trap	3
81138eb8:	df000c15 	stw	fp,48(sp)
81138ebc:	df000c04 	addi	fp,sp,48
81138ec0:	2005883a 	mov	r2,r4
81138ec4:	e17fff15 	stw	r5,-4(fp)
81138ec8:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81138ecc:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
81138ed0:	e0bffe03 	ldbu	r2,-8(fp)
81138ed4:	10800af0 	cmpltui	r2,r2,43
81138ed8:	1000051e 	bne	r2,zero,81138ef0 <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
81138edc:	e0bffe03 	ldbu	r2,-8(fp)
81138ee0:	10803fe0 	cmpeqi	r2,r2,255
81138ee4:	1000021e 	bne	r2,zero,81138ef0 <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
81138ee8:	00800a84 	movi	r2,42
81138eec:	00005d06 	br	81139064 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
81138ef0:	e0bfff17 	ldw	r2,-4(fp)
81138ef4:	1000021e 	bne	r2,zero,81138f00 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
81138ef8:	00800244 	movi	r2,9
81138efc:	00005906 	br	81139064 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
81138f00:	e0bfff17 	ldw	r2,-4(fp)
81138f04:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
81138f08:	e0bfff17 	ldw	r2,-4(fp)
81138f0c:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138f10:	0005303a 	rdctl	r2,status
81138f14:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138f18:	e0fffd17 	ldw	r3,-12(fp)
81138f1c:	00bfff84 	movi	r2,-2
81138f20:	1884703a 	and	r2,r3,r2
81138f24:	1001703a 	wrctl	status,r2
  
  return context;
81138f28:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
81138f2c:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
81138f30:	e0bffe03 	ldbu	r2,-8(fp)
81138f34:	10803fd8 	cmpnei	r2,r2,255
81138f38:	1000031e 	bne	r2,zero,81138f48 <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
81138f3c:	d0a0a117 	ldw	r2,-32124(gp)
81138f40:	10800c83 	ldbu	r2,50(r2)
81138f44:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81138f48:	e0fffe03 	ldbu	r3,-8(fp)
81138f4c:	00a045b4 	movhi	r2,33046
81138f50:	1084d804 	addi	r2,r2,4960
81138f54:	18c7883a 	add	r3,r3,r3
81138f58:	18c7883a 	add	r3,r3,r3
81138f5c:	10c5883a 	add	r2,r2,r3
81138f60:	10800017 	ldw	r2,0(r2)
81138f64:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
81138f68:	e0bff817 	ldw	r2,-32(fp)
81138f6c:	1000061e 	bne	r2,zero,81138f88 <OSTaskStkChk+0xdc>
81138f70:	e0bff617 	ldw	r2,-40(fp)
81138f74:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138f78:	e0bff717 	ldw	r2,-36(fp)
81138f7c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81138f80:	008010c4 	movi	r2,67
81138f84:	00003706 	br	81139064 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
81138f88:	e0bff817 	ldw	r2,-32(fp)
81138f8c:	10800058 	cmpnei	r2,r2,1
81138f90:	1000061e 	bne	r2,zero,81138fac <OSTaskStkChk+0x100>
81138f94:	e0bff617 	ldw	r2,-40(fp)
81138f98:	e0bff915 	stw	r2,-28(fp)
81138f9c:	e0bff917 	ldw	r2,-28(fp)
81138fa0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81138fa4:	008010c4 	movi	r2,67
81138fa8:	00002e06 	br	81139064 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
81138fac:	e0bff817 	ldw	r2,-32(fp)
81138fb0:	1080040b 	ldhu	r2,16(r2)
81138fb4:	10bfffcc 	andi	r2,r2,65535
81138fb8:	1080004c 	andi	r2,r2,1
81138fbc:	1000061e 	bne	r2,zero,81138fd8 <OSTaskStkChk+0x12c>
81138fc0:	e0bff617 	ldw	r2,-40(fp)
81138fc4:	e0bffa15 	stw	r2,-24(fp)
81138fc8:	e0bffa17 	ldw	r2,-24(fp)
81138fcc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
81138fd0:	00801144 	movi	r2,69
81138fd4:	00002306 	br	81139064 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
81138fd8:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
81138fdc:	e0bff817 	ldw	r2,-32(fp)
81138fe0:	10800317 	ldw	r2,12(r2)
81138fe4:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
81138fe8:	e0bff817 	ldw	r2,-32(fp)
81138fec:	10800217 	ldw	r2,8(r2)
81138ff0:	e0bff415 	stw	r2,-48(fp)
81138ff4:	e0bff617 	ldw	r2,-40(fp)
81138ff8:	e0bffb15 	stw	r2,-20(fp)
81138ffc:	e0bffb17 	ldw	r2,-20(fp)
81139000:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
81139004:	00000306 	br	81139014 <OSTaskStkChk+0x168>
        nfree++;
81139008:	e0bff517 	ldw	r2,-44(fp)
8113900c:	10800044 	addi	r2,r2,1
81139010:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
81139014:	e0bff417 	ldw	r2,-48(fp)
81139018:	10c00104 	addi	r3,r2,4
8113901c:	e0fff415 	stw	r3,-48(fp)
81139020:	10800017 	ldw	r2,0(r2)
81139024:	103ff826 	beq	r2,zero,81139008 <__reset+0xfb119008>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
81139028:	e0bff517 	ldw	r2,-44(fp)
8113902c:	1085883a 	add	r2,r2,r2
81139030:	1085883a 	add	r2,r2,r2
81139034:	1007883a 	mov	r3,r2
81139038:	e0bfff17 	ldw	r2,-4(fp)
8113903c:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
81139040:	e0fffc17 	ldw	r3,-16(fp)
81139044:	e0bff517 	ldw	r2,-44(fp)
81139048:	1885c83a 	sub	r2,r3,r2
8113904c:	1085883a 	add	r2,r2,r2
81139050:	1085883a 	add	r2,r2,r2
81139054:	1007883a 	mov	r3,r2
81139058:	e0bfff17 	ldw	r2,-4(fp)
8113905c:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
81139060:	0005883a 	mov	r2,zero
}
81139064:	e037883a 	mov	sp,fp
81139068:	df000017 	ldw	fp,0(sp)
8113906c:	dec00104 	addi	sp,sp,4
81139070:	f800283a 	ret

81139074 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
81139074:	defff504 	addi	sp,sp,-44
81139078:	de00012e 	bgeu	sp,et,81139080 <OSTaskSuspend+0xc>
8113907c:	003b68fa 	trap	3
81139080:	dfc00a15 	stw	ra,40(sp)
81139084:	df000915 	stw	fp,36(sp)
81139088:	df000904 	addi	fp,sp,36
8113908c:	2005883a 	mov	r2,r4
81139090:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139094:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
81139098:	e0bfff03 	ldbu	r2,-4(fp)
8113909c:	10800a98 	cmpnei	r2,r2,42
811390a0:	1000021e 	bne	r2,zero,811390ac <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
811390a4:	008011c4 	movi	r2,71
811390a8:	00006806 	br	8113924c <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
811390ac:	e0bfff03 	ldbu	r2,-4(fp)
811390b0:	10800ab0 	cmpltui	r2,r2,42
811390b4:	1000051e 	bne	r2,zero,811390cc <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
811390b8:	e0bfff03 	ldbu	r2,-4(fp)
811390bc:	10803fe0 	cmpeqi	r2,r2,255
811390c0:	1000021e 	bne	r2,zero,811390cc <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
811390c4:	00800a84 	movi	r2,42
811390c8:	00006006 	br	8113924c <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811390cc:	0005303a 	rdctl	r2,status
811390d0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811390d4:	e0fffe17 	ldw	r3,-8(fp)
811390d8:	00bfff84 	movi	r2,-2
811390dc:	1884703a 	and	r2,r3,r2
811390e0:	1001703a 	wrctl	status,r2
  
  return context;
811390e4:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
811390e8:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
811390ec:	e0bfff03 	ldbu	r2,-4(fp)
811390f0:	10803fd8 	cmpnei	r2,r2,255
811390f4:	1000061e 	bne	r2,zero,81139110 <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
811390f8:	d0a0a117 	ldw	r2,-32124(gp)
811390fc:	10800c83 	ldbu	r2,50(r2)
81139100:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
81139104:	00800044 	movi	r2,1
81139108:	e0bff705 	stb	r2,-36(fp)
8113910c:	00000906 	br	81139134 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
81139110:	d0a0a117 	ldw	r2,-32124(gp)
81139114:	10800c83 	ldbu	r2,50(r2)
81139118:	10c03fcc 	andi	r3,r2,255
8113911c:	e0bfff03 	ldbu	r2,-4(fp)
81139120:	1880031e 	bne	r3,r2,81139130 <OSTaskSuspend+0xbc>
        self = OS_TRUE;
81139124:	00800044 	movi	r2,1
81139128:	e0bff705 	stb	r2,-36(fp)
8113912c:	00000106 	br	81139134 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
81139130:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
81139134:	e0ffff03 	ldbu	r3,-4(fp)
81139138:	00a045b4 	movhi	r2,33046
8113913c:	1084d804 	addi	r2,r2,4960
81139140:	18c7883a 	add	r3,r3,r3
81139144:	18c7883a 	add	r3,r3,r3
81139148:	10c5883a 	add	r2,r2,r3
8113914c:	10800017 	ldw	r2,0(r2)
81139150:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
81139154:	e0bffa17 	ldw	r2,-24(fp)
81139158:	1000061e 	bne	r2,zero,81139174 <OSTaskSuspend+0x100>
8113915c:	e0bff817 	ldw	r2,-32(fp)
81139160:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139164:	e0bff917 	ldw	r2,-28(fp)
81139168:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
8113916c:	00801204 	movi	r2,72
81139170:	00003606 	br	8113924c <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
81139174:	e0bffa17 	ldw	r2,-24(fp)
81139178:	10800058 	cmpnei	r2,r2,1
8113917c:	1000061e 	bne	r2,zero,81139198 <OSTaskSuspend+0x124>
81139180:	e0bff817 	ldw	r2,-32(fp)
81139184:	e0bffb15 	stw	r2,-20(fp)
81139188:	e0bffb17 	ldw	r2,-20(fp)
8113918c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
81139190:	008010c4 	movi	r2,67
81139194:	00002d06 	br	8113924c <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
81139198:	e0bffa17 	ldw	r2,-24(fp)
8113919c:	10800d03 	ldbu	r2,52(r2)
811391a0:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
811391a4:	e0fffd03 	ldbu	r3,-12(fp)
811391a8:	e13ffd03 	ldbu	r4,-12(fp)
811391ac:	d0a09d44 	addi	r2,gp,-32139
811391b0:	2085883a 	add	r2,r4,r2
811391b4:	10800003 	ldbu	r2,0(r2)
811391b8:	1009883a 	mov	r4,r2
811391bc:	e0bffa17 	ldw	r2,-24(fp)
811391c0:	10800d43 	ldbu	r2,53(r2)
811391c4:	0084303a 	nor	r2,zero,r2
811391c8:	2084703a 	and	r2,r4,r2
811391cc:	1009883a 	mov	r4,r2
811391d0:	d0a09d44 	addi	r2,gp,-32139
811391d4:	1885883a 	add	r2,r3,r2
811391d8:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
811391dc:	e0fffd03 	ldbu	r3,-12(fp)
811391e0:	d0a09d44 	addi	r2,gp,-32139
811391e4:	1885883a 	add	r2,r3,r2
811391e8:	10800003 	ldbu	r2,0(r2)
811391ec:	10803fcc 	andi	r2,r2,255
811391f0:	1000071e 	bne	r2,zero,81139210 <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
811391f4:	e0bffa17 	ldw	r2,-24(fp)
811391f8:	10800d83 	ldbu	r2,54(r2)
811391fc:	0084303a 	nor	r2,zero,r2
81139200:	1007883a 	mov	r3,r2
81139204:	d0a09d03 	ldbu	r2,-32140(gp)
81139208:	1884703a 	and	r2,r3,r2
8113920c:	d0a09d05 	stb	r2,-32140(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
81139210:	e0bffa17 	ldw	r2,-24(fp)
81139214:	10800c03 	ldbu	r2,48(r2)
81139218:	10800214 	ori	r2,r2,8
8113921c:	1007883a 	mov	r3,r2
81139220:	e0bffa17 	ldw	r2,-24(fp)
81139224:	10c00c05 	stb	r3,48(r2)
81139228:	e0bff817 	ldw	r2,-32(fp)
8113922c:	e0bffc15 	stw	r2,-16(fp)
81139230:	e0bffc17 	ldw	r2,-16(fp)
81139234:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
81139238:	e0bff703 	ldbu	r2,-36(fp)
8113923c:	10800058 	cmpnei	r2,r2,1
81139240:	1000011e 	bne	r2,zero,81139248 <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
81139244:	11326c80 	call	811326c8 <OS_Sched>
    }
    return (OS_ERR_NONE);
81139248:	0005883a 	mov	r2,zero
}
8113924c:	e037883a 	mov	sp,fp
81139250:	dfc00117 	ldw	ra,4(sp)
81139254:	df000017 	ldw	fp,0(sp)
81139258:	dec00204 	addi	sp,sp,8
8113925c:	f800283a 	ret

81139260 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
81139260:	defff604 	addi	sp,sp,-40
81139264:	de00012e 	bgeu	sp,et,8113926c <OSTaskQuery+0xc>
81139268:	003b68fa 	trap	3
8113926c:	dfc00915 	stw	ra,36(sp)
81139270:	df000815 	stw	fp,32(sp)
81139274:	df000804 	addi	fp,sp,32
81139278:	2005883a 	mov	r2,r4
8113927c:	e17fff15 	stw	r5,-4(fp)
81139280:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139284:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
81139288:	e0bffe03 	ldbu	r2,-8(fp)
8113928c:	10800af0 	cmpltui	r2,r2,43
81139290:	1000051e 	bne	r2,zero,811392a8 <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
81139294:	e0bffe03 	ldbu	r2,-8(fp)
81139298:	10803fe0 	cmpeqi	r2,r2,255
8113929c:	1000021e 	bne	r2,zero,811392a8 <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
811392a0:	00800a84 	movi	r2,42
811392a4:	00003406 	br	81139378 <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
811392a8:	e0bfff17 	ldw	r2,-4(fp)
811392ac:	1000021e 	bne	r2,zero,811392b8 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
811392b0:	00800244 	movi	r2,9
811392b4:	00003006 	br	81139378 <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811392b8:	0005303a 	rdctl	r2,status
811392bc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811392c0:	e0fffd17 	ldw	r3,-12(fp)
811392c4:	00bfff84 	movi	r2,-2
811392c8:	1884703a 	and	r2,r3,r2
811392cc:	1001703a 	wrctl	status,r2
  
  return context;
811392d0:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
811392d4:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
811392d8:	e0bffe03 	ldbu	r2,-8(fp)
811392dc:	10803fd8 	cmpnei	r2,r2,255
811392e0:	1000031e 	bne	r2,zero,811392f0 <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
811392e4:	d0a0a117 	ldw	r2,-32124(gp)
811392e8:	10800c83 	ldbu	r2,50(r2)
811392ec:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
811392f0:	e0fffe03 	ldbu	r3,-8(fp)
811392f4:	00a045b4 	movhi	r2,33046
811392f8:	1084d804 	addi	r2,r2,4960
811392fc:	18c7883a 	add	r3,r3,r3
81139300:	18c7883a 	add	r3,r3,r3
81139304:	10c5883a 	add	r2,r2,r3
81139308:	10800017 	ldw	r2,0(r2)
8113930c:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
81139310:	e0bffa17 	ldw	r2,-24(fp)
81139314:	1000061e 	bne	r2,zero,81139330 <OSTaskQuery+0xd0>
81139318:	e0bff817 	ldw	r2,-32(fp)
8113931c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139320:	e0bff917 	ldw	r2,-28(fp)
81139324:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
81139328:	00800a44 	movi	r2,41
8113932c:	00001206 	br	81139378 <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
81139330:	e0bffa17 	ldw	r2,-24(fp)
81139334:	10800058 	cmpnei	r2,r2,1
81139338:	1000061e 	bne	r2,zero,81139354 <OSTaskQuery+0xf4>
8113933c:	e0bff817 	ldw	r2,-32(fp)
81139340:	e0bffb15 	stw	r2,-20(fp)
81139344:	e0bffb17 	ldw	r2,-20(fp)
81139348:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113934c:	008010c4 	movi	r2,67
81139350:	00000906 	br	81139378 <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
81139354:	01801b04 	movi	r6,108
81139358:	e17ffa17 	ldw	r5,-24(fp)
8113935c:	e13fff17 	ldw	r4,-4(fp)
81139360:	11326580 	call	81132658 <OS_MemCopy>
81139364:	e0bff817 	ldw	r2,-32(fp)
81139368:	e0bffc15 	stw	r2,-16(fp)
8113936c:	e0bffc17 	ldw	r2,-16(fp)
81139370:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81139374:	0005883a 	mov	r2,zero
}
81139378:	e037883a 	mov	sp,fp
8113937c:	dfc00117 	ldw	ra,4(sp)
81139380:	df000017 	ldw	fp,0(sp)
81139384:	dec00204 	addi	sp,sp,8
81139388:	f800283a 	ret

8113938c <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
8113938c:	defffc04 	addi	sp,sp,-16
81139390:	de00012e 	bgeu	sp,et,81139398 <OS_TaskStkClr+0xc>
81139394:	003b68fa 	trap	3
81139398:	df000315 	stw	fp,12(sp)
8113939c:	df000304 	addi	fp,sp,12
811393a0:	e13ffd15 	stw	r4,-12(fp)
811393a4:	e17ffe15 	stw	r5,-8(fp)
811393a8:	3005883a 	mov	r2,r6
811393ac:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
811393b0:	e0bfff0b 	ldhu	r2,-4(fp)
811393b4:	1080004c 	andi	r2,r2,1
811393b8:	10000d26 	beq	r2,zero,811393f0 <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
811393bc:	e0bfff0b 	ldhu	r2,-4(fp)
811393c0:	1080008c 	andi	r2,r2,2
811393c4:	10000a26 	beq	r2,zero,811393f0 <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
811393c8:	00000706 	br	811393e8 <OS_TaskStkClr+0x5c>
                size--;
811393cc:	e0bffe17 	ldw	r2,-8(fp)
811393d0:	10bfffc4 	addi	r2,r2,-1
811393d4:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
811393d8:	e0bffd17 	ldw	r2,-12(fp)
811393dc:	10c00104 	addi	r3,r2,4
811393e0:	e0fffd15 	stw	r3,-12(fp)
811393e4:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
811393e8:	e0bffe17 	ldw	r2,-8(fp)
811393ec:	103ff71e 	bne	r2,zero,811393cc <__reset+0xfb1193cc>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
811393f0:	0001883a 	nop
811393f4:	e037883a 	mov	sp,fp
811393f8:	df000017 	ldw	fp,0(sp)
811393fc:	dec00104 	addi	sp,sp,4
81139400:	f800283a 	ret

81139404 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
81139404:	defff904 	addi	sp,sp,-28
81139408:	de00012e 	bgeu	sp,et,81139410 <OSTimeDly+0xc>
8113940c:	003b68fa 	trap	3
81139410:	dfc00615 	stw	ra,24(sp)
81139414:	df000515 	stw	fp,20(sp)
81139418:	df000504 	addi	fp,sp,20
8113941c:	2005883a 	mov	r2,r4
81139420:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139424:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81139428:	d0a0a003 	ldbu	r2,-32128(gp)
8113942c:	10803fcc 	andi	r2,r2,255
81139430:	1000311e 	bne	r2,zero,811394f8 <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
81139434:	e0bfff0b 	ldhu	r2,-4(fp)
81139438:	10003026 	beq	r2,zero,811394fc <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113943c:	0005303a 	rdctl	r2,status
81139440:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139444:	e0fffe17 	ldw	r3,-8(fp)
81139448:	00bfff84 	movi	r2,-2
8113944c:	1884703a 	and	r2,r3,r2
81139450:	1001703a 	wrctl	status,r2
  
  return context;
81139454:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
81139458:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
8113945c:	d0a0a117 	ldw	r2,-32124(gp)
81139460:	10800d03 	ldbu	r2,52(r2)
81139464:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
81139468:	e0fffd03 	ldbu	r3,-12(fp)
8113946c:	e13ffd03 	ldbu	r4,-12(fp)
81139470:	d0a09d44 	addi	r2,gp,-32139
81139474:	2085883a 	add	r2,r4,r2
81139478:	10800003 	ldbu	r2,0(r2)
8113947c:	1009883a 	mov	r4,r2
81139480:	d0a0a117 	ldw	r2,-32124(gp)
81139484:	10800d43 	ldbu	r2,53(r2)
81139488:	0084303a 	nor	r2,zero,r2
8113948c:	2084703a 	and	r2,r4,r2
81139490:	1009883a 	mov	r4,r2
81139494:	d0a09d44 	addi	r2,gp,-32139
81139498:	1885883a 	add	r2,r3,r2
8113949c:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
811394a0:	e0fffd03 	ldbu	r3,-12(fp)
811394a4:	d0a09d44 	addi	r2,gp,-32139
811394a8:	1885883a 	add	r2,r3,r2
811394ac:	10800003 	ldbu	r2,0(r2)
811394b0:	10803fcc 	andi	r2,r2,255
811394b4:	1000071e 	bne	r2,zero,811394d4 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
811394b8:	d0a0a117 	ldw	r2,-32124(gp)
811394bc:	10800d83 	ldbu	r2,54(r2)
811394c0:	0084303a 	nor	r2,zero,r2
811394c4:	1007883a 	mov	r3,r2
811394c8:	d0a09d03 	ldbu	r2,-32140(gp)
811394cc:	1884703a 	and	r2,r3,r2
811394d0:	d0a09d05 	stb	r2,-32140(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
811394d4:	d0a0a117 	ldw	r2,-32124(gp)
811394d8:	e0ffff0b 	ldhu	r3,-4(fp)
811394dc:	10c00b8d 	sth	r3,46(r2)
811394e0:	e0bffb17 	ldw	r2,-20(fp)
811394e4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811394e8:	e0bffc17 	ldw	r2,-16(fp)
811394ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
811394f0:	11326c80 	call	811326c8 <OS_Sched>
811394f4:	00000106 	br	811394fc <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
811394f8:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
811394fc:	e037883a 	mov	sp,fp
81139500:	dfc00117 	ldw	ra,4(sp)
81139504:	df000017 	ldw	fp,0(sp)
81139508:	dec00204 	addi	sp,sp,8
8113950c:	f800283a 	ret

81139510 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
81139510:	defff804 	addi	sp,sp,-32
81139514:	de00012e 	bgeu	sp,et,8113951c <OSTimeDlyHMSM+0xc>
81139518:	003b68fa 	trap	3
8113951c:	dfc00715 	stw	ra,28(sp)
81139520:	df000615 	stw	fp,24(sp)
81139524:	df000604 	addi	fp,sp,24
81139528:	2015883a 	mov	r10,r4
8113952c:	2809883a 	mov	r4,r5
81139530:	3007883a 	mov	r3,r6
81139534:	3805883a 	mov	r2,r7
81139538:	e2bffc05 	stb	r10,-16(fp)
8113953c:	e13ffd05 	stb	r4,-12(fp)
81139540:	e0fffe05 	stb	r3,-8(fp)
81139544:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81139548:	d0a0a003 	ldbu	r2,-32128(gp)
8113954c:	10803fcc 	andi	r2,r2,255
81139550:	10000226 	beq	r2,zero,8113955c <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
81139554:	00801544 	movi	r2,85
81139558:	00004106 	br	81139660 <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
8113955c:	e0bffc03 	ldbu	r2,-16(fp)
81139560:	1000081e 	bne	r2,zero,81139584 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
81139564:	e0bffd03 	ldbu	r2,-12(fp)
81139568:	1000061e 	bne	r2,zero,81139584 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
8113956c:	e0bffe03 	ldbu	r2,-8(fp)
81139570:	1000041e 	bne	r2,zero,81139584 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
81139574:	e0bfff0b 	ldhu	r2,-4(fp)
81139578:	1000021e 	bne	r2,zero,81139584 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
8113957c:	00801504 	movi	r2,84
81139580:	00003706 	br	81139660 <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
81139584:	e0bffd03 	ldbu	r2,-12(fp)
81139588:	10800f30 	cmpltui	r2,r2,60
8113958c:	1000021e 	bne	r2,zero,81139598 <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
81139590:	00801444 	movi	r2,81
81139594:	00003206 	br	81139660 <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
81139598:	e0bffe03 	ldbu	r2,-8(fp)
8113959c:	10800f30 	cmpltui	r2,r2,60
811395a0:	1000021e 	bne	r2,zero,811395ac <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
811395a4:	00801484 	movi	r2,82
811395a8:	00002d06 	br	81139660 <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
811395ac:	e0bfff0b 	ldhu	r2,-4(fp)
811395b0:	1080fa30 	cmpltui	r2,r2,1000
811395b4:	1000021e 	bne	r2,zero,811395c0 <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
811395b8:	008014c4 	movi	r2,83
811395bc:	00002806 	br	81139660 <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
811395c0:	e0bffc03 	ldbu	r2,-16(fp)
811395c4:	10c38424 	muli	r3,r2,3600
811395c8:	e0bffd03 	ldbu	r2,-12(fp)
811395cc:	10800f24 	muli	r2,r2,60
811395d0:	1887883a 	add	r3,r3,r2
811395d4:	e0bffe03 	ldbu	r2,-8(fp)
811395d8:	1885883a 	add	r2,r3,r2
811395dc:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
811395e0:	e0bfff0b 	ldhu	r2,-4(fp)
811395e4:	10c0fa24 	muli	r3,r2,1000
811395e8:	008418b4 	movhi	r2,4194
811395ec:	109374c4 	addi	r2,r2,19923
811395f0:	188a383a 	mulxuu	r5,r3,r2
811395f4:	1885383a 	mul	r2,r3,r2
811395f8:	1011883a 	mov	r8,r2
811395fc:	2813883a 	mov	r9,r5
81139600:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
81139604:	2085883a 	add	r2,r4,r2
81139608:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
8113960c:	e0bffb17 	ldw	r2,-20(fp)
81139610:	1004d43a 	srli	r2,r2,16
81139614:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
81139618:	e0bffb17 	ldw	r2,-20(fp)
8113961c:	10bfffcc 	andi	r2,r2,65535
81139620:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
81139624:	e0bffb17 	ldw	r2,-20(fp)
81139628:	10bfffcc 	andi	r2,r2,65535
8113962c:	1009883a 	mov	r4,r2
81139630:	11394040 	call	81139404 <OSTimeDly>
    while (loops > 0) {
81139634:	00000706 	br	81139654 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
81139638:	01200014 	movui	r4,32768
8113963c:	11394040 	call	81139404 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
81139640:	01200014 	movui	r4,32768
81139644:	11394040 	call	81139404 <OSTimeDly>
        loops--;
81139648:	e0bffa0b 	ldhu	r2,-24(fp)
8113964c:	10bfffc4 	addi	r2,r2,-1
81139650:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
81139654:	e0bffa0b 	ldhu	r2,-24(fp)
81139658:	103ff71e 	bne	r2,zero,81139638 <__reset+0xfb119638>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
8113965c:	0005883a 	mov	r2,zero
}
81139660:	e037883a 	mov	sp,fp
81139664:	dfc00117 	ldw	ra,4(sp)
81139668:	df000017 	ldw	fp,0(sp)
8113966c:	dec00204 	addi	sp,sp,8
81139670:	f800283a 	ret

81139674 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
81139674:	defff504 	addi	sp,sp,-44
81139678:	de00012e 	bgeu	sp,et,81139680 <OSTimeDlyResume+0xc>
8113967c:	003b68fa 	trap	3
81139680:	dfc00a15 	stw	ra,40(sp)
81139684:	df000915 	stw	fp,36(sp)
81139688:	df000904 	addi	fp,sp,36
8113968c:	2005883a 	mov	r2,r4
81139690:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139694:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
81139698:	e0bfff03 	ldbu	r2,-4(fp)
8113969c:	10800ab0 	cmpltui	r2,r2,42
811396a0:	1000021e 	bne	r2,zero,811396ac <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
811396a4:	00800a84 	movi	r2,42
811396a8:	00006406 	br	8113983c <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811396ac:	0005303a 	rdctl	r2,status
811396b0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811396b4:	e0fffe17 	ldw	r3,-8(fp)
811396b8:	00bfff84 	movi	r2,-2
811396bc:	1884703a 	and	r2,r3,r2
811396c0:	1001703a 	wrctl	status,r2
  
  return context;
811396c4:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
811396c8:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
811396cc:	e0ffff03 	ldbu	r3,-4(fp)
811396d0:	00a045b4 	movhi	r2,33046
811396d4:	1084d804 	addi	r2,r2,4960
811396d8:	18c7883a 	add	r3,r3,r3
811396dc:	18c7883a 	add	r3,r3,r3
811396e0:	10c5883a 	add	r2,r2,r3
811396e4:	10800017 	ldw	r2,0(r2)
811396e8:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
811396ec:	e0bff917 	ldw	r2,-28(fp)
811396f0:	1000061e 	bne	r2,zero,8113970c <OSTimeDlyResume+0x98>
811396f4:	e0bff717 	ldw	r2,-36(fp)
811396f8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811396fc:	e0bff817 	ldw	r2,-32(fp)
81139700:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81139704:	008010c4 	movi	r2,67
81139708:	00004c06 	br	8113983c <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113970c:	e0bff917 	ldw	r2,-28(fp)
81139710:	10800058 	cmpnei	r2,r2,1
81139714:	1000061e 	bne	r2,zero,81139730 <OSTimeDlyResume+0xbc>
81139718:	e0bff717 	ldw	r2,-36(fp)
8113971c:	e0bffa15 	stw	r2,-24(fp)
81139720:	e0bffa17 	ldw	r2,-24(fp)
81139724:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
81139728:	008010c4 	movi	r2,67
8113972c:	00004306 	br	8113983c <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
81139730:	e0bff917 	ldw	r2,-28(fp)
81139734:	10800b8b 	ldhu	r2,46(r2)
81139738:	10bfffcc 	andi	r2,r2,65535
8113973c:	1000061e 	bne	r2,zero,81139758 <OSTimeDlyResume+0xe4>
81139740:	e0bff717 	ldw	r2,-36(fp)
81139744:	e0bffb15 	stw	r2,-20(fp)
81139748:	e0bffb17 	ldw	r2,-20(fp)
8113974c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
81139750:	00801404 	movi	r2,80
81139754:	00003906 	br	8113983c <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
81139758:	e0bff917 	ldw	r2,-28(fp)
8113975c:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81139760:	e0bff917 	ldw	r2,-28(fp)
81139764:	10800c03 	ldbu	r2,48(r2)
81139768:	10803fcc 	andi	r2,r2,255
8113976c:	10800dcc 	andi	r2,r2,55
81139770:	10000b26 	beq	r2,zero,811397a0 <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
81139774:	e0bff917 	ldw	r2,-28(fp)
81139778:	10c00c03 	ldbu	r3,48(r2)
8113977c:	00bff204 	movi	r2,-56
81139780:	1884703a 	and	r2,r3,r2
81139784:	1007883a 	mov	r3,r2
81139788:	e0bff917 	ldw	r2,-28(fp)
8113978c:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
81139790:	e0bff917 	ldw	r2,-28(fp)
81139794:	00c00044 	movi	r3,1
81139798:	10c00c45 	stb	r3,49(r2)
8113979c:	00000206 	br	811397a8 <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
811397a0:	e0bff917 	ldw	r2,-28(fp)
811397a4:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
811397a8:	e0bff917 	ldw	r2,-28(fp)
811397ac:	10800c03 	ldbu	r2,48(r2)
811397b0:	10803fcc 	andi	r2,r2,255
811397b4:	1080020c 	andi	r2,r2,8
811397b8:	10001b1e 	bne	r2,zero,81139828 <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
811397bc:	e0bff917 	ldw	r2,-28(fp)
811397c0:	10c00d83 	ldbu	r3,54(r2)
811397c4:	d0a09d03 	ldbu	r2,-32140(gp)
811397c8:	1884b03a 	or	r2,r3,r2
811397cc:	d0a09d05 	stb	r2,-32140(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811397d0:	e0bff917 	ldw	r2,-28(fp)
811397d4:	10800d03 	ldbu	r2,52(r2)
811397d8:	10c03fcc 	andi	r3,r2,255
811397dc:	e0bff917 	ldw	r2,-28(fp)
811397e0:	10800d03 	ldbu	r2,52(r2)
811397e4:	11003fcc 	andi	r4,r2,255
811397e8:	d0a09d44 	addi	r2,gp,-32139
811397ec:	2085883a 	add	r2,r4,r2
811397f0:	11000003 	ldbu	r4,0(r2)
811397f4:	e0bff917 	ldw	r2,-28(fp)
811397f8:	10800d43 	ldbu	r2,53(r2)
811397fc:	2084b03a 	or	r2,r4,r2
81139800:	1009883a 	mov	r4,r2
81139804:	d0a09d44 	addi	r2,gp,-32139
81139808:	1885883a 	add	r2,r3,r2
8113980c:	11000005 	stb	r4,0(r2)
81139810:	e0bff717 	ldw	r2,-36(fp)
81139814:	e0bffc15 	stw	r2,-16(fp)
81139818:	e0bffc17 	ldw	r2,-16(fp)
8113981c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
81139820:	11326c80 	call	811326c8 <OS_Sched>
81139824:	00000406 	br	81139838 <OSTimeDlyResume+0x1c4>
81139828:	e0bff717 	ldw	r2,-36(fp)
8113982c:	e0bffd15 	stw	r2,-12(fp)
81139830:	e0bffd17 	ldw	r2,-12(fp)
81139834:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
81139838:	0005883a 	mov	r2,zero
}
8113983c:	e037883a 	mov	sp,fp
81139840:	dfc00117 	ldw	ra,4(sp)
81139844:	df000017 	ldw	fp,0(sp)
81139848:	dec00204 	addi	sp,sp,8
8113984c:	f800283a 	ret

81139850 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
81139850:	defffb04 	addi	sp,sp,-20
81139854:	de00012e 	bgeu	sp,et,8113985c <OSTimeGet+0xc>
81139858:	003b68fa 	trap	3
8113985c:	df000415 	stw	fp,16(sp)
81139860:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139864:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139868:	0005303a 	rdctl	r2,status
8113986c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139870:	e0fffe17 	ldw	r3,-8(fp)
81139874:	00bfff84 	movi	r2,-2
81139878:	1884703a 	and	r2,r3,r2
8113987c:	1001703a 	wrctl	status,r2
  
  return context;
81139880:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
81139884:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
81139888:	d0a0a317 	ldw	r2,-32116(gp)
8113988c:	e0bffd15 	stw	r2,-12(fp)
81139890:	e0bffc17 	ldw	r2,-16(fp)
81139894:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139898:	e0bfff17 	ldw	r2,-4(fp)
8113989c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
811398a0:	e0bffd17 	ldw	r2,-12(fp)
}
811398a4:	e037883a 	mov	sp,fp
811398a8:	df000017 	ldw	fp,0(sp)
811398ac:	dec00104 	addi	sp,sp,4
811398b0:	f800283a 	ret

811398b4 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
811398b4:	defffb04 	addi	sp,sp,-20
811398b8:	de00012e 	bgeu	sp,et,811398c0 <OSTimeSet+0xc>
811398bc:	003b68fa 	trap	3
811398c0:	df000415 	stw	fp,16(sp)
811398c4:	df000404 	addi	fp,sp,16
811398c8:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811398cc:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811398d0:	0005303a 	rdctl	r2,status
811398d4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811398d8:	e0fffd17 	ldw	r3,-12(fp)
811398dc:	00bfff84 	movi	r2,-2
811398e0:	1884703a 	and	r2,r3,r2
811398e4:	1001703a 	wrctl	status,r2
  
  return context;
811398e8:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
811398ec:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
811398f0:	e0bfff17 	ldw	r2,-4(fp)
811398f4:	d0a0a315 	stw	r2,-32116(gp)
811398f8:	e0bffc17 	ldw	r2,-16(fp)
811398fc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139900:	e0bffe17 	ldw	r2,-8(fp)
81139904:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81139908:	0001883a 	nop
8113990c:	e037883a 	mov	sp,fp
81139910:	df000017 	ldw	fp,0(sp)
81139914:	dec00104 	addi	sp,sp,4
81139918:	f800283a 	ret

8113991c <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
8113991c:	defff804 	addi	sp,sp,-32
81139920:	de00012e 	bgeu	sp,et,81139928 <OSTmrCreate+0xc>
81139924:	003b68fa 	trap	3
81139928:	dfc00715 	stw	ra,28(sp)
8113992c:	df000615 	stw	fp,24(sp)
81139930:	df000604 	addi	fp,sp,24
81139934:	e13ffc15 	stw	r4,-16(fp)
81139938:	e17ffd15 	stw	r5,-12(fp)
8113993c:	3005883a 	mov	r2,r6
81139940:	e1ffff15 	stw	r7,-4(fp)
81139944:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81139948:	e0800417 	ldw	r2,16(fp)
8113994c:	1000021e 	bne	r2,zero,81139958 <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
81139950:	0005883a 	mov	r2,zero
81139954:	00005d06 	br	81139acc <OSTmrCreate+0x1b0>
    }
    switch (opt) {
81139958:	e0bffe03 	ldbu	r2,-8(fp)
8113995c:	10c00060 	cmpeqi	r3,r2,1
81139960:	1800091e 	bne	r3,zero,81139988 <OSTmrCreate+0x6c>
81139964:	108000a0 	cmpeqi	r2,r2,2
81139968:	10000e26 	beq	r2,zero,811399a4 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
8113996c:	e0bffd17 	ldw	r2,-12(fp)
81139970:	1000111e 	bne	r2,zero,811399b8 <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
81139974:	e0800417 	ldw	r2,16(fp)
81139978:	00ffe0c4 	movi	r3,-125
8113997c:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
81139980:	0005883a 	mov	r2,zero
81139984:	00005106 	br	81139acc <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
81139988:	e0bffc17 	ldw	r2,-16(fp)
8113998c:	10000c1e 	bne	r2,zero,811399c0 <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
81139990:	e0800417 	ldw	r2,16(fp)
81139994:	00ffe084 	movi	r3,-126
81139998:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8113999c:	0005883a 	mov	r2,zero
811399a0:	00004a06 	br	81139acc <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
811399a4:	e0800417 	ldw	r2,16(fp)
811399a8:	00ffe104 	movi	r3,-124
811399ac:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
811399b0:	0005883a 	mov	r2,zero
811399b4:	00004506 	br	81139acc <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
811399b8:	0001883a 	nop
811399bc:	00000106 	br	811399c4 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
811399c0:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
811399c4:	d0a0a003 	ldbu	r2,-32128(gp)
811399c8:	10803fcc 	andi	r2,r2,255
811399cc:	10000526 	beq	r2,zero,811399e4 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
811399d0:	e0800417 	ldw	r2,16(fp)
811399d4:	00ffe2c4 	movi	r3,-117
811399d8:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
811399dc:	0005883a 	mov	r2,zero
811399e0:	00003a06 	br	81139acc <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
811399e4:	113a8d40 	call	8113a8d4 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
811399e8:	113a3740 	call	8113a374 <OSTmr_Alloc>
811399ec:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
811399f0:	e0bffa17 	ldw	r2,-24(fp)
811399f4:	1000061e 	bne	r2,zero,81139a10 <OSTmrCreate+0xf4>
        OSTmr_Unlock();
811399f8:	113a9180 	call	8113a918 <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
811399fc:	e0800417 	ldw	r2,16(fp)
81139a00:	00ffe184 	movi	r3,-122
81139a04:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
81139a08:	0005883a 	mov	r2,zero
81139a0c:	00002f06 	br	81139acc <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
81139a10:	e0bffa17 	ldw	r2,-24(fp)
81139a14:	00c00044 	movi	r3,1
81139a18:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
81139a1c:	e0bffa17 	ldw	r2,-24(fp)
81139a20:	e0fffc17 	ldw	r3,-16(fp)
81139a24:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
81139a28:	e0bffa17 	ldw	r2,-24(fp)
81139a2c:	e0fffd17 	ldw	r3,-12(fp)
81139a30:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
81139a34:	e0bffa17 	ldw	r2,-24(fp)
81139a38:	e0fffe03 	ldbu	r3,-8(fp)
81139a3c:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
81139a40:	e0bffa17 	ldw	r2,-24(fp)
81139a44:	e0ffff17 	ldw	r3,-4(fp)
81139a48:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
81139a4c:	e0bffa17 	ldw	r2,-24(fp)
81139a50:	e0c00217 	ldw	r3,8(fp)
81139a54:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
81139a58:	e0800317 	ldw	r2,12(fp)
81139a5c:	10001726 	beq	r2,zero,81139abc <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
81139a60:	e1000317 	ldw	r4,12(fp)
81139a64:	11328980 	call	81132898 <OS_StrLen>
81139a68:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
81139a6c:	e0bffb03 	ldbu	r2,-20(fp)
81139a70:	10800428 	cmpgeui	r2,r2,16
81139a74:	1000061e 	bne	r2,zero,81139a90 <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
81139a78:	e0bffa17 	ldw	r2,-24(fp)
81139a7c:	10800804 	addi	r2,r2,32
81139a80:	e1400317 	ldw	r5,12(fp)
81139a84:	1009883a 	mov	r4,r2
81139a88:	113281c0 	call	8113281c <OS_StrCopy>
81139a8c:	00000b06 	br	81139abc <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
81139a90:	e0bffa17 	ldw	r2,-24(fp)
81139a94:	00c008c4 	movi	r3,35
81139a98:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
81139a9c:	e0bffa17 	ldw	r2,-24(fp)
81139aa0:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
81139aa4:	e0800417 	ldw	r2,16(fp)
81139aa8:	00ffe304 	movi	r3,-116
81139aac:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
81139ab0:	113a9180 	call	8113a918 <OSTmr_Unlock>
            return (ptmr);
81139ab4:	e0bffa17 	ldw	r2,-24(fp)
81139ab8:	00000406 	br	81139acc <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
81139abc:	113a9180 	call	8113a918 <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
81139ac0:	e0800417 	ldw	r2,16(fp)
81139ac4:	10000005 	stb	zero,0(r2)
    return (ptmr);
81139ac8:	e0bffa17 	ldw	r2,-24(fp)
}
81139acc:	e037883a 	mov	sp,fp
81139ad0:	dfc00117 	ldw	ra,4(sp)
81139ad4:	df000017 	ldw	fp,0(sp)
81139ad8:	dec00204 	addi	sp,sp,8
81139adc:	f800283a 	ret

81139ae0 <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
81139ae0:	defffc04 	addi	sp,sp,-16
81139ae4:	de00012e 	bgeu	sp,et,81139aec <OSTmrDel+0xc>
81139ae8:	003b68fa 	trap	3
81139aec:	dfc00315 	stw	ra,12(sp)
81139af0:	df000215 	stw	fp,8(sp)
81139af4:	df000204 	addi	fp,sp,8
81139af8:	e13ffe15 	stw	r4,-8(fp)
81139afc:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
81139b00:	e0bfff17 	ldw	r2,-4(fp)
81139b04:	1000021e 	bne	r2,zero,81139b10 <OSTmrDel+0x30>
        return (OS_FALSE);
81139b08:	0005883a 	mov	r2,zero
81139b0c:	00003f06 	br	81139c0c <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
81139b10:	e0bffe17 	ldw	r2,-8(fp)
81139b14:	1000051e 	bne	r2,zero,81139b2c <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81139b18:	e0bfff17 	ldw	r2,-4(fp)
81139b1c:	00ffe284 	movi	r3,-118
81139b20:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81139b24:	0005883a 	mov	r2,zero
81139b28:	00003806 	br	81139c0c <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
81139b2c:	e0bffe17 	ldw	r2,-8(fp)
81139b30:	10800003 	ldbu	r2,0(r2)
81139b34:	10803fcc 	andi	r2,r2,255
81139b38:	10801920 	cmpeqi	r2,r2,100
81139b3c:	1000051e 	bne	r2,zero,81139b54 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81139b40:	e0bfff17 	ldw	r2,-4(fp)
81139b44:	00ffe244 	movi	r3,-119
81139b48:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81139b4c:	0005883a 	mov	r2,zero
81139b50:	00002e06 	br	81139c0c <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
81139b54:	d0a0a003 	ldbu	r2,-32128(gp)
81139b58:	10803fcc 	andi	r2,r2,255
81139b5c:	10000526 	beq	r2,zero,81139b74 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
81139b60:	e0bfff17 	ldw	r2,-4(fp)
81139b64:	00ffe2c4 	movi	r3,-117
81139b68:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
81139b6c:	0005883a 	mov	r2,zero
81139b70:	00002606 	br	81139c0c <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
81139b74:	113a8d40 	call	8113a8d4 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81139b78:	e0bffe17 	ldw	r2,-8(fp)
81139b7c:	10800c43 	ldbu	r2,49(r2)
81139b80:	10803fcc 	andi	r2,r2,255
81139b84:	10c000c8 	cmpgei	r3,r2,3
81139b88:	1800031e 	bne	r3,zero,81139b98 <OSTmrDel+0xb8>
81139b8c:	00800d16 	blt	zero,r2,81139bc4 <OSTmrDel+0xe4>
81139b90:	10001326 	beq	r2,zero,81139be0 <OSTmrDel+0x100>
81139b94:	00001806 	br	81139bf8 <OSTmrDel+0x118>
81139b98:	108000e0 	cmpeqi	r2,r2,3
81139b9c:	10001626 	beq	r2,zero,81139bf8 <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
81139ba0:	e13ffe17 	ldw	r4,-8(fp)
81139ba4:	113a7d80 	call	8113a7d8 <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81139ba8:	e13ffe17 	ldw	r4,-8(fp)
81139bac:	113a3e80 	call	8113a3e8 <OSTmr_Free>
             OSTmr_Unlock();
81139bb0:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81139bb4:	e0bfff17 	ldw	r2,-4(fp)
81139bb8:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81139bbc:	00800044 	movi	r2,1
81139bc0:	00001206 	br	81139c0c <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
81139bc4:	e13ffe17 	ldw	r4,-8(fp)
81139bc8:	113a3e80 	call	8113a3e8 <OSTmr_Free>
             OSTmr_Unlock();
81139bcc:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81139bd0:	e0bfff17 	ldw	r2,-4(fp)
81139bd4:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
81139bd8:	00800044 	movi	r2,1
81139bdc:	00000b06 	br	81139c0c <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
81139be0:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81139be4:	e0bfff17 	ldw	r2,-4(fp)
81139be8:	00ffe1c4 	movi	r3,-121
81139bec:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81139bf0:	0005883a 	mov	r2,zero
81139bf4:	00000506 	br	81139c0c <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
81139bf8:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81139bfc:	e0bfff17 	ldw	r2,-4(fp)
81139c00:	00ffe344 	movi	r3,-115
81139c04:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
81139c08:	0005883a 	mov	r2,zero
    }
}
81139c0c:	e037883a 	mov	sp,fp
81139c10:	dfc00117 	ldw	ra,4(sp)
81139c14:	df000017 	ldw	fp,0(sp)
81139c18:	dec00204 	addi	sp,sp,8
81139c1c:	f800283a 	ret

81139c20 <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
81139c20:	defffa04 	addi	sp,sp,-24
81139c24:	de00012e 	bgeu	sp,et,81139c2c <OSTmrNameGet+0xc>
81139c28:	003b68fa 	trap	3
81139c2c:	dfc00515 	stw	ra,20(sp)
81139c30:	df000415 	stw	fp,16(sp)
81139c34:	df000404 	addi	fp,sp,16
81139c38:	e13ffd15 	stw	r4,-12(fp)
81139c3c:	e17ffe15 	stw	r5,-8(fp)
81139c40:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81139c44:	e0bfff17 	ldw	r2,-4(fp)
81139c48:	1000021e 	bne	r2,zero,81139c54 <OSTmrNameGet+0x34>
        return (0);
81139c4c:	0005883a 	mov	r2,zero
81139c50:	00003e06 	br	81139d4c <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
81139c54:	e0bffe17 	ldw	r2,-8(fp)
81139c58:	1000051e 	bne	r2,zero,81139c70 <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
81139c5c:	e0bfff17 	ldw	r2,-4(fp)
81139c60:	00ffe204 	movi	r3,-120
81139c64:	10c00005 	stb	r3,0(r2)
        return (0);
81139c68:	0005883a 	mov	r2,zero
81139c6c:	00003706 	br	81139d4c <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
81139c70:	e0bffd17 	ldw	r2,-12(fp)
81139c74:	1000051e 	bne	r2,zero,81139c8c <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
81139c78:	e0bfff17 	ldw	r2,-4(fp)
81139c7c:	00ffe284 	movi	r3,-118
81139c80:	10c00005 	stb	r3,0(r2)
        return (0);
81139c84:	0005883a 	mov	r2,zero
81139c88:	00003006 	br	81139d4c <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81139c8c:	e0bffd17 	ldw	r2,-12(fp)
81139c90:	10800003 	ldbu	r2,0(r2)
81139c94:	10803fcc 	andi	r2,r2,255
81139c98:	10801920 	cmpeqi	r2,r2,100
81139c9c:	1000051e 	bne	r2,zero,81139cb4 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81139ca0:	e0bfff17 	ldw	r2,-4(fp)
81139ca4:	00ffe244 	movi	r3,-119
81139ca8:	10c00005 	stb	r3,0(r2)
        return (0);
81139cac:	0005883a 	mov	r2,zero
81139cb0:	00002606 	br	81139d4c <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81139cb4:	d0a0a003 	ldbu	r2,-32128(gp)
81139cb8:	10803fcc 	andi	r2,r2,255
81139cbc:	10000526 	beq	r2,zero,81139cd4 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
81139cc0:	e0bfff17 	ldw	r2,-4(fp)
81139cc4:	00c00444 	movi	r3,17
81139cc8:	10c00005 	stb	r3,0(r2)
        return (0);
81139ccc:	0005883a 	mov	r2,zero
81139cd0:	00001e06 	br	81139d4c <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
81139cd4:	113a8d40 	call	8113a8d4 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81139cd8:	e0bffd17 	ldw	r2,-12(fp)
81139cdc:	10800c43 	ldbu	r2,49(r2)
81139ce0:	10803fcc 	andi	r2,r2,255
81139ce4:	10000e26 	beq	r2,zero,81139d20 <OSTmrNameGet+0x100>
81139ce8:	10001316 	blt	r2,zero,81139d38 <OSTmrNameGet+0x118>
81139cec:	10800108 	cmpgei	r2,r2,4
81139cf0:	1000111e 	bne	r2,zero,81139d38 <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
81139cf4:	e0bffd17 	ldw	r2,-12(fp)
81139cf8:	10800804 	addi	r2,r2,32
81139cfc:	100b883a 	mov	r5,r2
81139d00:	e13ffe17 	ldw	r4,-8(fp)
81139d04:	113281c0 	call	8113281c <OS_StrCopy>
81139d08:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
81139d0c:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81139d10:	e0bfff17 	ldw	r2,-4(fp)
81139d14:	10000005 	stb	zero,0(r2)
             return (len);
81139d18:	e0bffc03 	ldbu	r2,-16(fp)
81139d1c:	00000b06 	br	81139d4c <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
81139d20:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81139d24:	e0bfff17 	ldw	r2,-4(fp)
81139d28:	00ffe1c4 	movi	r3,-121
81139d2c:	10c00005 	stb	r3,0(r2)
             return (0);
81139d30:	0005883a 	mov	r2,zero
81139d34:	00000506 	br	81139d4c <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
81139d38:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81139d3c:	e0bfff17 	ldw	r2,-4(fp)
81139d40:	00ffe344 	movi	r3,-115
81139d44:	10c00005 	stb	r3,0(r2)
             return (0);
81139d48:	0005883a 	mov	r2,zero
    }
}
81139d4c:	e037883a 	mov	sp,fp
81139d50:	dfc00117 	ldw	ra,4(sp)
81139d54:	df000017 	ldw	fp,0(sp)
81139d58:	dec00204 	addi	sp,sp,8
81139d5c:	f800283a 	ret

81139d60 <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
81139d60:	defffb04 	addi	sp,sp,-20
81139d64:	de00012e 	bgeu	sp,et,81139d6c <OSTmrRemainGet+0xc>
81139d68:	003b68fa 	trap	3
81139d6c:	dfc00415 	stw	ra,16(sp)
81139d70:	df000315 	stw	fp,12(sp)
81139d74:	df000304 	addi	fp,sp,12
81139d78:	e13ffe15 	stw	r4,-8(fp)
81139d7c:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81139d80:	e0bfff17 	ldw	r2,-4(fp)
81139d84:	1000021e 	bne	r2,zero,81139d90 <OSTmrRemainGet+0x30>
        return (0);
81139d88:	0005883a 	mov	r2,zero
81139d8c:	00005d06 	br	81139f04 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
81139d90:	e0bffe17 	ldw	r2,-8(fp)
81139d94:	1000051e 	bne	r2,zero,81139dac <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81139d98:	e0bfff17 	ldw	r2,-4(fp)
81139d9c:	00ffe284 	movi	r3,-118
81139da0:	10c00005 	stb	r3,0(r2)
        return (0);
81139da4:	0005883a 	mov	r2,zero
81139da8:	00005606 	br	81139f04 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81139dac:	e0bffe17 	ldw	r2,-8(fp)
81139db0:	10800003 	ldbu	r2,0(r2)
81139db4:	10803fcc 	andi	r2,r2,255
81139db8:	10801920 	cmpeqi	r2,r2,100
81139dbc:	1000051e 	bne	r2,zero,81139dd4 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81139dc0:	e0bfff17 	ldw	r2,-4(fp)
81139dc4:	00ffe244 	movi	r3,-119
81139dc8:	10c00005 	stb	r3,0(r2)
        return (0);
81139dcc:	0005883a 	mov	r2,zero
81139dd0:	00004c06 	br	81139f04 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81139dd4:	d0a0a003 	ldbu	r2,-32128(gp)
81139dd8:	10803fcc 	andi	r2,r2,255
81139ddc:	10000526 	beq	r2,zero,81139df4 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
81139de0:	e0bfff17 	ldw	r2,-4(fp)
81139de4:	00ffe2c4 	movi	r3,-117
81139de8:	10c00005 	stb	r3,0(r2)
        return (0);
81139dec:	0005883a 	mov	r2,zero
81139df0:	00004406 	br	81139f04 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
81139df4:	113a8d40 	call	8113a8d4 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
81139df8:	e0bffe17 	ldw	r2,-8(fp)
81139dfc:	10800c43 	ldbu	r2,49(r2)
81139e00:	10803fcc 	andi	r2,r2,255
81139e04:	10c00060 	cmpeqi	r3,r2,1
81139e08:	1800121e 	bne	r3,zero,81139e54 <OSTmrRemainGet+0xf4>
81139e0c:	10c00088 	cmpgei	r3,r2,2
81139e10:	1800021e 	bne	r3,zero,81139e1c <OSTmrRemainGet+0xbc>
81139e14:	10003026 	beq	r2,zero,81139ed8 <OSTmrRemainGet+0x178>
81139e18:	00003506 	br	81139ef0 <OSTmrRemainGet+0x190>
81139e1c:	10c000a0 	cmpeqi	r3,r2,2
81139e20:	1800281e 	bne	r3,zero,81139ec4 <OSTmrRemainGet+0x164>
81139e24:	108000e0 	cmpeqi	r2,r2,3
81139e28:	10003126 	beq	r2,zero,81139ef0 <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
81139e2c:	e0bffe17 	ldw	r2,-8(fp)
81139e30:	10c00517 	ldw	r3,20(r2)
81139e34:	d0a0a217 	ldw	r2,-32120(gp)
81139e38:	1885c83a 	sub	r2,r3,r2
81139e3c:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
81139e40:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
81139e44:	e0bfff17 	ldw	r2,-4(fp)
81139e48:	10000005 	stb	zero,0(r2)
             return (remain);
81139e4c:	e0bffd17 	ldw	r2,-12(fp)
81139e50:	00002c06 	br	81139f04 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
81139e54:	e0bffe17 	ldw	r2,-8(fp)
81139e58:	10800c03 	ldbu	r2,48(r2)
81139e5c:	10803fcc 	andi	r2,r2,255
81139e60:	108000a0 	cmpeqi	r2,r2,2
81139e64:	10000e26 	beq	r2,zero,81139ea0 <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
81139e68:	e0bffe17 	ldw	r2,-8(fp)
81139e6c:	10800617 	ldw	r2,24(r2)
81139e70:	1000041e 	bne	r2,zero,81139e84 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
81139e74:	e0bffe17 	ldw	r2,-8(fp)
81139e78:	10800717 	ldw	r2,28(r2)
81139e7c:	e0bffd15 	stw	r2,-12(fp)
81139e80:	00000306 	br	81139e90 <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
81139e84:	e0bffe17 	ldw	r2,-8(fp)
81139e88:	10800617 	ldw	r2,24(r2)
81139e8c:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
81139e90:	113a9180 	call	8113a918 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
81139e94:	e0bfff17 	ldw	r2,-4(fp)
81139e98:	10000005 	stb	zero,0(r2)
                      break;
81139e9c:	00000706 	br	81139ebc <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
81139ea0:	e0bffe17 	ldw	r2,-8(fp)
81139ea4:	10800617 	ldw	r2,24(r2)
81139ea8:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
81139eac:	113a9180 	call	8113a918 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
81139eb0:	e0bfff17 	ldw	r2,-4(fp)
81139eb4:	10000005 	stb	zero,0(r2)
                      break;
81139eb8:	0001883a 	nop
             }
             return (remain);
81139ebc:	e0bffd17 	ldw	r2,-12(fp)
81139ec0:	00001006 	br	81139f04 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
81139ec4:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
81139ec8:	e0bfff17 	ldw	r2,-4(fp)
81139ecc:	10000005 	stb	zero,0(r2)
             return (0);
81139ed0:	0005883a 	mov	r2,zero
81139ed4:	00000b06 	br	81139f04 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
81139ed8:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
81139edc:	e0bfff17 	ldw	r2,-4(fp)
81139ee0:	00ffe1c4 	movi	r3,-121
81139ee4:	10c00005 	stb	r3,0(r2)
             return (0);
81139ee8:	0005883a 	mov	r2,zero
81139eec:	00000506 	br	81139f04 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
81139ef0:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
81139ef4:	e0bfff17 	ldw	r2,-4(fp)
81139ef8:	00ffe344 	movi	r3,-115
81139efc:	10c00005 	stb	r3,0(r2)
             return (0);
81139f00:	0005883a 	mov	r2,zero
    }
}
81139f04:	e037883a 	mov	sp,fp
81139f08:	dfc00117 	ldw	ra,4(sp)
81139f0c:	df000017 	ldw	fp,0(sp)
81139f10:	dec00204 	addi	sp,sp,8
81139f14:	f800283a 	ret

81139f18 <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
81139f18:	defffb04 	addi	sp,sp,-20
81139f1c:	de00012e 	bgeu	sp,et,81139f24 <OSTmrStateGet+0xc>
81139f20:	003b68fa 	trap	3
81139f24:	dfc00415 	stw	ra,16(sp)
81139f28:	df000315 	stw	fp,12(sp)
81139f2c:	df000304 	addi	fp,sp,12
81139f30:	e13ffe15 	stw	r4,-8(fp)
81139f34:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
81139f38:	e0bfff17 	ldw	r2,-4(fp)
81139f3c:	1000021e 	bne	r2,zero,81139f48 <OSTmrStateGet+0x30>
        return (0);
81139f40:	0005883a 	mov	r2,zero
81139f44:	00002a06 	br	81139ff0 <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
81139f48:	e0bffe17 	ldw	r2,-8(fp)
81139f4c:	1000051e 	bne	r2,zero,81139f64 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
81139f50:	e0bfff17 	ldw	r2,-4(fp)
81139f54:	00ffe284 	movi	r3,-118
81139f58:	10c00005 	stb	r3,0(r2)
        return (0);
81139f5c:	0005883a 	mov	r2,zero
81139f60:	00002306 	br	81139ff0 <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
81139f64:	e0bffe17 	ldw	r2,-8(fp)
81139f68:	10800003 	ldbu	r2,0(r2)
81139f6c:	10803fcc 	andi	r2,r2,255
81139f70:	10801920 	cmpeqi	r2,r2,100
81139f74:	1000051e 	bne	r2,zero,81139f8c <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
81139f78:	e0bfff17 	ldw	r2,-4(fp)
81139f7c:	00ffe244 	movi	r3,-119
81139f80:	10c00005 	stb	r3,0(r2)
        return (0);
81139f84:	0005883a 	mov	r2,zero
81139f88:	00001906 	br	81139ff0 <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
81139f8c:	d0a0a003 	ldbu	r2,-32128(gp)
81139f90:	10803fcc 	andi	r2,r2,255
81139f94:	10000526 	beq	r2,zero,81139fac <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
81139f98:	e0bfff17 	ldw	r2,-4(fp)
81139f9c:	00ffe2c4 	movi	r3,-117
81139fa0:	10c00005 	stb	r3,0(r2)
        return (0);
81139fa4:	0005883a 	mov	r2,zero
81139fa8:	00001106 	br	81139ff0 <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
81139fac:	113a8d40 	call	8113a8d4 <OSTmr_Lock>
    state = ptmr->OSTmrState;
81139fb0:	e0bffe17 	ldw	r2,-8(fp)
81139fb4:	10800c43 	ldbu	r2,49(r2)
81139fb8:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
81139fbc:	e0bffd03 	ldbu	r2,-12(fp)
81139fc0:	1005883a 	mov	r2,r2
81139fc4:	10800128 	cmpgeui	r2,r2,4
81139fc8:	1000031e 	bne	r2,zero,81139fd8 <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
81139fcc:	e0bfff17 	ldw	r2,-4(fp)
81139fd0:	10000005 	stb	zero,0(r2)
             break;
81139fd4:	00000406 	br	81139fe8 <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
81139fd8:	e0bfff17 	ldw	r2,-4(fp)
81139fdc:	00ffe344 	movi	r3,-115
81139fe0:	10c00005 	stb	r3,0(r2)
             break;
81139fe4:	0001883a 	nop
    }
    OSTmr_Unlock();
81139fe8:	113a9180 	call	8113a918 <OSTmr_Unlock>
    return (state);
81139fec:	e0bffd03 	ldbu	r2,-12(fp)
}
81139ff0:	e037883a 	mov	sp,fp
81139ff4:	dfc00117 	ldw	ra,4(sp)
81139ff8:	df000017 	ldw	fp,0(sp)
81139ffc:	dec00204 	addi	sp,sp,8
8113a000:	f800283a 	ret

8113a004 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
8113a004:	defffc04 	addi	sp,sp,-16
8113a008:	de00012e 	bgeu	sp,et,8113a010 <OSTmrStart+0xc>
8113a00c:	003b68fa 	trap	3
8113a010:	dfc00315 	stw	ra,12(sp)
8113a014:	df000215 	stw	fp,8(sp)
8113a018:	df000204 	addi	fp,sp,8
8113a01c:	e13ffe15 	stw	r4,-8(fp)
8113a020:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113a024:	e0bfff17 	ldw	r2,-4(fp)
8113a028:	1000021e 	bne	r2,zero,8113a034 <OSTmrStart+0x30>
        return (OS_FALSE);
8113a02c:	0005883a 	mov	r2,zero
8113a030:	00004106 	br	8113a138 <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
8113a034:	e0bffe17 	ldw	r2,-8(fp)
8113a038:	1000051e 	bne	r2,zero,8113a050 <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113a03c:	e0bfff17 	ldw	r2,-4(fp)
8113a040:	00ffe284 	movi	r3,-118
8113a044:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113a048:	0005883a 	mov	r2,zero
8113a04c:	00003a06 	br	8113a138 <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8113a050:	e0bffe17 	ldw	r2,-8(fp)
8113a054:	10800003 	ldbu	r2,0(r2)
8113a058:	10803fcc 	andi	r2,r2,255
8113a05c:	10801920 	cmpeqi	r2,r2,100
8113a060:	1000051e 	bne	r2,zero,8113a078 <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113a064:	e0bfff17 	ldw	r2,-4(fp)
8113a068:	00ffe244 	movi	r3,-119
8113a06c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113a070:	0005883a 	mov	r2,zero
8113a074:	00003006 	br	8113a138 <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113a078:	d0a0a003 	ldbu	r2,-32128(gp)
8113a07c:	10803fcc 	andi	r2,r2,255
8113a080:	10000526 	beq	r2,zero,8113a098 <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
8113a084:	e0bfff17 	ldw	r2,-4(fp)
8113a088:	00ffe2c4 	movi	r3,-117
8113a08c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113a090:	0005883a 	mov	r2,zero
8113a094:	00002806 	br	8113a138 <OSTmrStart+0x134>
    }
    OSTmr_Lock();
8113a098:	113a8d40 	call	8113a8d4 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113a09c:	e0bffe17 	ldw	r2,-8(fp)
8113a0a0:	10800c43 	ldbu	r2,49(r2)
8113a0a4:	10803fcc 	andi	r2,r2,255
8113a0a8:	10c000c8 	cmpgei	r3,r2,3
8113a0ac:	1800031e 	bne	r3,zero,8113a0bc <OSTmrStart+0xb8>
8113a0b0:	00800e16 	blt	zero,r2,8113a0ec <OSTmrStart+0xe8>
8113a0b4:	10001526 	beq	r2,zero,8113a10c <OSTmrStart+0x108>
8113a0b8:	00001a06 	br	8113a124 <OSTmrStart+0x120>
8113a0bc:	108000e0 	cmpeqi	r2,r2,3
8113a0c0:	10001826 	beq	r2,zero,8113a124 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
8113a0c4:	e13ffe17 	ldw	r4,-8(fp)
8113a0c8:	113a7d80 	call	8113a7d8 <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8113a0cc:	000b883a 	mov	r5,zero
8113a0d0:	e13ffe17 	ldw	r4,-8(fp)
8113a0d4:	113a6880 	call	8113a688 <OSTmr_Link>
             OSTmr_Unlock();
8113a0d8:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113a0dc:	e0bfff17 	ldw	r2,-4(fp)
8113a0e0:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113a0e4:	00800044 	movi	r2,1
8113a0e8:	00001306 	br	8113a138 <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8113a0ec:	000b883a 	mov	r5,zero
8113a0f0:	e13ffe17 	ldw	r4,-8(fp)
8113a0f4:	113a6880 	call	8113a688 <OSTmr_Link>
             OSTmr_Unlock();
8113a0f8:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113a0fc:	e0bfff17 	ldw	r2,-4(fp)
8113a100:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113a104:	00800044 	movi	r2,1
8113a108:	00000b06 	br	8113a138 <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
8113a10c:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113a110:	e0bfff17 	ldw	r2,-4(fp)
8113a114:	00ffe1c4 	movi	r3,-121
8113a118:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113a11c:	0005883a 	mov	r2,zero
8113a120:	00000506 	br	8113a138 <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
8113a124:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113a128:	e0bfff17 	ldw	r2,-4(fp)
8113a12c:	00ffe344 	movi	r3,-115
8113a130:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113a134:	0005883a 	mov	r2,zero
    }
}
8113a138:	e037883a 	mov	sp,fp
8113a13c:	dfc00117 	ldw	ra,4(sp)
8113a140:	df000017 	ldw	fp,0(sp)
8113a144:	dec00204 	addi	sp,sp,8
8113a148:	f800283a 	ret

8113a14c <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
8113a14c:	defff904 	addi	sp,sp,-28
8113a150:	de00012e 	bgeu	sp,et,8113a158 <OSTmrStop+0xc>
8113a154:	003b68fa 	trap	3
8113a158:	dfc00615 	stw	ra,24(sp)
8113a15c:	df000515 	stw	fp,20(sp)
8113a160:	df000504 	addi	fp,sp,20
8113a164:	e13ffc15 	stw	r4,-16(fp)
8113a168:	2805883a 	mov	r2,r5
8113a16c:	e1bffe15 	stw	r6,-8(fp)
8113a170:	e1ffff15 	stw	r7,-4(fp)
8113a174:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
8113a178:	e0bfff17 	ldw	r2,-4(fp)
8113a17c:	1000021e 	bne	r2,zero,8113a188 <OSTmrStop+0x3c>
        return (OS_FALSE);
8113a180:	0005883a 	mov	r2,zero
8113a184:	00006606 	br	8113a320 <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
8113a188:	e0bffc17 	ldw	r2,-16(fp)
8113a18c:	1000051e 	bne	r2,zero,8113a1a4 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
8113a190:	e0bfff17 	ldw	r2,-4(fp)
8113a194:	00ffe284 	movi	r3,-118
8113a198:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113a19c:	0005883a 	mov	r2,zero
8113a1a0:	00005f06 	br	8113a320 <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
8113a1a4:	e0bffc17 	ldw	r2,-16(fp)
8113a1a8:	10800003 	ldbu	r2,0(r2)
8113a1ac:	10803fcc 	andi	r2,r2,255
8113a1b0:	10801920 	cmpeqi	r2,r2,100
8113a1b4:	1000051e 	bne	r2,zero,8113a1cc <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113a1b8:	e0bfff17 	ldw	r2,-4(fp)
8113a1bc:	00ffe244 	movi	r3,-119
8113a1c0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113a1c4:	0005883a 	mov	r2,zero
8113a1c8:	00005506 	br	8113a320 <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
8113a1cc:	d0a0a003 	ldbu	r2,-32128(gp)
8113a1d0:	10803fcc 	andi	r2,r2,255
8113a1d4:	10000526 	beq	r2,zero,8113a1ec <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
8113a1d8:	e0bfff17 	ldw	r2,-4(fp)
8113a1dc:	00ffe2c4 	movi	r3,-117
8113a1e0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113a1e4:	0005883a 	mov	r2,zero
8113a1e8:	00004d06 	br	8113a320 <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
8113a1ec:	113a8d40 	call	8113a8d4 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113a1f0:	e0bffc17 	ldw	r2,-16(fp)
8113a1f4:	10800c43 	ldbu	r2,49(r2)
8113a1f8:	10803fcc 	andi	r2,r2,255
8113a1fc:	10c000c8 	cmpgei	r3,r2,3
8113a200:	1800031e 	bne	r3,zero,8113a210 <OSTmrStop+0xc4>
8113a204:	00803516 	blt	zero,r2,8113a2dc <OSTmrStop+0x190>
8113a208:	10003a26 	beq	r2,zero,8113a2f4 <OSTmrStop+0x1a8>
8113a20c:	00003f06 	br	8113a30c <OSTmrStop+0x1c0>
8113a210:	108000e0 	cmpeqi	r2,r2,3
8113a214:	10003d26 	beq	r2,zero,8113a30c <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
8113a218:	e13ffc17 	ldw	r4,-16(fp)
8113a21c:	113a7d80 	call	8113a7d8 <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
8113a220:	e0bfff17 	ldw	r2,-4(fp)
8113a224:	10000005 	stb	zero,0(r2)
             switch (opt) {
8113a228:	e0bffd03 	ldbu	r2,-12(fp)
8113a22c:	10c000e0 	cmpeqi	r3,r2,3
8113a230:	1800041e 	bne	r3,zero,8113a244 <OSTmrStop+0xf8>
8113a234:	10c00120 	cmpeqi	r3,r2,4
8113a238:	1800121e 	bne	r3,zero,8113a284 <OSTmrStop+0x138>
8113a23c:	10002326 	beq	r2,zero,8113a2cc <OSTmrStop+0x180>
8113a240:	00001e06 	br	8113a2bc <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8113a244:	e0bffc17 	ldw	r2,-16(fp)
8113a248:	10800117 	ldw	r2,4(r2)
8113a24c:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113a250:	e0bffb17 	ldw	r2,-20(fp)
8113a254:	10000726 	beq	r2,zero,8113a274 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
8113a258:	e0bffc17 	ldw	r2,-16(fp)
8113a25c:	10c00217 	ldw	r3,8(r2)
8113a260:	e0bffb17 	ldw	r2,-20(fp)
8113a264:	180b883a 	mov	r5,r3
8113a268:	e13ffc17 	ldw	r4,-16(fp)
8113a26c:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8113a270:	00001706 	br	8113a2d0 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8113a274:	e0bfff17 	ldw	r2,-4(fp)
8113a278:	00ffe3c4 	movi	r3,-113
8113a27c:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8113a280:	00001306 	br	8113a2d0 <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8113a284:	e0bffc17 	ldw	r2,-16(fp)
8113a288:	10800117 	ldw	r2,4(r2)
8113a28c:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113a290:	e0bffb17 	ldw	r2,-20(fp)
8113a294:	10000526 	beq	r2,zero,8113a2ac <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
8113a298:	e0bffb17 	ldw	r2,-20(fp)
8113a29c:	e17ffe17 	ldw	r5,-8(fp)
8113a2a0:	e13ffc17 	ldw	r4,-16(fp)
8113a2a4:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8113a2a8:	00000906 	br	8113a2d0 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8113a2ac:	e0bfff17 	ldw	r2,-4(fp)
8113a2b0:	00ffe3c4 	movi	r3,-113
8113a2b4:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8113a2b8:	00000506 	br	8113a2d0 <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
8113a2bc:	e0bfff17 	ldw	r2,-4(fp)
8113a2c0:	00ffe104 	movi	r3,-124
8113a2c4:	10c00005 	stb	r3,0(r2)
                     break;
8113a2c8:	00000106 	br	8113a2d0 <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
8113a2cc:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
8113a2d0:	113a9180 	call	8113a918 <OSTmr_Unlock>
             return (OS_TRUE);
8113a2d4:	00800044 	movi	r2,1
8113a2d8:	00001106 	br	8113a320 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
8113a2dc:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
8113a2e0:	e0bfff17 	ldw	r2,-4(fp)
8113a2e4:	00ffe384 	movi	r3,-114
8113a2e8:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
8113a2ec:	00800044 	movi	r2,1
8113a2f0:	00000b06 	br	8113a320 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
8113a2f4:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113a2f8:	e0bfff17 	ldw	r2,-4(fp)
8113a2fc:	00ffe1c4 	movi	r3,-121
8113a300:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113a304:	0005883a 	mov	r2,zero
8113a308:	00000506 	br	8113a320 <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
8113a30c:	113a9180 	call	8113a918 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113a310:	e0bfff17 	ldw	r2,-4(fp)
8113a314:	00ffe344 	movi	r3,-115
8113a318:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113a31c:	0005883a 	mov	r2,zero
    }
}
8113a320:	e037883a 	mov	sp,fp
8113a324:	dfc00117 	ldw	ra,4(sp)
8113a328:	df000017 	ldw	fp,0(sp)
8113a32c:	dec00204 	addi	sp,sp,8
8113a330:	f800283a 	ret

8113a334 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
8113a334:	defffd04 	addi	sp,sp,-12
8113a338:	de00012e 	bgeu	sp,et,8113a340 <OSTmrSignal+0xc>
8113a33c:	003b68fa 	trap	3
8113a340:	dfc00215 	stw	ra,8(sp)
8113a344:	df000115 	stw	fp,4(sp)
8113a348:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
8113a34c:	d0a08f17 	ldw	r2,-32196(gp)
8113a350:	1009883a 	mov	r4,r2
8113a354:	11379000 	call	81137900 <OSSemPost>
8113a358:	e0bfff05 	stb	r2,-4(fp)
    return (err);
8113a35c:	e0bfff03 	ldbu	r2,-4(fp)
}
8113a360:	e037883a 	mov	sp,fp
8113a364:	dfc00117 	ldw	ra,4(sp)
8113a368:	df000017 	ldw	fp,0(sp)
8113a36c:	dec00204 	addi	sp,sp,8
8113a370:	f800283a 	ret

8113a374 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
8113a374:	defffe04 	addi	sp,sp,-8
8113a378:	de00012e 	bgeu	sp,et,8113a380 <OSTmr_Alloc+0xc>
8113a37c:	003b68fa 	trap	3
8113a380:	df000115 	stw	fp,4(sp)
8113a384:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
8113a388:	d0a08d17 	ldw	r2,-32204(gp)
8113a38c:	1000021e 	bne	r2,zero,8113a398 <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
8113a390:	0005883a 	mov	r2,zero
8113a394:	00001006 	br	8113a3d8 <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
8113a398:	d0a08d17 	ldw	r2,-32204(gp)
8113a39c:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
8113a3a0:	e0bfff17 	ldw	r2,-4(fp)
8113a3a4:	10800317 	ldw	r2,12(r2)
8113a3a8:	d0a08d15 	stw	r2,-32204(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
8113a3ac:	e0bfff17 	ldw	r2,-4(fp)
8113a3b0:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
8113a3b4:	e0bfff17 	ldw	r2,-4(fp)
8113a3b8:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
8113a3bc:	d0a0920b 	ldhu	r2,-32184(gp)
8113a3c0:	10800044 	addi	r2,r2,1
8113a3c4:	d0a0920d 	sth	r2,-32184(gp)
    OSTmrFree--;
8113a3c8:	d0a0960b 	ldhu	r2,-32168(gp)
8113a3cc:	10bfffc4 	addi	r2,r2,-1
8113a3d0:	d0a0960d 	sth	r2,-32168(gp)
    return (ptmr);
8113a3d4:	e0bfff17 	ldw	r2,-4(fp)
}
8113a3d8:	e037883a 	mov	sp,fp
8113a3dc:	df000017 	ldw	fp,0(sp)
8113a3e0:	dec00104 	addi	sp,sp,4
8113a3e4:	f800283a 	ret

8113a3e8 <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
8113a3e8:	defffe04 	addi	sp,sp,-8
8113a3ec:	de00012e 	bgeu	sp,et,8113a3f4 <OSTmr_Free+0xc>
8113a3f0:	003b68fa 	trap	3
8113a3f4:	df000115 	stw	fp,4(sp)
8113a3f8:	df000104 	addi	fp,sp,4
8113a3fc:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
8113a400:	e0bfff17 	ldw	r2,-4(fp)
8113a404:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
8113a408:	e0bfff17 	ldw	r2,-4(fp)
8113a40c:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
8113a410:	e0bfff17 	ldw	r2,-4(fp)
8113a414:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
8113a418:	e0bfff17 	ldw	r2,-4(fp)
8113a41c:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
8113a420:	e0bfff17 	ldw	r2,-4(fp)
8113a424:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
8113a428:	e0bfff17 	ldw	r2,-4(fp)
8113a42c:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
8113a430:	e0bfff17 	ldw	r2,-4(fp)
8113a434:	00c00fc4 	movi	r3,63
8113a438:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
8113a43c:	e0bfff17 	ldw	r2,-4(fp)
8113a440:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
8113a444:	e0bfff17 	ldw	r2,-4(fp)
8113a448:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
8113a44c:	d0e08d17 	ldw	r3,-32204(gp)
8113a450:	e0bfff17 	ldw	r2,-4(fp)
8113a454:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
8113a458:	e0bfff17 	ldw	r2,-4(fp)
8113a45c:	d0a08d15 	stw	r2,-32204(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
8113a460:	d0a0920b 	ldhu	r2,-32184(gp)
8113a464:	10bfffc4 	addi	r2,r2,-1
8113a468:	d0a0920d 	sth	r2,-32184(gp)
    OSTmrFree++;
8113a46c:	d0a0960b 	ldhu	r2,-32168(gp)
8113a470:	10800044 	addi	r2,r2,1
8113a474:	d0a0960d 	sth	r2,-32168(gp)
}
8113a478:	0001883a 	nop
8113a47c:	e037883a 	mov	sp,fp
8113a480:	df000017 	ldw	fp,0(sp)
8113a484:	dec00104 	addi	sp,sp,4
8113a488:	f800283a 	ret

8113a48c <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
8113a48c:	defffa04 	addi	sp,sp,-24
8113a490:	de00012e 	bgeu	sp,et,8113a498 <OSTmr_Init+0xc>
8113a494:	003b68fa 	trap	3
8113a498:	dfc00515 	stw	ra,20(sp)
8113a49c:	df000415 	stw	fp,16(sp)
8113a4a0:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
8113a4a4:	01406804 	movi	r5,416
8113a4a8:	012045b4 	movhi	r4,33046
8113a4ac:	212ef604 	addi	r4,r4,-17448
8113a4b0:	11325fc0 	call	811325fc <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
8113a4b4:	01400404 	movi	r5,16
8113a4b8:	012045b4 	movhi	r4,33046
8113a4bc:	212ce204 	addi	r4,r4,-19576
8113a4c0:	11325fc0 	call	811325fc <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
8113a4c4:	00a045b4 	movhi	r2,33046
8113a4c8:	10aef604 	addi	r2,r2,-17448
8113a4cc:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
8113a4d0:	00a045b4 	movhi	r2,33046
8113a4d4:	10af0304 	addi	r2,r2,-17396
8113a4d8:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8113a4dc:	e03ffc0d 	sth	zero,-16(fp)
8113a4e0:	00001606 	br	8113a53c <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
8113a4e4:	e0bffd17 	ldw	r2,-12(fp)
8113a4e8:	00c01904 	movi	r3,100
8113a4ec:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
8113a4f0:	e0bffd17 	ldw	r2,-12(fp)
8113a4f4:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
8113a4f8:	e0bffd17 	ldw	r2,-12(fp)
8113a4fc:	e0fffe17 	ldw	r3,-8(fp)
8113a500:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
8113a504:	e0bffd17 	ldw	r2,-12(fp)
8113a508:	00c00fc4 	movi	r3,63
8113a50c:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8113a510:	e0bffd17 	ldw	r2,-12(fp)
8113a514:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
8113a518:	e0bffd17 	ldw	r2,-12(fp)
8113a51c:	10800d04 	addi	r2,r2,52
8113a520:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
8113a524:	e0bffe17 	ldw	r2,-8(fp)
8113a528:	10800d04 	addi	r2,r2,52
8113a52c:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8113a530:	e0bffc0b 	ldhu	r2,-16(fp)
8113a534:	10800044 	addi	r2,r2,1
8113a538:	e0bffc0d 	sth	r2,-16(fp)
8113a53c:	e0bffc0b 	ldhu	r2,-16(fp)
8113a540:	108001f0 	cmpltui	r2,r2,7
8113a544:	103fe71e 	bne	r2,zero,8113a4e4 <__reset+0xfb11a4e4>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
8113a548:	e0bffd17 	ldw	r2,-12(fp)
8113a54c:	00c01904 	movi	r3,100
8113a550:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
8113a554:	e0bffd17 	ldw	r2,-12(fp)
8113a558:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
8113a55c:	e0bffd17 	ldw	r2,-12(fp)
8113a560:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
8113a564:	e0bffd17 	ldw	r2,-12(fp)
8113a568:	00c00fc4 	movi	r3,63
8113a56c:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8113a570:	e0bffd17 	ldw	r2,-12(fp)
8113a574:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
8113a578:	d020a215 	stw	zero,-32120(gp)
    OSTmrUsed           = 0;
8113a57c:	d020920d 	sth	zero,-32184(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
8113a580:	00800204 	movi	r2,8
8113a584:	d0a0960d 	sth	r2,-32168(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
8113a588:	00a045b4 	movhi	r2,33046
8113a58c:	10aef604 	addi	r2,r2,-17448
8113a590:	d0a08d15 	stw	r2,-32204(gp)
    OSTmrSem            = OSSemCreate(1);
8113a594:	01000044 	movi	r4,1
8113a598:	11372500 	call	81137250 <OSSemCreate>
8113a59c:	d0a0a415 	stw	r2,-32112(gp)
    OSTmrSemSignal      = OSSemCreate(0);
8113a5a0:	0009883a 	mov	r4,zero
8113a5a4:	11372500 	call	81137250 <OSSemCreate>
8113a5a8:	d0a08f15 	stw	r2,-32196(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
8113a5ac:	d0a0a417 	ldw	r2,-32112(gp)
8113a5b0:	e0ffff04 	addi	r3,fp,-4
8113a5b4:	180d883a 	mov	r6,r3
8113a5b8:	01604534 	movhi	r5,33044
8113a5bc:	2955e204 	addi	r5,r5,22408
8113a5c0:	1009883a 	mov	r4,r2
8113a5c4:	1130e580 	call	81130e58 <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
8113a5c8:	d0a08f17 	ldw	r2,-32196(gp)
8113a5cc:	e0ffff04 	addi	r3,fp,-4
8113a5d0:	180d883a 	mov	r6,r3
8113a5d4:	01604534 	movhi	r5,33044
8113a5d8:	2955e704 	addi	r5,r5,22428
8113a5dc:	1009883a 	mov	r4,r2
8113a5e0:	1130e580 	call	81130e58 <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
8113a5e4:	113a6000 	call	8113a600 <OSTmr_InitTask>
}
8113a5e8:	0001883a 	nop
8113a5ec:	e037883a 	mov	sp,fp
8113a5f0:	dfc00117 	ldw	ra,4(sp)
8113a5f4:	df000017 	ldw	fp,0(sp)
8113a5f8:	dec00204 	addi	sp,sp,8
8113a5fc:	f800283a 	ret

8113a600 <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
8113a600:	defff804 	addi	sp,sp,-32
8113a604:	de00012e 	bgeu	sp,et,8113a60c <OSTmr_InitTask+0xc>
8113a608:	003b68fa 	trap	3
8113a60c:	dfc00715 	stw	ra,28(sp)
8113a610:	df000615 	stw	fp,24(sp)
8113a614:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
8113a618:	008000c4 	movi	r2,3
8113a61c:	d8800415 	stw	r2,16(sp)
8113a620:	d8000315 	stw	zero,12(sp)
8113a624:	00808004 	movi	r2,512
8113a628:	d8800215 	stw	r2,8(sp)
8113a62c:	00a045b4 	movhi	r2,33046
8113a630:	10b72a04 	addi	r2,r2,-9048
8113a634:	d8800115 	stw	r2,4(sp)
8113a638:	00bfff54 	movui	r2,65533
8113a63c:	d8800015 	stw	r2,0(sp)
8113a640:	01c00744 	movi	r7,29
8113a644:	01a045b4 	movhi	r6,33046
8113a648:	31b92904 	addi	r6,r6,-7004
8113a64c:	000b883a 	mov	r5,zero
8113a650:	01204534 	movhi	r4,33044
8113a654:	212a5504 	addi	r4,r4,-22188
8113a658:	11382e40 	call	811382e4 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
8113a65c:	e1bfff04 	addi	r6,fp,-4
8113a660:	01604534 	movhi	r5,33044
8113a664:	2955ec04 	addi	r5,r5,22448
8113a668:	01000744 	movi	r4,29
8113a66c:	1138b140 	call	81138b14 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
8113a670:	0001883a 	nop
8113a674:	e037883a 	mov	sp,fp
8113a678:	dfc00117 	ldw	ra,4(sp)
8113a67c:	df000017 	ldw	fp,0(sp)
8113a680:	dec00204 	addi	sp,sp,8
8113a684:	f800283a 	ret

8113a688 <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
8113a688:	defffa04 	addi	sp,sp,-24
8113a68c:	de00012e 	bgeu	sp,et,8113a694 <OSTmr_Link+0xc>
8113a690:	003b68fa 	trap	3
8113a694:	df000515 	stw	fp,20(sp)
8113a698:	df000504 	addi	fp,sp,20
8113a69c:	e13ffe15 	stw	r4,-8(fp)
8113a6a0:	2805883a 	mov	r2,r5
8113a6a4:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
8113a6a8:	e0bffe17 	ldw	r2,-8(fp)
8113a6ac:	00c000c4 	movi	r3,3
8113a6b0:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
8113a6b4:	e0bfff03 	ldbu	r2,-4(fp)
8113a6b8:	10800058 	cmpnei	r2,r2,1
8113a6bc:	1000071e 	bne	r2,zero,8113a6dc <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8113a6c0:	e0bffe17 	ldw	r2,-8(fp)
8113a6c4:	10c00717 	ldw	r3,28(r2)
8113a6c8:	d0a0a217 	ldw	r2,-32120(gp)
8113a6cc:	1887883a 	add	r3,r3,r2
8113a6d0:	e0bffe17 	ldw	r2,-8(fp)
8113a6d4:	10c00515 	stw	r3,20(r2)
8113a6d8:	00001006 	br	8113a71c <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
8113a6dc:	e0bffe17 	ldw	r2,-8(fp)
8113a6e0:	10800617 	ldw	r2,24(r2)
8113a6e4:	1000071e 	bne	r2,zero,8113a704 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8113a6e8:	e0bffe17 	ldw	r2,-8(fp)
8113a6ec:	10c00717 	ldw	r3,28(r2)
8113a6f0:	d0a0a217 	ldw	r2,-32120(gp)
8113a6f4:	1887883a 	add	r3,r3,r2
8113a6f8:	e0bffe17 	ldw	r2,-8(fp)
8113a6fc:	10c00515 	stw	r3,20(r2)
8113a700:	00000606 	br	8113a71c <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
8113a704:	e0bffe17 	ldw	r2,-8(fp)
8113a708:	10c00617 	ldw	r3,24(r2)
8113a70c:	d0a0a217 	ldw	r2,-32120(gp)
8113a710:	1887883a 	add	r3,r3,r2
8113a714:	e0bffe17 	ldw	r2,-8(fp)
8113a718:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8113a71c:	e0bffe17 	ldw	r2,-8(fp)
8113a720:	10800517 	ldw	r2,20(r2)
8113a724:	1080004c 	andi	r2,r2,1
8113a728:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8113a72c:	e0bffb0b 	ldhu	r2,-20(fp)
8113a730:	100690fa 	slli	r3,r2,3
8113a734:	00a045b4 	movhi	r2,33046
8113a738:	10ace204 	addi	r2,r2,-19576
8113a73c:	1885883a 	add	r2,r3,r2
8113a740:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
8113a744:	e0bffc17 	ldw	r2,-16(fp)
8113a748:	10800017 	ldw	r2,0(r2)
8113a74c:	1000091e 	bne	r2,zero,8113a774 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
8113a750:	e0bffc17 	ldw	r2,-16(fp)
8113a754:	e0fffe17 	ldw	r3,-8(fp)
8113a758:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
8113a75c:	e0bffe17 	ldw	r2,-8(fp)
8113a760:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
8113a764:	e0bffc17 	ldw	r2,-16(fp)
8113a768:	00c00044 	movi	r3,1
8113a76c:	10c0010d 	sth	r3,4(r2)
8113a770:	00001206 	br	8113a7bc <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
8113a774:	e0bffc17 	ldw	r2,-16(fp)
8113a778:	10800017 	ldw	r2,0(r2)
8113a77c:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
8113a780:	e0bffc17 	ldw	r2,-16(fp)
8113a784:	e0fffe17 	ldw	r3,-8(fp)
8113a788:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
8113a78c:	e0bffe17 	ldw	r2,-8(fp)
8113a790:	e0fffd17 	ldw	r3,-12(fp)
8113a794:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
8113a798:	e0bffd17 	ldw	r2,-12(fp)
8113a79c:	e0fffe17 	ldw	r3,-8(fp)
8113a7a0:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
8113a7a4:	e0bffc17 	ldw	r2,-16(fp)
8113a7a8:	1080010b 	ldhu	r2,4(r2)
8113a7ac:	10800044 	addi	r2,r2,1
8113a7b0:	1007883a 	mov	r3,r2
8113a7b4:	e0bffc17 	ldw	r2,-16(fp)
8113a7b8:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
8113a7bc:	e0bffe17 	ldw	r2,-8(fp)
8113a7c0:	10000415 	stw	zero,16(r2)
}
8113a7c4:	0001883a 	nop
8113a7c8:	e037883a 	mov	sp,fp
8113a7cc:	df000017 	ldw	fp,0(sp)
8113a7d0:	dec00104 	addi	sp,sp,4
8113a7d4:	f800283a 	ret

8113a7d8 <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
8113a7d8:	defffa04 	addi	sp,sp,-24
8113a7dc:	de00012e 	bgeu	sp,et,8113a7e4 <OSTmr_Unlink+0xc>
8113a7e0:	003b68fa 	trap	3
8113a7e4:	df000515 	stw	fp,20(sp)
8113a7e8:	df000504 	addi	fp,sp,20
8113a7ec:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8113a7f0:	e0bfff17 	ldw	r2,-4(fp)
8113a7f4:	10800517 	ldw	r2,20(r2)
8113a7f8:	1080004c 	andi	r2,r2,1
8113a7fc:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8113a800:	e0bffb0b 	ldhu	r2,-20(fp)
8113a804:	100690fa 	slli	r3,r2,3
8113a808:	00a045b4 	movhi	r2,33046
8113a80c:	10ace204 	addi	r2,r2,-19576
8113a810:	1885883a 	add	r2,r3,r2
8113a814:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
8113a818:	e0bffc17 	ldw	r2,-16(fp)
8113a81c:	10c00017 	ldw	r3,0(r2)
8113a820:	e0bfff17 	ldw	r2,-4(fp)
8113a824:	18800b1e 	bne	r3,r2,8113a854 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
8113a828:	e0bfff17 	ldw	r2,-4(fp)
8113a82c:	10800317 	ldw	r2,12(r2)
8113a830:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
8113a834:	e0bffc17 	ldw	r2,-16(fp)
8113a838:	e0fffd17 	ldw	r3,-12(fp)
8113a83c:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
8113a840:	e0bffd17 	ldw	r2,-12(fp)
8113a844:	10001126 	beq	r2,zero,8113a88c <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
8113a848:	e0bffd17 	ldw	r2,-12(fp)
8113a84c:	10000415 	stw	zero,16(r2)
8113a850:	00000e06 	br	8113a88c <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
8113a854:	e0bfff17 	ldw	r2,-4(fp)
8113a858:	10800417 	ldw	r2,16(r2)
8113a85c:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
8113a860:	e0bfff17 	ldw	r2,-4(fp)
8113a864:	10800317 	ldw	r2,12(r2)
8113a868:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
8113a86c:	e0bffd17 	ldw	r2,-12(fp)
8113a870:	e0fffe17 	ldw	r3,-8(fp)
8113a874:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
8113a878:	e0bffe17 	ldw	r2,-8(fp)
8113a87c:	10000326 	beq	r2,zero,8113a88c <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
8113a880:	e0bffe17 	ldw	r2,-8(fp)
8113a884:	e0fffd17 	ldw	r3,-12(fp)
8113a888:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
8113a88c:	e0bfff17 	ldw	r2,-4(fp)
8113a890:	00c00044 	movi	r3,1
8113a894:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
8113a898:	e0bfff17 	ldw	r2,-4(fp)
8113a89c:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
8113a8a0:	e0bfff17 	ldw	r2,-4(fp)
8113a8a4:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
8113a8a8:	e0bffc17 	ldw	r2,-16(fp)
8113a8ac:	1080010b 	ldhu	r2,4(r2)
8113a8b0:	10bfffc4 	addi	r2,r2,-1
8113a8b4:	1007883a 	mov	r3,r2
8113a8b8:	e0bffc17 	ldw	r2,-16(fp)
8113a8bc:	10c0010d 	sth	r3,4(r2)
}
8113a8c0:	0001883a 	nop
8113a8c4:	e037883a 	mov	sp,fp
8113a8c8:	df000017 	ldw	fp,0(sp)
8113a8cc:	dec00104 	addi	sp,sp,4
8113a8d0:	f800283a 	ret

8113a8d4 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
8113a8d4:	defffd04 	addi	sp,sp,-12
8113a8d8:	de00012e 	bgeu	sp,et,8113a8e0 <OSTmr_Lock+0xc>
8113a8dc:	003b68fa 	trap	3
8113a8e0:	dfc00215 	stw	ra,8(sp)
8113a8e4:	df000115 	stw	fp,4(sp)
8113a8e8:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
8113a8ec:	d0a0a417 	ldw	r2,-32112(gp)
8113a8f0:	e1bfff04 	addi	r6,fp,-4
8113a8f4:	000b883a 	mov	r5,zero
8113a8f8:	1009883a 	mov	r4,r2
8113a8fc:	11375780 	call	81137578 <OSSemPend>
    (void)err;
}
8113a900:	0001883a 	nop
8113a904:	e037883a 	mov	sp,fp
8113a908:	dfc00117 	ldw	ra,4(sp)
8113a90c:	df000017 	ldw	fp,0(sp)
8113a910:	dec00204 	addi	sp,sp,8
8113a914:	f800283a 	ret

8113a918 <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
8113a918:	defffe04 	addi	sp,sp,-8
8113a91c:	de00012e 	bgeu	sp,et,8113a924 <OSTmr_Unlock+0xc>
8113a920:	003b68fa 	trap	3
8113a924:	dfc00115 	stw	ra,4(sp)
8113a928:	df000015 	stw	fp,0(sp)
8113a92c:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
8113a930:	d0a0a417 	ldw	r2,-32112(gp)
8113a934:	1009883a 	mov	r4,r2
8113a938:	11379000 	call	81137900 <OSSemPost>
}
8113a93c:	0001883a 	nop
8113a940:	e037883a 	mov	sp,fp
8113a944:	dfc00117 	ldw	ra,4(sp)
8113a948:	df000017 	ldw	fp,0(sp)
8113a94c:	dec00204 	addi	sp,sp,8
8113a950:	f800283a 	ret

8113a954 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
8113a954:	defff704 	addi	sp,sp,-36
8113a958:	de00012e 	bgeu	sp,et,8113a960 <OSTmr_Task+0xc>
8113a95c:	003b68fa 	trap	3
8113a960:	dfc00815 	stw	ra,32(sp)
8113a964:	df000715 	stw	fp,28(sp)
8113a968:	df000704 	addi	fp,sp,28
8113a96c:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
8113a970:	d0a08f17 	ldw	r2,-32196(gp)
8113a974:	e0fffe04 	addi	r3,fp,-8
8113a978:	180d883a 	mov	r6,r3
8113a97c:	000b883a 	mov	r5,zero
8113a980:	1009883a 	mov	r4,r2
8113a984:	11375780 	call	81137578 <OSSemPend>
        OSTmr_Lock();
8113a988:	113a8d40 	call	8113a8d4 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
8113a98c:	d0a0a217 	ldw	r2,-32120(gp)
8113a990:	10800044 	addi	r2,r2,1
8113a994:	d0a0a215 	stw	r2,-32120(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
8113a998:	d0a0a217 	ldw	r2,-32120(gp)
8113a99c:	1080004c 	andi	r2,r2,1
8113a9a0:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
8113a9a4:	e0bffa0b 	ldhu	r2,-24(fp)
8113a9a8:	100690fa 	slli	r3,r2,3
8113a9ac:	00a045b4 	movhi	r2,33046
8113a9b0:	10ace204 	addi	r2,r2,-19576
8113a9b4:	1885883a 	add	r2,r3,r2
8113a9b8:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
8113a9bc:	e0bffb17 	ldw	r2,-20(fp)
8113a9c0:	10800017 	ldw	r2,0(r2)
8113a9c4:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
8113a9c8:	00002206 	br	8113aa54 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
8113a9cc:	e0bff917 	ldw	r2,-28(fp)
8113a9d0:	10800317 	ldw	r2,12(r2)
8113a9d4:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
8113a9d8:	e0bff917 	ldw	r2,-28(fp)
8113a9dc:	10c00517 	ldw	r3,20(r2)
8113a9e0:	d0a0a217 	ldw	r2,-32120(gp)
8113a9e4:	1880191e 	bne	r3,r2,8113aa4c <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
8113a9e8:	e0bff917 	ldw	r2,-28(fp)
8113a9ec:	10800117 	ldw	r2,4(r2)
8113a9f0:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
8113a9f4:	e0bffd17 	ldw	r2,-12(fp)
8113a9f8:	10000626 	beq	r2,zero,8113aa14 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
8113a9fc:	e0bff917 	ldw	r2,-28(fp)
8113aa00:	10c00217 	ldw	r3,8(r2)
8113aa04:	e0bffd17 	ldw	r2,-12(fp)
8113aa08:	180b883a 	mov	r5,r3
8113aa0c:	e13ff917 	ldw	r4,-28(fp)
8113aa10:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
8113aa14:	e13ff917 	ldw	r4,-28(fp)
8113aa18:	113a7d80 	call	8113a7d8 <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
8113aa1c:	e0bff917 	ldw	r2,-28(fp)
8113aa20:	10800c03 	ldbu	r2,48(r2)
8113aa24:	10803fcc 	andi	r2,r2,255
8113aa28:	10800098 	cmpnei	r2,r2,2
8113aa2c:	1000041e 	bne	r2,zero,8113aa40 <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
8113aa30:	01400044 	movi	r5,1
8113aa34:	e13ff917 	ldw	r4,-28(fp)
8113aa38:	113a6880 	call	8113a688 <OSTmr_Link>
8113aa3c:	00000306 	br	8113aa4c <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
8113aa40:	e0bff917 	ldw	r2,-28(fp)
8113aa44:	00c00084 	movi	r3,2
8113aa48:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
8113aa4c:	e0bffc17 	ldw	r2,-16(fp)
8113aa50:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
8113aa54:	e0bff917 	ldw	r2,-28(fp)
8113aa58:	103fdc1e 	bne	r2,zero,8113a9cc <__reset+0xfb11a9cc>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
8113aa5c:	113a9180 	call	8113a918 <OSTmr_Unlock>
    }
8113aa60:	003fc306 	br	8113a970 <__reset+0xfb11a970>

8113aa64 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
8113aa64:	defffd04 	addi	sp,sp,-12
8113aa68:	de00012e 	bgeu	sp,et,8113aa70 <alt_dev_reg+0xc>
8113aa6c:	003b68fa 	trap	3
8113aa70:	dfc00215 	stw	ra,8(sp)
8113aa74:	df000115 	stw	fp,4(sp)
8113aa78:	df000104 	addi	fp,sp,4
8113aa7c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
8113aa80:	d1600d04 	addi	r5,gp,-32716
8113aa84:	e13fff17 	ldw	r4,-4(fp)
8113aa88:	1142d040 	call	81142d04 <alt_dev_llist_insert>
}
8113aa8c:	e037883a 	mov	sp,fp
8113aa90:	dfc00117 	ldw	ra,4(sp)
8113aa94:	df000017 	ldw	fp,0(sp)
8113aa98:	dec00204 	addi	sp,sp,8
8113aa9c:	f800283a 	ret

8113aaa0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
8113aaa0:	defffd04 	addi	sp,sp,-12
8113aaa4:	de00012e 	bgeu	sp,et,8113aaac <alt_irq_init+0xc>
8113aaa8:	003b68fa 	trap	3
8113aaac:	dfc00215 	stw	ra,8(sp)
8113aab0:	df000115 	stw	fp,4(sp)
8113aab4:	df000104 	addi	fp,sp,4
8113aab8:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
8113aabc:	11437440 	call	81143744 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
8113aac0:	00800044 	movi	r2,1
8113aac4:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
8113aac8:	0001883a 	nop
8113aacc:	e037883a 	mov	sp,fp
8113aad0:	dfc00117 	ldw	ra,4(sp)
8113aad4:	df000017 	ldw	fp,0(sp)
8113aad8:	dec00204 	addi	sp,sp,8
8113aadc:	f800283a 	ret

8113aae0 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
8113aae0:	defffe04 	addi	sp,sp,-8
8113aae4:	de00012e 	bgeu	sp,et,8113aaec <alt_sys_init+0xc>
8113aae8:	003b68fa 	trap	3
8113aaec:	dfc00115 	stw	ra,4(sp)
8113aaf0:	df000015 	stw	fp,0(sp)
8113aaf4:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
8113aaf8:	01c0fa04 	movi	r7,1000
8113aafc:	01800304 	movi	r6,12
8113ab00:	000b883a 	mov	r5,zero
8113ab04:	01200034 	movhi	r4,32768
8113ab08:	21022004 	addi	r4,r4,2176
8113ab0c:	113fe380 	call	8113fe38 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
8113ab10:	018002c4 	movi	r6,11
8113ab14:	000b883a 	mov	r5,zero
8113ab18:	01204534 	movhi	r4,33044
8113ab1c:	21198804 	addi	r4,r4,26144
8113ab20:	113f1240 	call	8113f124 <altera_avalon_jtag_uart_init>
8113ab24:	01204534 	movhi	r4,33044
8113ab28:	21197e04 	addi	r4,r4,26104
8113ab2c:	113aa640 	call	8113aa64 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
8113ab30:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
8113ab34:	018003c4 	movi	r6,15
8113ab38:	000b883a 	mov	r5,zero
8113ab3c:	01204534 	movhi	r4,33044
8113ab40:	211da304 	addi	r4,r4,30348
8113ab44:	113ffe40 	call	8113ffe4 <altera_avalon_uart_init>
8113ab48:	01204534 	movhi	r4,33044
8113ab4c:	211d9904 	addi	r4,r4,30308
8113ab50:	113aa640 	call	8113aa64 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
8113ab54:	00a04534 	movhi	r2,33044
8113ab58:	109dcd04 	addi	r2,r2,30516
8113ab5c:	10c00717 	ldw	r3,28(r2)
8113ab60:	00a04534 	movhi	r2,33044
8113ab64:	109dcd04 	addi	r2,r2,30516
8113ab68:	10800817 	ldw	r2,32(r2)
8113ab6c:	100d883a 	mov	r6,r2
8113ab70:	180b883a 	mov	r5,r3
8113ab74:	01204534 	movhi	r4,33044
8113ab78:	211dcd04 	addi	r4,r4,30516
8113ab7c:	114286c0 	call	8114286c <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
8113ab80:	00a04534 	movhi	r2,33044
8113ab84:	109de604 	addi	r2,r2,30616
8113ab88:	10c00717 	ldw	r3,28(r2)
8113ab8c:	00a04534 	movhi	r2,33044
8113ab90:	109de604 	addi	r2,r2,30616
8113ab94:	10800817 	ldw	r2,32(r2)
8113ab98:	100d883a 	mov	r6,r2
8113ab9c:	180b883a 	mov	r5,r3
8113aba0:	01204534 	movhi	r4,33044
8113aba4:	211de604 	addi	r4,r4,30616
8113aba8:	114286c0 	call	8114286c <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
8113abac:	01204534 	movhi	r4,33044
8113abb0:	211dff04 	addi	r4,r4,30716
8113abb4:	113aa640 	call	8113aa64 <alt_dev_reg>
}
8113abb8:	0001883a 	nop
8113abbc:	e037883a 	mov	sp,fp
8113abc0:	dfc00117 	ldw	ra,4(sp)
8113abc4:	df000017 	ldw	fp,0(sp)
8113abc8:	dec00204 	addi	sp,sp,8
8113abcc:	f800283a 	ret

8113abd0 <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
8113abd0:	defffa04 	addi	sp,sp,-24
8113abd4:	de00012e 	bgeu	sp,et,8113abdc <Write_Sector_Data+0xc>
8113abd8:	003b68fa 	trap	3
8113abdc:	dfc00515 	stw	ra,20(sp)
8113abe0:	df000415 	stw	fp,16(sp)
8113abe4:	df000404 	addi	fp,sp,16
8113abe8:	e13ffe15 	stw	r4,-8(fp)
8113abec:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
8113abf0:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
8113abf4:	113d9b80 	call	8113d9b8 <alt_up_sd_card_is_Present>
8113abf8:	10001e26 	beq	r2,zero,8113ac74 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
8113abfc:	00803fc4 	movi	r2,255
8113ac00:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8113ac04:	d0a0ae17 	ldw	r2,-32072(gp)
8113ac08:	e13ffe17 	ldw	r4,-8(fp)
8113ac0c:	e0ffff17 	ldw	r3,-4(fp)
8113ac10:	20c7883a 	add	r3,r4,r3
8113ac14:	1806927a 	slli	r3,r3,9
8113ac18:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
8113ac1c:	d0a0ad17 	ldw	r2,-32076(gp)
8113ac20:	00c00604 	movi	r3,24
8113ac24:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8113ac28:	d0a0aa17 	ldw	r2,-32088(gp)
8113ac2c:	1080002b 	ldhuio	r2,0(r2)
8113ac30:	10bfffcc 	andi	r2,r2,65535
8113ac34:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
8113ac38:	e0bffd0b 	ldhu	r2,-12(fp)
8113ac3c:	10bfffcc 	andi	r2,r2,65535
8113ac40:	1080010c 	andi	r2,r2,4
8113ac44:	103ff81e 	bne	r2,zero,8113ac28 <__reset+0xfb11ac28>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
8113ac48:	e0bffd0b 	ldhu	r2,-12(fp)
8113ac4c:	10bfffcc 	andi	r2,r2,65535
8113ac50:	1080040c 	andi	r2,r2,16
8113ac54:	1000071e 	bne	r2,zero,8113ac74 <Write_Sector_Data+0xa4>
        {
            result = true;
8113ac58:	00800044 	movi	r2,1
8113ac5c:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8113ac60:	d020b315 	stw	zero,-32052(gp)
            current_sector_index = sector_index+partition_offset;
8113ac64:	e0fffe17 	ldw	r3,-8(fp)
8113ac68:	e0bfff17 	ldw	r2,-4(fp)
8113ac6c:	1885883a 	add	r2,r3,r2
8113ac70:	d0a0b415 	stw	r2,-32048(gp)
        }
    }
    return result;
8113ac74:	e0bffc17 	ldw	r2,-16(fp)
}
8113ac78:	e037883a 	mov	sp,fp
8113ac7c:	dfc00117 	ldw	ra,4(sp)
8113ac80:	df000017 	ldw	fp,0(sp)
8113ac84:	dec00204 	addi	sp,sp,8
8113ac88:	f800283a 	ret

8113ac8c <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
8113ac8c:	defffd04 	addi	sp,sp,-12
8113ac90:	de00012e 	bgeu	sp,et,8113ac98 <Save_Modified_Sector+0xc>
8113ac94:	003b68fa 	trap	3
8113ac98:	dfc00215 	stw	ra,8(sp)
8113ac9c:	df000115 	stw	fp,4(sp)
8113aca0:	df000104 	addi	fp,sp,4
    bool result = true;
8113aca4:	00800044 	movi	r2,1
8113aca8:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
8113acac:	d0a0b317 	ldw	r2,-32052(gp)
8113acb0:	10000526 	beq	r2,zero,8113acc8 <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
8113acb4:	d0a0b417 	ldw	r2,-32048(gp)
8113acb8:	000b883a 	mov	r5,zero
8113acbc:	1009883a 	mov	r4,r2
8113acc0:	113abd00 	call	8113abd0 <Write_Sector_Data>
8113acc4:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
8113acc8:	e0bfff17 	ldw	r2,-4(fp)
}
8113accc:	e037883a 	mov	sp,fp
8113acd0:	dfc00117 	ldw	ra,4(sp)
8113acd4:	df000017 	ldw	fp,0(sp)
8113acd8:	dec00204 	addi	sp,sp,8
8113acdc:	f800283a 	ret

8113ace0 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
8113ace0:	defffa04 	addi	sp,sp,-24
8113ace4:	de00012e 	bgeu	sp,et,8113acec <Read_Sector_Data+0xc>
8113ace8:	003b68fa 	trap	3
8113acec:	dfc00515 	stw	ra,20(sp)
8113acf0:	df000415 	stw	fp,16(sp)
8113acf4:	df000404 	addi	fp,sp,16
8113acf8:	e13ffe15 	stw	r4,-8(fp)
8113acfc:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
8113ad00:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
8113ad04:	113d9b80 	call	8113d9b8 <alt_up_sd_card_is_Present>
8113ad08:	10002726 	beq	r2,zero,8113ada8 <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
8113ad0c:	00803fc4 	movi	r2,255
8113ad10:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
8113ad14:	d0a0b317 	ldw	r2,-32052(gp)
8113ad18:	10000726 	beq	r2,zero,8113ad38 <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
8113ad1c:	d0a0b417 	ldw	r2,-32048(gp)
8113ad20:	000b883a 	mov	r5,zero
8113ad24:	1009883a 	mov	r4,r2
8113ad28:	113abd00 	call	8113abd0 <Write_Sector_Data>
8113ad2c:	1000021e 	bne	r2,zero,8113ad38 <Read_Sector_Data+0x58>
            {
                return false;
8113ad30:	0005883a 	mov	r2,zero
8113ad34:	00001d06 	br	8113adac <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8113ad38:	d0a0ae17 	ldw	r2,-32072(gp)
8113ad3c:	e13ffe17 	ldw	r4,-8(fp)
8113ad40:	e0ffff17 	ldw	r3,-4(fp)
8113ad44:	20c7883a 	add	r3,r4,r3
8113ad48:	1806927a 	slli	r3,r3,9
8113ad4c:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
8113ad50:	d0a0ad17 	ldw	r2,-32076(gp)
8113ad54:	00c00444 	movi	r3,17
8113ad58:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8113ad5c:	d0a0aa17 	ldw	r2,-32088(gp)
8113ad60:	1080002b 	ldhuio	r2,0(r2)
8113ad64:	10bfffcc 	andi	r2,r2,65535
8113ad68:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
8113ad6c:	e0bffd0b 	ldhu	r2,-12(fp)
8113ad70:	10bfffcc 	andi	r2,r2,65535
8113ad74:	1080010c 	andi	r2,r2,4
8113ad78:	103ff81e 	bne	r2,zero,8113ad5c <__reset+0xfb11ad5c>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
8113ad7c:	e0bffd0b 	ldhu	r2,-12(fp)
8113ad80:	10bfffcc 	andi	r2,r2,65535
8113ad84:	1080040c 	andi	r2,r2,16
8113ad88:	1000071e 	bne	r2,zero,8113ada8 <Read_Sector_Data+0xc8>
		{
			result = true;
8113ad8c:	00800044 	movi	r2,1
8113ad90:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8113ad94:	d020b315 	stw	zero,-32052(gp)
            current_sector_index = sector_index+partition_offset;
8113ad98:	e0fffe17 	ldw	r3,-8(fp)
8113ad9c:	e0bfff17 	ldw	r2,-4(fp)
8113ada0:	1885883a 	add	r2,r3,r2
8113ada4:	d0a0b415 	stw	r2,-32048(gp)
		}
	}
	return result;
8113ada8:	e0bffc17 	ldw	r2,-16(fp)
}
8113adac:	e037883a 	mov	sp,fp
8113adb0:	dfc00117 	ldw	ra,4(sp)
8113adb4:	df000017 	ldw	fp,0(sp)
8113adb8:	dec00204 	addi	sp,sp,8
8113adbc:	f800283a 	ret

8113adc0 <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
8113adc0:	defffb04 	addi	sp,sp,-20
8113adc4:	de00012e 	bgeu	sp,et,8113adcc <get_cluster_flag+0xc>
8113adc8:	003b68fa 	trap	3
8113adcc:	dfc00415 	stw	ra,16(sp)
8113add0:	df000315 	stw	fp,12(sp)
8113add4:	df000304 	addi	fp,sp,12
8113add8:	e13ffe15 	stw	r4,-8(fp)
8113addc:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
8113ade0:	e0bffe17 	ldw	r2,-8(fp)
8113ade4:	1004d23a 	srli	r2,r2,8
8113ade8:	d0e0b017 	ldw	r3,-32064(gp)
8113adec:	10c5883a 	add	r2,r2,r3
8113adf0:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8113adf4:	00a045b4 	movhi	r2,33046
8113adf8:	10850804 	addi	r2,r2,5152
8113adfc:	10801117 	ldw	r2,68(r2)
8113ae00:	e0fffd17 	ldw	r3,-12(fp)
8113ae04:	1885883a 	add	r2,r3,r2
8113ae08:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
8113ae0c:	d0a0b417 	ldw	r2,-32048(gp)
8113ae10:	e0fffd17 	ldw	r3,-12(fp)
8113ae14:	18800726 	beq	r3,r2,8113ae34 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8113ae18:	e0bffd17 	ldw	r2,-12(fp)
8113ae1c:	000b883a 	mov	r5,zero
8113ae20:	1009883a 	mov	r4,r2
8113ae24:	113ace00 	call	8113ace0 <Read_Sector_Data>
8113ae28:	1000021e 	bne	r2,zero,8113ae34 <get_cluster_flag+0x74>
        {
            return false;
8113ae2c:	0005883a 	mov	r2,zero
8113ae30:	00000d06 	br	8113ae68 <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
8113ae34:	e0bffe17 	ldw	r2,-8(fp)
8113ae38:	10803fcc 	andi	r2,r2,255
8113ae3c:	1085883a 	add	r2,r2,r2
8113ae40:	1007883a 	mov	r3,r2
8113ae44:	d0a0b217 	ldw	r2,-32056(gp)
8113ae48:	10800a17 	ldw	r2,40(r2)
8113ae4c:	1885883a 	add	r2,r3,r2
8113ae50:	1080002b 	ldhuio	r2,0(r2)
8113ae54:	10bfffcc 	andi	r2,r2,65535
8113ae58:	1007883a 	mov	r3,r2
8113ae5c:	e0bfff17 	ldw	r2,-4(fp)
8113ae60:	10c0000d 	sth	r3,0(r2)
    return true;
8113ae64:	00800044 	movi	r2,1
}
8113ae68:	e037883a 	mov	sp,fp
8113ae6c:	dfc00117 	ldw	ra,4(sp)
8113ae70:	df000017 	ldw	fp,0(sp)
8113ae74:	dec00204 	addi	sp,sp,8
8113ae78:	f800283a 	ret

8113ae7c <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
8113ae7c:	defffa04 	addi	sp,sp,-24
8113ae80:	de00012e 	bgeu	sp,et,8113ae88 <mark_cluster+0xc>
8113ae84:	003b68fa 	trap	3
8113ae88:	dfc00515 	stw	ra,20(sp)
8113ae8c:	df000415 	stw	fp,16(sp)
8113ae90:	df000404 	addi	fp,sp,16
8113ae94:	e13ffd15 	stw	r4,-12(fp)
8113ae98:	2805883a 	mov	r2,r5
8113ae9c:	e1bfff15 	stw	r6,-4(fp)
8113aea0:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
8113aea4:	e0bffd17 	ldw	r2,-12(fp)
8113aea8:	1004d23a 	srli	r2,r2,8
8113aeac:	d0e0b017 	ldw	r3,-32064(gp)
8113aeb0:	10c5883a 	add	r2,r2,r3
8113aeb4:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
8113aeb8:	e0bfff17 	ldw	r2,-4(fp)
8113aebc:	10000726 	beq	r2,zero,8113aedc <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8113aec0:	00a045b4 	movhi	r2,33046
8113aec4:	10850804 	addi	r2,r2,5152
8113aec8:	10801117 	ldw	r2,68(r2)
8113aecc:	e0fffc17 	ldw	r3,-16(fp)
8113aed0:	1885883a 	add	r2,r3,r2
8113aed4:	e0bffc15 	stw	r2,-16(fp)
8113aed8:	00000606 	br	8113aef4 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
8113aedc:	00a045b4 	movhi	r2,33046
8113aee0:	10850804 	addi	r2,r2,5152
8113aee4:	10801217 	ldw	r2,72(r2)
8113aee8:	e0fffc17 	ldw	r3,-16(fp)
8113aeec:	1885883a 	add	r2,r3,r2
8113aef0:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
8113aef4:	d0a0b417 	ldw	r2,-32048(gp)
8113aef8:	e0fffc17 	ldw	r3,-16(fp)
8113aefc:	18800726 	beq	r3,r2,8113af1c <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8113af00:	e0bffc17 	ldw	r2,-16(fp)
8113af04:	000b883a 	mov	r5,zero
8113af08:	1009883a 	mov	r4,r2
8113af0c:	113ace00 	call	8113ace0 <Read_Sector_Data>
8113af10:	1000021e 	bne	r2,zero,8113af1c <mark_cluster+0xa0>
        {
            return false;
8113af14:	0005883a 	mov	r2,zero
8113af18:	00000d06 	br	8113af50 <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
8113af1c:	e0bffd17 	ldw	r2,-12(fp)
8113af20:	10803fcc 	andi	r2,r2,255
8113af24:	1085883a 	add	r2,r2,r2
8113af28:	1007883a 	mov	r3,r2
8113af2c:	d0a0b217 	ldw	r2,-32056(gp)
8113af30:	10800a17 	ldw	r2,40(r2)
8113af34:	1885883a 	add	r2,r3,r2
8113af38:	1007883a 	mov	r3,r2
8113af3c:	e0bffe0f 	ldh	r2,-8(fp)
8113af40:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
8113af44:	00800044 	movi	r2,1
8113af48:	d0a0b315 	stw	r2,-32052(gp)
    return true;
8113af4c:	00800044 	movi	r2,1
}
8113af50:	e037883a 	mov	sp,fp
8113af54:	dfc00117 	ldw	ra,4(sp)
8113af58:	df000017 	ldw	fp,0(sp)
8113af5c:	dec00204 	addi	sp,sp,8
8113af60:	f800283a 	ret

8113af64 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
8113af64:	defff704 	addi	sp,sp,-36
8113af68:	de00012e 	bgeu	sp,et,8113af70 <Check_for_Master_Boot_Record+0xc>
8113af6c:	003b68fa 	trap	3
8113af70:	dfc00815 	stw	ra,32(sp)
8113af74:	df000715 	stw	fp,28(sp)
8113af78:	df000704 	addi	fp,sp,28
	bool result = false;
8113af7c:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
8113af80:	000b883a 	mov	r5,zero
8113af84:	0009883a 	mov	r4,zero
8113af88:	113ace00 	call	8113ace0 <Read_Sector_Data>
8113af8c:	10005a26 	beq	r2,zero,8113b0f8 <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
8113af90:	d0a0b217 	ldw	r2,-32056(gp)
8113af94:	10800a17 	ldw	r2,40(r2)
8113af98:	10807f84 	addi	r2,r2,510
8113af9c:	1080002b 	ldhuio	r2,0(r2)
8113afa0:	10bfffcc 	andi	r2,r2,65535
8113afa4:	10bfffcc 	andi	r2,r2,65535
8113afa8:	10a0001c 	xori	r2,r2,32768
8113afac:	10a00004 	addi	r2,r2,-32768
8113afb0:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
8113afb4:	e0bffb17 	ldw	r2,-20(fp)
8113afb8:	10ffffcc 	andi	r3,r2,65535
8113afbc:	00aa9554 	movui	r2,43605
8113afc0:	18804d1e 	bne	r3,r2,8113b0f8 <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8113afc4:	e03ffa15 	stw	zero,-24(fp)
8113afc8:	00004806 	br	8113b0ec <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
8113afcc:	e0bffa17 	ldw	r2,-24(fp)
8113afd0:	1004913a 	slli	r2,r2,4
8113afd4:	10806f84 	addi	r2,r2,446
8113afd8:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
8113afdc:	d0a0b217 	ldw	r2,-32056(gp)
8113afe0:	10c00a17 	ldw	r3,40(r2)
8113afe4:	e0bffc17 	ldw	r2,-16(fp)
8113afe8:	1885883a 	add	r2,r3,r2
8113afec:	10800104 	addi	r2,r2,4
8113aff0:	10800023 	ldbuio	r2,0(r2)
8113aff4:	10803fcc 	andi	r2,r2,255
8113aff8:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
8113affc:	e0bffd07 	ldb	r2,-12(fp)
8113b000:	10800060 	cmpeqi	r2,r2,1
8113b004:	1000091e 	bne	r2,zero,8113b02c <Check_for_Master_Boot_Record+0xc8>
8113b008:	e0bffd07 	ldb	r2,-12(fp)
8113b00c:	10800120 	cmpeqi	r2,r2,4
8113b010:	1000061e 	bne	r2,zero,8113b02c <Check_for_Master_Boot_Record+0xc8>
8113b014:	e0bffd07 	ldb	r2,-12(fp)
8113b018:	108001a0 	cmpeqi	r2,r2,6
8113b01c:	1000031e 	bne	r2,zero,8113b02c <Check_for_Master_Boot_Record+0xc8>
8113b020:	e0bffd07 	ldb	r2,-12(fp)
8113b024:	10800398 	cmpnei	r2,r2,14
8113b028:	10002d1e 	bne	r2,zero,8113b0e0 <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
8113b02c:	d0a0b217 	ldw	r2,-32056(gp)
8113b030:	10c00a17 	ldw	r3,40(r2)
8113b034:	e0bffc17 	ldw	r2,-16(fp)
8113b038:	1885883a 	add	r2,r3,r2
8113b03c:	10800284 	addi	r2,r2,10
8113b040:	1080002b 	ldhuio	r2,0(r2)
8113b044:	10bfffcc 	andi	r2,r2,65535
8113b048:	1006943a 	slli	r3,r2,16
8113b04c:	d0a0b217 	ldw	r2,-32056(gp)
8113b050:	11000a17 	ldw	r4,40(r2)
8113b054:	e0bffc17 	ldw	r2,-16(fp)
8113b058:	2085883a 	add	r2,r4,r2
8113b05c:	10800204 	addi	r2,r2,8
8113b060:	1080002b 	ldhuio	r2,0(r2)
8113b064:	10bfffcc 	andi	r2,r2,65535
8113b068:	10bfffcc 	andi	r2,r2,65535
8113b06c:	1884b03a 	or	r2,r3,r2
8113b070:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
8113b074:	d0a0b217 	ldw	r2,-32056(gp)
8113b078:	10c00a17 	ldw	r3,40(r2)
8113b07c:	e0bffc17 	ldw	r2,-16(fp)
8113b080:	1885883a 	add	r2,r3,r2
8113b084:	10800384 	addi	r2,r2,14
8113b088:	1080002b 	ldhuio	r2,0(r2)
8113b08c:	10bfffcc 	andi	r2,r2,65535
8113b090:	1006943a 	slli	r3,r2,16
8113b094:	d0a0b217 	ldw	r2,-32056(gp)
8113b098:	11000a17 	ldw	r4,40(r2)
8113b09c:	e0bffc17 	ldw	r2,-16(fp)
8113b0a0:	2085883a 	add	r2,r4,r2
8113b0a4:	10800304 	addi	r2,r2,12
8113b0a8:	1080002b 	ldhuio	r2,0(r2)
8113b0ac:	10bfffcc 	andi	r2,r2,65535
8113b0b0:	10bfffcc 	andi	r2,r2,65535
8113b0b4:	1884b03a 	or	r2,r3,r2
8113b0b8:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
8113b0bc:	e0bfff17 	ldw	r2,-4(fp)
8113b0c0:	0080070e 	bge	zero,r2,8113b0e0 <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
8113b0c4:	00800044 	movi	r2,1
8113b0c8:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
8113b0cc:	e0bfff17 	ldw	r2,-4(fp)
8113b0d0:	d0a0b115 	stw	r2,-32060(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
8113b0d4:	e0bffe17 	ldw	r2,-8(fp)
8113b0d8:	d0a0b015 	stw	r2,-32064(gp)
						break;
8113b0dc:	00000606 	br	8113b0f8 <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8113b0e0:	e0bffa17 	ldw	r2,-24(fp)
8113b0e4:	10800044 	addi	r2,r2,1
8113b0e8:	e0bffa15 	stw	r2,-24(fp)
8113b0ec:	e0bffa17 	ldw	r2,-24(fp)
8113b0f0:	10800110 	cmplti	r2,r2,4
8113b0f4:	103fb51e 	bne	r2,zero,8113afcc <__reset+0xfb11afcc>
				}
			}
		}
	}

	return result;
8113b0f8:	e0bff917 	ldw	r2,-28(fp)
}
8113b0fc:	e037883a 	mov	sp,fp
8113b100:	dfc00117 	ldw	ra,4(sp)
8113b104:	df000017 	ldw	fp,0(sp)
8113b108:	dec00204 	addi	sp,sp,8
8113b10c:	f800283a 	ret

8113b110 <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
8113b110:	defff804 	addi	sp,sp,-32
8113b114:	de00012e 	bgeu	sp,et,8113b11c <Read_File_Record_At_Offset+0xc>
8113b118:	003b68fa 	trap	3
8113b11c:	dfc00715 	stw	ra,28(sp)
8113b120:	df000615 	stw	fp,24(sp)
8113b124:	df000604 	addi	fp,sp,24
8113b128:	e13ffc15 	stw	r4,-16(fp)
8113b12c:	e17ffd15 	stw	r5,-12(fp)
8113b130:	e1bffe15 	stw	r6,-8(fp)
8113b134:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
8113b138:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113b13c:	e0bffc17 	ldw	r2,-16(fp)
8113b140:	108007cc 	andi	r2,r2,31
8113b144:	10008d1e 	bne	r2,zero,8113b37c <Read_File_Record_At_Offset+0x26c>
8113b148:	113d9b80 	call	8113d9b8 <alt_up_sd_card_is_Present>
8113b14c:	10008b26 	beq	r2,zero,8113b37c <Read_File_Record_At_Offset+0x26c>
8113b150:	d0a0a917 	ldw	r2,-32092(gp)
8113b154:	10008926 	beq	r2,zero,8113b37c <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8113b158:	e03ffb15 	stw	zero,-20(fp)
8113b15c:	00001106 	br	8113b1a4 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
8113b160:	e0fffc17 	ldw	r3,-16(fp)
8113b164:	e0bffb17 	ldw	r2,-20(fp)
8113b168:	1885883a 	add	r2,r3,r2
8113b16c:	1007883a 	mov	r3,r2
8113b170:	d0a0b217 	ldw	r2,-32056(gp)
8113b174:	10800a17 	ldw	r2,40(r2)
8113b178:	1885883a 	add	r2,r3,r2
8113b17c:	10800023 	ldbuio	r2,0(r2)
8113b180:	10803fcc 	andi	r2,r2,255
8113b184:	1009883a 	mov	r4,r2
8113b188:	e0fffd17 	ldw	r3,-12(fp)
8113b18c:	e0bffb17 	ldw	r2,-20(fp)
8113b190:	1885883a 	add	r2,r3,r2
8113b194:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8113b198:	e0bffb17 	ldw	r2,-20(fp)
8113b19c:	10800044 	addi	r2,r2,1
8113b1a0:	e0bffb15 	stw	r2,-20(fp)
8113b1a4:	e0bffb17 	ldw	r2,-20(fp)
8113b1a8:	10800210 	cmplti	r2,r2,8
8113b1ac:	103fec1e 	bne	r2,zero,8113b160 <__reset+0xfb11b160>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8113b1b0:	e03ffb15 	stw	zero,-20(fp)
8113b1b4:	00001306 	br	8113b204 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
8113b1b8:	e0fffc17 	ldw	r3,-16(fp)
8113b1bc:	e0bffb17 	ldw	r2,-20(fp)
8113b1c0:	1885883a 	add	r2,r3,r2
8113b1c4:	1007883a 	mov	r3,r2
8113b1c8:	d0a0b217 	ldw	r2,-32056(gp)
8113b1cc:	10800a17 	ldw	r2,40(r2)
8113b1d0:	1885883a 	add	r2,r3,r2
8113b1d4:	10800204 	addi	r2,r2,8
8113b1d8:	10800023 	ldbuio	r2,0(r2)
8113b1dc:	10803fcc 	andi	r2,r2,255
8113b1e0:	1009883a 	mov	r4,r2
8113b1e4:	e0fffd17 	ldw	r3,-12(fp)
8113b1e8:	e0bffb17 	ldw	r2,-20(fp)
8113b1ec:	1885883a 	add	r2,r3,r2
8113b1f0:	10800204 	addi	r2,r2,8
8113b1f4:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8113b1f8:	e0bffb17 	ldw	r2,-20(fp)
8113b1fc:	10800044 	addi	r2,r2,1
8113b200:	e0bffb15 	stw	r2,-20(fp)
8113b204:	e0bffb17 	ldw	r2,-20(fp)
8113b208:	108000d0 	cmplti	r2,r2,3
8113b20c:	103fea1e 	bne	r2,zero,8113b1b8 <__reset+0xfb11b1b8>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
8113b210:	d0a0b217 	ldw	r2,-32056(gp)
8113b214:	10c00a17 	ldw	r3,40(r2)
8113b218:	e0bffc17 	ldw	r2,-16(fp)
8113b21c:	1885883a 	add	r2,r3,r2
8113b220:	108002c4 	addi	r2,r2,11
8113b224:	10800023 	ldbuio	r2,0(r2)
8113b228:	10803fcc 	andi	r2,r2,255
8113b22c:	1007883a 	mov	r3,r2
8113b230:	e0bffd17 	ldw	r2,-12(fp)
8113b234:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
8113b238:	d0a0b217 	ldw	r2,-32056(gp)
8113b23c:	10c00a17 	ldw	r3,40(r2)
8113b240:	e0bffc17 	ldw	r2,-16(fp)
8113b244:	1885883a 	add	r2,r3,r2
8113b248:	10800384 	addi	r2,r2,14
8113b24c:	1080002b 	ldhuio	r2,0(r2)
8113b250:	10bfffcc 	andi	r2,r2,65535
8113b254:	1007883a 	mov	r3,r2
8113b258:	e0bffd17 	ldw	r2,-12(fp)
8113b25c:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
8113b260:	d0a0b217 	ldw	r2,-32056(gp)
8113b264:	10c00a17 	ldw	r3,40(r2)
8113b268:	e0bffc17 	ldw	r2,-16(fp)
8113b26c:	1885883a 	add	r2,r3,r2
8113b270:	10800404 	addi	r2,r2,16
8113b274:	1080002b 	ldhuio	r2,0(r2)
8113b278:	10bfffcc 	andi	r2,r2,65535
8113b27c:	1007883a 	mov	r3,r2
8113b280:	e0bffd17 	ldw	r2,-12(fp)
8113b284:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
8113b288:	d0a0b217 	ldw	r2,-32056(gp)
8113b28c:	10c00a17 	ldw	r3,40(r2)
8113b290:	e0bffc17 	ldw	r2,-16(fp)
8113b294:	1885883a 	add	r2,r3,r2
8113b298:	10800484 	addi	r2,r2,18
8113b29c:	1080002b 	ldhuio	r2,0(r2)
8113b2a0:	10bfffcc 	andi	r2,r2,65535
8113b2a4:	1007883a 	mov	r3,r2
8113b2a8:	e0bffd17 	ldw	r2,-12(fp)
8113b2ac:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
8113b2b0:	d0a0b217 	ldw	r2,-32056(gp)
8113b2b4:	10c00a17 	ldw	r3,40(r2)
8113b2b8:	e0bffc17 	ldw	r2,-16(fp)
8113b2bc:	1885883a 	add	r2,r3,r2
8113b2c0:	10800584 	addi	r2,r2,22
8113b2c4:	1080002b 	ldhuio	r2,0(r2)
8113b2c8:	10bfffcc 	andi	r2,r2,65535
8113b2cc:	1007883a 	mov	r3,r2
8113b2d0:	e0bffd17 	ldw	r2,-12(fp)
8113b2d4:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
8113b2d8:	d0a0b217 	ldw	r2,-32056(gp)
8113b2dc:	10c00a17 	ldw	r3,40(r2)
8113b2e0:	e0bffc17 	ldw	r2,-16(fp)
8113b2e4:	1885883a 	add	r2,r3,r2
8113b2e8:	10800604 	addi	r2,r2,24
8113b2ec:	1080002b 	ldhuio	r2,0(r2)
8113b2f0:	10bfffcc 	andi	r2,r2,65535
8113b2f4:	1007883a 	mov	r3,r2
8113b2f8:	e0bffd17 	ldw	r2,-12(fp)
8113b2fc:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
8113b300:	d0a0b217 	ldw	r2,-32056(gp)
8113b304:	10c00a17 	ldw	r3,40(r2)
8113b308:	e0bffc17 	ldw	r2,-16(fp)
8113b30c:	1885883a 	add	r2,r3,r2
8113b310:	10800684 	addi	r2,r2,26
8113b314:	1080002b 	ldhuio	r2,0(r2)
8113b318:	10bfffcc 	andi	r2,r2,65535
8113b31c:	1007883a 	mov	r3,r2
8113b320:	e0bffd17 	ldw	r2,-12(fp)
8113b324:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
8113b328:	d0a0b217 	ldw	r2,-32056(gp)
8113b32c:	10c00a17 	ldw	r3,40(r2)
8113b330:	e0bffc17 	ldw	r2,-16(fp)
8113b334:	1885883a 	add	r2,r3,r2
8113b338:	10800704 	addi	r2,r2,28
8113b33c:	10800037 	ldwio	r2,0(r2)
8113b340:	1007883a 	mov	r3,r2
8113b344:	e0bffd17 	ldw	r2,-12(fp)
8113b348:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
8113b34c:	e0bffd17 	ldw	r2,-12(fp)
8113b350:	e0fffe17 	ldw	r3,-8(fp)
8113b354:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
8113b358:	e0bffd17 	ldw	r2,-12(fp)
8113b35c:	e0ffff17 	ldw	r3,-4(fp)
8113b360:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
8113b364:	e0bffc17 	ldw	r2,-16(fp)
8113b368:	1007883a 	mov	r3,r2
8113b36c:	e0bffd17 	ldw	r2,-12(fp)
8113b370:	10c00c0d 	sth	r3,48(r2)
		result = true;
8113b374:	00800044 	movi	r2,1
8113b378:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
8113b37c:	e0bffa17 	ldw	r2,-24(fp)
}
8113b380:	e037883a 	mov	sp,fp
8113b384:	dfc00117 	ldw	ra,4(sp)
8113b388:	df000017 	ldw	fp,0(sp)
8113b38c:	dec00204 	addi	sp,sp,8
8113b390:	f800283a 	ret

8113b394 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
8113b394:	defff904 	addi	sp,sp,-28
8113b398:	de00012e 	bgeu	sp,et,8113b3a0 <Write_File_Record_At_Offset+0xc>
8113b39c:	003b68fa 	trap	3
8113b3a0:	dfc00615 	stw	ra,24(sp)
8113b3a4:	df000515 	stw	fp,20(sp)
8113b3a8:	df000504 	addi	fp,sp,20
8113b3ac:	e13ffe15 	stw	r4,-8(fp)
8113b3b0:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
8113b3b4:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113b3b8:	e0bffe17 	ldw	r2,-8(fp)
8113b3bc:	108007cc 	andi	r2,r2,31
8113b3c0:	1000931e 	bne	r2,zero,8113b610 <Write_File_Record_At_Offset+0x27c>
8113b3c4:	113d9b80 	call	8113d9b8 <alt_up_sd_card_is_Present>
8113b3c8:	10009126 	beq	r2,zero,8113b610 <Write_File_Record_At_Offset+0x27c>
8113b3cc:	d0a0a917 	ldw	r2,-32092(gp)
8113b3d0:	10008f26 	beq	r2,zero,8113b610 <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8113b3d4:	e03ffc15 	stw	zero,-16(fp)
8113b3d8:	00001f06 	br	8113b458 <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
8113b3dc:	e0bffc17 	ldw	r2,-16(fp)
8113b3e0:	10800044 	addi	r2,r2,1
8113b3e4:	e0ffff17 	ldw	r3,-4(fp)
8113b3e8:	1885883a 	add	r2,r3,r2
8113b3ec:	10800003 	ldbu	r2,0(r2)
8113b3f0:	10803fcc 	andi	r2,r2,255
8113b3f4:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
8113b3f8:	e0bffd0f 	ldh	r2,-12(fp)
8113b3fc:	1004923a 	slli	r2,r2,8
8113b400:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
8113b404:	e0ffff17 	ldw	r3,-4(fp)
8113b408:	e0bffc17 	ldw	r2,-16(fp)
8113b40c:	1885883a 	add	r2,r3,r2
8113b410:	10800003 	ldbu	r2,0(r2)
8113b414:	10c03fcc 	andi	r3,r2,255
8113b418:	e0bffd0b 	ldhu	r2,-12(fp)
8113b41c:	1884b03a 	or	r2,r3,r2
8113b420:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
8113b424:	e0fffe17 	ldw	r3,-8(fp)
8113b428:	e0bffc17 	ldw	r2,-16(fp)
8113b42c:	1885883a 	add	r2,r3,r2
8113b430:	1007883a 	mov	r3,r2
8113b434:	d0a0b217 	ldw	r2,-32056(gp)
8113b438:	10800a17 	ldw	r2,40(r2)
8113b43c:	1885883a 	add	r2,r3,r2
8113b440:	1007883a 	mov	r3,r2
8113b444:	e0bffd0f 	ldh	r2,-12(fp)
8113b448:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8113b44c:	e0bffc17 	ldw	r2,-16(fp)
8113b450:	10800084 	addi	r2,r2,2
8113b454:	e0bffc15 	stw	r2,-16(fp)
8113b458:	e0bffc17 	ldw	r2,-16(fp)
8113b45c:	10800210 	cmplti	r2,r2,8
8113b460:	103fde1e 	bne	r2,zero,8113b3dc <__reset+0xfb11b3dc>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
8113b464:	e03ffc15 	stw	zero,-16(fp)
8113b468:	00001306 	br	8113b4b8 <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
8113b46c:	e0fffe17 	ldw	r3,-8(fp)
8113b470:	e0bffc17 	ldw	r2,-16(fp)
8113b474:	1885883a 	add	r2,r3,r2
8113b478:	1007883a 	mov	r3,r2
8113b47c:	d0a0b217 	ldw	r2,-32056(gp)
8113b480:	10800a17 	ldw	r2,40(r2)
8113b484:	1885883a 	add	r2,r3,r2
8113b488:	10800204 	addi	r2,r2,8
8113b48c:	1009883a 	mov	r4,r2
8113b490:	e0ffff17 	ldw	r3,-4(fp)
8113b494:	e0bffc17 	ldw	r2,-16(fp)
8113b498:	1885883a 	add	r2,r3,r2
8113b49c:	10800204 	addi	r2,r2,8
8113b4a0:	10800003 	ldbu	r2,0(r2)
8113b4a4:	10803fcc 	andi	r2,r2,255
8113b4a8:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
8113b4ac:	e0bffc17 	ldw	r2,-16(fp)
8113b4b0:	10800044 	addi	r2,r2,1
8113b4b4:	e0bffc15 	stw	r2,-16(fp)
8113b4b8:	e0bffc17 	ldw	r2,-16(fp)
8113b4bc:	108000d0 	cmplti	r2,r2,3
8113b4c0:	103fea1e 	bne	r2,zero,8113b46c <__reset+0xfb11b46c>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
8113b4c4:	d0a0b217 	ldw	r2,-32056(gp)
8113b4c8:	10c00a17 	ldw	r3,40(r2)
8113b4cc:	e0bffe17 	ldw	r2,-8(fp)
8113b4d0:	1885883a 	add	r2,r3,r2
8113b4d4:	108002c4 	addi	r2,r2,11
8113b4d8:	1007883a 	mov	r3,r2
8113b4dc:	e0bfff17 	ldw	r2,-4(fp)
8113b4e0:	108002c3 	ldbu	r2,11(r2)
8113b4e4:	10803fcc 	andi	r2,r2,255
8113b4e8:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
8113b4ec:	d0a0b217 	ldw	r2,-32056(gp)
8113b4f0:	10c00a17 	ldw	r3,40(r2)
8113b4f4:	e0bffe17 	ldw	r2,-8(fp)
8113b4f8:	1885883a 	add	r2,r3,r2
8113b4fc:	10800384 	addi	r2,r2,14
8113b500:	1007883a 	mov	r3,r2
8113b504:	e0bfff17 	ldw	r2,-4(fp)
8113b508:	1080030b 	ldhu	r2,12(r2)
8113b50c:	10bfffcc 	andi	r2,r2,65535
8113b510:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
8113b514:	d0a0b217 	ldw	r2,-32056(gp)
8113b518:	10c00a17 	ldw	r3,40(r2)
8113b51c:	e0bffe17 	ldw	r2,-8(fp)
8113b520:	1885883a 	add	r2,r3,r2
8113b524:	10800404 	addi	r2,r2,16
8113b528:	1007883a 	mov	r3,r2
8113b52c:	e0bfff17 	ldw	r2,-4(fp)
8113b530:	1080038b 	ldhu	r2,14(r2)
8113b534:	10bfffcc 	andi	r2,r2,65535
8113b538:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
8113b53c:	d0a0b217 	ldw	r2,-32056(gp)
8113b540:	10c00a17 	ldw	r3,40(r2)
8113b544:	e0bffe17 	ldw	r2,-8(fp)
8113b548:	1885883a 	add	r2,r3,r2
8113b54c:	10800484 	addi	r2,r2,18
8113b550:	1007883a 	mov	r3,r2
8113b554:	e0bfff17 	ldw	r2,-4(fp)
8113b558:	1080040b 	ldhu	r2,16(r2)
8113b55c:	10bfffcc 	andi	r2,r2,65535
8113b560:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
8113b564:	d0a0b217 	ldw	r2,-32056(gp)
8113b568:	10c00a17 	ldw	r3,40(r2)
8113b56c:	e0bffe17 	ldw	r2,-8(fp)
8113b570:	1885883a 	add	r2,r3,r2
8113b574:	10800584 	addi	r2,r2,22
8113b578:	1007883a 	mov	r3,r2
8113b57c:	e0bfff17 	ldw	r2,-4(fp)
8113b580:	1080048b 	ldhu	r2,18(r2)
8113b584:	10bfffcc 	andi	r2,r2,65535
8113b588:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
8113b58c:	d0a0b217 	ldw	r2,-32056(gp)
8113b590:	10c00a17 	ldw	r3,40(r2)
8113b594:	e0bffe17 	ldw	r2,-8(fp)
8113b598:	1885883a 	add	r2,r3,r2
8113b59c:	10800604 	addi	r2,r2,24
8113b5a0:	1007883a 	mov	r3,r2
8113b5a4:	e0bfff17 	ldw	r2,-4(fp)
8113b5a8:	1080050b 	ldhu	r2,20(r2)
8113b5ac:	10bfffcc 	andi	r2,r2,65535
8113b5b0:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
8113b5b4:	d0a0b217 	ldw	r2,-32056(gp)
8113b5b8:	10c00a17 	ldw	r3,40(r2)
8113b5bc:	e0bffe17 	ldw	r2,-8(fp)
8113b5c0:	1885883a 	add	r2,r3,r2
8113b5c4:	10800684 	addi	r2,r2,26
8113b5c8:	1007883a 	mov	r3,r2
8113b5cc:	e0bfff17 	ldw	r2,-4(fp)
8113b5d0:	1080058b 	ldhu	r2,22(r2)
8113b5d4:	10bfffcc 	andi	r2,r2,65535
8113b5d8:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
8113b5dc:	d0a0b217 	ldw	r2,-32056(gp)
8113b5e0:	10c00a17 	ldw	r3,40(r2)
8113b5e4:	e0bffe17 	ldw	r2,-8(fp)
8113b5e8:	1885883a 	add	r2,r3,r2
8113b5ec:	10800704 	addi	r2,r2,28
8113b5f0:	1007883a 	mov	r3,r2
8113b5f4:	e0bfff17 	ldw	r2,-4(fp)
8113b5f8:	10800617 	ldw	r2,24(r2)
8113b5fc:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
8113b600:	00800044 	movi	r2,1
8113b604:	d0a0b315 	stw	r2,-32052(gp)
        result = true;
8113b608:	00800044 	movi	r2,1
8113b60c:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
8113b610:	e0bffb17 	ldw	r2,-20(fp)
}
8113b614:	e037883a 	mov	sp,fp
8113b618:	dfc00117 	ldw	ra,4(sp)
8113b61c:	df000017 	ldw	fp,0(sp)
8113b620:	dec00204 	addi	sp,sp,8
8113b624:	f800283a 	ret

8113b628 <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
8113b628:	defff904 	addi	sp,sp,-28
8113b62c:	de00012e 	bgeu	sp,et,8113b634 <Check_for_DOS_FAT+0xc>
8113b630:	003b68fa 	trap	3
8113b634:	dfc00615 	stw	ra,24(sp)
8113b638:	df000515 	stw	fp,20(sp)
8113b63c:	df000504 	addi	fp,sp,20
8113b640:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
8113b644:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
8113b648:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
8113b64c:	e17fff17 	ldw	r5,-4(fp)
8113b650:	0009883a 	mov	r4,zero
8113b654:	113ace00 	call	8113ace0 <Read_Sector_Data>
8113b658:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
8113b65c:	d0a0b217 	ldw	r2,-32056(gp)
8113b660:	10800a17 	ldw	r2,40(r2)
8113b664:	10807f84 	addi	r2,r2,510
8113b668:	1080002b 	ldhuio	r2,0(r2)
8113b66c:	10bfffcc 	andi	r2,r2,65535
8113b670:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
8113b674:	e0bffe0f 	ldh	r2,-8(fp)
8113b678:	10ffffcc 	andi	r3,r2,65535
8113b67c:	00aa9554 	movui	r2,43605
8113b680:	1881841e 	bne	r3,r2,8113bc94 <Check_for_DOS_FAT+0x66c>
8113b684:	e0bffb17 	ldw	r2,-20(fp)
8113b688:	10018226 	beq	r2,zero,8113bc94 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
8113b68c:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
8113b690:	d0a0b217 	ldw	r2,-32056(gp)
8113b694:	10800a17 	ldw	r2,40(r2)
8113b698:	10800023 	ldbuio	r2,0(r2)
8113b69c:	10803fcc 	andi	r2,r2,255
8113b6a0:	1007883a 	mov	r3,r2
8113b6a4:	00a045b4 	movhi	r2,33046
8113b6a8:	10850804 	addi	r2,r2,5152
8113b6ac:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
8113b6b0:	d0a0b217 	ldw	r2,-32056(gp)
8113b6b4:	10800a17 	ldw	r2,40(r2)
8113b6b8:	10800044 	addi	r2,r2,1
8113b6bc:	10800023 	ldbuio	r2,0(r2)
8113b6c0:	10803fcc 	andi	r2,r2,255
8113b6c4:	1007883a 	mov	r3,r2
8113b6c8:	00a045b4 	movhi	r2,33046
8113b6cc:	10850804 	addi	r2,r2,5152
8113b6d0:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
8113b6d4:	d0a0b217 	ldw	r2,-32056(gp)
8113b6d8:	10800a17 	ldw	r2,40(r2)
8113b6dc:	10800084 	addi	r2,r2,2
8113b6e0:	10800023 	ldbuio	r2,0(r2)
8113b6e4:	10803fcc 	andi	r2,r2,255
8113b6e8:	1007883a 	mov	r3,r2
8113b6ec:	00a045b4 	movhi	r2,33046
8113b6f0:	10850804 	addi	r2,r2,5152
8113b6f4:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
8113b6f8:	e03ffc15 	stw	zero,-16(fp)
8113b6fc:	00001106 	br	8113b744 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
8113b700:	d0a0b217 	ldw	r2,-32056(gp)
8113b704:	10c00a17 	ldw	r3,40(r2)
8113b708:	e0bffc17 	ldw	r2,-16(fp)
8113b70c:	1885883a 	add	r2,r3,r2
8113b710:	108000c4 	addi	r2,r2,3
8113b714:	10800023 	ldbuio	r2,0(r2)
8113b718:	10803fcc 	andi	r2,r2,255
8113b71c:	1009883a 	mov	r4,r2
8113b720:	00a045b4 	movhi	r2,33046
8113b724:	10850804 	addi	r2,r2,5152
8113b728:	e0fffc17 	ldw	r3,-16(fp)
8113b72c:	10c5883a 	add	r2,r2,r3
8113b730:	108000c4 	addi	r2,r2,3
8113b734:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
8113b738:	e0bffc17 	ldw	r2,-16(fp)
8113b73c:	10800044 	addi	r2,r2,1
8113b740:	e0bffc15 	stw	r2,-16(fp)
8113b744:	e0bffc17 	ldw	r2,-16(fp)
8113b748:	10800210 	cmplti	r2,r2,8
8113b74c:	103fec1e 	bne	r2,zero,8113b700 <__reset+0xfb11b700>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
8113b750:	d0a0b217 	ldw	r2,-32056(gp)
8113b754:	10800a17 	ldw	r2,40(r2)
8113b758:	10800304 	addi	r2,r2,12
8113b75c:	10800023 	ldbuio	r2,0(r2)
8113b760:	10803fcc 	andi	r2,r2,255
8113b764:	1004923a 	slli	r2,r2,8
8113b768:	1007883a 	mov	r3,r2
8113b76c:	d0a0b217 	ldw	r2,-32056(gp)
8113b770:	10800a17 	ldw	r2,40(r2)
8113b774:	108002c4 	addi	r2,r2,11
8113b778:	10800023 	ldbuio	r2,0(r2)
8113b77c:	10803fcc 	andi	r2,r2,255
8113b780:	10803fcc 	andi	r2,r2,255
8113b784:	1080201c 	xori	r2,r2,128
8113b788:	10bfe004 	addi	r2,r2,-128
8113b78c:	1884b03a 	or	r2,r3,r2
8113b790:	1007883a 	mov	r3,r2
8113b794:	00a045b4 	movhi	r2,33046
8113b798:	10850804 	addi	r2,r2,5152
8113b79c:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
8113b7a0:	d0a0b217 	ldw	r2,-32056(gp)
8113b7a4:	10800a17 	ldw	r2,40(r2)
8113b7a8:	10800344 	addi	r2,r2,13
8113b7ac:	10800023 	ldbuio	r2,0(r2)
8113b7b0:	10803fcc 	andi	r2,r2,255
8113b7b4:	1007883a 	mov	r3,r2
8113b7b8:	00a045b4 	movhi	r2,33046
8113b7bc:	10850804 	addi	r2,r2,5152
8113b7c0:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
8113b7c4:	d0a0b217 	ldw	r2,-32056(gp)
8113b7c8:	10800a17 	ldw	r2,40(r2)
8113b7cc:	10800384 	addi	r2,r2,14
8113b7d0:	1080002b 	ldhuio	r2,0(r2)
8113b7d4:	10bfffcc 	andi	r2,r2,65535
8113b7d8:	1007883a 	mov	r3,r2
8113b7dc:	00a045b4 	movhi	r2,33046
8113b7e0:	10850804 	addi	r2,r2,5152
8113b7e4:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
8113b7e8:	d0a0b217 	ldw	r2,-32056(gp)
8113b7ec:	10800a17 	ldw	r2,40(r2)
8113b7f0:	10800404 	addi	r2,r2,16
8113b7f4:	10800023 	ldbuio	r2,0(r2)
8113b7f8:	10803fcc 	andi	r2,r2,255
8113b7fc:	1007883a 	mov	r3,r2
8113b800:	00a045b4 	movhi	r2,33046
8113b804:	10850804 	addi	r2,r2,5152
8113b808:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
8113b80c:	d0a0b217 	ldw	r2,-32056(gp)
8113b810:	10800a17 	ldw	r2,40(r2)
8113b814:	10800484 	addi	r2,r2,18
8113b818:	10800023 	ldbuio	r2,0(r2)
8113b81c:	10803fcc 	andi	r2,r2,255
8113b820:	1004923a 	slli	r2,r2,8
8113b824:	1007883a 	mov	r3,r2
8113b828:	d0a0b217 	ldw	r2,-32056(gp)
8113b82c:	10800a17 	ldw	r2,40(r2)
8113b830:	10800444 	addi	r2,r2,17
8113b834:	10800023 	ldbuio	r2,0(r2)
8113b838:	10803fcc 	andi	r2,r2,255
8113b83c:	10803fcc 	andi	r2,r2,255
8113b840:	1884b03a 	or	r2,r3,r2
8113b844:	1007883a 	mov	r3,r2
8113b848:	00a045b4 	movhi	r2,33046
8113b84c:	10850804 	addi	r2,r2,5152
8113b850:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
8113b854:	d0a0b217 	ldw	r2,-32056(gp)
8113b858:	10800a17 	ldw	r2,40(r2)
8113b85c:	10800504 	addi	r2,r2,20
8113b860:	10800023 	ldbuio	r2,0(r2)
8113b864:	10803fcc 	andi	r2,r2,255
8113b868:	1004923a 	slli	r2,r2,8
8113b86c:	1007883a 	mov	r3,r2
8113b870:	d0a0b217 	ldw	r2,-32056(gp)
8113b874:	10800a17 	ldw	r2,40(r2)
8113b878:	108004c4 	addi	r2,r2,19
8113b87c:	10800023 	ldbuio	r2,0(r2)
8113b880:	10803fcc 	andi	r2,r2,255
8113b884:	10803fcc 	andi	r2,r2,255
8113b888:	1884b03a 	or	r2,r3,r2
8113b88c:	1007883a 	mov	r3,r2
8113b890:	00a045b4 	movhi	r2,33046
8113b894:	10850804 	addi	r2,r2,5152
8113b898:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
8113b89c:	d0a0b217 	ldw	r2,-32056(gp)
8113b8a0:	10800a17 	ldw	r2,40(r2)
8113b8a4:	10800544 	addi	r2,r2,21
8113b8a8:	10800023 	ldbuio	r2,0(r2)
8113b8ac:	10803fcc 	andi	r2,r2,255
8113b8b0:	1007883a 	mov	r3,r2
8113b8b4:	00a045b4 	movhi	r2,33046
8113b8b8:	10850804 	addi	r2,r2,5152
8113b8bc:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
8113b8c0:	d0a0b217 	ldw	r2,-32056(gp)
8113b8c4:	10800a17 	ldw	r2,40(r2)
8113b8c8:	10800584 	addi	r2,r2,22
8113b8cc:	1080002b 	ldhuio	r2,0(r2)
8113b8d0:	10bfffcc 	andi	r2,r2,65535
8113b8d4:	1007883a 	mov	r3,r2
8113b8d8:	00a045b4 	movhi	r2,33046
8113b8dc:	10850804 	addi	r2,r2,5152
8113b8e0:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
8113b8e4:	d0a0b217 	ldw	r2,-32056(gp)
8113b8e8:	10800a17 	ldw	r2,40(r2)
8113b8ec:	10800604 	addi	r2,r2,24
8113b8f0:	1080002b 	ldhuio	r2,0(r2)
8113b8f4:	10bfffcc 	andi	r2,r2,65535
8113b8f8:	1007883a 	mov	r3,r2
8113b8fc:	00a045b4 	movhi	r2,33046
8113b900:	10850804 	addi	r2,r2,5152
8113b904:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
8113b908:	d0a0b217 	ldw	r2,-32056(gp)
8113b90c:	10800a17 	ldw	r2,40(r2)
8113b910:	10800684 	addi	r2,r2,26
8113b914:	1080002b 	ldhuio	r2,0(r2)
8113b918:	10bfffcc 	andi	r2,r2,65535
8113b91c:	1007883a 	mov	r3,r2
8113b920:	00a045b4 	movhi	r2,33046
8113b924:	10850804 	addi	r2,r2,5152
8113b928:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
8113b92c:	d0a0b217 	ldw	r2,-32056(gp)
8113b930:	10800a17 	ldw	r2,40(r2)
8113b934:	10800704 	addi	r2,r2,28
8113b938:	10800037 	ldwio	r2,0(r2)
8113b93c:	1007883a 	mov	r3,r2
8113b940:	00a045b4 	movhi	r2,33046
8113b944:	10850804 	addi	r2,r2,5152
8113b948:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
8113b94c:	d0a0b217 	ldw	r2,-32056(gp)
8113b950:	10800a17 	ldw	r2,40(r2)
8113b954:	10800804 	addi	r2,r2,32
8113b958:	10800037 	ldwio	r2,0(r2)
8113b95c:	1007883a 	mov	r3,r2
8113b960:	00a045b4 	movhi	r2,33046
8113b964:	10850804 	addi	r2,r2,5152
8113b968:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
8113b96c:	d0a0b217 	ldw	r2,-32056(gp)
8113b970:	10800a17 	ldw	r2,40(r2)
8113b974:	10800904 	addi	r2,r2,36
8113b978:	10800023 	ldbuio	r2,0(r2)
8113b97c:	10803fcc 	andi	r2,r2,255
8113b980:	1007883a 	mov	r3,r2
8113b984:	00a045b4 	movhi	r2,33046
8113b988:	10850804 	addi	r2,r2,5152
8113b98c:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
8113b990:	d0a0b217 	ldw	r2,-32056(gp)
8113b994:	10800a17 	ldw	r2,40(r2)
8113b998:	10800944 	addi	r2,r2,37
8113b99c:	10800023 	ldbuio	r2,0(r2)
8113b9a0:	10803fcc 	andi	r2,r2,255
8113b9a4:	1007883a 	mov	r3,r2
8113b9a8:	00a045b4 	movhi	r2,33046
8113b9ac:	10850804 	addi	r2,r2,5152
8113b9b0:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
8113b9b4:	d0a0b217 	ldw	r2,-32056(gp)
8113b9b8:	10800a17 	ldw	r2,40(r2)
8113b9bc:	10800984 	addi	r2,r2,38
8113b9c0:	10800023 	ldbuio	r2,0(r2)
8113b9c4:	10803fcc 	andi	r2,r2,255
8113b9c8:	1007883a 	mov	r3,r2
8113b9cc:	00a045b4 	movhi	r2,33046
8113b9d0:	10850804 	addi	r2,r2,5152
8113b9d4:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
8113b9d8:	00a045b4 	movhi	r2,33046
8113b9dc:	10850804 	addi	r2,r2,5152
8113b9e0:	1080040b 	ldhu	r2,16(r2)
8113b9e4:	10ffffcc 	andi	r3,r2,65535
8113b9e8:	00a045b4 	movhi	r2,33046
8113b9ec:	10850804 	addi	r2,r2,5152
8113b9f0:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
8113b9f4:	00a045b4 	movhi	r2,33046
8113b9f8:	10850804 	addi	r2,r2,5152
8113b9fc:	10c01117 	ldw	r3,68(r2)
8113ba00:	00a045b4 	movhi	r2,33046
8113ba04:	10850804 	addi	r2,r2,5152
8113ba08:	1080068b 	ldhu	r2,26(r2)
8113ba0c:	10bfffcc 	andi	r2,r2,65535
8113ba10:	1887883a 	add	r3,r3,r2
8113ba14:	00a045b4 	movhi	r2,33046
8113ba18:	10850804 	addi	r2,r2,5152
8113ba1c:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
8113ba20:	00a045b4 	movhi	r2,33046
8113ba24:	10850804 	addi	r2,r2,5152
8113ba28:	10c01217 	ldw	r3,72(r2)
8113ba2c:	00a045b4 	movhi	r2,33046
8113ba30:	10850804 	addi	r2,r2,5152
8113ba34:	1080068b 	ldhu	r2,26(r2)
8113ba38:	10bfffcc 	andi	r2,r2,65535
8113ba3c:	1887883a 	add	r3,r3,r2
8113ba40:	00a045b4 	movhi	r2,33046
8113ba44:	10850804 	addi	r2,r2,5152
8113ba48:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
8113ba4c:	00a045b4 	movhi	r2,33046
8113ba50:	10850804 	addi	r2,r2,5152
8113ba54:	10c01317 	ldw	r3,76(r2)
8113ba58:	00a045b4 	movhi	r2,33046
8113ba5c:	10850804 	addi	r2,r2,5152
8113ba60:	1080050b 	ldhu	r2,20(r2)
8113ba64:	10bfffcc 	andi	r2,r2,65535
8113ba68:	1008917a 	slli	r4,r2,5
8113ba6c:	00a045b4 	movhi	r2,33046
8113ba70:	10850804 	addi	r2,r2,5152
8113ba74:	1080030b 	ldhu	r2,12(r2)
8113ba78:	10bfffcc 	andi	r2,r2,65535
8113ba7c:	2085283a 	div	r2,r4,r2
8113ba80:	1887883a 	add	r3,r3,r2
8113ba84:	00a045b4 	movhi	r2,33046
8113ba88:	10850804 	addi	r2,r2,5152
8113ba8c:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
8113ba90:	00a045b4 	movhi	r2,33046
8113ba94:	10850804 	addi	r2,r2,5152
8113ba98:	1080058b 	ldhu	r2,22(r2)
8113ba9c:	10bfffcc 	andi	r2,r2,65535
8113baa0:	10000b26 	beq	r2,zero,8113bad0 <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
8113baa4:	00a045b4 	movhi	r2,33046
8113baa8:	10850804 	addi	r2,r2,5152
8113baac:	1080058b 	ldhu	r2,22(r2)
8113bab0:	10ffffcc 	andi	r3,r2,65535
8113bab4:	00a045b4 	movhi	r2,33046
8113bab8:	10850804 	addi	r2,r2,5152
8113babc:	10800383 	ldbu	r2,14(r2)
8113bac0:	10803fcc 	andi	r2,r2,255
8113bac4:	1885283a 	div	r2,r3,r2
8113bac8:	e0bffd15 	stw	r2,-12(fp)
8113bacc:	00000906 	br	8113baf4 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
8113bad0:	00a045b4 	movhi	r2,33046
8113bad4:	10850804 	addi	r2,r2,5152
8113bad8:	10c00917 	ldw	r3,36(r2)
8113badc:	00a045b4 	movhi	r2,33046
8113bae0:	10850804 	addi	r2,r2,5152
8113bae4:	10800383 	ldbu	r2,14(r2)
8113bae8:	10803fcc 	andi	r2,r2,255
8113baec:	1885203a 	divu	r2,r3,r2
8113baf0:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
8113baf4:	e0bffd17 	ldw	r2,-12(fp)
8113baf8:	1083fdc8 	cmpgei	r2,r2,4087
8113bafc:	1000051e 	bne	r2,zero,8113bb14 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
8113bb00:	00a045b4 	movhi	r2,33046
8113bb04:	10850804 	addi	r2,r2,5152
8113bb08:	00c00304 	movi	r3,12
8113bb0c:	10c01085 	stb	r3,66(r2)
8113bb10:	00000c06 	br	8113bb44 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
8113bb14:	e0bffd17 	ldw	r2,-12(fp)
8113bb18:	00fffb54 	movui	r3,65517
8113bb1c:	18800516 	blt	r3,r2,8113bb34 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
8113bb20:	00a045b4 	movhi	r2,33046
8113bb24:	10850804 	addi	r2,r2,5152
8113bb28:	00c00404 	movi	r3,16
8113bb2c:	10c01085 	stb	r3,66(r2)
8113bb30:	00000406 	br	8113bb44 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
8113bb34:	00a045b4 	movhi	r2,33046
8113bb38:	10850804 	addi	r2,r2,5152
8113bb3c:	00c00804 	movi	r3,32
8113bb40:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
8113bb44:	e03ffc15 	stw	zero,-16(fp)
8113bb48:	00001106 	br	8113bb90 <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
8113bb4c:	d0a0b217 	ldw	r2,-32056(gp)
8113bb50:	10c00a17 	ldw	r3,40(r2)
8113bb54:	e0bffc17 	ldw	r2,-16(fp)
8113bb58:	1885883a 	add	r2,r3,r2
8113bb5c:	108009c4 	addi	r2,r2,39
8113bb60:	10800023 	ldbuio	r2,0(r2)
8113bb64:	10803fcc 	andi	r2,r2,255
8113bb68:	1009883a 	mov	r4,r2
8113bb6c:	00a045b4 	movhi	r2,33046
8113bb70:	10850804 	addi	r2,r2,5152
8113bb74:	e0fffc17 	ldw	r3,-16(fp)
8113bb78:	10c5883a 	add	r2,r2,r3
8113bb7c:	10800ac4 	addi	r2,r2,43
8113bb80:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
8113bb84:	e0bffc17 	ldw	r2,-16(fp)
8113bb88:	10800044 	addi	r2,r2,1
8113bb8c:	e0bffc15 	stw	r2,-16(fp)
8113bb90:	e0bffc17 	ldw	r2,-16(fp)
8113bb94:	10800110 	cmplti	r2,r2,4
8113bb98:	103fec1e 	bne	r2,zero,8113bb4c <__reset+0xfb11bb4c>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8113bb9c:	e03ffc15 	stw	zero,-16(fp)
8113bba0:	00001106 	br	8113bbe8 <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
8113bba4:	d0a0b217 	ldw	r2,-32056(gp)
8113bba8:	10c00a17 	ldw	r3,40(r2)
8113bbac:	e0bffc17 	ldw	r2,-16(fp)
8113bbb0:	1885883a 	add	r2,r3,r2
8113bbb4:	10800ac4 	addi	r2,r2,43
8113bbb8:	10800023 	ldbuio	r2,0(r2)
8113bbbc:	10803fcc 	andi	r2,r2,255
8113bbc0:	1009883a 	mov	r4,r2
8113bbc4:	00a045b4 	movhi	r2,33046
8113bbc8:	10850804 	addi	r2,r2,5152
8113bbcc:	e0fffc17 	ldw	r3,-16(fp)
8113bbd0:	10c5883a 	add	r2,r2,r3
8113bbd4:	10800bc4 	addi	r2,r2,47
8113bbd8:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8113bbdc:	e0bffc17 	ldw	r2,-16(fp)
8113bbe0:	10800044 	addi	r2,r2,1
8113bbe4:	e0bffc15 	stw	r2,-16(fp)
8113bbe8:	e0bffc17 	ldw	r2,-16(fp)
8113bbec:	108002d0 	cmplti	r2,r2,11
8113bbf0:	103fec1e 	bne	r2,zero,8113bba4 <__reset+0xfb11bba4>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
8113bbf4:	e03ffc15 	stw	zero,-16(fp)
8113bbf8:	00001106 	br	8113bc40 <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
8113bbfc:	d0a0b217 	ldw	r2,-32056(gp)
8113bc00:	10c00a17 	ldw	r3,40(r2)
8113bc04:	e0bffc17 	ldw	r2,-16(fp)
8113bc08:	1885883a 	add	r2,r3,r2
8113bc0c:	10800d84 	addi	r2,r2,54
8113bc10:	10800023 	ldbuio	r2,0(r2)
8113bc14:	10803fcc 	andi	r2,r2,255
8113bc18:	1009883a 	mov	r4,r2
8113bc1c:	00a045b4 	movhi	r2,33046
8113bc20:	10850804 	addi	r2,r2,5152
8113bc24:	e0fffc17 	ldw	r3,-16(fp)
8113bc28:	10c5883a 	add	r2,r2,r3
8113bc2c:	10800e84 	addi	r2,r2,58
8113bc30:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
8113bc34:	e0bffc17 	ldw	r2,-16(fp)
8113bc38:	10800044 	addi	r2,r2,1
8113bc3c:	e0bffc15 	stw	r2,-16(fp)
8113bc40:	e0bffc17 	ldw	r2,-16(fp)
8113bc44:	10800210 	cmplti	r2,r2,8
8113bc48:	103fec1e 	bne	r2,zero,8113bbfc <__reset+0xfb11bbfc>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8113bc4c:	e03ffc15 	stw	zero,-16(fp)
8113bc50:	00000a06 	br	8113bc7c <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
8113bc54:	00a045b4 	movhi	r2,33046
8113bc58:	10851d04 	addi	r2,r2,5236
8113bc5c:	e0fffc17 	ldw	r3,-16(fp)
8113bc60:	180691ba 	slli	r3,r3,6
8113bc64:	10c5883a 	add	r2,r2,r3
8113bc68:	10800f04 	addi	r2,r2,60
8113bc6c:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8113bc70:	e0bffc17 	ldw	r2,-16(fp)
8113bc74:	10800044 	addi	r2,r2,1
8113bc78:	e0bffc15 	stw	r2,-16(fp)
8113bc7c:	e0bffc17 	ldw	r2,-16(fp)
8113bc80:	10800510 	cmplti	r2,r2,20
8113bc84:	103ff31e 	bne	r2,zero,8113bc54 <__reset+0xfb11bc54>
		{
			active_files[counter].in_use = false;
		}
		result = true;
8113bc88:	00800044 	movi	r2,1
8113bc8c:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
8113bc90:	00000106 	br	8113bc98 <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
8113bc94:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
8113bc98:	e0bffb17 	ldw	r2,-20(fp)
}
8113bc9c:	e037883a 	mov	sp,fp
8113bca0:	dfc00117 	ldw	ra,4(sp)
8113bca4:	df000017 	ldw	fp,0(sp)
8113bca8:	dec00204 	addi	sp,sp,8
8113bcac:	f800283a 	ret

8113bcb0 <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
8113bcb0:	defffc04 	addi	sp,sp,-16
8113bcb4:	de00012e 	bgeu	sp,et,8113bcbc <Look_for_FAT16+0xc>
8113bcb8:	003b68fa 	trap	3
8113bcbc:	dfc00315 	stw	ra,12(sp)
8113bcc0:	df000215 	stw	fp,8(sp)
8113bcc4:	df000204 	addi	fp,sp,8
	bool result = false;
8113bcc8:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
8113bccc:	113d9b80 	call	8113d9b8 <alt_up_sd_card_is_Present>
8113bcd0:	10002e26 	beq	r2,zero,8113bd8c <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
8113bcd4:	d0a0ac17 	ldw	r2,-32080(gp)
8113bcd8:	1080000b 	ldhu	r2,0(r2)
8113bcdc:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
8113bce0:	d020b015 	stw	zero,-32064(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
8113bce4:	d020b115 	stw	zero,-32060(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
8113bce8:	e0bfff0f 	ldh	r2,-4(fp)
8113bcec:	10002716 	blt	r2,zero,8113bd8c <Look_for_FAT16+0xdc>
8113bcf0:	e0bfff0b 	ldhu	r2,-4(fp)
8113bcf4:	10bfffcc 	andi	r2,r2,65535
8113bcf8:	1083000c 	andi	r2,r2,3072
8113bcfc:	10830020 	cmpeqi	r2,r2,3072
8113bd00:	1000221e 	bne	r2,zero,8113bd8c <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
8113bd04:	e0bfff0b 	ldhu	r2,-4(fp)
8113bd08:	10bfffcc 	andi	r2,r2,65535
8113bd0c:	1083000c 	andi	r2,r2,3072
8113bd10:	10810018 	cmpnei	r2,r2,1024
8113bd14:	1000031e 	bne	r2,zero,8113bd24 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
8113bd18:	0009883a 	mov	r4,zero
8113bd1c:	113b6280 	call	8113b628 <Check_for_DOS_FAT>
8113bd20:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
8113bd24:	e0bfff0b 	ldhu	r2,-4(fp)
8113bd28:	10bfffcc 	andi	r2,r2,65535
8113bd2c:	1083000c 	andi	r2,r2,3072
8113bd30:	1000061e 	bne	r2,zero,8113bd4c <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
8113bd34:	113af640 	call	8113af64 <Check_for_Master_Boot_Record>
8113bd38:	10000426 	beq	r2,zero,8113bd4c <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
8113bd3c:	d0a0b017 	ldw	r2,-32064(gp)
8113bd40:	1009883a 	mov	r4,r2
8113bd44:	113b6280 	call	8113b628 <Check_for_DOS_FAT>
8113bd48:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
8113bd4c:	e0bffe17 	ldw	r2,-8(fp)
8113bd50:	10800058 	cmpnei	r2,r2,1
8113bd54:	10000d1e 	bne	r2,zero,8113bd8c <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
8113bd58:	00a045b4 	movhi	r2,33046
8113bd5c:	10850804 	addi	r2,r2,5152
8113bd60:	10801083 	ldbu	r2,66(r2)
8113bd64:	10803fcc 	andi	r2,r2,255
8113bd68:	10800420 	cmpeqi	r2,r2,16
8113bd6c:	1000021e 	bne	r2,zero,8113bd78 <Look_for_FAT16+0xc8>
				{
					result = false;
8113bd70:	e03ffe15 	stw	zero,-8(fp)
8113bd74:	00000506 	br	8113bd8c <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
8113bd78:	00a045b4 	movhi	r2,33046
8113bd7c:	10850804 	addi	r2,r2,5152
8113bd80:	1080058b 	ldhu	r2,22(r2)
8113bd84:	10bfffcc 	andi	r2,r2,65535
8113bd88:	d0a0b115 	stw	r2,-32060(gp)
				}
			}
		}
	}
	return result;
8113bd8c:	e0bffe17 	ldw	r2,-8(fp)
}
8113bd90:	e037883a 	mov	sp,fp
8113bd94:	dfc00117 	ldw	ra,4(sp)
8113bd98:	df000017 	ldw	fp,0(sp)
8113bd9c:	dec00204 	addi	sp,sp,8
8113bda0:	f800283a 	ret

8113bda4 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
8113bda4:	defffb04 	addi	sp,sp,-20
8113bda8:	de00012e 	bgeu	sp,et,8113bdb0 <filename_to_upper_case+0xc>
8113bdac:	003b68fa 	trap	3
8113bdb0:	dfc00415 	stw	ra,16(sp)
8113bdb4:	df000315 	stw	fp,12(sp)
8113bdb8:	df000304 	addi	fp,sp,12
8113bdbc:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
8113bdc0:	e13fff17 	ldw	r4,-4(fp)
8113bdc4:	111b1180 	call	8111b118 <strlen>
8113bdc8:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
8113bdcc:	e03ffd15 	stw	zero,-12(fp)
8113bdd0:	00001e06 	br	8113be4c <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
8113bdd4:	e0bffd17 	ldw	r2,-12(fp)
8113bdd8:	e0ffff17 	ldw	r3,-4(fp)
8113bddc:	1885883a 	add	r2,r3,r2
8113bde0:	10800003 	ldbu	r2,0(r2)
8113bde4:	10803fcc 	andi	r2,r2,255
8113bde8:	1080201c 	xori	r2,r2,128
8113bdec:	10bfe004 	addi	r2,r2,-128
8113bdf0:	10801850 	cmplti	r2,r2,97
8113bdf4:	1000121e 	bne	r2,zero,8113be40 <filename_to_upper_case+0x9c>
8113bdf8:	e0bffd17 	ldw	r2,-12(fp)
8113bdfc:	e0ffff17 	ldw	r3,-4(fp)
8113be00:	1885883a 	add	r2,r3,r2
8113be04:	10800003 	ldbu	r2,0(r2)
8113be08:	10803fcc 	andi	r2,r2,255
8113be0c:	1080201c 	xori	r2,r2,128
8113be10:	10bfe004 	addi	r2,r2,-128
8113be14:	10801ec8 	cmpgei	r2,r2,123
8113be18:	1000091e 	bne	r2,zero,8113be40 <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
8113be1c:	e0bffd17 	ldw	r2,-12(fp)
8113be20:	e0ffff17 	ldw	r3,-4(fp)
8113be24:	1885883a 	add	r2,r3,r2
8113be28:	e0fffd17 	ldw	r3,-12(fp)
8113be2c:	e13fff17 	ldw	r4,-4(fp)
8113be30:	20c7883a 	add	r3,r4,r3
8113be34:	18c00003 	ldbu	r3,0(r3)
8113be38:	18fff804 	addi	r3,r3,-32
8113be3c:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
8113be40:	e0bffd17 	ldw	r2,-12(fp)
8113be44:	10800044 	addi	r2,r2,1
8113be48:	e0bffd15 	stw	r2,-12(fp)
8113be4c:	e0fffd17 	ldw	r3,-12(fp)
8113be50:	e0bffe17 	ldw	r2,-8(fp)
8113be54:	18bfdf16 	blt	r3,r2,8113bdd4 <__reset+0xfb11bdd4>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
8113be58:	0001883a 	nop
8113be5c:	e037883a 	mov	sp,fp
8113be60:	dfc00117 	ldw	ra,4(sp)
8113be64:	df000017 	ldw	fp,0(sp)
8113be68:	dec00204 	addi	sp,sp,8
8113be6c:	f800283a 	ret

8113be70 <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
8113be70:	defff804 	addi	sp,sp,-32
8113be74:	de00012e 	bgeu	sp,et,8113be7c <check_file_name_for_FAT16_compliance+0xc>
8113be78:	003b68fa 	trap	3
8113be7c:	dfc00715 	stw	ra,28(sp)
8113be80:	df000615 	stw	fp,24(sp)
8113be84:	df000604 	addi	fp,sp,24
8113be88:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
8113be8c:	e13fff17 	ldw	r4,-4(fp)
8113be90:	111b1180 	call	8111b118 <strlen>
8113be94:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
8113be98:	00bfffc4 	movi	r2,-1
8113be9c:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
8113bea0:	00bfffc4 	movi	r2,-1
8113bea4:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
8113bea8:	00800044 	movi	r2,1
8113beac:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
8113beb0:	e03ffa15 	stw	zero,-24(fp)
8113beb4:	00006d06 	br	8113c06c <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
8113beb8:	e0bffa17 	ldw	r2,-24(fp)
8113bebc:	e0ffff17 	ldw	r3,-4(fp)
8113bec0:	1885883a 	add	r2,r3,r2
8113bec4:	10800003 	ldbu	r2,0(r2)
8113bec8:	10803fcc 	andi	r2,r2,255
8113becc:	1080201c 	xori	r2,r2,128
8113bed0:	10bfe004 	addi	r2,r2,-128
8113bed4:	10800820 	cmpeqi	r2,r2,32
8113bed8:	10003e1e 	bne	r2,zero,8113bfd4 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113bedc:	e0bffa17 	ldw	r2,-24(fp)
8113bee0:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
8113bee4:	e0bffb17 	ldw	r2,-20(fp)
8113bee8:	1880121e 	bne	r3,r2,8113bf34 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113beec:	e0bffa17 	ldw	r2,-24(fp)
8113bef0:	e0ffff17 	ldw	r3,-4(fp)
8113bef4:	1885883a 	add	r2,r3,r2
8113bef8:	10800003 	ldbu	r2,0(r2)
8113befc:	10803fcc 	andi	r2,r2,255
8113bf00:	1080201c 	xori	r2,r2,128
8113bf04:	10bfe004 	addi	r2,r2,-128
8113bf08:	10801720 	cmpeqi	r2,r2,92
8113bf0c:	1000311e 	bne	r2,zero,8113bfd4 <check_file_name_for_FAT16_compliance+0x164>
8113bf10:	e0bffa17 	ldw	r2,-24(fp)
8113bf14:	e0ffff17 	ldw	r3,-4(fp)
8113bf18:	1885883a 	add	r2,r3,r2
8113bf1c:	10800003 	ldbu	r2,0(r2)
8113bf20:	10803fcc 	andi	r2,r2,255
8113bf24:	1080201c 	xori	r2,r2,128
8113bf28:	10bfe004 	addi	r2,r2,-128
8113bf2c:	10800be0 	cmpeqi	r2,r2,47
8113bf30:	1000281e 	bne	r2,zero,8113bfd4 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
8113bf34:	e0fffa17 	ldw	r3,-24(fp)
8113bf38:	e0bffc17 	ldw	r2,-16(fp)
8113bf3c:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113bf40:	10800258 	cmpnei	r2,r2,9
8113bf44:	1000091e 	bne	r2,zero,8113bf6c <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
8113bf48:	e0bffa17 	ldw	r2,-24(fp)
8113bf4c:	e0ffff17 	ldw	r3,-4(fp)
8113bf50:	1885883a 	add	r2,r3,r2
8113bf54:	10800003 	ldbu	r2,0(r2)
8113bf58:	10803fcc 	andi	r2,r2,255
8113bf5c:	1080201c 	xori	r2,r2,128
8113bf60:	10bfe004 	addi	r2,r2,-128
8113bf64:	10800b98 	cmpnei	r2,r2,46
8113bf68:	10001a1e 	bne	r2,zero,8113bfd4 <check_file_name_for_FAT16_compliance+0x164>
8113bf6c:	e0fffb17 	ldw	r3,-20(fp)
8113bf70:	e0bffc17 	ldw	r2,-16(fp)
8113bf74:	18801926 	beq	r3,r2,8113bfdc <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8113bf78:	e0fffa17 	ldw	r3,-24(fp)
8113bf7c:	e0bffc17 	ldw	r2,-16(fp)
8113bf80:	1885c83a 	sub	r2,r3,r2
8113bf84:	10800110 	cmplti	r2,r2,4
8113bf88:	1000141e 	bne	r2,zero,8113bfdc <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8113bf8c:	e0bffa17 	ldw	r2,-24(fp)
8113bf90:	e0ffff17 	ldw	r3,-4(fp)
8113bf94:	1885883a 	add	r2,r3,r2
8113bf98:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8113bf9c:	10803fcc 	andi	r2,r2,255
8113bfa0:	1080201c 	xori	r2,r2,128
8113bfa4:	10bfe004 	addi	r2,r2,-128
8113bfa8:	10801720 	cmpeqi	r2,r2,92
8113bfac:	10000b1e 	bne	r2,zero,8113bfdc <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8113bfb0:	e0bffa17 	ldw	r2,-24(fp)
8113bfb4:	e0ffff17 	ldw	r3,-4(fp)
8113bfb8:	1885883a 	add	r2,r3,r2
8113bfbc:	10800003 	ldbu	r2,0(r2)
8113bfc0:	10803fcc 	andi	r2,r2,255
8113bfc4:	1080201c 	xori	r2,r2,128
8113bfc8:	10bfe004 	addi	r2,r2,-128
8113bfcc:	10800be0 	cmpeqi	r2,r2,47
8113bfd0:	1000021e 	bne	r2,zero,8113bfdc <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
8113bfd4:	e03ffd15 	stw	zero,-12(fp)
            break;
8113bfd8:	00002706 	br	8113c078 <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
8113bfdc:	e0bffa17 	ldw	r2,-24(fp)
8113bfe0:	e0ffff17 	ldw	r3,-4(fp)
8113bfe4:	1885883a 	add	r2,r3,r2
8113bfe8:	10800003 	ldbu	r2,0(r2)
8113bfec:	10803fcc 	andi	r2,r2,255
8113bff0:	1080201c 	xori	r2,r2,128
8113bff4:	10bfe004 	addi	r2,r2,-128
8113bff8:	10801720 	cmpeqi	r2,r2,92
8113bffc:	1000091e 	bne	r2,zero,8113c024 <check_file_name_for_FAT16_compliance+0x1b4>
8113c000:	e0bffa17 	ldw	r2,-24(fp)
8113c004:	e0ffff17 	ldw	r3,-4(fp)
8113c008:	1885883a 	add	r2,r3,r2
8113c00c:	10800003 	ldbu	r2,0(r2)
8113c010:	10803fcc 	andi	r2,r2,255
8113c014:	1080201c 	xori	r2,r2,128
8113c018:	10bfe004 	addi	r2,r2,-128
8113c01c:	10800bd8 	cmpnei	r2,r2,47
8113c020:	1000041e 	bne	r2,zero,8113c034 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
8113c024:	e0bffa17 	ldw	r2,-24(fp)
8113c028:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
8113c02c:	e0bffa17 	ldw	r2,-24(fp)
8113c030:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
8113c034:	e0bffa17 	ldw	r2,-24(fp)
8113c038:	e0ffff17 	ldw	r3,-4(fp)
8113c03c:	1885883a 	add	r2,r3,r2
8113c040:	10800003 	ldbu	r2,0(r2)
8113c044:	10803fcc 	andi	r2,r2,255
8113c048:	1080201c 	xori	r2,r2,128
8113c04c:	10bfe004 	addi	r2,r2,-128
8113c050:	10800b98 	cmpnei	r2,r2,46
8113c054:	1000021e 	bne	r2,zero,8113c060 <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
8113c058:	e0bffa17 	ldw	r2,-24(fp)
8113c05c:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
8113c060:	e0bffa17 	ldw	r2,-24(fp)
8113c064:	10800044 	addi	r2,r2,1
8113c068:	e0bffa15 	stw	r2,-24(fp)
8113c06c:	e0fffa17 	ldw	r3,-24(fp)
8113c070:	e0bffe17 	ldw	r2,-8(fp)
8113c074:	18bf9016 	blt	r3,r2,8113beb8 <__reset+0xfb11beb8>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
8113c078:	e0bffe17 	ldw	r2,-8(fp)
8113c07c:	10bfffc4 	addi	r2,r2,-1
8113c080:	e0ffff17 	ldw	r3,-4(fp)
8113c084:	1885883a 	add	r2,r3,r2
8113c088:	10800003 	ldbu	r2,0(r2)
8113c08c:	10803fcc 	andi	r2,r2,255
8113c090:	1080201c 	xori	r2,r2,128
8113c094:	10bfe004 	addi	r2,r2,-128
8113c098:	10801720 	cmpeqi	r2,r2,92
8113c09c:	10000a1e 	bne	r2,zero,8113c0c8 <check_file_name_for_FAT16_compliance+0x258>
8113c0a0:	e0bffe17 	ldw	r2,-8(fp)
8113c0a4:	10bfffc4 	addi	r2,r2,-1
8113c0a8:	e0ffff17 	ldw	r3,-4(fp)
8113c0ac:	1885883a 	add	r2,r3,r2
8113c0b0:	10800003 	ldbu	r2,0(r2)
8113c0b4:	10803fcc 	andi	r2,r2,255
8113c0b8:	1080201c 	xori	r2,r2,128
8113c0bc:	10bfe004 	addi	r2,r2,-128
8113c0c0:	10800bd8 	cmpnei	r2,r2,47
8113c0c4:	1000011e 	bne	r2,zero,8113c0cc <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
8113c0c8:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
8113c0cc:	e0bffd17 	ldw	r2,-12(fp)
}
8113c0d0:	e037883a 	mov	sp,fp
8113c0d4:	dfc00117 	ldw	ra,4(sp)
8113c0d8:	df000017 	ldw	fp,0(sp)
8113c0dc:	dec00204 	addi	sp,sp,8
8113c0e0:	f800283a 	ret

8113c0e4 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
8113c0e4:	defffb04 	addi	sp,sp,-20
8113c0e8:	de00012e 	bgeu	sp,et,8113c0f0 <get_dir_divider_location+0xc>
8113c0ec:	003b68fa 	trap	3
8113c0f0:	dfc00415 	stw	ra,16(sp)
8113c0f4:	df000315 	stw	fp,12(sp)
8113c0f8:	df000304 	addi	fp,sp,12
8113c0fc:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
8113c100:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
8113c104:	e13fff17 	ldw	r4,-4(fp)
8113c108:	111b1180 	call	8111b118 <strlen>
8113c10c:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
8113c110:	e03ffd15 	stw	zero,-12(fp)
8113c114:	00001506 	br	8113c16c <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
8113c118:	e0bffd17 	ldw	r2,-12(fp)
8113c11c:	e0ffff17 	ldw	r3,-4(fp)
8113c120:	1885883a 	add	r2,r3,r2
8113c124:	10800003 	ldbu	r2,0(r2)
8113c128:	10803fcc 	andi	r2,r2,255
8113c12c:	1080201c 	xori	r2,r2,128
8113c130:	10bfe004 	addi	r2,r2,-128
8113c134:	10801720 	cmpeqi	r2,r2,92
8113c138:	10000f1e 	bne	r2,zero,8113c178 <get_dir_divider_location+0x94>
8113c13c:	e0bffd17 	ldw	r2,-12(fp)
8113c140:	e0ffff17 	ldw	r3,-4(fp)
8113c144:	1885883a 	add	r2,r3,r2
8113c148:	10800003 	ldbu	r2,0(r2)
8113c14c:	10803fcc 	andi	r2,r2,255
8113c150:	1080201c 	xori	r2,r2,128
8113c154:	10bfe004 	addi	r2,r2,-128
8113c158:	10800be0 	cmpeqi	r2,r2,47
8113c15c:	1000061e 	bne	r2,zero,8113c178 <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
8113c160:	e0bffd17 	ldw	r2,-12(fp)
8113c164:	10800044 	addi	r2,r2,1
8113c168:	e0bffd15 	stw	r2,-12(fp)
8113c16c:	e0fffd17 	ldw	r3,-12(fp)
8113c170:	e0bffe17 	ldw	r2,-8(fp)
8113c174:	18bfe816 	blt	r3,r2,8113c118 <__reset+0xfb11c118>
        {
            break;
        }
    }
    
    if (index == length)
8113c178:	e0fffd17 	ldw	r3,-12(fp)
8113c17c:	e0bffe17 	ldw	r2,-8(fp)
8113c180:	1880021e 	bne	r3,r2,8113c18c <get_dir_divider_location+0xa8>
    {
        index = -1;
8113c184:	00bfffc4 	movi	r2,-1
8113c188:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
8113c18c:	e0bffd17 	ldw	r2,-12(fp)
}
8113c190:	e037883a 	mov	sp,fp
8113c194:	dfc00117 	ldw	ra,4(sp)
8113c198:	df000017 	ldw	fp,0(sp)
8113c19c:	dec00204 	addi	sp,sp,8
8113c1a0:	f800283a 	ret

8113c1a4 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
8113c1a4:	defffa04 	addi	sp,sp,-24
8113c1a8:	de00012e 	bgeu	sp,et,8113c1b0 <match_file_record_to_name_ext+0xc>
8113c1ac:	003b68fa 	trap	3
8113c1b0:	df000515 	stw	fp,20(sp)
8113c1b4:	df000504 	addi	fp,sp,20
8113c1b8:	e13ffd15 	stw	r4,-12(fp)
8113c1bc:	e17ffe15 	stw	r5,-8(fp)
8113c1c0:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
8113c1c4:	00800044 	movi	r2,1
8113c1c8:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
8113c1cc:	e03ffc15 	stw	zero,-16(fp)
8113c1d0:	00004606 	br	8113c2ec <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
8113c1d4:	e0fffd17 	ldw	r3,-12(fp)
8113c1d8:	e0bffc17 	ldw	r2,-16(fp)
8113c1dc:	1885883a 	add	r2,r3,r2
8113c1e0:	10800003 	ldbu	r2,0(r2)
8113c1e4:	10803fcc 	andi	r2,r2,255
8113c1e8:	10801870 	cmpltui	r2,r2,97
8113c1ec:	1000101e 	bne	r2,zero,8113c230 <match_file_record_to_name_ext+0x8c>
8113c1f0:	e0fffd17 	ldw	r3,-12(fp)
8113c1f4:	e0bffc17 	ldw	r2,-16(fp)
8113c1f8:	1885883a 	add	r2,r3,r2
8113c1fc:	10800003 	ldbu	r2,0(r2)
8113c200:	10803fcc 	andi	r2,r2,255
8113c204:	10801ee8 	cmpgeui	r2,r2,123
8113c208:	1000091e 	bne	r2,zero,8113c230 <match_file_record_to_name_ext+0x8c>
8113c20c:	e0fffd17 	ldw	r3,-12(fp)
8113c210:	e0bffc17 	ldw	r2,-16(fp)
8113c214:	1885883a 	add	r2,r3,r2
8113c218:	10800003 	ldbu	r2,0(r2)
8113c21c:	10bff804 	addi	r2,r2,-32
8113c220:	10c03fcc 	andi	r3,r2,255
8113c224:	18c0201c 	xori	r3,r3,128
8113c228:	18ffe004 	addi	r3,r3,-128
8113c22c:	00000706 	br	8113c24c <match_file_record_to_name_ext+0xa8>
8113c230:	e0fffd17 	ldw	r3,-12(fp)
8113c234:	e0bffc17 	ldw	r2,-16(fp)
8113c238:	1885883a 	add	r2,r3,r2
8113c23c:	10800003 	ldbu	r2,0(r2)
8113c240:	10c03fcc 	andi	r3,r2,255
8113c244:	18c0201c 	xori	r3,r3,128
8113c248:	18ffe004 	addi	r3,r3,-128
8113c24c:	e0bffc17 	ldw	r2,-16(fp)
8113c250:	e13ffe17 	ldw	r4,-8(fp)
8113c254:	2085883a 	add	r2,r4,r2
8113c258:	10800003 	ldbu	r2,0(r2)
8113c25c:	10803fcc 	andi	r2,r2,255
8113c260:	1080201c 	xori	r2,r2,128
8113c264:	10bfe004 	addi	r2,r2,-128
8113c268:	10801850 	cmplti	r2,r2,97
8113c26c:	1000121e 	bne	r2,zero,8113c2b8 <match_file_record_to_name_ext+0x114>
8113c270:	e0bffc17 	ldw	r2,-16(fp)
8113c274:	e13ffe17 	ldw	r4,-8(fp)
8113c278:	2085883a 	add	r2,r4,r2
8113c27c:	10800003 	ldbu	r2,0(r2)
8113c280:	10803fcc 	andi	r2,r2,255
8113c284:	1080201c 	xori	r2,r2,128
8113c288:	10bfe004 	addi	r2,r2,-128
8113c28c:	10801ec8 	cmpgei	r2,r2,123
8113c290:	1000091e 	bne	r2,zero,8113c2b8 <match_file_record_to_name_ext+0x114>
8113c294:	e0bffc17 	ldw	r2,-16(fp)
8113c298:	e13ffe17 	ldw	r4,-8(fp)
8113c29c:	2085883a 	add	r2,r4,r2
8113c2a0:	10800003 	ldbu	r2,0(r2)
8113c2a4:	10bff804 	addi	r2,r2,-32
8113c2a8:	10803fcc 	andi	r2,r2,255
8113c2ac:	1080201c 	xori	r2,r2,128
8113c2b0:	10bfe004 	addi	r2,r2,-128
8113c2b4:	00000706 	br	8113c2d4 <match_file_record_to_name_ext+0x130>
8113c2b8:	e0bffc17 	ldw	r2,-16(fp)
8113c2bc:	e13ffe17 	ldw	r4,-8(fp)
8113c2c0:	2085883a 	add	r2,r4,r2
8113c2c4:	10800003 	ldbu	r2,0(r2)
8113c2c8:	10803fcc 	andi	r2,r2,255
8113c2cc:	1080201c 	xori	r2,r2,128
8113c2d0:	10bfe004 	addi	r2,r2,-128
8113c2d4:	18800226 	beq	r3,r2,8113c2e0 <match_file_record_to_name_ext+0x13c>
        {
            match = false;
8113c2d8:	e03ffb15 	stw	zero,-20(fp)
			break;
8113c2dc:	00000606 	br	8113c2f8 <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
8113c2e0:	e0bffc17 	ldw	r2,-16(fp)
8113c2e4:	10800044 	addi	r2,r2,1
8113c2e8:	e0bffc15 	stw	r2,-16(fp)
8113c2ec:	e0bffc17 	ldw	r2,-16(fp)
8113c2f0:	10800210 	cmplti	r2,r2,8
8113c2f4:	103fb71e 	bne	r2,zero,8113c1d4 <__reset+0xfb11c1d4>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
8113c2f8:	e03ffc15 	stw	zero,-16(fp)
8113c2fc:	00004a06 	br	8113c428 <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
8113c300:	e0fffd17 	ldw	r3,-12(fp)
8113c304:	e0bffc17 	ldw	r2,-16(fp)
8113c308:	1885883a 	add	r2,r3,r2
8113c30c:	10800204 	addi	r2,r2,8
8113c310:	10800003 	ldbu	r2,0(r2)
8113c314:	10803fcc 	andi	r2,r2,255
8113c318:	10801870 	cmpltui	r2,r2,97
8113c31c:	1000121e 	bne	r2,zero,8113c368 <match_file_record_to_name_ext+0x1c4>
8113c320:	e0fffd17 	ldw	r3,-12(fp)
8113c324:	e0bffc17 	ldw	r2,-16(fp)
8113c328:	1885883a 	add	r2,r3,r2
8113c32c:	10800204 	addi	r2,r2,8
8113c330:	10800003 	ldbu	r2,0(r2)
8113c334:	10803fcc 	andi	r2,r2,255
8113c338:	10801ee8 	cmpgeui	r2,r2,123
8113c33c:	10000a1e 	bne	r2,zero,8113c368 <match_file_record_to_name_ext+0x1c4>
8113c340:	e0fffd17 	ldw	r3,-12(fp)
8113c344:	e0bffc17 	ldw	r2,-16(fp)
8113c348:	1885883a 	add	r2,r3,r2
8113c34c:	10800204 	addi	r2,r2,8
8113c350:	10800003 	ldbu	r2,0(r2)
8113c354:	10bff804 	addi	r2,r2,-32
8113c358:	10c03fcc 	andi	r3,r2,255
8113c35c:	18c0201c 	xori	r3,r3,128
8113c360:	18ffe004 	addi	r3,r3,-128
8113c364:	00000806 	br	8113c388 <match_file_record_to_name_ext+0x1e4>
8113c368:	e0fffd17 	ldw	r3,-12(fp)
8113c36c:	e0bffc17 	ldw	r2,-16(fp)
8113c370:	1885883a 	add	r2,r3,r2
8113c374:	10800204 	addi	r2,r2,8
8113c378:	10800003 	ldbu	r2,0(r2)
8113c37c:	10c03fcc 	andi	r3,r2,255
8113c380:	18c0201c 	xori	r3,r3,128
8113c384:	18ffe004 	addi	r3,r3,-128
8113c388:	e0bffc17 	ldw	r2,-16(fp)
8113c38c:	e13fff17 	ldw	r4,-4(fp)
8113c390:	2085883a 	add	r2,r4,r2
8113c394:	10800003 	ldbu	r2,0(r2)
8113c398:	10803fcc 	andi	r2,r2,255
8113c39c:	1080201c 	xori	r2,r2,128
8113c3a0:	10bfe004 	addi	r2,r2,-128
8113c3a4:	10801850 	cmplti	r2,r2,97
8113c3a8:	1000121e 	bne	r2,zero,8113c3f4 <match_file_record_to_name_ext+0x250>
8113c3ac:	e0bffc17 	ldw	r2,-16(fp)
8113c3b0:	e13fff17 	ldw	r4,-4(fp)
8113c3b4:	2085883a 	add	r2,r4,r2
8113c3b8:	10800003 	ldbu	r2,0(r2)
8113c3bc:	10803fcc 	andi	r2,r2,255
8113c3c0:	1080201c 	xori	r2,r2,128
8113c3c4:	10bfe004 	addi	r2,r2,-128
8113c3c8:	10801ec8 	cmpgei	r2,r2,123
8113c3cc:	1000091e 	bne	r2,zero,8113c3f4 <match_file_record_to_name_ext+0x250>
8113c3d0:	e0bffc17 	ldw	r2,-16(fp)
8113c3d4:	e13fff17 	ldw	r4,-4(fp)
8113c3d8:	2085883a 	add	r2,r4,r2
8113c3dc:	10800003 	ldbu	r2,0(r2)
8113c3e0:	10bff804 	addi	r2,r2,-32
8113c3e4:	10803fcc 	andi	r2,r2,255
8113c3e8:	1080201c 	xori	r2,r2,128
8113c3ec:	10bfe004 	addi	r2,r2,-128
8113c3f0:	00000706 	br	8113c410 <match_file_record_to_name_ext+0x26c>
8113c3f4:	e0bffc17 	ldw	r2,-16(fp)
8113c3f8:	e13fff17 	ldw	r4,-4(fp)
8113c3fc:	2085883a 	add	r2,r4,r2
8113c400:	10800003 	ldbu	r2,0(r2)
8113c404:	10803fcc 	andi	r2,r2,255
8113c408:	1080201c 	xori	r2,r2,128
8113c40c:	10bfe004 	addi	r2,r2,-128
8113c410:	18800226 	beq	r3,r2,8113c41c <match_file_record_to_name_ext+0x278>
        {
            match = false;
8113c414:	e03ffb15 	stw	zero,-20(fp)
			break;
8113c418:	00000606 	br	8113c434 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
8113c41c:	e0bffc17 	ldw	r2,-16(fp)
8113c420:	10800044 	addi	r2,r2,1
8113c424:	e0bffc15 	stw	r2,-16(fp)
8113c428:	e0bffc17 	ldw	r2,-16(fp)
8113c42c:	108000d0 	cmplti	r2,r2,3
8113c430:	103fb31e 	bne	r2,zero,8113c300 <__reset+0xfb11c300>
        {
            match = false;
			break;
        }
    }
	return match;
8113c434:	e0bffb17 	ldw	r2,-20(fp)
}
8113c438:	e037883a 	mov	sp,fp
8113c43c:	df000017 	ldw	fp,0(sp)
8113c440:	dec00104 	addi	sp,sp,4
8113c444:	f800283a 	ret

8113c448 <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
8113c448:	deffe704 	addi	sp,sp,-100
8113c44c:	de00012e 	bgeu	sp,et,8113c454 <get_home_directory_cluster_for_file+0xc>
8113c450:	003b68fa 	trap	3
8113c454:	dfc01815 	stw	ra,96(sp)
8113c458:	df001715 	stw	fp,92(sp)
8113c45c:	df001704 	addi	fp,sp,92
8113c460:	e13ffd15 	stw	r4,-12(fp)
8113c464:	e17ffe15 	stw	r5,-8(fp)
8113c468:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
8113c46c:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
8113c470:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
8113c474:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
8113c478:	e13ffd17 	ldw	r4,-12(fp)
8113c47c:	113c0e40 	call	8113c0e4 <get_dir_divider_location>
8113c480:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
8113c484:	00012f06 	br	8113c944 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
8113c488:	00800804 	movi	r2,32
8113c48c:	e0bff905 	stb	r2,-28(fp)
8113c490:	00800804 	movi	r2,32
8113c494:	e0bff945 	stb	r2,-27(fp)
8113c498:	00800804 	movi	r2,32
8113c49c:	e0bff985 	stb	r2,-26(fp)
8113c4a0:	00800804 	movi	r2,32
8113c4a4:	e0bff9c5 	stb	r2,-25(fp)
8113c4a8:	00800804 	movi	r2,32
8113c4ac:	e0bffa05 	stb	r2,-24(fp)
8113c4b0:	00800804 	movi	r2,32
8113c4b4:	e0bffa45 	stb	r2,-23(fp)
8113c4b8:	00800804 	movi	r2,32
8113c4bc:	e0bffa85 	stb	r2,-22(fp)
8113c4c0:	00800804 	movi	r2,32
8113c4c4:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
8113c4c8:	00800804 	movi	r2,32
8113c4cc:	e0bffb05 	stb	r2,-20(fp)
8113c4d0:	00800804 	movi	r2,32
8113c4d4:	e0bffb45 	stb	r2,-19(fp)
8113c4d8:	00800804 	movi	r2,32
8113c4dc:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
8113c4e0:	00bfffc4 	movi	r2,-1
8113c4e4:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
8113c4e8:	e0bfea17 	ldw	r2,-88(fp)
8113c4ec:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
8113c4f0:	e03fec15 	stw	zero,-80(fp)
8113c4f4:	00002d06 	br	8113c5ac <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
8113c4f8:	e0ffec17 	ldw	r3,-80(fp)
8113c4fc:	e0bfed17 	ldw	r2,-76(fp)
8113c500:	1885883a 	add	r2,r3,r2
8113c504:	1007883a 	mov	r3,r2
8113c508:	e0bffd17 	ldw	r2,-12(fp)
8113c50c:	10c5883a 	add	r2,r2,r3
8113c510:	10800003 	ldbu	r2,0(r2)
8113c514:	10803fcc 	andi	r2,r2,255
8113c518:	1080201c 	xori	r2,r2,128
8113c51c:	10bfe004 	addi	r2,r2,-128
8113c520:	10800b98 	cmpnei	r2,r2,46
8113c524:	1000031e 	bne	r2,zero,8113c534 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
8113c528:	e0bfec17 	ldw	r2,-80(fp)
8113c52c:	e0bfee15 	stw	r2,-72(fp)
8113c530:	00001b06 	br	8113c5a0 <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
8113c534:	e0bfee17 	ldw	r2,-72(fp)
8113c538:	10000c0e 	bge	r2,zero,8113c56c <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
8113c53c:	e0ffec17 	ldw	r3,-80(fp)
8113c540:	e0bfed17 	ldw	r2,-76(fp)
8113c544:	1885883a 	add	r2,r3,r2
8113c548:	1007883a 	mov	r3,r2
8113c54c:	e0bffd17 	ldw	r2,-12(fp)
8113c550:	10c5883a 	add	r2,r2,r3
8113c554:	10c00003 	ldbu	r3,0(r2)
8113c558:	e13ff904 	addi	r4,fp,-28
8113c55c:	e0bfec17 	ldw	r2,-80(fp)
8113c560:	2085883a 	add	r2,r4,r2
8113c564:	10c00005 	stb	r3,0(r2)
8113c568:	00000d06 	br	8113c5a0 <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
8113c56c:	e0ffec17 	ldw	r3,-80(fp)
8113c570:	e0bfee17 	ldw	r2,-72(fp)
8113c574:	1885c83a 	sub	r2,r3,r2
8113c578:	e13fec17 	ldw	r4,-80(fp)
8113c57c:	e0ffed17 	ldw	r3,-76(fp)
8113c580:	20c7883a 	add	r3,r4,r3
8113c584:	1809883a 	mov	r4,r3
8113c588:	e0fffd17 	ldw	r3,-12(fp)
8113c58c:	1907883a 	add	r3,r3,r4
8113c590:	18c00003 	ldbu	r3,0(r3)
8113c594:	e13ffb04 	addi	r4,fp,-20
8113c598:	2085883a 	add	r2,r4,r2
8113c59c:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
8113c5a0:	e0bfec17 	ldw	r2,-80(fp)
8113c5a4:	10800044 	addi	r2,r2,1
8113c5a8:	e0bfec15 	stw	r2,-80(fp)
8113c5ac:	e0ffec17 	ldw	r3,-80(fp)
8113c5b0:	e0bfeb17 	ldw	r2,-84(fp)
8113c5b4:	18bfd016 	blt	r3,r2,8113c4f8 <__reset+0xfb11c4f8>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
8113c5b8:	e0bfea17 	ldw	r2,-88(fp)
8113c5bc:	10005c1e 	bne	r2,zero,8113c730 <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113c5c0:	00a045b4 	movhi	r2,33046
8113c5c4:	10850804 	addi	r2,r2,5152
8113c5c8:	1080050b 	ldhu	r2,20(r2)
8113c5cc:	10bfffcc 	andi	r2,r2,65535
8113c5d0:	1006917a 	slli	r3,r2,5
8113c5d4:	00a045b4 	movhi	r2,33046
8113c5d8:	10850804 	addi	r2,r2,5152
8113c5dc:	1080030b 	ldhu	r2,12(r2)
8113c5e0:	10bfffcc 	andi	r2,r2,65535
8113c5e4:	1885283a 	div	r2,r3,r2
8113c5e8:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113c5ec:	e03ff015 	stw	zero,-64(fp)
8113c5f0:	00003b06 	br	8113c6e0 <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
8113c5f4:	00a045b4 	movhi	r2,33046
8113c5f8:	10850804 	addi	r2,r2,5152
8113c5fc:	10c01317 	ldw	r3,76(r2)
8113c600:	e0bff017 	ldw	r2,-64(fp)
8113c604:	1885883a 	add	r2,r3,r2
8113c608:	1007883a 	mov	r3,r2
8113c60c:	d0a0b017 	ldw	r2,-32064(gp)
8113c610:	100b883a 	mov	r5,r2
8113c614:	1809883a 	mov	r4,r3
8113c618:	113ace00 	call	8113ace0 <Read_Sector_Data>
8113c61c:	10003426 	beq	r2,zero,8113c6f0 <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113c620:	e03ff115 	stw	zero,-60(fp)
8113c624:	00002506 	br	8113c6bc <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8113c628:	e0bff117 	ldw	r2,-60(fp)
8113c62c:	1004917a 	slli	r2,r2,5
8113c630:	e0fff017 	ldw	r3,-64(fp)
8113c634:	180f883a 	mov	r7,r3
8113c638:	000d883a 	mov	r6,zero
8113c63c:	e17fff17 	ldw	r5,-4(fp)
8113c640:	1009883a 	mov	r4,r2
8113c644:	113b1100 	call	8113b110 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113c648:	e0bfff17 	ldw	r2,-4(fp)
8113c64c:	10800003 	ldbu	r2,0(r2)
8113c650:	10803fcc 	andi	r2,r2,255
8113c654:	10803960 	cmpeqi	r2,r2,229
8113c658:	1000151e 	bne	r2,zero,8113c6b0 <get_home_directory_cluster_for_file+0x268>
8113c65c:	e0bfff17 	ldw	r2,-4(fp)
8113c660:	10800003 	ldbu	r2,0(r2)
8113c664:	10803fcc 	andi	r2,r2,255
8113c668:	10001126 	beq	r2,zero,8113c6b0 <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
8113c66c:	e0fffb04 	addi	r3,fp,-20
8113c670:	e0bff904 	addi	r2,fp,-28
8113c674:	180d883a 	mov	r6,r3
8113c678:	100b883a 	mov	r5,r2
8113c67c:	e13fff17 	ldw	r4,-4(fp)
8113c680:	113c1a40 	call	8113c1a4 <match_file_record_to_name_ext>
8113c684:	e0bff815 	stw	r2,-32(fp)
                            if (match)
8113c688:	e0bff817 	ldw	r2,-32(fp)
8113c68c:	10000826 	beq	r2,zero,8113c6b0 <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
8113c690:	e0bfff17 	ldw	r2,-4(fp)
8113c694:	1080058b 	ldhu	r2,22(r2)
8113c698:	10bfffcc 	andi	r2,r2,65535
8113c69c:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
8113c6a0:	e0bfff17 	ldw	r2,-4(fp)
8113c6a4:	00c00044 	movi	r3,1
8113c6a8:	10c00a15 	stw	r3,40(r2)
                                break;
8113c6ac:	00000606 	br	8113c6c8 <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113c6b0:	e0bff117 	ldw	r2,-60(fp)
8113c6b4:	10800044 	addi	r2,r2,1
8113c6b8:	e0bff115 	stw	r2,-60(fp)
8113c6bc:	e0bff117 	ldw	r2,-60(fp)
8113c6c0:	10800410 	cmplti	r2,r2,16
8113c6c4:	103fd81e 	bne	r2,zero,8113c628 <__reset+0xfb11c628>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
8113c6c8:	e0ffef17 	ldw	r3,-68(fp)
8113c6cc:	e0bfea17 	ldw	r2,-88(fp)
8113c6d0:	1880091e 	bne	r3,r2,8113c6f8 <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113c6d4:	e0bff017 	ldw	r2,-64(fp)
8113c6d8:	10800044 	addi	r2,r2,1
8113c6dc:	e0bff015 	stw	r2,-64(fp)
8113c6e0:	e0fff017 	ldw	r3,-64(fp)
8113c6e4:	e0bff717 	ldw	r2,-36(fp)
8113c6e8:	18bfc216 	blt	r3,r2,8113c5f4 <__reset+0xfb11c5f4>
8113c6ec:	00000306 	br	8113c6fc <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
8113c6f0:	0001883a 	nop
8113c6f4:	00000106 	br	8113c6fc <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
8113c6f8:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
8113c6fc:	e0ffef17 	ldw	r3,-68(fp)
8113c700:	e0bfea17 	ldw	r2,-88(fp)
8113c704:	18800826 	beq	r3,r2,8113c728 <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
8113c708:	e0bfef17 	ldw	r2,-68(fp)
8113c70c:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
8113c710:	e0ffed17 	ldw	r3,-76(fp)
8113c714:	e0bfeb17 	ldw	r2,-84(fp)
8113c718:	1885883a 	add	r2,r3,r2
8113c71c:	10800044 	addi	r2,r2,1
8113c720:	e0bfed15 	stw	r2,-76(fp)
8113c724:	00007d06 	br	8113c91c <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
8113c728:	0005883a 	mov	r2,zero
8113c72c:	00009106 	br	8113c974 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
8113c730:	e0bfea17 	ldw	r2,-88(fp)
8113c734:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113c738:	e0bff417 	ldw	r2,-48(fp)
8113c73c:	10ffff84 	addi	r3,r2,-2
8113c740:	00a045b4 	movhi	r2,33046
8113c744:	10850804 	addi	r2,r2,5152
8113c748:	10800383 	ldbu	r2,14(r2)
8113c74c:	10803fcc 	andi	r2,r2,255
8113c750:	1885383a 	mul	r2,r3,r2
8113c754:	1007883a 	mov	r3,r2
8113c758:	00a045b4 	movhi	r2,33046
8113c75c:	10850804 	addi	r2,r2,5152
8113c760:	10801417 	ldw	r2,80(r2)
8113c764:	1885883a 	add	r2,r3,r2
8113c768:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113c76c:	e03ff215 	stw	zero,-56(fp)
8113c770:	00003606 	br	8113c84c <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113c774:	e0fff217 	ldw	r3,-56(fp)
8113c778:	e0bff517 	ldw	r2,-44(fp)
8113c77c:	1885883a 	add	r2,r3,r2
8113c780:	d0e0b017 	ldw	r3,-32064(gp)
8113c784:	180b883a 	mov	r5,r3
8113c788:	1009883a 	mov	r4,r2
8113c78c:	113ace00 	call	8113ace0 <Read_Sector_Data>
8113c790:	10003526 	beq	r2,zero,8113c868 <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
8113c794:	e03ff315 	stw	zero,-52(fp)
8113c798:	00002306 	br	8113c828 <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
8113c79c:	e0bff317 	ldw	r2,-52(fp)
8113c7a0:	1004917a 	slli	r2,r2,5
8113c7a4:	e0fff417 	ldw	r3,-48(fp)
8113c7a8:	e13ff217 	ldw	r4,-56(fp)
8113c7ac:	200f883a 	mov	r7,r4
8113c7b0:	180d883a 	mov	r6,r3
8113c7b4:	e17fff17 	ldw	r5,-4(fp)
8113c7b8:	1009883a 	mov	r4,r2
8113c7bc:	113b1100 	call	8113b110 <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113c7c0:	e0bfff17 	ldw	r2,-4(fp)
8113c7c4:	10800003 	ldbu	r2,0(r2)
8113c7c8:	10803fcc 	andi	r2,r2,255
8113c7cc:	10803960 	cmpeqi	r2,r2,229
8113c7d0:	1000121e 	bne	r2,zero,8113c81c <get_home_directory_cluster_for_file+0x3d4>
8113c7d4:	e0bfff17 	ldw	r2,-4(fp)
8113c7d8:	10800003 	ldbu	r2,0(r2)
8113c7dc:	10803fcc 	andi	r2,r2,255
8113c7e0:	10000e26 	beq	r2,zero,8113c81c <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
8113c7e4:	e0fffb04 	addi	r3,fp,-20
8113c7e8:	e0bff904 	addi	r2,fp,-28
8113c7ec:	180d883a 	mov	r6,r3
8113c7f0:	100b883a 	mov	r5,r2
8113c7f4:	e13fff17 	ldw	r4,-4(fp)
8113c7f8:	113c1a40 	call	8113c1a4 <match_file_record_to_name_ext>
8113c7fc:	e0bff615 	stw	r2,-40(fp)
                                if (match)
8113c800:	e0bff617 	ldw	r2,-40(fp)
8113c804:	10000526 	beq	r2,zero,8113c81c <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
8113c808:	e0bfff17 	ldw	r2,-4(fp)
8113c80c:	1080058b 	ldhu	r2,22(r2)
8113c810:	10bfffcc 	andi	r2,r2,65535
8113c814:	e0bfef15 	stw	r2,-68(fp)
                                    break;
8113c818:	00000606 	br	8113c834 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
8113c81c:	e0bff317 	ldw	r2,-52(fp)
8113c820:	10800044 	addi	r2,r2,1
8113c824:	e0bff315 	stw	r2,-52(fp)
8113c828:	e0bff317 	ldw	r2,-52(fp)
8113c82c:	10800410 	cmplti	r2,r2,16
8113c830:	103fda1e 	bne	r2,zero,8113c79c <__reset+0xfb11c79c>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
8113c834:	e0ffef17 	ldw	r3,-68(fp)
8113c838:	e0bfea17 	ldw	r2,-88(fp)
8113c83c:	18800c1e 	bne	r3,r2,8113c870 <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113c840:	e0bff217 	ldw	r2,-56(fp)
8113c844:	10800044 	addi	r2,r2,1
8113c848:	e0bff215 	stw	r2,-56(fp)
8113c84c:	00a045b4 	movhi	r2,33046
8113c850:	10850804 	addi	r2,r2,5152
8113c854:	10800383 	ldbu	r2,14(r2)
8113c858:	10803fcc 	andi	r2,r2,255
8113c85c:	e0fff217 	ldw	r3,-56(fp)
8113c860:	18bfc416 	blt	r3,r2,8113c774 <__reset+0xfb11c774>
8113c864:	00000306 	br	8113c874 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
8113c868:	0001883a 	nop
8113c86c:	00000106 	br	8113c874 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
8113c870:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
8113c874:	e0ffef17 	ldw	r3,-68(fp)
8113c878:	e0bfea17 	ldw	r2,-88(fp)
8113c87c:	1880141e 	bne	r3,r2,8113c8d0 <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
8113c880:	e0bfef17 	ldw	r2,-68(fp)
8113c884:	e0fffc04 	addi	r3,fp,-16
8113c888:	180b883a 	mov	r5,r3
8113c88c:	1009883a 	mov	r4,r2
8113c890:	113adc00 	call	8113adc0 <get_cluster_flag>
8113c894:	10000c26 	beq	r2,zero,8113c8c8 <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
8113c898:	e0bffc0b 	ldhu	r2,-16(fp)
8113c89c:	10bfffcc 	andi	r2,r2,65535
8113c8a0:	10fffe0c 	andi	r3,r2,65528
8113c8a4:	00bffe14 	movui	r2,65528
8113c8a8:	1880021e 	bne	r3,r2,8113c8b4 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
8113c8ac:	0005883a 	mov	r2,zero
8113c8b0:	00003006 	br	8113c974 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
8113c8b4:	e0bffc0b 	ldhu	r2,-16(fp)
8113c8b8:	10bfffcc 	andi	r2,r2,65535
8113c8bc:	10bffe0c 	andi	r2,r2,65528
8113c8c0:	e0bfef15 	stw	r2,-68(fp)
8113c8c4:	00000206 	br	8113c8d0 <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
8113c8c8:	0005883a 	mov	r2,zero
8113c8cc:	00002906 	br	8113c974 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
8113c8d0:	e0bff417 	ldw	r2,-48(fp)
8113c8d4:	00fffdd4 	movui	r3,65527
8113c8d8:	18800316 	blt	r3,r2,8113c8e8 <get_home_directory_cluster_for_file+0x4a0>
8113c8dc:	e0ffef17 	ldw	r3,-68(fp)
8113c8e0:	e0bfea17 	ldw	r2,-88(fp)
8113c8e4:	18bf9426 	beq	r3,r2,8113c738 <__reset+0xfb11c738>
            if (new_cluster != home_dir_cluster)
8113c8e8:	e0ffef17 	ldw	r3,-68(fp)
8113c8ec:	e0bfea17 	ldw	r2,-88(fp)
8113c8f0:	18800826 	beq	r3,r2,8113c914 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
8113c8f4:	e0bfef17 	ldw	r2,-68(fp)
8113c8f8:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
8113c8fc:	e0ffed17 	ldw	r3,-76(fp)
8113c900:	e0bfeb17 	ldw	r2,-84(fp)
8113c904:	1885883a 	add	r2,r3,r2
8113c908:	10800044 	addi	r2,r2,1
8113c90c:	e0bfed15 	stw	r2,-76(fp)
8113c910:	00000206 	br	8113c91c <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
8113c914:	0005883a 	mov	r2,zero
8113c918:	00001606 	br	8113c974 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
8113c91c:	e0bfed17 	ldw	r2,-76(fp)
8113c920:	e0fffd17 	ldw	r3,-12(fp)
8113c924:	1885883a 	add	r2,r3,r2
8113c928:	1009883a 	mov	r4,r2
8113c92c:	113c0e40 	call	8113c0e4 <get_dir_divider_location>
8113c930:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
8113c934:	e0bfeb17 	ldw	r2,-84(fp)
8113c938:	1000020e 	bge	r2,zero,8113c944 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
8113c93c:	00800044 	movi	r2,1
8113c940:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
8113c944:	e0bfeb17 	ldw	r2,-84(fp)
8113c948:	00becf16 	blt	zero,r2,8113c488 <__reset+0xfb11c488>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
8113c94c:	e0bffe17 	ldw	r2,-8(fp)
8113c950:	e0ffea17 	ldw	r3,-88(fp)
8113c954:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
8113c958:	e0bfea17 	ldw	r2,-88(fp)
8113c95c:	1000041e 	bne	r2,zero,8113c970 <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
8113c960:	e0bfff17 	ldw	r2,-4(fp)
8113c964:	10000a15 	stw	zero,40(r2)
		result = true;
8113c968:	00800044 	movi	r2,1
8113c96c:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
8113c970:	e0bfe917 	ldw	r2,-92(fp)
}
8113c974:	e037883a 	mov	sp,fp
8113c978:	dfc00117 	ldw	ra,4(sp)
8113c97c:	df000017 	ldw	fp,0(sp)
8113c980:	dec00204 	addi	sp,sp,8
8113c984:	f800283a 	ret

8113c988 <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
8113c988:	deffe804 	addi	sp,sp,-96
8113c98c:	de00012e 	bgeu	sp,et,8113c994 <find_file_in_directory+0xc>
8113c990:	003b68fa 	trap	3
8113c994:	dfc01715 	stw	ra,92(sp)
8113c998:	df001615 	stw	fp,88(sp)
8113c99c:	df001604 	addi	fp,sp,88
8113c9a0:	e13ffd15 	stw	r4,-12(fp)
8113c9a4:	e17ffe15 	stw	r5,-8(fp)
8113c9a8:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
8113c9ac:	e13ffe17 	ldw	r4,-8(fp)
8113c9b0:	113c0e40 	call	8113c0e4 <get_dir_divider_location>
8113c9b4:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
8113c9b8:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
8113c9bc:	00800804 	movi	r2,32
8113c9c0:	e0bff905 	stb	r2,-28(fp)
8113c9c4:	00800804 	movi	r2,32
8113c9c8:	e0bff945 	stb	r2,-27(fp)
8113c9cc:	00800804 	movi	r2,32
8113c9d0:	e0bff985 	stb	r2,-26(fp)
8113c9d4:	00800804 	movi	r2,32
8113c9d8:	e0bff9c5 	stb	r2,-25(fp)
8113c9dc:	00800804 	movi	r2,32
8113c9e0:	e0bffa05 	stb	r2,-24(fp)
8113c9e4:	00800804 	movi	r2,32
8113c9e8:	e0bffa45 	stb	r2,-23(fp)
8113c9ec:	00800804 	movi	r2,32
8113c9f0:	e0bffa85 	stb	r2,-22(fp)
8113c9f4:	00800804 	movi	r2,32
8113c9f8:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
8113c9fc:	00800804 	movi	r2,32
8113ca00:	e0bffb05 	stb	r2,-20(fp)
8113ca04:	00800804 	movi	r2,32
8113ca08:	e0bffb45 	stb	r2,-19(fp)
8113ca0c:	00800804 	movi	r2,32
8113ca10:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
8113ca14:	00bfffc4 	movi	r2,-1
8113ca18:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
8113ca1c:	e0bffd17 	ldw	r2,-12(fp)
8113ca20:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
8113ca24:	e13ffe17 	ldw	r4,-8(fp)
8113ca28:	111b1180 	call	8111b118 <strlen>
8113ca2c:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
8113ca30:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
8113ca34:	00000b06 	br	8113ca64 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
8113ca38:	e0ffeb17 	ldw	r3,-84(fp)
8113ca3c:	e0bfea17 	ldw	r2,-88(fp)
8113ca40:	1885883a 	add	r2,r3,r2
8113ca44:	10800044 	addi	r2,r2,1
8113ca48:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
8113ca4c:	e0bfeb17 	ldw	r2,-84(fp)
8113ca50:	e0fffe17 	ldw	r3,-8(fp)
8113ca54:	1885883a 	add	r2,r3,r2
8113ca58:	1009883a 	mov	r4,r2
8113ca5c:	113c0e40 	call	8113c0e4 <get_dir_divider_location>
8113ca60:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
8113ca64:	e0bfea17 	ldw	r2,-88(fp)
8113ca68:	00bff316 	blt	zero,r2,8113ca38 <__reset+0xfb11ca38>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8113ca6c:	e0bfeb17 	ldw	r2,-84(fp)
8113ca70:	e0bfee15 	stw	r2,-72(fp)
8113ca74:	00002706 	br	8113cb14 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
8113ca78:	e0bfee17 	ldw	r2,-72(fp)
8113ca7c:	e0fffe17 	ldw	r3,-8(fp)
8113ca80:	1885883a 	add	r2,r3,r2
8113ca84:	10800003 	ldbu	r2,0(r2)
8113ca88:	10803fcc 	andi	r2,r2,255
8113ca8c:	1080201c 	xori	r2,r2,128
8113ca90:	10bfe004 	addi	r2,r2,-128
8113ca94:	10800b98 	cmpnei	r2,r2,46
8113ca98:	1000031e 	bne	r2,zero,8113caa8 <find_file_in_directory+0x120>
        {
            ext_index = index;
8113ca9c:	e0bfee17 	ldw	r2,-72(fp)
8113caa0:	e0bfec15 	stw	r2,-80(fp)
8113caa4:	00001806 	br	8113cb08 <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
8113caa8:	e0bfec17 	ldw	r2,-80(fp)
8113caac:	10000b0e 	bge	r2,zero,8113cadc <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
8113cab0:	e0ffee17 	ldw	r3,-72(fp)
8113cab4:	e0bfeb17 	ldw	r2,-84(fp)
8113cab8:	1885c83a 	sub	r2,r3,r2
8113cabc:	e0ffee17 	ldw	r3,-72(fp)
8113cac0:	e13ffe17 	ldw	r4,-8(fp)
8113cac4:	20c7883a 	add	r3,r4,r3
8113cac8:	18c00003 	ldbu	r3,0(r3)
8113cacc:	e13ff904 	addi	r4,fp,-28
8113cad0:	2085883a 	add	r2,r4,r2
8113cad4:	10c00005 	stb	r3,0(r2)
8113cad8:	00000b06 	br	8113cb08 <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
8113cadc:	e0ffee17 	ldw	r3,-72(fp)
8113cae0:	e0bfec17 	ldw	r2,-80(fp)
8113cae4:	1885c83a 	sub	r2,r3,r2
8113cae8:	10bfffc4 	addi	r2,r2,-1
8113caec:	e0ffee17 	ldw	r3,-72(fp)
8113caf0:	e13ffe17 	ldw	r4,-8(fp)
8113caf4:	20c7883a 	add	r3,r4,r3
8113caf8:	18c00003 	ldbu	r3,0(r3)
8113cafc:	e13ffb04 	addi	r4,fp,-20
8113cb00:	2085883a 	add	r2,r4,r2
8113cb04:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8113cb08:	e0bfee17 	ldw	r2,-72(fp)
8113cb0c:	10800044 	addi	r2,r2,1
8113cb10:	e0bfee15 	stw	r2,-72(fp)
8113cb14:	e0ffee17 	ldw	r3,-72(fp)
8113cb18:	e0bff417 	ldw	r2,-48(fp)
8113cb1c:	18bfd616 	blt	r3,r2,8113ca78 <__reset+0xfb11ca78>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
8113cb20:	e0bffd17 	ldw	r2,-12(fp)
8113cb24:	1000461e 	bne	r2,zero,8113cc40 <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113cb28:	00a045b4 	movhi	r2,33046
8113cb2c:	10850804 	addi	r2,r2,5152
8113cb30:	1080050b 	ldhu	r2,20(r2)
8113cb34:	10bfffcc 	andi	r2,r2,65535
8113cb38:	1006917a 	slli	r3,r2,5
8113cb3c:	00a045b4 	movhi	r2,33046
8113cb40:	10850804 	addi	r2,r2,5152
8113cb44:	1080030b 	ldhu	r2,12(r2)
8113cb48:	10bfffcc 	andi	r2,r2,65535
8113cb4c:	1885283a 	div	r2,r3,r2
8113cb50:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113cb54:	e03ff015 	stw	zero,-64(fp)
8113cb58:	00003506 	br	8113cc30 <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113cb5c:	00a045b4 	movhi	r2,33046
8113cb60:	10850804 	addi	r2,r2,5152
8113cb64:	10c01317 	ldw	r3,76(r2)
8113cb68:	e0bff017 	ldw	r2,-64(fp)
8113cb6c:	1885883a 	add	r2,r3,r2
8113cb70:	1007883a 	mov	r3,r2
8113cb74:	d0a0b017 	ldw	r2,-32064(gp)
8113cb78:	100b883a 	mov	r5,r2
8113cb7c:	1809883a 	mov	r4,r3
8113cb80:	113ace00 	call	8113ace0 <Read_Sector_Data>
8113cb84:	10009626 	beq	r2,zero,8113cde0 <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113cb88:	e03ff115 	stw	zero,-60(fp)
8113cb8c:	00002006 	br	8113cc10 <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8113cb90:	e0bff117 	ldw	r2,-60(fp)
8113cb94:	1004917a 	slli	r2,r2,5
8113cb98:	e0fff017 	ldw	r3,-64(fp)
8113cb9c:	180f883a 	mov	r7,r3
8113cba0:	000d883a 	mov	r6,zero
8113cba4:	e17fff17 	ldw	r5,-4(fp)
8113cba8:	1009883a 	mov	r4,r2
8113cbac:	113b1100 	call	8113b110 <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113cbb0:	e0bfff17 	ldw	r2,-4(fp)
8113cbb4:	10800003 	ldbu	r2,0(r2)
8113cbb8:	10803fcc 	andi	r2,r2,255
8113cbbc:	10803960 	cmpeqi	r2,r2,229
8113cbc0:	1000101e 	bne	r2,zero,8113cc04 <find_file_in_directory+0x27c>
8113cbc4:	e0bfff17 	ldw	r2,-4(fp)
8113cbc8:	10800003 	ldbu	r2,0(r2)
8113cbcc:	10803fcc 	andi	r2,r2,255
8113cbd0:	10000c26 	beq	r2,zero,8113cc04 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
8113cbd4:	e0fffb04 	addi	r3,fp,-20
8113cbd8:	e0bff904 	addi	r2,fp,-28
8113cbdc:	180d883a 	mov	r6,r3
8113cbe0:	100b883a 	mov	r5,r2
8113cbe4:	e13fff17 	ldw	r4,-4(fp)
8113cbe8:	113c1a40 	call	8113c1a4 <match_file_record_to_name_ext>
8113cbec:	e0bff815 	stw	r2,-32(fp)

                        if (match)
8113cbf0:	e0bff817 	ldw	r2,-32(fp)
8113cbf4:	10000326 	beq	r2,zero,8113cc04 <find_file_in_directory+0x27c>
                        {
                            result = true;
8113cbf8:	00800044 	movi	r2,1
8113cbfc:	e0bfef15 	stw	r2,-68(fp)
                            break;
8113cc00:	00000606 	br	8113cc1c <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113cc04:	e0bff117 	ldw	r2,-60(fp)
8113cc08:	10800044 	addi	r2,r2,1
8113cc0c:	e0bff115 	stw	r2,-60(fp)
8113cc10:	e0bff117 	ldw	r2,-60(fp)
8113cc14:	10800410 	cmplti	r2,r2,16
8113cc18:	103fdd1e 	bne	r2,zero,8113cb90 <__reset+0xfb11cb90>
            }
            else
            {
                break;
            }
            if (result)
8113cc1c:	e0bfef17 	ldw	r2,-68(fp)
8113cc20:	1000711e 	bne	r2,zero,8113cde8 <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113cc24:	e0bff017 	ldw	r2,-64(fp)
8113cc28:	10800044 	addi	r2,r2,1
8113cc2c:	e0bff015 	stw	r2,-64(fp)
8113cc30:	e0fff017 	ldw	r3,-64(fp)
8113cc34:	e0bff717 	ldw	r2,-36(fp)
8113cc38:	18bfc816 	blt	r3,r2,8113cb5c <__reset+0xfb11cb5c>
8113cc3c:	00006b06 	br	8113cdec <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113cc40:	e0bfed17 	ldw	r2,-76(fp)
8113cc44:	10ffff84 	addi	r3,r2,-2
8113cc48:	00a045b4 	movhi	r2,33046
8113cc4c:	10850804 	addi	r2,r2,5152
8113cc50:	10800383 	ldbu	r2,14(r2)
8113cc54:	10803fcc 	andi	r2,r2,255
8113cc58:	1885383a 	mul	r2,r3,r2
8113cc5c:	1007883a 	mov	r3,r2
8113cc60:	00a045b4 	movhi	r2,33046
8113cc64:	10850804 	addi	r2,r2,5152
8113cc68:	10801417 	ldw	r2,80(r2)
8113cc6c:	1885883a 	add	r2,r3,r2
8113cc70:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113cc74:	e03ff215 	stw	zero,-56(fp)
8113cc78:	00003306 	br	8113cd48 <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113cc7c:	e0fff217 	ldw	r3,-56(fp)
8113cc80:	e0bff517 	ldw	r2,-44(fp)
8113cc84:	1885883a 	add	r2,r3,r2
8113cc88:	d0e0b017 	ldw	r3,-32064(gp)
8113cc8c:	180b883a 	mov	r5,r3
8113cc90:	1009883a 	mov	r4,r2
8113cc94:	113ace00 	call	8113ace0 <Read_Sector_Data>
8113cc98:	10003226 	beq	r2,zero,8113cd64 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113cc9c:	e03ff315 	stw	zero,-52(fp)
8113cca0:	00002106 	br	8113cd28 <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
8113cca4:	e0bff317 	ldw	r2,-52(fp)
8113cca8:	1004917a 	slli	r2,r2,5
8113ccac:	e0ffed17 	ldw	r3,-76(fp)
8113ccb0:	e13ff217 	ldw	r4,-56(fp)
8113ccb4:	200f883a 	mov	r7,r4
8113ccb8:	180d883a 	mov	r6,r3
8113ccbc:	e17fff17 	ldw	r5,-4(fp)
8113ccc0:	1009883a 	mov	r4,r2
8113ccc4:	113b1100 	call	8113b110 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113ccc8:	e0bfff17 	ldw	r2,-4(fp)
8113cccc:	10800003 	ldbu	r2,0(r2)
8113ccd0:	10803fcc 	andi	r2,r2,255
8113ccd4:	10803960 	cmpeqi	r2,r2,229
8113ccd8:	1000101e 	bne	r2,zero,8113cd1c <find_file_in_directory+0x394>
8113ccdc:	e0bfff17 	ldw	r2,-4(fp)
8113cce0:	10800003 	ldbu	r2,0(r2)
8113cce4:	10803fcc 	andi	r2,r2,255
8113cce8:	10000c26 	beq	r2,zero,8113cd1c <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
8113ccec:	e0fffb04 	addi	r3,fp,-20
8113ccf0:	e0bff904 	addi	r2,fp,-28
8113ccf4:	180d883a 	mov	r6,r3
8113ccf8:	100b883a 	mov	r5,r2
8113ccfc:	e13fff17 	ldw	r4,-4(fp)
8113cd00:	113c1a40 	call	8113c1a4 <match_file_record_to_name_ext>
8113cd04:	e0bff615 	stw	r2,-40(fp)

                            if (match)
8113cd08:	e0bff617 	ldw	r2,-40(fp)
8113cd0c:	10000326 	beq	r2,zero,8113cd1c <find_file_in_directory+0x394>
                            {                               
                                result = true;
8113cd10:	00800044 	movi	r2,1
8113cd14:	e0bfef15 	stw	r2,-68(fp)
                                break;
8113cd18:	00000606 	br	8113cd34 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113cd1c:	e0bff317 	ldw	r2,-52(fp)
8113cd20:	10800044 	addi	r2,r2,1
8113cd24:	e0bff315 	stw	r2,-52(fp)
8113cd28:	e0bff317 	ldw	r2,-52(fp)
8113cd2c:	10800410 	cmplti	r2,r2,16
8113cd30:	103fdc1e 	bne	r2,zero,8113cca4 <__reset+0xfb11cca4>
                }
                else
                {
                    break;
                }
                if (result)
8113cd34:	e0bfef17 	ldw	r2,-68(fp)
8113cd38:	10000c1e 	bne	r2,zero,8113cd6c <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113cd3c:	e0bff217 	ldw	r2,-56(fp)
8113cd40:	10800044 	addi	r2,r2,1
8113cd44:	e0bff215 	stw	r2,-56(fp)
8113cd48:	00a045b4 	movhi	r2,33046
8113cd4c:	10850804 	addi	r2,r2,5152
8113cd50:	10800383 	ldbu	r2,14(r2)
8113cd54:	10803fcc 	andi	r2,r2,255
8113cd58:	e0fff217 	ldw	r3,-56(fp)
8113cd5c:	18bfc716 	blt	r3,r2,8113cc7c <__reset+0xfb11cc7c>
8113cd60:	00000306 	br	8113cd70 <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
8113cd64:	0001883a 	nop
8113cd68:	00000106 	br	8113cd70 <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
8113cd6c:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
8113cd70:	e0bfef17 	ldw	r2,-68(fp)
8113cd74:	1000141e 	bne	r2,zero,8113cdc8 <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
8113cd78:	e0bfed17 	ldw	r2,-76(fp)
8113cd7c:	e0fffc04 	addi	r3,fp,-16
8113cd80:	180b883a 	mov	r5,r3
8113cd84:	1009883a 	mov	r4,r2
8113cd88:	113adc00 	call	8113adc0 <get_cluster_flag>
8113cd8c:	10000c26 	beq	r2,zero,8113cdc0 <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8113cd90:	e0bffc0b 	ldhu	r2,-16(fp)
8113cd94:	10bfffcc 	andi	r2,r2,65535
8113cd98:	10fffe0c 	andi	r3,r2,65528
8113cd9c:	00bffe14 	movui	r2,65528
8113cda0:	1880021e 	bne	r3,r2,8113cdac <find_file_in_directory+0x424>
					{
						return false;
8113cda4:	0005883a 	mov	r2,zero
8113cda8:	00001106 	br	8113cdf0 <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
8113cdac:	e0bffc0b 	ldhu	r2,-16(fp)
8113cdb0:	10bfffcc 	andi	r2,r2,65535
8113cdb4:	10bffe0c 	andi	r2,r2,65528
8113cdb8:	e0bfed15 	stw	r2,-76(fp)
8113cdbc:	00000206 	br	8113cdc8 <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
8113cdc0:	0005883a 	mov	r2,zero
8113cdc4:	00000a06 	br	8113cdf0 <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
8113cdc8:	e0bfed17 	ldw	r2,-76(fp)
8113cdcc:	00fffdd4 	movui	r3,65527
8113cdd0:	18800616 	blt	r3,r2,8113cdec <find_file_in_directory+0x464>
8113cdd4:	e0bfef17 	ldw	r2,-68(fp)
8113cdd8:	103f9926 	beq	r2,zero,8113cc40 <__reset+0xfb11cc40>
8113cddc:	00000306 	br	8113cdec <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
8113cde0:	0001883a 	nop
8113cde4:	00000106 	br	8113cdec <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
8113cde8:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
8113cdec:	e0bfef17 	ldw	r2,-68(fp)
}
8113cdf0:	e037883a 	mov	sp,fp
8113cdf4:	dfc00117 	ldw	ra,4(sp)
8113cdf8:	df000017 	ldw	fp,0(sp)
8113cdfc:	dec00204 	addi	sp,sp,8
8113ce00:	f800283a 	ret

8113ce04 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
8113ce04:	defff504 	addi	sp,sp,-44
8113ce08:	de00012e 	bgeu	sp,et,8113ce10 <find_first_empty_cluster+0xc>
8113ce0c:	003b68fa 	trap	3
8113ce10:	dfc00a15 	stw	ra,40(sp)
8113ce14:	df000915 	stw	fp,36(sp)
8113ce18:	df000904 	addi	fp,sp,36
8113ce1c:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
8113ce20:	00a045b4 	movhi	r2,33046
8113ce24:	10850804 	addi	r2,r2,5152
8113ce28:	10801117 	ldw	r2,68(r2)
8113ce2c:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
8113ce30:	00800084 	movi	r2,2
8113ce34:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
8113ce38:	00bfffc4 	movi	r2,-1
8113ce3c:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
8113ce40:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
8113ce44:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
8113ce48:	00a045b4 	movhi	r2,33046
8113ce4c:	10850804 	addi	r2,r2,5152
8113ce50:	10801417 	ldw	r2,80(r2)
8113ce54:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
8113ce58:	00a045b4 	movhi	r2,33046
8113ce5c:	10850804 	addi	r2,r2,5152
8113ce60:	1080058b 	ldhu	r2,22(r2)
8113ce64:	10bfffcc 	andi	r2,r2,65535
8113ce68:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
8113ce6c:	00a045b4 	movhi	r2,33046
8113ce70:	10850804 	addi	r2,r2,5152
8113ce74:	10800917 	ldw	r2,36(r2)
8113ce78:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
8113ce7c:	e0bffd17 	ldw	r2,-12(fp)
8113ce80:	e0fffe17 	ldw	r3,-8(fp)
8113ce84:	18800b2e 	bgeu	r3,r2,8113ceb4 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8113ce88:	e0fffd17 	ldw	r3,-12(fp)
8113ce8c:	e0bffc17 	ldw	r2,-16(fp)
8113ce90:	1887c83a 	sub	r3,r3,r2
8113ce94:	00a045b4 	movhi	r2,33046
8113ce98:	10850804 	addi	r2,r2,5152
8113ce9c:	10800383 	ldbu	r2,14(r2)
8113cea0:	10803fcc 	andi	r2,r2,255
8113cea4:	1885203a 	divu	r2,r3,r2
8113cea8:	10800044 	addi	r2,r2,1
8113ceac:	e0bffb15 	stw	r2,-20(fp)
8113ceb0:	00002a06 	br	8113cf5c <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
8113ceb4:	e0fffe17 	ldw	r3,-8(fp)
8113ceb8:	e0bffc17 	ldw	r2,-16(fp)
8113cebc:	1887c83a 	sub	r3,r3,r2
8113cec0:	00a045b4 	movhi	r2,33046
8113cec4:	10850804 	addi	r2,r2,5152
8113cec8:	10800383 	ldbu	r2,14(r2)
8113cecc:	10803fcc 	andi	r2,r2,255
8113ced0:	1885203a 	divu	r2,r3,r2
8113ced4:	10800044 	addi	r2,r2,1
8113ced8:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
8113cedc:	00001f06 	br	8113cf5c <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
8113cee0:	e0bff717 	ldw	r2,-36(fp)
8113cee4:	d0e0b017 	ldw	r3,-32064(gp)
8113cee8:	180b883a 	mov	r5,r3
8113ceec:	1009883a 	mov	r4,r2
8113cef0:	113ace00 	call	8113ace0 <Read_Sector_Data>
8113cef4:	10001426 	beq	r2,zero,8113cf48 <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
8113cef8:	e0bff817 	ldw	r2,-32(fp)
8113cefc:	10803fcc 	andi	r2,r2,255
8113cf00:	1085883a 	add	r2,r2,r2
8113cf04:	1007883a 	mov	r3,r2
8113cf08:	d0a0b217 	ldw	r2,-32056(gp)
8113cf0c:	10800a17 	ldw	r2,40(r2)
8113cf10:	1885883a 	add	r2,r3,r2
8113cf14:	1080002b 	ldhuio	r2,0(r2)
8113cf18:	10bfffcc 	andi	r2,r2,65535
8113cf1c:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
8113cf20:	e0bff90f 	ldh	r2,-28(fp)
8113cf24:	10000726 	beq	r2,zero,8113cf44 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
8113cf28:	e0bff817 	ldw	r2,-32(fp)
8113cf2c:	10800044 	addi	r2,r2,1
8113cf30:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
8113cf34:	e0bff817 	ldw	r2,-32(fp)
8113cf38:	10803fcc 	andi	r2,r2,255
8113cf3c:	103fee1e 	bne	r2,zero,8113cef8 <__reset+0xfb11cef8>
8113cf40:	00000106 	br	8113cf48 <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
8113cf44:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
8113cf48:	e0bff90f 	ldh	r2,-28(fp)
8113cf4c:	10000926 	beq	r2,zero,8113cf74 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
8113cf50:	e0bff717 	ldw	r2,-36(fp)
8113cf54:	10800044 	addi	r2,r2,1
8113cf58:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
8113cf5c:	00a045b4 	movhi	r2,33046
8113cf60:	10850804 	addi	r2,r2,5152
8113cf64:	10c01217 	ldw	r3,72(r2)
8113cf68:	e0bff717 	ldw	r2,-36(fp)
8113cf6c:	18bfdc1e 	bne	r3,r2,8113cee0 <__reset+0xfb11cee0>
8113cf70:	00000106 	br	8113cf78 <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
8113cf74:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
8113cf78:	e0bff90f 	ldh	r2,-28(fp)
8113cf7c:	1000081e 	bne	r2,zero,8113cfa0 <find_first_empty_cluster+0x19c>
8113cf80:	e0bff90f 	ldh	r2,-28(fp)
8113cf84:	e0fffb17 	ldw	r3,-20(fp)
8113cf88:	18800536 	bltu	r3,r2,8113cfa0 <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
8113cf8c:	e0bfff17 	ldw	r2,-4(fp)
8113cf90:	e0fff817 	ldw	r3,-32(fp)
8113cf94:	10c00015 	stw	r3,0(r2)
		result = true;
8113cf98:	00800044 	movi	r2,1
8113cf9c:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
8113cfa0:	e0bffa17 	ldw	r2,-24(fp)
}
8113cfa4:	e037883a 	mov	sp,fp
8113cfa8:	dfc00117 	ldw	ra,4(sp)
8113cfac:	df000017 	ldw	fp,0(sp)
8113cfb0:	dec00204 	addi	sp,sp,8
8113cfb4:	f800283a 	ret

8113cfb8 <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
8113cfb8:	defff604 	addi	sp,sp,-40
8113cfbc:	de00012e 	bgeu	sp,et,8113cfc4 <find_first_empty_record_in_a_subdirectory+0xc>
8113cfc0:	003b68fa 	trap	3
8113cfc4:	dfc00915 	stw	ra,36(sp)
8113cfc8:	df000815 	stw	fp,32(sp)
8113cfcc:	df000804 	addi	fp,sp,32
8113cfd0:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
8113cfd4:	00bfffc4 	movi	r2,-1
8113cfd8:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
8113cfdc:	e0bfff17 	ldw	r2,-4(fp)
8113cfe0:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113cfe4:	e0bff917 	ldw	r2,-28(fp)
8113cfe8:	10ffff84 	addi	r3,r2,-2
8113cfec:	00a045b4 	movhi	r2,33046
8113cff0:	10850804 	addi	r2,r2,5152
8113cff4:	10800383 	ldbu	r2,14(r2)
8113cff8:	10803fcc 	andi	r2,r2,255
8113cffc:	1885383a 	mul	r2,r3,r2
8113d000:	1007883a 	mov	r3,r2
8113d004:	00a045b4 	movhi	r2,33046
8113d008:	10850804 	addi	r2,r2,5152
8113d00c:	10801417 	ldw	r2,80(r2)
8113d010:	1885883a 	add	r2,r3,r2
8113d014:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113d018:	e03ffa15 	stw	zero,-24(fp)
8113d01c:	00002c06 	br	8113d0d0 <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113d020:	e0fffa17 	ldw	r3,-24(fp)
8113d024:	e0bffc17 	ldw	r2,-16(fp)
8113d028:	1885883a 	add	r2,r3,r2
8113d02c:	d0e0b017 	ldw	r3,-32064(gp)
8113d030:	180b883a 	mov	r5,r3
8113d034:	1009883a 	mov	r4,r2
8113d038:	113ace00 	call	8113ace0 <Read_Sector_Data>
8113d03c:	10002b26 	beq	r2,zero,8113d0ec <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113d040:	e03ffb15 	stw	zero,-20(fp)
8113d044:	00001c06 	br	8113d0b8 <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8113d048:	e0bffb17 	ldw	r2,-20(fp)
8113d04c:	1004917a 	slli	r2,r2,5
8113d050:	1007883a 	mov	r3,r2
8113d054:	d0a0b217 	ldw	r2,-32056(gp)
8113d058:	10800a17 	ldw	r2,40(r2)
8113d05c:	1885883a 	add	r2,r3,r2
8113d060:	10800023 	ldbuio	r2,0(r2)
8113d064:	10803fcc 	andi	r2,r2,255
8113d068:	10803fcc 	andi	r2,r2,255
8113d06c:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
8113d070:	e0bffd0b 	ldhu	r2,-12(fp)
8113d074:	10803960 	cmpeqi	r2,r2,229
8113d078:	1000021e 	bne	r2,zero,8113d084 <find_first_empty_record_in_a_subdirectory+0xcc>
8113d07c:	e0bffd0b 	ldhu	r2,-12(fp)
8113d080:	10000a1e 	bne	r2,zero,8113d0ac <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
8113d084:	e0bffa17 	ldw	r2,-24(fp)
8113d088:	1006913a 	slli	r3,r2,4
8113d08c:	e0bffb17 	ldw	r2,-20(fp)
8113d090:	1885883a 	add	r2,r3,r2
8113d094:	1006943a 	slli	r3,r2,16
8113d098:	e0bff917 	ldw	r2,-28(fp)
8113d09c:	1884b03a 	or	r2,r3,r2
8113d0a0:	e0bff815 	stw	r2,-32(fp)
                        return result;
8113d0a4:	e0bff817 	ldw	r2,-32(fp)
8113d0a8:	00005306 	br	8113d1f8 <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8113d0ac:	e0bffb17 	ldw	r2,-20(fp)
8113d0b0:	10800044 	addi	r2,r2,1
8113d0b4:	e0bffb15 	stw	r2,-20(fp)
8113d0b8:	e0bffb17 	ldw	r2,-20(fp)
8113d0bc:	10800410 	cmplti	r2,r2,16
8113d0c0:	103fe11e 	bne	r2,zero,8113d048 <__reset+0xfb11d048>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113d0c4:	e0bffa17 	ldw	r2,-24(fp)
8113d0c8:	10800044 	addi	r2,r2,1
8113d0cc:	e0bffa15 	stw	r2,-24(fp)
8113d0d0:	00a045b4 	movhi	r2,33046
8113d0d4:	10850804 	addi	r2,r2,5152
8113d0d8:	10800383 	ldbu	r2,14(r2)
8113d0dc:	10803fcc 	andi	r2,r2,255
8113d0e0:	e0fffa17 	ldw	r3,-24(fp)
8113d0e4:	18bfce16 	blt	r3,r2,8113d020 <__reset+0xfb11d020>
8113d0e8:	00000106 	br	8113d0f0 <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
8113d0ec:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
8113d0f0:	e0bff817 	ldw	r2,-32(fp)
8113d0f4:	1000390e 	bge	r2,zero,8113d1dc <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
8113d0f8:	e0bff917 	ldw	r2,-28(fp)
8113d0fc:	e0fffd84 	addi	r3,fp,-10
8113d100:	180b883a 	mov	r5,r3
8113d104:	1009883a 	mov	r4,r2
8113d108:	113adc00 	call	8113adc0 <get_cluster_flag>
8113d10c:	10003126 	beq	r2,zero,8113d1d4 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8113d110:	e0bffd8b 	ldhu	r2,-10(fp)
8113d114:	10bfffcc 	andi	r2,r2,65535
8113d118:	10fffe0c 	andi	r3,r2,65528
8113d11c:	00bffe14 	movui	r2,65528
8113d120:	18802e1e 	bne	r3,r2,8113d1dc <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
8113d124:	e0bffe04 	addi	r2,fp,-8
8113d128:	1009883a 	mov	r4,r2
8113d12c:	113ce040 	call	8113ce04 <find_first_empty_cluster>
8113d130:	10002326 	beq	r2,zero,8113d1c0 <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
8113d134:	e0bff917 	ldw	r2,-28(fp)
8113d138:	e0fffe17 	ldw	r3,-8(fp)
8113d13c:	18ffffcc 	andi	r3,r3,65535
8113d140:	18e0001c 	xori	r3,r3,32768
8113d144:	18e00004 	addi	r3,r3,-32768
8113d148:	01800044 	movi	r6,1
8113d14c:	180b883a 	mov	r5,r3
8113d150:	1009883a 	mov	r4,r2
8113d154:	113ae7c0 	call	8113ae7c <mark_cluster>
8113d158:	10001926 	beq	r2,zero,8113d1c0 <find_first_empty_record_in_a_subdirectory+0x208>
8113d15c:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
8113d160:	01800044 	movi	r6,1
8113d164:	017fffc4 	movi	r5,-1
8113d168:	1009883a 	mov	r4,r2
8113d16c:	113ae7c0 	call	8113ae7c <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
8113d170:	10001326 	beq	r2,zero,8113d1c0 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113d174:	e0bff917 	ldw	r2,-28(fp)
8113d178:	e0fffe17 	ldw	r3,-8(fp)
8113d17c:	18ffffcc 	andi	r3,r3,65535
8113d180:	18e0001c 	xori	r3,r3,32768
8113d184:	18e00004 	addi	r3,r3,-32768
8113d188:	000d883a 	mov	r6,zero
8113d18c:	180b883a 	mov	r5,r3
8113d190:	1009883a 	mov	r4,r2
8113d194:	113ae7c0 	call	8113ae7c <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
8113d198:	10000926 	beq	r2,zero,8113d1c0 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113d19c:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
8113d1a0:	000d883a 	mov	r6,zero
8113d1a4:	017fffc4 	movi	r5,-1
8113d1a8:	1009883a 	mov	r4,r2
8113d1ac:	113ae7c0 	call	8113ae7c <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8113d1b0:	10000326 	beq	r2,zero,8113d1c0 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
8113d1b4:	113ac8c0 	call	8113ac8c <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
8113d1b8:	e0bffe17 	ldw	r2,-8(fp)
8113d1bc:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
8113d1c0:	e0bffd8b 	ldhu	r2,-10(fp)
8113d1c4:	10bfffcc 	andi	r2,r2,65535
8113d1c8:	10bffe0c 	andi	r2,r2,65528
8113d1cc:	e0bff915 	stw	r2,-28(fp)
8113d1d0:	00000206 	br	8113d1dc <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
8113d1d4:	00bfffc4 	movi	r2,-1
8113d1d8:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
8113d1dc:	e0bff917 	ldw	r2,-28(fp)
8113d1e0:	00fffdd4 	movui	r3,65527
8113d1e4:	18800316 	blt	r3,r2,8113d1f4 <find_first_empty_record_in_a_subdirectory+0x23c>
8113d1e8:	e0bff817 	ldw	r2,-32(fp)
8113d1ec:	10bfffe0 	cmpeqi	r2,r2,-1
8113d1f0:	103f7c1e 	bne	r2,zero,8113cfe4 <__reset+0xfb11cfe4>
    return result; 
8113d1f4:	e0bff817 	ldw	r2,-32(fp)
}
8113d1f8:	e037883a 	mov	sp,fp
8113d1fc:	dfc00117 	ldw	ra,4(sp)
8113d200:	df000017 	ldw	fp,0(sp)
8113d204:	dec00204 	addi	sp,sp,8
8113d208:	f800283a 	ret

8113d20c <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
8113d20c:	defff904 	addi	sp,sp,-28
8113d210:	de00012e 	bgeu	sp,et,8113d218 <find_first_empty_record_in_root_directory+0xc>
8113d214:	003b68fa 	trap	3
8113d218:	dfc00615 	stw	ra,24(sp)
8113d21c:	df000515 	stw	fp,20(sp)
8113d220:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113d224:	00a045b4 	movhi	r2,33046
8113d228:	10850804 	addi	r2,r2,5152
8113d22c:	1080050b 	ldhu	r2,20(r2)
8113d230:	10bfffcc 	andi	r2,r2,65535
8113d234:	1006917a 	slli	r3,r2,5
8113d238:	00a045b4 	movhi	r2,33046
8113d23c:	10850804 	addi	r2,r2,5152
8113d240:	1080030b 	ldhu	r2,12(r2)
8113d244:	10bfffcc 	andi	r2,r2,65535
8113d248:	1885283a 	div	r2,r3,r2
8113d24c:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
8113d250:	00bfffc4 	movi	r2,-1
8113d254:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113d258:	e03ffb15 	stw	zero,-20(fp)
8113d25c:	00002d06 	br	8113d314 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113d260:	00a045b4 	movhi	r2,33046
8113d264:	10850804 	addi	r2,r2,5152
8113d268:	10c01317 	ldw	r3,76(r2)
8113d26c:	e0bffb17 	ldw	r2,-20(fp)
8113d270:	1885883a 	add	r2,r3,r2
8113d274:	1007883a 	mov	r3,r2
8113d278:	d0a0b017 	ldw	r2,-32064(gp)
8113d27c:	100b883a 	mov	r5,r2
8113d280:	1809883a 	mov	r4,r3
8113d284:	113ace00 	call	8113ace0 <Read_Sector_Data>
8113d288:	10002626 	beq	r2,zero,8113d324 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8113d28c:	e03ffc15 	stw	zero,-16(fp)
8113d290:	00001a06 	br	8113d2fc <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
8113d294:	e0bffc17 	ldw	r2,-16(fp)
8113d298:	1004917a 	slli	r2,r2,5
8113d29c:	1007883a 	mov	r3,r2
8113d2a0:	d0a0b217 	ldw	r2,-32056(gp)
8113d2a4:	10800a17 	ldw	r2,40(r2)
8113d2a8:	1885883a 	add	r2,r3,r2
8113d2ac:	10800023 	ldbuio	r2,0(r2)
8113d2b0:	10803fcc 	andi	r2,r2,255
8113d2b4:	10803fcc 	andi	r2,r2,255
8113d2b8:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
8113d2bc:	e0bfff0b 	ldhu	r2,-4(fp)
8113d2c0:	10803960 	cmpeqi	r2,r2,229
8113d2c4:	1000021e 	bne	r2,zero,8113d2d0 <find_first_empty_record_in_root_directory+0xc4>
8113d2c8:	e0bfff0b 	ldhu	r2,-4(fp)
8113d2cc:	1000081e 	bne	r2,zero,8113d2f0 <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
8113d2d0:	e0bffb17 	ldw	r2,-20(fp)
8113d2d4:	1006913a 	slli	r3,r2,4
8113d2d8:	e0bffc17 	ldw	r2,-16(fp)
8113d2dc:	1885883a 	add	r2,r3,r2
8113d2e0:	1004943a 	slli	r2,r2,16
8113d2e4:	e0bffe15 	stw	r2,-8(fp)
                    return result;
8113d2e8:	e0bffe17 	ldw	r2,-8(fp)
8113d2ec:	00000f06 	br	8113d32c <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8113d2f0:	e0bffc17 	ldw	r2,-16(fp)
8113d2f4:	10800044 	addi	r2,r2,1
8113d2f8:	e0bffc15 	stw	r2,-16(fp)
8113d2fc:	e0bffc17 	ldw	r2,-16(fp)
8113d300:	10800410 	cmplti	r2,r2,16
8113d304:	103fe31e 	bne	r2,zero,8113d294 <__reset+0xfb11d294>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113d308:	e0bffb17 	ldw	r2,-20(fp)
8113d30c:	10800044 	addi	r2,r2,1
8113d310:	e0bffb15 	stw	r2,-20(fp)
8113d314:	e0fffb17 	ldw	r3,-20(fp)
8113d318:	e0bffd17 	ldw	r2,-12(fp)
8113d31c:	18bfd016 	blt	r3,r2,8113d260 <__reset+0xfb11d260>
8113d320:	00000106 	br	8113d328 <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
8113d324:	0001883a 	nop
        }
    }
    return result;
8113d328:	e0bffe17 	ldw	r2,-8(fp)
}
8113d32c:	e037883a 	mov	sp,fp
8113d330:	dfc00117 	ldw	ra,4(sp)
8113d334:	df000017 	ldw	fp,0(sp)
8113d338:	dec00204 	addi	sp,sp,8
8113d33c:	f800283a 	ret

8113d340 <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
8113d340:	defffa04 	addi	sp,sp,-24
8113d344:	de00012e 	bgeu	sp,et,8113d34c <convert_filename_to_name_extension+0xc>
8113d348:	003b68fa 	trap	3
8113d34c:	df000515 	stw	fp,20(sp)
8113d350:	df000504 	addi	fp,sp,20
8113d354:	e13ffd15 	stw	r4,-12(fp)
8113d358:	e17ffe15 	stw	r5,-8(fp)
8113d35c:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
8113d360:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
8113d364:	e03ffb15 	stw	zero,-20(fp)
8113d368:	00002506 	br	8113d400 <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
8113d36c:	e0bffc17 	ldw	r2,-16(fp)
8113d370:	e0fffd17 	ldw	r3,-12(fp)
8113d374:	1885883a 	add	r2,r3,r2
8113d378:	10800003 	ldbu	r2,0(r2)
8113d37c:	10803fcc 	andi	r2,r2,255
8113d380:	1080201c 	xori	r2,r2,128
8113d384:	10bfe004 	addi	r2,r2,-128
8113d388:	10800ba0 	cmpeqi	r2,r2,46
8113d38c:	1000141e 	bne	r2,zero,8113d3e0 <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
8113d390:	e0bffb17 	ldw	r2,-20(fp)
8113d394:	e0fffe17 	ldw	r3,-8(fp)
8113d398:	1885883a 	add	r2,r3,r2
8113d39c:	e0fffc17 	ldw	r3,-16(fp)
8113d3a0:	e13ffd17 	ldw	r4,-12(fp)
8113d3a4:	20c7883a 	add	r3,r4,r3
8113d3a8:	18c00003 	ldbu	r3,0(r3)
8113d3ac:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
8113d3b0:	e0bffc17 	ldw	r2,-16(fp)
8113d3b4:	e0fffd17 	ldw	r3,-12(fp)
8113d3b8:	1885883a 	add	r2,r3,r2
8113d3bc:	10800003 	ldbu	r2,0(r2)
8113d3c0:	10803fcc 	andi	r2,r2,255
8113d3c4:	1080201c 	xori	r2,r2,128
8113d3c8:	10bfe004 	addi	r2,r2,-128
8113d3cc:	10000926 	beq	r2,zero,8113d3f4 <convert_filename_to_name_extension+0xb4>
8113d3d0:	e0bffc17 	ldw	r2,-16(fp)
8113d3d4:	10800044 	addi	r2,r2,1
8113d3d8:	e0bffc15 	stw	r2,-16(fp)
8113d3dc:	00000506 	br	8113d3f4 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
8113d3e0:	e0bffb17 	ldw	r2,-20(fp)
8113d3e4:	e0fffe17 	ldw	r3,-8(fp)
8113d3e8:	1885883a 	add	r2,r3,r2
8113d3ec:	00c00804 	movi	r3,32
8113d3f0:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
8113d3f4:	e0bffb17 	ldw	r2,-20(fp)
8113d3f8:	10800044 	addi	r2,r2,1
8113d3fc:	e0bffb15 	stw	r2,-20(fp)
8113d400:	e0bffb17 	ldw	r2,-20(fp)
8113d404:	10800210 	cmplti	r2,r2,8
8113d408:	103fd81e 	bne	r2,zero,8113d36c <__reset+0xfb11d36c>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
8113d40c:	e0bffc17 	ldw	r2,-16(fp)
8113d410:	e0fffd17 	ldw	r3,-12(fp)
8113d414:	1885883a 	add	r2,r3,r2
8113d418:	10800003 	ldbu	r2,0(r2)
8113d41c:	10803fcc 	andi	r2,r2,255
8113d420:	1080201c 	xori	r2,r2,128
8113d424:	10bfe004 	addi	r2,r2,-128
8113d428:	10800b98 	cmpnei	r2,r2,46
8113d42c:	1000031e 	bne	r2,zero,8113d43c <convert_filename_to_name_extension+0xfc>
8113d430:	e0bffc17 	ldw	r2,-16(fp)
8113d434:	10800044 	addi	r2,r2,1
8113d438:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
8113d43c:	e03ffb15 	stw	zero,-20(fp)
8113d440:	00001c06 	br	8113d4b4 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
8113d444:	e0bffc17 	ldw	r2,-16(fp)
8113d448:	e0fffd17 	ldw	r3,-12(fp)
8113d44c:	1885883a 	add	r2,r3,r2
8113d450:	10800003 	ldbu	r2,0(r2)
8113d454:	10803fcc 	andi	r2,r2,255
8113d458:	1080201c 	xori	r2,r2,128
8113d45c:	10bfe004 	addi	r2,r2,-128
8113d460:	10000c26 	beq	r2,zero,8113d494 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
8113d464:	e0bffb17 	ldw	r2,-20(fp)
8113d468:	e0ffff17 	ldw	r3,-4(fp)
8113d46c:	1885883a 	add	r2,r3,r2
8113d470:	e0fffc17 	ldw	r3,-16(fp)
8113d474:	e13ffd17 	ldw	r4,-12(fp)
8113d478:	20c7883a 	add	r3,r4,r3
8113d47c:	18c00003 	ldbu	r3,0(r3)
8113d480:	10c00005 	stb	r3,0(r2)
            local++;
8113d484:	e0bffc17 	ldw	r2,-16(fp)
8113d488:	10800044 	addi	r2,r2,1
8113d48c:	e0bffc15 	stw	r2,-16(fp)
8113d490:	00000506 	br	8113d4a8 <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
8113d494:	e0bffb17 	ldw	r2,-20(fp)
8113d498:	e0ffff17 	ldw	r3,-4(fp)
8113d49c:	1885883a 	add	r2,r3,r2
8113d4a0:	00c00804 	movi	r3,32
8113d4a4:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
8113d4a8:	e0bffb17 	ldw	r2,-20(fp)
8113d4ac:	10800044 	addi	r2,r2,1
8113d4b0:	e0bffb15 	stw	r2,-20(fp)
8113d4b4:	e0bffb17 	ldw	r2,-20(fp)
8113d4b8:	108000d0 	cmplti	r2,r2,3
8113d4bc:	103fe11e 	bne	r2,zero,8113d444 <__reset+0xfb11d444>
        {
            extension[counter] = ' ';
        }
    }

}
8113d4c0:	0001883a 	nop
8113d4c4:	e037883a 	mov	sp,fp
8113d4c8:	df000017 	ldw	fp,0(sp)
8113d4cc:	dec00104 	addi	sp,sp,4
8113d4d0:	f800283a 	ret

8113d4d4 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
8113d4d4:	defff504 	addi	sp,sp,-44
8113d4d8:	de00012e 	bgeu	sp,et,8113d4e0 <create_file+0xc>
8113d4dc:	003b68fa 	trap	3
8113d4e0:	dfc00a15 	stw	ra,40(sp)
8113d4e4:	df000915 	stw	fp,36(sp)
8113d4e8:	df000904 	addi	fp,sp,36
8113d4ec:	e13ffd15 	stw	r4,-12(fp)
8113d4f0:	e17ffe15 	stw	r5,-8(fp)
8113d4f4:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
8113d4f8:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
8113d4fc:	e0bffc04 	addi	r2,fp,-16
8113d500:	1009883a 	mov	r4,r2
8113d504:	113ce040 	call	8113ce04 <find_first_empty_cluster>
8113d508:	1000a026 	beq	r2,zero,8113d78c <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
8113d50c:	e0bfff17 	ldw	r2,-4(fp)
8113d510:	10800a17 	ldw	r2,40(r2)
8113d514:	1000031e 	bne	r2,zero,8113d524 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
8113d518:	113d20c0 	call	8113d20c <find_first_empty_record_in_root_directory>
8113d51c:	e0bff815 	stw	r2,-32(fp)
8113d520:	00000606 	br	8113d53c <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
8113d524:	e0bfff17 	ldw	r2,-4(fp)
8113d528:	1080058b 	ldhu	r2,22(r2)
8113d52c:	10bfffcc 	andi	r2,r2,65535
8113d530:	1009883a 	mov	r4,r2
8113d534:	113cfb80 	call	8113cfb8 <find_first_empty_record_in_a_subdirectory>
8113d538:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
8113d53c:	e0bff817 	ldw	r2,-32(fp)
8113d540:	10009216 	blt	r2,zero,8113d78c <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
8113d544:	e13ffd17 	ldw	r4,-12(fp)
8113d548:	113c0e40 	call	8113c0e4 <get_dir_divider_location>
8113d54c:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
8113d550:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
8113d554:	00000b06 	br	8113d584 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
8113d558:	e0fffa17 	ldw	r3,-24(fp)
8113d55c:	e0bff917 	ldw	r2,-28(fp)
8113d560:	1885883a 	add	r2,r3,r2
8113d564:	10800044 	addi	r2,r2,1
8113d568:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
8113d56c:	e0bffa17 	ldw	r2,-24(fp)
8113d570:	e0fffd17 	ldw	r3,-12(fp)
8113d574:	1885883a 	add	r2,r3,r2
8113d578:	1009883a 	mov	r4,r2
8113d57c:	113c0e40 	call	8113c0e4 <get_dir_divider_location>
8113d580:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
8113d584:	e0bff917 	ldw	r2,-28(fp)
8113d588:	00bff316 	blt	zero,r2,8113d558 <__reset+0xfb11d558>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
8113d58c:	e0bffa17 	ldw	r2,-24(fp)
8113d590:	e0fffd17 	ldw	r3,-12(fp)
8113d594:	1887883a 	add	r3,r3,r2
8113d598:	e13ffe17 	ldw	r4,-8(fp)
8113d59c:	e0bffe17 	ldw	r2,-8(fp)
8113d5a0:	10800204 	addi	r2,r2,8
8113d5a4:	100d883a 	mov	r6,r2
8113d5a8:	200b883a 	mov	r5,r4
8113d5ac:	1809883a 	mov	r4,r3
8113d5b0:	113d3400 	call	8113d340 <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
8113d5b4:	e0bffe17 	ldw	r2,-8(fp)
8113d5b8:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
8113d5bc:	e0bffe17 	ldw	r2,-8(fp)
8113d5c0:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
8113d5c4:	e0bffe17 	ldw	r2,-8(fp)
8113d5c8:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
8113d5cc:	e0bffe17 	ldw	r2,-8(fp)
8113d5d0:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
8113d5d4:	e0bffe17 	ldw	r2,-8(fp)
8113d5d8:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
8113d5dc:	e0bffe17 	ldw	r2,-8(fp)
8113d5e0:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
8113d5e4:	e0bffc17 	ldw	r2,-16(fp)
8113d5e8:	1007883a 	mov	r3,r2
8113d5ec:	e0bffe17 	ldw	r2,-8(fp)
8113d5f0:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
8113d5f4:	e0bffe17 	ldw	r2,-8(fp)
8113d5f8:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
8113d5fc:	e0fffc17 	ldw	r3,-16(fp)
8113d600:	e0bffe17 	ldw	r2,-8(fp)
8113d604:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
8113d608:	e0bffe17 	ldw	r2,-8(fp)
8113d60c:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
8113d610:	e0bffe17 	ldw	r2,-8(fp)
8113d614:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
8113d618:	e0bff817 	ldw	r2,-32(fp)
8113d61c:	10ffffcc 	andi	r3,r2,65535
8113d620:	e0bffe17 	ldw	r2,-8(fp)
8113d624:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
8113d628:	e0bff817 	ldw	r2,-32(fp)
8113d62c:	1004d43a 	srli	r2,r2,16
8113d630:	1000010e 	bge	r2,zero,8113d638 <create_file+0x164>
8113d634:	108003c4 	addi	r2,r2,15
8113d638:	1005d13a 	srai	r2,r2,4
8113d63c:	1007883a 	mov	r3,r2
8113d640:	e0bffe17 	ldw	r2,-8(fp)
8113d644:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
8113d648:	e0bff817 	ldw	r2,-32(fp)
8113d64c:	1004d43a 	srli	r2,r2,16
8113d650:	1007883a 	mov	r3,r2
8113d654:	00a00034 	movhi	r2,32768
8113d658:	108003c4 	addi	r2,r2,15
8113d65c:	1884703a 	and	r2,r3,r2
8113d660:	1000040e 	bge	r2,zero,8113d674 <create_file+0x1a0>
8113d664:	10bfffc4 	addi	r2,r2,-1
8113d668:	00fffc04 	movi	r3,-16
8113d66c:	10c4b03a 	or	r2,r2,r3
8113d670:	10800044 	addi	r2,r2,1
8113d674:	1004917a 	slli	r2,r2,5
8113d678:	1007883a 	mov	r3,r2
8113d67c:	e0bffe17 	ldw	r2,-8(fp)
8113d680:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
8113d684:	e0bfff17 	ldw	r2,-4(fp)
8113d688:	1080058b 	ldhu	r2,22(r2)
8113d68c:	10ffffcc 	andi	r3,r2,65535
8113d690:	e0bffe17 	ldw	r2,-8(fp)
8113d694:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
8113d698:	e0bffe17 	ldw	r2,-8(fp)
8113d69c:	00c00044 	movi	r3,1
8113d6a0:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
8113d6a4:	e0bffe17 	ldw	r2,-8(fp)
8113d6a8:	00c00044 	movi	r3,1
8113d6ac:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
8113d6b0:	e0bffe17 	ldw	r2,-8(fp)
8113d6b4:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
8113d6b8:	1000071e 	bne	r2,zero,8113d6d8 <create_file+0x204>
8113d6bc:	00a045b4 	movhi	r2,33046
8113d6c0:	10850804 	addi	r2,r2,5152
8113d6c4:	10c01317 	ldw	r3,76(r2)
8113d6c8:	e0bffe17 	ldw	r2,-8(fp)
8113d6cc:	10800b17 	ldw	r2,44(r2)
8113d6d0:	1885883a 	add	r2,r3,r2
8113d6d4:	00000f06 	br	8113d714 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
8113d6d8:	00a045b4 	movhi	r2,33046
8113d6dc:	10850804 	addi	r2,r2,5152
8113d6e0:	10c01417 	ldw	r3,80(r2)
8113d6e4:	e0bffe17 	ldw	r2,-8(fp)
8113d6e8:	10800a17 	ldw	r2,40(r2)
8113d6ec:	113fff84 	addi	r4,r2,-2
8113d6f0:	00a045b4 	movhi	r2,33046
8113d6f4:	10850804 	addi	r2,r2,5152
8113d6f8:	10800383 	ldbu	r2,14(r2)
8113d6fc:	10803fcc 	andi	r2,r2,255
8113d700:	2085383a 	mul	r2,r4,r2
8113d704:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
8113d708:	e0bffe17 	ldw	r2,-8(fp)
8113d70c:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
8113d710:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
8113d714:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
8113d718:	e0bffb17 	ldw	r2,-20(fp)
8113d71c:	d0e0b017 	ldw	r3,-32064(gp)
8113d720:	180b883a 	mov	r5,r3
8113d724:	1009883a 	mov	r4,r2
8113d728:	113ace00 	call	8113ace0 <Read_Sector_Data>
8113d72c:	10001726 	beq	r2,zero,8113d78c <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
8113d730:	e0bffe17 	ldw	r2,-8(fp)
8113d734:	10800c0b 	ldhu	r2,48(r2)
8113d738:	10bfffcc 	andi	r2,r2,65535
8113d73c:	10a0001c 	xori	r2,r2,32768
8113d740:	10a00004 	addi	r2,r2,-32768
8113d744:	e17ffe17 	ldw	r5,-8(fp)
8113d748:	1009883a 	mov	r4,r2
8113d74c:	113b3940 	call	8113b394 <Write_File_Record_At_Offset>
8113d750:	10000e26 	beq	r2,zero,8113d78c <create_file+0x2b8>
                {
                    Save_Modified_Sector();
8113d754:	113ac8c0 	call	8113ac8c <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
8113d758:	e0bffc17 	ldw	r2,-16(fp)
8113d75c:	01800044 	movi	r6,1
8113d760:	017fffc4 	movi	r5,-1
8113d764:	1009883a 	mov	r4,r2
8113d768:	113ae7c0 	call	8113ae7c <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
8113d76c:	e0bffc17 	ldw	r2,-16(fp)
8113d770:	000d883a 	mov	r6,zero
8113d774:	017fffc4 	movi	r5,-1
8113d778:	1009883a 	mov	r4,r2
8113d77c:	113ae7c0 	call	8113ae7c <mark_cluster>
8113d780:	10000226 	beq	r2,zero,8113d78c <create_file+0x2b8>
                    {
                        result = true;
8113d784:	00800044 	movi	r2,1
8113d788:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
8113d78c:	e0bff717 	ldw	r2,-36(fp)
}
8113d790:	e037883a 	mov	sp,fp
8113d794:	dfc00117 	ldw	ra,4(sp)
8113d798:	df000017 	ldw	fp,0(sp)
8113d79c:	dec00204 	addi	sp,sp,8
8113d7a0:	f800283a 	ret

8113d7a4 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
8113d7a4:	defffb04 	addi	sp,sp,-20
8113d7a8:	de00012e 	bgeu	sp,et,8113d7b0 <copy_file_record_name_to_string+0xc>
8113d7ac:	003b68fa 	trap	3
8113d7b0:	df000415 	stw	fp,16(sp)
8113d7b4:	df000404 	addi	fp,sp,16
8113d7b8:	e13ffe15 	stw	r4,-8(fp)
8113d7bc:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
8113d7c0:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
8113d7c4:	e03ffc15 	stw	zero,-16(fp)
8113d7c8:	00001506 	br	8113d820 <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
8113d7cc:	e0fffe17 	ldw	r3,-8(fp)
8113d7d0:	e0bffc17 	ldw	r2,-16(fp)
8113d7d4:	1885883a 	add	r2,r3,r2
8113d7d8:	10800003 	ldbu	r2,0(r2)
8113d7dc:	10803fcc 	andi	r2,r2,255
8113d7e0:	10800820 	cmpeqi	r2,r2,32
8113d7e4:	10000b1e 	bne	r2,zero,8113d814 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
8113d7e8:	e0bffd17 	ldw	r2,-12(fp)
8113d7ec:	e0ffff17 	ldw	r3,-4(fp)
8113d7f0:	1885883a 	add	r2,r3,r2
8113d7f4:	e13ffe17 	ldw	r4,-8(fp)
8113d7f8:	e0fffc17 	ldw	r3,-16(fp)
8113d7fc:	20c7883a 	add	r3,r4,r3
8113d800:	18c00003 	ldbu	r3,0(r3)
8113d804:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
8113d808:	e0bffd17 	ldw	r2,-12(fp)
8113d80c:	10800044 	addi	r2,r2,1
8113d810:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
8113d814:	e0bffc17 	ldw	r2,-16(fp)
8113d818:	10800044 	addi	r2,r2,1
8113d81c:	e0bffc15 	stw	r2,-16(fp)
8113d820:	e0bffc17 	ldw	r2,-16(fp)
8113d824:	10800210 	cmplti	r2,r2,8
8113d828:	103fe81e 	bne	r2,zero,8113d7cc <__reset+0xfb11d7cc>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
8113d82c:	e0bffe17 	ldw	r2,-8(fp)
8113d830:	10800203 	ldbu	r2,8(r2)
8113d834:	10803fcc 	andi	r2,r2,255
8113d838:	10800820 	cmpeqi	r2,r2,32
8113d83c:	1000241e 	bne	r2,zero,8113d8d0 <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
8113d840:	e0bffd17 	ldw	r2,-12(fp)
8113d844:	e0ffff17 	ldw	r3,-4(fp)
8113d848:	1885883a 	add	r2,r3,r2
8113d84c:	00c00b84 	movi	r3,46
8113d850:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
8113d854:	e0bffd17 	ldw	r2,-12(fp)
8113d858:	10800044 	addi	r2,r2,1
8113d85c:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
8113d860:	e03ffc15 	stw	zero,-16(fp)
8113d864:	00001706 	br	8113d8c4 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
8113d868:	e0fffe17 	ldw	r3,-8(fp)
8113d86c:	e0bffc17 	ldw	r2,-16(fp)
8113d870:	1885883a 	add	r2,r3,r2
8113d874:	10800204 	addi	r2,r2,8
8113d878:	10800003 	ldbu	r2,0(r2)
8113d87c:	10803fcc 	andi	r2,r2,255
8113d880:	10800820 	cmpeqi	r2,r2,32
8113d884:	10000c1e 	bne	r2,zero,8113d8b8 <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
8113d888:	e0bffd17 	ldw	r2,-12(fp)
8113d88c:	e0ffff17 	ldw	r3,-4(fp)
8113d890:	1885883a 	add	r2,r3,r2
8113d894:	e13ffe17 	ldw	r4,-8(fp)
8113d898:	e0fffc17 	ldw	r3,-16(fp)
8113d89c:	20c7883a 	add	r3,r4,r3
8113d8a0:	18c00204 	addi	r3,r3,8
8113d8a4:	18c00003 	ldbu	r3,0(r3)
8113d8a8:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
8113d8ac:	e0bffd17 	ldw	r2,-12(fp)
8113d8b0:	10800044 	addi	r2,r2,1
8113d8b4:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
8113d8b8:	e0bffc17 	ldw	r2,-16(fp)
8113d8bc:	10800044 	addi	r2,r2,1
8113d8c0:	e0bffc15 	stw	r2,-16(fp)
8113d8c4:	e0bffc17 	ldw	r2,-16(fp)
8113d8c8:	108000d0 	cmplti	r2,r2,3
8113d8cc:	103fe61e 	bne	r2,zero,8113d868 <__reset+0xfb11d868>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
8113d8d0:	e0bffd17 	ldw	r2,-12(fp)
8113d8d4:	e0ffff17 	ldw	r3,-4(fp)
8113d8d8:	1885883a 	add	r2,r3,r2
8113d8dc:	10000005 	stb	zero,0(r2)
}
8113d8e0:	0001883a 	nop
8113d8e4:	e037883a 	mov	sp,fp
8113d8e8:	df000017 	ldw	fp,0(sp)
8113d8ec:	dec00104 	addi	sp,sp,4
8113d8f0:	f800283a 	ret

8113d8f4 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
8113d8f4:	defffc04 	addi	sp,sp,-16
8113d8f8:	de00012e 	bgeu	sp,et,8113d900 <alt_up_sd_card_open_dev+0xc>
8113d8fc:	003b68fa 	trap	3
8113d900:	dfc00315 	stw	ra,12(sp)
8113d904:	df000215 	stw	fp,8(sp)
8113d908:	df000204 	addi	fp,sp,8
8113d90c:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
8113d910:	d1600d04 	addi	r5,gp,-32716
8113d914:	e13fff17 	ldw	r4,-4(fp)
8113d918:	1142db00 	call	81142db0 <alt_find_dev>
8113d91c:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
8113d920:	e0bffe17 	ldw	r2,-8(fp)
8113d924:	10001e26 	beq	r2,zero,8113d9a0 <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
8113d928:	e0bffe17 	ldw	r2,-8(fp)
8113d92c:	10800a17 	ldw	r2,40(r2)
8113d930:	10808d04 	addi	r2,r2,564
8113d934:	d0a0aa15 	stw	r2,-32088(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
8113d938:	e0bffe17 	ldw	r2,-8(fp)
8113d93c:	10800a17 	ldw	r2,40(r2)
8113d940:	10808904 	addi	r2,r2,548
8113d944:	d0a0ab15 	stw	r2,-32084(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
8113d948:	e0bffe17 	ldw	r2,-8(fp)
8113d94c:	10800a17 	ldw	r2,40(r2)
8113d950:	10808404 	addi	r2,r2,528
8113d954:	d0a0ac15 	stw	r2,-32080(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
8113d958:	e0bffe17 	ldw	r2,-8(fp)
8113d95c:	10800a17 	ldw	r2,40(r2)
8113d960:	10808c04 	addi	r2,r2,560
8113d964:	d0a0ad15 	stw	r2,-32076(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
8113d968:	e0bffe17 	ldw	r2,-8(fp)
8113d96c:	10800a17 	ldw	r2,40(r2)
8113d970:	10808b04 	addi	r2,r2,556
8113d974:	d0a0ae15 	stw	r2,-32072(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
8113d978:	e0bffe17 	ldw	r2,-8(fp)
8113d97c:	10800a17 	ldw	r2,40(r2)
8113d980:	d0a0af15 	stw	r2,-32068(gp)
		device_pointer = dev;
8113d984:	e0bffe17 	ldw	r2,-8(fp)
8113d988:	d0a0b215 	stw	r2,-32056(gp)
		initialized = false;
8113d98c:	d020a815 	stw	zero,-32096(gp)
		is_sd_card_formated_as_FAT16 = false;
8113d990:	d020a915 	stw	zero,-32092(gp)
		search_data.valid = false;
8113d994:	00a045b4 	movhi	r2,33046
8113d998:	10850304 	addi	r2,r2,5132
8113d99c:	10000415 	stw	zero,16(r2)
	}
	return dev;
8113d9a0:	e0bffe17 	ldw	r2,-8(fp)
}
8113d9a4:	e037883a 	mov	sp,fp
8113d9a8:	dfc00117 	ldw	ra,4(sp)
8113d9ac:	df000017 	ldw	fp,0(sp)
8113d9b0:	dec00204 	addi	sp,sp,8
8113d9b4:	f800283a 	ret

8113d9b8 <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
8113d9b8:	defffd04 	addi	sp,sp,-12
8113d9bc:	de00012e 	bgeu	sp,et,8113d9c4 <alt_up_sd_card_is_Present+0xc>
8113d9c0:	003b68fa 	trap	3
8113d9c4:	df000215 	stw	fp,8(sp)
8113d9c8:	df000204 	addi	fp,sp,8
    bool result = false;
8113d9cc:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
8113d9d0:	d0a0b217 	ldw	r2,-32056(gp)
8113d9d4:	10000826 	beq	r2,zero,8113d9f8 <alt_up_sd_card_is_Present+0x40>
8113d9d8:	d0a0aa17 	ldw	r2,-32088(gp)
8113d9dc:	1080002b 	ldhuio	r2,0(r2)
8113d9e0:	10bfffcc 	andi	r2,r2,65535
8113d9e4:	1080008c 	andi	r2,r2,2
8113d9e8:	10000326 	beq	r2,zero,8113d9f8 <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
8113d9ec:	00800044 	movi	r2,1
8113d9f0:	e0bffe15 	stw	r2,-8(fp)
8113d9f4:	00001e06 	br	8113da70 <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
8113d9f8:	d0a0a817 	ldw	r2,-32096(gp)
8113d9fc:	10800058 	cmpnei	r2,r2,1
8113da00:	10001b1e 	bne	r2,zero,8113da70 <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
8113da04:	d020a815 	stw	zero,-32096(gp)
		search_data.valid = false;
8113da08:	00a045b4 	movhi	r2,33046
8113da0c:	10850304 	addi	r2,r2,5132
8113da10:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
8113da14:	d020a915 	stw	zero,-32092(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
8113da18:	e03fff15 	stw	zero,-4(fp)
8113da1c:	00001106 	br	8113da64 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
8113da20:	00a045b4 	movhi	r2,33046
8113da24:	10851d04 	addi	r2,r2,5236
8113da28:	e0ffff17 	ldw	r3,-4(fp)
8113da2c:	180691ba 	slli	r3,r3,6
8113da30:	10c5883a 	add	r2,r2,r3
8113da34:	10800f04 	addi	r2,r2,60
8113da38:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
8113da3c:	00a045b4 	movhi	r2,33046
8113da40:	10851d04 	addi	r2,r2,5236
8113da44:	e0ffff17 	ldw	r3,-4(fp)
8113da48:	180691ba 	slli	r3,r3,6
8113da4c:	10c5883a 	add	r2,r2,r3
8113da50:	10800e04 	addi	r2,r2,56
8113da54:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
8113da58:	e0bfff17 	ldw	r2,-4(fp)
8113da5c:	10800044 	addi	r2,r2,1
8113da60:	e0bfff15 	stw	r2,-4(fp)
8113da64:	e0bfff17 	ldw	r2,-4(fp)
8113da68:	10800510 	cmplti	r2,r2,20
8113da6c:	103fec1e 	bne	r2,zero,8113da20 <__reset+0xfb11da20>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
8113da70:	e0bffe17 	ldw	r2,-8(fp)
}
8113da74:	e037883a 	mov	sp,fp
8113da78:	df000017 	ldw	fp,0(sp)
8113da7c:	dec00104 	addi	sp,sp,4
8113da80:	f800283a 	ret

8113da84 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
8113da84:	defffd04 	addi	sp,sp,-12
8113da88:	de00012e 	bgeu	sp,et,8113da90 <alt_up_sd_card_is_FAT16+0xc>
8113da8c:	003b68fa 	trap	3
8113da90:	dfc00215 	stw	ra,8(sp)
8113da94:	df000115 	stw	fp,4(sp)
8113da98:	df000104 	addi	fp,sp,4
	bool result = false;
8113da9c:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
8113daa0:	113d9b80 	call	8113d9b8 <alt_up_sd_card_is_Present>
8113daa4:	10000c26 	beq	r2,zero,8113dad8 <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
8113daa8:	d0a0a817 	ldw	r2,-32096(gp)
8113daac:	1000071e 	bne	r2,zero,8113dacc <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
8113dab0:	113bcb00 	call	8113bcb0 <Look_for_FAT16>
8113dab4:	d0a0a915 	stw	r2,-32092(gp)
			initialized = is_sd_card_formated_as_FAT16;
8113dab8:	d0a0a917 	ldw	r2,-32092(gp)
8113dabc:	d0a0a815 	stw	r2,-32096(gp)
			search_data.valid = false;
8113dac0:	00a045b4 	movhi	r2,33046
8113dac4:	10850304 	addi	r2,r2,5132
8113dac8:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
8113dacc:	d0a0a917 	ldw	r2,-32092(gp)
8113dad0:	e0bfff15 	stw	r2,-4(fp)
8113dad4:	00000206 	br	8113dae0 <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
8113dad8:	d020a815 	stw	zero,-32096(gp)
		is_sd_card_formated_as_FAT16 = false;
8113dadc:	d020a915 	stw	zero,-32092(gp)
	}

	return result;
8113dae0:	e0bfff17 	ldw	r2,-4(fp)
}
8113dae4:	e037883a 	mov	sp,fp
8113dae8:	dfc00117 	ldw	ra,4(sp)
8113daec:	df000017 	ldw	fp,0(sp)
8113daf0:	dec00204 	addi	sp,sp,8
8113daf4:	f800283a 	ret

8113daf8 <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
8113daf8:	deffea04 	addi	sp,sp,-88
8113dafc:	de00012e 	bgeu	sp,et,8113db04 <alt_up_sd_card_find_first+0xc>
8113db00:	003b68fa 	trap	3
8113db04:	dfc01515 	stw	ra,84(sp)
8113db08:	df001415 	stw	fp,80(sp)
8113db0c:	df001404 	addi	fp,sp,80
8113db10:	e13ffe15 	stw	r4,-8(fp)
8113db14:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
8113db18:	00800084 	movi	r2,2
8113db1c:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113db20:	113d9b80 	call	8113d9b8 <alt_up_sd_card_is_Present>
8113db24:	10002426 	beq	r2,zero,8113dbb8 <alt_up_sd_card_find_first+0xc0>
8113db28:	d0a0a917 	ldw	r2,-32092(gp)
8113db2c:	10002226 	beq	r2,zero,8113dbb8 <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
8113db30:	e0ffee04 	addi	r3,fp,-72
8113db34:	e0bfed04 	addi	r2,fp,-76
8113db38:	180d883a 	mov	r6,r3
8113db3c:	100b883a 	mov	r5,r2
8113db40:	e13ffe17 	ldw	r4,-8(fp)
8113db44:	113c4480 	call	8113c448 <get_home_directory_cluster_for_file>
8113db48:	10001926 	beq	r2,zero,8113dbb0 <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
8113db4c:	e0bfed17 	ldw	r2,-76(fp)
8113db50:	1007883a 	mov	r3,r2
8113db54:	00a045b4 	movhi	r2,33046
8113db58:	10850304 	addi	r2,r2,5132
8113db5c:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
8113db60:	e0bfed17 	ldw	r2,-76(fp)
8113db64:	1007883a 	mov	r3,r2
8113db68:	00a045b4 	movhi	r2,33046
8113db6c:	10850304 	addi	r2,r2,5132
8113db70:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
8113db74:	00a045b4 	movhi	r2,33046
8113db78:	10850304 	addi	r2,r2,5132
8113db7c:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
8113db80:	00a045b4 	movhi	r2,33046
8113db84:	10850304 	addi	r2,r2,5132
8113db88:	00ffffc4 	movi	r3,-1
8113db8c:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
8113db90:	00a045b4 	movhi	r2,33046
8113db94:	10850304 	addi	r2,r2,5132
8113db98:	00c00044 	movi	r3,1
8113db9c:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
8113dba0:	e13fff17 	ldw	r4,-4(fp)
8113dba4:	113dbd00 	call	8113dbd0 <alt_up_sd_card_find_next>
8113dba8:	e0bfec0d 	sth	r2,-80(fp)
8113dbac:	00000206 	br	8113dbb8 <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
8113dbb0:	00800044 	movi	r2,1
8113dbb4:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
8113dbb8:	e0bfec0b 	ldhu	r2,-80(fp)
}
8113dbbc:	e037883a 	mov	sp,fp
8113dbc0:	dfc00117 	ldw	ra,4(sp)
8113dbc4:	df000017 	ldw	fp,0(sp)
8113dbc8:	dec00204 	addi	sp,sp,8
8113dbcc:	f800283a 	ret

8113dbd0 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
8113dbd0:	deffe404 	addi	sp,sp,-112
8113dbd4:	de00012e 	bgeu	sp,et,8113dbdc <alt_up_sd_card_find_next+0xc>
8113dbd8:	003b68fa 	trap	3
8113dbdc:	dfc01b15 	stw	ra,108(sp)
8113dbe0:	df001a15 	stw	fp,104(sp)
8113dbe4:	df001a04 	addi	fp,sp,104
8113dbe8:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
8113dbec:	00800084 	movi	r2,2
8113dbf0:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113dbf4:	113d9b80 	call	8113d9b8 <alt_up_sd_card_is_Present>
8113dbf8:	1000df26 	beq	r2,zero,8113df78 <alt_up_sd_card_find_next+0x3a8>
8113dbfc:	d0a0a917 	ldw	r2,-32092(gp)
8113dc00:	1000dd26 	beq	r2,zero,8113df78 <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
8113dc04:	00a045b4 	movhi	r2,33046
8113dc08:	10850304 	addi	r2,r2,5132
8113dc0c:	10800417 	ldw	r2,16(r2)
8113dc10:	1000d726 	beq	r2,zero,8113df70 <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
8113dc14:	00a045b4 	movhi	r2,33046
8113dc18:	10850304 	addi	r2,r2,5132
8113dc1c:	10800117 	ldw	r2,4(r2)
8113dc20:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
8113dc24:	e0bfe717 	ldw	r2,-100(fp)
8113dc28:	1000561e 	bne	r2,zero,8113dd84 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113dc2c:	00a045b4 	movhi	r2,33046
8113dc30:	10850804 	addi	r2,r2,5152
8113dc34:	1080050b 	ldhu	r2,20(r2)
8113dc38:	10bfffcc 	andi	r2,r2,65535
8113dc3c:	1006917a 	slli	r3,r2,5
8113dc40:	00a045b4 	movhi	r2,33046
8113dc44:	10850804 	addi	r2,r2,5152
8113dc48:	1080030b 	ldhu	r2,12(r2)
8113dc4c:	10bfffcc 	andi	r2,r2,65535
8113dc50:	1885283a 	div	r2,r3,r2
8113dc54:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
8113dc58:	00a045b4 	movhi	r2,33046
8113dc5c:	10850304 	addi	r2,r2,5132
8113dc60:	10800217 	ldw	r2,8(r2)
8113dc64:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
8113dc68:	00a045b4 	movhi	r2,33046
8113dc6c:	10850304 	addi	r2,r2,5132
8113dc70:	1080030b 	ldhu	r2,12(r2)
8113dc74:	10bfffcc 	andi	r2,r2,65535
8113dc78:	10a0001c 	xori	r2,r2,32768
8113dc7c:	10a00004 	addi	r2,r2,-32768
8113dc80:	10800044 	addi	r2,r2,1
8113dc84:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
8113dc88:	00003606 	br	8113dd64 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8113dc8c:	00a045b4 	movhi	r2,33046
8113dc90:	10850804 	addi	r2,r2,5152
8113dc94:	10c01317 	ldw	r3,76(r2)
8113dc98:	e0bfe817 	ldw	r2,-96(fp)
8113dc9c:	1885883a 	add	r2,r3,r2
8113dca0:	1007883a 	mov	r3,r2
8113dca4:	d0a0b017 	ldw	r2,-32064(gp)
8113dca8:	100b883a 	mov	r5,r2
8113dcac:	1809883a 	mov	r4,r3
8113dcb0:	113ace00 	call	8113ace0 <Read_Sector_Data>
8113dcb4:	10002f26 	beq	r2,zero,8113dd74 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
8113dcb8:	00002306 	br	8113dd48 <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
8113dcbc:	e0bfe917 	ldw	r2,-92(fp)
8113dcc0:	1004917a 	slli	r2,r2,5
8113dcc4:	e13fe817 	ldw	r4,-96(fp)
8113dcc8:	e0ffef04 	addi	r3,fp,-68
8113dccc:	200f883a 	mov	r7,r4
8113dcd0:	000d883a 	mov	r6,zero
8113dcd4:	180b883a 	mov	r5,r3
8113dcd8:	1009883a 	mov	r4,r2
8113dcdc:	113b1100 	call	8113b110 <Read_File_Record_At_Offset>
8113dce0:	10001626 	beq	r2,zero,8113dd3c <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
8113dce4:	e0bfef03 	ldbu	r2,-68(fp)
8113dce8:	10803fcc 	andi	r2,r2,255
8113dcec:	10001326 	beq	r2,zero,8113dd3c <alt_up_sd_card_find_next+0x16c>
8113dcf0:	e0bfef03 	ldbu	r2,-68(fp)
8113dcf4:	10803fcc 	andi	r2,r2,255
8113dcf8:	10803960 	cmpeqi	r2,r2,229
8113dcfc:	10000f1e 	bne	r2,zero,8113dd3c <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
8113dd00:	e0bfe917 	ldw	r2,-92(fp)
8113dd04:	1007883a 	mov	r3,r2
8113dd08:	00a045b4 	movhi	r2,33046
8113dd0c:	10850304 	addi	r2,r2,5132
8113dd10:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
8113dd14:	e0ffe817 	ldw	r3,-96(fp)
8113dd18:	00a045b4 	movhi	r2,33046
8113dd1c:	10850304 	addi	r2,r2,5132
8113dd20:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
8113dd24:	e0bfef04 	addi	r2,fp,-68
8113dd28:	e17fff17 	ldw	r5,-4(fp)
8113dd2c:	1009883a 	mov	r4,r2
8113dd30:	113d7a40 	call	8113d7a4 <copy_file_record_name_to_string>
									return 0;
8113dd34:	0005883a 	mov	r2,zero
8113dd38:	00009006 	br	8113df7c <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
8113dd3c:	e0bfe917 	ldw	r2,-92(fp)
8113dd40:	10800044 	addi	r2,r2,1
8113dd44:	e0bfe915 	stw	r2,-92(fp)
8113dd48:	e0bfe917 	ldw	r2,-92(fp)
8113dd4c:	10800410 	cmplti	r2,r2,16
8113dd50:	103fda1e 	bne	r2,zero,8113dcbc <__reset+0xfb11dcbc>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
8113dd54:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
8113dd58:	e0bfe817 	ldw	r2,-96(fp)
8113dd5c:	10800044 	addi	r2,r2,1
8113dd60:	e0bfe815 	stw	r2,-96(fp)
8113dd64:	e0ffe817 	ldw	r3,-96(fp)
8113dd68:	e0bfec17 	ldw	r2,-80(fp)
8113dd6c:	18bfc716 	blt	r3,r2,8113dc8c <__reset+0xfb11dc8c>
8113dd70:	00000106 	br	8113dd78 <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
8113dd74:	0001883a 	nop
					}
				}
				result = -1;
8113dd78:	00bfffc4 	movi	r2,-1
8113dd7c:	e0bfe60d 	sth	r2,-104(fp)
8113dd80:	00007d06 	br	8113df78 <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
8113dd84:	00a045b4 	movhi	r2,33046
8113dd88:	10850304 	addi	r2,r2,5132
8113dd8c:	1080030b 	ldhu	r2,12(r2)
8113dd90:	10bfffcc 	andi	r2,r2,65535
8113dd94:	10a0001c 	xori	r2,r2,32768
8113dd98:	10a00004 	addi	r2,r2,-32768
8113dd9c:	10800044 	addi	r2,r2,1
8113dda0:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113dda4:	e0bfe717 	ldw	r2,-100(fp)
8113dda8:	10ffff84 	addi	r3,r2,-2
8113ddac:	00a045b4 	movhi	r2,33046
8113ddb0:	10850804 	addi	r2,r2,5152
8113ddb4:	10800383 	ldbu	r2,14(r2)
8113ddb8:	10803fcc 	andi	r2,r2,255
8113ddbc:	1885383a 	mul	r2,r3,r2
8113ddc0:	1007883a 	mov	r3,r2
8113ddc4:	00a045b4 	movhi	r2,33046
8113ddc8:	10850804 	addi	r2,r2,5152
8113ddcc:	10801417 	ldw	r2,80(r2)
8113ddd0:	1885883a 	add	r2,r3,r2
8113ddd4:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
8113ddd8:	00a045b4 	movhi	r2,33046
8113dddc:	10850304 	addi	r2,r2,5132
8113dde0:	10800217 	ldw	r2,8(r2)
8113dde4:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113dde8:	00003806 	br	8113decc <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113ddec:	e0ffeb17 	ldw	r3,-84(fp)
8113ddf0:	e0bfed17 	ldw	r2,-76(fp)
8113ddf4:	1885883a 	add	r2,r3,r2
8113ddf8:	d0e0b017 	ldw	r3,-32064(gp)
8113ddfc:	180b883a 	mov	r5,r3
8113de00:	1009883a 	mov	r4,r2
8113de04:	113ace00 	call	8113ace0 <Read_Sector_Data>
8113de08:	10003726 	beq	r2,zero,8113dee8 <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
8113de0c:	00002806 	br	8113deb0 <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
8113de10:	e0bfea17 	ldw	r2,-88(fp)
8113de14:	1004917a 	slli	r2,r2,5
8113de18:	e13fe717 	ldw	r4,-100(fp)
8113de1c:	e17feb17 	ldw	r5,-84(fp)
8113de20:	e0ffef04 	addi	r3,fp,-68
8113de24:	280f883a 	mov	r7,r5
8113de28:	200d883a 	mov	r6,r4
8113de2c:	180b883a 	mov	r5,r3
8113de30:	1009883a 	mov	r4,r2
8113de34:	113b1100 	call	8113b110 <Read_File_Record_At_Offset>
8113de38:	10001a26 	beq	r2,zero,8113dea4 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
8113de3c:	e0bfef03 	ldbu	r2,-68(fp)
8113de40:	10803fcc 	andi	r2,r2,255
8113de44:	10001726 	beq	r2,zero,8113dea4 <alt_up_sd_card_find_next+0x2d4>
8113de48:	e0bfef03 	ldbu	r2,-68(fp)
8113de4c:	10803fcc 	andi	r2,r2,255
8113de50:	10803960 	cmpeqi	r2,r2,229
8113de54:	1000131e 	bne	r2,zero,8113dea4 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
8113de58:	e0ffe717 	ldw	r3,-100(fp)
8113de5c:	00a045b4 	movhi	r2,33046
8113de60:	10850304 	addi	r2,r2,5132
8113de64:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
8113de68:	e0bfea17 	ldw	r2,-88(fp)
8113de6c:	1007883a 	mov	r3,r2
8113de70:	00a045b4 	movhi	r2,33046
8113de74:	10850304 	addi	r2,r2,5132
8113de78:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
8113de7c:	e0ffeb17 	ldw	r3,-84(fp)
8113de80:	00a045b4 	movhi	r2,33046
8113de84:	10850304 	addi	r2,r2,5132
8113de88:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
8113de8c:	e0bfef04 	addi	r2,fp,-68
8113de90:	e17fff17 	ldw	r5,-4(fp)
8113de94:	1009883a 	mov	r4,r2
8113de98:	113d7a40 	call	8113d7a4 <copy_file_record_name_to_string>
										return 0;
8113de9c:	0005883a 	mov	r2,zero
8113dea0:	00003606 	br	8113df7c <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
8113dea4:	e0bfea17 	ldw	r2,-88(fp)
8113dea8:	10800044 	addi	r2,r2,1
8113deac:	e0bfea15 	stw	r2,-88(fp)
8113deb0:	e0bfea17 	ldw	r2,-88(fp)
8113deb4:	10800410 	cmplti	r2,r2,16
8113deb8:	103fd51e 	bne	r2,zero,8113de10 <__reset+0xfb11de10>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
8113debc:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113dec0:	e0bfeb17 	ldw	r2,-84(fp)
8113dec4:	10800044 	addi	r2,r2,1
8113dec8:	e0bfeb15 	stw	r2,-84(fp)
8113decc:	00a045b4 	movhi	r2,33046
8113ded0:	10850804 	addi	r2,r2,5152
8113ded4:	10800383 	ldbu	r2,14(r2)
8113ded8:	10803fcc 	andi	r2,r2,255
8113dedc:	e0ffeb17 	ldw	r3,-84(fp)
8113dee0:	18bfc216 	blt	r3,r2,8113ddec <__reset+0xfb11ddec>
8113dee4:	00000106 	br	8113deec <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
8113dee8:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
8113deec:	00a045b4 	movhi	r2,33046
8113def0:	10850804 	addi	r2,r2,5152
8113def4:	10800383 	ldbu	r2,14(r2)
8113def8:	10803fcc 	andi	r2,r2,255
8113defc:	e0ffeb17 	ldw	r3,-84(fp)
8113df00:	18801716 	blt	r3,r2,8113df60 <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
8113df04:	e0bfe717 	ldw	r2,-100(fp)
8113df08:	e0ffee04 	addi	r3,fp,-72
8113df0c:	180b883a 	mov	r5,r3
8113df10:	1009883a 	mov	r4,r2
8113df14:	113adc00 	call	8113adc0 <get_cluster_flag>
8113df18:	10000f26 	beq	r2,zero,8113df58 <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8113df1c:	e0bfee0b 	ldhu	r2,-72(fp)
8113df20:	10bfffcc 	andi	r2,r2,65535
8113df24:	10fffe0c 	andi	r3,r2,65528
8113df28:	00bffe14 	movui	r2,65528
8113df2c:	1880051e 	bne	r3,r2,8113df44 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
8113df30:	00bfffc4 	movi	r2,-1
8113df34:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
8113df38:	00a045b4 	movhi	r2,33046
8113df3c:	10850304 	addi	r2,r2,5132
8113df40:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
8113df44:	e0bfee0b 	ldhu	r2,-72(fp)
8113df48:	10bfffcc 	andi	r2,r2,65535
8113df4c:	10bffe0c 	andi	r2,r2,65528
8113df50:	e0bfe715 	stw	r2,-100(fp)
8113df54:	00000206 	br	8113df60 <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
8113df58:	00bfffc4 	movi	r2,-1
8113df5c:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
8113df60:	e0bfe717 	ldw	r2,-100(fp)
8113df64:	00fffdd4 	movui	r3,65527
8113df68:	18bf8e0e 	bge	r3,r2,8113dda4 <__reset+0xfb11dda4>
8113df6c:	00000206 	br	8113df78 <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
8113df70:	008000c4 	movi	r2,3
8113df74:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
8113df78:	e0bfe60b 	ldhu	r2,-104(fp)
}
8113df7c:	e037883a 	mov	sp,fp
8113df80:	dfc00117 	ldw	ra,4(sp)
8113df84:	df000017 	ldw	fp,0(sp)
8113df88:	dec00204 	addi	sp,sp,8
8113df8c:	f800283a 	ret

8113df90 <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
8113df90:	deffe904 	addi	sp,sp,-92
8113df94:	de00012e 	bgeu	sp,et,8113df9c <alt_up_sd_card_fopen+0xc>
8113df98:	003b68fa 	trap	3
8113df9c:	dfc01615 	stw	ra,88(sp)
8113dfa0:	df001515 	stw	fp,84(sp)
8113dfa4:	df001504 	addi	fp,sp,84
8113dfa8:	e13ffe15 	stw	r4,-8(fp)
8113dfac:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
8113dfb0:	00bfffc4 	movi	r2,-1
8113dfb4:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113dfb8:	113d9b80 	call	8113d9b8 <alt_up_sd_card_is_Present>
8113dfbc:	1000cf26 	beq	r2,zero,8113e2fc <alt_up_sd_card_fopen+0x36c>
8113dfc0:	d0a0a917 	ldw	r2,-32092(gp)
8113dfc4:	1000cd26 	beq	r2,zero,8113e2fc <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
8113dfc8:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
8113dfcc:	e13ffe17 	ldw	r4,-8(fp)
8113dfd0:	113bda40 	call	8113bda4 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
8113dfd4:	e13ffe17 	ldw	r4,-8(fp)
8113dfd8:	113be700 	call	8113be70 <check_file_name_for_FAT16_compliance>
8113dfdc:	1000c726 	beq	r2,zero,8113e2fc <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
8113dfe0:	e0ffee04 	addi	r3,fp,-72
8113dfe4:	e0bfed04 	addi	r2,fp,-76
8113dfe8:	180d883a 	mov	r6,r3
8113dfec:	100b883a 	mov	r5,r2
8113dff0:	e13ffe17 	ldw	r4,-8(fp)
8113dff4:	113c4480 	call	8113c448 <get_home_directory_cluster_for_file>
8113dff8:	1000021e 	bne	r2,zero,8113e004 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
8113dffc:	e0bfeb0b 	ldhu	r2,-84(fp)
8113e000:	0000bf06 	br	8113e300 <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
8113e004:	e03fec15 	stw	zero,-80(fp)
8113e008:	00000e06 	br	8113e044 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
8113e00c:	00a045b4 	movhi	r2,33046
8113e010:	10851d04 	addi	r2,r2,5236
8113e014:	e0ffec17 	ldw	r3,-80(fp)
8113e018:	180691ba 	slli	r3,r3,6
8113e01c:	10c5883a 	add	r2,r2,r3
8113e020:	10800f04 	addi	r2,r2,60
8113e024:	10800017 	ldw	r2,0(r2)
8113e028:	1000031e 	bne	r2,zero,8113e038 <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
8113e02c:	e0bfec17 	ldw	r2,-80(fp)
8113e030:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
8113e034:	00000606 	br	8113e050 <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
8113e038:	e0bfec17 	ldw	r2,-80(fp)
8113e03c:	10800044 	addi	r2,r2,1
8113e040:	e0bfec15 	stw	r2,-80(fp)
8113e044:	e0bfec17 	ldw	r2,-80(fp)
8113e048:	10800510 	cmplti	r2,r2,20
8113e04c:	103fef1e 	bne	r2,zero,8113e00c <__reset+0xfb11e00c>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
8113e050:	e0bfeb0f 	ldh	r2,-84(fp)
8113e054:	1000a916 	blt	r2,zero,8113e2fc <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
8113e058:	e0bfed17 	ldw	r2,-76(fp)
8113e05c:	1009883a 	mov	r4,r2
8113e060:	e0bfeb0f 	ldh	r2,-84(fp)
8113e064:	100691ba 	slli	r3,r2,6
8113e068:	00a045b4 	movhi	r2,33046
8113e06c:	10851d04 	addi	r2,r2,5236
8113e070:	1885883a 	add	r2,r3,r2
8113e074:	100d883a 	mov	r6,r2
8113e078:	e17ffe17 	ldw	r5,-8(fp)
8113e07c:	113c9880 	call	8113c988 <find_file_in_directory>
8113e080:	10007b26 	beq	r2,zero,8113e270 <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
8113e084:	e0bfff17 	ldw	r2,-4(fp)
8113e088:	10000226 	beq	r2,zero,8113e094 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
8113e08c:	00bfffc4 	movi	r2,-1
8113e090:	00009b06 	br	8113e300 <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
8113e094:	e13feb0f 	ldh	r4,-84(fp)
8113e098:	e0ffeb0f 	ldh	r3,-84(fp)
8113e09c:	00a045b4 	movhi	r2,33046
8113e0a0:	10851d04 	addi	r2,r2,5236
8113e0a4:	180691ba 	slli	r3,r3,6
8113e0a8:	10c5883a 	add	r2,r2,r3
8113e0ac:	10800584 	addi	r2,r2,22
8113e0b0:	1080000b 	ldhu	r2,0(r2)
8113e0b4:	10ffffcc 	andi	r3,r2,65535
8113e0b8:	00a045b4 	movhi	r2,33046
8113e0bc:	10851d04 	addi	r2,r2,5236
8113e0c0:	200891ba 	slli	r4,r4,6
8113e0c4:	1105883a 	add	r2,r2,r4
8113e0c8:	10800704 	addi	r2,r2,28
8113e0cc:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
8113e0d0:	e0ffeb0f 	ldh	r3,-84(fp)
8113e0d4:	00a045b4 	movhi	r2,33046
8113e0d8:	10851d04 	addi	r2,r2,5236
8113e0dc:	180691ba 	slli	r3,r3,6
8113e0e0:	10c5883a 	add	r2,r2,r3
8113e0e4:	10800804 	addi	r2,r2,32
8113e0e8:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
8113e0ec:	e0ffeb0f 	ldh	r3,-84(fp)
8113e0f0:	00a045b4 	movhi	r2,33046
8113e0f4:	10851d04 	addi	r2,r2,5236
8113e0f8:	180691ba 	slli	r3,r3,6
8113e0fc:	10c5883a 	add	r2,r2,r3
8113e100:	10800904 	addi	r2,r2,36
8113e104:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
8113e108:	e0ffeb0f 	ldh	r3,-84(fp)
8113e10c:	00a045b4 	movhi	r2,33046
8113e110:	10851d04 	addi	r2,r2,5236
8113e114:	180691ba 	slli	r3,r3,6
8113e118:	10c5883a 	add	r2,r2,r3
8113e11c:	10800f04 	addi	r2,r2,60
8113e120:	00c00044 	movi	r3,1
8113e124:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
8113e128:	e0ffeb0f 	ldh	r3,-84(fp)
8113e12c:	00a045b4 	movhi	r2,33046
8113e130:	10851d04 	addi	r2,r2,5236
8113e134:	180691ba 	slli	r3,r3,6
8113e138:	10c5883a 	add	r2,r2,r3
8113e13c:	10800e04 	addi	r2,r2,56
8113e140:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
8113e144:	e03fec15 	stw	zero,-80(fp)
8113e148:	00004506 	br	8113e260 <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
8113e14c:	e0ffeb0f 	ldh	r3,-84(fp)
8113e150:	e0bfec17 	ldw	r2,-80(fp)
8113e154:	18803f26 	beq	r3,r2,8113e254 <alt_up_sd_card_fopen+0x2c4>
8113e158:	00a045b4 	movhi	r2,33046
8113e15c:	10851d04 	addi	r2,r2,5236
8113e160:	e0ffec17 	ldw	r3,-80(fp)
8113e164:	180691ba 	slli	r3,r3,6
8113e168:	10c5883a 	add	r2,r2,r3
8113e16c:	10800f04 	addi	r2,r2,60
8113e170:	10800017 	ldw	r2,0(r2)
8113e174:	10800058 	cmpnei	r2,r2,1
8113e178:	1000361e 	bne	r2,zero,8113e254 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
8113e17c:	e0ffeb0f 	ldh	r3,-84(fp)
8113e180:	00a045b4 	movhi	r2,33046
8113e184:	10851d04 	addi	r2,r2,5236
8113e188:	180691ba 	slli	r3,r3,6
8113e18c:	10c5883a 	add	r2,r2,r3
8113e190:	10800a04 	addi	r2,r2,40
8113e194:	10c00017 	ldw	r3,0(r2)
8113e198:	00a045b4 	movhi	r2,33046
8113e19c:	10851d04 	addi	r2,r2,5236
8113e1a0:	e13fec17 	ldw	r4,-80(fp)
8113e1a4:	200891ba 	slli	r4,r4,6
8113e1a8:	1105883a 	add	r2,r2,r4
8113e1ac:	10800a04 	addi	r2,r2,40
8113e1b0:	10800017 	ldw	r2,0(r2)
8113e1b4:	1880271e 	bne	r3,r2,8113e254 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
8113e1b8:	e0ffeb0f 	ldh	r3,-84(fp)
8113e1bc:	00a045b4 	movhi	r2,33046
8113e1c0:	10851d04 	addi	r2,r2,5236
8113e1c4:	180691ba 	slli	r3,r3,6
8113e1c8:	10c5883a 	add	r2,r2,r3
8113e1cc:	10800b04 	addi	r2,r2,44
8113e1d0:	10c00017 	ldw	r3,0(r2)
8113e1d4:	00a045b4 	movhi	r2,33046
8113e1d8:	10851d04 	addi	r2,r2,5236
8113e1dc:	e13fec17 	ldw	r4,-80(fp)
8113e1e0:	200891ba 	slli	r4,r4,6
8113e1e4:	1105883a 	add	r2,r2,r4
8113e1e8:	10800b04 	addi	r2,r2,44
8113e1ec:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
8113e1f0:	1880181e 	bne	r3,r2,8113e254 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
8113e1f4:	e0ffeb0f 	ldh	r3,-84(fp)
8113e1f8:	00a045b4 	movhi	r2,33046
8113e1fc:	10851d04 	addi	r2,r2,5236
8113e200:	180691ba 	slli	r3,r3,6
8113e204:	10c5883a 	add	r2,r2,r3
8113e208:	10800c04 	addi	r2,r2,48
8113e20c:	1100000b 	ldhu	r4,0(r2)
8113e210:	00a045b4 	movhi	r2,33046
8113e214:	10851d04 	addi	r2,r2,5236
8113e218:	e0ffec17 	ldw	r3,-80(fp)
8113e21c:	180691ba 	slli	r3,r3,6
8113e220:	10c5883a 	add	r2,r2,r3
8113e224:	10800c04 	addi	r2,r2,48
8113e228:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
8113e22c:	20ffffcc 	andi	r3,r4,65535
8113e230:	18e0001c 	xori	r3,r3,32768
8113e234:	18e00004 	addi	r3,r3,-32768
8113e238:	10bfffcc 	andi	r2,r2,65535
8113e23c:	10a0001c 	xori	r2,r2,32768
8113e240:	10a00004 	addi	r2,r2,-32768
8113e244:	1880031e 	bne	r3,r2,8113e254 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
8113e248:	00bfff84 	movi	r2,-2
8113e24c:	e0bfeb0d 	sth	r2,-84(fp)
								break;
8113e250:	00002a06 	br	8113e2fc <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
8113e254:	e0bfec17 	ldw	r2,-80(fp)
8113e258:	10800044 	addi	r2,r2,1
8113e25c:	e0bfec15 	stw	r2,-80(fp)
8113e260:	e0bfec17 	ldw	r2,-80(fp)
8113e264:	10800510 	cmplti	r2,r2,20
8113e268:	103fb81e 	bne	r2,zero,8113e14c <__reset+0xfb11e14c>
8113e26c:	00002306 	br	8113e2fc <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
8113e270:	e0bfff17 	ldw	r2,-4(fp)
8113e274:	10001f26 	beq	r2,zero,8113e2f4 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
8113e278:	e0bfeb0f 	ldh	r2,-84(fp)
8113e27c:	100691ba 	slli	r3,r2,6
8113e280:	00a045b4 	movhi	r2,33046
8113e284:	10851d04 	addi	r2,r2,5236
8113e288:	1885883a 	add	r2,r3,r2
8113e28c:	e0ffee04 	addi	r3,fp,-72
8113e290:	180d883a 	mov	r6,r3
8113e294:	100b883a 	mov	r5,r2
8113e298:	e13ffe17 	ldw	r4,-8(fp)
8113e29c:	113d4d40 	call	8113d4d4 <create_file>
8113e2a0:	10001126 	beq	r2,zero,8113e2e8 <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
8113e2a4:	e0ffeb0f 	ldh	r3,-84(fp)
8113e2a8:	00a045b4 	movhi	r2,33046
8113e2ac:	10851d04 	addi	r2,r2,5236
8113e2b0:	180691ba 	slli	r3,r3,6
8113e2b4:	10c5883a 	add	r2,r2,r3
8113e2b8:	10800f04 	addi	r2,r2,60
8113e2bc:	00c00044 	movi	r3,1
8113e2c0:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
8113e2c4:	e0ffeb0f 	ldh	r3,-84(fp)
8113e2c8:	00a045b4 	movhi	r2,33046
8113e2cc:	10851d04 	addi	r2,r2,5236
8113e2d0:	180691ba 	slli	r3,r3,6
8113e2d4:	10c5883a 	add	r2,r2,r3
8113e2d8:	10800e04 	addi	r2,r2,56
8113e2dc:	00c00044 	movi	r3,1
8113e2e0:	10c00015 	stw	r3,0(r2)
8113e2e4:	00000506 	br	8113e2fc <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
8113e2e8:	00bfffc4 	movi	r2,-1
8113e2ec:	e0bfeb0d 	sth	r2,-84(fp)
8113e2f0:	00000206 	br	8113e2fc <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
8113e2f4:	00bfffc4 	movi	r2,-1
8113e2f8:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
8113e2fc:	e0bfeb0b 	ldhu	r2,-84(fp)
}
8113e300:	e037883a 	mov	sp,fp
8113e304:	dfc00117 	ldw	ra,4(sp)
8113e308:	df000017 	ldw	fp,0(sp)
8113e30c:	dec00204 	addi	sp,sp,8
8113e310:	f800283a 	ret

8113e314 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
8113e314:	defffd04 	addi	sp,sp,-12
8113e318:	de00012e 	bgeu	sp,et,8113e320 <alt_up_sd_card_set_attributes+0xc>
8113e31c:	003b68fa 	trap	3
8113e320:	df000215 	stw	fp,8(sp)
8113e324:	df000204 	addi	fp,sp,8
8113e328:	2007883a 	mov	r3,r4
8113e32c:	2805883a 	mov	r2,r5
8113e330:	e0fffe0d 	sth	r3,-8(fp)
8113e334:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8113e338:	e0bffe0f 	ldh	r2,-8(fp)
8113e33c:	10001416 	blt	r2,zero,8113e390 <alt_up_sd_card_set_attributes+0x7c>
8113e340:	e0bffe0f 	ldh	r2,-8(fp)
8113e344:	10800508 	cmpgei	r2,r2,20
8113e348:	1000111e 	bne	r2,zero,8113e390 <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
8113e34c:	e0fffe0f 	ldh	r3,-8(fp)
8113e350:	00a045b4 	movhi	r2,33046
8113e354:	10851d04 	addi	r2,r2,5236
8113e358:	180691ba 	slli	r3,r3,6
8113e35c:	10c5883a 	add	r2,r2,r3
8113e360:	10800f04 	addi	r2,r2,60
8113e364:	10800017 	ldw	r2,0(r2)
8113e368:	10000926 	beq	r2,zero,8113e390 <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
8113e36c:	e0fffe0f 	ldh	r3,-8(fp)
8113e370:	e0bfff0b 	ldhu	r2,-4(fp)
8113e374:	1009883a 	mov	r4,r2
8113e378:	00a045b4 	movhi	r2,33046
8113e37c:	10851d04 	addi	r2,r2,5236
8113e380:	180691ba 	slli	r3,r3,6
8113e384:	10c5883a 	add	r2,r2,r3
8113e388:	108002c4 	addi	r2,r2,11
8113e38c:	11000005 	stb	r4,0(r2)
        }
    }
}
8113e390:	0001883a 	nop
8113e394:	e037883a 	mov	sp,fp
8113e398:	df000017 	ldw	fp,0(sp)
8113e39c:	dec00104 	addi	sp,sp,4
8113e3a0:	f800283a 	ret

8113e3a4 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
8113e3a4:	defffd04 	addi	sp,sp,-12
8113e3a8:	de00012e 	bgeu	sp,et,8113e3b0 <alt_up_sd_card_get_attributes+0xc>
8113e3ac:	003b68fa 	trap	3
8113e3b0:	df000215 	stw	fp,8(sp)
8113e3b4:	df000204 	addi	fp,sp,8
8113e3b8:	2005883a 	mov	r2,r4
8113e3bc:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
8113e3c0:	00bfffc4 	movi	r2,-1
8113e3c4:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8113e3c8:	e0bfff0f 	ldh	r2,-4(fp)
8113e3cc:	10001416 	blt	r2,zero,8113e420 <alt_up_sd_card_get_attributes+0x7c>
8113e3d0:	e0bfff0f 	ldh	r2,-4(fp)
8113e3d4:	10800508 	cmpgei	r2,r2,20
8113e3d8:	1000111e 	bne	r2,zero,8113e420 <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
8113e3dc:	e0ffff0f 	ldh	r3,-4(fp)
8113e3e0:	00a045b4 	movhi	r2,33046
8113e3e4:	10851d04 	addi	r2,r2,5236
8113e3e8:	180691ba 	slli	r3,r3,6
8113e3ec:	10c5883a 	add	r2,r2,r3
8113e3f0:	10800f04 	addi	r2,r2,60
8113e3f4:	10800017 	ldw	r2,0(r2)
8113e3f8:	10000926 	beq	r2,zero,8113e420 <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
8113e3fc:	e0ffff0f 	ldh	r3,-4(fp)
8113e400:	00a045b4 	movhi	r2,33046
8113e404:	10851d04 	addi	r2,r2,5236
8113e408:	180691ba 	slli	r3,r3,6
8113e40c:	10c5883a 	add	r2,r2,r3
8113e410:	108002c4 	addi	r2,r2,11
8113e414:	10800003 	ldbu	r2,0(r2)
8113e418:	10803fcc 	andi	r2,r2,255
8113e41c:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
8113e420:	e0bffe0b 	ldhu	r2,-8(fp)
}
8113e424:	e037883a 	mov	sp,fp
8113e428:	df000017 	ldw	fp,0(sp)
8113e42c:	dec00104 	addi	sp,sp,4
8113e430:	f800283a 	ret

8113e434 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
8113e434:	defffa04 	addi	sp,sp,-24
8113e438:	de00012e 	bgeu	sp,et,8113e440 <alt_up_sd_card_read+0xc>
8113e43c:	003b68fa 	trap	3
8113e440:	dfc00515 	stw	ra,20(sp)
8113e444:	df000415 	stw	fp,16(sp)
8113e448:	df000404 	addi	fp,sp,16
8113e44c:	2005883a 	mov	r2,r4
8113e450:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
8113e454:	00bfffc4 	movi	r2,-1
8113e458:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8113e45c:	e0bfff0f 	ldh	r2,-4(fp)
8113e460:	1000ce16 	blt	r2,zero,8113e79c <alt_up_sd_card_read+0x368>
8113e464:	e0bfff0f 	ldh	r2,-4(fp)
8113e468:	10800508 	cmpgei	r2,r2,20
8113e46c:	1000cb1e 	bne	r2,zero,8113e79c <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
8113e470:	e0ffff0f 	ldh	r3,-4(fp)
8113e474:	00a045b4 	movhi	r2,33046
8113e478:	10851d04 	addi	r2,r2,5236
8113e47c:	180691ba 	slli	r3,r3,6
8113e480:	10c5883a 	add	r2,r2,r3
8113e484:	10800f04 	addi	r2,r2,60
8113e488:	10800017 	ldw	r2,0(r2)
8113e48c:	1000c326 	beq	r2,zero,8113e79c <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
8113e490:	e0ffff0f 	ldh	r3,-4(fp)
8113e494:	00a045b4 	movhi	r2,33046
8113e498:	10851d04 	addi	r2,r2,5236
8113e49c:	180691ba 	slli	r3,r3,6
8113e4a0:	10c5883a 	add	r2,r2,r3
8113e4a4:	10800904 	addi	r2,r2,36
8113e4a8:	10c00017 	ldw	r3,0(r2)
8113e4ac:	e13fff0f 	ldh	r4,-4(fp)
8113e4b0:	00a045b4 	movhi	r2,33046
8113e4b4:	10851d04 	addi	r2,r2,5236
8113e4b8:	200891ba 	slli	r4,r4,6
8113e4bc:	1105883a 	add	r2,r2,r4
8113e4c0:	10800604 	addi	r2,r2,24
8113e4c4:	10800017 	ldw	r2,0(r2)
8113e4c8:	1880b42e 	bgeu	r3,r2,8113e79c <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113e4cc:	00a045b4 	movhi	r2,33046
8113e4d0:	10850804 	addi	r2,r2,5152
8113e4d4:	10c01417 	ldw	r3,80(r2)
8113e4d8:	e13fff0f 	ldh	r4,-4(fp)
8113e4dc:	00a045b4 	movhi	r2,33046
8113e4e0:	10851d04 	addi	r2,r2,5236
8113e4e4:	200891ba 	slli	r4,r4,6
8113e4e8:	1105883a 	add	r2,r2,r4
8113e4ec:	10800704 	addi	r2,r2,28
8113e4f0:	10800017 	ldw	r2,0(r2)
8113e4f4:	113fff84 	addi	r4,r2,-2
8113e4f8:	00a045b4 	movhi	r2,33046
8113e4fc:	10850804 	addi	r2,r2,5152
8113e500:	10800383 	ldbu	r2,14(r2)
8113e504:	10803fcc 	andi	r2,r2,255
8113e508:	2085383a 	mul	r2,r4,r2
8113e50c:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
8113e510:	e13fff0f 	ldh	r4,-4(fp)
8113e514:	00a045b4 	movhi	r2,33046
8113e518:	10851d04 	addi	r2,r2,5236
8113e51c:	200891ba 	slli	r4,r4,6
8113e520:	1105883a 	add	r2,r2,r4
8113e524:	10800804 	addi	r2,r2,32
8113e528:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113e52c:	1885883a 	add	r2,r3,r2
8113e530:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
8113e534:	e0ffff0f 	ldh	r3,-4(fp)
8113e538:	00a045b4 	movhi	r2,33046
8113e53c:	10851d04 	addi	r2,r2,5236
8113e540:	180691ba 	slli	r3,r3,6
8113e544:	10c5883a 	add	r2,r2,r3
8113e548:	10800904 	addi	r2,r2,36
8113e54c:	10800017 	ldw	r2,0(r2)
8113e550:	10006826 	beq	r2,zero,8113e6f4 <alt_up_sd_card_read+0x2c0>
8113e554:	e0ffff0f 	ldh	r3,-4(fp)
8113e558:	00a045b4 	movhi	r2,33046
8113e55c:	10851d04 	addi	r2,r2,5236
8113e560:	180691ba 	slli	r3,r3,6
8113e564:	10c5883a 	add	r2,r2,r3
8113e568:	10800904 	addi	r2,r2,36
8113e56c:	10800017 	ldw	r2,0(r2)
8113e570:	10807fcc 	andi	r2,r2,511
8113e574:	10005f1e 	bne	r2,zero,8113e6f4 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8113e578:	e0ffff0f 	ldh	r3,-4(fp)
8113e57c:	00a045b4 	movhi	r2,33046
8113e580:	10851d04 	addi	r2,r2,5236
8113e584:	180691ba 	slli	r3,r3,6
8113e588:	10c5883a 	add	r2,r2,r3
8113e58c:	10800804 	addi	r2,r2,32
8113e590:	10c00017 	ldw	r3,0(r2)
8113e594:	00a045b4 	movhi	r2,33046
8113e598:	10850804 	addi	r2,r2,5152
8113e59c:	10800383 	ldbu	r2,14(r2)
8113e5a0:	10803fcc 	andi	r2,r2,255
8113e5a4:	10bfffc4 	addi	r2,r2,-1
8113e5a8:	1880401e 	bne	r3,r2,8113e6ac <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
8113e5ac:	e0ffff0f 	ldh	r3,-4(fp)
8113e5b0:	00a045b4 	movhi	r2,33046
8113e5b4:	10851d04 	addi	r2,r2,5236
8113e5b8:	180691ba 	slli	r3,r3,6
8113e5bc:	10c5883a 	add	r2,r2,r3
8113e5c0:	10800704 	addi	r2,r2,28
8113e5c4:	10800017 	ldw	r2,0(r2)
8113e5c8:	e0fffe04 	addi	r3,fp,-8
8113e5cc:	180b883a 	mov	r5,r3
8113e5d0:	1009883a 	mov	r4,r2
8113e5d4:	113adc00 	call	8113adc0 <get_cluster_flag>
8113e5d8:	10003226 	beq	r2,zero,8113e6a4 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
8113e5dc:	e0bffe0b 	ldhu	r2,-8(fp)
8113e5e0:	10bfffcc 	andi	r2,r2,65535
8113e5e4:	10fffe0c 	andi	r3,r2,65528
8113e5e8:	00bffe14 	movui	r2,65528
8113e5ec:	1880021e 	bne	r3,r2,8113e5f8 <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
8113e5f0:	00bfffc4 	movi	r2,-1
8113e5f4:	00006a06 	br	8113e7a0 <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
8113e5f8:	e13fff0f 	ldh	r4,-4(fp)
8113e5fc:	e0bffe0b 	ldhu	r2,-8(fp)
8113e600:	10ffffcc 	andi	r3,r2,65535
8113e604:	00a045b4 	movhi	r2,33046
8113e608:	10851d04 	addi	r2,r2,5236
8113e60c:	200891ba 	slli	r4,r4,6
8113e610:	1105883a 	add	r2,r2,r4
8113e614:	10800704 	addi	r2,r2,28
8113e618:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
8113e61c:	e0ffff0f 	ldh	r3,-4(fp)
8113e620:	00a045b4 	movhi	r2,33046
8113e624:	10851d04 	addi	r2,r2,5236
8113e628:	180691ba 	slli	r3,r3,6
8113e62c:	10c5883a 	add	r2,r2,r3
8113e630:	10800804 	addi	r2,r2,32
8113e634:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113e638:	00a045b4 	movhi	r2,33046
8113e63c:	10850804 	addi	r2,r2,5152
8113e640:	10c01417 	ldw	r3,80(r2)
8113e644:	e13fff0f 	ldh	r4,-4(fp)
8113e648:	00a045b4 	movhi	r2,33046
8113e64c:	10851d04 	addi	r2,r2,5236
8113e650:	200891ba 	slli	r4,r4,6
8113e654:	1105883a 	add	r2,r2,r4
8113e658:	10800704 	addi	r2,r2,28
8113e65c:	10800017 	ldw	r2,0(r2)
8113e660:	113fff84 	addi	r4,r2,-2
8113e664:	00a045b4 	movhi	r2,33046
8113e668:	10850804 	addi	r2,r2,5152
8113e66c:	10800383 	ldbu	r2,14(r2)
8113e670:	10803fcc 	andi	r2,r2,255
8113e674:	2085383a 	mul	r2,r4,r2
8113e678:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
8113e67c:	e13fff0f 	ldh	r4,-4(fp)
8113e680:	00a045b4 	movhi	r2,33046
8113e684:	10851d04 	addi	r2,r2,5236
8113e688:	200891ba 	slli	r4,r4,6
8113e68c:	1105883a 	add	r2,r2,r4
8113e690:	10800804 	addi	r2,r2,32
8113e694:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113e698:	1885883a 	add	r2,r3,r2
8113e69c:	e0bffd15 	stw	r2,-12(fp)
8113e6a0:	00001406 	br	8113e6f4 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
8113e6a4:	00bfff84 	movi	r2,-2
8113e6a8:	00003d06 	br	8113e7a0 <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
8113e6ac:	e13fff0f 	ldh	r4,-4(fp)
8113e6b0:	e0ffff0f 	ldh	r3,-4(fp)
8113e6b4:	00a045b4 	movhi	r2,33046
8113e6b8:	10851d04 	addi	r2,r2,5236
8113e6bc:	180691ba 	slli	r3,r3,6
8113e6c0:	10c5883a 	add	r2,r2,r3
8113e6c4:	10800804 	addi	r2,r2,32
8113e6c8:	10800017 	ldw	r2,0(r2)
8113e6cc:	10c00044 	addi	r3,r2,1
8113e6d0:	00a045b4 	movhi	r2,33046
8113e6d4:	10851d04 	addi	r2,r2,5236
8113e6d8:	200891ba 	slli	r4,r4,6
8113e6dc:	1105883a 	add	r2,r2,r4
8113e6e0:	10800804 	addi	r2,r2,32
8113e6e4:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
8113e6e8:	e0bffd17 	ldw	r2,-12(fp)
8113e6ec:	10800044 	addi	r2,r2,1
8113e6f0:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
8113e6f4:	d0e0b017 	ldw	r3,-32064(gp)
8113e6f8:	e0bffd17 	ldw	r2,-12(fp)
8113e6fc:	1885883a 	add	r2,r3,r2
8113e700:	1007883a 	mov	r3,r2
8113e704:	d0a0b417 	ldw	r2,-32048(gp)
8113e708:	18800726 	beq	r3,r2,8113e728 <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
8113e70c:	d0a0b017 	ldw	r2,-32064(gp)
8113e710:	100b883a 	mov	r5,r2
8113e714:	e13ffd17 	ldw	r4,-12(fp)
8113e718:	113ace00 	call	8113ace0 <Read_Sector_Data>
8113e71c:	1000021e 	bne	r2,zero,8113e728 <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
8113e720:	00bfff84 	movi	r2,-2
8113e724:	00001e06 	br	8113e7a0 <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
8113e728:	d0e0af17 	ldw	r3,-32068(gp)
8113e72c:	e13fff0f 	ldh	r4,-4(fp)
8113e730:	00a045b4 	movhi	r2,33046
8113e734:	10851d04 	addi	r2,r2,5236
8113e738:	200891ba 	slli	r4,r4,6
8113e73c:	1105883a 	add	r2,r2,r4
8113e740:	10800904 	addi	r2,r2,36
8113e744:	10800017 	ldw	r2,0(r2)
8113e748:	10807fcc 	andi	r2,r2,511
8113e74c:	1885883a 	add	r2,r3,r2
8113e750:	10800023 	ldbuio	r2,0(r2)
8113e754:	10803fcc 	andi	r2,r2,255
8113e758:	10803fcc 	andi	r2,r2,255
8113e75c:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
8113e760:	e13fff0f 	ldh	r4,-4(fp)
8113e764:	e0ffff0f 	ldh	r3,-4(fp)
8113e768:	00a045b4 	movhi	r2,33046
8113e76c:	10851d04 	addi	r2,r2,5236
8113e770:	180691ba 	slli	r3,r3,6
8113e774:	10c5883a 	add	r2,r2,r3
8113e778:	10800904 	addi	r2,r2,36
8113e77c:	10800017 	ldw	r2,0(r2)
8113e780:	10c00044 	addi	r3,r2,1
8113e784:	00a045b4 	movhi	r2,33046
8113e788:	10851d04 	addi	r2,r2,5236
8113e78c:	200891ba 	slli	r4,r4,6
8113e790:	1105883a 	add	r2,r2,r4
8113e794:	10800904 	addi	r2,r2,36
8113e798:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
8113e79c:	e0bffc0b 	ldhu	r2,-16(fp)
}
8113e7a0:	e037883a 	mov	sp,fp
8113e7a4:	dfc00117 	ldw	ra,4(sp)
8113e7a8:	df000017 	ldw	fp,0(sp)
8113e7ac:	dec00204 	addi	sp,sp,8
8113e7b0:	f800283a 	ret

8113e7b4 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
8113e7b4:	defff804 	addi	sp,sp,-32
8113e7b8:	de00012e 	bgeu	sp,et,8113e7c0 <alt_up_sd_card_write+0xc>
8113e7bc:	003b68fa 	trap	3
8113e7c0:	dfc00715 	stw	ra,28(sp)
8113e7c4:	df000615 	stw	fp,24(sp)
8113e7c8:	df000604 	addi	fp,sp,24
8113e7cc:	2007883a 	mov	r3,r4
8113e7d0:	2805883a 	mov	r2,r5
8113e7d4:	e0fffe0d 	sth	r3,-8(fp)
8113e7d8:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
8113e7dc:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
8113e7e0:	e0bffe0f 	ldh	r2,-8(fp)
8113e7e4:	10017716 	blt	r2,zero,8113edc4 <alt_up_sd_card_write+0x610>
8113e7e8:	e0bffe0f 	ldh	r2,-8(fp)
8113e7ec:	10800508 	cmpgei	r2,r2,20
8113e7f0:	1001741e 	bne	r2,zero,8113edc4 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
8113e7f4:	e0fffe0f 	ldh	r3,-8(fp)
8113e7f8:	00a045b4 	movhi	r2,33046
8113e7fc:	10851d04 	addi	r2,r2,5236
8113e800:	180691ba 	slli	r3,r3,6
8113e804:	10c5883a 	add	r2,r2,r3
8113e808:	10800f04 	addi	r2,r2,60
8113e80c:	10800017 	ldw	r2,0(r2)
8113e810:	10016c26 	beq	r2,zero,8113edc4 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113e814:	00a045b4 	movhi	r2,33046
8113e818:	10850804 	addi	r2,r2,5152
8113e81c:	10c01417 	ldw	r3,80(r2)
8113e820:	e13ffe0f 	ldh	r4,-8(fp)
8113e824:	00a045b4 	movhi	r2,33046
8113e828:	10851d04 	addi	r2,r2,5236
8113e82c:	200891ba 	slli	r4,r4,6
8113e830:	1105883a 	add	r2,r2,r4
8113e834:	10800704 	addi	r2,r2,28
8113e838:	10800017 	ldw	r2,0(r2)
8113e83c:	113fff84 	addi	r4,r2,-2
8113e840:	00a045b4 	movhi	r2,33046
8113e844:	10850804 	addi	r2,r2,5152
8113e848:	10800383 	ldbu	r2,14(r2)
8113e84c:	10803fcc 	andi	r2,r2,255
8113e850:	2085383a 	mul	r2,r4,r2
8113e854:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
8113e858:	e13ffe0f 	ldh	r4,-8(fp)
8113e85c:	00a045b4 	movhi	r2,33046
8113e860:	10851d04 	addi	r2,r2,5236
8113e864:	200891ba 	slli	r4,r4,6
8113e868:	1105883a 	add	r2,r2,r4
8113e86c:	10800804 	addi	r2,r2,32
8113e870:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113e874:	1885883a 	add	r2,r3,r2
8113e878:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
8113e87c:	e0fffe0f 	ldh	r3,-8(fp)
8113e880:	00a045b4 	movhi	r2,33046
8113e884:	10851d04 	addi	r2,r2,5236
8113e888:	180691ba 	slli	r3,r3,6
8113e88c:	10c5883a 	add	r2,r2,r3
8113e890:	10800904 	addi	r2,r2,36
8113e894:	10c00017 	ldw	r3,0(r2)
8113e898:	00a045b4 	movhi	r2,33046
8113e89c:	10850804 	addi	r2,r2,5152
8113e8a0:	1080030b 	ldhu	r2,12(r2)
8113e8a4:	10bfffcc 	andi	r2,r2,65535
8113e8a8:	1889203a 	divu	r4,r3,r2
8113e8ac:	2085383a 	mul	r2,r4,r2
8113e8b0:	1885c83a 	sub	r2,r3,r2
8113e8b4:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
8113e8b8:	e0fffe0f 	ldh	r3,-8(fp)
8113e8bc:	00a045b4 	movhi	r2,33046
8113e8c0:	10851d04 	addi	r2,r2,5236
8113e8c4:	180691ba 	slli	r3,r3,6
8113e8c8:	10c5883a 	add	r2,r2,r3
8113e8cc:	10800904 	addi	r2,r2,36
8113e8d0:	10c00017 	ldw	r3,0(r2)
8113e8d4:	e13ffe0f 	ldh	r4,-8(fp)
8113e8d8:	00a045b4 	movhi	r2,33046
8113e8dc:	10851d04 	addi	r2,r2,5236
8113e8e0:	200891ba 	slli	r4,r4,6
8113e8e4:	1105883a 	add	r2,r2,r4
8113e8e8:	10800604 	addi	r2,r2,24
8113e8ec:	10800017 	ldw	r2,0(r2)
8113e8f0:	1880672e 	bgeu	r3,r2,8113ea90 <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
8113e8f4:	e0fffe0f 	ldh	r3,-8(fp)
8113e8f8:	00a045b4 	movhi	r2,33046
8113e8fc:	10851d04 	addi	r2,r2,5236
8113e900:	180691ba 	slli	r3,r3,6
8113e904:	10c5883a 	add	r2,r2,r3
8113e908:	10800904 	addi	r2,r2,36
8113e90c:	10800017 	ldw	r2,0(r2)
8113e910:	1000e126 	beq	r2,zero,8113ec98 <alt_up_sd_card_write+0x4e4>
8113e914:	e0bffc0f 	ldh	r2,-16(fp)
8113e918:	1000df1e 	bne	r2,zero,8113ec98 <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8113e91c:	e0fffe0f 	ldh	r3,-8(fp)
8113e920:	00a045b4 	movhi	r2,33046
8113e924:	10851d04 	addi	r2,r2,5236
8113e928:	180691ba 	slli	r3,r3,6
8113e92c:	10c5883a 	add	r2,r2,r3
8113e930:	10800804 	addi	r2,r2,32
8113e934:	10c00017 	ldw	r3,0(r2)
8113e938:	00a045b4 	movhi	r2,33046
8113e93c:	10850804 	addi	r2,r2,5152
8113e940:	10800383 	ldbu	r2,14(r2)
8113e944:	10803fcc 	andi	r2,r2,255
8113e948:	10bfffc4 	addi	r2,r2,-1
8113e94c:	18803d1e 	bne	r3,r2,8113ea44 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
8113e950:	e0fffe0f 	ldh	r3,-8(fp)
8113e954:	00a045b4 	movhi	r2,33046
8113e958:	10851d04 	addi	r2,r2,5236
8113e95c:	180691ba 	slli	r3,r3,6
8113e960:	10c5883a 	add	r2,r2,r3
8113e964:	10800704 	addi	r2,r2,28
8113e968:	10800017 	ldw	r2,0(r2)
8113e96c:	e0fffc84 	addi	r3,fp,-14
8113e970:	180b883a 	mov	r5,r3
8113e974:	1009883a 	mov	r4,r2
8113e978:	113adc00 	call	8113adc0 <get_cluster_flag>
8113e97c:	10002f26 	beq	r2,zero,8113ea3c <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
8113e980:	e0bffc8b 	ldhu	r2,-14(fp)
8113e984:	10bfffcc 	andi	r2,r2,65535
8113e988:	10bffe28 	cmpgeui	r2,r2,65528
8113e98c:	1000c21e 	bne	r2,zero,8113ec98 <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
8113e990:	e13ffe0f 	ldh	r4,-8(fp)
8113e994:	e0bffc8b 	ldhu	r2,-14(fp)
8113e998:	10ffffcc 	andi	r3,r2,65535
8113e99c:	00a045b4 	movhi	r2,33046
8113e9a0:	10851d04 	addi	r2,r2,5236
8113e9a4:	200891ba 	slli	r4,r4,6
8113e9a8:	1105883a 	add	r2,r2,r4
8113e9ac:	10800704 	addi	r2,r2,28
8113e9b0:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
8113e9b4:	e0fffe0f 	ldh	r3,-8(fp)
8113e9b8:	00a045b4 	movhi	r2,33046
8113e9bc:	10851d04 	addi	r2,r2,5236
8113e9c0:	180691ba 	slli	r3,r3,6
8113e9c4:	10c5883a 	add	r2,r2,r3
8113e9c8:	10800804 	addi	r2,r2,32
8113e9cc:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113e9d0:	00a045b4 	movhi	r2,33046
8113e9d4:	10850804 	addi	r2,r2,5152
8113e9d8:	10c01417 	ldw	r3,80(r2)
8113e9dc:	e13ffe0f 	ldh	r4,-8(fp)
8113e9e0:	00a045b4 	movhi	r2,33046
8113e9e4:	10851d04 	addi	r2,r2,5236
8113e9e8:	200891ba 	slli	r4,r4,6
8113e9ec:	1105883a 	add	r2,r2,r4
8113e9f0:	10800704 	addi	r2,r2,28
8113e9f4:	10800017 	ldw	r2,0(r2)
8113e9f8:	113fff84 	addi	r4,r2,-2
8113e9fc:	00a045b4 	movhi	r2,33046
8113ea00:	10850804 	addi	r2,r2,5152
8113ea04:	10800383 	ldbu	r2,14(r2)
8113ea08:	10803fcc 	andi	r2,r2,255
8113ea0c:	2085383a 	mul	r2,r4,r2
8113ea10:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
8113ea14:	e13ffe0f 	ldh	r4,-8(fp)
8113ea18:	00a045b4 	movhi	r2,33046
8113ea1c:	10851d04 	addi	r2,r2,5236
8113ea20:	200891ba 	slli	r4,r4,6
8113ea24:	1105883a 	add	r2,r2,r4
8113ea28:	10800804 	addi	r2,r2,32
8113ea2c:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113ea30:	1885883a 	add	r2,r3,r2
8113ea34:	e0bffb15 	stw	r2,-20(fp)
8113ea38:	00009706 	br	8113ec98 <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
8113ea3c:	0005883a 	mov	r2,zero
8113ea40:	0000e106 	br	8113edc8 <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
8113ea44:	e13ffe0f 	ldh	r4,-8(fp)
8113ea48:	e0fffe0f 	ldh	r3,-8(fp)
8113ea4c:	00a045b4 	movhi	r2,33046
8113ea50:	10851d04 	addi	r2,r2,5236
8113ea54:	180691ba 	slli	r3,r3,6
8113ea58:	10c5883a 	add	r2,r2,r3
8113ea5c:	10800804 	addi	r2,r2,32
8113ea60:	10800017 	ldw	r2,0(r2)
8113ea64:	10c00044 	addi	r3,r2,1
8113ea68:	00a045b4 	movhi	r2,33046
8113ea6c:	10851d04 	addi	r2,r2,5236
8113ea70:	200891ba 	slli	r4,r4,6
8113ea74:	1105883a 	add	r2,r2,r4
8113ea78:	10800804 	addi	r2,r2,32
8113ea7c:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
8113ea80:	e0bffb17 	ldw	r2,-20(fp)
8113ea84:	10800044 	addi	r2,r2,1
8113ea88:	e0bffb15 	stw	r2,-20(fp)
8113ea8c:	00008206 	br	8113ec98 <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
8113ea90:	e0fffe0f 	ldh	r3,-8(fp)
8113ea94:	00a045b4 	movhi	r2,33046
8113ea98:	10851d04 	addi	r2,r2,5236
8113ea9c:	180691ba 	slli	r3,r3,6
8113eaa0:	10c5883a 	add	r2,r2,r3
8113eaa4:	10800904 	addi	r2,r2,36
8113eaa8:	10800017 	ldw	r2,0(r2)
8113eaac:	10007a26 	beq	r2,zero,8113ec98 <alt_up_sd_card_write+0x4e4>
8113eab0:	e0bffc0f 	ldh	r2,-16(fp)
8113eab4:	1000781e 	bne	r2,zero,8113ec98 <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
8113eab8:	e0fffe0f 	ldh	r3,-8(fp)
8113eabc:	00a045b4 	movhi	r2,33046
8113eac0:	10851d04 	addi	r2,r2,5236
8113eac4:	180691ba 	slli	r3,r3,6
8113eac8:	10c5883a 	add	r2,r2,r3
8113eacc:	10800804 	addi	r2,r2,32
8113ead0:	10c00017 	ldw	r3,0(r2)
8113ead4:	00a045b4 	movhi	r2,33046
8113ead8:	10850804 	addi	r2,r2,5152
8113eadc:	10800383 	ldbu	r2,14(r2)
8113eae0:	10803fcc 	andi	r2,r2,255
8113eae4:	10bfffc4 	addi	r2,r2,-1
8113eae8:	18803e1e 	bne	r3,r2,8113ebe4 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
8113eaec:	e0bffd04 	addi	r2,fp,-12
8113eaf0:	1009883a 	mov	r4,r2
8113eaf4:	113ce040 	call	8113ce04 <find_first_empty_cluster>
8113eaf8:	10003826 	beq	r2,zero,8113ebdc <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
8113eafc:	e0fffe0f 	ldh	r3,-8(fp)
8113eb00:	00a045b4 	movhi	r2,33046
8113eb04:	10851d04 	addi	r2,r2,5236
8113eb08:	180691ba 	slli	r3,r3,6
8113eb0c:	10c5883a 	add	r2,r2,r3
8113eb10:	10800704 	addi	r2,r2,28
8113eb14:	10800017 	ldw	r2,0(r2)
8113eb18:	e0fffd17 	ldw	r3,-12(fp)
8113eb1c:	18ffffcc 	andi	r3,r3,65535
8113eb20:	18e0001c 	xori	r3,r3,32768
8113eb24:	18e00004 	addi	r3,r3,-32768
8113eb28:	01800044 	movi	r6,1
8113eb2c:	180b883a 	mov	r5,r3
8113eb30:	1009883a 	mov	r4,r2
8113eb34:	113ae7c0 	call	8113ae7c <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
8113eb38:	e0bffd17 	ldw	r2,-12(fp)
8113eb3c:	01800044 	movi	r6,1
8113eb40:	017fffc4 	movi	r5,-1
8113eb44:	1009883a 	mov	r4,r2
8113eb48:	113ae7c0 	call	8113ae7c <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
8113eb4c:	e0fffe0f 	ldh	r3,-8(fp)
8113eb50:	00a045b4 	movhi	r2,33046
8113eb54:	10851d04 	addi	r2,r2,5236
8113eb58:	180691ba 	slli	r3,r3,6
8113eb5c:	10c5883a 	add	r2,r2,r3
8113eb60:	10800704 	addi	r2,r2,28
8113eb64:	10800017 	ldw	r2,0(r2)
8113eb68:	e0fffd17 	ldw	r3,-12(fp)
8113eb6c:	18ffffcc 	andi	r3,r3,65535
8113eb70:	18e0001c 	xori	r3,r3,32768
8113eb74:	18e00004 	addi	r3,r3,-32768
8113eb78:	000d883a 	mov	r6,zero
8113eb7c:	180b883a 	mov	r5,r3
8113eb80:	1009883a 	mov	r4,r2
8113eb84:	113ae7c0 	call	8113ae7c <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
8113eb88:	e0bffd17 	ldw	r2,-12(fp)
8113eb8c:	000d883a 	mov	r6,zero
8113eb90:	017fffc4 	movi	r5,-1
8113eb94:	1009883a 	mov	r4,r2
8113eb98:	113ae7c0 	call	8113ae7c <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
8113eb9c:	e13ffe0f 	ldh	r4,-8(fp)
8113eba0:	e0fffd17 	ldw	r3,-12(fp)
8113eba4:	00a045b4 	movhi	r2,33046
8113eba8:	10851d04 	addi	r2,r2,5236
8113ebac:	200891ba 	slli	r4,r4,6
8113ebb0:	1105883a 	add	r2,r2,r4
8113ebb4:	10800704 	addi	r2,r2,28
8113ebb8:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
8113ebbc:	e0fffe0f 	ldh	r3,-8(fp)
8113ebc0:	00a045b4 	movhi	r2,33046
8113ebc4:	10851d04 	addi	r2,r2,5236
8113ebc8:	180691ba 	slli	r3,r3,6
8113ebcc:	10c5883a 	add	r2,r2,r3
8113ebd0:	10800804 	addi	r2,r2,32
8113ebd4:	10000015 	stw	zero,0(r2)
8113ebd8:	00001506 	br	8113ec30 <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
8113ebdc:	0005883a 	mov	r2,zero
8113ebe0:	00007906 	br	8113edc8 <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
8113ebe4:	e13ffe0f 	ldh	r4,-8(fp)
8113ebe8:	e0fffe0f 	ldh	r3,-8(fp)
8113ebec:	00a045b4 	movhi	r2,33046
8113ebf0:	10851d04 	addi	r2,r2,5236
8113ebf4:	180691ba 	slli	r3,r3,6
8113ebf8:	10c5883a 	add	r2,r2,r3
8113ebfc:	10800904 	addi	r2,r2,36
8113ec00:	10c00017 	ldw	r3,0(r2)
8113ec04:	00a045b4 	movhi	r2,33046
8113ec08:	10850804 	addi	r2,r2,5152
8113ec0c:	1080030b 	ldhu	r2,12(r2)
8113ec10:	10bfffcc 	andi	r2,r2,65535
8113ec14:	1887203a 	divu	r3,r3,r2
8113ec18:	00a045b4 	movhi	r2,33046
8113ec1c:	10851d04 	addi	r2,r2,5236
8113ec20:	200891ba 	slli	r4,r4,6
8113ec24:	1105883a 	add	r2,r2,r4
8113ec28:	10800804 	addi	r2,r2,32
8113ec2c:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113ec30:	00a045b4 	movhi	r2,33046
8113ec34:	10850804 	addi	r2,r2,5152
8113ec38:	10c01417 	ldw	r3,80(r2)
8113ec3c:	e13ffe0f 	ldh	r4,-8(fp)
8113ec40:	00a045b4 	movhi	r2,33046
8113ec44:	10851d04 	addi	r2,r2,5236
8113ec48:	200891ba 	slli	r4,r4,6
8113ec4c:	1105883a 	add	r2,r2,r4
8113ec50:	10800704 	addi	r2,r2,28
8113ec54:	10800017 	ldw	r2,0(r2)
8113ec58:	113fff84 	addi	r4,r2,-2
8113ec5c:	00a045b4 	movhi	r2,33046
8113ec60:	10850804 	addi	r2,r2,5152
8113ec64:	10800383 	ldbu	r2,14(r2)
8113ec68:	10803fcc 	andi	r2,r2,255
8113ec6c:	2085383a 	mul	r2,r4,r2
8113ec70:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
8113ec74:	e13ffe0f 	ldh	r4,-8(fp)
8113ec78:	00a045b4 	movhi	r2,33046
8113ec7c:	10851d04 	addi	r2,r2,5236
8113ec80:	200891ba 	slli	r4,r4,6
8113ec84:	1105883a 	add	r2,r2,r4
8113ec88:	10800804 	addi	r2,r2,32
8113ec8c:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8113ec90:	1885883a 	add	r2,r3,r2
8113ec94:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
8113ec98:	d0e0b017 	ldw	r3,-32064(gp)
8113ec9c:	e0bffb17 	ldw	r2,-20(fp)
8113eca0:	1885883a 	add	r2,r3,r2
8113eca4:	1007883a 	mov	r3,r2
8113eca8:	d0a0b417 	ldw	r2,-32048(gp)
8113ecac:	18800726 	beq	r3,r2,8113eccc <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
8113ecb0:	d0a0b017 	ldw	r2,-32064(gp)
8113ecb4:	100b883a 	mov	r5,r2
8113ecb8:	e13ffb17 	ldw	r4,-20(fp)
8113ecbc:	113ace00 	call	8113ace0 <Read_Sector_Data>
8113ecc0:	1000021e 	bne	r2,zero,8113eccc <alt_up_sd_card_write+0x518>
                {
					return false;
8113ecc4:	0005883a 	mov	r2,zero
8113ecc8:	00003f06 	br	8113edc8 <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
8113eccc:	d0e0af17 	ldw	r3,-32068(gp)
8113ecd0:	e0bffc0f 	ldh	r2,-16(fp)
8113ecd4:	1885883a 	add	r2,r3,r2
8113ecd8:	e0ffff07 	ldb	r3,-4(fp)
8113ecdc:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
8113ece0:	e13ffe0f 	ldh	r4,-8(fp)
8113ece4:	e0fffe0f 	ldh	r3,-8(fp)
8113ece8:	00a045b4 	movhi	r2,33046
8113ecec:	10851d04 	addi	r2,r2,5236
8113ecf0:	180691ba 	slli	r3,r3,6
8113ecf4:	10c5883a 	add	r2,r2,r3
8113ecf8:	10800904 	addi	r2,r2,36
8113ecfc:	10800017 	ldw	r2,0(r2)
8113ed00:	10c00044 	addi	r3,r2,1
8113ed04:	00a045b4 	movhi	r2,33046
8113ed08:	10851d04 	addi	r2,r2,5236
8113ed0c:	200891ba 	slli	r4,r4,6
8113ed10:	1105883a 	add	r2,r2,r4
8113ed14:	10800904 	addi	r2,r2,36
8113ed18:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
8113ed1c:	e0fffe0f 	ldh	r3,-8(fp)
8113ed20:	00a045b4 	movhi	r2,33046
8113ed24:	10851d04 	addi	r2,r2,5236
8113ed28:	180691ba 	slli	r3,r3,6
8113ed2c:	10c5883a 	add	r2,r2,r3
8113ed30:	10800904 	addi	r2,r2,36
8113ed34:	10c00017 	ldw	r3,0(r2)
8113ed38:	e13ffe0f 	ldh	r4,-8(fp)
8113ed3c:	00a045b4 	movhi	r2,33046
8113ed40:	10851d04 	addi	r2,r2,5236
8113ed44:	200891ba 	slli	r4,r4,6
8113ed48:	1105883a 	add	r2,r2,r4
8113ed4c:	10800604 	addi	r2,r2,24
8113ed50:	10800017 	ldw	r2,0(r2)
8113ed54:	18801736 	bltu	r3,r2,8113edb4 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
8113ed58:	e13ffe0f 	ldh	r4,-8(fp)
8113ed5c:	e0fffe0f 	ldh	r3,-8(fp)
8113ed60:	00a045b4 	movhi	r2,33046
8113ed64:	10851d04 	addi	r2,r2,5236
8113ed68:	180691ba 	slli	r3,r3,6
8113ed6c:	10c5883a 	add	r2,r2,r3
8113ed70:	10800604 	addi	r2,r2,24
8113ed74:	10800017 	ldw	r2,0(r2)
8113ed78:	10c00044 	addi	r3,r2,1
8113ed7c:	00a045b4 	movhi	r2,33046
8113ed80:	10851d04 	addi	r2,r2,5236
8113ed84:	200891ba 	slli	r4,r4,6
8113ed88:	1105883a 	add	r2,r2,r4
8113ed8c:	10800604 	addi	r2,r2,24
8113ed90:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
8113ed94:	e0fffe0f 	ldh	r3,-8(fp)
8113ed98:	00a045b4 	movhi	r2,33046
8113ed9c:	10851d04 	addi	r2,r2,5236
8113eda0:	180691ba 	slli	r3,r3,6
8113eda4:	10c5883a 	add	r2,r2,r3
8113eda8:	10800e04 	addi	r2,r2,56
8113edac:	00c00044 	movi	r3,1
8113edb0:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
8113edb4:	00800044 	movi	r2,1
8113edb8:	d0a0b315 	stw	r2,-32052(gp)
			result = true;
8113edbc:	00800044 	movi	r2,1
8113edc0:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
8113edc4:	e0bffa17 	ldw	r2,-24(fp)
}
8113edc8:	e037883a 	mov	sp,fp
8113edcc:	dfc00117 	ldw	ra,4(sp)
8113edd0:	df000017 	ldw	fp,0(sp)
8113edd4:	dec00204 	addi	sp,sp,8
8113edd8:	f800283a 	ret

8113eddc <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
8113eddc:	defffb04 	addi	sp,sp,-20
8113ede0:	de00012e 	bgeu	sp,et,8113ede8 <alt_up_sd_card_fclose+0xc>
8113ede4:	003b68fa 	trap	3
8113ede8:	dfc00415 	stw	ra,16(sp)
8113edec:	df000315 	stw	fp,12(sp)
8113edf0:	df000304 	addi	fp,sp,12
8113edf4:	2005883a 	mov	r2,r4
8113edf8:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
8113edfc:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113ee00:	113d9b80 	call	8113d9b8 <alt_up_sd_card_is_Present>
8113ee04:	10006026 	beq	r2,zero,8113ef88 <alt_up_sd_card_fclose+0x1ac>
8113ee08:	d0a0a917 	ldw	r2,-32092(gp)
8113ee0c:	10005e26 	beq	r2,zero,8113ef88 <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
8113ee10:	e0ffff0f 	ldh	r3,-4(fp)
8113ee14:	00a045b4 	movhi	r2,33046
8113ee18:	10851d04 	addi	r2,r2,5236
8113ee1c:	180691ba 	slli	r3,r3,6
8113ee20:	10c5883a 	add	r2,r2,r3
8113ee24:	10800f04 	addi	r2,r2,60
8113ee28:	10800017 	ldw	r2,0(r2)
8113ee2c:	10005626 	beq	r2,zero,8113ef88 <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
8113ee30:	e0ffff0f 	ldh	r3,-4(fp)
8113ee34:	00a045b4 	movhi	r2,33046
8113ee38:	10851d04 	addi	r2,r2,5236
8113ee3c:	180691ba 	slli	r3,r3,6
8113ee40:	10c5883a 	add	r2,r2,r3
8113ee44:	10800e04 	addi	r2,r2,56
8113ee48:	10800017 	ldw	r2,0(r2)
8113ee4c:	10004526 	beq	r2,zero,8113ef64 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
8113ee50:	e0ffff0f 	ldh	r3,-4(fp)
8113ee54:	00a045b4 	movhi	r2,33046
8113ee58:	10851d04 	addi	r2,r2,5236
8113ee5c:	180691ba 	slli	r3,r3,6
8113ee60:	10c5883a 	add	r2,r2,r3
8113ee64:	10800b04 	addi	r2,r2,44
8113ee68:	10800017 	ldw	r2,0(r2)
8113ee6c:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
8113ee70:	e0ffff0f 	ldh	r3,-4(fp)
8113ee74:	00a045b4 	movhi	r2,33046
8113ee78:	10851d04 	addi	r2,r2,5236
8113ee7c:	180691ba 	slli	r3,r3,6
8113ee80:	10c5883a 	add	r2,r2,r3
8113ee84:	10800a04 	addi	r2,r2,40
8113ee88:	10800017 	ldw	r2,0(r2)
8113ee8c:	1000071e 	bne	r2,zero,8113eeac <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
8113ee90:	00a045b4 	movhi	r2,33046
8113ee94:	10850804 	addi	r2,r2,5152
8113ee98:	10801317 	ldw	r2,76(r2)
8113ee9c:	e0fffe17 	ldw	r3,-8(fp)
8113eea0:	1885883a 	add	r2,r3,r2
8113eea4:	e0bffe15 	stw	r2,-8(fp)
8113eea8:	00001406 	br	8113eefc <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
8113eeac:	00a045b4 	movhi	r2,33046
8113eeb0:	10850804 	addi	r2,r2,5152
8113eeb4:	10c01417 	ldw	r3,80(r2)
8113eeb8:	e0bffe17 	ldw	r2,-8(fp)
8113eebc:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
8113eec0:	e13fff0f 	ldh	r4,-4(fp)
8113eec4:	00a045b4 	movhi	r2,33046
8113eec8:	10851d04 	addi	r2,r2,5236
8113eecc:	200891ba 	slli	r4,r4,6
8113eed0:	1105883a 	add	r2,r2,r4
8113eed4:	10800a04 	addi	r2,r2,40
8113eed8:	10800017 	ldw	r2,0(r2)
8113eedc:	113fff84 	addi	r4,r2,-2
8113eee0:	00a045b4 	movhi	r2,33046
8113eee4:	10850804 	addi	r2,r2,5152
8113eee8:	10800383 	ldbu	r2,14(r2)
8113eeec:	10803fcc 	andi	r2,r2,255
8113eef0:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
8113eef4:	1885883a 	add	r2,r3,r2
8113eef8:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
8113eefc:	e0bffe17 	ldw	r2,-8(fp)
8113ef00:	d0e0b017 	ldw	r3,-32064(gp)
8113ef04:	180b883a 	mov	r5,r3
8113ef08:	1009883a 	mov	r4,r2
8113ef0c:	113ace00 	call	8113ace0 <Read_Sector_Data>
8113ef10:	10001426 	beq	r2,zero,8113ef64 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
8113ef14:	e0ffff0f 	ldh	r3,-4(fp)
8113ef18:	00a045b4 	movhi	r2,33046
8113ef1c:	10851d04 	addi	r2,r2,5236
8113ef20:	180691ba 	slli	r3,r3,6
8113ef24:	10c5883a 	add	r2,r2,r3
8113ef28:	10800c04 	addi	r2,r2,48
8113ef2c:	1080000b 	ldhu	r2,0(r2)
8113ef30:	113fffcc 	andi	r4,r2,65535
8113ef34:	2120001c 	xori	r4,r4,32768
8113ef38:	21200004 	addi	r4,r4,-32768
8113ef3c:	e0bfff0f 	ldh	r2,-4(fp)
8113ef40:	100691ba 	slli	r3,r2,6
8113ef44:	00a045b4 	movhi	r2,33046
8113ef48:	10851d04 	addi	r2,r2,5236
8113ef4c:	1885883a 	add	r2,r3,r2
8113ef50:	100b883a 	mov	r5,r2
8113ef54:	113b3940 	call	8113b394 <Write_File_Record_At_Offset>
8113ef58:	10000226 	beq	r2,zero,8113ef64 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
8113ef5c:	113ac8c0 	call	8113ac8c <Save_Modified_Sector>
8113ef60:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
8113ef64:	e0ffff0f 	ldh	r3,-4(fp)
8113ef68:	00a045b4 	movhi	r2,33046
8113ef6c:	10851d04 	addi	r2,r2,5236
8113ef70:	180691ba 	slli	r3,r3,6
8113ef74:	10c5883a 	add	r2,r2,r3
8113ef78:	10800f04 	addi	r2,r2,60
8113ef7c:	10000015 	stw	zero,0(r2)
			result = true;
8113ef80:	00800044 	movi	r2,1
8113ef84:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
8113ef88:	e0bffd17 	ldw	r2,-12(fp)
}
8113ef8c:	e037883a 	mov	sp,fp
8113ef90:	dfc00117 	ldw	ra,4(sp)
8113ef94:	df000017 	ldw	fp,0(sp)
8113ef98:	dec00204 	addi	sp,sp,8
8113ef9c:	f800283a 	ret

8113efa0 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
8113efa0:	defffa04 	addi	sp,sp,-24
8113efa4:	de00012e 	bgeu	sp,et,8113efac <altera_avalon_jtag_uart_read_fd+0xc>
8113efa8:	003b68fa 	trap	3
8113efac:	dfc00515 	stw	ra,20(sp)
8113efb0:	df000415 	stw	fp,16(sp)
8113efb4:	df000404 	addi	fp,sp,16
8113efb8:	e13ffd15 	stw	r4,-12(fp)
8113efbc:	e17ffe15 	stw	r5,-8(fp)
8113efc0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
8113efc4:	e0bffd17 	ldw	r2,-12(fp)
8113efc8:	10800017 	ldw	r2,0(r2)
8113efcc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
8113efd0:	e0bffc17 	ldw	r2,-16(fp)
8113efd4:	10c00a04 	addi	r3,r2,40
8113efd8:	e0bffd17 	ldw	r2,-12(fp)
8113efdc:	10800217 	ldw	r2,8(r2)
8113efe0:	100f883a 	mov	r7,r2
8113efe4:	e1bfff17 	ldw	r6,-4(fp)
8113efe8:	e17ffe17 	ldw	r5,-8(fp)
8113efec:	1809883a 	mov	r4,r3
8113eff0:	113f8240 	call	8113f824 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
8113eff4:	e037883a 	mov	sp,fp
8113eff8:	dfc00117 	ldw	ra,4(sp)
8113effc:	df000017 	ldw	fp,0(sp)
8113f000:	dec00204 	addi	sp,sp,8
8113f004:	f800283a 	ret

8113f008 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
8113f008:	defffa04 	addi	sp,sp,-24
8113f00c:	de00012e 	bgeu	sp,et,8113f014 <altera_avalon_jtag_uart_write_fd+0xc>
8113f010:	003b68fa 	trap	3
8113f014:	dfc00515 	stw	ra,20(sp)
8113f018:	df000415 	stw	fp,16(sp)
8113f01c:	df000404 	addi	fp,sp,16
8113f020:	e13ffd15 	stw	r4,-12(fp)
8113f024:	e17ffe15 	stw	r5,-8(fp)
8113f028:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
8113f02c:	e0bffd17 	ldw	r2,-12(fp)
8113f030:	10800017 	ldw	r2,0(r2)
8113f034:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
8113f038:	e0bffc17 	ldw	r2,-16(fp)
8113f03c:	10c00a04 	addi	r3,r2,40
8113f040:	e0bffd17 	ldw	r2,-12(fp)
8113f044:	10800217 	ldw	r2,8(r2)
8113f048:	100f883a 	mov	r7,r2
8113f04c:	e1bfff17 	ldw	r6,-4(fp)
8113f050:	e17ffe17 	ldw	r5,-8(fp)
8113f054:	1809883a 	mov	r4,r3
8113f058:	113fae80 	call	8113fae8 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
8113f05c:	e037883a 	mov	sp,fp
8113f060:	dfc00117 	ldw	ra,4(sp)
8113f064:	df000017 	ldw	fp,0(sp)
8113f068:	dec00204 	addi	sp,sp,8
8113f06c:	f800283a 	ret

8113f070 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
8113f070:	defffc04 	addi	sp,sp,-16
8113f074:	de00012e 	bgeu	sp,et,8113f07c <altera_avalon_jtag_uart_close_fd+0xc>
8113f078:	003b68fa 	trap	3
8113f07c:	dfc00315 	stw	ra,12(sp)
8113f080:	df000215 	stw	fp,8(sp)
8113f084:	df000204 	addi	fp,sp,8
8113f088:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
8113f08c:	e0bfff17 	ldw	r2,-4(fp)
8113f090:	10800017 	ldw	r2,0(r2)
8113f094:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
8113f098:	e0bffe17 	ldw	r2,-8(fp)
8113f09c:	10c00a04 	addi	r3,r2,40
8113f0a0:	e0bfff17 	ldw	r2,-4(fp)
8113f0a4:	10800217 	ldw	r2,8(r2)
8113f0a8:	100b883a 	mov	r5,r2
8113f0ac:	1809883a 	mov	r4,r3
8113f0b0:	113f6bc0 	call	8113f6bc <altera_avalon_jtag_uart_close>
}
8113f0b4:	e037883a 	mov	sp,fp
8113f0b8:	dfc00117 	ldw	ra,4(sp)
8113f0bc:	df000017 	ldw	fp,0(sp)
8113f0c0:	dec00204 	addi	sp,sp,8
8113f0c4:	f800283a 	ret

8113f0c8 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
8113f0c8:	defffa04 	addi	sp,sp,-24
8113f0cc:	de00012e 	bgeu	sp,et,8113f0d4 <altera_avalon_jtag_uart_ioctl_fd+0xc>
8113f0d0:	003b68fa 	trap	3
8113f0d4:	dfc00515 	stw	ra,20(sp)
8113f0d8:	df000415 	stw	fp,16(sp)
8113f0dc:	df000404 	addi	fp,sp,16
8113f0e0:	e13ffd15 	stw	r4,-12(fp)
8113f0e4:	e17ffe15 	stw	r5,-8(fp)
8113f0e8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
8113f0ec:	e0bffd17 	ldw	r2,-12(fp)
8113f0f0:	10800017 	ldw	r2,0(r2)
8113f0f4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
8113f0f8:	e0bffc17 	ldw	r2,-16(fp)
8113f0fc:	10800a04 	addi	r2,r2,40
8113f100:	e1bfff17 	ldw	r6,-4(fp)
8113f104:	e17ffe17 	ldw	r5,-8(fp)
8113f108:	1009883a 	mov	r4,r2
8113f10c:	113f72c0 	call	8113f72c <altera_avalon_jtag_uart_ioctl>
}
8113f110:	e037883a 	mov	sp,fp
8113f114:	dfc00117 	ldw	ra,4(sp)
8113f118:	df000017 	ldw	fp,0(sp)
8113f11c:	dec00204 	addi	sp,sp,8
8113f120:	f800283a 	ret

8113f124 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
8113f124:	deffef04 	addi	sp,sp,-68
8113f128:	de00012e 	bgeu	sp,et,8113f130 <altera_avalon_jtag_uart_init+0xc>
8113f12c:	003b68fa 	trap	3
8113f130:	dfc01015 	stw	ra,64(sp)
8113f134:	df000f15 	stw	fp,60(sp)
8113f138:	dc400e15 	stw	r17,56(sp)
8113f13c:	dc000d15 	stw	r16,52(sp)
8113f140:	df000f04 	addi	fp,sp,60
8113f144:	e13ff715 	stw	r4,-36(fp)
8113f148:	e17ff815 	stw	r5,-32(fp)
8113f14c:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
8113f150:	e0bff717 	ldw	r2,-36(fp)
8113f154:	10800c04 	addi	r2,r2,48
8113f158:	e0bff215 	stw	r2,-56(fp)
8113f15c:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
8113f160:	e0bff60b 	ldhu	r2,-40(fp)
8113f164:	e0fff684 	addi	r3,fp,-38
8113f168:	180b883a 	mov	r5,r3
8113f16c:	1009883a 	mov	r4,r2
8113f170:	11332f40 	call	811332f4 <OSFlagCreate>
8113f174:	1007883a 	mov	r3,r2
8113f178:	e0bff217 	ldw	r2,-56(fp)
8113f17c:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
8113f180:	e0bff717 	ldw	r2,-36(fp)
8113f184:	10800a04 	addi	r2,r2,40
8113f188:	e0bff315 	stw	r2,-52(fp)
8113f18c:	00800044 	movi	r2,1
8113f190:	e0bff58d 	sth	r2,-42(fp)
8113f194:	e0bff58b 	ldhu	r2,-42(fp)
8113f198:	1009883a 	mov	r4,r2
8113f19c:	11372500 	call	81137250 <OSSemCreate>
8113f1a0:	1007883a 	mov	r3,r2
8113f1a4:	e0bff317 	ldw	r2,-52(fp)
8113f1a8:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
8113f1ac:	e0bff717 	ldw	r2,-36(fp)
8113f1b0:	10800b04 	addi	r2,r2,44
8113f1b4:	e0bff415 	stw	r2,-48(fp)
8113f1b8:	00800044 	movi	r2,1
8113f1bc:	e0bff50d 	sth	r2,-44(fp)
8113f1c0:	e0bff50b 	ldhu	r2,-44(fp)
8113f1c4:	1009883a 	mov	r4,r2
8113f1c8:	11372500 	call	81137250 <OSSemCreate>
8113f1cc:	1007883a 	mov	r3,r2
8113f1d0:	e0bff417 	ldw	r2,-48(fp)
8113f1d4:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
8113f1d8:	e0bff717 	ldw	r2,-36(fp)
8113f1dc:	00c00044 	movi	r3,1
8113f1e0:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
8113f1e4:	e0bff717 	ldw	r2,-36(fp)
8113f1e8:	10800017 	ldw	r2,0(r2)
8113f1ec:	10800104 	addi	r2,r2,4
8113f1f0:	1007883a 	mov	r3,r2
8113f1f4:	e0bff717 	ldw	r2,-36(fp)
8113f1f8:	10800817 	ldw	r2,32(r2)
8113f1fc:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
8113f200:	e0bff817 	ldw	r2,-32(fp)
8113f204:	e0fff917 	ldw	r3,-28(fp)
8113f208:	d8000015 	stw	zero,0(sp)
8113f20c:	e1fff717 	ldw	r7,-36(fp)
8113f210:	01a04534 	movhi	r6,33044
8113f214:	31bcbd04 	addi	r6,r6,-3340
8113f218:	180b883a 	mov	r5,r3
8113f21c:	1009883a 	mov	r4,r2
8113f220:	1142e480 	call	81142e48 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
8113f224:	e0bff717 	ldw	r2,-36(fp)
8113f228:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
8113f22c:	e0bff717 	ldw	r2,-36(fp)
8113f230:	10800204 	addi	r2,r2,8
8113f234:	d0e08717 	ldw	r3,-32228(gp)
8113f238:	e1fff717 	ldw	r7,-36(fp)
8113f23c:	01a04534 	movhi	r6,33044
8113f240:	31bd6c04 	addi	r6,r6,-2640
8113f244:	180b883a 	mov	r5,r3
8113f248:	1009883a 	mov	r4,r2
8113f24c:	1142b8c0 	call	81142b8c <alt_alarm_start>
8113f250:	1000040e 	bge	r2,zero,8113f264 <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
8113f254:	e0fff717 	ldw	r3,-36(fp)
8113f258:	00a00034 	movhi	r2,32768
8113f25c:	10bfffc4 	addi	r2,r2,-1
8113f260:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
8113f264:	d0a08083 	ldbu	r2,-32254(gp)
8113f268:	10803fcc 	andi	r2,r2,255
8113f26c:	10800058 	cmpnei	r2,r2,1
8113f270:	10000f1e 	bne	r2,zero,8113f2b0 <altera_avalon_jtag_uart_init+0x18c>
8113f274:	d0e08717 	ldw	r3,-32228(gp)
8113f278:	00b33374 	movhi	r2,52429
8113f27c:	10b33344 	addi	r2,r2,-13107
8113f280:	1888383a 	mulxuu	r4,r3,r2
8113f284:	1885383a 	mul	r2,r3,r2
8113f288:	1021883a 	mov	r16,r2
8113f28c:	2023883a 	mov	r17,r4
8113f290:	8804d0fa 	srli	r2,r17,3
8113f294:	e1fff717 	ldw	r7,-36(fp)
8113f298:	01a044f4 	movhi	r6,33043
8113f29c:	31bf2404 	addi	r6,r6,-880
8113f2a0:	100b883a 	mov	r5,r2
8113f2a4:	012045b4 	movhi	r4,33046
8113f2a8:	212cdc04 	addi	r4,r4,-19600
8113f2ac:	1142b8c0 	call	81142b8c <alt_alarm_start>
8113f2b0:	d0a08103 	ldbu	r2,-32252(gp)
8113f2b4:	10803fcc 	andi	r2,r2,255
8113f2b8:	10800058 	cmpnei	r2,r2,1
8113f2bc:	1000051e 	bne	r2,zero,8113f2d4 <altera_avalon_jtag_uart_init+0x1b0>
8113f2c0:	e0bff717 	ldw	r2,-36(fp)
8113f2c4:	10800017 	ldw	r2,0(r2)
8113f2c8:	100b883a 	mov	r5,r2
8113f2cc:	e13ff717 	ldw	r4,-36(fp)
8113f2d0:	112fe280 	call	8112fe28 <alt_log_jtag_uart_startup_info>
}
8113f2d4:	0001883a 	nop
8113f2d8:	e6fffe04 	addi	sp,fp,-8
8113f2dc:	dfc00317 	ldw	ra,12(sp)
8113f2e0:	df000217 	ldw	fp,8(sp)
8113f2e4:	dc400117 	ldw	r17,4(sp)
8113f2e8:	dc000017 	ldw	r16,0(sp)
8113f2ec:	dec00404 	addi	sp,sp,16
8113f2f0:	f800283a 	ret

8113f2f4 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
8113f2f4:	defff204 	addi	sp,sp,-56
8113f2f8:	de00012e 	bgeu	sp,et,8113f300 <altera_avalon_jtag_uart_irq+0xc>
8113f2fc:	003b68fa 	trap	3
8113f300:	dfc00d15 	stw	ra,52(sp)
8113f304:	df000c15 	stw	fp,48(sp)
8113f308:	df000c04 	addi	fp,sp,48
8113f30c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
8113f310:	e0bfff17 	ldw	r2,-4(fp)
8113f314:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
8113f318:	e0bff617 	ldw	r2,-40(fp)
8113f31c:	10800017 	ldw	r2,0(r2)
8113f320:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
8113f324:	e0bff717 	ldw	r2,-36(fp)
8113f328:	e17ff617 	ldw	r5,-40(fp)
8113f32c:	1009883a 	mov	r4,r2
8113f330:	112fe7c0 	call	8112fe7c <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
8113f334:	e0bff717 	ldw	r2,-36(fp)
8113f338:	10800104 	addi	r2,r2,4
8113f33c:	10800037 	ldwio	r2,0(r2)
8113f340:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
8113f344:	e0bff817 	ldw	r2,-32(fp)
8113f348:	1080c00c 	andi	r2,r2,768
8113f34c:	10009126 	beq	r2,zero,8113f594 <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
8113f350:	e0bff817 	ldw	r2,-32(fp)
8113f354:	1080400c 	andi	r2,r2,256
8113f358:	10004726 	beq	r2,zero,8113f478 <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
8113f35c:	00800074 	movhi	r2,1
8113f360:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8113f364:	e0bff617 	ldw	r2,-40(fp)
8113f368:	10800d17 	ldw	r2,52(r2)
8113f36c:	10800044 	addi	r2,r2,1
8113f370:	1081ffcc 	andi	r2,r2,2047
8113f374:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
8113f378:	e0bff617 	ldw	r2,-40(fp)
8113f37c:	10c00e17 	ldw	r3,56(r2)
8113f380:	e0bff917 	ldw	r2,-28(fp)
8113f384:	18802726 	beq	r3,r2,8113f424 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
8113f388:	e0bff717 	ldw	r2,-36(fp)
8113f38c:	10800037 	ldwio	r2,0(r2)
8113f390:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
8113f394:	e0bff417 	ldw	r2,-48(fp)
8113f398:	10a0000c 	andi	r2,r2,32768
8113f39c:	10002326 	beq	r2,zero,8113f42c <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
8113f3a0:	e0bff617 	ldw	r2,-40(fp)
8113f3a4:	10800d17 	ldw	r2,52(r2)
8113f3a8:	e0fff417 	ldw	r3,-48(fp)
8113f3ac:	1809883a 	mov	r4,r3
8113f3b0:	e0fff617 	ldw	r3,-40(fp)
8113f3b4:	1885883a 	add	r2,r3,r2
8113f3b8:	10801104 	addi	r2,r2,68
8113f3bc:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8113f3c0:	e0bff617 	ldw	r2,-40(fp)
8113f3c4:	10800d17 	ldw	r2,52(r2)
8113f3c8:	10800044 	addi	r2,r2,1
8113f3cc:	10c1ffcc 	andi	r3,r2,2047
8113f3d0:	e0bff617 	ldw	r2,-40(fp)
8113f3d4:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
8113f3d8:	e0bff617 	ldw	r2,-40(fp)
8113f3dc:	10800c17 	ldw	r2,48(r2)
8113f3e0:	e0bffb15 	stw	r2,-20(fp)
8113f3e4:	00800044 	movi	r2,1
8113f3e8:	e0bffc0d 	sth	r2,-16(fp)
8113f3ec:	00800044 	movi	r2,1
8113f3f0:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8113f3f4:	d0a09003 	ldbu	r2,-32192(gp)
8113f3f8:	10803fcc 	andi	r2,r2,255
8113f3fc:	103fd926 	beq	r2,zero,8113f364 <__reset+0xfb11f364>
  {
    OSFlagPost (group, flags, opt, &err);
8113f400:	e0bffc0b 	ldhu	r2,-16(fp)
8113f404:	e0fffc83 	ldbu	r3,-14(fp)
8113f408:	e13ffdc4 	addi	r4,fp,-9
8113f40c:	200f883a 	mov	r7,r4
8113f410:	180d883a 	mov	r6,r3
8113f414:	100b883a 	mov	r5,r2
8113f418:	e13ffb17 	ldw	r4,-20(fp)
8113f41c:	1133f000 	call	81133f00 <OSFlagPost>
      }
8113f420:	003fd006 	br	8113f364 <__reset+0xfb11f364>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
8113f424:	0001883a 	nop
8113f428:	00000106 	br	8113f430 <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
8113f42c:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
8113f430:	e0bff417 	ldw	r2,-48(fp)
8113f434:	10bfffec 	andhi	r2,r2,65535
8113f438:	10000f26 	beq	r2,zero,8113f478 <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
8113f43c:	e0bff617 	ldw	r2,-40(fp)
8113f440:	10c00817 	ldw	r3,32(r2)
8113f444:	00bfff84 	movi	r2,-2
8113f448:	1886703a 	and	r3,r3,r2
8113f44c:	e0bff617 	ldw	r2,-40(fp)
8113f450:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
8113f454:	e0bff717 	ldw	r2,-36(fp)
8113f458:	10800104 	addi	r2,r2,4
8113f45c:	1007883a 	mov	r3,r2
8113f460:	e0bff617 	ldw	r2,-40(fp)
8113f464:	10800817 	ldw	r2,32(r2)
8113f468:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
8113f46c:	e0bff717 	ldw	r2,-36(fp)
8113f470:	10800104 	addi	r2,r2,4
8113f474:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
8113f478:	e0bff817 	ldw	r2,-32(fp)
8113f47c:	1080800c 	andi	r2,r2,512
8113f480:	103fac26 	beq	r2,zero,8113f334 <__reset+0xfb11f334>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
8113f484:	e0bff817 	ldw	r2,-32(fp)
8113f488:	1004d43a 	srli	r2,r2,16
8113f48c:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
8113f490:	00002606 	br	8113f52c <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
8113f494:	e0bff717 	ldw	r2,-36(fp)
8113f498:	e0fff617 	ldw	r3,-40(fp)
8113f49c:	18c01017 	ldw	r3,64(r3)
8113f4a0:	e13ff617 	ldw	r4,-40(fp)
8113f4a4:	20c7883a 	add	r3,r4,r3
8113f4a8:	18c21104 	addi	r3,r3,2116
8113f4ac:	18c00003 	ldbu	r3,0(r3)
8113f4b0:	18c03fcc 	andi	r3,r3,255
8113f4b4:	18c0201c 	xori	r3,r3,128
8113f4b8:	18ffe004 	addi	r3,r3,-128
8113f4bc:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8113f4c0:	e0bff617 	ldw	r2,-40(fp)
8113f4c4:	10801017 	ldw	r2,64(r2)
8113f4c8:	10800044 	addi	r2,r2,1
8113f4cc:	10c1ffcc 	andi	r3,r2,2047
8113f4d0:	e0bff617 	ldw	r2,-40(fp)
8113f4d4:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
8113f4d8:	e0bff617 	ldw	r2,-40(fp)
8113f4dc:	10800c17 	ldw	r2,48(r2)
8113f4e0:	e0bffa15 	stw	r2,-24(fp)
8113f4e4:	00800084 	movi	r2,2
8113f4e8:	e0bffd0d 	sth	r2,-12(fp)
8113f4ec:	00800044 	movi	r2,1
8113f4f0:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8113f4f4:	d0a09003 	ldbu	r2,-32192(gp)
8113f4f8:	10803fcc 	andi	r2,r2,255
8113f4fc:	10000826 	beq	r2,zero,8113f520 <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
8113f500:	e0bffd0b 	ldhu	r2,-12(fp)
8113f504:	e0fffd83 	ldbu	r3,-10(fp)
8113f508:	e13ffe04 	addi	r4,fp,-8
8113f50c:	200f883a 	mov	r7,r4
8113f510:	180d883a 	mov	r6,r3
8113f514:	100b883a 	mov	r5,r2
8113f518:	e13ffa17 	ldw	r4,-24(fp)
8113f51c:	1133f000 	call	81133f00 <OSFlagPost>

        space--;
8113f520:	e0bff517 	ldw	r2,-44(fp)
8113f524:	10bfffc4 	addi	r2,r2,-1
8113f528:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
8113f52c:	e0bff517 	ldw	r2,-44(fp)
8113f530:	10000526 	beq	r2,zero,8113f548 <altera_avalon_jtag_uart_irq+0x254>
8113f534:	e0bff617 	ldw	r2,-40(fp)
8113f538:	10c01017 	ldw	r3,64(r2)
8113f53c:	e0bff617 	ldw	r2,-40(fp)
8113f540:	10800f17 	ldw	r2,60(r2)
8113f544:	18bfd31e 	bne	r3,r2,8113f494 <__reset+0xfb11f494>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
8113f548:	e0bff517 	ldw	r2,-44(fp)
8113f54c:	103f7926 	beq	r2,zero,8113f334 <__reset+0xfb11f334>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
8113f550:	e0bff617 	ldw	r2,-40(fp)
8113f554:	10c00817 	ldw	r3,32(r2)
8113f558:	00bfff44 	movi	r2,-3
8113f55c:	1886703a 	and	r3,r3,r2
8113f560:	e0bff617 	ldw	r2,-40(fp)
8113f564:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
8113f568:	e0bff617 	ldw	r2,-40(fp)
8113f56c:	10800017 	ldw	r2,0(r2)
8113f570:	10800104 	addi	r2,r2,4
8113f574:	1007883a 	mov	r3,r2
8113f578:	e0bff617 	ldw	r2,-40(fp)
8113f57c:	10800817 	ldw	r2,32(r2)
8113f580:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
8113f584:	e0bff717 	ldw	r2,-36(fp)
8113f588:	10800104 	addi	r2,r2,4
8113f58c:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
8113f590:	003f6806 	br	8113f334 <__reset+0xfb11f334>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
8113f594:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
8113f598:	0001883a 	nop
8113f59c:	e037883a 	mov	sp,fp
8113f5a0:	dfc00117 	ldw	ra,4(sp)
8113f5a4:	df000017 	ldw	fp,0(sp)
8113f5a8:	dec00204 	addi	sp,sp,8
8113f5ac:	f800283a 	ret

8113f5b0 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
8113f5b0:	defff904 	addi	sp,sp,-28
8113f5b4:	de00012e 	bgeu	sp,et,8113f5bc <altera_avalon_jtag_uart_timeout+0xc>
8113f5b8:	003b68fa 	trap	3
8113f5bc:	dfc00615 	stw	ra,24(sp)
8113f5c0:	df000515 	stw	fp,20(sp)
8113f5c4:	df000504 	addi	fp,sp,20
8113f5c8:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
8113f5cc:	e0bfff17 	ldw	r2,-4(fp)
8113f5d0:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
8113f5d4:	e0bffb17 	ldw	r2,-20(fp)
8113f5d8:	10800017 	ldw	r2,0(r2)
8113f5dc:	10800104 	addi	r2,r2,4
8113f5e0:	10800037 	ldwio	r2,0(r2)
8113f5e4:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
8113f5e8:	e0bffc17 	ldw	r2,-16(fp)
8113f5ec:	1081000c 	andi	r2,r2,1024
8113f5f0:	10000b26 	beq	r2,zero,8113f620 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
8113f5f4:	e0bffb17 	ldw	r2,-20(fp)
8113f5f8:	10800017 	ldw	r2,0(r2)
8113f5fc:	10800104 	addi	r2,r2,4
8113f600:	1007883a 	mov	r3,r2
8113f604:	e0bffb17 	ldw	r2,-20(fp)
8113f608:	10800817 	ldw	r2,32(r2)
8113f60c:	10810014 	ori	r2,r2,1024
8113f610:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
8113f614:	e0bffb17 	ldw	r2,-20(fp)
8113f618:	10000915 	stw	zero,36(r2)
8113f61c:	00002106 	br	8113f6a4 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
8113f620:	e0bffb17 	ldw	r2,-20(fp)
8113f624:	10c00917 	ldw	r3,36(r2)
8113f628:	00a00034 	movhi	r2,32768
8113f62c:	10bfff04 	addi	r2,r2,-4
8113f630:	10c01c36 	bltu	r2,r3,8113f6a4 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
8113f634:	e0bffb17 	ldw	r2,-20(fp)
8113f638:	10800917 	ldw	r2,36(r2)
8113f63c:	10c00044 	addi	r3,r2,1
8113f640:	e0bffb17 	ldw	r2,-20(fp)
8113f644:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
8113f648:	e0bffb17 	ldw	r2,-20(fp)
8113f64c:	10c00917 	ldw	r3,36(r2)
8113f650:	e0bffb17 	ldw	r2,-20(fp)
8113f654:	10800117 	ldw	r2,4(r2)
8113f658:	18801236 	bltu	r3,r2,8113f6a4 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
8113f65c:	e0bffb17 	ldw	r2,-20(fp)
8113f660:	10800c17 	ldw	r2,48(r2)
8113f664:	e0bffd15 	stw	r2,-12(fp)
8113f668:	00800104 	movi	r2,4
8113f66c:	e0bffe0d 	sth	r2,-8(fp)
8113f670:	00800044 	movi	r2,1
8113f674:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8113f678:	d0a09003 	ldbu	r2,-32192(gp)
8113f67c:	10803fcc 	andi	r2,r2,255
8113f680:	10000826 	beq	r2,zero,8113f6a4 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
8113f684:	e0bffe0b 	ldhu	r2,-8(fp)
8113f688:	e0fffe83 	ldbu	r3,-6(fp)
8113f68c:	e13ffec4 	addi	r4,fp,-5
8113f690:	200f883a 	mov	r7,r4
8113f694:	180d883a 	mov	r6,r3
8113f698:	100b883a 	mov	r5,r2
8113f69c:	e13ffd17 	ldw	r4,-12(fp)
8113f6a0:	1133f000 	call	81133f00 <OSFlagPost>
8113f6a4:	d0a08717 	ldw	r2,-32228(gp)
    }
  }

  return alt_ticks_per_second();
}
8113f6a8:	e037883a 	mov	sp,fp
8113f6ac:	dfc00117 	ldw	ra,4(sp)
8113f6b0:	df000017 	ldw	fp,0(sp)
8113f6b4:	dec00204 	addi	sp,sp,8
8113f6b8:	f800283a 	ret

8113f6bc <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
8113f6bc:	defffd04 	addi	sp,sp,-12
8113f6c0:	de00012e 	bgeu	sp,et,8113f6c8 <altera_avalon_jtag_uart_close+0xc>
8113f6c4:	003b68fa 	trap	3
8113f6c8:	df000215 	stw	fp,8(sp)
8113f6cc:	df000204 	addi	fp,sp,8
8113f6d0:	e13ffe15 	stw	r4,-8(fp)
8113f6d4:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
8113f6d8:	00000506 	br	8113f6f0 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
8113f6dc:	e0bfff17 	ldw	r2,-4(fp)
8113f6e0:	1090000c 	andi	r2,r2,16384
8113f6e4:	10000226 	beq	r2,zero,8113f6f0 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
8113f6e8:	00bffd44 	movi	r2,-11
8113f6ec:	00000b06 	br	8113f71c <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
8113f6f0:	e0bffe17 	ldw	r2,-8(fp)
8113f6f4:	10c01017 	ldw	r3,64(r2)
8113f6f8:	e0bffe17 	ldw	r2,-8(fp)
8113f6fc:	10800f17 	ldw	r2,60(r2)
8113f700:	18800526 	beq	r3,r2,8113f718 <altera_avalon_jtag_uart_close+0x5c>
8113f704:	e0bffe17 	ldw	r2,-8(fp)
8113f708:	10c00917 	ldw	r3,36(r2)
8113f70c:	e0bffe17 	ldw	r2,-8(fp)
8113f710:	10800117 	ldw	r2,4(r2)
8113f714:	18bff136 	bltu	r3,r2,8113f6dc <__reset+0xfb11f6dc>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
8113f718:	0005883a 	mov	r2,zero
}
8113f71c:	e037883a 	mov	sp,fp
8113f720:	df000017 	ldw	fp,0(sp)
8113f724:	dec00104 	addi	sp,sp,4
8113f728:	f800283a 	ret

8113f72c <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
8113f72c:	defffa04 	addi	sp,sp,-24
8113f730:	de00012e 	bgeu	sp,et,8113f738 <altera_avalon_jtag_uart_ioctl+0xc>
8113f734:	003b68fa 	trap	3
8113f738:	df000515 	stw	fp,20(sp)
8113f73c:	df000504 	addi	fp,sp,20
8113f740:	e13ffd15 	stw	r4,-12(fp)
8113f744:	e17ffe15 	stw	r5,-8(fp)
8113f748:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
8113f74c:	00bff9c4 	movi	r2,-25
8113f750:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
8113f754:	e0bffe17 	ldw	r2,-8(fp)
8113f758:	10da8060 	cmpeqi	r3,r2,27137
8113f75c:	1800031e 	bne	r3,zero,8113f76c <altera_avalon_jtag_uart_ioctl+0x40>
8113f760:	109a80a0 	cmpeqi	r2,r2,27138
8113f764:	1000181e 	bne	r2,zero,8113f7c8 <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
8113f768:	00002906 	br	8113f810 <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
8113f76c:	e0bffd17 	ldw	r2,-12(fp)
8113f770:	10c00117 	ldw	r3,4(r2)
8113f774:	00a00034 	movhi	r2,32768
8113f778:	10bfffc4 	addi	r2,r2,-1
8113f77c:	18802126 	beq	r3,r2,8113f804 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
8113f780:	e0bfff17 	ldw	r2,-4(fp)
8113f784:	10800017 	ldw	r2,0(r2)
8113f788:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
8113f78c:	e0bffc17 	ldw	r2,-16(fp)
8113f790:	10800090 	cmplti	r2,r2,2
8113f794:	1000061e 	bne	r2,zero,8113f7b0 <altera_avalon_jtag_uart_ioctl+0x84>
8113f798:	e0fffc17 	ldw	r3,-16(fp)
8113f79c:	00a00034 	movhi	r2,32768
8113f7a0:	10bfffc4 	addi	r2,r2,-1
8113f7a4:	18800226 	beq	r3,r2,8113f7b0 <altera_avalon_jtag_uart_ioctl+0x84>
8113f7a8:	e0bffc17 	ldw	r2,-16(fp)
8113f7ac:	00000206 	br	8113f7b8 <altera_avalon_jtag_uart_ioctl+0x8c>
8113f7b0:	00a00034 	movhi	r2,32768
8113f7b4:	10bfff84 	addi	r2,r2,-2
8113f7b8:	e0fffd17 	ldw	r3,-12(fp)
8113f7bc:	18800115 	stw	r2,4(r3)
      rc = 0;
8113f7c0:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
8113f7c4:	00000f06 	br	8113f804 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
8113f7c8:	e0bffd17 	ldw	r2,-12(fp)
8113f7cc:	10c00117 	ldw	r3,4(r2)
8113f7d0:	00a00034 	movhi	r2,32768
8113f7d4:	10bfffc4 	addi	r2,r2,-1
8113f7d8:	18800c26 	beq	r3,r2,8113f80c <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
8113f7dc:	e0bffd17 	ldw	r2,-12(fp)
8113f7e0:	10c00917 	ldw	r3,36(r2)
8113f7e4:	e0bffd17 	ldw	r2,-12(fp)
8113f7e8:	10800117 	ldw	r2,4(r2)
8113f7ec:	1885803a 	cmpltu	r2,r3,r2
8113f7f0:	10c03fcc 	andi	r3,r2,255
8113f7f4:	e0bfff17 	ldw	r2,-4(fp)
8113f7f8:	10c00015 	stw	r3,0(r2)
      rc = 0;
8113f7fc:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
8113f800:	00000206 	br	8113f80c <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
8113f804:	0001883a 	nop
8113f808:	00000106 	br	8113f810 <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
8113f80c:	0001883a 	nop

  default:
    break;
  }

  return rc;
8113f810:	e0bffb17 	ldw	r2,-20(fp)
}
8113f814:	e037883a 	mov	sp,fp
8113f818:	df000017 	ldw	fp,0(sp)
8113f81c:	dec00104 	addi	sp,sp,4
8113f820:	f800283a 	ret

8113f824 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
8113f824:	deffed04 	addi	sp,sp,-76
8113f828:	de00012e 	bgeu	sp,et,8113f830 <altera_avalon_jtag_uart_read+0xc>
8113f82c:	003b68fa 	trap	3
8113f830:	dfc01215 	stw	ra,72(sp)
8113f834:	df001115 	stw	fp,68(sp)
8113f838:	df001104 	addi	fp,sp,68
8113f83c:	e13ffc15 	stw	r4,-16(fp)
8113f840:	e17ffd15 	stw	r5,-12(fp)
8113f844:	e1bffe15 	stw	r6,-8(fp)
8113f848:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
8113f84c:	e0bffd17 	ldw	r2,-12(fp)
8113f850:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
8113f854:	e0bffc17 	ldw	r2,-16(fp)
8113f858:	10800a17 	ldw	r2,40(r2)
8113f85c:	e0bff815 	stw	r2,-32(fp)
8113f860:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8113f864:	e0bff90b 	ldhu	r2,-28(fp)
8113f868:	e0fffb04 	addi	r3,fp,-20
8113f86c:	180d883a 	mov	r6,r3
8113f870:	100b883a 	mov	r5,r2
8113f874:	e13ff817 	ldw	r4,-32(fp)
8113f878:	11375780 	call	81137578 <OSSemPend>

  while (space > 0)
8113f87c:	00006106 	br	8113fa04 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
8113f880:	e0bffc17 	ldw	r2,-16(fp)
8113f884:	10800d17 	ldw	r2,52(r2)
8113f888:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
8113f88c:	e0bffc17 	ldw	r2,-16(fp)
8113f890:	10800e17 	ldw	r2,56(r2)
8113f894:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
8113f898:	e0fff317 	ldw	r3,-52(fp)
8113f89c:	e0bff417 	ldw	r2,-48(fp)
8113f8a0:	18800536 	bltu	r3,r2,8113f8b8 <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
8113f8a4:	e0fff317 	ldw	r3,-52(fp)
8113f8a8:	e0bff417 	ldw	r2,-48(fp)
8113f8ac:	1885c83a 	sub	r2,r3,r2
8113f8b0:	e0bff115 	stw	r2,-60(fp)
8113f8b4:	00000406 	br	8113f8c8 <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
8113f8b8:	00c20004 	movi	r3,2048
8113f8bc:	e0bff417 	ldw	r2,-48(fp)
8113f8c0:	1885c83a 	sub	r2,r3,r2
8113f8c4:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
8113f8c8:	e0bff117 	ldw	r2,-60(fp)
8113f8cc:	10001e26 	beq	r2,zero,8113f948 <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
8113f8d0:	e0fffe17 	ldw	r3,-8(fp)
8113f8d4:	e0bff117 	ldw	r2,-60(fp)
8113f8d8:	1880022e 	bgeu	r3,r2,8113f8e4 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
8113f8dc:	e0bffe17 	ldw	r2,-8(fp)
8113f8e0:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
8113f8e4:	e0bffc17 	ldw	r2,-16(fp)
8113f8e8:	10c01104 	addi	r3,r2,68
8113f8ec:	e0bff417 	ldw	r2,-48(fp)
8113f8f0:	1885883a 	add	r2,r3,r2
8113f8f4:	e1bff117 	ldw	r6,-60(fp)
8113f8f8:	100b883a 	mov	r5,r2
8113f8fc:	e13ff017 	ldw	r4,-64(fp)
8113f900:	111abac0 	call	8111abac <memcpy>
      ptr   += n;
8113f904:	e0fff017 	ldw	r3,-64(fp)
8113f908:	e0bff117 	ldw	r2,-60(fp)
8113f90c:	1885883a 	add	r2,r3,r2
8113f910:	e0bff015 	stw	r2,-64(fp)
      space -= n;
8113f914:	e0fffe17 	ldw	r3,-8(fp)
8113f918:	e0bff117 	ldw	r2,-60(fp)
8113f91c:	1885c83a 	sub	r2,r3,r2
8113f920:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8113f924:	e0fff417 	ldw	r3,-48(fp)
8113f928:	e0bff117 	ldw	r2,-60(fp)
8113f92c:	1885883a 	add	r2,r3,r2
8113f930:	10c1ffcc 	andi	r3,r2,2047
8113f934:	e0bffc17 	ldw	r2,-16(fp)
8113f938:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
8113f93c:	e0bffe17 	ldw	r2,-8(fp)
8113f940:	00bfcf16 	blt	zero,r2,8113f880 <__reset+0xfb11f880>
8113f944:	00000106 	br	8113f94c <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
8113f948:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
8113f94c:	e0fff017 	ldw	r3,-64(fp)
8113f950:	e0bffd17 	ldw	r2,-12(fp)
8113f954:	18802e1e 	bne	r3,r2,8113fa10 <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
8113f958:	e0bfff17 	ldw	r2,-4(fp)
8113f95c:	1090000c 	andi	r2,r2,16384
8113f960:	10002d1e 	bne	r2,zero,8113fa18 <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
8113f964:	d0a09003 	ldbu	r2,-32192(gp)
8113f968:	10803fcc 	andi	r2,r2,255
8113f96c:	10800058 	cmpnei	r2,r2,1
8113f970:	1000161e 	bne	r2,zero,8113f9cc <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
8113f974:	e0bffc17 	ldw	r2,-16(fp)
8113f978:	10800c17 	ldw	r2,48(r2)
8113f97c:	e0bff215 	stw	r2,-56(fp)
8113f980:	00800144 	movi	r2,5
8113f984:	e0bff98d 	sth	r2,-26(fp)
8113f988:	00bfe0c4 	movi	r2,-125
8113f98c:	e0bffa05 	stb	r2,-24(fp)
8113f990:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
8113f994:	d0a09003 	ldbu	r2,-32192(gp)
8113f998:	10803fcc 	andi	r2,r2,255
8113f99c:	10001526 	beq	r2,zero,8113f9f4 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
8113f9a0:	e0fff98b 	ldhu	r3,-26(fp)
8113f9a4:	e13ffa03 	ldbu	r4,-24(fp)
8113f9a8:	e17ffa8b 	ldhu	r5,-22(fp)
8113f9ac:	e0bffb44 	addi	r2,fp,-19
8113f9b0:	d8800015 	stw	r2,0(sp)
8113f9b4:	280f883a 	mov	r7,r5
8113f9b8:	200d883a 	mov	r6,r4
8113f9bc:	180b883a 	mov	r5,r3
8113f9c0:	e13ff217 	ldw	r4,-56(fp)
8113f9c4:	11338d80 	call	811338d8 <OSFlagPend>
8113f9c8:	00000a06 	br	8113f9f4 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
8113f9cc:	0001883a 	nop
8113f9d0:	e0bffc17 	ldw	r2,-16(fp)
8113f9d4:	10c00d17 	ldw	r3,52(r2)
8113f9d8:	e0bff317 	ldw	r2,-52(fp)
8113f9dc:	1880051e 	bne	r3,r2,8113f9f4 <altera_avalon_jtag_uart_read+0x1d0>
8113f9e0:	e0bffc17 	ldw	r2,-16(fp)
8113f9e4:	10c00917 	ldw	r3,36(r2)
8113f9e8:	e0bffc17 	ldw	r2,-16(fp)
8113f9ec:	10800117 	ldw	r2,4(r2)
8113f9f0:	18bff736 	bltu	r3,r2,8113f9d0 <__reset+0xfb11f9d0>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
8113f9f4:	e0bffc17 	ldw	r2,-16(fp)
8113f9f8:	10c00d17 	ldw	r3,52(r2)
8113f9fc:	e0bff317 	ldw	r2,-52(fp)
8113fa00:	18800726 	beq	r3,r2,8113fa20 <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
8113fa04:	e0bffe17 	ldw	r2,-8(fp)
8113fa08:	00bf9d16 	blt	zero,r2,8113f880 <__reset+0xfb11f880>
8113fa0c:	00000506 	br	8113fa24 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
8113fa10:	0001883a 	nop
8113fa14:	00000306 	br	8113fa24 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
8113fa18:	0001883a 	nop
8113fa1c:	00000106 	br	8113fa24 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
8113fa20:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
8113fa24:	e0bffc17 	ldw	r2,-16(fp)
8113fa28:	10800a17 	ldw	r2,40(r2)
8113fa2c:	1009883a 	mov	r4,r2
8113fa30:	11379000 	call	81137900 <OSSemPost>

  if (ptr != buffer)
8113fa34:	e0fff017 	ldw	r3,-64(fp)
8113fa38:	e0bffd17 	ldw	r2,-12(fp)
8113fa3c:	18801826 	beq	r3,r2,8113faa0 <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fa40:	0005303a 	rdctl	r2,status
8113fa44:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fa48:	e0fff717 	ldw	r3,-36(fp)
8113fa4c:	00bfff84 	movi	r2,-2
8113fa50:	1884703a 	and	r2,r3,r2
8113fa54:	1001703a 	wrctl	status,r2
  
  return context;
8113fa58:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
8113fa5c:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
8113fa60:	e0bffc17 	ldw	r2,-16(fp)
8113fa64:	10800817 	ldw	r2,32(r2)
8113fa68:	10c00054 	ori	r3,r2,1
8113fa6c:	e0bffc17 	ldw	r2,-16(fp)
8113fa70:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
8113fa74:	e0bffc17 	ldw	r2,-16(fp)
8113fa78:	10800017 	ldw	r2,0(r2)
8113fa7c:	10800104 	addi	r2,r2,4
8113fa80:	1007883a 	mov	r3,r2
8113fa84:	e0bffc17 	ldw	r2,-16(fp)
8113fa88:	10800817 	ldw	r2,32(r2)
8113fa8c:	18800035 	stwio	r2,0(r3)
8113fa90:	e0bff617 	ldw	r2,-40(fp)
8113fa94:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fa98:	e0bff517 	ldw	r2,-44(fp)
8113fa9c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
8113faa0:	e0fff017 	ldw	r3,-64(fp)
8113faa4:	e0bffd17 	ldw	r2,-12(fp)
8113faa8:	18800426 	beq	r3,r2,8113fabc <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
8113faac:	e0fff017 	ldw	r3,-64(fp)
8113fab0:	e0bffd17 	ldw	r2,-12(fp)
8113fab4:	1885c83a 	sub	r2,r3,r2
8113fab8:	00000606 	br	8113fad4 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
8113fabc:	e0bfff17 	ldw	r2,-4(fp)
8113fac0:	1090000c 	andi	r2,r2,16384
8113fac4:	10000226 	beq	r2,zero,8113fad0 <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
8113fac8:	00bffd44 	movi	r2,-11
8113facc:	00000106 	br	8113fad4 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
8113fad0:	00bffec4 	movi	r2,-5
}
8113fad4:	e037883a 	mov	sp,fp
8113fad8:	dfc00117 	ldw	ra,4(sp)
8113fadc:	df000017 	ldw	fp,0(sp)
8113fae0:	dec00204 	addi	sp,sp,8
8113fae4:	f800283a 	ret

8113fae8 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
8113fae8:	deffed04 	addi	sp,sp,-76
8113faec:	de00012e 	bgeu	sp,et,8113faf4 <altera_avalon_jtag_uart_write+0xc>
8113faf0:	003b68fa 	trap	3
8113faf4:	dfc01215 	stw	ra,72(sp)
8113faf8:	df001115 	stw	fp,68(sp)
8113fafc:	df001104 	addi	fp,sp,68
8113fb00:	e13ffc15 	stw	r4,-16(fp)
8113fb04:	e17ffd15 	stw	r5,-12(fp)
8113fb08:	e1bffe15 	stw	r6,-8(fp)
8113fb0c:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
8113fb10:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
8113fb14:	e0bffd17 	ldw	r2,-12(fp)
8113fb18:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
8113fb1c:	e0bffc17 	ldw	r2,-16(fp)
8113fb20:	10800b17 	ldw	r2,44(r2)
8113fb24:	e0bff815 	stw	r2,-32(fp)
8113fb28:	e03ff90d 	sth	zero,-28(fp)
8113fb2c:	e0bff90b 	ldhu	r2,-28(fp)
8113fb30:	e0fffb44 	addi	r3,fp,-19
8113fb34:	180d883a 	mov	r6,r3
8113fb38:	100b883a 	mov	r5,r2
8113fb3c:	e13ff817 	ldw	r4,-32(fp)
8113fb40:	11375780 	call	81137578 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
8113fb44:	00003706 	br	8113fc24 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
8113fb48:	e0bffc17 	ldw	r2,-16(fp)
8113fb4c:	10800f17 	ldw	r2,60(r2)
8113fb50:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
8113fb54:	e0bffc17 	ldw	r2,-16(fp)
8113fb58:	10801017 	ldw	r2,64(r2)
8113fb5c:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
8113fb60:	e0fff417 	ldw	r3,-48(fp)
8113fb64:	e0bff017 	ldw	r2,-64(fp)
8113fb68:	1880062e 	bgeu	r3,r2,8113fb84 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
8113fb6c:	e0fff017 	ldw	r3,-64(fp)
8113fb70:	e0bff417 	ldw	r2,-48(fp)
8113fb74:	1885c83a 	sub	r2,r3,r2
8113fb78:	10bfffc4 	addi	r2,r2,-1
8113fb7c:	e0bff115 	stw	r2,-60(fp)
8113fb80:	00000b06 	br	8113fbb0 <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
8113fb84:	e0bff017 	ldw	r2,-64(fp)
8113fb88:	10000526 	beq	r2,zero,8113fba0 <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
8113fb8c:	00c20004 	movi	r3,2048
8113fb90:	e0bff417 	ldw	r2,-48(fp)
8113fb94:	1885c83a 	sub	r2,r3,r2
8113fb98:	e0bff115 	stw	r2,-60(fp)
8113fb9c:	00000406 	br	8113fbb0 <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
8113fba0:	00c1ffc4 	movi	r3,2047
8113fba4:	e0bff417 	ldw	r2,-48(fp)
8113fba8:	1885c83a 	sub	r2,r3,r2
8113fbac:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
8113fbb0:	e0bff117 	ldw	r2,-60(fp)
8113fbb4:	10001e26 	beq	r2,zero,8113fc30 <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
8113fbb8:	e0fffe17 	ldw	r3,-8(fp)
8113fbbc:	e0bff117 	ldw	r2,-60(fp)
8113fbc0:	1880022e 	bgeu	r3,r2,8113fbcc <altera_avalon_jtag_uart_write+0xe4>
        n = count;
8113fbc4:	e0bffe17 	ldw	r2,-8(fp)
8113fbc8:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
8113fbcc:	e0bffc17 	ldw	r2,-16(fp)
8113fbd0:	10c21104 	addi	r3,r2,2116
8113fbd4:	e0bff417 	ldw	r2,-48(fp)
8113fbd8:	1885883a 	add	r2,r3,r2
8113fbdc:	e1bff117 	ldw	r6,-60(fp)
8113fbe0:	e17ffd17 	ldw	r5,-12(fp)
8113fbe4:	1009883a 	mov	r4,r2
8113fbe8:	111abac0 	call	8111abac <memcpy>
      ptr   += n;
8113fbec:	e0fffd17 	ldw	r3,-12(fp)
8113fbf0:	e0bff117 	ldw	r2,-60(fp)
8113fbf4:	1885883a 	add	r2,r3,r2
8113fbf8:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
8113fbfc:	e0fffe17 	ldw	r3,-8(fp)
8113fc00:	e0bff117 	ldw	r2,-60(fp)
8113fc04:	1885c83a 	sub	r2,r3,r2
8113fc08:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8113fc0c:	e0fff417 	ldw	r3,-48(fp)
8113fc10:	e0bff117 	ldw	r2,-60(fp)
8113fc14:	1885883a 	add	r2,r3,r2
8113fc18:	10c1ffcc 	andi	r3,r2,2047
8113fc1c:	e0bffc17 	ldw	r2,-16(fp)
8113fc20:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
8113fc24:	e0bffe17 	ldw	r2,-8(fp)
8113fc28:	00bfc716 	blt	zero,r2,8113fb48 <__reset+0xfb11fb48>
8113fc2c:	00000106 	br	8113fc34 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
8113fc30:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fc34:	0005303a 	rdctl	r2,status
8113fc38:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fc3c:	e0fff717 	ldw	r3,-36(fp)
8113fc40:	00bfff84 	movi	r2,-2
8113fc44:	1884703a 	and	r2,r3,r2
8113fc48:	1001703a 	wrctl	status,r2
  
  return context;
8113fc4c:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
8113fc50:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
8113fc54:	e0bffc17 	ldw	r2,-16(fp)
8113fc58:	10800817 	ldw	r2,32(r2)
8113fc5c:	10c00094 	ori	r3,r2,2
8113fc60:	e0bffc17 	ldw	r2,-16(fp)
8113fc64:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
8113fc68:	e0bffc17 	ldw	r2,-16(fp)
8113fc6c:	10800017 	ldw	r2,0(r2)
8113fc70:	10800104 	addi	r2,r2,4
8113fc74:	1007883a 	mov	r3,r2
8113fc78:	e0bffc17 	ldw	r2,-16(fp)
8113fc7c:	10800817 	ldw	r2,32(r2)
8113fc80:	18800035 	stwio	r2,0(r3)
8113fc84:	e0bff617 	ldw	r2,-40(fp)
8113fc88:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fc8c:	e0bff317 	ldw	r2,-52(fp)
8113fc90:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
8113fc94:	e0bffe17 	ldw	r2,-8(fp)
8113fc98:	00802a0e 	bge	zero,r2,8113fd44 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
8113fc9c:	e0bfff17 	ldw	r2,-4(fp)
8113fca0:	1090000c 	andi	r2,r2,16384
8113fca4:	10002a1e 	bne	r2,zero,8113fd50 <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
8113fca8:	d0a09003 	ldbu	r2,-32192(gp)
8113fcac:	10803fcc 	andi	r2,r2,255
8113fcb0:	10800058 	cmpnei	r2,r2,1
8113fcb4:	1000161e 	bne	r2,zero,8113fd10 <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
8113fcb8:	e0bffc17 	ldw	r2,-16(fp)
8113fcbc:	10800c17 	ldw	r2,48(r2)
8113fcc0:	e0bff515 	stw	r2,-44(fp)
8113fcc4:	00800184 	movi	r2,6
8113fcc8:	e0bff98d 	sth	r2,-26(fp)
8113fccc:	00bfe0c4 	movi	r2,-125
8113fcd0:	e0bffa05 	stb	r2,-24(fp)
8113fcd4:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
8113fcd8:	d0a09003 	ldbu	r2,-32192(gp)
8113fcdc:	10803fcc 	andi	r2,r2,255
8113fce0:	10001526 	beq	r2,zero,8113fd38 <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
8113fce4:	e0fff98b 	ldhu	r3,-26(fp)
8113fce8:	e13ffa03 	ldbu	r4,-24(fp)
8113fcec:	e17ffa8b 	ldhu	r5,-22(fp)
8113fcf0:	e0bffb04 	addi	r2,fp,-20
8113fcf4:	d8800015 	stw	r2,0(sp)
8113fcf8:	280f883a 	mov	r7,r5
8113fcfc:	200d883a 	mov	r6,r4
8113fd00:	180b883a 	mov	r5,r3
8113fd04:	e13ff517 	ldw	r4,-44(fp)
8113fd08:	11338d80 	call	811338d8 <OSFlagPend>
8113fd0c:	00000a06 	br	8113fd38 <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
8113fd10:	0001883a 	nop
8113fd14:	e0bffc17 	ldw	r2,-16(fp)
8113fd18:	10c01017 	ldw	r3,64(r2)
8113fd1c:	e0bff017 	ldw	r2,-64(fp)
8113fd20:	1880051e 	bne	r3,r2,8113fd38 <altera_avalon_jtag_uart_write+0x250>
8113fd24:	e0bffc17 	ldw	r2,-16(fp)
8113fd28:	10c00917 	ldw	r3,36(r2)
8113fd2c:	e0bffc17 	ldw	r2,-16(fp)
8113fd30:	10800117 	ldw	r2,4(r2)
8113fd34:	18bff736 	bltu	r3,r2,8113fd14 <__reset+0xfb11fd14>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
8113fd38:	e0bffc17 	ldw	r2,-16(fp)
8113fd3c:	10800917 	ldw	r2,36(r2)
8113fd40:	1000051e 	bne	r2,zero,8113fd58 <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
8113fd44:	e0bffe17 	ldw	r2,-8(fp)
8113fd48:	00bfb616 	blt	zero,r2,8113fc24 <__reset+0xfb11fc24>
8113fd4c:	00000306 	br	8113fd5c <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
8113fd50:	0001883a 	nop
8113fd54:	00000106 	br	8113fd5c <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
8113fd58:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
8113fd5c:	e0bffc17 	ldw	r2,-16(fp)
8113fd60:	10800b17 	ldw	r2,44(r2)
8113fd64:	1009883a 	mov	r4,r2
8113fd68:	11379000 	call	81137900 <OSSemPost>

  if (ptr != start)
8113fd6c:	e0fffd17 	ldw	r3,-12(fp)
8113fd70:	e0bff217 	ldw	r2,-56(fp)
8113fd74:	18800426 	beq	r3,r2,8113fd88 <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
8113fd78:	e0fffd17 	ldw	r3,-12(fp)
8113fd7c:	e0bff217 	ldw	r2,-56(fp)
8113fd80:	1885c83a 	sub	r2,r3,r2
8113fd84:	00000606 	br	8113fda0 <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
8113fd88:	e0bfff17 	ldw	r2,-4(fp)
8113fd8c:	1090000c 	andi	r2,r2,16384
8113fd90:	10000226 	beq	r2,zero,8113fd9c <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
8113fd94:	00bffd44 	movi	r2,-11
8113fd98:	00000106 	br	8113fda0 <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
8113fd9c:	00bffec4 	movi	r2,-5
}
8113fda0:	e037883a 	mov	sp,fp
8113fda4:	dfc00117 	ldw	ra,4(sp)
8113fda8:	df000017 	ldw	fp,0(sp)
8113fdac:	dec00204 	addi	sp,sp,8
8113fdb0:	f800283a 	ret

8113fdb4 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
8113fdb4:	defffa04 	addi	sp,sp,-24
8113fdb8:	de00012e 	bgeu	sp,et,8113fdc0 <alt_avalon_timer_sc_irq+0xc>
8113fdbc:	003b68fa 	trap	3
8113fdc0:	dfc00515 	stw	ra,20(sp)
8113fdc4:	df000415 	stw	fp,16(sp)
8113fdc8:	df000404 	addi	fp,sp,16
8113fdcc:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
8113fdd0:	0007883a 	mov	r3,zero
8113fdd4:	e0bfff17 	ldw	r2,-4(fp)
8113fdd8:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
8113fddc:	e0bfff17 	ldw	r2,-4(fp)
8113fde0:	10800104 	addi	r2,r2,4
8113fde4:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
8113fde8:	11300200 	call	81130020 <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113fdec:	0005303a 	rdctl	r2,status
8113fdf0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113fdf4:	e0fffd17 	ldw	r3,-12(fp)
8113fdf8:	00bfff84 	movi	r2,-2
8113fdfc:	1884703a 	and	r2,r3,r2
8113fe00:	1001703a 	wrctl	status,r2
  
  return context;
8113fe04:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
8113fe08:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
8113fe0c:	11306640 	call	81130664 <alt_tick>
8113fe10:	e0bffc17 	ldw	r2,-16(fp)
8113fe14:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113fe18:	e0bffe17 	ldw	r2,-8(fp)
8113fe1c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
8113fe20:	0001883a 	nop
8113fe24:	e037883a 	mov	sp,fp
8113fe28:	dfc00117 	ldw	ra,4(sp)
8113fe2c:	df000017 	ldw	fp,0(sp)
8113fe30:	dec00204 	addi	sp,sp,8
8113fe34:	f800283a 	ret

8113fe38 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
8113fe38:	defff804 	addi	sp,sp,-32
8113fe3c:	de00012e 	bgeu	sp,et,8113fe44 <alt_avalon_timer_sc_init+0xc>
8113fe40:	003b68fa 	trap	3
8113fe44:	dfc00715 	stw	ra,28(sp)
8113fe48:	df000615 	stw	fp,24(sp)
8113fe4c:	df000604 	addi	fp,sp,24
8113fe50:	e13ffc15 	stw	r4,-16(fp)
8113fe54:	e17ffd15 	stw	r5,-12(fp)
8113fe58:	e1bffe15 	stw	r6,-8(fp)
8113fe5c:	e1ffff15 	stw	r7,-4(fp)
8113fe60:	e0bfff17 	ldw	r2,-4(fp)
8113fe64:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
8113fe68:	d0a08717 	ldw	r2,-32228(gp)
8113fe6c:	1000021e 	bne	r2,zero,8113fe78 <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
8113fe70:	e0bffb17 	ldw	r2,-20(fp)
8113fe74:	d0a08715 	stw	r2,-32228(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
8113fe78:	e0bffc17 	ldw	r2,-16(fp)
8113fe7c:	10800104 	addi	r2,r2,4
8113fe80:	00c001c4 	movi	r3,7
8113fe84:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
8113fe88:	d8000015 	stw	zero,0(sp)
8113fe8c:	e1fffc17 	ldw	r7,-16(fp)
8113fe90:	01a04534 	movhi	r6,33044
8113fe94:	31bf6d04 	addi	r6,r6,-588
8113fe98:	e17ffe17 	ldw	r5,-8(fp)
8113fe9c:	e13ffd17 	ldw	r4,-12(fp)
8113fea0:	1142e480 	call	81142e48 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
8113fea4:	0001883a 	nop
8113fea8:	e037883a 	mov	sp,fp
8113feac:	dfc00117 	ldw	ra,4(sp)
8113feb0:	df000017 	ldw	fp,0(sp)
8113feb4:	dec00204 	addi	sp,sp,8
8113feb8:	f800283a 	ret

8113febc <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
8113febc:	defffa04 	addi	sp,sp,-24
8113fec0:	de00012e 	bgeu	sp,et,8113fec8 <altera_avalon_uart_read_fd+0xc>
8113fec4:	003b68fa 	trap	3
8113fec8:	dfc00515 	stw	ra,20(sp)
8113fecc:	df000415 	stw	fp,16(sp)
8113fed0:	df000404 	addi	fp,sp,16
8113fed4:	e13ffd15 	stw	r4,-12(fp)
8113fed8:	e17ffe15 	stw	r5,-8(fp)
8113fedc:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8113fee0:	e0bffd17 	ldw	r2,-12(fp)
8113fee4:	10800017 	ldw	r2,0(r2)
8113fee8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
8113feec:	e0bffc17 	ldw	r2,-16(fp)
8113fef0:	10c00a04 	addi	r3,r2,40
8113fef4:	e0bffd17 	ldw	r2,-12(fp)
8113fef8:	10800217 	ldw	r2,8(r2)
8113fefc:	100f883a 	mov	r7,r2
8113ff00:	e1bfff17 	ldw	r6,-4(fp)
8113ff04:	e17ffe17 	ldw	r5,-8(fp)
8113ff08:	1809883a 	mov	r4,r3
8113ff0c:	114057c0 	call	8114057c <altera_avalon_uart_read>
      fd->fd_flags);
}
8113ff10:	e037883a 	mov	sp,fp
8113ff14:	dfc00117 	ldw	ra,4(sp)
8113ff18:	df000017 	ldw	fp,0(sp)
8113ff1c:	dec00204 	addi	sp,sp,8
8113ff20:	f800283a 	ret

8113ff24 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
8113ff24:	defffa04 	addi	sp,sp,-24
8113ff28:	de00012e 	bgeu	sp,et,8113ff30 <altera_avalon_uart_write_fd+0xc>
8113ff2c:	003b68fa 	trap	3
8113ff30:	dfc00515 	stw	ra,20(sp)
8113ff34:	df000415 	stw	fp,16(sp)
8113ff38:	df000404 	addi	fp,sp,16
8113ff3c:	e13ffd15 	stw	r4,-12(fp)
8113ff40:	e17ffe15 	stw	r5,-8(fp)
8113ff44:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8113ff48:	e0bffd17 	ldw	r2,-12(fp)
8113ff4c:	10800017 	ldw	r2,0(r2)
8113ff50:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
8113ff54:	e0bffc17 	ldw	r2,-16(fp)
8113ff58:	10c00a04 	addi	r3,r2,40
8113ff5c:	e0bffd17 	ldw	r2,-12(fp)
8113ff60:	10800217 	ldw	r2,8(r2)
8113ff64:	100f883a 	mov	r7,r2
8113ff68:	e1bfff17 	ldw	r6,-4(fp)
8113ff6c:	e17ffe17 	ldw	r5,-8(fp)
8113ff70:	1809883a 	mov	r4,r3
8113ff74:	11408300 	call	81140830 <altera_avalon_uart_write>
      fd->fd_flags);
}
8113ff78:	e037883a 	mov	sp,fp
8113ff7c:	dfc00117 	ldw	ra,4(sp)
8113ff80:	df000017 	ldw	fp,0(sp)
8113ff84:	dec00204 	addi	sp,sp,8
8113ff88:	f800283a 	ret

8113ff8c <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
8113ff8c:	defffc04 	addi	sp,sp,-16
8113ff90:	de00012e 	bgeu	sp,et,8113ff98 <altera_avalon_uart_close_fd+0xc>
8113ff94:	003b68fa 	trap	3
8113ff98:	dfc00315 	stw	ra,12(sp)
8113ff9c:	df000215 	stw	fp,8(sp)
8113ffa0:	df000204 	addi	fp,sp,8
8113ffa4:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8113ffa8:	e0bfff17 	ldw	r2,-4(fp)
8113ffac:	10800017 	ldw	r2,0(r2)
8113ffb0:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
8113ffb4:	e0bffe17 	ldw	r2,-8(fp)
8113ffb8:	10c00a04 	addi	r3,r2,40
8113ffbc:	e0bfff17 	ldw	r2,-4(fp)
8113ffc0:	10800217 	ldw	r2,8(r2)
8113ffc4:	100b883a 	mov	r5,r2
8113ffc8:	1809883a 	mov	r4,r3
8113ffcc:	11404dc0 	call	811404dc <altera_avalon_uart_close>
}
8113ffd0:	e037883a 	mov	sp,fp
8113ffd4:	dfc00117 	ldw	ra,4(sp)
8113ffd8:	df000017 	ldw	fp,0(sp)
8113ffdc:	dec00204 	addi	sp,sp,8
8113ffe0:	f800283a 	ret

8113ffe4 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
8113ffe4:	defff304 	addi	sp,sp,-52
8113ffe8:	de00012e 	bgeu	sp,et,8113fff0 <altera_avalon_uart_init+0xc>
8113ffec:	003b68fa 	trap	3
8113fff0:	dfc00c15 	stw	ra,48(sp)
8113fff4:	df000b15 	stw	fp,44(sp)
8113fff8:	df000b04 	addi	fp,sp,44
8113fffc:	e13ffd15 	stw	r4,-12(fp)
81140000:	e17ffe15 	stw	r5,-8(fp)
81140004:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
81140008:	e0bffd17 	ldw	r2,-12(fp)
8114000c:	10800017 	ldw	r2,0(r2)
81140010:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81140014:	e0bffd17 	ldw	r2,-12(fp)
81140018:	10800704 	addi	r2,r2,28
8114001c:	e0bffa15 	stw	r2,-24(fp)
81140020:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81140024:	e0bffb0b 	ldhu	r2,-20(fp)
81140028:	e0fffc84 	addi	r3,fp,-14
8114002c:	180b883a 	mov	r5,r3
81140030:	1009883a 	mov	r4,r2
81140034:	11332f40 	call	811332f4 <OSFlagCreate>
81140038:	1007883a 	mov	r3,r2
8114003c:	e0bffa17 	ldw	r2,-24(fp)
81140040:	10c00015 	stw	r3,0(r2)
  return err;
81140044:	e0bffc83 	ldbu	r2,-14(fp)
81140048:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
8114004c:	1000241e 	bne	r2,zero,811400e0 <altera_avalon_uart_init+0xfc>
81140050:	e0bffd17 	ldw	r2,-12(fp)
81140054:	10800804 	addi	r2,r2,32
81140058:	e0bff715 	stw	r2,-36(fp)
8114005c:	00800044 	movi	r2,1
81140060:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81140064:	e0bffb8b 	ldhu	r2,-18(fp)
81140068:	1009883a 	mov	r4,r2
8114006c:	11372500 	call	81137250 <OSSemCreate>
81140070:	1007883a 	mov	r3,r2
81140074:	e0bff717 	ldw	r2,-36(fp)
81140078:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8114007c:	e0bff717 	ldw	r2,-36(fp)
81140080:	10800017 	ldw	r2,0(r2)
81140084:	10000226 	beq	r2,zero,81140090 <altera_avalon_uart_init+0xac>
81140088:	0005883a 	mov	r2,zero
8114008c:	00000106 	br	81140094 <altera_avalon_uart_init+0xb0>
81140090:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81140094:	1000121e 	bne	r2,zero,811400e0 <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
81140098:	e0bffd17 	ldw	r2,-12(fp)
8114009c:	10800904 	addi	r2,r2,36
811400a0:	e0bff815 	stw	r2,-32(fp)
811400a4:	00800044 	movi	r2,1
811400a8:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811400ac:	e0bffc0b 	ldhu	r2,-16(fp)
811400b0:	1009883a 	mov	r4,r2
811400b4:	11372500 	call	81137250 <OSSemCreate>
811400b8:	1007883a 	mov	r3,r2
811400bc:	e0bff817 	ldw	r2,-32(fp)
811400c0:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
811400c4:	e0bff817 	ldw	r2,-32(fp)
811400c8:	10800017 	ldw	r2,0(r2)
811400cc:	10000226 	beq	r2,zero,811400d8 <altera_avalon_uart_init+0xf4>
811400d0:	0005883a 	mov	r2,zero
811400d4:	00000106 	br	811400dc <altera_avalon_uart_init+0xf8>
811400d8:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
811400dc:	10000226 	beq	r2,zero,811400e8 <altera_avalon_uart_init+0x104>
811400e0:	00800044 	movi	r2,1
811400e4:	00000106 	br	811400ec <altera_avalon_uart_init+0x108>
811400e8:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
811400ec:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
811400f0:	e0bff917 	ldw	r2,-28(fp)
811400f4:	10000f1e 	bne	r2,zero,81140134 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
811400f8:	e0bffd17 	ldw	r2,-12(fp)
811400fc:	00c32004 	movi	r3,3200
81140100:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
81140104:	e0bff617 	ldw	r2,-40(fp)
81140108:	10800304 	addi	r2,r2,12
8114010c:	e0fffd17 	ldw	r3,-12(fp)
81140110:	18c00117 	ldw	r3,4(r3)
81140114:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
81140118:	d8000015 	stw	zero,0(sp)
8114011c:	e1fffd17 	ldw	r7,-12(fp)
81140120:	01a04534 	movhi	r6,33044
81140124:	31805304 	addi	r6,r6,332
81140128:	e17fff17 	ldw	r5,-4(fp)
8114012c:	e13ffe17 	ldw	r4,-8(fp)
81140130:	1142e480 	call	81142e48 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
81140134:	0001883a 	nop
81140138:	e037883a 	mov	sp,fp
8114013c:	dfc00117 	ldw	ra,4(sp)
81140140:	df000017 	ldw	fp,0(sp)
81140144:	dec00204 	addi	sp,sp,8
81140148:	f800283a 	ret

8114014c <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
8114014c:	defffa04 	addi	sp,sp,-24
81140150:	de00012e 	bgeu	sp,et,81140158 <altera_avalon_uart_irq+0xc>
81140154:	003b68fa 	trap	3
81140158:	dfc00515 	stw	ra,20(sp)
8114015c:	df000415 	stw	fp,16(sp)
81140160:	df000404 	addi	fp,sp,16
81140164:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
81140168:	e0bfff17 	ldw	r2,-4(fp)
8114016c:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
81140170:	e0bffc17 	ldw	r2,-16(fp)
81140174:	10800017 	ldw	r2,0(r2)
81140178:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
8114017c:	e0bffd17 	ldw	r2,-12(fp)
81140180:	10800204 	addi	r2,r2,8
81140184:	10800037 	ldwio	r2,0(r2)
81140188:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
8114018c:	e0bffd17 	ldw	r2,-12(fp)
81140190:	10800204 	addi	r2,r2,8
81140194:	0007883a 	mov	r3,zero
81140198:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
8114019c:	e0bffd17 	ldw	r2,-12(fp)
811401a0:	10800204 	addi	r2,r2,8
811401a4:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
811401a8:	e0bffe17 	ldw	r2,-8(fp)
811401ac:	1080200c 	andi	r2,r2,128
811401b0:	10000326 	beq	r2,zero,811401c0 <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
811401b4:	e17ffe17 	ldw	r5,-8(fp)
811401b8:	e13ffc17 	ldw	r4,-16(fp)
811401bc:	11401f00 	call	811401f0 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
811401c0:	e0bffe17 	ldw	r2,-8(fp)
811401c4:	1081100c 	andi	r2,r2,1088
811401c8:	10000326 	beq	r2,zero,811401d8 <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
811401cc:	e17ffe17 	ldw	r5,-8(fp)
811401d0:	e13ffc17 	ldw	r4,-16(fp)
811401d4:	11403300 	call	81140330 <altera_avalon_uart_txirq>
  }
  

}
811401d8:	0001883a 	nop
811401dc:	e037883a 	mov	sp,fp
811401e0:	dfc00117 	ldw	ra,4(sp)
811401e4:	df000017 	ldw	fp,0(sp)
811401e8:	dec00204 	addi	sp,sp,8
811401ec:	f800283a 	ret

811401f0 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
811401f0:	defff904 	addi	sp,sp,-28
811401f4:	de00012e 	bgeu	sp,et,811401fc <altera_avalon_uart_rxirq+0xc>
811401f8:	003b68fa 	trap	3
811401fc:	dfc00615 	stw	ra,24(sp)
81140200:	df000515 	stw	fp,20(sp)
81140204:	df000504 	addi	fp,sp,20
81140208:	e13ffe15 	stw	r4,-8(fp)
8114020c:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
81140210:	e0bfff17 	ldw	r2,-4(fp)
81140214:	108000cc 	andi	r2,r2,3
81140218:	10003f1e 	bne	r2,zero,81140318 <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
8114021c:	e0bffe17 	ldw	r2,-8(fp)
81140220:	10c00317 	ldw	r3,12(r2)
81140224:	e0bffe17 	ldw	r2,-8(fp)
81140228:	10800217 	ldw	r2,8(r2)
8114022c:	1880121e 	bne	r3,r2,81140278 <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
81140230:	e0bffe17 	ldw	r2,-8(fp)
81140234:	10800717 	ldw	r2,28(r2)
81140238:	e0bffc15 	stw	r2,-16(fp)
8114023c:	00800044 	movi	r2,1
81140240:	e0bffd0d 	sth	r2,-12(fp)
81140244:	00800044 	movi	r2,1
81140248:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
8114024c:	d0a09003 	ldbu	r2,-32192(gp)
81140250:	10803fcc 	andi	r2,r2,255
81140254:	10000826 	beq	r2,zero,81140278 <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
81140258:	e0bffd0b 	ldhu	r2,-12(fp)
8114025c:	e0fffd83 	ldbu	r3,-10(fp)
81140260:	e13ffdc4 	addi	r4,fp,-9
81140264:	200f883a 	mov	r7,r4
81140268:	180d883a 	mov	r6,r3
8114026c:	100b883a 	mov	r5,r2
81140270:	e13ffc17 	ldw	r4,-16(fp)
81140274:	1133f000 	call	81133f00 <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81140278:	e0bffe17 	ldw	r2,-8(fp)
8114027c:	10800317 	ldw	r2,12(r2)
81140280:	10800044 	addi	r2,r2,1
81140284:	10800fcc 	andi	r2,r2,63
81140288:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
8114028c:	e0bffe17 	ldw	r2,-8(fp)
81140290:	10800317 	ldw	r2,12(r2)
81140294:	e0fffe17 	ldw	r3,-8(fp)
81140298:	18c00017 	ldw	r3,0(r3)
8114029c:	18c00037 	ldwio	r3,0(r3)
811402a0:	1809883a 	mov	r4,r3
811402a4:	e0fffe17 	ldw	r3,-8(fp)
811402a8:	1885883a 	add	r2,r3,r2
811402ac:	10800a04 	addi	r2,r2,40
811402b0:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
811402b4:	e0bffe17 	ldw	r2,-8(fp)
811402b8:	e0fffb17 	ldw	r3,-20(fp)
811402bc:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
811402c0:	e0bffe17 	ldw	r2,-8(fp)
811402c4:	10800317 	ldw	r2,12(r2)
811402c8:	10800044 	addi	r2,r2,1
811402cc:	10800fcc 	andi	r2,r2,63
811402d0:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
811402d4:	e0bffe17 	ldw	r2,-8(fp)
811402d8:	10c00217 	ldw	r3,8(r2)
811402dc:	e0bffb17 	ldw	r2,-20(fp)
811402e0:	18800e1e 	bne	r3,r2,8114031c <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
811402e4:	e0bffe17 	ldw	r2,-8(fp)
811402e8:	10c00117 	ldw	r3,4(r2)
811402ec:	00bfdfc4 	movi	r2,-129
811402f0:	1886703a 	and	r3,r3,r2
811402f4:	e0bffe17 	ldw	r2,-8(fp)
811402f8:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
811402fc:	e0bffe17 	ldw	r2,-8(fp)
81140300:	10800017 	ldw	r2,0(r2)
81140304:	10800304 	addi	r2,r2,12
81140308:	e0fffe17 	ldw	r3,-8(fp)
8114030c:	18c00117 	ldw	r3,4(r3)
81140310:	10c00035 	stwio	r3,0(r2)
81140314:	00000106 	br	8114031c <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
81140318:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
8114031c:	e037883a 	mov	sp,fp
81140320:	dfc00117 	ldw	ra,4(sp)
81140324:	df000017 	ldw	fp,0(sp)
81140328:	dec00204 	addi	sp,sp,8
8114032c:	f800283a 	ret

81140330 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81140330:	defffa04 	addi	sp,sp,-24
81140334:	de00012e 	bgeu	sp,et,8114033c <altera_avalon_uart_txirq+0xc>
81140338:	003b68fa 	trap	3
8114033c:	dfc00515 	stw	ra,20(sp)
81140340:	df000415 	stw	fp,16(sp)
81140344:	df000404 	addi	fp,sp,16
81140348:	e13ffe15 	stw	r4,-8(fp)
8114034c:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
81140350:	e0bffe17 	ldw	r2,-8(fp)
81140354:	10c00417 	ldw	r3,16(r2)
81140358:	e0bffe17 	ldw	r2,-8(fp)
8114035c:	10800517 	ldw	r2,20(r2)
81140360:	18804726 	beq	r3,r2,81140480 <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
81140364:	e0bffe17 	ldw	r2,-8(fp)
81140368:	10800617 	ldw	r2,24(r2)
8114036c:	1080008c 	andi	r2,r2,2
81140370:	10000326 	beq	r2,zero,81140380 <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
81140374:	e0bfff17 	ldw	r2,-4(fp)
81140378:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
8114037c:	10003226 	beq	r2,zero,81140448 <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
81140380:	e0bffe17 	ldw	r2,-8(fp)
81140384:	10c00417 	ldw	r3,16(r2)
81140388:	e0bffe17 	ldw	r2,-8(fp)
8114038c:	10800517 	ldw	r2,20(r2)
81140390:	10800044 	addi	r2,r2,1
81140394:	10800fcc 	andi	r2,r2,63
81140398:	1880121e 	bne	r3,r2,811403e4 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
8114039c:	e0bffe17 	ldw	r2,-8(fp)
811403a0:	10800717 	ldw	r2,28(r2)
811403a4:	e0bffc15 	stw	r2,-16(fp)
811403a8:	00800084 	movi	r2,2
811403ac:	e0bffd0d 	sth	r2,-12(fp)
811403b0:	00800044 	movi	r2,1
811403b4:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811403b8:	d0a09003 	ldbu	r2,-32192(gp)
811403bc:	10803fcc 	andi	r2,r2,255
811403c0:	10000826 	beq	r2,zero,811403e4 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
811403c4:	e0bffd0b 	ldhu	r2,-12(fp)
811403c8:	e0fffd83 	ldbu	r3,-10(fp)
811403cc:	e13ffdc4 	addi	r4,fp,-9
811403d0:	200f883a 	mov	r7,r4
811403d4:	180d883a 	mov	r6,r3
811403d8:	100b883a 	mov	r5,r2
811403dc:	e13ffc17 	ldw	r4,-16(fp)
811403e0:	1133f000 	call	81133f00 <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
811403e4:	e0bffe17 	ldw	r2,-8(fp)
811403e8:	10800017 	ldw	r2,0(r2)
811403ec:	10800104 	addi	r2,r2,4
811403f0:	e0fffe17 	ldw	r3,-8(fp)
811403f4:	18c00417 	ldw	r3,16(r3)
811403f8:	e13ffe17 	ldw	r4,-8(fp)
811403fc:	20c7883a 	add	r3,r4,r3
81140400:	18c01a04 	addi	r3,r3,104
81140404:	18c00003 	ldbu	r3,0(r3)
81140408:	18c03fcc 	andi	r3,r3,255
8114040c:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
81140410:	e0bffe17 	ldw	r2,-8(fp)
81140414:	10800417 	ldw	r2,16(r2)
81140418:	10800044 	addi	r2,r2,1
8114041c:	e0fffe17 	ldw	r3,-8(fp)
81140420:	18800415 	stw	r2,16(r3)
81140424:	10c00fcc 	andi	r3,r2,63
81140428:	e0bffe17 	ldw	r2,-8(fp)
8114042c:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
81140430:	e0bffe17 	ldw	r2,-8(fp)
81140434:	10800117 	ldw	r2,4(r2)
81140438:	10c01014 	ori	r3,r2,64
8114043c:	e0bffe17 	ldw	r2,-8(fp)
81140440:	10c00115 	stw	r3,4(r2)
81140444:	00000e06 	br	81140480 <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
81140448:	e0bffe17 	ldw	r2,-8(fp)
8114044c:	10800017 	ldw	r2,0(r2)
81140450:	10800204 	addi	r2,r2,8
81140454:	10800037 	ldwio	r2,0(r2)
81140458:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
8114045c:	e0bfff17 	ldw	r2,-4(fp)
81140460:	1082000c 	andi	r2,r2,2048
81140464:	1000061e 	bne	r2,zero,81140480 <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
81140468:	e0bffe17 	ldw	r2,-8(fp)
8114046c:	10c00117 	ldw	r3,4(r2)
81140470:	00bfefc4 	movi	r2,-65
81140474:	1886703a 	and	r3,r3,r2
81140478:	e0bffe17 	ldw	r2,-8(fp)
8114047c:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
81140480:	e0bffe17 	ldw	r2,-8(fp)
81140484:	10c00417 	ldw	r3,16(r2)
81140488:	e0bffe17 	ldw	r2,-8(fp)
8114048c:	10800517 	ldw	r2,20(r2)
81140490:	1880061e 	bne	r3,r2,811404ac <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81140494:	e0bffe17 	ldw	r2,-8(fp)
81140498:	10c00117 	ldw	r3,4(r2)
8114049c:	00beefc4 	movi	r2,-1089
811404a0:	1886703a 	and	r3,r3,r2
811404a4:	e0bffe17 	ldw	r2,-8(fp)
811404a8:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
811404ac:	e0bffe17 	ldw	r2,-8(fp)
811404b0:	10800017 	ldw	r2,0(r2)
811404b4:	10800304 	addi	r2,r2,12
811404b8:	e0fffe17 	ldw	r3,-8(fp)
811404bc:	18c00117 	ldw	r3,4(r3)
811404c0:	10c00035 	stwio	r3,0(r2)
}
811404c4:	0001883a 	nop
811404c8:	e037883a 	mov	sp,fp
811404cc:	dfc00117 	ldw	ra,4(sp)
811404d0:	df000017 	ldw	fp,0(sp)
811404d4:	dec00204 	addi	sp,sp,8
811404d8:	f800283a 	ret

811404dc <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
811404dc:	defffd04 	addi	sp,sp,-12
811404e0:	de00012e 	bgeu	sp,et,811404e8 <altera_avalon_uart_close+0xc>
811404e4:	003b68fa 	trap	3
811404e8:	df000215 	stw	fp,8(sp)
811404ec:	df000204 	addi	fp,sp,8
811404f0:	e13ffe15 	stw	r4,-8(fp)
811404f4:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
811404f8:	00000506 	br	81140510 <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
811404fc:	e0bfff17 	ldw	r2,-4(fp)
81140500:	1090000c 	andi	r2,r2,16384
81140504:	10000226 	beq	r2,zero,81140510 <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
81140508:	00bffd44 	movi	r2,-11
8114050c:	00000606 	br	81140528 <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81140510:	e0bffe17 	ldw	r2,-8(fp)
81140514:	10c00417 	ldw	r3,16(r2)
81140518:	e0bffe17 	ldw	r2,-8(fp)
8114051c:	10800517 	ldw	r2,20(r2)
81140520:	18bff61e 	bne	r3,r2,811404fc <__reset+0xfb1204fc>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81140524:	0005883a 	mov	r2,zero
}
81140528:	e037883a 	mov	sp,fp
8114052c:	df000017 	ldw	fp,0(sp)
81140530:	dec00104 	addi	sp,sp,4
81140534:	f800283a 	ret

81140538 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81140538:	defffe04 	addi	sp,sp,-8
8114053c:	de00012e 	bgeu	sp,et,81140544 <alt_get_errno+0xc>
81140540:	003b68fa 	trap	3
81140544:	dfc00115 	stw	ra,4(sp)
81140548:	df000015 	stw	fp,0(sp)
8114054c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81140550:	d0a01017 	ldw	r2,-32704(gp)
81140554:	10000326 	beq	r2,zero,81140564 <alt_get_errno+0x2c>
81140558:	d0a01017 	ldw	r2,-32704(gp)
8114055c:	103ee83a 	callr	r2
81140560:	00000106 	br	81140568 <alt_get_errno+0x30>
81140564:	d0a07d04 	addi	r2,gp,-32268
}
81140568:	e037883a 	mov	sp,fp
8114056c:	dfc00117 	ldw	ra,4(sp)
81140570:	df000017 	ldw	fp,0(sp)
81140574:	dec00204 	addi	sp,sp,8
81140578:	f800283a 	ret

8114057c <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
8114057c:	deffec04 	addi	sp,sp,-80
81140580:	de00012e 	bgeu	sp,et,81140588 <altera_avalon_uart_read+0xc>
81140584:	003b68fa 	trap	3
81140588:	dfc01315 	stw	ra,76(sp)
8114058c:	df001215 	stw	fp,72(sp)
81140590:	df001204 	addi	fp,sp,72
81140594:	e13ffc15 	stw	r4,-16(fp)
81140598:	e17ffd15 	stw	r5,-12(fp)
8114059c:	e1bffe15 	stw	r6,-8(fp)
811405a0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
811405a4:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
811405a8:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
811405ac:	e0bfff17 	ldw	r2,-4(fp)
811405b0:	1090000c 	andi	r2,r2,16384
811405b4:	1005003a 	cmpeq	r2,r2,zero
811405b8:	10803fcc 	andi	r2,r2,255
811405bc:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
811405c0:	e0bffc17 	ldw	r2,-16(fp)
811405c4:	10800817 	ldw	r2,32(r2)
811405c8:	e0bff815 	stw	r2,-32(fp)
811405cc:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
811405d0:	e0bff90b 	ldhu	r2,-28(fp)
811405d4:	e0fffb44 	addi	r3,fp,-19
811405d8:	180d883a 	mov	r6,r3
811405dc:	100b883a 	mov	r5,r2
811405e0:	e13ff817 	ldw	r4,-32(fp)
811405e4:	11375780 	call	81137578 <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
811405e8:	00001306 	br	81140638 <altera_avalon_uart_read+0xbc>
    {
      count++;
811405ec:	e0bff017 	ldw	r2,-64(fp)
811405f0:	10800044 	addi	r2,r2,1
811405f4:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
811405f8:	e0bffd17 	ldw	r2,-12(fp)
811405fc:	10c00044 	addi	r3,r2,1
81140600:	e0fffd15 	stw	r3,-12(fp)
81140604:	e0fffc17 	ldw	r3,-16(fp)
81140608:	18c00217 	ldw	r3,8(r3)
8114060c:	e13ffc17 	ldw	r4,-16(fp)
81140610:	20c7883a 	add	r3,r4,r3
81140614:	18c00a04 	addi	r3,r3,40
81140618:	18c00003 	ldbu	r3,0(r3)
8114061c:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
81140620:	e0bffc17 	ldw	r2,-16(fp)
81140624:	10800217 	ldw	r2,8(r2)
81140628:	10800044 	addi	r2,r2,1
8114062c:	10c00fcc 	andi	r3,r2,63
81140630:	e0bffc17 	ldw	r2,-16(fp)
81140634:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81140638:	e0fff017 	ldw	r3,-64(fp)
8114063c:	e0bffe17 	ldw	r2,-8(fp)
81140640:	1880050e 	bge	r3,r2,81140658 <altera_avalon_uart_read+0xdc>
81140644:	e0bffc17 	ldw	r2,-16(fp)
81140648:	10c00217 	ldw	r3,8(r2)
8114064c:	e0bffc17 	ldw	r2,-16(fp)
81140650:	10800317 	ldw	r2,12(r2)
81140654:	18bfe51e 	bne	r3,r2,811405ec <__reset+0xfb1205ec>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
81140658:	e0bff017 	ldw	r2,-64(fp)
8114065c:	10003a1e 	bne	r2,zero,81140748 <altera_avalon_uart_read+0x1cc>
81140660:	e0bffc17 	ldw	r2,-16(fp)
81140664:	10c00217 	ldw	r3,8(r2)
81140668:	e0bffc17 	ldw	r2,-16(fp)
8114066c:	10800317 	ldw	r2,12(r2)
81140670:	1880351e 	bne	r3,r2,81140748 <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
81140674:	e0bff117 	ldw	r2,-60(fp)
81140678:	1000071e 	bne	r2,zero,81140698 <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
8114067c:	11405380 	call	81140538 <alt_get_errno>
81140680:	1007883a 	mov	r3,r2
81140684:	008002c4 	movi	r2,11
81140688:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
8114068c:	00800044 	movi	r2,1
81140690:	e0bfef05 	stb	r2,-68(fp)
        break;
81140694:	00003006 	br	81140758 <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140698:	0005303a 	rdctl	r2,status
8114069c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811406a0:	e0fff517 	ldw	r3,-44(fp)
811406a4:	00bfff84 	movi	r2,-2
811406a8:	1884703a 	and	r2,r3,r2
811406ac:	1001703a 	wrctl	status,r2
  
  return context;
811406b0:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
811406b4:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
811406b8:	e0bffc17 	ldw	r2,-16(fp)
811406bc:	10800117 	ldw	r2,4(r2)
811406c0:	10c02014 	ori	r3,r2,128
811406c4:	e0bffc17 	ldw	r2,-16(fp)
811406c8:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
811406cc:	e0bffc17 	ldw	r2,-16(fp)
811406d0:	10800017 	ldw	r2,0(r2)
811406d4:	10800304 	addi	r2,r2,12
811406d8:	e0fffc17 	ldw	r3,-16(fp)
811406dc:	18c00117 	ldw	r3,4(r3)
811406e0:	10c00035 	stwio	r3,0(r2)
811406e4:	e0bff417 	ldw	r2,-48(fp)
811406e8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811406ec:	e0bff617 	ldw	r2,-40(fp)
811406f0:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
811406f4:	e0bffc17 	ldw	r2,-16(fp)
811406f8:	10800717 	ldw	r2,28(r2)
811406fc:	e0bff215 	stw	r2,-56(fp)
81140700:	00800044 	movi	r2,1
81140704:	e0bff98d 	sth	r2,-26(fp)
81140708:	00bfe0c4 	movi	r2,-125
8114070c:	e0bffa05 	stb	r2,-24(fp)
81140710:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81140714:	d0a09003 	ldbu	r2,-32192(gp)
81140718:	10803fcc 	andi	r2,r2,255
8114071c:	10000a26 	beq	r2,zero,81140748 <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81140720:	e0fff98b 	ldhu	r3,-26(fp)
81140724:	e13ffa03 	ldbu	r4,-24(fp)
81140728:	e17ffa8b 	ldhu	r5,-22(fp)
8114072c:	e0bffb04 	addi	r2,fp,-20
81140730:	d8800015 	stw	r2,0(sp)
81140734:	280f883a 	mov	r7,r5
81140738:	200d883a 	mov	r6,r4
8114073c:	180b883a 	mov	r5,r3
81140740:	e13ff217 	ldw	r4,-56(fp)
81140744:	11338d80 	call	811338d8 <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
81140748:	e0bff017 	ldw	r2,-64(fp)
8114074c:	1000021e 	bne	r2,zero,81140758 <altera_avalon_uart_read+0x1dc>
81140750:	e0bffe17 	ldw	r2,-8(fp)
81140754:	103fb81e 	bne	r2,zero,81140638 <__reset+0xfb120638>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81140758:	e0bffc17 	ldw	r2,-16(fp)
8114075c:	10800817 	ldw	r2,32(r2)
81140760:	1009883a 	mov	r4,r2
81140764:	11379000 	call	81137900 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140768:	0005303a 	rdctl	r2,status
8114076c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140770:	e0fff717 	ldw	r3,-36(fp)
81140774:	00bfff84 	movi	r2,-2
81140778:	1884703a 	and	r2,r3,r2
8114077c:	1001703a 	wrctl	status,r2
  
  return context;
81140780:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
81140784:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81140788:	e0bffc17 	ldw	r2,-16(fp)
8114078c:	10800117 	ldw	r2,4(r2)
81140790:	10c02014 	ori	r3,r2,128
81140794:	e0bffc17 	ldw	r2,-16(fp)
81140798:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8114079c:	e0bffc17 	ldw	r2,-16(fp)
811407a0:	10800017 	ldw	r2,0(r2)
811407a4:	10800304 	addi	r2,r2,12
811407a8:	e0fffc17 	ldw	r3,-16(fp)
811407ac:	18c00117 	ldw	r3,4(r3)
811407b0:	10c00035 	stwio	r3,0(r2)
811407b4:	e0bff417 	ldw	r2,-48(fp)
811407b8:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811407bc:	e0bff317 	ldw	r2,-52(fp)
811407c0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
811407c4:	e0bfef03 	ldbu	r2,-68(fp)
811407c8:	10000226 	beq	r2,zero,811407d4 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
811407cc:	00bffd44 	movi	r2,-11
811407d0:	00000106 	br	811407d8 <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
811407d4:	e0bff017 	ldw	r2,-64(fp)
  }
}
811407d8:	e037883a 	mov	sp,fp
811407dc:	dfc00117 	ldw	ra,4(sp)
811407e0:	df000017 	ldw	fp,0(sp)
811407e4:	dec00204 	addi	sp,sp,8
811407e8:	f800283a 	ret

811407ec <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811407ec:	defffe04 	addi	sp,sp,-8
811407f0:	de00012e 	bgeu	sp,et,811407f8 <alt_get_errno+0xc>
811407f4:	003b68fa 	trap	3
811407f8:	dfc00115 	stw	ra,4(sp)
811407fc:	df000015 	stw	fp,0(sp)
81140800:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81140804:	d0a01017 	ldw	r2,-32704(gp)
81140808:	10000326 	beq	r2,zero,81140818 <alt_get_errno+0x2c>
8114080c:	d0a01017 	ldw	r2,-32704(gp)
81140810:	103ee83a 	callr	r2
81140814:	00000106 	br	8114081c <alt_get_errno+0x30>
81140818:	d0a07d04 	addi	r2,gp,-32268
}
8114081c:	e037883a 	mov	sp,fp
81140820:	dfc00117 	ldw	ra,4(sp)
81140824:	df000017 	ldw	fp,0(sp)
81140828:	dec00204 	addi	sp,sp,8
8114082c:	f800283a 	ret

81140830 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
81140830:	deffec04 	addi	sp,sp,-80
81140834:	de00012e 	bgeu	sp,et,8114083c <altera_avalon_uart_write+0xc>
81140838:	003b68fa 	trap	3
8114083c:	dfc01315 	stw	ra,76(sp)
81140840:	df001215 	stw	fp,72(sp)
81140844:	df001204 	addi	fp,sp,72
81140848:	e13ffc15 	stw	r4,-16(fp)
8114084c:	e17ffd15 	stw	r5,-12(fp)
81140850:	e1bffe15 	stw	r6,-8(fp)
81140854:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
81140858:	e0bffe17 	ldw	r2,-8(fp)
8114085c:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
81140860:	e0bfff17 	ldw	r2,-4(fp)
81140864:	1090000c 	andi	r2,r2,16384
81140868:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
8114086c:	e0bffc17 	ldw	r2,-16(fp)
81140870:	10800917 	ldw	r2,36(r2)
81140874:	e0bff815 	stw	r2,-32(fp)
81140878:	e03ff90d 	sth	zero,-28(fp)
8114087c:	e0bff90b 	ldhu	r2,-28(fp)
81140880:	e0fffb44 	addi	r3,fp,-19
81140884:	180d883a 	mov	r6,r3
81140888:	100b883a 	mov	r5,r2
8114088c:	e13ff817 	ldw	r4,-32(fp)
81140890:	11375780 	call	81137578 <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81140894:	00005106 	br	811409dc <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81140898:	e0bffc17 	ldw	r2,-16(fp)
8114089c:	10800517 	ldw	r2,20(r2)
811408a0:	10800044 	addi	r2,r2,1
811408a4:	10800fcc 	andi	r2,r2,63
811408a8:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
811408ac:	e0bffc17 	ldw	r2,-16(fp)
811408b0:	10c00417 	ldw	r3,16(r2)
811408b4:	e0bff217 	ldw	r2,-56(fp)
811408b8:	1880371e 	bne	r3,r2,81140998 <altera_avalon_uart_write+0x168>
    {
      if (no_block)
811408bc:	e0bff017 	ldw	r2,-64(fp)
811408c0:	10000526 	beq	r2,zero,811408d8 <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
811408c4:	11407ec0 	call	811407ec <alt_get_errno>
811408c8:	1007883a 	mov	r3,r2
811408cc:	008002c4 	movi	r2,11
811408d0:	18800015 	stw	r2,0(r3)
        break;
811408d4:	00004306 	br	811409e4 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811408d8:	0005303a 	rdctl	r2,status
811408dc:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811408e0:	e0fff517 	ldw	r3,-44(fp)
811408e4:	00bfff84 	movi	r2,-2
811408e8:	1884703a 	and	r2,r3,r2
811408ec:	1001703a 	wrctl	status,r2
  
  return context;
811408f0:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
811408f4:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
811408f8:	e0bffc17 	ldw	r2,-16(fp)
811408fc:	10800117 	ldw	r2,4(r2)
81140900:	10c11014 	ori	r3,r2,1088
81140904:	e0bffc17 	ldw	r2,-16(fp)
81140908:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
8114090c:	e0bffc17 	ldw	r2,-16(fp)
81140910:	10800017 	ldw	r2,0(r2)
81140914:	10800304 	addi	r2,r2,12
81140918:	e0fffc17 	ldw	r3,-16(fp)
8114091c:	18c00117 	ldw	r3,4(r3)
81140920:	10c00035 	stwio	r3,0(r2)
81140924:	e0bff417 	ldw	r2,-48(fp)
81140928:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114092c:	e0bff117 	ldw	r2,-60(fp)
81140930:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
81140934:	e0bffc17 	ldw	r2,-16(fp)
81140938:	10800717 	ldw	r2,28(r2)
8114093c:	e0bff315 	stw	r2,-52(fp)
81140940:	00800084 	movi	r2,2
81140944:	e0bff98d 	sth	r2,-26(fp)
81140948:	00bfe0c4 	movi	r2,-125
8114094c:	e0bffa05 	stb	r2,-24(fp)
81140950:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81140954:	d0a09003 	ldbu	r2,-32192(gp)
81140958:	10803fcc 	andi	r2,r2,255
8114095c:	10000a26 	beq	r2,zero,81140988 <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81140960:	e0fff98b 	ldhu	r3,-26(fp)
81140964:	e13ffa03 	ldbu	r4,-24(fp)
81140968:	e17ffa8b 	ldhu	r5,-22(fp)
8114096c:	e0bffb04 	addi	r2,fp,-20
81140970:	d8800015 	stw	r2,0(sp)
81140974:	280f883a 	mov	r7,r5
81140978:	200d883a 	mov	r6,r4
8114097c:	180b883a 	mov	r5,r3
81140980:	e13ff317 	ldw	r4,-52(fp)
81140984:	11338d80 	call	811338d8 <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
81140988:	e0bffc17 	ldw	r2,-16(fp)
8114098c:	10c00417 	ldw	r3,16(r2)
81140990:	e0bff217 	ldw	r2,-56(fp)
81140994:	18bfe726 	beq	r3,r2,81140934 <__reset+0xfb120934>
      }
    }

    count--;
81140998:	e0bfef17 	ldw	r2,-68(fp)
8114099c:	10bfffc4 	addi	r2,r2,-1
811409a0:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
811409a4:	e0bffc17 	ldw	r2,-16(fp)
811409a8:	10c00517 	ldw	r3,20(r2)
811409ac:	e0bffd17 	ldw	r2,-12(fp)
811409b0:	11000044 	addi	r4,r2,1
811409b4:	e13ffd15 	stw	r4,-12(fp)
811409b8:	10800003 	ldbu	r2,0(r2)
811409bc:	1009883a 	mov	r4,r2
811409c0:	e0bffc17 	ldw	r2,-16(fp)
811409c4:	10c5883a 	add	r2,r2,r3
811409c8:	10801a04 	addi	r2,r2,104
811409cc:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
811409d0:	e0bffc17 	ldw	r2,-16(fp)
811409d4:	e0fff217 	ldw	r3,-56(fp)
811409d8:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
811409dc:	e0bfef17 	ldw	r2,-68(fp)
811409e0:	103fad1e 	bne	r2,zero,81140898 <__reset+0xfb120898>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
811409e4:	e0bffc17 	ldw	r2,-16(fp)
811409e8:	10800917 	ldw	r2,36(r2)
811409ec:	1009883a 	mov	r4,r2
811409f0:	11379000 	call	81137900 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811409f4:	0005303a 	rdctl	r2,status
811409f8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811409fc:	e0fff717 	ldw	r3,-36(fp)
81140a00:	00bfff84 	movi	r2,-2
81140a04:	1884703a 	and	r2,r3,r2
81140a08:	1001703a 	wrctl	status,r2
  
  return context;
81140a0c:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
81140a10:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81140a14:	e0bffc17 	ldw	r2,-16(fp)
81140a18:	10800117 	ldw	r2,4(r2)
81140a1c:	10c11014 	ori	r3,r2,1088
81140a20:	e0bffc17 	ldw	r2,-16(fp)
81140a24:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81140a28:	e0bffc17 	ldw	r2,-16(fp)
81140a2c:	10800017 	ldw	r2,0(r2)
81140a30:	10800304 	addi	r2,r2,12
81140a34:	e0fffc17 	ldw	r3,-16(fp)
81140a38:	18c00117 	ldw	r3,4(r3)
81140a3c:	10c00035 	stwio	r3,0(r2)
81140a40:	e0bff417 	ldw	r2,-48(fp)
81140a44:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140a48:	e0bff617 	ldw	r2,-40(fp)
81140a4c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
81140a50:	e0fffe17 	ldw	r3,-8(fp)
81140a54:	e0bfef17 	ldw	r2,-68(fp)
81140a58:	1885c83a 	sub	r2,r3,r2
}
81140a5c:	e037883a 	mov	sp,fp
81140a60:	dfc00117 	ldw	ra,4(sp)
81140a64:	df000017 	ldw	fp,0(sp)
81140a68:	dec00204 	addi	sp,sp,8
81140a6c:	f800283a 	ret

81140a70 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81140a70:	defffe04 	addi	sp,sp,-8
81140a74:	de00012e 	bgeu	sp,et,81140a7c <alt_get_errno+0xc>
81140a78:	003b68fa 	trap	3
81140a7c:	dfc00115 	stw	ra,4(sp)
81140a80:	df000015 	stw	fp,0(sp)
81140a84:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81140a88:	d0a01017 	ldw	r2,-32704(gp)
81140a8c:	10000326 	beq	r2,zero,81140a9c <alt_get_errno+0x2c>
81140a90:	d0a01017 	ldw	r2,-32704(gp)
81140a94:	103ee83a 	callr	r2
81140a98:	00000106 	br	81140aa0 <alt_get_errno+0x30>
81140a9c:	d0a07d04 	addi	r2,gp,-32268
}
81140aa0:	e037883a 	mov	sp,fp
81140aa4:	dfc00117 	ldw	ra,4(sp)
81140aa8:	df000017 	ldw	fp,0(sp)
81140aac:	dec00204 	addi	sp,sp,8
81140ab0:	f800283a 	ret

81140ab4 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
81140ab4:	defffc04 	addi	sp,sp,-16
81140ab8:	de00012e 	bgeu	sp,et,81140ac0 <alt_msgdma_write_standard_descriptor+0xc>
81140abc:	003b68fa 	trap	3
81140ac0:	df000315 	stw	fp,12(sp)
81140ac4:	df000304 	addi	fp,sp,12
81140ac8:	e13ffd15 	stw	r4,-12(fp)
81140acc:	e17ffe15 	stw	r5,-8(fp)
81140ad0:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81140ad4:	e0bffd17 	ldw	r2,-12(fp)
81140ad8:	10800037 	ldwio	r2,0(r2)
81140adc:	1080010c 	andi	r2,r2,4
81140ae0:	10000226 	beq	r2,zero,81140aec <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
81140ae4:	00bff904 	movi	r2,-28
81140ae8:	00001506 	br	81140b40 <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
81140aec:	e0bfff17 	ldw	r2,-4(fp)
81140af0:	10800017 	ldw	r2,0(r2)
81140af4:	1007883a 	mov	r3,r2
81140af8:	e0bffe17 	ldw	r2,-8(fp)
81140afc:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
81140b00:	e0bffe17 	ldw	r2,-8(fp)
81140b04:	10800104 	addi	r2,r2,4
81140b08:	e0ffff17 	ldw	r3,-4(fp)
81140b0c:	18c00117 	ldw	r3,4(r3)
81140b10:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
81140b14:	e0bffe17 	ldw	r2,-8(fp)
81140b18:	10800204 	addi	r2,r2,8
81140b1c:	e0ffff17 	ldw	r3,-4(fp)
81140b20:	18c00217 	ldw	r3,8(r3)
81140b24:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
81140b28:	e0bffe17 	ldw	r2,-8(fp)
81140b2c:	10800304 	addi	r2,r2,12
81140b30:	e0ffff17 	ldw	r3,-4(fp)
81140b34:	18c00317 	ldw	r3,12(r3)
81140b38:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
81140b3c:	0005883a 	mov	r2,zero
}
81140b40:	e037883a 	mov	sp,fp
81140b44:	df000017 	ldw	fp,0(sp)
81140b48:	dec00104 	addi	sp,sp,4
81140b4c:	f800283a 	ret

81140b50 <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
81140b50:	defffc04 	addi	sp,sp,-16
81140b54:	de00012e 	bgeu	sp,et,81140b5c <alt_msgdma_write_extended_descriptor+0xc>
81140b58:	003b68fa 	trap	3
81140b5c:	df000315 	stw	fp,12(sp)
81140b60:	df000304 	addi	fp,sp,12
81140b64:	e13ffd15 	stw	r4,-12(fp)
81140b68:	e17ffe15 	stw	r5,-8(fp)
81140b6c:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81140b70:	e0bffd17 	ldw	r2,-12(fp)
81140b74:	10800037 	ldwio	r2,0(r2)
81140b78:	1080010c 	andi	r2,r2,4
81140b7c:	10000226 	beq	r2,zero,81140b88 <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
81140b80:	00bff904 	movi	r2,-28
81140b84:	00003b06 	br	81140c74 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
81140b88:	e0bfff17 	ldw	r2,-4(fp)
81140b8c:	10800017 	ldw	r2,0(r2)
81140b90:	1007883a 	mov	r3,r2
81140b94:	e0bffe17 	ldw	r2,-8(fp)
81140b98:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
81140b9c:	e0bffe17 	ldw	r2,-8(fp)
81140ba0:	10800104 	addi	r2,r2,4
81140ba4:	e0ffff17 	ldw	r3,-4(fp)
81140ba8:	18c00117 	ldw	r3,4(r3)
81140bac:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
81140bb0:	e0bffe17 	ldw	r2,-8(fp)
81140bb4:	10800204 	addi	r2,r2,8
81140bb8:	e0ffff17 	ldw	r3,-4(fp)
81140bbc:	18c00217 	ldw	r3,8(r3)
81140bc0:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
81140bc4:	e0bffe17 	ldw	r2,-8(fp)
81140bc8:	10800304 	addi	r2,r2,12
81140bcc:	e0ffff17 	ldw	r3,-4(fp)
81140bd0:	18c0030b 	ldhu	r3,12(r3)
81140bd4:	18ffffcc 	andi	r3,r3,65535
81140bd8:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
81140bdc:	e0bffe17 	ldw	r2,-8(fp)
81140be0:	10800384 	addi	r2,r2,14
81140be4:	e0ffff17 	ldw	r3,-4(fp)
81140be8:	18c00383 	ldbu	r3,14(r3)
81140bec:	18c03fcc 	andi	r3,r3,255
81140bf0:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
81140bf4:	e0bffe17 	ldw	r2,-8(fp)
81140bf8:	108003c4 	addi	r2,r2,15
81140bfc:	e0ffff17 	ldw	r3,-4(fp)
81140c00:	18c003c3 	ldbu	r3,15(r3)
81140c04:	18c03fcc 	andi	r3,r3,255
81140c08:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
81140c0c:	e0bffe17 	ldw	r2,-8(fp)
81140c10:	10800404 	addi	r2,r2,16
81140c14:	e0ffff17 	ldw	r3,-4(fp)
81140c18:	18c0040b 	ldhu	r3,16(r3)
81140c1c:	18ffffcc 	andi	r3,r3,65535
81140c20:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
81140c24:	e0bffe17 	ldw	r2,-8(fp)
81140c28:	10800484 	addi	r2,r2,18
81140c2c:	e0ffff17 	ldw	r3,-4(fp)
81140c30:	18c0048b 	ldhu	r3,18(r3)
81140c34:	18ffffcc 	andi	r3,r3,65535
81140c38:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
81140c3c:	e0bffe17 	ldw	r2,-8(fp)
81140c40:	10800504 	addi	r2,r2,20
81140c44:	0007883a 	mov	r3,zero
81140c48:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
81140c4c:	e0bffe17 	ldw	r2,-8(fp)
81140c50:	10800604 	addi	r2,r2,24
81140c54:	0007883a 	mov	r3,zero
81140c58:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
81140c5c:	e0bffe17 	ldw	r2,-8(fp)
81140c60:	10800704 	addi	r2,r2,28
81140c64:	e0ffff17 	ldw	r3,-4(fp)
81140c68:	18c00717 	ldw	r3,28(r3)
81140c6c:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
81140c70:	0005883a 	mov	r2,zero
}
81140c74:	e037883a 	mov	sp,fp
81140c78:	df000017 	ldw	fp,0(sp)
81140c7c:	dec00104 	addi	sp,sp,4
81140c80:	f800283a 	ret

81140c84 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
81140c84:	defff804 	addi	sp,sp,-32
81140c88:	de00012e 	bgeu	sp,et,81140c90 <alt_msgdma_irq+0xc>
81140c8c:	003b68fa 	trap	3
81140c90:	dfc00715 	stw	ra,28(sp)
81140c94:	df000615 	stw	fp,24(sp)
81140c98:	df000604 	addi	fp,sp,24
81140c9c:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
81140ca0:	e0bfff17 	ldw	r2,-4(fp)
81140ca4:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
81140ca8:	e0bffa17 	ldw	r2,-24(fp)
81140cac:	10801783 	ldbu	r2,94(r2)
81140cb0:	10803fcc 	andi	r2,r2,255
81140cb4:	10001126 	beq	r2,zero,81140cfc <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81140cb8:	e0bffa17 	ldw	r2,-24(fp)
81140cbc:	10800617 	ldw	r2,24(r2)
81140cc0:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
81140cc4:	1007883a 	mov	r3,r2
81140cc8:	00bffdc4 	movi	r2,-9
81140ccc:	1884703a 	and	r2,r3,r2
81140cd0:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81140cd4:	e0bffa17 	ldw	r2,-24(fp)
81140cd8:	10800617 	ldw	r2,24(r2)
81140cdc:	e0fffb17 	ldw	r3,-20(fp)
81140ce0:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
81140ce4:	e0bffa17 	ldw	r2,-24(fp)
81140ce8:	10800617 	ldw	r2,24(r2)
81140cec:	10800404 	addi	r2,r2,16
81140cf0:	00c00044 	movi	r3,1
81140cf4:	10c00035 	stwio	r3,0(r2)
81140cf8:	00001106 	br	81140d40 <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81140cfc:	e0bffa17 	ldw	r2,-24(fp)
81140d00:	10800317 	ldw	r2,12(r2)
81140d04:	10800104 	addi	r2,r2,4
81140d08:	10800037 	ldwio	r2,0(r2)
81140d0c:	1007883a 	mov	r3,r2
81140d10:	00bffbc4 	movi	r2,-17
81140d14:	1884703a 	and	r2,r3,r2
81140d18:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81140d1c:	e0bffa17 	ldw	r2,-24(fp)
81140d20:	10800317 	ldw	r2,12(r2)
81140d24:	10800104 	addi	r2,r2,4
81140d28:	e0fffb17 	ldw	r3,-20(fp)
81140d2c:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
81140d30:	e0bffa17 	ldw	r2,-24(fp)
81140d34:	10800317 	ldw	r2,12(r2)
81140d38:	00c08004 	movi	r3,512
81140d3c:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
81140d40:	e0bffa17 	ldw	r2,-24(fp)
81140d44:	10800b17 	ldw	r2,44(r2)
81140d48:	10001226 	beq	r2,zero,81140d94 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81140d4c:	0005303a 	rdctl	r2,status
81140d50:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81140d54:	e0fffd17 	ldw	r3,-12(fp)
81140d58:	00bfff84 	movi	r2,-2
81140d5c:	1884703a 	and	r2,r3,r2
81140d60:	1001703a 	wrctl	status,r2
  
  return context;
81140d64:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
81140d68:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
81140d6c:	e0bffa17 	ldw	r2,-24(fp)
81140d70:	10800b17 	ldw	r2,44(r2)
81140d74:	e0fffa17 	ldw	r3,-24(fp)
81140d78:	18c00c17 	ldw	r3,48(r3)
81140d7c:	1809883a 	mov	r4,r3
81140d80:	103ee83a 	callr	r2
81140d84:	e0bffc17 	ldw	r2,-16(fp)
81140d88:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81140d8c:	e0bffe17 	ldw	r2,-8(fp)
81140d90:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
81140d94:	e0bffa17 	ldw	r2,-24(fp)
81140d98:	10801783 	ldbu	r2,94(r2)
81140d9c:	10803fcc 	andi	r2,r2,255
81140da0:	10000a26 	beq	r2,zero,81140dcc <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81140da4:	e0bffa17 	ldw	r2,-24(fp)
81140da8:	10800617 	ldw	r2,24(r2)
81140dac:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81140db0:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
81140db4:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81140db8:	e0bffa17 	ldw	r2,-24(fp)
81140dbc:	10800617 	ldw	r2,24(r2)
81140dc0:	e0fffb17 	ldw	r3,-20(fp)
81140dc4:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
81140dc8:	00000c06 	br	81140dfc <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81140dcc:	e0bffa17 	ldw	r2,-24(fp)
81140dd0:	10800317 	ldw	r2,12(r2)
81140dd4:	10800104 	addi	r2,r2,4
81140dd8:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
81140ddc:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81140de0:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81140de4:	e0bffa17 	ldw	r2,-24(fp)
81140de8:	10800317 	ldw	r2,12(r2)
81140dec:	10800104 	addi	r2,r2,4
81140df0:	e0fffb17 	ldw	r3,-20(fp)
81140df4:	10c00035 	stwio	r3,0(r2)
    }

    return;
81140df8:	0001883a 	nop
}
81140dfc:	e037883a 	mov	sp,fp
81140e00:	dfc00117 	ldw	ra,4(sp)
81140e04:	df000017 	ldw	fp,0(sp)
81140e08:	dec00204 	addi	sp,sp,8
81140e0c:	f800283a 	ret

81140e10 <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81140e10:	defffb04 	addi	sp,sp,-20
81140e14:	de00012e 	bgeu	sp,et,81140e1c <alt_msgdma_construct_standard_descriptor+0xc>
81140e18:	003b68fa 	trap	3
81140e1c:	df000415 	stw	fp,16(sp)
81140e20:	df000404 	addi	fp,sp,16
81140e24:	e13ffc15 	stw	r4,-16(fp)
81140e28:	e17ffd15 	stw	r5,-12(fp)
81140e2c:	e1bffe15 	stw	r6,-8(fp)
81140e30:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81140e34:	e0bffc17 	ldw	r2,-16(fp)
81140e38:	10c01217 	ldw	r3,72(r2)
81140e3c:	e0800117 	ldw	r2,4(fp)
81140e40:	18800436 	bltu	r3,r2,81140e54 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
81140e44:	e0bffc17 	ldw	r2,-16(fp)
81140e48:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81140e4c:	10803fcc 	andi	r2,r2,255
81140e50:	10000226 	beq	r2,zero,81140e5c <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
81140e54:	00bffa84 	movi	r2,-22
81140e58:	00000e06 	br	81140e94 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
81140e5c:	e0bffd17 	ldw	r2,-12(fp)
81140e60:	e0fffe17 	ldw	r3,-8(fp)
81140e64:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81140e68:	e0bffd17 	ldw	r2,-12(fp)
81140e6c:	e0ffff17 	ldw	r3,-4(fp)
81140e70:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81140e74:	e0bffd17 	ldw	r2,-12(fp)
81140e78:	e0c00117 	ldw	r3,4(fp)
81140e7c:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81140e80:	e0800217 	ldw	r2,8(fp)
81140e84:	10e00034 	orhi	r3,r2,32768
81140e88:	e0bffd17 	ldw	r2,-12(fp)
81140e8c:	10c00315 	stw	r3,12(r2)
    
    return 0;
81140e90:	0005883a 	mov	r2,zero
}
81140e94:	e037883a 	mov	sp,fp
81140e98:	df000017 	ldw	fp,0(sp)
81140e9c:	dec00104 	addi	sp,sp,4
81140ea0:	f800283a 	ret

81140ea4 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81140ea4:	defff604 	addi	sp,sp,-40
81140ea8:	de00012e 	bgeu	sp,et,81140eb0 <alt_msgdma_construct_extended_descriptor+0xc>
81140eac:	003b68fa 	trap	3
81140eb0:	df000915 	stw	fp,36(sp)
81140eb4:	df000904 	addi	fp,sp,36
81140eb8:	e13ff715 	stw	r4,-36(fp)
81140ebc:	e17ff815 	stw	r5,-32(fp)
81140ec0:	e1bff915 	stw	r6,-28(fp)
81140ec4:	e1fffa15 	stw	r7,-24(fp)
81140ec8:	e1800317 	ldw	r6,12(fp)
81140ecc:	e1400417 	ldw	r5,16(fp)
81140ed0:	e1000517 	ldw	r4,20(fp)
81140ed4:	e0c00617 	ldw	r3,24(fp)
81140ed8:	e0800717 	ldw	r2,28(fp)
81140edc:	e1bffb0d 	sth	r6,-20(fp)
81140ee0:	e17ffc05 	stb	r5,-16(fp)
81140ee4:	e13ffd05 	stb	r4,-12(fp)
81140ee8:	e0fffe0d 	sth	r3,-8(fp)
81140eec:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
81140ef0:	e0bff717 	ldw	r2,-36(fp)
81140ef4:	10c01217 	ldw	r3,72(r2)
81140ef8:	e0800117 	ldw	r2,4(fp)
81140efc:	18801936 	bltu	r3,r2,81140f64 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
81140f00:	e13ff717 	ldw	r4,-36(fp)
81140f04:	20801317 	ldw	r2,76(r4)
81140f08:	20c01417 	ldw	r3,80(r4)
81140f0c:	e13ffe0b 	ldhu	r4,-8(fp)
81140f10:	213fffcc 	andi	r4,r4,65535
81140f14:	2015883a 	mov	r10,r4
81140f18:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
81140f1c:	1ac01136 	bltu	r3,r11,81140f64 <alt_msgdma_construct_extended_descriptor+0xc0>
81140f20:	58c0011e 	bne	r11,r3,81140f28 <alt_msgdma_construct_extended_descriptor+0x84>
81140f24:	12800f36 	bltu	r2,r10,81140f64 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81140f28:	e13ff717 	ldw	r4,-36(fp)
81140f2c:	20801317 	ldw	r2,76(r4)
81140f30:	20c01417 	ldw	r3,80(r4)
81140f34:	e13fff0b 	ldhu	r4,-4(fp)
81140f38:	213fffcc 	andi	r4,r4,65535
81140f3c:	2011883a 	mov	r8,r4
81140f40:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81140f44:	1a400736 	bltu	r3,r9,81140f64 <alt_msgdma_construct_extended_descriptor+0xc0>
81140f48:	48c0011e 	bne	r9,r3,81140f50 <alt_msgdma_construct_extended_descriptor+0xac>
81140f4c:	12000536 	bltu	r2,r8,81140f64 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
81140f50:	e0bff717 	ldw	r2,-36(fp)
81140f54:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81140f58:	10803fcc 	andi	r2,r2,255
81140f5c:	10800060 	cmpeqi	r2,r2,1
81140f60:	1000021e 	bne	r2,zero,81140f6c <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81140f64:	00bffa84 	movi	r2,-22
81140f68:	00002106 	br	81140ff0 <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
81140f6c:	e0bff817 	ldw	r2,-32(fp)
81140f70:	e0fff917 	ldw	r3,-28(fp)
81140f74:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
81140f78:	e0bff817 	ldw	r2,-32(fp)
81140f7c:	e0fffa17 	ldw	r3,-24(fp)
81140f80:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81140f84:	e0bff817 	ldw	r2,-32(fp)
81140f88:	e0c00117 	ldw	r3,4(fp)
81140f8c:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81140f90:	e0bff817 	ldw	r2,-32(fp)
81140f94:	e0fffb0b 	ldhu	r3,-20(fp)
81140f98:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
81140f9c:	e0bff817 	ldw	r2,-32(fp)
81140fa0:	e0fffc03 	ldbu	r3,-16(fp)
81140fa4:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
81140fa8:	e0bff817 	ldw	r2,-32(fp)
81140fac:	e0fffd03 	ldbu	r3,-12(fp)
81140fb0:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
81140fb4:	e0bff817 	ldw	r2,-32(fp)
81140fb8:	e0fffe0b 	ldhu	r3,-8(fp)
81140fbc:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
81140fc0:	e0bff817 	ldw	r2,-32(fp)
81140fc4:	e0ffff0b 	ldhu	r3,-4(fp)
81140fc8:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
81140fcc:	e0bff817 	ldw	r2,-32(fp)
81140fd0:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
81140fd4:	e0bff817 	ldw	r2,-32(fp)
81140fd8:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81140fdc:	e0800217 	ldw	r2,8(fp)
81140fe0:	10e00034 	orhi	r3,r2,32768
81140fe4:	e0bff817 	ldw	r2,-32(fp)
81140fe8:	10c00715 	stw	r3,28(r2)

  return 0 ;
81140fec:	0005883a 	mov	r2,zero

}
81140ff0:	e037883a 	mov	sp,fp
81140ff4:	df000017 	ldw	fp,0(sp)
81140ff8:	dec00104 	addi	sp,sp,4
81140ffc:	f800283a 	ret

81141000 <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
81141000:	deffee04 	addi	sp,sp,-72
81141004:	de00012e 	bgeu	sp,et,8114100c <alt_msgdma_descriptor_async_transfer+0xc>
81141008:	003b68fa 	trap	3
8114100c:	dfc01115 	stw	ra,68(sp)
81141010:	df001015 	stw	fp,64(sp)
81141014:	df001004 	addi	fp,sp,64
81141018:	e13ffd15 	stw	r4,-12(fp)
8114101c:	e17ffe15 	stw	r5,-8(fp)
81141020:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
81141024:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
81141028:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
8114102c:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81141030:	e0bffd17 	ldw	r2,-12(fp)
81141034:	10800317 	ldw	r2,12(r2)
81141038:	10800204 	addi	r2,r2,8
8114103c:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
81141040:	10bfffcc 	andi	r2,r2,65535
81141044:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81141048:	e0bffd17 	ldw	r2,-12(fp)
8114104c:	10800317 	ldw	r2,12(r2)
81141050:	10800204 	addi	r2,r2,8
81141054:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
81141058:	1004d43a 	srli	r2,r2,16
8114105c:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81141060:	e0bffd17 	ldw	r2,-12(fp)
81141064:	10800917 	ldw	r2,36(r2)
81141068:	e0fff417 	ldw	r3,-48(fp)
8114106c:	1880042e 	bgeu	r3,r2,81141080 <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
81141070:	e0bffd17 	ldw	r2,-12(fp)
81141074:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81141078:	e0fff317 	ldw	r3,-52(fp)
8114107c:	18800236 	bltu	r3,r2,81141088 <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
81141080:	00bff904 	movi	r2,-28
81141084:	0000a906 	br	8114132c <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
81141088:	e0bffd17 	ldw	r2,-12(fp)
8114108c:	10801817 	ldw	r2,96(r2)
81141090:	e0bff615 	stw	r2,-40(fp)
81141094:	e03ffc0d 	sth	zero,-16(fp)
81141098:	e0bffc0b 	ldhu	r2,-16(fp)
8114109c:	e0fffc84 	addi	r3,fp,-14
811410a0:	180d883a 	mov	r6,r3
811410a4:	100b883a 	mov	r5,r2
811410a8:	e13ff617 	ldw	r4,-40(fp)
811410ac:	11375780 	call	81137578 <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
811410b0:	00800804 	movi	r2,32
811410b4:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811410b8:	0005303a 	rdctl	r2,status
811410bc:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811410c0:	e0fff717 	ldw	r3,-36(fp)
811410c4:	00bfff84 	movi	r2,-2
811410c8:	1884703a 	and	r2,r3,r2
811410cc:	1001703a 	wrctl	status,r2
  
  return context;
811410d0:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
811410d4:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
811410d8:	e0bffd17 	ldw	r2,-12(fp)
811410dc:	10800317 	ldw	r2,12(r2)
811410e0:	10800104 	addi	r2,r2,4
811410e4:	e0fff117 	ldw	r3,-60(fp)
811410e8:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
811410ec:	e0bffd17 	ldw	r2,-12(fp)
811410f0:	10800317 	ldw	r2,12(r2)
811410f4:	e0fffd17 	ldw	r3,-12(fp)
811410f8:	18c00317 	ldw	r3,12(r3)
811410fc:	18c00037 	ldwio	r3,0(r3)
81141100:	10c00035 	stwio	r3,0(r2)
81141104:	e0bff217 	ldw	r2,-56(fp)
81141108:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114110c:	e0bffb17 	ldw	r2,-20(fp)
81141110:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81141114:	e0bffe17 	ldw	r2,-8(fp)
81141118:	10001e26 	beq	r2,zero,81141194 <alt_msgdma_descriptor_async_transfer+0x194>
8114111c:	e0bfff17 	ldw	r2,-4(fp)
81141120:	10001c1e 	bne	r2,zero,81141194 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81141124:	00001106 	br	8114116c <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81141128:	01000044 	movi	r4,1
8114112c:	112ef6c0 	call	8112ef6c <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81141130:	e0bff00b 	ldhu	r2,-64(fp)
81141134:	1084e230 	cmpltui	r2,r2,5000
81141138:	1000091e 	bne	r2,zero,81141160 <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
8114113c:	01204534 	movhi	r4,33044
81141140:	21161404 	addi	r4,r4,22608
81141144:	11434cc0 	call	811434cc <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81141148:	e0bffd17 	ldw	r2,-12(fp)
8114114c:	10801817 	ldw	r2,96(r2)
81141150:	1009883a 	mov	r4,r2
81141154:	11379000 	call	81137900 <OSSemPost>
				
                return -ETIME;
81141158:	00bff084 	movi	r2,-62
8114115c:	00007306 	br	8114132c <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81141160:	e0bff00b 	ldhu	r2,-64(fp)
81141164:	10800044 	addi	r2,r2,1
81141168:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8114116c:	e0bffd17 	ldw	r2,-12(fp)
81141170:	10c00317 	ldw	r3,12(r2)
81141174:	e0bffd17 	ldw	r2,-12(fp)
81141178:	10800417 	ldw	r2,16(r2)
8114117c:	e1bffe17 	ldw	r6,-8(fp)
81141180:	100b883a 	mov	r5,r2
81141184:	1809883a 	mov	r4,r3
81141188:	1140ab40 	call	81140ab4 <alt_msgdma_write_standard_descriptor>
8114118c:	103fe61e 	bne	r2,zero,81141128 <__reset+0xfb121128>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81141190:	00002706 	br	81141230 <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81141194:	e0bffe17 	ldw	r2,-8(fp)
81141198:	10001f1e 	bne	r2,zero,81141218 <alt_msgdma_descriptor_async_transfer+0x218>
8114119c:	e0bfff17 	ldw	r2,-4(fp)
811411a0:	10001d26 	beq	r2,zero,81141218 <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
811411a4:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
811411a8:	00001106 	br	811411f0 <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
811411ac:	01000044 	movi	r4,1
811411b0:	112ef6c0 	call	8112ef6c <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811411b4:	e0bff00b 	ldhu	r2,-64(fp)
811411b8:	1084e230 	cmpltui	r2,r2,5000
811411bc:	1000091e 	bne	r2,zero,811411e4 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
811411c0:	01204534 	movhi	r4,33044
811411c4:	21162a04 	addi	r4,r4,22696
811411c8:	11434cc0 	call	811434cc <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811411cc:	e0bffd17 	ldw	r2,-12(fp)
811411d0:	10801817 	ldw	r2,96(r2)
811411d4:	1009883a 	mov	r4,r2
811411d8:	11379000 	call	81137900 <OSSemPost>
				
                return -ETIME;
811411dc:	00bff084 	movi	r2,-62
811411e0:	00005206 	br	8114132c <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
811411e4:	e0bff00b 	ldhu	r2,-64(fp)
811411e8:	10800044 	addi	r2,r2,1
811411ec:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
811411f0:	e0bffd17 	ldw	r2,-12(fp)
811411f4:	10c00317 	ldw	r3,12(r2)
811411f8:	e0bffd17 	ldw	r2,-12(fp)
811411fc:	10800417 	ldw	r2,16(r2)
81141200:	e1bfff17 	ldw	r6,-4(fp)
81141204:	100b883a 	mov	r5,r2
81141208:	1809883a 	mov	r4,r3
8114120c:	1140b500 	call	81140b50 <alt_msgdma_write_extended_descriptor>
81141210:	103fe61e 	bne	r2,zero,811411ac <__reset+0xfb1211ac>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81141214:	00000606 	br	81141230 <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81141218:	e0bffd17 	ldw	r2,-12(fp)
8114121c:	10801817 	ldw	r2,96(r2)
81141220:	1009883a 	mov	r4,r2
81141224:	11379000 	call	81137900 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81141228:	00bfffc4 	movi	r2,-1
8114122c:	00003f06 	br	8114132c <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
81141230:	e0bffd17 	ldw	r2,-12(fp)
81141234:	10800b17 	ldw	r2,44(r2)
81141238:	10001c26 	beq	r2,zero,811412ac <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
8114123c:	e0bffd17 	ldw	r2,-12(fp)
81141240:	10c00d17 	ldw	r3,52(r2)
81141244:	e0bff117 	ldw	r2,-60(fp)
81141248:	1884b03a 	or	r2,r3,r2
8114124c:	10800514 	ori	r2,r2,20
81141250:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81141254:	e0fff117 	ldw	r3,-60(fp)
81141258:	00bff7c4 	movi	r2,-33
8114125c:	1884703a 	and	r2,r3,r2
81141260:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81141264:	0005303a 	rdctl	r2,status
81141268:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114126c:	e0fff917 	ldw	r3,-28(fp)
81141270:	00bfff84 	movi	r2,-2
81141274:	1884703a 	and	r2,r3,r2
81141278:	1001703a 	wrctl	status,r2
  
  return context;
8114127c:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
81141280:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81141284:	e0bffd17 	ldw	r2,-12(fp)
81141288:	10800317 	ldw	r2,12(r2)
8114128c:	10800104 	addi	r2,r2,4
81141290:	e0fff117 	ldw	r3,-60(fp)
81141294:	10c00035 	stwio	r3,0(r2)
81141298:	e0bff217 	ldw	r2,-56(fp)
8114129c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811412a0:	e0bff517 	ldw	r2,-44(fp)
811412a4:	1001703a 	wrctl	status,r2
811412a8:	00001b06 	br	81141318 <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
811412ac:	e0bffd17 	ldw	r2,-12(fp)
811412b0:	10c00d17 	ldw	r3,52(r2)
811412b4:	e0bff117 	ldw	r2,-60(fp)
811412b8:	1884b03a 	or	r2,r3,r2
811412bc:	10800114 	ori	r2,r2,4
811412c0:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
811412c4:	e0fff117 	ldw	r3,-60(fp)
811412c8:	00bff3c4 	movi	r2,-49
811412cc:	1884703a 	and	r2,r3,r2
811412d0:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811412d4:	0005303a 	rdctl	r2,status
811412d8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811412dc:	e0fffa17 	ldw	r3,-24(fp)
811412e0:	00bfff84 	movi	r2,-2
811412e4:	1884703a 	and	r2,r3,r2
811412e8:	1001703a 	wrctl	status,r2
  
  return context;
811412ec:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
811412f0:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
811412f4:	e0bffd17 	ldw	r2,-12(fp)
811412f8:	10800317 	ldw	r2,12(r2)
811412fc:	10800104 	addi	r2,r2,4
81141300:	e0fff117 	ldw	r3,-60(fp)
81141304:	10c00035 	stwio	r3,0(r2)
81141308:	e0bff217 	ldw	r2,-56(fp)
8114130c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141310:	e0bff817 	ldw	r2,-32(fp)
81141314:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
81141318:	e0bffd17 	ldw	r2,-12(fp)
8114131c:	10801817 	ldw	r2,96(r2)
81141320:	1009883a 	mov	r4,r2
81141324:	11379000 	call	81137900 <OSSemPost>
    
    return 0;
81141328:	0005883a 	mov	r2,zero
}
8114132c:	e037883a 	mov	sp,fp
81141330:	dfc00117 	ldw	ra,4(sp)
81141334:	df000017 	ldw	fp,0(sp)
81141338:	dec00204 	addi	sp,sp,8
8114133c:	f800283a 	ret

81141340 <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
81141340:	deffee04 	addi	sp,sp,-72
81141344:	de00012e 	bgeu	sp,et,8114134c <alt_msgdma_descriptor_sync_transfer+0xc>
81141348:	003b68fa 	trap	3
8114134c:	dfc01115 	stw	ra,68(sp)
81141350:	df001015 	stw	fp,64(sp)
81141354:	df001004 	addi	fp,sp,64
81141358:	e13ffd15 	stw	r4,-12(fp)
8114135c:	e17ffe15 	stw	r5,-8(fp)
81141360:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
81141364:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
81141368:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
8114136c:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
81141370:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81141374:	e0bffd17 	ldw	r2,-12(fp)
81141378:	10800317 	ldw	r2,12(r2)
8114137c:	10800204 	addi	r2,r2,8
81141380:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
81141384:	10bfffcc 	andi	r2,r2,65535
81141388:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114138c:	e0bffd17 	ldw	r2,-12(fp)
81141390:	10800317 	ldw	r2,12(r2)
81141394:	10800204 	addi	r2,r2,8
81141398:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
8114139c:	1004d43a 	srli	r2,r2,16
811413a0:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
811413a4:	00807804 	movi	r2,480
811413a8:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811413ac:	00001906 	br	81141414 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
811413b0:	01000044 	movi	r4,1
811413b4:	112ef6c0 	call	8112ef6c <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811413b8:	e0bff10b 	ldhu	r2,-60(fp)
811413bc:	1084e230 	cmpltui	r2,r2,5000
811413c0:	1000051e 	bne	r2,zero,811413d8 <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
811413c4:	01204534 	movhi	r4,33044
811413c8:	21164004 	addi	r4,r4,22784
811413cc:	11434cc0 	call	811434cc <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
811413d0:	00bff084 	movi	r2,-62
811413d4:	0000d706 	br	81141734 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
811413d8:	e0bff10b 	ldhu	r2,-60(fp)
811413dc:	10800044 	addi	r2,r2,1
811413e0:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811413e4:	e0bffd17 	ldw	r2,-12(fp)
811413e8:	10800317 	ldw	r2,12(r2)
811413ec:	10800204 	addi	r2,r2,8
811413f0:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
811413f4:	10bfffcc 	andi	r2,r2,65535
811413f8:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811413fc:	e0bffd17 	ldw	r2,-12(fp)
81141400:	10800317 	ldw	r2,12(r2)
81141404:	10800204 	addi	r2,r2,8
81141408:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
8114140c:	1004d43a 	srli	r2,r2,16
81141410:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81141414:	e0bffd17 	ldw	r2,-12(fp)
81141418:	10800917 	ldw	r2,36(r2)
8114141c:	e0fff317 	ldw	r3,-52(fp)
81141420:	18bfe32e 	bgeu	r3,r2,811413b0 <__reset+0xfb1213b0>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
81141424:	e0bffd17 	ldw	r2,-12(fp)
81141428:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114142c:	e0fff217 	ldw	r3,-56(fp)
81141430:	18bfdf2e 	bgeu	r3,r2,811413b0 <__reset+0xfb1213b0>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
81141434:	e0bffd17 	ldw	r2,-12(fp)
81141438:	10801817 	ldw	r2,96(r2)
8114143c:	e0bff815 	stw	r2,-32(fp)
81141440:	e03ffc0d 	sth	zero,-16(fp)
81141444:	e0bffc0b 	ldhu	r2,-16(fp)
81141448:	e0fffc84 	addi	r3,fp,-14
8114144c:	180d883a 	mov	r6,r3
81141450:	100b883a 	mov	r5,r2
81141454:	e13ff817 	ldw	r4,-32(fp)
81141458:	11375780 	call	81137578 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114145c:	0005303a 	rdctl	r2,status
81141460:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81141464:	e0fffb17 	ldw	r3,-20(fp)
81141468:	00bfff84 	movi	r2,-2
8114146c:	1884703a 	and	r2,r3,r2
81141470:	1001703a 	wrctl	status,r2
  
  return context;
81141474:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
81141478:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8114147c:	e0bffd17 	ldw	r2,-12(fp)
81141480:	10800317 	ldw	r2,12(r2)
81141484:	10800104 	addi	r2,r2,4
81141488:	00c00804 	movi	r3,32
8114148c:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81141490:	e0bffd17 	ldw	r2,-12(fp)
81141494:	10800317 	ldw	r2,12(r2)
81141498:	e0fffd17 	ldw	r3,-12(fp)
8114149c:	18c00317 	ldw	r3,12(r3)
811414a0:	18c00037 	ldwio	r3,0(r3)
811414a4:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
811414a8:	e0bffe17 	ldw	r2,-8(fp)
811414ac:	10001f26 	beq	r2,zero,8114152c <alt_msgdma_descriptor_sync_transfer+0x1ec>
811414b0:	e0bfff17 	ldw	r2,-4(fp)
811414b4:	10001d1e 	bne	r2,zero,8114152c <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
811414b8:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
811414bc:	00001106 	br	81141504 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
811414c0:	01000044 	movi	r4,1
811414c4:	112ef6c0 	call	8112ef6c <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811414c8:	e0bff10b 	ldhu	r2,-60(fp)
811414cc:	1084e230 	cmpltui	r2,r2,5000
811414d0:	1000091e 	bne	r2,zero,811414f8 <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
811414d4:	01204534 	movhi	r4,33044
811414d8:	21165404 	addi	r4,r4,22864
811414dc:	11434cc0 	call	811434cc <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811414e0:	e0bffd17 	ldw	r2,-12(fp)
811414e4:	10801817 	ldw	r2,96(r2)
811414e8:	1009883a 	mov	r4,r2
811414ec:	11379000 	call	81137900 <OSSemPost>
				
                return -ETIME;
811414f0:	00bff084 	movi	r2,-62
811414f4:	00008f06 	br	81141734 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
811414f8:	e0bff10b 	ldhu	r2,-60(fp)
811414fc:	10800044 	addi	r2,r2,1
81141500:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81141504:	e0bffd17 	ldw	r2,-12(fp)
81141508:	10c00317 	ldw	r3,12(r2)
8114150c:	e0bffd17 	ldw	r2,-12(fp)
81141510:	10800417 	ldw	r2,16(r2)
81141514:	e1bffe17 	ldw	r6,-8(fp)
81141518:	100b883a 	mov	r5,r2
8114151c:	1809883a 	mov	r4,r3
81141520:	1140ab40 	call	81140ab4 <alt_msgdma_write_standard_descriptor>
81141524:	103fe61e 	bne	r2,zero,811414c0 <__reset+0xfb1214c0>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81141528:	00002706 	br	811415c8 <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
8114152c:	e0bffe17 	ldw	r2,-8(fp)
81141530:	10001f1e 	bne	r2,zero,811415b0 <alt_msgdma_descriptor_sync_transfer+0x270>
81141534:	e0bfff17 	ldw	r2,-4(fp)
81141538:	10001d26 	beq	r2,zero,811415b0 <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
8114153c:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81141540:	00001106 	br	81141588 <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81141544:	01000044 	movi	r4,1
81141548:	112ef6c0 	call	8112ef6c <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114154c:	e0bff10b 	ldhu	r2,-60(fp)
81141550:	1084e230 	cmpltui	r2,r2,5000
81141554:	1000091e 	bne	r2,zero,8114157c <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
81141558:	01204534 	movhi	r4,33044
8114155c:	21166504 	addi	r4,r4,22932
81141560:	11434cc0 	call	811434cc <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81141564:	e0bffd17 	ldw	r2,-12(fp)
81141568:	10801817 	ldw	r2,96(r2)
8114156c:	1009883a 	mov	r4,r2
81141570:	11379000 	call	81137900 <OSSemPost>
				
                return -ETIME;
81141574:	00bff084 	movi	r2,-62
81141578:	00006e06 	br	81141734 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
8114157c:	e0bff10b 	ldhu	r2,-60(fp)
81141580:	10800044 	addi	r2,r2,1
81141584:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81141588:	e0bffd17 	ldw	r2,-12(fp)
8114158c:	10c00317 	ldw	r3,12(r2)
81141590:	e0bffd17 	ldw	r2,-12(fp)
81141594:	10800417 	ldw	r2,16(r2)
81141598:	e1bfff17 	ldw	r6,-4(fp)
8114159c:	100b883a 	mov	r5,r2
811415a0:	1809883a 	mov	r4,r3
811415a4:	1140b500 	call	81140b50 <alt_msgdma_write_extended_descriptor>
811415a8:	103fe61e 	bne	r2,zero,81141544 <__reset+0xfb121544>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
811415ac:	00000606 	br	811415c8 <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
811415b0:	e0bffd17 	ldw	r2,-12(fp)
811415b4:	10801817 	ldw	r2,96(r2)
811415b8:	1009883a 	mov	r4,r2
811415bc:	11379000 	call	81137900 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
811415c0:	00bfffc4 	movi	r2,-1
811415c4:	00005b06 	br	81141734 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
811415c8:	e0bffd17 	ldw	r2,-12(fp)
811415cc:	10800317 	ldw	r2,12(r2)
811415d0:	10800104 	addi	r2,r2,4
811415d4:	e0fffd17 	ldw	r3,-12(fp)
811415d8:	19000d17 	ldw	r4,52(r3)
811415dc:	00fff2c4 	movi	r3,-53
811415e0:	20c6703a 	and	r3,r4,r3
811415e4:	18c00114 	ori	r3,r3,4
811415e8:	10c00035 	stwio	r3,0(r2)
811415ec:	e0bff517 	ldw	r2,-44(fp)
811415f0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811415f4:	e0bff717 	ldw	r2,-36(fp)
811415f8:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
811415fc:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81141600:	e0bffd17 	ldw	r2,-12(fp)
81141604:	10800317 	ldw	r2,12(r2)
81141608:	10800037 	ldwio	r2,0(r2)
8114160c:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81141610:	00001506 	br	81141668 <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
81141614:	01000044 	movi	r4,1
81141618:	112ef6c0 	call	8112ef6c <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
8114161c:	e0bff10b 	ldhu	r2,-60(fp)
81141620:	1084e230 	cmpltui	r2,r2,5000
81141624:	1000091e 	bne	r2,zero,8114164c <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
81141628:	01204534 	movhi	r4,33044
8114162c:	21167604 	addi	r4,r4,23000
81141630:	11434cc0 	call	811434cc <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
81141634:	e0bffd17 	ldw	r2,-12(fp)
81141638:	10801817 	ldw	r2,96(r2)
8114163c:	1009883a 	mov	r4,r2
81141640:	11379000 	call	81137900 <OSSemPost>
			
            return -ETIME;
81141644:	00bff084 	movi	r2,-62
81141648:	00003a06 	br	81141734 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
8114164c:	e0bff10b 	ldhu	r2,-60(fp)
81141650:	10800044 	addi	r2,r2,1
81141654:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81141658:	e0bffd17 	ldw	r2,-12(fp)
8114165c:	10800317 	ldw	r2,12(r2)
81141660:	10800037 	ldwio	r2,0(r2)
81141664:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81141668:	e0fff017 	ldw	r3,-64(fp)
8114166c:	e0bff617 	ldw	r2,-40(fp)
81141670:	1884703a 	and	r2,r3,r2
81141674:	1000031e 	bne	r2,zero,81141684 <alt_msgdma_descriptor_sync_transfer+0x344>
81141678:	e0bff017 	ldw	r2,-64(fp)
8114167c:	1080004c 	andi	r2,r2,1
81141680:	103fe41e 	bne	r2,zero,81141614 <__reset+0xfb121614>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
81141684:	e0fff017 	ldw	r3,-64(fp)
81141688:	e0bff617 	ldw	r2,-40(fp)
8114168c:	1884703a 	and	r2,r3,r2
81141690:	10000626 	beq	r2,zero,811416ac <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81141694:	e0bffd17 	ldw	r2,-12(fp)
81141698:	10801817 	ldw	r2,96(r2)
8114169c:	1009883a 	mov	r4,r2
811416a0:	11379000 	call	81137900 <OSSemPost>
		
        return error;
811416a4:	e0bff617 	ldw	r2,-40(fp)
811416a8:	00002206 	br	81141734 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
811416ac:	e0bffd17 	ldw	r2,-12(fp)
811416b0:	10800317 	ldw	r2,12(r2)
811416b4:	10800104 	addi	r2,r2,4
811416b8:	10800037 	ldwio	r2,0(r2)
811416bc:	10800814 	ori	r2,r2,32
811416c0:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811416c4:	0005303a 	rdctl	r2,status
811416c8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811416cc:	e0fffa17 	ldw	r3,-24(fp)
811416d0:	00bfff84 	movi	r2,-2
811416d4:	1884703a 	and	r2,r3,r2
811416d8:	1001703a 	wrctl	status,r2
  
  return context;
811416dc:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
811416e0:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
811416e4:	e0bffd17 	ldw	r2,-12(fp)
811416e8:	10800317 	ldw	r2,12(r2)
811416ec:	10800104 	addi	r2,r2,4
811416f0:	e0fff417 	ldw	r3,-48(fp)
811416f4:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
811416f8:	e0bffd17 	ldw	r2,-12(fp)
811416fc:	10800317 	ldw	r2,12(r2)
81141700:	e0fffd17 	ldw	r3,-12(fp)
81141704:	18c00317 	ldw	r3,12(r3)
81141708:	18c00037 	ldwio	r3,0(r3)
8114170c:	10c00035 	stwio	r3,0(r2)
81141710:	e0bff517 	ldw	r2,-44(fp)
81141714:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81141718:	e0bff917 	ldw	r2,-28(fp)
8114171c:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
81141720:	e0bffd17 	ldw	r2,-12(fp)
81141724:	10801817 	ldw	r2,96(r2)
81141728:	1009883a 	mov	r4,r2
8114172c:	11379000 	call	81137900 <OSSemPost>
    
    return 0;
81141730:	0005883a 	mov	r2,zero

}
81141734:	e037883a 	mov	sp,fp
81141738:	dfc00117 	ldw	ra,4(sp)
8114173c:	df000017 	ldw	fp,0(sp)
81141740:	dec00204 	addi	sp,sp,8
81141744:	f800283a 	ret

81141748 <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
81141748:	defff804 	addi	sp,sp,-32
8114174c:	de00012e 	bgeu	sp,et,81141754 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
81141750:	003b68fa 	trap	3
81141754:	dfc00715 	stw	ra,28(sp)
81141758:	df000615 	stw	fp,24(sp)
8114175c:	df000604 	addi	fp,sp,24
81141760:	e13ffc15 	stw	r4,-16(fp)
81141764:	e17ffd15 	stw	r5,-12(fp)
81141768:	e1bffe15 	stw	r6,-8(fp)
8114176c:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
81141770:	e0800217 	ldw	r2,8(fp)
81141774:	d8800115 	stw	r2,4(sp)
81141778:	e0bfff17 	ldw	r2,-4(fp)
8114177c:	d8800015 	stw	r2,0(sp)
81141780:	e1fffe17 	ldw	r7,-8(fp)
81141784:	000d883a 	mov	r6,zero
81141788:	e17ffd17 	ldw	r5,-12(fp)
8114178c:	e13ffc17 	ldw	r4,-16(fp)
81141790:	1140e100 	call	81140e10 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81141794:	e037883a 	mov	sp,fp
81141798:	dfc00117 	ldw	ra,4(sp)
8114179c:	df000017 	ldw	fp,0(sp)
811417a0:	dec00204 	addi	sp,sp,8
811417a4:	f800283a 	ret

811417a8 <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
811417a8:	defff804 	addi	sp,sp,-32
811417ac:	de00012e 	bgeu	sp,et,811417b4 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
811417b0:	003b68fa 	trap	3
811417b4:	dfc00715 	stw	ra,28(sp)
811417b8:	df000615 	stw	fp,24(sp)
811417bc:	df000604 	addi	fp,sp,24
811417c0:	e13ffc15 	stw	r4,-16(fp)
811417c4:	e17ffd15 	stw	r5,-12(fp)
811417c8:	e1bffe15 	stw	r6,-8(fp)
811417cc:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
811417d0:	e0800217 	ldw	r2,8(fp)
811417d4:	d8800115 	stw	r2,4(sp)
811417d8:	e0bfff17 	ldw	r2,-4(fp)
811417dc:	d8800015 	stw	r2,0(sp)
811417e0:	000f883a 	mov	r7,zero
811417e4:	e1bffe17 	ldw	r6,-8(fp)
811417e8:	e17ffd17 	ldw	r5,-12(fp)
811417ec:	e13ffc17 	ldw	r4,-16(fp)
811417f0:	1140e100 	call	81140e10 <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
811417f4:	e037883a 	mov	sp,fp
811417f8:	dfc00117 	ldw	ra,4(sp)
811417fc:	df000017 	ldw	fp,0(sp)
81141800:	dec00204 	addi	sp,sp,8
81141804:	f800283a 	ret

81141808 <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81141808:	defff804 	addi	sp,sp,-32
8114180c:	de00012e 	bgeu	sp,et,81141814 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
81141810:	003b68fa 	trap	3
81141814:	dfc00715 	stw	ra,28(sp)
81141818:	df000615 	stw	fp,24(sp)
8114181c:	df000604 	addi	fp,sp,24
81141820:	e13ffc15 	stw	r4,-16(fp)
81141824:	e17ffd15 	stw	r5,-12(fp)
81141828:	e1bffe15 	stw	r6,-8(fp)
8114182c:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81141830:	e0800317 	ldw	r2,12(fp)
81141834:	d8800115 	stw	r2,4(sp)
81141838:	e0800217 	ldw	r2,8(fp)
8114183c:	d8800015 	stw	r2,0(sp)
81141840:	e1ffff17 	ldw	r7,-4(fp)
81141844:	e1bffe17 	ldw	r6,-8(fp)
81141848:	e17ffd17 	ldw	r5,-12(fp)
8114184c:	e13ffc17 	ldw	r4,-16(fp)
81141850:	1140e100 	call	81140e10 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81141854:	e037883a 	mov	sp,fp
81141858:	dfc00117 	ldw	ra,4(sp)
8114185c:	df000017 	ldw	fp,0(sp)
81141860:	dec00204 	addi	sp,sp,8
81141864:	f800283a 	ret

81141868 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
81141868:	defff004 	addi	sp,sp,-64
8114186c:	de00012e 	bgeu	sp,et,81141874 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
81141870:	003b68fa 	trap	3
81141874:	dfc00f15 	stw	ra,60(sp)
81141878:	df000e15 	stw	fp,56(sp)
8114187c:	df000e04 	addi	fp,sp,56
81141880:	e13ff915 	stw	r4,-28(fp)
81141884:	e17ffa15 	stw	r5,-24(fp)
81141888:	e1bffb15 	stw	r6,-20(fp)
8114188c:	e1fffc15 	stw	r7,-16(fp)
81141890:	e1000317 	ldw	r4,12(fp)
81141894:	e0c00417 	ldw	r3,16(fp)
81141898:	e0800517 	ldw	r2,20(fp)
8114189c:	e13ffd0d 	sth	r4,-12(fp)
811418a0:	e0fffe05 	stb	r3,-8(fp)
811418a4:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
811418a8:	e0bffd0b 	ldhu	r2,-12(fp)
811418ac:	e0fffe03 	ldbu	r3,-8(fp)
811418b0:	e13fff0b 	ldhu	r4,-4(fp)
811418b4:	d9000615 	stw	r4,24(sp)
811418b8:	d8000515 	stw	zero,20(sp)
811418bc:	d8c00415 	stw	r3,16(sp)
811418c0:	d8000315 	stw	zero,12(sp)
811418c4:	d8800215 	stw	r2,8(sp)
811418c8:	e0800217 	ldw	r2,8(fp)
811418cc:	d8800115 	stw	r2,4(sp)
811418d0:	e0bffc17 	ldw	r2,-16(fp)
811418d4:	d8800015 	stw	r2,0(sp)
811418d8:	e1fffb17 	ldw	r7,-20(fp)
811418dc:	000d883a 	mov	r6,zero
811418e0:	e17ffa17 	ldw	r5,-24(fp)
811418e4:	e13ff917 	ldw	r4,-28(fp)
811418e8:	1140ea40 	call	81140ea4 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
811418ec:	e037883a 	mov	sp,fp
811418f0:	dfc00117 	ldw	ra,4(sp)
811418f4:	df000017 	ldw	fp,0(sp)
811418f8:	dec00204 	addi	sp,sp,8
811418fc:	f800283a 	ret

81141900 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81141900:	defff004 	addi	sp,sp,-64
81141904:	de00012e 	bgeu	sp,et,8114190c <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
81141908:	003b68fa 	trap	3
8114190c:	dfc00f15 	stw	ra,60(sp)
81141910:	df000e15 	stw	fp,56(sp)
81141914:	df000e04 	addi	fp,sp,56
81141918:	e13ff915 	stw	r4,-28(fp)
8114191c:	e17ffa15 	stw	r5,-24(fp)
81141920:	e1bffb15 	stw	r6,-20(fp)
81141924:	e1fffc15 	stw	r7,-16(fp)
81141928:	e1000317 	ldw	r4,12(fp)
8114192c:	e0c00417 	ldw	r3,16(fp)
81141930:	e0800517 	ldw	r2,20(fp)
81141934:	e13ffd0d 	sth	r4,-12(fp)
81141938:	e0fffe05 	stb	r3,-8(fp)
8114193c:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
81141940:	e0bffd0b 	ldhu	r2,-12(fp)
81141944:	e0fffe03 	ldbu	r3,-8(fp)
81141948:	e13fff0b 	ldhu	r4,-4(fp)
8114194c:	d8000615 	stw	zero,24(sp)
81141950:	d9000515 	stw	r4,20(sp)
81141954:	d8000415 	stw	zero,16(sp)
81141958:	d8c00315 	stw	r3,12(sp)
8114195c:	d8800215 	stw	r2,8(sp)
81141960:	e0800217 	ldw	r2,8(fp)
81141964:	d8800115 	stw	r2,4(sp)
81141968:	e0bffc17 	ldw	r2,-16(fp)
8114196c:	d8800015 	stw	r2,0(sp)
81141970:	000f883a 	mov	r7,zero
81141974:	e1bffb17 	ldw	r6,-20(fp)
81141978:	e17ffa17 	ldw	r5,-24(fp)
8114197c:	e13ff917 	ldw	r4,-28(fp)
81141980:	1140ea40 	call	81140ea4 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
81141984:	e037883a 	mov	sp,fp
81141988:	dfc00117 	ldw	ra,4(sp)
8114198c:	df000017 	ldw	fp,0(sp)
81141990:	dec00204 	addi	sp,sp,8
81141994:	f800283a 	ret

81141998 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
81141998:	deffee04 	addi	sp,sp,-72
8114199c:	de00012e 	bgeu	sp,et,811419a4 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
811419a0:	003b68fa 	trap	3
811419a4:	dfc01115 	stw	ra,68(sp)
811419a8:	df001015 	stw	fp,64(sp)
811419ac:	df001004 	addi	fp,sp,64
811419b0:	e13ff715 	stw	r4,-36(fp)
811419b4:	e17ff815 	stw	r5,-32(fp)
811419b8:	e1bff915 	stw	r6,-28(fp)
811419bc:	e1fffa15 	stw	r7,-24(fp)
811419c0:	e1800417 	ldw	r6,16(fp)
811419c4:	e1400517 	ldw	r5,20(fp)
811419c8:	e1000617 	ldw	r4,24(fp)
811419cc:	e0c00717 	ldw	r3,28(fp)
811419d0:	e0800817 	ldw	r2,32(fp)
811419d4:	e1bffb0d 	sth	r6,-20(fp)
811419d8:	e17ffc05 	stb	r5,-16(fp)
811419dc:	e13ffd05 	stb	r4,-12(fp)
811419e0:	e0fffe0d 	sth	r3,-8(fp)
811419e4:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
811419e8:	e0bffb0b 	ldhu	r2,-20(fp)
811419ec:	e0fffc03 	ldbu	r3,-16(fp)
811419f0:	e13ffd03 	ldbu	r4,-12(fp)
811419f4:	e17ffe0b 	ldhu	r5,-8(fp)
811419f8:	e1bfff0b 	ldhu	r6,-4(fp)
811419fc:	d9800615 	stw	r6,24(sp)
81141a00:	d9400515 	stw	r5,20(sp)
81141a04:	d9000415 	stw	r4,16(sp)
81141a08:	d8c00315 	stw	r3,12(sp)
81141a0c:	d8800215 	stw	r2,8(sp)
81141a10:	e0800317 	ldw	r2,12(fp)
81141a14:	d8800115 	stw	r2,4(sp)
81141a18:	e0800217 	ldw	r2,8(fp)
81141a1c:	d8800015 	stw	r2,0(sp)
81141a20:	e1fffa17 	ldw	r7,-24(fp)
81141a24:	e1bff917 	ldw	r6,-28(fp)
81141a28:	e17ff817 	ldw	r5,-32(fp)
81141a2c:	e13ff717 	ldw	r4,-36(fp)
81141a30:	1140ea40 	call	81140ea4 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
81141a34:	e037883a 	mov	sp,fp
81141a38:	dfc00117 	ldw	ra,4(sp)
81141a3c:	df000017 	ldw	fp,0(sp)
81141a40:	dec00204 	addi	sp,sp,8
81141a44:	f800283a 	ret

81141a48 <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81141a48:	defffb04 	addi	sp,sp,-20
81141a4c:	de00012e 	bgeu	sp,et,81141a54 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
81141a50:	003b68fa 	trap	3
81141a54:	df000415 	stw	fp,16(sp)
81141a58:	df000404 	addi	fp,sp,16
81141a5c:	e13ffc15 	stw	r4,-16(fp)
81141a60:	e17ffd15 	stw	r5,-12(fp)
81141a64:	e1bffe15 	stw	r6,-8(fp)
81141a68:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81141a6c:	e0bffc17 	ldw	r2,-16(fp)
81141a70:	10c01217 	ldw	r3,72(r2)
81141a74:	e0800117 	ldw	r2,4(fp)
81141a78:	18800436 	bltu	r3,r2,81141a8c <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
81141a7c:	e0bffc17 	ldw	r2,-16(fp)
81141a80:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81141a84:	10803fcc 	andi	r2,r2,255
81141a88:	10000226 	beq	r2,zero,81141a94 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
81141a8c:	00bffa84 	movi	r2,-22
81141a90:	00001406 	br	81141ae4 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
81141a94:	e0bffd17 	ldw	r2,-12(fp)
81141a98:	e0fffe17 	ldw	r3,-8(fp)
81141a9c:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81141aa0:	e0bffd17 	ldw	r2,-12(fp)
81141aa4:	e0ffff17 	ldw	r3,-4(fp)
81141aa8:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81141aac:	e0bffd17 	ldw	r2,-12(fp)
81141ab0:	e0c00117 	ldw	r3,4(fp)
81141ab4:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
81141ab8:	e0fffd17 	ldw	r3,-12(fp)
81141abc:	e0bffd17 	ldw	r2,-12(fp)
81141ac0:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81141ac4:	e0c00217 	ldw	r3,8(fp)
81141ac8:	00900034 	movhi	r2,16384
81141acc:	10bfffc4 	addi	r2,r2,-1
81141ad0:	1884703a 	and	r2,r3,r2
81141ad4:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
81141ad8:	e0bffd17 	ldw	r2,-12(fp)
81141adc:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
81141ae0:	0005883a 	mov	r2,zero
}
81141ae4:	e037883a 	mov	sp,fp
81141ae8:	df000017 	ldw	fp,0(sp)
81141aec:	dec00104 	addi	sp,sp,4
81141af0:	f800283a 	ret

81141af4 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81141af4:	defff404 	addi	sp,sp,-48
81141af8:	de00012e 	bgeu	sp,et,81141b00 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
81141afc:	003b68fa 	trap	3
81141b00:	df000b15 	stw	fp,44(sp)
81141b04:	df000b04 	addi	fp,sp,44
81141b08:	e13ff715 	stw	r4,-36(fp)
81141b0c:	e17ff815 	stw	r5,-32(fp)
81141b10:	e1bff915 	stw	r6,-28(fp)
81141b14:	e1fffa15 	stw	r7,-24(fp)
81141b18:	e1800517 	ldw	r6,20(fp)
81141b1c:	e1400617 	ldw	r5,24(fp)
81141b20:	e1000717 	ldw	r4,28(fp)
81141b24:	e0c00817 	ldw	r3,32(fp)
81141b28:	e0800917 	ldw	r2,36(fp)
81141b2c:	e1bffb0d 	sth	r6,-20(fp)
81141b30:	e17ffc05 	stb	r5,-16(fp)
81141b34:	e13ffd05 	stb	r4,-12(fp)
81141b38:	e0fffe0d 	sth	r3,-8(fp)
81141b3c:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
81141b40:	e0bff717 	ldw	r2,-36(fp)
81141b44:	10c01217 	ldw	r3,72(r2)
81141b48:	e0800317 	ldw	r2,12(fp)
81141b4c:	18801936 	bltu	r3,r2,81141bb4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
81141b50:	e13ff717 	ldw	r4,-36(fp)
81141b54:	20801317 	ldw	r2,76(r4)
81141b58:	20c01417 	ldw	r3,80(r4)
81141b5c:	e13ffe0b 	ldhu	r4,-8(fp)
81141b60:	213fffcc 	andi	r4,r4,65535
81141b64:	2015883a 	mov	r10,r4
81141b68:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
81141b6c:	1ac01136 	bltu	r3,r11,81141bb4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81141b70:	58c0011e 	bne	r11,r3,81141b78 <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
81141b74:	12800f36 	bltu	r2,r10,81141bb4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81141b78:	e13ff717 	ldw	r4,-36(fp)
81141b7c:	20801317 	ldw	r2,76(r4)
81141b80:	20c01417 	ldw	r3,80(r4)
81141b84:	e13fff0b 	ldhu	r4,-4(fp)
81141b88:	213fffcc 	andi	r4,r4,65535
81141b8c:	2011883a 	mov	r8,r4
81141b90:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81141b94:	1a400736 	bltu	r3,r9,81141bb4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81141b98:	48c0011e 	bne	r9,r3,81141ba0 <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
81141b9c:	12000536 	bltu	r2,r8,81141bb4 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
81141ba0:	e0bff717 	ldw	r2,-36(fp)
81141ba4:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81141ba8:	10803fcc 	andi	r2,r2,255
81141bac:	10800060 	cmpeqi	r2,r2,1
81141bb0:	1000021e 	bne	r2,zero,81141bbc <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81141bb4:	00bffa84 	movi	r2,-22
81141bb8:	00003106 	br	81141c80 <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
81141bbc:	e0bff817 	ldw	r2,-32(fp)
81141bc0:	e0fff917 	ldw	r3,-28(fp)
81141bc4:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
81141bc8:	e0bff817 	ldw	r2,-32(fp)
81141bcc:	e0fffa17 	ldw	r3,-24(fp)
81141bd0:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
81141bd4:	e0bff817 	ldw	r2,-32(fp)
81141bd8:	e0c00117 	ldw	r3,4(fp)
81141bdc:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
81141be0:	e0bff817 	ldw	r2,-32(fp)
81141be4:	e0c00217 	ldw	r3,8(fp)
81141be8:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81141bec:	e0bff817 	ldw	r2,-32(fp)
81141bf0:	e0c00317 	ldw	r3,12(fp)
81141bf4:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81141bf8:	e0bff817 	ldw	r2,-32(fp)
81141bfc:	e0fffb0b 	ldhu	r3,-20(fp)
81141c00:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
81141c04:	e0bff817 	ldw	r2,-32(fp)
81141c08:	e0fffc03 	ldbu	r3,-16(fp)
81141c0c:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
81141c10:	e0bff817 	ldw	r2,-32(fp)
81141c14:	e0fffd03 	ldbu	r3,-12(fp)
81141c18:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
81141c1c:	e0bff817 	ldw	r2,-32(fp)
81141c20:	e0fffe0b 	ldhu	r3,-8(fp)
81141c24:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
81141c28:	e0bff817 	ldw	r2,-32(fp)
81141c2c:	e0ffff0b 	ldhu	r3,-4(fp)
81141c30:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
81141c34:	e0bff817 	ldw	r2,-32(fp)
81141c38:	1019883a 	mov	r12,r2
81141c3c:	001b883a 	mov	r13,zero
81141c40:	e33ff515 	stw	r12,-44(fp)
81141c44:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
81141c48:	e0fff517 	ldw	r3,-44(fp)
81141c4c:	e0bff817 	ldw	r2,-32(fp)
81141c50:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
81141c54:	e0fff617 	ldw	r3,-40(fp)
81141c58:	e0bff817 	ldw	r2,-32(fp)
81141c5c:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81141c60:	e0c00417 	ldw	r3,16(fp)
81141c64:	00900034 	movhi	r2,16384
81141c68:	10bfffc4 	addi	r2,r2,-1
81141c6c:	1884703a 	and	r2,r3,r2
81141c70:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
81141c74:	e0bff817 	ldw	r2,-32(fp)
81141c78:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
81141c7c:	0005883a 	mov	r2,zero
}
81141c80:	e037883a 	mov	sp,fp
81141c84:	df000017 	ldw	fp,0(sp)
81141c88:	dec00104 	addi	sp,sp,4
81141c8c:	f800283a 	ret

81141c90 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
81141c90:	defff804 	addi	sp,sp,-32
81141c94:	de00012e 	bgeu	sp,et,81141c9c <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
81141c98:	003b68fa 	trap	3
81141c9c:	dfc00715 	stw	ra,28(sp)
81141ca0:	df000615 	stw	fp,24(sp)
81141ca4:	df000604 	addi	fp,sp,24
81141ca8:	e13ffc15 	stw	r4,-16(fp)
81141cac:	e17ffd15 	stw	r5,-12(fp)
81141cb0:	e1bffe15 	stw	r6,-8(fp)
81141cb4:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81141cb8:	e0800317 	ldw	r2,12(fp)
81141cbc:	d8800115 	stw	r2,4(sp)
81141cc0:	e0800217 	ldw	r2,8(fp)
81141cc4:	d8800015 	stw	r2,0(sp)
81141cc8:	e1ffff17 	ldw	r7,-4(fp)
81141ccc:	e1bffe17 	ldw	r6,-8(fp)
81141cd0:	e17ffd17 	ldw	r5,-12(fp)
81141cd4:	e13ffc17 	ldw	r4,-16(fp)
81141cd8:	1141a480 	call	81141a48 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
81141cdc:	e037883a 	mov	sp,fp
81141ce0:	dfc00117 	ldw	ra,4(sp)
81141ce4:	df000017 	ldw	fp,0(sp)
81141ce8:	dec00204 	addi	sp,sp,8
81141cec:	f800283a 	ret

81141cf0 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81141cf0:	defff804 	addi	sp,sp,-32
81141cf4:	de00012e 	bgeu	sp,et,81141cfc <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
81141cf8:	003b68fa 	trap	3
81141cfc:	dfc00715 	stw	ra,28(sp)
81141d00:	df000615 	stw	fp,24(sp)
81141d04:	df000604 	addi	fp,sp,24
81141d08:	e13ffc15 	stw	r4,-16(fp)
81141d0c:	e17ffd15 	stw	r5,-12(fp)
81141d10:	e1bffe15 	stw	r6,-8(fp)
81141d14:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81141d18:	e0800217 	ldw	r2,8(fp)
81141d1c:	d8800115 	stw	r2,4(sp)
81141d20:	e0bfff17 	ldw	r2,-4(fp)
81141d24:	d8800015 	stw	r2,0(sp)
81141d28:	e1fffe17 	ldw	r7,-8(fp)
81141d2c:	000d883a 	mov	r6,zero
81141d30:	e17ffd17 	ldw	r5,-12(fp)
81141d34:	e13ffc17 	ldw	r4,-16(fp)
81141d38:	1141a480 	call	81141a48 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
81141d3c:	e037883a 	mov	sp,fp
81141d40:	dfc00117 	ldw	ra,4(sp)
81141d44:	df000017 	ldw	fp,0(sp)
81141d48:	dec00204 	addi	sp,sp,8
81141d4c:	f800283a 	ret

81141d50 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
81141d50:	defff804 	addi	sp,sp,-32
81141d54:	de00012e 	bgeu	sp,et,81141d5c <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
81141d58:	003b68fa 	trap	3
81141d5c:	dfc00715 	stw	ra,28(sp)
81141d60:	df000615 	stw	fp,24(sp)
81141d64:	df000604 	addi	fp,sp,24
81141d68:	e13ffc15 	stw	r4,-16(fp)
81141d6c:	e17ffd15 	stw	r5,-12(fp)
81141d70:	e1bffe15 	stw	r6,-8(fp)
81141d74:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81141d78:	e0800217 	ldw	r2,8(fp)
81141d7c:	d8800115 	stw	r2,4(sp)
81141d80:	e0bfff17 	ldw	r2,-4(fp)
81141d84:	d8800015 	stw	r2,0(sp)
81141d88:	000f883a 	mov	r7,zero
81141d8c:	e1bffe17 	ldw	r6,-8(fp)
81141d90:	e17ffd17 	ldw	r5,-12(fp)
81141d94:	e13ffc17 	ldw	r4,-16(fp)
81141d98:	1141a480 	call	81141a48 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
81141d9c:	e037883a 	mov	sp,fp
81141da0:	dfc00117 	ldw	ra,4(sp)
81141da4:	df000017 	ldw	fp,0(sp)
81141da8:	dec00204 	addi	sp,sp,8
81141dac:	f800283a 	ret

81141db0 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
81141db0:	deffee04 	addi	sp,sp,-72
81141db4:	de00012e 	bgeu	sp,et,81141dbc <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
81141db8:	003b68fa 	trap	3
81141dbc:	dfc01115 	stw	ra,68(sp)
81141dc0:	df001015 	stw	fp,64(sp)
81141dc4:	df001004 	addi	fp,sp,64
81141dc8:	e13ff915 	stw	r4,-28(fp)
81141dcc:	e17ffa15 	stw	r5,-24(fp)
81141dd0:	e1bffb15 	stw	r6,-20(fp)
81141dd4:	e1fffc15 	stw	r7,-16(fp)
81141dd8:	e1000417 	ldw	r4,16(fp)
81141ddc:	e0c00517 	ldw	r3,20(fp)
81141de0:	e0800617 	ldw	r2,24(fp)
81141de4:	e13ffd0d 	sth	r4,-12(fp)
81141de8:	e0fffe05 	stb	r3,-8(fp)
81141dec:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
81141df0:	e0bffd0b 	ldhu	r2,-12(fp)
81141df4:	e0fffe03 	ldbu	r3,-8(fp)
81141df8:	e13fff0b 	ldhu	r4,-4(fp)
81141dfc:	d9000815 	stw	r4,32(sp)
81141e00:	d8000715 	stw	zero,28(sp)
81141e04:	d8c00615 	stw	r3,24(sp)
81141e08:	d8000515 	stw	zero,20(sp)
81141e0c:	d8800415 	stw	r2,16(sp)
81141e10:	e0800317 	ldw	r2,12(fp)
81141e14:	d8800315 	stw	r2,12(sp)
81141e18:	e0800217 	ldw	r2,8(fp)
81141e1c:	d8800215 	stw	r2,8(sp)
81141e20:	e0bffc17 	ldw	r2,-16(fp)
81141e24:	d8800115 	stw	r2,4(sp)
81141e28:	e0bffb17 	ldw	r2,-20(fp)
81141e2c:	d8800015 	stw	r2,0(sp)
81141e30:	000f883a 	mov	r7,zero
81141e34:	000d883a 	mov	r6,zero
81141e38:	e17ffa17 	ldw	r5,-24(fp)
81141e3c:	e13ff917 	ldw	r4,-28(fp)
81141e40:	1141af40 	call	81141af4 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
81141e44:	e037883a 	mov	sp,fp
81141e48:	dfc00117 	ldw	ra,4(sp)
81141e4c:	df000017 	ldw	fp,0(sp)
81141e50:	dec00204 	addi	sp,sp,8
81141e54:	f800283a 	ret

81141e58 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81141e58:	deffee04 	addi	sp,sp,-72
81141e5c:	de00012e 	bgeu	sp,et,81141e64 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
81141e60:	003b68fa 	trap	3
81141e64:	dfc01115 	stw	ra,68(sp)
81141e68:	df001015 	stw	fp,64(sp)
81141e6c:	df001004 	addi	fp,sp,64
81141e70:	e13ff915 	stw	r4,-28(fp)
81141e74:	e17ffa15 	stw	r5,-24(fp)
81141e78:	e1bffb15 	stw	r6,-20(fp)
81141e7c:	e1fffc15 	stw	r7,-16(fp)
81141e80:	e1000417 	ldw	r4,16(fp)
81141e84:	e0c00517 	ldw	r3,20(fp)
81141e88:	e0800617 	ldw	r2,24(fp)
81141e8c:	e13ffd0d 	sth	r4,-12(fp)
81141e90:	e0fffe05 	stb	r3,-8(fp)
81141e94:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
81141e98:	e0bffd0b 	ldhu	r2,-12(fp)
81141e9c:	e0fffe03 	ldbu	r3,-8(fp)
81141ea0:	e13fff0b 	ldhu	r4,-4(fp)
81141ea4:	d8000815 	stw	zero,32(sp)
81141ea8:	d9000715 	stw	r4,28(sp)
81141eac:	d8000615 	stw	zero,24(sp)
81141eb0:	d8c00515 	stw	r3,20(sp)
81141eb4:	d8800415 	stw	r2,16(sp)
81141eb8:	e0800317 	ldw	r2,12(fp)
81141ebc:	d8800315 	stw	r2,12(sp)
81141ec0:	e0800217 	ldw	r2,8(fp)
81141ec4:	d8800215 	stw	r2,8(sp)
81141ec8:	d8000115 	stw	zero,4(sp)
81141ecc:	d8000015 	stw	zero,0(sp)
81141ed0:	e1fffc17 	ldw	r7,-16(fp)
81141ed4:	e1bffb17 	ldw	r6,-20(fp)
81141ed8:	e17ffa17 	ldw	r5,-24(fp)
81141edc:	e13ff917 	ldw	r4,-28(fp)
81141ee0:	1141af40 	call	81141af4 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
81141ee4:	e037883a 	mov	sp,fp
81141ee8:	dfc00117 	ldw	ra,4(sp)
81141eec:	df000017 	ldw	fp,0(sp)
81141ef0:	dec00204 	addi	sp,sp,8
81141ef4:	f800283a 	ret

81141ef8 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81141ef8:	deffec04 	addi	sp,sp,-80
81141efc:	de00012e 	bgeu	sp,et,81141f04 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
81141f00:	003b68fa 	trap	3
81141f04:	dfc01315 	stw	ra,76(sp)
81141f08:	df001215 	stw	fp,72(sp)
81141f0c:	df001204 	addi	fp,sp,72
81141f10:	e13ff715 	stw	r4,-36(fp)
81141f14:	e17ff815 	stw	r5,-32(fp)
81141f18:	e1bff915 	stw	r6,-28(fp)
81141f1c:	e1fffa15 	stw	r7,-24(fp)
81141f20:	e1800617 	ldw	r6,24(fp)
81141f24:	e1400717 	ldw	r5,28(fp)
81141f28:	e1000817 	ldw	r4,32(fp)
81141f2c:	e0c00917 	ldw	r3,36(fp)
81141f30:	e0800a17 	ldw	r2,40(fp)
81141f34:	e1bffb0d 	sth	r6,-20(fp)
81141f38:	e17ffc05 	stb	r5,-16(fp)
81141f3c:	e13ffd05 	stb	r4,-12(fp)
81141f40:	e0fffe0d 	sth	r3,-8(fp)
81141f44:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
81141f48:	e0bffb0b 	ldhu	r2,-20(fp)
81141f4c:	e0fffc03 	ldbu	r3,-16(fp)
81141f50:	e13ffd03 	ldbu	r4,-12(fp)
81141f54:	e17ffe0b 	ldhu	r5,-8(fp)
81141f58:	e1bfff0b 	ldhu	r6,-4(fp)
81141f5c:	d9800815 	stw	r6,32(sp)
81141f60:	d9400715 	stw	r5,28(sp)
81141f64:	d9000615 	stw	r4,24(sp)
81141f68:	d8c00515 	stw	r3,20(sp)
81141f6c:	d8800415 	stw	r2,16(sp)
81141f70:	e0800517 	ldw	r2,20(fp)
81141f74:	d8800315 	stw	r2,12(sp)
81141f78:	e0800417 	ldw	r2,16(fp)
81141f7c:	d8800215 	stw	r2,8(sp)
81141f80:	e0800317 	ldw	r2,12(fp)
81141f84:	d8800115 	stw	r2,4(sp)
81141f88:	e0800217 	ldw	r2,8(fp)
81141f8c:	d8800015 	stw	r2,0(sp)
81141f90:	e1fffa17 	ldw	r7,-24(fp)
81141f94:	e1bff917 	ldw	r6,-28(fp)
81141f98:	e17ff817 	ldw	r5,-32(fp)
81141f9c:	e13ff717 	ldw	r4,-36(fp)
81141fa0:	1141af40 	call	81141af4 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
81141fa4:	e037883a 	mov	sp,fp
81141fa8:	dfc00117 	ldw	ra,4(sp)
81141fac:	df000017 	ldw	fp,0(sp)
81141fb0:	dec00204 	addi	sp,sp,8
81141fb4:	f800283a 	ret

81141fb8 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
81141fb8:	defffc04 	addi	sp,sp,-16
81141fbc:	de00012e 	bgeu	sp,et,81141fc4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
81141fc0:	003b68fa 	trap	3
81141fc4:	df000315 	stw	fp,12(sp)
81141fc8:	df000304 	addi	fp,sp,12
81141fcc:	e13ffe15 	stw	r4,-8(fp)
81141fd0:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
81141fd4:	e0bfff17 	ldw	r2,-4(fp)
81141fd8:	1000021e 	bne	r2,zero,81141fe4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
81141fdc:	00bffa84 	movi	r2,-22
81141fe0:	00002f06 	br	811420a0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
81141fe4:	e0bfff17 	ldw	r2,-4(fp)
81141fe8:	10c00317 	ldw	r3,12(r2)
81141fec:	e0bfff17 	ldw	r2,-4(fp)
81141ff0:	18800226 	beq	r3,r2,81141ffc <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
81141ff4:	00bffa84 	movi	r2,-22
81141ff8:	00002906 	br	811420a0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
81141ffc:	e0bffe17 	ldw	r2,-8(fp)
81142000:	10800017 	ldw	r2,0(r2)
81142004:	1000051e 	bne	r2,zero,8114201c <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
81142008:	e0bffe17 	ldw	r2,-8(fp)
8114200c:	e0ffff17 	ldw	r3,-4(fp)
81142010:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
81142014:	0005883a 	mov	r2,zero
81142018:	00002106 	br	811420a0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
8114201c:	e0bffe17 	ldw	r2,-8(fp)
81142020:	10c00017 	ldw	r3,0(r2)
81142024:	e0bfff17 	ldw	r2,-4(fp)
81142028:	1880021e 	bne	r3,r2,81142034 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
8114202c:	00bffa84 	movi	r2,-22
81142030:	00001b06 	br	811420a0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
81142034:	e0bffe17 	ldw	r2,-8(fp)
81142038:	10800017 	ldw	r2,0(r2)
8114203c:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
81142040:	00000906 	br	81142068 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
81142044:	e0bffd17 	ldw	r2,-12(fp)
81142048:	10c00317 	ldw	r3,12(r2)
8114204c:	e0bfff17 	ldw	r2,-4(fp)
81142050:	1880021e 	bne	r3,r2,8114205c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
81142054:	00bffa84 	movi	r2,-22
81142058:	00001106 	br	811420a0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
8114205c:	e0bffd17 	ldw	r2,-12(fp)
81142060:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
81142064:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
81142068:	e0bffd17 	ldw	r2,-12(fp)
8114206c:	10800317 	ldw	r2,12(r2)
81142070:	e0fffe17 	ldw	r3,-8(fp)
81142074:	18c00017 	ldw	r3,0(r3)
81142078:	10fff21e 	bne	r2,r3,81142044 <__reset+0xfb122044>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
8114207c:	e0ffff17 	ldw	r3,-4(fp)
81142080:	e0bffd17 	ldw	r2,-12(fp)
81142084:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
81142088:	e0bffe17 	ldw	r2,-8(fp)
8114208c:	10800017 	ldw	r2,0(r2)
81142090:	1007883a 	mov	r3,r2
81142094:	e0bfff17 	ldw	r2,-4(fp)
81142098:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
8114209c:	0005883a 	mov	r2,zero
}
811420a0:	e037883a 	mov	sp,fp
811420a4:	df000017 	ldw	fp,0(sp)
811420a8:	dec00104 	addi	sp,sp,4
811420ac:	f800283a 	ret

811420b0 <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
811420b0:	defff804 	addi	sp,sp,-32
811420b4:	de00012e 	bgeu	sp,et,811420bc <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
811420b8:	003b68fa 	trap	3
811420bc:	df000715 	stw	fp,28(sp)
811420c0:	df000704 	addi	fp,sp,28
811420c4:	e13ffe15 	stw	r4,-8(fp)
811420c8:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
811420cc:	e13fff17 	ldw	r4,-4(fp)
811420d0:	2000021e 	bne	r4,zero,811420dc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
811420d4:	00bffa84 	movi	r2,-22
811420d8:	00005906 	br	81142240 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
811420dc:	e13fff17 	ldw	r4,-4(fp)
811420e0:	2015883a 	mov	r10,r4
811420e4:	0017883a 	mov	r11,zero
811420e8:	e2bffc15 	stw	r10,-16(fp)
811420ec:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
811420f0:	e13fff17 	ldw	r4,-4(fp)
811420f4:	21400317 	ldw	r5,12(r4)
811420f8:	e13ffc17 	ldw	r4,-16(fp)
811420fc:	29000626 	beq	r5,r4,81142118 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
81142100:	e13fff17 	ldw	r4,-4(fp)
81142104:	21400b17 	ldw	r5,44(r4)
81142108:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8114210c:	29000226 	beq	r5,r4,81142118 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
81142110:	00bffa84 	movi	r2,-22
81142114:	00004a06 	br	81142240 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
81142118:	e13ffe17 	ldw	r4,-8(fp)
8114211c:	21000017 	ldw	r4,0(r4)
81142120:	2000051e 	bne	r4,zero,81142138 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
81142124:	e0bffe17 	ldw	r2,-8(fp)
81142128:	e0ffff17 	ldw	r3,-4(fp)
8114212c:	10c00015 	stw	r3,0(r2)
		return 0;
81142130:	0005883a 	mov	r2,zero
81142134:	00004206 	br	81142240 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
81142138:	e13ffe17 	ldw	r4,-8(fp)
8114213c:	21400017 	ldw	r5,0(r4)
81142140:	e13fff17 	ldw	r4,-4(fp)
81142144:	2900021e 	bne	r5,r4,81142150 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
81142148:	00bffa84 	movi	r2,-22
8114214c:	00003c06 	br	81142240 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
81142150:	e13ffe17 	ldw	r4,-8(fp)
81142154:	21000017 	ldw	r4,0(r4)
81142158:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
8114215c:	e13ffe17 	ldw	r4,-8(fp)
81142160:	21000017 	ldw	r4,0(r4)
81142164:	2011883a 	mov	r8,r4
81142168:	0013883a 	mov	r9,zero
8114216c:	e23ffa15 	stw	r8,-24(fp)
81142170:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81142174:	00001806 	br	811421d8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
81142178:	e13fff17 	ldw	r4,-4(fp)
8114217c:	200d883a 	mov	r6,r4
81142180:	000f883a 	mov	r7,zero
81142184:	e1bffc15 	stw	r6,-16(fp)
81142188:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
8114218c:	e13ff917 	ldw	r4,-28(fp)
81142190:	21400317 	ldw	r5,12(r4)
81142194:	e13ffc17 	ldw	r4,-16(fp)
81142198:	2900061e 	bne	r5,r4,811421b4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
8114219c:	e13ff917 	ldw	r4,-28(fp)
811421a0:	21400b17 	ldw	r5,44(r4)
811421a4:	e13ffd17 	ldw	r4,-12(fp)
811421a8:	2900021e 	bne	r5,r4,811421b4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
811421ac:	00bffa84 	movi	r2,-22
811421b0:	00002306 	br	81142240 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
811421b4:	e13ff917 	ldw	r4,-28(fp)
811421b8:	21000317 	ldw	r4,12(r4)
811421bc:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
811421c0:	e13ff917 	ldw	r4,-28(fp)
811421c4:	21000b17 	ldw	r4,44(r4)
811421c8:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
811421cc:	e13ffc17 	ldw	r4,-16(fp)
811421d0:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
811421d4:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
811421d8:	e13ff917 	ldw	r4,-28(fp)
811421dc:	21400317 	ldw	r5,12(r4)
811421e0:	e13ffa17 	ldw	r4,-24(fp)
811421e4:	29000426 	beq	r5,r4,811421f8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
811421e8:	e13ff917 	ldw	r4,-28(fp)
811421ec:	21400b17 	ldw	r5,44(r4)
811421f0:	e13ffb17 	ldw	r4,-20(fp)
811421f4:	293fe01e 	bne	r5,r4,81142178 <__reset+0xfb122178>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
811421f8:	e13fff17 	ldw	r4,-4(fp)
811421fc:	2005883a 	mov	r2,r4
81142200:	0007883a 	mov	r3,zero
81142204:	e0bffc15 	stw	r2,-16(fp)
81142208:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
8114220c:	e0fffc17 	ldw	r3,-16(fp)
81142210:	e0bff917 	ldw	r2,-28(fp)
81142214:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
81142218:	e0fffd17 	ldw	r3,-12(fp)
8114221c:	e0bff917 	ldw	r2,-28(fp)
81142220:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
81142224:	e0fffa17 	ldw	r3,-24(fp)
81142228:	e0bfff17 	ldw	r2,-4(fp)
8114222c:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
81142230:	e0fffb17 	ldw	r3,-20(fp)
81142234:	e0bfff17 	ldw	r2,-4(fp)
81142238:	10c00b15 	stw	r3,44(r2)
	return 0;
8114223c:	0005883a 	mov	r2,zero
}
81142240:	e037883a 	mov	sp,fp
81142244:	df000017 	ldw	fp,0(sp)
81142248:	dec00104 	addi	sp,sp,4
8114224c:	f800283a 	ret

81142250 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
81142250:	defffc04 	addi	sp,sp,-16
81142254:	de00012e 	bgeu	sp,et,8114225c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
81142258:	003b68fa 	trap	3
8114225c:	df000315 	stw	fp,12(sp)
81142260:	df000304 	addi	fp,sp,12
81142264:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
81142268:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
8114226c:	e0bfff17 	ldw	r2,-4(fp)
81142270:	1000021e 	bne	r2,zero,8114227c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
81142274:	00bffa84 	movi	r2,-22
81142278:	00001906 	br	811422e0 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8114227c:	e0bfff17 	ldw	r2,-4(fp)
81142280:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
81142284:	00000a06 	br	811422b0 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
81142288:	e0bffd17 	ldw	r2,-12(fp)
8114228c:	10800717 	ldw	r2,28(r2)
81142290:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81142294:	e0bffe17 	ldw	r2,-8(fp)
81142298:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8114229c:	e0bffd17 	ldw	r2,-12(fp)
811422a0:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
811422a4:	e0bffd17 	ldw	r2,-12(fp)
811422a8:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
811422ac:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
811422b0:	e0bffd17 	ldw	r2,-12(fp)
811422b4:	10c00317 	ldw	r3,12(r2)
811422b8:	e0bfff17 	ldw	r2,-4(fp)
811422bc:	18bff21e 	bne	r3,r2,81142288 <__reset+0xfb122288>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
811422c0:	e0bffd17 	ldw	r2,-12(fp)
811422c4:	10800717 	ldw	r2,28(r2)
811422c8:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
811422cc:	e0bffe17 	ldw	r2,-8(fp)
811422d0:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
811422d4:	e0bffd17 	ldw	r2,-12(fp)
811422d8:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
811422dc:	0005883a 	mov	r2,zero
}
811422e0:	e037883a 	mov	sp,fp
811422e4:	df000017 	ldw	fp,0(sp)
811422e8:	dec00104 	addi	sp,sp,4
811422ec:	f800283a 	ret

811422f0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
811422f0:	defff804 	addi	sp,sp,-32
811422f4:	de00012e 	bgeu	sp,et,811422fc <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
811422f8:	003b68fa 	trap	3
811422fc:	df000715 	stw	fp,28(sp)
81142300:	df000704 	addi	fp,sp,28
81142304:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
81142308:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
8114230c:	e13fff17 	ldw	r4,-4(fp)
81142310:	2000021e 	bne	r4,zero,8114231c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
81142314:	00bffa84 	movi	r2,-22
81142318:	00002806 	br	811423bc <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8114231c:	e13fff17 	ldw	r4,-4(fp)
81142320:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
81142324:	e13fff17 	ldw	r4,-4(fp)
81142328:	2005883a 	mov	r2,r4
8114232c:	0007883a 	mov	r3,zero
81142330:	e0bffb15 	stw	r2,-20(fp)
81142334:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81142338:	00001006 	br	8114237c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
8114233c:	e0bff917 	ldw	r2,-28(fp)
81142340:	10800f17 	ldw	r2,60(r2)
81142344:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81142348:	e0bffa17 	ldw	r2,-24(fp)
8114234c:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
81142350:	e0bff917 	ldw	r2,-28(fp)
81142354:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
81142358:	e0bff917 	ldw	r2,-28(fp)
8114235c:	10800317 	ldw	r2,12(r2)
81142360:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
81142364:	e0bff917 	ldw	r2,-28(fp)
81142368:	10800b17 	ldw	r2,44(r2)
8114236c:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
81142370:	e0bffd17 	ldw	r2,-12(fp)
81142374:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
81142378:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114237c:	e0bff917 	ldw	r2,-28(fp)
81142380:	10c00317 	ldw	r3,12(r2)
81142384:	e0bffb17 	ldw	r2,-20(fp)
81142388:	18800426 	beq	r3,r2,8114239c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8114238c:	e0bff917 	ldw	r2,-28(fp)
81142390:	10c00b17 	ldw	r3,44(r2)
81142394:	e0bffc17 	ldw	r2,-16(fp)
81142398:	18bfe81e 	bne	r3,r2,8114233c <__reset+0xfb12233c>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
8114239c:	e0bff917 	ldw	r2,-28(fp)
811423a0:	10800f17 	ldw	r2,60(r2)
811423a4:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
811423a8:	e0bffa17 	ldw	r2,-24(fp)
811423ac:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
811423b0:	e0bff917 	ldw	r2,-28(fp)
811423b4:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
811423b8:	0005883a 	mov	r2,zero
}
811423bc:	e037883a 	mov	sp,fp
811423c0:	df000017 	ldw	fp,0(sp)
811423c4:	dec00104 	addi	sp,sp,4
811423c8:	f800283a 	ret

811423cc <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
811423cc:	deffeb04 	addi	sp,sp,-84
811423d0:	de00012e 	bgeu	sp,et,811423d8 <alt_msgdma_start_prefetcher_with_list_addr+0xc>
811423d4:	003b68fa 	trap	3
811423d8:	dfc01415 	stw	ra,80(sp)
811423dc:	df001315 	stw	fp,76(sp)
811423e0:	df001304 	addi	fp,sp,76
811423e4:	e13ffb15 	stw	r4,-20(fp)
811423e8:	e17ffc15 	stw	r5,-16(fp)
811423ec:	e1bffd15 	stw	r6,-12(fp)
811423f0:	3807883a 	mov	r3,r7
811423f4:	e0800217 	ldw	r2,8(fp)
811423f8:	e0fffe05 	stb	r3,-8(fp)
811423fc:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
81142400:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
81142404:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
81142408:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
8114240c:	e0bffc17 	ldw	r2,-16(fp)
81142410:	e0bff815 	stw	r2,-32(fp)
81142414:	e0bffd17 	ldw	r2,-12(fp)
81142418:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
8114241c:	e0bffb17 	ldw	r2,-20(fp)
81142420:	10801817 	ldw	r2,96(r2)
81142424:	e0bff615 	stw	r2,-40(fp)
81142428:	e03ff70d 	sth	zero,-36(fp)
8114242c:	e0bff70b 	ldhu	r2,-36(fp)
81142430:	e0fffa04 	addi	r3,fp,-24
81142434:	180d883a 	mov	r6,r3
81142438:	100b883a 	mov	r5,r2
8114243c:	e13ff617 	ldw	r4,-40(fp)
81142440:	11375780 	call	81137578 <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
81142444:	e0bffb17 	ldw	r2,-20(fp)
81142448:	10800617 	ldw	r2,24(r2)
8114244c:	10800037 	ldwio	r2,0(r2)
81142450:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
81142454:	e0bfed17 	ldw	r2,-76(fp)
81142458:	1080004c 	andi	r2,r2,1
8114245c:	10000626 	beq	r2,zero,81142478 <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
81142460:	e0bffb17 	ldw	r2,-20(fp)
81142464:	10801817 	ldw	r2,96(r2)
81142468:	1009883a 	mov	r4,r2
8114246c:	11379000 	call	81137900 <OSSemPost>
		return -EBUSY;
81142470:	00bffc04 	movi	r2,-16
81142474:	00009606 	br	811426d0 <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81142478:	00800804 	movi	r2,32
8114247c:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142480:	0005303a 	rdctl	r2,status
81142484:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142488:	e0fff217 	ldw	r3,-56(fp)
8114248c:	00bfff84 	movi	r2,-2
81142490:	1884703a 	and	r2,r3,r2
81142494:	1001703a 	wrctl	status,r2
  
  return context;
81142498:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8114249c:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
811424a0:	e0bffb17 	ldw	r2,-20(fp)
811424a4:	10800317 	ldw	r2,12(r2)
811424a8:	10800104 	addi	r2,r2,4
811424ac:	e0ffee17 	ldw	r3,-72(fp)
811424b0:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
811424b4:	e0bffb17 	ldw	r2,-20(fp)
811424b8:	10800317 	ldw	r2,12(r2)
811424bc:	e0fffb17 	ldw	r3,-20(fp)
811424c0:	18c00317 	ldw	r3,12(r3)
811424c4:	18c00037 	ldwio	r3,0(r3)
811424c8:	10c00035 	stwio	r3,0(r2)
811424cc:	e0bfef17 	ldw	r2,-68(fp)
811424d0:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811424d4:	e0bff017 	ldw	r2,-64(fp)
811424d8:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
811424dc:	e0bffb17 	ldw	r2,-20(fp)
811424e0:	10800b17 	ldw	r2,44(r2)
811424e4:	10002326 	beq	r2,zero,81142574 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
811424e8:	e0bffb17 	ldw	r2,-20(fp)
811424ec:	10c00d17 	ldw	r3,52(r2)
811424f0:	e0bfee17 	ldw	r2,-72(fp)
811424f4:	1884b03a 	or	r2,r3,r2
811424f8:	10800514 	ori	r2,r2,20
811424fc:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81142500:	e0ffee17 	ldw	r3,-72(fp)
81142504:	00bff7c4 	movi	r2,-33
81142508:	1884703a 	and	r2,r3,r2
8114250c:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81142510:	e0bfed17 	ldw	r2,-76(fp)
81142514:	10800214 	ori	r2,r2,8
81142518:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114251c:	0005303a 	rdctl	r2,status
81142520:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142524:	e0fff417 	ldw	r3,-48(fp)
81142528:	00bfff84 	movi	r2,-2
8114252c:	1884703a 	and	r2,r3,r2
81142530:	1001703a 	wrctl	status,r2
  
  return context;
81142534:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
81142538:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
8114253c:	e0bffb17 	ldw	r2,-20(fp)
81142540:	10800317 	ldw	r2,12(r2)
81142544:	10800104 	addi	r2,r2,4
81142548:	e0ffee17 	ldw	r3,-72(fp)
8114254c:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81142550:	e0bffb17 	ldw	r2,-20(fp)
81142554:	10800617 	ldw	r2,24(r2)
81142558:	e0ffed17 	ldw	r3,-76(fp)
8114255c:	10c00035 	stwio	r3,0(r2)
81142560:	e0bfef17 	ldw	r2,-68(fp)
81142564:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142568:	e0bff117 	ldw	r2,-60(fp)
8114256c:	1001703a 	wrctl	status,r2
81142570:	00002306 	br	81142600 <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
81142574:	e0bffb17 	ldw	r2,-20(fp)
81142578:	10c00d17 	ldw	r3,52(r2)
8114257c:	e0bfee17 	ldw	r2,-72(fp)
81142580:	1884b03a 	or	r2,r3,r2
81142584:	10800114 	ori	r2,r2,4
81142588:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
8114258c:	e0ffee17 	ldw	r3,-72(fp)
81142590:	00bff3c4 	movi	r2,-49
81142594:	1884703a 	and	r2,r3,r2
81142598:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
8114259c:	e0ffed17 	ldw	r3,-76(fp)
811425a0:	00bffdc4 	movi	r2,-9
811425a4:	1884703a 	and	r2,r3,r2
811425a8:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811425ac:	0005303a 	rdctl	r2,status
811425b0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811425b4:	e0fff517 	ldw	r3,-44(fp)
811425b8:	00bfff84 	movi	r2,-2
811425bc:	1884703a 	and	r2,r3,r2
811425c0:	1001703a 	wrctl	status,r2
  
  return context;
811425c4:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
811425c8:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
811425cc:	e0bffb17 	ldw	r2,-20(fp)
811425d0:	10800317 	ldw	r2,12(r2)
811425d4:	10800104 	addi	r2,r2,4
811425d8:	e0ffee17 	ldw	r3,-72(fp)
811425dc:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
811425e0:	e0bffb17 	ldw	r2,-20(fp)
811425e4:	10800617 	ldw	r2,24(r2)
811425e8:	e0ffed17 	ldw	r3,-76(fp)
811425ec:	10c00035 	stwio	r3,0(r2)
811425f0:	e0bfef17 	ldw	r2,-68(fp)
811425f4:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811425f8:	e0bff317 	ldw	r2,-52(fp)
811425fc:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
81142600:	e0bffb17 	ldw	r2,-20(fp)
81142604:	10800617 	ldw	r2,24(r2)
81142608:	10800104 	addi	r2,r2,4
8114260c:	e0fff817 	ldw	r3,-32(fp)
81142610:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
81142614:	e0bffb17 	ldw	r2,-20(fp)
81142618:	10800617 	ldw	r2,24(r2)
8114261c:	10800204 	addi	r2,r2,8
81142620:	e0fff917 	ldw	r3,-28(fp)
81142624:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
81142628:	e0bffe03 	ldbu	r2,-8(fp)
8114262c:	10000426 	beq	r2,zero,81142640 <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
81142630:	e0bfed17 	ldw	r2,-76(fp)
81142634:	10800414 	ori	r2,r2,16
81142638:	e0bfed15 	stw	r2,-76(fp)
8114263c:	00000406 	br	81142650 <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
81142640:	e0ffed17 	ldw	r3,-76(fp)
81142644:	00bffbc4 	movi	r2,-17
81142648:	1884703a 	and	r2,r3,r2
8114264c:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
81142650:	e0bfff03 	ldbu	r2,-4(fp)
81142654:	10000e26 	beq	r2,zero,81142690 <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
81142658:	e0bfed17 	ldw	r2,-76(fp)
8114265c:	10800094 	ori	r2,r2,2
81142660:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
81142664:	e0bffb17 	ldw	r2,-20(fp)
81142668:	10800617 	ldw	r2,24(r2)
8114266c:	10800304 	addi	r2,r2,12
81142670:	10800037 	ldwio	r2,0(r2)
81142674:	10000a1e 	bne	r2,zero,811426a0 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
81142678:	e0bffb17 	ldw	r2,-20(fp)
8114267c:	10800617 	ldw	r2,24(r2)
81142680:	10800304 	addi	r2,r2,12
81142684:	00c03fc4 	movi	r3,255
81142688:	10c00035 	stwio	r3,0(r2)
8114268c:	00000406 	br	811426a0 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
81142690:	e0ffed17 	ldw	r3,-76(fp)
81142694:	00bfff44 	movi	r2,-3
81142698:	1884703a 	and	r2,r3,r2
8114269c:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
811426a0:	e0bfed17 	ldw	r2,-76(fp)
811426a4:	10800054 	ori	r2,r2,1
811426a8:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
811426ac:	e0bffb17 	ldw	r2,-20(fp)
811426b0:	10800617 	ldw	r2,24(r2)
811426b4:	e0ffed17 	ldw	r3,-76(fp)
811426b8:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
811426bc:	e0bffb17 	ldw	r2,-20(fp)
811426c0:	10801817 	ldw	r2,96(r2)
811426c4:	1009883a 	mov	r4,r2
811426c8:	11379000 	call	81137900 <OSSemPost>
	 
	 return 0;
811426cc:	0005883a 	mov	r2,zero
}
811426d0:	e037883a 	mov	sp,fp
811426d4:	dfc00117 	ldw	ra,4(sp)
811426d8:	df000017 	ldw	fp,0(sp)
811426dc:	dec00204 	addi	sp,sp,8
811426e0:	f800283a 	ret

811426e4 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
811426e4:	defff704 	addi	sp,sp,-36
811426e8:	de00012e 	bgeu	sp,et,811426f0 <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
811426ec:	003b68fa 	trap	3
811426f0:	dfc00815 	stw	ra,32(sp)
811426f4:	df000715 	stw	fp,28(sp)
811426f8:	dc400615 	stw	r17,24(sp)
811426fc:	dc000515 	stw	r16,20(sp)
81142700:	df000704 	addi	fp,sp,28
81142704:	e13ffa15 	stw	r4,-24(fp)
81142708:	e17ffb15 	stw	r5,-20(fp)
8114270c:	3007883a 	mov	r3,r6
81142710:	3805883a 	mov	r2,r7
81142714:	e0fffc05 	stb	r3,-16(fp)
81142718:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
8114271c:	e13ffb17 	ldw	r4,-20(fp)
81142720:	11422500 	call	81142250 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
81142724:	10000226 	beq	r2,zero,81142730 <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
81142728:	00bffa84 	movi	r2,-22
8114272c:	00000b06 	br	8114275c <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
81142730:	e0bffb17 	ldw	r2,-20(fp)
81142734:	1021883a 	mov	r16,r2
81142738:	0023883a 	mov	r17,zero
8114273c:	e0fffc03 	ldbu	r3,-16(fp)
81142740:	e0bffd03 	ldbu	r2,-12(fp)
81142744:	d8800015 	stw	r2,0(sp)
81142748:	180f883a 	mov	r7,r3
8114274c:	800b883a 	mov	r5,r16
81142750:	880d883a 	mov	r6,r17
81142754:	e13ffa17 	ldw	r4,-24(fp)
81142758:	11423cc0 	call	811423cc <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
8114275c:	e6fffe04 	addi	sp,fp,-8
81142760:	dfc00317 	ldw	ra,12(sp)
81142764:	df000217 	ldw	fp,8(sp)
81142768:	dc400117 	ldw	r17,4(sp)
8114276c:	dc000017 	ldw	r16,0(sp)
81142770:	dec00404 	addi	sp,sp,16
81142774:	f800283a 	ret

81142778 <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
81142778:	defff704 	addi	sp,sp,-36
8114277c:	de00012e 	bgeu	sp,et,81142784 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
81142780:	003b68fa 	trap	3
81142784:	dfc00815 	stw	ra,32(sp)
81142788:	df000715 	stw	fp,28(sp)
8114278c:	dc400615 	stw	r17,24(sp)
81142790:	dc000515 	stw	r16,20(sp)
81142794:	df000704 	addi	fp,sp,28
81142798:	e13ffa15 	stw	r4,-24(fp)
8114279c:	e17ffb15 	stw	r5,-20(fp)
811427a0:	3007883a 	mov	r3,r6
811427a4:	3805883a 	mov	r2,r7
811427a8:	e0fffc05 	stb	r3,-16(fp)
811427ac:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
811427b0:	e13ffb17 	ldw	r4,-20(fp)
811427b4:	11422f00 	call	811422f0 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
811427b8:	10000226 	beq	r2,zero,811427c4 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
811427bc:	00bffa84 	movi	r2,-22
811427c0:	00000b06 	br	811427f0 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
811427c4:	e0bffb17 	ldw	r2,-20(fp)
811427c8:	1021883a 	mov	r16,r2
811427cc:	0023883a 	mov	r17,zero
811427d0:	e0fffc03 	ldbu	r3,-16(fp)
811427d4:	e0bffd03 	ldbu	r2,-12(fp)
811427d8:	d8800015 	stw	r2,0(sp)
811427dc:	180f883a 	mov	r7,r3
811427e0:	800b883a 	mov	r5,r16
811427e4:	880d883a 	mov	r6,r17
811427e8:	e13ffa17 	ldw	r4,-24(fp)
811427ec:	11423cc0 	call	811423cc <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
811427f0:	e6fffe04 	addi	sp,fp,-8
811427f4:	dfc00317 	ldw	ra,12(sp)
811427f8:	df000217 	ldw	fp,8(sp)
811427fc:	dc400117 	ldw	r17,4(sp)
81142800:	dc000017 	ldw	r16,0(sp)
81142804:	dec00404 	addi	sp,sp,16
81142808:	f800283a 	ret

8114280c <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
8114280c:	defffc04 	addi	sp,sp,-16
81142810:	de00012e 	bgeu	sp,et,81142818 <alt_msgdma_open+0xc>
81142814:	003b68fa 	trap	3
81142818:	dfc00315 	stw	ra,12(sp)
8114281c:	df000215 	stw	fp,8(sp)
81142820:	df000204 	addi	fp,sp,8
81142824:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
81142828:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
8114282c:	d1603504 	addi	r5,gp,-32556
81142830:	e13fff17 	ldw	r4,-4(fp)
81142834:	1142db00 	call	81142db0 <alt_find_dev>
81142838:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
8114283c:	e0bffe17 	ldw	r2,-8(fp)
81142840:	1000041e 	bne	r2,zero,81142854 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
81142844:	1140a700 	call	81140a70 <alt_get_errno>
81142848:	1007883a 	mov	r3,r2
8114284c:	008004c4 	movi	r2,19
81142850:	18800015 	stw	r2,0(r3)
    }

    return dev;
81142854:	e0bffe17 	ldw	r2,-8(fp)
}
81142858:	e037883a 	mov	sp,fp
8114285c:	dfc00117 	ldw	ra,4(sp)
81142860:	df000017 	ldw	fp,0(sp)
81142864:	dec00204 	addi	sp,sp,8
81142868:	f800283a 	ret

8114286c <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
8114286c:	defff604 	addi	sp,sp,-40
81142870:	de00012e 	bgeu	sp,et,81142878 <alt_msgdma_init+0xc>
81142874:	003b68fa 	trap	3
81142878:	dfc00915 	stw	ra,36(sp)
8114287c:	df000815 	stw	fp,32(sp)
81142880:	df000804 	addi	fp,sp,32
81142884:	e13ffd15 	stw	r4,-12(fp)
81142888:	e17ffe15 	stw	r5,-8(fp)
8114288c:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
81142890:	e0bffd17 	ldw	r2,-12(fp)
81142894:	10801783 	ldbu	r2,94(r2)
81142898:	10803fcc 	andi	r2,r2,255
8114289c:	10000b26 	beq	r2,zero,811428cc <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
811428a0:	e0bffd17 	ldw	r2,-12(fp)
811428a4:	10800617 	ldw	r2,24(r2)
811428a8:	00c00104 	movi	r3,4
811428ac:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
811428b0:	0001883a 	nop
811428b4:	e0bffd17 	ldw	r2,-12(fp)
811428b8:	10800617 	ldw	r2,24(r2)
811428bc:	10800037 	ldwio	r2,0(r2)
811428c0:	1080010c 	andi	r2,r2,4
811428c4:	1005d0ba 	srai	r2,r2,2
811428c8:	103ffa1e 	bne	r2,zero,811428b4 <__reset+0xfb1228b4>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
811428cc:	e0bffd17 	ldw	r2,-12(fp)
811428d0:	10800317 	ldw	r2,12(r2)
811428d4:	10800104 	addi	r2,r2,4
811428d8:	00c00084 	movi	r3,2
811428dc:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
811428e0:	0001883a 	nop
811428e4:	e0bffd17 	ldw	r2,-12(fp)
811428e8:	10800317 	ldw	r2,12(r2)
811428ec:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
811428f0:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
811428f4:	103ffb1e 	bne	r2,zero,811428e4 <__reset+0xfb1228e4>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
811428f8:	e0bffd17 	ldw	r2,-12(fp)
811428fc:	10800317 	ldw	r2,12(r2)
81142900:	10800104 	addi	r2,r2,4
81142904:	10800037 	ldwio	r2,0(r2)
81142908:	1007883a 	mov	r3,r2
8114290c:	00bffbc4 	movi	r2,-17
81142910:	1884703a 	and	r2,r3,r2
81142914:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81142918:	e0bff917 	ldw	r2,-28(fp)
8114291c:	10800814 	ori	r2,r2,32
81142920:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81142924:	e0bffd17 	ldw	r2,-12(fp)
81142928:	10800317 	ldw	r2,12(r2)
8114292c:	10800104 	addi	r2,r2,4
81142930:	e0fff917 	ldw	r3,-28(fp)
81142934:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
81142938:	e0bffd17 	ldw	r2,-12(fp)
8114293c:	10800317 	ldw	r2,12(r2)
81142940:	e0fffd17 	ldw	r3,-12(fp)
81142944:	18c00317 	ldw	r3,12(r3)
81142948:	18c00037 	ldwio	r3,0(r3)
8114294c:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
81142950:	e0bffd17 	ldw	r2,-12(fp)
81142954:	10801783 	ldbu	r2,94(r2)
81142958:	10803fcc 	andi	r2,r2,255
8114295c:	10000826 	beq	r2,zero,81142980 <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
81142960:	e0bffd17 	ldw	r2,-12(fp)
81142964:	10800617 	ldw	r2,24(r2)
81142968:	10800404 	addi	r2,r2,16
8114296c:	e0fffd17 	ldw	r3,-12(fp)
81142970:	18c00617 	ldw	r3,24(r3)
81142974:	18c00404 	addi	r3,r3,16
81142978:	18c00037 	ldwio	r3,0(r3)
8114297c:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
81142980:	d1603504 	addi	r5,gp,-32556
81142984:	e13ffd17 	ldw	r4,-12(fp)
81142988:	1142d040 	call	81142d04 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
8114298c:	e0bffd17 	ldw	r2,-12(fp)
81142990:	10801804 	addi	r2,r2,96
81142994:	e0bffb15 	stw	r2,-20(fp)
81142998:	00800044 	movi	r2,1
8114299c:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811429a0:	e0bffc0b 	ldhu	r2,-16(fp)
811429a4:	1009883a 	mov	r4,r2
811429a8:	11372500 	call	81137250 <OSSemCreate>
811429ac:	1007883a 	mov	r3,r2
811429b0:	e0bffb17 	ldw	r2,-20(fp)
811429b4:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
811429b8:	e0bffb17 	ldw	r2,-20(fp)
811429bc:	10800017 	ldw	r2,0(r2)
811429c0:	10000226 	beq	r2,zero,811429cc <alt_msgdma_init+0x160>
811429c4:	0005883a 	mov	r2,zero
811429c8:	00000106 	br	811429d0 <alt_msgdma_init+0x164>
811429cc:	00bfffc4 	movi	r2,-1
811429d0:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
811429d4:	e0bffa17 	ldw	r2,-24(fp)
811429d8:	1000081e 	bne	r2,zero,811429fc <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
811429dc:	d8000015 	stw	zero,0(sp)
811429e0:	e1fffd17 	ldw	r7,-12(fp)
811429e4:	01a04534 	movhi	r6,33044
811429e8:	31832104 	addi	r6,r6,3204
811429ec:	e17fff17 	ldw	r5,-4(fp)
811429f0:	e13ffe17 	ldw	r4,-8(fp)
811429f4:	1142e480 	call	81142e48 <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
811429f8:	00000406 	br	81142a0c <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
811429fc:	01204534 	movhi	r4,33044
81142a00:	21168804 	addi	r4,r4,23072
81142a04:	11434cc0 	call	811434cc <alt_printf>
    }
    
    return;
81142a08:	0001883a 	nop

}
81142a0c:	e037883a 	mov	sp,fp
81142a10:	dfc00117 	ldw	ra,4(sp)
81142a14:	df000017 	ldw	fp,0(sp)
81142a18:	dec00204 	addi	sp,sp,8
81142a1c:	f800283a 	ret

81142a20 <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
81142a20:	defffb04 	addi	sp,sp,-20
81142a24:	de00012e 	bgeu	sp,et,81142a2c <alt_msgdma_register_callback+0xc>
81142a28:	003b68fa 	trap	3
81142a2c:	df000415 	stw	fp,16(sp)
81142a30:	df000404 	addi	fp,sp,16
81142a34:	e13ffc15 	stw	r4,-16(fp)
81142a38:	e17ffd15 	stw	r5,-12(fp)
81142a3c:	e1bffe15 	stw	r6,-8(fp)
81142a40:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
81142a44:	e0bffc17 	ldw	r2,-16(fp)
81142a48:	e0fffd17 	ldw	r3,-12(fp)
81142a4c:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
81142a50:	e0bffc17 	ldw	r2,-16(fp)
81142a54:	e0ffff17 	ldw	r3,-4(fp)
81142a58:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
81142a5c:	e0bffc17 	ldw	r2,-16(fp)
81142a60:	e0fffe17 	ldw	r3,-8(fp)
81142a64:	10c00d15 	stw	r3,52(r2)

    return ;
81142a68:	0001883a 	nop
}
81142a6c:	e037883a 	mov	sp,fp
81142a70:	df000017 	ldw	fp,0(sp)
81142a74:	dec00104 	addi	sp,sp,4
81142a78:	f800283a 	ret

81142a7c <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
81142a7c:	defffc04 	addi	sp,sp,-16
81142a80:	de00012e 	bgeu	sp,et,81142a88 <alt_msgdma_standard_descriptor_async_transfer+0xc>
81142a84:	003b68fa 	trap	3
81142a88:	dfc00315 	stw	ra,12(sp)
81142a8c:	df000215 	stw	fp,8(sp)
81142a90:	df000204 	addi	fp,sp,8
81142a94:	e13ffe15 	stw	r4,-8(fp)
81142a98:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
81142a9c:	000d883a 	mov	r6,zero
81142aa0:	e17fff17 	ldw	r5,-4(fp)
81142aa4:	e13ffe17 	ldw	r4,-8(fp)
81142aa8:	11410000 	call	81141000 <alt_msgdma_descriptor_async_transfer>

}
81142aac:	e037883a 	mov	sp,fp
81142ab0:	dfc00117 	ldw	ra,4(sp)
81142ab4:	df000017 	ldw	fp,0(sp)
81142ab8:	dec00204 	addi	sp,sp,8
81142abc:	f800283a 	ret

81142ac0 <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
81142ac0:	defffc04 	addi	sp,sp,-16
81142ac4:	de00012e 	bgeu	sp,et,81142acc <alt_msgdma_extended_descriptor_async_transfer+0xc>
81142ac8:	003b68fa 	trap	3
81142acc:	dfc00315 	stw	ra,12(sp)
81142ad0:	df000215 	stw	fp,8(sp)
81142ad4:	df000204 	addi	fp,sp,8
81142ad8:	e13ffe15 	stw	r4,-8(fp)
81142adc:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
81142ae0:	e1bfff17 	ldw	r6,-4(fp)
81142ae4:	000b883a 	mov	r5,zero
81142ae8:	e13ffe17 	ldw	r4,-8(fp)
81142aec:	11410000 	call	81141000 <alt_msgdma_descriptor_async_transfer>
}
81142af0:	e037883a 	mov	sp,fp
81142af4:	dfc00117 	ldw	ra,4(sp)
81142af8:	df000017 	ldw	fp,0(sp)
81142afc:	dec00204 	addi	sp,sp,8
81142b00:	f800283a 	ret

81142b04 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
81142b04:	defffc04 	addi	sp,sp,-16
81142b08:	de00012e 	bgeu	sp,et,81142b10 <alt_msgdma_standard_descriptor_sync_transfer+0xc>
81142b0c:	003b68fa 	trap	3
81142b10:	dfc00315 	stw	ra,12(sp)
81142b14:	df000215 	stw	fp,8(sp)
81142b18:	df000204 	addi	fp,sp,8
81142b1c:	e13ffe15 	stw	r4,-8(fp)
81142b20:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
81142b24:	000d883a 	mov	r6,zero
81142b28:	e17fff17 	ldw	r5,-4(fp)
81142b2c:	e13ffe17 	ldw	r4,-8(fp)
81142b30:	11413400 	call	81141340 <alt_msgdma_descriptor_sync_transfer>
}
81142b34:	e037883a 	mov	sp,fp
81142b38:	dfc00117 	ldw	ra,4(sp)
81142b3c:	df000017 	ldw	fp,0(sp)
81142b40:	dec00204 	addi	sp,sp,8
81142b44:	f800283a 	ret

81142b48 <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
81142b48:	defffc04 	addi	sp,sp,-16
81142b4c:	de00012e 	bgeu	sp,et,81142b54 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
81142b50:	003b68fa 	trap	3
81142b54:	dfc00315 	stw	ra,12(sp)
81142b58:	df000215 	stw	fp,8(sp)
81142b5c:	df000204 	addi	fp,sp,8
81142b60:	e13ffe15 	stw	r4,-8(fp)
81142b64:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
81142b68:	e1bfff17 	ldw	r6,-4(fp)
81142b6c:	000b883a 	mov	r5,zero
81142b70:	e13ffe17 	ldw	r4,-8(fp)
81142b74:	11413400 	call	81141340 <alt_msgdma_descriptor_sync_transfer>
}
81142b78:	e037883a 	mov	sp,fp
81142b7c:	dfc00117 	ldw	ra,4(sp)
81142b80:	df000017 	ldw	fp,0(sp)
81142b84:	dec00204 	addi	sp,sp,8
81142b88:	f800283a 	ret

81142b8c <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
81142b8c:	defff504 	addi	sp,sp,-44
81142b90:	de00012e 	bgeu	sp,et,81142b98 <alt_alarm_start+0xc>
81142b94:	003b68fa 	trap	3
81142b98:	df000a15 	stw	fp,40(sp)
81142b9c:	df000a04 	addi	fp,sp,40
81142ba0:	e13ffc15 	stw	r4,-16(fp)
81142ba4:	e17ffd15 	stw	r5,-12(fp)
81142ba8:	e1bffe15 	stw	r6,-8(fp)
81142bac:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
81142bb0:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81142bb4:	d0a08717 	ldw	r2,-32228(gp)
  
  if (alt_ticks_per_second ())
81142bb8:	10003c26 	beq	r2,zero,81142cac <alt_alarm_start+0x120>
  {
    if (alarm)
81142bbc:	e0bffc17 	ldw	r2,-16(fp)
81142bc0:	10003826 	beq	r2,zero,81142ca4 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
81142bc4:	e0bffc17 	ldw	r2,-16(fp)
81142bc8:	e0fffe17 	ldw	r3,-8(fp)
81142bcc:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
81142bd0:	e0bffc17 	ldw	r2,-16(fp)
81142bd4:	e0ffff17 	ldw	r3,-4(fp)
81142bd8:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142bdc:	0005303a 	rdctl	r2,status
81142be0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142be4:	e0fff917 	ldw	r3,-28(fp)
81142be8:	00bfff84 	movi	r2,-2
81142bec:	1884703a 	and	r2,r3,r2
81142bf0:	1001703a 	wrctl	status,r2
  
  return context;
81142bf4:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
81142bf8:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81142bfc:	d0a08817 	ldw	r2,-32224(gp)
      
      current_nticks = alt_nticks();
81142c00:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
81142c04:	e0fffd17 	ldw	r3,-12(fp)
81142c08:	e0bff617 	ldw	r2,-40(fp)
81142c0c:	1885883a 	add	r2,r3,r2
81142c10:	10c00044 	addi	r3,r2,1
81142c14:	e0bffc17 	ldw	r2,-16(fp)
81142c18:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
81142c1c:	e0bffc17 	ldw	r2,-16(fp)
81142c20:	10c00217 	ldw	r3,8(r2)
81142c24:	e0bff617 	ldw	r2,-40(fp)
81142c28:	1880042e 	bgeu	r3,r2,81142c3c <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
81142c2c:	e0bffc17 	ldw	r2,-16(fp)
81142c30:	00c00044 	movi	r3,1
81142c34:	10c00405 	stb	r3,16(r2)
81142c38:	00000206 	br	81142c44 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
81142c3c:	e0bffc17 	ldw	r2,-16(fp)
81142c40:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
81142c44:	e0bffc17 	ldw	r2,-16(fp)
81142c48:	d0e01404 	addi	r3,gp,-32688
81142c4c:	e0fffa15 	stw	r3,-24(fp)
81142c50:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
81142c54:	e0bffb17 	ldw	r2,-20(fp)
81142c58:	e0fffa17 	ldw	r3,-24(fp)
81142c5c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
81142c60:	e0bffa17 	ldw	r2,-24(fp)
81142c64:	10c00017 	ldw	r3,0(r2)
81142c68:	e0bffb17 	ldw	r2,-20(fp)
81142c6c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
81142c70:	e0bffa17 	ldw	r2,-24(fp)
81142c74:	10800017 	ldw	r2,0(r2)
81142c78:	e0fffb17 	ldw	r3,-20(fp)
81142c7c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
81142c80:	e0bffa17 	ldw	r2,-24(fp)
81142c84:	e0fffb17 	ldw	r3,-20(fp)
81142c88:	10c00015 	stw	r3,0(r2)
81142c8c:	e0bff817 	ldw	r2,-32(fp)
81142c90:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142c94:	e0bff717 	ldw	r2,-36(fp)
81142c98:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
81142c9c:	0005883a 	mov	r2,zero
81142ca0:	00000306 	br	81142cb0 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
81142ca4:	00bffa84 	movi	r2,-22
81142ca8:	00000106 	br	81142cb0 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
81142cac:	00bfde84 	movi	r2,-134
  }
}
81142cb0:	e037883a 	mov	sp,fp
81142cb4:	df000017 	ldw	fp,0(sp)
81142cb8:	dec00104 	addi	sp,sp,4
81142cbc:	f800283a 	ret

81142cc0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81142cc0:	defffe04 	addi	sp,sp,-8
81142cc4:	de00012e 	bgeu	sp,et,81142ccc <alt_get_errno+0xc>
81142cc8:	003b68fa 	trap	3
81142ccc:	dfc00115 	stw	ra,4(sp)
81142cd0:	df000015 	stw	fp,0(sp)
81142cd4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81142cd8:	d0a01017 	ldw	r2,-32704(gp)
81142cdc:	10000326 	beq	r2,zero,81142cec <alt_get_errno+0x2c>
81142ce0:	d0a01017 	ldw	r2,-32704(gp)
81142ce4:	103ee83a 	callr	r2
81142ce8:	00000106 	br	81142cf0 <alt_get_errno+0x30>
81142cec:	d0a07d04 	addi	r2,gp,-32268
}
81142cf0:	e037883a 	mov	sp,fp
81142cf4:	dfc00117 	ldw	ra,4(sp)
81142cf8:	df000017 	ldw	fp,0(sp)
81142cfc:	dec00204 	addi	sp,sp,8
81142d00:	f800283a 	ret

81142d04 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
81142d04:	defffa04 	addi	sp,sp,-24
81142d08:	de00012e 	bgeu	sp,et,81142d10 <alt_dev_llist_insert+0xc>
81142d0c:	003b68fa 	trap	3
81142d10:	dfc00515 	stw	ra,20(sp)
81142d14:	df000415 	stw	fp,16(sp)
81142d18:	df000404 	addi	fp,sp,16
81142d1c:	e13ffe15 	stw	r4,-8(fp)
81142d20:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
81142d24:	e0bffe17 	ldw	r2,-8(fp)
81142d28:	10000326 	beq	r2,zero,81142d38 <alt_dev_llist_insert+0x34>
81142d2c:	e0bffe17 	ldw	r2,-8(fp)
81142d30:	10800217 	ldw	r2,8(r2)
81142d34:	1000061e 	bne	r2,zero,81142d50 <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
81142d38:	1142cc00 	call	81142cc0 <alt_get_errno>
81142d3c:	1007883a 	mov	r3,r2
81142d40:	00800584 	movi	r2,22
81142d44:	18800015 	stw	r2,0(r3)
    return -EINVAL;
81142d48:	00bffa84 	movi	r2,-22
81142d4c:	00001306 	br	81142d9c <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
81142d50:	e0bffe17 	ldw	r2,-8(fp)
81142d54:	e0ffff17 	ldw	r3,-4(fp)
81142d58:	e0fffc15 	stw	r3,-16(fp)
81142d5c:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
81142d60:	e0bffd17 	ldw	r2,-12(fp)
81142d64:	e0fffc17 	ldw	r3,-16(fp)
81142d68:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
81142d6c:	e0bffc17 	ldw	r2,-16(fp)
81142d70:	10c00017 	ldw	r3,0(r2)
81142d74:	e0bffd17 	ldw	r2,-12(fp)
81142d78:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
81142d7c:	e0bffc17 	ldw	r2,-16(fp)
81142d80:	10800017 	ldw	r2,0(r2)
81142d84:	e0fffd17 	ldw	r3,-12(fp)
81142d88:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
81142d8c:	e0bffc17 	ldw	r2,-16(fp)
81142d90:	e0fffd17 	ldw	r3,-12(fp)
81142d94:	10c00015 	stw	r3,0(r2)

  return 0;  
81142d98:	0005883a 	mov	r2,zero
}
81142d9c:	e037883a 	mov	sp,fp
81142da0:	dfc00117 	ldw	ra,4(sp)
81142da4:	df000017 	ldw	fp,0(sp)
81142da8:	dec00204 	addi	sp,sp,8
81142dac:	f800283a 	ret

81142db0 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
81142db0:	defffa04 	addi	sp,sp,-24
81142db4:	de00012e 	bgeu	sp,et,81142dbc <alt_find_dev+0xc>
81142db8:	003b68fa 	trap	3
81142dbc:	dfc00515 	stw	ra,20(sp)
81142dc0:	df000415 	stw	fp,16(sp)
81142dc4:	df000404 	addi	fp,sp,16
81142dc8:	e13ffe15 	stw	r4,-8(fp)
81142dcc:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
81142dd0:	e0bfff17 	ldw	r2,-4(fp)
81142dd4:	10800017 	ldw	r2,0(r2)
81142dd8:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
81142ddc:	e13ffe17 	ldw	r4,-8(fp)
81142de0:	111b1180 	call	8111b118 <strlen>
81142de4:	10800044 	addi	r2,r2,1
81142de8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
81142dec:	00000d06 	br	81142e24 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
81142df0:	e0bffc17 	ldw	r2,-16(fp)
81142df4:	10800217 	ldw	r2,8(r2)
81142df8:	e0fffd17 	ldw	r3,-12(fp)
81142dfc:	180d883a 	mov	r6,r3
81142e00:	e17ffe17 	ldw	r5,-8(fp)
81142e04:	1009883a 	mov	r4,r2
81142e08:	1143e300 	call	81143e30 <memcmp>
81142e0c:	1000021e 	bne	r2,zero,81142e18 <alt_find_dev+0x68>
    {
      /* match found */

      return next;
81142e10:	e0bffc17 	ldw	r2,-16(fp)
81142e14:	00000706 	br	81142e34 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
81142e18:	e0bffc17 	ldw	r2,-16(fp)
81142e1c:	10800017 	ldw	r2,0(r2)
81142e20:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
81142e24:	e0fffc17 	ldw	r3,-16(fp)
81142e28:	e0bfff17 	ldw	r2,-4(fp)
81142e2c:	18bff01e 	bne	r3,r2,81142df0 <__reset+0xfb122df0>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
81142e30:	0005883a 	mov	r2,zero
}
81142e34:	e037883a 	mov	sp,fp
81142e38:	dfc00117 	ldw	ra,4(sp)
81142e3c:	df000017 	ldw	fp,0(sp)
81142e40:	dec00204 	addi	sp,sp,8
81142e44:	f800283a 	ret

81142e48 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
81142e48:	defff904 	addi	sp,sp,-28
81142e4c:	de00012e 	bgeu	sp,et,81142e54 <alt_ic_isr_register+0xc>
81142e50:	003b68fa 	trap	3
81142e54:	dfc00615 	stw	ra,24(sp)
81142e58:	df000515 	stw	fp,20(sp)
81142e5c:	df000504 	addi	fp,sp,20
81142e60:	e13ffc15 	stw	r4,-16(fp)
81142e64:	e17ffd15 	stw	r5,-12(fp)
81142e68:	e1bffe15 	stw	r6,-8(fp)
81142e6c:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
81142e70:	e0800217 	ldw	r2,8(fp)
81142e74:	d8800015 	stw	r2,0(sp)
81142e78:	e1ffff17 	ldw	r7,-4(fp)
81142e7c:	e1bffe17 	ldw	r6,-8(fp)
81142e80:	e17ffd17 	ldw	r5,-12(fp)
81142e84:	e13ffc17 	ldw	r4,-16(fp)
81142e88:	11430180 	call	81143018 <alt_iic_isr_register>
}  
81142e8c:	e037883a 	mov	sp,fp
81142e90:	dfc00117 	ldw	ra,4(sp)
81142e94:	df000017 	ldw	fp,0(sp)
81142e98:	dec00204 	addi	sp,sp,8
81142e9c:	f800283a 	ret

81142ea0 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
81142ea0:	defff904 	addi	sp,sp,-28
81142ea4:	de00012e 	bgeu	sp,et,81142eac <alt_ic_irq_enable+0xc>
81142ea8:	003b68fa 	trap	3
81142eac:	df000615 	stw	fp,24(sp)
81142eb0:	df000604 	addi	fp,sp,24
81142eb4:	e13ffe15 	stw	r4,-8(fp)
81142eb8:	e17fff15 	stw	r5,-4(fp)
81142ebc:	e0bfff17 	ldw	r2,-4(fp)
81142ec0:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142ec4:	0005303a 	rdctl	r2,status
81142ec8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142ecc:	e0fffb17 	ldw	r3,-20(fp)
81142ed0:	00bfff84 	movi	r2,-2
81142ed4:	1884703a 	and	r2,r3,r2
81142ed8:	1001703a 	wrctl	status,r2
  
  return context;
81142edc:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81142ee0:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
81142ee4:	00c00044 	movi	r3,1
81142ee8:	e0bffa17 	ldw	r2,-24(fp)
81142eec:	1884983a 	sll	r2,r3,r2
81142ef0:	1007883a 	mov	r3,r2
81142ef4:	d0a07f17 	ldw	r2,-32260(gp)
81142ef8:	1884b03a 	or	r2,r3,r2
81142efc:	d0a07f15 	stw	r2,-32260(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81142f00:	d0a07f17 	ldw	r2,-32260(gp)
81142f04:	100170fa 	wrctl	ienable,r2
81142f08:	e0bffc17 	ldw	r2,-16(fp)
81142f0c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142f10:	e0bffd17 	ldw	r2,-12(fp)
81142f14:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81142f18:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
81142f1c:	0001883a 	nop
}
81142f20:	e037883a 	mov	sp,fp
81142f24:	df000017 	ldw	fp,0(sp)
81142f28:	dec00104 	addi	sp,sp,4
81142f2c:	f800283a 	ret

81142f30 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
81142f30:	defff904 	addi	sp,sp,-28
81142f34:	de00012e 	bgeu	sp,et,81142f3c <alt_ic_irq_disable+0xc>
81142f38:	003b68fa 	trap	3
81142f3c:	df000615 	stw	fp,24(sp)
81142f40:	df000604 	addi	fp,sp,24
81142f44:	e13ffe15 	stw	r4,-8(fp)
81142f48:	e17fff15 	stw	r5,-4(fp)
81142f4c:	e0bfff17 	ldw	r2,-4(fp)
81142f50:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142f54:	0005303a 	rdctl	r2,status
81142f58:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142f5c:	e0fffb17 	ldw	r3,-20(fp)
81142f60:	00bfff84 	movi	r2,-2
81142f64:	1884703a 	and	r2,r3,r2
81142f68:	1001703a 	wrctl	status,r2
  
  return context;
81142f6c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81142f70:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
81142f74:	00c00044 	movi	r3,1
81142f78:	e0bffa17 	ldw	r2,-24(fp)
81142f7c:	1884983a 	sll	r2,r3,r2
81142f80:	0084303a 	nor	r2,zero,r2
81142f84:	1007883a 	mov	r3,r2
81142f88:	d0a07f17 	ldw	r2,-32260(gp)
81142f8c:	1884703a 	and	r2,r3,r2
81142f90:	d0a07f15 	stw	r2,-32260(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81142f94:	d0a07f17 	ldw	r2,-32260(gp)
81142f98:	100170fa 	wrctl	ienable,r2
81142f9c:	e0bffc17 	ldw	r2,-16(fp)
81142fa0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81142fa4:	e0bffd17 	ldw	r2,-12(fp)
81142fa8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81142fac:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
81142fb0:	0001883a 	nop
}
81142fb4:	e037883a 	mov	sp,fp
81142fb8:	df000017 	ldw	fp,0(sp)
81142fbc:	dec00104 	addi	sp,sp,4
81142fc0:	f800283a 	ret

81142fc4 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
81142fc4:	defffc04 	addi	sp,sp,-16
81142fc8:	de00012e 	bgeu	sp,et,81142fd0 <alt_ic_irq_enabled+0xc>
81142fcc:	003b68fa 	trap	3
81142fd0:	df000315 	stw	fp,12(sp)
81142fd4:	df000304 	addi	fp,sp,12
81142fd8:	e13ffe15 	stw	r4,-8(fp)
81142fdc:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
81142fe0:	000530fa 	rdctl	r2,ienable
81142fe4:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
81142fe8:	00c00044 	movi	r3,1
81142fec:	e0bfff17 	ldw	r2,-4(fp)
81142ff0:	1884983a 	sll	r2,r3,r2
81142ff4:	1007883a 	mov	r3,r2
81142ff8:	e0bffd17 	ldw	r2,-12(fp)
81142ffc:	1884703a 	and	r2,r3,r2
81143000:	1004c03a 	cmpne	r2,r2,zero
81143004:	10803fcc 	andi	r2,r2,255
}
81143008:	e037883a 	mov	sp,fp
8114300c:	df000017 	ldw	fp,0(sp)
81143010:	dec00104 	addi	sp,sp,4
81143014:	f800283a 	ret

81143018 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
81143018:	defff504 	addi	sp,sp,-44
8114301c:	de00012e 	bgeu	sp,et,81143024 <alt_iic_isr_register+0xc>
81143020:	003b68fa 	trap	3
81143024:	dfc00a15 	stw	ra,40(sp)
81143028:	df000915 	stw	fp,36(sp)
8114302c:	df000904 	addi	fp,sp,36
81143030:	e13ffc15 	stw	r4,-16(fp)
81143034:	e17ffd15 	stw	r5,-12(fp)
81143038:	e1bffe15 	stw	r6,-8(fp)
8114303c:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
81143040:	00bffa84 	movi	r2,-22
81143044:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
81143048:	e0bffd17 	ldw	r2,-12(fp)
8114304c:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
81143050:	e0bff817 	ldw	r2,-32(fp)
81143054:	10800808 	cmpgei	r2,r2,32
81143058:	1000271e 	bne	r2,zero,811430f8 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114305c:	0005303a 	rdctl	r2,status
81143060:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143064:	e0fffb17 	ldw	r3,-20(fp)
81143068:	00bfff84 	movi	r2,-2
8114306c:	1884703a 	and	r2,r3,r2
81143070:	1001703a 	wrctl	status,r2
  
  return context;
81143074:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
81143078:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
8114307c:	00a045b4 	movhi	r2,33046
81143080:	10865d04 	addi	r2,r2,6516
81143084:	e0fff817 	ldw	r3,-32(fp)
81143088:	180690fa 	slli	r3,r3,3
8114308c:	10c5883a 	add	r2,r2,r3
81143090:	e0fffe17 	ldw	r3,-8(fp)
81143094:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
81143098:	00a045b4 	movhi	r2,33046
8114309c:	10865d04 	addi	r2,r2,6516
811430a0:	e0fff817 	ldw	r3,-32(fp)
811430a4:	180690fa 	slli	r3,r3,3
811430a8:	10c5883a 	add	r2,r2,r3
811430ac:	10800104 	addi	r2,r2,4
811430b0:	e0ffff17 	ldw	r3,-4(fp)
811430b4:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
811430b8:	e0bffe17 	ldw	r2,-8(fp)
811430bc:	10000526 	beq	r2,zero,811430d4 <alt_iic_isr_register+0xbc>
811430c0:	e0bff817 	ldw	r2,-32(fp)
811430c4:	100b883a 	mov	r5,r2
811430c8:	e13ffc17 	ldw	r4,-16(fp)
811430cc:	1142ea00 	call	81142ea0 <alt_ic_irq_enable>
811430d0:	00000406 	br	811430e4 <alt_iic_isr_register+0xcc>
811430d4:	e0bff817 	ldw	r2,-32(fp)
811430d8:	100b883a 	mov	r5,r2
811430dc:	e13ffc17 	ldw	r4,-16(fp)
811430e0:	1142f300 	call	81142f30 <alt_ic_irq_disable>
811430e4:	e0bff715 	stw	r2,-36(fp)
811430e8:	e0bffa17 	ldw	r2,-24(fp)
811430ec:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811430f0:	e0bff917 	ldw	r2,-28(fp)
811430f4:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
811430f8:	e0bff717 	ldw	r2,-36(fp)
}
811430fc:	e037883a 	mov	sp,fp
81143100:	dfc00117 	ldw	ra,4(sp)
81143104:	df000017 	ldw	fp,0(sp)
81143108:	dec00204 	addi	sp,sp,8
8114310c:	f800283a 	ret

81143110 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
81143110:	defff904 	addi	sp,sp,-28
81143114:	de00012e 	bgeu	sp,et,8114311c <alt_open_fd+0xc>
81143118:	003b68fa 	trap	3
8114311c:	dfc00615 	stw	ra,24(sp)
81143120:	df000515 	stw	fp,20(sp)
81143124:	df000504 	addi	fp,sp,20
81143128:	e13ffc15 	stw	r4,-16(fp)
8114312c:	e17ffd15 	stw	r5,-12(fp)
81143130:	e1bffe15 	stw	r6,-8(fp)
81143134:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
81143138:	e1bfff17 	ldw	r6,-4(fp)
8114313c:	e17ffe17 	ldw	r5,-8(fp)
81143140:	e13ffd17 	ldw	r4,-12(fp)
81143144:	11433700 	call	81143370 <open>
81143148:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
8114314c:	e0bffb17 	ldw	r2,-20(fp)
81143150:	10001c16 	blt	r2,zero,811431c4 <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
81143154:	00a04534 	movhi	r2,33044
81143158:	1098f704 	addi	r2,r2,25564
8114315c:	e0fffb17 	ldw	r3,-20(fp)
81143160:	18c00324 	muli	r3,r3,12
81143164:	10c5883a 	add	r2,r2,r3
81143168:	10c00017 	ldw	r3,0(r2)
8114316c:	e0bffc17 	ldw	r2,-16(fp)
81143170:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
81143174:	00a04534 	movhi	r2,33044
81143178:	1098f704 	addi	r2,r2,25564
8114317c:	e0fffb17 	ldw	r3,-20(fp)
81143180:	18c00324 	muli	r3,r3,12
81143184:	10c5883a 	add	r2,r2,r3
81143188:	10800104 	addi	r2,r2,4
8114318c:	10c00017 	ldw	r3,0(r2)
81143190:	e0bffc17 	ldw	r2,-16(fp)
81143194:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
81143198:	00a04534 	movhi	r2,33044
8114319c:	1098f704 	addi	r2,r2,25564
811431a0:	e0fffb17 	ldw	r3,-20(fp)
811431a4:	18c00324 	muli	r3,r3,12
811431a8:	10c5883a 	add	r2,r2,r3
811431ac:	10800204 	addi	r2,r2,8
811431b0:	10c00017 	ldw	r3,0(r2)
811431b4:	e0bffc17 	ldw	r2,-16(fp)
811431b8:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
811431bc:	e13ffb17 	ldw	r4,-20(fp)
811431c0:	11304580 	call	81130458 <alt_release_fd>
  }
} 
811431c4:	0001883a 	nop
811431c8:	e037883a 	mov	sp,fp
811431cc:	dfc00117 	ldw	ra,4(sp)
811431d0:	df000017 	ldw	fp,0(sp)
811431d4:	dec00204 	addi	sp,sp,8
811431d8:	f800283a 	ret

811431dc <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
811431dc:	defffb04 	addi	sp,sp,-20
811431e0:	de00012e 	bgeu	sp,et,811431e8 <alt_io_redirect+0xc>
811431e4:	003b68fa 	trap	3
811431e8:	dfc00415 	stw	ra,16(sp)
811431ec:	df000315 	stw	fp,12(sp)
811431f0:	df000304 	addi	fp,sp,12
811431f4:	e13ffd15 	stw	r4,-12(fp)
811431f8:	e17ffe15 	stw	r5,-8(fp)
811431fc:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
81143200:	01c07fc4 	movi	r7,511
81143204:	01800044 	movi	r6,1
81143208:	e17ffd17 	ldw	r5,-12(fp)
8114320c:	01204534 	movhi	r4,33044
81143210:	2118fa04 	addi	r4,r4,25576
81143214:	11431100 	call	81143110 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
81143218:	01c07fc4 	movi	r7,511
8114321c:	000d883a 	mov	r6,zero
81143220:	e17ffe17 	ldw	r5,-8(fp)
81143224:	01204534 	movhi	r4,33044
81143228:	2118f704 	addi	r4,r4,25564
8114322c:	11431100 	call	81143110 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
81143230:	01c07fc4 	movi	r7,511
81143234:	01800044 	movi	r6,1
81143238:	e17fff17 	ldw	r5,-4(fp)
8114323c:	01204534 	movhi	r4,33044
81143240:	2118fd04 	addi	r4,r4,25588
81143244:	11431100 	call	81143110 <alt_open_fd>
}  
81143248:	0001883a 	nop
8114324c:	e037883a 	mov	sp,fp
81143250:	dfc00117 	ldw	ra,4(sp)
81143254:	df000017 	ldw	fp,0(sp)
81143258:	dec00204 	addi	sp,sp,8
8114325c:	f800283a 	ret

81143260 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81143260:	defffe04 	addi	sp,sp,-8
81143264:	de00012e 	bgeu	sp,et,8114326c <alt_get_errno+0xc>
81143268:	003b68fa 	trap	3
8114326c:	dfc00115 	stw	ra,4(sp)
81143270:	df000015 	stw	fp,0(sp)
81143274:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81143278:	d0a01017 	ldw	r2,-32704(gp)
8114327c:	10000326 	beq	r2,zero,8114328c <alt_get_errno+0x2c>
81143280:	d0a01017 	ldw	r2,-32704(gp)
81143284:	103ee83a 	callr	r2
81143288:	00000106 	br	81143290 <alt_get_errno+0x30>
8114328c:	d0a07d04 	addi	r2,gp,-32268
}
81143290:	e037883a 	mov	sp,fp
81143294:	dfc00117 	ldw	ra,4(sp)
81143298:	df000017 	ldw	fp,0(sp)
8114329c:	dec00204 	addi	sp,sp,8
811432a0:	f800283a 	ret

811432a4 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
811432a4:	defffd04 	addi	sp,sp,-12
811432a8:	de00012e 	bgeu	sp,et,811432b0 <alt_file_locked+0xc>
811432ac:	003b68fa 	trap	3
811432b0:	df000215 	stw	fp,8(sp)
811432b4:	df000204 	addi	fp,sp,8
811432b8:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
811432bc:	e0bfff17 	ldw	r2,-4(fp)
811432c0:	10800217 	ldw	r2,8(r2)
811432c4:	10d00034 	orhi	r3,r2,16384
811432c8:	e0bfff17 	ldw	r2,-4(fp)
811432cc:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
811432d0:	e03ffe15 	stw	zero,-8(fp)
811432d4:	00001d06 	br	8114334c <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
811432d8:	00a04534 	movhi	r2,33044
811432dc:	1098f704 	addi	r2,r2,25564
811432e0:	e0fffe17 	ldw	r3,-8(fp)
811432e4:	18c00324 	muli	r3,r3,12
811432e8:	10c5883a 	add	r2,r2,r3
811432ec:	10c00017 	ldw	r3,0(r2)
811432f0:	e0bfff17 	ldw	r2,-4(fp)
811432f4:	10800017 	ldw	r2,0(r2)
811432f8:	1880111e 	bne	r3,r2,81143340 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
811432fc:	00a04534 	movhi	r2,33044
81143300:	1098f704 	addi	r2,r2,25564
81143304:	e0fffe17 	ldw	r3,-8(fp)
81143308:	18c00324 	muli	r3,r3,12
8114330c:	10c5883a 	add	r2,r2,r3
81143310:	10800204 	addi	r2,r2,8
81143314:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
81143318:	1000090e 	bge	r2,zero,81143340 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
8114331c:	e0bffe17 	ldw	r2,-8(fp)
81143320:	10c00324 	muli	r3,r2,12
81143324:	00a04534 	movhi	r2,33044
81143328:	1098f704 	addi	r2,r2,25564
8114332c:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81143330:	e0bfff17 	ldw	r2,-4(fp)
81143334:	18800226 	beq	r3,r2,81143340 <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
81143338:	00bffcc4 	movi	r2,-13
8114333c:	00000806 	br	81143360 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81143340:	e0bffe17 	ldw	r2,-8(fp)
81143344:	10800044 	addi	r2,r2,1
81143348:	e0bffe15 	stw	r2,-8(fp)
8114334c:	d0a00f17 	ldw	r2,-32708(gp)
81143350:	1007883a 	mov	r3,r2
81143354:	e0bffe17 	ldw	r2,-8(fp)
81143358:	18bfdf2e 	bgeu	r3,r2,811432d8 <__reset+0xfb1232d8>
    }
  }
  
  /* The device is not locked */
 
  return 0;
8114335c:	0005883a 	mov	r2,zero
}
81143360:	e037883a 	mov	sp,fp
81143364:	df000017 	ldw	fp,0(sp)
81143368:	dec00104 	addi	sp,sp,4
8114336c:	f800283a 	ret

81143370 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
81143370:	defff604 	addi	sp,sp,-40
81143374:	de00012e 	bgeu	sp,et,8114337c <open+0xc>
81143378:	003b68fa 	trap	3
8114337c:	dfc00915 	stw	ra,36(sp)
81143380:	df000815 	stw	fp,32(sp)
81143384:	df000804 	addi	fp,sp,32
81143388:	e13ffd15 	stw	r4,-12(fp)
8114338c:	e17ffe15 	stw	r5,-8(fp)
81143390:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
81143394:	00bfffc4 	movi	r2,-1
81143398:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
8114339c:	00bffb44 	movi	r2,-19
811433a0:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
811433a4:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
811433a8:	d1600d04 	addi	r5,gp,-32716
811433ac:	e13ffd17 	ldw	r4,-12(fp)
811433b0:	1142db00 	call	81142db0 <alt_find_dev>
811433b4:	e0bff815 	stw	r2,-32(fp)
811433b8:	e0bff817 	ldw	r2,-32(fp)
811433bc:	1000051e 	bne	r2,zero,811433d4 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
811433c0:	e13ffd17 	ldw	r4,-12(fp)
811433c4:	1143b580 	call	81143b58 <alt_find_file>
811433c8:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
811433cc:	00800044 	movi	r2,1
811433d0:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
811433d4:	e0bff817 	ldw	r2,-32(fp)
811433d8:	10002926 	beq	r2,zero,81143480 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
811433dc:	e13ff817 	ldw	r4,-32(fp)
811433e0:	1143c680 	call	81143c68 <alt_get_fd>
811433e4:	e0bff915 	stw	r2,-28(fp)
811433e8:	e0bff917 	ldw	r2,-28(fp)
811433ec:	1000030e 	bge	r2,zero,811433fc <open+0x8c>
    {
      status = index;
811433f0:	e0bff917 	ldw	r2,-28(fp)
811433f4:	e0bffa15 	stw	r2,-24(fp)
811433f8:	00002306 	br	81143488 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
811433fc:	e0bff917 	ldw	r2,-28(fp)
81143400:	10c00324 	muli	r3,r2,12
81143404:	00a04534 	movhi	r2,33044
81143408:	1098f704 	addi	r2,r2,25564
8114340c:	1885883a 	add	r2,r3,r2
81143410:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
81143414:	e0fffe17 	ldw	r3,-8(fp)
81143418:	00900034 	movhi	r2,16384
8114341c:	10bfffc4 	addi	r2,r2,-1
81143420:	1886703a 	and	r3,r3,r2
81143424:	e0bffc17 	ldw	r2,-16(fp)
81143428:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
8114342c:	e0bffb17 	ldw	r2,-20(fp)
81143430:	1000051e 	bne	r2,zero,81143448 <open+0xd8>
81143434:	e13ffc17 	ldw	r4,-16(fp)
81143438:	11432a40 	call	811432a4 <alt_file_locked>
8114343c:	e0bffa15 	stw	r2,-24(fp)
81143440:	e0bffa17 	ldw	r2,-24(fp)
81143444:	10001016 	blt	r2,zero,81143488 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
81143448:	e0bff817 	ldw	r2,-32(fp)
8114344c:	10800317 	ldw	r2,12(r2)
81143450:	10000826 	beq	r2,zero,81143474 <open+0x104>
81143454:	e0bff817 	ldw	r2,-32(fp)
81143458:	10800317 	ldw	r2,12(r2)
8114345c:	e1ffff17 	ldw	r7,-4(fp)
81143460:	e1bffe17 	ldw	r6,-8(fp)
81143464:	e17ffd17 	ldw	r5,-12(fp)
81143468:	e13ffc17 	ldw	r4,-16(fp)
8114346c:	103ee83a 	callr	r2
81143470:	00000106 	br	81143478 <open+0x108>
81143474:	0005883a 	mov	r2,zero
81143478:	e0bffa15 	stw	r2,-24(fp)
8114347c:	00000206 	br	81143488 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
81143480:	00bffb44 	movi	r2,-19
81143484:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
81143488:	e0bffa17 	ldw	r2,-24(fp)
8114348c:	1000090e 	bge	r2,zero,811434b4 <open+0x144>
  {
    alt_release_fd (index);  
81143490:	e13ff917 	ldw	r4,-28(fp)
81143494:	11304580 	call	81130458 <alt_release_fd>
    ALT_ERRNO = -status;
81143498:	11432600 	call	81143260 <alt_get_errno>
8114349c:	1007883a 	mov	r3,r2
811434a0:	e0bffa17 	ldw	r2,-24(fp)
811434a4:	0085c83a 	sub	r2,zero,r2
811434a8:	18800015 	stw	r2,0(r3)
    return -1;
811434ac:	00bfffc4 	movi	r2,-1
811434b0:	00000106 	br	811434b8 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
811434b4:	e0bff917 	ldw	r2,-28(fp)
}
811434b8:	e037883a 	mov	sp,fp
811434bc:	dfc00117 	ldw	ra,4(sp)
811434c0:	df000017 	ldw	fp,0(sp)
811434c4:	dec00204 	addi	sp,sp,8
811434c8:	f800283a 	ret

811434cc <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
811434cc:	defff204 	addi	sp,sp,-56
811434d0:	de00012e 	bgeu	sp,et,811434d8 <alt_printf+0xc>
811434d4:	003b68fa 	trap	3
811434d8:	dfc00a15 	stw	ra,40(sp)
811434dc:	df000915 	stw	fp,36(sp)
811434e0:	df000904 	addi	fp,sp,36
811434e4:	e13fff15 	stw	r4,-4(fp)
811434e8:	e1400215 	stw	r5,8(fp)
811434ec:	e1800315 	stw	r6,12(fp)
811434f0:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
811434f4:	e0800204 	addi	r2,fp,8
811434f8:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
811434fc:	e0bfff17 	ldw	r2,-4(fp)
81143500:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
81143504:	00006f06 	br	811436c4 <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
81143508:	e0bff807 	ldb	r2,-32(fp)
8114350c:	10800960 	cmpeqi	r2,r2,37
81143510:	1000041e 	bne	r2,zero,81143524 <alt_printf+0x58>
        {
            alt_putchar(c);
81143514:	e0bff807 	ldb	r2,-32(fp)
81143518:	1009883a 	mov	r4,r2
8114351c:	11437000 	call	81143700 <alt_putchar>
81143520:	00006806 	br	811436c4 <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
81143524:	e0bff717 	ldw	r2,-36(fp)
81143528:	10c00044 	addi	r3,r2,1
8114352c:	e0fff715 	stw	r3,-36(fp)
81143530:	10800003 	ldbu	r2,0(r2)
81143534:	e0bff805 	stb	r2,-32(fp)
81143538:	e0bff807 	ldb	r2,-32(fp)
8114353c:	10006926 	beq	r2,zero,811436e4 <alt_printf+0x218>
            {
                if (c == '%')
81143540:	e0bff807 	ldb	r2,-32(fp)
81143544:	10800958 	cmpnei	r2,r2,37
81143548:	1000041e 	bne	r2,zero,8114355c <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
8114354c:	e0bff807 	ldb	r2,-32(fp)
81143550:	1009883a 	mov	r4,r2
81143554:	11437000 	call	81143700 <alt_putchar>
81143558:	00005a06 	br	811436c4 <alt_printf+0x1f8>
                } 
                else if (c == 'c')
8114355c:	e0bff807 	ldb	r2,-32(fp)
81143560:	108018d8 	cmpnei	r2,r2,99
81143564:	1000081e 	bne	r2,zero,81143588 <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
81143568:	e0bffe17 	ldw	r2,-8(fp)
8114356c:	10c00104 	addi	r3,r2,4
81143570:	e0fffe15 	stw	r3,-8(fp)
81143574:	10800017 	ldw	r2,0(r2)
81143578:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
8114357c:	e13ffd17 	ldw	r4,-12(fp)
81143580:	11437000 	call	81143700 <alt_putchar>
81143584:	00004f06 	br	811436c4 <alt_printf+0x1f8>
                }
                else if (c == 'x')
81143588:	e0bff807 	ldb	r2,-32(fp)
8114358c:	10801e18 	cmpnei	r2,r2,120
81143590:	1000341e 	bne	r2,zero,81143664 <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
81143594:	e0bffe17 	ldw	r2,-8(fp)
81143598:	10c00104 	addi	r3,r2,4
8114359c:	e0fffe15 	stw	r3,-8(fp)
811435a0:	10800017 	ldw	r2,0(r2)
811435a4:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
811435a8:	e0bffb17 	ldw	r2,-20(fp)
811435ac:	1000031e 	bne	r2,zero,811435bc <alt_printf+0xf0>
                    {
                        alt_putchar('0');
811435b0:	01000c04 	movi	r4,48
811435b4:	11437000 	call	81143700 <alt_putchar>
                        continue;
811435b8:	00004206 	br	811436c4 <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
811435bc:	00800704 	movi	r2,28
811435c0:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
811435c4:	00000306 	br	811435d4 <alt_printf+0x108>
                        digit_shift -= 4;
811435c8:	e0bff917 	ldw	r2,-28(fp)
811435cc:	10bfff04 	addi	r2,r2,-4
811435d0:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
811435d4:	00c003c4 	movi	r3,15
811435d8:	e0bff917 	ldw	r2,-28(fp)
811435dc:	1884983a 	sll	r2,r3,r2
811435e0:	1007883a 	mov	r3,r2
811435e4:	e0bffb17 	ldw	r2,-20(fp)
811435e8:	1884703a 	and	r2,r3,r2
811435ec:	103ff626 	beq	r2,zero,811435c8 <__reset+0xfb1235c8>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
811435f0:	00001906 	br	81143658 <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
811435f4:	00c003c4 	movi	r3,15
811435f8:	e0bff917 	ldw	r2,-28(fp)
811435fc:	1884983a 	sll	r2,r3,r2
81143600:	1007883a 	mov	r3,r2
81143604:	e0bffb17 	ldw	r2,-20(fp)
81143608:	1886703a 	and	r3,r3,r2
8114360c:	e0bff917 	ldw	r2,-28(fp)
81143610:	1884d83a 	srl	r2,r3,r2
81143614:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
81143618:	e0bffc17 	ldw	r2,-16(fp)
8114361c:	108002a8 	cmpgeui	r2,r2,10
81143620:	1000041e 	bne	r2,zero,81143634 <alt_printf+0x168>
                            c = '0' + digit;
81143624:	e0bffc17 	ldw	r2,-16(fp)
81143628:	10800c04 	addi	r2,r2,48
8114362c:	e0bff805 	stb	r2,-32(fp)
81143630:	00000306 	br	81143640 <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
81143634:	e0bffc17 	ldw	r2,-16(fp)
81143638:	108015c4 	addi	r2,r2,87
8114363c:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
81143640:	e0bff807 	ldb	r2,-32(fp)
81143644:	1009883a 	mov	r4,r2
81143648:	11437000 	call	81143700 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
8114364c:	e0bff917 	ldw	r2,-28(fp)
81143650:	10bfff04 	addi	r2,r2,-4
81143654:	e0bff915 	stw	r2,-28(fp)
81143658:	e0bff917 	ldw	r2,-28(fp)
8114365c:	103fe50e 	bge	r2,zero,811435f4 <__reset+0xfb1235f4>
81143660:	00001806 	br	811436c4 <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
81143664:	e0bff807 	ldb	r2,-32(fp)
81143668:	10801cd8 	cmpnei	r2,r2,115
8114366c:	1000151e 	bne	r2,zero,811436c4 <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
81143670:	e0bffe17 	ldw	r2,-8(fp)
81143674:	10c00104 	addi	r3,r2,4
81143678:	e0fffe15 	stw	r3,-8(fp)
8114367c:	10800017 	ldw	r2,0(r2)
81143680:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
81143684:	00000906 	br	811436ac <alt_printf+0x1e0>
                      alt_putchar(*s++);
81143688:	e0bffa17 	ldw	r2,-24(fp)
8114368c:	10c00044 	addi	r3,r2,1
81143690:	e0fffa15 	stw	r3,-24(fp)
81143694:	10800003 	ldbu	r2,0(r2)
81143698:	10803fcc 	andi	r2,r2,255
8114369c:	1080201c 	xori	r2,r2,128
811436a0:	10bfe004 	addi	r2,r2,-128
811436a4:	1009883a 	mov	r4,r2
811436a8:	11437000 	call	81143700 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
811436ac:	e0bffa17 	ldw	r2,-24(fp)
811436b0:	10800003 	ldbu	r2,0(r2)
811436b4:	10803fcc 	andi	r2,r2,255
811436b8:	1080201c 	xori	r2,r2,128
811436bc:	10bfe004 	addi	r2,r2,-128
811436c0:	103ff11e 	bne	r2,zero,81143688 <__reset+0xfb123688>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
811436c4:	e0bff717 	ldw	r2,-36(fp)
811436c8:	10c00044 	addi	r3,r2,1
811436cc:	e0fff715 	stw	r3,-36(fp)
811436d0:	10800003 	ldbu	r2,0(r2)
811436d4:	e0bff805 	stb	r2,-32(fp)
811436d8:	e0bff807 	ldb	r2,-32(fp)
811436dc:	103f8a1e 	bne	r2,zero,81143508 <__reset+0xfb123508>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
811436e0:	00000106 	br	811436e8 <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
811436e4:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
811436e8:	0001883a 	nop
811436ec:	e037883a 	mov	sp,fp
811436f0:	dfc00117 	ldw	ra,4(sp)
811436f4:	df000017 	ldw	fp,0(sp)
811436f8:	dec00504 	addi	sp,sp,20
811436fc:	f800283a 	ret

81143700 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
81143700:	defffd04 	addi	sp,sp,-12
81143704:	de00012e 	bgeu	sp,et,8114370c <alt_putchar+0xc>
81143708:	003b68fa 	trap	3
8114370c:	dfc00215 	stw	ra,8(sp)
81143710:	df000115 	stw	fp,4(sp)
81143714:	df000104 	addi	fp,sp,4
81143718:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
8114371c:	d0a00517 	ldw	r2,-32748(gp)
81143720:	10800217 	ldw	r2,8(r2)
81143724:	100b883a 	mov	r5,r2
81143728:	e13fff17 	ldw	r4,-4(fp)
8114372c:	1143f540 	call	81143f54 <putc>
#endif
#endif
}
81143730:	e037883a 	mov	sp,fp
81143734:	dfc00117 	ldw	ra,4(sp)
81143738:	df000017 	ldw	fp,0(sp)
8114373c:	dec00204 	addi	sp,sp,8
81143740:	f800283a 	ret

81143744 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
81143744:	deffff04 	addi	sp,sp,-4
81143748:	de00012e 	bgeu	sp,et,81143750 <altera_nios2_gen2_irq_init+0xc>
8114374c:	003b68fa 	trap	3
81143750:	df000015 	stw	fp,0(sp)
81143754:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
81143758:	000170fa 	wrctl	ienable,zero
}
8114375c:	0001883a 	nop
81143760:	e037883a 	mov	sp,fp
81143764:	df000017 	ldw	fp,0(sp)
81143768:	dec00104 	addi	sp,sp,4
8114376c:	f800283a 	ret

81143770 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
81143770:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
81143774:	de002436 	bltu	sp,et,81143808 <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
81143778:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
8114377c:	d120a117 	ldw	r4,-32124(gp)

      stw ra,  0(sp)
81143780:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
81143784:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
81143788:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
8114378c:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
81143790:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
81143794:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
81143798:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
8114379c:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
811437a0:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
811437a4:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
811437a8:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
811437ac:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
811437b0:	1143a0c0 	call	81143a0c <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
811437b4:	d1209b17 	ldw	r4,-32148(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
811437b8:	d1609287 	ldb	r5,-32182(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
811437bc:	d120a115 	stw	r4,-32124(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
811437c0:	d16092c5 	stb	r5,-32181(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
811437c4:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
811437c8:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
811437cc:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
811437d0:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
811437d4:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
811437d8:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
811437dc:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
811437e0:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
811437e4:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
811437e8:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
811437ec:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
811437f0:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
811437f4:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
811437f8:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
811437fc:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
81143800:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
81143804:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
81143808:	003da0fa 	break	3

8114380c <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
8114380c:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
81143810:	047fff84 	movi	r17,-2
      and   r18, r18, r17
81143814:	9464703a 	and	r18,r18,r17
      wrctl status, r18
81143818:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
8114381c:	1143a0c0 	call	81143a0c <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
81143820:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
81143824:	d4a09005 	stb	r18,-32192(gp)

      /*
       * start execution of the new task.
       */

      br 9b
81143828:	003fe206 	br	811437b4 <__reset+0xfb1237b4>

8114382c <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
8114382c:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
81143830:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
81143834:	10800054 	ori	r2,r2,1
      wrctl status, r2
81143838:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
8114383c:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
81143840:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
81143844:	dec00204 	addi	sp,sp,8

      callr r2
81143848:	103ee83a 	callr	r2

      nop
8114384c:	0001883a 	nop

81143850 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
81143850:	defff704 	addi	sp,sp,-36
81143854:	de00012e 	bgeu	sp,et,8114385c <OSTaskStkInit+0xc>
81143858:	003b68fa 	trap	3
8114385c:	dfc00815 	stw	ra,32(sp)
81143860:	df000715 	stw	fp,28(sp)
81143864:	df000704 	addi	fp,sp,28
81143868:	e13ffc15 	stw	r4,-16(fp)
8114386c:	e17ffd15 	stw	r5,-12(fp)
81143870:	e1bffe15 	stw	r6,-8(fp)
81143874:	3805883a 	mov	r2,r7
81143878:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
8114387c:	e0fffe17 	ldw	r3,-8(fp)
81143880:	00bfff04 	movi	r2,-4
81143884:	1884703a 	and	r2,r3,r2
81143888:	10bef704 	addi	r2,r2,-1060
8114388c:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
81143890:	01810904 	movi	r6,1060
81143894:	000b883a 	mov	r5,zero
81143898:	e13ff917 	ldw	r4,-28(fp)
8114389c:	111acfc0 	call	8111acfc <memset>
811438a0:	e0bff917 	ldw	r2,-28(fp)
811438a4:	10c0bb04 	addi	r3,r2,748
811438a8:	e0bff917 	ldw	r2,-28(fp)
811438ac:	10c00115 	stw	r3,4(r2)
811438b0:	e0bff917 	ldw	r2,-28(fp)
811438b4:	10c0d504 	addi	r3,r2,852
811438b8:	e0bff917 	ldw	r2,-28(fp)
811438bc:	10c00215 	stw	r3,8(r2)
811438c0:	e0bff917 	ldw	r2,-28(fp)
811438c4:	10c0ef04 	addi	r3,r2,956
811438c8:	e0bff917 	ldw	r2,-28(fp)
811438cc:	10c00315 	stw	r3,12(r2)
811438d0:	e0fff917 	ldw	r3,-28(fp)
811438d4:	00a04534 	movhi	r2,33044
811438d8:	10969004 	addi	r2,r2,23104
811438dc:	18800d15 	stw	r2,52(r3)
811438e0:	e0bff917 	ldw	r2,-28(fp)
811438e4:	00c00044 	movi	r3,1
811438e8:	10c02915 	stw	r3,164(r2)
811438ec:	10002a15 	stw	zero,168(r2)
811438f0:	e0bff917 	ldw	r2,-28(fp)
811438f4:	00ccc384 	movi	r3,13070
811438f8:	10c02b0d 	sth	r3,172(r2)
811438fc:	e0bff917 	ldw	r2,-28(fp)
81143900:	00eaf344 	movi	r3,-21555
81143904:	10c02b8d 	sth	r3,174(r2)
81143908:	e0bff917 	ldw	r2,-28(fp)
8114390c:	00c48d04 	movi	r3,4660
81143910:	10c02c0d 	sth	r3,176(r2)
81143914:	e0bff917 	ldw	r2,-28(fp)
81143918:	00f99b44 	movi	r3,-6547
8114391c:	10c02c8d 	sth	r3,178(r2)
81143920:	e0bff917 	ldw	r2,-28(fp)
81143924:	00f7bb04 	movi	r3,-8468
81143928:	10c02d0d 	sth	r3,180(r2)
8114392c:	e0bff917 	ldw	r2,-28(fp)
81143930:	00c00144 	movi	r3,5
81143934:	10c02d8d 	sth	r3,182(r2)
81143938:	e0bff917 	ldw	r2,-28(fp)
8114393c:	00c002c4 	movi	r3,11
81143940:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
81143944:	e0bff917 	ldw	r2,-28(fp)
81143948:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
8114394c:	e0bffa17 	ldw	r2,-24(fp)
81143950:	10bff304 	addi	r2,r2,-52
81143954:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
81143958:	e0bffb17 	ldw	r2,-20(fp)
8114395c:	10800c04 	addi	r2,r2,48
81143960:	e0fffc17 	ldw	r3,-16(fp)
81143964:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
81143968:	e0bffb17 	ldw	r2,-20(fp)
8114396c:	10800b04 	addi	r2,r2,44
81143970:	e0fffd17 	ldw	r3,-12(fp)
81143974:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
81143978:	e0bffb17 	ldw	r2,-20(fp)
8114397c:	10800a04 	addi	r2,r2,40
81143980:	e0fff917 	ldw	r3,-28(fp)
81143984:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
81143988:	00a04534 	movhi	r2,33044
8114398c:	108e0b04 	addi	r2,r2,14380
81143990:	10c00104 	addi	r3,r2,4
81143994:	e0bffb17 	ldw	r2,-20(fp)
81143998:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
8114399c:	e0bffb17 	ldw	r2,-20(fp)
}
811439a0:	e037883a 	mov	sp,fp
811439a4:	dfc00117 	ldw	ra,4(sp)
811439a8:	df000017 	ldw	fp,0(sp)
811439ac:	dec00204 	addi	sp,sp,8
811439b0:	f800283a 	ret

811439b4 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
811439b4:	defffe04 	addi	sp,sp,-8
811439b8:	de00012e 	bgeu	sp,et,811439c0 <OSTaskCreateHook+0xc>
811439bc:	003b68fa 	trap	3
811439c0:	df000115 	stw	fp,4(sp)
811439c4:	df000104 	addi	fp,sp,4
811439c8:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
811439cc:	0001883a 	nop
811439d0:	e037883a 	mov	sp,fp
811439d4:	df000017 	ldw	fp,0(sp)
811439d8:	dec00104 	addi	sp,sp,4
811439dc:	f800283a 	ret

811439e0 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
811439e0:	defffe04 	addi	sp,sp,-8
811439e4:	de00012e 	bgeu	sp,et,811439ec <OSTaskDelHook+0xc>
811439e8:	003b68fa 	trap	3
811439ec:	df000115 	stw	fp,4(sp)
811439f0:	df000104 	addi	fp,sp,4
811439f4:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
811439f8:	0001883a 	nop
811439fc:	e037883a 	mov	sp,fp
81143a00:	df000017 	ldw	fp,0(sp)
81143a04:	dec00104 	addi	sp,sp,4
81143a08:	f800283a 	ret

81143a0c <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
81143a0c:	deffff04 	addi	sp,sp,-4
81143a10:	de00012e 	bgeu	sp,et,81143a18 <OSTaskSwHook+0xc>
81143a14:	003b68fa 	trap	3
81143a18:	df000015 	stw	fp,0(sp)
81143a1c:	d839883a 	mov	fp,sp
}
81143a20:	0001883a 	nop
81143a24:	e037883a 	mov	sp,fp
81143a28:	df000017 	ldw	fp,0(sp)
81143a2c:	dec00104 	addi	sp,sp,4
81143a30:	f800283a 	ret

81143a34 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
81143a34:	deffff04 	addi	sp,sp,-4
81143a38:	de00012e 	bgeu	sp,et,81143a40 <OSTaskStatHook+0xc>
81143a3c:	003b68fa 	trap	3
81143a40:	df000015 	stw	fp,0(sp)
81143a44:	d839883a 	mov	fp,sp
}
81143a48:	0001883a 	nop
81143a4c:	e037883a 	mov	sp,fp
81143a50:	df000017 	ldw	fp,0(sp)
81143a54:	dec00104 	addi	sp,sp,4
81143a58:	f800283a 	ret

81143a5c <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
81143a5c:	defffe04 	addi	sp,sp,-8
81143a60:	de00012e 	bgeu	sp,et,81143a68 <OSTimeTickHook+0xc>
81143a64:	003b68fa 	trap	3
81143a68:	dfc00115 	stw	ra,4(sp)
81143a6c:	df000015 	stw	fp,0(sp)
81143a70:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
81143a74:	d0a0b50b 	ldhu	r2,-32044(gp)
81143a78:	10800044 	addi	r2,r2,1
81143a7c:	d0a0b50d 	sth	r2,-32044(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
81143a80:	d0a0b50b 	ldhu	r2,-32044(gp)
81143a84:	10bfffcc 	andi	r2,r2,65535
81143a88:	10807d30 	cmpltui	r2,r2,500
81143a8c:	1000021e 	bne	r2,zero,81143a98 <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
81143a90:	d020b50d 	sth	zero,-32044(gp)
        OSTmrSignal();
81143a94:	113a3340 	call	8113a334 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
81143a98:	0001883a 	nop
81143a9c:	e037883a 	mov	sp,fp
81143aa0:	dfc00117 	ldw	ra,4(sp)
81143aa4:	df000017 	ldw	fp,0(sp)
81143aa8:	dec00204 	addi	sp,sp,8
81143aac:	f800283a 	ret

81143ab0 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
81143ab0:	deffff04 	addi	sp,sp,-4
81143ab4:	de00012e 	bgeu	sp,et,81143abc <OSInitHookBegin+0xc>
81143ab8:	003b68fa 	trap	3
81143abc:	df000015 	stw	fp,0(sp)
81143ac0:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
81143ac4:	d020b50d 	sth	zero,-32044(gp)
#endif
}
81143ac8:	0001883a 	nop
81143acc:	e037883a 	mov	sp,fp
81143ad0:	df000017 	ldw	fp,0(sp)
81143ad4:	dec00104 	addi	sp,sp,4
81143ad8:	f800283a 	ret

81143adc <OSInitHookEnd>:

void OSInitHookEnd(void)
{
81143adc:	deffff04 	addi	sp,sp,-4
81143ae0:	de00012e 	bgeu	sp,et,81143ae8 <OSInitHookEnd+0xc>
81143ae4:	003b68fa 	trap	3
81143ae8:	df000015 	stw	fp,0(sp)
81143aec:	d839883a 	mov	fp,sp
}
81143af0:	0001883a 	nop
81143af4:	e037883a 	mov	sp,fp
81143af8:	df000017 	ldw	fp,0(sp)
81143afc:	dec00104 	addi	sp,sp,4
81143b00:	f800283a 	ret

81143b04 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
81143b04:	deffff04 	addi	sp,sp,-4
81143b08:	de00012e 	bgeu	sp,et,81143b10 <OSTaskIdleHook+0xc>
81143b0c:	003b68fa 	trap	3
81143b10:	df000015 	stw	fp,0(sp)
81143b14:	d839883a 	mov	fp,sp
}
81143b18:	0001883a 	nop
81143b1c:	e037883a 	mov	sp,fp
81143b20:	df000017 	ldw	fp,0(sp)
81143b24:	dec00104 	addi	sp,sp,4
81143b28:	f800283a 	ret

81143b2c <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
81143b2c:	defffe04 	addi	sp,sp,-8
81143b30:	de00012e 	bgeu	sp,et,81143b38 <OSTCBInitHook+0xc>
81143b34:	003b68fa 	trap	3
81143b38:	df000115 	stw	fp,4(sp)
81143b3c:	df000104 	addi	fp,sp,4
81143b40:	e13fff15 	stw	r4,-4(fp)
}
81143b44:	0001883a 	nop
81143b48:	e037883a 	mov	sp,fp
81143b4c:	df000017 	ldw	fp,0(sp)
81143b50:	dec00104 	addi	sp,sp,4
81143b54:	f800283a 	ret

81143b58 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
81143b58:	defffb04 	addi	sp,sp,-20
81143b5c:	de00012e 	bgeu	sp,et,81143b64 <alt_find_file+0xc>
81143b60:	003b68fa 	trap	3
81143b64:	dfc00415 	stw	ra,16(sp)
81143b68:	df000315 	stw	fp,12(sp)
81143b6c:	df000304 	addi	fp,sp,12
81143b70:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
81143b74:	d0a00b17 	ldw	r2,-32724(gp)
81143b78:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
81143b7c:	00003106 	br	81143c44 <alt_find_file+0xec>
  {
    len = strlen(next->name);
81143b80:	e0bffd17 	ldw	r2,-12(fp)
81143b84:	10800217 	ldw	r2,8(r2)
81143b88:	1009883a 	mov	r4,r2
81143b8c:	111b1180 	call	8111b118 <strlen>
81143b90:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
81143b94:	e0bffd17 	ldw	r2,-12(fp)
81143b98:	10c00217 	ldw	r3,8(r2)
81143b9c:	e0bffe17 	ldw	r2,-8(fp)
81143ba0:	10bfffc4 	addi	r2,r2,-1
81143ba4:	1885883a 	add	r2,r3,r2
81143ba8:	10800003 	ldbu	r2,0(r2)
81143bac:	10803fcc 	andi	r2,r2,255
81143bb0:	1080201c 	xori	r2,r2,128
81143bb4:	10bfe004 	addi	r2,r2,-128
81143bb8:	10800bd8 	cmpnei	r2,r2,47
81143bbc:	1000031e 	bne	r2,zero,81143bcc <alt_find_file+0x74>
    {
      len -= 1;
81143bc0:	e0bffe17 	ldw	r2,-8(fp)
81143bc4:	10bfffc4 	addi	r2,r2,-1
81143bc8:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
81143bcc:	e0bffe17 	ldw	r2,-8(fp)
81143bd0:	e0ffff17 	ldw	r3,-4(fp)
81143bd4:	1885883a 	add	r2,r3,r2
81143bd8:	10800003 	ldbu	r2,0(r2)
81143bdc:	10803fcc 	andi	r2,r2,255
81143be0:	1080201c 	xori	r2,r2,128
81143be4:	10bfe004 	addi	r2,r2,-128
81143be8:	10800be0 	cmpeqi	r2,r2,47
81143bec:	1000081e 	bne	r2,zero,81143c10 <alt_find_file+0xb8>
81143bf0:	e0bffe17 	ldw	r2,-8(fp)
81143bf4:	e0ffff17 	ldw	r3,-4(fp)
81143bf8:	1885883a 	add	r2,r3,r2
81143bfc:	10800003 	ldbu	r2,0(r2)
81143c00:	10803fcc 	andi	r2,r2,255
81143c04:	1080201c 	xori	r2,r2,128
81143c08:	10bfe004 	addi	r2,r2,-128
81143c0c:	10000a1e 	bne	r2,zero,81143c38 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
81143c10:	e0bffd17 	ldw	r2,-12(fp)
81143c14:	10800217 	ldw	r2,8(r2)
81143c18:	e0fffe17 	ldw	r3,-8(fp)
81143c1c:	180d883a 	mov	r6,r3
81143c20:	e17fff17 	ldw	r5,-4(fp)
81143c24:	1009883a 	mov	r4,r2
81143c28:	1143e300 	call	81143e30 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
81143c2c:	1000021e 	bne	r2,zero,81143c38 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
81143c30:	e0bffd17 	ldw	r2,-12(fp)
81143c34:	00000706 	br	81143c54 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
81143c38:	e0bffd17 	ldw	r2,-12(fp)
81143c3c:	10800017 	ldw	r2,0(r2)
81143c40:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
81143c44:	e0fffd17 	ldw	r3,-12(fp)
81143c48:	d0a00b04 	addi	r2,gp,-32724
81143c4c:	18bfcc1e 	bne	r3,r2,81143b80 <__reset+0xfb123b80>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
81143c50:	0005883a 	mov	r2,zero
}
81143c54:	e037883a 	mov	sp,fp
81143c58:	dfc00117 	ldw	ra,4(sp)
81143c5c:	df000017 	ldw	fp,0(sp)
81143c60:	dec00204 	addi	sp,sp,8
81143c64:	f800283a 	ret

81143c68 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
81143c68:	defff904 	addi	sp,sp,-28
81143c6c:	de00012e 	bgeu	sp,et,81143c74 <alt_get_fd+0xc>
81143c70:	003b68fa 	trap	3
81143c74:	dfc00615 	stw	ra,24(sp)
81143c78:	df000515 	stw	fp,20(sp)
81143c7c:	df000504 	addi	fp,sp,20
81143c80:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
81143c84:	00bffa04 	movi	r2,-24
81143c88:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
81143c8c:	d0a07e17 	ldw	r2,-32264(gp)
81143c90:	e0bffd15 	stw	r2,-12(fp)
81143c94:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81143c98:	e0bffe0b 	ldhu	r2,-8(fp)
81143c9c:	e0fffe84 	addi	r3,fp,-6
81143ca0:	180d883a 	mov	r6,r3
81143ca4:	100b883a 	mov	r5,r2
81143ca8:	e13ffd17 	ldw	r4,-12(fp)
81143cac:	11375780 	call	81137578 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
81143cb0:	e03ffb15 	stw	zero,-20(fp)
81143cb4:	00001906 	br	81143d1c <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
81143cb8:	00a04534 	movhi	r2,33044
81143cbc:	1098f704 	addi	r2,r2,25564
81143cc0:	e0fffb17 	ldw	r3,-20(fp)
81143cc4:	18c00324 	muli	r3,r3,12
81143cc8:	10c5883a 	add	r2,r2,r3
81143ccc:	10800017 	ldw	r2,0(r2)
81143cd0:	10000f1e 	bne	r2,zero,81143d10 <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
81143cd4:	00a04534 	movhi	r2,33044
81143cd8:	1098f704 	addi	r2,r2,25564
81143cdc:	e0fffb17 	ldw	r3,-20(fp)
81143ce0:	18c00324 	muli	r3,r3,12
81143ce4:	10c5883a 	add	r2,r2,r3
81143ce8:	e0ffff17 	ldw	r3,-4(fp)
81143cec:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
81143cf0:	d0e00f17 	ldw	r3,-32708(gp)
81143cf4:	e0bffb17 	ldw	r2,-20(fp)
81143cf8:	1880020e 	bge	r3,r2,81143d04 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
81143cfc:	e0bffb17 	ldw	r2,-20(fp)
81143d00:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
81143d04:	e0bffb17 	ldw	r2,-20(fp)
81143d08:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
81143d0c:	00000606 	br	81143d28 <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
81143d10:	e0bffb17 	ldw	r2,-20(fp)
81143d14:	10800044 	addi	r2,r2,1
81143d18:	e0bffb15 	stw	r2,-20(fp)
81143d1c:	e0bffb17 	ldw	r2,-20(fp)
81143d20:	10800810 	cmplti	r2,r2,32
81143d24:	103fe41e 	bne	r2,zero,81143cb8 <__reset+0xfb123cb8>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
81143d28:	d0a07e17 	ldw	r2,-32264(gp)
81143d2c:	1009883a 	mov	r4,r2
81143d30:	11379000 	call	81137900 <OSSemPost>

  return rc;
81143d34:	e0bffc17 	ldw	r2,-16(fp)
}
81143d38:	e037883a 	mov	sp,fp
81143d3c:	dfc00117 	ldw	ra,4(sp)
81143d40:	df000017 	ldw	fp,0(sp)
81143d44:	dec00204 	addi	sp,sp,8
81143d48:	f800283a 	ret

81143d4c <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
81143d4c:	defffe04 	addi	sp,sp,-8
81143d50:	de00012e 	bgeu	sp,et,81143d58 <alt_exception_cause_generated_bad_addr+0xc>
81143d54:	003b68fa 	trap	3
81143d58:	df000115 	stw	fp,4(sp)
81143d5c:	df000104 	addi	fp,sp,4
81143d60:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
81143d64:	e0bfff17 	ldw	r2,-4(fp)
81143d68:	10bffe84 	addi	r2,r2,-6
81143d6c:	10c00428 	cmpgeui	r3,r2,16
81143d70:	18001a1e 	bne	r3,zero,81143ddc <alt_exception_cause_generated_bad_addr+0x90>
81143d74:	100690ba 	slli	r3,r2,2
81143d78:	00a04534 	movhi	r2,33044
81143d7c:	108f6304 	addi	r2,r2,15756
81143d80:	1885883a 	add	r2,r3,r2
81143d84:	10800017 	ldw	r2,0(r2)
81143d88:	1000683a 	jmp	r2
81143d8c:	81143dcc 	andi	r4,r16,20727
81143d90:	81143dcc 	andi	r4,r16,20727
81143d94:	81143ddc 	xori	r4,r16,20727
81143d98:	81143ddc 	xori	r4,r16,20727
81143d9c:	81143ddc 	xori	r4,r16,20727
81143da0:	81143dcc 	andi	r4,r16,20727
81143da4:	81143dd4 	ori	r4,r16,20727
81143da8:	81143ddc 	xori	r4,r16,20727
81143dac:	81143dcc 	andi	r4,r16,20727
81143db0:	81143dcc 	andi	r4,r16,20727
81143db4:	81143ddc 	xori	r4,r16,20727
81143db8:	81143dcc 	andi	r4,r16,20727
81143dbc:	81143dd4 	ori	r4,r16,20727
81143dc0:	81143ddc 	xori	r4,r16,20727
81143dc4:	81143ddc 	xori	r4,r16,20727
81143dc8:	81143dcc 	andi	r4,r16,20727
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
81143dcc:	00800044 	movi	r2,1
81143dd0:	00000306 	br	81143de0 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
81143dd4:	0005883a 	mov	r2,zero
81143dd8:	00000106 	br	81143de0 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
81143ddc:	0005883a 	mov	r2,zero
  }
}
81143de0:	e037883a 	mov	sp,fp
81143de4:	df000017 	ldw	fp,0(sp)
81143de8:	dec00104 	addi	sp,sp,4
81143dec:	f800283a 	ret

81143df0 <exit>:
81143df0:	defffe04 	addi	sp,sp,-8
81143df4:	000b883a 	mov	r5,zero
81143df8:	de00012e 	bgeu	sp,et,81143e00 <exit+0x10>
81143dfc:	003b68fa 	trap	3
81143e00:	dc000015 	stw	r16,0(sp)
81143e04:	dfc00115 	stw	ra,4(sp)
81143e08:	2021883a 	mov	r16,r4
81143e0c:	11441100 	call	81144110 <__call_exitprocs>
81143e10:	00a04534 	movhi	r2,33044
81143e14:	109e0e04 	addi	r2,r2,30776
81143e18:	11000017 	ldw	r4,0(r2)
81143e1c:	20800f17 	ldw	r2,60(r4)
81143e20:	10000126 	beq	r2,zero,81143e28 <exit+0x38>
81143e24:	103ee83a 	callr	r2
81143e28:	8009883a 	mov	r4,r16
81143e2c:	11442980 	call	81144298 <_exit>

81143e30 <memcmp>:
81143e30:	01c000c4 	movi	r7,3
81143e34:	3980192e 	bgeu	r7,r6,81143e9c <memcmp+0x6c>
81143e38:	2144b03a 	or	r2,r4,r5
81143e3c:	11c4703a 	and	r2,r2,r7
81143e40:	10000f26 	beq	r2,zero,81143e80 <memcmp+0x50>
81143e44:	20800003 	ldbu	r2,0(r4)
81143e48:	28c00003 	ldbu	r3,0(r5)
81143e4c:	10c0151e 	bne	r2,r3,81143ea4 <memcmp+0x74>
81143e50:	31bfff84 	addi	r6,r6,-2
81143e54:	01ffffc4 	movi	r7,-1
81143e58:	00000406 	br	81143e6c <memcmp+0x3c>
81143e5c:	20800003 	ldbu	r2,0(r4)
81143e60:	28c00003 	ldbu	r3,0(r5)
81143e64:	31bfffc4 	addi	r6,r6,-1
81143e68:	10c00e1e 	bne	r2,r3,81143ea4 <memcmp+0x74>
81143e6c:	21000044 	addi	r4,r4,1
81143e70:	29400044 	addi	r5,r5,1
81143e74:	31fff91e 	bne	r6,r7,81143e5c <__reset+0xfb123e5c>
81143e78:	0005883a 	mov	r2,zero
81143e7c:	f800283a 	ret
81143e80:	20c00017 	ldw	r3,0(r4)
81143e84:	28800017 	ldw	r2,0(r5)
81143e88:	18bfee1e 	bne	r3,r2,81143e44 <__reset+0xfb123e44>
81143e8c:	31bfff04 	addi	r6,r6,-4
81143e90:	21000104 	addi	r4,r4,4
81143e94:	29400104 	addi	r5,r5,4
81143e98:	39bff936 	bltu	r7,r6,81143e80 <__reset+0xfb123e80>
81143e9c:	303fe91e 	bne	r6,zero,81143e44 <__reset+0xfb123e44>
81143ea0:	003ff506 	br	81143e78 <__reset+0xfb123e78>
81143ea4:	10c5c83a 	sub	r2,r2,r3
81143ea8:	f800283a 	ret

81143eac <_putc_r>:
81143eac:	defffc04 	addi	sp,sp,-16
81143eb0:	de00012e 	bgeu	sp,et,81143eb8 <_putc_r+0xc>
81143eb4:	003b68fa 	trap	3
81143eb8:	dc000215 	stw	r16,8(sp)
81143ebc:	dfc00315 	stw	ra,12(sp)
81143ec0:	2021883a 	mov	r16,r4
81143ec4:	20000226 	beq	r4,zero,81143ed0 <_putc_r+0x24>
81143ec8:	20800e17 	ldw	r2,56(r4)
81143ecc:	10001b26 	beq	r2,zero,81143f3c <_putc_r+0x90>
81143ed0:	30800217 	ldw	r2,8(r6)
81143ed4:	10bfffc4 	addi	r2,r2,-1
81143ed8:	30800215 	stw	r2,8(r6)
81143edc:	10000a16 	blt	r2,zero,81143f08 <_putc_r+0x5c>
81143ee0:	30800017 	ldw	r2,0(r6)
81143ee4:	11400005 	stb	r5,0(r2)
81143ee8:	30800017 	ldw	r2,0(r6)
81143eec:	10c00044 	addi	r3,r2,1
81143ef0:	30c00015 	stw	r3,0(r6)
81143ef4:	10800003 	ldbu	r2,0(r2)
81143ef8:	dfc00317 	ldw	ra,12(sp)
81143efc:	dc000217 	ldw	r16,8(sp)
81143f00:	dec00404 	addi	sp,sp,16
81143f04:	f800283a 	ret
81143f08:	30c00617 	ldw	r3,24(r6)
81143f0c:	10c00616 	blt	r2,r3,81143f28 <_putc_r+0x7c>
81143f10:	30800017 	ldw	r2,0(r6)
81143f14:	00c00284 	movi	r3,10
81143f18:	11400005 	stb	r5,0(r2)
81143f1c:	30800017 	ldw	r2,0(r6)
81143f20:	11400003 	ldbu	r5,0(r2)
81143f24:	28fff11e 	bne	r5,r3,81143eec <__reset+0xfb123eec>
81143f28:	8009883a 	mov	r4,r16
81143f2c:	dfc00317 	ldw	ra,12(sp)
81143f30:	dc000217 	ldw	r16,8(sp)
81143f34:	dec00404 	addi	sp,sp,16
81143f38:	112c9cc1 	jmpi	8112c9cc <__swbuf_r>
81143f3c:	d9400015 	stw	r5,0(sp)
81143f40:	d9800115 	stw	r6,4(sp)
81143f44:	11234cc0 	call	811234cc <__sinit>
81143f48:	d9800117 	ldw	r6,4(sp)
81143f4c:	d9400017 	ldw	r5,0(sp)
81143f50:	003fdf06 	br	81143ed0 <__reset+0xfb123ed0>

81143f54 <putc>:
81143f54:	00a04534 	movhi	r2,33044
81143f58:	defffc04 	addi	sp,sp,-16
81143f5c:	109e0f04 	addi	r2,r2,30780
81143f60:	de00012e 	bgeu	sp,et,81143f68 <putc+0x14>
81143f64:	003b68fa 	trap	3
81143f68:	dc000115 	stw	r16,4(sp)
81143f6c:	14000017 	ldw	r16,0(r2)
81143f70:	dc400215 	stw	r17,8(sp)
81143f74:	dfc00315 	stw	ra,12(sp)
81143f78:	2023883a 	mov	r17,r4
81143f7c:	80000226 	beq	r16,zero,81143f88 <putc+0x34>
81143f80:	80800e17 	ldw	r2,56(r16)
81143f84:	10001a26 	beq	r2,zero,81143ff0 <putc+0x9c>
81143f88:	28800217 	ldw	r2,8(r5)
81143f8c:	10bfffc4 	addi	r2,r2,-1
81143f90:	28800215 	stw	r2,8(r5)
81143f94:	10000b16 	blt	r2,zero,81143fc4 <putc+0x70>
81143f98:	28800017 	ldw	r2,0(r5)
81143f9c:	14400005 	stb	r17,0(r2)
81143fa0:	28800017 	ldw	r2,0(r5)
81143fa4:	10c00044 	addi	r3,r2,1
81143fa8:	28c00015 	stw	r3,0(r5)
81143fac:	10800003 	ldbu	r2,0(r2)
81143fb0:	dfc00317 	ldw	ra,12(sp)
81143fb4:	dc400217 	ldw	r17,8(sp)
81143fb8:	dc000117 	ldw	r16,4(sp)
81143fbc:	dec00404 	addi	sp,sp,16
81143fc0:	f800283a 	ret
81143fc4:	28c00617 	ldw	r3,24(r5)
81143fc8:	10c00e16 	blt	r2,r3,81144004 <putc+0xb0>
81143fcc:	28800017 	ldw	r2,0(r5)
81143fd0:	01000284 	movi	r4,10
81143fd4:	14400005 	stb	r17,0(r2)
81143fd8:	28800017 	ldw	r2,0(r5)
81143fdc:	10c00003 	ldbu	r3,0(r2)
81143fe0:	193ff01e 	bne	r3,r4,81143fa4 <__reset+0xfb123fa4>
81143fe4:	280d883a 	mov	r6,r5
81143fe8:	180b883a 	mov	r5,r3
81143fec:	00000706 	br	8114400c <putc+0xb8>
81143ff0:	8009883a 	mov	r4,r16
81143ff4:	d9400015 	stw	r5,0(sp)
81143ff8:	11234cc0 	call	811234cc <__sinit>
81143ffc:	d9400017 	ldw	r5,0(sp)
81144000:	003fe106 	br	81143f88 <__reset+0xfb123f88>
81144004:	280d883a 	mov	r6,r5
81144008:	880b883a 	mov	r5,r17
8114400c:	8009883a 	mov	r4,r16
81144010:	dfc00317 	ldw	ra,12(sp)
81144014:	dc400217 	ldw	r17,8(sp)
81144018:	dc000117 	ldw	r16,4(sp)
8114401c:	dec00404 	addi	sp,sp,16
81144020:	112c9cc1 	jmpi	8112c9cc <__swbuf_r>

81144024 <strncpy>:
81144024:	2906b03a 	or	r3,r5,r4
81144028:	18c000cc 	andi	r3,r3,3
8114402c:	2005883a 	mov	r2,r4
81144030:	18002c1e 	bne	r3,zero,811440e4 <strncpy+0xc0>
81144034:	010000c4 	movi	r4,3
81144038:	21802a2e 	bgeu	r4,r6,811440e4 <strncpy+0xc0>
8114403c:	033fbff4 	movhi	r12,65279
81144040:	02e02074 	movhi	r11,32897
81144044:	633fbfc4 	addi	r12,r12,-257
81144048:	5ae02004 	addi	r11,r11,-32640
8114404c:	100f883a 	mov	r7,r2
81144050:	2a000017 	ldw	r8,0(r5)
81144054:	3815883a 	mov	r10,r7
81144058:	4313883a 	add	r9,r8,r12
8114405c:	0206303a 	nor	r3,zero,r8
81144060:	48c6703a 	and	r3,r9,r3
81144064:	1ac6703a 	and	r3,r3,r11
81144068:	1800261e 	bne	r3,zero,81144104 <strncpy+0xe0>
8114406c:	39c00104 	addi	r7,r7,4
81144070:	52000015 	stw	r8,0(r10)
81144074:	31bfff04 	addi	r6,r6,-4
81144078:	3811883a 	mov	r8,r7
8114407c:	29400104 	addi	r5,r5,4
81144080:	21bff336 	bltu	r4,r6,81144050 <__reset+0xfb124050>
81144084:	30001e26 	beq	r6,zero,81144100 <strncpy+0xdc>
81144088:	29c00003 	ldbu	r7,0(r5)
8114408c:	31bfffc4 	addi	r6,r6,-1
81144090:	40c00044 	addi	r3,r8,1
81144094:	41c00005 	stb	r7,0(r8)
81144098:	39c03fcc 	andi	r7,r7,255
8114409c:	39c0201c 	xori	r7,r7,128
811440a0:	39ffe004 	addi	r7,r7,-128
811440a4:	29400044 	addi	r5,r5,1
811440a8:	38001026 	beq	r7,zero,811440ec <strncpy+0xc8>
811440ac:	1811883a 	mov	r8,r3
811440b0:	00000906 	br	811440d8 <strncpy+0xb4>
811440b4:	29c00003 	ldbu	r7,0(r5)
811440b8:	31bfffc4 	addi	r6,r6,-1
811440bc:	29400044 	addi	r5,r5,1
811440c0:	41c00005 	stb	r7,0(r8)
811440c4:	39c03fcc 	andi	r7,r7,255
811440c8:	39c0201c 	xori	r7,r7,128
811440cc:	39ffe004 	addi	r7,r7,-128
811440d0:	1811883a 	mov	r8,r3
811440d4:	38000526 	beq	r7,zero,811440ec <strncpy+0xc8>
811440d8:	18c00044 	addi	r3,r3,1
811440dc:	303ff51e 	bne	r6,zero,811440b4 <__reset+0xfb1240b4>
811440e0:	f800283a 	ret
811440e4:	1011883a 	mov	r8,r2
811440e8:	003fe606 	br	81144084 <__reset+0xfb124084>
811440ec:	30000726 	beq	r6,zero,8114410c <strncpy+0xe8>
811440f0:	198d883a 	add	r6,r3,r6
811440f4:	18000005 	stb	zero,0(r3)
811440f8:	18c00044 	addi	r3,r3,1
811440fc:	19bffd1e 	bne	r3,r6,811440f4 <__reset+0xfb1240f4>
81144100:	f800283a 	ret
81144104:	3811883a 	mov	r8,r7
81144108:	003fdf06 	br	81144088 <__reset+0xfb124088>
8114410c:	f800283a 	ret

81144110 <__call_exitprocs>:
81144110:	defff504 	addi	sp,sp,-44
81144114:	de00012e 	bgeu	sp,et,8114411c <__call_exitprocs+0xc>
81144118:	003b68fa 	trap	3
8114411c:	df000915 	stw	fp,36(sp)
81144120:	dd400615 	stw	r21,24(sp)
81144124:	dc800315 	stw	r18,12(sp)
81144128:	dfc00a15 	stw	ra,40(sp)
8114412c:	ddc00815 	stw	r23,32(sp)
81144130:	dd800715 	stw	r22,28(sp)
81144134:	dd000515 	stw	r20,20(sp)
81144138:	dcc00415 	stw	r19,16(sp)
8114413c:	dc400215 	stw	r17,8(sp)
81144140:	dc000115 	stw	r16,4(sp)
81144144:	d9000015 	stw	r4,0(sp)
81144148:	2839883a 	mov	fp,r5
8114414c:	04800044 	movi	r18,1
81144150:	057fffc4 	movi	r21,-1
81144154:	00a04534 	movhi	r2,33044
81144158:	109e0e04 	addi	r2,r2,30776
8114415c:	12000017 	ldw	r8,0(r2)
81144160:	45005217 	ldw	r20,328(r8)
81144164:	44c05204 	addi	r19,r8,328
81144168:	a0001c26 	beq	r20,zero,811441dc <__call_exitprocs+0xcc>
8114416c:	a0800117 	ldw	r2,4(r20)
81144170:	15ffffc4 	addi	r23,r2,-1
81144174:	b8000d16 	blt	r23,zero,811441ac <__call_exitprocs+0x9c>
81144178:	14000044 	addi	r16,r2,1
8114417c:	8421883a 	add	r16,r16,r16
81144180:	8421883a 	add	r16,r16,r16
81144184:	84402004 	addi	r17,r16,128
81144188:	a463883a 	add	r17,r20,r17
8114418c:	a421883a 	add	r16,r20,r16
81144190:	e0001e26 	beq	fp,zero,8114420c <__call_exitprocs+0xfc>
81144194:	80804017 	ldw	r2,256(r16)
81144198:	e0801c26 	beq	fp,r2,8114420c <__call_exitprocs+0xfc>
8114419c:	bdffffc4 	addi	r23,r23,-1
811441a0:	843fff04 	addi	r16,r16,-4
811441a4:	8c7fff04 	addi	r17,r17,-4
811441a8:	bd7ff91e 	bne	r23,r21,81144190 <__reset+0xfb124190>
811441ac:	00800034 	movhi	r2,0
811441b0:	10800004 	addi	r2,r2,0
811441b4:	10000926 	beq	r2,zero,811441dc <__call_exitprocs+0xcc>
811441b8:	a0800117 	ldw	r2,4(r20)
811441bc:	1000301e 	bne	r2,zero,81144280 <__call_exitprocs+0x170>
811441c0:	a0800017 	ldw	r2,0(r20)
811441c4:	10003226 	beq	r2,zero,81144290 <__call_exitprocs+0x180>
811441c8:	a009883a 	mov	r4,r20
811441cc:	98800015 	stw	r2,0(r19)
811441d0:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
811441d4:	9d000017 	ldw	r20,0(r19)
811441d8:	a03fe41e 	bne	r20,zero,8114416c <__reset+0xfb12416c>
811441dc:	dfc00a17 	ldw	ra,40(sp)
811441e0:	df000917 	ldw	fp,36(sp)
811441e4:	ddc00817 	ldw	r23,32(sp)
811441e8:	dd800717 	ldw	r22,28(sp)
811441ec:	dd400617 	ldw	r21,24(sp)
811441f0:	dd000517 	ldw	r20,20(sp)
811441f4:	dcc00417 	ldw	r19,16(sp)
811441f8:	dc800317 	ldw	r18,12(sp)
811441fc:	dc400217 	ldw	r17,8(sp)
81144200:	dc000117 	ldw	r16,4(sp)
81144204:	dec00b04 	addi	sp,sp,44
81144208:	f800283a 	ret
8114420c:	a0800117 	ldw	r2,4(r20)
81144210:	80c00017 	ldw	r3,0(r16)
81144214:	10bfffc4 	addi	r2,r2,-1
81144218:	15c01426 	beq	r2,r23,8114426c <__call_exitprocs+0x15c>
8114421c:	80000015 	stw	zero,0(r16)
81144220:	183fde26 	beq	r3,zero,8114419c <__reset+0xfb12419c>
81144224:	95c8983a 	sll	r4,r18,r23
81144228:	a0806217 	ldw	r2,392(r20)
8114422c:	a5800117 	ldw	r22,4(r20)
81144230:	2084703a 	and	r2,r4,r2
81144234:	10000b26 	beq	r2,zero,81144264 <__call_exitprocs+0x154>
81144238:	a0806317 	ldw	r2,396(r20)
8114423c:	2088703a 	and	r4,r4,r2
81144240:	20000c1e 	bne	r4,zero,81144274 <__call_exitprocs+0x164>
81144244:	89400017 	ldw	r5,0(r17)
81144248:	d9000017 	ldw	r4,0(sp)
8114424c:	183ee83a 	callr	r3
81144250:	a0800117 	ldw	r2,4(r20)
81144254:	15bfbf1e 	bne	r2,r22,81144154 <__reset+0xfb124154>
81144258:	98800017 	ldw	r2,0(r19)
8114425c:	153fcf26 	beq	r2,r20,8114419c <__reset+0xfb12419c>
81144260:	003fbc06 	br	81144154 <__reset+0xfb124154>
81144264:	183ee83a 	callr	r3
81144268:	003ff906 	br	81144250 <__reset+0xfb124250>
8114426c:	a5c00115 	stw	r23,4(r20)
81144270:	003feb06 	br	81144220 <__reset+0xfb124220>
81144274:	89000017 	ldw	r4,0(r17)
81144278:	183ee83a 	callr	r3
8114427c:	003ff406 	br	81144250 <__reset+0xfb124250>
81144280:	a0800017 	ldw	r2,0(r20)
81144284:	a027883a 	mov	r19,r20
81144288:	1029883a 	mov	r20,r2
8114428c:	003fb606 	br	81144168 <__reset+0xfb124168>
81144290:	0005883a 	mov	r2,zero
81144294:	003ffb06 	br	81144284 <__reset+0xfb124284>

81144298 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
81144298:	defffc04 	addi	sp,sp,-16
8114429c:	de00012e 	bgeu	sp,et,811442a4 <_exit+0xc>
811442a0:	003b68fa 	trap	3
811442a4:	dfc00315 	stw	ra,12(sp)
811442a8:	df000215 	stw	fp,8(sp)
811442ac:	df000204 	addi	fp,sp,8
811442b0:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
811442b4:	d0a01217 	ldw	r2,-32696(gp)
811442b8:	10800058 	cmpnei	r2,r2,1
811442bc:	1000031e 	bne	r2,zero,811442cc <_exit+0x34>
811442c0:	01204534 	movhi	r4,33044
811442c4:	21169104 	addi	r4,r4,23108
811442c8:	112fc300 	call	8112fc30 <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
811442cc:	d0a01217 	ldw	r2,-32696(gp)
811442d0:	10800058 	cmpnei	r2,r2,1
811442d4:	1000041e 	bne	r2,zero,811442e8 <_exit+0x50>
811442d8:	e17fff17 	ldw	r5,-4(fp)
811442dc:	01204534 	movhi	r4,33044
811442e0:	21169c04 	addi	r4,r4,23152
811442e4:	112fc300 	call	8112fc30 <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
811442e8:	d0a01217 	ldw	r2,-32696(gp)
811442ec:	10800058 	cmpnei	r2,r2,1
811442f0:	1000031e 	bne	r2,zero,81144300 <_exit+0x68>
811442f4:	01204534 	movhi	r4,33044
811442f8:	2116a704 	addi	r4,r4,23196
811442fc:	112fc300 	call	8112fc30 <alt_log_printf_proc>
  ALT_OS_STOP();
81144300:	d0209005 	stb	zero,-32192(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
81144304:	d0a01217 	ldw	r2,-32696(gp)
81144308:	10800058 	cmpnei	r2,r2,1
8114430c:	1000031e 	bne	r2,zero,8114431c <_exit+0x84>
81144310:	01204534 	movhi	r4,33044
81144314:	2116b104 	addi	r4,r4,23236
81144318:	112fc300 	call	8112fc30 <alt_log_printf_proc>
8114431c:	e0bfff17 	ldw	r2,-4(fp)
81144320:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
81144324:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
81144328:	10000226 	beq	r2,zero,81144334 <_exit+0x9c>
    ALT_SIM_FAIL();
8114432c:	002af070 	cmpltui	zero,zero,43969
81144330:	00000106 	br	81144338 <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
81144334:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
81144338:	d0a01217 	ldw	r2,-32696(gp)
8114433c:	10800058 	cmpnei	r2,r2,1
81144340:	1000031e 	bne	r2,zero,81144350 <_exit+0xb8>
81144344:	01204534 	movhi	r4,33044
81144348:	2116bb04 	addi	r4,r4,23276
8114434c:	112fc300 	call	8112fc30 <alt_log_printf_proc>
  while (1);
81144350:	003fff06 	br	81144350 <__reset+0xfb124350>
